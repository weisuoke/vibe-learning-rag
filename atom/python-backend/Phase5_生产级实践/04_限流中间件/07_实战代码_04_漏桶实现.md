# 实战代码4：漏桶实现

> 手写漏桶算法的完整实现

---

## 基础实现

```python
"""漏桶限流器 - 基础实现"""
import time
from collections import deque

class LeakyBucket:
    def __init__(self, rate: float, capacity: int):
        self.rate = rate
        self.capacity = capacity
        self.queue = deque()
        self.last_time = time.time()

    def acquire(self) -> bool:
        now = time.time()
        elapsed = now - self.last_time

        processed = int(elapsed * self.rate)
        for _ in range(min(processed, len(self.queue))):
            self.queue.popleft()

        self.last_time = now

        if len(self.queue) < self.capacity:
            self.queue.append(now)
            return True
        return False
```

---

## Redis 实现

```python
"""漏桶限流器 - Redis 实现"""
import redis
import time

class RedisLeakyBucket:
    LUA_SCRIPT = """
    local key = KEYS[1]
    local rate = tonumber(ARGV[1])
    local capacity = tonumber(ARGV[2])
    local now = tonumber(ARGV[3])

    local last_time_key = key .. ':last_time'
    local last_time = tonumber(redis.call('GET', last_time_key)) or now

    local elapsed = now - last_time
    local processed = math.floor(elapsed * rate)

    if processed > 0 then
        for i = 1, processed do
            redis.call('LPOP', key)
        end
        redis.call('SET', last_time_key, now)
        redis.call('EXPIRE', last_time_key, 3600)
    end

    local queue_size = redis.call('LLEN', key)

    if queue_size < capacity then
        redis.call('RPUSH', key, now)
        redis.call('EXPIRE', key, 3600)
        return 1
    end
    return 0
    """

    def __init__(self, redis_client: redis.Redis, key: str, rate: float, capacity: int):
        self.redis = redis_client
        self.key = key
        self.rate = rate
        self.capacity = capacity
        self.script_sha = self.redis.script_load(self.LUA_SCRIPT)

    def acquire(self) -> bool:
        now = time.time()
        result = self.redis.evalsha(
            self.script_sha, 1, self.key,
            self.rate, self.capacity, now
        )
        return result == 1
```

---

## FastAPI 集成

```python
"""漏桶限流 - FastAPI 集成（保护数据库）"""
from fastapi import FastAPI, BackgroundTasks, HTTPException
import redis

app = FastAPI()
redis_client = redis.Redis()

db_limiter = RedisLeakyBucket(redis_client, "db:write", rate=10, capacity=100)

@app.post("/save")
async def save_data(data: dict, background_tasks: BackgroundTasks):
    if not db_limiter.acquire():
        raise HTTPException(status_code=429, detail="Too many writes")

    background_tasks.add_task(save_to_db, data)
    return {"status": "queued"}

async def save_to_db(data: dict):
    # 以固定速率写入数据库
    pass
```

---

**记住：** 漏桶用于流量整形，输出速率恒定，适合保护下游服务。
