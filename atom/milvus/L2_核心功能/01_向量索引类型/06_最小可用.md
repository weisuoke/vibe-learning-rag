# 最小可用知识

掌握以下内容，就能开始使用向量索引：

---

## 4.1 理解索引的作用

**为什么需要索引？**

在没有索引的情况下，Milvus 需要遍历所有向量计算距离（暴力检索），时间复杂度是 O(n*d)：
- n = 向量数量
- d = 向量维度

**举例：**
- 100万个 768 维向量
- 每次查询需要计算 100万 × 768 = 7.68亿次浮点运算
- 即使每秒10亿次运算，也需要 0.768 秒

**索引的作用：**
通过预先构建数据结构，将检索复杂度降低到 O(log n) 或更低。

```python
# 没有索引：遍历所有向量
for vector in all_vectors:  # O(n)
    distance = calculate_distance(query, vector)  # O(d)

# 有索引：只检索相关子集
relevant_vectors = index.search(query)  # O(log n) 或更快
for vector in relevant_vectors:  # 只检索少量向量
    distance = calculate_distance(query, vector)
```

---

## 4.2 掌握 FLAT 索引（最简单的基准）

**FLAT 是什么？**

FLAT 是最简单的索引类型，本质上就是"不使用索引"，直接暴力检索。

**为什么要学 FLAT？**
1. **基准对照**：其他索引的性能都是和 FLAT 对比
2. **小规模首选**：< 10万向量时，FLAT 可能比复杂索引更快
3. **100% 召回率**：精确检索，不会漏掉任何结果

**基本使用：**

```python
from pymilvus import Collection, connections

# 连接 Milvus
connections.connect("default", host="localhost", port="19530")

# 假设已有 Collection
collection = Collection("my_collection")

# 创建 FLAT 索引
index_params = {
    "index_type": "FLAT",
    "metric_type": "L2",  # 欧氏距离
    "params": {}  # FLAT 无需参数
}
collection.create_index(
    field_name="embedding",
    index_params=index_params
)

# 加载到内存
collection.load()

# 检索
results = collection.search(
    data=[[0.1, 0.2, ..., 0.768]],  # 查询向量
    anns_field="embedding",
    param={"metric_type": "L2"},
    limit=10  # 返回 top 10
)
```

**适用场景：**
- 个人知识库（< 1000 篇文档）
- 原型验证阶段
- 需要 100% 召回率的场景

---

## 4.3 学会创建索引的基本语法

**创建索引的三要素：**

1. **index_type**：索引类型（FLAT, IVF_FLAT, HNSW）
2. **metric_type**：距离度量（L2, IP, COSINE）
3. **params**：索引参数（不同索引类型参数不同）

**通用模板：**

```python
# 1. 定义索引参数
index_params = {
    "index_type": "索引类型",
    "metric_type": "距离度量",
    "params": {
        # 索引特定参数
    }
}

# 2. 创建索引
collection.create_index(
    field_name="embedding",  # 向量字段名
    index_params=index_params
)

# 3. 加载 Collection（必须！）
collection.load()

# 4. 检索
search_params = {
    "metric_type": "距离度量",
    "params": {
        # 搜索参数
    }
}
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param=search_params,
    limit=10
)
```

**重要提醒：**
- ⚠️ 创建索引后必须调用 `collection.load()` 才能检索
- ⚠️ 修改索引需要先 `drop_index()` 再重新创建
- ⚠️ 索引创建是异步的，大数据集可能需要等待

---

## 4.4 理解核心参数

### IVF_FLAT 参数

**nlist**（构建参数）：
- **含义**：将向量聚类成多少个桶
- **建议值**：`sqrt(n)` 到 `4*sqrt(n)`，其中 n 是向量数量
- **影响**：越大构建越慢，但检索可能更快

```python
# 100万向量
nlist = int(4 * (1000000 ** 0.5))  # ≈ 4000
```

**nprobe**（搜索参数）：
- **含义**：搜索时检查多少个桶
- **建议值**：从 8 开始，根据召回率调整
- **影响**：越大召回率越高，但速度越慢

```python
index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "L2",
    "params": {"nlist": 1024}  # 构建参数
}

search_params = {
    "metric_type": "L2",
    "params": {"nprobe": 16}  # 搜索参数
}
```

### HNSW 参数

**M**（构建参数）：
- **含义**：每层最大连接数
- **建议值**：4-64，常用 16
- **影响**：越大召回率越高，但内存占用越大

**efConstruction**（构建参数）：
- **含义**：构建时的搜索范围
- **建议值**：100-500，常用 200
- **影响**：越大索引质量越高，但构建越慢

**ef**（搜索参数）：
- **含义**：搜索时的候选集大小
- **建议值**：从 64 开始调整
- **影响**：越大召回率越高，但速度越慢

```python
index_params = {
    "index_type": "HNSW",
    "metric_type": "L2",
    "params": {
        "M": 16,
        "efConstruction": 200
    }
}

search_params = {
    "metric_type": "L2",
    "params": {"ef": 64}
}
```

---

## 4.5 根据数据规模选择索引类型

**决策树：**

```
你的向量数量是多少？

< 10万
  └─> 使用 FLAT
      - 无需参数调优
      - 100% 召回率
      - 实现最简单

10万 - 100万
  └─> 使用 IVF_FLAT
      - nlist = 4 * sqrt(n)
      - nprobe = 16（起始值）
      - 平衡精度和速度

> 100万
  └─> 使用 HNSW
      - M = 16
      - efConstruction = 200
      - ef = 64（起始值）
      - 高性能，但占内存
```

**快速参考表：**

| 向量数量 | 推荐索引 | 典型参数 | 召回率 | 查询延迟 |
|---------|---------|---------|--------|---------|
| < 1万 | FLAT | 无 | 100% | < 10ms |
| 1万-10万 | FLAT 或 IVF_FLAT | nlist=128, nprobe=8 | 100% / 95%+ | < 20ms |
| 10万-100万 | IVF_FLAT | nlist=1024, nprobe=16 | 95%+ | < 50ms |
| > 100万 | HNSW | M=16, ef=64 | 90%+ | < 10ms |

---

## 这些知识足以：

✅ **在小型项目中使用 FLAT 索引**
- 个人知识库
- 原型验证
- 精确检索场景

✅ **理解索引的基本概念**
- 为什么需要索引
- 索引如何加速检索
- 不同索引的适用场景

✅ **根据数据规模做初步选择**
- 小规模 → FLAT
- 中规模 → IVF_FLAT
- 大规模 → HNSW

✅ **为后续深入学习打基础**
- 理解核心参数的含义
- 知道如何创建和使用索引
- 了解性能权衡

---

## 实战练习

**练习1：创建 FLAT 索引**

```python
from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType
import numpy as np

# 1. 连接
connections.connect("default", host="localhost", port="19530")

# 2. 创建 Collection
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=128)
]
schema = CollectionSchema(fields, description="test collection")
collection = Collection("test_flat", schema)

# 3. 插入数据
vectors = np.random.rand(1000, 128).tolist()
collection.insert([vectors])

# 4. 创建 FLAT 索引
index_params = {
    "index_type": "FLAT",
    "metric_type": "L2",
    "params": {}
}
collection.create_index("embedding", index_params)

# 5. 加载并检索
collection.load()
query = np.random.rand(1, 128).tolist()
results = collection.search(
    data=query,
    anns_field="embedding",
    param={"metric_type": "L2"},
    limit=5
)

print(f"找到 {len(results[0])} 个结果")
for hit in results[0]:
    print(f"ID: {hit.id}, 距离: {hit.distance}")
```

**练习2：对比 FLAT 和 IVF_FLAT**

尝试将上面的代码改为 IVF_FLAT 索引，对比性能差异。

---

**下一步：** [07_双重类比.md](./07_双重类比.md) - 通过类比深入理解索引
