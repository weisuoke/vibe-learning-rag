# 核心概念2：生成器函数

> 理解 `yield` 关键字：Python 最优雅的惰性求值方式

---

## 什么是生成器函数？

**生成器函数**是包含 `yield` 关键字的函数，调用时不会立即执行，而是返回一个生成器对象。

**核心特征：**
1. 函数中包含 `yield` 关键字
2. 调用时返回生成器对象（不执行函数体）
3. 每次调用 `next()` 时执行到下一个 `yield`
4. `yield` 暂停函数执行并保存状态

---

## 一句话定义

**生成器函数是使用 `yield` 关键字的函数,调用时返回一个可以暂停和恢复执行的生成器对象,实现惰性求值和状态保存。**

---

## 生成器函数的基本语法

### 最简单的生成器函数

```python
def simple_generator():
    """最简单的生成器函数"""
    print("开始执行")
    yield 1
    print("继续执行")
    yield 2
    print("结束执行")
    yield 3

# 调用生成器函数（不执行函数体）
gen = simple_generator()
print(f"生成器对象: {gen}")  # <generator object simple_generator at 0x...>

# 第一次调用 next()
print(next(gen))  # 输出: 开始执行 \n 1

# 第二次调用 next()
print(next(gen))  # 输出: 继续执行 \n 2

# 第三次调用 next()
print(next(gen))  # 输出: 结束执行 \n 3

# 第四次调用 next()（生成器耗尽）
try:
    print(next(gen))
except StopIteration:
    print("生成器已耗尽")
```

**关键点：**
- 调用 `simple_generator()` 不执行函数体，只返回生成器对象
- 每次 `next()` 执行到下一个 `yield`
- `yield` 暂停执行并返回值
- 函数结束时自动抛出 `StopIteration`

---

## yield 的执行机制

### yield 的三个阶段

```python
def demo_yield():
    print("阶段1: yield 之前")
    x = yield "第一个值"  # 暂停点1
    print(f"阶段2: yield 之后, x={x}")
    y = yield "第二个值"  # 暂停点2
    print(f"阶段3: 最后, y={y}")

# 创建生成器
gen = demo_yield()

# 第一次 next(): 执行到第一个 yield
value1 = next(gen)
print(f"得到: {value1}\n")

# 第二次 next(): 从第一个 yield 后继续，执行到第二个 yield
value2 = next(gen)
print(f"得到: {value2}\n")

# 第三次 next(): 从第二个 yield 后继续，函数结束
try:
    next(gen)
except StopIteration:
    print("生成器结束")
```

**输出：**
```
阶段1: yield 之前
得到: 第一个值

阶段2: yield 之后, x=None
得到: 第二个值

阶段3: 最后, y=None
生成器结束
```

**执行流程：**
1. `next(gen)` → 执行到第一个 `yield` → 返回 "第一个值" → 暂停
2. `next(gen)` → 从第一个 `yield` 后继续 → 执行到第二个 `yield` → 返回 "第二个值" → 暂停
3. `next(gen)` → 从第二个 `yield` 后继续 → 函数结束 → 抛出 `StopIteration`

---

## 生成器 vs 普通函数

### 对比示例

```python
# 普通函数：一次性返回全部结果
def normal_function(n):
    """普通函数：一次性计算并返回"""
    result = []
    for i in range(n):
        result.append(i ** 2)
    return result  # 一次性返回

# 使用普通函数
numbers = normal_function(5)
print(numbers)  # [0, 1, 4, 9, 16]
print(numbers)  # [0, 1, 4, 9, 16]（可以多次访问）

# 生成器函数：按需生成每个结果
def generator_function(n):
    """生成器函数：按需生成"""
    for i in range(n):
        yield i ** 2  # 每次返回一个

# 使用生成器函数
gen = generator_function(5)
print(next(gen))  # 0
print(next(gen))  # 1
print(next(gen))  # 4
# 或者用 for 循环
for num in generator_function(5):
    print(num)  # 0, 1, 4, 9, 16
```

### 关键区别

| 特性 | 普通函数 | 生成器函数 |
|------|---------|-----------|
| **返回方式** | `return` 一次性返回 | `yield` 多次返回 |
| **执行时机** | 调用时立即执行 | 调用时返回生成器对象 |
| **状态保存** | 不保存状态 | 保存执行状态 |
| **内存占用** | 存储全部结果 | 按需生成，内存高效 |
| **可重复性** | 可多次使用结果 | 一次性，耗尽后不可重用 |
| **适用场景** | 小数据集 | 大数据集、流式处理 |

---

## 生成器的状态保存

### 局部变量的保存

```python
def counter_with_state():
    """生成器保存局部变量状态"""
    count = 0  # 局部变量
    while count < 5:
        count += 1
        yield count
        print(f"当前 count={count}")

# 使用
gen = counter_with_state()
print(next(gen))  # 1
print(next(gen))  # 2（count 的值被保存了）
print(next(gen))  # 3
```

**输出：**
```
1
当前 count=1
2
当前 count=2
3
```

**关键点：**
- `count` 变量的值在每次 `yield` 后被保存
- 下次调用 `next()` 时从保存的状态继续

### 复杂状态的保存

```python
def fibonacci_generator():
    """斐波那契数列生成器（保存两个状态变量）"""
    a, b = 0, 1  # 两个状态变量
    while True:
        yield a
        a, b = b, a + b  # 更新状态

# 使用
fib = fibonacci_generator()
for _ in range(10):
    print(next(fib))  # 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

**状态变化：**
```
初始: a=0, b=1
yield 0 → a=1, b=1
yield 1 → a=1, b=2
yield 1 → a=2, b=3
yield 2 → a=3, b=5
...
```

---

## yield 的高级用法

### 1. yield 表达式（接收值）

```python
def echo_generator():
    """生成器可以接收外部发送的值"""
    while True:
        received = yield  # yield 作为表达式，接收值
        print(f"收到: {received}")

# 使用
gen = echo_generator()
next(gen)  # 启动生成器（必须先调用一次 next）
gen.send("Hello")  # 发送值到生成器
gen.send("World")
```

**输出：**
```
收到: Hello
收到: World
```

### 2. yield from（委托生成器）

```python
def sub_generator():
    """子生成器"""
    yield 1
    yield 2

def main_generator():
    """主生成器：委托给子生成器"""
    yield "开始"
    yield from sub_generator()  # 委托给子生成器
    yield "结束"

# 使用
for value in main_generator():
    print(value)
```

**输出：**
```
开始
1
2
结束
```

**`yield from` 的作用：**
- 将迭代委托给另一个生成器
- 等价于 `for item in sub_generator(): yield item`
- 更简洁，性能更好

### 3. 生成器的 return 值

```python
def generator_with_return():
    """生成器可以有 return 值"""
    yield 1
    yield 2
    return "完成"  # return 值会成为 StopIteration 的参数

# 使用
gen = generator_with_return()
print(next(gen))  # 1
print(next(gen))  # 2

try:
    next(gen)
except StopIteration as e:
    print(f"生成器返回值: {e.value}")  # 完成
```

---

## 实际应用场景

### 场景1：大文件逐行处理

```python
def read_large_file(filename):
    """逐行读取大文件（内存高效）"""
    with open(filename, 'r', encoding='utf-8') as f:
        for line in f:
            # 处理每一行
            processed = line.strip().upper()
            yield processed

# 使用：处理 10GB 文件也不会内存爆炸
for line in read_large_file('large_file.log'):
    if 'ERROR' in line:
        print(line)
```

### 场景2：数据流过滤

```python
def filter_data(data_stream, condition):
    """过滤数据流"""
    for item in data_stream:
        if condition(item):
            yield item

# 使用
numbers = range(100)
even_numbers = filter_data(numbers, lambda x: x % 2 == 0)

for num in even_numbers:
    print(num)  # 0, 2, 4, 6, ...
```

### 场景3：数据转换管道

```python
def read_data(filename):
    """读取数据"""
    with open(filename) as f:
        for line in f:
            yield line.strip()

def parse_data(lines):
    """解析数据"""
    for line in lines:
        parts = line.split(',')
        yield {'name': parts[0], 'age': int(parts[1])}

def filter_adults(records):
    """过滤成年人"""
    for record in records:
        if record['age'] >= 18:
            yield record

# 使用：构建数据处理管道
pipeline = filter_adults(parse_data(read_data('data.csv')))

for record in pipeline:
    print(record)
```

**管道流程：**
```
read_data → parse_data → filter_adults → 输出
   ↓           ↓            ↓
  逐行读取    逐行解析     逐条过滤
```

### 场景4：无限序列生成

```python
def infinite_counter(start=0):
    """无限计数器"""
    n = start
    while True:
        yield n
        n += 1

# 使用：生成无限序列
counter = infinite_counter()
for _ in range(10):
    print(next(counter))  # 0, 1, 2, ..., 9

def primes():
    """无限素数生成器"""
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    n = 2
    while True:
        if is_prime(n):
            yield n
        n += 1

# 使用：生成前 10 个素数
prime_gen = primes()
for _ in range(10):
    print(next(prime_gen))  # 2, 3, 5, 7, 11, 13, 17, 19, 23, 29
```

### 场景5：批量数据处理

```python
def batch_generator(data, batch_size):
    """将数据分批返回"""
    batch = []
    for item in data:
        batch.append(item)
        if len(batch) >= batch_size:
            yield batch
            batch = []
    if batch:  # 返回最后一批（可能不满）
        yield batch

# 使用：批量处理大数据集
data = range(1000)
for batch in batch_generator(data, batch_size=100):
    print(f"处理批次: {len(batch)} 项")
    # 批量处理数据
    process_batch(batch)
```

---

## 在 AI Agent 开发中的应用

### 应用1：AI 流式响应

```python
from openai import OpenAI

def stream_ai_response(prompt: str):
    """流式返回 AI 响应"""
    client = OpenAI()

    # 调用 OpenAI API，启用流式响应
    stream = client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        stream=True  # 关键：启用流式
    )

    # 逐个 token 返回
    for chunk in stream:
        if chunk.choices[0].delta.content:
            yield chunk.choices[0].delta.content

# 在 FastAPI 中使用
from fastapi import FastAPI
from fastapi.responses import StreamingResponse

app = FastAPI()

@app.get("/chat")
async def chat(prompt: str):
    """AI 聊天端点（流式响应）"""
    return StreamingResponse(
        stream_ai_response(prompt),
        media_type="text/plain"
    )
```

### 应用2：数据库结果流式处理

```python
def fetch_users_stream(db_session, batch_size=1000):
    """流式获取用户数据（避免一次性加载全部）"""
    offset = 0
    while True:
        # 分批查询
        users = db_session.query(User)\
            .offset(offset)\
            .limit(batch_size)\
            .all()

        if not users:
            break

        # 逐个返回用户
        for user in users:
            yield user

        offset += batch_size

# 使用
for user in fetch_users_stream(db):
    process_user(user)  # 逐个处理，不占用大量内存
```

### 应用3：日志流式监控

```python
import time

def tail_log_file(filename):
    """实时监控日志文件（类似 tail -f）"""
    with open(filename, 'r') as f:
        # 移动到文件末尾
        f.seek(0, 2)

        while True:
            line = f.readline()
            if line:
                yield line.strip()
            else:
                time.sleep(0.1)  # 等待新内容

# 使用
for log_line in tail_log_file('app.log'):
    if 'ERROR' in log_line:
        send_alert(log_line)
```

---

## 生成器的性能优势

### 内存对比

```python
import sys

# 方式1：列表（一次性加载全部）
def get_squares_list(n):
    return [x ** 2 for x in range(n)]

# 方式2：生成器（按需生成）
def get_squares_generator(n):
    for x in range(n):
        yield x ** 2

# 内存占用对比
n = 1_000_000

squares_list = get_squares_list(n)
print(f"列表内存占用: {sys.getsizeof(squares_list) / 1024 / 1024:.2f} MB")

squares_gen = get_squares_generator(n)
print(f"生成器内存占用: {sys.getsizeof(squares_gen)} 字节")
```

**输出：**
```
列表内存占用: 8.00 MB
生成器内存占用: 128 字节
```

### 时间对比

```python
import time

# 场景：只需要前 10 个元素

# 方式1：列表（计算全部 100 万个）
start = time.time()
squares_list = [x ** 2 for x in range(1_000_000)]
first_10 = squares_list[:10]
print(f"列表方式耗时: {time.time() - start:.3f}s")

# 方式2：生成器（只计算前 10 个）
start = time.time()
squares_gen = (x ** 2 for x in range(1_000_000))
first_10 = [next(squares_gen) for _ in range(10)]
print(f"生成器方式耗时: {time.time() - start:.6f}s")
```

**输出：**
```
列表方式耗时: 0.123s
生成器方式耗时: 0.000002s
```

---

## 生成器的最佳实践

### 实践1：使用生成器表达式简化代码

```python
# ❌ 不推荐：手写生成器函数（简单场景）
def squares(n):
    for i in range(n):
        yield i ** 2

# ✅ 推荐：使用生成器表达式
squares = (i ** 2 for i in range(n))
```

### 实践2：使用 yield from 委托

```python
# ❌ 不推荐：手动循环 yield
def flatten(nested_list):
    for sublist in nested_list:
        for item in sublist:
            yield item

# ✅ 推荐：使用 yield from
def flatten(nested_list):
    for sublist in nested_list:
        yield from sublist
```

### 实践3：生成器函数命名

```python
# ✅ 推荐：使用动词或动词短语
def generate_numbers():
    ...

def read_lines(filename):
    ...

def stream_data():
    ...

# ❌ 不推荐：使用名词
def numbers():  # 不清楚是返回列表还是生成器
    ...
```

### 实践4：文档字符串说明

```python
def process_large_file(filename):
    """
    逐行处理大文件

    Args:
        filename: 文件路径

    Yields:
        str: 处理后的每一行

    Note:
        这是一个生成器函数，按需读取文件，内存高效
    """
    with open(filename) as f:
        for line in f:
            yield line.strip().upper()
```

---

## 常见陷阱

### 陷阱1：生成器只能遍历一次

```python
# ❌ 错误：尝试多次遍历同一个生成器
gen = (x for x in range(5))
list1 = list(gen)  # [0, 1, 2, 3, 4]
list2 = list(gen)  # []（生成器已耗尽）

# ✅ 正确：每次重新创建生成器
def create_gen():
    return (x for x in range(5))

list1 = list(create_gen())
list2 = list(create_gen())
```

### 陷阱2：生成器中的循环变量

```python
# ❌ 错误：循环变量被共享
def bad_generator():
    funcs = []
    for i in range(3):
        funcs.append(lambda: i)  # 闭包陷阱
    for func in funcs:
        yield func()

list(bad_generator())  # [2, 2, 2]（都是最后的值）

# ✅ 正确：直接 yield
def good_generator():
    for i in range(3):
        yield i

list(good_generator())  # [0, 1, 2]
```

### 陷阱3：生成器中的异常处理

```python
# ❌ 错误：异常未处理，生成器中断
def bad_generator():
    for i in range(10):
        yield 1 / i  # i=0 时会抛出异常

# 使用：第一次就会报错
gen = bad_generator()
next(gen)  # ZeroDivisionError

# ✅ 正确：处理异常
def good_generator():
    for i in range(10):
        try:
            yield 1 / i
        except ZeroDivisionError:
            yield float('inf')

# 使用：正常工作
gen = good_generator()
print(next(gen))  # inf
print(next(gen))  # 1.0
```

---

## 生成器 vs 迭代器类

### 何时使用生成器函数？

```python
# ✅ 适合用生成器函数的场景
# 1. 简单的迭代逻辑
def simple_range(n):
    for i in range(n):
        yield i

# 2. 数据转换
def transform_data(data):
    for item in data:
        yield process(item)

# 3. 流式处理
def stream_file(filename):
    with open(filename) as f:
        for line in f:
            yield line.strip()
```

### 何时使用迭代器类？

```python
# ✅ 适合用迭代器类的场景
# 1. 复杂的状态管理
class ComplexIterator:
    def __init__(self):
        self.state1 = ...
        self.state2 = ...
        self.state3 = ...

    def __iter__(self):
        return self

    def __next__(self):
        # 复杂的状态更新逻辑
        ...

# 2. 需要多个方法
class DataIterator:
    def __iter__(self):
        return self

    def __next__(self):
        ...

    def reset(self):
        """重置迭代器"""
        ...

    def skip(self, n):
        """跳过 n 个元素"""
        ...
```

---

## 总结

### 核心要点

1. **生成器函数 = 包含 `yield` 的函数**
2. **调用生成器函数返回生成器对象，不执行函数体**
3. **`yield` 暂停执行并保存状态**
4. **每次 `next()` 从上次暂停的地方继续**
5. **函数结束时自动抛出 `StopIteration`**
6. **生成器是一次性的，耗尽后不可重用**

### 最佳实践

- ✅ 简单场景用生成器表达式
- ✅ 复杂逻辑用生成器函数
- ✅ 使用 `yield from` 委托子生成器
- ✅ 文档字符串说明是生成器
- ✅ 处理可能的异常
- ❌ 不要假设生成器可以多次遍历
- ❌ 不要在生成器中使用闭包陷阱

### 使用场景

- ✅ 大文件处理
- ✅ 流式数据处理
- ✅ 无限序列
- ✅ 数据管道
- ✅ AI 流式响应
- ✅ 批量数据处理

---

**版本：** v1.0
**最后更新：** 2026-02-11
