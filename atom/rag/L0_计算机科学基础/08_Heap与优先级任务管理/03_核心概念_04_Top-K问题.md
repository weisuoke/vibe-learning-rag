# 核心概念04: Top-K问题

## 核心目标

**深入理解Top-K问题的定义、解法对比、heap解法的优势,以及在RAG系统中的应用。**

---

## 1. Top-K问题定义

### 1.1 问题描述

**输入:** 包含n个元素的数组
**输出:** 数组中最大(或最小)的K个元素
**约束:** K ≤ n

**变种:**
- Top-K最大值
- Top-K最小值
- 第K大元素
- Top-K频繁元素

### 1.2 实际应用

**RAG系统:**
- 从100万文档中检索Top-10最相似文档
- 从1000个chunk中选择Top-5最相关片段

**推荐系统:**
- 推荐Top-10商品
- 展示Top-20热门视频

**搜索引擎:**
- 返回Top-10搜索结果
- 展示Top-5自动补全建议

**数据分析:**
- 找出Top-100销量商品
- 统计Top-50高频词

---

## 2. 解法对比

### 2.1 方法1: 排序

```python
def top_k_sort(nums, k):
    """
    排序后取前K个

    时间复杂度: O(n log n)
    空间复杂度: O(1) 或 O(n) (取决于排序算法)
    """
    nums.sort(reverse=True)
    return nums[:k]
```

**优点:**
- 实现简单
- 适合小数据集
- 如果需要全排序,这是唯一选择

**缺点:**
- 当K << n时过度计算
- 时间复杂度O(n log n)较高

**适用场景:**
- K接近n
- 需要全排序
- 数据量小(<10000)

### 2.2 方法2: Min-heap (推荐)

```python
import heapq

def top_k_heap(nums, k):
    """
    使用min-heap维护Top-K

    时间复杂度: O(n log k)
    空间复杂度: O(k)
    """
    heap = []

    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)

    return sorted(heap, reverse=True)
```

**优点:**
- 时间复杂度O(n log k),当K << n时优于排序
- 空间复杂度O(k),内存效率高
- 支持流式处理(数据逐个到达)

**缺点:**
- K较大时性能下降
- 需要额外的heap数据结构

**适用场景:**
- K << n (如K=10, n=1000000)
- 流式数据处理
- 内存受限

### 2.3 方法3: Quickselect

```python
import random

def quickselect(nums, k):
    """
    基于快排的选择算法

    时间复杂度: O(n) 平均, O(n²) 最坏
    空间复杂度: O(1)
    """
    def partition(left, right, pivot_idx):
        pivot = nums[pivot_idx]
        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]

        store_idx = left
        for i in range(left, right):
            if nums[i] > pivot:
                nums[i], nums[store_idx] = nums[store_idx], nums[i]
                store_idx += 1

        nums[store_idx], nums[right] = nums[right], nums[store_idx]
        return store_idx

    left, right = 0, len(nums) - 1
    while True:
        pivot_idx = random.randint(left, right)
        pivot_idx = partition(left, right, pivot_idx)

        if pivot_idx == k - 1:
            return nums[:k]
        elif pivot_idx < k - 1:
            left = pivot_idx + 1
        else:
            right = pivot_idx - 1
```

**优点:**
- 平均时间复杂度O(n)
- 原地算法,空间O(1)

**缺点:**
- 最坏情况O(n²)
- 不支持流式处理
- 会修改原数组

**适用场景:**
- 一次性查询
- 内存极度受限
- 不需要保持原数组

### 2.4 方法4: 计数排序(特殊场景)

```python
def top_k_counting(nums, k, max_val):
    """
    计数排序(仅适用于整数且范围小)

    时间复杂度: O(n + m), m是值域范围
    空间复杂度: O(m)
    """
    count = [0] * (max_val + 1)

    for num in nums:
        count[num] += 1

    result = []
    for val in range(max_val, -1, -1):
        for _ in range(count[val]):
            if len(result) >= k:
                return result
            result.append(val)

    return result
```

**优点:**
- 时间复杂度O(n + m)
- 稳定排序

**缺点:**
- 仅适用于整数
- 值域范围大时空间开销大

**适用场景:**
- 整数数组
- 值域范围小(如0-1000)

---

## 3. 性能对比

### 3.1 时间复杂度对比

| 方法 | 时间复杂度 | 最坏情况 | 适用K值 |
|------|------------|----------|---------|
| 排序 | O(n log n) | O(n log n) | K ≈ n |
| Min-heap | O(n log k) | O(n log k) | K << n ✅ |
| Quickselect | O(n) 平均 | O(n²) | 任意K |
| 计数排序 | O(n + m) | O(n + m) | 整数,小值域 |

### 3.2 空间复杂度对比

| 方法 | 空间复杂度 | 说明 |
|------|------------|------|
| 排序 | O(1) 或 O(n) | 取决于排序算法 |
| Min-heap | O(k) ✅ | 只存K个元素 |
| Quickselect | O(1) | 原地算法 |
| 计数排序 | O(m) | m是值域范围 |

### 3.3 实测性能

```python
import heapq
import time
import random

def benchmark_top_k(n, k):
    """性能对比测试"""
    nums = [random.randint(1, 1000000) for _ in range(n)]

    # 方法1: 排序
    start = time.time()
    result1 = sorted(nums, reverse=True)[:k]
    time_sort = time.time() - start

    # 方法2: Min-heap
    start = time.time()
    result2 = heapq.nlargest(k, nums)
    time_heap = time.time() - start

    print(f"n={n}, k={k}:")
    print(f"  排序:    {time_sort:.4f}s")
    print(f"  Min-heap: {time_heap:.4f}s")
    print(f"  加速比:  {time_sort/time_heap:.2f}x")

# 测试
benchmark_top_k(n=1000000, k=10)
benchmark_top_k(n=1000000, k=1000)
benchmark_top_k(n=1000000, k=100000)

# 输出示例:
# n=1000000, k=10:
#   排序:    0.2134s
#   Min-heap: 0.0342s
#   加速比:  6.24x
#
# n=1000000, k=1000:
#   排序:    0.2156s
#   Min-heap: 0.0891s
#   加速比:  2.42x
#
# n=1000000, k=100000:
#   排序:    0.2178s
#   Min-heap: 0.1823s
#   加速比:  1.19x
```

**结论:**
- K << n时,heap优势明显(6倍加速)
- K ≈ n时,排序更优
- 临界点约在K = n/10

---

## 4. Heap解法详解

### 4.1 为什么用Min-heap找最大值?

**反直觉但正确的选择!**

```
关键洞察: heap[0]是"入场门槛"

Min-heap维护Top-K最大值:
1. heap[0]是当前K个元素中的最小值
2. 新元素如果 > heap[0],说明它比当前最小的还大,应该替换
3. 新元素如果 <= heap[0],说明它不够大,丢弃

类比:选秀节目晋级
- 晋级名单有10个位置(K=10)
- 第10名是"门槛"(heap[0])
- 新选手分数 > 第10名,淘汰第10名,新选手晋级
- 新选手分数 <= 第10名,新选手淘汰
```

### 4.2 完整实现

```python
import heapq

def top_k_largest(nums, k):
    """
    找出Top-K最大值

    Args:
        nums: 输入数组
        k: 返回元素个数

    Returns:
        Top-K最大值列表(降序)

    时间复杂度: O(n log k)
    空间复杂度: O(k)
    """
    if k <= 0:
        return []
    if k >= len(nums):
        return sorted(nums, reverse=True)

    heap = []

    for num in nums:
        if len(heap) < k:
            # heap未满,直接插入
            heapq.heappush(heap, num)
        elif num > heap[0]:
            # 新元素比堆顶大,替换堆顶
            heapq.heapreplace(heap, num)
        # else: 新元素不够大,丢弃

    # 返回结果(降序)
    return sorted(heap, reverse=True)

# 测试
nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]
print(top_k_largest(nums, 3))  # [9, 6, 5]
```

### 4.3 优化技巧

**优化1: 使用heapreplace而非pop+push**

```python
# ❌ 慢: pop + push (两次heapify)
if num > heap[0]:
    heapq.heappop(heap)
    heapq.heappush(heap, num)

# ✅ 快: replace (一次heapify)
if num > heap[0]:
    heapq.heapreplace(heap, num)
```

**优化2: 批量初始化**

```python
def top_k_optimized(nums, k):
    """优化版:批量初始化heap"""
    if k >= len(nums):
        return sorted(nums, reverse=True)

    # 前K个元素直接建堆 O(k)
    heap = nums[:k]
    heapq.heapify(heap)

    # 处理剩余元素 O((n-k) log k)
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heapreplace(heap, num)

    return sorted(heap, reverse=True)
```

**优化3: 避免最后排序**

```python
def top_k_no_sort(nums, k):
    """
    如果不需要排序,直接返回heap

    节省O(k log k)排序时间
    """
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)

    return heap  # 不排序,直接返回
```

---

## 5. Python标准库实现

### 5.1 heapq.nlargest

```python
import heapq

# 最简单的方式
top_k = heapq.nlargest(k, nums)

# 等价于
def nlargest(k, iterable):
    """heapq.nlargest的简化实现"""
    it = iter(iterable)
    result = list(itertools.islice(it, k))
    if not result:
        return result

    heapq.heapify(result)

    for elem in it:
        if elem > result[0]:
            heapq.heapreplace(result, elem)

    result.sort(reverse=True)
    return result
```

### 5.2 heapq.nsmallest

```python
import heapq

# Top-K最小值
top_k = heapq.nsmallest(k, nums)

# 使用max-heap实现(Python 3.14+)
def nsmallest_max_heap(k, nums):
    """使用max-heap找Top-K最小值"""
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush_max(heap, num)
        elif num < heap[0]:
            heapq.heapreplace_max(heap, num)

    return sorted(heap)
```

### 5.3 带key参数

```python
import heapq

# 按对象属性排序
students = [
    {"name": "Alice", "score": 85},
    {"name": "Bob", "score": 92},
    {"name": "Charlie", "score": 78},
]

# 找出分数最高的2个学生
top_2 = heapq.nlargest(2, students, key=lambda x: x["score"])
print(top_2)
# [{'name': 'Bob', 'score': 92}, {'name': 'Alice', 'score': 85}]
```

---

## 6. RAG应用场景

### 6.1 文档检索

```python
import heapq
import numpy as np

class RAGRetriever:
    """
    RAG Top-K文档检索器

    使用min-heap维护Top-K最相似文档
    """

    def __init__(self, k=10):
        self.k = k

    def retrieve(self, query_emb, doc_embs):
        """
        检索Top-K文档

        Args:
            query_emb: 查询向量 (d,)
            doc_embs: [(doc_id, embedding), ...]

        Returns:
            Top-K文档列表 [(score, doc_id), ...]
        """
        heap = []

        for doc_id, doc_emb in doc_embs:
            # 计算相似度
            score = self.cosine_similarity(query_emb, doc_emb)

            if len(heap) < self.k:
                heapq.heappush(heap, (score, doc_id))
            elif score > heap[0][0]:
                heapq.heapreplace(heap, (score, doc_id))

        # 返回Top-K(降序)
        return sorted(heap, reverse=True)

    @staticmethod
    def cosine_similarity(a, b):
        """计算余弦相似度"""
        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

# 使用示例
retriever = RAGRetriever(k=10)

# 模拟100万文档
query_emb = np.random.rand(768)
doc_embs = [
    (f"doc_{i}", np.random.rand(768))
    for i in range(1000000)
]

# 检索Top-10
top_docs = retriever.retrieve(query_emb, doc_embs)
print(f"Top-10 documents: {top_docs[:3]}")
```

### 6.2 混合检索

```python
import heapq

class HybridRetriever:
    """
    混合检索:BM25 + 向量检索

    使用heap合并多个检索结果
    """

    def __init__(self, k=10):
        self.k = k

    def retrieve(self, query, bm25_results, vector_results, alpha=0.5):
        """
        混合检索

        Args:
            query: 查询文本
            bm25_results: [(doc_id, bm25_score), ...]
            vector_results: [(doc_id, vector_score), ...]
            alpha: BM25权重(1-alpha为向量权重)

        Returns:
            Top-K文档列表
        """
        # 合并分数
        doc_scores = {}

        for doc_id, score in bm25_results:
            doc_scores[doc_id] = alpha * score

        for doc_id, score in vector_results:
            if doc_id in doc_scores:
                doc_scores[doc_id] += (1 - alpha) * score
            else:
                doc_scores[doc_id] = (1 - alpha) * score

        # 使用heap找Top-K
        heap = []
        for doc_id, score in doc_scores.items():
            if len(heap) < self.k:
                heapq.heappush(heap, (score, doc_id))
            elif score > heap[0][0]:
                heapq.heapreplace(heap, (score, doc_id))

        return sorted(heap, reverse=True)
```

### 6.3 流式Top-K

```python
import heapq

class StreamingTopK:
    """
    流式Top-K维护

    适用场景:文档逐个到达,实时维护Top-K
    """

    def __init__(self, k):
        self.k = k
        self.heap = []

    def add(self, doc_id, score):
        """
        添加新文档

        时间复杂度: O(log k)
        """
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, (score, doc_id))
        elif score > self.heap[0][0]:
            heapq.heapreplace(self.heap, (score, doc_id))

    def get_top_k(self):
        """
        获取当前Top-K

        时间复杂度: O(k log k)
        """
        return sorted(self.heap, reverse=True)

    def get_threshold(self):
        """
        获取当前门槛分数

        时间复杂度: O(1)
        """
        return self.heap[0][0] if len(self.heap) == self.k else float('-inf')

# 使用示例
stream = StreamingTopK(k=10)

# 文档逐个到达
for i in range(1000):
    doc_id = f"doc_{i}"
    score = random.random()
    stream.add(doc_id, score)

    # 实时查看Top-10
    if i % 100 == 0:
        print(f"After {i} documents:")
        print(f"  Threshold: {stream.get_threshold():.4f}")
        print(f"  Top-3: {stream.get_top_k()[:3]}")
```

---

## 7. 变种问题

### 7.1 第K大元素

```python
import heapq

def find_kth_largest(nums, k):
    """
    找出第K大元素

    方法1: Min-heap
    时间复杂度: O(n log k)
    """
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)

    return heap[0]  # 堆顶就是第K大

# 测试
nums = [3, 2, 1, 5, 6, 4]
print(find_kth_largest(nums, 2))  # 5
```

### 7.2 Top-K频繁元素

```python
import heapq
from collections import Counter

def top_k_frequent(nums, k):
    """
    找出出现频率最高的K个元素

    时间复杂度: O(n log k)
    """
    # 统计频率
    count = Counter(nums)

    # 使用min-heap维护Top-K
    heap = []
    for num, freq in count.items():
        if len(heap) < k:
            heapq.heappush(heap, (freq, num))
        elif freq > heap[0][0]:
            heapq.heapreplace(heap, (freq, num))

    return [num for freq, num in sorted(heap, reverse=True)]

# 测试
nums = [1, 1, 1, 2, 2, 3]
print(top_k_frequent(nums, 2))  # [1, 2]
```

### 7.3 Top-K最接近的元素

```python
import heapq

def find_closest_elements(arr, k, x):
    """
    找出最接近x的K个元素

    时间复杂度: O(n log k)
    """
    # 使用max-heap(存储距离的负值)
    heap = []

    for num in arr:
        dist = abs(num - x)

        if len(heap) < k:
            heapq.heappush(heap, (-dist, num))
        elif dist < -heap[0][0]:
            heapq.heapreplace(heap, (-dist, num))

    # 返回结果(升序)
    return sorted([num for dist, num in heap])

# 测试
arr = [1, 2, 3, 4, 5]
print(find_closest_elements(arr, 4, 3))  # [1, 2, 3, 4]
```

---

## 8. 常见陷阱

### 陷阱1: 混淆min-heap和max-heap

```python
# ❌ 错误:用max-heap找最大值
heap = []
for num in nums:
    heapq.heappush(heap, -num)  # 负值模拟max-heap
# 问题:需要O(n)空间,而非O(k)

# ✅ 正确:用min-heap找最大值
heap = []
for num in nums:
    if len(heap) < k:
        heapq.heappush(heap, num)
    elif num > heap[0]:
        heapq.heapreplace(heap, num)
```

### 陷阱2: 忘记检查K的边界

```python
# ❌ 错误:没有检查K
def top_k_wrong(nums, k):
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)
    return heap

# 问题:K=0或K>n时出错

# ✅ 正确:检查边界
def top_k_correct(nums, k):
    if k <= 0:
        return []
    if k >= len(nums):
        return sorted(nums, reverse=True)

    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)

    return sorted(heap, reverse=True)
```

### 陷阱3: 过度优化

```python
# ❌ 错误:K很大时仍用heap
def top_k_wrong(nums, k):
    # K=999999, n=1000000
    # heap方法: O(n log k) ≈ O(n * 20)
    # 排序方法: O(n log n) ≈ O(n * 20)
    # 两者相当,但排序更简单
    pass

# ✅ 正确:根据K选择方法
def top_k_correct(nums, k):
    if k > len(nums) // 2:
        # K较大,用排序
        return sorted(nums, reverse=True)[:k]
    else:
        # K较小,用heap
        return heapq.nlargest(k, nums)
```

---

## 9. 一句话总结

**Top-K问题有排序O(n log n)、heap O(n log k)、quickselect O(n)三种主流解法,当K << n时heap最优(时间O(n log k)、空间O(k)),核心是用min-heap维护Top-K最大值(heap[0]是入场门槛),广泛应用于RAG文档检索、推荐系统和搜索引擎。**
