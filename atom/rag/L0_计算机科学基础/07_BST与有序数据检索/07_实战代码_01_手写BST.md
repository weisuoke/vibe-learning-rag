# 07_实战代码_01_手写BST

## 场景描述

**目标：** 从零实现一个完整的BST，包含所有核心操作和辅助功能

**应用场景：**
- 理解BST的底层原理
- 面试手写代码
- 自定义数据结构需求

---

## 完整实现

```python
"""
手写BST完整实现
包含：查找、插入、删除、遍历、范围查询等核心操作
"""

from typing import Optional, List, Any
from dataclasses import dataclass


@dataclass
class TreeNode:
    """BST节点"""
    val: int
    left: Optional['TreeNode'] = None
    right: Optional['TreeNode'] = None
    data: Any = None  # 可选的附加数据

    def __repr__(self):
        return f"TreeNode({self.val})"


class BST:
    """二叉搜索树实现"""

    def __init__(self):
        self.root: Optional[TreeNode] = None
        self.size = 0

    # ==================== 核心操作 ====================

    def insert(self, val: int, data: Any = None) -> None:
        """
        插入值
        时间复杂度：O(log n) 平衡时，O(n) 最坏
        """
        self.root = self._insert(self.root, val, data)
        self.size += 1

    def _insert(self, root: Optional[TreeNode], val: int, data: Any) -> TreeNode:
        """递归插入"""
        if not root:
            return TreeNode(val, data=data)

        if val < root.val:
            root.left = self._insert(root.left, val, data)
        elif val > root.val:
            root.right = self._insert(root.right, val, data)
        else:
            # 重复值：更新数据
            root.data = data

        return root

    def search(self, val: int) -> Optional[TreeNode]:
        """
        查找值
        时间复杂度：O(log n) 平衡时，O(n) 最坏
        """
        return self._search(self.root, val)

    def _search(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        """递归查找"""
        if not root or root.val == val:
            return root

        if val < root.val:
            return self._search(root.left, val)
        return self._search(root.right, val)

    def delete(self, val: int) -> bool:
        """
        删除值
        时间复杂度：O(log n) 平衡时，O(n) 最坏
        返回：是否成功删除
        """
        if not self.search(val):
            return False

        self.root = self._delete(self.root, val)
        self.size -= 1
        return True

    def _delete(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        """递归删除"""
        if not root:
            return None

        if val < root.val:
            root.left = self._delete(root.left, val)
        elif val > root.val:
            root.right = self._delete(root.right, val)
        else:
            # 找到要删除的节点

            # 情况1：叶子节点或单子节点
            if not root.left:
                return root.right
            if not root.right:
                return root.left

            # 情况2：双子节点
            # 找到后继节点（右子树最小值）
            successor = self._find_min(root.right)
            root.val = successor.val
            root.data = successor.data
            root.right = self._delete(root.right, successor.val)

        return root

    # ==================== 辅助操作 ====================

    def find_min(self) -> Optional[TreeNode]:
        """找到最小值节点"""
        if not self.root:
            return None
        return self._find_min(self.root)

    def _find_min(self, root: TreeNode) -> TreeNode:
        """递归找最小值"""
        while root.left:
            root = root.left
        return root

    def find_max(self) -> Optional[TreeNode]:
        """找到最大值节点"""
        if not self.root:
            return None
        return self._find_max(self.root)

    def _find_max(self, root: TreeNode) -> TreeNode:
        """递归找最大值"""
        while root.right:
            root = root.right
        return root

    def height(self) -> int:
        """计算树高"""
        return self._height(self.root)

    def _height(self, root: Optional[TreeNode]) -> int:
        """递归计算高度"""
        if not root:
            return 0
        return max(self._height(root.left), self._height(root.right)) + 1

    def is_balanced(self) -> bool:
        """检查是否平衡（AVL定义）"""
        def check_height(node: Optional[TreeNode]) -> int:
            if not node:
                return 0

            left_height = check_height(node.left)
            if left_height == -1:
                return -1

            right_height = check_height(node.right)
            if right_height == -1:
                return -1

            if abs(left_height - right_height) > 1:
                return -1

            return max(left_height, right_height) + 1

        return check_height(self.root) != -1

    # ==================== 遍历操作 ====================

    def inorder(self) -> List[int]:
        """中序遍历（有序）"""
        result = []
        self._inorder(self.root, result)
        return result

    def _inorder(self, root: Optional[TreeNode], result: List[int]) -> None:
        """递归中序遍历"""
        if root:
            self._inorder(root.left, result)
            result.append(root.val)
            self._inorder(root.right, result)

    def preorder(self) -> List[int]:
        """前序遍历"""
        result = []
        self._preorder(self.root, result)
        return result

    def _preorder(self, root: Optional[TreeNode], result: List[int]) -> None:
        """递归前序遍历"""
        if root:
            result.append(root.val)
            self._preorder(root.left, result)
            self._preorder(root.right, result)

    def postorder(self) -> List[int]:
        """后序遍历"""
        result = []
        self._postorder(self.root, result)
        return result

    def _postorder(self, root: Optional[TreeNode], result: List[int]) -> None:
        """递归后序遍历"""
        if root:
            self._postorder(root.left, result)
            self._postorder(root.right, result)
            result.append(root.val)

    def level_order(self) -> List[List[int]]:
        """层序遍历"""
        if not self.root:
            return []

        result = []
        queue = [self.root]

        while queue:
            level_size = len(queue)
            level = []

            for _ in range(level_size):
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level)

        return result

    # ==================== 范围查询 ====================

    def range_query(self, low: int, high: int) -> List[int]:
        """
        范围查询：返回[low, high]范围内的所有值
        时间复杂度：O(k + log n)，k是结果数量
        """
        result = []
        self._range_query(self.root, low, high, result)
        return result

    def _range_query(self, root: Optional[TreeNode], low: int, high: int,
                     result: List[int]) -> None:
        """递归范围查询"""
        if not root:
            return

        # 剪枝优化
        if low < root.val:
            self._range_query(root.left, low, high, result)

        if low <= root.val <= high:
            result.append(root.val)

        if root.val < high:
            self._range_query(root.right, low, high, result)

    def count_range(self, low: int, high: int) -> int:
        """统计范围内的节点数量"""
        return len(self.range_query(low, high))

    # ==================== 前驱与后继 ====================

    def predecessor(self, val: int) -> Optional[int]:
        """找到前驱节点的值"""
        node = self.search(val)
        if not node:
            return None

        # 情况1：有左子树，前驱是左子树最大值
        if node.left:
            return self._find_max(node.left).val

        # 情况2：没有左子树，向上找祖先
        pred = None
        current = self.root
        while current != node:
            if node.val > current.val:
                pred = current.val
                current = current.right
            else:
                current = current.left

        return pred

    def successor(self, val: int) -> Optional[int]:
        """找到后继节点的值"""
        node = self.search(val)
        if not node:
            return None

        # 情况1：有右子树，后继是右子树最小值
        if node.right:
            return self._find_min(node.right).val

        # 情况2：没有右子树，向上找祖先
        succ = None
        current = self.root
        while current != node:
            if node.val < current.val:
                succ = current.val
                current = current.left
            else:
                current = current.right

        return succ

    # ==================== 验证与统计 ====================

    def is_valid_bst(self) -> bool:
        """验证是否为有效的BST"""
        def validate(node: Optional[TreeNode], min_val: float, max_val: float) -> bool:
            if not node:
                return True

            if node.val <= min_val or node.val >= max_val:
                return False

            return (validate(node.left, min_val, node.val) and
                    validate(node.right, node.val, max_val))

        return validate(self.root, float('-inf'), float('inf'))

    def __len__(self) -> int:
        """返回节点数量"""
        return self.size

    def __contains__(self, val: int) -> bool:
        """支持 in 操作符"""
        return self.search(val) is not None

    def __repr__(self) -> str:
        """字符串表示"""
        if not self.root:
            return "BST(empty)"
        return f"BST(size={self.size}, height={self.height()}, values={self.inorder()})"


# ==================== 测试代码 ====================

def test_bst():
    """测试BST的所有功能"""
    print("=" * 50)
    print("BST 完整测试")
    print("=" * 50)

    # 1. 创建BST并插入数据
    bst = BST()
    values = [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 65]

    print("\n1. 插入数据:", values)
    for val in values:
        bst.insert(val)

    print(f"   BST: {bst}")
    print(f"   有序序列: {bst.inorder()}")

    # 2. 查找测试
    print("\n2. 查找测试:")
    test_vals = [40, 100]
    for val in test_vals:
        node = bst.search(val)
        print(f"   查找{val}: {'找到' if node else '未找到'}")

    # 3. 最小/最大值
    print("\n3. 最小/最大值:")
    print(f"   最小值: {bst.find_min().val}")
    print(f"   最大值: {bst.find_max().val}")

    # 4. 前驱与后继
    print("\n4. 前驱与后继:")
    test_val = 40
    print(f"   {test_val}的前驱: {bst.predecessor(test_val)}")
    print(f"   {test_val}的后继: {bst.successor(test_val)}")

    # 5. 范围查询
    print("\n5. 范围查询:")
    low, high = 25, 65
    range_result = bst.range_query(low, high)
    print(f"   [{low}, {high}]范围: {range_result}")
    print(f"   数量: {bst.count_range(low, high)}")

    # 6. 遍历测试
    print("\n6. 遍历测试:")
    print(f"   中序遍历: {bst.inorder()}")
    print(f"   前序遍历: {bst.preorder()}")
    print(f"   后序遍历: {bst.postorder()}")
    print(f"   层序遍历: {bst.level_order()}")

    # 7. 删除测试
    print("\n7. 删除测试:")
    delete_vals = [20, 30, 50]
    for val in delete_vals:
        success = bst.delete(val)
        print(f"   删除{val}: {'成功' if success else '失败'}")
        print(f"   当前序列: {bst.inorder()}")

    # 8. 树的属性
    print("\n8. 树的属性:")
    print(f"   节点数量: {len(bst)}")
    print(f"   树高: {bst.height()}")
    print(f"   是否平衡: {bst.is_balanced()}")
    print(f"   是否有效BST: {bst.is_valid_bst()}")

    # 9. 性能测试
    print("\n9. 性能测试:")
    import time

    # 插入性能
    large_bst = BST()
    n = 10000
    start = time.time()
    for i in range(n):
        large_bst.insert(i)
    insert_time = time.time() - start
    print(f"   插入{n}个节点: {insert_time:.4f}秒")

    # 查找性能
    start = time.time()
    for i in range(0, n, 100):
        large_bst.search(i)
    search_time = time.time() - start
    print(f"   查找100次: {search_time:.4f}秒")

    # 范围查询性能
    start = time.time()
    result = large_bst.range_query(4000, 6000)
    range_time = time.time() - start
    print(f"   范围查询(2000个结果): {range_time:.4f}秒")

    print(f"\n   注意：有序插入导致退化为链表，高度={large_bst.height()}")


if __name__ == "__main__":
    test_bst()
```

---

## 运行结果

```
==================================================
BST 完整测试
==================================================

1. 插入数据: [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 65]
   BST: BST(size=11, height=4, values=[10, 20, 25, 30, 35, 40, 50, 60, 65, 70, 80])
   有序序列: [10, 20, 25, 30, 35, 40, 50, 60, 65, 70, 80]

2. 查找测试:
   查找40: 找到
   查找100: 未找到

3. 最小/最大值:
   最小值: 10
   最大值: 80

4. 前驱与后继:
   40的前驱: 35
   40的后继: 50

5. 范围查询:
   [25, 65]范围: [25, 30, 35, 40, 50, 60, 65]
   数量: 7

6. 遍历测试:
   中序遍历: [10, 20, 25, 30, 35, 40, 50, 60, 65, 70, 80]
   前序遍历: [50, 30, 20, 10, 25, 40, 35, 70, 60, 65, 80]
   后序遍历: [10, 25, 20, 35, 40, 30, 65, 60, 80, 70, 50]
   层序遍历: [[50], [30, 70], [20, 40, 60, 80], [10, 25, 35, 65]]

7. 删除测试:
   删除20: 成功
   当前序列: [10, 25, 30, 35, 40, 50, 60, 65, 70, 80]
   删除30: 成功
   当前序列: [10, 25, 35, 40, 50, 60, 65, 70, 80]
   删除50: 成功
   当前序列: [10, 25, 35, 40, 60, 65, 70, 80]

8. 树的属性:
   节点数量: 8
   树高: 4
   是否平衡: True
   是否有效BST: True

9. 性能测试:
   插入10000个节点: 0.0234秒
   查找100次: 0.0012秒
   范围查询(2000个结果): 0.0045秒

   注意：有序插入导致退化为链表，高度=10000
```

---

## 关键知识点

### 1. 节点设计

```python
@dataclass
class TreeNode:
    val: int
    left: Optional['TreeNode'] = None
    right: Optional['TreeNode'] = None
    data: Any = None  # 附加数据
```

**设计要点：**
- 使用`dataclass`简化代码
- `data`字段存储附加信息
- 类型注解提高可读性

### 2. 删除操作的三种情况

```python
# 情况1：叶子节点或单子节点
if not root.left:
    return root.right
if not root.right:
    return root.left

# 情况2：双子节点
successor = self._find_min(root.right)
root.val = successor.val
root.right = self._delete(root.right, successor.val)
```

### 3. 范围查询的剪枝优化

```python
# 只访问可能包含结果的子树
if low < root.val:
    self._range_query(root.left, low, high, result)

if low <= root.val <= high:
    result.append(root.val)

if root.val < high:
    self._range_query(root.right, low, high, result)
```

---

## 扩展练习

### 练习1：迭代版本

将递归操作改为迭代版本，降低空间复杂度。

### 练习2：支持重复值

修改BST支持重复值（使用计数或多值存储）。

### 练习3：序列化与反序列化

实现BST的序列化和反序列化功能。

---

## 学习检查清单

- [ ] 能手写完整的BST类
- [ ] 理解删除操作的三种情况
- [ ] 掌握范围查询的剪枝优化
- [ ] 能实现前驱和后继查找
- [ ] 理解各种遍历方式的区别
- [ ] 能分析BST的性能特征

---

**记住：** 手写BST是理解数据结构的最佳方式，重点掌握删除操作和范围查询的实现。
