# 反直觉点

> 揭示 Context Files 配置中的 3 个常见误区，避免踩坑

---

## 反直觉点 1：AGENTS.md 不是覆盖，而是累加

### 直觉认为

"项目根目录的 AGENTS.md 会覆盖全局的 AGENTS.md，就像 settings.json 那样。"

### 实际情况

**所有层级的 AGENTS.md 都会被加载并合并（concatenate），不是覆盖！**

```bash
# 目录结构
~/.pi/agent/AGENTS.md          # 全局配置
/projects/AGENTS.md            # 项目根配置
/projects/my-app/AGENTS.md     # 子项目配置

# Pi Agent 启动时的加载顺序
1. 读取 ~/.pi/agent/AGENTS.md
2. 读取 /projects/AGENTS.md
3. 读取 /projects/my-app/AGENTS.md
4. 将三个文件的内容拼接在一起（不是覆盖）

# 最终 Pi Agent 看到的内容
全局规则
+
项目根规则
+
子项目规则
```

### 为什么反直觉？

因为 settings.json 是覆盖机制，容易让人误以为 AGENTS.md 也是覆盖。

```json
// settings.json 是覆盖机制
// ~/.pi/agent/settings.json
{
  "defaultModel": "claude-sonnet-4",
  "theme": "dark"
}

// .pi/settings.json（项目级）
{
  "defaultModel": "claude-opus-4"  // 覆盖全局的 sonnet
  // theme 继承全局的 "dark"
}
```

### 实际影响

**场景：Mono-repo 项目**

```bash
# 项目结构
/my-monorepo/
├── AGENTS.md                    # 通用规范
├── packages/
│   ├── frontend/
│   │   └── AGENTS.md            # 前端特定规范
│   └── backend/
│       └── AGENTS.md            # 后端特定规范
```

```markdown
# /my-monorepo/AGENTS.md（通用规范）
- 使用 TypeScript
- 遵循 ESLint
- 提交信息遵循 Conventional Commits

# /my-monorepo/packages/frontend/AGENTS.md（前端特定）
- 使用 React 18
- 组件放在 src/components/
- 样式使用 Tailwind CSS

# 在 frontend/ 目录启动 Pi 时，Pi Agent 看到的内容：
- 使用 TypeScript                    # 来自根目录
- 遵循 ESLint                        # 来自根目录
- 提交信息遵循 Conventional Commits   # 来自根目录
- 使用 React 18                      # 来自 frontend/
- 组件放在 src/components/           # 来自 frontend/
- 样式使用 Tailwind CSS              # 来自 frontend/
```

### 最佳实践

**使用"渐进式披露"（Progressive Disclosure）模式：**

```markdown
# 根目录 AGENTS.md - 通用规则
- 代码风格：Prettier
- 提交规范：Conventional Commits

# 子目录 AGENTS.md - 特定规则（不重复根目录的内容）
- 前端框架：React
- 状态管理：Zustand
```

**来源：** Twitter @badlogicgames 的 progressive disclosure 最佳实践

---

## 反直觉点 2：settings.json 的合并规则是"嵌套对象合并，数组替换"

### 直觉认为

"项目级 settings.json 会完全覆盖全局 settings.json。"

### 实际情况

**嵌套对象会深度合并，但数组会完全替换！**

```json
// 全局配置：~/.pi/agent/settings.json
{
  "defaultModel": "claude-sonnet-4",
  "theme": "dark",
  "compaction": {
    "enabled": true,
    "reserveTokens": 50000,
    "keepRecentTokens": 10000
  },
  "packages": ["@pi/core", "@pi/utils"]
}

// 项目配置：.pi/settings.json
{
  "defaultModel": "claude-opus-4",
  "compaction": {
    "reserveTokens": 80000
  },
  "packages": ["@pi/custom"]
}

// 最终生效的配置（合并后）
{
  "defaultModel": "claude-opus-4",        // 项目覆盖全局
  "theme": "dark",                        // 继承全局
  "compaction": {
    "enabled": true,                      // 继承全局
    "reserveTokens": 80000,               // 项目覆盖全局
    "keepRecentTokens": 10000             // 继承全局
  },
  "packages": ["@pi/custom"]              // 数组完全替换（不合并）
}
```

### 为什么反直觉？

因为对象和数组的合并规则不一致：
- **对象**：深度合并（merge）
- **数组**：完全替换（replace）

### 实际影响

**场景：想在项目中添加额外的 packages**

```json
// ❌ 错误做法（会丢失全局的 packages）
// .pi/settings.json
{
  "packages": ["@pi/custom"]  // 全局的 @pi/core 和 @pi/utils 会丢失
}

// ✅ 正确做法（显式包含全局的 packages）
// .pi/settings.json
{
  "packages": [
    "@pi/core",      // 手动包含全局的
    "@pi/utils",     // 手动包含全局的
    "@pi/custom"     // 添加项目特定的
  ]
}
```

### 最佳实践

**如果需要扩展数组配置，必须显式包含全局的值：**

```json
// 全局配置
{
  "skills": ["~/.pi/skills/common"]
}

// 项目配置（想添加项目特定的 skill）
{
  "skills": [
    "~/.pi/skills/common",      // 必须显式包含
    "./.pi/skills/project"      // 添加项目特定的
  ]
}
```

**来源：** 官方文档 settings.md 的 override rules

---

## 反直觉点 3：SYSTEM.md 会完全替换默认提示词，而不是追加

### 直觉认为

"SYSTEM.md 会在默认提示词的基础上添加我的自定义规则。"

### 实际情况

**SYSTEM.md 会完全替换默认提示词，APPEND_SYSTEM.md 才是追加！**

```markdown
# 使用 SYSTEM.md（完全替换）
.pi/SYSTEM.md:
你是一个 TypeScript 专家。

# Pi Agent 的系统提示词
你是一个 TypeScript 专家。
（默认的所有提示词都被替换了）

---

# 使用 APPEND_SYSTEM.md（追加）
.pi/APPEND_SYSTEM.md:
你是一个 TypeScript 专家。

# Pi Agent 的系统提示词
[默认的系统提示词...]
你是一个 TypeScript 专家。
（追加到默认提示词后面）
```

### 为什么反直觉？

因为文件名 `SYSTEM.md` 没有明确表达"替换"的语义，容易让人误以为是"追加"。

### 实际影响

**场景：想让 Pi Agent 遵循特定的代码风格**

```markdown
# ❌ 错误做法（会丢失默认的所有能力）
# .pi/SYSTEM.md
你必须使用函数式编程风格。

# 结果：Pi Agent 失去了默认的所有能力
# - 不知道如何使用工具
# - 不知道如何读写文件
# - 不知道如何执行命令
# 只知道"使用函数式编程风格"

---

# ✅ 正确做法（追加到默认提示词）
# .pi/APPEND_SYSTEM.md
你必须使用函数式编程风格。

# 结果：Pi Agent 保留默认能力 + 遵循函数式编程
```

### 何时使用 SYSTEM.md？

**只在以下场景使用 SYSTEM.md（完全替换）：**
- 你想完全自定义 AI 的行为（高级用户）
- 你清楚默认提示词的所有内容
- 你有能力重新编写完整的系统提示词

**大多数情况下，使用 APPEND_SYSTEM.md（追加）：**
- 添加项目特定的规则
- 定制代码风格
- 添加安全约束

### 最佳实践

```markdown
# .pi/APPEND_SYSTEM.md（推荐）
# 代码风格
- 使用函数式编程
- 优先使用 const
- 避免使用 any

# 安全规则
- 不要修改 src/legacy/ 目录
- 不要删除测试文件

# 工作方式
- 代码优先，少说多做
- 每次修改后运行测试
```

**来源：** 官方文档 README.md 的 SYSTEM.md vs APPEND_SYSTEM.md 说明

---

## 总结对照表

| 误区 | 直觉认为 | 实际情况 | 正确做法 |
|------|----------|----------|----------|
| **AGENTS.md 加载** | 覆盖 | 累加（concatenate） | 使用渐进式披露，避免重复 |
| **settings.json 合并** | 完全覆盖 | 对象合并，数组替换 | 数组配置需显式包含全局值 |
| **SYSTEM.md 行为** | 追加 | 完全替换 | 大多数情况用 APPEND_SYSTEM.md |

---

## 快速检查清单

**配置 AGENTS.md 时：**
- [ ] 是否在多个层级都有 AGENTS.md？
- [ ] 子目录的 AGENTS.md 是否重复了父目录的内容？
- [ ] 是否使用了渐进式披露模式？

**配置 settings.json 时：**
- [ ] 是否修改了数组类型的配置（packages、skills 等）？
- [ ] 是否显式包含了全局配置中的数组值？
- [ ] 是否理解对象会合并、数组会替换？

**配置 SYSTEM.md 时：**
- [ ] 是否真的需要完全替换默认提示词？
- [ ] 是否应该使用 APPEND_SYSTEM.md 代替？
- [ ] 是否测试过配置后 Pi Agent 的行为？

---

**记住：** 理解这三个反直觉点，能避免 90% 的 Context Files 配置问题！
