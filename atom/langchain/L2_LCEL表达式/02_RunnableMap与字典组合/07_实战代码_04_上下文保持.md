# 实战代码4: 上下文保持

> **完整可运行的上下文保持示例**

---

## 环境准备

```bash
# 安装依赖
uv add langchain langchain-openai python-dotenv

# 配置 API Key
echo "OPENAI_API_KEY=your_key_here" > .env
```

---

## 示例1: RunnablePassthrough.assign() 基础用法

```python
"""
使用 assign() 在原有字典基础上添加新字段
"""
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from dotenv import load_dotenv

load_dotenv()

model = ChatOpenAI(model="gpt-4")

# 使用 assign() 添加新字段
chain = RunnablePassthrough.assign(
    summary=ChatPromptTemplate.from_template("总结: {text}") | model
)

# 输入字典
input_data = {
    "text": "LangChain 是一个强大的 AI 框架",
    "user": "Alice",
}

result = chain.invoke(input_data)

print("原始字段:")
print("  text:", result["text"])
print("  user:", result["user"])
print("\n新增字段:")
print("  summary:", result["summary"].content)
```

---

## 示例2: 逐步扩展上下文

```python
"""
通过多个 assign() 逐步扩展上下文
"""
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from dotenv import load_dotenv

load_dotenv()

model = ChatOpenAI(model="gpt-4")

# 逐步扩展上下文
chain = (
    # 步骤1: 添加摘要
    RunnablePassthrough.assign(
        summary=ChatPromptTemplate.from_template("总结: {text}") | model
    )
    # 步骤2: 添加关键词
    | RunnablePassthrough.assign(
        keywords=ChatPromptTemplate.from_template("关键词: {text}") | model
    )
    # 步骤3: 添加元数据
    | RunnablePassthrough.assign(
        metadata=lambda x: {
            "length": len(x["text"]),
            "has_summary": "summary" in x,
            "has_keywords": "keywords" in x,
        }
    )
)

result = chain.invoke({"text": "LangChain 让 AI 开发更简单"})

print("原始输入:", result["text"])
print("摘要:", result["summary"].content)
print("关键词:", result["keywords"].content)
print("元数据:", result["metadata"])
```

---

## 示例3: RAG 中的上下文保持

```python
"""
RAG 链中保持所有中间结果
"""
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_community.vectorstores import Chroma
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_core.documents import Document
from dotenv import load_dotenv

load_dotenv()

# 准备知识库
docs = [
    Document(page_content="LangChain 是一个 AI 框架"),
    Document(page_content="LCEL 是表达式语言"),
]

vectorstore = Chroma.from_documents(
    documents=docs,
    embedding=OpenAIEmbeddings()
)
retriever = vectorstore.as_retriever()

model = ChatOpenAI(model="gpt-4")

# 保持所有中间结果的 RAG 链
rag_chain = (
    # 步骤1: 添加检索结果
    RunnablePassthrough.assign(
        context=lambda x: retriever.invoke(x["question"])
    )
    # 步骤2: 生成答案
    | RunnablePassthrough.assign(
        answer=ChatPromptTemplate.from_template(
            "根据上下文回答问题\n\n上下文: {context}\n\n问题: {question}"
        ) | model
    )
    # 步骤3: 添加分析
    | RunnablePassthrough.assign(
        analysis=lambda x: {
            "context_count": len(x["context"]),
            "answer_length": len(x["answer"].content),
            "question_length": len(x["question"]),
        }
    )
)

result = rag_chain.invoke({"question": "LangChain 是什么？"})

print("问题:", result["question"])
print("检索到的文档数:", result["analysis"]["context_count"])
print("答案:", result["answer"].content)
print("答案长度:", result["analysis"]["answer_length"])
```

---

## 示例4: 条件上下文扩展

```python
"""
根据条件决定是否添加字段
"""
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough, RunnableLambda
from dotenv import load_dotenv

load_dotenv()

model = ChatOpenAI(model="gpt-4")

def conditional_assign(x):
    """根据文本长度决定是否添加详细分析"""
    result = x.copy()

    # 添加基础摘要
    summary_chain = ChatPromptTemplate.from_template("总结: {text}") | model
    result["summary"] = summary_chain.invoke(x)

    # 长文本添加详细分析
    if len(x["text"]) > 50:
        detailed_chain = ChatPromptTemplate.from_template("详细分析: {text}") | model
        result["detailed_analysis"] = detailed_chain.invoke(x)

    return result

chain = RunnableLambda(conditional_assign)

# 测试短文本
short_result = chain.invoke({"text": "LangChain 很好"})
print("短文本字段:", list(short_result.keys()))

# 测试长文本
long_result = chain.invoke({
    "text": "LangChain 是一个非常强大的 AI 应用开发框架，它提供了丰富的组件和工具"
})
print("长文本字段:", list(long_result.keys()))
```

---

## 示例5: 嵌套上下文管理

```python
"""
管理嵌套的上下文结构
"""
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from dotenv import load_dotenv

load_dotenv()

model = ChatOpenAI(model="gpt-4")

# 嵌套上下文管理
chain = (
    # 添加内容分析组
    RunnablePassthrough.assign(
        content_analysis={
            "summary": ChatPromptTemplate.from_template("总结: {text}") | model,
            "keywords": ChatPromptTemplate.from_template("关键词: {text}") | model,
        }
    )
    # 添加元数据组
    | RunnablePassthrough.assign(
        metadata={
            "length": lambda x: len(x["text"]),
            "word_count": lambda x: len(x["text"].split()),
        }
    )
)

result = chain.invoke({"text": "LangChain 让开发更简单"})

print("原始文本:", result["text"])
print("\n内容分析:")
print("  摘要:", result["content_analysis"]["summary"].content)
print("  关键词:", result["content_analysis"]["keywords"].content)
print("\n元数据:")
print("  长度:", result["metadata"]["length"])
print("  词数:", result["metadata"]["word_count"])
```

---

## 示例6: 多步骤数据处理流程

```python
"""
完整的数据处理流程，保持所有中间状态
"""
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough, RunnableLambda
from dotenv import load_dotenv

load_dotenv()

model = ChatOpenAI(model="gpt-4")

# 多步骤处理流程
processing_chain = (
    # 步骤1: 预处理
    RunnablePassthrough.assign(
        cleaned_text=lambda x: x["text"].strip().lower()
    )
    # 步骤2: 分析
    | RunnablePassthrough.assign(
        analysis=ChatPromptTemplate.from_template(
            "分析以下文本: {cleaned_text}"
        ) | model
    )
    # 步骤3: 提取关键信息
    | RunnablePassthrough.assign(
        key_points=ChatPromptTemplate.from_template(
            "从分析中提取关键点: {analysis}"
        ) | model
    )
    # 步骤4: 生成报告
    | RunnablePassthrough.assign(
        report=lambda x: {
            "original": x["text"],
            "cleaned": x["cleaned_text"],
            "analysis_summary": x["analysis"].content[:100] + "...",
            "key_points": x["key_points"].content,
        }
    )
)

result = processing_chain.invoke({
    "text": "  LangChain 是一个强大的 AI 框架  "
})

print("=== 处理报告 ===")
print("原始文本:", result["report"]["original"])
print("清理后:", result["report"]["cleaned"])
print("分析摘要:", result["report"]["analysis_summary"])
print("关键点:", result["report"]["key_points"])
```

---

## 示例7: 错误处理与上下文保持

```python
"""
在保持上下文的同时处理错误
"""
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough, RunnableLambda
from dotenv import load_dotenv
import logging

load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

model = ChatOpenAI(model="gpt-4")

def safe_assign(func, field_name):
    """安全的 assign，捕获错误"""
    def wrapper(x):
        try:
            result = func(x)
            return {**x, field_name: result, f"{field_name}_status": "success"}
        except Exception as e:
            logger.error(f"[{field_name}] 失败: {e}")
            return {**x, f"{field_name}_status": "failed", f"{field_name}_error": str(e)}
    return RunnableLambda(wrapper)

# 带错误处理的链
chain = (
    safe_assign(
        lambda x: (ChatPromptTemplate.from_template("总结: {text}") | model).invoke(x),
        "summary"
    )
    | safe_assign(
        lambda x: (ChatPromptTemplate.from_template("关键词: {text}") | model).invoke(x),
        "keywords"
    )
)

result = chain.invoke({"text": "LangChain 很强大"})

print("摘要状态:", result.get("summary_status"))
if result.get("summary_status") == "success":
    print("摘要:", result["summary"].content)

print("关键词状态:", result.get("keywords_status"))
if result.get("keywords_status") == "success":
    print("关键词:", result["keywords"].content)
```

---

## 示例8: 完整的企业级上下文管理

```python
"""
企业级应用中的上下文管理
包含：验证、转换、增强、监控
"""
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough, RunnableLambda
from dotenv import load_dotenv
import logging
import time
from typing import Dict, Any

load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

model = ChatOpenAI(model="gpt-4")

def validate_input(x: Dict[str, Any]) -> Dict[str, Any]:
    """验证输入"""
    if "text" not in x:
        raise ValueError("缺少 text 字段")
    if len(x["text"]) < 5:
        raise ValueError("文本太短")
    return {**x, "validation": "passed"}

def add_timestamp(x: Dict[str, Any]) -> Dict[str, Any]:
    """添加时间戳"""
    return {**x, "timestamp": time.time()}

def add_metadata(x: Dict[str, Any]) -> Dict[str, Any]:
    """添加元数据"""
    return {
        **x,
        "metadata": {
            "text_length": len(x["text"]),
            "word_count": len(x["text"].split()),
            "has_validation": "validation" in x,
        }
    }

# 企业级处理链
enterprise_chain = (
    # 步骤1: 验证
    RunnableLambda(validate_input)
    # 步骤2: 添加时间戳
    | RunnableLambda(add_timestamp)
    # 步骤3: 添加元数据
    | RunnableLambda(add_metadata)
    # 步骤4: 生成摘要
    | RunnablePassthrough.assign(
        summary=ChatPromptTemplate.from_template("总结: {text}") | model
    )
    # 步骤5: 生成关键词
    | RunnablePassthrough.assign(
        keywords=ChatPromptTemplate.from_template("关键词: {text}") | model
    )
    # 步骤6: 生成最终报告
    | RunnableLambda(lambda x: {
        "input": {
            "text": x["text"],
            "timestamp": x["timestamp"],
        },
        "metadata": x["metadata"],
        "results": {
            "summary": x["summary"].content,
            "keywords": x["keywords"].content,
        },
        "validation": x["validation"],
    })
)

# 测试
try:
    result = enterprise_chain.invoke({
        "text": "LangChain 是一个强大的 AI 应用开发框架"
    })

    print("=== 处理报告 ===")
    print("输入文本:", result["input"]["text"])
    print("处理时间:", result["input"]["timestamp"])
    print("验证状态:", result["validation"])
    print("\n元数据:")
    for key, value in result["metadata"].items():
        print(f"  {key}: {value}")
    print("\n结果:")
    print("  摘要:", result["results"]["summary"])
    print("  关键词:", result["results"]["keywords"])

except ValueError as e:
    print(f"验证失败: {e}")
```

---

## 常见模式总结

### 模式1: 基础 assign
```python
RunnablePassthrough.assign(
    new_field=chain
)
```

### 模式2: 逐步扩展
```python
(
    RunnablePassthrough.assign(field1=chain1)
    | RunnablePassthrough.assign(field2=chain2)
)
```

### 模式3: RAG 上下文保持
```python
(
    RunnablePassthrough.assign(context=retriever)
    | RunnablePassthrough.assign(answer=prompt | model)
)
```

### 模式4: 嵌套结构
```python
RunnablePassthrough.assign(
    group={
        "field1": chain1,
        "field2": chain2,
    }
)
```

### 模式5: 条件扩展
```python
RunnableLambda(lambda x: {
    **x,
    "new_field": chain.invoke(x) if condition(x) else None
})
```

---

## 最佳实践

### 1. 保持上下文清晰

```python
# ✅ 好：清晰的字段名
RunnablePassthrough.assign(
    retrieved_documents=retriever,
    generated_answer=prompt | model,
)

# ❌ 不好：模糊的字段名
RunnablePassthrough.assign(
    data=retriever,
    result=prompt | model,
)
```

### 2. 避免字段覆盖

```python
# ❌ 错误：覆盖原有字段
RunnablePassthrough.assign(
    text=lambda x: x["text"].upper()  # 覆盖了原始 text
)

# ✅ 正确：使用新字段名
RunnablePassthrough.assign(
    processed_text=lambda x: x["text"].upper()
)
```

### 3. 合理组织嵌套

```python
# ✅ 好：逻辑分组
RunnablePassthrough.assign(
    analysis={
        "summary": summary_chain,
        "keywords": keywords_chain,
    },
    metadata={
        "length": lambda x: len(x["text"]),
        "timestamp": lambda x: time.time(),
    }
)
```

### 4. 添加调试信息

```python
# 添加调试字段
RunnablePassthrough.assign(
    debug_info=lambda x: {
        "input_keys": list(x.keys()),
        "text_length": len(x.get("text", "")),
        "timestamp": time.time(),
    }
)
```

---

## 性能优化

### 1. 避免重复计算

```python
# ❌ 不好：重复调用
chain = (
    RunnablePassthrough.assign(
        summary=ChatPromptTemplate.from_template("总结: {text}") | model
    )
    | RunnablePassthrough.assign(
        keywords=ChatPromptTemplate.from_template("关键词: {summary}") | model
    )
)

# ✅ 好：使用已有结果
chain = (
    RunnablePassthrough.assign(
        summary=ChatPromptTemplate.from_template("总结: {text}") | model
    )
    | RunnablePassthrough.assign(
        keywords=lambda x: (
            ChatPromptTemplate.from_template("关键词: {summary}") | model
        ).invoke({"summary": x["summary"].content})
    )
)
```

### 2. 延迟计算

```python
# 只在需要时计算
RunnablePassthrough.assign(
    expensive_field=lambda x: expensive_operation(x) if x.get("need_expensive") else None
)
```

---

## 调试技巧

### 打印中间状态

```python
def debug_print(x):
    print("=== 当前状态 ===")
    for key, value in x.items():
        print(f"{key}: {type(value)}")
    return x

chain = (
    RunnablePassthrough.assign(field1=chain1)
    | RunnableLambda(debug_print)
    | RunnablePassthrough.assign(field2=chain2)
)
```

### 添加日志

```python
import logging

logger = logging.getLogger(__name__)

def logged_assign(field_name, chain):
    def wrapper(x):
        logger.info(f"[{field_name}] 开始")
        result = chain.invoke(x)
        logger.info(f"[{field_name}] 完成")
        return {**x, field_name: result}
    return RunnableLambda(wrapper)
```

---

## 下一步学习

- [核心概念2: 键值映射](./03_核心概念_02_键值映射.md) - 深入理解输入输出
- [实战代码2: RAG检索场景](./07_实战代码_02_RAG检索场景.md) - RAG 中的上下文管理
- [化骨绵掌](./09_化骨绵掌.md) - 快速复习所有知识点

---

**版本**: v1.0
**最后更新**: 2026-02-19
**适用**: LangChain 0.3+, Python 3.13+
