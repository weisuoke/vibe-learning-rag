# 核心概念：引用溯源系统

> 为生成内容标注来源，实现可追溯性和可验证性

---

## 原理讲解

### 为什么需要引用溯源？

**核心问题：** 用户如何知道 LLM 的答案是否可信？

```
LLM 答案：「Python 3.9 新增了字典合并运算符和类型提示改进」
用户疑问：这是真的吗？从哪里来的？
```

**引用溯源的价值：**

1. **可验证性**：用户可以点击来源验证答案
2. **可信度**：有来源支持的答案更可信
3. **责任追溯**：出错时可以追溯到具体文档

### 引用溯源的三个层次

#### 层次1：文档级引用

**最简单的引用方式：** 标注答案来自哪个文档

```python
answer = "Python 3.9 新增了字典合并运算符"
source = "Python 3.9 发布说明"

# 输出
print(f"{answer}\n来源：{source}")
```

#### 层次2：句子级引用

**更精细的引用：** 每个句子标注来源

```python
answer = """
Python 3.9 于 2020 年 10 月发布 [1]。
新增了字典合并运算符 | [2]。
改进了类型提示功能 [3]。

来源：
[1] Python 官方发布公告
[2] PEP 584 - 字典合并运算符
[3] PEP 585 - 类型提示泛型
"""
```

#### 层次3：事实级引用

**最精细的引用：** 每个事实性陈述都标注来源

```python
answer = """
Python 3.9 于 2020 年 10 月 5 日 [1] 发布，
这是一个重要的版本更新 [2]。
新增了字典合并运算符 | [3]，
可以方便地合并两个字典 [4]。
"""
```

### 引用溯源的实现方式

#### 方式1：Prompt 工程（推荐）

**核心思想：** 在 Prompt 中明确要求 LLM 添加引用

```python
prompt = f"""
基于以下文档回答问题，并用 [1], [2] 标注引用来源：

文档1：{doc1}
文档2：{doc2}

问题：{query}

要求：
1. 每个事实性陈述都要标注来源
2. 使用 [1], [2] 格式标注
3. 不要添加文档中没有的信息

答案：
"""
```

**优点：**
- 简单易实现
- 无需额外模型
- LLM 通常能很好地遵循指令

**缺点：**
- LLM 可能遗漏引用
- 引用可能不准确
- 需要后处理验证

#### 方式2：后处理提取

**核心思想：** 生成答案后，自动提取并添加引用

```python
def add_citations_post_processing(answer, docs):
    # 1. 将答案拆分成句子
    sentences = split_sentences(answer)

    # 2. 为每个句子找到最匹配的文档
    cited_answer = ""
    for sentence in sentences:
        best_doc_idx = find_best_match(sentence, docs)
        cited_answer += f"{sentence} [{best_doc_idx + 1}]"

    # 3. 添加来源列表
    sources = "\n\n来源：\n"
    for i, doc in enumerate(docs):
        sources += f"[{i + 1}] {doc.metadata['title']}\n"

    return cited_answer + sources
```

**优点：**
- 引用更准确（基于相似度计算）
- 可以处理 LLM 遗漏的引用

**缺点：**
- 需要额外计算
- 可能过度引用

#### 方式3：混合方式（最佳实践）

**结合 Prompt 工程和后处理验证：**

```python
def hybrid_citation_system(query, docs, llm):
    # 步骤1：Prompt 工程要求 LLM 添加引用
    prompt = create_citation_prompt(query, docs)
    answer = llm.generate(prompt)

    # 步骤2：提取引用
    citations = extract_citations(answer)

    # 步骤3：验证引用有效性
    for citation in citations:
        if not is_valid_citation(citation, docs):
            # 引用无效，自动修正
            answer = fix_citation(answer, citation, docs)

    # 步骤4：检查遗漏的引用
    uncited_sentences = find_uncited_sentences(answer)
    for sentence in uncited_sentences:
        # 自动添加引用
        answer = add_citation(answer, sentence, docs)

    return answer
```

---

## 手写实现

### 实现1：基于 Prompt 的引用系统

```python
from typing import List, Dict
from openai import OpenAI
import re

class PromptBasedCitationSystem:
    """
    基于 Prompt 工程的引用系统
    """

    def __init__(self, api_key: str):
        self.client = OpenAI(api_key=api_key)

    def generate_with_citations(
        self,
        query: str,
        docs: List[Dict[str, str]],
        model: str = "gpt-4"
    ) -> str:
        """
        生成带引用的答案

        Args:
            query: 用户查询
            docs: 文档列表，每个文档包含 'content' 和 'title'
            model: LLM 模型

        Returns:
            带引用的答案
        """
        # 构建带编号的文档
        numbered_docs = ""
        for i, doc in enumerate(docs):
            numbered_docs += f"\n文档{i+1}：{doc['content']}\n"

        # 构建 Prompt
        prompt = f"""基于以下文档回答问题，并用 [1], [2] 等标注引用来源。

{numbered_docs}

问题：{query}

要求：
1. 每个事实性陈述都要标注来源，格式为 [数字]
2. 不要添加文档中没有的信息
3. 如果文档中没有答案，明确说明
4. 在答案末尾列出所有引用的来源

答案："""

        # 调用 LLM
        response = self.client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )

        answer = response.choices[0].message.content

        # 添加来源元数据
        answer += "\n\n来源详情：\n"
        for i, doc in enumerate(docs):
            answer += f"[{i+1}] {doc.get('title', f'文档{i+1}')}\n"

        return answer

    def extract_citations(self, answer: str) -> List[int]:
        """
        提取答案中的引用编号

        Args:
            answer: 带引用的答案

        Returns:
            引用编号列表
        """
        citations = re.findall(r'\[(\d+)\]', answer)
        return [int(c) for c in citations]

    def verify_citations(self, answer: str, num_docs: int) -> Dict[str, any]:
        """
        验证引用的有效性

        Args:
            answer: 带引用的答案
            num_docs: 文档数量

        Returns:
            验证结果
        """
        citations = self.extract_citations(answer)

        # 检查引用是否有效
        invalid_citations = [c for c in citations if c > num_docs or c < 1]

        # 检查是否有未使用的文档
        used_docs = set(citations)
        unused_docs = set(range(1, num_docs + 1)) - used_docs

        return {
            "valid": len(invalid_citations) == 0,
            "invalid_citations": invalid_citations,
            "unused_docs": list(unused_docs),
            "citation_count": len(citations)
        }


# 使用示例
if __name__ == "__main__":
    import os

    system = PromptBasedCitationSystem(api_key=os.getenv("OPENAI_API_KEY"))

    # 准备文档
    docs = [
        {
            "content": "Python 3.9 于 2020 年 10 月 5 日发布",
            "title": "Python 官方发布公告"
        },
        {
            "content": "Python 3.9 新增了字典合并运算符 |",
            "title": "PEP 584 - 字典合并运算符"
        },
        {
            "content": "Python 3.9 改进了类型提示功能",
            "title": "PEP 585 - 类型提示泛型"
        }
    ]

    # 生成带引用的答案
    query = "Python 3.9 有什么新特性？"
    answer = system.generate_with_citations(query, docs)

    print("=== 带引用的答案 ===")
    print(answer)

    # 验证引用
    verification = system.verify_citations(answer, len(docs))
    print("\n=== 引用验证 ===")
    print(f"引用有效: {verification['valid']}")
    print(f"引用数量: {verification['citation_count']}")
    if verification['unused_docs']:
        print(f"未使用的文档: {verification['unused_docs']}")
```

### 实现2：后处理引用系统

```python
from sentence_transformers import SentenceTransformer, util
import numpy as np

class PostProcessingCitationSystem:
    """
    后处理引用系统
    生成答案后自动添加引用
    """

    def __init__(self, model_name: str = 'all-MiniLM-L6-v2'):
        self.encoder = SentenceTransformer(model_name)

    def add_citations(
        self,
        answer: str,
        docs: List[Dict[str, str]],
        threshold: float = 0.5
    ) -> str:
        """
        为答案自动添加引用

        Args:
            answer: 生成的答案（无引用）
            docs: 文档列表
            threshold: 相似度阈值

        Returns:
            带引用的答案
        """
        # 1. 拆分句子
        sentences = [s.strip() + '。' for s in answer.split('。') if s.strip()]

        # 2. 编码句子和文档
        sentence_embeddings = self.encoder.encode(sentences)
        doc_embeddings = self.encoder.encode([doc['content'] for doc in docs])

        # 3. 为每个句子找到最匹配的文档
        cited_answer = ""
        for i, sentence in enumerate(sentences):
            # 计算相似度
            similarities = util.cos_sim(
                sentence_embeddings[i],
                doc_embeddings
            )[0].numpy()

            # 找到最相似的文档
            best_doc_idx = int(np.argmax(similarities))
            best_similarity = similarities[best_doc_idx]

            # 如果相似度超过阈值，添加引用
            if best_similarity >= threshold:
                cited_answer += f"{sentence} [{best_doc_idx + 1}]\n"
            else:
                cited_answer += f"{sentence}\n"

        # 4. 添加来源列表
        cited_answer += "\n来源：\n"
        for i, doc in enumerate(docs):
            cited_answer += f"[{i + 1}] {doc.get('title', f'文档{i+1}')}\n"

        return cited_answer


# 使用示例
if __name__ == "__main__":
    system = PostProcessingCitationSystem()

    docs = [
        {
            "content": "Python 3.9 于 2020 年 10 月 5 日发布",
            "title": "Python 官方发布公告"
        },
        {
            "content": "Python 3.9 新增了字典合并运算符 |",
            "title": "PEP 584"
        }
    ]

    # 无引用的答案
    answer = "Python 3.9 在 2020 年发布。新增了字典合并运算符。"

    # 自动添加引用
    cited_answer = system.add_citations(answer, docs, threshold=0.5)

    print("=== 原始答案 ===")
    print(answer)
    print("\n=== 添加引用后 ===")
    print(cited_answer)
```

---

## RAG应用场景

### 场景1：学术问答系统

**需求：** 为学术问答提供可验证的引用

```python
def academic_qa_with_citations(query: str, papers: List[Dict]):
    """
    学术问答系统，每个答案都有论文引用
    """
    # 1. 检索相关论文
    relevant_papers = retrieve_papers(query, papers, top_k=5)

    # 2. 生成带引用的答案
    citation_system = PromptBasedCitationSystem(api_key=os.getenv("OPENAI_API_KEY"))
    answer = citation_system.generate_with_citations(query, relevant_papers)

    # 3. 格式化为学术引用格式
    formatted_answer = format_academic_citations(answer, relevant_papers)

    return formatted_answer
```

### 场景2：法律文档分析

**需求：** 法律意见必须引用具体法条

```python
def legal_analysis_with_citations(case: str, laws: List[Dict]):
    """
    法律分析系统，引用具体法条
    """
    prompt = f"""
基于以下法律条文分析案件：

{format_laws(laws)}

案件：{case}

要求：
1. 每个法律观点都要引用具体法条
2. 使用格式：根据《XX法》第X条 [1]
3. 提供完整的法律依据

分析：
"""

    answer = llm.generate(prompt)
    return answer
```

### 场景3：医疗信息检索

**需求：** 医疗建议必须有权威来源

```python
def medical_qa_with_citations(query: str, medical_docs: List[Dict]):
    """
    医疗问答系统，引用权威医学文献
    """
    # 只使用权威来源
    authoritative_docs = filter_authoritative(medical_docs)

    # 生成带引用的答案
    answer = generate_with_citations(query, authoritative_docs)

    # 添加免责声明
    disclaimer = "\n\n免责声明：以上信息仅供参考，请咨询专业医生。"

    return answer + disclaimer
```

---

## 完整代码示例

```python
"""
完整的引用溯源系统
演示：从检索到生成到引用验证的完整流程
"""

from sentence_transformers import SentenceTransformer, CrossEncoder, util
from openai import OpenAI
import os
import re
from typing import List, Dict

# ===== 初始化 =====
print("=== 初始化引用溯源系统 ===")

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
encoder = SentenceTransformer('all-MiniLM-L6-v2')
nli_model = CrossEncoder('cross-encoder/nli-deberta-v3-base')

print("✓ 系统初始化完成\n")

# ===== 准备文档 =====
docs = [
    {
        "content": "Python 3.9 于 2020 年 10 月 5 日正式发布，这是一个重要的版本更新。",
        "title": "Python 3.9 发布公告",
        "url": "https://www.python.org/downloads/release/python-390/"
    },
    {
        "content": "Python 3.9 新增了字典合并运算符 |，可以方便地合并两个字典。例如：d1 | d2",
        "title": "PEP 584 - 字典合并运算符",
        "url": "https://peps.python.org/pep-0584/"
    },
    {
        "content": "Python 3.9 改进了类型提示功能，支持使用内置集合类型（如 list、dict）作为泛型。",
        "title": "PEP 585 - 标准集合中的类型提示泛型",
        "url": "https://peps.python.org/pep-0585/"
    }
]

query = "Python 3.9 有什么新特性？"

# ===== 步骤1：生成带引用的答案 =====
print("=== 步骤1：生成带引用的答案 ===")

numbered_docs = "\n\n".join([
    f"文档{i+1}：{doc['content']}"
    for i, doc in enumerate(docs)
])

prompt = f"""基于以下文档回答问题，并用 [1], [2] 标注引用来源：

{numbered_docs}

问题：{query}

要求：每个事实性陈述都要标注来源。

答案："""

response = client.chat.completions.create(
    model="gpt-4",
    messages=[{"role": "user", "content": prompt}],
    temperature=0.3
)

answer = response.choices[0].message.content
print(f"生成答案：\n{answer}\n")

# ===== 步骤2：提取引用 =====
print("=== 步骤2：提取引用 ===")

citations = re.findall(r'\[(\d+)\]', answer)
citations = [int(c) for c in citations]

print(f"提取到的引用：{citations}")
print(f"引用数量：{len(set(citations))}\n")

# ===== 步骤3：验证引用有效性 =====
print("=== 步骤3：验证引用有效性 ===")

# 检查引用是否在有效范围内
invalid_citations = [c for c in citations if c > len(docs) or c < 1]

if invalid_citations:
    print(f"✗ 发现无效引用：{invalid_citations}")
else:
    print("✓ 所有引用都有效")

# 检查是否有未使用的文档
used_docs = set(citations)
unused_docs = set(range(1, len(docs) + 1)) - used_docs

if unused_docs:
    print(f"⚠ 未使用的文档：{unused_docs}")
else:
    print("✓ 所有文档都被引用")

print()

# ===== 步骤4：验证引用内容的一致性 =====
print("=== 步骤4：验证引用内容的一致性 ===")

# 提取每个引用对应的句子
sentences_with_citations = re.findall(r'([^。]+\[\d+\])', answer)

for sentence_with_citation in sentences_with_citations:
    # 提取句子和引用编号
    match = re.search(r'(.+)\[(\d+)\]', sentence_with_citation)
    if match:
        sentence = match.group(1).strip()
        citation_num = int(match.group(2))

        # 获取引用的文档
        cited_doc = docs[citation_num - 1]['content']

        # 使用 NLI 检查一致性
        scores = nli_model.predict([(cited_doc, sentence)])
        entailment_score = scores[0][2]

        status = "✓" if entailment_score >= 0.7 else "✗"
        print(f"{status} 引用[{citation_num}]: {sentence}")
        print(f"   一致性分数: {entailment_score:.2f}\n")

# ===== 步骤5：生成最终输出 =====
print("=== 步骤5：生成最终输出 ===")

final_answer = answer + "\n\n来源详情：\n"
for i, doc in enumerate(docs):
    if (i + 1) in used_docs:
        final_answer += f"[{i+1}] {doc['title']}\n"
        final_answer += f"     {doc['url']}\n"

print(final_answer)
```

---

## 关键要点

### 1. 引用格式选择

**推荐格式：**
- 简单场景：`[1]`, `[2]`
- 学术场景：`(作者, 年份)`
- 法律场景：`《XX法》第X条`

### 2. 引用粒度

**三个层次：**
- 文档级：整个答案引用一个文档
- 句子级：每个句子引用一个文档（推荐）
- 事实级：每个事实引用一个文档（最精细）

### 3. 引用验证

**必须验证：**
- 引用编号是否有效
- 引用内容是否一致
- 是否有遗漏的引用

### 4. 用户体验

**优化建议：**
- 提供可点击的引用链接
- 悬停显示引用内容预览
- 支持引用折叠/展开

---

## 总结

**引用溯源系统的核心价值：**

1. **可验证性**：用户可以验证答案来源
2. **可信度**：有引用的答案更可信
3. **责任追溯**：出错时可以追溯来源

**实现方式：**

- Prompt 工程（简单易用）
- 后处理提取（更准确）
- 混合方式（最佳实践）

**在 RAG 开发中的应用：**

- 学术问答系统
- 法律文档分析
- 医疗信息检索
- 任何需要可验证性的场景

**记住：**

> **引用不等于准确，需要结合一致性检测验证引用内容是否正确。**
>
> **引用溯源是建立用户信任的关键，但不是唯一方法。**
