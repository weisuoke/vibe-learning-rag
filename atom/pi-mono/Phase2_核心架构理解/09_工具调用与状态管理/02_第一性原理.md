# 第一性原理

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题，而不是通过类比或经验推理。

---

## 工具调用与状态管理的第一性原理

### 1. 最基础的定义

**工具调用 = 让 LLM 能够执行外部操作的机制**

**状态管理 = 让 Agent 能够记住历史交互的机制**

仅此而已！没有更基础的了。

LLM 本身只能生成文本，无法读取文件、执行命令、访问数据库。工具调用赋予了 LLM "手脚"，让它能与外部世界交互。

状态管理让 Agent 能够记住之前说过的话、做过的事，形成连续的对话体验。

---

### 2. 为什么需要工具调用与状态管理？

#### 核心问题1：LLM 的能力边界

**问题：** LLM 只能生成文本，无法执行实际操作。

```
用户: "帮我读取 config.json 文件"
LLM (无工具): "我无法直接读取文件，但你可以用 cat config.json 命令..."
LLM (有工具): [调用 read 工具] "文件内容是: {...}"
```

**第一性原理推导：**
- LLM = 文本生成器
- 实际任务需要外部操作（文件、网络、数据库）
- 因此需要：**工具调用机制**

#### 核心问题2：对话的连续性

**问题：** 每次 LLM 调用都是独立的，无法记住历史。

```
用户: "我叫张三"
LLM: "你好，张三！"

用户: "我叫什么名字？"
LLM (无状态): "抱歉，我不知道你的名字"
LLM (有状态): "你叫张三"
```

**第一性原理推导：**
- LLM = 无状态函数（输入 → 输出）
- 对话需要上下文连续性
- 因此需要：**状态管理机制**

---

### 3. 工具调用与状态管理的三层价值

#### 价值1：扩展 LLM 能力边界

**工具调用让 LLM 从"只能说"变成"能做"。**

```typescript
// 没有工具：只能生成建议
const response = await llm.generate("如何修复这个 bug？");
// 输出: "你可以尝试修改第 10 行..."

// 有工具：可以直接修复
const response = await agent.run("修复这个 bug");
// 执行: read(file) → analyze → edit(file, fix) → test
```

**类比：** 就像给盲人配上了眼睛（read 工具）、给哑巴配上了嘴巴（write 工具）。

#### 价值2：实现可靠的执行

**Schema + 验证 + 自纠正 = 可靠的工具调用。**

```typescript
// 问题：LLM 可能生成错误参数
{
  "path": "/etc/passwd",  // 危险路径
  "mode": "delete"        // 错误的参数名
}

// 解决：Schema 验证 + 自纠正
1. Schema 定义约束（path 必须在工作目录内）
2. AJV 验证拦截错误参数
3. 错误信息返回给 LLM
4. LLM 自动修正（80% 成功率）[3]
```

**类比：** 就像给工具加上了"安全锁"，防止误操作。

#### 价值3：保持对话连续性

**状态管理让 Agent 拥有"记忆"。**

```typescript
// 没有状态：每次都是新对话
用户: "创建一个 React 组件"
Agent: [创建 Button.tsx]

用户: "给它加个点击事件"
Agent: "给什么加点击事件？"  // 忘记了之前的上下文

// 有状态：记住历史
用户: "创建一个 React 组件"
Agent: [创建 Button.tsx，记录到状态]

用户: "给它加个点击事件"
Agent: [读取状态，知道是 Button.tsx] [修改文件]
```

**类比：** 就像给 Agent 配上了"笔记本"，随时记录和查阅。

---

### 4. 从第一性原理推导 Pi-mono 的设计

**推理链：**

```
1. LLM 只能生成文本，需要工具调用扩展能力
   ↓
2. 工具调用需要定义参数格式（Schema）
   ↓
3. Schema 需要被 LLM 理解（JSON Schema）和被代码验证（TypeScript 类型）
   ↓
4. TypeBox 同时满足两个需求（生成 JSON Schema + 推导 TS 类型）
   ↓
5. 验证失败不应该崩溃，而应该让 LLM 自纠正
   ↓
6. 因此：返回错误信息给 LLM，而不是抛出异常
   ↓
7. 对话需要连续性，需要状态管理
   ↓
8. 状态需要持久化（崩溃恢复）和高性能（频繁写入）
   ↓
9. JSONL 追加写入满足两个需求（O(1) 写入 + 完整历史）
   ↓
10. 对话可能有分支（用户回退重试），需要树形结构
    ↓
11. 因此：每条消息记录 parentId，形成树形结构
    ↓
12. 最终设计：TypeBox Schema + AJV 验证 + 自纠正 + JSONL 树形存储
```

---

### 5. 从第一性原理推导工具执行流程

**推理链：**

```
1. LLM 生成工具调用请求（JSON 格式）
   ↓
2. 需要解析 JSON（可能格式错误）
   ↓
3. 需要验证参数（可能不符合 Schema）
   ↓
4. 验证失败 → 返回错误给 LLM（自纠正）
   ↓
5. 验证成功 → 执行工具
   ↓
6. 工具可能失败（文件不存在、权限不足）
   ↓
7. 失败 → 返回错误信息给 LLM（让它处理）
   ↓
8. 成功 → 返回结果给 LLM
   ↓
9. LLM 根据结果决定下一步（继续调用工具 or 返回用户）
   ↓
10. 整个过程记录到状态（JSONL 追加）
    ↓
11. 最终流程：Parse → Validate → Execute → Return → Record
```

---

### 6. 从第一性原理推导状态持久化方案

**推理链：**

```
1. 对话历史需要持久化（崩溃恢复）
   ↓
2. 写入频率高（每条消息都要记录）
   ↓
3. 传统方案：读取整个 JSON → 修改 → 写回（O(n) 性能）
   ↓
4. 性能瓶颈：文件越大，读写越慢
   ↓
5. 优化思路：能否只追加，不读取？
   ↓
6. JSONL 格式：每行一个 JSON 对象，支持追加
   ↓
7. 追加写入 = O(1) 性能，不受文件大小影响
   ↓
8. 但如何支持分支（用户回退重试）？
   ↓
9. 树形结构：每条消息记录 parentId
   ↓
10. 读取时：从叶子节点回溯到根节点，重建对话历史
    ↓
11. 最终方案：JSONL 追加 + parentId 树形结构
```

---

### 7. 从第一性原理推导自纠正机制

**推理链：**

```
1. LLM 可能生成错误的工具调用参数
   ↓
2. 传统方案：抛出异常 → Agent 崩溃 → 需要人工修复
   ↓
3. 问题：人工修复成本高，用户体验差
   ↓
4. 观察：LLM 能理解错误信息并修正（类似人类）
   ↓
5. 优化思路：能否让 LLM 自己修正错误？
   ↓
6. 实现：验证失败 → 返回错误信息给 LLM（不抛异常）
   ↓
7. LLM 看到错误 → 理解问题 → 生成修正后的参数
   ↓
8. 实测：80% 的错误能在下一轮自动修正 [3]
   ↓
9. 最终机制：错误即反馈，让 LLM 从错误中学习
```

---

### 8. 一句话总结第一性原理

**工具调用是 LLM 与外部世界交互的桥梁，状态管理是 Agent 的记忆系统，两者通过 Schema 约束、验证反馈和追加持久化实现可靠性和高性能。**

---

## 第一性原理的实践价值

### 理解设计决策

当你看到 pi-mono 的代码时，可以从第一性原理理解为什么这样设计：

- **为什么用 TypeBox 而不是 Zod？** → 因为需要同时生成 JSON Schema（给 LLM）和 TS 类型（给代码），TypeBox 更轻量 [4]
- **为什么验证失败返回错误而不是抛异常？** → 因为 LLM 能自纠正，抛异常会中断流程
- **为什么用 JSONL 而不是 JSON？** → 因为追加写入是 O(1)，JSON 需要读取整个文件
- **为什么需要 parentId？** → 因为对话有分支，需要树形结构

### 指导自定义开发

当你需要扩展 pi-mono 时，可以从第一性原理思考：

- **添加新工具？** → 定义 Schema → 实现 execute 函数 → 注册到 registry
- **优化性能？** → 分析瓶颈（验证？执行？持久化？）→ 针对性优化
- **支持新场景？** → 从需求出发 → 推导必要的机制 → 最小化实现

---

**参考文献：**
- [3] Microsoft Agent-Lightning: https://github.com/microsoft/agent-lightning
- [4] TypeBox vs Zod: https://github.com/colinhacks/zod/issues/2482
