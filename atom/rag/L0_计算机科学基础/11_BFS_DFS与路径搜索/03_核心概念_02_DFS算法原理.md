# 核心概念 02：DFS 算法原理

## 一句话定义

**DFS（深度优先搜索）是使用栈或递归实现的深度探索算法，沿着一条路径尽可能深入直到无路可走再回溯，适合路径探索和推理链构建。**

---

## 核心思想

DFS 的核心思想可以用一个简单的比喻理解：

**想象你在一个迷宫中探险：**
- 你选择一条路一直走下去
- 走到死胡同时，退回上一个岔路口
- 选择另一条未走过的路继续深入
- 重复这个过程，直到探索完所有路径

这就是 **回溯（Backtracking）** 的思想。

---

## 算法实现

### 1. 递归实现（推荐，最自然）

```python
from typing import Dict, List, Set

def dfs_recursive(graph: Dict[str, List[str]], start: str, visited: Set[str] = None) -> List[str]:
    """
    DFS 递归实现

    参数:
        graph: 邻接表表示的图
        start: 起始节点
        visited: 已访问节点集合（递归间共享）

    返回:
        按 DFS 顺序访问的节点列表
    """
    # 1. 初始化 visited（首次调用时）
    if visited is None:
        visited = set()

    # 2. 标记当前节点为已访问
    visited.add(start)
    result = [start]

    # 3. 递归访问所有未访问的邻居
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            # 递归调用，深入探索
            result.extend(dfs_recursive(graph, neighbor, visited))

    return result
```

**关键点：**
1. **递归调用**：自然地实现了"深入-回溯"的过程
2. **visited 共享**：所有递归调用共享同一个 visited 集合
3. **回溯自动**：函数返回时自动回溯到上一层

**递归过程可视化：**
```
图结构：
    A
   / \
  B   C
 / \
D   E

递归调用栈：
dfs(A) → 访问 A
  ├─ dfs(B) → 访问 B
  │   ├─ dfs(D) → 访问 D，返回
  │   └─ dfs(E) → 访问 E，返回
  └─ dfs(C) → 访问 C，返回

输出：A → B → D → E → C
```

---

### 2. 迭代实现（使用栈）

```python
def dfs_iterative(graph: Dict[str, List[str]], start: str) -> List[str]:
    """
    DFS 迭代实现（使用显式栈）

    返回:
        按 DFS 顺序访问的节点列表
    """
    visited = set()
    stack = [start]  # 使用 list 作为栈（LIFO）
    result = []

    while stack:
        # 1. 弹出栈顶节点
        node = stack.pop()  # O(1) 时间复杂度

        # 2. 如果未访问，处理该节点
        if node not in visited:
            visited.add(node)
            result.append(node)

            # 3. 将所有未访问的邻居压入栈
            # 注意：反向压入以保持与递归相同的顺序
            for neighbor in reversed(graph.get(node, [])):
                if neighbor not in visited:
                    stack.append(neighbor)

    return result
```

**关键点：**
1. **栈（LIFO）**：后进先出，模拟递归调用栈
2. **反向压入**：保持与递归版本相同的访问顺序
3. **出栈时标记**：节点出栈时才标记为已访问

**为什么反向压入？**
```python
# 不反向：
graph = {'A': ['B', 'C']}
stack.extend(['B', 'C'])  # 栈：[B, C]
stack.pop()  # 先访问 C

# 反向：
stack.extend(reversed(['B', 'C']))  # 栈：[C, B]
stack.pop()  # 先访问 B（与递归一致）
```

---

### 3. 路径记录版本

```python
def dfs_with_path(graph: Dict[str, List[str]], start: str, target: str) -> List[str]:
    """
    DFS 查找路径（不保证最短）

    返回:
        从 start 到 target 的一条路径，如果不存在返回 []
    """
    def dfs_helper(node: str, target: str, visited: Set[str], path: List[str]) -> bool:
        """
        递归辅助函数

        返回:
            是否找到目标节点
        """
        # 1. 标记当前节点
        visited.add(node)
        path.append(node)

        # 2. 找到目标
        if node == target:
            return True

        # 3. 递归探索邻居
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs_helper(neighbor, target, visited, path):
                    return True  # 找到路径，停止搜索

        # 4. 回溯：移除当前节点
        path.pop()
        return False

    visited = set()
    path = []

    if dfs_helper(start, target, visited, path):
        return path
    return []
```

**回溯机制：**
```
搜索路径：A → B → D（死胡同）
回溯：移除 D，回到 B
继续：B → E（找到目标）
最终路径：A → B → E
```

---

## 复杂度分析

### 时间复杂度：O(V + E)

**V = 节点数，E = 边数**

**分析：**
- 每个节点访问一次：O(V)
- 每条边检查一次：O(E)
- 总时间：O(V + E)

**与 BFS 相同！** 只是访问顺序不同。

---

### 空间复杂度：O(h)

**h = 递归深度（树高）**

**递归版本：**
- 递归调用栈：O(h)
- visited 集合：O(V)
- 总空间：O(V + h) ≈ O(V)

**迭代版本：**
- 显式栈：O(h)
- visited 集合：O(V)
- 总空间：O(V + h) ≈ O(V)

**最坏情况：链状图**
```
A → B → C → D → E

递归深度 = 5
栈最大长度 = 5
空间复杂度 = O(5) = O(V)
```

**最好情况：完全二叉树**
```
递归深度 = log(V)
栈最大长度 = log(V)
空间复杂度 = O(log V)
```

**DFS vs BFS 空间对比：**
| 图结构 | DFS 空间 | BFS 空间 |
|--------|----------|----------|
| 链状图 | O(V) | O(1) |
| 完全二叉树 | O(log V) | O(V) |
| 宽而浅的图 | O(log V) | O(V) |
| 窄而深的图 | O(V) | O(1) |

---

## DFS 的关键特性

### 特性1：深度优先

**DFS 沿着一条路径尽可能深入，直到无路可走再回溯**

**可视化：**
```
图结构：
    A
   / \
  B   C
 / \   \
D   E   F

DFS 访问顺序：
A → B → D（深入到底）
    ↓ 回溯到 B
    E（继续深入）
    ↓ 回溯到 A
    C → F

输出：A → B → D → E → C → F
```

**对比 BFS：**
```
BFS 访问顺序：
层级0: A
层级1: B, C
层级2: D, E, F

输出：A → B → C → D → E → F
```

---

### 特性2：路径探索

**DFS 自然地表达"路径"的概念，适合路径相关问题**

**应用场景：**
- 找到从起点到终点的任意路径
- 检测图中是否存在环
- 拓扑排序（处理依赖关系）
- 连通分量检测

**示例：检测环**
```python
def has_cycle(graph: Dict[str, List[str]]) -> bool:
    """
    使用 DFS 检测有向图中是否存在环

    原理：如果在 DFS 过程中遇到"正在访问"的节点，说明存在环
    """
    WHITE = 0  # 未访问
    GRAY = 1   # 正在访问（在当前路径上）
    BLACK = 2  # 已完成

    color = {node: WHITE for node in graph}

    def dfs(node: str) -> bool:
        color[node] = GRAY  # 标记为正在访问

        for neighbor in graph.get(node, []):
            if color[neighbor] == GRAY:
                return True  # 遇到正在访问的节点，存在环
            if color[neighbor] == WHITE:
                if dfs(neighbor):
                    return True

        color[node] = BLACK  # 标记为已完成
        return False

    for node in graph:
        if color[node] == WHITE:
            if dfs(node):
                return True

    return False
```

---

### 特性3：回溯机制

**DFS 的回溯机制使其适合"尝试-撤销"类问题**

**应用场景：**
- 排列组合生成
- 数独求解
- N 皇后问题
- 路径搜索（找所有路径）

**示例：找所有路径**
```python
def find_all_paths(graph: Dict[str, List[str]], start: str, target: str) -> List[List[str]]:
    """
    找到从 start 到 target 的所有路径

    使用回溯机制：
    - 尝试一条路径
    - 如果不通，回溯并尝试其他路径
    """
    all_paths = []

    def dfs(node: str, path: List[str], visited: Set[str]):
        # 1. 添加当前节点到路径
        path.append(node)
        visited.add(node)

        # 2. 找到目标，记录路径
        if node == target:
            all_paths.append(path[:])  # 复制路径
        else:
            # 3. 继续探索
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    dfs(neighbor, path, visited)

        # 4. 回溯：移除当前节点
        path.pop()
        visited.remove(node)

    dfs(start, [], set())
    return all_paths
```

**回溯过程：**
```
图：A → B → D
    A → C → D

搜索过程：
1. A → B → D（找到路径1）
2. 回溯到 B，无其他邻居
3. 回溯到 A
4. A → C → D（找到路径2）

结果：[[A, B, D], [A, C, D]]
```

---

## 在 RAG 中的应用

### 应用1：推理链构建（KG2RAG）

**场景：** 组织连贯的推理段落

```python
def dfs_organize_chunks(kg, entities: List[str], max_depth: int = 3) -> List[List[str]]:
    """
    使用 DFS 组织连贯的推理链

    应用：KG2RAG 的第二步（深度组织）

    原理：
    - DFS 沿着关系链深入探索
    - 每条路径形成一个连贯的推理段落
    """
    organized = []
    visited = set()

    def dfs_path(entity: str, path: List[str], depth: int):
        """构建从 entity 出发的推理路径"""
        if depth >= max_depth or entity in visited:
            return

        visited.add(entity)
        path.append(entity)

        # 获取邻居实体
        neighbors = kg.get_neighbors(entity)

        if not neighbors or depth == max_depth - 1:
            # 到达叶子节点或最大深度，保存路径
            organized.append(path[:])
        else:
            # 继续深入（只选择一个邻居，形成单一路径）
            for neighbor in neighbors:
                if neighbor not in visited:
                    dfs_path(neighbor, path, depth + 1)
                    break  # 只沿着一条路径深入

        path.pop()  # 回溯

    # 从每个实体出发构建路径
    for entity in entities:
        if entity not in visited:
            dfs_path(entity, [], 0)

    return organized
```

**实际效果：**
```
输入实体：[Einstein, 相对论, 光电效应]

DFS 组织结果：
路径1：Einstein → 相对论 → 时空弯曲 → 引力波探测
路径2：Einstein → 光电效应 → 量子力学 → 半导体
路径3：相对论 → GPS技术 → 现代导航

每条路径是连贯的推理链，避免碎片化
```

**来源：** KG2RAG (NAACL 2025) - https://arxiv.org/abs/2502.06864

---

### 应用2：因果推理（Agentic Graph RAG）

**场景：** 深度探索因果关系链

```python
def causal_reasoning_dfs(kg, query: str, max_depth: int = 5) -> List[str]:
    """
    使用 DFS 进行因果推理

    应用：Agentic Graph RAG 的因果查询处理

    原理：
    - 因果关系通常是链状的（A → B → C）
    - DFS 适合沿着因果链深入探索
    """
    # 提取查询中的实体
    entities = kg.extract_entities(query)

    # 识别因果关系类型的边
    causal_relations = ['causes', 'leads_to', 'results_in', 'influences']

    def dfs_causal(entity: str, depth: int, visited: Set[str], path: List[str]) -> List[str]:
        """沿着因果链深入探索"""
        if depth >= max_depth or entity in visited:
            return path

        visited.add(entity)
        path.append(entity)

        # 只沿着因果关系边探索
        for relation, neighbor in kg.get_neighbors_with_relation(entity):
            if relation in causal_relations and neighbor not in visited:
                # 深入探索因果链
                return dfs_causal(neighbor, depth + 1, visited, path)

        return path

    # 从每个实体出发构建因果链
    causal_chains = []
    for entity in entities:
        chain = dfs_causal(entity, 0, set(), [])
        if len(chain) > 1:  # 至少有2个节点才是有效的因果链
            causal_chains.append(chain)

    return causal_chains
```

**实际效果：**
```
查询："为什么 Python 成为 AI 开发的首选语言？"

DFS 因果推理：
Python → 简洁语法 → 快速原型开发 → 科学计算社区 → NumPy/Pandas → AI 生态

每一步都是因果关系，形成完整的推理链
```

**来源：** Agentic Graph RAG (2025) - https://pmc.ncbi.nlm.nih.gov/articles/PMC12748213

---

### 应用3：ARK 框架的深度扩展

**场景：** 按需深度探索邻域

```python
def ark_depth_expansion(kg, entity: str, llm) -> List[str]:
    """
    ARK 框架的深度扩展（DFS 风格）

    原理：
    - 从候选实体出发
    - 深入探索 1-hop 邻域
    - LLM 决定是否继续深入
    """
    expanded = [entity]
    visited = {entity}

    def dfs_expand(current: str, depth: int):
        """递归扩展邻域"""
        if depth >= 3:  # 最大深度限制
            return

        neighbors = kg.get_neighbors(current)

        for neighbor in neighbors:
            if neighbor not in visited:
                visited.add(neighbor)
                expanded.append(neighbor)

                # LLM 决定是否继续深入
                decision = llm.should_expand(neighbor, expanded)
                if decision == "expand":
                    dfs_expand(neighbor, depth + 1)

    dfs_expand(entity, 0)
    return expanded
```

**来源：** ARK (2026.01) - https://arxiv.org/abs/2601.13969

---

## 常见变体

### 1. 前序/中序/后序遍历

**在树结构中，DFS 有三种遍历顺序：**

```python
class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder(root: TreeNode) -> List[int]:
    """前序遍历：根 → 左 → 右"""
    if not root:
        return []
    return [root.val] + preorder(root.left) + preorder(root.right)

def inorder(root: TreeNode) -> List[int]:
    """中序遍历：左 → 根 → 右"""
    if not root:
        return []
    return inorder(root.left) + [root.val] + inorder(root.right)

def postorder(root: TreeNode) -> List[int]:
    """后序遍历：左 → 右 → 根"""
    if not root:
        return []
    return postorder(root.left) + postorder(root.right) + [root.val]
```

**应用：**
- 前序：复制树结构
- 中序：二叉搜索树的有序遍历
- 后序：删除树节点（先删子节点再删父节点）

---

### 2. 迭代加深 DFS（IDDFS）

**结合 BFS 和 DFS 的优点：**

```python
def iddfs(graph: Dict[str, List[str]], start: str, target: str, max_depth: int = 10) -> List[str]:
    """
    迭代加深 DFS

    优点：
    - 像 BFS 一样保证最短路径
    - 像 DFS 一样节省空间
    """
    def dfs_limited(node: str, target: str, depth: int, visited: Set[str], path: List[str]) -> bool:
        """限制深度的 DFS"""
        if node == target:
            return True

        if depth == 0:
            return False  # 达到深度限制

        visited.add(node)
        path.append(node)

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs_limited(neighbor, target, depth - 1, visited, path):
                    return True

        path.pop()
        visited.remove(node)
        return False

    # 逐步增加深度限制
    for depth in range(max_depth + 1):
        visited = set()
        path = []
        if dfs_limited(start, target, depth, visited, path):
            return path

    return []
```

**时间复杂度：** O(b^d)，但常数因子较小
**空间复杂度：** O(d)，与 DFS 相同

---

### 3. 拓扑排序

**使用 DFS 进行拓扑排序（处理依赖关系）：**

```python
def topological_sort(graph: Dict[str, List[str]]) -> List[str]:
    """
    拓扑排序（DFS 实现）

    应用：
    - 任务调度（先完成依赖任务）
    - 编译顺序（先编译依赖模块）
    - 课程安排（先修课程）
    """
    visited = set()
    stack = []

    def dfs(node: str):
        visited.add(node)

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor)

        # 后序位置：所有依赖都已处理
        stack.append(node)

    for node in graph:
        if node not in visited:
            dfs(node)

    return stack[::-1]  # 反转得到拓扑序
```

**示例：**
```
依赖关系：
A → B（A 依赖 B）
A → C
B → D
C → D

拓扑序：D → B → C → A
（先完成 D，再完成 B 和 C，最后完成 A）
```

---

## 实战技巧

### 技巧1：递归 vs 迭代的选择

```python
# ✅ 推荐：简单场景用递归
def dfs_simple(graph, start):
    visited = set()

    def dfs(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)

    dfs(start)

# ✅ 推荐：深度很大时用迭代（避免栈溢出）
def dfs_deep(graph, start):
    stack = [start]
    visited = set()

    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            stack.extend(graph[node])
```

**选择标准：**
- 递归：代码简洁，适合深度 < 1000
- 迭代：避免栈溢出，适合深度 > 1000

---

### 技巧2：避免重复访问

```python
# ❌ 错误：没有 visited 标记
def bad_dfs(graph, node):
    print(node)
    for neighbor in graph[node]:
        bad_dfs(graph, neighbor)  # 可能无限递归

# ✅ 正确：使用 visited 集合
def good_dfs(graph, node, visited=None):
    if visited is None:
        visited = set()

    if node in visited:
        return

    visited.add(node)
    print(node)

    for neighbor in graph[node]:
        good_dfs(graph, neighbor, visited)
```

---

### 技巧3：路径记录的回溯

```python
# ❌ 错误：忘记回溯
def bad_path_dfs(graph, node, path):
    path.append(node)
    # ... 递归 ...
    # 忘记 path.pop()，导致路径错误

# ✅ 正确：记得回溯
def good_path_dfs(graph, node, path, visited):
    path.append(node)
    visited.add(node)

    # ... 递归 ...

    path.pop()  # 回溯
    visited.remove(node)  # 回溯
```

---

## DFS vs BFS 总结

| 维度 | DFS | BFS |
|------|-----|-----|
| **数据结构** | 栈（LIFO）或递归 | 队列（FIFO） |
| **遍历顺序** | 深度优先（一条路走到底） | 层序（先近后远） |
| **最短路径** | ❌ 不保证 | ✅ 保证最短 |
| **空间复杂度** | O(h) 递归深度 | O(V) 需要存储整层 |
| **适用场景** | 路径探索、深度推理、回溯 | 最短路径、广度检索 |
| **RAG 应用** | 推理链构建、因果探索 | 邻域扩展、候选检索 |
| **实现难度** | 递归简单，迭代稍复杂 | 迭代简单 |

---

## 学习检查

理解了 DFS 算法原理后，你应该能回答：

- [ ] DFS 使用什么数据结构？（栈或递归）
- [ ] DFS 的时间复杂度是多少？（O(V + E)）
- [ ] DFS 为什么不保证最短路径？（深度优先，不是层序）
- [ ] 什么是回溯？（尝试-撤销机制）
- [ ] DFS 在 RAG 中的应用场景？（推理链构建、因果推理）

---

## 下一步

学完 DFS 算法原理后，建议继续学习：
1. `03_核心概念_03_遍历策略对比.md` - 深入对比 BFS 和 DFS
2. `03_核心概念_04_路径重建技术.md` - 学习路径重建
3. `07_实战代码_场景1_基础BFS_DFS实现.md` - 动手实践

---

**版本：** v1.0
**最后更新：** 2026-02-14
**参考文献：**
- KG2RAG (NAACL 2025): https://arxiv.org/abs/2502.06864
- Agentic Graph RAG (2025): https://pmc.ncbi.nlm.nih.gov/articles/PMC12748213
- ARK (2026.01): https://arxiv.org/abs/2601.13969
