# Agent执行器 - 核心概念2：工具调用机制

> 深入理解 Agent 如何选择和调用工具

---

## 什么是工具调用机制？

**工具调用机制**是 Agent 能够执行外部操作的核心能力，它让 LLM 从"只能生成文本"升级为"能够执行操作"。

**核心流程**：
```
LLM 决策 → 选择工具 → 解析参数 → 执行工具 → 返回结果
```

---

## 工具的本质

### 工具 = 函数 + 描述

```python
# 最基础的工具定义
class Tool:
    def __init__(self, name: str, description: str, func: callable):
        self.name = name              # 工具名称（唯一标识）
        self.description = description  # 工具描述（给 LLM 看）
        self.func = func              # 实际执行的函数

    def run(self, input: str) -> str:
        """执行工具"""
        return self.func(input)
```

**三个核心要素**：
1. **name**：工具的唯一标识（如 `query_order`）
2. **description**：告诉 LLM 这个工具是干什么的（最重要！）
3. **func**：实际执行的函数

---

## 工具定义的三种方式

### 方式1：使用 @tool 装饰器（推荐）

```python
from langchain.tools import tool

@tool
def query_order(order_id: str) -> str:
    """
    查询订单信息

    输入：订单ID（字符串，如 '12345'）
    输出：订单状态和预计到达时间
    """
    # 实际查询逻辑
    orders = {
        "12345": "订单已发货，预计明天到达",
        "67890": "订单已签收",
    }
    return orders.get(order_id, "订单不存在")
```

**优点**：
- 简洁，只需要一个装饰器
- 自动从函数签名提取参数信息
- 自动从 docstring 提取描述

**关键要求**：
- 必须有类型注解（`order_id: str`）
- 必须有返回类型注解（`-> str`）
- 必须有 docstring（工具描述）

---

### 方式2：使用 Tool 类

```python
from langchain.tools import Tool

def query_order_impl(order_id: str) -> str:
    """实际的查询逻辑"""
    orders = {
        "12345": "订单已发货，预计明天到达",
        "67890": "订单已签收",
    }
    return orders.get(order_id, "订单不存在")

# 创建工具
query_order_tool = Tool(
    name="query_order",
    description="查询订单信息，输入订单ID，返回订单状态",
    func=query_order_impl,
)
```

**优点**：
- 更灵活，可以自定义所有参数
- 可以包装现有函数

**缺点**：
- 代码更冗长
- 需要手动编写描述

---

### 方式3：使用 StructuredTool（复杂参数）

```python
from langchain.tools import StructuredTool
from pydantic import BaseModel, Field

# 定义参数模型
class QueryOrderInput(BaseModel):
    order_id: str = Field(description="订单ID")
    include_logistics: bool = Field(default=False, description="是否包含物流信息")

def query_order_impl(order_id: str, include_logistics: bool = False) -> str:
    """查询订单信息"""
    result = f"订单 {order_id} 已发货"
    if include_logistics:
        result += "，物流信息：预计明天到达"
    return result

# 创建工具
query_order_tool = StructuredTool(
    name="query_order",
    description="查询订单信息",
    func=query_order_impl,
    args_schema=QueryOrderInput,
)
```

**优点**：
- 支持复杂参数（多个参数、可选参数、默认值）
- 参数验证更严格

**适用场景**：
- 工具需要多个参数
- 参数有复杂的验证规则

---

## 工具描述的重要性

### 为什么工具描述如此重要？

**LLM 选择工具的唯一依据就是工具描述！**

```python
# 场景：用户问"订单12345什么时候到？"

# LLM 的决策过程：
1. 读取所有工具的描述
2. 理解用户问题
3. 匹配最合适的工具
4. 生成工具调用指令
```

**如果描述不清晰，LLM 会选择错误的工具！**

---

### 好的工具描述 vs 差的工具描述

#### ❌ 差的工具描述

```python
@tool
def query(id: str) -> str:
    """查询"""  # 太简单，LLM 不知道这是干什么的
    return "结果"

@tool
def get_data(param: str) -> str:
    """获取数据"""  # 太模糊，什么数据？
    return "数据"

@tool
def tool1(x: str) -> str:
    """工具1"""  # 完全没有信息
    return "结果"
```

**问题**：
- 描述太简单，LLM 不知道什么时候用
- 没有说明输入和输出
- 没有说明适用场景

---

#### ✅ 好的工具描述

```python
@tool
def query_order(order_id: str) -> str:
    """
    查询订单信息

    功能：根据订单ID查询订单状态和物流信息

    输入：
    - order_id: 订单ID（字符串，如 '12345'）

    输出：
    - 订单状态（如 '已发货'、'已签收'）
    - 预计到达时间（如 '预计明天到达'）

    适用场景：
    - 用户询问"订单什么时候到"
    - 用户询问"订单状态"
    - 用户提供订单ID

    示例：
    输入：'12345'
    输出：'订单已发货，预计明天到达'
    """
    orders = {
        "12345": "订单已发货，预计明天到达",
        "67890": "订单已签收",
    }
    return orders.get(order_id, "订单不存在")
```

**优点**：
- 清晰说明功能
- 详细说明输入和输出
- 提供适用场景
- 给出示例

---

### 工具描述的最佳实践

**模板**：

```python
@tool
def tool_name(param: str) -> str:
    """
    [一句话功能描述]

    功能：[详细功能说明]

    输入：
    - param1: [参数说明]
    - param2: [参数说明]

    输出：
    - [输出说明]

    适用场景：
    - [场景1]
    - [场景2]

    注意事项：
    - [注意事项1]
    - [注意事项2]

    示例：
    输入：[示例输入]
    输出：[示例输出]
    """
    # 实现...
```

**关键要素**：
1. **一句话功能描述**：让 LLM 快速理解
2. **详细功能说明**：说明这个工具是干什么的
3. **输入说明**：每个参数的含义和格式
4. **输出说明**：返回什么结果
5. **适用场景**：什么时候应该用这个工具
6. **注意事项**：特殊情况和限制
7. **示例**：具体的输入输出示例

---

## LLM 如何选择工具？

### 选择过程

```python
# LLM 的决策过程

# 1. 读取用户问题
question = "订单12345什么时候到？"

# 2. 读取所有工具的描述
tools_description = """
1. query_order: 查询订单信息，输入订单ID，返回订单状态
2. query_inventory: 查询库存信息，输入产品ID，返回库存数量
3. calculate: 计算数学表达式，输入表达式，返回计算结果
"""

# 3. LLM 推理
prompt = f"""
用户问题：{question}
可用工具：{tools_description}

请选择最合适的工具并说明原因。
"""

# 4. LLM 输出
response = """
Thought: 用户询问订单状态，需要查询订单信息
Action: query_order
Action Input: 12345
"""
```

**选择依据**：
1. **工具描述**：最重要的依据
2. **用户问题**：理解用户的意图
3. **当前上下文**：之前的执行结果

---

### 影响选择准确性的因素

#### 1. 工具描述的清晰度

```python
# ❌ 描述不清晰，LLM 可能选错
@tool
def query(id: str) -> str:
    """查询"""
    return "结果"

# ✅ 描述清晰，LLM 容易选对
@tool
def query_order(order_id: str) -> str:
    """查询订单信息，输入订单ID，返回订单状态"""
    return "结果"
```

---

#### 2. 工具数量

```python
# ❌ 工具太多，LLM 选择困难
tools = [tool1, tool2, ..., tool20]  # 20个工具

# ✅ 工具数量合理，LLM 容易选择
tools = [tool1, tool2, tool3, tool4, tool5]  # 5个工具
```

**推荐**：5-10 个工具最佳

---

#### 3. 工具的相似度

```python
# ❌ 工具功能相似，LLM 难以区分
@tool
def query_order_status(order_id: str) -> str:
    """查询订单状态"""
    return "已发货"

@tool
def query_order_info(order_id: str) -> str:
    """查询订单信息"""
    return "订单已发货"

# ✅ 合并为一个工具
@tool
def query_order(order_id: str) -> str:
    """查询订单信息（包含状态、物流等）"""
    return "订单已发货，预计明天到达"
```

---

## 工具参数解析

### 参数解析的流程

```python
# LLM 输出
thought = """
Thought: 需要查询订单信息
Action: query_order
Action Input: 12345
"""

# 1. 解析 Action
action_name = "query_order"  # 工具名称

# 2. 解析 Action Input
action_input = "12345"  # 工具参数

# 3. 找到对应的工具
tool = find_tool(tools, action_name)

# 4. 执行工具
observation = tool.run(action_input)
```

---

### 简单参数 vs 复杂参数

#### 简单参数（单个字符串）

```python
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    return f"订单 {order_id} 已发货"

# LLM 输出
"""
Action: query_order
Action Input: 12345
"""

# 解析
action_input = "12345"  # 直接使用
```

---

#### 复杂参数（多个参数）

```python
from langchain.tools import StructuredTool
from pydantic import BaseModel, Field

class QueryOrderInput(BaseModel):
    order_id: str = Field(description="订单ID")
    include_logistics: bool = Field(default=False, description="是否包含物流信息")

@tool
def query_order(order_id: str, include_logistics: bool = False) -> str:
    """查询订单信息"""
    result = f"订单 {order_id} 已发货"
    if include_logistics:
        result += "，物流信息：预计明天到达"
    return result

# LLM 输出
"""
Action: query_order
Action Input: {"order_id": "12345", "include_logistics": true}
"""

# 解析
action_input = {"order_id": "12345", "include_logistics": True}
# 系统会自动解析 JSON 并传递给函数
```

---

### 参数验证

```python
from pydantic import BaseModel, Field, validator

class QueryOrderInput(BaseModel):
    order_id: str = Field(description="订单ID")

    @validator('order_id')
    def validate_order_id(cls, v):
        if not v.isdigit():
            raise ValueError("订单ID必须是数字")
        if len(v) != 5:
            raise ValueError("订单ID必须是5位数字")
        return v

# 如果 LLM 生成了无效的参数，会自动抛出错误
# Action Input: "abc"  # 错误：订单ID必须是数字
# Action Input: "123"  # 错误：订单ID必须是5位数字
# Action Input: "12345"  # 正确
```

---

## 工具执行

### 同步执行 vs 异步执行

#### 同步执行

```python
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    # 同步查询数据库
    result = db.query(f"SELECT * FROM orders WHERE id = '{order_id}'")
    return result

# 执行
observation = query_order.run("12345")
```

**问题**：如果查询很慢，会阻塞整个 Agent

---

#### 异步执行（推荐）

```python
@tool
async def query_order(order_id: str) -> str:
    """查询订单信息"""
    # 异步查询数据库
    result = await db.query_async(f"SELECT * FROM orders WHERE id = '{order_id}'")
    return result

# 执行
observation = await query_order.arun("12345")
```

**优点**：不会阻塞，可以并发执行多个工具

---

### 错误处理

```python
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    try:
        # 查询数据库
        result = db.query(f"SELECT * FROM orders WHERE id = '{order_id}'")
        if not result:
            return f"订单 {order_id} 不存在"
        return f"订单 {order_id} 已发货"
    except Exception as e:
        # 返回错误信息（不要抛出异常）
        return f"查询失败：{str(e)}"
```

**关键**：
- 不要抛出异常，返回错误信息
- 让 Agent 知道发生了什么
- Agent 可以根据错误信息调整策略

---

## 工具结果处理

### 结果格式

```python
# 工具执行结果
observation = "订单12345已发货，预计明天到达"

# 添加到上下文
context.append(f"Observation: {observation}")

# LLM 继续思考
prompt = f"""
当前信息：
{context}

请继续思考下一步。
"""
```

---

### 结果验证

```python
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    result = db.query(f"SELECT * FROM orders WHERE id = '{order_id}'")

    # 验证结果
    if not result:
        return "订单不存在"

    # 格式化结果
    return f"订单 {order_id} 状态：{result['status']}，预计到达：{result['eta']}"
```

**最佳实践**：
- 验证结果的有效性
- 格式化结果，让 LLM 容易理解
- 提供足够的信息，但不要太冗长

---

## 实际应用案例

### 案例1：数据库查询工具

```python
from langchain.tools import tool
import asyncpg

# 数据库连接池（全局变量）
db_pool = None

async def init_db():
    global db_pool
    db_pool = await asyncpg.create_pool(
        "postgresql://user:password@localhost/dbname"
    )

@tool
async def query_order(order_id: str) -> str:
    """
    查询订单信息

    输入：订单ID（5位数字）
    输出：订单状态、金额、收货地址等信息
    """
    try:
        async with db_pool.acquire() as conn:
            row = await conn.fetchrow(
                "SELECT * FROM orders WHERE id = $1",
                order_id
            )

            if not row:
                return f"订单 {order_id} 不存在"

            return f"""
订单ID：{row['id']}
状态：{row['status']}
金额：{row['amount']}元
收货地址：{row['address']}
预计到达：{row['eta']}
"""
    except Exception as e:
        return f"查询失败：{str(e)}"
```

---

### 案例2：API 调用工具

```python
import httpx

@tool
async def query_weather(city: str) -> str:
    """
    查询天气信息

    输入：城市名称（如 '北京'、'上海'）
    输出：当前天气、温度、湿度等信息
    """
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"https://api.weather.com/v1/current",
                params={"city": city, "key": "YOUR_API_KEY"}
            )
            data = response.json()

            return f"""
城市：{city}
天气：{data['weather']}
温度：{data['temperature']}°C
湿度：{data['humidity']}%
"""
    except Exception as e:
        return f"查询失败：{str(e)}"
```

---

### 案例3：计算工具

```python
@tool
def calculator(expression: str) -> str:
    """
    计算数学表达式

    输入：数学表达式（如 '2+3*4'、'(10+5)/3'）
    输出：计算结果

    支持的运算：+、-、*、/、()
    """
    try:
        # 安全的计算（不使用 eval）
        import ast
        import operator

        # 支持的运算符
        operators = {
            ast.Add: operator.add,
            ast.Sub: operator.sub,
            ast.Mult: operator.mul,
            ast.Div: operator.truediv,
        }

        def eval_expr(node):
            if isinstance(node, ast.Num):
                return node.n
            elif isinstance(node, ast.BinOp):
                return operators[type(node.op)](
                    eval_expr(node.left),
                    eval_expr(node.right)
                )
            else:
                raise ValueError("不支持的运算")

        tree = ast.parse(expression, mode='eval')
        result = eval_expr(tree.body)
        return f"计算结果：{result}"
    except Exception as e:
        return f"计算错误：{str(e)}"
```

---

## 工具调用的最佳实践

### 1. 工具设计原则

**单一职责**：
```python
# ❌ 一个工具做太多事情
@tool
def manage_order(action: str, order_id: str) -> str:
    """管理订单（查询、取消、修改）"""
    if action == "query":
        return query_order_impl(order_id)
    elif action == "cancel":
        return cancel_order_impl(order_id)
    elif action == "modify":
        return modify_order_impl(order_id)

# ✅ 每个工具只做一件事
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    return query_order_impl(order_id)

@tool
def cancel_order(order_id: str) -> str:
    """取消订单"""
    return cancel_order_impl(order_id)
```

---

### 2. 工具命名规范

**清晰的命名**：
```python
# ❌ 命名不清晰
@tool
def get(id: str) -> str:
    """获取"""
    return "结果"

# ✅ 命名清晰
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    return "结果"
```

**命名规范**：
- 使用动词开头（query、create、update、delete）
- 说明操作的对象（order、user、product）
- 使用下划线分隔（query_order，不是 queryOrder）

---

### 3. 工具数量控制

**推荐数量**：5-10 个工具

**如果工具太多**：
1. **合并相似工具**：
   ```python
   # 合并前：3个工具
   calculate_sum, calculate_average, calculate_max

   # 合并后：1个工具
   calculate(operation, numbers)
   ```

2. **分场景提供工具**：
   ```python
   # 客服场景
   customer_service_tools = [query_order, query_inventory]

   # 数据分析场景
   data_analysis_tools = [query_data, calculate_stats]
   ```

---

### 4. 工具描述优化

**模板**：
```python
@tool
def tool_name(param: str) -> str:
    """
    [一句话功能描述]

    输入：[参数说明]
    输出：[输出说明]
    适用场景：[场景说明]
    示例：[示例]
    """
    # 实现...
```

---

### 5. 错误处理

**返回错误信息，不要抛出异常**：
```python
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    try:
        result = db.query(order_id)
        return result
    except Exception as e:
        # ✅ 返回错误信息
        return f"查询失败：{str(e)}"
        # ❌ 不要抛出异常
        # raise e
```

---

## 学习检查清单

完成本文档学习后，你应该能够：

- [ ] 理解工具的本质（函数 + 描述）
- [ ] 使用三种方式定义工具（@tool、Tool、StructuredTool）
- [ ] 编写清晰的工具描述
- [ ] 理解 LLM 如何选择工具
- [ ] 处理简单参数和复杂参数
- [ ] 实现同步和异步工具
- [ ] 处理工具执行错误
- [ ] 应用工具调用的最佳实践

---

**版本：** v1.0
**最后更新：** 2026-02-12
**维护者：** Claude Code
