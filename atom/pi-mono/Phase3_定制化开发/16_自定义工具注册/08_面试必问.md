# 面试必问

> **掌握核心问题，展现深度理解**

本文档整理了自定义工具注册相关的高频面试问题，并提供深度解析和优秀答案示例。

---

## 问题 1：请解释 Pi-mono 中自定义工具注册的核心机制

### 优秀答案

**核心机制包含四个关键部分：**

**1. Tool Definition 接口**
- 定义工具的元数据（name, description）
- 使用 TypeBox 定义参数 Schema
- 实现 execute 执行函数
- 可选的自定义渲染（renderCall, renderResult）

**2. registerTool API**
- 在 Extension 的 activate 函数中调用
- 将工具注册到 ExtensionContext
- 框架收集所有注册的工具

**3. 工具包装与事件**
- 框架使用 wrapRegisteredTool 包装工具
- 触发 tool_call 和 tool_result 事件
- Extension 可以监听和拦截这些事件

**4. LLM 集成**
- 工具列表转换为 LLM 可理解的格式（JSON Schema）
- 在 LLM 调用时作为 tools 参数发送
- LLM 根据用户输入决定是否调用工具

**关键代码路径：**
```
Extension.activate()
  → context.registerTool(tool)
  → ExtensionContext 存储工具
  → wrapRegisteredTool(tool)
  → 发送给 LLM
  → LLM 调用工具
  → tool_call event
  → tool.execute()
  → tool_result event
```

**深度理解：**
- 工具注册是声明式的，不是命令式的
- 框架负责工具的生命周期管理
- 事件系统提供了强大的扩展能力

---

## 问题 2：TypeBox Schema 在工具注册中的作用是什么？

### 优秀答案

**TypeBox Schema 提供三重作用：**

**1. LLM 理解（静态）**
```typescript
Type.Object({
  city: Type.String({ 
    description: 'City name for weather query' 
  })
})
```
- 生成 JSON Schema 描述
- LLM 根据 description 理解参数含义
- LLM 根据类型约束生成正确的参数

**2. 运行时验证（动态）**
```typescript
Type.Number({ minimum: 1, maximum: 100 })
```
- 在工具执行前自动验证参数
- 验证失败时工具不会被调用
- 返回清晰的错误信息给 LLM

**3. TypeScript 类型推导（编译时）**
```typescript
const params = Type.Object({
  age: Type.Number()
});

type Params = Static<typeof params>;
// Params = { age: number }
```
- 提供类型安全
- IDE 自动补全
- 编译时类型检查

**为什么选择 TypeBox 而不是 Zod？**
- TypeBox 生成标准 JSON Schema（LLM 友好）
- 性能更好（编译时优化）
- 与 pi-mono 的类型系统集成更好

**实战建议：**
- 充分利用约束（minimum, maximum, pattern, format）
- 每个字段都要有清晰的 description
- 使用 Type.Optional() 标记可选字段
- 使用 Type.Union() 和 Type.Literal() 定义枚举

---

## 问题 3：execute 函数为什么必须是 async？

### 优秀答案

**必须是 async 的四个原因：**

**1. 统一接口**
```typescript
// 框架内部实现
async function callTool(tool, params, context) {
  const result = await tool.execute(params, context);
  return result;
}
```
- 所有工具使用相同的调用方式
- 简化框架实现
- 避免类型判断

**2. 支持 AbortSignal**
```typescript
const execute = async (params, context) => {
  const { signal } = context;
  
  if (signal.aborted) {
    return { content: 'Cancelled' };
  }
  
  const data = await fetch(url, { signal });
  return { content: data };
};
```
- AbortSignal 是异步操作的标准取消机制
- 用户可以取消长时间运行的工具
- 同步函数无法支持取消

**3. 支持 onUpdate 回调**
```typescript
const execute = async (params, context) => {
  const { onUpdate } = context;
  
  for (let i = 0; i <= 100; i += 10) {
    await sleep(1000);
    onUpdate?.({ content: `Progress: ${i}%` });
  }
  
  return { content: 'Complete!' };
};
```
- 流式更新需要异步上下文
- 提供实时进度反馈
- 改善用户体验

**4. 未来扩展性**
- 即使当前逻辑是同步的，未来可能需要：
  - 调用外部 API
  - 读取文件
  - 查询数据库
  - 等待用户输入
- 使用 async 函数，无需修改接口

**性能影响：**
- async 函数的开销极小（微秒级别）
- 100万次调用差异仅 3ms
- 可以忽略不计

**常见错误：**
```typescript
// ❌ 错误：同步函数
const execute = ({ name }) => {
  return { content: `Hello, ${name}!` };
};

// ✅ 正确：async 函数
const execute = async ({ name }) => {
  return { content: `Hello, ${name}!` };
};
```

---

## 问题 4：如何实现自定义渲染？

### 优秀答案

**自定义渲染包含两个部分：**

**1. renderCall - 工具调用时的显示**
```typescript
renderCall: (params) => {
  return `Searching for: ${params.query}`;
}
```
- 在工具执行前显示
- 告诉用户工具正在做什么
- 可以格式化参数显示

**2. renderResult - 工具结果的显示**
```typescript
renderResult: (result) => {
  const data = JSON.parse(result.content);
  return `Found ${data.count} results`;
}
```
- 在工具执行后显示
- 格式化结果显示
- 可以提取关键信息

**使用 pi-tui 组件：**
```typescript
import { Box, Text } from '@pi-mono/pi-tui';

renderResult: (result) => {
  return (
    <Box flexDirection="column">
      <Text color="green">✓ Success</Text>
      <Text>{result.content}</Text>
    </Box>
  );
}
```

**实战案例（来自 question.ts）：**
```typescript
renderCall: (params) => {
  return (
    <Box flexDirection="column">
      <Text bold>{params.question}</Text>
      {params.options.map((opt, i) => (
        <Text key={i}>  {i + 1}. {opt.label}</Text>
      ))}
    </Box>
  );
}
```

**为什么需要自定义渲染？**
- 默认渲染只显示原始 JSON
- 自定义渲染提供更好的用户体验
- 可以突出关键信息
- 可以使用颜色、格式化等

**最佳实践：**
- renderCall 显示参数的关键信息
- renderResult 提取和格式化结果
- 使用 pi-tui 组件保持一致的 UI 风格
- 避免显示过多细节（如完整的 JSON）

---

## 问题 5：工具注册后为什么不立即可用？

### 优秀答案

**工具注册到可用需要经过以下步骤：**

**1. Extension 加载阶段**
```typescript
export const myExtension: Extension = {
  async activate(context) {
    context.registerTool(tool1);
    context.registerTool(tool2);
    // 此时工具已注册，但 LLM 还不知道
  }
};
```
- 所有 Extension 的 activate 函数执行完毕
- 工具列表被收集和整理

**2. 工具描述生成**
- 将 Tool Definition 转换为 JSON Schema
- 生成 LLM 可理解的格式
- 包含 name, description, parameters

**3. 发送给 LLM**
- 在下一次 LLM 调用时
- 将工具列表作为 tools 参数发送
- LLM 才能"看到"这些工具

**4. 用户操作（新 Extension）**
- 如果 Extension 是在会话中途添加的
- 需要执行 `/reload` 重新加载
- 否则工具不会被发送给 LLM

**为什么这样设计？**

**性能优化：**
- 避免每次注册工具都重新生成工具列表
- 批量处理所有工具，一次性发送给 LLM
- 减少 LLM 调用次数

**一致性保证：**
- 确保所有 Extension 都加载完成
- 避免工具列表不完整
- 避免竞态条件

**实战建议：**
```typescript
// 开发新 Extension 时
export const myExtension: Extension = {
  async activate(context) {
    context.registerTool(myTool);
    context.logger.info('Tool registered:', myTool.name);
    // 然后执行 /reload
    // 然后执行 /tools 查看工具列表
  }
};
```

**调试工具不生效：**
1. 检查 Extension 是否加载（查看日志）
2. 检查工具名称是否唯一
3. 检查是否执行了 `/reload`
4. 使用 `/tools` 查看工具列表

---

## 问题 6：如何处理工具执行中的错误？

### 优秀答案

**错误处理的三个层次：**

**1. Schema 验证错误（自动处理）**
```typescript
parameters: Type.Object({
  age: Type.Number({ minimum: 0, maximum: 120 })
})

// LLM 传入 age: 200
// 结果：TypeBox 自动验证失败，工具不会被调用
// LLM 收到错误信息，可以重试
```
- 框架自动处理
- 不需要在 execute 中验证
- LLM 会收到清晰的错误信息

**2. 业务逻辑错误（手动处理）**
```typescript
const execute = async ({ userId }, context) => {
  try {
    const user = await db.findUser(userId);
    
    if (!user) {
      return { 
        content: 'Error: User not found',
        metadata: { error: true }
      };
    }
    
    return { content: JSON.stringify(user) };
  } catch (error) {
    context.logger.error('Database error:', error);
    return { 
      content: `Error: ${error.message}`,
      metadata: { error: true }
    };
  }
};
```
- 使用 try-catch 捕获异常
- 返回友好的错误信息
- 记录日志便于调试

**3. 取消操作（AbortSignal）**
```typescript
const execute = async (params, context) => {
  const { signal } = context;
  
  try {
    const data = await fetch(url, { signal });
    
    if (signal.aborted) {
      return { content: 'Operation cancelled by user' };
    }
    
    return { content: data };
  } catch (error) {
    if (error.name === 'AbortError') {
      return { content: 'Operation cancelled' };
    }
    return { content: `Error: ${error.message}` };
  }
};
```
- 检查 signal.aborted
- 传递 signal 给异步操作
- 捕获 AbortError

**最佳实践：**

**1. 错误信息要友好**
```typescript
// ❌ 不好
return { content: 'Error: ENOENT' };

// ✅ 好
return { content: 'Error: File not found. Please check the file path.' };
```

**2. 记录详细日志**
```typescript
catch (error) {
  context.logger.error('Failed to process file:', {
    filePath: params.filePath,
    error: error.message,
    stack: error.stack
  });
  return { content: 'Error processing file' };
}
```

**3. 使用 metadata 标记错误**
```typescript
return {
  content: 'Error: ...',
  metadata: {
    error: true,
    errorType: 'NotFound',
    errorCode: 404
  }
};
```

**4. 不要吞掉错误**
```typescript
// ❌ 错误：吞掉错误
catch (error) {
  return { content: 'Success' };  // 假装成功
}

// ✅ 正确：返回错误信息
catch (error) {
  return { content: `Error: ${error.message}` };
}
```

---

## 问题 7：如何实现工具的状态管理？

### 优秀答案

**使用 ExtensionContext.session 进行状态管理：**

**1. 基本用法**
```typescript
const execute = async (params, context) => {
  // 读取状态
  const history = context.session.get('messageHistory') || [];
  
  // 修改状态
  history.push(params.message);
  
  // 保存状态
  context.session.set('messageHistory', history);
  
  return { content: `Saved. Total: ${history.length}` };
};
```

**2. 实战案例（来自 todo.ts）**
```typescript
// 添加任务
const addTask = async ({ task }, context) => {
  const tasks = context.session.get('tasks') || [];
  const newTask = {
    id: Date.now(),
    task,
    completed: false
  };
  tasks.push(newTask);
  context.session.set('tasks', tasks);
  return { content: `Task added: ${task}` };
};

// 列出任务
const listTasks = async (params, context) => {
  const tasks = context.session.get('tasks') || [];
  return { 
    content: tasks.map(t => 
      `${t.completed ? '✓' : '○'} ${t.task}`
    ).join('\n')
  };
};

// 完成任务
const completeTask = async ({ id }, context) => {
  const tasks = context.session.get('tasks') || [];
  const task = tasks.find(t => t.id === id);
  if (task) {
    task.completed = true;
    context.session.set('tasks', tasks);
    return { content: 'Task completed' };
  }
  return { content: 'Task not found' };
};
```

**3. 状态的生命周期**
- session 状态在整个会话期间持久化
- 会话结束后状态被清除
- 不同会话之间状态隔离

**4. 最佳实践**

**使用类型安全的状态：**
```typescript
interface TaskState {
  tasks: Array<{
    id: number;
    task: string;
    completed: boolean;
  }>;
}

const execute = async (params, context) => {
  const state = context.session.get<TaskState>('tasks') || { tasks: [] };
  // ...
};
```

**避免状态过大：**
```typescript
// ❌ 不好：存储大量数据
context.session.set('allMessages', hugeArray);

// ✅ 好：只存储必要的数据
context.session.set('recentMessages', lastN(messages, 10));
```

**使用命名空间：**
```typescript
// 避免不同工具的状态冲突
context.session.set('myTool:state', data);
context.session.get('myTool:state');
```

---

## 问题 8：如何优化工具的性能？

### 优秀答案

**性能优化的四个方向：**

**1. 输出截断（来自 truncated-tool.ts）**
```typescript
const MAX_OUTPUT_SIZE = 10000;

const execute = async (params, context) => {
  const output = await generateLargeOutput();
  
  if (output.length > MAX_OUTPUT_SIZE) {
    // 截断输出
    const truncated = output.substring(0, MAX_OUTPUT_SIZE);
    
    // 保存完整输出到文件
    const filePath = `/tmp/output-${Date.now()}.txt`;
    await fs.writeFile(filePath, output);
    
    return {
      content: truncated + `\n\n[Output truncated. Full output saved to ${filePath}]`,
      metadata: {
        truncated: true,
        fullOutputPath: filePath
      }
    };
  }
  
  return { content: output };
};
```

**2. 流式更新（使用 onUpdate）**
```typescript
const execute = async (params, context) => {
  const { onUpdate } = context;
  
  let result = '';
  for (let i = 0; i < 100; i++) {
    const chunk = await processChunk(i);
    result += chunk;
    
    // 每10个chunk更新一次
    if (i % 10 === 0) {
      onUpdate?.({ content: `Processing: ${i}%` });
    }
  }
  
  return { content: result };
};
```

**3. 缓存结果**
```typescript
const cache = new Map();

const execute = async ({ query }, context) => {
  // 检查缓存
  if (cache.has(query)) {
    context.logger.info('Cache hit');
    return { content: cache.get(query) };
  }
  
  // 执行查询
  const result = await expensiveQuery(query);
  
  // 保存到缓存
  cache.set(query, result);
  
  return { content: result };
};
```

**4. 并发控制**
```typescript
import pLimit from 'p-limit';

const limit = pLimit(5);  // 最多5个并发

const execute = async ({ urls }, context) => {
  const results = await Promise.all(
    urls.map(url => 
      limit(() => fetch(url))
    )
  );
  
  return { content: JSON.stringify(results) };
};
```

**5. 超时控制**
```typescript
const execute = async (params, context) => {
  const { signal } = context;
  
  const timeout = setTimeout(() => {
    return { content: 'Operation timeout' };
  }, 30000);  // 30秒超时
  
  try {
    const result = await longRunningOperation({ signal });
    clearTimeout(timeout);
    return { content: result };
  } catch (error) {
    clearTimeout(timeout);
    return { content: `Error: ${error.message}` };
  }
};
```

**性能监控：**
```typescript
const execute = async (params, context) => {
  const startTime = Date.now();
  
  try {
    const result = await operation();
    
    const duration = Date.now() - startTime;
    context.logger.info('Tool execution time:', duration, 'ms');
    
    return {
      content: result,
      metadata: { executionTime: duration }
    };
  } catch (error) {
    const duration = Date.now() - startTime;
    context.logger.error('Tool failed after', duration, 'ms');
    throw error;
  }
};
```

---

## 总结：面试准备清单

**核心概念：**
- [ ] Tool Definition 的四个必需字段
- [ ] TypeBox Schema 的三重作用
- [ ] execute 函数必须是 async 的原因
- [ ] registerTool 的调用时机

**高级特性：**
- [ ] 自定义渲染（renderCall, renderResult）
- [ ] 事件系统（tool_call, tool_result）
- [ ] 状态管理（session）
- [ ] 性能优化（截断、缓存、并发）

**实战经验：**
- [ ] 错误处理的最佳实践
- [ ] AbortSignal 的使用
- [ ] onUpdate 流式更新
- [ ] 工具调试技巧

**源码理解：**
- [ ] 工具注册流程
- [ ] 工具包装机制
- [ ] LLM 集成方式
- [ ] Extension 生命周期

掌握这些内容，你就能在面试中展现对 Pi-mono 自定义工具注册的深度理解！
