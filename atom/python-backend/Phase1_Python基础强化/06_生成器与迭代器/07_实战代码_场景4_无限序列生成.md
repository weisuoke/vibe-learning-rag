# 实战代码 - 场景4：无限序列生成

> 使用生成器生成无限序列，实现数学序列和实时数据流

---

## 场景描述

**问题：** 需要生成无限长的数据序列（如斐波那契数列、素数序列、实时事件流）

**挑战：**
- 无法用列表表示无限序列
- 需要按需生成，不能一次性计算全部
- 需要支持随时停止

**解决方案：** 使用生成器生成无限序列

---

## 完整可运行代码

```python
"""
场景4：无限序列生成
演示：使用生成器生成无限长的数据序列
"""

import time
from typing import Generator
import itertools

# ===== 1. 基础：无限计数器 =====
print("=== 1. 基础：无限计数器 ===\n")

def infinite_counter(start: int = 0, step: int = 1) -> Generator[int, None, None]:
    """
    无限计数器

    Args:
        start: 起始值
        step: 步长

    Yields:
        int: 下一个计数值
    """
    n = start
    while True:
        yield n
        n += step

# 使用：取前 10 个
print("无限计数器（前 10 个）:")
counter = infinite_counter(0, 2)
for _ in range(10):
    print(f"  {next(counter)}")

print()

# ===== 2. 斐波那契数列 =====
print("=== 2. 斐波那契数列 ===\n")

def fibonacci() -> Generator[int, None, None]:
    """
    无限斐波那契数列

    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
    """
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 使用：取前 15 个
print("斐波那契数列（前 15 个）:")
fib = fibonacci()
for _ in range(15):
    print(f"  {next(fib)}")

print()

# ===== 3. 素数生成器 =====
print("=== 3. 素数生成器 ===\n")

def is_prime(n: int) -> bool:
    """判断是否为素数"""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(n ** 0.5) + 1, 2):
        if n % i == 0:
            return False
    return True

def primes() -> Generator[int, None, None]:
    """
    无限素数生成器

    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...
    """
    n = 2
    while True:
        if is_prime(n):
            yield n
        n += 1

# 使用：取前 20 个素数
print("素数序列（前 20 个）:")
prime_gen = primes()
primes_list = [next(prime_gen) for _ in range(20)]
print(f"  {primes_list}")

print()

# ===== 4. 循环序列 =====
print("=== 4. 循环序列 ===\n")

def cycle(items: list) -> Generator:
    """
    无限循环序列

    [1, 2, 3] -> 1, 2, 3, 1, 2, 3, 1, 2, 3, ...
    """
    while True:
        for item in items:
            yield item

# 使用
print("循环序列（前 10 个）:")
cycler = cycle(['A', 'B', 'C'])
for _ in range(10):
    print(f"  {next(cycler)}")

print()

# ===== 5. 随机数生成器 =====
print("=== 5. 随机数生成器 ===\n")

import random

def random_numbers(min_val: int = 0, max_val: int = 100) -> Generator[int, None, None]:
    """
    无限随机数生成器
    """
    while True:
        yield random.randint(min_val, max_val)

# 使用
print("随机数序列（前 10 个）:")
rand_gen = random_numbers(1, 10)
for _ in range(10):
    print(f"  {next(rand_gen)}")

print()

# ===== 6. 时间戳生成器 =====
print("=== 6. 时间戳生成器 ===\n")

from datetime import datetime, timedelta

def timestamp_generator(start: datetime = None,
                       interval: timedelta = timedelta(seconds=1)) -> Generator[datetime, None, None]:
    """
    无限时间戳生成器

    Args:
        start: 起始时间（默认为当前时间）
        interval: 时间间隔
    """
    current = start or datetime.now()
    while True:
        yield current
        current += interval

# 使用
print("时间戳序列（前 5 个，间隔 1 小时）:")
ts_gen = timestamp_generator(
    start=datetime(2026, 2, 11, 10, 0, 0),
    interval=timedelta(hours=1)
)
for _ in range(5):
    print(f"  {next(ts_gen)}")

print()

# ===== 7. 实时事件流模拟 =====
print("=== 7. 实时事件流模拟 ===\n")

def event_stream() -> Generator[dict, None, None]:
    """
    模拟实时事件流

    生成无限的事件数据
    """
    event_id = 0
    event_types = ['login', 'logout', 'purchase', 'view']

    while True:
        event_id += 1
        yield {
            'id': event_id,
            'type': random.choice(event_types),
            'timestamp': datetime.now().isoformat(),
            'user_id': random.randint(1, 100)
        }
        time.sleep(0.1)  # 模拟事件间隔

# 使用：监控前 5 个事件
print("事件流（前 5 个）:")
events = event_stream()
for _ in range(5):
    event = next(events)
    print(f"  事件 {event['id']}: {event['type']} by 用户 {event['user_id']}")

print()

# ===== 8. 组合无限序列 =====
print("=== 8. 组合无限序列 ===\n")

def merge_infinite(*generators: Generator) -> Generator:
    """
    合并多个无限生成器（轮流取值）
    """
    while True:
        for gen in generators:
            try:
                yield next(gen)
            except StopIteration:
                pass

# 使用
print("合并两个计数器（前 10 个）:")
gen1 = infinite_counter(0, 1)
gen2 = infinite_counter(100, 10)
merged = merge_infinite(gen1, gen2)

for _ in range(10):
    print(f"  {next(merged)}")

print()

# ===== 9. 条件无限序列 =====
print("=== 9. 条件无限序列 ===\n")

def conditional_infinite(condition: callable) -> Generator[int, None, None]:
    """
    根据条件生成无限序列

    只生成满足条件的数字
    """
    n = 0
    while True:
        if condition(n):
            yield n
        n += 1

# 使用：只生成能被 3 整除的数
print("能被 3 整除的数（前 10 个）:")
div3 = conditional_infinite(lambda x: x % 3 == 0)
for _ in range(10):
    print(f"  {next(div3)}")

print()

# ===== 10. 实际应用：ID 生成器 =====
print("=== 10. 实际应用：ID 生成器 ===\n")

class IDGenerator:
    """
    全局唯一 ID 生成器

    功能：
    - 生成递增的唯一 ID
    - 支持前缀
    - 线程安全（简化版）
    """

    def __init__(self, prefix: str = "", start: int = 1):
        self.prefix = prefix
        self.current = start

    def generate(self) -> Generator[str, None, None]:
        """生成无限 ID 序列"""
        while True:
            id_str = f"{self.prefix}{self.current:06d}"
            self.current += 1
            yield id_str

# 使用
print("ID 生成器（前 10 个）:")
id_gen = IDGenerator(prefix="USER_")
ids = id_gen.generate()

for _ in range(10):
    print(f"  {next(ids)}")

print()

# ===== 11. 实际应用：分页数据生成器 =====
print("=== 11. 实际应用：分页数据生成器 ===\n")

def paginated_data(fetch_page: callable, page_size: int = 10) -> Generator:
    """
    无限分页数据生成器

    Args:
        fetch_page: 获取页面数据的函数 (page_num) -> list
        page_size: 每页大小

    Yields:
        每条数据
    """
    page = 1
    while True:
        data = fetch_page(page, page_size)
        if not data:
            break
        for item in data:
            yield item
        page += 1

# 模拟数据库查询
def mock_fetch_page(page: int, size: int) -> list:
    """模拟分页查询"""
    start = (page - 1) * size
    end = start + size
    # 模拟只有 50 条数据
    if start >= 50:
        return []
    return [f"Item-{i}" for i in range(start, min(end, 50))]

# 使用
print("分页数据（前 15 个）:")
paged = paginated_data(mock_fetch_page, page_size=10)
for _ in range(15):
    print(f"  {next(paged)}")

print()

# ===== 12. 实际应用：实时日志监控 =====
print("=== 12. 实际应用：实时日志监控 ===\n")

def tail_log(filename: str, interval: float = 0.1) -> Generator[str, None, None]:
    """
    实时监控日志文件（类似 tail -f）

    Args:
        filename: 日志文件路径
        interval: 检查间隔（秒）

    Yields:
        新增的日志行
    """
    with open(filename, 'r') as f:
        # 移动到文件末尾
        f.seek(0, 2)

        while True:
            line = f.readline()
            if line:
                yield line.strip()
            else:
                time.sleep(interval)

print("实时日志监控（演示概念）:")
print("  def tail_log(filename):")
print("      while True:")
print("          line = f.readline()")
print("          if line:")
print("              yield line")

print()

# ===== 13. 实际应用：心跳信号生成器 =====
print("=== 13. 实际应用：心跳信号生成器 ===\n")

def heartbeat(interval: float = 1.0) -> Generator[dict, None, None]:
    """
    心跳信号生成器

    Args:
        interval: 心跳间隔（秒）

    Yields:
        心跳信号
    """
    beat_count = 0
    while True:
        beat_count += 1
        yield {
            'beat': beat_count,
            'timestamp': datetime.now().isoformat(),
            'status': 'alive'
        }
        time.sleep(interval)

# 使用
print("心跳信号（前 3 个）:")
hb = heartbeat(interval=0.5)
for _ in range(3):
    signal = next(hb)
    print(f"  心跳 {signal['beat']}: {signal['status']} at {signal['timestamp']}")

print()

# ===== 14. 使用 itertools 的无限序列 =====
print("=== 14. 使用 itertools 的无限序列 ===\n")

# itertools.count: 无限计数
print("itertools.count（前 5 个）:")
for i, val in enumerate(itertools.count(10, 2)):
    if i >= 5:
        break
    print(f"  {val}")

# itertools.cycle: 无限循环
print("\nitertools.cycle（前 8 个）:")
for i, val in enumerate(itertools.cycle(['A', 'B', 'C'])):
    if i >= 8:
        break
    print(f"  {val}")

# itertools.repeat: 无限重复
print("\nitertools.repeat（前 5 个）:")
for i, val in enumerate(itertools.repeat('X')):
    if i >= 5:
        break
    print(f"  {val}")

print()

# ===== 15. 实际应用：数据流处理 =====
print("=== 15. 实际应用：数据流处理 ===\n")

class DataStream:
    """
    数据流处理器

    功能：
    - 生成无限数据流
    - 支持过滤和转换
    - 支持窗口操作
    """

    def __init__(self, source: Generator):
        self.source = source

    def filter(self, predicate: callable) -> Generator:
        """过滤数据流"""
        for item in self.source:
            if predicate(item):
                yield item

    def map(self, func: callable) -> Generator:
        """转换数据流"""
        for item in self.source:
            yield func(item)

    def window(self, size: int) -> Generator[list, None, None]:
        """滑动窗口"""
        window = []
        for item in self.source:
            window.append(item)
            if len(window) >= size:
                yield window.copy()
                window.pop(0)

# 使用
print("数据流处理（前 5 个窗口）:")
stream = DataStream(infinite_counter(0, 1))
windowed = stream.window(3)

for _ in range(5):
    window = next(windowed)
    print(f"  窗口: {window}")

print()

# ===== 总结 =====
print("=== 总结 ===")
print("\n无限序列生成器的优势:")
print("  1. 内存高效：不存储全部数据，按需生成")
print("  2. 表达能力强：可以表示无限长的序列")
print("  3. 灵活控制：可以随时停止或继续")
print("  4. 组合性好：可以组合多个无限序列")
print("\n适用场景:")
print("  - 数学序列（斐波那契、素数）")
print("  - 实时数据流（事件流、日志流）")
print("  - ID 生成器")
print("  - 心跳信号")
print("  - 分页数据处理")
print("\n注意事项:")
print("  - 必须手动停止（使用 break 或 take）")
print("  - 不能用 len() 获取长度")
print("  - 不能用 list() 转换（会无限循环）")
```

---

## 关键技术点

### 1. 无限循环 + yield

```python
def infinite_sequence():
    n = 0
    while True:  # 无限循环
        yield n
        n += 1
```

### 2. 使用 itertools

```python
import itertools

# 无限计数
itertools.count(start, step)

# 无限循环
itertools.cycle(iterable)

# 无限重复
itertools.repeat(value)
```

### 3. 手动停止

```python
# 方式1：使用 break
for item in infinite_gen():
    if condition:
        break

# 方式2：使用 itertools.islice
first_10 = list(itertools.islice(infinite_gen(), 10))

# 方式3：手动调用 next()
gen = infinite_gen()
for _ in range(10):
    print(next(gen))
```

### 4. 组合无限序列

```python
def merge(*generators):
    while True:
        for gen in generators:
            yield next(gen)
```

---

## 常见陷阱

### 陷阱1：尝试转换为列表

```python
# ❌ 错误：会无限循环，耗尽内存
gen = infinite_counter()
lst = list(gen)  # 永远不会结束！

# ✅ 正确：限制数量
gen = infinite_counter()
lst = list(itertools.islice(gen, 100))
```

### 陷阱2：尝试获取长度

```python
# ❌ 错误：无限序列没有长度
gen = infinite_counter()
length = len(gen)  # TypeError

# ✅ 正确：不需要知道长度
gen = infinite_counter()
for _ in range(10):
    print(next(gen))
```

### 陷阱3：忘记停止条件

```python
# ❌ 错误：无限循环
for item in infinite_counter():
    print(item)  # 永远不会停止

# ✅ 正确：添加停止条件
for item in infinite_counter():
    if item >= 10:
        break
    print(item)
```

---

## 在 AI Agent 开发中的应用

### 应用1：请求 ID 生成器

```python
class RequestIDGenerator:
    def __init__(self):
        self.counter = itertools.count(1)

    def next_id(self) -> str:
        return f"REQ-{next(self.counter):08d}"

# 全局 ID 生成器
id_gen = RequestIDGenerator()

@app.post("/api/chat")
async def chat(request: ChatRequest):
    request_id = id_gen.next_id()
    logger.info(f"[{request_id}] 处理请求")
    ...
```

### 应用2：心跳监控

```python
async def heartbeat_monitor():
    """心跳监控"""
    for beat in heartbeat(interval=30):
        await send_heartbeat(beat)
        await check_health()
```

### 应用3：实时事件处理

```python
async def process_events():
    """处理实时事件流"""
    for event in event_stream():
        await handle_event(event)
```

---

## 最佳实践

### 1. 提供停止机制

```python
def infinite_with_stop(stop_condition: callable):
    n = 0
    while not stop_condition(n):
        yield n
        n += 1
```

### 2. 添加超时控制

```python
import time

def infinite_with_timeout(timeout: float):
    start = time.time()
    n = 0
    while time.time() - start < timeout:
        yield n
        n += 1
```

### 3. 使用 itertools.islice 限制

```python
# 取前 N 个
first_n = list(itertools.islice(infinite_gen(), n))

# 跳过前 M 个，取 N 个
subset = list(itertools.islice(infinite_gen(), m, m+n))
```

### 4. 组合使用

```python
# 组合多个无限序列
combined = itertools.chain(
    itertools.islice(gen1(), 10),
    itertools.islice(gen2(), 10)
)
```

---

**版本：** v1.0
**最后更新：** 2026-02-11
