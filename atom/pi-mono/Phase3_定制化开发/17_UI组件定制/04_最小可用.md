# 最小可用知识

> **学习目标**: 掌握 20% 核心知识解决 80% 问题
> **阅读时间**: 45 分钟
> **难度级别**: ⭐⭐⭐ (中级)

---

## 概述

**最小可用知识**是指用最少的学习成本，掌握能够解决大部分实际问题的核心知识。本文档提炼了 UI 组件定制的 20% 核心内容，让你能够快速上手并解决 80% 的实际需求。

### 学习目标

完成本文档学习后，你将能够：
- 实现基础的差分渲染
- 创建简单的自定义编辑器
- 构建基本的 Widget 组件
- 使用 CSI 2026 消除闪烁

### 核心原则

**简单优先**: 不要过早优化，先实现功能
**实用导向**: 关注最常用的场景
**快速上手**: 最短时间内达到可用状态

---

## 核心 1: 差分渲染的本质

### 核心概念

**差分渲染 = 只更新变化的部分**

```typescript
// 全量渲染 (慢)
function fullRender(state: State): void {
  for (let row = 0; row < state.rows; row++) {
    for (let col = 0; col < state.cols; col++) {
      terminal.write(row, col, state.cells[row][col]);
    }
  }
}

// 差分渲染 (快)
function diffRender(prevState: State, currState: State): void {
  for (let row = 0; row < currState.rows; row++) {
    for (let col = 0; col < currState.cols; col++) {
      if (prevState.cells[row][col] !== currState.cells[row][col]) {
        terminal.write(row, col, currState.cells[row][col]);
      }
    }
  }
}
```

### 最小实现

**步骤 1: 定义 Cell 数据结构**
```typescript
interface Cell {
  char: string;
  fg?: string;  // 前景色
  bg?: string;  // 背景色
}
```

**步骤 2: 维护两个 Buffer**
```typescript
class Renderer {
  private prevBuffer: Cell[][] = [];
  private currBuffer: Cell[][] = [];

  render(newBuffer: Cell[][]): void {
    this.currBuffer = newBuffer;
    this.diff();
    this.prevBuffer = this.currBuffer;
  }
}
```

**步骤 3: 实现 Diff 函数**
```typescript
private diff(): void {
  for (let row = 0; row < this.currBuffer.length; row++) {
    for (let col = 0; col < this.currBuffer[row].length; col++) {
      const prev = this.prevBuffer[row]?.[col];
      const curr = this.currBuffer[row][col];

      if (!prev || prev.char !== curr.char || prev.fg !== curr.fg || prev.bg !== curr.bg) {
        this.writeCell(row, col, curr);
      }
    }
  }
}

private writeCell(row: number, col: number, cell: Cell): void {
  let output = `\x1b[${row + 1};${col + 1}H`;  // 移动光标
  if (cell.fg) output += `\x1b[38;5;${cell.fg}m`;  // 设置前景色
  if (cell.bg) output += `\x1b[48;5;${cell.bg}m`;  // 设置背景色
  output += cell.char;
  process.stdout.write(output);
}
```

### 完整示例

```typescript
class SimpleDiffRenderer {
  private prevBuffer: Cell[][] = [];
  private rows: number;
  private cols: number;

  constructor(rows: number, cols: number) {
    this.rows = rows;
    this.cols = cols;
    this.initBuffer();
  }

  private initBuffer(): void {
    this.prevBuffer = Array(this.rows).fill(null).map(() =>
      Array(this.cols).fill(null).map(() => ({ char: ' ' }))
    );
  }

  render(currBuffer: Cell[][]): void {
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.cols; col++) {
        const prev = this.prevBuffer[row][col];
        const curr = currBuffer[row][col];

        if (this.cellChanged(prev, curr)) {
          this.writeCell(row, col, curr);
          this.prevBuffer[row][col] = { ...curr };
        }
      }
    }
  }

  private cellChanged(prev: Cell, curr: Cell): boolean {
    return prev.char !== curr.char ||
           prev.fg !== curr.fg ||
           prev.bg !== curr.bg;
  }

  private writeCell(row: number, col: number, cell: Cell): void {
    let output = `\x1b[${row + 1};${col + 1}H`;
    if (cell.fg) output += `\x1b[38;5;${cell.fg}m`;
    if (cell.bg) output += `\x1b[48;5;${cell.bg}m`;
    output += cell.char;
    output += '\x1b[0m';  // 重置样式
    process.stdout.write(output);
  }
}

// 使用
const renderer = new SimpleDiffRenderer(24, 80);

// 创建一个简单的 buffer
const buffer: Cell[][] = Array(24).fill(null).map(() =>
  Array(80).fill(null).map(() => ({ char: ' ' }))
);

// 在 (5, 10) 位置写入 "Hello"
'Hello'.split('').forEach((char, i) => {
  buffer[5][10 + i] = { char, fg: '2' };  // 绿色
});

// 渲染
renderer.render(buffer);
```

### 关键要点

1. **维护两个 buffer**: prevBuffer 和 currBuffer
2. **逐个比较 cells**: 找出变化的位置
3. **只输出变化**: 减少终端输出量
4. **性能提升**: 从 O(rows × cols) 到 O(changed cells)

---

## 核心 2: 创建基础自定义编辑器

### 核心概念

**编辑器 = 状态 + 渲染 + 输入处理**

```typescript
interface EditorComponent {
  render(ctx: RenderContext): Component;  // 如何展示
  handleKey(key: KeyEvent): boolean;      // 如何响应
  getValue(): string;                     // 获取值
}
```

### 最小实现

**步骤 1: 定义状态**
```typescript
class MinimalEditor implements EditorComponent {
  private value: string = '';
  private cursor: number = 0;
}
```

**步骤 2: 实现渲染**
```typescript
render(ctx: RenderContext): Component {
  return {
    type: 'text',
    content: this.value,
    cursor: ctx.focused ? this.cursor : undefined
  };
}
```

**步骤 3: 实现输入处理**
```typescript
handleKey(key: KeyEvent): boolean {
  switch (key.name) {
    case 'backspace':
      if (this.cursor > 0) {
        this.value = this.value.slice(0, this.cursor - 1) +
                     this.value.slice(this.cursor);
        this.cursor--;
      }
      return true;

    case 'left':
      if (this.cursor > 0) this.cursor--;
      return true;

    case 'right':
      if (this.cursor < this.value.length) this.cursor++;
      return true;

    default:
      // 插入字符
      if (key.sequence && !key.ctrl && !key.meta) {
        this.value = this.value.slice(0, this.cursor) +
                     key.sequence +
                     this.value.slice(this.cursor);
        this.cursor += key.sequence.length;
        return true;
      }
      return false;
  }
}
```

**步骤 4: 实现状态管理**
```typescript
getValue(): string {
  return this.value;
}

setValue(value: string): void {
  this.value = value;
  this.cursor = value.length;
}
```

### 完整示例

```typescript
class SimpleTextEditor implements EditorComponent {
  private value: string = '';
  private cursor: number = 0;

  render(ctx: RenderContext): Component {
    // 简化的渲染逻辑
    const beforeCursor = this.value.slice(0, this.cursor);
    const atCursor = this.value[this.cursor] || ' ';
    const afterCursor = this.value.slice(this.cursor + 1);

    let output = beforeCursor;
    if (ctx.focused) {
      output += `\x1b[7m${atCursor}\x1b[0m`;  // 反色显示光标
    } else {
      output += atCursor;
    }
    output += afterCursor;

    return { type: 'text', content: output };
  }

  handleKey(key: KeyEvent): boolean {
    switch (key.name) {
      case 'backspace':
        if (this.cursor > 0) {
          this.value = this.value.slice(0, this.cursor - 1) +
                       this.value.slice(this.cursor);
          this.cursor--;
        }
        return true;

      case 'delete':
        if (this.cursor < this.value.length) {
          this.value = this.value.slice(0, this.cursor) +
                       this.value.slice(this.cursor + 1);
        }
        return true;

      case 'left':
        if (this.cursor > 0) this.cursor--;
        return true;

      case 'right':
        if (this.cursor < this.value.length) this.cursor++;
        return true;

      case 'home':
        this.cursor = 0;
        return true;

      case 'end':
        this.cursor = this.value.length;
        return true;

      default:
        if (key.sequence && !key.ctrl && !key.meta) {
          this.value = this.value.slice(0, this.cursor) +
                       key.sequence +
                       this.value.slice(this.cursor);
          this.cursor += key.sequence.length;
          return true;
        }
        return false;
    }
  }

  getValue(): string {
    return this.value;
  }

  setValue(value: string): void {
    this.value = value;
    this.cursor = value.length;
  }
}

// 使用
const editor = new SimpleTextEditor();
editor.setValue('Hello World');

// 模拟按键
editor.handleKey({ name: 'end', sequence: '', ctrl: false, meta: false, shift: false });
editor.handleKey({ name: 'backspace', sequence: '', ctrl: false, meta: false, shift: false });
editor.handleKey({ name: '', sequence: '!', ctrl: false, meta: false, shift: false });

console.log(editor.getValue());  // "Hello World!"
```

### 关键要点

1. **状态管理**: value + cursor
2. **渲染逻辑**: 显示文本 + 光标
3. **输入处理**: 插入、删除、移动光标
4. **返回值**: handleKey 返回 true 表示已处理

---

## 核心 3: 创建简单 Widget

### 核心概念

**Widget = 组件 + 定位**

```typescript
interface Component {
  render(ctx: RenderContext): string;
  getSize?(): { width: number; height: number };
}

interface OverlayPosition {
  type: 'absolute' | 'anchor';
  x?: number;
  y?: number;
  anchor?: string;
}
```

### 最小实现

**步骤 1: 创建 Widget 组件**
```typescript
class TooltipWidget implements Component {
  constructor(private text: string) {}

  render(ctx: RenderContext): string {
    const border = '─'.repeat(this.text.length + 2);
    return `┌${border}┐\n│ ${this.text} │\n└${border}┘`;
  }

  getSize(): { width: number; height: number } {
    return {
      width: this.text.length + 4,
      height: 3
    };
  }
}
```

**步骤 2: 实现定位**
```typescript
function positionWidget(
  widget: Component,
  position: OverlayPosition,
  terminal: { width: number; height: number }
): { x: number; y: number } {
  if (position.type === 'absolute') {
    return { x: position.x!, y: position.y! };
  }

  // Anchor positioning
  const size = widget.getSize?.() || { width: 0, height: 0 };

  switch (position.anchor) {
    case 'top-left':
      return { x: 0, y: 0 };
    case 'top-right':
      return { x: terminal.width - size.width, y: 0 };
    case 'bottom-left':
      return { x: 0, y: terminal.height - size.height };
    case 'bottom-right':
      return { x: terminal.width - size.width, y: terminal.height - size.height };
    case 'center':
      return {
        x: Math.floor((terminal.width - size.width) / 2),
        y: Math.floor((terminal.height - size.height) / 2)
      };
    default:
      return { x: 0, y: 0 };
  }
}
```

**步骤 3: 渲染 Widget**
```typescript
function renderWidget(
  widget: Component,
  position: { x: number; y: number }
): void {
  const content = widget.render({ width: 80, height: 24, focused: false });
  const lines = content.split('\n');

  lines.forEach((line, i) => {
    const row = position.y + i;
    const col = position.x;
    process.stdout.write(`\x1b[${row + 1};${col + 1}H${line}`);
  });
}
```

### 完整示例

```typescript
// 创建 Tooltip
const tooltip = new TooltipWidget('Press Enter to submit');

// 定位到右下角
const terminal = { width: 80, height: 24 };
const position = positionWidget(
  tooltip,
  { type: 'anchor', anchor: 'bottom-right' },
  terminal
);

// 渲染
renderWidget(tooltip, position);

// 创建 Progress Bar Widget
class ProgressBarWidget implements Component {
  constructor(private progress: number, private width: number = 20) {}

  render(ctx: RenderContext): string {
    const filled = Math.floor(this.width * this.progress / 100);
    const empty = this.width - filled;
    return `[${'█'.repeat(filled)}${'░'.repeat(empty)}] ${this.progress}%`;
  }

  getSize(): { width: number; height: number } {
    return { width: this.width + 8, height: 1 };
  }

  setProgress(progress: number): void {
    this.progress = Math.max(0, Math.min(100, progress));
  }
}

// 使用
const progressBar = new ProgressBarWidget(50, 30);
const progressPos = positionWidget(
  progressBar,
  { type: 'anchor', anchor: 'bottom-left' },
  terminal
);
renderWidget(progressBar, progressPos);
```

### 关键要点

1. **组件接口**: render() + getSize()
2. **定位策略**: absolute 或 anchor
3. **边界处理**: 确保不超出终端范围
4. **渲染逻辑**: 逐行输出到指定位置

---

## 核心 4: 使用 CSI 2026 消除闪烁

### 核心概念

**CSI 2026 = 原子化输出**

```typescript
// 传统方式 (有闪烁)
terminal.write(0, 0, 'A');
terminal.write(0, 1, 'B');
terminal.write(0, 2, 'C');

// CSI 2026 (无闪烁)
terminal.write('\x1b[?2026h');  // Begin sync
terminal.write(0, 0, 'A');
terminal.write(0, 1, 'B');
terminal.write(0, 2, 'C');
terminal.write('\x1b[?2026l');  // End sync
```

### 最小实现

**封装函数**:
```typescript
function withSync(fn: () => void): void {
  process.stdout.write('\x1b[?2026h');  // Begin
  fn();
  process.stdout.write('\x1b[?2026l');  // End
}

// 使用
withSync(() => {
  process.stdout.write('\x1b[1;1HHello');
  process.stdout.write('\x1b[2;1HWorld');
});
```

### 完整示例

```typescript
class SyncRenderer {
  private syncSupported: boolean;

  constructor() {
    this.syncSupported = this.detectSyncSupport();
  }

  private detectSyncSupport(): boolean {
    // 检测终端是否支持 CSI 2026
    return process.env.TERM_PROGRAM === 'iTerm.app' ||
           process.env.TERM_PROGRAM === 'WezTerm' ||
           process.env.TERM_PROGRAM === 'vscode';
  }

  render(fn: () => void): void {
    if (this.syncSupported) {
      process.stdout.write('\x1b[?2026h');
    }

    fn();

    if (this.syncSupported) {
      process.stdout.write('\x1b[?2026l');
    }
  }
}

// 使用
const renderer = new SyncRenderer();

renderer.render(() => {
  // 所有输出都会被缓冲，然后原子化显示
  for (let i = 0; i < 10; i++) {
    process.stdout.write(`\x1b[${i + 1};1HLine ${i}`);
  }
});
```

### 集成到差分渲染

```typescript
class DiffRendererWithSync extends SimpleDiffRenderer {
  private syncRenderer: SyncRenderer;

  constructor(rows: number, cols: number) {
    super(rows, cols);
    this.syncRenderer = new SyncRenderer();
  }

  render(currBuffer: Cell[][]): void {
    this.syncRenderer.render(() => {
      super.render(currBuffer);
    });
  }
}

// 使用
const renderer = new DiffRendererWithSync(24, 80);
renderer.render(buffer);  // 无闪烁渲染
```

### 关键要点

1. **Begin sync**: `\x1b[?2026h`
2. **End sync**: `\x1b[?2026l`
3. **兼容性检测**: 不是所有终端都支持
4. **降级策略**: 不支持时正常输出

---

## 用这些知识你能做什么

### 场景 1: 简单的状态显示

```typescript
// 创建一个简单的状态栏
class StatusBar implements Component {
  constructor(private status: string) {}

  render(ctx: RenderContext): string {
    return `Status: ${this.status}`;
  }

  getSize(): { width: number; height: number } {
    return { width: this.status.length + 8, height: 1 };
  }

  setStatus(status: string): void {
    this.status = status;
  }
}

const statusBar = new StatusBar('Ready');
const position = positionWidget(
  statusBar,
  { type: 'anchor', anchor: 'bottom-left' },
  { width: 80, height: 24 }
);

// 更新状态
statusBar.setStatus('Processing...');
renderWidget(statusBar, position);
```

### 场景 2: 简单的输入表单

```typescript
class SimpleForm {
  private nameEditor = new SimpleTextEditor();
  private emailEditor = new SimpleTextEditor();
  private focusedField: 'name' | 'email' = 'name';

  render(): void {
    console.clear();

    console.log('Name:');
    console.log(this.nameEditor.render({
      width: 80,
      height: 1,
      focused: this.focusedField === 'name'
    }).content);

    console.log('\nEmail:');
    console.log(this.emailEditor.render({
      width: 80,
      height: 1,
      focused: this.focusedField === 'email'
    }).content);
  }

  handleKey(key: KeyEvent): boolean {
    if (key.name === 'tab') {
      this.focusedField = this.focusedField === 'name' ? 'email' : 'name';
      return true;
    }

    const editor = this.focusedField === 'name' ? this.nameEditor : this.emailEditor;
    return editor.handleKey(key);
  }

  getValues(): { name: string; email: string } {
    return {
      name: this.nameEditor.getValue(),
      email: this.emailEditor.getValue()
    };
  }
}

// 使用
const form = new SimpleForm();
form.render();
```

### 场景 3: 简单的加载指示器

```typescript
class LoadingSpinner implements Component {
  private frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
  private currentFrame = 0;

  render(ctx: RenderContext): string {
    return `${this.frames[this.currentFrame]} Loading...`;
  }

  getSize(): { width: number; height: number } {
    return { width: 12, height: 1 };
  }

  tick(): void {
    this.currentFrame = (this.currentFrame + 1) % this.frames.length;
  }
}

// 使用
const spinner = new LoadingSpinner();
const position = positionWidget(
  spinner,
  { type: 'anchor', anchor: 'center' },
  { width: 80, height: 24 }
);

const interval = setInterval(() => {
  spinner.tick();
  renderWidget(spinner, position);
}, 100);

// 停止
setTimeout(() => clearInterval(interval), 5000);
```

### 场景 4: 简单的通知系统

```typescript
class NotificationManager {
  private notifications: Array<{ widget: Component; position: { x: number; y: number } }> = [];

  show(message: string, duration: number = 3000): void {
    const notification = new TooltipWidget(message);
    const position = positionWidget(
      notification,
      { type: 'anchor', anchor: 'top-right' },
      { width: 80, height: 24 }
    );

    this.notifications.push({ widget: notification, position });
    this.render();

    setTimeout(() => {
      this.notifications = this.notifications.filter(n => n.widget !== notification);
      this.render();
    }, duration);
  }

  private render(): void {
    withSync(() => {
      this.notifications.forEach(({ widget, position }) => {
        renderWidget(widget, position);
      });
    });
  }
}

// 使用
const notificationManager = new NotificationManager();
notificationManager.show('File saved successfully');
notificationManager.show('Connection established');
```

---

## 总结

### 你已经掌握的核心知识

**1. 差分渲染**:
- 维护 prevBuffer 和 currBuffer
- 逐个比较 cells，只更新变化
- 性能提升 20-100x

**2. 自定义编辑器**:
- 状态: value + cursor
- 渲染: 显示文本 + 光标
- 输入: 插入、删除、移动

**3. Widget 组件**:
- 组件: render() + getSize()
- 定位: absolute 或 anchor
- 渲染: 逐行输出到指定位置

**4. CSI 2026**:
- Begin: `\x1b[?2026h`
- End: `\x1b[?2026l`
- 效果: 消除闪烁

### 你能解决的问题

- ✅ 创建流畅的终端 UI
- ✅ 实现基础的文本编辑
- ✅ 构建简单的 Widget 组件
- ✅ 消除渲染闪烁

### 下一步

**如果需要更深入的理解**:
- 阅读 **02_第一性原理.md** - 理解为什么这样设计
- 阅读 **03_核心概念_01_pi-tui差分渲染.md** - 深入 3-tier 策略

**如果需要更多实战经验**:
- 阅读 **07_实战代码_01_基础差分渲染实现.md** - 完整实现
- 阅读 **07_实战代码_02_自定义编辑器开发.md** - 高级编辑器
- 阅读 **07_实战代码_03_Widget组件创建.md** - 复杂 Widget

**如果需要优化性能**:
- 阅读 **07_实战代码_05_性能优化实战.md** - 性能调优技术

---

**记住**: 这 20% 的核心知识足以解决 80% 的实际问题。先用起来，再深入优化！

---

**版本**: v1.0
**最后更新**: 2026-02-21
**维护者**: Claude Code
