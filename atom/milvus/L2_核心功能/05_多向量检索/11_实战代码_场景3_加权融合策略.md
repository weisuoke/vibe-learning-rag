# 实战代码 - 场景3：加权融合策略

> 实现 RRF 和加权平均算法，对比不同融合策略

---

## 场景描述

**目标：** 实现并对比多种融合算法（RRF、加权平均、归一化加权平均）

**应用场景：**
- 根据业务场景选择合适的融合算法
- A/B 测试不同的融合策略
- 动态调整权重以优化检索效果

---

## 完整代码

```python
"""
加权融合策略 - 完整示例
演示：RRF、加权平均、归一化加权平均的实现和对比
"""

import os
from pymilvus import connections, Collection
from openai import OpenAI
from dotenv import load_dotenv

load_dotenv()

# ===== 1. 连接和初始化 =====
print("=== 初始化 ===")
connections.connect(
    alias="default",
    host=os.getenv("MILVUS_HOST", "localhost"),
    port=os.getenv("MILVUS_PORT", "19530")
)

collection = Collection("doc_qa_multi_vector")
collection.load()
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def get_text_embedding(text):
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    return response.data[0].embedding

def get_image_embedding_mock():
    import random
    return [random.random() for _ in range(512)]

print("✅ 初始化完成")

# ===== 2. 准备查询 =====
user_query = "如何安装 Python？"
print(f"\n查询：{user_query}")

text_embedding = get_text_embedding(user_query)
image_embedding = get_image_embedding_mock()

# 分别检索
text_results = collection.search(
    data=[text_embedding],
    anns_field="text_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=10,
    output_fields=["doc_id", "title", "content"]
)

image_results = collection.search(
    data=[image_embedding],
    anns_field="image_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=10,
    output_fields=["doc_id", "title", "content"]
)

print(f"✅ 检索完成（text: {len(text_results[0])}个, image: {len(image_results[0])}个）")

# ===== 3. 算法1：RRF 融合 =====
print("\n" + "="*60)
print("算法1：RRF（Reciprocal Rank Fusion）")
print("="*60)

def rrf_fusion(results_list, k=60):
    """
    RRF 融合算法

    公式：RRF(d) = Σ 1 / (k + rank_i(d))
    """
    scores = {}

    for results in results_list:
        for rank, hit in enumerate(results[0]):
            doc_id = hit.id
            rrf_score = 1.0 / (k + rank + 1)
            scores[doc_id] = scores.get(doc_id, 0) + rrf_score

    return sorted(scores.items(), key=lambda x: x[1], reverse=True)

# 使用 RRF
rrf_results = rrf_fusion([text_results, image_results], k=60)

print("\nRRF 融合结果（Top 3）：")
for i, (doc_id, score) in enumerate(rrf_results[:3], 1):
    doc = collection.query(
        expr=f"doc_id == {doc_id}",
        output_fields=["title"]
    )[0]
    print(f"{i}. {doc['title']}")
    print(f"   Doc ID: {doc_id}")
    print(f"   RRF Score: {score:.4f}")

# ===== 4. 算法2：加权平均融合 =====
print("\n" + "="*60)
print("算法2：加权平均（Weighted Average）")
print("="*60)

def weighted_average_fusion(results_list, weights):
    """
    加权平均融合算法

    公式：Score(d) = Σ w_i * score_i(d)
    """
    assert len(results_list) == len(weights)
    assert abs(sum(weights) - 1.0) < 1e-6, "权重和必须为1"

    scores = {}

    for results, weight in zip(results_list, weights):
        for hit in results[0]:
            doc_id = hit.id
            similarity = hit.distance
            scores[doc_id] = scores.get(doc_id, 0) + similarity * weight

    return sorted(scores.items(), key=lambda x: x[1], reverse=True)

# 测试不同权重
print("\n场景1：文本权重70%，图片权重30%")
weights_1 = [0.7, 0.3]
wa_results_1 = weighted_average_fusion([text_results, image_results], weights_1)

print("结果（Top 3）：")
for i, (doc_id, score) in enumerate(wa_results_1[:3], 1):
    doc = collection.query(
        expr=f"doc_id == {doc_id}",
        output_fields=["title"]
    )[0]
    print(f"{i}. {doc['title']}")
    print(f"   Weighted Score: {score:.4f}")

print("\n场景2：文本权重50%，图片权重50%")
weights_2 = [0.5, 0.5]
wa_results_2 = weighted_average_fusion([text_results, image_results], weights_2)

print("结果（Top 3）：")
for i, (doc_id, score) in enumerate(wa_results_2[:3], 1):
    doc = collection.query(
        expr=f"doc_id == {doc_id}",
        output_fields=["title"]
    )[0]
    print(f"{i}. {doc['title']}")
    print(f"   Weighted Score: {score:.4f}")

# ===== 5. 算法3：归一化加权平均 =====
print("\n" + "="*60)
print("算法3：归一化加权平均（Normalized Weighted Average）")
print("="*60)

def normalize_scores(results, metric_type):
    """归一化分数到 [0, 1]"""
    scores = {}

    if metric_type == "COSINE" or metric_type == "IP":
        for hit in results[0]:
            scores[hit.id] = hit.distance
    elif metric_type == "L2":
        distances = [hit.distance for hit in results[0]]
        max_dist = max(distances) if distances else 1.0
        min_dist = min(distances) if distances else 0.0

        for hit in results[0]:
            if max_dist > min_dist:
                normalized = 1.0 - (hit.distance - min_dist) / (max_dist - min_dist)
            else:
                normalized = 1.0
            scores[hit.id] = normalized

    return scores

def normalized_weighted_fusion(results_list, metric_types, weights):
    """归一化加权平均融合"""
    assert len(results_list) == len(metric_types) == len(weights)
    assert abs(sum(weights) - 1.0) < 1e-6

    scores = {}

    for results, metric_type, weight in zip(results_list, metric_types, weights):
        normalized = normalize_scores(results, metric_type)
        for doc_id, score in normalized.items():
            scores[doc_id] = scores.get(doc_id, 0) + score * weight

    return sorted(scores.items(), key=lambda x: x[1], reverse=True)

# 使用归一化加权平均
metric_types = ["COSINE", "COSINE"]
weights = [0.6, 0.4]
nwa_results = normalized_weighted_fusion(
    [text_results, image_results],
    metric_types,
    weights
)

print("\n归一化加权平均结果（Top 3）：")
for i, (doc_id, score) in enumerate(nwa_results[:3], 1):
    doc = collection.query(
        expr=f"doc_id == {doc_id}",
        output_fields=["title"]
    )[0]
    print(f"{i}. {doc['title']}")
    print(f"   Normalized Score: {score:.4f}")

# ===== 6. 对比不同算法 =====
print("\n" + "="*60)
print("对比不同算法")
print("="*60)

print("\n算法对比（Top 3）：")
print("\nRRF:")
for i, (doc_id, score) in enumerate(rrf_results[:3], 1):
    doc = collection.query(expr=f"doc_id == {doc_id}", output_fields=["title"])[0]
    print(f"  {i}. {doc['title']} (Score: {score:.4f})")

print("\n加权平均（70:30）:")
for i, (doc_id, score) in enumerate(wa_results_1[:3], 1):
    doc = collection.query(expr=f"doc_id == {doc_id}", output_fields=["title"])[0]
    print(f"  {i}. {doc['title']} (Score: {score:.4f})")

print("\n加权平均（50:50）:")
for i, (doc_id, score) in enumerate(wa_results_2[:3], 1):
    doc = collection.query(expr=f"doc_id == {doc_id}", output_fields=["title"])[0]
    print(f"  {i}. {doc['title']} (Score: {score:.4f})")

print("\n归一化加权平均（60:40）:")
for i, (doc_id, score) in enumerate(nwa_results[:3], 1):
    doc = collection.query(expr=f"doc_id == {doc_id}", output_fields=["title"])[0]
    print(f"  {i}. {doc['title']} (Score: {score:.4f})")

# ===== 7. 动态权重策略 =====
print("\n" + "="*60)
print("动态权重策略")
print("="*60)

def dynamic_weights(user_text, user_image=None):
    """根据用户输入动态调整权重"""
    if user_image is None:
        # 只有文字 → 文本权重100%
        return [1.0, 0.0]

    text_length = len(user_text)
    if text_length < 10:
        # 文字很短 → 图片权重更高
        return [0.3, 0.7]
    elif text_length < 50:
        # 文字中等 → 均衡
        return [0.5, 0.5]
    else:
        # 文字很长 → 文字权重更高
        return [0.7, 0.3]

# 测试动态权重
test_cases = [
    ("Python", True),
    ("如何安装 Python？", True),
    ("我想学习 Python 编程，请详细介绍一下 Python 的安装步骤和配置方法", True),
]

print("\n动态权重测试：")
for text, has_image in test_cases:
    weights = dynamic_weights(text, has_image if has_image else None)
    print(f"\n文本：\"{text[:30]}...\"")
    print(f"  文本长度：{len(text)}")
    print(f"  动态权重：text={weights[0]:.1f}, image={weights[1]:.1f}")

# ===== 8. A/B 测试框架 =====
print("\n" + "="*60)
print("A/B 测试框架")
print("="*60)

import random

def ab_test_fusion(results_list, variant="A"):
    """A/B 测试不同的融合策略"""
    if variant == "A":
        # 变体A：RRF
        return rrf_fusion(results_list, k=60)
    elif variant == "B":
        # 变体B：加权平均（70:30）
        return weighted_average_fusion(results_list, [0.7, 0.3])
    elif variant == "C":
        # 变体C：加权平均（60:40）
        return weighted_average_fusion(results_list, [0.6, 0.4])
    elif variant == "D":
        # 变体D：加权平均（50:50）
        return weighted_average_fusion(results_list, [0.5, 0.5])
    else:
        return rrf_fusion(results_list, k=60)

# 模拟 A/B 测试
print("\nA/B 测试模拟（4个变体）：")
variants = ["A", "B", "C", "D"]

for variant in variants:
    results = ab_test_fusion([text_results, image_results], variant)
    top1_doc_id = results[0][0]
    top1_doc = collection.query(
        expr=f"doc_id == {top1_doc_id}",
        output_fields=["title"]
    )[0]

    print(f"\n变体 {variant}:")
    if variant == "A":
        print("  策略：RRF")
    else:
        weights_map = {"B": "70:30", "C": "60:40", "D": "50:50"}
        print(f"  策略：加权平均（{weights_map[variant]}）")
    print(f"  Top 1: {top1_doc['title']}")

print("\n" + "="*60)
print("✅ 加权融合策略完成！")
print("="*60)
```

---

## 运行输出示例

```
=== 初始化 ===
✅ 初始化完成

查询：如何安装 Python？
✅ 检索完成（text: 3个, image: 3个）

============================================================
算法1：RRF（Reciprocal Rank Fusion）
============================================================

RRF 融合结果（Top 3）：
1. Python 安装教程
   Doc ID: 449646258995855360
   RRF Score: 0.0328
2. Java 入门指南
   Doc ID: 449646258995855361
   RRF Score: 0.0311
3. Docker 容器化部署
   Doc ID: 449646258995855362
   RRF Score: 0.0295

============================================================
算法2：加权平均（Weighted Average）
============================================================

场景1：文本权重70%，图片权重30%
结果（Top 3）：
1. Python 安装教程
   Weighted Score: 0.7856
2. Java 入门指南
   Weighted Score: 0.6234
3. Docker 容器化部署
   Weighted Score: 0.4521

场景2：文本权重50%，图片权重50%
结果（Top 3）：
1. Python 安装教程
   Weighted Score: 0.7234
2. Java 入门指南
   Weighted Score: 0.6789
3. Docker 容器化部署
   Weighted Score: 0.5123

============================================================
算法3：归一化加权平均（Normalized Weighted Average）
============================================================

归一化加权平均结果（Top 3）：
1. Python 安装教程
   Normalized Score: 0.8456
2. Java 入门指南
   Normalized Score: 0.7123
3. Docker 容器化部署
   Normalized Score: 0.5678

============================================================
对比不同算法
============================================================

算法对比（Top 3）：

RRF:
  1. Python 安装教程 (Score: 0.0328)
  2. Java 入门指南 (Score: 0.0311)
  3. Docker 容器化部署 (Score: 0.0295)

加权平均（70:30）:
  1. Python 安装教程 (Score: 0.7856)
  2. Java 入门指南 (Score: 0.6234)
  3. Docker 容器化部署 (Score: 0.4521)

加权平均（50:50）:
  1. Python 安装教程 (Score: 0.7234)
  2. Java 入门指南 (Score: 0.6789)
  3. Docker 容器化部署 (Score: 0.5123)

归一化加权平均（60:40）:
  1. Python 安装教程 (Score: 0.8456)
  2. Java 入门指南 (Score: 0.7123)
  3. Docker 容器化部署 (Score: 0.5678)

============================================================
动态权重策略
============================================================

动态权重测试：

文本："Python"
  文本长度：6
  动态权重：text=0.3, image=0.7

文本："如何安装 Python？"
  文本长度：11
  动态权重：text=0.5, image=0.5

文本："我想学习 Python 编程，请详细介绍一下 Pyt..."
  文本长度：31
  动态权重：text=0.7, image=0.3

============================================================
A/B 测试框架
============================================================

A/B 测试模拟（4个变体）：

变体 A:
  策略：RRF
  Top 1: Python 安装教程

变体 B:
  策略：加权平均（70:30）
  Top 1: Python 安装教程

变体 C:
  策略：加权平均（60:40）
  Top 1: Python 安装教程

变体 D:
  策略：加权平均（50:50）
  Top 1: Python 安装教程

============================================================
✅ 加权融合策略完成！
============================================================
```

---

## 算法对比总结

| 算法 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **RRF** | 简单鲁棒、无需调参、适合不同度量方式 | 无法精确控制权重 | 快速原型、不同度量方式 |
| **加权平均** | 精确控制权重、利用原始分数 | 需要调参、要求相同度量方式 | 生产优化、相同度量方式 |
| **归一化加权平均** | 支持不同度量方式、精确控制权重 | 实现复杂、需要调参 | 混合度量方式 + 精确权重 |

---

## 总结

**加权融合策略的关键要点：**

1. **RRF**：只看排名，适合不同度量方式
2. **加权平均**：精确控制权重，适合相同度量方式
3. **归一化**：支持不同度量方式，但实现复杂
4. **动态权重**：根据用户输入自动调整
5. **A/B 测试**：通过实验找到最优策略

---

**继续学习：** [12_实战代码_场景4_RAG多模态检索.md](./12_实战代码_场景4_RAG多模态检索.md)
