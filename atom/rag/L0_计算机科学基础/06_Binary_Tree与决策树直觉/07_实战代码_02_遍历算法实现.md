# 遍历算法实现 - 实战代码

> 四种遍历的递归+迭代实现

---

## 完整代码

```python
"""
树的遍历算法实现
演示：前序、中序、后序、层序遍历（递归+迭代）
"""

from collections import deque

class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

# ===== 1. 前序遍历 =====
def preorder_recursive(root):
    """前序遍历（递归）：根→左→右"""
    if not root:
        return []
    return [root.val] + preorder_recursive(root.left) + preorder_recursive(root.right)

def preorder_iterative(root):
    """前序遍历（迭代）：使用栈"""
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # 先右后左（因为栈是 LIFO）
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result

# ===== 2. 中序遍历 =====
def inorder_recursive(root):
    """中序遍历（递归）：左→根→右"""
    if not root:
        return []
    return inorder_recursive(root.left) + [root.val] + inorder_recursive(root.right)

def inorder_iterative(root):
    """中序遍历（迭代）：使用栈"""
    result = []
    stack = []
    current = root
    
    while current or stack:
        # 一直往左走
        while current:
            stack.append(current)
            current = current.left
        
        # 访问节点
        current = stack.pop()
        result.append(current.val)
        
        # 转向右子树
        current = current.right
    
    return result

# ===== 3. 后序遍历 =====
def postorder_recursive(root):
    """后序遍历（递归）：左→右→根"""
    if not root:
        return []
    return postorder_recursive(root.left) + postorder_recursive(root.right) + [root.val]

def postorder_iterative(root):
    """后序遍历（迭代）：使用栈"""
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # 先左后右
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    
    # 反转结果（根右左 → 左右根）
    return result[::-1]

# ===== 4. 层序遍历 =====
def levelorder(root):
    """层序遍历：使用队列"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        result.append(node.val)
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return result

def levelorder_by_level(root):
    """层序遍历：按层分组"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        level_nodes = []
        
        for _ in range(level_size):
            node = queue.popleft()
            level_nodes.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level_nodes)
    
    return result

# ===== 5. 构建测试树 =====
def build_test_tree():
    """构建测试树"""
    #       1
    #      / \
    #     2   3
    #    / \
    #   4   5
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    return root

# ===== 测试代码 =====
if __name__ == "__main__":
    print("=== 树的遍历算法测试 ===\n")
    
    # 构建测试树
    root = build_test_tree()
    
    print("树结构:")
    print("       1")
    print("      / \\")
    print("     2   3")
    print("    / \\")
    print("   4   5")
    print()
    
    # 前序遍历
    print("前序遍历（递归）:", preorder_recursive(root))
    print("前序遍历（迭代）:", preorder_iterative(root))
    print()
    
    # 中序遍历
    print("中序遍历（递归）:", inorder_recursive(root))
    print("中序遍历（迭代）:", inorder_iterative(root))
    print()
    
    # 后序遍历
    print("后序遍历（递归）:", postorder_recursive(root))
    print("后序遍历（迭代）:", postorder_iterative(root))
    print()
    
    # 层序遍历
    print("层序遍历:", levelorder(root))
    print("层序遍历（按层）:", levelorder_by_level(root))
```

## 运行输出

```
=== 树的遍历算法测试 ===

树结构:
       1
      / \
     2   3
    / \
   4   5

前序遍历（递归）: [1, 2, 4, 5, 3]
前序遍历（迭代）: [1, 2, 4, 5, 3]

中序遍历（递归）: [4, 2, 5, 1, 3]
中序遍历（迭代）: [4, 2, 5, 1, 3]

后序遍历（递归）: [4, 5, 2, 3, 1]
后序遍历（迭代）: [4, 5, 2, 3, 1]

层序遍历: [1, 2, 3, 4, 5]
层序遍历（按层）: [[1], [2, 3], [4, 5]]
```

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+
