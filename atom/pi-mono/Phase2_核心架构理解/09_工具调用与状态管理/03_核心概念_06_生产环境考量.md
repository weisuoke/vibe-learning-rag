# 核心概念 06：生产环境考量

## 概述

生产环境部署需要考虑可靠性、性能、可观测性、安全性和成本。Pi-mono 的设计为生产环境提供了良好基础，但需要额外优化。

---

## 数据库 vs 文件存储

### 文件存储（JSONL）适用场景

**适合：**
- 单用户/小团队（< 10 人）
- 原型开发和 MVP
- 本地开发工具
- 低并发（< 10 QPS）

**优势：** 零依赖、部署简单、易调试、崩溃安全

**限制：** 无复杂查询、并发控制有限、不支持分布式

### 数据库适用场景

**适合：**
- 多用户 SaaS（> 100 用户）
- 高并发（> 100 QPS）
- 需要复杂查询
- 分布式部署

**推荐方案：PostgreSQL + JSONB**

```typescript
// 表结构
CREATE TABLE sessions (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  metadata JSONB
);

CREATE TABLE session_entries (
  id UUID PRIMARY KEY,
  session_id UUID REFERENCES sessions(id),
  parent_id UUID,
  timestamp BIGINT NOT NULL,
  type VARCHAR(20) NOT NULL,
  content TEXT NOT NULL,
  metadata JSONB,
  INDEX idx_session_parent (session_id, parent_id),
  INDEX idx_timestamp (timestamp)
);
```

### 混合方案

```typescript
// 热数据用数据库，冷数据归档到 JSONL
class HybridStorage {
  async append(entry: SessionEntry) {
    // 写入数据库
    await db.sessionEntries.create(entry);

    // 定期归档（30 天前的数据）
    if (shouldArchive(entry.session_id)) {
      await this.archiveToJSONL(entry.session_id);
    }
  }

  async archiveToJSONL(sessionId: string) {
    const entries = await db.sessionEntries.findMany({
      where: {
        session_id: sessionId,
        timestamp: { lt: Date.now() - 30 * 24 * 3600 * 1000 }
      }
    });

    const jsonl = entries.map(e => JSON.stringify(e)).join('\n');
    await s3.upload(`archives/${sessionId}.jsonl`, jsonl);

    // 删除已归档的数据
    await db.sessionEntries.deleteMany({
      where: { id: { in: entries.map(e => e.id) } }
    });
  }
}
```

---

## 可观测性

### 1. 日志记录

```typescript
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// 记录工具调用
logger.info('tool_execution', {
  tool_name: 'read',
  params: { path: './config.json' },
  duration_ms: 15,
  success: true
});

// 记录验证失败
logger.warn('validation_failed', {
  tool_name: 'read',
  errors: validate.errors,
  params: params
});
```

### 2. 指标监控

```typescript
import { Counter, Histogram } from 'prom-client';

// 工具调用计数
const toolCallCounter = new Counter({
  name: 'tool_calls_total',
  help: 'Total number of tool calls',
  labelNames: ['tool_name', 'status']
});

// 工具执行时间
const toolDurationHistogram = new Histogram({
  name: 'tool_execution_duration_seconds',
  help: 'Tool execution duration',
  labelNames: ['tool_name'],
  buckets: [0.01, 0.05, 0.1, 0.5, 1, 5]
});

// 使用
async function executeTool(name: string, params: unknown) {
  const start = Date.now();

  try {
    const result = await tool.execute(params);
    toolCallCounter.inc({ tool_name: name, status: 'success' });
    return result;
  } catch (error) {
    toolCallCounter.inc({ tool_name: name, status: 'error' });
    throw error;
  } finally {
    const duration = (Date.now() - start) / 1000;
    toolDurationHistogram.observe({ tool_name: name }, duration);
  }
}
```

### 3. 分布式追踪

```typescript
import { trace, context } from '@opentelemetry/api';

const tracer = trace.getTracer('agent');

async function executeToolWithTracing(name: string, params: unknown) {
  return tracer.startActiveSpan(`tool.${name}`, async (span) => {
    span.setAttribute('tool.name', name);
    span.setAttribute('tool.params', JSON.stringify(params));

    try {
      const result = await tool.execute(params);
      span.setAttribute('tool.result.length', result.output.length);
      span.setStatus({ code: 0 });
      return result;
    } catch (error) {
      span.recordException(error);
      span.setStatus({ code: 2, message: error.message });
      throw error;
    } finally {
      span.end();
    }
  });
}
```

---

## 性能优化

### 1. 连接池

```typescript
import { Pool } from 'pg';

const pool = new Pool({
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000
});

// 使用连接池
async function saveEntry(entry: SessionEntry) {
  const client = await pool.connect();
  try {
    await client.query(
      'INSERT INTO session_entries (id, session_id, content) VALUES ($1, $2, $3)',
      [entry.id, entry.session_id, entry.content]
    );
  } finally {
    client.release();
  }
}
```

### 2. 批量写入

```typescript
class BatchWriter {
  private buffer: SessionEntry[] = [];
  private flushTimer: NodeJS.Timeout;

  constructor(
    private maxBatchSize = 100,
    private flushIntervalMs = 1000
  ) {
    this.flushTimer = setInterval(() => this.flush(), flushIntervalMs);
  }

  async append(entry: SessionEntry) {
    this.buffer.push(entry);
    if (this.buffer.length >= this.maxBatchSize) {
      await this.flush();
    }
  }

  async flush() {
    if (this.buffer.length === 0) return;

    const entries = this.buffer.splice(0);

    // 批量插入
    await db.sessionEntries.createMany({
      data: entries
    });
  }
}
```

### 3. 缓存策略

```typescript
import Redis from 'ioredis';

const redis = new Redis();

class CachedContextBuilder {
  async buildContext(sessionId: string, branchId: string) {
    const cacheKey = `context:${sessionId}:${branchId}`;

    // 尝试从缓存读取
    const cached = await redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }

    // 构建上下文
    const context = await this.buildContextFromDB(sessionId, branchId);

    // 写入缓存（5 分钟过期）
    await redis.setex(cacheKey, 300, JSON.stringify(context));

    return context;
  }
}
```

---

## 安全加固

### 1. 路径验证

```typescript
import path from 'path';

function validatePath(filePath: string, workDir: string): boolean {
  const resolved = path.resolve(workDir, filePath);

  // 必须在工作目录内
  if (!resolved.startsWith(workDir)) {
    throw new Error('Path must be within working directory');
  }

  // 禁止访问敏感文件
  const forbidden = ['.env', '.git', 'node_modules/.bin'];
  if (forbidden.some(f => resolved.includes(f))) {
    throw new Error('Access to sensitive files is forbidden');
  }

  return true;
}
```

### 2. 命令注入防护

```typescript
import { spawn } from 'child_process';

async function executeBash(command: string): Promise<string> {
  // 禁止危险命令
  const dangerous = ['rm -rf', 'dd if=', ':(){ :|:& };:'];
  if (dangerous.some(d => command.includes(d))) {
    throw new Error('Dangerous command detected');
  }

  // 使用 spawn 而非 exec（避免 shell 注入）
  const [cmd, ...args] = command.split(' ');
  const proc = spawn(cmd, args, {
    shell: false,  // 不使用 shell
    timeout: 120000
  });

  let output = '';
  proc.stdout.on('data', data => output += data);

  return new Promise((resolve, reject) => {
    proc.on('close', code => {
      if (code === 0) resolve(output);
      else reject(new Error(`Command failed with code ${code}`));
    });
  });
}
```

### 3. 速率限制

```typescript
import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
  windowMs: 60 * 1000,  // 1 分钟
  max: 100,  // 最多 100 次请求
  message: 'Too many requests, please try again later'
});

app.use('/api/agent', limiter);
```

---

## 成本控制

### 1. Token 使用监控

```typescript
class TokenTracker {
  private usage = new Map<string, number>();

  track(userId: string, tokens: number) {
    const current = this.usage.get(userId) || 0;
    this.usage.set(userId, current + tokens);

    // 检查配额
    if (current + tokens > 1000000) {  // 100 万 token 限制
      throw new Error('Token quota exceeded');
    }
  }

  async getUsage(userId: string): Promise<number> {
    return this.usage.get(userId) || 0;
  }
}
```

### 2. 模型选择策略

```typescript
function selectModel(taskComplexity: 'simple' | 'medium' | 'complex') {
  switch (taskComplexity) {
    case 'simple':
      return 'claude-3-5-haiku-20241022';  // 最便宜
    case 'medium':
      return 'claude-3-5-sonnet-20241022';  // 平衡
    case 'complex':
      return 'claude-opus-4-20250514';  // 最强
  }
}

// 自动检测复杂度
function detectComplexity(message: string): 'simple' | 'medium' | 'complex' {
  if (message.length < 100) return 'simple';
  if (message.includes('refactor') || message.includes('architecture')) {
    return 'complex';
  }
  return 'medium';
}
```

---

## 崩溃恢复

### 1. 健康检查

```typescript
app.get('/health', async (req, res) => {
  const checks = {
    database: await checkDatabase(),
    redis: await checkRedis(),
    disk: await checkDiskSpace()
  };

  const healthy = Object.values(checks).every(c => c);
  res.status(healthy ? 200 : 503).json(checks);
});

async function checkDatabase(): Promise<boolean> {
  try {
    await db.$queryRaw`SELECT 1`;
    return true;
  } catch {
    return false;
  }
}
```

### 2. 优雅关闭

```typescript
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully');

  // 停止接受新请求
  server.close();

  // 等待现有请求完成
  await waitForActiveRequests();

  // 刷新缓冲区
  await sessionWriter.flush();

  // 关闭数据库连接
  await db.$disconnect();

  process.exit(0);
});
```

---

## 部署架构

### 单机部署

```
┌─────────────────────────────────┐
│         Load Balancer           │
│         (Nginx/Caddy)           │
└────────────┬────────────────────┘
             │
┌────────────▼────────────────────┐
│       Agent Server              │
│  ┌──────────────────────────┐  │
│  │  Node.js Process         │  │
│  │  - Tool Registry         │  │
│  │  - Session Manager       │  │
│  │  - LLM Client            │  │
│  └──────────────────────────┘  │
│                                 │
│  ┌──────────────────────────┐  │
│  │  JSONL Files             │  │
│  │  /data/sessions/         │  │
│  └──────────────────────────┘  │
└─────────────────────────────────┘
```

### 分布式部署

```
┌─────────────────────────────────┐
│         Load Balancer           │
└────────┬────────────┬───────────┘
         │            │
┌────────▼───┐  ┌────▼──────────┐
│ Agent      │  │ Agent         │
│ Server 1   │  │ Server 2      │
└────────┬───┘  └────┬──────────┘
         │            │
         └────────┬───┘
                  │
         ┌────────▼────────────┐
         │   PostgreSQL        │
         │   (Primary)         │
         └────────┬────────────┘
                  │
         ┌────────▼────────────┐
         │   PostgreSQL        │
         │   (Replica)         │
         └─────────────────────┘
```

---

## 总结

**生产环境的五个关键考量：**

1. **存储选择**：文件（开发/小规模）vs 数据库（生产/大规模）
2. **可观测性**：日志、指标、追踪三位一体
3. **性能优化**：连接池、批量写入、缓存策略
4. **安全加固**：路径验证、命令注入防护、速率限制
5. **成本控制**：Token 监控、模型选择、配额管理

**Pi-mono 到生产环境的演进路径：**
- 阶段1：JSONL 文件（原型）
- 阶段2：PostgreSQL + JSONL 归档（小规模生产）
- 阶段3：分布式部署 + Redis 缓存（大规模生产）

---

**参考文献：**
- [6] Google ADK Context Management
- [9] AI agents querying internal APIs
- [10] Persistent Agent States
