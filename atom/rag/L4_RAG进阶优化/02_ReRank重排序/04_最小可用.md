# 最小可用

掌握以下内容，就能在 RAG 系统中使用 ReRank：

---

## 4.1 安装依赖

```bash
# 方式1：使用 sentence-transformers（开源，本地运行）
pip install sentence-transformers

# 方式2：使用 Cohere API（商业，效果更好）
pip install cohere
```

---

## 4.2 使用 Cross-Encoder 进行 ReRank

```python
from sentence_transformers import CrossEncoder

# 1. 加载模型（首次会下载）
reranker = CrossEncoder('cross-encoder/ms-marco-MiniLM-L-6-v2')

# 2. 准备数据
query = "如何在Python中读取JSON文件？"
documents = [
    "Python 是一种流行的编程语言",
    "使用 json.load() 函数可以读取 JSON 文件",
    "JSON 是 JavaScript Object Notation 的缩写",
    "import json; data = json.load(open('file.json'))",
]

# 3. 计算相关性分数
pairs = [(query, doc) for doc in documents]
scores = reranker.predict(pairs)

# 4. 按分数排序
ranked = sorted(zip(documents, scores), key=lambda x: x[1], reverse=True)

# 5. 输出结果
for doc, score in ranked:
    print(f"{score:.4f}: {doc}")
```

**输出：**
```
0.9234: 使用 json.load() 函数可以读取 JSON 文件
0.8876: import json; data = json.load(open('file.json'))
0.0156: Python 是一种流行的编程语言
0.0089: JSON 是 JavaScript Object Notation 的缩写
```

---

## 4.3 使用 Cohere Rerank API

```python
import cohere

# 1. 初始化客户端
co = cohere.Client("your-api-key")

# 2. 调用 Rerank API
query = "如何在Python中读取JSON文件？"
documents = [
    "Python 是一种流行的编程语言",
    "使用 json.load() 函数可以读取 JSON 文件",
    "JSON 是 JavaScript Object Notation 的缩写",
    "import json; data = json.load(open('file.json'))",
]

results = co.rerank(
    query=query,
    documents=documents,
    top_n=3,  # 只返回 Top 3
    model="rerank-english-v2.0"
)

# 3. 输出结果
for result in results.results:
    print(f"{result.relevance_score:.4f}: {documents[result.index]}")
```

---

## 4.4 集成到 RAG 流程

```python
def rag_with_rerank(query: str, vector_store, reranker, llm, top_n=50, top_k=5):
    """
    带 ReRank 的 RAG 流程

    Args:
        query: 用户问题
        vector_store: 向量数据库
        reranker: Cross-Encoder 模型
        llm: 大语言模型
        top_n: 向量检索召回数量
        top_k: ReRank 后保留数量
    """
    # 1. 向量检索召回 Top-N
    candidates = vector_store.similarity_search(query, k=top_n)

    # 2. ReRank 精排
    pairs = [(query, doc.page_content) for doc in candidates]
    scores = reranker.predict(pairs)

    # 3. 按分数排序，取 Top-K
    ranked = sorted(zip(candidates, scores), key=lambda x: x[1], reverse=True)
    top_docs = [doc for doc, score in ranked[:top_k]]

    # 4. 构建上下文
    context = "\n\n".join([doc.page_content for doc in top_docs])

    # 5. 生成回答
    prompt = f"""基于以下参考资料回答问题。

参考资料：
{context}

问题：{query}

回答："""

    return llm.invoke(prompt)
```

---

## 4.5 常用模型选择

| 场景 | 推荐模型 | 说明 |
|------|----------|------|
| 快速入门 | `cross-encoder/ms-marco-MiniLM-L-6-v2` | 轻量，速度快 |
| 更高精度 | `cross-encoder/ms-marco-MiniLM-L-12-v2` | 更大，更准 |
| 中文场景 | `BAAI/bge-reranker-base` | 中文效果好 |
| 生产环境 | Cohere Rerank API | 效果最好，按量付费 |

---

## 这些知识足以：

- ✅ 在 RAG 系统中添加 ReRank 环节
- ✅ 使用开源模型或商业 API 进行重排序
- ✅ 理解两阶段检索的基本流程
- ✅ 为后续学习高级优化打下基础

---

**下一步：** [05_双重类比](./05_双重类比.md) - 用前端和日常生活类比理解 ReRank
