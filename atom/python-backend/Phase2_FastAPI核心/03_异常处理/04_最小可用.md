# 最小可用

> 掌握以下内容，就能开始使用 FastAPI 异常处理

---

## 核心知识点

掌握以下 5 个核心知识点，就能处理 80% 的异常场景：

---

### 4.1 使用 HTTPException 抛出标准错误

**最常用的异常处理方式**

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = db.get_user(user_id)
    if not user:
        # 直接抛出 HTTPException
        raise HTTPException(status_code=404, detail="用户不存在")
    return user
```

**记住这 4 个最常用的状态码：**
- **400**：请求参数错误
- **401**：未认证（未登录）
- **404**：资源不存在
- **500**：服务器内部错误

---

### 4.2 创建自定义异常类

**封装业务错误**

```python
# 1. 定义自定义异常类
class UserNotFoundError(Exception):
    def __init__(self, user_id: int):
        self.user_id = user_id
        super().__init__(f"用户 {user_id} 不存在")

# 2. 注册异常处理器
from fastapi import Request
from fastapi.responses import JSONResponse

@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    return JSONResponse(
        status_code=404,
        content={"error": "用户不存在", "user_id": exc.user_id}
    )

# 3. 在路由中使用
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = db.get_user(user_id)
    if not user:
        raise UserNotFoundError(user_id)  # 抛出自定义异常
    return user
```

**好处：**
- 代码更清晰（`raise UserNotFoundError(user_id)` 比 `raise HTTPException(...)` 更直观）
- 统一处理（所有 `UserNotFoundError` 都返回相同格式）
- 易于维护（修改错误响应只需改一处）

---

### 4.3 处理第三方库异常

**统一处理数据库、LLM 等第三方库的异常**

```python
from sqlalchemy.exc import SQLAlchemyError
from openai import OpenAIError

# 处理数据库异常
@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_error_handler(request: Request, exc: SQLAlchemyError):
    logger.error(f"数据库错误: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "数据库操作失败，请稍后重试"}
    )

# 处理 OpenAI 异常
@app.exception_handler(OpenAIError)
async def openai_error_handler(request: Request, exc: OpenAIError):
    logger.error(f"OpenAI 错误: {exc}")
    return JSONResponse(
        status_code=503,
        content={"error": "AI 服务暂时不可用"}
    )
```

**常见的第三方异常：**
- **SQLAlchemyError**：数据库操作失败
- **OpenAIError**：LLM API 调用失败
- **RedisError**：缓存操作失败
- **RequestException**：HTTP 请求失败

---

### 4.4 统一错误响应格式

**让所有错误都返回相同的 JSON 格式**

```python
from datetime import datetime
import uuid

def create_error_response(status_code: int, error: str, code: str = None):
    """创建统一的错误响应"""
    return JSONResponse(
        status_code=status_code,
        content={
            "success": False,
            "error": error,
            "code": code,
            "timestamp": datetime.utcnow().isoformat()
        }
    )

# 使用统一的错误响应
@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    return create_error_response(
        status_code=404,
        error="用户不存在",
        code="USER_NOT_FOUND"
    )

@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_error_handler(request: Request, exc: SQLAlchemyError):
    logger.error(f"数据库错误: {exc}")
    return create_error_response(
        status_code=500,
        error="数据库操作失败",
        code="DATABASE_ERROR"
    )
```

**统一的错误响应格式：**
```json
{
  "success": false,
  "error": "用户不存在",
  "code": "USER_NOT_FOUND",
  "timestamp": "2026-02-11T09:30:00.000Z"
}
```

---

### 4.5 添加全局异常中间件

**捕获所有未处理的异常**

```python
from starlette.middleware.base import BaseHTTPMiddleware

class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        try:
            response = await call_next(request)
            response.headers["X-Request-ID"] = request_id
            return response
        except Exception as exc:
            logger.error(f"未处理的异常: {exc}", exc_info=True)
            return JSONResponse(
                status_code=500,
                content={
                    "error": "服务器内部错误",
                    "request_id": request_id
                },
                headers={"X-Request-ID": request_id}
            )

# 注册中间件
app.add_middleware(ErrorHandlingMiddleware)
```

**好处：**
- 捕获所有未处理的异常（防止服务器崩溃）
- 自动添加 request_id（便于追踪问题）
- 统一记录日志

---

## 完整示例

### 最小可用的异常处理架构

```python
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from sqlalchemy.exc import SQLAlchemyError
from openai import OpenAIError
from datetime import datetime
import uuid
import logging

logger = logging.getLogger(__name__)

app = FastAPI()

# ===== 1. 自定义异常类 =====
class UserNotFoundError(Exception):
    def __init__(self, user_id: int):
        self.user_id = user_id
        super().__init__(f"用户 {user_id} 不存在")

# ===== 2. 统一错误响应格式 =====
def create_error_response(status_code: int, error: str, code: str = None, request_id: str = None):
    content = {
        "success": False,
        "error": error,
        "timestamp": datetime.utcnow().isoformat()
    }
    if code:
        content["code"] = code
    if request_id:
        content["request_id"] = request_id

    return JSONResponse(status_code=status_code, content=content)

# ===== 3. 异常处理器 =====
@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    return create_error_response(
        status_code=404,
        error="用户不存在",
        code="USER_NOT_FOUND",
        request_id=getattr(request.state, "request_id", None)
    )

@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_error_handler(request: Request, exc: SQLAlchemyError):
    logger.error(f"数据库错误: {exc}")
    return create_error_response(
        status_code=500,
        error="数据库操作失败",
        code="DATABASE_ERROR",
        request_id=getattr(request.state, "request_id", None)
    )

@app.exception_handler(OpenAIError)
async def openai_error_handler(request: Request, exc: OpenAIError):
    logger.error(f"OpenAI 错误: {exc}")
    return create_error_response(
        status_code=503,
        error="AI 服务暂时不可用",
        code="AI_SERVICE_ERROR",
        request_id=getattr(request.state, "request_id", None)
    )

# ===== 4. 全局异常中间件 =====
class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        try:
            response = await call_next(request)
            response.headers["X-Request-ID"] = request_id
            return response
        except Exception as exc:
            logger.error(f"未处理的异常: {exc}", exc_info=True)
            return create_error_response(
                status_code=500,
                error="服务器内部错误",
                code="INTERNAL_ERROR",
                request_id=request_id
            )

app.add_middleware(ErrorHandlingMiddleware)

# ===== 5. 路由示例 =====
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    """获取用户信息"""
    user = db.get_user(user_id)  # 可能抛出 SQLAlchemyError
    if not user:
        raise UserNotFoundError(user_id)  # 抛出自定义异常
    return user

@app.post("/chat")
async def chat(message: str):
    """AI 对话"""
    response = openai.chat.completions.create(  # 可能抛出 OpenAIError
        model="gpt-4",
        messages=[{"role": "user", "content": message}]
    )
    return {"reply": response.choices[0].message.content}

@app.get("/health")
async def health():
    """健康检查"""
    return {"status": "ok"}
```

---

## 这些知识足以

掌握以上 5 个核心知识点，你就能：

- ✅ 处理 80% 的异常场景
- ✅ 返回友好的错误信息给用户
- ✅ 统一错误响应格式
- ✅ 记录详细的错误日志
- ✅ 追踪每个请求（通过 request_id）
- ✅ 处理数据库、LLM 等第三方库的异常
- ✅ 防止服务器崩溃（全局异常中间件）

---

## 快速参考

### 常用状态码

| 状态码 | 使用场景 | 示例 |
|--------|----------|------|
| 400 | 请求参数错误 | 缺少必填字段、格式错误 |
| 401 | 未认证 | 未登录、Token 过期 |
| 403 | 无权限 | 已登录但无权访问 |
| 404 | 资源不存在 | 用户不存在、文章不存在 |
| 500 | 服务器内部错误 | 数据库错误、未捕获的异常 |
| 503 | 服务不可用 | 第三方 API 超时 |

---

### 异常处理模板

```python
# 1. 抛出 HTTPException
raise HTTPException(status_code=404, detail="资源不存在")

# 2. 自定义异常类
class MyError(Exception):
    pass

@app.exception_handler(MyError)
async def my_error_handler(request: Request, exc: MyError):
    return JSONResponse(status_code=400, content={"error": str(exc)})

# 3. 处理第三方异常
@app.exception_handler(ThirdPartyError)
async def third_party_error_handler(request: Request, exc: ThirdPartyError):
    logger.error(f"第三方错误: {exc}")
    return JSONResponse(status_code=503, content={"error": "服务暂时不可用"})
```

---

## 下一步学习

掌握最小可用知识后，可以继续学习：

- **双重类比**：理解 FastAPI 异常处理与 Express 的对应关系
- **反直觉点**：避免常见的异常处理误区
- **实战代码**：更多实际场景的完整示例
- **化骨绵掌**：深入理解异常处理的原理和最佳实践

---

**记住：** 异常处理的核心是让错误可控、可理解、可追踪。从这 5 个核心知识点开始，逐步构建生产级的异常处理架构。
