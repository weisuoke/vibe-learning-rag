# 实战代码3：多环境配置切换

## 场景说明

演示如何实现开发/测试/生产环境的配置自动切换，包括多层配置加载、环境检测、配置验证等完整功能。

---

## 完整代码示例

### 示例1：基础环境切换

```python
"""
基础环境切换
演示：根据 ENV 环境变量加载不同的配置文件
"""
import os
from dotenv import load_dotenv

# 检测环境
env = os.getenv("ENV", "dev")

# 加载对应的配置文件
env_file = f".env.{env}"
load_dotenv(env_file)

print(f"✅ 当前环境: {env}")
print(f"✅ 加载配置文件: {env_file}")

# 读取配置
DATABASE_URL = os.getenv("DATABASE_URL")
DEBUG = os.getenv("DEBUG", "False").lower() == "true"
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")

print(f"🗄️  数据库: {DATABASE_URL}")
print(f"🐛 调试模式: {DEBUG}")
print(f"📝 日志级别: {LOG_LEVEL}")
```

**配置文件：**

```bash
# .env.dev
DATABASE_URL=postgresql://localhost:5432/dev_db
DEBUG=True
LOG_LEVEL=DEBUG

# .env.test
DATABASE_URL=postgresql://test-db:5432/test_db
DEBUG=False
LOG_LEVEL=INFO

# .env.prod
DATABASE_URL=postgresql://prod-db:5432/prod_db
DEBUG=False
LOG_LEVEL=WARNING
```

**使用：**

```bash
# 开发环境
ENV=dev python app.py

# 测试环境
ENV=test python app.py

# 生产环境
ENV=prod python app.py
```

---

### 示例2：多层配置加载

```python
"""
多层配置加载
演示：基础配置 + 环境配置 + 本地配置的层级加载
"""
import os
from dotenv import load_dotenv
from pathlib import Path

def load_env_files():
    """加载多层配置文件"""
    env = os.getenv("ENV", "dev")

    # 配置文件列表（按优先级从低到高）
    env_files = [
        ".env",                # 基础配置
        f".env.{env}",         # 环境配置
        ".env.local",          # 本地配置
    ]

    loaded_files = []
    for env_file in env_files:
        if Path(env_file).exists():
            load_dotenv(env_file, override=True)
            loaded_files.append(env_file)
            print(f"✅ 加载: {env_file}")
        else:
            print(f"⚠️  跳过: {env_file}（文件不存在）")

    return loaded_files

# 加载配置
print("=== 加载配置文件 ===")
loaded = load_env_files()

print(f"\n=== 配置优先级 ===")
print(" → ".join(loaded))

# 读取配置
print(f"\n=== 最终配置 ===")
print(f"APP_NAME: {os.getenv('APP_NAME')}")
print(f"DATABASE_URL: {os.getenv('DATABASE_URL')}")
print(f"DEBUG: {os.getenv('DEBUG')}")
```

**配置文件：**

```bash
# .env（基础配置）
APP_NAME=AI Agent API
LOG_LEVEL=INFO
DATABASE_POOL_SIZE=10

# .env.dev（开发环境）
DATABASE_URL=postgresql://localhost:5432/dev_db
DEBUG=True

# .env.local（本地配置）
DATABASE_URL=postgresql://localhost:5433/my_local_db
```

**运行输出：**

```
=== 加载配置文件 ===
✅ 加载: .env
✅ 加载: .env.dev
✅ 加载: .env.local

=== 配置优先级 ===
.env → .env.dev → .env.local

=== 最终配置 ===
APP_NAME: AI Agent API
DATABASE_URL: postgresql://localhost:5433/my_local_db
DEBUG: True
```

---

### 示例3：使用 Pydantic Settings 的环境切换

```python
"""
Pydantic Settings 环境切换
演示：使用 Pydantic Settings 实现类型安全的环境切换
"""
import os
from enum import Enum
from pydantic import field_validator
from pydantic_settings import BaseSettings

class Environment(str, Enum):
    DEV = "dev"
    TEST = "test"
    PROD = "prod"

class Settings(BaseSettings):
    env: Environment = Environment.DEV
    debug: bool = False
    database_url: str
    openai_api_key: str
    log_level: str = "INFO"

    @field_validator("debug")
    @classmethod
    def validate_debug(cls, v: bool, info) -> bool:
        # 生产环境不能启用调试模式
        if info.data.get("env") == Environment.PROD and v:
            raise ValueError("生产环境不能启用调试模式")
        return v

    class Config:
        # 根据环境变量选择配置文件
        env_file = f".env.{os.getenv('ENV', 'dev')}"

# 加载配置
try:
    settings = Settings()
    print(f"✅ 配置加载成功")
    print(f"   环境: {settings.env}")
    print(f"   调试模式: {settings.debug}")
    print(f"   数据库: {settings.database_url}")
    print(f"   日志级别: {settings.log_level}")
except Exception as e:
    print(f"❌ 配置错误: {e}")
```

---

### 示例4：完整的配置管理系统

```python
"""
完整的配置管理系统
演示：生产级的多环境配置管理
"""
import os
import sys
from enum import Enum
from pathlib import Path
from pydantic import Field, field_validator, model_validator
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

class Environment(str, Enum):
    DEV = "dev"
    TEST = "test"
    PROD = "prod"

def load_env_files():
    """加载多层配置文件"""
    env = os.getenv("ENV", "dev")

    # 1. 加载基础配置
    if Path(".env").exists():
        load_dotenv(".env")
        print(f"✅ 加载基础配置: .env")

    # 2. 加载环境配置
    env_file = f".env.{env}"
    if Path(env_file).exists():
        load_dotenv(env_file, override=True)
        print(f"✅ 加载环境配置: {env_file}")
    else:
        print(f"❌ 错误：配置文件不存在: {env_file}")
        print(f"提示：请复制 .env.example 为 {env_file}")
        sys.exit(1)

    # 3. 加载本地配置
    if Path(".env.local").exists():
        load_dotenv(".env.local", override=True)
        print(f"✅ 加载本地配置: .env.local")

# 启动时加载配置
load_env_files()

class Settings(BaseSettings):
    # 环境标识
    env: Environment = Environment.DEV

    # 应用配置
    app_name: str = "AI Agent API"
    debug: bool = False
    log_level: str = "INFO"

    # 数据库配置
    database_url: str = Field(..., description="数据库连接字符串")

    # LLM 配置
    openai_api_key: str = Field(..., description="OpenAI API 密钥")
    openai_model: str = "gpt-4"

    # 安全配置
    secret_key: str = Field(..., min_length=32, description="JWT 密钥")

    @field_validator("database_url")
    @classmethod
    def validate_database_url(cls, v: str, info) -> str:
        env = info.data.get("env")
        if env == Environment.PROD and ("localhost" in v or "127.0.0.1" in v):
            raise ValueError("生产环境不能使用本地数据库")
        return v

    @model_validator(mode='after')
    def validate_production_config(self):
        if self.env == Environment.PROD:
            if self.debug:
                raise ValueError("生产环境不能启用调试模式")
        return self

    class Config:
        # 不需要 env_file，因为已经手动加载
        pass

# 加载配置
try:
    settings = Settings()
    print(f"\n✅ 配置验证通过")
    print(f"   环境: {settings.env}")
    print(f"   应用名称: {settings.app_name}")
    print(f"   调试模式: {settings.debug}")
    print(f"   日志级别: {settings.log_level}")
    print(f"   数据库: {settings.database_url}")
    print(f"   LLM 模型: {settings.openai_model}")
except Exception as e:
    print(f"\n❌ 配置错误: {e}")
    sys.exit(1)
```

---

## 项目结构

```
project/
├── .env                    # 基础配置
├── .env.dev                # 开发环境
├── .env.test               # 测试环境
├── .env.prod               # 生产环境（不提交）
├── .env.local              # 本地配置（不提交）
├── .env.example            # 配置模板
├── .gitignore
├── config.py               # 配置模块
├── app.py                  # 应用入口
└── README.md
```

---

## 配置文件示例

### .env（基础配置）

```bash
# 应用配置
APP_NAME=AI Agent API
LOG_LEVEL=INFO

# 数据库配置
DATABASE_POOL_SIZE=10

# LLM 配置
OPENAI_MODEL=gpt-4
OPENAI_TEMPERATURE=0.7
```

### .env.dev（开发环境）

```bash
ENV=dev
DEBUG=True
LOG_LEVEL=DEBUG

DATABASE_URL=postgresql://localhost:5432/dev_db
OPENAI_API_KEY=sk-dev-xxx
SECRET_KEY=dev-secret-key-xxxxxxxxxxxxx
```

### .env.test（测试环境）

```bash
ENV=test
DEBUG=False
LOG_LEVEL=INFO

DATABASE_URL=postgresql://test-db:5432/test_db
OPENAI_API_KEY=sk-test-xxx
SECRET_KEY=test-secret-key-xxxxxxxxxxxxx
```

### .env.prod（生产环境）

```bash
ENV=prod
DEBUG=False
LOG_LEVEL=WARNING

DATABASE_URL=postgresql://prod-db.example.com:5432/prod_db
OPENAI_API_KEY=sk-prod-xxxxxxxxxxxxx
SECRET_KEY=prod-secret-key-xxxxxxxxxxxxx
```

### .env.example（配置模板）

```bash
ENV=dev
DEBUG=True
LOG_LEVEL=INFO

DATABASE_URL=postgresql://localhost:5432/dbname
OPENAI_API_KEY=your_openai_api_key_here
SECRET_KEY=your-secret-key-at-least-32-characters-long
```

---

## 运行说明

### 1. 初始化配置

```bash
# 复制配置模板
cp .env.example .env.dev

# 编辑配置
vim .env.dev
```

### 2. 运行不同环境

```bash
# 开发环境
ENV=dev python app.py

# 测试环境
ENV=test python app.py

# 生产环境
ENV=prod python app.py
```

---

## 总结

**多环境配置切换的核心要点：**

1. **环境标识**：使用 ENV 环境变量标识当前环境
2. **多层加载**：基础配置 + 环境配置 + 本地配置
3. **配置优先级**：.env.local > .env.{env} > .env
4. **类型安全**：使用 Pydantic Settings 验证配置
5. **环境验证**：生产环境的特殊验证规则

**最佳实践：**
- 使用标准的环境标识（dev/test/prod）
- 提供 .env.example 作为模板
- 验证配置文件是否存在
- 生产环境的严格验证
- 文档化配置优先级
