# 第一性原理

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题。

## Sub-Agents 的第一性原理

### 1. 最基础的定义

**Sub-Agent = 在独立进程中运行的、具有专用系统提示和工具集的 AI 代理**

仅此而已！没有更基础的了。

### 2. 为什么需要 Sub-Agents？

**核心问题：单个 Agent 的上下文窗口和能力有限，无法高效处理复杂的多步骤任务。**

想象你是一个项目经理，面对一个大型项目：
- 如果你一个人做所有事情，你会：
  - 上下文切换频繁（从写代码到测试到文档）
  - 记忆负担重（要记住所有细节）
  - 效率低下（无法并行处理）
  - 容易出错（精力分散）

这就是单个 Agent 面临的问题：
- **上下文窗口限制**：一个 Agent 的上下文有限（如 200K tokens），复杂任务会超出限制
- **专业化需求**：不同任务需要不同的工具和策略（如快速侦查 vs 深度实现）
- **并行执行需求**：独立的子任务可以同时进行，提高效率
- **隔离需求**：子任务的上下文不应互相污染

### 3. Sub-Agents 的三层价值

#### 价值1：上下文隔离

**每个 Sub-Agent 运行在独立的 `pi` 进程中，拥有自己的上下文窗口。**

**类比**：就像 Docker 容器，每个容器有自己的文件系统和进程空间。

**实际应用**：
```typescript
// 主 Agent 的上下文：处理用户请求
// Sub-Agent 1 的上下文：只关注代码搜索
// Sub-Agent 2 的上下文：只关注实现计划
// 互不干扰，各自专注
```

**为什么重要**：
- 避免上下文污染（子任务的细节不会占用主 Agent 的上下文）
- 突破上下文限制（每个 Sub-Agent 都有完整的上下文窗口）
- 提高专注度（每个 Agent 只看到相关信息）

#### 价值2：专业化分工

**不同的 Sub-Agent 可以配置不同的工具、模型和系统提示。**

**类比**：就像公司里的不同部门，销售部、技术部、财务部各司其职。

**实际应用**：
```typescript
// Scout Agent: 快速侦查，使用 Haiku 模型，只有读取工具
// Planner Agent: 制定计划，使用 Sonnet 模型，有读取和分析工具
// Worker Agent: 执行实现，使用 Sonnet 模型，有完整工具集
// Reviewer Agent: 代码审查，使用 Sonnet 模型，有读取和测试工具
```

**为什么重要**：
- 成本优化（简单任务用便宜的模型）
- 效率提升（专用工具集减少无关工具调用）
- 质量保证（专业化的系统提示提高输出质量）

#### 价值3：并行执行

**独立的 Sub-Agents 可以同时运行，提高整体效率。**

**类比**：就像多线程编程，多个线程同时执行不同任务。

**实际应用**：
```typescript
// 并行执行多个独立任务
{
  tasks: [
    { agent: "scout", task: "找到所有认证相关代码" },
    { agent: "scout", task: "找到所有数据库相关代码" },
    { agent: "scout", task: "找到所有 API 端点" }
  ]
}
// 三个任务同时执行，总时间 = max(task1, task2, task3)
// 而不是 task1 + task2 + task3
```

**为什么重要**：
- 时间节省（并行执行减少总时间）
- 资源利用（充分利用 API 并发限制）
- 用户体验（更快的响应时间）

### 4. 从第一性原理推导 Sub-Agents 的应用

**推理链：**

```
1. 前提：AI Agent 有上下文窗口限制
   ↓
2. 推导：复杂任务需要分解成小任务
   ↓
3. 推导：小任务需要独立的上下文空间
   ↓
4. 推导：独立上下文 = 独立进程
   ↓
5. 推导：不同任务需要不同能力
   ↓
6. 推导：不同能力 = 不同工具集 + 不同模型 + 不同提示
   ↓
7. 推导：独立任务可以并行执行
   ↓
8. 推导：并行执行 = 多个独立进程同时运行
   ↓
9. 推导：任务之间需要协作
   ↓
10. 推导：协作 = 任务委托 + 结果传递
   ↓
11. 最终应用：Sub-Agents = 独立进程 + 专用配置 + 任务委托 + 并行执行
```

**具体应用场景：**

**场景1：复杂重构任务**
```
用户：重构认证系统以支持 OAuth
  ↓
主 Agent：分解任务
  ↓
Sub-Agent 1 (Scout)：找到所有认证相关代码 → 返回文件列表
  ↓
Sub-Agent 2 (Planner)：基于文件列表制定重构计划 → 返回步骤
  ↓
Sub-Agent 3 (Worker)：执行重构步骤 → 返回实现结果
  ↓
Sub-Agent 4 (Reviewer)：审查实现 → 返回改进建议
  ↓
Sub-Agent 5 (Worker)：应用改进 → 返回最终结果
```

**场景2：并行信息收集**
```
用户：分析项目的技术栈
  ↓
主 Agent：并行委托
  ↓
Sub-Agent 1：分析前端技术栈 ┐
Sub-Agent 2：分析后端技术栈 ├→ 并行执行
Sub-Agent 3：分析数据库技术栈 ┘
  ↓
主 Agent：汇总结果 → 返回完整分析
```

**场景3：链式工作流**
```
用户：实现新功能并审查
  ↓
Sub-Agent 1 (Scout)：侦查相关代码 → 输出1
  ↓
Sub-Agent 2 (Planner)：基于输出1制定计划 → 输出2
  ↓
Sub-Agent 3 (Worker)：基于输出2实现功能 → 输出3
  ↓
Sub-Agent 4 (Reviewer)：审查输出3 → 输出4
  ↓
Sub-Agent 5 (Worker)：基于输出4修复问题 → 最终输出
```

### 5. 一句话总结第一性原理

**Sub-Agents 是通过进程隔离实现上下文独立、通过专业化配置实现能力分工、通过任务委托实现协作的多 Agent 系统，从根本上解决了单 Agent 的上下文限制和专业化需求。**

---

## 与其他概念的关系

### Sub-Agents vs Extensions

| 维度 | Sub-Agents | Extensions |
|------|-----------|-----------|
| **本质** | 独立进程 | 工具注册 |
| **上下文** | 独立上下文 | 共享上下文 |
| **用途** | 任务委托 | 功能扩展 |
| **隔离性** | 完全隔离 | 无隔离 |

**关系**：Sub-Agents 本身是通过 Extension 实现的工具。

### Sub-Agents vs MCP Server

| 维度 | Sub-Agents | MCP Server |
|------|-----------|-----------|
| **本质** | 独立 pi 进程 | 外部服务 |
| **协议** | JSON mode | MCP 协议 |
| **用途** | 任务委托 | 工具扩展 |
| **AI 能力** | 有（LLM） | 无（纯工具）|

**关系**：Sub-Agents 是有 AI 能力的代理，MCP Server 是无 AI 能力的工具服务。

### Sub-Agents vs Plan Mode

| 维度 | Sub-Agents | Plan Mode |
|------|-----------|-----------|
| **本质** | 多 Agent 协作 | 单 Agent 多步骤 |
| **上下文** | 多个独立上下文 | 单个上下文 |
| **用途** | 任务分解与委托 | 计划生成与执行 |
| **并行性** | 支持并行 | 顺序执行 |

**关系**：Plan Mode 可以使用 Sub-Agents 来执行计划中的步骤。

---

## 核心洞察

1. **隔离是基础**：进程隔离是 Sub-Agents 的基础，没有隔离就没有独立上下文
2. **专业化是优势**：不同的工具集和模型配置是 Sub-Agents 的核心优势
3. **协作是目标**：任务委托和结果传递是 Sub-Agents 的最终目标
4. **并行是效率**：并行执行是 Sub-Agents 提高效率的关键

**记住**：Sub-Agents 不是简单的函数调用，而是独立的 AI 代理，有自己的"思考空间"和"工具箱"。
