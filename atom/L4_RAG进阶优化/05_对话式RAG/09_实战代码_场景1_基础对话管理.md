# 实战代码：场景1 - 基础对话管理

> 实现一个完整的对话会话管理器

---

## 场景说明

本场景实现一个基础的对话管理器`ConversationManager`，提供以下功能：
- Session管理：为每个用户维护独立的对话会话
- 历史存储：记录所有对话轮次
- 上下文获取：提取最近N轮对话
- 会话清空：删除指定会话的历史

**适用场景：**
- 原型开发和测试
- 小规模应用（<1000用户）
- 不需要持久化的场景

---

## 完整代码实现

```python
"""
基础对话管理器实现
功能：Session管理、历史存储、上下文获取
"""

from typing import Dict, List, Optional
from dataclasses import dataclass, field
from datetime import datetime
import json


@dataclass
class Message:
    """对话消息数据结构"""
    role: str  # "user" 或 "assistant" 或 "system"
    content: str  # 消息内容
    timestamp: datetime = field(default_factory=datetime.now)  # 时间戳
    metadata: Optional[Dict] = None  # 元数据（可选）

    def to_dict(self) -> Dict:
        """转换为字典"""
        return {
            "role": self.role,
            "content": self.content,
            "timestamp": self.timestamp.isoformat(),
            "metadata": self.metadata
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Message':
        """从字典创建"""
        return cls(
            role=data["role"],
            content=data["content"],
            timestamp=datetime.fromisoformat(data["timestamp"]),
            metadata=data.get("metadata")
        )


class ConversationManager:
    """对话管理器"""

    def __init__(self, max_history: int = 20):
        """
        初始化对话管理器

        Args:
            max_history: 每个会话最多保留的消息数（滑动窗口）
        """
        self.sessions: Dict[str, List[Message]] = {}
        self.max_history = max_history

    def add_message(self, session_id: str, role: str, content: str,
                   metadata: Optional[Dict] = None) -> Message:
        """
        添加消息到会话

        Args:
            session_id: 会话ID
            role: 角色（user/assistant/system）
            content: 消息内容
            metadata: 元数据（可选）

        Returns:
            创建的Message对象
        """
        # 创建消息
        message = Message(
            role=role,
            content=content,
            timestamp=datetime.now(),
            metadata=metadata
        )

        # 初始化会话（如果不存在）
        if session_id not in self.sessions:
            self.sessions[session_id] = []

        # 添加到会话
        self.sessions[session_id].append(message)

        # 滑动窗口：超过max_history就删除最早的消息
        if len(self.sessions[session_id]) > self.max_history:
            removed_count = len(self.sessions[session_id]) - self.max_history
            self.sessions[session_id] = self.sessions[session_id][-self.max_history:]
            print(f"[Session {session_id}] 滑动窗口：删除了{removed_count}条最早的消息")

        return message

    def get_context(self, session_id: str, last_n: Optional[int] = None) -> List[Message]:
        """
        获取会话的上下文

        Args:
            session_id: 会话ID
            last_n: 获取最近N轮对话（每轮=2条消息）。None表示获取全部

        Returns:
            消息列表
        """
        if session_id not in self.sessions:
            return []

        messages = self.sessions[session_id]

        if last_n is None:
            return messages

        # 每轮对话=2条消息（user + assistant）
        keep_count = last_n * 2
        return messages[-keep_count:] if len(messages) > keep_count else messages

    def get_session_info(self, session_id: str) -> Dict:
        """
        获取会话信息

        Args:
            session_id: 会话ID

        Returns:
            会话信息字典
        """
        if session_id not in self.sessions:
            return {
                "session_id": session_id,
                "exists": False,
                "message_count": 0
            }

        messages = self.sessions[session_id]
        return {
            "session_id": session_id,
            "exists": True,
            "message_count": len(messages),
            "turn_count": len(messages) // 2,
            "first_message_time": messages[0].timestamp.isoformat() if messages else None,
            "last_message_time": messages[-1].timestamp.isoformat() if messages else None,
        }

    def clear_session(self, session_id: str) -> bool:
        """
        清空会话

        Args:
            session_id: 会话ID

        Returns:
            是否成功清空
        """
        if session_id in self.sessions:
            del self.sessions[session_id]
            print(f"[Session {session_id}] 已清空")
            return True
        return False

    def list_sessions(self) -> List[str]:
        """
        列出所有会话ID

        Returns:
            会话ID列表
        """
        return list(self.sessions.keys())

    def export_session(self, session_id: str) -> Optional[str]:
        """
        导出会话为JSON

        Args:
            session_id: 会话ID

        Returns:
            JSON字符串，如果会话不存在则返回None
        """
        if session_id not in self.sessions:
            return None

        messages = self.sessions[session_id]
        data = {
            "session_id": session_id,
            "messages": [msg.to_dict() for msg in messages]
        }
        return json.dumps(data, ensure_ascii=False, indent=2)

    def import_session(self, json_str: str) -> bool:
        """
        从JSON导入会话

        Args:
            json_str: JSON字符串

        Returns:
            是否成功导入
        """
        try:
            data = json.loads(json_str)
            session_id = data["session_id"]
            messages = [Message.from_dict(msg) for msg in data["messages"]]
            self.sessions[session_id] = messages
            print(f"[Session {session_id}] 导入成功，共{len(messages)}条消息")
            return True
        except Exception as e:
            print(f"导入失败: {e}")
            return False


# ===== 使用示例 =====

def main():
    """演示对话管理器的使用"""

    # 1. 创建对话管理器
    print("=== 1. 创建对话管理器 ===")
    manager = ConversationManager(max_history=20)
    print("对话管理器已创建\n")

    # 2. 模拟用户A的对话
    print("=== 2. 用户A的对话 ===")
    session_a = "user_alice"

    manager.add_message(session_a, "user", "什么是RAG？")
    manager.add_message(session_a, "assistant", "RAG是检索增强生成，结合了检索和生成的优势...")

    manager.add_message(session_a, "user", "它有什么优势？")
    manager.add_message(session_a, "assistant", "RAG的优势包括：1. 知识更新及时 2. 减少幻觉...")

    manager.add_message(session_a, "user", "如何实现？")
    manager.add_message(session_a, "assistant", "实现RAG需要：1. 向量数据库 2. Embedding模型...")

    print(f"用户A已进行{len(manager.get_context(session_a)) // 2}轮对话\n")

    # 3. 模拟用户B的对话
    print("=== 3. 用户B的对话 ===")
    session_b = "user_bob"

    manager.add_message(session_b, "user", "什么是Transformer？")
    manager.add_message(session_b, "assistant", "Transformer是一种基于注意力机制的神经网络架构...")

    print(f"用户B已进行{len(manager.get_context(session_b)) // 2}轮对话\n")

    # 4. 获取上下文
    print("=== 4. 获取上下文 ===")

    # 获取用户A的最近2轮对话
    context_a = manager.get_context(session_a, last_n=2)
    print(f"用户A的最近2轮对话：")
    for msg in context_a:
        print(f"  {msg.role}: {msg.content[:50]}...")

    print()

    # 获取用户B的全部对话
    context_b = manager.get_context(session_b)
    print(f"用户B的全部对话：")
    for msg in context_b:
        print(f"  {msg.role}: {msg.content[:50]}...")

    print()

    # 5. 查看会话信息
    print("=== 5. 会话信息 ===")
    info_a = manager.get_session_info(session_a)
    print(f"用户A: {info_a['turn_count']}轮对话，共{info_a['message_count']}条消息")

    info_b = manager.get_session_info(session_b)
    print(f"用户B: {info_b['turn_count']}轮对话，共{info_b['message_count']}条消息")

    print()

    # 6. 列出所有会话
    print("=== 6. 所有会话 ===")
    sessions = manager.list_sessions()
    print(f"当前活跃会话: {sessions}\n")

    # 7. 导出和导入
    print("=== 7. 导出和导入 ===")
    exported = manager.export_session(session_a)
    print(f"导出用户A的会话（前100字符）:\n{exported[:100]}...\n")

    # 8. 清空会话
    print("=== 8. 清空会话 ===")
    manager.clear_session(session_b)
    print(f"剩余会话: {manager.list_sessions()}\n")

    # 9. 测试滑动窗口
    print("=== 9. 测试滑动窗口 ===")
    test_session = "test_user"
    manager_small = ConversationManager(max_history=6)  # 只保留3轮

    for i in range(5):
        manager_small.add_message(test_session, "user", f"问题{i+1}")
        manager_small.add_message(test_session, "assistant", f"回答{i+1}")

    final_context = manager_small.get_context(test_session)
    print(f"滑动窗口测试：原本10条消息，现在保留{len(final_context)}条")
    print("保留的消息:")
    for msg in final_context:
        print(f"  {msg.role}: {msg.content}")


if __name__ == "__main__":
    main()
```

---

## 运行输出示例

```
=== 1. 创建对话管理器 ===
对话管理器已创建

=== 2. 用户A的对话 ===
用户A已进行3轮对话

=== 3. 用户B的对话 ===
用户B已进行1轮对话

=== 4. 获取上下文 ===
用户A的最近2轮对话：
  user: 它有什么优势？...
  assistant: RAG的优势包括：1. 知识更新及时 2. 减少幻觉......
  user: 如何实现？...
  assistant: 实现RAG需要：1. 向量数据库 2. Embedding模型......

用户B的全部对话：
  user: 什么是Transformer？...
  assistant: Transformer是一种基于注意力机制的神经网络架构......

=== 5. 会话信息 ===
用户A: 3轮对话，共6条消息
用户B: 1轮对话，共2条消息

=== 6. 所有会话 ===
当前活跃会话: ['user_alice', 'user_bob']

=== 7. 导出和导入 ===
导出用户A的会话（前100字符）:
{
  "session_id": "user_alice",
  "messages": [
    {
      "role": "user",
      "content": "什么是RAG...

=== 8. 清空会话 ===
[Session user_bob] 已清空
剩余会话: ['user_alice']

=== 9. 测试滑动窗口 ===
[Session test_user] 滑动窗口：删除了4条最早的消息
滑动窗口测试：原本10条消息，现在保留6条
保留的消息:
  user: 问题4
  assistant: 回答4
  user: 问题5
  assistant: 回答5
```

---

## 在RAG系统中的集成

### 集成到对话式RAG

```python
from openai import OpenAI

def conversational_rag_with_manager(session_id: str, user_query: str) -> str:
    """
    使用ConversationManager的对话式RAG
    """
    # 初始化
    manager = ConversationManager(max_history=20)
    client = OpenAI()

    # 1. 获取历史上下文
    history = manager.get_context(session_id, last_n=3)

    # 2. 构建Prompt
    history_text = "\n".join([
        f"{msg.role}: {msg.content}"
        for msg in history
    ])

    prompt = f"""
对话历史:
{history_text}

用户问题: {user_query}

请基于对话历史回答问题。
"""

    # 3. LLM生成
    response = client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )

    answer = response.choices[0].message.content

    # 4. 保存到历史
    manager.add_message(session_id, "user", user_query)
    manager.add_message(session_id, "assistant", answer)

    return answer
```

---

## 扩展思考

### 1. 如何持久化到数据库？

```python
import sqlite3

class DatabaseConversationManager(ConversationManager):
    """带数据库持久化的对话管理器"""

    def __init__(self, db_path: str = "conversations.db", **kwargs):
        super().__init__(**kwargs)
        self.conn = sqlite3.connect(db_path)
        self._create_table()

    def _create_table(self):
        """创建数据库表"""
        self.conn.execute("""
            CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT NOT NULL,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                timestamp TEXT NOT NULL,
                metadata TEXT
            )
        """)
        self.conn.commit()

    def add_message(self, session_id: str, role: str, content: str,
                   metadata: Optional[Dict] = None) -> Message:
        """添加消息（同时写入数据库）"""
        message = super().add_message(session_id, role, content, metadata)

        # 写入数据库
        self.conn.execute(
            "INSERT INTO messages (session_id, role, content, timestamp, metadata) VALUES (?, ?, ?, ?, ?)",
            (session_id, role, content, message.timestamp.isoformat(),
             json.dumps(metadata) if metadata else None)
        )
        self.conn.commit()

        return message
```

### 2. 如何处理并发会话？

```python
from threading import Lock

class ThreadSafeConversationManager(ConversationManager):
    """线程安全的对话管理器"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.locks: Dict[str, Lock] = {}
        self.global_lock = Lock()

    def _get_session_lock(self, session_id: str) -> Lock:
        """获取会话锁"""
        with self.global_lock:
            if session_id not in self.locks:
                self.locks[session_id] = Lock()
            return self.locks[session_id]

    def add_message(self, session_id: str, role: str, content: str,
                   metadata: Optional[Dict] = None) -> Message:
        """线程安全的添加消息"""
        lock = self._get_session_lock(session_id)
        with lock:
            return super().add_message(session_id, role, content, metadata)
```

### 3. 性能优化建议

**内存优化：**
- 定期清理过期会话（如超过24小时未活跃）
- 限制单个会话的最大消息数
- 使用LRU缓存淘汰不活跃会话

**查询优化：**
- 为session_id建立索引
- 使用连接池管理数据库连接
- 批量写入减少I/O

**扩展性：**
- 使用Redis存储热数据
- 使用消息队列异步写入数据库
- 分片存储（按session_id哈希）

---

## 总结

**本场景实现了：**
- ✅ 基础的Session管理
- ✅ 内存存储对话历史
- ✅ 滑动窗口自动清理
- ✅ 导出/导入功能

**适用场景：**
- 原型开发和测试
- 小规模应用
- 不需要持久化的场景

**下一步：**
- 学习 `10_实战代码_场景2_历史压缩实现.md` - 添加历史压缩功能
- 学习 `12_实战代码_场景4_完整对话式RAG.md` - 完整的端到端系统
