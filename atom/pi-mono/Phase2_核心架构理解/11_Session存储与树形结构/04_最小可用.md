# 最小可用

> 掌握这些核心知识，就能开始使用 Session 存储与树形结构

---

## 学习目标

**掌握以下 5 个核心概念，你就能：**
- ✅ 实现简单的会话持久化
- ✅ 支持基本的历史回溯
- ✅ 创建和管理分支
- ✅ 为后续深入学习打下基础

**学习时间：** 专注学习约 30-60 分钟

---

## 核心概念 1：JSONL 基础读写

### 必须掌握

**JSONL 格式：** 每行一个 JSON 对象

```jsonl
{"id": "1", "content": "Hello"}
{"id": "2", "content": "World"}
```

**追加写入：**

```typescript
import * as fs from 'fs';

// 追加一行
function appendLine(filePath: string, data: any): void {
  const line = JSON.stringify(data) + '\n';
  fs.appendFileSync(filePath, line, 'utf-8');
}

// 使用
appendLine('session.jsonl', { id: '1', content: 'Hello' });
appendLine('session.jsonl', { id: '2', content: 'World' });
```

**读取所有行：**

```typescript
// 读取所有条目
function readAll(filePath: string): any[] {
  if (!fs.existsSync(filePath)) {
    return [];
  }

  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.split('\n').filter(line => line.trim());

  return lines.map(line => JSON.parse(line));
}

// 使用
const entries = readAll('session.jsonl');
console.log(entries);
// [{ id: '1', content: 'Hello' }, { id: '2', content: 'World' }]
```

### 关键要点

- ✅ JSONL 每行独立，可以逐行解析
- ✅ 追加写入不需要读取现有内容
- ✅ 性能优秀，O(1) 复杂度

---

## 核心概念 2：id/parentId 树形结构

### 必须掌握

**树形结构的表示：**

```typescript
interface TreeNode {
  id: string;           // 当前节点的唯一 ID
  parentId: string | null; // 父节点的 ID（根节点为 null）
  content?: string;     // 节点内容
}
```

**示例数据：**

```jsonl
{"id": "root", "parentId": null, "content": "Start"}
{"id": "msg1", "parentId": "root", "content": "Hello"}
{"id": "msg2", "parentId": "msg1", "content": "Hi"}
{"id": "msg3", "parentId": "msg2", "content": "How are you?"}
{"id": "msg4", "parentId": "msg2", "content": "What's your name?"}
```

**树形结构：**

```
root
└── msg1 ("Hello")
    └── msg2 ("Hi")
        ├── msg3 ("How are you?")
        └── msg4 ("What's your name?")
```

**构建映射：**

```typescript
// 建立 ID 到节点的映射
function buildMap(entries: TreeNode[]): Map<string, TreeNode> {
  const map = new Map<string, TreeNode>();

  for (const entry of entries) {
    map.set(entry.id, entry);
  }

  return map;
}

// 使用
const entries = readAll('session.jsonl');
const entryMap = buildMap(entries);

// 快速查找
const node = entryMap.get('msg2');
console.log(node); // { id: 'msg2', parentId: 'msg1', content: 'Hi' }
```

### 关键要点

- ✅ id/parentId 是最简单的树形结构表示
- ✅ 使用 Map 可以快速查找节点
- ✅ 扁平存储，易于追加

---

## 核心概念 3：追加新条目

### 必须掌握

**生成唯一 ID：**

```typescript
import { randomBytes } from 'crypto';

function generateId(): string {
  return randomBytes(4).toString('hex');
}

// 示例输出
generateId(); // "a3f2c8d1"
generateId(); // "7b9e4f2a"
```

**追加新条目：**

```typescript
interface SessionEntry {
  type: string;
  id: string;
  parentId: string | null;
  timestamp: string;
  content?: string;
}

function addEntry(
  filePath: string,
  parentId: string,
  type: string,
  content?: string
): string {
  const id = generateId();
  const entry: SessionEntry = {
    type,
    id,
    parentId,
    timestamp: new Date().toISOString(),
    content
  };

  const line = JSON.stringify(entry) + '\n';
  fs.appendFileSync(filePath, line, 'utf-8');

  return id;
}

// 使用
const rootId = addEntry('session.jsonl', null, 'session');
const msg1Id = addEntry('session.jsonl', rootId, 'user', 'Hello');
const msg2Id = addEntry('session.jsonl', msg1Id, 'assistant', 'Hi');
```

### 关键要点

- ✅ 每个条目都有唯一的 ID
- ✅ 新条目的 parentId 指向父节点
- ✅ 追加写入，不修改现有数据

---

## 核心概念 4：从叶子到根遍历

### 必须掌握

**获取从叶子到根的路径：**

```typescript
function getBranch(
  entryMap: Map<string, SessionEntry>,
  fromId: string
): SessionEntry[] {
  const branch: SessionEntry[] = [];
  let currentId: string | null = fromId;

  // 从叶子向上遍历到根
  while (currentId !== null) {
    const entry = entryMap.get(currentId);
    if (!entry) {
      throw new Error(`Entry not found: ${currentId}`);
    }

    branch.push(entry);
    currentId = entry.parentId;
  }

  // 反转，使其从根到叶子
  return branch.reverse();
}

// 使用
const entries = readAll('session.jsonl');
const entryMap = buildMap(entries);

const branch = getBranch(entryMap, 'msg3');
console.log(branch.map(e => e.content));
// ["Start", "Hello", "Hi", "How are you?"]
```

**可视化路径：**

```typescript
function visualizeBranch(branch: SessionEntry[]): void {
  console.log('Branch path:');
  for (let i = 0; i < branch.length; i++) {
    const prefix = '  '.repeat(i);
    console.log(`${prefix}└─ ${branch[i].type}: ${branch[i].content || branch[i].id}`);
  }
}

// 使用
visualizeBranch(branch);
// Branch path:
// └─ session: Start
//   └─ user: Hello
//     └─ assistant: Hi
//       └─ user: How are you?
```

### 关键要点

- ✅ 从叶子向上遍历，直到根节点
- ✅ 反转数组得到从根到叶子的路径
- ✅ 时间复杂度 O(h)，h 是树的高度

---

## 核心概念 5：基础分支创建

### 必须掌握

**Leaf Pointer（叶子指针）：**

```typescript
class SimpleSessionManager {
  private filePath: string;
  private leafId: string;  // 当前叶子节点

  constructor(filePath: string) {
    this.filePath = filePath;

    // 初始化：创建根节点
    const rootId = this.addEntry(null, 'session');
    this.leafId = rootId;
  }

  // 添加条目（总是添加到叶子节点下）
  addEntry(parentId: string | null, type: string, content?: string): string {
    const id = generateId();
    const entry: SessionEntry = {
      type,
      id,
      parentId: parentId || this.leafId,
      timestamp: new Date().toISOString(),
      content
    };

    const line = JSON.stringify(entry) + '\n';
    fs.appendFileSync(this.filePath, line, 'utf-8');

    // 更新叶子指针
    this.leafId = id;

    return id;
  }

  // 创建分支（移动叶子指针）
  branch(branchFromId: string): void {
    this.leafId = branchFromId;
    console.log(`Branched from ${branchFromId}`);
  }

  // 获取当前叶子 ID
  getLeafId(): string {
    return this.leafId;
  }
}
```

**使用示例：**

```typescript
const manager = new SimpleSessionManager('session.jsonl');

// 初始对话
manager.addEntry(null, 'user', 'Hello');
manager.addEntry(null, 'assistant', 'Hi there!');
const msg2Id = manager.getLeafId();

manager.addEntry(null, 'user', 'How are you?');
manager.addEntry(null, 'assistant', 'I\'m good');

// 创建分支：回到 msg2
manager.branch(msg2Id);

// 从 msg2 开始新的对话路径
manager.addEntry(null, 'user', 'What\'s your name?');
manager.addEntry(null, 'assistant', 'I\'m Claude');
```

**树形结构：**

```
root
└── user: "Hello"
    └── assistant: "Hi there!"
        ├── user: "How are you?"
        │   └── assistant: "I'm good"
        └── user: "What's your name?"  ← 分支
            └── assistant: "I'm Claude"
```

### 关键要点

- ✅ Leaf Pointer 指向当前活跃节点
- ✅ 新条目总是添加到叶子节点下
- ✅ 分支只是移动叶子指针

---

## 完整的最小实现

### 代码清单

```typescript
import * as fs from 'fs';
import { randomBytes } from 'crypto';

interface SessionEntry {
  type: string;
  id: string;
  parentId: string | null;
  timestamp: string;
  content?: string;
}

class MinimalSessionManager {
  private filePath: string;
  private leafId: string;

  constructor(filePath: string) {
    this.filePath = filePath;

    // 如果文件不存在，创建根节点
    if (!fs.existsSync(filePath)) {
      const rootId = this.generateId();
      this.appendEntry({
        type: 'session',
        id: rootId,
        parentId: null,
        timestamp: new Date().toISOString()
      });
      this.leafId = rootId;
    } else {
      // 加载现有会话，找到最后一个条目作为叶子
      const entries = this.readAll();
      this.leafId = entries[entries.length - 1].id;
    }
  }

  // 生成唯一 ID
  private generateId(): string {
    return randomBytes(4).toString('hex');
  }

  // 追加条目到文件
  private appendEntry(entry: SessionEntry): void {
    const line = JSON.stringify(entry) + '\n';
    fs.appendFileSync(this.filePath, line, 'utf-8');
  }

  // 读取所有条目
  private readAll(): SessionEntry[] {
    if (!fs.existsSync(this.filePath)) {
      return [];
    }

    const content = fs.readFileSync(this.filePath, 'utf-8');
    const lines = content.split('\n').filter(line => line.trim());

    return lines.map(line => JSON.parse(line));
  }

  // 建立 ID 映射
  private buildMap(entries: SessionEntry[]): Map<string, SessionEntry> {
    const map = new Map<string, SessionEntry>();
    for (const entry of entries) {
      map.set(entry.id, entry);
    }
    return map;
  }

  // 添加消息
  addMessage(content: string, type: 'user' | 'assistant'): string {
    const id = this.generateId();
    const entry: SessionEntry = {
      type,
      id,
      parentId: this.leafId,
      timestamp: new Date().toISOString(),
      content
    };

    this.appendEntry(entry);
    this.leafId = id;

    return id;
  }

  // 创建分支
  branch(branchFromId: string): void {
    const entries = this.readAll();
    const entryMap = this.buildMap(entries);

    if (!entryMap.has(branchFromId)) {
      throw new Error(`Entry not found: ${branchFromId}`);
    }

    this.leafId = branchFromId;
    console.log(`Branched from ${branchFromId}`);
  }

  // 获取分支（从叶子到根）
  getBranch(fromId?: string): SessionEntry[] {
    const entries = this.readAll();
    const entryMap = this.buildMap(entries);

    const branch: SessionEntry[] = [];
    let currentId: string | null = fromId || this.leafId;

    while (currentId !== null) {
      const entry = entryMap.get(currentId);
      if (!entry) break;

      branch.push(entry);
      currentId = entry.parentId;
    }

    return branch.reverse();
  }

  // 可视化当前分支
  visualize(): void {
    const branch = this.getBranch();

    console.log('\n=== Current Branch ===');
    for (let i = 0; i < branch.length; i++) {
      const prefix = '  '.repeat(i);
      const entry = branch[i];
      console.log(`${prefix}└─ [${entry.type}] ${entry.content || entry.id}`);
    }
    console.log('');
  }

  // 获取当前叶子 ID
  getLeafId(): string {
    return this.leafId;
  }
}
```

### 使用示例

```typescript
// 创建会话管理器
const manager = new MinimalSessionManager('my-session.jsonl');

// 添加对话
manager.addMessage('Hello', 'user');
manager.addMessage('Hi there!', 'assistant');
const msg2Id = manager.getLeafId();

manager.addMessage('How are you?', 'user');
manager.addMessage('I\'m good', 'assistant');

// 可视化当前分支
manager.visualize();

// 创建分支
manager.branch(msg2Id);

// 从分支点继续对话
manager.addMessage('What\'s your name?', 'user');
manager.addMessage('I\'m Claude', 'assistant');

// 可视化新分支
manager.visualize();

// 获取分支历史
const branch = manager.getBranch();
console.log('Branch messages:', branch.map(e => e.content));
```

---

## 实践练习

### 练习 1：基础读写

**任务：** 创建一个 JSONL 文件，添加 5 条消息，然后读取并打印。

```typescript
// 你的代码
const filePath = 'practice.jsonl';

// 1. 添加 5 条消息
// 2. 读取所有消息
// 3. 打印消息内容
```

### 练习 2：树形结构

**任务：** 创建一个包含分支的会话树。

```typescript
// 你的代码
const manager = new MinimalSessionManager('practice.jsonl');

// 1. 创建主对话路径（3 条消息）
// 2. 回到第 2 条消息
// 3. 创建分支（2 条消息）
// 4. 可视化两个分支
```

### 练习 3：历史回溯

**任务：** 实现一个函数，打印从任意节点到根的路径。

```typescript
// 你的代码
function printPath(manager: MinimalSessionManager, nodeId: string): void {
  // 1. 获取分支
  // 2. 打印每个节点的内容
}
```

---

## 常见问题

### Q1: 为什么用 JSONL 而不是 JSON 数组？

**A:** JSONL 支持追加写入，性能更好。JSON 数组需要每次重写整个文件。

### Q2: 如何避免 ID 碰撞？

**A:** 使用 `randomBytes(4).toString('hex')` 生成 8 字符的十六进制 ID，碰撞概率极低（2^32 种可能）。

### Q3: 分支会创建新文件吗？

**A:** 不会。所有分支都在同一个 JSONL 文件中，通过 id/parentId 关系表示。

### Q4: 如何删除一个分支？

**A:** 最小实现不支持删除。如果需要，可以在读取时过滤掉特定的节点。

### Q5: 文件会不会太大？

**A:** 对于单个会话（通常 < 10,000 条消息），文件大小在 1-10 MB，完全可以接受。

---

## 下一步学习

掌握了这 5 个核心概念后，你可以：

1. **深入学习**
   - 双重类比 → `05_双重类比.md`
   - 反直觉点 → `06_反直觉点.md`

2. **实战练习**
   - 实战代码 → `07_实战代码_*.md`

3. **面试准备**
   - 面试必问 → `08_面试必问.md`

4. **完全掌握**
   - 化骨绵掌 → `09_化骨绵掌.md`

---

## 检查清单

在继续学习之前，确保你能够：

- [ ] 理解 JSONL 格式和追加写入
- [ ] 理解 id/parentId 树形结构
- [ ] 能够追加新条目到 JSONL 文件
- [ ] 能够从叶子到根遍历树
- [ ] 能够创建和切换分支
- [ ] 能够运行完整的最小实现代码

**如果以上都能做到，恭喜你已经掌握了 Session 存储的核心知识！**

---

## 关键要点回顾

1. **JSONL 格式**：每行一个 JSON 对象，支持追加写入
2. **id/parentId**：最简单的树形结构表示
3. **追加写入**：O(1) 复杂度，性能优秀
4. **从叶子到根**：遍历树获取完整路径
5. **Leaf Pointer**：指向当前活跃节点，支持分支

---

**恭喜！** 你已经掌握了 Session 存储与树形结构的最小可用知识。

**下一步**：深入理解双重类比 → `05_双重类比.md`
