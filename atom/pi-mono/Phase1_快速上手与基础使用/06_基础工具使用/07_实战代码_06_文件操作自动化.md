# æ–‡ä»¶æ“ä½œè‡ªåŠ¨åŒ–

> ä½¿ç”¨å››ä¸ªå·¥å…·å®ç°å¤æ‚çš„æ–‡ä»¶æ“ä½œè‡ªåŠ¨åŒ–æµç¨‹

---

## åœºæ™¯ 1ï¼šæ‰¹é‡æ–‡ä»¶é‡å‘½å

```typescript
// batch-rename.ts
import fs from 'fs'
import path from 'path'
import { execSync } from 'child_process'

class BatchRenamer {
  async renameFiles(pattern: string, replacement: string, dir: string): Promise<void> {
    console.log(`\nğŸ“ Batch renaming files in ${dir}\n`)

    // 1. Bash - æŸ¥æ‰¾åŒ¹é…çš„æ–‡ä»¶
    const files = execSync(`find ${dir} -name "${pattern}"`, { encoding: 'utf-8' })
      .split('\n')
      .filter(f => f)

    console.log(`Found ${files.length} files to rename\n`)

    for (const oldPath of files) {
      const dir = path.dirname(oldPath)
      const oldName = path.basename(oldPath)
      const newName = oldName.replace(new RegExp(pattern.replace('*', '.*')), replacement)
      const newPath = path.join(dir, newName)

      // 2. Bash - é‡å‘½åæ–‡ä»¶
      execSync(`mv "${oldPath}" "${newPath}"`)
      console.log(`âœ“ ${oldName} â†’ ${newName}`)

      // 3. Read - è¯»å–æ–‡ä»¶å†…å®¹
      const content = fs.readFileSync(newPath, 'utf-8')

      // 4. Edit - æ›´æ–°æ–‡ä»¶å†…éƒ¨å¼•ç”¨
      const updated = content.replace(new RegExp(oldName, 'g'), newName)
      if (updated !== content) {
        fs.writeFileSync(newPath, updated)
        console.log(`  âœ“ Updated internal references`)
      }
    }

    console.log(`\nâœ… Renamed ${files.length} files`)
  }
}

new BatchRenamer().renameFiles('*.old.ts', '.new.ts', './src')
```

---

## åœºæ™¯ 2ï¼šä»£ç åº“è¿ç§»

```typescript
// codebase-migration.ts
import fs from 'fs'
import path from 'path'
import { execSync } from 'child_process'

class CodebaseMigration {
  async migrateCodebase(sourceDir: string, targetDir: string): Promise<void> {
    console.log(`\nğŸšš Migrating codebase from ${sourceDir} to ${targetDir}\n`)

    // 1. Bash - åˆ›å»ºç›®æ ‡ç›®å½•
    execSync(`mkdir -p ${targetDir}`)

    // 2. Bash - å¤åˆ¶æ–‡ä»¶
    execSync(`cp -r ${sourceDir}/* ${targetDir}/`)

    // 3. æŸ¥æ‰¾æ‰€æœ‰æ–‡ä»¶
    const files = this.findFiles(targetDir)

    // 4. æ›´æ–°æ¯ä¸ªæ–‡ä»¶
    for (const file of files) {
      await this.updateFile(file, sourceDir, targetDir)
    }

    console.log(`\nâœ… Migration completed`)
  }

  private findFiles(dir: string): string[] {
    const files: string[] = []
    const walk = (currentDir: string) => {
      const entries = fs.readdirSync(currentDir, { withFileTypes: true })
      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name)
        if (entry.isDirectory()) {
          walk(fullPath)
        } else if (entry.name.match(/\.(ts|tsx|js|jsx)$/)) {
          files.push(fullPath)
        }
      }
    }
    walk(dir)
    return files
  }

  private async updateFile(file: string, oldBase: string, newBase: string): Promise<void> {
    // Read - è¯»å–æ–‡ä»¶
    const content = fs.readFileSync(file, 'utf-8')

    // Edit - æ›´æ–°å¯¼å…¥è·¯å¾„
    const updated = content.replace(
      new RegExp(oldBase, 'g'),
      newBase
    )

    if (updated !== content) {
      fs.writeFileSync(file, updated)
      console.log(`âœ“ Updated: ${path.relative(newBase, file)}`)
    }
  }
}

new CodebaseMigration().migrateCodebase('./old-project', './new-project')
```

---

## åœºæ™¯ 3ï¼šæ–‡æ¡£ç”Ÿæˆè‡ªåŠ¨åŒ–

```typescript
// doc-automation.ts
import fs from 'fs'
import { execSync } from 'child_process'

class DocAutomation {
  async generateDocs(sourceDir: string, outputDir: string): Promise<void> {
    console.log(`\nğŸ“š Generating documentation\n`)

    // 1. Bash - åˆ›å»ºè¾“å‡ºç›®å½•
    execSync(`mkdir -p ${outputDir}`)

    // 2. Bash - æŸ¥æ‰¾æ‰€æœ‰æºæ–‡ä»¶
    const files = execSync(`find ${sourceDir} -name "*.ts"`, { encoding: 'utf-8' })
      .split('\n')
      .filter(f => f)

    // 3. ä¸ºæ¯ä¸ªæ–‡ä»¶ç”Ÿæˆæ–‡æ¡£
    for (const file of files) {
      await this.generateFileDoc(file, outputDir)
    }

    // 4. Write - ç”Ÿæˆç´¢å¼•æ–‡ä»¶
    await this.generateIndex(files, outputDir)

    console.log(`\nâœ… Documentation generated in ${outputDir}`)
  }

  private async generateFileDoc(file: string, outputDir: string): Promise<void> {
    // Read - è¯»å–æºæ–‡ä»¶
    const content = fs.readFileSync(file, 'utf-8')

    // æå–å‡½æ•°å’Œç±»
    const functions = this.extractFunctions(content)
    const classes = this.extractClasses(content)

    // Write - ç”Ÿæˆ Markdown æ–‡æ¡£
    const docPath = `${outputDir}/${path.basename(file, '.ts')}.md`
    let doc = `# ${path.basename(file)}\n\n`

    if (classes.length > 0) {
      doc += `## Classes\n\n`
      classes.forEach(c => doc += `- ${c}\n`)
      doc += `\n`
    }

    if (functions.length > 0) {
      doc += `## Functions\n\n`
      functions.forEach(f => doc += `- ${f}\n`)
    }

    fs.writeFileSync(docPath, doc)
    console.log(`âœ“ Generated: ${path.basename(docPath)}`)
  }

  private extractFunctions(content: string): string[] {
    const matches = content.match(/function\s+(\w+)/g) || []
    return matches.map(m => m.replace('function ', ''))
  }

  private extractClasses(content: string): string[] {
    const matches = content.match(/class\s+(\w+)/g) || []
    return matches.map(m => m.replace('class ', ''))
  }

  private async generateIndex(files: string[], outputDir: string): Promise<void> {
    let index = `# API Documentation\n\n`
    index += `## Files\n\n`

    files.forEach(file => {
      const name = path.basename(file, '.ts')
      index += `- [${name}](./${name}.md)\n`
    })

    fs.writeFileSync(`${outputDir}/README.md`, index)
    console.log(`âœ“ Generated: README.md`)
  }
}

new DocAutomation().generateDocs('./src', './docs')
```

---

## åœºæ™¯ 4ï¼šå¤‡ä»½å’Œæ¢å¤

```typescript
// backup-restore.ts
import fs from 'fs'
import { execSync } from 'child_process'

class BackupRestore {
  async backup(sourceDir: string, backupDir: string): Promise<void> {
    console.log(`\nğŸ’¾ Creating backup\n`)

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const backupPath = `${backupDir}/backup-${timestamp}`

    // 1. Bash - åˆ›å»ºå¤‡ä»½ç›®å½•
    execSync(`mkdir -p ${backupPath}`)

    // 2. Bash - å¤åˆ¶æ–‡ä»¶
    execSync(`cp -r ${sourceDir}/* ${backupPath}/`)

    // 3. Bash - å‹ç¼©å¤‡ä»½
    execSync(`tar -czf ${backupPath}.tar.gz -C ${backupDir} backup-${timestamp}`)

    // 4. Bash - åˆ é™¤ä¸´æ—¶ç›®å½•
    execSync(`rm -rf ${backupPath}`)

    // 5. Write - åˆ›å»ºå¤‡ä»½æ¸…å•
    const manifest = {
      timestamp,
      source: sourceDir,
      backup: `${backupPath}.tar.gz`,
      files: execSync(`find ${sourceDir} -type f`, { encoding: 'utf-8' })
        .split('\n')
        .filter(f => f).length
    }

    fs.writeFileSync(
      `${backupDir}/manifest-${timestamp}.json`,
      JSON.stringify(manifest, null, 2)
    )

    console.log(`âœ… Backup created: ${backupPath}.tar.gz`)
  }

  async restore(backupFile: string, targetDir: string): Promise<void> {
    console.log(`\nâ™»ï¸  Restoring from backup\n`)

    // 1. Bash - è§£å‹å¤‡ä»½
    execSync(`tar -xzf ${backupFile} -C ${path.dirname(backupFile)}`)

    const extractedDir = backupFile.replace('.tar.gz', '')

    // 2. Bash - å¤åˆ¶åˆ°ç›®æ ‡ç›®å½•
    execSync(`mkdir -p ${targetDir}`)
    execSync(`cp -r ${extractedDir}/* ${targetDir}/`)

    // 3. Bash - æ¸…ç†
    execSync(`rm -rf ${extractedDir}`)

    console.log(`âœ… Restored to: ${targetDir}`)
  }
}

const backup = new BackupRestore()
backup.backup('./src', './backups')
// backup.restore('./backups/backup-2026-02-19.tar.gz', './src-restored')
```

---

## æœ€ä½³å®è·µæ€»ç»“

### 1. å·¥å…·ç»„åˆç­–ç•¥

- **Bash**: æ–‡ä»¶ç³»ç»Ÿæ“ä½œï¼ˆæŸ¥æ‰¾ã€å¤åˆ¶ã€ç§»åŠ¨ã€å‹ç¼©ï¼‰
- **Read**: è¯»å–æ–‡ä»¶å†…å®¹è¿›è¡Œåˆ†æ
- **Edit**: æ›´æ–°æ–‡ä»¶å†…å®¹
- **Write**: ç”Ÿæˆæ–°æ–‡ä»¶ï¼ˆæ–‡æ¡£ã€æ¸…å•ï¼‰

### 2. é”™è¯¯å¤„ç†

```typescript
try {
  execSync(command)
  const content = fs.readFileSync(file, 'utf-8')
  fs.writeFileSync(file, updated)
} catch (error) {
  console.error('Error:', error.message)
  // å›æ»šæˆ–æ¸…ç†
}
```

### 3. è¿›åº¦åé¦ˆ

```typescript
console.log(`Processing ${i + 1}/${total}: ${file}`)
```

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2026-02-19
**ç»´æŠ¤è€…ï¼š** Claude Code
