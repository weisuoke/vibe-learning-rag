# 【核心概念2】事务管理

> commit/rollback、ACID、隔离级别的详细讲解

---

## 概述

**事务是数据库操作的基本单位，确保数据的一致性和完整性。**

```
┌─────────────────────────────────────┐
│          事务（Transaction）         │
├─────────────────────────────────────┤
│  操作1: INSERT INTO users ...        │
│  操作2: UPDATE orders ...            │
│  操作3: DELETE FROM inventory ...    │
├─────────────────────────────────────┤
│  commit() → 所有操作生效             │
│  rollback() → 所有操作撤销           │
└─────────────────────────────────────┘
```

**ACID 原则：**
- **Atomicity（原子性）**：所有操作要么都成功，要么都失败
- **Consistency（一致性）**：数据库从一个一致状态到另一个一致状态
- **Isolation（隔离性）**：并发事务互不干扰
- **Durability（持久性）**：提交后数据永久保存

---

## 1. 事务的基本操作

### 1.1 commit：提交事务

**commit 将 Session 中的所有操作提交到数据库。**

```python
from sqlalchemy.orm import Session

with SessionLocal() as session:
    # 添加用户
    user = User(name="Alice", email="alice@example.com")
    session.add(user)

    # 提交事务
    session.commit()
    # 此时数据写入数据库，其他事务可以看到
```

**commit 的工作流程：**

```
1. flush() → 将 Session 中的操作同步到数据库
   ├─ 执行 INSERT/UPDATE/DELETE SQL
   └─ 数据在当前事务中可见

2. COMMIT → 提交事务
   ├─ 数据持久化
   └─ 其他事务可以看到

3. expire_all() → 对象过期（如果 expire_on_commit=True）
   └─ 下次访问对象时重新查询
```

**示例：**

```python
with SessionLocal() as session:
    user = User(name="Alice")
    session.add(user)

    # flush：同步到数据库，但不提交
    session.flush()
    print(user.id)  # 可以获取数据库生成的 ID

    # commit：提交事务
    session.commit()
    # 数据持久化，其他事务可以看到
```

---

### 1.2 rollback：回滚事务

**rollback 撤销 Session 中所有未提交的操作。**

```python
with SessionLocal() as session:
    try:
        # 添加用户
        user = User(name="Alice")
        session.add(user)

        # 添加订单
        order = Order(user_id=user.id, amount=100)
        session.add(order)

        # 模拟错误
        raise ValueError("Something went wrong")

        session.commit()
    except Exception as e:
        # 回滚所有操作
        session.rollback()
        print(f"Error: {e}")
        # user 和 order 都不会被保存
```

**rollback 的工作流程：**

```
1. ROLLBACK → 回滚事务
   ├─ 撤销所有未提交的操作
   └─ 数据库恢复到事务开始前的状态

2. expire_all() → 对象过期
   └─ Session 中的对象状态被清空

3. close_all_sessions() → 关闭所有连接
   └─ 释放资源
```

**示例：**

```python
with SessionLocal() as session:
    user = User(name="Alice")
    session.add(user)
    session.flush()

    print(user.id)  # 1（数据库生成的 ID）

    # 回滚
    session.rollback()

    print(user.id)  # None（对象过期）
    # 数据库中没有这条记录
```

---

### 1.3 flush：同步到数据库

**flush 将 Session 中的操作同步到数据库，但不提交事务。**

```python
with SessionLocal() as session:
    user = User(name="Alice")
    session.add(user)

    # flush：同步到数据库
    session.flush()
    print(user.id)  # 1（数据库生成的 ID）

    # 此时数据在当前事务中可见，但其他事务看不到

    # commit：提交事务
    session.commit()
    # 此时其他事务可以看到
```

**flush vs commit：**

| 操作 | flush | commit |
|------|-------|--------|
| **执行 SQL** | ✅ | ✅ |
| **提交事务** | ❌ | ✅ |
| **数据可见性** | 当前事务 | 所有事务 |
| **可以回滚** | ✅ | ❌ |
| **自动触发** | 查询前（autoflush） | 不会自动触发 |

**示例：**

```python
with SessionLocal() as session:
    # 添加用户
    user = User(name="Alice")
    session.add(user)

    # flush：同步到数据库
    session.flush()

    # 查询用户（可以查到）
    found_user = session.query(User).filter_by(name="Alice").first()
    print(found_user.id)  # 1

    # 回滚（可以撤销）
    session.rollback()

    # 查询用户（查不到）
    found_user = session.query(User).filter_by(name="Alice").first()
    print(found_user)  # None
```

---

## 2. ACID 原则

### 2.1 Atomicity（原子性）

**原子性：事务中的所有操作要么都成功，要么都失败。**

```python
# 场景：银行转账
with SessionLocal() as session:
    try:
        # 操作1：从 Alice 账户扣款
        alice = session.query(User).filter_by(name="Alice").first()
        alice.balance -= 100

        # 操作2：向 Bob 账户存款
        bob = session.query(User).filter_by(name="Bob").first()
        bob.balance += 100

        # 提交事务
        session.commit()
        # 两个操作都成功

    except Exception as e:
        # 回滚事务
        session.rollback()
        # 两个操作都失败
```

**原子性的保证：**

```python
# 示例：部分操作失败
with SessionLocal() as session:
    try:
        # 操作1：创建用户（成功）
        user = User(name="Alice")
        session.add(user)
        session.flush()

        # 操作2：创建订单（失败）
        order = Order(user_id=999)  # 不存在的用户
        session.add(order)
        session.flush()  # 抛出异常

        session.commit()

    except Exception as e:
        # 回滚所有操作
        session.rollback()
        # user 和 order 都不会被保存
```

---

### 2.2 Consistency（一致性）

**一致性：数据库从一个一致状态到另一个一致状态。**

```python
# 场景：库存扣减
with SessionLocal() as session:
    try:
        # 查询库存
        product = session.query(Product).filter_by(id=1).first()

        # 检查库存是否足够
        if product.stock < 10:
            raise ValueError("Insufficient stock")

        # 扣减库存
        product.stock -= 10

        # 创建订单
        order = Order(product_id=product.id, quantity=10)
        session.add(order)

        # 提交事务
        session.commit()
        # 数据库保持一致：库存减少，订单增加

    except Exception as e:
        # 回滚事务
        session.rollback()
        # 数据库保持一致：库存不变，订单不增加
```

**一致性的保证：**

```python
# 示例：约束检查
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True)  # 唯一约束
    balance = Column(Integer, CheckConstraint('balance >= 0'))  # 检查约束

with SessionLocal() as session:
    try:
        # 违反唯一约束
        user1 = User(email="alice@example.com")
        user2 = User(email="alice@example.com")  # 重复邮箱
        session.add_all([user1, user2])
        session.commit()  # 抛出异常

    except Exception as e:
        session.rollback()
        # 数据库保持一致：没有重复邮箱
```

---

### 2.3 Isolation（隔离性）

**隔离性：并发事务互不干扰。**

```python
# 场景：两个事务同时修改同一条记录

# 事务1
with SessionLocal() as session1:
    user = session1.query(User).filter_by(id=1).first()
    user.balance = 100
    session1.commit()

# 事务2（同时发生）
with SessionLocal() as session2:
    user = session2.query(User).filter_by(id=1).first()
    user.balance = 200
    session2.commit()

# 最终结果：取决于隔离级别
```

**隔离级别：**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|---------|------|-----------|------|
| **Read Uncommitted** | ✅ | ✅ | ✅ |
| **Read Committed** | ❌ | ✅ | ✅ |
| **Repeatable Read** | ❌ | ❌ | ✅ |
| **Serializable** | ❌ | ❌ | ❌ |

**设置隔离级别：**

```python
from sqlalchemy import create_engine

# 方法1：创建 Engine 时设置
engine = create_engine(
    "postgresql://...",
    isolation_level="REPEATABLE READ"
)

# 方法2：在连接上设置
with engine.connect() as conn:
    conn.execution_options(isolation_level="SERIALIZABLE")
    # 执行操作

# 方法3：在 Session 上设置
with SessionLocal() as session:
    session.connection(execution_options={"isolation_level": "SERIALIZABLE"})
    # 执行操作
```

---

### 2.4 Durability（持久性）

**持久性：提交后数据永久保存。**

```python
with SessionLocal() as session:
    user = User(name="Alice")
    session.add(user)
    session.commit()
    # 数据已持久化，即使系统崩溃也不会丢失

# 重启应用后
with SessionLocal() as session:
    user = session.query(User).filter_by(name="Alice").first()
    print(user)  # 数据仍然存在
```

**持久性的保证：**
- 数据写入磁盘
- 使用 WAL（Write-Ahead Logging）
- 事务日志

---

## 3. 事务隔离级别

### 3.1 Read Uncommitted（读未提交）

**允许读取未提交的数据（脏读）。**

```python
# 事务1
with SessionLocal() as session1:
    user = User(name="Alice", balance=100)
    session1.add(user)
    session1.flush()  # 未提交

    # 事务2（同时发生）
    with SessionLocal() as session2:
        # 设置隔离级别为 Read Uncommitted
        session2.connection(execution_options={"isolation_level": "READ UNCOMMITTED"})

        # 可以读取未提交的数据
        user = session2.query(User).filter_by(name="Alice").first()
        print(user.balance)  # 100（脏读）

    # 事务1回滚
    session1.rollback()

# 事务2读取的数据是无效的
```

**问题：脏读**
- 读取了未提交的数据
- 如果事务回滚，读取的数据是无效的

---

### 3.2 Read Committed（读已提交）

**只能读取已提交的数据（PostgreSQL 默认）。**

```python
# 事务1
with SessionLocal() as session1:
    user = User(name="Alice", balance=100)
    session1.add(user)
    session1.flush()  # 未提交

    # 事务2（同时发生）
    with SessionLocal() as session2:
        # 设置隔离级别为 Read Committed
        session2.connection(execution_options={"isolation_level": "READ COMMITTED"})

        # 读取不到未提交的数据
        user = session2.query(User).filter_by(name="Alice").first()
        print(user)  # None

    # 事务1提交
    session1.commit()

    # 事务2再次查询
    with SessionLocal() as session2:
        user = session2.query(User).filter_by(name="Alice").first()
        print(user.balance)  # 100（可以读取）
```

**问题：不可重复读**

```python
# 事务1
with SessionLocal() as session1:
    # 第一次查询
    user = session1.query(User).filter_by(id=1).first()
    print(user.balance)  # 100

    # 事务2（同时发生）
    with SessionLocal() as session2:
        user = session2.query(User).filter_by(id=1).first()
        user.balance = 200
        session2.commit()

    # 第二次查询
    session1.expire_all()  # 刷新对象
    user = session1.query(User).filter_by(id=1).first()
    print(user.balance)  # 200（不可重复读）
```

---

### 3.3 Repeatable Read（可重复读）

**同一事务中多次读取同一数据，结果一致（MySQL 默认）。**

```python
# 事务1
with SessionLocal() as session1:
    # 设置隔离级别为 Repeatable Read
    session1.connection(execution_options={"isolation_level": "REPEATABLE READ"})

    # 第一次查询
    user = session1.query(User).filter_by(id=1).first()
    print(user.balance)  # 100

    # 事务2（同时发生）
    with SessionLocal() as session2:
        user = session2.query(User).filter_by(id=1).first()
        user.balance = 200
        session2.commit()

    # 第二次查询
    session1.expire_all()  # 刷新对象
    user = session1.query(User).filter_by(id=1).first()
    print(user.balance)  # 100（可重复读）
```

**问题：幻读**

```python
# 事务1
with SessionLocal() as session1:
    # 设置隔离级别为 Repeatable Read
    session1.connection(execution_options={"isolation_level": "REPEATABLE READ"})

    # 第一次查询
    users = session1.query(User).filter(User.age > 18).all()
    print(len(users))  # 10

    # 事务2（同时发生）
    with SessionLocal() as session2:
        user = User(name="Alice", age=20)
        session2.add(user)
        session2.commit()

    # 第二次查询
    users = session1.query(User).filter(User.age > 18).all()
    print(len(users))  # 11（幻读）
```

---

### 3.4 Serializable（可串行化）

**最高隔离级别，完全隔离，避免所有并发问题。**

```python
# 事务1
with SessionLocal() as session1:
    # 设置隔离级别为 Serializable
    session1.connection(execution_options={"isolation_level": "SERIALIZABLE"})

    # 查询用户
    user = session1.query(User).filter_by(id=1).first()
    user.balance += 100

    # 事务2（同时发生）
    with SessionLocal() as session2:
        session2.connection(execution_options={"isolation_level": "SERIALIZABLE"})

        # 尝试修改同一用户
        user = session2.query(User).filter_by(id=1).first()
        user.balance += 200

        # 提交时会抛出异常
        try:
            session2.commit()
        except Exception as e:
            print(f"Error: {e}")  # 串行化冲突

    # 事务1提交
    session1.commit()
```

**性能影响：**
- Serializable > Repeatable Read > Read Committed > Read Uncommitted
- 隔离级别越高，性能越低

---

## 4. 锁机制

### 4.1 乐观锁（Optimistic Locking）

**假设冲突很少发生，使用版本号检测冲突。**

```python
from sqlalchemy import Column, Integer, String

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    name = Column(String)
    balance = Column(Integer)
    version = Column(Integer, default=0)  # 版本号

# 使用乐观锁
with SessionLocal() as session:
    # 查询用户
    user = session.query(User).filter_by(id=1).first()
    original_version = user.version

    # 修改用户
    user.balance += 100

    # 提交时检查版本号
    result = session.query(User).filter(
        User.id == user.id,
        User.version == original_version
    ).update({
        "balance": user.balance,
        "version": user.version + 1
    })

    if result == 0:
        # 版本号不匹配，说明有其他事务修改了数据
        session.rollback()
        raise ValueError("Optimistic lock failed")

    session.commit()
```

**优点：**
- 不需要锁定数据库
- 性能高

**缺点：**
- 冲突时需要重试
- 适合冲突少的场景

---

### 4.2 悲观锁（Pessimistic Locking）

**假设冲突经常发生，提前锁定数据。**

```python
# 使用悲观锁
with SessionLocal() as session:
    # 查询用户并锁定
    user = session.query(User).with_for_update().filter_by(id=1).first()
    # 执行 SELECT ... FOR UPDATE

    # 修改用户
    user.balance += 100

    # 提交事务
    session.commit()
    # 释放锁
```

**锁的类型：**

```python
# 排他锁（写锁）
user = session.query(User).with_for_update().filter_by(id=1).first()
# SELECT ... FOR UPDATE

# 共享锁（读锁）
user = session.query(User).with_for_update(read=True).filter_by(id=1).first()
# SELECT ... FOR SHARE

# 跳过锁定的行
user = session.query(User).with_for_update(skip_locked=True).filter_by(id=1).first()
# SELECT ... FOR UPDATE SKIP LOCKED

# 不等待锁
user = session.query(User).with_for_update(nowait=True).filter_by(id=1).first()
# SELECT ... FOR UPDATE NOWAIT
```

**优点：**
- 避免冲突
- 适合冲突多的场景

**缺点：**
- 锁定数据库
- 性能低

---

## 5. 嵌套事务（Savepoint）

### 5.1 使用 begin_nested

**创建保存点，实现部分回滚。**

```python
with SessionLocal() as session:
    # 外层事务
    user = User(name="Alice")
    session.add(user)

    # 嵌套事务（SAVEPOINT）
    with session.begin_nested():
        order = Order(user_id=user.id, amount=100)
        session.add(order)

        # 嵌套事务回滚
        session.rollback()  # 只回滚 order

    # 外层事务提交
    session.commit()  # Alice 被保存，order 被回滚
```

**工作原理：**

```sql
BEGIN;  -- 外层事务

INSERT INTO users (name) VALUES ('Alice');

SAVEPOINT sp1;  -- 嵌套事务

INSERT INTO orders (user_id, amount) VALUES (1, 100);

ROLLBACK TO SAVEPOINT sp1;  -- 回滚到保存点

COMMIT;  -- 提交外层事务
```

---

### 5.2 应用场景

**场景1：部分回滚**

```python
with SessionLocal() as session:
    # 创建用户
    user = User(name="Alice")
    session.add(user)
    session.flush()

    # 尝试创建订单
    try:
        with session.begin_nested():
            order = Order(user_id=user.id, amount=100)
            session.add(order)

            # 验证失败
            if order.amount > user.balance:
                raise ValueError("Insufficient balance")

            session.commit()
    except ValueError:
        # 回滚订单，但保留用户
        session.rollback()

    # 提交用户
    session.commit()
```

**场景2：批量操作的部分失败**

```python
with SessionLocal() as session:
    for data in batch_data:
        try:
            with session.begin_nested():
                user = User(**data)
                session.add(user)
                session.commit()
        except Exception as e:
            # 跳过失败的记录
            session.rollback()
            print(f"Failed to insert {data}: {e}")

    # 提交成功的记录
    session.commit()
```

---

## 6. 事务最佳实践

### 6.1 保持事务简短

```python
# ❌ 错误：事务太长
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()

    # 调用外部 API（耗时）
    response = requests.post("https://api.example.com", json=user.dict())

    # 处理响应（耗时）
    process_response(response)

    # 提交事务
    session.commit()

# ✅ 正确：事务简短
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()
    user_data = user.dict()

# 调用外部 API（不在事务中）
response = requests.post("https://api.example.com", json=user_data)
process_response(response)

# 更新数据库
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()
    user.status = "processed"
    session.commit()
```

### 6.2 避免在事务中执行长时间操作

```python
# ❌ 错误：在事务中执行长时间操作
with SessionLocal() as session:
    users = session.query(User).all()

    for user in users:
        # 发送邮件（耗时）
        send_email(user.email, "Hello")

    session.commit()

# ✅ 正确：先查询，再执行长时间操作
with SessionLocal() as session:
    users = session.query(User).all()
    user_emails = [user.email for user in users]

# 发送邮件（不在事务中）
for email in user_emails:
    send_email(email, "Hello")
```

### 6.3 使用上下文管理器

```python
# ❌ 错误：手动管理事务
session = SessionLocal()
try:
    user = User(name="Alice")
    session.add(user)
    session.commit()
except:
    session.rollback()
finally:
    session.close()

# ✅ 正确：使用上下文管理器
with SessionLocal() as session:
    user = User(name="Alice")
    session.add(user)
    session.commit()
```

### 6.4 处理死锁

```python
from sqlalchemy.exc import OperationalError
import time

def create_user_with_retry(name, max_retries=3):
    for attempt in range(max_retries):
        try:
            with SessionLocal() as session:
                user = User(name=name)
                session.add(user)
                session.commit()
                return user
        except OperationalError as e:
            if "deadlock" in str(e).lower():
                if attempt < max_retries - 1:
                    time.sleep(0.1 * (2 ** attempt))  # 指数退避
                    continue
            raise
```

---

## 总结

**事务管理的核心要点：**

1. **基本操作**：commit 提交，rollback 回滚，flush 同步
2. **ACID 原则**：原子性、一致性、隔离性、持久性
3. **隔离级别**：Read Uncommitted < Read Committed < Repeatable Read < Serializable
4. **锁机制**：乐观锁（版本号）、悲观锁（SELECT FOR UPDATE）
5. **嵌套事务**：使用 begin_nested 创建保存点
6. **最佳实践**：保持事务简短、避免长时间操作、使用上下文管理器

**记住：** 事务是数据一致性的保证，合理使用事务可以避免数据不一致和并发问题。
