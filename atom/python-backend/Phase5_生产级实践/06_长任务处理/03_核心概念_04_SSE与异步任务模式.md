# 核心概念04：SSE与异步任务模式

> 深入理解Server-Sent Events、异步任务模式和任务取消机制

---

## 什么是SSE（Server-Sent Events）？

### 定义

**SSE = HTTP长连接 + 服务器单向推送 + 自动重连**

SSE是一种基于HTTP的服务器推送技术，允许服务器主动向客户端推送数据，无需客户端轮询。

### HTTP vs SSE vs WebSocket

```
HTTP（请求-响应）：
客户端 ──请求──> 服务器
客户端 <──响应── 服务器
（每次通信都需要新请求）

SSE（服务器推送）：
客户端 ──建立连接──> 服务器
客户端 <────推送──── 服务器
客户端 <────推送──── 服务器
（服务器持续推送，客户端只接收）

WebSocket（双向通信）：
客户端 ←─────────> 服务器
       双向实时通信
（双方都可以主动发送消息）
```

**对比表**：

| 特性 | HTTP | SSE | WebSocket |
|------|------|-----|-----------|
| **通信方向** | 单向（客户端→服务器） | 单向（服务器→客户端） | 双向 |
| **协议** | HTTP | HTTP | WebSocket协议 |
| **连接** | 短连接 | 长连接 | 长连接 |
| **自动重连** | ❌ | ✅ 浏览器自动 | ❌ 需要手动实现 |
| **实现复杂度** | 简单 | 简单 | 复杂 |
| **适用场景** | 普通API | 进度推送、通知 | 聊天、实时协作 |

---

## SSE协议基础

### 1. SSE消息格式

```
data: 这是一条消息\n\n

data: {"type": "progress", "value": 50}\n\n

data: 多行消息第一行\n
data: 多行消息第二行\n\n

event: custom-event\n
data: 自定义事件数据\n\n

id: 123\n
data: 带ID的消息\n\n

retry: 5000\n
data: 设置重连间隔为5秒\n\n
```

**关键字段**：
- `data:`：消息内容（必需）
- `event:`：事件类型（可选，默认为"message"）
- `id:`：消息ID（可选，用于断线重连）
- `retry:`：重连间隔（可选，单位毫秒）
- `\n\n`：消息结束标记（两个换行符）

---

### 2. SSE连接建立

```
1. 客户端发起HTTP请求
   GET /stream HTTP/1.1
   Host: localhost:8000
   Accept: text/event-stream
   Cache-Control: no-cache

2. 服务器响应
   HTTP/1.1 200 OK
   Content-Type: text/event-stream
   Cache-Control: no-cache
   Connection: keep-alive

3. 服务器持续推送数据
   data: {"progress": 10}\n\n
   data: {"progress": 20}\n\n
   ...
```

**关键点**：
- `Content-Type: text/event-stream`：SSE专用MIME类型
- `Cache-Control: no-cache`：禁止缓存
- `Connection: keep-alive`：保持连接

---

## FastAPI中实现SSE

### 1. 基础SSE端点

```python
# app/main.py
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import asyncio
import json

app = FastAPI()

@app.get("/stream")
async def stream_data():
    """基础SSE端点"""
    async def generate():
        for i in range(10):
            # 发送数据
            data = {"count": i, "timestamp": datetime.now().isoformat()}
            yield f"data: {json.dumps(data)}\n\n"

            # 等待1秒
            await asyncio.sleep(1)

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

**关键点**：
- `StreamingResponse`：流式响应
- `media_type="text/event-stream"`：SSE格式
- `yield f"data: {json.dumps(data)}\n\n"`：SSE消息格式
- `await asyncio.sleep(1)`：异步等待

---

### 2. 前端连接SSE

```javascript
// 前端代码（JavaScript）
const eventSource = new EventSource('/stream');

// 接收消息
eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log('收到数据:', data);
};

// 连接打开
eventSource.onopen = () => {
    console.log('SSE连接已建立');
};

// 连接错误
eventSource.onerror = (error) => {
    console.error('SSE错误:', error);
    // 浏览器会自动重连
};

// 关闭连接
eventSource.close();
```

**关键点**：
- `EventSource`：浏览器原生SSE客户端
- `onmessage`：接收消息
- `onerror`：错误处理（浏览器自动重连）
- `close()`：关闭连接

---

### 3. 自定义事件类型

```python
@app.get("/stream-events")
async def stream_events():
    """发送不同类型的事件"""
    async def generate():
        # 发送进度事件
        yield f"event: progress\n"
        yield f"data: {json.dumps({'value': 50})}\n\n"

        await asyncio.sleep(1)

        # 发送完成事件
        yield f"event: complete\n"
        yield f"data: {json.dumps({'status': 'done'})}\n\n"

    return StreamingResponse(generate(), media_type="text/event-stream")
```

```javascript
// 前端监听自定义事件
const eventSource = new EventSource('/stream-events');

// 监听progress事件
eventSource.addEventListener('progress', (event) => {
    const data = JSON.parse(event.data);
    console.log('进度:', data.value);
});

// 监听complete事件
eventSource.addEventListener('complete', (event) => {
    const data = JSON.parse(event.data);
    console.log('完成:', data.status);
    eventSource.close();
});
```

---

### 4. 带ID的消息（支持断线重连）

```python
@app.get("/stream-with-id")
async def stream_with_id():
    """发送带ID的消息"""
    async def generate():
        for i in range(100):
            # 发送带ID的消息
            yield f"id: {i}\n"
            yield f"data: {json.dumps({'count': i})}\n\n"
            await asyncio.sleep(1)

    return StreamingResponse(generate(), media_type="text/event-stream")
```

```javascript
// 前端自动从上次断开的位置继续
const eventSource = new EventSource('/stream-with-id');

eventSource.onmessage = (event) => {
    console.log('消息ID:', event.lastEventId);
    console.log('数据:', event.data);
};

// 断线重连时，浏览器会自动发送Last-Event-ID头
// GET /stream-with-id
// Last-Event-ID: 42
```

---

## 任务进度推送（SSE实现）

### 1. 架构设计

```
┌─────────────────────────────────────────────────────────┐
│                  SSE进度推送系统                         │
│                                                          │
│  ┌──────────┐                                           │
│  │ 客户端   │                                           │
│  └────┬─────┘                                           │
│       │ 1. 建立SSE连接                                  │
│       ↓                                                  │
│  ┌──────────────────────────────────────────┐          │
│  │         SSE端点                           │          │
│  │  /tasks/{task_id}/stream                 │          │
│  └──────────────────────────────────────────┘          │
│       │                                                  │
│       │ 2. 定期查询数据库                               │
│       ↓                                                  │
│  ┌──────────────────────────────────────────┐          │
│  │         数据库                            │          │
│  │  查询任务状态和进度                       │          │
│  └──────────────────────────────────────────┘          │
│       ↑                                                  │
│       │ 3. Worker更新进度                               │
│       │                                                  │
│  ┌──────────────────────────────────────────┐          │
│  │         Celery Worker                     │          │
│  │  - 执行任务                               │          │
│  │  - 更新数据库进度                         │          │
│  └──────────────────────────────────────────┘          │
└─────────────────────────────────────────────────────────┘
```

---

### 2. 实现任务进度推送

```python
# app/main.py
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
from app.models.task import Task
from app.core.database import SessionLocal
import asyncio
import json

app = FastAPI()

@app.get("/tasks/{task_id}/stream")
async def stream_task_progress(task_id: str):
    """SSE推送任务进度"""
    async def generate():
        db = SessionLocal()

        try:
            while True:
                # 查询任务状态
                task = db.query(Task).filter(Task.task_id == task_id).first()

                if not task:
                    yield f"data: {json.dumps({'error': 'Task not found'})}\n\n"
                    break

                # 推送进度
                data = {
                    "task_id": task_id,
                    "status": task.status.value,
                    "progress": task.progress,
                    "message": task.metadata.get('message') if task.metadata else None
                }
                yield f"data: {json.dumps(data)}\n\n"

                # 任务完成，停止推送
                if task.status in ["completed", "failed", "canceled"]:
                    # 发送完成事件
                    yield f"event: complete\n"
                    yield f"data: {json.dumps({'result': task.result})}\n\n"
                    break

                # 每秒查询一次
                await asyncio.sleep(1)

        finally:
            db.close()

    return StreamingResponse(
        generate(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no"  # 禁用Nginx缓冲
        }
    )
```

**关键点**：
- 定期查询数据库（每秒一次）
- 任务完成后停止推送
- 发送自定义事件（complete）
- 禁用缓存和缓冲

---

### 3. 前端进度条

```javascript
// 前端进度条实现
const taskId = 'task-123';
const eventSource = new EventSource(`/tasks/${taskId}/stream`);

// 更新进度条
eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);

    // 更新进度条
    document.getElementById('progress').value = data.progress;
    document.getElementById('status').textContent = data.status;

    if (data.message) {
        document.getElementById('message').textContent = data.message;
    }
};

// 任务完成
eventSource.addEventListener('complete', (event) => {
    const data = JSON.parse(event.data);
    console.log('任务完成:', data.result);

    // 关闭连接
    eventSource.close();

    // 显示完成消息
    alert('任务完成！');
});

// 错误处理
eventSource.onerror = (error) => {
    console.error('SSE错误:', error);
    // 浏览器会自动重连
};
```

---

## 异步任务模式

### 1. asyncio.create_task

```python
import asyncio

async def long_running_task(task_id: str):
    """长时间运行的任务"""
    print(f"任务 {task_id} 开始")

    # 模拟耗时操作
    await asyncio.sleep(60)

    print(f"任务 {task_id} 完成")
    return {"status": "done"}

@app.post("/submit")
async def submit_task():
    """提交任务（异步执行）"""
    task_id = "task-123"

    # 创建后台任务（不等待完成）
    asyncio.create_task(long_running_task(task_id))

    # 立即返回
    return {
        "task_id": task_id,
        "status": "processing"
    }
```

**关键点**：
- `asyncio.create_task()`：创建后台任务
- 不等待任务完成，立即返回
- 任务在事件循环中异步执行

---

### 2. 任务状态追踪

```python
# 全局任务字典
tasks = {}

async def long_running_task(task_id: str):
    """带状态追踪的任务"""
    # 更新状态为运行中
    tasks[task_id] = {"status": "running", "progress": 0}

    try:
        for i in range(10):
            # 模拟处理
            await asyncio.sleep(1)

            # 更新进度
            tasks[task_id]["progress"] = (i + 1) * 10

        # 任务完成
        tasks[task_id]["status"] = "completed"
        tasks[task_id]["result"] = {"data": "processed"}

    except Exception as e:
        # 任务失败
        tasks[task_id]["status"] = "failed"
        tasks[task_id]["error"] = str(e)

@app.post("/submit")
async def submit_task():
    """提交任务"""
    task_id = f"task-{uuid.uuid4()}"

    # 初始化任务状态
    tasks[task_id] = {"status": "pending", "progress": 0}

    # 创建后台任务
    asyncio.create_task(long_running_task(task_id))

    return {"task_id": task_id}

@app.get("/tasks/{task_id}")
async def get_task_status(task_id: str):
    """查询任务状态"""
    if task_id not in tasks:
        return {"error": "Task not found"}

    return tasks[task_id]
```

---

### 3. SSE推送任务进度（内存版）

```python
@app.get("/tasks/{task_id}/stream")
async def stream_task_progress(task_id: str):
    """SSE推送任务进度（从内存读取）"""
    async def generate():
        while True:
            # 从内存读取任务状态
            if task_id not in tasks:
                yield f"data: {json.dumps({'error': 'Task not found'})}\n\n"
                break

            task = tasks[task_id]

            # 推送进度
            yield f"data: {json.dumps(task)}\n\n"

            # 任务完成，停止推送
            if task["status"] in ["completed", "failed"]:
                break

            # 每秒推送一次
            await asyncio.sleep(1)

    return StreamingResponse(generate(), media_type="text/event-stream")
```

---

## 任务取消机制

### 1. 取消asyncio任务

```python
# 全局任务字典（存储Task对象）
running_tasks = {}

async def long_running_task(task_id: str):
    """可取消的任务"""
    try:
        for i in range(100):
            # 检查是否被取消
            if asyncio.current_task().cancelled():
                print(f"任务 {task_id} 被取消")
                return {"status": "canceled"}

            # 模拟处理
            await asyncio.sleep(1)

            # 更新进度
            tasks[task_id]["progress"] = (i + 1)

        return {"status": "completed"}

    except asyncio.CancelledError:
        print(f"任务 {task_id} 被取消")
        tasks[task_id]["status"] = "canceled"
        raise

@app.post("/submit")
async def submit_task():
    """提交任务"""
    task_id = f"task-{uuid.uuid4()}"

    # 初始化任务状态
    tasks[task_id] = {"status": "running", "progress": 0}

    # 创建后台任务
    task = asyncio.create_task(long_running_task(task_id))
    running_tasks[task_id] = task

    return {"task_id": task_id}

@app.post("/tasks/{task_id}/cancel")
async def cancel_task(task_id: str):
    """取消任务"""
    if task_id not in running_tasks:
        return {"error": "Task not found"}

    # 取消任务
    task = running_tasks[task_id]
    task.cancel()

    # 更新状态
    tasks[task_id]["status"] = "canceled"

    return {"status": "canceled"}
```

---

### 2. 优雅取消（清理资源）

```python
async def long_running_task(task_id: str):
    """优雅取消的任务"""
    # 打开资源
    file = open(f"/tmp/{task_id}.txt", "w")

    try:
        for i in range(100):
            # 处理数据
            await asyncio.sleep(1)
            file.write(f"Progress: {i}\n")

        return {"status": "completed"}

    except asyncio.CancelledError:
        print(f"任务 {task_id} 被取消，清理资源")

        # 清理资源
        file.write("Task canceled\n")
        file.close()

        # 删除临时文件
        os.remove(f"/tmp/{task_id}.txt")

        raise

    finally:
        # 确保资源被释放
        if not file.closed:
            file.close()
```

---

### 3. 超时取消

```python
async def long_running_task(task_id: str):
    """长时间运行的任务"""
    await asyncio.sleep(120)  # 2分钟
    return {"status": "completed"}

@app.post("/submit")
async def submit_task():
    """提交任务（带超时）"""
    task_id = f"task-{uuid.uuid4()}"

    async def run_with_timeout():
        try:
            # 设置超时时间（60秒）
            result = await asyncio.wait_for(
                long_running_task(task_id),
                timeout=60
            )
            tasks[task_id] = {"status": "completed", "result": result}

        except asyncio.TimeoutError:
            # 超时
            tasks[task_id] = {"status": "failed", "error": "Task timeout"}

    # 创建后台任务
    asyncio.create_task(run_with_timeout())

    return {"task_id": task_id}
```

---

## SSE vs WebSocket：何时使用SSE？

### 适用场景对比

| 场景 | 推荐技术 | 原因 |
|------|---------|------|
| **任务进度推送** | SSE | 单向推送，自动重连，简单 |
| **实时通知** | SSE | 单向推送，简单 |
| **日志流** | SSE | 单向推送，简单 |
| **监控数据** | SSE | 单向推送，简单 |
| **聊天应用** | WebSocket | 双向通信，实时互动 |
| **实时协作** | WebSocket | 双向通信，低延迟 |
| **在线游戏** | WebSocket | 双向通信，高频通信 |

---

### SSE的优势

1. **自动重连**：浏览器自动处理断线重连
2. **简单实现**：50行代码 vs WebSocket 200行代码
3. **HTTP协议**：无需特殊协议支持
4. **防火墙友好**：基于HTTP，不会被防火墙阻止
5. **断点续传**：支持Last-Event-ID

---

### SSE的限制

1. **单向通信**：只能服务器→客户端
2. **仅文本**：不支持二进制数据
3. **连接数限制**：浏览器对同一域名的SSE连接有限制（通常6个）
4. **不支持自定义头**：无法在连接建立后发送自定义头

---

## 生产级SSE实现

### 1. 错误处理

```python
@app.get("/tasks/{task_id}/stream")
async def stream_task_progress(task_id: str):
    """带错误处理的SSE端点"""
    async def generate():
        db = SessionLocal()

        try:
            while True:
                try:
                    # 查询任务状态
                    task = db.query(Task).filter(Task.task_id == task_id).first()

                    if not task:
                        yield f"data: {json.dumps({'error': 'Task not found'})}\n\n"
                        break

                    # 推送进度
                    data = {
                        "task_id": task_id,
                        "status": task.status.value,
                        "progress": task.progress
                    }
                    yield f"data: {json.dumps(data)}\n\n"

                    # 任务完成
                    if task.status in ["completed", "failed", "canceled"]:
                        break

                    await asyncio.sleep(1)

                except Exception as e:
                    # 发送错误消息
                    yield f"data: {json.dumps({'error': str(e)})}\n\n"
                    break

        finally:
            db.close()

    return StreamingResponse(
        generate(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no"
        }
    )
```

---

### 2. 心跳机制

```python
@app.get("/tasks/{task_id}/stream")
async def stream_task_progress(task_id: str):
    """带心跳的SSE端点"""
    async def generate():
        db = SessionLocal()
        last_heartbeat = time.time()

        try:
            while True:
                # 查询任务状态
                task = db.query(Task).filter(Task.task_id == task_id).first()

                if task:
                    # 推送进度
                    data = {
                        "task_id": task_id,
                        "status": task.status.value,
                        "progress": task.progress
                    }
                    yield f"data: {json.dumps(data)}\n\n"

                    # 任务完成
                    if task.status in ["completed", "failed", "canceled"]:
                        break

                # 发送心跳（每30秒）
                if time.time() - last_heartbeat > 30:
                    yield f": heartbeat\n\n"  # 注释行，不会被客户端处理
                    last_heartbeat = time.time()

                await asyncio.sleep(1)

        finally:
            db.close()

    return StreamingResponse(generate(), media_type="text/event-stream")
```

---

### 3. 连接限制

```python
# 全局连接计数器
active_connections = {}

@app.get("/tasks/{task_id}/stream")
async def stream_task_progress(task_id: str):
    """带连接限制的SSE端点"""
    # 检查连接数
    if task_id in active_connections:
        return {"error": "Already connected"}

    async def generate():
        # 标记连接
        active_connections[task_id] = True

        try:
            # ... 推送逻辑 ...
            pass

        finally:
            # 移除连接标记
            active_connections.pop(task_id, None)

    return StreamingResponse(generate(), media_type="text/event-stream")
```

---

## 最佳实践

### 1. 选择SSE还是WebSocket？

**决策树**：
```
需要双向通信？
├─ 是 → 用 WebSocket
└─ 否 → 用 SSE
```

**简单规则**：
- ✅ **进度推送**：用SSE
- ✅ **实时通知**：用SSE
- ✅ **日志流**：用SSE
- ✅ **聊天应用**：用WebSocket
- ✅ **实时协作**：用WebSocket

---

### 2. SSE性能优化

```python
# 1. 使用Redis缓存任务状态
import redis

r = redis.Redis()

@app.get("/tasks/{task_id}/stream")
async def stream_task_progress(task_id: str):
    async def generate():
        while True:
            # 从Redis读取（更快）
            task_data = r.get(f"task:{task_id}")

            if task_data:
                yield f"data: {task_data.decode()}\n\n"

            await asyncio.sleep(1)

    return StreamingResponse(generate(), media_type="text/event-stream")

# 2. Worker更新Redis
@app.task
def process_document(task_id: str):
    # 更新Redis
    r.set(f"task:{task_id}", json.dumps({
        "status": "running",
        "progress": 50
    }))
```

---

### 3. 断线重连处理

```python
@app.get("/tasks/{task_id}/stream")
async def stream_task_progress(task_id: str, last_event_id: str = None):
    """支持断线重连的SSE端点"""
    async def generate():
        # 从上次断开的位置继续
        start_from = int(last_event_id) if last_event_id else 0

        for i in range(start_from, 100):
            # 发送带ID的消息
            yield f"id: {i}\n"
            yield f"data: {json.dumps({'progress': i})}\n\n"
            await asyncio.sleep(1)

    return StreamingResponse(generate(), media_type="text/event-stream")
```

---

## 总结

### SSE核心要点

1. **单向推送**：服务器→客户端
2. **自动重连**：浏览器自动处理
3. **简单实现**：基于HTTP，50行代码
4. **适用场景**：进度推送、通知、日志流

### 异步任务模式核心要点

1. **asyncio.create_task()**：创建后台任务
2. **任务取消**：`task.cancel()`
3. **超时控制**：`asyncio.wait_for()`
4. **资源清理**：`try...finally`

### 实现检查清单

- [ ] 实现SSE端点（StreamingResponse）
- [ ] 实现任务进度推送（定期查询数据库）
- [ ] 实现前端连接（EventSource）
- [ ] 实现任务取消（task.cancel()）
- [ ] 实现错误处理（try...except）
- [ ] 实现心跳机制（防止连接超时）
- [ ] 实现连接限制（防止重复连接）

---

**记住**：对于进度推送，SSE是比WebSocket更简单的选择，因为它自动处理重连，实现简单，且满足单向推送的需求。
