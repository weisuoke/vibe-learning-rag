# 核心概念：优先级队列

## 概述

**优先级队列按优先级而非时间顺序处理任务,使用堆数据结构实现O(log n)的入队出队操作,是AI Agent任务调度的核心工具。**

---

## 定义与特性

### 核心定义

优先级队列是一种特殊的队列,具有以下特性:
1. **按优先级出队**:优先级最高的元素先出队
2. **堆实现**:通常使用最小堆或最大堆
3. **动态调整**:可以在运行时调整任务优先级

### 基本操作

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def push(self, item, priority):
        """入队:O(log n)"""
        heapq.heappush(self.heap, (priority, item))

    def pop(self):
        """出队:O(log n)"""
        if self.is_empty():
            raise IndexError("队列为空")
        return heapq.heappop(self.heap)[1]

    def peek(self):
        """查看:O(1)"""
        if self.is_empty():
            raise IndexError("队列为空")
        return self.heap[0][1]

    def is_empty(self):
        """判空:O(1)"""
        return len(self.heap) == 0
```

---

## Python实现

### 方式1:heapq模块(推荐)

```python
import heapq

# 创建优先级队列
pq = []

# 入队:(优先级,任务)
heapq.heappush(pq, (1, "高优先级任务"))
heapq.heappush(pq, (5, "低优先级任务"))
heapq.heappush(pq, (3, "中优先级任务"))

# 出队:优先级最小的先出
priority, task = heapq.heappop(pq)
print(f"优先级{priority}: {task}")  # 优先级1: 高优先级任务

# 查看队首
priority, task = pq[0]
print(f"下一个: 优先级{priority}")
```

**关键点**:
- 数字越小,优先级越高
- 自动维护堆结构
- 不支持随机访问

### 方式2:queue.PriorityQueue(线程安全)

```python
from queue import PriorityQueue

# 创建优先级队列
pq = PriorityQueue()

# 入队
pq.put((1, "高优先级"))
pq.put((5, "低优先级"))
pq.put((3, "中优先级"))

# 出队
priority, task = pq.get()
print(f"优先级{priority}: {task}")

# 非阻塞操作
try:
    priority, task = pq.get_nowait()
except:
    print("队列为空")
```

**特点**:
- 线程安全
- 支持阻塞和超时
- 适合多线程场景

### 方式3:asyncio.PriorityQueue(异步)

```python
import asyncio

async def main():
    pq = asyncio.PriorityQueue()

    # 入队
    await pq.put((1, "高优先级"))
    await pq.put((5, "低优先级"))
    await pq.put((3, "中优先级"))

    # 出队
    priority, task = await pq.get()
    print(f"优先级{priority}: {task}")

asyncio.run(main())
```

**特点**:
- 异步非阻塞
- 适合I/O密集型任务
- 单线程高并发

---

## 防饥饿机制

### 问题:低优先级任务可能永远得不到执行

```python
import heapq

pq = []

# 持续添加高优先级任务
for i in range(1000):
    heapq.heappush(pq, (1, f"高优先级{i}"))

# 添加低优先级任务
heapq.heappush(pq, (10, "低优先级"))

# 结果:低优先级任务永远得不到执行(饥饿)
```

### 解决方案1:优先级老化(Aging)

```python
import heapq
import time

class AgingPriorityQueue:
    """优先级老化队列"""

    def __init__(self, aging_rate=0.01):
        self.heap = []
        self.aging_rate = aging_rate
        self.counter = 0

    def push(self, task, priority):
        """入队:优先级随时间降低"""
        timestamp = time.time()
        heapq.heappush(self.heap, (priority, timestamp, self.counter, task))
        self.counter += 1

    def pop(self):
        """出队:考虑老化"""
        if not self.heap:
            raise IndexError("队列为空")

        # 重新计算所有任务的优先级
        now = time.time()
        adjusted_heap = []

        for priority, timestamp, counter, task in self.heap:
            # 优先级随等待时间降低
            wait_time = now - timestamp
            adjusted_priority = priority - (wait_time * self.aging_rate)
            adjusted_heap.append((adjusted_priority, timestamp, counter, task))

        heapq.heapify(adjusted_heap)
        self.heap = adjusted_heap

        _, _, _, task = heapq.heappop(self.heap)
        return task

# 测试
aq = AgingPriorityQueue(aging_rate=0.1)

# 添加任务
aq.push("低优先级", priority=10)
time.sleep(1)  # 等待1秒

for i in range(10):
    aq.push(f"高优先级{i}", priority=1)

# 低优先级任务因为等待时间长,优先级提升
print(aq.pop())  # 可能输出"低优先级"
```

### 解决方案2:加权公平队列(WFQ)

```python
import heapq

class WeightedFairQueue:
    """加权公平队列"""

    def __init__(self):
        self.tasks = {}  # task_id -> {task, weight, executed_time}
        self.heap = []

    def add_task(self, task_id, task, weight=1):
        """添加任务"""
        self.tasks[task_id] = {
            'task': task,
            'weight': weight,
            'executed_time': 0
        }
        self._update_heap()

    def get_task(self):
        """获取下一个任务"""
        if not self.heap:
            return None

        # 按 权重/已执行时间 排序
        _, task_id = heapq.heappop(self.heap)
        task_info = self.tasks[task_id]

        # 更新执行时间
        task_info['executed_time'] += 1

        # 重新加入堆
        self._update_heap()

        return task_info['task']

    def _update_heap(self):
        """更新堆"""
        self.heap = []
        for task_id, info in self.tasks.items():
            # 优先级 = -权重/(已执行时间+1)
            priority = -info['weight'] / (info['executed_time'] + 1)
            heapq.heappush(self.heap, (priority, task_id))

# 测试
wfq = WeightedFairQueue()
wfq.add_task("vip", "VIP任务", weight=10)
wfq.add_task("normal", "普通任务", weight=1)

# VIP任务获得10倍的执行机会
for _ in range(20):
    task = wfq.get_task()
    print(task)
```

### 解决方案3:最大等待时间限制

```python
import heapq
import asyncio
from datetime import datetime, timedelta

class MaxWaitQueue:
    """最大等待时间队列"""

    def __init__(self, max_wait_seconds=60):
        self.heap = []
        self.max_wait = timedelta(seconds=max_wait_seconds)

    async def add_task(self, task, priority):
        """添加任务"""
        timestamp = datetime.now()
        heapq.heappush(self.heap, (priority, timestamp, task))

    async def get_task(self):
        """获取任务"""
        if not self.heap:
            return None

        now = datetime.now()

        # 检查是否有任务等待过久
        for i, (priority, timestamp, task) in enumerate(self.heap):
            wait_time = now - timestamp

            if wait_time > self.max_wait:
                # 强制执行等待过久的任务
                self.heap.pop(i)
                heapq.heapify(self.heap)
                return task

        # 正常按优先级执行
        _, _, task = heapq.heappop(self.heap)
        return task

# 测试
async def main():
    mwq = MaxWaitQueue(max_wait_seconds=5)

    # 添加低优先级任务
    await mwq.add_task("低优先级", priority=10)

    # 等待6秒
    await asyncio.sleep(6)

    # 添加高优先级任务
    await mwq.add_task("高优先级", priority=1)

    # 低优先级任务因为等待超过5秒,被强制执行
    task = await mwq.get_task()
    print(task)  # "低优先级"

asyncio.run(main())
```

---

## AI Agent应用场景

### 场景1:多Agent任务调度(LangChain模式)

根据2025-2026最新实践,LangChain社区总结了10种优先级队列模式:

```python
import heapq
import asyncio
from dataclasses import dataclass
from typing import List
from datetime import datetime

@dataclass
class AgentTask:
    task_id: str
    priority: int
    agent_type: str
    data: dict
    timestamp: datetime
    slo_deadline: float = None  # SLO截止时间

class MultiAgentScheduler:
    """多Agent调度器(SLO感知)"""

    def __init__(self):
        self.heap = []
        self.counter = 0

    async def add_task(self, task: AgentTask):
        """添加任务"""
        # 计算动态优先级
        priority = self._calculate_priority(task)
        heapq.heappush(self.heap, (priority, self.counter, task))
        self.counter += 1

    def _calculate_priority(self, task: AgentTask):
        """计算优先级(SLO感知)"""
        base_priority = task.priority

        if task.slo_deadline:
            # 考虑SLO截止时间
            now = datetime.now().timestamp()
            time_to_deadline = task.slo_deadline - now

            if time_to_deadline < 10:
                # 接近截止时间,提升优先级
                base_priority -= 5

        return base_priority

    async def get_task(self) -> AgentTask:
        """获取任务"""
        if not self.heap:
            return None

        _, _, task = heapq.heappop(self.heap)
        return task

# 使用
async def main():
    scheduler = MultiAgentScheduler()

    # 添加任务
    await scheduler.add_task(AgentTask(
        task_id="task1",
        priority=5,
        agent_type="search",
        data={"query": "搜索内容"},
        timestamp=datetime.now()
    ))

    await scheduler.add_task(AgentTask(
        task_id="task2",
        priority=1,
        agent_type="analyze",
        data={"content": "分析内容"},
        timestamp=datetime.now(),
        slo_deadline=datetime.now().timestamp() + 5  # 5秒内完成
    ))

    # 获取任务
    task = await scheduler.get_task()
    print(f"执行任务: {task.task_id}")

asyncio.run(main())
```

### 场景2:多租户公平调度

```python
import heapq
from collections import defaultdict

class MultiTenantScheduler:
    """多租户调度器"""

    def __init__(self):
        self.tenant_queues = defaultdict(list)
        self.tenant_usage = defaultdict(int)  # 租户使用量

    def add_task(self, tenant_id: str, task, priority: int):
        """添加任务"""
        heapq.heappush(self.tenant_queues[tenant_id], (priority, task))

    def get_task(self):
        """获取任务(公平调度)"""
        if not self.tenant_queues:
            return None

        # 选择使用量最少的租户
        tenant_id = min(
            self.tenant_queues.keys(),
            key=lambda t: self.tenant_usage[t]
        )

        queue = self.tenant_queues[tenant_id]
        if not queue:
            del self.tenant_queues[tenant_id]
            return self.get_task()

        _, task = heapq.heappop(queue)
        self.tenant_usage[tenant_id] += 1

        return tenant_id, task

# 使用
scheduler = MultiTenantScheduler()

# 租户A添加10个任务
for i in range(10):
    scheduler.add_task("tenant_a", f"任务A{i}", priority=1)

# 租户B添加2个任务
for i in range(2):
    scheduler.add_task("tenant_b", f"任务B{i}", priority=1)

# 公平调度:租户B的任务会优先执行
for _ in range(5):
    tenant_id, task = scheduler.get_task()
    print(f"{tenant_id}: {task}")
```

### 场景3:Deadline Lanes(截止时间通道)

```python
import heapq
import asyncio
from datetime import datetime, timedelta

class DeadlineLanes:
    """截止时间通道"""

    def __init__(self):
        self.urgent_lane = []    # 紧急通道(<10秒)
        self.normal_lane = []    # 普通通道(10-60秒)
        self.batch_lane = []     # 批处理通道(>60秒)

    async def add_task(self, task, deadline: datetime):
        """添加任务"""
        now = datetime.now()
        time_to_deadline = (deadline - now).total_seconds()

        if time_to_deadline < 10:
            heapq.heappush(self.urgent_lane, (deadline, task))
        elif time_to_deadline < 60:
            heapq.heappush(self.normal_lane, (deadline, task))
        else:
            heapq.heappush(self.batch_lane, (deadline, task))

    async def get_task(self):
        """获取任务"""
        # 优先处理紧急通道
        if self.urgent_lane:
            _, task = heapq.heappop(self.urgent_lane)
            return task

        # 其次处理普通通道
        if self.normal_lane:
            _, task = heapq.heappop(self.normal_lane)
            return task

        # 最后处理批处理通道
        if self.batch_lane:
            _, task = heapq.heappop(self.batch_lane)
            return task

        return None

# 使用
async def main():
    lanes = DeadlineLanes()

    now = datetime.now()

    # 添加不同截止时间的任务
    await lanes.add_task("紧急任务", now + timedelta(seconds=5))
    await lanes.add_task("普通任务", now + timedelta(seconds=30))
    await lanes.add_task("批处理任务", now + timedelta(seconds=120))

    # 紧急任务优先执行
    task = await lanes.get_task()
    print(task)  # "紧急任务"

asyncio.run(main())
```

---

## 性能对比

### 时间复杂度

| 操作 | FIFO队列 | 优先级队列 |
|------|----------|-----------|
| 入队 | O(1) | O(log n) |
| 出队 | O(1) | O(log n) |
| 查看 | O(1) | O(1) |
| 查找 | O(n) | O(n) |

### 基准测试

```python
import time
import heapq
from collections import deque

def benchmark_fifo(n=10000):
    """FIFO队列"""
    queue = deque()
    start = time.time()

    for i in range(n):
        queue.append(i)

    for i in range(n):
        queue.popleft()

    return time.time() - start

def benchmark_priority(n=10000):
    """优先级队列"""
    pq = []
    start = time.time()

    for i in range(n):
        heapq.heappush(pq, (i % 10, i))

    for i in range(n):
        heapq.heappop(pq)

    return time.time() - start

print(f"FIFO队列: {benchmark_fifo():.4f}秒")
print(f"优先级队列: {benchmark_priority():.4f}秒")
```

**结果**(10000个元素):
```
FIFO队列: 0.0012秒
优先级队列: 0.0089秒  # 约7倍慢
```

---

## 常见问题

### Q1:如何实现最大堆?

**A**:Python heapq是最小堆,取负数实现最大堆

```python
import heapq

# 最大堆:优先级越大越先出
max_heap = []
heapq.heappush(max_heap, (-10, "高优先级"))
heapq.heappush(max_heap, (-1, "低优先级"))

priority, task = heapq.heappop(max_heap)
print(f"优先级{-priority}: {task}")  # 优先级10: 高优先级
```

### Q2:如何处理相同优先级?

**A**:添加计数器保证FIFO

```python
import heapq

pq = []
counter = 0

def push(task, priority):
    global counter
    heapq.heappush(pq, (priority, counter, task))
    counter += 1

# 相同优先级按添加顺序
push("任务1", priority=1)
push("任务2", priority=1)
push("任务3", priority=1)

print(heapq.heappop(pq)[2])  # "任务1"
print(heapq.heappop(pq)[2])  # "任务2"
```

### Q3:如何动态调整优先级?

**A**:重新构建堆

```python
import heapq

class DynamicPriorityQueue:
    def __init__(self):
        self.heap = []
        self.tasks = {}  # task_id -> (priority, task)

    def add_task(self, task_id, task, priority):
        self.tasks[task_id] = (priority, task)
        self._rebuild_heap()

    def update_priority(self, task_id, new_priority):
        if task_id in self.tasks:
            _, task = self.tasks[task_id]
            self.tasks[task_id] = (new_priority, task)
            self._rebuild_heap()

    def _rebuild_heap(self):
        self.heap = [
            (priority, task_id, task)
            for task_id, (priority, task) in self.tasks.items()
        ]
        heapq.heapify(self.heap)

    def get_task(self):
        if not self.heap:
            return None
        _, task_id, task = heapq.heappop(self.heap)
        del self.tasks[task_id]
        return task
```

---

## 最佳实践

### 1.选择合适的优先级范围

```python
# 推荐:1-10的整数
class Priority:
    CRITICAL = 1
    HIGH = 3
    NORMAL = 5
    LOW = 7
    BATCH = 10
```

### 2.实现防饥饿机制

```python
# 必须:防止低优先级任务永远得不到执行
class AntiStarvationQueue:
    def __init__(self, max_wait_seconds=60):
        self.heap = []
        self.max_wait = max_wait_seconds

    # 实现优先级老化或最大等待时间
```

### 3.监控队列状态

```python
class MonitoredPriorityQueue:
    def __init__(self):
        self.heap = []
        self.metrics = {
            'total_tasks': 0,
            'by_priority': {}
        }

    def add_task(self, task, priority):
        heapq.heappush(self.heap, (priority, task))
        self.metrics['total_tasks'] += 1
        self.metrics['by_priority'][priority] = \
            self.metrics['by_priority'].get(priority, 0) + 1

    def get_metrics(self):
        return self.metrics
```

### 4.优雅降级

```python
async def process_with_fallback(pq):
    """优先级队列满时降级为FIFO"""
    if pq.qsize() > 10000:
        # 降级为FIFO
        return await fifo_queue.get()
    else:
        return await pq.get()
```

---

## 总结

### 核心要点

1. **按优先级出队**:不是FIFO
2. **堆实现**:O(log n)操作
3. **防饥饿**:必须实现老化机制
4. **AI Agent应用**:多Agent调度、SLO感知、多租户公平

### 选择指南

| 场景 | 推荐方案 |
|------|----------|
| 任务有明确优先级 | 优先级队列 |
| 需要防饥饿 | 优先级老化 |
| 多租户系统 | 加权公平队列 |
| SLO要求 | Deadline Lanes |

### 记忆口诀

**"优先级高先执行,防饥饿要老化,多租户要公平,SLO要通道"**

---

**关键洞察**:优先级队列是AI Agent任务调度的核心工具。2025-2026的最新实践表明,单纯的优先级队列不够,必须结合SLO感知、多租户公平、防饥饿机制才能满足生产环境需求。
