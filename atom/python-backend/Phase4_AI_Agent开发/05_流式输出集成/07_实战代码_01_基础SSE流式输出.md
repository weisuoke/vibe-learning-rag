# 实战代码01: 基础SSE流式输出

> 从零手写 SSE 服务器,深入理解流式输出原理

---

## 概述

本节通过手写 SSE 服务器,从最基础的原理开始,逐步实现完整的流式输出功能。

**学习目标:**
- 理解 SSE 协议的底层实现
- 手写纯 Python SSE 服务器
- 使用 FastAPI 实现 SSE 端点
- 前端接收和显示流式数据

---

## 1. 纯 Python 实现 SSE 服务器

### 1.1 最简单的 SSE 服务器

```python
"""
最简单的 SSE 服务器
文件: examples/streaming/01_basic_sse.py
"""

from http.server import BaseHTTPRequestHandler, HTTPServer
import time

class SSEHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        """处理 GET 请求"""
        if self.path == '/stream':
            self.send_sse_stream()
        elif self.path == '/':
            self.send_html_page()
        else:
            self.send_response(404)
            self.end_headers()

    def send_sse_stream(self):
        """发送 SSE 流式响应"""
        # 1. 发送 SSE 响应头
        self.send_response(200)
        self.send_header('Content-Type', 'text/event-stream')
        self.send_header('Cache-Control', 'no-cache')
        self.send_header('Connection', 'keep-alive')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()

        # 2. 发送 SSE 消息
        try:
            for i in range(10):
                # 构造 SSE 消息格式: data: 内容\n\n
                message = f"data: Message {i}\n\n"
                self.wfile.write(message.encode('utf-8'))
                self.wfile.flush()  # 立即发送,不缓存
                time.sleep(1)  # 模拟延迟

            # 3. 发送完成事件
            self.wfile.write(b"event: done\ndata: Stream completed\n\n")
            self.wfile.flush()

        except BrokenPipeError:
            print("Client disconnected")

    def send_html_page(self):
        """发送测试页面"""
        html = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>SSE Test</title>
        </head>
        <body>
            <h1>SSE Stream Test</h1>
            <div id="messages"></div>
            <script>
                const eventSource = new EventSource('/stream');
                const messagesDiv = document.getElementById('messages');

                eventSource.onmessage = (event) => {
                    const p = document.createElement('p');
                    p.textContent = event.data;
                    messagesDiv.appendChild(p);
                };

                eventSource.addEventListener('done', (event) => {
                    const p = document.createElement('p');
                    p.textContent = 'Done: ' + event.data;
                    p.style.color = 'green';
                    messagesDiv.appendChild(p);
                    eventSource.close();
                });

                eventSource.onerror = () => {
                    const p = document.createElement('p');
                    p.textContent = 'Error occurred';
                    p.style.color = 'red';
                    messagesDiv.appendChild(p);
                };
            </script>
        </body>
        </html>
        """
        self.send_response(200)
        self.send_header('Content-Type', 'text/html')
        self.end_headers()
        self.wfile.write(html.encode('utf-8'))

if __name__ == '__main__':
    server = HTTPServer(('localhost', 8000), SSEHandler)
    print("SSE Server running on http://localhost:8000")
    print("Open http://localhost:8000 in your browser")
    server.serve_forever()
```

**运行:**

```bash
python examples/streaming/01_basic_sse.py
# 打开浏览器访问 http://localhost:8000
```

**输出:**
```
Message 0
Message 1
Message 2
...
Done: Stream completed
```

---

## 2. FastAPI 实现 SSE 端点

### 2.1 基础 FastAPI SSE

```python
"""
FastAPI 基础 SSE 实现
文件: examples/streaming/02_fastapi_basic.py
"""

from fastapi import FastAPI
from fastapi.responses import StreamingResponse, HTMLResponse
import asyncio

app = FastAPI()

@app.get("/stream")
async def stream_endpoint():
    """基础 SSE 流式端点"""
    async def generate():
        for i in range(10):
            yield f"data: Message {i}\n\n"
            await asyncio.sleep(1)
        yield f"event: done\ndata: Completed\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )

@app.get("/", response_class=HTMLResponse)
async def index():
    """测试页面"""
    return """
    <!DOCTYPE html>
    <html>
    <head>
        <title>FastAPI SSE Test</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            #messages { border: 1px solid #ccc; padding: 10px; min-height: 200px; }
            .message { padding: 5px; margin: 5px 0; background: #f0f0f0; }
            .done { color: green; font-weight: bold; }
        </style>
    </head>
    <body>
        <h1>FastAPI SSE Stream Test</h1>
        <button onclick="startStream()">Start Stream</button>
        <button onclick="stopStream()">Stop Stream</button>
        <div id="messages"></div>

        <script>
            let eventSource = null;

            function startStream() {
                if (eventSource) {
                    eventSource.close();
                }

                const messagesDiv = document.getElementById('messages');
                messagesDiv.innerHTML = '';

                eventSource = new EventSource('/stream');

                eventSource.onmessage = (event) => {
                    const div = document.createElement('div');
                    div.className = 'message';
                    div.textContent = event.data;
                    messagesDiv.appendChild(div);
                };

                eventSource.addEventListener('done', (event) => {
                    const div = document.createElement('div');
                    div.className = 'message done';
                    div.textContent = 'Done: ' + event.data;
                    messagesDiv.appendChild(div);
                    eventSource.close();
                });

                eventSource.onerror = () => {
                    const div = document.createElement('div');
                    div.className = 'message';
                    div.style.color = 'red';
                    div.textContent = 'Error occurred';
                    messagesDiv.appendChild(div);
                };
            }

            function stopStream() {
                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }
            }
        </script>
    </body>
    </html>
    """

# 运行: uvicorn examples.streaming.02_fastapi_basic:app --reload
```

### 2.2 带参数的 SSE 端点

```python
"""
带参数的 SSE 端点
文件: examples/streaming/03_fastapi_params.py
"""

from fastapi import FastAPI, Query
from fastapi.responses import StreamingResponse
import asyncio
import json

app = FastAPI()

@app.get("/stream")
async def stream_with_params(
    count: int = Query(10, ge=1, le=100),
    delay: float = Query(1.0, ge=0.1, le=5.0),
    message: str = Query("Message")
):
    """带参数的 SSE 端点"""
    async def generate():
        # 发送配置信息
        config = {
            "count": count,
            "delay": delay,
            "message": message
        }
        yield f"event: config\ndata: {json.dumps(config)}\n\n"

        # 流式发送消息
        for i in range(count):
            data = {
                "index": i,
                "message": f"{message} {i}",
                "timestamp": asyncio.get_event_loop().time()
            }
            yield f"data: {json.dumps(data)}\n\n"
            await asyncio.sleep(delay)

        # 发送完成事件
        yield f"event: done\ndata: {json.dumps({'total': count})}\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )

# 测试:
# curl "http://localhost:8000/stream?count=5&delay=0.5&message=Hello"
```

---

## 3. 完整的 SSE 实现

### 3.1 生产级 SSE 端点

```python
"""
生产级 SSE 实现
文件: examples/streaming/04_production_sse.py
"""

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
import asyncio
import json
import time
import uuid

app = FastAPI()

# 配置 CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# 存储活跃的连接
active_connections = {}

@app.get("/stream")
async def production_stream(
    request: Request,
    message: str = "Hello",
    enable_heartbeat: bool = True
):
    """生产级 SSE 端点"""
    # 生成连接 ID
    connection_id = str(uuid.uuid4())

    # 检查 Last-Event-ID (断点续传)
    last_event_id = request.headers.get('Last-Event-ID', '0')
    start_id = int(last_event_id) + 1

    async def generate():
        try:
            # 记录连接
            active_connections[connection_id] = {
                "start_time": time.time(),
                "last_event_id": start_id - 1
            }

            # 1. 设置重连间隔
            yield "retry: 3000\n\n"

            # 2. 发送初始化事件
            init_data = {
                "connection_id": connection_id,
                "start_id": start_id,
                "message": message
            }
            yield f"event: init\ndata: {json.dumps(init_data)}\n\n"

            # 3. 流式发送数据
            last_heartbeat = time.time()
            heartbeat_interval = 30  # 30秒心跳

            for i in range(start_id, start_id + 20):
                # 检查客户端是否断开
                if await request.is_disconnected():
                    print(f"Client {connection_id} disconnected")
                    break

                # 发送数据
                data = {
                    "id": i,
                    "message": f"{message} {i}",
                    "timestamp": time.time()
                }
                yield f"id: {i}\ndata: {json.dumps(data)}\n\n"

                # 更新最后事件 ID
                active_connections[connection_id]["last_event_id"] = i

                # 发送心跳
                if enable_heartbeat and time.time() - last_heartbeat > heartbeat_interval:
                    yield ": heartbeat\n\n"
                    last_heartbeat = time.time()

                await asyncio.sleep(0.5)

            # 4. 发送完成事件
            done_data = {
                "connection_id": connection_id,
                "total_events": 20,
                "duration": time.time() - active_connections[connection_id]["start_time"]
            }
            yield f"event: done\ndata: {json.dumps(done_data)}\n\n"

        except Exception as e:
            # 发送错误事件
            error_data = {
                "connection_id": connection_id,
                "error": str(e)
            }
            yield f"event: error\ndata: {json.dumps(error_data)}\n\n"

        finally:
            # 清理连接
            if connection_id in active_connections:
                del active_connections[connection_id]
            print(f"Connection {connection_id} closed")

    return StreamingResponse(
        generate(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",
            "Connection": "keep-alive"
        }
    )

@app.get("/connections")
async def get_connections():
    """获取活跃连接数"""
    return {
        "active_connections": len(active_connections),
        "connections": [
            {
                "id": conn_id,
                "duration": time.time() - conn["start_time"],
                "last_event_id": conn["last_event_id"]
            }
            for conn_id, conn in active_connections.items()
        ]
    }

# 运行: uvicorn examples.streaming.04_production_sse:app --reload
```

---

## 4. 前端完整示例

### 4.1 React 实现

```javascript
/**
 * React SSE 客户端
 * 文件: examples/streaming/frontend/ReactSSE.jsx
 */

import React, { useState, useEffect, useRef } from 'react';

function StreamingClient() {
    const [messages, setMessages] = useState([]);
    const [isStreaming, setIsStreaming] = useState(false);
    const [error, setError] = useState(null);
    const [config, setConfig] = useState(null);
    const eventSourceRef = useRef(null);

    const startStream = () => {
        // 关闭现有连接
        if (eventSourceRef.current) {
            eventSourceRef.current.close();
        }

        // 清空消息
        setMessages([]);
        setError(null);
        setIsStreaming(true);

        // 创建新连接
        const eventSource = new EventSource(
            'http://localhost:8000/stream?message=Hello&enable_heartbeat=true'
        );
        eventSourceRef.current = eventSource;

        // 监听配置事件
        eventSource.addEventListener('config', (event) => {
            const data = JSON.parse(event.data);
            setConfig(data);
        });

        // 监听初始化事件
        eventSource.addEventListener('init', (event) => {
            const data = JSON.parse(event.data);
            console.log('Connected:', data);
        });

        // 监听消息
        eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);
            setMessages(prev => [...prev, data]);
        };

        // 监听完成事件
        eventSource.addEventListener('done', (event) => {
            const data = JSON.parse(event.data);
            console.log('Done:', data);
            setIsStreaming(false);
            eventSource.close();
        });

        // 监听错误
        eventSource.onerror = (error) => {
            console.error('Error:', error);
            setError('Connection error');
            setIsStreaming(false);
            eventSource.close();
        };
    };

    const stopStream = () => {
        if (eventSourceRef.current) {
            eventSourceRef.current.close();
            setIsStreaming(false);
        }
    };

    // 组件卸载时关闭连接
    useEffect(() => {
        return () => {
            if (eventSourceRef.current) {
                eventSourceRef.current.close();
            }
        };
    }, []);

    return (
        <div style={{ padding: '20px' }}>
            <h1>SSE Streaming Client</h1>

            <div style={{ marginBottom: '20px' }}>
                <button onClick={startStream} disabled={isStreaming}>
                    Start Stream
                </button>
                <button onClick={stopStream} disabled={!isStreaming} style={{ marginLeft: '10px' }}>
                    Stop Stream
                </button>
            </div>

            {config && (
                <div style={{ marginBottom: '20px', padding: '10px', background: '#f0f0f0' }}>
                    <strong>Config:</strong> {JSON.stringify(config)}
                </div>
            )}

            {error && (
                <div style={{ color: 'red', marginBottom: '20px' }}>
                    Error: {error}
                </div>
            )}

            <div style={{ border: '1px solid #ccc', padding: '10px', minHeight: '300px' }}>
                <h3>Messages ({messages.length}):</h3>
                {messages.map((msg, index) => (
                    <div key={index} style={{ padding: '5px', margin: '5px 0', background: '#f9f9f9' }}>
                        <strong>#{msg.id}:</strong> {msg.message}
                        <span style={{ float: 'right', fontSize: '0.8em', color: '#666' }}>
                            {new Date(msg.timestamp * 1000).toLocaleTimeString()}
                        </span>
                    </div>
                ))}
            </div>
        </div>
    );
}

export default StreamingClient;
```

### 4.2 Vue 实现

```vue
<!--
Vue SSE 客户端
文件: examples/streaming/frontend/VueSSE.vue
-->

<template>
  <div class="streaming-client">
    <h1>SSE Streaming Client</h1>

    <div class="controls">
      <button @click="startStream" :disabled="isStreaming">
        Start Stream
      </button>
      <button @click="stopStream" :disabled="!isStreaming">
        Stop Stream
      </button>
    </div>

    <div v-if="config" class="config">
      <strong>Config:</strong> {{ config }}
    </div>

    <div v-if="error" class="error">
      Error: {{ error }}
    </div>

    <div class="messages">
      <h3>Messages ({{ messages.length }}):</h3>
      <div v-for="(msg, index) in messages" :key="index" class="message">
        <strong>#{{ msg.id }}:</strong> {{ msg.message }}
        <span class="timestamp">
          {{ formatTime(msg.timestamp) }}
        </span>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onUnmounted } from 'vue';

const messages = ref([]);
const isStreaming = ref(false);
const error = ref(null);
const config = ref(null);
let eventSource = null;

const startStream = () => {
  // 关闭现有连接
  if (eventSource) {
    eventSource.close();
  }

  // 清空状态
  messages.value = [];
  error.value = null;
  isStreaming.value = true;

  // 创建新连接
  eventSource = new EventSource(
    'http://localhost:8000/stream?message=Hello&enable_heartbeat=true'
  );

  // 监听配置事件
  eventSource.addEventListener('config', (event) => {
    config.value = JSON.parse(event.data);
  });

  // 监听初始化事件
  eventSource.addEventListener('init', (event) => {
    const data = JSON.parse(event.data);
    console.log('Connected:', data);
  });

  // 监听消息
  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    messages.value.push(data);
  };

  // 监听完成事件
  eventSource.addEventListener('done', (event) => {
    const data = JSON.parse(event.data);
    console.log('Done:', data);
    isStreaming.value = false;
    eventSource.close();
  });

  // 监听错误
  eventSource.onerror = () => {
    error.value = 'Connection error';
    isStreaming.value = false;
    eventSource.close();
  };
};

const stopStream = () => {
  if (eventSource) {
    eventSource.close();
    isStreaming.value = false;
  }
};

const formatTime = (timestamp) => {
  return new Date(timestamp * 1000).toLocaleTimeString();
};

// 组件卸载时关闭连接
onUnmounted(() => {
  if (eventSource) {
    eventSource.close();
  }
});
</script>

<style scoped>
.streaming-client {
  padding: 20px;
}

.controls {
  margin-bottom: 20px;
}

.controls button {
  margin-right: 10px;
  padding: 10px 20px;
}

.config {
  margin-bottom: 20px;
  padding: 10px;
  background: #f0f0f0;
}

.error {
  color: red;
  margin-bottom: 20px;
}

.messages {
  border: 1px solid #ccc;
  padding: 10px;
  min-height: 300px;
}

.message {
  padding: 5px;
  margin: 5px 0;
  background: #f9f9f9;
}

.timestamp {
  float: right;
  font-size: 0.8em;
  color: #666;
}
</style>
```

---

## 5. 测试和调试

### 5.1 使用 curl 测试

```bash
# 基础测试
curl -N http://localhost:8000/stream

# 带参数测试
curl -N "http://localhost:8000/stream?count=5&delay=0.5&message=Test"

# 测试断点续传
curl -N -H "Last-Event-ID: 5" http://localhost:8000/stream
```

### 5.2 使用 Python 测试

```python
"""
Python SSE 客户端测试
文件: examples/streaming/test_sse_client.py
"""

import requests

def test_sse_stream():
    """测试 SSE 流式输出"""
    url = "http://localhost:8000/stream"

    with requests.get(url, stream=True) as response:
        print(f"Status: {response.status_code}")
        print(f"Headers: {response.headers}")
        print("\nStream content:")

        for line in response.iter_lines():
            if line:
                print(line.decode('utf-8'))

if __name__ == '__main__':
    test_sse_stream()
```

### 5.3 性能测试

```python
"""
SSE 性能测试
文件: examples/streaming/benchmark_sse.py
"""

import asyncio
import aiohttp
import time

async def test_concurrent_streams(num_clients=10):
    """测试并发流式连接"""
    url = "http://localhost:8000/stream?count=10&delay=0.1"

    async def single_client(client_id):
        start_time = time.time()
        message_count = 0

        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                async for line in response.content:
                    if line.startswith(b'data:'):
                        message_count += 1

        duration = time.time() - start_time
        print(f"Client {client_id}: {message_count} messages in {duration:.2f}s")

    # 并发运行多个客户端
    tasks = [single_client(i) for i in range(num_clients)]
    await asyncio.gather(*tasks)

if __name__ == '__main__':
    asyncio.run(test_concurrent_streams(10))
```

---

## 6. 常见问题和解决方案

### 问题1: 响应被缓冲

**问题:** 消息不是实时显示,而是批量显示

**解决方案:**

```python
# 服务端: 禁用缓冲
return StreamingResponse(
    generate(),
    media_type="text/event-stream",
    headers={
        "X-Accel-Buffering": "no",  # Nginx
        "Cache-Control": "no-cache"
    }
)
```

```nginx
# Nginx 配置
location /stream {
    proxy_pass http://backend;
    proxy_buffering off;
    proxy_cache off;
}
```

### 问题2: 连接被关闭

**问题:** 连接在空闲时被关闭

**解决方案:** 添加心跳

```python
async def generate():
    last_heartbeat = time.time()

    for i in range(100):
        yield f"data: {i}\n\n"

        # 每30秒发送心跳
        if time.time() - last_heartbeat > 30:
            yield ": heartbeat\n\n"
            last_heartbeat = time.time()
```

### 问题3: 浏览器连接数限制

**问题:** 同一域名最多6个 SSE 连接

**解决方案:**
1. 使用不同的子域名
2. 复用同一个 SSE 连接
3. 使用 HTTP/2

---

## 总结

**本节要点:**

1. **纯 Python 实现**: 理解 SSE 协议的底层原理
2. **FastAPI 实现**: 使用 StreamingResponse 简化开发
3. **生产级实现**: 心跳、断点续传、错误处理
4. **前端集成**: React 和 Vue 的完整示例
5. **测试调试**: curl、Python 客户端、性能测试

**关键代码:**
- SSE 响应头: `Content-Type: text/event-stream`
- SSE 消息格式: `data: 内容\n\n`
- 心跳: `: heartbeat\n\n`
- 断点续传: `Last-Event-ID` 请求头

**下一步:**

掌握了基础 SSE 实现后,可以学习:
- LangChain Token 流式输出
- LangChain Chunk 流式输出
- RAG 流式问答

---

**记住:** 手写 SSE 服务器是理解流式输出原理的最佳方式,掌握了原理才能更好地使用 FastAPI 和 LangChain。
