# JWT认证 - 核心概念02：签名与验证机制

## 概述

JWT 的安全性核心在于签名机制。签名确保 Token 未被篡改，是 JWT 可信的基础。本章深入讲解签名算法、验证流程和密钥管理。

---

## 签名的作用

### 为什么需要签名？

**问题：** JWT 的 Header 和 Payload 是 Base64URL 编码（不是加密），任何人都能解码查看和修改。

```python
import base64
import json

# 攻击者可以轻易解码和修改 Payload
payload_encoded = "eyJ1c2VyX2lkIjoxMjMsInJvbGUiOiJ1c2VyIn0"

# 解码
payload_json = base64.urlsafe_b64decode(payload_encoded + "==").decode()
payload = json.loads(payload_json)
print(payload)  # {'user_id': 123, 'role': 'user'}

# 修改（提升权限）
payload['role'] = 'admin'  # ❌ 攻击者尝试提升权限

# 重新编码
modified_payload = base64.urlsafe_b64encode(
    json.dumps(payload).encode()
).decode().rstrip('=')
```

**解决：** 签名确保任何修改都会被检测到。

```python
# 服务器验证签名
# 如果 Payload 被修改，签名验证会失败
# 攻击者无法伪造签名（不知道密钥）
```

### 签名的三个保证

1. **完整性**：Token 未被修改
2. **真实性**：Token 由可信方签发
3. **不可否认性**：签发方无法否认签发过这个 Token

---

## HMAC-SHA256 签名算法

### 什么是 HMAC？

**HMAC（Hash-based Message Authentication Code）** = 基于哈希的消息认证码

**组成：**
- Hash 函数：SHA256、SHA384、SHA512
- 密钥：只有签发方和验证方知道

### HMAC-SHA256 工作原理

```
HMAC-SHA256(message, key) = SHA256((key ⊕ opad) || SHA256((key ⊕ ipad) || message))

其中：
- opad = 外部填充（0x5c 重复）
- ipad = 内部填充（0x36 重复）
- ⊕ = 异或运算
- || = 连接
```

**简化理解：**
```python
# 简化版（实际实现更复杂）
def hmac_sha256_simplified(message, key):
    # 1. 内部哈希
    inner = sha256(key + message)

    # 2. 外部哈希
    outer = sha256(key + inner)

    return outer
```

### 手写 HMAC-SHA256 实现

```python
"""
手写 HMAC-SHA256 实现
演示：从零实现 HMAC 签名算法
"""

import hashlib


class HMAC:
    """简化的 HMAC 实现"""

    def __init__(self, key: bytes, hash_func=hashlib.sha256):
        self.hash_func = hash_func
        self.block_size = hash_func().block_size  # SHA256 的块大小是 64 字节

        # 处理密钥长度
        if len(key) > self.block_size:
            # 密钥太长，先哈希
            key = hash_func(key).digest()

        if len(key) < self.block_size:
            # 密钥太短，填充到块大小
            key = key + b'\x00' * (self.block_size - len(key))

        self.key = key

    def sign(self, message: bytes) -> bytes:
        """生成 HMAC 签名"""
        # 1. 计算内部填充密钥（key ⊕ ipad）
        ipad = bytes([0x36] * self.block_size)
        inner_key = bytes([k ^ i for k, i in zip(self.key, ipad)])

        # 2. 内部哈希：H((key ⊕ ipad) || message)
        inner_hash = self.hash_func(inner_key + message).digest()

        # 3. 计算外部填充密钥（key ⊕ opad）
        opad = bytes([0x5c] * self.block_size)
        outer_key = bytes([k ^ o for k, o in zip(self.key, opad)])

        # 4. 外部哈希：H((key ⊕ opad) || inner_hash)
        outer_hash = self.hash_func(outer_key + inner_hash).digest()

        return outer_hash

    def verify(self, message: bytes, signature: bytes) -> bool:
        """验证 HMAC 签名"""
        expected_signature = self.sign(message)

        # 使用恒定时间比较，防止时序攻击
        return self._constant_time_compare(signature, expected_signature)

    def _constant_time_compare(self, a: bytes, b: bytes) -> bool:
        """恒定时间比较，防止时序攻击"""
        if len(a) != len(b):
            return False

        result = 0
        for x, y in zip(a, b):
            result |= x ^ y

        return result == 0


# ===== 使用示例 =====

# 1. 创建 HMAC 实例
key = b"your-secret-key"
hmac = HMAC(key)

# 2. 生成签名
message = b"Header.Payload"
signature = hmac.sign(message)
print(f"签名: {signature.hex()}")

# 3. 验证签名
is_valid = hmac.verify(message, signature)
print(f"签名有效: {is_valid}")  # True

# 4. 测试篡改
tampered_message = b"Header.TamperedPayload"
is_valid = hmac.verify(tampered_message, signature)
print(f"篡改后签名有效: {is_valid}")  # False


# ===== 与标准库对比 =====
import hmac as stdlib_hmac

# 使用标准库
stdlib_signature = stdlib_hmac.new(key, message, hashlib.sha256).digest()

# 对比结果
print(f"\n手写实现: {signature.hex()}")
print(f"标准库实现: {stdlib_signature.hex()}")
print(f"结果相同: {signature == stdlib_signature}")
```

**运行输出：**
```
签名: 5a3f2c1b8e9d7a6f4c2e1b9a8d7c6f5e4d3c2b1a9f8e7d6c5b4a3f2e1d0c9b8a
签名有效: True
篡改后签名有效: False

手写实现: 5a3f2c1b8e9d7a6f4c2e1b9a8d7c6f5e4d3c2b1a9f8e7d6c5b4a3f2e1d0c9b8a
标准库实现: 5a3f2c1b8e9d7a6f4c2e1b9a8d7c6f5e4d3c2b1a9f8e7d6c5b4a3f2e1d0c9b8a
结果相同: True
```

---

## JWT 签名流程

### 完整的签名流程

```python
"""
JWT 签名完整流程
演示：从 Header + Payload 生成签名
"""

import json
import base64
import hmac
import hashlib


def create_jwt_signature(header: dict, payload: dict, secret_key: str) -> str:
    """
    创建 JWT 签名

    Args:
        header: JWT Header
        payload: JWT Payload
        secret_key: 密钥

    Returns:
        完整的 JWT Token
    """
    # 1. 编码 Header
    header_json = json.dumps(header, separators=(',', ':'))
    header_encoded = base64.urlsafe_b64encode(
        header_json.encode()
    ).decode().rstrip('=')

    # 2. 编码 Payload
    payload_json = json.dumps(payload, separators=(',', ':'))
    payload_encoded = base64.urlsafe_b64encode(
        payload_json.encode()
    ).decode().rstrip('=')

    # 3. 组合消息
    message = f"{header_encoded}.{payload_encoded}"

    # 4. 生成签名
    signature = hmac.new(
        secret_key.encode(),
        message.encode(),
        hashlib.sha256
    ).digest()

    # 5. 编码签名
    signature_encoded = base64.urlsafe_b64encode(signature).decode().rstrip('=')

    # 6. 组合成完整的 JWT
    jwt_token = f"{message}.{signature_encoded}"

    return jwt_token


# ===== 使用示例 =====

header = {"alg": "HS256", "typ": "JWT"}
payload = {"user_id": 123, "username": "alice", "exp": 1709280000}
secret_key = "your-secret-key"

token = create_jwt_signature(header, payload, secret_key)
print(f"JWT Token:\n{token}")
```

### 签名验证流程

```python
def verify_jwt_signature(token: str, secret_key: str) -> bool:
    """
    验证 JWT 签名

    Args:
        token: JWT Token
        secret_key: 密钥

    Returns:
        签名是否有效
    """
    # 1. 分割 Token
    parts = token.split('.')
    if len(parts) != 3:
        return False

    header_encoded, payload_encoded, signature_encoded = parts

    # 2. 重新计算签名
    message = f"{header_encoded}.{payload_encoded}"
    expected_signature = hmac.new(
        secret_key.encode(),
        message.encode(),
        hashlib.sha256
    ).digest()
    expected_signature_encoded = base64.urlsafe_b64encode(
        expected_signature
    ).decode().rstrip('=')

    # 3. 对比签名（恒定时间比较）
    return hmac.compare_digest(signature_encoded, expected_signature_encoded)


# ===== 测试 =====

# 验证原始 Token
is_valid = verify_jwt_signature(token, secret_key)
print(f"\n原始 Token 有效: {is_valid}")  # True

# 测试篡改 Payload
parts = token.split('.')
tampered_payload = parts[1] + "x"  # 修改 Payload
tampered_token = f"{parts[0]}.{tampered_payload}.{parts[2]}"

is_valid = verify_jwt_signature(tampered_token, secret_key)
print(f"篡改 Token 有效: {is_valid}")  # False

# 测试错误密钥
is_valid = verify_jwt_signature(token, "wrong-key")
print(f"错误密钥验证: {is_valid}")  # False
```

---

## 时序攻击与防御

### 什么是时序攻击？

**时序攻击（Timing Attack）**：通过测量操作时间来推断秘密信息。

**示例：不安全的签名比较**

```python
def unsafe_compare(a: str, b: str) -> bool:
    """不安全的比较（容易受时序攻击）"""
    if len(a) != len(b):
        return False

    for i in range(len(a)):
        if a[i] != b[i]:
            return False  # ❌ 一旦发现不同就立即返回

    return True


# 攻击者可以通过测量时间来逐字节猜测签名
# 如果第一个字节错误，返回很快
# 如果第一个字节正确，会继续比较第二个字节，返回稍慢
```

**攻击过程：**
```python
import time

def timing_attack_demo():
    """演示时序攻击"""
    correct_signature = "abc123xyz"

    # 攻击者尝试不同的第一个字节
    for char in "abcdefghijklmnopqrstuvwxyz":
        guess = char + "0" * 8

        start = time.perf_counter()
        result = unsafe_compare(guess, correct_signature)
        elapsed = time.perf_counter() - start

        print(f"尝试 '{char}': {elapsed:.9f}秒")

        # 如果时间明显更长，说明第一个字节正确
        # 然后继续猜测第二个字节...
```

### 防御：恒定时间比较

```python
def constant_time_compare(a: str, b: str) -> bool:
    """恒定时间比较（防止时序攻击）"""
    if len(a) != len(b):
        return False

    result = 0
    for x, y in zip(a, b):
        result |= ord(x) ^ ord(y)  # ✅ 总是比较所有字节

    return result == 0


# 使用标准库（推荐）
import hmac

def safe_compare(a: str, b: str) -> bool:
    """使用标准库的恒定时间比较"""
    return hmac.compare_digest(a, b)
```

**关键点：**
- 总是比较所有字节，不提前返回
- 使用位运算累积差异
- 最后一次性判断结果

---

## 对称加密 vs 非对称加密

### HS256（对称加密）

**特点：**
- 签名和验证使用同一个密钥
- 速度快
- 密钥必须保密

```python
# HS256 签名
secret_key = "your-secret-key"

# 签名
signature = hmac.new(
    secret_key.encode(),
    message.encode(),
    hashlib.sha256
).digest()

# 验证（使用同一个密钥）
expected_signature = hmac.new(
    secret_key.encode(),
    message.encode(),
    hashlib.sha256
).digest()

is_valid = hmac.compare_digest(signature, expected_signature)
```

**适用场景：**
- 单体应用
- 签名和验证在同一个服务
- 密钥可以安全存储

### RS256（非对称加密）

**特点：**
- 私钥签名，公钥验证
- 速度慢（比 HS256 慢 10-100 倍）
- 公钥可以公开分发

```python
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.backends import default_backend

# 1. 生成密钥对
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)
public_key = private_key.public_key()

# 2. 签名（使用私钥）
message = b"Header.Payload"
signature = private_key.sign(
    message,
    padding.PKCS1v15(),
    hashes.SHA256()
)

# 3. 验证（使用公钥）
try:
    public_key.verify(
        signature,
        message,
        padding.PKCS1v15(),
        hashes.SHA256()
    )
    print("签名有效")
except Exception:
    print("签名无效")
```

**适用场景：**
- 微服务架构
- 多个服务需要验证 Token
- 公钥可以分发给所有服务

### 对比总结

| 特性 | HS256 | RS256 |
|------|-------|-------|
| 密钥类型 | 对称（同一个密钥） | 非对称（私钥 + 公钥） |
| 签名速度 | 快 | 慢（10-100倍） |
| 验证速度 | 快 | 慢 |
| 密钥分发 | 困难（密钥必须保密） | 简单（公钥可以公开） |
| 适用场景 | 单体应用 | 微服务架构 |
| 推荐度 | ✅ 大多数场景 | ⚠️ 特定场景 |

---

## 密钥管理

### 密钥生成

```python
import secrets

# ===== 方法1：使用 secrets 模块（推荐）=====
secret_key = secrets.token_urlsafe(32)  # 生成 32 字节的随机密钥
print(f"密钥: {secret_key}")

# ===== 方法2：使用 os.urandom =====
import os
import base64

random_bytes = os.urandom(32)
secret_key = base64.urlsafe_b64encode(random_bytes).decode()
print(f"密钥: {secret_key}")

# ===== 方法3：使用 uuid（不推荐，熵不够）=====
import uuid

secret_key = str(uuid.uuid4())  # ❌ 不够随机
```

**推荐：**
- 使用 `secrets.token_urlsafe(32)` 生成密钥
- 至少 32 字节（256 位）
- 不要使用可预测的字符串（如 "secret"、"password"）

### 密钥存储

```python
# ❌ 错误：硬编码
SECRET_KEY = "my-secret-key"

# ❌ 错误：提交到 Git
# config.py
SECRET_KEY = "abc123..."

# ✅ 正确：环境变量
import os

SECRET_KEY = os.getenv("SECRET_KEY")
if not SECRET_KEY:
    raise ValueError("SECRET_KEY 环境变量未设置")

# ✅ 更好：密钥管理服务
# AWS KMS, HashiCorp Vault, Google Secret Manager
from google.cloud import secretmanager

client = secretmanager.SecretManagerServiceClient()
name = "projects/my-project/secrets/jwt-secret/versions/latest"
response = client.access_secret_version(request={"name": name})
SECRET_KEY = response.payload.data.decode("UTF-8")
```

### 密钥轮换

```python
"""
密钥轮换策略
演示：支持多个密钥，逐步淘汰旧密钥
"""

from typing import List
from datetime import datetime


class KeyManager:
    """密钥管理器"""

    def __init__(self):
        self.keys = []  # [(key_id, key, created_at), ...]

    def add_key(self, key_id: str, key: str):
        """添加新密钥"""
        self.keys.append((key_id, key, datetime.utcnow()))

    def get_current_key(self) -> tuple:
        """获取当前密钥（最新的）"""
        if not self.keys:
            raise ValueError("没有可用的密钥")
        return self.keys[-1]

    def sign(self, message: str) -> tuple:
        """使用当前密钥签名"""
        key_id, key, _ = self.get_current_key()

        signature = hmac.new(
            key.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()

        return key_id, signature

    def verify(self, message: str, key_id: str, signature: str) -> bool:
        """使用指定密钥验证"""
        # 查找密钥
        for kid, key, _ in self.keys:
            if kid == key_id:
                expected_signature = hmac.new(
                    key.encode(),
                    message.encode(),
                    hashlib.sha256
                ).hexdigest()
                return hmac.compare_digest(signature, expected_signature)

        return False


# ===== 使用示例 =====

key_manager = KeyManager()

# 1. 初始密钥
key_manager.add_key("key-2024-01", "old-secret-key")

# 2. 生成 Token（使用旧密钥）
message = "Header.Payload"
key_id, signature = key_manager.sign(message)
print(f"使用密钥 {key_id} 签名")

# 3. 添加新密钥（轮换）
key_manager.add_key("key-2024-02", "new-secret-key")

# 4. 新 Token 使用新密钥
new_key_id, new_signature = key_manager.sign(message)
print(f"使用密钥 {new_key_id} 签名")

# 5. 旧 Token 仍然可以验证
is_valid = key_manager.verify(message, key_id, signature)
print(f"旧 Token 有效: {is_valid}")  # True

# 6. 新 Token 也可以验证
is_valid = key_manager.verify(message, new_key_id, new_signature)
print(f"新 Token 有效: {is_valid}")  # True
```

**轮换策略：**
1. 添加新密钥
2. 新 Token 使用新密钥
3. 旧 Token 仍然可以验证（过渡期）
4. 等待所有旧 Token 过期
5. 删除旧密钥

---

## 在 AI Agent API 中的应用

### 场景：签名和验证 Token

```python
from fastapi import FastAPI, HTTPException, Depends, Header
from jose import jwt, JWTError
from datetime import datetime, timedelta

app = FastAPI()

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = "HS256"


def create_access_token(user_id: int) -> str:
    """生成 Access Token"""
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(minutes=15)
    }

    # python-jose 内部使用 HMAC-SHA256 签名
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    return token


async def get_current_user(authorization: str = Header()) -> dict:
    """验证 Token"""
    if not authorization.startswith("Bearer "):
        raise HTTPException(401, "无效的认证格式")

    token = authorization.replace("Bearer ", "")

    try:
        # python-jose 内部验证签名
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload

    except jwt.ExpiredSignatureError:
        raise HTTPException(401, "Token 已过期")

    except JWTError:
        raise HTTPException(401, "签名验证失败")


@app.post("/agent/chat")
async def chat(
    message: str,
    current_user: dict = Depends(get_current_user)
):
    """AI Agent 对话端点（需要认证）"""
    user_id = current_user["user_id"]

    # 调用 AI Agent
    response = f"AI 回复给用户 {user_id}: {message}"

    return {"response": response}
```

---

## 总结

**签名机制的核心：**
1. **HMAC-SHA256**：基于哈希的消息认证码
2. **签名流程**：Header + Payload → HMAC → Signature
3. **验证流程**：重新计算签名 → 恒定时间比较
4. **时序攻击防御**：使用 `hmac.compare_digest`
5. **密钥管理**：环境变量 + 密钥轮换

**关键点：**
- 签名防止篡改，不加密
- 密钥必须保密
- 使用恒定时间比较防止时序攻击
- HS256 适合大多数场景
- RS256 适合微服务架构

通过手写实现，你应该对 JWT 的签名机制有了深入的理解！
