# 核心概念09：配置最佳实践

> **本节目标**: 掌握配置系统的最佳实践，构建生产就绪的应用

---

## 一、配置工厂模式

### 1.1 基础工厂

```python
from typing import Optional
from langchain_core.runnables import RunnableConfig

def create_config(
    env: str,
    user_id: Optional[str] = None,
    **kwargs
) -> RunnableConfig:
    """配置工厂函数"""
    base_config = {
        "tags": [env],
        "metadata": {"environment": env}
    }

    if user_id:
        base_config["metadata"]["user_id"] = user_id

    # 合并额外配置
    return merge_configs(base_config, kwargs)

# 使用
prod_config = create_config("production", "user-123", max_concurrency=3)
dev_config = create_config("development", max_concurrency=10)
```

### 1.2 环境特定工厂

```python
class ConfigFactory:
    """配置工厂类"""

    @staticmethod
    def for_production(user_id: str) -> RunnableConfig:
        """生产环境配置"""
        return {
            "tags": ["production", "user-request"],
            "metadata": {
                "environment": "production",
                "user_id": user_id
            },
            "max_concurrency": 3,
            "recursion_limit": 10,
            "callbacks": [LangChainTracer(project_name="prod")]
        }

    @staticmethod
    def for_development() -> RunnableConfig:
        """开发环境配置"""
        return {
            "tags": ["development"],
            "metadata": {"environment": "development"},
            "max_concurrency": 10,
            "recursion_limit": 50,
            "callbacks": [StdOutCallbackHandler()]
        }

    @staticmethod
    def for_testing() -> RunnableConfig:
        """测试环境配置"""
        return {
            "tags": ["testing"],
            "metadata": {"environment": "testing"},
            "max_concurrency": 5,
            "recursion_limit": 25
        }

# 使用
config = ConfigFactory.for_production("user-123")
```

### 1.3 构建器模式

```python
class ConfigBuilder:
    """配置构建器"""

    def __init__(self):
        self._config: RunnableConfig = {}

    def with_tags(self, *tags: str) -> 'ConfigBuilder':
        """添加tags"""
        self._config.setdefault("tags", []).extend(tags)
        return self

    def with_metadata(self, **metadata) -> 'ConfigBuilder':
        """添加metadata"""
        self._config.setdefault("metadata", {}).update(metadata)
        return self

    def with_concurrency(self, max_conc: int) -> 'ConfigBuilder':
        """设置并发"""
        self._config["max_concurrency"] = max_conc
        return self

    def with_callbacks(self, *callbacks) -> 'ConfigBuilder':
        """添加callbacks"""
        self._config.setdefault("callbacks", []).extend(callbacks)
        return self

    def build(self) -> RunnableConfig:
        """构建配置"""
        return self._config.copy()

# 使用
config = (ConfigBuilder()
    .with_tags("production", "user-request")
    .with_metadata(user_id="user-123", environment="production")
    .with_concurrency(3)
    .with_callbacks(LangChainTracer())
    .build())
```

---

## 二、配置验证

### 2.1 基础验证

```python
from pydantic import BaseModel, Field, validator

class ValidatedConfig(BaseModel):
    """验证的配置模型"""
    tags: list[str] = Field(default_factory=list, max_items=10)
    metadata: dict = Field(default_factory=dict)
    max_concurrency: Optional[int] = Field(None, ge=1, le=100)
    recursion_limit: Optional[int] = Field(None, ge=1, le=100)

    @validator('metadata')
    def validate_no_secrets(cls, v):
        """确保metadata中没有秘密"""
        sensitive_keys = ['api_key', 'password', 'token', 'secret']
        for key in v.keys():
            if any(s in key.lower() for s in sensitive_keys):
                raise ValueError(f"不允许在metadata中存储敏感键: {key}")
        return v

    @validator('tags')
    def validate_tags(cls, v):
        """验证tags格式"""
        for tag in v:
            if not isinstance(tag, str):
                raise ValueError("所有tags必须是字符串")
            if len(tag) > 50:
                raise ValueError("tag长度不能超过50")
        return v

# 使用
try:
    validated = ValidatedConfig(
        tags=["production"],
        metadata={"user_id": "123"},
        max_concurrency=5
    )
    config = validated.dict(exclude_none=True)
except ValueError as e:
    print(f"配置验证失败: {e}")
```

### 2.2 运行时验证

```python
def validate_config(config: RunnableConfig) -> RunnableConfig:
    """运行时配置验证"""
    # 验证max_concurrency
    if "max_concurrency" in config:
        max_conc = config["max_concurrency"]
        if not isinstance(max_conc, int) or max_conc < 1 or max_conc > 100:
            raise ValueError("max_concurrency必须在1-100之间")

    # 验证recursion_limit
    if "recursion_limit" in config:
        rec_limit = config["recursion_limit"]
        if not isinstance(rec_limit, int) or rec_limit < 1 or rec_limit > 100:
            raise ValueError("recursion_limit必须在1-100之间")

    # 验证metadata
    if "metadata" in config:
        metadata = config["metadata"]
        if not isinstance(metadata, dict):
            raise ValueError("metadata必须是字典")

        # 检查敏感键
        sensitive_keys = ['api_key', 'password', 'token', 'secret']
        for key in metadata.keys():
            if any(s in key.lower() for s in sensitive_keys):
                raise ValueError(f"不允许在metadata中存储敏感键: {key}")

    # 验证tags
    if "tags" in config:
        tags = config["tags"]
        if not isinstance(tags, list):
            raise ValueError("tags必须是列表")
        if len(tags) > 50:
            raise ValueError("tags数量不能超过50")
        if not all(isinstance(t, str) for t in tags):
            raise ValueError("所有tags必须是字符串")

    return config

# 使用
config = {"tags": ["test"], "max_concurrency": 5}
validated_config = validate_config(config)
```

---

## 三、线程安全

### 3.1 不可变配置

```python
# ✓ 好：配置是不可变的
config = {"tags": ["base"], "max_concurrency": 5}

# 多个线程可以安全地共享同一个配置
def worker(input):
    result = chain.invoke(input, config=config)
    return result

# 并发执行
with ThreadPoolExecutor(max_workers=5) as executor:
    results = list(executor.map(worker, inputs))
```

### 3.2 线程本地配置

```python
import threading

# 线程本地存储
thread_local = threading.local()

def get_thread_config():
    """获取线程本地配置"""
    if not hasattr(thread_local, 'config'):
        thread_local.config = {
            "tags": [f"thread-{threading.current_thread().name}"],
            "metadata": {"thread_id": threading.current_thread().ident}
        }
    return thread_local.config

# 使用
def worker(input):
    config = get_thread_config()
    result = chain.invoke(input, config=config)
    return result
```

### 3.3 上下文变量

```python
from contextvars import ContextVar

# 上下文变量（推荐）
config_context: ContextVar[Optional[RunnableConfig]] = ContextVar(
    'config_context',
    default=None
)

def set_context_config(config: RunnableConfig):
    """设置上下文配置"""
    config_context.set(config)

def get_context_config() -> Optional[RunnableConfig]:
    """获取上下文配置"""
    return config_context.get()

# 使用
async def async_worker(input):
    # 每个异步任务有独立的上下文
    set_context_config({"tags": ["async-task"]})
    result = await chain.ainvoke(input, config=get_context_config())
    return result
```

---

## 四、安全最佳实践

根据研究材料（temp/09_config_security.md）：

### 4.1 不要在配置中存储秘密

```python
# ❌ 错误：硬编码秘密
config = {
    "metadata": {
        "api_key": "sk-1234567890",  # 危险！
        "password": "secret123"
    }
}

# ✓ 正确：使用环境变量
import os
from langchain_core.utils import SecretStr

config = {
    "metadata": {
        "user_id": "user-123",  # 非敏感数据
        "environment": "production"
    }
}

# 秘密通过环境变量或秘密管理器
api_key = SecretStr(os.getenv("OPENAI_API_KEY"))
```

### 4.2 输入验证

```python
def sanitize_metadata(metadata: dict) -> dict:
    """清理metadata防止注入"""
    sanitized = {}

    for key, value in metadata.items():
        # 验证键名
        if not key.isidentifier():
            continue

        # 清理字符串值
        if isinstance(value, str):
            # 移除控制字符
            value = ''.join(c for c in value if c.isprintable())
            # 限制长度
            value = value[:1000]
            # 转义特殊字符
            value = value.replace("{", "{{").replace("}", "}}")

        # 验证值类型
        if isinstance(value, (str, int, float, bool)):
            sanitized[key] = value

    return sanitized

# 使用
user_metadata = {"user_input": "Hello {system_prompt}"}
safe_metadata = sanitize_metadata(user_metadata)
config = {"metadata": safe_metadata}
```

### 4.3 权限控制

```python
from enum import Enum

class Permission(Enum):
    READ = "read"
    WRITE = "write"
    EXECUTE = "execute"
    ADMIN = "admin"

class ConfigPermissionChecker:
    """配置权限检查器"""

    def __init__(self, user_permissions: set[Permission]):
        self.user_permissions = user_permissions

    def can_set_callbacks(self) -> bool:
        return Permission.ADMIN in self.user_permissions

    def can_set_max_concurrency(self, value: int) -> bool:
        if Permission.ADMIN in self.user_permissions:
            return True
        return value <= 5  # 普通用户限制

    def validate_config(self, config: dict) -> dict:
        if "callbacks" in config and not self.can_set_callbacks():
            raise PermissionError("没有权限设置callbacks")

        if "max_concurrency" in config:
            if not self.can_set_max_concurrency(config["max_concurrency"]):
                raise PermissionError("max_concurrency超出权限限制")

        return config

# 使用
user_perms = {Permission.READ, Permission.EXECUTE}
checker = ConfigPermissionChecker(user_perms)
safe_config = checker.validate_config(user_config)
```

---

## 五、常见反模式

### 5.1 全局配置

```python
# ❌ 反模式：全局配置
GLOBAL_CONFIG = {"max_concurrency": 5}

def process(input):
    return chain.invoke(input, config=GLOBAL_CONFIG)

# 问题：难以测试、线程不安全、隐式依赖

# ✓ 正确：显式传递配置
def process(input, config):
    return chain.invoke(input, config=config)
```

### 5.2 修改传入的配置

```python
# ❌ 反模式：修改传入的配置
def process(input, config):
    config["tags"].append("processed")  # 修改了原配置！
    return chain.invoke(input, config=config)

# ✓ 正确：创建新配置
def process(input, config):
    new_config = merge_configs(config, {"tags": ["processed"]})
    return chain.invoke(input, config=new_config)
```

### 5.3 过度配置

```python
# ❌ 反模式：过度配置
config = {
    "tags": ["tag1", "tag2", "tag3", "tag4", "tag5", "tag6", "tag7", "tag8"],
    "metadata": {
        "key1": "value1",
        "key2": "value2",
        # ... 50个键
    },
    "callbacks": [callback1, callback2, callback3, callback4, callback5]
}

# ✓ 正确：最小必需配置
config = {
    "tags": ["production"],
    "metadata": {"user_id": "user-123"},
    "max_concurrency": 5
}
```

### 5.4 硬编码配置

```python
# ❌ 反模式：硬编码配置
config = {
    "tags": ["production"],
    "max_concurrency": 3,
    "callbacks": [LangChainTracer(project_name="my-app")]
}

# ✓ 正确：从环境或配置文件读取
import os

config = {
    "tags": [os.getenv("ENV", "development")],
    "max_concurrency": int(os.getenv("MAX_CONCURRENCY", "5")),
    "callbacks": [LangChainTracer(project_name=os.getenv("LANGSMITH_PROJECT"))]
}
```

---

## 六、测试配置

### 6.1 配置隔离

```python
import pytest

@pytest.fixture
def test_config():
    """测试配置fixture"""
    return {
        "tags": ["test"],
        "metadata": {"environment": "test"},
        "max_concurrency": 1,  # 串行执行，便于调试
        "recursion_limit": 5
    }

def test_chain(test_config):
    """使用测试配置"""
    result = chain.invoke(input, config=test_config)
    assert result is not None
```

### 6.2 配置模拟

```python
from unittest.mock import Mock

def test_with_mock_callbacks():
    """使用模拟callbacks测试"""
    mock_callback = Mock()

    config = {"callbacks": [mock_callback]}
    result = chain.invoke(input, config=config)

    # 验证回调被调用
    assert mock_callback.on_chain_start.called
    assert mock_callback.on_chain_end.called
```

### 6.3 配置验证测试

```python
def test_config_validation():
    """测试配置验证"""
    # 有效配置
    valid_config = {"max_concurrency": 5}
    assert validate_config(valid_config) == valid_config

    # 无效配置
    invalid_config = {"max_concurrency": 200}
    with pytest.raises(ValueError):
        validate_config(invalid_config)
```

---

## 七、文档化

### 7.1 配置文档

```python
def create_production_config(user_id: str) -> RunnableConfig:
    """
    创建生产环境配置

    参数:
        user_id: 用户ID

    返回:
        生产环境配置，包含：
        - tags: ["production", "user-request"]
        - metadata: user_id, environment
        - max_concurrency: 3
        - recursion_limit: 10
        - callbacks: LangSmith追踪

    示例:
        >>> config = create_production_config("user-123")
        >>> result = chain.invoke(input, config=config)
    """
    return {
        "tags": ["production", "user-request"],
        "metadata": {
            "user_id": user_id,
            "environment": "production"
        },
        "max_concurrency": 3,
        "recursion_limit": 10,
        "callbacks": [LangChainTracer(project_name="prod")]
    }
```

### 7.2 配置示例

```python
# 在README或文档中提供配置示例

# 基础配置
basic_config = {
    "tags": ["production"],
    "metadata": {"user_id": "user-123"}
}

# 完整配置
full_config = {
    "tags": ["production", "user-facing"],
    "metadata": {
        "user_id": "user-123",
        "session_id": "session-456",
        "environment": "production"
    },
    "callbacks": [LangChainTracer(project_name="prod")],
    "max_concurrency": 3,
    "recursion_limit": 10
}

# 开发配置
dev_config = {
    "tags": ["development"],
    "callbacks": [StdOutCallbackHandler()],
    "max_concurrency": 10
}
```

---

## 八、监控与日志

### 8.1 配置审计

```python
import logging
import json
from datetime import datetime

class ConfigAuditor:
    """配置审计日志"""

    def __init__(self):
        self.logger = logging.getLogger("config_audit")

    def log_config_use(self, user_id: str, config: dict, action: str):
        """记录配置使用"""
        audit_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "user_id": user_id,
            "action": action,
            "config": {
                "tags": config.get("tags", []),
                "metadata": config.get("metadata", {}),
                "max_concurrency": config.get("max_concurrency"),
                "has_callbacks": "callbacks" in config
            }
        }
        self.logger.info(json.dumps(audit_entry))

# 使用
auditor = ConfigAuditor()
auditor.log_config_use("user-123", config, "invoke_chain")
```

### 8.2 配置监控

```python
class ConfigMonitor:
    """配置监控"""

    def __init__(self):
        self.config_usage = {}

    def track_config(self, config: dict):
        """追踪配置使用"""
        max_conc = config.get("max_concurrency", "default")
        self.config_usage[max_conc] = self.config_usage.get(max_conc, 0) + 1

    def get_stats(self):
        """获取统计信息"""
        return self.config_usage

# 使用
monitor = ConfigMonitor()
monitor.track_config(config)
print(monitor.get_stats())
```

---

## 九、2025-2026最佳实践

### 9.1 使用SecretStr

```python
from langchain_core.utils import SecretStr

# ✓ 使用SecretStr保护敏感数据
api_key = SecretStr(os.getenv("OPENAI_API_KEY"))
llm = ChatOpenAI(api_key=api_key)

# SecretStr不会在日志中泄露
print(api_key)  # 输出: SecretStr('**********')
```

### 9.2 LangSmith集成

```python
# ✓ 使用环境变量配置LangSmith
os.environ["LANGSMITH_TRACING"] = "true"
os.environ["LANGSMITH_PROJECT"] = "my-project"

# 配置自动包含追踪
config = {
    "tags": ["production"],
    "metadata": {"user_id": "user-123"}
}
```

### 9.3 异步优先

```python
# ✓ 使用异步方法
async def process_async(input, config):
    result = await chain.ainvoke(input, config=config)
    return result

# 批处理使用异步
results = await chain.abatch(inputs, config=config)
```

---

## 十、检查清单

### 10.1 配置安全检查清单

- [ ] 不在配置中存储秘密
- [ ] 使用SecretStr保护敏感数据
- [ ] 验证所有用户提供的配置
- [ ] 实施权限控制
- [ ] 记录审计日志
- [ ] 清理用户输入防止注入

### 10.2 配置质量检查清单

- [ ] 使用配置工厂模式
- [ ] 配置是不可变的
- [ ] 显式传递配置
- [ ] 避免全局配置
- [ ] 文档化配置选项
- [ ] 提供配置示例

### 10.3 配置性能检查清单

- [ ] 设置合理的max_concurrency
- [ ] 设置合理的recursion_limit
- [ ] 使用异步方法
- [ ] 监控配置使用
- [ ] 定期性能测试

---

## 十一、总结

配置最佳实践的核心原则：

1. **工厂模式**: 使用工厂函数或类创建配置
2. **验证**: 验证所有配置，防止错误
3. **线程安全**: 配置不可变，使用上下文变量
4. **安全**: 不存储秘密，验证输入，权限控制
5. **测试**: 隔离测试配置，模拟callbacks
6. **文档化**: 清晰的文档和示例
7. **监控**: 审计日志和使用统计

---

## 十二、下一步

- 实战练习: [实战代码07 - 配置工厂模式](./07_实战代码_07_配置工厂模式.md)
- 完整应用: [实战代码08 - 完整RAG应用配置](./07_实战代码_08_完整RAG应用配置.md)
- 最小可用: [04_最小可用](./04_最小可用.md)
