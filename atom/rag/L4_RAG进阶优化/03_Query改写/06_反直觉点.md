# 反直觉点

Query改写最容易犯的 3 个错误，以及为什么人们容易这样错。

---

## 误区1：所有查询都应该改写 ❌

### 错误观点

"既然 Query改写能提升检索效果，那就对所有查询都进行改写。"

### 为什么错？

**精确查询改写后反而会变差：**

```python
# 原始查询（精确）
query = "Python 3.12.1 release notes"

# 改写后（引入噪音）
rewritten = "Python 最新版本发布说明 新特性 更新内容"

# 问题：
# - 原始查询可以精确匹配 "3.12.1" 版本
# - 改写后可能匹配到 3.11、3.10 等其他版本
# - 精确信息被稀释了
```

**错误码、命令等精确查询：**

```python
# 这些查询不应该改写
exact_queries = [
    "error: ECONNREFUSED",           # 错误码需要精确匹配
    "pip install langchain==0.1.0",  # 命令需要精确匹配
    "TypeError: 'NoneType'",         # 错误信息需要精确匹配
    "git reset --hard HEAD~1",       # Git 命令需要精确匹配
]
```

### 为什么人们容易这样错？

1. **过度泛化**：看到改写在某些场景有效，就认为所有场景都有效
2. **忽视成本**：没有考虑改写带来的延迟和 API 成本
3. **一刀切思维**：追求简单统一的方案，不愿意做条件判断

### 正确理解

```python
def smart_rewrite(query: str) -> list[str]:
    """
    智能判断是否需要改写
    """
    # 检测精确查询特征
    import re

    exact_patterns = [
        r'error[:\s]',           # 错误信息
        r'\d+\.\d+\.\d+',        # 版本号
        r'pip\s+install',        # pip 命令
        r'git\s+\w+',            # git 命令
        r'import\s+\w+',         # import 语句
    ]

    for pattern in exact_patterns:
        if re.search(pattern, query, re.IGNORECASE):
            # 精确查询，不改写
            return [query]

    # 非精确查询，进行改写
    return multi_query_rewrite(query)
```

**记住：改写是工具，不是目的。精确查询直接用，模糊查询才改写。**

---

## 误区2：HyDE 生成的假设答案越详细越好 ❌

### 错误观点

"让 LLM 生成更长、更详细的假设答案，检索效果会更好。"

### 为什么错？

**假设答案太长会引入噪音：**

```python
# 用户查询
query = "Python 怎么读取 JSON 文件"

# 过长的假设答案（❌ 不好）
hyde_long = """
Python 读取 JSON 文件有多种方法。最常用的是使用内置的 json 模块。
首先需要 import json，然后使用 open() 函数打开文件，再用 json.load()
读取内容。也可以使用 json.loads() 读取字符串。此外，pandas 库的
read_json() 函数也可以读取 JSON 文件，特别适合处理 JSON 数组数据。
对于大型 JSON 文件，可以考虑使用 ijson 库进行流式解析，避免内存溢出。
还有 orjson 库提供更快的解析速度。在处理嵌套 JSON 时，可以使用
jsonpath-ng 库进行路径查询...
"""
# 问题：包含了太多不相关的内容（pandas、ijson、orjson、jsonpath-ng）
# 这些内容会干扰检索，可能返回不相关的文档

# 简洁的假设答案（✅ 好）
hyde_short = """
Python 读取 JSON 文件使用内置的 json 模块。用 open() 打开文件，
然后用 json.load() 解析 JSON 内容为 Python 字典或列表。
"""
# 简洁、聚焦，只包含核心信息
```

**假设答案可能包含错误信息：**

```python
# 用户查询
query = "Python 3.13 有什么新特性"

# LLM 可能生成错误的假设答案
hyde_wrong = """
Python 3.13 引入了模式匹配语法 match-case，支持结构化模式匹配...
"""
# 问题：match-case 是 Python 3.10 引入的，不是 3.13
# 用错误信息去检索，可能找到错误的文档
```

### 为什么人们容易这样错？

1. **直觉误导**：认为信息越多越好
2. **忽视噪音**：没有意识到无关信息会干扰检索
3. **过度信任 LLM**：认为 LLM 生成的内容都是准确的

### 正确理解

```python
def hyde_with_constraints(query: str) -> str:
    """
    生成简洁、聚焦的假设答案
    """
    prompt = f"""请简要回答以下问题（50-100字）。
只包含最核心的信息，不要展开讨论。

问题：{query}

简要回答："""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.5,  # 降低温度，减少发散
        max_tokens=150    # 限制长度
    )

    return response.choices[0].message.content
```

**记住：HyDE 的假设答案要简洁聚焦，100 字左右最佳。**

---

## 误区3：Query改写可以完全替代好的检索系统 ❌

### 错误观点

"只要 Query改写做得好，检索系统差一点也没关系。"

### 为什么错？

**Query改写只是优化输入，不能弥补检索系统的根本缺陷：**

```
检索效果 = 检索系统质量 × 查询质量

如果检索系统质量 = 0.3（差）
即使查询质量 = 1.0（完美）
最终效果 = 0.3 × 1.0 = 0.3（仍然差）

如果检索系统质量 = 0.9（好）
查询质量 = 0.7（一般）
最终效果 = 0.9 × 0.7 = 0.63（还不错）
```

**Query改写无法解决的问题：**

| 问题 | Query改写能解决？ |
|------|------------------|
| 文档分块不合理 | ❌ 不能 |
| Embedding 模型质量差 | ❌ 不能 |
| 向量索引配置不当 | ❌ 不能 |
| 文档内容本身不全 | ❌ 不能 |
| 用户表达不清晰 | ✅ 能 |
| 用户用词不专业 | ✅ 能 |

### 为什么人们容易这样错？

1. **银弹思维**：希望找到一个万能解决方案
2. **避重就轻**：改写比优化检索系统更容易实现
3. **因果混淆**：把改写的效果归因于改写本身，忽视了检索系统的基础作用

### 正确理解

```
RAG 优化的优先级：

1. 首先：确保检索系统基础扎实
   - 合理的文档分块
   - 高质量的 Embedding 模型
   - 正确的向量索引配置

2. 然后：优化检索策略
   - 混合检索（BM25 + 向量）
   - ReRank 重排序

3. 最后：Query改写锦上添花
   - HyDE
   - Multi-Query
   - Query Decomposition
```

**Query改写是锦上添花，不是雪中送炭。**

```python
# 正确的优化顺序
def optimize_rag_system():
    # Step 1: 基础检索系统
    ensure_good_chunking()
    ensure_good_embedding_model()
    ensure_good_vector_index()

    # Step 2: 检索策略
    implement_hybrid_search()
    implement_rerank()

    # Step 3: Query改写（最后才做）
    implement_query_rewrite()
```

---

## 误区总结

| 误区 | 正确理解 |
|------|---------|
| 所有查询都应该改写 | 精确查询不改写，模糊查询才改写 |
| 假设答案越详细越好 | 简洁聚焦，100 字左右最佳 |
| 改写可以替代好的检索系统 | 改写是锦上添花，基础要先打好 |

---

## 自检清单

在使用 Query改写时，问自己：

- [ ] 这个查询是精确查询还是模糊查询？
- [ ] HyDE 的假设答案是否足够简洁？
- [ ] 检索系统的基础是否已经优化好？
- [ ] 改写带来的延迟是否可接受？
- [ ] 改写后的查询是否保持了原始意图？

---

**下一步：** [07_实战代码](./07_实战代码.md) - 完整可运行的 Query改写示例
