# 04_最小可用

## 核心理念

**最小可用知识：** 掌握这5个操作，你就能在80%的场景中使用BST。

---

## 必备操作清单

### 1. BST基本操作（查找、插入、删除）

#### 节点定义

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
```

#### 查找操作

```python
def search(root, target):
    """
    在BST中查找目标值
    时间复杂度：O(log n) 平衡时，O(n) 最坏
    """
    if not root or root.val == target:
        return root

    if target < root.val:
        return search(root.left, target)  # 往左找
    else:
        return search(root.right, target)  # 往右找
```

**核心思想：** 利用BST性质，每次排除一半搜索空间

#### 插入操作

```python
def insert(root, val):
    """
    在BST中插入新值
    时间复杂度：O(log n) 平衡时，O(n) 最坏
    """
    if not root:
        return TreeNode(val)

    if val < root.val:
        root.left = insert(root.left, val)
    else:
        root.right = insert(root.right, val)

    return root
```

**核心思想：** 找到正确位置后插入，BST性质自动保持

#### 删除操作

```python
def delete(root, val):
    """
    在BST中删除指定值
    时间复杂度：O(log n) 平衡时，O(n) 最坏
    """
    if not root:
        return None

    if val < root.val:
        root.left = delete(root.left, val)
    elif val > root.val:
        root.right = delete(root.right, val)
    else:
        # 找到要删除的节点
        # 情况1：叶子节点或只有一个子节点
        if not root.left:
            return root.right
        if not root.right:
            return root.left

        # 情况2：有两个子节点
        # 找到右子树的最小值（后继节点）
        min_node = find_min(root.right)
        root.val = min_node.val
        root.right = delete(root.right, min_node.val)

    return root

def find_min(root):
    """找到子树的最小值节点"""
    while root.left:
        root = root.left
    return root
```

**核心思想：** 三种情况分别处理

---

### 2. 中序遍历获取有序序列

```python
def inorder(root):
    """
    中序遍历BST，得到有序序列
    时间复杂度：O(n)
    """
    if not root:
        return []

    result = []
    result.extend(inorder(root.left))   # 左
    result.append(root.val)              # 根
    result.extend(inorder(root.right))  # 右

    return result
```

**应用场景：**
- 获取所有元素的有序列表
- 验证BST的正确性
- 排序操作

**示例：**
```python
#       50
#      /  \
#    30    70
#   / \   / \
#  20 40 60 80

inorder(root)  # [20, 30, 40, 50, 60, 70, 80]
```

---

### 3. 范围查询

```python
def range_query(root, low, high):
    """
    查找[low, high]范围内的所有值
    时间复杂度：O(k + log n)，k是结果数量
    """
    if not root:
        return []

    result = []

    # 如果当前值大于low，可能在左子树有结果
    if low < root.val:
        result.extend(range_query(root.left, low, high))

    # 如果当前值在范围内，加入结果
    if low <= root.val <= high:
        result.append(root.val)

    # 如果当前值小于high，可能在右子树有结果
    if root.val < high:
        result.extend(range_query(root.right, low, high))

    return result
```

**应用场景：**
- 时间范围查询（"最近24小时的日志"）
- 分数范围查询（"80-90分的学生"）
- 价格范围查询（"100-200元的商品"）

**示例：**
```python
#       50
#      /  \
#    30    70
#   / \   / \
#  20 40 60 80

range_query(root, 35, 65)  # [40, 50, 60]
```

---

### 4. 平衡性检查

```python
def is_balanced(root):
    """
    检查BST是否平衡
    平衡定义：左右子树高度差 ≤ 1
    """
    def check_height(node):
        if not node:
            return 0

        left_height = check_height(node.left)
        if left_height == -1:
            return -1

        right_height = check_height(node.right)
        if right_height == -1:
            return -1

        # 检查平衡性
        if abs(left_height - right_height) > 1:
            return -1

        return max(left_height, right_height) + 1

    return check_height(root) != -1
```

**应用场景：**
- 性能诊断
- 决定是否需要重平衡
- 数据结构验证

---

### 5. 简单的AVL旋转

#### 右旋（Left-Left情况）

```python
def rotate_right(y):
    """
    右旋操作
          y                x
         / \              / \
        x   T3    →      T1  y
       / \                  / \
      T1 T2                T2 T3
    """
    x = y.left
    T2 = x.right

    # 执行旋转
    x.right = y
    y.left = T2

    return x  # 新的根节点
```

#### 左旋（Right-Right情况）

```python
def rotate_left(x):
    """
    左旋操作
        x                y
       / \              / \
      T1  y     →      x  T3
         / \          / \
        T2 T3        T1 T2
    """
    y = x.right
    T2 = y.left

    # 执行旋转
    y.left = x
    x.right = T2

    return y  # 新的根节点
```

**应用场景：**
- AVL树的平衡维护
- 红黑树的调整
- 性能优化

---

## 完整示例：最小可用BST

```python
class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        """插入值"""
        self.root = self._insert(self.root, val)

    def _insert(self, root, val):
        if not root:
            return TreeNode(val)
        if val < root.val:
            root.left = self._insert(root.left, val)
        else:
            root.right = self._insert(root.right, val)
        return root

    def search(self, val):
        """查找值"""
        return self._search(self.root, val)

    def _search(self, root, val):
        if not root or root.val == val:
            return root
        if val < root.val:
            return self._search(root.left, val)
        return self._search(root.right, val)

    def delete(self, val):
        """删除值"""
        self.root = self._delete(self.root, val)

    def _delete(self, root, val):
        if not root:
            return None
        if val < root.val:
            root.left = self._delete(root.left, val)
        elif val > root.val:
            root.right = self._delete(root.right, val)
        else:
            if not root.left:
                return root.right
            if not root.right:
                return root.left
            min_node = self._find_min(root.right)
            root.val = min_node.val
            root.right = self._delete(root.right, min_node.val)
        return root

    def _find_min(self, root):
        while root.left:
            root = root.left
        return root

    def inorder(self):
        """中序遍历"""
        return self._inorder(self.root)

    def _inorder(self, root):
        if not root:
            return []
        result = []
        result.extend(self._inorder(root.left))
        result.append(root.val)
        result.extend(self._inorder(root.right))
        return result

    def range_query(self, low, high):
        """范围查询"""
        return self._range_query(self.root, low, high)

    def _range_query(self, root, low, high):
        if not root:
            return []
        result = []
        if low < root.val:
            result.extend(self._range_query(root.left, low, high))
        if low <= root.val <= high:
            result.append(root.val)
        if root.val < high:
            result.extend(self._range_query(root.right, low, high))
        return result


# 使用示例
bst = BST()

# 插入数据
for val in [50, 30, 70, 20, 40, 60, 80]:
    bst.insert(val)

# 查找
node = bst.search(40)
print(f"找到节点: {node.val if node else 'None'}")  # 找到节点: 40

# 中序遍历
print(f"有序序列: {bst.inorder()}")  # [20, 30, 40, 50, 60, 70, 80]

# 范围查询
print(f"35-65范围: {bst.range_query(35, 65)}")  # [40, 50, 60]

# 删除
bst.delete(30)
print(f"删除30后: {bst.inorder()}")  # [20, 40, 50, 60, 70, 80]
```

---

## AI Agent应用示例

### 场景1：对话历史时间检索

```python
class ConversationHistory:
    def __init__(self):
        self.bst = BST()

    def add_message(self, timestamp, message):
        """添加消息"""
        node = TreeNode(timestamp)
        node.message = message
        self.bst.root = self.bst._insert(self.bst.root, node)

    def get_recent_messages(self, hours=24):
        """获取最近N小时的消息"""
        import time
        now = time.time()
        start = now - hours * 3600
        return self.bst.range_query(start, now)
```

### 场景2：优先级任务队列

```python
class PriorityTaskQueue:
    def __init__(self):
        self.bst = BST()

    def add_task(self, priority, task):
        """添加任务"""
        node = TreeNode(priority)
        node.task = task
        self.bst.root = self.bst._insert(self.bst.root, node)

    def get_top_k_tasks(self, k):
        """获取优先级最高的K个任务"""
        all_tasks = self.bst.inorder()
        return all_tasks[-k:]  # 最后K个是优先级最高的
```

---

## 学习检查清单

- [ ] 能手写BST的查找、插入、删除操作
- [ ] 理解中序遍历为什么得到有序序列
- [ ] 能实现范围查询并理解剪枝优化
- [ ] 知道如何检查BST的平衡性
- [ ] 理解左旋和右旋的原理
- [ ] 能用BST解决实际问题（时间检索、任务调度）

---

## 常见错误

### 错误1：删除双子节点时逻辑错误

```python
# ❌ 错误：直接用右子树替换
def delete_wrong(root, val):
    if root.val == val:
        return root.right  # 丢失了左子树！

# ✅ 正确：用后继节点替换
def delete_correct(root, val):
    if root.val == val:
        if not root.left or not root.right:
            return root.left or root.right
        # 找到后继节点
        min_node = find_min(root.right)
        root.val = min_node.val
        root.right = delete(root.right, min_node.val)
    return root
```

### 错误2：范围查询没有剪枝

```python
# ❌ 错误：总是遍历所有节点
def range_query_wrong(root, low, high):
    if not root:
        return []
    result = []
    result.extend(range_query_wrong(root.left, low, high))  # 总是访问左子树
    if low <= root.val <= high:
        result.append(root.val)
    result.extend(range_query_wrong(root.right, low, high))  # 总是访问右子树
    return result

# ✅ 正确：根据范围剪枝
def range_query_correct(root, low, high):
    if not root:
        return []
    result = []
    if low < root.val:  # 只有可能在左子树时才访问
        result.extend(range_query_correct(root.left, low, high))
    if low <= root.val <= high:
        result.append(root.val)
    if root.val < high:  # 只有可能在右子树时才访问
        result.extend(range_query_correct(root.right, low, high))
    return result
```

---

## 性能对比

| 操作 | 数组 | 有序数组 | 链表 | 哈希表 | BST（平衡） |
|------|------|---------|------|--------|------------|
| 查找 | O(n) | O(log n) | O(n) | O(1) | O(log n) |
| 插入 | O(1) | O(n) | O(1) | O(1) | O(log n) |
| 删除 | O(n) | O(n) | O(1) | O(1) | O(log n) |
| 范围查询 | O(n) | O(k+log n) | O(n) | O(n) | O(k+log n) |
| 有序遍历 | O(n log n) | O(n) | O(n log n) | O(n log n) | O(n) |

**BST的优势：** 在需要有序性和范围查询的场景下，BST是最佳选择。

---

**记住：** 掌握这5个操作，你就能在大多数场景中使用BST。重点是理解原理，而不是死记代码。
