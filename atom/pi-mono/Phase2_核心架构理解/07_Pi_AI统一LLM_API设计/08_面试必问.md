# 面试必问

> 2个高频面试问题 + 出彩回答

---

## 问题1："如何设计一个统一的 LLM API？"

### 普通回答（❌ 不出彩）

"我会创建一个统一的接口，然后为每个 Provider 写一个适配器，把不同的 API 格式转换成统一格式。"

**问题：**
- 太笼统，没有细节
- 没有说明设计考虑
- 没有展示深度思考

---

### 出彩回答（✅ 推荐）

> **统一 LLM API 的设计需要考虑三个层面：**
>
> **1. 接口设计层面**
>
> 首先要定义统一的接口，我会使用 Adapter Pattern：
> - 定义 `ProviderAdapter` 接口，包含 `complete()` 和 `stream()` 方法
> - 每个 Provider 实现这个接口
> - 业务代码只依赖接口，不依赖具体实现
>
> **2. 数据格式层面**
>
> 需要设计统一的消息格式：
> - 使用中间格式（Pi AI 格式）而非直接转换
> - 复杂度从 O(N²) 降低到 O(N)
> - 支持多模态内容（文本、图片、工具调用）
>
> **3. 功能抽象层面**
>
> 区分通用功能和特有功能：
> - 通用功能（工具调用、流式响应）抽象为标准接口
> - 特有功能（Claude 的 thinking blocks）通过 options 参数传递
> - 渐进式增强，不强制最小公约数
>
> **实际案例：**
>
> 在我之前的项目中，我们支持了 OpenAI、Anthropic、Google 三个 Provider。通过这种设计，切换 Provider 只需修改一行配置，业务代码完全不变。当 OpenAI API 升级时，我们只需更新 OpenAIAdapter，其他代码无需修改。
>
> **性能考虑：**
>
> 格式转换的开销 < 1ms，而网络延迟 > 50ms，所以抽象层的性能影响可以忽略不计。

---

### 为什么这个回答出彩？

1. ✅ **结构清晰**：三个层面（接口、数据、功能）
2. ✅ **有深度**：提到复杂度分析（O(N²) vs O(N)）
3. ✅ **有实践**：结合实际项目经验
4. ✅ **有权衡**：讨论性能考虑
5. ✅ **展示思考**：不是简单的"做什么"，而是"为什么这样做"

---

## 问题2："统一 API 会不会牺牲 Provider 特有功能？"

### 普通回答（❌ 不出彩）

"不会，我们可以通过配置参数来支持特有功能。"

**问题：**
- 太简单，没有说明如何实现
- 没有展示对问题的深入理解

---

### 出彩回答（✅ 推荐）

> **这是一个常见的误区。统一 API 不会牺牲特有功能，关键在于设计策略：**
>
> **1. 分层设计**
>
> - **核心层**：抽象所有 Provider 都支持的功能（工具调用、流式响应）
> - **扩展层**：通过 `options` 参数支持特有功能
>
> 示例：
> ```typescript
> // 通用功能
> const response = await complete(model, context);
>
> // 特有功能（Claude 的 thinking blocks）
> const response = await complete(model, context, {
>   thinking: { type: 'enabled', budget_tokens: 1000 }
> });
> ```
>
> **2. 渐进式增强**
>
> 不是"最小公约数"，而是"渐进式增强"：
> - 基础功能开箱即用
> - 高级功能按需启用
> - 不强制所有 Provider 支持所有功能
>
> **3. 实际权衡**
>
> 在设计中需要权衡：
> - **抽象 vs 灵活性**：通用功能抽象，特有功能保留
> - **易用性 vs 完整性**：简单场景简单，复杂场景可控
> - **维护成本 vs 功能完整**：核心功能统一维护，特有功能各自维护
>
> **对比其他方案：**
>
> - **LiteLLM**：强制统一为 OpenAI 格式，牺牲了灵活性
> - **直接使用 SDK**：完全灵活但维护成本高
> - **Pi AI**：平衡了易用性和灵活性
>
> **实际数据：**
>
> 在我们的项目中，95% 的场景只用通用功能，5% 的场景需要特有功能。这种设计让大多数代码保持简单，同时不限制高级用法。

---

### 为什么这个回答出彩？

1. ✅ **纠正误区**：指出这是常见误区
2. ✅ **有方案**：分层设计 + 渐进式增强
3. ✅ **有对比**：与其他方案对比
4. ✅ **有数据**：95% vs 5% 的实际数据
5. ✅ **展示权衡**：讨论设计权衡

---

## 面试技巧

### 1. STAR 法则

- **Situation**：描述场景
- **Task**：说明任务
- **Action**：解释行动
- **Result**：展示结果

### 2. 展示深度

- 不只说"做什么"，更要说"为什么"
- 讨论设计权衡
- 提到性能考虑
- 对比不同方案

### 3. 结合实践

- 引用实际项目经验
- 提供具体数据
- 说明遇到的问题和解决方案

---

## 延伸问题

### Q1: "如何处理 Provider API 的变更？"

**关键点：**
- 版本管理
- 向后兼容
- 渐进式迁移

### Q2: "如何优化多 Provider 调用的性能？"

**关键点：**
- 连接池
- 并发控制
- 缓存策略

### Q3: "如何测试 Provider Adapter？"

**关键点：**
- Mock Provider API
- 集成测试
- 契约测试

---

**版本：** v1.0
**最后更新：** 2026-02-19
