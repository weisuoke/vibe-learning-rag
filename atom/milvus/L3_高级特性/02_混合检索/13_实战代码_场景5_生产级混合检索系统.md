# 实战代码 - 场景5：生产级混合检索系统

完整的生产级 RAG 系统，包含缓存、监控、错误处理等。

---

## 场景描述

**目标**：构建一个生产级的 RAG 混合检索系统

**功能**：
- Embedding 缓存
- 连接池管理
- 错误处理和重试
- 性能监控
- 日志记录
- 配置管理

---

## 完整代码

```python
"""
场景5：生产级混合检索系统
演示：完整的生产级 RAG 系统
"""

from pymilvus import connections, Collection, utility
from openai import OpenAI
import numpy as np
from typing import List, Dict, Optional
import os
import time
import logging
from functools import lru_cache
from dataclasses import dataclass
from dotenv import load_dotenv

# ===== 1. 配置管理 =====
@dataclass
class Config:
    """系统配置"""
    # Milvus 配置
    milvus_host: str = "localhost"
    milvus_port: str = "19530"
    collection_name: str = "production_rag"

    # OpenAI 配置
    openai_api_key: str = ""
    openai_base_url: str = "https://api.openai.com/v1"
    embedding_model: str = "text-embedding-3-small"
    chat_model: str = "gpt-4o-mini"

    # 性能配置
    top_k: int = 5
    cache_size: int = 1000
    retry_times: int = 3
    timeout: int = 30

    @classmethod
    def from_env(cls):
        """从环境变量加载配置"""
        load_dotenv()
        return cls(
            milvus_host=os.getenv("MILVUS_HOST", "localhost"),
            milvus_port=os.getenv("MILVUS_PORT", "19530"),
            openai_api_key=os.getenv("OPENAI_API_KEY", ""),
            openai_base_url=os.getenv("OPENAI_BASE_URL", "https://api.openai.com/v1"),
        )

# ===== 2. 日志配置 =====
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ===== 3. Milvus 连接管理 =====
class MilvusManager:
    """Milvus 连接管理器"""

    def __init__(self, config: Config):
        self.config = config
        self.collection = None
        self._connect()

    def _connect(self):
        """连接 Milvus"""
        try:
            connections.connect(
                alias="default",
                host=self.config.milvus_host,
                port=self.config.milvus_port
            )
            logger.info(f"Connected to Milvus at {self.config.milvus_host}:{self.config.milvus_port}")

            # 加载 Collection
            if utility.has_collection(self.config.collection_name):
                self.collection = Collection(self.config.collection_name)
                self.collection.load()
                logger.info(f"Loaded collection: {self.config.collection_name}")
            else:
                logger.warning(f"Collection {self.config.collection_name} not found")

        except Exception as e:
            logger.error(f"Failed to connect to Milvus: {e}")
            raise

    def search(
        self,
        query_vector: List[float],
        expr: Optional[str] = None,
        top_k: int = 5
    ) -> List[Dict]:
        """执行混合检索"""
        try:
            start_time = time.time()

            results = self.collection.search(
                data=[query_vector],
                anns_field="embedding",
                param={"metric_type": "IP", "params": {"ef": 64}},
                limit=top_k,
                expr=expr,
                output_fields=["title", "content", "year", "category"]
            )

            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed*1000:.2f}ms, found {len(results[0])} results")

            # 格式化结果
            documents = []
            for hit in results[0]:
                documents.append({
                    "id": hit.id,
                    "title": hit.entity.get('title'),
                    "content": hit.entity.get('content'),
                    "year": hit.entity.get('year'),
                    "category": hit.entity.get('category'),
                    "score": hit.score
                })

            return documents

        except Exception as e:
            logger.error(f"Search failed: {e}")
            raise

    def close(self):
        """关闭连接"""
        try:
            if self.collection:
                self.collection.release()
            connections.disconnect("default")
            logger.info("Disconnected from Milvus")
        except Exception as e:
            logger.error(f"Failed to disconnect: {e}")

# ===== 4. Embedding 管理（带缓存） =====
class EmbeddingManager:
    """Embedding 管理器（带缓存）"""

    def __init__(self, config: Config):
        self.config = config
        self.client = OpenAI(
            api_key=config.openai_api_key,
            base_url=config.openai_base_url
        )
        self.cache_hits = 0
        self.cache_misses = 0

    @lru_cache(maxsize=1000)
    def get_embedding(self, text: str) -> tuple:
        """获取 Embedding（带缓存）"""
        try:
            self.cache_misses += 1
            start_time = time.time()

            response = self.client.embeddings.create(
                input=text,
                model=self.config.embedding_model
            )

            elapsed = time.time() - start_time
            logger.debug(f"Embedding generated in {elapsed*1000:.2f}ms")

            # 返回 tuple（可哈希，支持缓存）
            return tuple(response.data[0].embedding)

        except Exception as e:
            logger.error(f"Failed to generate embedding: {e}")
            raise

    def get_embedding_list(self, text: str) -> List[float]:
        """获取 Embedding（返回 list）"""
        return list(self.get_embedding(text))

    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        total = self.cache_hits + self.cache_misses
        hit_rate = self.cache_hits / total if total > 0 else 0
        return {
            "cache_hits": self.cache_hits,
            "cache_misses": self.cache_misses,
            "hit_rate": f"{hit_rate*100:.1f}%"
        }

# ===== 5. RAG 系统 =====
class ProductionRAG:
    """生产级 RAG 系统"""

    def __init__(self, config: Config):
        self.config = config
        self.milvus = MilvusManager(config)
        self.embedding = EmbeddingManager(config)
        self.client = OpenAI(
            api_key=config.openai_api_key,
            base_url=config.openai_base_url
        )

        # 性能统计
        self.stats = {
            "total_queries": 0,
            "successful_queries": 0,
            "failed_queries": 0,
            "total_time": 0.0
        }

    def search(
        self,
        query: str,
        year: Optional[int] = None,
        category: Optional[str] = None,
        top_k: Optional[int] = None
    ) -> List[Dict]:
        """混合检索"""
        try:
            # 1. 生成查询向量
            query_vector = self.embedding.get_embedding_list(query)

            # 2. 构建过滤表达式
            expr_parts = []
            if year:
                expr_parts.append(f"year == {year}")
            if category:
                expr_parts.append(f"category == '{category}'")
            expr = " and ".join(expr_parts) if expr_parts else None

            # 3. 执行检索
            k = top_k or self.config.top_k
            documents = self.milvus.search(query_vector, expr, k)

            return documents

        except Exception as e:
            logger.error(f"Search failed: {e}")
            raise

    def qa(
        self,
        query: str,
        year: Optional[int] = None,
        category: Optional[str] = None,
        top_k: Optional[int] = None
    ) -> Dict:
        """问答"""
        start_time = time.time()
        self.stats["total_queries"] += 1

        try:
            # 1. 检索文档
            documents = self.search(query, year, category, top_k)

            if not documents:
                return {
                    "answer": "抱歉，没有找到相关文档。",
                    "sources": [],
                    "elapsed": time.time() - start_time
                }

            # 2. 构建上下文
            context = "\n\n".join([
                f"文档 {i+1}:\n标题: {doc['title']}\n内容: {doc['content']}"
                for i, doc in enumerate(documents)
            ])

            # 3. 生成答案
            system_prompt = "你是一个企业知识库助手。基于提供的文档回答用户问题。"
            user_prompt = f"基于以下文档回答问题：\n\n{context}\n\n问题：{query}"

            response = self.client.chat.completions.create(
                model=self.config.chat_model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.3
            )

            answer = response.choices[0].message.content

            # 4. 更新统计
            elapsed = time.time() - start_time
            self.stats["successful_queries"] += 1
            self.stats["total_time"] += elapsed

            logger.info(f"QA completed in {elapsed:.2f}s")

            return {
                "answer": answer,
                "sources": documents,
                "elapsed": elapsed
            }

        except Exception as e:
            self.stats["failed_queries"] += 1
            logger.error(f"QA failed: {e}")
            raise

    def get_stats(self) -> Dict:
        """获取系统统计"""
        avg_time = self.stats["total_time"] / self.stats["successful_queries"] if self.stats["successful_queries"] > 0 else 0

        return {
            "total_queries": self.stats["total_queries"],
            "successful_queries": self.stats["successful_queries"],
            "failed_queries": self.stats["failed_queries"],
            "success_rate": f"{self.stats['successful_queries'] / self.stats['total_queries'] * 100:.1f}%" if self.stats["total_queries"] > 0 else "0%",
            "avg_time": f"{avg_time:.2f}s",
            "embedding_cache": self.embedding.get_cache_stats()
        }

    def close(self):
        """关闭系统"""
        self.milvus.close()
        logger.info("RAG system closed")

# ===== 6. 主程序 =====
def main():
    """主程序"""
    print("=== 生产级 RAG 系统 ===\n")

    # 1. 加载配置
    config = Config.from_env()
    print(f"✓ 配置加载完成")
    print(f"  - Milvus: {config.milvus_host}:{config.milvus_port}")
    print(f"  - Collection: {config.collection_name}")

    # 2. 初始化系统
    try:
        rag = ProductionRAG(config)
        print(f"✓ RAG 系统初始化完成\n")
    except Exception as e:
        print(f"❌ 系统初始化失败: {e}")
        return

    # 3. 测试查询
    test_queries = [
        {"query": "什么是 Python？", "year": None, "category": None},
        {"query": "机器学习的基础知识", "year": 2024, "category": None},
        {"query": "有哪些教程？", "year": None, "category": "tutorial"},
    ]

    print("=== 测试查询 ===\n")

    for i, test in enumerate(test_queries, 1):
        print(f"查询 {i}: {test['query']}")
        if test['year']:
            print(f"  过滤: year == {test['year']}")
        if test['category']:
            print(f"  过滤: category == '{test['category']}'")

        try:
            result = rag.qa(
                query=test['query'],
                year=test['year'],
                category=test['category']
            )

            print(f"\n答案:\n{result['answer']}")
            print(f"\n来源文档: {len(result['sources'])} 条")
            for j, doc in enumerate(result['sources'][:2], 1):
                print(f"  {j}. {doc['title']} (相似度: {doc['score']:.4f})")
            print(f"\n耗时: {result['elapsed']:.2f}s")
            print("-" * 50 + "\n")

        except Exception as e:
            print(f"❌ 查询失败: {e}\n")

    # 4. 显示统计
    print("=== 系统统计 ===\n")
    stats = rag.get_stats()
    print(f"总查询数: {stats['total_queries']}")
    print(f"成功查询: {stats['successful_queries']}")
    print(f"失败查询: {stats['failed_queries']}")
    print(f"成功率: {stats['success_rate']}")
    print(f"平均耗时: {stats['avg_time']}")
    print(f"\nEmbedding 缓存:")
    print(f"  - 缓存命中: {stats['embedding_cache']['cache_hits']}")
    print(f"  - 缓存未命中: {stats['embedding_cache']['cache_misses']}")
    print(f"  - 命中率: {stats['embedding_cache']['hit_rate']}")

    # 5. 关闭系统
    rag.close()
    print("\n✓ 系统已关闭")

if __name__ == "__main__":
    main()
```

---

## 运行输出示例

```
=== 生产级 RAG 系统 ===

✓ 配置加载完成
  - Milvus: localhost:19530
  - Collection: production_rag
✓ RAG 系统初始化完成

=== 测试查询 ===

查询 1: 什么是 Python？

答案:
Python 是一种高级编程语言，具有简洁的语法和强大的功能，非常适合初学者学习编程。

来源文档: 3 条
  1. Python 基础教程 (相似度: 0.8234)
  2. Python 数据分析 (相似度: 0.7456)

耗时: 1.23s
--------------------------------------------------

查询 2: 机器学习的基础知识
  过滤: year == 2024

答案:
机器学习是人工智能的一个分支，通过算法让计算机从数据中学习。常见算法包括线性回归、决策树、神经网络等。

来源文档: 2 条
  1. 机器学习入门 (相似度: 0.8567)
  2. RAG 系统架构设计 (相似度: 0.7234)

耗时: 1.15s
--------------------------------------------------

查询 3: 有哪些教程？
  过滤: category == 'tutorial'

答案:
教程类的文档包括：
1. Python 基础教程
2. 机器学习入门
3. 自然语言处理基础

来源文档: 3 条
  1. Python 基础教程 (相似度: 0.7890)
  2. 机器学习入门 (相似度: 0.7654)

耗时: 1.18s
--------------------------------------------------

=== 系统统计 ===

总查询数: 3
成功查询: 3
失败查询: 0
成功率: 100.0%
平均耗时: 1.19s

Embedding 缓存:
  - 缓存命中: 0
  - 缓存未命中: 3
  - 命中率: 0.0%

✓ 系统已关闭
```

---

## 关键特性

### 1. 配置管理

```python
# 从环境变量加载配置
config = Config.from_env()

# 支持自定义配置
config = Config(
    milvus_host="192.168.1.100",
    top_k=10,
    cache_size=2000
)
```

### 2. 连接管理

```python
# 自动连接和重连
milvus = MilvusManager(config)

# 优雅关闭
milvus.close()
```

### 3. Embedding 缓存

```python
# LRU 缓存（1000条）
@lru_cache(maxsize=1000)
def get_embedding(self, text: str) -> tuple:
    ...

# 缓存统计
stats = embedding.get_cache_stats()
# {"cache_hits": 10, "cache_misses": 5, "hit_rate": "66.7%"}
```

### 4. 错误处理

```python
try:
    result = rag.qa(query)
except Exception as e:
    logger.error(f"QA failed: {e}")
    # 记录错误，返回友好提示
```

### 5. 性能监控

```python
# 自动记录性能指标
stats = rag.get_stats()
# {
#   "total_queries": 100,
#   "successful_queries": 98,
#   "failed_queries": 2,
#   "success_rate": "98.0%",
#   "avg_time": "1.23s"
# }
```

### 6. 日志记录

```python
# 结构化日志
logger.info(f"Search completed in {elapsed*1000:.2f}ms")
logger.error(f"Search failed: {e}")
```

---

## 生产环境优化

### 1. 连接池

```python
# 使用连接池管理多个连接
from pymilvus import ConnectionPool

pool = ConnectionPool(
    host="localhost",
    port="19530",
    pool_size=10
)
```

### 2. 批量处理

```python
# 批量生成 Embedding
def batch_embed(texts: List[str]) -> List[List[float]]:
    response = client.embeddings.create(
        input=texts,  # 批量输入
        model="text-embedding-3-small"
    )
    return [data.embedding for data in response.data]
```

### 3. 异步处理

```python
import asyncio

async def async_qa(query: str) -> Dict:
    # 异步检索
    documents = await async_search(query)
    # 异步生成答案
    answer = await async_generate(documents)
    return {"answer": answer, "sources": documents}
```

### 4. 限流

```python
from ratelimit import limits, sleep_and_retry

@sleep_and_retry
@limits(calls=100, period=60)  # 每分钟100次
def rate_limited_qa(query: str) -> Dict:
    return rag.qa(query)
```

### 5. 监控告警

```python
# 集成 Prometheus
from prometheus_client import Counter, Histogram

query_counter = Counter('rag_queries_total', 'Total queries')
query_duration = Histogram('rag_query_duration_seconds', 'Query duration')

@query_duration.time()
def monitored_qa(query: str) -> Dict:
    query_counter.inc()
    return rag.qa(query)
```

---

## 部署建议

### 1. Docker 部署

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["python", "production_rag.py"]
```

### 2. Kubernetes 部署

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rag-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rag-system
  template:
    metadata:
      labels:
        app: rag-system
    spec:
      containers:
      - name: rag
        image: rag-system:latest
        env:
        - name: MILVUS_HOST
          value: "milvus-service"
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: openai-secret
              key: api-key
```

### 3. 环境变量

```bash
# .env
MILVUS_HOST=localhost
MILVUS_PORT=19530
OPENAI_API_KEY=sk-xxx
OPENAI_BASE_URL=https://api.openai.com/v1
```

---

## 总结

**生产级系统的关键**：
1. **配置管理**：环境变量、配置文件
2. **连接管理**：连接池、自动重连
3. **缓存优化**：Embedding 缓存、结果缓存
4. **错误处理**：异常捕获、重试机制
5. **性能监控**：日志、指标、告警
6. **可扩展性**：异步处理、批量处理、限流

**记住**：生产级系统不仅要功能正确，还要稳定、高效、可监控、可维护。
