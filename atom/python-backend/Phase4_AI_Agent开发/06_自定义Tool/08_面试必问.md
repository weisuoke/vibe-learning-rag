# 自定义Tool - 面试必问

> 2个关于自定义Tool的高频面试问题

---

## 问题1："如何设计一个好的Tool？"

### 普通回答（❌ 不出彩）

"一个好的Tool需要有清晰的功能定义，参数验证，还要有错误处理。"

**问题：**
- 太笼统，没有具体细节
- 没有说明为什么这些重要
- 没有展示实际经验

---

### 出彩回答（✅ 推荐）

> **设计好的Tool需要从三个层面考虑：**
>
> **1. LLM理解层面（最关键）**
>
> Tool的调用者是LLM，不是人类开发者，所以描述是最重要的。我会确保：
> - **清晰的功能描述**：一句话说明Tool做什么，详细说明返回什么信息
> - **明确的适用场景**：列举具体的用户问题示例，让LLM知道何时调用
> - **完整的参数说明**：不仅说明类型，还要说明格式、范围、示例
>
> 举例：我之前设计过一个订单查询Tool，最初描述只写"查询订单"，LLM经常选错。后来我加上"适用场景：用户询问'我的订单XXX怎么样了？'"，准确率从60%提升到95%。
>
> **2. 参数验证层面**
>
> 使用Pydantic定义严格的Schema：
> - **类型验证**：确保参数类型正确
> - **范围限制**：使用`ge`/`le`限制数值范围，`min_length`/`max_length`限制字符串长度
> - **默认值**：为可选参数提供合理的默认值
>
> 这样可以在Tool执行前就拦截无效参数，避免浪费API调用。
>
> **3. 执行可靠性层面**
>
> Tool的执行逻辑要健壮：
> - **返回错误信息而非抛出异常**：让LLM能理解错误并尝试其他方案
> - **资源管理**：使用连接池复用数据库连接、HTTP客户端
> - **超时处理**：避免Tool执行时间过长阻塞Agent
> - **日志记录**：记录Tool调用情况，便于调试和监控
>
> **与普通API的区别**
>
> 设计Tool和设计API的最大区别是：
> - **API**：调用者是人类开发者，可以看代码、查文档
> - **Tool**：调用者是LLM，只能看描述，无法"理解"代码
>
> 所以Tool的描述比API文档更重要，必须让LLM能够准确理解何时调用、如何调用。
>
> **在实际项目中的应用**
>
> 我在做智能客服项目时，设计了一套Tool系统：
> - **订单查询Tool**：查询订单状态、物流信息
> - **用户信息Tool**：查询用户的基本信息和消费记录
> - **发送通知Tool**：发送邮件或短信通知
>
> 通过清晰的描述和严格的参数验证，Agent的Tool选择准确率达到95%以上，用户满意度显著提升。

---

### 为什么这个回答出彩？

1. ✅ **多层次解释**：从LLM理解、参数验证、执行可靠性三个层面分析
2. ✅ **具体例子**：用订单查询Tool的实际案例说明描述的重要性
3. ✅ **对比说明**：明确Tool和API的区别，展示深度理解
4. ✅ **实际经验**：提到智能客服项目的实践，展示项目经验
5. ✅ **量化结果**：准确率从60%提升到95%，用数据说话

---

## 问题2："Tool调用失败如何处理？"

### 普通回答（❌ 不出彩）

"Tool调用失败时应该捕获异常，记录日志，然后返回错误信息给用户。"

**问题：**
- 没有区分不同类型的失败
- 没有说明如何让LLM理解错误
- 没有提到降级策略

---

### 出彩回答（✅ 推荐）

> **Tool调用失败的处理需要分三个层次：**
>
> **1. 预防层面：在Tool执行前拦截**
>
> 使用Pydantic Schema在Tool执行前验证参数：
> ```python
> class OrderInput(BaseModel):
>     order_id: str = Field(pattern=r'^ORD-\d{6}$')  # 格式验证
>
> @tool(args_schema=OrderInput)
> def query_order(order_id: str) -> str:
>     # 参数已经验证过，不会有格式错误
>     pass
> ```
>
> 这样可以避免80%的无效调用，节省API成本。
>
> **2. 执行层面：返回错误信息而非抛出异常**
>
> 关键点：Tool的调用者是LLM，需要文本形式的错误信息。
>
> ```python
> @tool
> def query_order(order_id: str) -> str:
>     """查询订单"""
>     try:
>         order = db.get_order(order_id)
>         if not order:
>             # ✅ 返回错误信息，LLM可以理解
>             return "错误：订单不存在。建议：请检查订单号是否正确。"
>         return format_order(order)
>     except DatabaseError as e:
>         # ✅ 返回具体的错误类型和建议
>         return f"数据库错误：{str(e)}。建议：请稍后重试。"
>     except Exception as e:
>         # ✅ 兜底错误处理
>         return f"系统错误：{str(e)}。建议：请联系客服。"
> ```
>
> 为什么不抛出异常？
> - 抛出异常会中断Agent执行
> - LLM看不到异常信息（被框架捕获）
> - 用户只会看到"系统错误"，体验很差
>
> 返回错误信息的好处：
> - LLM能理解错误原因
> - Agent可以尝试其他方案（如换个Tool、调整参数）
> - 用户能看到友好的错误提示
>
> **3. Agent层面：降级策略**
>
> 在Agent配置中设置降级策略：
>
> ```python
> # 策略1：重试机制
> agent_executor = AgentExecutor(
>     agent=agent,
>     tools=tools,
>     max_iterations=5,  # 允许多次尝试
>     handle_parsing_errors=True  # 处理解析错误
> )
>
> # 策略2：提供备用Tool
> tools = [
>     query_order_primary,    # 主Tool：查询主数据库
>     query_order_backup,     # 备用Tool：查询备份数据库
>     escalate_to_human       # 兜底：转人工
> ]
> ```
>
> **实际案例：智能客服系统**
>
> 我在做智能客服时遇到过这个问题：
>
> **问题场景：**
> - 用户询问："我的订单ORD-123456怎么样了？"
> - Agent调用`query_order("ORD-123456")`
> - 数据库连接超时
>
> **最初的处理（差）：**
> ```python
> @tool
> def query_order(order_id: str) -> str:
>     order = db.get_order(order_id)  # 超时，抛出异常
>     return str(order)
>
> # 结果：Agent执行中断，用户看到"系统错误"
> ```
>
> **改进后的处理（好）：**
> ```python
> @tool
> def query_order(order_id: str) -> str:
>     try:
>         order = db.get_order(order_id, timeout=3)
>         return format_order(order)
>     except TimeoutError:
>         return "数据库响应超时。建议：请稍后重试，或提供订单的其他信息（如下单时间、商品名称）帮助查找。"
>
> # 结果：LLM理解错误，生成友好回复：
> # "抱歉，系统暂时无法查询订单。您可以稍后重试，或者告诉我订单的下单时间和商品名称，我用其他方式帮您查找。"
> ```
>
> **效果对比：**
> - **改进前**：用户看到"系统错误"，满意度低，需要人工介入
> - **改进后**：用户看到友好提示，可以提供更多信息，或者稍后重试，满意度提升30%
>
> **总结：Tool失败处理的三个原则**
>
> 1. **预防优于治疗**：用Schema拦截无效参数
> 2. **返回优于抛出**：返回错误信息让LLM理解
> 3. **降级优于中断**：提供备用方案或转人工

---

### 为什么这个回答出彩？

1. ✅ **三层次分析**：预防、执行、Agent层面的完整方案
2. ✅ **对比说明**：抛出异常 vs 返回错误信息的区别
3. ✅ **实际案例**：智能客服系统的真实问题和解决方案
4. ✅ **效果量化**：满意度提升30%，用数据说话
5. ✅ **原则总结**：提炼出可复用的设计原则

---

## 延伸问题

### 问题3："如何优化Tool的性能？"

**关键点：**

1. **连接池复用**
   ```python
   # 模块级别创建客户端，复用连接
   http_client = httpx.AsyncClient()
   db_pool = asyncpg.create_pool()

   @tool
   async def fetch_data(url: str) -> str:
       response = await http_client.get(url)  # 复用连接
       return response.text
   ```

2. **缓存结果**
   ```python
   from functools import lru_cache

   @lru_cache(maxsize=100)
   def get_product_info(product_id: str) -> str:
       # 缓存产品信息，避免重复查询
       return db.query(product_id)
   ```

3. **并发调用**
   ```python
   # LangChain会自动并发调用异步Tool
   # 确保Tool是异步的
   @tool
   async def fetch_weather(city: str) -> str:
       async with httpx.AsyncClient() as client:
           response = await client.get(f"/weather?city={city}")
           return response.text
   ```

4. **超时控制**
   ```python
   @tool
   async def query_database(query: str) -> str:
       try:
           result = await asyncio.wait_for(
               db.execute(query),
               timeout=3.0  # 3秒超时
           )
           return str(result)
       except asyncio.TimeoutError:
           return "查询超时，请简化查询条件或稍后重试。"
   ```

---

### 问题4："Tool和普通函数有什么区别？"

**关键区别：**

| 维度 | 普通函数 | Tool |
|-----|---------|------|
| **调用者** | 人类开发者 | LLM |
| **调用方式** | 直接调用 | LLM根据描述选择 |
| **参数传递** | 开发者明确知道参数 | LLM从对话中提取 |
| **错误处理** | 抛出异常 | 返回错误信息 |
| **返回值** | 任意类型 | 必须是字符串 |
| **文档** | 给开发者看 | 给LLM看 |
| **描述重要性** | 中等 | 极高（决定是否被调用） |

**设计差异：**

```python
# 普通函数
def get_order(order_id: int) -> Order:
    """获取订单"""
    order = db.query(Order).filter_by(id=order_id).first()
    if not order:
        raise NotFoundError(f"Order {order_id} not found")
    return order

# Tool
@tool
def get_order_details(order_id: str) -> str:
    """获取订单详细信息

    根据订单ID查询订单的完整信息，包括订单状态、商品列表、总金额、收货地址。

    适用场景：
    - 用户询问"我的订单XXX怎么样了？"
    - 用户询问"订单XXX的物流信息"

    Args:
        order_id: 订单ID，格式为ORD-XXXXXX

    Returns:
        订单详细信息的文本描述
    """
    try:
        order = db.query(Order).filter_by(id=order_id).first()
        if not order:
            return f"错误：订单{order_id}不存在。请检查订单号是否正确。"

        return f"""订单信息：
订单号：{order.id}
状态：{order.status}
商品：{', '.join([item.name for item in order.items])}
金额：¥{order.total_amount}
地址：{order.shipping_address}
"""
    except Exception as e:
        return f"查询订单时发生错误：{str(e)}。请稍后重试。"
```

---

## 面试技巧总结

### 1. 展示深度理解

- **不要**：只说"Tool需要清晰的描述"
- **要**：说明"Tool的调用者是LLM，描述是LLM选择Tool的唯一依据，所以描述比代码更重要"

### 2. 用实际案例

- **不要**：只说理论
- **要**：举具体项目的例子，说明遇到的问题和解决方案

### 3. 量化效果

- **不要**：只说"提升了性能"
- **要**：说"准确率从60%提升到95%"、"响应时间从5秒降到2秒"

### 4. 对比说明

- **不要**：只说一种方案
- **要**：对比不同方案的优劣，说明为什么选择这个方案

### 5. 总结原则

- **不要**：只说具体做法
- **要**：提炼出可复用的设计原则

---

## 快速参考

### 设计好的Tool的检查清单

- [ ] 清晰的功能描述（一句话 + 详细说明）
- [ ] 明确的适用场景（举例用户问题）
- [ ] 完整的参数说明（类型、格式、范围）
- [ ] 严格的参数验证（Pydantic Schema）
- [ ] 返回错误信息（不抛出异常）
- [ ] 资源管理（连接池、超时）
- [ ] 日志记录（调用情况、错误信息）
- [ ] 单元测试（覆盖正常和异常情况）

### Tool失败处理的三个层次

1. **预防层面**：Pydantic Schema验证参数
2. **执行层面**：返回错误信息而非抛出异常
3. **Agent层面**：重试机制、备用Tool、转人工

### Tool vs 普通函数

| 维度 | 普通函数 | Tool |
|-----|---------|------|
| 调用者 | 人类 | LLM |
| 错误处理 | 抛出异常 | 返回错误信息 |
| 返回值 | 任意类型 | 字符串 |
| 描述重要性 | 中等 | 极高 |

---

**记住：** 面试时要展示深度理解、实际经验、量化效果，不要只说理论！
