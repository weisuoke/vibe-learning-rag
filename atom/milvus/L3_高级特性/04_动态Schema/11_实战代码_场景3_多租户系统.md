# 实战代码 - 场景3：多租户系统

> 使用动态Schema实现多租户系统的灵活字段管理

---

## 场景描述

在SaaS多租户系统中，不同租户可能需要不同的字段：
- 租户A（电商）：需要价格、库存、SKU等字段
- 租户B（新闻）：需要作者、发布时间、浏览量等字段
- 租户C（文档）：需要版本、协作者、权限等字段

使用动态Schema可以在同一个Collection中支持不同租户的不同字段需求。

---

## 完整代码

```python
from pymilvus import connections, Collection, CollectionSchema, FieldSchema, DataType, utility
from sentence_transformers import SentenceTransformer
import numpy as np
from datetime import datetime
from typing import Dict, List, Any

class MultiTenantDynamicSystem:
    """多租户动态Schema系统"""

    def __init__(self, collection_name="multi_tenant_dynamic"):
        self.collection_name = collection_name
        self.collection = None
        self.model = None
        self.tenant_schemas = {}  # 记录每个租户的字段Schema

    def setup(self):
        """初始化系统"""
        print("=" * 60)
        print("多租户动态Schema系统 - 初始化")
        print("=" * 60)

        # 连接Milvus
        connections.connect(host="localhost", port="19530")
        print("✅ 已连接到Milvus")

        # 删除旧Collection
        if utility.has_collection(self.collection_name):
            utility.drop_collection(self.collection_name)

        # 创建Collection（通用固定字段 + 租户特有动态字段）
        fields = [
            FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
            FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=384),
            FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=2000),
            FieldSchema(name="tenant_id", dtype=DataType.VARCHAR, max_length=50),  # 租户ID（固定）
            FieldSchema(name="doc_type", dtype=DataType.VARCHAR, max_length=50)    # 文档类型（固定）
        ]

        schema = CollectionSchema(
            fields=fields,
            description="Multi-tenant system with dynamic schema",
            enable_dynamic_field=True  # 启用动态字段（租户特有字段）
        )

        self.collection = Collection(name=self.collection_name, schema=schema)
        print(f"✅ 已创建Collection: {self.collection_name}")
        print("   - 通用固定字段: id, embedding, text, tenant_id, doc_type")
        print("   - 租户特有字段: 动态管理")

        # 加载Embedding模型
        print("\n加载Embedding模型...")
        self.model = SentenceTransformer('all-MiniLM-L6-v2')
        print("✅ 模型加载完成")

    def register_tenant_schema(self, tenant_id: str, schema: Dict[str, type]):
        """注册租户的字段Schema"""
        self.tenant_schemas[tenant_id] = schema
        print(f"✅ 已注册租户 {tenant_id} 的Schema")
        print(f"   字段: {list(schema.keys())}")

    def insert_tenant_data(self, tenant_id: str, documents: List[Dict[str, Any]]):
        """插入租户数据"""
        print(f"\n插入租户 {tenant_id} 的数据...")

        # 验证租户Schema
        if tenant_id not in self.tenant_schemas:
            print(f"⚠️ 租户 {tenant_id} 未注册Schema，将自动推断")

        data = []
        for doc in documents:
            # 生成Embedding
            embedding = self.model.encode(doc["text"]).tolist()

            # 构建数据项
            item = {
                "text": doc["text"],
                "embedding": embedding,
                "tenant_id": tenant_id,
                "doc_type": doc.get("doc_type", "default")
            }

            # 添加租户特有字段（动态字段）
            for key, value in doc.items():
                if key not in ["text", "doc_type"]:
                    item[key] = value

            data.append(item)

        # 插入数据
        result = self.collection.insert(data)
        self.collection.flush()

        print(f"✅ 已插入 {len(data)} 条数据")
        return result.primary_keys

    def tenant_a_ecommerce(self):
        """租户A：电商系统"""
        print("\n" + "=" * 60)
        print("租户A：电商系统")
        print("=" * 60)

        # 注册租户Schema
        self.register_tenant_schema("tenant_a", {
            "product_name": str,
            "price": float,
            "stock": int,
            "category": str,
            "sku": str,
            "brand": str
        })

        # 插入电商数据
        documents = [
            {
                "text": "High-performance laptop with 16GB RAM and 512GB SSD",
                "doc_type": "product",
                "product_name": "Gaming Laptop Pro",
                "price": 1299.99,
                "stock": 50,
                "category": "Electronics",
                "sku": "LAP-001",
                "brand": "TechBrand"
            },
            {
                "text": "Wireless noise-cancelling headphones with 30-hour battery",
                "doc_type": "product",
                "product_name": "Premium Headphones",
                "price": 299.99,
                "stock": 120,
                "category": "Audio",
                "sku": "AUD-002",
                "brand": "SoundPro"
            }
        ]

        return self.insert_tenant_data("tenant_a", documents)

    def tenant_b_news(self):
        """租户B：新闻系统"""
        print("\n" + "=" * 60)
        print("租户B：新闻系统")
        print("=" * 60)

        # 注册租户Schema
        self.register_tenant_schema("tenant_b", {
            "title": str,
            "author": str,
            "publish_date": str,
            "category": str,
            "views": int,
            "likes": int,
            "tags": list
        })

        # 插入新闻数据
        documents = [
            {
                "text": "Breaking news: AI technology reaches new milestone in natural language processing",
                "doc_type": "article",
                "title": "AI Breakthrough in NLP",
                "author": "John Smith",
                "publish_date": "2024-01-15",
                "category": "Technology",
                "views": 15000,
                "likes": 1200,
                "tags": ["AI", "NLP", "Technology"]
            },
            {
                "text": "Market analysis: Tech stocks surge amid positive earnings reports",
                "doc_type": "article",
                "title": "Tech Stocks Rally",
                "author": "Jane Doe",
                "publish_date": "2024-01-16",
                "category": "Finance",
                "views": 8500,
                "likes": 650,
                "tags": ["Finance", "Stocks", "Market"]
            }
        ]

        return self.insert_tenant_data("tenant_b", documents)

    def tenant_c_documents(self):
        """租户C：文档管理系统"""
        print("\n" + "=" * 60)
        print("租户C：文档管理系统")
        print("=" * 60)

        # 注册租户Schema
        self.register_tenant_schema("tenant_c", {
            "title": str,
            "owner": str,
            "department": str,
            "version": int,
            "collaborators": list,
            "last_modified": str,
            "access_level": str,
            "file_size": int
        })

        # 插入文档数据
        documents = [
            {
                "text": "Q4 2024 Financial Report - Detailed analysis of revenue and expenses",
                "doc_type": "report",
                "title": "Q4 Financial Report",
                "owner": "Alice Johnson",
                "department": "Finance",
                "version": 3,
                "collaborators": ["Bob Lee", "Carol White"],
                "last_modified": "2024-01-10",
                "access_level": "confidential",
                "file_size": 2048000
            },
            {
                "text": "Product roadmap for 2024 - Strategic planning and feature priorities",
                "doc_type": "planning",
                "title": "2024 Product Roadmap",
                "owner": "David Chen",
                "department": "Product",
                "version": 5,
                "collaborators": ["Eve Martinez", "Frank Wilson"],
                "last_modified": "2024-01-12",
                "access_level": "internal",
                "file_size": 1536000
            }
        ]

        return self.insert_tenant_data("tenant_c", documents)

    def create_index_and_load(self):
        """创建索引并加载"""
        print("\n" + "=" * 60)
        print("创建索引并加载Collection")
        print("=" * 60)

        # 创建向量索引
        index_params = {
            "index_type": "IVF_FLAT",
            "metric_type": "L2",
            "params": {"nlist": 128}
        }
        self.collection.create_index(field_name="embedding", index_params=index_params)

        # 为tenant_id创建索引（高频查询字段）
        self.collection.create_index(field_name="tenant_id", index_params={"index_type": "TRIE"})

        self.collection.load()
        print("✅ 索引创建完成，Collection已加载")

    def query_tenant_data(self, tenant_id: str):
        """查询特定租户的数据"""
        print("\n" + "=" * 60)
        print(f"查询租户 {tenant_id} 的数据")
        print("=" * 60)

        results = self.collection.query(
            expr=f'tenant_id == "{tenant_id}"',
            output_fields=["*"],
            limit=100
        )

        print(f"✅ 找到 {len(results)} 条数据\n")

        for i, result in enumerate(results, 1):
            print(f"文档 {i}:")
            print(f"  ID: {result['id']}")
            print(f"  Text: {result['text'][:60]}...")
            print(f"  Type: {result['doc_type']}")

            # 显示租户特有字段
            tenant_fields = {k: v for k, v in result.items()
                           if k not in ["id", "text", "embedding", "tenant_id", "doc_type"]}

            if tenant_fields:
                print("  租户特有字段:")
                for field_name, field_value in tenant_fields.items():
                    if isinstance(field_value, list):
                        print(f"    {field_name}: {', '.join(map(str, field_value))}")
                    else:
                        print(f"    {field_name}: {field_value}")
            print()

    def tenant_search(self, tenant_id: str, query: str, filter_expr: str = None):
        """租户内检索"""
        print("\n" + "=" * 60)
        print(f"租户 {tenant_id} 检索: {query}")
        if filter_expr:
            print(f"过滤条件: {filter_expr}")
        print("=" * 60)

        # 生成查询向量
        query_embedding = self.model.encode(query).tolist()

        # 构建完整的过滤表达式
        full_expr = f'tenant_id == "{tenant_id}"'
        if filter_expr:
            full_expr = f'{full_expr} and {filter_expr}'

        # 向量检索
        search_params = {"metric_type": "L2", "params": {"nprobe": 10}}

        results = self.collection.search(
            data=[query_embedding],
            anns_field="embedding",
            param=search_params,
            limit=5,
            expr=full_expr,
            output_fields=["*"]
        )

        print(f"✅ 找到 {len(results[0])} 条相关文档\n")

        for i, hit in enumerate(results[0], 1):
            print(f"结果 {i}:")
            print(f"  相似度: {1 / (1 + hit.distance):.4f}")
            print(f"  文本: {hit.entity.get('text')[:60]}...")

            # 显示租户特有字段
            tenant_fields = {k: v for k, v in hit.entity.items()
                           if k not in ["id", "text", "embedding", "tenant_id", "doc_type"]}

            if tenant_fields:
                print("  租户特有字段:")
                for field_name, field_value in tenant_fields.items():
                    if isinstance(field_value, list):
                        print(f"    {field_name}: {', '.join(map(str, field_value))}")
                    else:
                        print(f"    {field_name}: {field_value}")
            print()

    def cross_tenant_statistics(self):
        """跨租户统计"""
        print("\n" + "=" * 60)
        print("跨租户统计")
        print("=" * 60)

        # 查询所有数据
        results = self.collection.query(
            expr="id > 0",
            output_fields=["*"],
            limit=1000
        )

        # 按租户统计
        tenant_stats = {}
        for result in results:
            tenant_id = result["tenant_id"]
            if tenant_id not in tenant_stats:
                tenant_stats[tenant_id] = {
                    "count": 0,
                    "fields": set()
                }

            tenant_stats[tenant_id]["count"] += 1

            # 统计字段
            for field_name in result.keys():
                if field_name not in ["id", "text", "embedding", "tenant_id", "doc_type"]:
                    tenant_stats[tenant_id]["fields"].add(field_name)

        print(f"✅ 共 {len(results)} 条数据，{len(tenant_stats)} 个租户\n")

        for tenant_id, stats in tenant_stats.items():
            print(f"租户 {tenant_id}:")
            print(f"  文档数: {stats['count']}")
            print(f"  特有字段: {', '.join(sorted(stats['fields']))}")
            print()

    def tenant_data_isolation_test(self):
        """测试租户数据隔离"""
        print("\n" + "=" * 60)
        print("测试租户数据隔离")
        print("=" * 60)

        # 测试1：租户A只能看到自己的数据
        results_a = self.collection.query(
            expr='tenant_id == "tenant_a"',
            output_fields=["tenant_id", "doc_type"],
            limit=100
        )

        print(f"租户A查询结果: {len(results_a)} 条")
        tenant_ids_a = set(r["tenant_id"] for r in results_a)
        print(f"  包含的租户ID: {tenant_ids_a}")
        assert tenant_ids_a == {"tenant_a"}, "❌ 数据隔离失败！"
        print("  ✅ 数据隔离正常")

        # 测试2：租户B只能看到自己的数据
        results_b = self.collection.query(
            expr='tenant_id == "tenant_b"',
            output_fields=["tenant_id", "doc_type"],
            limit=100
        )

        print(f"\n租户B查询结果: {len(results_b)} 条")
        tenant_ids_b = set(r["tenant_id"] for r in results_b)
        print(f"  包含的租户ID: {tenant_ids_b}")
        assert tenant_ids_b == {"tenant_b"}, "❌ 数据隔离失败！"
        print("  ✅ 数据隔离正常")

        print("\n✅ 所有租户数据隔离测试通过")

    def cleanup(self):
        """清理资源"""
        print("\n" + "=" * 60)
        print("清理资源")
        print("=" * 60)

        self.collection.release()
        connections.disconnect("default")
        print("✅ 资源清理完成")

    def run(self):
        """运行完整演示"""
        try:
            # 1. 初始化
            self.setup()

            # 2. 租户A：电商系统
            self.tenant_a_ecommerce()

            # 3. 租户B：新闻系统
            self.tenant_b_news()

            # 4. 租户C：文档管理系统
            self.tenant_c_documents()

            # 5. 创建索引并加载
            self.create_index_and_load()

            # 6. 查询各租户数据
            self.query_tenant_data("tenant_a")
            self.query_tenant_data("tenant_b")
            self.query_tenant_data("tenant_c")

            # 7. 租户内检索
            self.tenant_search("tenant_a", "laptop computer", filter_expr='price < 1500')
            self.tenant_search("tenant_b", "technology news", filter_expr='views > 10000')
            self.tenant_search("tenant_c", "financial report", filter_expr='access_level == "confidential"')

            # 8. 跨租户统计
            self.cross_tenant_statistics()

            # 9. 测试数据隔离
            self.tenant_data_isolation_test()

            # 10. 清理
            self.cleanup()

            print("\n" + "=" * 60)
            print("✅ 多租户动态Schema系统演示完成！")
            print("=" * 60)

        except Exception as e:
            print(f"\n❌ 发生错误: {e}")
            import traceback
            traceback.print_exc()


if __name__ == "__main__":
    system = MultiTenantDynamicSystem()
    system.run()
```

---

## 核心优势

### 1. 单Collection支持多租户

```python
# 传统方式：每个租户一个Collection
tenant_a_collection = Collection("tenant_a_products")
tenant_b_collection = Collection("tenant_b_articles")
tenant_c_collection = Collection("tenant_c_documents")

# 动态Schema：所有租户共享一个Collection
shared_collection = Collection("multi_tenant")
# 通过tenant_id区分租户
# 通过动态字段支持不同租户的不同字段需求
```

### 2. 灵活的租户字段管理

```python
# 租户A：电商字段
tenant_a_doc = {
    "tenant_id": "tenant_a",
    "text": "Product description",
    "price": 99.99,
    "stock": 100,
    "sku": "PRD-001"
}

# 租户B：新闻字段
tenant_b_doc = {
    "tenant_id": "tenant_b",
    "text": "News article",
    "author": "John",
    "publish_date": "2024-01-01",
    "views": 1000
}
```

### 3. 租户数据隔离

```python
# 查询时自动隔离
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    expr='tenant_id == "tenant_a"',  # 租户隔离
    output_fields=["*"]
)
```

---

## 架构设计

### 1. Schema设计

```python
# 通用固定字段（所有租户共享）
fixed_fields = [
    "id",           # 主键
    "embedding",    # 向量
    "text",         # 文本内容
    "tenant_id",    # 租户ID（关键！）
    "doc_type"      # 文档类型
]

# 租户特有字段（动态）
tenant_specific_fields = {
    "tenant_a": ["price", "stock", "sku", "brand"],
    "tenant_b": ["author", "publish_date", "views", "likes"],
    "tenant_c": ["owner", "department", "version", "collaborators"]
}
```

### 2. 数据隔离策略

```python
# 策略1：查询时过滤
results = collection.query(
    expr=f'tenant_id == "{current_tenant_id}"',
    output_fields=["*"]
)

# 策略2：检索时过滤
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    expr=f'tenant_id == "{current_tenant_id}"',
    output_fields=["*"]
)

# 策略3：应用层验证
def verify_tenant_access(user_tenant_id, doc_tenant_id):
    if user_tenant_id != doc_tenant_id:
        raise PermissionError("Access denied")
```

### 3. 性能优化

```python
# 优化1：为tenant_id创建索引
collection.create_index(
    field_name="tenant_id",
    index_params={"index_type": "TRIE"}
)

# 优化2：使用Partition按租户分区
collection.create_partition("tenant_a")
collection.create_partition("tenant_b")

# 优化3：租户内高频字段迁移到固定Schema
# 如果某个租户的某个字段查询频繁，考虑迁移到固定字段
```

---

## 实际应用场景

### 场景1：SaaS平台

```python
# 不同行业的客户使用同一个系统
# 电商客户：需要商品相关字段
# 教育客户：需要课程相关字段
# 医疗客户：需要病历相关字段

# 使用动态Schema支持不同行业的不同需求
```

### 场景2：企业内部系统

```python
# 不同部门使用同一个文档管理系统
# 财务部：需要财务相关字段
# 人力部：需要人事相关字段
# 技术部：需要技术相关字段

# 使用动态Schema支持不同部门的不同需求
```

### 场景3：多语言内容平台

```python
# 不同语言的内容有不同的元数据
# 中文内容：需要拼音、繁简体等字段
# 英文内容：需要词根、时态等字段
# 日文内容：需要假名、汉字等字段

# 使用动态Schema支持不同语言的不同需求
```

---

## 安全考虑

### 1. 租户数据隔离

```python
class TenantSecurityManager:
    """租户安全管理器"""

    def __init__(self, collection):
        self.collection = collection

    def query_with_tenant_check(self, user_tenant_id, expr, output_fields):
        """带租户检查的查询"""
        # 强制添加租户过滤
        safe_expr = f'tenant_id == "{user_tenant_id}"'
        if expr:
            safe_expr = f'{safe_expr} and ({expr})'

        return self.collection.query(
            expr=safe_expr,
            output_fields=output_fields
        )

    def search_with_tenant_check(self, user_tenant_id, query_vector, expr, **kwargs):
        """带租户检查的检索"""
        # 强制添加租户过滤
        safe_expr = f'tenant_id == "{user_tenant_id}"'
        if expr:
            safe_expr = f'{safe_expr} and ({expr})'

        return self.collection.search(
            data=[query_vector],
            anns_field="embedding",
            expr=safe_expr,
            **kwargs
        )
```

### 2. 字段访问控制

```python
class FieldAccessControl:
    """字段访问控制"""

    def __init__(self):
        self.field_permissions = {
            "tenant_a": ["price", "stock", "sku"],
            "tenant_b": ["author", "publish_date", "views"],
            "tenant_c": ["owner", "department", "version"]
        }

    def filter_fields(self, tenant_id, result):
        """过滤字段（只返回租户有权限的字段）"""
        allowed_fields = self.field_permissions.get(tenant_id, [])
        filtered = {k: v for k, v in result.items()
                   if k in ["id", "text", "tenant_id", "doc_type"] or k in allowed_fields}
        return filtered
```

---

## 成本优势

### 1. 降低运维成本

```python
# 传统方式：N个租户 = N个Collection
# - 需要管理N个Collection
# - 需要为每个Collection创建索引
# - 需要为每个Collection分配资源

# 动态Schema：N个租户 = 1个Collection
# - 只需管理1个Collection
# - 只需创建1次索引
# - 资源共享，利用率更高
```

### 2. 简化架构

```python
# 传统方式：复杂的路由逻辑
def get_collection(tenant_id):
    return Collection(f"tenant_{tenant_id}_collection")

# 动态Schema：统一的访问接口
def get_collection():
    return Collection("multi_tenant_collection")
```

---

## 总结

**核心价值**：
1. 单Collection支持多租户，降低运维成本
2. 灵活的租户字段管理，适应不同需求
3. 自动的租户数据隔离，保证安全性
4. 简化的系统架构，提高开发效率

**最佳实践**：
1. tenant_id作为固定字段，创建索引
2. 租户特有字段使用动态Schema
3. 查询时强制添加tenant_id过滤
4. 高频字段考虑迁移到固定Schema

**记住**：动态Schema是多租户系统的理想选择，但要注意数据隔离和安全性。
