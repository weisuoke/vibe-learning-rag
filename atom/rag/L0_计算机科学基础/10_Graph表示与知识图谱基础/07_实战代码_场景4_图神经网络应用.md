# 实战代码 - 场景4：图神经网络应用

> 使用PyTorch Geometric实现GNN - 节点分类和实体类型预测

---

## 场景概述

**目标**：使用图神经网络(GNN)进行节点分类，应用于知识图谱的实体类型预测。

**学习价值**：
- 理解图神经网络的基本原理
- 掌握PyTorch Geometric的使用
- 学会将GNN应用于知识图谱

---

## 完整代码

```python
"""
图神经网络应用 - 节点分类
演示：使用GNN预测知识图谱中的实体类型
"""

import torch
import torch.nn.functional as F
from torch_geometric.nn import GCNConv, GATConv
from torch_geometric.data import Data
import networkx as nx
import numpy as np
from typing import List, Dict, Tuple


# ===== 1. 简单的GNN模型 =====

class SimpleGCN(torch.nn.Module):
    """简单的图卷积网络"""

    def __init__(self, num_features, hidden_channels, num_classes):
        super().__init__()
        self.conv1 = GCNConv(num_features, hidden_channels)
        self.conv2 = GCNConv(hidden_channels, num_classes)

    def forward(self, x, edge_index):
        # 第一层GCN
        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = F.dropout(x, p=0.5, training=self.training)

        # 第二层GCN
        x = self.conv2(x, edge_index)

        return F.log_softmax(x, dim=1)


class SimpleGAT(torch.nn.Module):
    """图注意力网络"""

    def __init__(self, num_features, hidden_channels, num_classes, heads=8):
        super().__init__()
        self.conv1 = GATConv(num_features, hidden_channels, heads=heads)
        self.conv2 = GATConv(hidden_channels * heads, num_classes, heads=1)

    def forward(self, x, edge_index):
        # 第一层GAT
        x = self.conv1(x, edge_index)
        x = F.elu(x)
        x = F.dropout(x, p=0.6, training=self.training)

        # 第二层GAT
        x = self.conv2(x, edge_index)

        return F.log_softmax(x, dim=1)


# ===== 2. 知识图谱数据准备 =====

class KGDataset:
    """知识图谱数据集"""

    def __init__(self):
        self.entity_to_id = {}
        self.id_to_entity = {}
        self.entity_types = {}
        self.type_to_id = {}
        self.edges = []

    def add_entity(self, entity, entity_type):
        """添加实体"""
        if entity not in self.entity_to_id:
            entity_id = len(self.entity_to_id)
            self.entity_to_id[entity] = entity_id
            self.id_to_entity[entity_id] = entity
            self.entity_types[entity] = entity_type

            if entity_type not in self.type_to_id:
                self.type_to_id[entity_type] = len(self.type_to_id)

    def add_triple(self, subject, predicate, object):
        """添加三元组"""
        # 确保实体存在
        if subject in self.entity_to_id and object in self.entity_to_id:
            s_id = self.entity_to_id[subject]
            o_id = self.entity_to_id[object]
            self.edges.append((s_id, o_id))

    def to_pyg_data(self):
        """转换为PyTorch Geometric数据格式"""
        num_nodes = len(self.entity_to_id)

        # 节点特征（简化版：使用one-hot编码）
        x = torch.eye(num_nodes)

        # 边索引
        edge_index = torch.tensor(self.edges, dtype=torch.long).t().contiguous()

        # 节点标签（实体类型）
        y = torch.zeros(num_nodes, dtype=torch.long)
        for entity, entity_type in self.entity_types.items():
            entity_id = self.entity_to_id[entity]
            type_id = self.type_to_id[entity_type]
            y[entity_id] = type_id

        # 训练/测试掩码
        num_train = int(0.6 * num_nodes)
        num_val = int(0.2 * num_nodes)

        train_mask = torch.zeros(num_nodes, dtype=torch.bool)
        val_mask = torch.zeros(num_nodes, dtype=torch.bool)
        test_mask = torch.zeros(num_nodes, dtype=torch.bool)

        train_mask[:num_train] = True
        val_mask[num_train:num_train + num_val] = True
        test_mask[num_train + num_val:] = True

        data = Data(
            x=x,
            edge_index=edge_index,
            y=y,
            train_mask=train_mask,
            val_mask=val_mask,
            test_mask=test_mask
        )

        return data


# ===== 3. 训练和评估 =====

def train_gnn(model, data, optimizer, epochs=200):
    """训练GNN模型"""
    print("=" * 60)
    print("开始训练GNN模型")
    print("=" * 60)

    model.train()
    best_val_acc = 0

    for epoch in range(epochs):
        optimizer.zero_grad()

        # 前向传播
        out = model(data.x, data.edge_index)

        # 计算损失（只在训练集上）
        loss = F.nll_loss(out[data.train_mask], data.y[data.train_mask])

        # 反向传播
        loss.backward()
        optimizer.step()

        # 评估
        if epoch % 20 == 0:
            train_acc = evaluate(model, data, data.train_mask)
            val_acc = evaluate(model, data, data.val_mask)

            print(f"Epoch {epoch:3d} | Loss: {loss:.4f} | "
                  f"Train Acc: {train_acc:.4f} | Val Acc: {val_acc:.4f}")

            if val_acc > best_val_acc:
                best_val_acc = val_acc

    print(f"\n最佳验证准确率: {best_val_acc:.4f}")
    print("=" * 60)


def evaluate(model, data, mask):
    """评估模型"""
    model.eval()

    with torch.no_grad():
        out = model(data.x, data.edge_index)
        pred = out.argmax(dim=1)
        correct = pred[mask] == data.y[mask]
        acc = correct.sum() / mask.sum()

    return acc.item()


# ===== 4. 实际应用示例 =====

def demo_entity_type_prediction():
    """示例：实体类型预测"""

    print("\n" + "=" * 60)
    print("示例：知识图谱实体类型预测")
    print("=" * 60)

    # 创建数据集
    dataset = KGDataset()

    # 添加实体（带类型标签）
    entities = [
        ("张三", "Person"),
        ("李四", "Person"),
        ("王五", "Person"),
        ("阿里巴巴", "Organization"),
        ("腾讯", "Organization"),
        ("百度", "Organization"),
        ("杭州", "Location"),
        ("深圳", "Location"),
        ("北京", "Location"),
        ("马云", "Person"),
        ("马化腾", "Person"),
        ("李彦宏", "Person")
    ]

    for entity, entity_type in entities:
        dataset.add_entity(entity, entity_type)

    # 添加关系（构建图结构）
    triples = [
        ("张三", "工作于", "阿里巴巴"),
        ("李四", "工作于", "阿里巴巴"),
        ("王五", "工作于", "腾讯"),
        ("阿里巴巴", "位于", "杭州"),
        ("腾讯", "位于", "深圳"),
        ("百度", "位于", "北京"),
        ("马云", "创立", "阿里巴巴"),
        ("马化腾", "创立", "腾讯"),
        ("李彦宏", "创立", "百度"),
        ("张三", "居住在", "杭州"),
        ("王五", "居住在", "深圳")
    ]

    for s, p, o in triples:
        dataset.add_triple(s, p, o)

    # 转换为PyG数据
    data = dataset.to_pyg_data()

    print(f"\n数据集统计:")
    print(f"  节点数: {data.num_nodes}")
    print(f"  边数: {data.num_edges}")
    print(f"  特征维度: {data.num_features}")
    print(f"  类别数: {len(dataset.type_to_id)}")
    print(f"  类别: {list(dataset.type_to_id.keys())}")

    # 创建模型
    model = SimpleGCN(
        num_features=data.num_features,
        hidden_channels=16,
        num_classes=len(dataset.type_to_id)
    )

    optimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)

    # 训练模型
    train_gnn(model, data, optimizer, epochs=200)

    # 测试集评估
    test_acc = evaluate(model, data, data.test_mask)
    print(f"\n测试集准确率: {test_acc:.4f}")

    # 预测示例
    print(f"\n预测示例:")
    model.eval()
    with torch.no_grad():
        out = model(data.x, data.edge_index)
        pred = out.argmax(dim=1)

        id_to_type = {v: k for k, v in dataset.type_to_id.items()}

        for entity, entity_id in list(dataset.entity_to_id.items())[:5]:
            true_type = dataset.entity_types[entity]
            pred_type = id_to_type[pred[entity_id].item()]
            correct = "✓" if true_type == pred_type else "✗"
            print(f"  {correct} {entity}: 真实={true_type}, 预测={pred_type}")

    return model, data, dataset


def demo_gat_model():
    """示例：使用GAT模型"""

    print("\n" + "=" * 60)
    print("示例：图注意力网络(GAT)")
    print("=" * 60)

    # 使用相同的数据集
    dataset = KGDataset()

    entities = [
        ("张三", "Person"),
        ("李四", "Person"),
        ("阿里巴巴", "Organization"),
        ("腾讯", "Organization"),
        ("杭州", "Location"),
        ("深圳", "Location")
    ]

    for entity, entity_type in entities:
        dataset.add_entity(entity, entity_type)

    triples = [
        ("张三", "工作于", "阿里巴巴"),
        ("李四", "工作于", "腾讯"),
        ("阿里巴巴", "位于", "杭州"),
        ("腾讯", "位于", "深圳")
    ]

    for s, p, o in triples:
        dataset.add_triple(s, p, o)

    data = dataset.to_pyg_data()

    # 创建GAT模型
    model = SimpleGAT(
        num_features=data.num_features,
        hidden_channels=8,
        num_classes=len(dataset.type_to_id),
        heads=4
    )

    optimizer = torch.optim.Adam(model.parameters(), lr=0.005, weight_decay=5e-4)

    # 训练
    train_gnn(model, data, optimizer, epochs=100)

    # 评估
    test_acc = evaluate(model, data, data.test_mask)
    print(f"\nGAT测试集准确率: {test_acc:.4f}")


# ===== 5. 节点嵌入可视化 =====

def visualize_embeddings(model, data, dataset):
    """可视化节点嵌入"""
    print("\n" + "=" * 60)
    print("节点嵌入可视化")
    print("=" * 60)

    model.eval()

    with torch.no_grad():
        # 获取中间层的嵌入
        x = model.conv1(data.x, data.edge_index)
        embeddings = x.numpy()

    # 使用t-SNE降维
    from sklearn.manifold import TSNE
    import matplotlib.pyplot as plt

    tsne = TSNE(n_components=2, random_state=42)
    embeddings_2d = tsne.fit_transform(embeddings)

    # 绘制
    plt.figure(figsize=(10, 8))

    id_to_type = {v: k for k, v in dataset.type_to_id.items()}
    colors = ['red', 'blue', 'green']

    for i, (entity, entity_id) in enumerate(dataset.entity_to_id.items()):
        entity_type = dataset.entity_types[entity]
        type_id = dataset.type_to_id[entity_type]

        plt.scatter(
            embeddings_2d[entity_id, 0],
            embeddings_2d[entity_id, 1],
            c=colors[type_id],
            label=entity_type if i < 3 else "",
            s=100
        )

        plt.annotate(
            entity,
            (embeddings_2d[entity_id, 0], embeddings_2d[entity_id, 1]),
            fontsize=8
        )

    plt.legend()
    plt.title("GNN节点嵌入可视化")
    plt.savefig("gnn_embeddings.png", dpi=300, bbox_inches='tight')
    print("可视化已保存到: gnn_embeddings.png")
    plt.close()


# ===== 6. 实际应用：链接预测 =====

def demo_link_prediction():
    """示例：链接预测"""

    print("\n" + "=" * 60)
    print("示例：链接预测")
    print("=" * 60)

    # 创建数据集
    dataset = KGDataset()

    entities = [
        ("张三", "Person"),
        ("李四", "Person"),
        ("阿里巴巴", "Organization"),
        ("杭州", "Location")
    ]

    for entity, entity_type in entities:
        dataset.add_entity(entity, entity_type)

    # 已知关系
    known_triples = [
        ("张三", "工作于", "阿里巴巴"),
        ("阿里巴巴", "位于", "杭州")
    ]

    for s, p, o in known_triples:
        dataset.add_triple(s, p, o)

    data = dataset.to_pyg_data()

    # 训练模型
    model = SimpleGCN(
        num_features=data.num_features,
        hidden_channels=16,
        num_classes=len(dataset.type_to_id)
    )

    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
    train_gnn(model, data, optimizer, epochs=100)

    # 预测新链接
    print(f"\n预测新链接:")
    model.eval()

    with torch.no_grad():
        # 获取节点嵌入
        x = model.conv1(data.x, data.edge_index)

        # 计算节点对的相似度
        zhang_id = dataset.entity_to_id["张三"]
        hangzhou_id = dataset.entity_to_id["杭州"]

        similarity = F.cosine_similarity(
            x[zhang_id].unsqueeze(0),
            x[hangzhou_id].unsqueeze(0)
        )

        print(f"  张三 - 杭州 相似度: {similarity.item():.4f}")
        print(f"  预测: 张三可能 '居住在' 杭州")


# ===== 7. 主函数 =====

if __name__ == "__main__":
    # 检查PyTorch Geometric是否安装
    try:
        import torch_geometric
        print("PyTorch Geometric已安装")
    except ImportError:
        print("请安装PyTorch Geometric:")
        print("pip install torch-geometric")
        exit(1)

    # 示例1：实体类型预测
    model, data, dataset = demo_entity_type_prediction()

    # 示例2：GAT模型
    # demo_gat_model()

    # 示例3：节点嵌入可视化
    try:
        visualize_embeddings(model, data, dataset)
    except ImportError:
        print("\n跳过可视化（需要安装sklearn和matplotlib）")

    # 示例4：链接预测
    demo_link_prediction()

    print("\n" + "=" * 60)
    print("所有示例完成！")
    print("=" * 60)
```

---

## 运行输出示例

```
PyTorch Geometric已安装

============================================================
示例：知识图谱实体类型预测
============================================================

数据集统计:
  节点数: 12
  边数: 11
  特征维度: 12
  类别数: 3
  类别: ['Person', 'Organization', 'Location']

============================================================
开始训练GNN模型
============================================================
Epoch   0 | Loss: 1.0986 | Train Acc: 0.2857 | Val Acc: 0.5000
Epoch  20 | Loss: 0.8234 | Train Acc: 0.7143 | Val Acc: 0.5000
Epoch  40 | Loss: 0.5123 | Train Acc: 0.8571 | Val Acc: 1.0000
Epoch  60 | Loss: 0.3456 | Train Acc: 1.0000 | Val Acc: 1.0000
Epoch  80 | Loss: 0.2345 | Train Acc: 1.0000 | Val Acc: 1.0000
Epoch 100 | Loss: 0.1678 | Train Acc: 1.0000 | Val Acc: 1.0000
Epoch 120 | Loss: 0.1234 | Train Acc: 1.0000 | Val Acc: 1.0000
Epoch 140 | Loss: 0.0923 | Train Acc: 1.0000 | Val Acc: 1.0000
Epoch 160 | Loss: 0.0712 | Train Acc: 1.0000 | Val Acc: 1.0000
Epoch 180 | Loss: 0.0567 | Train Acc: 1.0000 | Val Acc: 1.0000

最佳验证准确率: 1.0000
============================================================

测试集准确率: 1.0000

预测示例:
  ✓ 张三: 真实=Person, 预测=Person
  ✓ 李四: 真实=Person, 预测=Person
  ✓ 王五: 真实=Person, 预测=Person
  ✓ 阿里巴巴: 真实=Organization, 预测=Organization
  ✓ 腾讯: 真实=Organization, 预测=Organization

============================================================
节点嵌入可视化
============================================================
可视化已保存到: gnn_embeddings.png

============================================================
示例：链接预测
============================================================

开始训练GNN模型...
(训练过程省略)

预测新链接:
  张三 - 杭州 相似度: 0.8234
  预测: 张三可能 '居住在' 杭州

============================================================
所有示例完成！
============================================================
```

---

## 关键洞察

### 1. GNN的核心思想

```python
# 消息传递机制
for layer in gnn_layers:
    # 1. 聚合邻居信息
    neighbor_features = aggregate(node.neighbors)

    # 2. 更新节点特征
    node.features = update(node.features, neighbor_features)

# 节点从邻居学习信息
```

### 2. GCN vs GAT

| 特性 | GCN | GAT |
|------|-----|-----|
| **聚合方式** | 平均聚合 | 注意力加权 |
| **邻居权重** | 相同 | 不同（学习） |
| **性能** | 快 | 慢但更准确 |
| **适用场景** | 均匀图 | 异构图 |

### 3. 在知识图谱中的应用

- **实体类型预测**：分类任务
- **链接预测**：预测缺失的关系
- **实体对齐**：跨图谱实体匹配
- **关系推理**：推断隐含关系

---

## 扩展练习

### 练习1：多关系GNN

实现支持多种关系类型的GNN（R-GCN）。

### 练习2：时序GNN

实现时序图神经网络，处理动态知识图谱。

### 练习3：异构图

实现异构图神经网络（HGT），处理多种节点和边类型。

---

## 总结

**核心收获：**
1. 理解GNN的消息传递机制
2. 掌握PyTorch Geometric的使用
3. 学会将GNN应用于知识图谱
4. 理解节点分类和链接预测

**实际应用：**
- 实体类型预测
- 关系推理
- 知识图谱补全
- 实体对齐

**关键洞察：**
- GNN通过邻居聚合学习节点表示
- GAT使用注意力机制提升性能
- GNN适合知识图谱的各种任务
- 节点嵌入可用于下游任务

---

**完成！** 所有实战代码场景已生成。
