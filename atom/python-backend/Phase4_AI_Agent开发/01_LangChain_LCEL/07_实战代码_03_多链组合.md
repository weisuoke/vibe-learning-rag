# 实战代码 03 - 多链组合

> 并行执行、条件分支的复杂链实现

---

## 场景1：并行执行多个任务

### 需求

同时执行多个独立任务，提升性能。

---

### 完整代码

```python
"""
场景1：并行执行多个任务
演示：RunnableParallel + 性能对比
"""

import os
import time
import asyncio
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

load_dotenv()

# ===== 1. 定义三个独立的链 =====
print("=== 定义三个独立的链 ===")

llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.7)
parser = StrOutputParser()

# 链1：总结
summary_chain = (
    ChatPromptTemplate.from_template("用一句话总结：{text}")
    | llm
    | parser
)

# 链2：提取关键词
keywords_chain = (
    ChatPromptTemplate.from_template("提取3个关键词：{text}")
    | llm
    | parser
)

# 链3：情感分析
sentiment_chain = (
    ChatPromptTemplate.from_template("分析情感（positive/negative/neutral）：{text}")
    | llm
    | parser
)

# ===== 2. 串行执行（慢） =====
print("\n=== 串行执行 ===")

text = "LangChain LCEL 是一种强大的表达式语言，让 AI 应用开发变得简单高效。"

start = time.time()
summary = summary_chain.invoke({"text": text})
keywords = keywords_chain.invoke({"text": text})
sentiment = sentiment_chain.invoke({"text": text})
serial_time = time.time() - start

print(f"串行耗时: {serial_time:.1f}秒")
print(f"总结: {summary}")
print(f"关键词: {keywords}")
print(f"情感: {sentiment}")

# ===== 3. 并行执行（快） =====
print("\n=== 并行执行 ===")

# 使用字典语法自动并行
parallel_chain = {
    "summary": summary_chain,
    "keywords": keywords_chain,
    "sentiment": sentiment_chain
}

async def run_parallel():
    start = time.time()
    result = await parallel_chain.ainvoke({"text": text})
    parallel_time = time.time() - start

    print(f"并行耗时: {parallel_time:.1f}秒")
    print(f"总结: {result['summary']}")
    print(f"关键词: {result['keywords']}")
    print(f"情感: {result['sentiment']}")
    print(f"\n性能提升: {serial_time / parallel_time:.1f}x")

asyncio.run(run_parallel())
```

**运行输出示例**：
```
=== 定义三个独立的链 ===

=== 串行执行 ===
串行耗时: 6.2秒
总结: LCEL 是让 AI 应用开发更简单的表达式语言
关键词: LangChain, LCEL, AI应用
情感: positive

=== 并行执行 ===
并行耗时: 2.1秒
总结: LCEL 是让 AI 应用开发更简单的表达式语言
关键词: LangChain, LCEL, AI应用
情感: positive

性能提升: 3.0x
```

---

## 场景2：条件路由

### 需求

根据输入条件选择不同的处理链。

---

### 完整代码

```python
"""
场景2：条件路由
演示：RunnableBranch + 根据条件选择链
"""

import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnableBranch

load_dotenv()

# ===== 1. 定义不同复杂度的链 =====
print("=== 定义不同复杂度的链 ===")

llm_fast = ChatOpenAI(model="gpt-3.5-turbo", temperature=0)
llm_smart = ChatOpenAI(model="gpt-4", temperature=0.7)
parser = StrOutputParser()

# 简单链：快速回答
simple_chain = (
    ChatPromptTemplate.from_template("简单回答（一句话）：{question}")
    | llm_fast
    | parser
)

# 普通链：详细回答
normal_chain = (
    ChatPromptTemplate.from_template("详细回答：{question}")
    | llm_fast
    | parser
)

# 复杂链：深入分析
complex_chain = (
    ChatPromptTemplate.from_template("深入分析并举例说明：{question}")
    | llm_smart
    | parser
)

# ===== 2. 创建条件路由 =====
print("\n=== 创建条件路由 ===")

router = RunnableBranch(
    (lambda x: len(x["question"]) < 20, simple_chain),
    (lambda x: len(x["question"]) < 100, normal_chain),
    complex_chain
)

# ===== 3. 测试不同长度的问题 =====
print("\n=== 测试条件路由 ===")

questions = [
    "什么是 LCEL？",  # 短问题 → simple_chain
    "请解释 LCEL 的核心概念和主要用途。",  # 中等问题 → normal_chain
    "请详细分析 LangChain LCEL 的设计理念、核心组件、实现原理，以及在实际项目中的应用场景和最佳实践。"  # 长问题 → complex_chain
]

for q in questions:
    print(f"\n问题长度: {len(q)}")
    print(f"问题: {q}")
    answer = router.invoke({"question": q})
    print(f"回答: {answer[:100]}...")
```

---

## 场景3：嵌套并行和条件

### 需求

组合并行执行和条件路由，构建复杂的处理流程。

---

### 完整代码

```python
"""
场景3：嵌套并行和条件
演示：复杂的链组合
"""

import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnableBranch, RunnablePassthrough

load_dotenv()

# ===== 1. 定义基础组件 =====
llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.7)
parser = StrOutputParser()

# ===== 2. 定义分析链 =====
summary_chain = (
    ChatPromptTemplate.from_template("总结：{text}")
    | llm
    | parser
)

keywords_chain = (
    ChatPromptTemplate.from_template("提取关键词：{text}")
    | llm
    | parser
)

# ===== 3. 定义路由链 =====
short_response = (
    ChatPromptTemplate.from_template("简短回答：{text}")
    | llm
    | parser
)

detailed_response = (
    ChatPromptTemplate.from_template("详细回答：{text}")
    | llm
    | parser
)

response_router = RunnableBranch(
    (lambda x: len(x["text"]) < 50, short_response),
    detailed_response
)

# ===== 4. 组合：并行分析 + 条件响应 =====
print("=== 构建复杂链 ===")

complex_chain = {
    "analysis": {
        "summary": summary_chain,
        "keywords": keywords_chain
    },
    "response": response_router,
    "original": RunnablePassthrough()
}

# ===== 5. 测试 =====
print("\n=== 测试复杂链 ===")

texts = [
    "LCEL 很强大",  # 短文本
    "LangChain LCEL 是一种表达式语言，用于构建 AI 应用。它提供了管道操作符、Runnable 接口等核心特性。"  # 长文本
]

for text in texts:
    print(f"\n输入文本: {text}")
    print(f"文本长度: {len(text)}")

    result = complex_chain.invoke({"text": text})

    print(f"\n分析结果:")
    print(f"  总结: {result['analysis']['summary']}")
    print(f"  关键词: {result['analysis']['keywords']}")
    print(f"\n响应: {result['response']}")
```

---

## 总结

### 三个场景对比

| 场景 | 核心特性 | 性能提升 | 适用场景 |
|------|---------|---------|---------|
| **场景1** | 并行执行 | 3倍 | 多个独立任务 |
| **场景2** | 条件路由 | - | 根据条件选择处理方式 |
| **场景3** | 嵌套组合 | - | 复杂业务逻辑 |

---

### 学习检查清单

- [ ] 使用字典语法实现并行执行
- [ ] 理解并行执行的性能优势
- [ ] 使用 RunnableBranch 实现条件路由
- [ ] 组合并行和条件构建复杂链
- [ ] 理解何时使用并行、何时使用串行

---

**版本**: v1.0
**最后更新**: 2026-02-12
