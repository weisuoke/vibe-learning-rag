# 实战代码 01：简单交互工具

> **基于 pi-mono question.ts 示例 + 2025-2026 MCP 交互模式**

---

## 场景描述

实现一个交互式问答工具，让 AI Agent 能够向用户提问并获取选择。这是 AI Agent 中最常见的交互模式之一，用于：

- **需求确认**：在执行操作前确认用户意图
- **选项选择**：从多个方案中让用户选择
- **参数收集**：收集执行任务所需的参数
- **自定义输入**：支持用户输入自定义文本

**2025-2026 行业趋势：**
- **MCP Apps 交互式 UI**：MCP 协议支持在对话中嵌入交互式 HTML UI（来源：[MCP Apps 2026](http://blog.modelcontextprotocol.io/posts/2026-01-26-mcp-apps/)）
- **TypeScript SDK 标准化**：官方 MCP TypeScript SDK 提供 `registerTool` 方法和 Zod 验证（来源：[MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)）
- **自定义渲染**：工具可返回自定义 UI 组件，提升用户体验（来源：[Shopify MCP UI](https://shopify.engineering/mcp-ui-breaking-the-text-wall)）

---

## 完整代码实现

### 基于 pi-mono 的 TypeScript 实现

```typescript
/**
 * 交互式问答工具 - 基于 pi-mono question.ts
 *
 * 功能特性：
 * 1. 支持多选项列表展示
 * 2. 支持自定义文本输入（"Type something..." 选项）
 * 3. 自定义 UI 渲染（选项列表 + 内联编辑器）
 * 4. 键盘导航（↑↓ 选择，Enter 确认，Escape 取消）
 *
 * 2025-2026 最佳实践：
 * - TypeBox schema 验证（替代 Zod，pi-mono 标准）
 * - 自定义 UI 组件（pi-tui 框架）
 * - 主题系统集成
 * - 错误处理与非交互模式支持
 *
 * 参考资料：
 * - pi-mono 源码：packages/coding-agent/examples/extensions/question.ts
 * - MCP Apps 交互模式：http://blog.modelcontextprotocol.io/posts/2026-01-26-mcp-apps/
 * - TypeScript SDK：https://github.com/modelcontextprotocol/typescript-sdk
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import {
  Editor,
  type EditorTheme,
  Key,
  matchesKey,
  Text,
  truncateToWidth
} from "@mariozechner/pi-tui";
import { Type } from "@sinclair/typebox";

// ============================================================================
// 类型定义
// ============================================================================

/**
 * 选项接口 - 支持标签和可选描述
 *
 * 2025-2026 最佳实践：
 * - 使用 TypeScript interface 定义清晰的数据结构
 * - 支持可选描述字段，提升用户体验
 */
interface OptionWithDesc {
  label: string;           // 选项显示文本
  description?: string;    // 可选的描述信息（显示在标签下方）
}

/**
 * 显示选项 - 扩展基础选项，添加特殊标记
 */
type DisplayOption = OptionWithDesc & {
  isOther?: boolean;  // 标记是否为"自定义输入"选项
};

/**
 * 问答详情 - 存储在 tool result details 中
 *
 * 用途：
 * - 记录问题和选项（用于会话历史）
 * - 记录用户答案
 * - 标记是否为自定义输入
 */
interface QuestionDetails {
  question: string;
  options: string[];
  answer: string | null;
  wasCustom?: boolean;
}

// ============================================================================
// Schema 定义 - TypeBox 验证
// ============================================================================

/**
 * 选项 Schema - 使用 TypeBox 定义
 *
 * 2025-2026 趋势：
 * - TypeBox 提供运行时类型验证
 * - 自动生成 JSON Schema 供 LLM 理解
 * - 比 Zod 更轻量，pi-mono 官方选择
 *
 * 参考：https://github.com/sinclairzx81/typebox
 */
const OptionSchema = Type.Object({
  label: Type.String({
    description: "Display label for the option"
  }),
  description: Type.Optional(Type.String({
    description: "Optional description shown below label"
  })),
});

/**
 * 问答参数 Schema
 *
 * LLM 调用工具时需要提供：
 * - question: 要问的问题
 * - options: 选项列表（至少 1 个）
 */
const QuestionParams = Type.Object({
  question: Type.String({
    description: "The question to ask the user"
  }),
  options: Type.Array(OptionSchema, {
    description: "Options for the user to choose from"
  }),
});

// ============================================================================
// 工具注册 - 核心逻辑
// ============================================================================

/**
 * 注册交互式问答工具
 *
 * @param pi - Extension API 实例
 *
 * 工作流程：
 * 1. LLM 调用 question 工具，传入问题和选项
 * 2. 工具显示自定义 UI（选项列表 + 编辑器）
 * 3. 用户选择选项或输入自定义文本
 * 4. 返回结果给 LLM，继续对话
 */
export default function question(pi: ExtensionAPI) {
  pi.registerTool({
    // ========================================================================
    // 工具元数据
    // ========================================================================
    name: "question",
    label: "Question",
    description: "Ask the user a question and let them pick from options. Use when you need user input to proceed.",
    parameters: QuestionParams,

    // ========================================================================
    // 执行函数 - 核心逻辑
    // ========================================================================
    async execute(_toolCallId, params, _signal, _onUpdate, ctx) {
      // ----------------------------------------------------------------------
      // 1. 检查 UI 可用性
      // ----------------------------------------------------------------------
      // 非交互模式（如 CI/CD）下无法显示 UI
      if (!ctx.hasUI) {
        return {
          content: [{
            type: "text",
            text: "Error: UI not available (running in non-interactive mode)"
          }],
          details: {
            question: params.question,
            options: params.options.map((o) => o.label),
            answer: null,
          } as QuestionDetails,
        };
      }

      // ----------------------------------------------------------------------
      // 2. 验证参数
      // ----------------------------------------------------------------------
      if (params.options.length === 0) {
        return {
          content: [{ type: "text", text: "Error: No options provided" }],
          details: {
            question: params.question,
            options: [],
            answer: null
          } as QuestionDetails,
        };
      }

      // ----------------------------------------------------------------------
      // 3. 构建选项列表（添加"自定义输入"选项）
      // ----------------------------------------------------------------------
      const allOptions: DisplayOption[] = [
        ...params.options,
        { label: "Type something.", isOther: true }
      ];

      // ----------------------------------------------------------------------
      // 4. 显示自定义 UI
      // ----------------------------------------------------------------------
      /**
       * ctx.ui.custom() - pi-mono 自定义 UI API
       *
       * 参数：
       * - tui: Terminal UI 实例
       * - theme: 主题配置
       * - kb: 键盘绑定（未使用）
       * - done: 完成回调，传入结果
       *
       * 返回：
       * - render: 渲染函数（返回字符串数组）
       * - handleInput: 输入处理函数
       * - invalidate: 缓存失效函数
       *
       * 2025-2026 最佳实践：
       * - 使用缓存优化渲染性能
       * - 支持键盘导航
       * - 主题系统集成
       */
      const result = await ctx.ui.custom<{
        answer: string;
        wasCustom: boolean;
        index?: number
      } | null>(
        (tui, theme, _kb, done) => {
          // ------------------------------------------------------------------
          // UI 状态
          // ------------------------------------------------------------------
          let optionIndex = 0;           // 当前选中的选项索引
          let editMode = false;          // 是否处于编辑模式
          let cachedLines: string[] | undefined;  // 渲染缓存

          // ------------------------------------------------------------------
          // 编辑器主题配置
          // ------------------------------------------------------------------
          const editorTheme: EditorTheme = {
            borderColor: (s) => theme.fg("accent", s),
            selectList: {
              selectedPrefix: (t) => theme.fg("accent", t),
              selectedText: (t) => theme.fg("accent", t),
              description: (t) => theme.fg("muted", t),
              scrollInfo: (t) => theme.fg("dim", t),
              noMatch: (t) => theme.fg("warning", t),
            },
          };
          const editor = new Editor(tui, editorTheme);

          // ------------------------------------------------------------------
          // 编辑器提交回调
          // ------------------------------------------------------------------
          editor.onSubmit = (value) => {
            const trimmed = value.trim();
            if (trimmed) {
              // 用户输入了自定义文本，返回结果
              done({ answer: trimmed, wasCustom: true });
            } else {
              // 空输入，返回选项列表
              editMode = false;
              editor.setText("");
              refresh();
            }
          };

          // ------------------------------------------------------------------
          // 刷新函数 - 清除缓存并请求重新渲染
          // ------------------------------------------------------------------
          function refresh() {
            cachedLines = undefined;
            tui.requestRender();
          }

          // ------------------------------------------------------------------
          // 输入处理函数 - 键盘事件
          // ------------------------------------------------------------------
          function handleInput(data: string) {
            // 编辑模式下的输入处理
            if (editMode) {
              if (matchesKey(data, Key.escape)) {
                // Escape 键：退出编辑模式
                editMode = false;
                editor.setText("");
                refresh();
                return;
              }
              // 其他按键：传递给编辑器
              editor.handleInput(data);
              refresh();
              return;
            }

            // 选项列表模式下的输入处理
            if (matchesKey(data, Key.up)) {
              // ↑ 键：向上移动
              optionIndex = Math.max(0, optionIndex - 1);
              refresh();
              return;
            }
            if (matchesKey(data, Key.down)) {
              // ↓ 键：向下移动
              optionIndex = Math.min(allOptions.length - 1, optionIndex + 1);
              refresh();
              return;
            }

            if (matchesKey(data, Key.enter)) {
              // Enter 键：确认选择
              const selected = allOptions[optionIndex];
              if (selected.isOther) {
                // 选择了"自定义输入"，进入编辑模式
                editMode = true;
                refresh();
              } else {
                // 选择了普通选项，返回结果
                done({
                  answer: selected.label,
                  wasCustom: false,
                  index: optionIndex + 1
                });
              }
              return;
            }

            if (matchesKey(data, Key.escape)) {
              // Escape 键：取消操作
              done(null);
            }
          }

          // ------------------------------------------------------------------
          // 渲染函数 - 生成 UI 字符串
          // ------------------------------------------------------------------
          function render(width: number): string[] {
            // 使用缓存优化性能
            if (cachedLines) return cachedLines;

            const lines: string[] = [];
            const add = (s: string) => lines.push(truncateToWidth(s, width));

            // 顶部分隔线
            add(theme.fg("accent", "─".repeat(width)));

            // 问题文本
            add(theme.fg("text", ` ${params.question}`));
            lines.push("");

            // 选项列表
            for (let i = 0; i < allOptions.length; i++) {
              const opt = allOptions[i];
              const selected = i === optionIndex;
              const isOther = opt.isOther === true;
              const prefix = selected ? theme.fg("accent", "> ") : "  ";

              // 选项标签
              if (isOther && editMode) {
                add(prefix + theme.fg("accent", `${i + 1}. ${opt.label} ✎`));
              } else if (selected) {
                add(prefix + theme.fg("accent", `${i + 1}. ${opt.label}`));
              } else {
                add(`  ${theme.fg("text", `${i + 1}. ${opt.label}`)}`);
              }

              // 选项描述（如果有）
              if (opt.description) {
                add(`     ${theme.fg("muted", opt.description)}`);
              }
            }

            // 编辑器（编辑模式下显示）
            if (editMode) {
              lines.push("");
              add(theme.fg("muted", " Your answer:"));
              for (const line of editor.render(width - 2)) {
                add(` ${line}`);
              }
            }

            // 底部提示
            lines.push("");
            if (editMode) {
              add(theme.fg("dim", " Enter to submit • Esc to go back"));
            } else {
              add(theme.fg("dim", " ↑↓ navigate • Enter to select • Esc to cancel"));
            }
            add(theme.fg("accent", "─".repeat(width)));

            // 缓存结果
            cachedLines = lines;
            return lines;
          }

          // ------------------------------------------------------------------
          // 返回 UI 组件接口
          // ------------------------------------------------------------------
          return {
            render,
            invalidate: () => {
              cachedLines = undefined;
            },
            handleInput,
          };
        },
      );

      // ----------------------------------------------------------------------
      // 5. 处理结果
      // ----------------------------------------------------------------------
      const simpleOptions = params.options.map((o) => o.label);

      // 用户取消
      if (!result) {
        return {
          content: [{ type: "text", text: "User cancelled the selection" }],
          details: {
            question: params.question,
            options: simpleOptions,
            answer: null
          } as QuestionDetails,
        };
      }

      // 用户输入自定义文本
      if (result.wasCustom) {
        return {
          content: [{ type: "text", text: `User wrote: ${result.answer}` }],
          details: {
            question: params.question,
            options: simpleOptions,
            answer: result.answer,
            wasCustom: true,
          } as QuestionDetails,
        };
      }

      // 用户选择了选项
      return {
        content: [{
          type: "text",
          text: `User selected: ${result.index}. ${result.answer}`
        }],
        details: {
          question: params.question,
          options: simpleOptions,
          answer: result.answer,
          wasCustom: false,
        } as QuestionDetails,
      };
    },

    // ========================================================================
    // 自定义渲染 - renderCall
    // ========================================================================
    /**
     * 渲染工具调用（显示在对话中）
     *
     * 2025-2026 最佳实践：
     * - 使用主题系统统一样式
     * - 显示关键信息（问题 + 选项）
     * - 简洁明了，避免冗余
     */
    renderCall(args, theme) {
      let text = theme.fg("toolTitle", theme.bold("question ")) +
                 theme.fg("muted", args.question);

      const opts = Array.isArray(args.options) ? args.options : [];
      if (opts.length) {
        const labels = opts.map((o: OptionWithDesc) => o.label);
        const numbered = [...labels, "Type something."].map((o, i) => `${i + 1}. ${o}`);
        text += `\n${theme.fg("dim", `  Options: ${numbered.join(", ")}`)}`;
      }

      return new Text(text, 0, 0);
    },

    // ========================================================================
    // 自定义渲染 - renderResult
    // ========================================================================
    /**
     * 渲染工具结果（显示在对话中）
     *
     * 2025-2026 最佳实践：
     * - 区分不同状态（取消、自定义、选择）
     * - 使用颜色和图标提升可读性
     * - 显示选项编号，方便追溯
     */
    renderResult(result, _options, theme) {
      const details = result.details as QuestionDetails | undefined;
      if (!details) {
        const text = result.content[0];
        return new Text(text?.type === "text" ? text.text : "", 0, 0);
      }

      // 用户取消
      if (details.answer === null) {
        return new Text(theme.fg("warning", "Cancelled"), 0, 0);
      }

      // 用户输入自定义文本
      if (details.wasCustom) {
        return new Text(
          theme.fg("success", "✓ ") +
          theme.fg("muted", "(wrote) ") +
          theme.fg("accent", details.answer),
          0,
          0,
        );
      }

      // 用户选择了选项
      const idx = details.options.indexOf(details.answer) + 1;
      const display = idx > 0 ? `${idx}. ${details.answer}` : details.answer;
      return new Text(
        theme.fg("success", "✓ ") + theme.fg("accent", display),
        0,
        0
      );
    },
  });
}
```

---

## 预期输出

### 场景 1：用户选择选项

**LLM 调用：**
```typescript
{
  "tool": "question",
  "params": {
    "question": "Which framework should we use?",
    "options": [
      { "label": "React", "description": "Popular UI library" },
      { "label": "Vue", "description": "Progressive framework" },
      { "label": "Svelte", "description": "Compile-time framework" }
    ]
  }
}
```

**UI 显示：**
```
────────────────────────────────────────
 Which framework should we use?

> 1. React
     Popular UI library
  2. Vue
     Progressive framework
  3. Svelte
     Compile-time framework
  4. Type something.

 ↑↓ navigate • Enter to select • Esc to cancel
────────────────────────────────────────
```

**用户操作：** 按 ↓ 选择 "Vue"，按 Enter 确认

**返回结果：**
```json
{
  "content": [{ "type": "text", "text": "User selected: 2. Vue" }],
  "details": {
    "question": "Which framework should we use?",
    "options": ["React", "Vue", "Svelte"],
    "answer": "Vue",
    "wasCustom": false
  }
}
```

### 场景 2：用户输入自定义文本

**用户操作：** 选择 "Type something."，输入 "Angular"，按 Enter

**返回结果：**
```json
{
  "content": [{ "type": "text", "text": "User wrote: Angular" }],
  "details": {
    "question": "Which framework should we use?",
    "options": ["React", "Vue", "Svelte"],
    "answer": "Angular",
    "wasCustom": true
  }
}
```

---

## 2025-2026 最佳实践总结

### 1. TypeBox Schema 验证

**为什么选择 TypeBox？**
- **运行时验证**：确保 LLM 传入的参数类型正确
- **JSON Schema 生成**：自动生成 LLM 可理解的 schema
- **轻量高效**：比 Zod 更小，pi-mono 官方选择

**参考：** [TypeBox GitHub](https://github.com/sinclairzx81/typebox)

### 2. 自定义 UI 组件

**pi-tui 框架特性：**
- **主题系统**：统一样式，支持深色/浅色模式
- **键盘导航**：↑↓ 选择，Enter 确认，Escape 取消
- **渲染缓存**：优化性能，避免重复渲染

**2025-2026 趋势：**
- **MCP Apps**：支持嵌入 HTML UI（来源：[MCP Apps](http://blog.modelcontextprotocol.io/posts/2026-01-26-mcp-apps/)）
- **交互式组件**：表单、仪表板、可视化（来源：[Shopify MCP UI](https://shopify.engineering/mcp-ui-breaking-the-text-wall)）

### 3. 错误处理

**非交互模式支持：**
```typescript
if (!ctx.hasUI) {
  return {
    content: [{ type: "text", text: "Error: UI not available" }],
    details: { question, options, answer: null }
  };
}
```

**参数验证：**
```typescript
if (params.options.length === 0) {
  return {
    content: [{ type: "text", text: "Error: No options provided" }],
    details: { question, options: [], answer: null }
  };
}
```

### 4. 状态管理

**UI 状态：**
- `optionIndex`：当前选中的选项
- `editMode`：是否处于编辑模式
- `cachedLines`：渲染缓存

**性能优化：**
- 使用缓存避免重复渲染
- 只在状态变化时刷新 UI

---

## 扩展应用场景

### 1. 多步骤向导

```typescript
// 步骤 1：选择操作类型
const action = await askQuestion("What do you want to do?", [
  "Create new file",
  "Edit existing file",
  "Delete file"
]);

// 步骤 2：根据选择执行不同操作
if (action === "Create new file") {
  const filename = await askQuestion("Enter filename:", []);
  // 创建文件...
}
```

### 2. 配置收集

```typescript
// 收集项目配置
const framework = await askQuestion("Choose framework:", ["React", "Vue"]);
const typescript = await askQuestion("Use TypeScript?", ["Yes", "No"]);
const testing = await askQuestion("Testing library:", ["Jest", "Vitest"]);
```

### 3. 确认操作

```typescript
// 危险操作前确认
const confirm = await askQuestion(
  "This will delete all files. Continue?",
  [
    { label: "Yes, delete all", description: "⚠️ Cannot be undone" },
    { label: "No, cancel", description: "Keep files safe" }
  ]
);
```

---

## 参考资料

### Pi-mono 源码
- **question.ts**：`sourcecode/pi-mono/packages/coding-agent/examples/extensions/question.ts`
- **Extension API**：`sourcecode/pi-mono/packages/coding-agent/src/core/extensions/types.ts:335-359`

### 2025-2026 行业标准
- **MCP TypeScript SDK**：https://github.com/modelcontextprotocol/typescript-sdk
- **MCP Apps 交互 UI**：http://blog.modelcontextprotocol.io/posts/2026-01-26-mcp-apps/
- **Shopify MCP UI 实践**：https://shopify.engineering/mcp-ui-breaking-the-text-wall
- **TypeBox Schema**：https://github.com/sinclairzx81/typebox

### 相关文档
- **03_核心概念_01_Tool_Definition接口.md**：工具定义接口详解
- **03_核心概念_05_自定义渲染.md**：renderCall 和 renderResult 详解
- **03_核心概念_07_错误处理.md**：错误处理最佳实践

---

**版本：** v1.0
**最后更新：** 2026-02-21
**作者：** Claude Code
**基于：** pi-mono question.ts + MCP 2025-2026 标准
