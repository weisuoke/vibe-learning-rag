# 核心概念2：带参数的装饰器（装饰器工厂）

> 理解如何创建可配置的装饰器，掌握装饰器工厂模式

---

## 什么是带参数的装饰器？

**带参数的装饰器是返回装饰器的函数，通过参数配置装饰器的行为，也称为装饰器工厂。**

---

## 为什么需要带参数的装饰器？

```python
# 场景：我们想要一个可配置的日志装饰器

# ❌ 问题：基础装饰器无法配置
def log(func):
    def wrapper(*args, **kwargs):
        print(f"[INFO] 调用 {func.__name__}")  # 日志级别固定为 INFO
        return func(*args, **kwargs)
    return wrapper

@log
def get_user():
    pass

# 如果我想要 [DEBUG] 或 [ERROR] 级别怎么办？
```

```python
# ✅ 解决方案：带参数的装饰器
def log(level="INFO"):
    """装饰器工厂：根据 level 参数创建装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"[{level}] 调用 {func.__name__}")
            return func(*args, **kwargs)
        return wrapper
    return decorator

@log(level="DEBUG")
def get_user():
    pass

@log(level="ERROR")
def delete_user():
    pass

get_user()    # [DEBUG] 调用 get_user
delete_user() # [ERROR] 调用 delete_user
```

---

## 三层函数结构

**带参数的装饰器需要三层函数：**

```python
def decorator_factory(param):
    """第1层：装饰器工厂（接收参数）"""
    def decorator(func):
        """第2层：装饰器（接收函数）"""
        def wrapper(*args, **kwargs):
            """第3层：包装函数（执行逻辑）"""
            # 可以访问 param 和 func
            return func(*args, **kwargs)
        return wrapper
    return decorator

@decorator_factory(param="value")
def my_function():
    pass

# 等价于：
# my_function = decorator_factory(param="value")(my_function)
```

**执行流程：**
1. `decorator_factory(param="value")` 返回 `decorator`
2. `decorator(my_function)` 返回 `wrapper`
3. `my_function` 现在指向 `wrapper`

---

## 详细执行流程

```python
def repeat(times):
    """装饰器工厂：重复执行函数 times 次"""
    print(f"[工厂] 创建装饰器，times={times}")

    def decorator(func):
        print(f"[装饰器] 装饰函数 {func.__name__}")

        def wrapper(*args, **kwargs):
            print(f"[包装] 开始执行 {func.__name__}，重复 {times} 次")
            for i in range(times):
                print(f"  第 {i+1} 次执行:")
                result = func(*args, **kwargs)
            return result

        return wrapper
    return decorator

@repeat(times=3)
def greet(name):
    print(f"    Hello, {name}!")

# 定义时输出：
# [工厂] 创建装饰器，times=3
# [装饰器] 装饰函数 greet

print("=" * 50)
greet("Alice")
# 调用时输出：
# [包装] 开始执行 greet，重复 3 次
#   第 1 次执行:
#     Hello, Alice!
#   第 2 次执行:
#     Hello, Alice!
#   第 3 次执行:
#     Hello, Alice!
```

---

## 实战示例1：可配置的日志装饰器

```python
from functools import wraps
from datetime import datetime

def log(level="INFO", include_args=True, include_result=True):
    """
    可配置的日志装饰器

    参数:
        level: 日志级别 (DEBUG, INFO, WARNING, ERROR)
        include_args: 是否记录参数
        include_result: 是否记录返回值
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # 记录函数调用
            log_msg = f"[{timestamp}] [{level}] 调用 {func.__name__}"

            # 可选：记录参数
            if include_args:
                log_msg += f"\n  参数: args={args}, kwargs={kwargs}"

            print(log_msg)

            # 执行函数
            result = func(*args, **kwargs)

            # 可选：记录返回值
            if include_result:
                print(f"  返回: {result}")

            return result
        return wrapper
    return decorator

# 使用不同配置
@log(level="DEBUG", include_args=True, include_result=True)
def add(a, b):
    return a + b

@log(level="INFO", include_args=False, include_result=False)
def get_user():
    return {"id": 1, "name": "Alice"}

add(1, 2)
# 输出：
# [2026-02-11 13:15:30] [DEBUG] 调用 add
#   参数: args=(1, 2), kwargs={}
#   返回: 3

get_user()
# 输出：
# [2026-02-11 13:15:31] [INFO] 调用 get_user
```

---

## 实战示例2：重试装饰器

```python
import time
from functools import wraps

def retry(max_attempts=3, delay=1, exceptions=(Exception,)):
    """
    重试装饰器：函数失败时自动重试

    参数:
        max_attempts: 最大重试次数
        delay: 重试间隔（秒）
        exceptions: 需要重试的异常类型
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(1, max_attempts + 1):
                try:
                    print(f"尝试 {attempt}/{max_attempts}: {func.__name__}")
                    result = func(*args, **kwargs)
                    print(f"成功！")
                    return result
                except exceptions as e:
                    print(f"失败: {e}")
                    if attempt == max_attempts:
                        print(f"达到最大重试次数，放弃")
                        raise
                    print(f"等待 {delay} 秒后重试...")
                    time.sleep(delay)
        return wrapper
    return decorator

# 模拟不稳定的 API 调用
import random

@retry(max_attempts=5, delay=0.5, exceptions=(ConnectionError,))
def call_unstable_api():
    """模拟不稳定的 API（70% 失败率）"""
    if random.random() < 0.7:
        raise ConnectionError("网络连接失败")
    return {"status": "success", "data": "Hello"}

try:
    result = call_unstable_api()
    print(f"最终结果: {result}")
except ConnectionError:
    print("API 调用最终失败")

# 可能的输出：
# 尝试 1/5: call_unstable_api
# 失败: 网络连接失败
# 等待 0.5 秒后重试...
# 尝试 2/5: call_unstable_api
# 失败: 网络连接失败
# 等待 0.5 秒后重试...
# 尝试 3/5: call_unstable_api
# 成功！
# 最终结果: {'status': 'success', 'data': 'Hello'}
```

---

## 实战示例3：限流装饰器

```python
import time
from functools import wraps
from collections import defaultdict

def rate_limit(max_calls=5, time_window=60):
    """
    限流装饰器：限制函数在时间窗口内的调用次数

    参数:
        max_calls: 时间窗口内最大调用次数
        time_window: 时间窗口（秒）
    """
    # 存储每个函数的调用记录
    call_records = defaultdict(list)

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time.time()
            func_name = func.__name__

            # 清理过期的调用记录
            call_records[func_name] = [
                timestamp for timestamp in call_records[func_name]
                if now - timestamp < time_window
            ]

            # 检查是否超过限制
            if len(call_records[func_name]) >= max_calls:
                oldest_call = call_records[func_name][0]
                wait_time = time_window - (now - oldest_call)
                raise Exception(
                    f"限流：{func_name} 在 {time_window} 秒内最多调用 {max_calls} 次，"
                    f"请等待 {wait_time:.1f} 秒"
                )

            # 记录本次调用
            call_records[func_name].append(now)

            # 执行函数
            return func(*args, **kwargs)

        return wrapper
    return decorator

@rate_limit(max_calls=3, time_window=10)
def send_email(to, subject):
    print(f"发送邮件到 {to}: {subject}")
    return "邮件已发送"

# 测试限流
for i in range(5):
    try:
        send_email(f"user{i}@example.com", f"测试邮件 {i}")
    except Exception as e:
        print(f"错误: {e}")
    time.sleep(1)

# 输出：
# 发送邮件到 user0@example.com: 测试邮件 0
# 发送邮件到 user1@example.com: 测试邮件 1
# 发送邮件到 user2@example.com: 测试邮件 2
# 错误: 限流：send_email 在 10 秒内最多调用 3 次，请等待 7.0 秒
# 错误: 限流：send_email 在 10 秒内最多调用 3 次，请等待 6.0 秒
```

---

## 实战示例4：权限检查装饰器

```python
from functools import wraps

def require_permission(permission):
    """
    权限检查装饰器

    参数:
        permission: 需要的权限（如 "admin", "user", "guest"）
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 模拟从上下文获取当前用户权限
            # 实际应用中，这可能来自 JWT token 或 session
            current_user_permission = kwargs.get("user_permission", "guest")

            # 权限等级
            permission_levels = {"guest": 0, "user": 1, "admin": 2}

            required_level = permission_levels.get(permission, 0)
            current_level = permission_levels.get(current_user_permission, 0)

            if current_level < required_level:
                raise PermissionError(
                    f"权限不足：需要 {permission} 权限，当前为 {current_user_permission}"
                )

            return func(*args, **kwargs)
        return wrapper
    return decorator

@require_permission("guest")
def view_public_content():
    return "公开内容"

@require_permission("user")
def view_user_content():
    return "用户内容"

@require_permission("admin")
def delete_user(user_id):
    return f"删除用户 {user_id}"

# 测试不同权限
print(view_public_content(user_permission="guest"))  # ✅ 成功
print(view_user_content(user_permission="user"))     # ✅ 成功

try:
    delete_user(123, user_permission="user")  # ❌ 失败
except PermissionError as e:
    print(f"错误: {e}")
# 输出：错误: 权限不足：需要 admin 权限，当前为 user

print(delete_user(123, user_permission="admin"))  # ✅ 成功
```

---

## 实战示例5：缓存装饰器（带过期时间）

```python
import time
from functools import wraps

def cache_with_ttl(ttl=60):
    """
    带过期时间的缓存装饰器

    参数:
        ttl: 缓存过期时间（秒）
    """
    def decorator(func):
        cache = {}  # {args: (result, timestamp)}

        @wraps(func)
        def wrapper(*args):
            now = time.time()

            # 检查缓存是否存在且未过期
            if args in cache:
                result, timestamp = cache[args]
                if now - timestamp < ttl:
                    print(f"缓存命中: {args} (剩余 {ttl - (now - timestamp):.1f}秒)")
                    return result
                else:
                    print(f"缓存过期: {args}")

            # 计算结果并缓存
            print(f"计算结果: {args}")
            result = func(*args)
            cache[args] = (result, now)
            return result

        return wrapper
    return decorator

@cache_with_ttl(ttl=5)
def expensive_computation(n):
    """模拟耗时计算"""
    time.sleep(1)
    return n * n

# 测试缓存
print(expensive_computation(10))  # 计算结果: (10,)
time.sleep(1)
print(expensive_computation(10))  # 缓存命中: (10,) (剩余 4.0秒)
time.sleep(5)
print(expensive_computation(10))  # 缓存过期: (10,)
```

---

## FastAPI 中的应用

```python
from fastapi import FastAPI, Depends, HTTPException

app = FastAPI()

# FastAPI 的路由装饰器就是带参数的装饰器
@app.get("/users")  # app.get(path="/users")
def get_users():
    return [{"id": 1, "name": "Alice"}]

@app.post("/users", status_code=201)  # 多个参数
def create_user(name: str):
    return {"id": 2, "name": name}

# 依赖注入也是带参数的装饰器
def get_current_user(token: str):
    if token != "valid_token":
        raise HTTPException(status_code=401, detail="Invalid token")
    return {"id": 1, "name": "Alice"}

@app.get("/profile")
def get_profile(user: dict = Depends(get_current_user)):
    return user
```

**FastAPI 装饰器的简化实现：**

```python
class FastAPI:
    def __init__(self):
        self.routes = {}

    def get(self, path: str, status_code: int = 200):
        """带参数的路由装饰器"""
        def decorator(func):
            # 注册路由
            self.routes[path] = {
                "method": "GET",
                "handler": func,
                "status_code": status_code
            }
            return func
        return decorator

app = FastAPI()

@app.get("/users", status_code=200)
def get_users():
    return [{"id": 1, "name": "Alice"}]

# 装饰器执行后：
# app.routes = {
#     "/users": {
#         "method": "GET",
#         "handler": get_users,
#         "status_code": 200
#     }
# }
```

---

## 可选参数的装饰器

有时我们希望装饰器既可以带参数，也可以不带参数：

```python
from functools import wraps

def smart_log(func=None, *, level="INFO"):
    """
    智能日志装饰器：可以带参数或不带参数

    用法1：不带参数
    @smart_log
    def my_func(): pass

    用法2：带参数
    @smart_log(level="DEBUG")
    def my_func(): pass
    """
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            print(f"[{level}] 调用 {f.__name__}")
            return f(*args, **kwargs)
        return wrapper

    # 如果 func 不为 None，说明是不带参数的用法
    if func is not None:
        return decorator(func)

    # 否则返回装饰器（带参数的用法）
    return decorator

# 用法1：不带参数
@smart_log
def func1():
    print("func1 执行")

# 用法2：带参数
@smart_log(level="DEBUG")
def func2():
    print("func2 执行")

func1()  # [INFO] 调用 func1
func2()  # [DEBUG] 调用 func2
```

---

## 常见错误

### 错误1：忘记返回装饰器

```python
# ❌ 错误
def bad_repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                func(*args, **kwargs)
        return wrapper
    # 忘记返回 decorator！

# @bad_repeat(3)  # TypeError: 'NoneType' object is not callable
# def greet():
#     print("Hello")
```

### 错误2：参数层级混乱

```python
# ❌ 错误：把参数放在装饰器层
def bad_log(func, level="INFO"):  # 错误：func 和 level 在同一层
    def wrapper(*args, **kwargs):
        print(f"[{level}] {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

# @bad_log(level="DEBUG")  # TypeError: bad_log() missing 1 required positional argument: 'func'
# def my_func():
#     pass
```

```python
# ✅ 正确：参数在工厂层，func 在装饰器层
def good_log(level="INFO"):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"[{level}] {func.__name__}")
            return func(*args, **kwargs)
        return wrapper
    return decorator

@good_log(level="DEBUG")
def my_func():
    pass
```

### 错误3：忘记调用装饰器工厂

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                func(*args, **kwargs)
        return wrapper
    return decorator

# ❌ 错误：忘记调用 repeat()
# @repeat  # TypeError: repeat() missing 1 required positional argument: 'times'
# def greet():
#     print("Hello")

# ✅ 正确：必须调用 repeat(times)
@repeat(3)
def greet():
    print("Hello")
```

---

## 对比：无参数 vs 带参数装饰器

```python
# 无参数装饰器（两层函数）
def simple_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@simple_decorator
def func1():
    pass

# 等价于：
# func1 = simple_decorator(func1)
```

```python
# 带参数装饰器（三层函数）
def param_decorator(param):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    return decorator

@param_decorator(param="value")
def func2():
    pass

# 等价于：
# func2 = param_decorator(param="value")(func2)
```

---

## 总结

**带参数装饰器的核心要点：**

1. **三层结构**：工厂 → 装饰器 → 包装函数
2. **执行顺序**：工厂(参数) → 装饰器(函数) → 包装函数(调用)
3. **闭包访问**：wrapper 可以访问 param 和 func
4. **配置灵活**：通过参数配置装饰器行为
5. **常见应用**：日志、重试、限流、权限、缓存

**在 AI Agent 开发中的应用：**
- FastAPI 路由配置（路径、方法、状态码）
- 权限检查（不同权限级别）
- 限流控制（不同限流策略）
- 重试机制（不同重试次数和间隔）
- 缓存策略（不同过期时间）

**下一步学习：**
- 核心概念3：类装饰器（基于类的装饰器）
- 实战代码：完整的 FastAPI 应用示例
