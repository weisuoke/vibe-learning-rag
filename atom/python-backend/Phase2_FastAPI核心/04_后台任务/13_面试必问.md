# 面试必问

> 掌握后台任务的高频面试题和出彩回答

---

## 问题1："FastAPI 的 BackgroundTasks 和 Celery 有什么区别？什么时候用哪个？"

### 普通回答（❌ 不出彩）

"BackgroundTasks 是 FastAPI 内置的，Celery 是独立的任务队列。BackgroundTasks 简单，Celery 功能强大。"

### 出彩回答（✅ 推荐）

> **BackgroundTasks 和 Celery 的区别可以从三个层面理解：**
>
> **1. 架构层面：**
> - BackgroundTasks 是**进程内**的后台任务，与 FastAPI 应用运行在同一进程中，无需额外服务
> - Celery 是**分布式**任务队列，需要独立的 Worker 进程和消息代理（Redis/RabbitMQ）
>
> **2. 可靠性层面：**
> - BackgroundTasks 的任务与请求生命周期绑定，如果服务器重启，任务会丢失，没有重试机制
> - Celery 的任务持久化到消息队列，支持重试、超时、优先级等高级特性
>
> **3. 适用场景：**
> - BackgroundTasks 适合**短时间（< 30秒）、失败可接受**的任务，如发送邮件、记录日志
> - Celery 适合**长时间、关键任务**，如视频转码、模型训练、定时任务
>
> **在 AI Agent 开发中的实践：**
> - 用户上传文档后生成 Embedding（10秒）→ BackgroundTasks
> - 批量处理大量文档（几分钟）→ Celery
> - 对话日志记录（1秒）→ BackgroundTasks
> - 模型微调训练（几小时）→ Celery
>
> **选择标准：**
> ```python
> if 任务时间 < 30秒 and 失败可接受:
>     使用 BackgroundTasks
> else:
>     使用 Celery
> ```

### 为什么这个回答出彩？

1. ✅ **多层次解释**：从架构、可靠性、场景三个维度对比
2. ✅ **具体例子**：给出 AI Agent 开发中的实际应用场景
3. ✅ **决策标准**：提供清晰的选择标准，展示实战经验
4. ✅ **技术深度**：提到进程内 vs 分布式、持久化、重试等关键概念

---

## 问题2："后台任务是如何执行的？它会阻塞其他请求吗？"

### 普通回答（❌ 不出彩）

"后台任务在响应返回后执行，不会阻塞请求。"

### 出彩回答（✅ 推荐）

> **后台任务的执行机制可以分为三个阶段：**
>
> **1. 添加阶段（请求处理中）：**
> ```python
> @app.post("/action")
> async def action(background_tasks: BackgroundTasks):
>     background_tasks.add_task(task_func)  # 只是添加到队列
>     return {"status": "ok"}  # 立即返回
> ```
> 此时任务只是被添加到一个内部队列，还没有执行。
>
> **2. 响应返回阶段：**
> FastAPI 将 HTTP 响应发送给客户端，客户端收到响应。
>
> **3. 任务执行阶段（响应后）：**
> FastAPI 在后台线程池中**顺序执行**队列中的任务。
>
> **关于阻塞的问题：**
> - 后台任务**不会阻塞 Web 工作线程**，因为它们在独立的线程池中执行
> - 但如果后台任务是 CPU 密集型（如大量计算），会占用 CPU 资源，间接影响性能
> - 如果后台任务是 I/O 密集型（如网络请求），使用 `async def` 可以避免阻塞
>
> **实际影响：**
> ```python
> # CPU 密集型任务（会影响性能）
> def heavy_computation():
>     result = 0
>     for i in range(100000000):
>         result += i
>     return result
>
> # I/O 密集型任务（不会阻塞）
> async def send_email():
>     async with httpx.AsyncClient() as client:
>         await client.post("https://api.email.com/send")
> ```
>
> **在生产环境中：**
> - 监控后台任务的执行时间
> - CPU 密集型任务应该用 Celery 分离到独立的 Worker
> - 使用异步任务（`async def`）处理 I/O 操作

### 为什么这个回答出彩？

1. ✅ **分阶段解释**：清晰展示任务的生命周期
2. ✅ **深入原理**：提到线程池、CPU vs I/O 密集型
3. ✅ **代码示例**：用代码说明不同类型任务的影响
4. ✅ **生产实践**：给出监控和优化建议

---

## 问题3："如果后台任务失败了怎么办？如何保证任务的可靠性？"

### 普通回答（❌ 不出彩）

"后台任务失败了就失败了，可以加 try-except 捕获异常。"

### 出彩回答（✅ 推荐）

> **后台任务的可靠性需要从三个层面保障：**
>
> **1. 错误处理层：**
> ```python
> import logging
> from functools import wraps
>
> logger = logging.getLogger(__name__)
>
> def safe_background_task(func):
>     """装饰器：为后台任务添加错误处理"""
>     @wraps(func)
>     async def wrapper(*args, **kwargs):
>         try:
>             if asyncio.iscoroutinefunction(func):
>                 return await func(*args, **kwargs)
>             else:
>                 return func(*args, **kwargs)
>         except Exception as e:
>             logger.error(f"后台任务失败: {func.__name__}, 错误: {e}")
>             # 记录失败任务到数据库
>             await save_failed_task(func.__name__, args, kwargs, str(e))
>     return wrapper
> ```
>
> **2. 监控层：**
> - 记录任务执行时间、成功率、失败原因
> - 使用结构化日志（如 structlog）便于分析
> - 设置告警：失败率超过阈值时通知
>
> **3. 重试层：**
> ```python
> async def retry_failed_tasks():
>     """定期重试失败的任务"""
>     failed_tasks = await get_failed_tasks()
>     for task in failed_tasks:
>         if task.retry_count < 3:
>             try:
>                 await execute_task(task)
>                 await mark_task_success(task.id)
>             except Exception:
>                 await increment_retry_count(task.id)
> ```
>
> **BackgroundTasks vs Celery 的可靠性对比：**
>
> | 特性 | BackgroundTasks | Celery |
> |------|----------------|--------|
> | 任务持久化 | ❌ 无 | ✅ 持久化到消息队列 |
> | 自动重试 | ❌ 无 | ✅ 内置重试机制 |
> | 失败恢复 | ❌ 服务重启丢失 | ✅ 服务重启后继续 |
> | 适用场景 | 失败可接受的任务 | 关键任务 |
>
> **在 AI Agent 开发中的实践：**
> - 对话日志记录失败 → 可接受，用 BackgroundTasks
> - 文档 Embedding 生成失败 → 不可接受，用 Celery + 重试
> - 邮件发送失败 → 记录到数据库，定期重试

### 为什么这个回答出彩？

1. ✅ **系统化方案**：从错误处理、监控、重试三个层面保障可靠性
2. ✅ **代码实现**：提供装饰器和重试机制的具体实现
3. ✅ **对比分析**：清晰对比 BackgroundTasks 和 Celery 的可靠性
4. ✅ **实战经验**：根据场景选择不同的可靠性策略

---

## 问题4："后台任务可以访问数据库连接吗？需要注意什么？"

### 普通回答（❌ 不出彩）

"可以访问，但要注意连接可能已经关闭。"

### 出彩回答（✅ 推荐）

> **后台任务访问数据库的核心问题是：请求作用域的资源管理。**
>
> **错误做法：**
> ```python
> @app.post("/create-user")
> async def create_user(
>     email: str,
>     background_tasks: BackgroundTasks,
>     db: Session = Depends(get_db)  # 请求作用域
> ):
>     user = User(email=email)
>     db.add(user)
>     db.commit()
>
>     # ❌ 错误：db 在后台任务执行时可能已关闭
>     background_tasks.add_task(send_welcome_email, user, db)
>     return {"user_id": user.id}
> ```
>
> **为什么错？**
> - `get_db()` 依赖注入的 Session 是**请求作用域**的
> - 响应返回后，依赖注入的清理逻辑会执行（`finally: db.close()`）
> - 后台任务执行时，db 已经关闭
>
> **正确做法1：传递数据，不传递资源**
> ```python
> def send_welcome_email(user_id: int):
>     # 在后台任务内部创建新的数据库连接
>     db = SessionLocal()
>     try:
>         user = db.query(User).filter(User.id == user_id).first()
>         send_email(user.email, "欢迎注册")
>     finally:
>         db.close()
>
> @app.post("/create-user")
> async def create_user(
>     email: str,
>     background_tasks: BackgroundTasks,
>     db: Session = Depends(get_db)
> ):
>     user = User(email=email)
>     db.add(user)
>     db.commit()
>
>     # ✅ 正确：只传递 user_id
>     background_tasks.add_task(send_welcome_email, user.id)
>     return {"user_id": user.id}
> ```
>
> **正确做法2：使用依赖注入工厂**
> ```python
> def create_background_task_with_db(func):
>     """创建带数据库连接的后台任务"""
>     def wrapper(*args, **kwargs):
>         db = SessionLocal()
>         try:
>             return func(db, *args, **kwargs)
>         finally:
>             db.close()
>     return wrapper
>
> @create_background_task_with_db
> def send_welcome_email(db: Session, user_id: int):
>     user = db.query(User).filter(User.id == user_id).first()
>     send_email(user.email, "欢迎注册")
> ```
>
> **核心原则：**
> 1. 后台任务应该是**自包含**的
> 2. 传递数据（ID、值），不传递资源（连接、Session）
> 3. 后台任务内部管理自己的资源生命周期

### 为什么这个回答出彩？

1. ✅ **问题根源**：解释请求作用域和资源生命周期的关系
2. ✅ **对比示例**：展示错误和正确的做法
3. ✅ **多种方案**：提供两种正确实现方式
4. ✅ **设计原则**：总结自包含的设计原则

---

## 快速参考：面试要点

| 问题类型 | 关键点 |
|---------|--------|
| BackgroundTasks vs Celery | 架构、可靠性、场景 |
| 执行机制 | 三阶段、线程池、CPU vs I/O |
| 可靠性保障 | 错误处理、监控、重试 |
| 数据库访问 | 请求作用域、自包含原则 |

---

**版本：** v1.0
**最后更新：** 2026-02-11
