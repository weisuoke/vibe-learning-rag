# 07_实战代码_01_数据处理与转换

> **本文档提供 RunnableLambda 在数据处理与转换场景中的完整实战代码。**

---

## 场景 1：文本预处理管道

### 需求

清洗用户输入的文本：去除空格、统一大小写、分词、过滤停用词。

### 完整实现

```python
from langchain_core.runnables import RunnableLambda
import re

# 步骤1: 清洗文本
def clean_text(text: str) -> str:
    """去除多余空格和特殊字符"""
    text = text.strip().lower()
    text = re.sub(r'[^\w\s]', '', text)
    text = re.sub(r'\s+', ' ', text)
    return text

# 步骤2: 分词
def tokenize(text: str) -> list[str]:
    """分词"""
    return text.split()

# 步骤3: 过滤停用词
STOP_WORDS = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for'}

def filter_stopwords(tokens: list[str]) -> list[str]:
    """过滤停用词"""
    return [token for token in tokens if token not in STOP_WORDS]

# 步骤4: 词干提取（简化版）
def stem_words(tokens: list[str]) -> list[str]:
    """简单的词干提取"""
    return [token.rstrip('s') if len(token) > 3 else token for token in tokens]

# 组合完整管道
preprocess_pipeline = (
    RunnableLambda(clean_text)
    | RunnableLambda(tokenize)
    | RunnableLambda(filter_stopwords)
    | RunnableLambda(stem_words)
)

# 测试
text = "  The Quick BROWN foxes are running in the forest!  "
result = preprocess_pipeline.invoke(text)
print(result)  # ['quick', 'brown', 'foxe', 'running', 'forest']
```

### 与 LangChain 组件集成

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# 预处理 + LLM 分析
analysis_chain = (
    RunnableLambda(clean_text)
    | RunnableLambda(lambda text: {"text": text})
    | ChatPromptTemplate.from_template("Analyze sentiment: {text}")
    | ChatOpenAI(model="gpt-4")
)

result = analysis_chain.invoke("  This is AMAZING!!!  ")
```

---

## 场景 2：JSON/字典格式转换

### 需求

在不同数据格式之间转换：JSON ↔ 文本 ↔ 字典。

### 完整实现

```python
from langchain_core.runnables import RunnableLambda
import json

# 转换1: 字典 → 文本
def dict_to_text(data: dict) -> str:
    """将字典转换为可读文本"""
    lines = []
    for key, value in data.items():
        if isinstance(value, dict):
            lines.append(f"{key}:")
            for k, v in value.items():
                lines.append(f"  {k}: {v}")
        else:
            lines.append(f"{key}: {value}")
    return "\n".join(lines)

# 转换2: 文本 → 字典
def text_to_dict(text: str) -> dict:
    """将文本转换为字典"""
    result = {}
    current_key = None

    for line in text.split('\n'):
        line = line.strip()
        if not line:
            continue

        if line.endswith(':') and not line.startswith(' '):
            current_key = line[:-1]
            result[current_key] = {}
        elif ':' in line:
            if line.startswith('  ') and current_key:
                key, value = line.strip().split(':', 1)
                result[current_key][key.strip()] = value.strip()
            else:
                key, value = line.split(':', 1)
                result[key.strip()] = value.strip()

    return result

# 转换3: JSON 字符串 → 字典
def json_to_dict(json_str: str) -> dict:
    """解析 JSON 字符串"""
    return json.loads(json_str)

# 转换4: 字典 → JSON 字符串
def dict_to_json(data: dict) -> str:
    """序列化为 JSON"""
    return json.dumps(data, indent=2, ensure_ascii=False)

# 使用示例
data = {
    "name": "Alice",
    "age": "30",
    "address": {
        "city": "NYC",
        "country": "USA"
    }
}

# 字典 → 文本
to_text = RunnableLambda(dict_to_text)
text = to_text.invoke(data)
print(text)
# name: Alice
# age: 30
# address:
#   city: NYC
#   country: USA

# 文本 → 字典
to_dict = RunnableLambda(text_to_dict)
recovered = to_dict.invoke(text)
print(recovered)

# 双向转换链
round_trip = (
    RunnableLambda(dict_to_text)
    | RunnableLambda(text_to_dict)
)
result = round_trip.invoke(data)
assert result == data  # 验证往返转换
```

### 在 RAG 中的应用

```python
from langchain_core.runnables import RunnableLambda
from langchain_openai import ChatOpenAI

# RAG 场景：格式化检索结果
def format_docs(docs: list[dict]) -> str:
    """格式化文档为文本"""
    formatted = []
    for i, doc in enumerate(docs, 1):
        formatted.append(f"Document {i}:")
        formatted.append(f"  Content: {doc['content']}")
        formatted.append(f"  Score: {doc['score']:.2f}")
    return "\n".join(formatted)

def parse_answer(text: str) -> dict:
    """解析 LLM 答案为结构化数据"""
    return {
        "answer": text,
        "length": len(text),
        "word_count": len(text.split())
    }

# RAG 链
rag_chain = (
    RunnableLambda(retrieve_docs)  # 返回 list[dict]
    | RunnableLambda(format_docs)   # 转换为文本
    | ChatPromptTemplate.from_template("Based on:\n{docs}\n\nAnswer: {query}")
    | ChatOpenAI(model="gpt-4")
    | RunnableLambda(lambda msg: msg.content)
    | RunnableLambda(parse_answer)  # 转换为结构化数据
)
```

---

## 场景 3：批量数据映射与过滤

### 需求

批量处理数据：映射、过滤、聚合。

### 完整实现

```python
from langchain_core.runnables import RunnableLambda

# 映射：提取字段
def extract_field(items: list[dict], field: str) -> list:
    """提取指定字段"""
    return [item.get(field) for item in items]

# 过滤：条件筛选
def filter_by_condition(items: list[dict], condition) -> list[dict]:
    """根据条件过滤"""
    return [item for item in items if condition(item)]

# 聚合：统计信息
def aggregate_stats(items: list[dict]) -> dict:
    """计算统计信息"""
    if not items:
        return {"count": 0, "avg": 0}

    values = [item.get("value", 0) for item in items]
    return {
        "count": len(values),
        "sum": sum(values),
        "avg": sum(values) / len(values),
        "min": min(values),
        "max": max(values)
    }

# 使用示例
data = [
    {"name": "Alice", "age": 30, "value": 100},
    {"name": "Bob", "age": 25, "value": 150},
    {"name": "Charlie", "age": 35, "value": 80},
    {"name": "David", "age": 28, "value": 120}
]

# 场景1: 提取名字
extract_names = RunnableLambda(lambda items: extract_field(items, "name"))
names = extract_names.invoke(data)
print(names)  # ['Alice', 'Bob', 'Charlie', 'David']

# 场景2: 过滤年龄 > 28
filter_age = RunnableLambda(
    lambda items: filter_by_condition(items, lambda x: x["age"] > 28)
)
filtered = filter_age.invoke(data)
print(filtered)  # [{'name': 'Alice', ...}, {'name': 'Charlie', ...}]

# 场景3: 计算统计
stats = RunnableLambda(aggregate_stats)
result = stats.invoke(data)
print(result)  # {'count': 4, 'sum': 450, 'avg': 112.5, 'min': 80, 'max': 150}

# 组合管道：过滤 → 统计
pipeline = (
    RunnableLambda(lambda items: filter_by_condition(items, lambda x: x["age"] > 28))
    | RunnableLambda(aggregate_stats)
)
result = pipeline.invoke(data)
print(result)  # 只统计年龄 > 28 的数据
```

### 批量处理优化

```python
from langchain_core.runnables import RunnableLambda

# 批量映射
def batch_transform(items: list[str]) -> list[str]:
    """批量转换"""
    return [item.upper() for item in items]

# 使用 batch 方法
runnable = RunnableLambda(lambda x: x.upper())

# 方式1: 手动循环（慢）
results = [runnable.invoke(item) for item in ["a", "b", "c"]]

# 方式2: 使用 batch（快）
results = runnable.batch(["a", "b", "c"])
print(results)  # ['A', 'B', 'C']

# 批量处理复杂数据
def process_item(item: dict) -> dict:
    """处理单个项目"""
    return {
        "id": item["id"],
        "name": item["name"].upper(),
        "score": item["value"] * 2
    }

processor = RunnableLambda(process_item)
results = processor.batch(data)
```

---

## 实战技巧

### 技巧 1：链式转换

```python
# 多步转换
chain = (
    RunnableLambda(clean_text)
    | RunnableLambda(tokenize)
    | RunnableLambda(filter_stopwords)
    | RunnableLambda(lambda tokens: " ".join(tokens))
)
```

### 技巧 2：条件转换

```python
def conditional_transform(data: dict) -> dict:
    """根据条件选择转换方式"""
    if data.get("type") == "json":
        return json.loads(data["content"])
    elif data.get("type") == "text":
        return {"text": data["content"]}
    else:
        return data

runnable = RunnableLambda(conditional_transform)
```

### 技巧 3：错误处理

```python
def safe_transform(data: dict) -> dict:
    """安全的转换（带错误处理）"""
    try:
        return json.loads(data["content"])
    except json.JSONDecodeError:
        return {"error": "Invalid JSON", "raw": data["content"]}

runnable = RunnableLambda(safe_transform)
```

---

## 完整示例：数据清洗管道

```python
from langchain_core.runnables import RunnableLambda
import re
import json

# 完整的数据清洗管道
def remove_nulls(data: dict) -> dict:
    """移除空值"""
    return {k: v for k, v in data.items() if v is not None}

def normalize_keys(data: dict) -> dict:
    """标准化键名（转小写，替换空格）"""
    return {k.lower().replace(" ", "_"): v for k, v in data.items()}

def validate_types(data: dict) -> dict:
    """验证和转换类型"""
    result = {}
    for key, value in data.items():
        if key.endswith("_id") and isinstance(value, str):
            result[key] = int(value) if value.isdigit() else value
        elif key.endswith("_date"):
            result[key] = value  # 可以添加日期解析
        else:
            result[key] = value
    return result

def add_metadata(data: dict) -> dict:
    """添加元数据"""
    import time
    data["_processed_at"] = time.time()
    data["_version"] = "1.0"
    return data

# 组合完整管道
cleaning_pipeline = (
    RunnableLambda(remove_nulls)
    | RunnableLambda(normalize_keys)
    | RunnableLambda(validate_types)
    | RunnableLambda(add_metadata)
)

# 测试
raw_data = {
    "User ID": "123",
    "User Name": "Alice",
    "Email": None,
    "Created Date": "2024-01-01",
    "Status": "active"
}

cleaned = cleaning_pipeline.invoke(raw_data)
print(json.dumps(cleaned, indent=2))
# {
#   "user_id": 123,
#   "user_name": "Alice",
#   "created_date": "2024-01-01",
#   "status": "active",
#   "_processed_at": 1708387200.0,
#   "_version": "1.0"
# }
```

---

## 总结

### 核心模式

1. **单步转换**: `RunnableLambda(func)`
2. **链式转换**: `func1 | func2 | func3`
3. **批量处理**: `.batch(items)`
4. **错误处理**: try-except + 默认值

### 最佳实践

- 每个函数职责单一
- 使用类型注解
- 添加错误处理
- 测试边界情况

---

## 引用来源

- [LangChain 官方文档](https://python.langchain.com/docs/expression_language/primitives/lambda)
- [LCEL Tutorial (GeeksforGeeks)](https://www.geeksforgeeks.org/langchain-expression-language-lcel/)

---

**版本**: v1.0
**最后更新**: 2026-02-20
