# 09_化骨绵掌

> **学习目标**：通过 10 个两分钟知识卡片，快速复习和巩固核心知识点

---

## 使用说明

**化骨绵掌 = 碎片化学习 + 快速复习**

- 每个卡片 2 分钟阅读
- 独立完整，可单独学习
- 适合通勤、排队等碎片时间
- 总计 20 分钟完整复习

---

## 卡片 1：核心定义（2 分钟）

### RunnablePassthrough

**一句话**：透传输入数据，可通过 assign() 添加新字段

**核心 API**：
```python
from langchain_core.runnables import RunnablePassthrough

# 基础透传
passthrough = RunnablePassthrough()
result = passthrough.invoke("hello")  # 输出: "hello"

# assign 扩展
chain = RunnablePassthrough.assign(
    new_field=lambda x: compute(x)
)
```

**记忆口诀**：
- 透传 = 输入不变
- assign = 添加字段
- 不会丢失原始数据

---

### RunnableLambda

**一句话**：将任意 Python 函数包装为标准 Runnable

**核心 API**：
```python
from langchain_core.runnables import RunnableLambda

# 包装函数
def my_func(x):
    return x.upper()

lambda_runnable = RunnableLambda(my_func)
result = lambda_runnable.invoke("hello")  # 输出: "HELLO"
```

**记忆口诀**：
- Lambda = 函数包装器
- 任何函数都能用
- 自动适配 LCEL 接口

---

## 卡片 2：RAG 标准模式（2 分钟）

### 问题

如何在 RAG 中保留原始查询并添加检索上下文？

### 解决方案

```python
from langchain_core.runnables import RunnablePassthrough

# RAG 链
rag_chain = (
    RunnablePassthrough.assign(
        context=lambda x: retriever.invoke(x["query"])
    )
    | prompt
    | llm
)

# 使用
result = rag_chain.invoke({"query": "什么是 LangChain?"})
```

### 数据流动

```
输入: {"query": "什么是 LangChain?"}
  ↓
assign 后: {"query": "什么是 LangChain?", "context": [doc1, doc2, doc3]}
  ↓
prompt 可以同时访问 query 和 context
```

### 关键点

- ✅ 原始查询保留
- ✅ 检索结果添加
- ✅ prompt 看到完整信息

---

## 卡片 3：assign() 的真实行为（2 分钟）

### 常见误区

**错误理解**：assign 会替换整个输入

```python
# ❌ 错误期望
input_data = {"query": "hello", "user": "alice"}
result = RunnablePassthrough.assign(context="retrieved").invoke(input_data)
# 期望: {"context": "retrieved"}  # 只有 context
```

### 真实行为

**正确理解**：assign 是扩展，不是替换

```python
# ✅ 真实输出
input_data = {"query": "hello", "user": "alice"}
result = RunnablePassthrough.assign(context="retrieved").invoke(input_data)
# 实际: {"query": "hello", "user": "alice", "context": "retrieved"}
# 所有原始字段都保留！
```

### 类比

**JavaScript 展开运算符**：
```javascript
const result = {
    ...input,        // 保留原有属性
    context: "..."   // 添加新属性
}
```

### 记住

- assign = `{...input, **new_fields}`
- 不是替换，是扩展
- 同名字段会被覆盖

---

## 卡片 4：查询改写模式（2 分钟）

### 场景

用户查询太简短，需要扩展为详细查询以提高检索质量

### 实现

```python
from langchain_core.runnables import RunnableLambda, RunnablePassthrough

# 1. 定义改写函数
def rewrite_query(input_dict):
    query = input_dict["query"]
    if len(query) < 10:
        rewritten = f"请详细解释：{query}"
    else:
        rewritten = query
    return {"query": rewritten, "original_query": query}

# 2. 构建链
chain = (
    RunnableLambda(rewrite_query)  # 改写
    | RunnablePassthrough.assign(context=retriever)  # 检索
    | llm
)
```

### 数据流

```
"RAG"
  ↓ rewrite_query
{"query": "请详细解释：RAG", "original_query": "RAG"}
  ↓ assign(context=retriever)
{"query": "请详细解释：RAG", "original_query": "RAG", "context": [...]}
  ↓ llm
答案
```

### 关键点

- Lambda 实现自定义逻辑
- Passthrough 保留所有数据
- 两者配合实现复杂流程

---

## 卡片 5：异步处理（2 分钟）

### 问题

同步函数会阻塞异步链，导致性能下降

### 错误示例

```python
import time

# ❌ 同步函数阻塞
def slow_sync(x):
    time.sleep(5)  # 阻塞整个事件循环
    return x

chain = RunnableLambda(slow_sync) | llm
await chain.ainvoke("input")  # 会阻塞 5 秒
```

### 正确示例

```python
import asyncio

# ✅ 异步函数不阻塞
async def fast_async(x):
    await asyncio.sleep(5)  # 不阻塞事件循环
    return x

chain = RunnableLambda(fast_async) | llm
await chain.ainvoke("input")  # 不会阻塞其他任务
```

### 性能对比

**10 个并发请求，每个耗时 1 秒**：
- 同步版本：10 秒（串行）
- 异步版本：1 秒（并行）
- 性能提升：10 倍

### 记住

- 异步链中必须用异步函数
- 使用 httpx、aiofiles 等异步库
- 避免 time.sleep、requests 等阻塞操作

---

## 卡片 6：错误处理与重试（2 分钟）

### 问题

Lambda 中的异常不会自动重试，需要显式处理

### 方式 1：函数内部处理

```python
def safe_func(x):
    try:
        return risky_operation(x)
    except Exception as e:
        logger.error(f"Error: {e}")
        return fallback_value
```

### 方式 2：使用 with_retry()

```python
from langchain_core.runnables import RunnableLambda

async def risky_api_call(x):
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com/data")
        response.raise_for_status()
        return response.json()

# 添加重试
safe_call = RunnableLambda(risky_api_call).with_retry(
    stop_after_attempt=3,
    wait_exponential_multiplier=1
)
```

### 方式 3：组合使用（推荐）

```python
# 函数内部处理 + with_retry + with_fallbacks
safe_call = (
    RunnableLambda(safe_func)
    .with_retry(stop_after_attempt=3)
    .with_fallbacks([RunnableLambda(fallback_func)])
)
```

### 最佳实践

- 函数内部：处理预期错误
- with_retry：处理临时性错误
- with_fallbacks：处理完全失败

---

## 卡片 7：并行数据增强（2 分钟）

### 场景

同时添加多个字段（检索结果、元数据、统计信息）

### 实现

```python
from datetime import datetime
from langchain_core.runnables import RunnablePassthrough

# 定义辅助函数
def get_metadata(x):
    return {
        "timestamp": datetime.now().isoformat(),
        "user": x.get("user", "anonymous")
    }

def get_stats(x):
    query = x["query"]
    return {
        "query_length": len(query),
        "word_count": len(query.split())
    }

# 同时添加多个字段
chain = RunnablePassthrough.assign(
    context=lambda x: retriever.invoke(x["query"]),
    metadata=get_metadata,
    stats=get_stats
)
```

### 结果

```python
input_data = {"query": "什么是 LangChain?", "user": "alice"}
result = chain.invoke(input_data)

# 输出:
# {
#     "query": "什么是 LangChain?",
#     "user": "alice",
#     "context": [doc1, doc2, doc3],
#     "metadata": {"timestamp": "...", "user": "alice"},
#     "stats": {"query_length": 15, "word_count": 3}
# }
```

### 注意

- assign 中的 lambda 是串行执行的
- 如需并行，使用 RunnableParallel

---

## 卡片 8：类型系统（2 分钟）

### RunnablePassthrough 的类型

```python
from typing import TypeVar

Input = TypeVar("Input")

# 类型签名：Runnable[Input, Input]
# 含义：输入类型 = 输出类型
passthrough: Runnable[dict, dict] = RunnablePassthrough()
```

### RunnableLambda 的类型

```python
# 类型签名：Runnable[Input, Output]
# 含义：输入输出类型由函数决定

def process(x: str) -> int:
    return len(x)

lambda_runnable: Runnable[str, int] = RunnableLambda(process)
```

### 类型推断的优势

```python
# 编译时类型检查
chain = (
    RunnableLambda(lambda x: x.upper())  # str → str
    | RunnableLambda(lambda x: len(x))   # str → int
    | RunnableLambda(lambda x: x * 2)    # int → int
)

# 类型系统知道：
# - 输入类型：str
# - 输出类型：int

# 如果类型不匹配，IDE 会提示错误
```

### 记住

- Passthrough：输入 = 输出
- Lambda：输入输出可不同
- 类型系统帮助发现错误

---

## 卡片 9：性能优化（2 分钟）

### 优化 1：使用异步

```python
# ❌ 同步版本
def sync_fetch(url):
    return requests.get(url).json()

# ✅ 异步版本
async def async_fetch(url):
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.json()

# 性能提升：10x+
```

### 优化 2：批处理

```python
# 批量处理
results = await chain.abatch([
    {"query": "q1"},
    {"query": "q2"},
    {"query": "q3"}
])

# 比逐个调用快 3-5 倍
```

### 优化 3：避免不必要的数据复制

```python
# ✅ assign 只是浅拷贝，不复制值
large_data = {
    "query": "hello",
    "embeddings": np.array([...])  # 1GB
}

result = RunnablePassthrough.assign(context="...").invoke(large_data)
# 内存占用：~1GB（不是 2GB）
```

### 优化 4：缓存

```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def expensive_compute(query):
    # 昂贵的计算
    return result

chain = RunnableLambda(expensive_compute) | llm
```

### 记住

- 异步 > 同步
- 批处理 > 逐个处理
- 浅拷贝不占额外内存
- 缓存减少重复计算

---

## 卡片 10：生产环境最佳实践（2 分钟）

### 1. 完善的错误处理

```python
# 分层错误处理
safe_chain = (
    RunnableLambda(safe_func)           # 函数内部处理
    .with_retry(stop_after_attempt=3)   # 自动重试
    .with_fallbacks([fallback])         # 降级策略
)
```

### 2. 日志和监控

```python
import logging

logger = logging.getLogger(__name__)

def monitored_func(x):
    start = time.time()
    try:
        result = process(x)
        logger.info(f"Success, time: {time.time() - start:.2f}s")
        return result
    except Exception as e:
        logger.error(f"Failed: {e}")
        raise
```

### 3. 使用 LangSmith 追踪

```python
import os

os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_API_KEY"] = "your-api-key"

# 自动记录所有中间步骤
chain.invoke(input_data)
```

### 4. 单元测试

```python
def test_assign_preserves_input():
    chain = RunnablePassthrough.assign(new="value")
    result = chain.invoke({"old": "data"})

    assert "old" in result
    assert "new" in result
    assert result["new"] == "value"
```

### 5. 性能监控

```python
# 监控关键指标
- 平均响应时间
- P95/P99 延迟
- 错误率
- 重试次数
```

### 记住

- 错误处理：分层处理
- 日志：记录关键信息
- 追踪：使用 LangSmith
- 测试：覆盖核心逻辑
- 监控：关注性能指标

---

## 快速复习检查清单

### 基础概念（必须掌握）

- [ ] RunnablePassthrough 的作用
- [ ] RunnableLambda 的作用
- [ ] assign() 的行为（扩展而非替换）
- [ ] RAG 中的标准用法

### 实战技能（能写代码）

- [ ] 构建 RAG 管道
- [ ] 实现查询改写
- [ ] 使用异步函数
- [ ] 添加错误重试

### 进阶理解（生产级）

- [ ] 理解类型系统
- [ ] 性能优化方法
- [ ] 生产环境最佳实践
- [ ] 常见陷阱和解决方案

---

## 学习路径建议

### 第一遍：快速浏览（20 分钟）

- 阅读所有 10 个卡片
- 理解核心概念
- 记住关键 API

### 第二遍：深入理解（1 小时）

- 运行代码示例
- 修改参数观察输出
- 理解数据流动

### 第三遍：实战应用（2 小时）

- 构建完整 RAG 应用
- 实现自定义功能
- 优化性能

### 日常复习（10 分钟）

- 随机选择 5 个卡片
- 快速复习核心知识
- 巩固记忆

---

## 记忆口诀

### 核心功能

```
Passthrough 透传数据，assign 添加字段
Lambda 包装函数，自定义转换逻辑
两者配合使用，构建灵活管道
```

### 常见陷阱

```
assign 是扩展，不是替换
同步函数阻塞，必须用异步
异常不重试，需要显式处理
```

### 最佳实践

```
错误处理分层，日志监控完善
异步批处理，性能提升明显
单元测试覆盖，生产环境稳定
```

---

## 总结

**10 个卡片，20 分钟，掌握核心知识**

1. **核心定义**：Passthrough 透传，Lambda 包装
2. **RAG 模式**：保留查询 + 添加上下文
3. **assign() 行为**：扩展而非替换
4. **查询改写**：Lambda + Passthrough 配合
5. **异步处理**：避免阻塞，提升性能
6. **错误处理**：分层处理，自动重试
7. **并行增强**：同时添加多个字段
8. **类型系统**：编译时检查，减少错误
9. **性能优化**：异步、批处理、缓存
10. **生产实践**：日志、监控、测试

---

**下一步**：
- 如果需要深入理解，阅读 `02_第一性原理.md` 和 `03_核心概念_*.md`
- 如果需要实战练习，查看 `07_实战代码_*.md`
- 如果需要避坑，重读 `06_反直觉点.md`

---

**参考资料**：
- [LangChain 官方文档](https://python.langchain.com/docs/concepts/lcel/) (2025)
- [Building Production-Ready AI Pipelines](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557) (2026)
- [LangChain Best Practices](https://www.swarnendu.de/blog/langchain-best-practices) (2025)

---

**版本**：v1.0
**最后更新**：2026-02-18
**总学习时间**：20 分钟（10 个卡片 × 2 分钟）
