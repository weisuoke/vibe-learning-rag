# 自定义Tool - 核心概念01：Tool定义方式

> 深入理解LangChain提供的4种Tool定义方式及其适用场景

---

## 概述

LangChain提供了4种Tool定义方式，从简单到复杂：

1. **@tool装饰器** - 最简单，推荐80%场景使用
2. **Tool类** - 快速定义，适合简单场景
3. **StructuredTool** - 复杂参数，需要详细验证
4. **BaseTool继承** - 高级定制，完全控制

**选择原则：**
- 优先使用@tool装饰器
- 只有在@tool无法满足需求时才考虑其他方式

---

## 方式1：@tool装饰器（推荐）

### 1.1 基本用法

**最简单的Tool：**
```python
from langchain.tools import tool

@tool
def get_current_time() -> str:
    """获取当前时间"""
    from datetime import datetime
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
```

**关键要素：**
- `@tool`：将函数转换为Tool
- 函数名：`get_current_time` → Tool名称
- 文档字符串：LLM用来理解功能
- 返回类型：必须是`str`

### 1.2 带参数的Tool

```python
@tool
def calculate_sum(a: int, b: int) -> str:
    """计算两个数的和

    Args:
        a: 第一个数字
        b: 第二个数字
    """
    result = a + b
    return f"{a} + {b} = {result}"
```

**参数说明：**
- 类型注解：`a: int, b: int` → LLM知道参数类型
- 文档字符串中的Args：描述每个参数的含义

### 1.3 带参数验证的Tool

```python
from pydantic import BaseModel, Field

class SearchInput(BaseModel):
    """搜索参数"""
    keyword: str = Field(
        description="搜索关键词",
        min_length=1,
        max_length=100
    )
    limit: int = Field(
        default=10,
        description="返回数量",
        ge=1,
        le=50
    )

@tool(args_schema=SearchInput)
def search_products(keyword: str, limit: int = 10) -> str:
    """搜索产品数据库

    根据关键词搜索产品，返回匹配的产品列表
    """
    results = [
        f"产品{i}: 包含'{keyword}'的产品"
        for i in range(1, min(limit, 5) + 1)
    ]
    return "\n".join(results)
```

**参数验证：**
- `args_schema=SearchInput`：绑定Pydantic Schema
- `Field`：定义参数的详细规则
- 自动验证：调用前自动验证参数

### 1.4 异步Tool

```python
import httpx

@tool
async def fetch_weather(city: str) -> str:
    """获取指定城市的天气信息

    Args:
        city: 城市名称，如'北京'、'上海'
    """
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"https://api.weather.com/v1/current",
            params={"city": city}
        )
        data = response.json()
        return f"{city}的天气：{data['weather']}，温度{data['temp']}°C"
```

**异步特性：**
- `async def`：定义异步Tool
- `await`：等待异步操作
- 自动并发：LangChain会自动并发调用异步Tool

### 1.5 自定义Tool名称

```python
@tool("weather_query")
def get_weather(city: str) -> str:
    """获取天气信息"""
    return f"{city}的天气：晴天"

# Tool名称是"weather_query"，而不是"get_weather"
```

### 1.6 返回直接结果

```python
@tool(return_direct=True)
def get_final_answer(answer: str) -> str:
    """返回最终答案，不需要LLM进一步处理

    Args:
        answer: 最终答案
    """
    return answer

# return_direct=True：Tool返回后直接作为最终答案，不再经过LLM
```

### 优点

- ✅ **最简单**：只需添加装饰器
- ✅ **类型安全**：自动从类型注解推断参数类型
- ✅ **灵活**：支持同步/异步、参数验证、自定义名称
- ✅ **可读性好**：代码清晰，易于维护

### 缺点

- ❌ **装饰器限制**：必须是函数，不能是类方法
- ❌ **复杂逻辑**：如果Tool逻辑很复杂，函数会很长

### 适用场景

- ✅ 大多数Tool（80%以上）
- ✅ 简单到中等复杂度的Tool
- ✅ 需要参数验证的Tool
- ✅ 异步Tool

---

## 方式2：Tool类

### 2.1 基本用法

```python
from langchain.tools import Tool

def get_time():
    from datetime import datetime
    return datetime.now().strftime("%H:%M:%S")

get_time_tool = Tool(
    name="get_time",
    func=get_time,
    description="获取当前时间"
)
```

**关键要素：**
- `name`：Tool名称
- `func`：实际执行的函数
- `description`：Tool描述

### 2.2 使用lambda函数

```python
get_time_tool = Tool(
    name="get_time",
    func=lambda: datetime.now().strftime("%H:%M:%S"),
    description="获取当前时间"
)
```

### 2.3 带参数的Tool

```python
def calculate(a: int, b: int) -> str:
    return f"{a} + {b} = {a + b}"

calculator_tool = Tool(
    name="calculator",
    func=calculate,
    description="计算两个数的和"
)
```

### 2.4 异步Tool

```python
async def fetch_data(url: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.text

fetch_tool = Tool(
    name="fetch_data",
    func=fetch_data,
    description="获取URL的内容",
    coroutine=fetch_data  # 异步函数需要指定coroutine
)
```

### 优点

- ✅ **快速定义**：适合简单Tool
- ✅ **灵活**：可以使用lambda或现有函数
- ✅ **无装饰器**：不需要修改原函数

### 缺点

- ❌ **参数验证弱**：没有Pydantic Schema
- ❌ **描述分离**：描述和函数分开，不如@tool清晰
- ❌ **类型推断弱**：需要手动指定参数类型

### 适用场景

- ✅ 简单Tool（无参数或参数简单）
- ✅ 快速原型开发
- ✅ 包装现有函数为Tool

---

## 方式3：StructuredTool

### 3.1 基本用法

```python
from langchain.tools import StructuredTool
from pydantic import BaseModel, Field

class OrderInput(BaseModel):
    """订单查询参数"""
    order_id: str = Field(description="订单ID，格式为ORD-XXXXXX")
    include_items: bool = Field(default=True, description="是否包含商品列表")

def query_order(order_id: str, include_items: bool = True) -> str:
    """查询订单详细信息"""
    order = {"id": order_id, "status": "shipped"}
    if include_items:
        order["items"] = ["商品1", "商品2"]
    return str(order)

query_order_tool = StructuredTool.from_function(
    func=query_order,
    name="query_order",
    description="查询订单详细信息",
    args_schema=OrderInput
)
```

**关键要素：**
- `from_function`：从函数创建Tool
- `args_schema`：Pydantic Schema定义参数
- 自动验证：调用前自动验证参数

### 3.2 复杂参数类型

```python
from typing import List, Optional

class SearchInput(BaseModel):
    """搜索参数"""
    keywords: List[str] = Field(description="搜索关键词列表")
    category: Optional[str] = Field(default=None, description="产品类别")
    min_price: Optional[float] = Field(default=None, ge=0, description="最低价格")
    max_price: Optional[float] = Field(default=None, ge=0, description="最高价格")
    sort_by: str = Field(default="relevance", description="排序方式：relevance, price, date")

def search_products(
    keywords: List[str],
    category: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    sort_by: str = "relevance"
) -> str:
    """搜索产品"""
    filters = []
    if category:
        filters.append(f"类别={category}")
    if min_price:
        filters.append(f"价格>={min_price}")
    if max_price:
        filters.append(f"价格<={max_price}")

    return f"搜索关键词：{', '.join(keywords)}\n筛选条件：{', '.join(filters)}\n排序：{sort_by}"

search_tool = StructuredTool.from_function(
    func=search_products,
    name="search_products",
    description="搜索产品数据库",
    args_schema=SearchInput
)
```

### 3.3 嵌套参数

```python
class Address(BaseModel):
    """地址"""
    street: str = Field(description="街道")
    city: str = Field(description="城市")
    zipcode: str = Field(description="邮编")

class OrderInput(BaseModel):
    """订单参数"""
    user_id: int = Field(description="用户ID")
    items: List[str] = Field(description="商品列表")
    shipping_address: Address = Field(description="收货地址")

def create_order(user_id: int, items: List[str], shipping_address: dict) -> str:
    """创建订单"""
    return f"订单创建成功：用户{user_id}，商品{len(items)}件，地址{shipping_address['city']}"

create_order_tool = StructuredTool.from_function(
    func=create_order,
    name="create_order",
    description="创建新订单",
    args_schema=OrderInput
)
```

### 3.4 异步StructuredTool

```python
async def query_database(query: str, limit: int = 10) -> str:
    """查询数据库"""
    # 异步数据库查询
    results = await db.execute(query, limit=limit)
    return str(results)

query_tool = StructuredTool.from_function(
    func=query_database,
    name="query_database",
    description="查询数据库",
    args_schema=QueryInput,
    coroutine=query_database  # 指定异步函数
)
```

### 优点

- ✅ **强大的参数验证**：完整的Pydantic功能
- ✅ **复杂参数**：支持列表、嵌套、可选参数
- ✅ **类型安全**：编译时类型检查
- ✅ **清晰的Schema**：参数结构一目了然

### 缺点

- ❌ **代码量大**：需要定义Schema类
- ❌ **复杂度高**：比@tool复杂

### 适用场景

- ✅ 复杂参数（列表、嵌套、多个可选参数）
- ✅ 需要严格参数验证的Tool
- ✅ 参数结构需要复用的Tool

---

## 方式4：BaseTool继承

### 4.1 基本用法

```python
from langchain.tools import BaseTool
from typing import Optional

class GetWeatherTool(BaseTool):
    name = "get_weather"
    description = "获取指定城市的天气信息"

    def _run(self, city: str) -> str:
        """同步执行"""
        return f"{city}的天气：晴天，25°C"

    async def _arun(self, city: str) -> str:
        """异步执行"""
        # 异步实现
        async with httpx.AsyncClient() as client:
            response = await client.get(f"/weather?city={city}")
            return response.text
```

**关键要素：**
- 继承`BaseTool`
- `name`：Tool名称
- `description`：Tool描述
- `_run`：同步执行方法
- `_arun`：异步执行方法（可选）

### 4.2 带参数验证

```python
from pydantic import Field

class SearchProductsTool(BaseTool):
    name = "search_products"
    description = "搜索产品数据库"

    # 定义参数Schema
    keyword: str = Field(description="搜索关键词")
    limit: int = Field(default=10, ge=1, le=50, description="返回数量")

    def _run(self, keyword: str, limit: int = 10) -> str:
        """执行搜索"""
        results = [f"产品{i}: {keyword}" for i in range(1, limit + 1)]
        return "\n".join(results)
```

### 4.3 带状态的Tool

```python
class DatabaseTool(BaseTool):
    name = "query_database"
    description = "查询数据库"

    # Tool的状态
    connection_string: str
    max_retries: int = 3

    def __init__(self, connection_string: str, **kwargs):
        super().__init__(**kwargs)
        self.connection_string = connection_string
        self.db = self._connect()

    def _connect(self):
        """建立数据库连接"""
        return create_connection(self.connection_string)

    def _run(self, query: str) -> str:
        """执行查询"""
        for attempt in range(self.max_retries):
            try:
                result = self.db.execute(query)
                return str(result)
            except Exception as e:
                if attempt == self.max_retries - 1:
                    return f"查询失败：{str(e)}"
                continue
```

### 4.4 自定义错误处理

```python
class RobustTool(BaseTool):
    name = "robust_tool"
    description = "带错误处理的Tool"

    handle_tool_error = True  # 启用错误处理

    def _run(self, param: str) -> str:
        """执行逻辑"""
        try:
            result = risky_operation(param)
            return result
        except ValueError as e:
            return f"参数错误：{str(e)}"
        except Exception as e:
            return f"执行失败：{str(e)}"

    def _handle_error(self, error: Exception) -> str:
        """自定义错误处理"""
        return f"Tool执行出错：{str(error)}。请检查参数或稍后重试。"
```

### 4.5 带回调的Tool

```python
from langchain.callbacks.manager import CallbackManagerForToolRun

class LoggingTool(BaseTool):
    name = "logging_tool"
    description = "带日志的Tool"

    def _run(
        self,
        param: str,
        run_manager: Optional[CallbackManagerForToolRun] = None
    ) -> str:
        """执行并记录日志"""
        if run_manager:
            run_manager.on_text(f"开始执行：{param}\n")

        result = do_something(param)

        if run_manager:
            run_manager.on_text(f"执行完成：{result}\n")

        return result
```

### 优点

- ✅ **完全控制**：可以自定义所有行为
- ✅ **状态管理**：Tool可以有内部状态
- ✅ **高级功能**：错误处理、回调、日志
- ✅ **复用性**：可以继承和扩展

### 缺点

- ❌ **复杂度最高**：需要理解BaseTool的机制
- ❌ **代码量大**：需要实现多个方法
- ❌ **过度设计**：大多数场景不需要这么复杂

### 适用场景

- ✅ 需要内部状态的Tool（如数据库连接）
- ✅ 需要自定义错误处理的Tool
- ✅ 需要回调和日志的Tool
- ✅ 需要复用和继承的Tool

---

## 4种方式对比

### 对比表

| 维度 | @tool装饰器 | Tool类 | StructuredTool | BaseTool继承 |
|-----|------------|--------|----------------|-------------|
| **复杂度** | ⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **代码量** | 最少 | 少 | 中等 | 最多 |
| **参数验证** | 强（Pydantic） | 弱 | 强（Pydantic） | 强（Pydantic） |
| **类型安全** | 强 | 弱 | 强 | 强 |
| **异步支持** | ✅ | ✅ | ✅ | ✅ |
| **状态管理** | ❌ | ❌ | ❌ | ✅ |
| **错误处理** | 手动 | 手动 | 手动 | 自定义 |
| **回调支持** | ❌ | ❌ | ❌ | ✅ |
| **适用场景** | 80%场景 | 简单Tool | 复杂参数 | 高级定制 |

### 选择流程图

```
需要定义Tool
    ↓
是否需要内部状态？
    ├── 是 → BaseTool继承
    └── 否 ↓
是否需要复杂参数验证？
    ├── 是 → StructuredTool
    └── 否 ↓
是否需要快速原型？
    ├── 是 → Tool类
    └── 否 ↓
使用@tool装饰器（推荐）
```

---

## 实际案例对比

### 案例：订单查询Tool

#### 方式1：@tool装饰器

```python
from langchain.tools import tool
from pydantic import BaseModel, Field

class OrderInput(BaseModel):
    order_id: str = Field(pattern=r'^ORD-\d{6}$')

@tool(args_schema=OrderInput)
def query_order(order_id: str) -> str:
    """查询订单详细信息

    根据订单ID查询订单的完整信息
    """
    order = db.get_order(order_id)
    if not order:
        return f"错误：订单{order_id}不存在"
    return format_order(order)
```

**代码量：** ~15行
**优点：** 简洁、清晰、易维护

#### 方式2：Tool类

```python
from langchain.tools import Tool

def query_order_func(order_id: str) -> str:
    order = db.get_order(order_id)
    if not order:
        return f"错误：订单{order_id}不存在"
    return format_order(order)

query_order_tool = Tool(
    name="query_order",
    func=query_order_func,
    description="查询订单详细信息"
)
```

**代码量：** ~12行
**缺点：** 没有参数验证

#### 方式3：StructuredTool

```python
from langchain.tools import StructuredTool
from pydantic import BaseModel, Field

class OrderInput(BaseModel):
    order_id: str = Field(pattern=r'^ORD-\d{6}$')

def query_order(order_id: str) -> str:
    order = db.get_order(order_id)
    if not order:
        return f"错误：订单{order_id}不存在"
    return format_order(order)

query_order_tool = StructuredTool.from_function(
    func=query_order,
    name="query_order",
    description="查询订单详细信息",
    args_schema=OrderInput
)
```

**代码量：** ~18行
**优点：** 参数验证强，但比@tool复杂

#### 方式4：BaseTool继承

```python
from langchain.tools import BaseTool
from pydantic import Field

class QueryOrderTool(BaseTool):
    name = "query_order"
    description = "查询订单详细信息"

    order_id: str = Field(pattern=r'^ORD-\d{6}$')

    def _run(self, order_id: str) -> str:
        order = db.get_order(order_id)
        if not order:
            return f"错误：订单{order_id}不存在"
        return format_order(order)
```

**代码量：** ~15行
**缺点：** 过度设计，没有必要

### 结论

对于订单查询这种场景，**@tool装饰器**是最佳选择：
- 代码简洁
- 参数验证强
- 易于维护

---

## 最佳实践

### 1. 优先使用@tool装饰器

```python
# ✅ 推荐：大多数场景
@tool
def my_tool(param: str) -> str:
    """Tool描述"""
    return result
```

### 2. 需要参数验证时使用args_schema

```python
# ✅ 推荐：复杂参数
class Input(BaseModel):
    param: str = Field(min_length=1)

@tool(args_schema=Input)
def my_tool(param: str) -> str:
    """Tool描述"""
    return result
```

### 3. 只在必要时使用StructuredTool

```python
# ⚠️ 只在@tool无法满足时使用
tool = StructuredTool.from_function(
    func=my_func,
    args_schema=Input
)
```

### 4. 避免过度使用BaseTool

```python
# ❌ 避免：大多数场景不需要
class MyTool(BaseTool):
    def _run(self, param: str) -> str:
        return result
```

### 5. 异步Tool使用async def

```python
# ✅ 推荐：异步Tool
@tool
async def my_tool(param: str) -> str:
    """Tool描述"""
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.text
```

---

## 总结

### 选择建议

1. **默认选择**：@tool装饰器（80%场景）
2. **快速原型**：Tool类（10%场景）
3. **复杂参数**：StructuredTool（8%场景）
4. **高级定制**：BaseTool继承（2%场景）

### 关键原则

- **简单优先**：能用@tool就不用其他方式
- **按需选择**：根据实际需求选择合适的方式
- **避免过度设计**：不要为了用而用

### 记住

**@tool装饰器是最佳选择，除非你有明确的理由使用其他方式。**
