# 实战代码 02：树形结构构建

> 完整的 TypeScript 树形结构构建实现，从扁平的 JSONL 条目构建树形结构

---

## 代码概览

本文实现完整的树形结构构建器，包括：

1. **类型定义**：树节点和条目类型
2. **映射构建**：建立 ID 和父子关系映射
3. **树构建**：递归构建树形结构
4. **树遍历**：从叶子到根、深度优先、广度优先
5. **树查询**：查找节点、获取子树、获取叶子节点

---

## 完整实现

### 类型定义

```typescript
// types.ts
export interface SessionEntry {
  type: string;
  id: string;
  parentId: string | null;
  timestamp: string;
  content?: string;
  [key: string]: any;
}

export interface TreeNode {
  entry: SessionEntry;
  children: TreeNode[];
  depth?: number;
  label?: string;
}

export interface TreeStats {
  totalNodes: number;
  maxDepth: number;
  leafCount: number;
  branchCount: number;
}
```

### 树构建器

```typescript
// tree-builder.ts
import { SessionEntry, TreeNode } from './types';

export class TreeBuilder {
  private entryMap = new Map<string, SessionEntry>();
  private childrenMap = new Map<string, SessionEntry[]>();
  private entries: SessionEntry[];

  constructor(entries: SessionEntry[]) {
    this.entries = entries;
    this.buildMaps();
  }

  /**
   * 构建 ID 映射和父子关系映射
   */
  private buildMaps(): void {
    // 清空现有映射
    this.entryMap.clear();
    this.childrenMap.clear();

    // 建立 ID 映射
    for (const entry of this.entries) {
      this.entryMap.set(entry.id, entry);
    }

    // 建立父子关系映射
    for (const entry of this.entries) {
      if (entry.parentId !== null) {
        if (!this.childrenMap.has(entry.parentId)) {
          this.childrenMap.set(entry.parentId, []);
        }
        this.childrenMap.get(entry.parentId)!.push(entry);
      }
    }
  }

  /**
   * 获取条目
   */
  getEntry(id: string): SessionEntry | undefined {
    return this.entryMap.get(id);
  }

  /**
   * 获取子节点
   */
  getChildren(id: string): SessionEntry[] {
    return this.childrenMap.get(id) || [];
  }

  /**
   * 获取父节点
   */
  getParent(id: string): SessionEntry | null {
    const entry = this.entryMap.get(id);
    if (!entry || entry.parentId === null) {
      return null;
    }
    return this.entryMap.get(entry.parentId) || null;
  }

  /**
   * 查找根节点
   */
  findRoot(): SessionEntry | null {
    for (const entry of this.entries) {
      if (entry.parentId === null) {
        return entry;
      }
    }
    return null;
  }

  /**
   * 递归构建子树
   */
  buildSubtree(rootId: string, depth: number = 0): TreeNode {
    const entry = this.entryMap.get(rootId);
    if (!entry) {
      throw new Error(`Entry not found: ${rootId}`);
    }

    const children = this.childrenMap.get(rootId) || [];

    return {
      entry,
      children: children.map(child => this.buildSubtree(child.id, depth + 1)),
      depth
    };
  }

  /**
   * 构建完整树
   */
  buildFullTree(): TreeNode | null {
    const root = this.findRoot();
    if (!root) {
      return null;
    }

    return this.buildSubtree(root.id);
  }

  /**
   * 从叶子到根获取路径
   */
  getBranch(fromId: string): SessionEntry[] {
    const branch: SessionEntry[] = [];
    let currentId: string | null = fromId;

    while (currentId !== null) {
      const entry = this.entryMap.get(currentId);
      if (!entry) {
        throw new Error(`Entry not found: ${currentId}`);
      }

      branch.push(entry);
      currentId = entry.parentId;
    }

    return branch.reverse();
  }

  /**
   * 获取所有叶子节点
   */
  getLeaves(): SessionEntry[] {
    const leaves: SessionEntry[] = [];

    for (const entry of this.entries) {
      const children = this.childrenMap.get(entry.id);
      if (!children || children.length === 0) {
        leaves.push(entry);
      }
    }

    return leaves;
  }

  /**
   * 获取树的统计信息
   */
  getStats(): TreeStats {
    const tree = this.buildFullTree();
    if (!tree) {
      return {
        totalNodes: 0,
        maxDepth: 0,
        leafCount: 0,
        branchCount: 0
      };
    }

    let totalNodes = 0;
    let maxDepth = 0;
    let leafCount = 0;
    let branchCount = 0;

    const traverse = (node: TreeNode): void => {
      totalNodes++;
      maxDepth = Math.max(maxDepth, node.depth || 0);

      if (node.children.length === 0) {
        leafCount++;
      } else if (node.children.length > 1) {
        branchCount++;
      }

      for (const child of node.children) {
        traverse(child);
      }
    };

    traverse(tree);

    return {
      totalNodes,
      maxDepth: maxDepth + 1,
      leafCount,
      branchCount
    };
  }

  /**
   * 检查是否存在环路
   */
  hasCircularReference(): boolean {
    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    const dfs = (id: string): boolean => {
      visited.add(id);
      recursionStack.add(id);

      const children = this.childrenMap.get(id) || [];
      for (const child of children) {
        if (!visited.has(child.id)) {
          if (dfs(child.id)) {
            return true;
          }
        } else if (recursionStack.has(child.id)) {
          return true;
        }
      }

      recursionStack.delete(id);
      return false;
    };

    const root = this.findRoot();
    if (!root) {
      return false;
    }

    return dfs(root.id);
  }
}
```

### 树遍历器

```typescript
// tree-traverser.ts
import { TreeNode, SessionEntry } from './types';

export class TreeTraverser {
  /**
   * 深度优先遍历（前序）
   */
  static *depthFirstPreOrder(node: TreeNode): Generator<TreeNode> {
    yield node;

    for (const child of node.children) {
      yield* TreeTraverser.depthFirstPreOrder(child);
    }
  }

  /**
   * 深度优先遍历（后序）
   */
  static *depthFirstPostOrder(node: TreeNode): Generator<TreeNode> {
    for (const child of node.children) {
      yield* TreeTraverser.depthFirstPostOrder(child);
    }

    yield node;
  }

  /**
   * 广度优先遍历
   */
  static *breadthFirst(node: TreeNode): Generator<TreeNode> {
    const queue: TreeNode[] = [node];

    while (queue.length > 0) {
      const current = queue.shift()!;
      yield current;

      for (const child of current.children) {
        queue.push(child);
      }
    }
  }

  /**
   * 查找节点
   */
  static findNode(
    root: TreeNode,
    predicate: (node: TreeNode) => boolean
  ): TreeNode | null {
    for (const node of TreeTraverser.depthFirstPreOrder(root)) {
      if (predicate(node)) {
        return node;
      }
    }
    return null;
  }

  /**
   * 查找所有匹配的节点
   */
  static findAllNodes(
    root: TreeNode,
    predicate: (node: TreeNode) => boolean
  ): TreeNode[] {
    const results: TreeNode[] = [];

    for (const node of TreeTraverser.depthFirstPreOrder(root)) {
      if (predicate(node)) {
        results.push(node);
      }
    }

    return results;
  }

  /**
   * 获取节点路径（从根到节点）
   */
  static getPath(root: TreeNode, targetId: string): TreeNode[] | null {
    const path: TreeNode[] = [];

    const dfs = (node: TreeNode): boolean => {
      path.push(node);

      if (node.entry.id === targetId) {
        return true;
      }

      for (const child of node.children) {
        if (dfs(child)) {
          return true;
        }
      }

      path.pop();
      return false;
    };

    if (dfs(root)) {
      return path;
    }

    return null;
  }

  /**
   * 计算树的高度
   */
  static getHeight(node: TreeNode): number {
    if (node.children.length === 0) {
      return 1;
    }

    let maxChildHeight = 0;
    for (const child of node.children) {
      maxChildHeight = Math.max(maxChildHeight, TreeTraverser.getHeight(child));
    }

    return maxChildHeight + 1;
  }

  /**
   * 获取指定深度的所有节点
   */
  static getNodesAtDepth(root: TreeNode, targetDepth: number): TreeNode[] {
    const nodes: TreeNode[] = [];

    const traverse = (node: TreeNode, currentDepth: number): void => {
      if (currentDepth === targetDepth) {
        nodes.push(node);
        return;
      }

      for (const child of node.children) {
        traverse(child, currentDepth + 1);
      }
    };

    traverse(root, 0);
    return nodes;
  }
}
```

### 树可视化器

```typescript
// tree-visualizer.ts
import { TreeNode } from './types';

export class TreeVisualizer {
  /**
   * ASCII 树形可视化
   */
  static visualize(node: TreeNode, options: {
    showDepth?: boolean;
    showType?: boolean;
    maxContentLength?: number;
  } = {}): string {
    const {
      showDepth = false,
      showType = true,
      maxContentLength = 30
    } = options;

    return this.renderNode(node, '', true, showDepth, showType, maxContentLength);
  }

  private static renderNode(
    node: TreeNode,
    prefix: string,
    isLast: boolean,
    showDepth: boolean,
    showType: boolean,
    maxContentLength: number
  ): string {
    const connector = isLast ? '└── ' : '├── ';
    const label = this.getNodeLabel(node, showDepth, showType, maxContentLength);

    let result = prefix + connector + label + '\n';

    const childPrefix = prefix + (isLast ? '    ' : '│   ');
    const children = node.children;

    for (let i = 0; i < children.length; i++) {
      const isLastChild = i === children.length - 1;
      result += this.renderNode(
        children[i],
        childPrefix,
        isLastChild,
        showDepth,
        showType,
        maxContentLength
      );
    }

    return result;
  }

  private static getNodeLabel(
    node: TreeNode,
    showDepth: boolean,
    showType: boolean,
    maxContentLength: number
  ): string {
    const parts: string[] = [];

    if (showDepth && node.depth !== undefined) {
      parts.push(`[D${node.depth}]`);
    }

    if (showType) {
      parts.push(`[${node.entry.type}]`);
    }

    parts.push(node.entry.id);

    if (node.entry.content) {
      const content = node.entry.content.substring(0, maxContentLength);
      const suffix = node.entry.content.length > maxContentLength ? '...' : '';
      parts.push(`"${content}${suffix}"`);
    }

    return parts.join(' ');
  }

  /**
   * JSON 树形可视化
   */
  static toJSON(node: TreeNode, options: {
    includeDepth?: boolean;
    includeFullEntry?: boolean;
  } = {}): any {
    const {
      includeDepth = true,
      includeFullEntry = false
    } = options;

    const result: any = {
      id: node.entry.id,
      type: node.entry.type
    };

    if (includeDepth && node.depth !== undefined) {
      result.depth = node.depth;
    }

    if (includeFullEntry) {
      result.entry = node.entry;
    } else if (node.entry.content) {
      result.content = node.entry.content;
    }

    if (node.children.length > 0) {
      result.children = node.children.map(child =>
        this.toJSON(child, options)
      );
    }

    return result;
  }

  /**
   * Markdown 树形可视化
   */
  static toMarkdown(node: TreeNode, level: number = 0): string {
    const indent = '  '.repeat(level);
    const label = `${node.entry.type}: ${node.entry.content || node.entry.id}`;

    let result = `${indent}- ${label}\n`;

    for (const child of node.children) {
      result += this.toMarkdown(child, level + 1);
    }

    return result;
  }
}
```

---

## 使用示例

### 示例 1：基础树构建

```typescript
import { TreeBuilder } from './tree-builder';
import { TreeVisualizer } from './tree-visualizer';

function basicTreeExample() {
  const entries = [
    { id: 'root', parentId: null, type: 'session', timestamp: '2024-01-01T10:00:00Z' },
    { id: 'msg1', parentId: 'root', type: 'user', timestamp: '2024-01-01T10:00:01Z', content: 'Hello' },
    { id: 'msg2', parentId: 'msg1', type: 'assistant', timestamp: '2024-01-01T10:00:02Z', content: 'Hi there!' },
    { id: 'msg3', parentId: 'msg2', type: 'user', timestamp: '2024-01-01T10:00:03Z', content: 'How are you?' },
    { id: 'msg4', parentId: 'msg2', type: 'user', timestamp: '2024-01-01T10:00:04Z', content: 'What\'s your name?' }
  ];

  const builder = new TreeBuilder(entries);
  const tree = builder.buildFullTree();

  if (tree) {
    console.log('Tree structure:');
    console.log(TreeVisualizer.visualize(tree));
  }
}

basicTreeExample();
```

**输出：**

```
Tree structure:
└── [session] root
    └── [user] msg1 "Hello"
        └── [assistant] msg2 "Hi there!"
            ├── [user] msg3 "How are you?"
            └── [user] msg4 "What's your name?"
```

### 示例 2：树遍历

```typescript
import { TreeTraverser } from './tree-traverser';

function traversalExample() {
  const builder = new TreeBuilder(entries);
  const tree = builder.buildFullTree();

  if (!tree) return;

  console.log('Depth-first (pre-order):');
  for (const node of TreeTraverser.depthFirstPreOrder(tree)) {
    console.log(`  ${node.entry.id}: ${node.entry.type}`);
  }

  console.log('\nBreadth-first:');
  for (const node of TreeTraverser.breadthFirst(tree)) {
    console.log(`  ${node.entry.id}: ${node.entry.type}`);
  }

  console.log('\nFind user messages:');
  const userNodes = TreeTraverser.findAllNodes(tree, node => node.entry.type === 'user');
  userNodes.forEach(node => {
    console.log(`  ${node.entry.id}: ${node.entry.content}`);
  });
}

traversalExample();
```

### 示例 3：获取分支路径

```typescript
function branchExample() {
  const builder = new TreeBuilder(entries);

  // 从叶子到根
  const branch = builder.getBranch('msg3');
  console.log('Branch from msg3 to root:');
  branch.forEach(entry => {
    console.log(`  ${entry.id}: ${entry.content || entry.type}`);
  });

  // 获取所有叶子节点
  const leaves = builder.getLeaves();
  console.log('\nLeaf nodes:');
  leaves.forEach(leaf => {
    console.log(`  ${leaf.id}: ${leaf.content || leaf.type}`);
  });
}

branchExample();
```

**输出：**

```
Branch from msg3 to root:
  root: session
  msg1: Hello
  msg2: Hi there!
  msg3: How are you?

Leaf nodes:
  msg3: How are you?
  msg4: What's your name?
```

### 示例 4：树统计信息

```typescript
function statsExample() {
  const builder = new TreeBuilder(entries);
  const stats = builder.getStats();

  console.log('Tree statistics:');
  console.log(`  Total nodes: ${stats.totalNodes}`);
  console.log(`  Max depth: ${stats.maxDepth}`);
  console.log(`  Leaf count: ${stats.leafCount}`);
  console.log(`  Branch count: ${stats.branchCount}`);
}

statsExample();
```

**输出：**

```
Tree statistics:
  Total nodes: 5
  Max depth: 4
  Leaf count: 2
  Branch count: 1
```

### 示例 5：从 JSONL 文件构建树

```typescript
import { JsonlManager } from './jsonl-manager';

async function buildTreeFromFile() {
  const jsonlManager = new JsonlManager('session.jsonl');
  const entries = jsonlManager.readAll();

  const builder = new TreeBuilder(entries);
  const tree = builder.buildFullTree();

  if (tree) {
    console.log(TreeVisualizer.visualize(tree, {
      showDepth: true,
      showType: true,
      maxContentLength: 50
    }));

    // 导出为 JSON
    const jsonTree = TreeVisualizer.toJSON(tree);
    console.log('\nJSON representation:');
    console.log(JSON.stringify(jsonTree, null, 2));
  }
}

buildTreeFromFile();
```

### 示例 6：查找特定节点

```typescript
function findNodeExample() {
  const builder = new TreeBuilder(entries);
  const tree = builder.buildFullTree();

  if (!tree) return;

  // 查找包含特定内容的节点
  const node = TreeTraverser.findNode(tree, node =>
    node.entry.content?.includes('name')
  );

  if (node) {
    console.log('Found node:', node.entry.id, node.entry.content);

    // 获取从根到该节点的路径
    const path = TreeTraverser.getPath(tree, node.entry.id);
    if (path) {
      console.log('Path from root:');
      path.forEach(n => {
        console.log(`  ${n.entry.id}: ${n.entry.content || n.entry.type}`);
      });
    }
  }
}

findNodeExample();
```

---

## 性能优化

### 优化 1：懒加载子节点

```typescript
class LazyTreeNode {
  private _children: LazyTreeNode[] | null = null;

  constructor(
    public entry: SessionEntry,
    private childrenMap: Map<string, SessionEntry[]>
  ) {}

  get children(): LazyTreeNode[] {
    if (this._children === null) {
      const childEntries = this.childrenMap.get(this.entry.id) || [];
      this._children = childEntries.map(e => new LazyTreeNode(e, this.childrenMap));
    }
    return this._children;
  }

  hasChildren(): boolean {
    return (this.childrenMap.get(this.entry.id)?.length || 0) > 0;
  }
}
```

### 优化 2：缓存常用查询

```typescript
class CachedTreeBuilder extends TreeBuilder {
  private branchCache = new Map<string, SessionEntry[]>();
  private leavesCache: SessionEntry[] | null = null;

  getBranch(fromId: string): SessionEntry[] {
    if (this.branchCache.has(fromId)) {
      return this.branchCache.get(fromId)!;
    }

    const branch = super.getBranch(fromId);
    this.branchCache.set(fromId, branch);
    return branch;
  }

  getLeaves(): SessionEntry[] {
    if (this.leavesCache !== null) {
      return this.leavesCache;
    }

    this.leavesCache = super.getLeaves();
    return this.leavesCache;
  }

  clearCache(): void {
    this.branchCache.clear();
    this.leavesCache = null;
  }
}
```

### 优化 3：增量更新

```typescript
class IncrementalTreeBuilder extends TreeBuilder {
  addEntry(entry: SessionEntry): void {
    // 添加到条目列表
    this.entries.push(entry);

    // 更新映射
    this.entryMap.set(entry.id, entry);

    if (entry.parentId !== null) {
      if (!this.childrenMap.has(entry.parentId)) {
        this.childrenMap.set(entry.parentId, []);
      }
      this.childrenMap.get(entry.parentId)!.push(entry);
    }
  }

  removeEntry(id: string): void {
    const entry = this.entryMap.get(id);
    if (!entry) return;

    // 从映射中删除
    this.entryMap.delete(id);

    if (entry.parentId !== null) {
      const siblings = this.childrenMap.get(entry.parentId);
      if (siblings) {
        const index = siblings.findIndex(e => e.id === id);
        if (index !== -1) {
          siblings.splice(index, 1);
        }
      }
    }

    // 从条目列表中删除
    const index = this.entries.findIndex(e => e.id === id);
    if (index !== -1) {
      this.entries.splice(index, 1);
    }
  }
}
```

---

## 与 Pi-mono 的对比

### Pi-mono 的实现

```typescript
// Pi-mono session-manager.ts
class SessionManager {
  private entryMap = new Map<string, SessionEntry>();
  private childrenMap = new Map<string, SessionEntry[]>();

  private buildSubtree(entryId: string): SessionTreeNode {
    const entry = this.entryMap.get(entryId)!;
    const children = this.childrenMap.get(entryId) || [];

    return {
      entry,
      children: children.map(child => this.buildSubtree(child.id))
    };
  }

  getTree(): SessionTreeNode {
    const root = this.entries.find(e => e.parentId === null);
    if (!root) {
      throw new Error('No root entry found');
    }

    return this.buildSubtree(root.id);
  }
}
```

### 我们的实现

```typescript
// 更完整、更灵活的实现
class TreeBuilder {
  // 支持多种遍历方式
  static depthFirstPreOrder(node: TreeNode): Generator<TreeNode> { ... }
  static breadthFirst(node: TreeNode): Generator<TreeNode> { ... }

  // 支持查询和统计
  findNode(predicate): TreeNode | null { ... }
  getStats(): TreeStats { ... }

  // 支持可视化
  visualize(options): string { ... }
  toJSON(options): any { ... }
}
```

---

## 关键要点总结

1. **映射构建**：使用 Map 建立 ID 和父子关系映射
2. **递归构建**：递归构建树形结构
3. **多种遍历**：深度优先、广度优先
4. **查询功能**：查找节点、获取路径、统计信息
5. **可视化**：ASCII、JSON、Markdown 多种格式

---

**下一步**：实现分支创建与导航 → `07_实战代码_03_分支创建与导航.md`
