# å®æˆ˜ä»£ç  04ï¼šåˆ†æ”¯æ€»ç»“å®ç°

> **ç›®æ ‡**ï¼šé€šè¿‡å®é™…ä»£ç ç¤ºä¾‹å­¦ä¹ å¦‚ä½•å®ç° Session åˆ†æ”¯æ€»ç»“åŠŸèƒ½

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å®Œæ•´å¯è¿è¡Œçš„åˆ†æ”¯æ€»ç»“å®ç°ç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•ï¼š
1. å®ç° `session_before_tree` é’©å­
2. è‡ªå®šä¹‰åˆ†æ”¯æ‘˜è¦ç”Ÿæˆ
3. è·¨åˆ†æ”¯ç´¯ç§¯æ–‡ä»¶è¿½è¸ª
4. ä¼˜åŒ–åˆ†æ”¯åˆ‡æ¢ä½“éªŒ

**å‰ç½®çŸ¥è¯†ï¼š**
- Session æ ‘å½¢ç»“æ„ï¼ˆçŸ¥è¯†ç‚¹ 11ï¼‰
- Compaction å‹ç¼©æœºåˆ¶
- Extension å¼€å‘åŸºç¡€

---

## ä»€ä¹ˆæ˜¯åˆ†æ”¯æ€»ç»“ï¼Ÿ

**åˆ†æ”¯æ€»ç»“ï¼ˆBranch Summarizationï¼‰** æ˜¯ Compaction çš„é«˜çº§åº”ç”¨ï¼Œç”¨äºåœ¨ Session åˆ†æ”¯åˆ‡æ¢æ—¶ç”Ÿæˆæ‘˜è¦ã€‚

**åœºæ™¯ï¼š**
```
ä¸»åˆ†æ”¯ï¼šå®ç°ç”¨æˆ·ç™»å½•åŠŸèƒ½
    â†“
åˆ†æ”¯ Aï¼šå°è¯•ä½¿ç”¨ JWT è®¤è¯
    â†“
åˆ†æ”¯ Bï¼šå°è¯•ä½¿ç”¨ Session è®¤è¯ï¼ˆä»ä¸»åˆ†æ”¯åˆ†å‰ï¼‰
```

**é—®é¢˜ï¼š**
- åˆ‡æ¢åˆ°åˆ†æ”¯ B æ—¶ï¼Œå¦‚ä½•çŸ¥é“ä¸»åˆ†æ”¯åšäº†ä»€ä¹ˆï¼Ÿ
- å¦‚ä½•é¿å…é‡å¤è¯»å–ç›¸åŒæ–‡ä»¶ï¼Ÿ

**è§£å†³æ–¹æ¡ˆï¼š**
- åœ¨åˆ›å»ºåˆ†æ”¯æ—¶ç”Ÿæˆä¸»åˆ†æ”¯çš„æ‘˜è¦
- ç´¯ç§¯è¿½è¸ªæ‰€æœ‰åˆ†æ”¯çš„æ–‡ä»¶æ“ä½œ

---

## ç¤ºä¾‹ 1ï¼šåŸºç¡€åˆ†æ”¯æ€»ç»“æ‰©å±•

### å®Œæ•´æ‰©å±•ä»£ç 

```typescript
/**
 * .pi/extensions/branch-summarization.ts
 * å®ç°åˆ†æ”¯æ€»ç»“åŠŸèƒ½
 */

import { Extension } from '@mariozechner/pi-agent-core';

export const branchSummarizationExtension: Extension = {
  name: 'branch-summarization',
  description: 'åœ¨åˆ†æ”¯åˆ‡æ¢æ—¶ç”Ÿæˆæ‘˜è¦',

  async onLoad(context) {
    console.log('âœ… Branch Summarization å·²åŠ è½½');

    // ç›‘å¬åˆ†æ”¯åˆ›å»ºå‰äº‹ä»¶
    context.session.on('session_before_tree', async (event) => {
      console.log('\nğŸŒ³ å³å°†åˆ›å»ºåˆ†æ”¯');
      console.log(`   å½“å‰åˆ†æ”¯: ${event.currentBranchId}`);
      console.log(`   æ–°åˆ†æ”¯: ${event.newBranchId}`);

      // ç”Ÿæˆå½“å‰åˆ†æ”¯çš„æ‘˜è¦
      const summary = await generateBranchSummary(event.messages);

      // æ·»åŠ æ‘˜è¦åˆ°æ–°åˆ†æ”¯
      event.branchSummary = summary;

      console.log('âœ… åˆ†æ”¯æ‘˜è¦å·²ç”Ÿæˆ');
    });

    // ç›‘å¬åˆ†æ”¯åˆ‡æ¢äº‹ä»¶
    context.session.on('session_branch_switched', async (event) => {
      console.log('\nğŸ”€ åˆ†æ”¯å·²åˆ‡æ¢');
      console.log(`   ä»: ${event.fromBranchId}`);
      console.log(`   åˆ°: ${event.toBranchId}`);

      // æ˜¾ç¤ºåˆ†æ”¯æ‘˜è¦
      if (event.branchSummary) {
        console.log('\nğŸ“ åˆ†æ”¯æ‘˜è¦:');
        console.log(event.branchSummary);
      }
    });
  },
};

/**
 * ç”Ÿæˆåˆ†æ”¯æ‘˜è¦
 */
async function generateBranchSummary(messages: any[]): Promise<string> {
  // æå–å…³é”®ä¿¡æ¯
  const stats = analyzeMessages(messages);

  // ç”Ÿæˆæ‘˜è¦
  const summary = `
## Branch Summary

### Overview
This branch contains ${stats.userMessages} user requests and ${stats.assistantMessages} assistant responses.

### Key Activities
${stats.keyTopics.map(topic => `- ${topic}`).join('\n')}

### Files
- **Read** (${stats.filesRead.size}): ${Array.from(stats.filesRead).join(', ') || 'None'}
- **Modified** (${stats.filesModified.size}): ${Array.from(stats.filesModified).join(', ') || 'None'}

### Statistics
- Total Messages: ${messages.length}
- Tool Calls: ${stats.toolCalls}
- Code Blocks: ${stats.codeBlocks}
  `.trim();

  return summary;
}

/**
 * åˆ†ææ¶ˆæ¯ç»Ÿè®¡
 */
function analyzeMessages(messages: any[]): {
  userMessages: number;
  assistantMessages: number;
  toolCalls: number;
  codeBlocks: number;
  filesRead: Set<string>;
  filesModified: Set<string>;
  keyTopics: string[];
} {
  const stats = {
    userMessages: 0,
    assistantMessages: 0,
    toolCalls: 0,
    codeBlocks: 0,
    filesRead: new Set<string>(),
    filesModified: new Set<string>(),
    keyTopics: [] as string[],
  };

  for (const message of messages) {
    if (message.role === 'user') {
      stats.userMessages++;
    } else if (message.role === 'assistant') {
      stats.assistantMessages++;
    }

    if (message.tool_calls) {
      stats.toolCalls += message.tool_calls.length;

      // æå–æ–‡ä»¶æ“ä½œ
      for (const toolCall of message.tool_calls) {
        const args = JSON.parse(toolCall.function.arguments || '{}');

        if (toolCall.function.name === 'read_file') {
          stats.filesRead.add(args.file_path);
        } else if (toolCall.function.name === 'write_file' ||
                   toolCall.function.name === 'edit_file') {
          stats.filesModified.add(args.file_path);
        }
      }
    }

    // ç»Ÿè®¡ä»£ç å—
    const content = message.content || '';
    const blocks = (content.match(/```/g) || []).length / 2;
    stats.codeBlocks += blocks;
  }

  // æå–å…³é”®ä¸»é¢˜
  stats.keyTopics = extractKeyTopics(messages);

  return stats;
}

/**
 * æå–å…³é”®ä¸»é¢˜
 */
function extractKeyTopics(messages: any[]): string[] {
  const topics = new Set<string>();

  const keywords = [
    { pattern: /implement|å®ç°/i, topic: 'Feature Implementation' },
    { pattern: /fix|ä¿®å¤|bug/i, topic: 'Bug Fix' },
    { pattern: /refactor|é‡æ„/i, topic: 'Refactoring' },
    { pattern: /test|æµ‹è¯•/i, topic: 'Testing' },
    { pattern: /debug|è°ƒè¯•/i, topic: 'Debugging' },
    { pattern: /optimize|ä¼˜åŒ–/i, topic: 'Optimization' },
    { pattern: /review|å®¡æŸ¥/i, topic: 'Code Review' },
  ];

  for (const message of messages) {
    const content = message.content || '';

    for (const { pattern, topic } of keywords) {
      if (pattern.test(content)) {
        topics.add(topic);
      }
    }
  }

  return Array.from(topics);
}
```

---

## ç¤ºä¾‹ 2ï¼šç´¯ç§¯æ–‡ä»¶è¿½è¸ª

### è·¨åˆ†æ”¯æ–‡ä»¶è¿½è¸ªæ‰©å±•

```typescript
/**
 * .pi/extensions/cumulative-file-tracking.ts
 * è·¨åˆ†æ”¯ç´¯ç§¯æ–‡ä»¶è¿½è¸ª
 */

import { Extension } from '@mariozechner/pi-agent-core';

interface FileTracker {
  read: Set<string>;
  modified: Set<string>;
  created: Set<string>;
  deleted: Set<string>;
}

export const cumulativeFileTrackingExtension: Extension = {
  name: 'cumulative-file-tracking',
  description: 'è·¨åˆ†æ”¯ç´¯ç§¯æ–‡ä»¶è¿½è¸ª',

  async onLoad(context) {
    console.log('âœ… Cumulative File Tracking å·²åŠ è½½');

    // å…¨å±€æ–‡ä»¶è¿½è¸ªå™¨
    const globalTracker: FileTracker = {
      read: new Set(),
      modified: new Set(),
      created: new Set(),
      deleted: new Set(),
    };

    // ç›‘å¬åˆ†æ”¯åˆ›å»ºå‰äº‹ä»¶
    context.session.on('session_before_tree', async (event) => {
      // ç´¯ç§¯å½“å‰åˆ†æ”¯çš„æ–‡ä»¶æ“ä½œ
      const branchFiles = extractFiles(event.messages);

      // åˆå¹¶åˆ°å…¨å±€è¿½è¸ªå™¨
      branchFiles.read.forEach(f => globalTracker.read.add(f));
      branchFiles.modified.forEach(f => globalTracker.modified.add(f));
      branchFiles.created.forEach(f => globalTracker.created.add(f));
      branchFiles.deleted.forEach(f => globalTracker.deleted.add(f));

      // æ·»åŠ åˆ°åˆ†æ”¯æ‘˜è¦
      event.branchSummary = generateFileTrackingSummary(globalTracker);

      console.log('\nğŸ“ ç´¯ç§¯æ–‡ä»¶è¿½è¸ª:');
      console.log(`   è¯»å–: ${globalTracker.read.size} ä¸ªæ–‡ä»¶`);
      console.log(`   ä¿®æ”¹: ${globalTracker.modified.size} ä¸ªæ–‡ä»¶`);
      console.log(`   åˆ›å»º: ${globalTracker.created.size} ä¸ªæ–‡ä»¶`);
      console.log(`   åˆ é™¤: ${globalTracker.deleted.size} ä¸ªæ–‡ä»¶`);
    });
  },
};

/**
 * æå–æ–‡ä»¶æ“ä½œ
 */
function extractFiles(messages: any[]): FileTracker {
  const tracker: FileTracker = {
    read: new Set(),
    modified: new Set(),
    created: new Set(),
    deleted: new Set(),
  };

  for (const message of messages) {
    if (!message.tool_calls) continue;

    for (const toolCall of message.tool_calls) {
      const args = JSON.parse(toolCall.function.arguments || '{}');
      const filePath = args.file_path || args.path;

      if (!filePath) continue;

      switch (toolCall.function.name) {
        case 'read_file':
          tracker.read.add(filePath);
          break;

        case 'write_file':
          // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œç®—ä½œåˆ›å»º
          tracker.created.add(filePath);
          tracker.modified.add(filePath);
          break;

        case 'edit_file':
          tracker.modified.add(filePath);
          break;

        case 'delete_file':
          tracker.deleted.add(filePath);
          break;
      }
    }
  }

  return tracker;
}

/**
 * ç”Ÿæˆæ–‡ä»¶è¿½è¸ªæ‘˜è¦
 */
function generateFileTrackingSummary(tracker: FileTracker): string {
  return `
## Cumulative File Tracking

### Files Read (${tracker.read.size})
${Array.from(tracker.read).map(f => `- ${f}`).join('\n') || '- None'}

### Files Modified (${tracker.modified.size})
${Array.from(tracker.modified).map(f => `- ${f}`).join('\n') || '- None'}

### Files Created (${tracker.created.size})
${Array.from(tracker.created).map(f => `- ${f}`).join('\n') || '- None'}

### Files Deleted (${tracker.deleted.size})
${Array.from(tracker.deleted).map(f => `- ${f}`).join('\n') || '- None'}
  `.trim();
}
```

---

## ç¤ºä¾‹ 3ï¼šæ™ºèƒ½åˆ†æ”¯æ‘˜è¦

### ä½¿ç”¨ LLM ç”Ÿæˆé«˜è´¨é‡æ‘˜è¦

```typescript
/**
 * .pi/extensions/smart-branch-summary.ts
 * ä½¿ç”¨ LLM ç”Ÿæˆæ™ºèƒ½åˆ†æ”¯æ‘˜è¦
 */

import { Extension } from '@mariozechner/pi-agent-core';

export const smartBranchSummaryExtension: Extension = {
  name: 'smart-branch-summary',
  description: 'ä½¿ç”¨ LLM ç”Ÿæˆæ™ºèƒ½åˆ†æ”¯æ‘˜è¦',

  async onLoad(context) {
    console.log('âœ… Smart Branch Summary å·²åŠ è½½');

    context.session.on('session_before_tree', async (event) => {
      console.log('\nğŸ§  ç”Ÿæˆæ™ºèƒ½åˆ†æ”¯æ‘˜è¦...');

      // åºåˆ—åŒ–å¯¹è¯
      const conversationText = serializeConversation(event.messages);

      // ä½¿ç”¨ LLM ç”Ÿæˆæ‘˜è¦
      const summary = await generateSmartSummary(
        conversationText,
        context.session.llm
      );

      event.branchSummary = summary;

      console.log('âœ… æ™ºèƒ½æ‘˜è¦å·²ç”Ÿæˆ');
    });
  },
};

/**
 * åºåˆ—åŒ–å¯¹è¯
 */
function serializeConversation(messages: any[]): string {
  let text = '';

  for (const message of messages) {
    text += `**${message.role}**: ${message.content || ''}\n\n`;
  }

  return text;
}

/**
 * ç”Ÿæˆæ™ºèƒ½æ‘˜è¦
 */
async function generateSmartSummary(
  conversationText: string,
  llm: any
): Promise<string> {
  const prompt = `
Please summarize the following conversation branch:

## Instructions
1. Provide a high-level overview (1-2 paragraphs)
2. List key decisions and actions
3. Track file operations
4. Identify any pending issues

## Format
Use the following markdown format:

## Branch Summary

### Overview
[Your summary here]

### Key Decisions
- [Decision 1]
- [Decision 2]

### Actions Taken
- [Action 1]
- [Action 2]

### Files
- Read: [file list]
- Modified: [file list]

### Pending Issues
- [Issue 1]
- [Issue 2]

## Conversation

${conversationText}
  `;

  const response = await llm.chat([
    { role: 'user', content: prompt }
  ]);

  return response.content;
}
```

---

## ç¤ºä¾‹ 4ï¼šåˆ†æ”¯å¯¹æ¯”å·¥å…·

### å¯¹æ¯”ä¸åŒåˆ†æ”¯çš„å·®å¼‚

```typescript
/**
 * branch-diff.ts
 * å¯¹æ¯”ä¸åŒåˆ†æ”¯çš„å·®å¼‚
 */

import * as fs from 'fs';
import * as path from 'path';

interface BranchInfo {
  id: string;
  parentId: string;
  messages: any[];
  summary?: string;
}

/**
 * ä» JSONL æ–‡ä»¶åŠ è½½åˆ†æ”¯
 */
function loadBranches(sessionPath: string): BranchInfo[] {
  const content = fs.readFileSync(sessionPath, 'utf-8');
  const lines = content.trim().split('\n');
  const messages = lines.map(line => JSON.parse(line));

  // æ„å»ºåˆ†æ”¯æ ‘
  const branches: Map<string, BranchInfo> = new Map();

  for (const message of messages) {
    const branchId = message.branchId || 'main';

    if (!branches.has(branchId)) {
      branches.set(branchId, {
        id: branchId,
        parentId: message.parentBranchId || '',
        messages: [],
      });
    }

    branches.get(branchId)!.messages.push(message);

    // æå–æ‘˜è¦
    if (message.role === 'branch_summary') {
      branches.get(branchId)!.summary = message.content;
    }
  }

  return Array.from(branches.values());
}

/**
 * å¯¹æ¯”ä¸¤ä¸ªåˆ†æ”¯
 */
function compareBranches(branch1: BranchInfo, branch2: BranchInfo) {
  console.log('='.repeat(80));
  console.log('åˆ†æ”¯å¯¹æ¯”');
  console.log('='.repeat(80));
  console.log();

  // åŸºæœ¬ä¿¡æ¯
  console.log(`åˆ†æ”¯ 1: ${branch1.id}`);
  console.log(`  æ¶ˆæ¯æ•°: ${branch1.messages.length}`);
  console.log(`  çˆ¶åˆ†æ”¯: ${branch1.parentId || 'None'}`);
  console.log();

  console.log(`åˆ†æ”¯ 2: ${branch2.id}`);
  console.log(`  æ¶ˆæ¯æ•°: ${branch2.messages.length}`);
  console.log(`  çˆ¶åˆ†æ”¯: ${branch2.parentId || 'None'}`);
  console.log();

  // æ–‡ä»¶æ“ä½œå¯¹æ¯”
  const files1 = extractFiles(branch1.messages);
  const files2 = extractFiles(branch2.messages);

  console.log('æ–‡ä»¶æ“ä½œå¯¹æ¯”:');
  console.log(`  åˆ†æ”¯ 1 è¯»å–: ${files1.read.size} ä¸ªæ–‡ä»¶`);
  console.log(`  åˆ†æ”¯ 2 è¯»å–: ${files2.read.size} ä¸ªæ–‡ä»¶`);
  console.log(`  åˆ†æ”¯ 1 ä¿®æ”¹: ${files1.modified.size} ä¸ªæ–‡ä»¶`);
  console.log(`  åˆ†æ”¯ 2 ä¿®æ”¹: ${files2.modified.size} ä¸ªæ–‡ä»¶`);
  console.log();

  // ç‹¬æœ‰æ–‡ä»¶
  const uniqueToB1 = new Set(
    Array.from(files1.modified).filter(f => !files2.modified.has(f))
  );
  const uniqueToB2 = new Set(
    Array.from(files2.modified).filter(f => !files1.modified.has(f))
  );

  if (uniqueToB1.size > 0) {
    console.log(`åˆ†æ”¯ 1 ç‹¬æœ‰ä¿®æ”¹ (${uniqueToB1.size}):`);
    Array.from(uniqueToB1).forEach(f => console.log(`  - ${f}`));
    console.log();
  }

  if (uniqueToB2.size > 0) {
    console.log(`åˆ†æ”¯ 2 ç‹¬æœ‰ä¿®æ”¹ (${uniqueToB2.size}):`);
    Array.from(uniqueToB2).forEach(f => console.log(`  - ${f}`));
    console.log();
  }

  // æ‘˜è¦å¯¹æ¯”
  if (branch1.summary || branch2.summary) {
    console.log('æ‘˜è¦å¯¹æ¯”:');
    console.log();
    console.log('åˆ†æ”¯ 1:');
    console.log(branch1.summary || '  æ— æ‘˜è¦');
    console.log();
    console.log('åˆ†æ”¯ 2:');
    console.log(branch2.summary || '  æ— æ‘˜è¦');
    console.log();
  }

  console.log('='.repeat(80));
}

function extractFiles(messages: any[]): {
  read: Set<string>;
  modified: Set<string>;
} {
  const files = {
    read: new Set<string>(),
    modified: new Set<string>(),
  };

  for (const message of messages) {
    if (!message.tool_calls) continue;

    for (const toolCall of message.tool_calls) {
      const args = JSON.parse(toolCall.function.arguments || '{}');
      const filePath = args.file_path || args.path;

      if (!filePath) continue;

      if (toolCall.function.name === 'read_file') {
        files.read.add(filePath);
      } else if (toolCall.function.name === 'write_file' ||
                 toolCall.function.name === 'edit_file') {
        files.modified.add(filePath);
      }
    }
  }

  return files;
}

/**
 * ä¸»å‡½æ•°
 */
function main() {
  const sessionPath = process.argv[2];

  if (!sessionPath) {
    console.log('ç”¨æ³•: npx tsx branch-diff.ts <session-file>');
    process.exit(1);
  }

  const branches = loadBranches(sessionPath);

  console.log(`æ‰¾åˆ° ${branches.length} ä¸ªåˆ†æ”¯`);
  console.log();

  // å¯¹æ¯”å‰ä¸¤ä¸ªåˆ†æ”¯
  if (branches.length >= 2) {
    compareBranches(branches[0], branches[1]);
  } else {
    console.log('éœ€è¦è‡³å°‘ 2 ä¸ªåˆ†æ”¯æ‰èƒ½å¯¹æ¯”');
  }
}

main();
```

### ä½¿ç”¨åˆ†æ”¯å¯¹æ¯”å·¥å…·

```bash
# è¿è¡Œå¯¹æ¯”å·¥å…·
npx tsx branch-diff.ts ~/.pi/sessions/<session-id>.jsonl

# è¾“å‡ºç¤ºä¾‹ï¼š
# ================================================================================
# åˆ†æ”¯å¯¹æ¯”
# ================================================================================
#
# åˆ†æ”¯ 1: main
#   æ¶ˆæ¯æ•°: 150
#   çˆ¶åˆ†æ”¯: None
#
# åˆ†æ”¯ 2: branch-jwt-auth
#   æ¶ˆæ¯æ•°: 50
#   çˆ¶åˆ†æ”¯: main
#
# æ–‡ä»¶æ“ä½œå¯¹æ¯”:
#   åˆ†æ”¯ 1 è¯»å–: 10 ä¸ªæ–‡ä»¶
#   åˆ†æ”¯ 2 è¯»å–: 5 ä¸ªæ–‡ä»¶
#   åˆ†æ”¯ 1 ä¿®æ”¹: 5 ä¸ªæ–‡ä»¶
#   åˆ†æ”¯ 2 ä¿®æ”¹: 3 ä¸ªæ–‡ä»¶
#
# åˆ†æ”¯ 2 ç‹¬æœ‰ä¿®æ”¹ (2):
#   - src/auth/jwt.ts
#   - src/middleware/auth.ts
#
# ================================================================================
```

---

## ç¤ºä¾‹ 5ï¼šåˆ†æ”¯å¯è§†åŒ–å·¥å…·

### å¯è§†åŒ–åˆ†æ”¯æ ‘ç»“æ„

```typescript
/**
 * branch-visualizer.ts
 * å¯è§†åŒ–åˆ†æ”¯æ ‘ç»“æ„
 */

import * as fs from 'fs';

interface BranchNode {
  id: string;
  parentId: string;
  messageCount: number;
  summary?: string;
  children: BranchNode[];
}

/**
 * æ„å»ºåˆ†æ”¯æ ‘
 */
function buildBranchTree(sessionPath: string): BranchNode {
  const content = fs.readFileSync(sessionPath, 'utf-8');
  const lines = content.trim().split('\n');
  const messages = lines.map(line => JSON.parse(line));

  // ç»Ÿè®¡æ¯ä¸ªåˆ†æ”¯çš„æ¶ˆæ¯æ•°
  const branchStats = new Map<string, { parentId: string; count: number; summary?: string }>();

  for (const message of messages) {
    const branchId = message.branchId || 'main';

    if (!branchStats.has(branchId)) {
      branchStats.set(branchId, {
        parentId: message.parentBranchId || '',
        count: 0,
      });
    }

    branchStats.get(branchId)!.count++;

    if (message.role === 'branch_summary') {
      branchStats.get(branchId)!.summary = message.content;
    }
  }

  // æ„å»ºæ ‘
  const nodes = new Map<string, BranchNode>();

  for (const [id, stats] of branchStats.entries()) {
    nodes.set(id, {
      id,
      parentId: stats.parentId,
      messageCount: stats.count,
      summary: stats.summary,
      children: [],
    });
  }

  // å»ºç«‹çˆ¶å­å…³ç³»
  for (const node of nodes.values()) {
    if (node.parentId && nodes.has(node.parentId)) {
      nodes.get(node.parentId)!.children.push(node);
    }
  }

  // è¿”å›æ ¹èŠ‚ç‚¹
  return nodes.get('main') || Array.from(nodes.values())[0];
}

/**
 * å¯è§†åŒ–åˆ†æ”¯æ ‘
 */
function visualizeBranchTree(node: BranchNode, prefix: string = '', isLast: boolean = true) {
  // æ‰“å°å½“å‰èŠ‚ç‚¹
  const connector = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
  console.log(prefix + connector + `${node.id} (${node.messageCount} messages)`);

  // æ‰“å°æ‘˜è¦ï¼ˆå¦‚æœæœ‰ï¼‰
  if (node.summary) {
    const summaryPrefix = prefix + (isLast ? '    ' : 'â”‚   ');
    const summaryLines = node.summary.split('\n').slice(0, 2); // åªæ˜¾ç¤ºå‰ä¸¤è¡Œ
    for (const line of summaryLines) {
      console.log(summaryPrefix + '  ' + line);
    }
  }

  // é€’å½’æ‰“å°å­èŠ‚ç‚¹
  const childPrefix = prefix + (isLast ? '    ' : 'â”‚   ');
  for (let i = 0; i < node.children.length; i++) {
    const isLastChild = i === node.children.length - 1;
    visualizeBranchTree(node.children[i], childPrefix, isLastChild);
  }
}

/**
 * ä¸»å‡½æ•°
 */
function main() {
  const sessionPath = process.argv[2];

  if (!sessionPath) {
    console.log('ç”¨æ³•: npx tsx branch-visualizer.ts <session-file>');
    process.exit(1);
  }

  console.log('åˆ†æ”¯æ ‘ç»“æ„:');
  console.log();

  const tree = buildBranchTree(sessionPath);
  visualizeBranchTree(tree);
}

main();
```

### ä½¿ç”¨å¯è§†åŒ–å·¥å…·

```bash
# è¿è¡Œå¯è§†åŒ–å·¥å…·
npx tsx branch-visualizer.ts ~/.pi/sessions/<session-id>.jsonl

# è¾“å‡ºç¤ºä¾‹ï¼š
# åˆ†æ”¯æ ‘ç»“æ„:
#
# â””â”€â”€ main (150 messages)
#     â”œâ”€â”€ branch-jwt-auth (50 messages)
#     â”‚     ## Branch Summary
#     â”‚     Implemented JWT authentication with bcrypt password hashing
#     â””â”€â”€ branch-session-auth (40 messages)
#           ## Branch Summary
#           Implemented session-based authentication with Redis
```

---

## æ€»ç»“

**æœ¬æ–‡æ¡£æä¾›çš„åˆ†æ”¯æ€»ç»“å·¥å…·ï¼š**

1. **åŸºç¡€åˆ†æ”¯æ€»ç»“**ï¼šåœ¨åˆ†æ”¯åˆ›å»ºæ—¶ç”Ÿæˆæ‘˜è¦
2. **ç´¯ç§¯æ–‡ä»¶è¿½è¸ª**ï¼šè·¨åˆ†æ”¯è¿½è¸ªæ–‡ä»¶æ“ä½œ
3. **æ™ºèƒ½åˆ†æ”¯æ‘˜è¦**ï¼šä½¿ç”¨ LLM ç”Ÿæˆé«˜è´¨é‡æ‘˜è¦
4. **åˆ†æ”¯å¯¹æ¯”å·¥å…·**ï¼šå¯¹æ¯”ä¸åŒåˆ†æ”¯çš„å·®å¼‚
5. **åˆ†æ”¯å¯è§†åŒ–**ï¼šå¯è§†åŒ–åˆ†æ”¯æ ‘ç»“æ„

**å…³é”®è¦ç‚¹ï¼š**
- åˆ†æ”¯æ€»ç»“å¸®åŠ©ç†è§£åˆ†æ”¯å†å²
- ç´¯ç§¯æ–‡ä»¶è¿½è¸ªé¿å…é‡å¤æ“ä½œ
- æ™ºèƒ½æ‘˜è¦æä¾›æ›´å¥½çš„ä¸Šä¸‹æ–‡
- å¯è§†åŒ–å·¥å…·å¸®åŠ©ç†è§£åˆ†æ”¯ç»“æ„

**ä¸ Compaction çš„å…³ç³»ï¼š**
- åˆ†æ”¯æ€»ç»“æ˜¯ Compaction çš„æ‰©å±•åº”ç”¨
- ä½¿ç”¨ç›¸åŒçš„æ‘˜è¦ç”ŸæˆæŠ€æœ¯
- éƒ½æ˜¯ä¸ºäº†ç®¡ç†é•¿æœŸå¯¹è¯çš„ä¸Šä¸‹æ–‡

---

**ä¸‹ä¸€æ­¥å­¦ä¹ ï¼š**
- **é¢è¯•å¿…é—®**ï¼šå¸¸è§é¢è¯•é—®é¢˜ï¼ˆ08_é¢è¯•å¿…é—®.mdï¼‰
- **åŒ–éª¨ç»µæŒ**ï¼š10ä¸ª2åˆ†é’ŸçŸ¥è¯†å¡ç‰‡ï¼ˆ09_åŒ–éª¨ç»µæŒ.mdï¼‰

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2026-02-20
**ç»´æŠ¤è€…ï¼š** Claude Code
