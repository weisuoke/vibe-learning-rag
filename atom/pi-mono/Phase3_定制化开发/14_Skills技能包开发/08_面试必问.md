# 面试必问

## 问题 1：什么是 Skills 技能包？它与 Prompt Templates 有什么区别?

### 标准答案

**Skills 技能包是 Pi-mono 中用于封装 AI Agent 能力的模块化单元，通过 SKILL.md 文件定义。**

**与 Prompt Templates 的区别：**

| 维度 | Skills 技能包 | Prompt Templates |
|------|---------------|------------------|
| 用途 | 封装完整的 Agent 能力 | 提供可复用的提示词片段 |
| 格式 | SKILL.md（固定文件名） | 任意 .md 文件 |
| 调用 | `/skill:name` | `/template-name` |
| 元数据 | name + description（必需） | 可选元数据 |
| 标准化 | 符合 Agent Skills 开放标准 | Pi-mono 内部标准 |
| 组合 | 可以调用其他技能 | 可以使用变量插值 |

**核心区别：**
- Skills 是"能力"，Templates 是"模板"
- Skills 定义"做什么"，Templates 定义"怎么说"
- Skills 可以组合成工作流，Templates 提供文本复用

### 深入理解

**来自源码的证据：**

```typescript
// skills.ts:73-80 - Skill 接口
export interface Skill {
  name: string;              // 技能名称
  description: string;       // 技能描述
  filePath: string;          // 文件路径
  baseDir: string;           // 基础目录
  source: string;            // 来源（global/project）
  disableModelInvocation: boolean;  // 是否禁用模型调用
}

// prompt-templates.ts - PromptTemplate 接口（简化）
interface PromptTemplate {
  name: string;              // 模板名称
  content: string;           // 模板内容
  variables: string[];       // 变量列表
}
```

**实际应用场景：**

```bash
# Skills - 完整的代码审查能力
/skill:code-review src/app.ts
→ 分析代码质量、发现问题、提供建议

# Templates - 可复用的提示词片段
/pr-review https://github.com/user/repo/pull/123
→ 使用模板格式化 PR 审查请求
```

---

## 问题 2：Skills 的加载机制是什么？什么时候加载？

### 标准答案

**Skills 在 Agent 启动时一次性加载，通过递归扫描技能目录实现。**

**加载流程（来自 skills.ts:146-230）：**

```typescript
// 1. 启动时调用
loadSkillsFromDir({
  dir: '~/.pi/agent/skills',
  source: 'global'
});

// 2. 递归扫描目录
function loadSkillsFromDirInternal(dir, source, includeRootFiles) {
  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    if (entry.isDirectory()) {
      // 递归扫描子目录
      loadSkillsFromDirInternal(fullPath, source, false);
    } else if (entry.name === "SKILL.md") {
      // 加载技能文件
      loadSkillFromFile(fullPath, source);
    }
  }
}

// 3. 解析和验证
function loadSkillFromFile(filePath, source) {
  const rawContent = readFileSync(filePath, 'utf-8');
  const { frontmatter } = parseFrontmatter(rawContent);

  // 验证 name 和 description
  validateName(frontmatter.name, parentDirName);
  validateDescription(frontmatter.description);

  return { skill, diagnostics };
}
```

**关键特性：**
1. **启动时加载** - 不是动态加载
2. **递归扫描** - 支持子目录组织
3. **验证机制** - 检查 name 和 description
4. **多源支持** - 全局 + 项目级别
5. **优先级** - 项目技能覆盖全局技能

### 深入理解

**为什么启动时加载？**
1. **简单性** - 避免文件监听和热重载的复杂性
2. **性能** - 技能文件很小，全量加载开销小
3. **一致性** - 确保会话期间技能列表稳定

**实际影响：**
```bash
# 添加新技能后需要重启
mkdir -p ~/.pi/agent/skills/new-skill
cat > ~/.pi/agent/skills/new-skill/SKILL.md << 'EOF'
---
name: new-skill
description: A new skill
---
...
EOF

# ❌ 不会立即生效
/skill:new-skill

# ✅ 需要重启
exit
pi
/skill:new-skill  # 现在可以使用
```

---

## 问题 3：Skills 的调用机制是什么？如何展开和注入？

### 标准答案

**Skills 调用是文本展开机制，将 SKILL.md 内容展开为 XML 块并注入到 LLM 上下文中。**

**调用流程（来自 agent-session.ts:883-907）：**

```typescript
private _expandSkillCommand(text: string): string {
  // 1. 检查是否为技能命令
  if (!text.startsWith("/skill:")) return text;

  // 2. 解析技能名称和参数
  const spaceIndex = text.indexOf(" ");
  const skillName = spaceIndex === -1 ? text.slice(7) : text.slice(7, spaceIndex);
  const args = spaceIndex === -1 ? "" : text.slice(spaceIndex + 1).trim();

  // 3. 查找技能
  const skill = this.resourceLoader.getSkills().skills.find(
    (s) => s.name === skillName
  );
  if (!skill) return text; // 找不到技能，返回原文本

  // 4. 读取文件内容
  const content = readFileSync(skill.filePath, 'utf-8');
  const body = stripFrontmatter(content).trim();

  // 5. 展开为 XML 块
  const skillBlock = `<skill name="${skill.name}" location="${skill.filePath}">
References are relative to ${skill.baseDir}.

${body}
</skill>`;

  // 6. 拼接参数
  return args ? `${skillBlock}\n\n${args}` : skillBlock;
}
```

**展开示例：**

```bash
# 输入
/skill:code-review src/app.ts

# 展开为
<skill name="code-review" location="~/.pi/agent/skills/code-review/SKILL.md">
References are relative to ~/.pi/agent/skills/code-review.

You are an expert code reviewer. Analyze the provided code and provide:
1. Code Quality Assessment
2. Potential Issues
3. Improvement Suggestions
</skill>

src/app.ts
```

### 深入理解

**关键点：**
1. **不是函数调用** - 是文本展开
2. **不是代码执行** - 是提示词注入
3. **参数是自由文本** - 没有类型检查
4. **返回值是 LLM 生成** - 非确定性

**与函数调用的对比：**

| 维度 | 函数调用 | Skills 调用 |
|------|----------|-------------|
| 机制 | 代码执行 | 文本展开 |
| 参数 | 类型化参数 | 自由文本 |
| 返回 | 确定性返回值 | LLM 生成文本 |
| 性能 | 毫秒级 | 秒级（LLM 推理） |
| 调试 | 断点调试 | 查看展开文本 |

---

## 问题 4：如何实现技能组合？有哪些注意事项？

### 标准答案

**技能组合通过在父技能中调用子技能实现，但不是自动的函数组合，而是依赖 LLM 理解和执行。**

**实现方式：**

```markdown
<!-- scout-and-plan/SKILL.md -->
---
name: scout-and-plan
description: Explore codebase and generate implementation plan
---

You are a planning assistant. Follow these steps carefully:

Step 1: First, use /skill:explore to understand the codebase structure
- Wait for the exploration to complete
- Review the exploration results

Step 2: Then, use /skill:plan to generate an implementation plan
- Base the plan on the exploration results
- Include specific file paths and line numbers

Step 3: Present the plan to the user for approval
- Format the plan clearly
- Ask if they want to proceed

IMPORTANT: Execute these steps in order. Do not skip any step.
```

**注意事项：**

1. **明确的指令**
   ```markdown
   <!-- ❌ 不够明确 -->
   Use explore and plan skills

   <!-- ✅ 明确的指令 -->
   Step 1: First, use /skill:explore
   Step 2: Wait for results
   Step 3: Then, use /skill:plan
   ```

2. **顺序控制**
   ```markdown
   <!-- ❌ 可能乱序 -->
   Use /skill:explore and /skill:plan

   <!-- ✅ 明确顺序 -->
   Step 1: /skill:explore
   Step 2: After exploration completes, /skill:plan
   ```

3. **错误处理**
   ```markdown
   Step 1: Use /skill:explore
   Step 2: If exploration fails, ask user for more context
   Step 3: If exploration succeeds, use /skill:plan
   ```

4. **数据传递**
   ```markdown
   Step 1: Use /skill:explore to find relevant files
   Step 2: Use /skill:plan based on the files found in step 1
   ```

### 深入理解

**为什么不是自动组合？**

因为 Skills 不是代码，是提示词：
- LLM 需要理解父技能的指令
- LLM 需要决定何时调用子技能
- LLM 需要处理子技能的结果
- 这个过程依赖 LLM 的推理能力

**实际执行流程：**

```
1. 用户调用父技能
   /skill:scout-and-plan

2. 父技能展开
   <skill name="scout-and-plan">
   Step 1: Use /skill:explore
   Step 2: Use /skill:plan
   </skill>

3. LLM 理解指令
   "我需要先调用 explore，再调用 plan"

4. LLM 生成调用命令
   /skill:explore

5. 子技能展开并执行
   [探索代码库]

6. LLM 继续执行下一步
   /skill:plan

7. 完成组合流程
```

---

## 问题 5：Skills 的验证规则是什么？如何确保技能格式正确？

### 标准答案

**Skills 有严格的验证规则，包括名称验证和描述验证。**

**名称验证规则（来自 skills.ts:91-115）：**

```typescript
function validateName(name: string, parentDirName: string): string[] {
  const errors: string[] = [];

  // 1. 必须与父目录名匹配
  if (name !== parentDirName) {
    errors.push(`name "${name}" does not match parent directory "${parentDirName}"`);
  }

  // 2. 最多 64 字符
  if (name.length > MAX_NAME_LENGTH) {
    errors.push(`name exceeds ${MAX_NAME_LENGTH} characters (${name.length})`);
  }

  // 3. 只能包含小写字母、数字、连字符
  if (!/^[a-z0-9-]+$/.test(name)) {
    errors.push(`name contains invalid characters (must be lowercase a-z, 0-9, hyphens only)`);
  }

  // 4. 不能以连字符开头或结尾
  if (name.startsWith("-") || name.endsWith("-")) {
    errors.push(`name must not start or end with a hyphen`);
  }

  // 5. 不能包含连续连字符
  if (name.includes("--")) {
    errors.push(`name must not contain consecutive hyphens`);
  }

  return errors;
}
```

**描述验证规则（来自 skills.ts:120-130）：**

```typescript
function validateDescription(description: string | undefined): string[] {
  const errors: string[] = [];

  // 1. 必需字段
  if (!description || description.trim() === "") {
    errors.push("description is required");
  }

  // 2. 最多 1024 字符
  if (description.length > MAX_DESCRIPTION_LENGTH) {
    errors.push(`description exceeds ${MAX_DESCRIPTION_LENGTH} characters`);
  }

  return errors;
}
```

### 深入理解

**验证示例：**

```yaml
# ✅ 正确的技能
---
name: code-review
description: Review code for quality and issues
---

# ❌ 名称与目录不匹配
# 目录：code-review/
---
name: codeReview  # 错误：不匹配
description: Review code
---

# ❌ 名称包含大写字母
---
name: Code-Review  # 错误：包含大写字母
description: Review code
---

# ❌ 名称包含下划线
---
name: code_review  # 错误：包含下划线
description: Review code
---

# ❌ 缺少描述
---
name: code-review
# 错误：缺少 description
---

# ❌ 描述过长
---
name: code-review
description: [超过 1024 字符的描述]  # 错误：过长
---
```

**为什么有这些规则？**

1. **名称与目录匹配** - 确保一致性，避免混淆
2. **小写字母和连字符** - 符合 URL 和文件系统规范
3. **长度限制** - 避免过长的名称和描述
4. **必需字段** - 确保技能有足够的元数据

---

## 问题 6：Skills 与 Agent Skills 开放标准的关系是什么？

### 标准答案

**Pi-mono 的 Skills 实现符合 Anthropic 推动的 Agent Skills 开放标准。**

**Agent Skills 标准（2025-2026）：**

1. **SKILL.md 文件格式**
   - 固定文件名：`SKILL.md`
   - YAML frontmatter：`name` + `description`
   - Markdown 正文：技能逻辑

2. **目录结构**
   ```
   skills/
   └── skill-name/
       └── SKILL.md
   ```

3. **元数据规范**
   ```yaml
   ---
   name: skill-name          # 必需，kebab-case
   description: ...          # 必需，简短描述
   disable-model-invocation: false  # 可选
   ---
   ```

4. **跨工具兼容**
   - Pi-mono Skills
   - Claude Code Skills
   - Vercel Agent Skills
   - Anthropic Skills Hub

**行业采用情况（2025-2026）：**

| 公司/项目 | 采用情况 | 技能数量 |
|-----------|----------|----------|
| Anthropic | 官方推动标准 | 50+ |
| Vercel | Agent Skills 市场 | 100+ |
| VoltAgent | awesome-agent-skills | 300+ |
| Google | 内部采用 | 未公开 |

**参考资源：**
- [anthropics/skills](https://github.com/anthropics/skills) - 官方仓库
- [Anthropic Makes Agent Skills an Open Standard](https://medium.com/lab7ai-insights/anthropic-makes-agent-skills-an-open-standard-for-modular-ai-agent-capabilities-781c697b4d3b)
- [Skills are the New Unit of AI Software Development](https://www.accessnewswire.com/newsroom/en/computers-technology-and-internet/skills-are-the-new-unit-of-ai-software-development-1138920)

### 深入理解

**为什么需要开放标准？**

1. **互操作性** - 不同工具可以共享技能
2. **生态系统** - 形成技能市场和社区
3. **最佳实践** - 统一的技能开发规范
4. **降低学习成本** - 一次学习，到处使用

**Pi-mono 的实现：**

```typescript
// skills.ts:66-80 - 符合标准的接口
export interface SkillFrontmatter {
  name?: string;                      // 标准字段
  description?: string;               // 标准字段
  "disable-model-invocation"?: boolean;  // 标准字段
  [key: string]: unknown;             // 扩展字段
}

export interface Skill {
  name: string;
  description: string;
  filePath: string;
  baseDir: string;
  source: string;
  disableModelInvocation: boolean;
}
```

---

## 问题 7：如何调试和测试 Skills？

### 标准答案

**Skills 调试主要通过查看展开后的文本和测试不同输入实现。**

**调试方法：**

1. **查看展开后的文本**
   ```typescript
   // agent-session.ts:883-907
   // 在 _expandSkillCommand 中添加日志
   console.log('Expanded skill:', skillBlock);
   ```

2. **测试不同输入**
   ```bash
   # 测试无参数调用
   /skill:my-skill

   # 测试带参数调用
   /skill:my-skill arg1 arg2

   # 测试长文本参数
   /skill:my-skill
   ```
   [长文本内容]
   ```
   ```

3. **验证技能加载**
   ```bash
   # 启动时查看日志
   pi --verbose

   # 检查技能列表
   /skills
   ```

4. **单元测试技能逻辑**
   ```typescript
   // 测试技能展开
   describe('Skill expansion', () => {
     it('should expand skill command', () => {
       const input = '/skill:my-skill arg';
       const output = expandSkillCommand(input);
       expect(output).toContain('<skill name="my-skill">');
       expect(output).toContain('arg');
     });
   });
   ```

**测试清单：**

- [ ] 技能文件格式正确（YAML frontmatter + Markdown）
- [ ] 名称与目录匹配
- [ ] 描述清晰且不超过 1024 字符
- [ ] 技能逻辑明确且可执行
- [ ] 参数处理正确
- [ ] 错误情况处理得当
- [ ] 与其他技能组合正常

### 深入理解

**常见问题和解决方案：**

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 技能未加载 | 文件名不是 SKILL.md | 重命名为 SKILL.md |
| 技能未加载 | 目录名与 name 不匹配 | 修改目录名或 name |
| 调用无效果 | 技能名称错误 | 检查技能名称拼写 |
| 结果不符合预期 | 技能逻辑不明确 | 添加更明确的指令 |
| 组合失败 | 步骤顺序不清晰 | 使用明确的步骤编号 |

---

## 总结：面试准备要点

### 核心概念

1. **Skills 是什么** - 模块化的 Agent 能力封装单元
2. **加载机制** - 启动时递归扫描，一次性加载
3. **调用机制** - 文本展开和注入，不是函数调用
4. **组合机制** - 提示词嵌套，依赖 LLM 理解
5. **验证规则** - 名称和描述的严格验证
6. **开放标准** - 符合 Agent Skills 标准，跨工具兼容

### 实现细节

1. **源码位置** - `packages/coding-agent/src/core/skills.ts`
2. **关键函数** - `loadSkillsFromDir`, `_expandSkillCommand`
3. **接口定义** - `Skill`, `SkillFrontmatter`
4. **验证逻辑** - `validateName`, `validateDescription`

### 2025-2026 趋势

1. **Skills 成为 AI 软件开发的新单元**
2. **SKILL.md 成为事实标准**
3. **技能市场生态形成**
4. **模块化 Agent 架构**

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
