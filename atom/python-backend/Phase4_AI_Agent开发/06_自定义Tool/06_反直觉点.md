# 自定义Tool - 反直觉点

> 3个关于自定义Tool的常见误区

---

## 误区1：Tool越多Agent越强大 ❌

### 为什么错？

**直觉想法：**
"给Agent提供100个Tool，它就能处理100种任务，比只有10个Tool的Agent强大10倍！"

**实际情况：**
Tool太多会导致：
1. **选择困难**：LLM需要从100个Tool中选择，容易选错
2. **上下文污染**：Tool描述占用大量token，挤压对话空间
3. **性能下降**：LLM分析Tool的时间变长
4. **成本增加**：更多token = 更高成本

### 为什么人们容易这样错？

**心理原因：**
- **多多益善心理**：认为功能越多越好
- **完美主义**：想要覆盖所有可能的场景
- **类比错误**：把Tool当成函数库（函数库确实越多越好）

**关键区别：**
- **函数库**：开发者明确知道调用哪个函数
- **Tool**：LLM需要从描述中推断应该调用哪个Tool

### 正确理解

**最佳实践：**
```python
# ❌ 给Agent提供所有Tool
all_tools = [
    get_weather, get_news, get_stock, get_sports,
    query_orders, query_users, query_products, query_inventory,
    send_email, send_sms, send_notification,
    read_file, write_file, delete_file, search_file,
    # ... 还有90个Tool
]

# ✅ 根据场景动态选择Tool
def get_tools_for_scenario(scenario: str):
    if scenario == "customer_service":
        return [query_orders, query_users, send_email]
    elif scenario == "data_analysis":
        return [query_database, generate_chart, export_csv]
    elif scenario == "content_creation":
        return [search_knowledge_base, generate_text, check_grammar]
    # ...
```

**经验法则：**
- **5-10个Tool**：最佳范围，LLM选择准确
- **10-20个Tool**：可接受，但要确保描述清晰
- **20+个Tool**：需要分组或动态加载

### 实际案例

**场景：智能客服Agent**

```python
# ❌ 提供所有Tool（50个）
agent = create_agent(
    tools=[
        # 订单相关（10个）
        query_order, cancel_order, refund_order, ...
        # 用户相关（10个）
        query_user, update_user, delete_user, ...
        # 产品相关（10个）
        query_product, update_inventory, ...
        # 物流相关（10个）
        track_shipment, update_address, ...
        # 支付相关（10个）
        process_payment, refund_payment, ...
    ]
)

# 用户问："我的订单ORD-123怎么样了？"
# LLM需要从50个Tool中选择
# 可能错误选择：query_user（因为描述相似）
# 耗时：5秒，成本：$0.05
```

```python
# ✅ 只提供相关Tool（5个）
agent = create_agent(
    tools=[
        query_order,        # 查询订单
        track_shipment,     # 追踪物流
        query_user,         # 查询用户信息
        send_notification,  # 发送通知
        escalate_to_human   # 转人工
    ]
)

# 用户问："我的订单ORD-123怎么样了？"
# LLM从5个Tool中选择
# 正确选择：query_order
# 耗时：2秒，成本：$0.01
```

**结果对比：**
- **准确率**：50个Tool（70%） vs 5个Tool（95%）
- **响应时间**：5秒 vs 2秒
- **成本**：$0.05 vs $0.01

---

## 误区2：Tool应该抛出异常 ❌

### 为什么错？

**直觉想法：**
"Tool遇到错误应该抛出异常，让Agent知道出错了。"

```python
@tool
def query_order(order_id: str) -> str:
    """查询订单"""
    order = db.get_order(order_id)
    if not order:
        raise ValueError(f"订单{order_id}不存在")  # ❌ 抛出异常
    return str(order)
```

**实际情况：**
- **异常会中断Agent执行**：Agent无法继续处理
- **LLM看不到错误信息**：异常被框架捕获，LLM不知道发生了什么
- **用户体验差**：直接报错，没有友好提示

### 为什么人们容易这样错？

**心理原因：**
- **编程习惯**：在普通代码中，异常是标准的错误处理方式
- **类比错误**：把Tool当成普通函数
- **忽略调用者**：忘记Tool的调用者是LLM，不是人类开发者

**关键区别：**
- **普通函数**：调用者是开发者，可以用try/catch处理异常
- **Tool**：调用者是LLM，需要文本形式的错误信息

### 正确理解

**最佳实践：**

```python
# ❌ 抛出异常
@tool
def query_order(order_id: str) -> str:
    """查询订单"""
    order = db.get_order(order_id)
    if not order:
        raise ValueError(f"订单{order_id}不存在")
    return str(order)

# ✅ 返回错误信息
@tool
def query_order(order_id: str) -> str:
    """查询订单"""
    try:
        order = db.get_order(order_id)
        if not order:
            return f"错误：订单{order_id}不存在。请检查订单号是否正确。"

        return f"""订单信息：
订单号：{order.id}
状态：{order.status}
金额：¥{order.amount}
"""
    except Exception as e:
        return f"查询订单时发生错误：{str(e)}。请稍后重试或联系客服。"
```

**为什么返回错误信息更好？**

1. **LLM能理解错误**：文本形式的错误信息，LLM可以读懂
2. **Agent可以继续**：不会中断执行，可以尝试其他方案
3. **用户体验好**：LLM可以用自然语言解释错误

### 实际案例

**场景：用户查询不存在的订单**

```python
# ❌ 抛出异常
@tool
def query_order(order_id: str) -> str:
    """查询订单"""
    order = db.get_order(order_id)
    if not order:
        raise ValueError(f"订单{order_id}不存在")
    return str(order)

# 用户问："我的订单ORD-999怎么样了？"
# Agent调用：query_order("ORD-999")
# 结果：抛出异常，Agent执行中断
# 用户看到：系统错误，请稍后重试
```

```python
# ✅ 返回错误信息
@tool
def query_order(order_id: str) -> str:
    """查询订单"""
    order = db.get_order(order_id)
    if not order:
        return f"错误：订单{order_id}不存在。请检查订单号是否正确。"
    return str(order)

# 用户问："我的订单ORD-999怎么样了？"
# Agent调用：query_order("ORD-999")
# Tool返回："错误：订单ORD-999不存在。请检查订单号是否正确。"
# LLM理解错误，生成回复：
# "抱歉，我没有找到订单号ORD-999。请确认订单号是否正确，或者提供订单的其他信息（如下单时间、商品名称）帮助我查找。"
```

**结果对比：**
- **异常方式**：系统错误，用户不知道原因
- **返回错误**：友好提示，引导用户提供正确信息

### 错误信息的最佳实践

```python
@tool
def tool_name(param: str) -> str:
    """Tool描述"""
    try:
        # 1. 参数验证错误
        if not param:
            return "错误：参数不能为空。请提供有效的参数。"

        # 2. 业务逻辑错误
        result = business_logic(param)
        if not result:
            return f"错误：未找到{param}的相关信息。请检查输入是否正确。"

        # 3. 成功返回
        return f"成功：{result}"

    except DatabaseError as e:
        # 4. 数据库错误
        return f"数据库错误：{str(e)}。请稍后重试。"

    except NetworkError as e:
        # 5. 网络错误
        return f"网络错误：{str(e)}。请检查网络连接。"

    except Exception as e:
        # 6. 未知错误
        return f"系统错误：{str(e)}。请联系技术支持。"
```

**错误信息模板：**
```
错误：[错误类型]
原因：[错误原因]
建议：[解决方案]
```

---

## 误区3：Tool描述不重要 ❌

### 为什么错？

**直觉想法：**
"Tool名称已经说明了功能，描述随便写写就行。"

```python
@tool
def get_weather(city: str) -> str:
    """获取天气"""  # ❌ 描述太简单
    return fetch_weather_api(city)
```

**实际情况：**
- **Tool描述是LLM选择Tool的唯一依据**
- **描述不清晰 = LLM选错Tool**
- **描述不完整 = LLM不知道何时用**

### 为什么人们容易这样错？

**心理原因：**
- **开发者视角**：认为函数名已经足够清晰
- **忽略调用者**：忘记调用者是LLM，不是人类
- **低估复杂度**：认为LLM"很聪明"，能自动理解

**关键区别：**
- **人类开发者**：可以看代码、问同事、查文档
- **LLM**：只能看描述，无法"理解"代码

### 正确理解

**Tool描述的重要性：**

```
用户问题："北京今天天气怎么样？"
    ↓
LLM分析：需要获取天气信息
    ↓
查看可用Tools：
    ├── get_weather: "获取天气" ← 太模糊！
    ├── get_time: "获取时间" ← 不匹配
    └── get_news: "获取新闻" ← 不匹配
    ↓
LLM困惑：get_weather能获取实时天气吗？还是历史天气？
    ↓
可能选错或不选
```

**好的描述：**

```
用户问题："北京今天天气怎么样？"
    ↓
LLM分析：需要获取天气信息
    ↓
查看可用Tools：
    ├── get_weather: "获取指定城市的实时天气信息，包括温度、天气状况、湿度、风速" ← 清晰！
    ├── get_time: "获取当前时间" ← 不匹配
    └── get_news: "获取最新新闻" ← 不匹配
    ↓
LLM确定：get_weather正是我需要的！
    ↓
调用：get_weather(city="北京")
```

### 实际案例

**场景：多个相似的Tool**

```python
# ❌ 描述不清晰
@tool
def get_order(order_id: str) -> str:
    """获取订单"""  # 获取什么信息？
    pass

@tool
def query_order(order_id: str) -> str:
    """查询订单"""  # 和get_order有什么区别？
    pass

@tool
def search_order(keyword: str) -> str:
    """搜索订单"""  # 和query_order有什么区别？
    pass

# 用户问："我的订单ORD-123怎么样了？"
# LLM困惑：应该用get_order、query_order还是search_order？
# 结果：可能选错
```

```python
# ✅ 描述清晰
@tool
def get_order_details(order_id: str) -> str:
    """获取订单详细信息

    根据订单ID查询订单的完整信息，包括：
    - 订单状态（待支付、已支付、已发货、已完成）
    - 商品列表
    - 总金额
    - 收货地址

    适用场景：
    - 用户询问"我的订单XXX怎么样了？"
    - 用户询问"订单XXX的物流信息"

    Args:
        order_id: 订单ID，格式为ORD-XXXXXX
    """
    pass

@tool
def search_orders_by_keyword(keyword: str) -> str:
    """根据关键词搜索订单

    在订单的商品名称、订单备注中搜索包含关键词的订单。

    适用场景：
    - 用户询问"我买的iPhone订单"
    - 用户询问"包含'生日礼物'的订单"

    Args:
        keyword: 搜索关键词

    Returns:
        匹配的订单列表（最多10条）
    """
    pass

@tool
def list_user_orders(user_id: int, status: str = None) -> str:
    """列出用户的所有订单

    查询指定用户的订单列表，可按状态筛选。

    适用场景：
    - 用户询问"我的所有订单"
    - 用户询问"我的待支付订单"

    Args:
        user_id: 用户ID
        status: 订单状态（可选）：pending, paid, shipped, completed

    Returns:
        订单列表（最多20条）
    """
    pass

# 用户问："我的订单ORD-123怎么样了？"
# LLM分析：
#   - get_order_details: 适用场景匹配！ ✅
#   - search_orders_by_keyword: 不匹配（需要关键词，不是订单ID）
#   - list_user_orders: 不匹配（列出所有订单，不是查询单个）
# 结果：正确选择get_order_details
```

### 描述的最佳实践

**完整的Tool描述模板：**

```python
@tool
def tool_name(param1: type1, param2: type2) -> str:
    """[一句话功能描述]

    [详细功能说明，包括：]
    - [返回什么信息1]
    - [返回什么信息2]
    - [返回什么信息3]

    适用场景：
    - [场景1：用户询问"..."]
    - [场景2：用户询问"..."]
    - [场景3：...]

    Args:
        param1: [参数1说明，包括格式、范围、示例]
        param2: [参数2说明]

    Returns:
        [返回值说明，包括格式、内容]

    注意事项：
    - [注意事项1]
    - [注意事项2]
    """
    pass
```

**描述检查清单：**

- [ ] 一句话功能描述（简洁明了）
- [ ] 详细功能说明（返回什么信息）
- [ ] 适用场景（何时使用，举例用户问题）
- [ ] 参数说明（格式、范围、示例）
- [ ] 返回值说明（格式、内容）
- [ ] 注意事项（限制、特殊情况）

### 描述质量对比

| 维度 | 差的描述 | 好的描述 |
|-----|---------|---------|
| **长度** | 1行 | 10-20行 |
| **功能说明** | "获取数据" | "获取订单的状态、商品、金额、地址" |
| **适用场景** | 无 | "用户询问'我的订单XXX怎么样了？'" |
| **参数说明** | 无 | "订单ID，格式为ORD-XXXXXX" |
| **返回值说明** | 无 | "订单详细信息的文本描述" |
| **LLM选择准确率** | 60% | 95% |

---

## 总结：3个反直觉点

### 1. Tool越多Agent越强大 ❌

**正确理解：**
- Tool数量要适中（5-10个最佳）
- 根据场景动态选择Tool
- 描述清晰比数量多更重要

**类比：**
- 工具箱里工具太多 → 找不到合适的工具
- 餐厅菜单太长 → 顾客选择困难

### 2. Tool应该抛出异常 ❌

**正确理解：**
- Tool应该返回错误信息，不是抛出异常
- LLM需要文本形式的错误信息
- 错误信息要友好、具体、可操作

**类比：**
- 抛出异常 = 服务员直接离开
- 返回错误 = 服务员解释"这道菜卖完了，推荐您试试..."

### 3. Tool描述不重要 ❌

**正确理解：**
- Tool描述是LLM选择Tool的唯一依据
- 描述要详细、清晰、包含适用场景
- 好的描述 = 95%准确率，差的描述 = 60%准确率

**类比：**
- 差的描述 = 工具说明书只写"工具"
- 好的描述 = 工具说明书详细说明用途、使用方法、注意事项

---

## 避免误区的实践建议

### 1. Tool数量控制

```python
# 定义Tool分组
CUSTOMER_SERVICE_TOOLS = [query_order, query_user, send_email]
DATA_ANALYSIS_TOOLS = [query_database, generate_chart, export_csv]
CONTENT_CREATION_TOOLS = [search_kb, generate_text, check_grammar]

# 根据场景选择
def create_agent_for_scenario(scenario: str):
    if scenario == "customer_service":
        tools = CUSTOMER_SERVICE_TOOLS
    elif scenario == "data_analysis":
        tools = DATA_ANALYSIS_TOOLS
    # ...
    return create_agent(tools=tools)
```

### 2. 错误处理模板

```python
@tool
def tool_name(param: str) -> str:
    """Tool描述"""
    try:
        # 业务逻辑
        result = do_something(param)
        if not result:
            return "错误：未找到结果。建议：..."
        return f"成功：{result}"
    except Exception as e:
        return f"错误：{str(e)}。建议：请稍后重试或联系客服。"
```

### 3. 描述模板

```python
@tool
def tool_name(param: str) -> str:
    """[一句话功能]

    [详细说明]
    - [返回信息1]
    - [返回信息2]

    适用场景：
    - [场景1]
    - [场景2]

    Args:
        param: [参数说明]

    Returns:
        [返回值说明]
    """
    pass
```

---

**记住：**
- **少而精** > 多而杂
- **返回错误** > 抛出异常
- **详细描述** > 简单描述
