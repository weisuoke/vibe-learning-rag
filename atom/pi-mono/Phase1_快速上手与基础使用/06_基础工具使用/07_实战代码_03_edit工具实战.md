# edit å·¥å…·å®æˆ˜

> å®Œæ•´çš„ TypeScript ç¤ºä¾‹å±•ç¤º edit å·¥å…·çš„å®é™…åº”ç”¨åœºæ™¯

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› edit å·¥å…·çš„å®Œæ•´å®æˆ˜ç¤ºä¾‹ï¼Œæ‰€æœ‰ä»£ç éƒ½å¯ä»¥ç›´æ¥è¿è¡Œã€‚

---

## åœºæ™¯ 1ï¼šè‡ªåŠ¨é‡æ„å·¥å…·

**ä»»åŠ¡ï¼š** æ‰¹é‡é‡æ„ä»£ç ï¼Œé‡å‘½åå˜é‡å’Œå‡½æ•°

```typescript
// auto-refactor.ts
import fs from 'fs'
import path from 'path'

interface RefactorRule {
  type: 'rename' | 'replace' | 'extract'
  pattern: string
  replacement: string
  files?: string[]
}

class AutoRefactor {
  /**
   * æ‰§è¡Œé‡æ„è§„åˆ™
   */
  async applyRefactorRules(rules: RefactorRule[]): Promise<void> {
    console.log(`\nğŸ”§ Applying ${rules.length} refactor rules\n`)

    for (const rule of rules) {
      await this.applyRule(rule)
    }

    console.log(`\nâœ… Refactoring completed!`)
  }

  /**
   * åº”ç”¨å•ä¸ªè§„åˆ™
   */
  private async applyRule(rule: RefactorRule): Promise<void> {
    console.log(`\nğŸ“ Applying rule: ${rule.type}`)
    console.log(`   Pattern: ${rule.pattern}`)
    console.log(`   Replacement: ${rule.replacement}`)

    const files = rule.files || this.findTSFiles('./src')

    for (const file of files) {
      await this.refactorFile(file, rule)
    }
  }

  /**
   * é‡æ„å•ä¸ªæ–‡ä»¶
   */
  private async refactorFile(filePath: string, rule: RefactorRule): Promise<void> {
    if (!fs.existsSync(filePath)) {
      console.log(`   âš ï¸  File not found: ${filePath}`)
      return
    }

    const content = fs.readFileSync(filePath, 'utf-8')

    // æ£€æŸ¥æ˜¯å¦åŒ…å«è¦æ›¿æ¢çš„å†…å®¹
    if (!content.includes(rule.pattern)) {
      return
    }

    // æ‰§è¡Œæ›¿æ¢
    const newContent = content.replace(new RegExp(rule.pattern, 'g'), rule.replacement)

    // å†™å…¥æ–‡ä»¶
    fs.writeFileSync(filePath, newContent, 'utf-8')

    console.log(`   âœ“ Updated: ${filePath}`)
  }

  /**
   * æŸ¥æ‰¾æ‰€æœ‰ TS æ–‡ä»¶
   */
  private findTSFiles(dir: string): string[] {
    const files: string[] = []

    const walk = (currentDir: string) => {
      const entries = fs.readdirSync(currentDir, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name)

        if (entry.isDirectory() && !['node_modules', 'dist'].includes(entry.name)) {
          walk(fullPath)
        } else if (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx')) {
          files.push(fullPath)
        }
      }
    }

    walk(dir)
    return files
  }

  /**
   * é‡å‘½åå‡½æ•°
   */
  async renameFunction(oldName: string, newName: string, files?: string[]): Promise<void> {
    console.log(`\nğŸ”„ Renaming function: ${oldName} â†’ ${newName}`)

    const targetFiles = files || this.findTSFiles('./src')

    for (const file of targetFiles) {
      const content = fs.readFileSync(file, 'utf-8')

      // æ›¿æ¢å‡½æ•°å®šä¹‰
      let updated = content.replace(
        new RegExp(`function\\s+${oldName}\\s*\\(`, 'g'),
        `function ${newName}(`
      )

      // æ›¿æ¢å‡½æ•°è°ƒç”¨
      updated = updated.replace(
        new RegExp(`${oldName}\\s*\\(`, 'g'),
        `${newName}(`
      )

      if (updated !== content) {
        fs.writeFileSync(file, updated, 'utf-8')
        console.log(`   âœ“ Updated: ${file}`)
      }
    }
  }

  /**
   * æ›´æ–°å¯¼å…¥è·¯å¾„
   */
  async updateImportPaths(oldPath: string, newPath: string): Promise<void> {
    console.log(`\nğŸ“¦ Updating import paths: ${oldPath} â†’ ${newPath}`)

    const files = this.findTSFiles('./src')

    for (const file of files) {
      const content = fs.readFileSync(file, 'utf-8')

      // æ›¿æ¢ import è¯­å¥
      const updated = content.replace(
        new RegExp(`from\\s+['"]${oldPath}['"]`, 'g'),
        `from '${newPath}'`
      )

      if (updated !== content) {
        fs.writeFileSync(file, updated, 'utf-8')
        console.log(`   âœ“ Updated: ${file}`)
      }
    }
  }

  /**
   * æ·»åŠ ç±»å‹æ³¨è§£
   */
  async addTypeAnnotations(filePath: string): Promise<void> {
    console.log(`\nğŸ·ï¸  Adding type annotations to: ${filePath}`)

    const content = fs.readFileSync(filePath, 'utf-8')
    const lines = content.split('\n')
    let updated = false

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i]

      // æ£€æµ‹æ²¡æœ‰ç±»å‹æ³¨è§£çš„å‡½æ•°å‚æ•°
      const match = line.match(/function\s+\w+\s*\(([^)]+)\)/)
      if (match) {
        const params = match[1]
        if (!params.includes(':')) {
          // æ·»åŠ  any ç±»å‹æ³¨è§£
          const annotatedParams = params
            .split(',')
            .map(p => `${p.trim()}: any`)
            .join(', ')

          lines[i] = line.replace(params, annotatedParams)
          updated = true
        }
      }
    }

    if (updated) {
      fs.writeFileSync(filePath, lines.join('\n'), 'utf-8')
      console.log(`   âœ“ Type annotations added`)
    } else {
      console.log(`   â„¹ï¸  No changes needed`)
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const refactor = new AutoRefactor()

  // ç¤ºä¾‹ 1ï¼šé‡å‘½åå‡½æ•°
  await refactor.renameFunction('oldFunctionName', 'newFunctionName')

  // ç¤ºä¾‹ 2ï¼šæ›´æ–°å¯¼å…¥è·¯å¾„
  await refactor.updateImportPaths('./utils/old', './utils/new')

  // ç¤ºä¾‹ 3ï¼šæ‰¹é‡åº”ç”¨è§„åˆ™
  await refactor.applyRefactorRules([
    {
      type: 'rename',
      pattern: 'getUserData',
      replacement: 'fetchUserData'
    },
    {
      type: 'replace',
      pattern: 'var ',
      replacement: 'const '
    }
  ])

  // ç¤ºä¾‹ 4ï¼šæ·»åŠ ç±»å‹æ³¨è§£
  await refactor.addTypeAnnotations('src/legacy.ts')
}

main()
```

---

## åœºæ™¯ 2ï¼šä»£ç æ ¼å¼åŒ–å·¥å…·

**ä»»åŠ¡ï¼š** è‡ªåŠ¨ä¿®å¤å¸¸è§çš„ä»£ç æ ¼å¼é—®é¢˜

```typescript
// code-formatter.ts
import fs from 'fs'

interface FormatRule {
  name: string
  pattern: RegExp
  replacement: string
  description: string
}

class CodeFormatter {
  private rules: FormatRule[] = [
    {
      name: 'trailing-semicolon',
      pattern: /([^;])\n/g,
      replacement: '$1;\n',
      description: 'Add missing semicolons'
    },
    {
      name: 'double-quotes',
      pattern: /'([^']*)'/g,
      replacement: '"$1"',
      description: 'Convert single quotes to double quotes'
    },
    {
      name: 'spacing-operators',
      pattern: /(\w+)=(\w+)/g,
      replacement: '$1 = $2',
      description: 'Add spaces around operators'
    },
    {
      name: 'trailing-whitespace',
      pattern: /[ \t]+$/gm,
      replacement: '',
      description: 'Remove trailing whitespace'
    },
    {
      name: 'multiple-blank-lines',
      pattern: /\n{3,}/g,
      replacement: '\n\n',
      description: 'Remove multiple blank lines'
    }
  ]

  /**
   * æ ¼å¼åŒ–æ–‡ä»¶
   */
  async formatFile(filePath: string, ruleNames?: string[]): Promise<void> {
    console.log(`\nâœ¨ Formatting: ${filePath}`)

    const content = fs.readFileSync(filePath, 'utf-8')
    let formatted = content

    // åº”ç”¨è§„åˆ™
    const rulesToApply = ruleNames
      ? this.rules.filter(r => ruleNames.includes(r.name))
      : this.rules

    for (const rule of rulesToApply) {
      const before = formatted
      formatted = formatted.replace(rule.pattern, rule.replacement)

      if (before !== formatted) {
        console.log(`   âœ“ Applied: ${rule.description}`)
      }
    }

    // å†™å…¥æ–‡ä»¶
    if (formatted !== content) {
      fs.writeFileSync(filePath, formatted, 'utf-8')
      console.log(`   âœ… File formatted`)
    } else {
      console.log(`   â„¹ï¸  No changes needed`)
    }
  }

  /**
   * ä¿®å¤ç¼©è¿›
   */
  async fixIndentation(filePath: string, indentSize: number = 2): Promise<void> {
    console.log(`\nğŸ“ Fixing indentation: ${filePath}`)

    const content = fs.readFileSync(filePath, 'utf-8')
    const lines = content.split('\n')
    const fixed: string[] = []
    let indentLevel = 0

    for (const line of lines) {
      const trimmed = line.trim()

      // å‡å°‘ç¼©è¿›ï¼ˆé—­åˆæ‹¬å·ï¼‰
      if (trimmed.startsWith('}') || trimmed.startsWith(']') || trimmed.startsWith(')')) {
        indentLevel = Math.max(0, indentLevel - 1)
      }

      // æ·»åŠ ç¼©è¿›
      const indent = ' '.repeat(indentLevel * indentSize)
      fixed.push(indent + trimmed)

      // å¢åŠ ç¼©è¿›ï¼ˆå¼€æ”¾æ‹¬å·ï¼‰
      if (trimmed.endsWith('{') || trimmed.endsWith('[') || trimmed.endsWith('(')) {
        indentLevel++
      }
    }

    const formatted = fixed.join('\n')
    if (formatted !== content) {
      fs.writeFileSync(filePath, formatted, 'utf-8')
      console.log(`   âœ… Indentation fixed`)
    } else {
      console.log(`   â„¹ï¸  No changes needed`)
    }
  }

  /**
   * ç»„ç»‡å¯¼å…¥è¯­å¥
   */
  async organizeImports(filePath: string): Promise<void> {
    console.log(`\nğŸ“¦ Organizing imports: ${filePath}`)

    const content = fs.readFileSync(filePath, 'utf-8')
    const lines = content.split('\n')

    // æå–å¯¼å…¥è¯­å¥
    const imports: string[] = []
    const otherLines: string[] = []
    let inImportSection = true

    for (const line of lines) {
      if (line.trim().startsWith('import ')) {
        imports.push(line)
      } else if (line.trim() === '' && inImportSection) {
        // è·³è¿‡å¯¼å…¥éƒ¨åˆ†çš„ç©ºè¡Œ
      } else {
        inImportSection = false
        otherLines.push(line)
      }
    }

    // æ’åºå¯¼å…¥
    const sortedImports = imports.sort((a, b) => {
      // ç¬¬ä¸‰æ–¹åº“ä¼˜å…ˆ
      const aIsThirdParty = !a.includes('./') && !a.includes('../')
      const bIsThirdParty = !b.includes('./') && !b.includes('../')

      if (aIsThirdParty && !bIsThirdParty) return -1
      if (!aIsThirdParty && bIsThirdParty) return 1

      return a.localeCompare(b)
    })

    // é‡æ–°ç»„åˆ
    const organized = [...sortedImports, '', ...otherLines].join('\n')

    if (organized !== content) {
      fs.writeFileSync(filePath, organized, 'utf-8')
      console.log(`   âœ… Imports organized`)
    } else {
      console.log(`   â„¹ï¸  No changes needed`)
    }
  }

  /**
   * æ·»åŠ ç¼ºå¤±çš„åˆ†å·
   */
  async addSemicolons(filePath: string): Promise<void> {
    console.log(`\n; Adding semicolons: ${filePath}`)

    const content = fs.readFileSync(filePath, 'utf-8')
    const lines = content.split('\n')
    const fixed: string[] = []

    for (const line of lines) {
      const trimmed = line.trim()

      // éœ€è¦åˆ†å·çš„è¡Œ
      if (
        trimmed &&
        !trimmed.endsWith(';') &&
        !trimmed.endsWith('{') &&
        !trimmed.endsWith('}') &&
        !trimmed.startsWith('//') &&
        !trimmed.startsWith('/*') &&
        !trimmed.startsWith('*')
      ) {
        fixed.push(line + ';')
      } else {
        fixed.push(line)
      }
    }

    const formatted = fixed.join('\n')
    if (formatted !== content) {
      fs.writeFileSync(filePath, formatted, 'utf-8')
      console.log(`   âœ… Semicolons added`)
    } else {
      console.log(`   â„¹ï¸  No changes needed`)
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const formatter = new CodeFormatter()

  // æ ¼å¼åŒ–å•ä¸ªæ–‡ä»¶
  await formatter.formatFile('src/app.ts')

  // ä¿®å¤ç¼©è¿›
  await formatter.fixIndentation('src/messy.ts', 2)

  // ç»„ç»‡å¯¼å…¥
  await formatter.organizeImports('src/index.ts')

  // æ·»åŠ åˆ†å·
  await formatter.addSemicolons('src/legacy.js')
}

main()
```

---

## åœºæ™¯ 3ï¼šç‰ˆæœ¬è¿ç§»å·¥å…·

**ä»»åŠ¡ï¼š** è‡ªåŠ¨è¿ç§»ä»£ç åˆ°æ–°ç‰ˆæœ¬ API

```typescript
// version-migrator.ts
import fs from 'fs'
import path from 'path'

interface MigrationRule {
  from: string
  to: string
  description: string
  filePattern?: RegExp
}

class VersionMigrator {
  /**
   * è¿ç§»åˆ°æ–°ç‰ˆæœ¬
   */
  async migrateToVersion(
    fromVersion: string,
    toVersion: string,
    projectDir: string
  ): Promise<void> {
    console.log(`\nğŸš€ Migrating from ${fromVersion} to ${toVersion}\n`)

    const rules = this.getMigrationRules(fromVersion, toVersion)
    const files = this.findFiles(projectDir)

    let totalChanges = 0

    for (const file of files) {
      const changes = await this.migrateFile(file, rules)
      totalChanges += changes
    }

    console.log(`\nâœ… Migration completed!`)
    console.log(`   Total changes: ${totalChanges}`)
  }

  /**
   * è·å–è¿ç§»è§„åˆ™
   */
  private getMigrationRules(from: string, to: string): MigrationRule[] {
    // React 16 â†’ 17 è¿ç§»è§„åˆ™ç¤ºä¾‹
    if (from === '16' && to === '17') {
      return [
        {
          from: 'import React from "react"',
          to: 'import React from "react"\nimport { render } from "react-dom"',
          description: 'Update React imports'
        },
        {
          from: 'ReactDOM.render(',
          to: 'render(',
          description: 'Use new render API'
        },
        {
          from: 'componentWillMount',
          to: 'componentDidMount',
          description: 'Replace deprecated lifecycle'
        },
        {
          from: 'componentWillReceiveProps',
          to: 'componentDidUpdate',
          description: 'Replace deprecated lifecycle'
        }
      ]
    }

    // TypeScript 4 â†’ 5 è¿ç§»è§„åˆ™ç¤ºä¾‹
    if (from === '4' && to === '5') {
      return [
        {
          from: 'namespace ',
          to: 'module ',
          description: 'Replace namespace with module'
        },
        {
          from: '<any>',
          to: 'as any',
          description: 'Use as syntax for type assertions'
        }
      ]
    }

    return []
  }

  /**
   * è¿ç§»å•ä¸ªæ–‡ä»¶
   */
  private async migrateFile(filePath: string, rules: MigrationRule[]): Promise<number> {
    const content = fs.readFileSync(filePath, 'utf-8')
    let updated = content
    let changes = 0

    for (const rule of rules) {
      // æ£€æŸ¥æ–‡ä»¶æ¨¡å¼
      if (rule.filePattern && !rule.filePattern.test(filePath)) {
        continue
      }

      // åº”ç”¨è§„åˆ™
      const before = updated
      updated = updated.replace(new RegExp(rule.from, 'g'), rule.to)

      if (before !== updated) {
        changes++
        console.log(`   âœ“ ${path.basename(filePath)}: ${rule.description}`)
      }
    }

    // å†™å…¥æ–‡ä»¶
    if (updated !== content) {
      fs.writeFileSync(filePath, updated, 'utf-8')
    }

    return changes
  }

  /**
   * æŸ¥æ‰¾æ–‡ä»¶
   */
  private findFiles(dir: string): string[] {
    const files: string[] = []

    const walk = (currentDir: string) => {
      const entries = fs.readdirSync(currentDir, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name)

        if (entry.isDirectory() && !['node_modules', 'dist'].includes(entry.name)) {
          walk(fullPath)
        } else if (entry.name.match(/\.(ts|tsx|js|jsx)$/)) {
          files.push(fullPath)
        }
      }
    }

    walk(dir)
    return files
  }

  /**
   * æ›´æ–° package.json ä¾èµ–
   */
  async updateDependencies(
    packageJsonPath: string,
    updates: Record<string, string>
  ): Promise<void> {
    console.log(`\nğŸ“¦ Updating dependencies in ${packageJsonPath}`)

    const content = fs.readFileSync(packageJsonPath, 'utf-8')
    const pkg = JSON.parse(content)

    // æ›´æ–°ä¾èµ–ç‰ˆæœ¬
    for (const [dep, version] of Object.entries(updates)) {
      if (pkg.dependencies?.[dep]) {
        pkg.dependencies[dep] = version
        console.log(`   âœ“ ${dep}: ${pkg.dependencies[dep]} â†’ ${version}`)
      }

      if (pkg.devDependencies?.[dep]) {
        pkg.devDependencies[dep] = version
        console.log(`   âœ“ ${dep}: ${pkg.devDependencies[dep]} â†’ ${version}`)
      }
    }

    // å†™å…¥æ–‡ä»¶
    fs.writeFileSync(packageJsonPath, JSON.stringify(pkg, null, 2))
    console.log(`   âœ… Dependencies updated`)
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const migrator = new VersionMigrator()

  // è¿ç§» React ç‰ˆæœ¬
  await migrator.migrateToVersion('16', '17', './src')

  // æ›´æ–° package.json
  await migrator.updateDependencies('package.json', {
    'react': '^17.0.0',
    'react-dom': '^17.0.0',
    '@types/react': '^17.0.0'
  })
}

main()
```

---

## åœºæ™¯ 4ï¼šä»£ç è´¨é‡ä¿®å¤å·¥å…·

**ä»»åŠ¡ï¼š** è‡ªåŠ¨ä¿®å¤å¸¸è§çš„ä»£ç è´¨é‡é—®é¢˜

```typescript
// code-quality-fixer.ts
import fs from 'fs'

interface QualityIssue {
  type: string
  line: number
  message: string
  fix?: () => void
}

class CodeQualityFixer {
  /**
   * ä¿®å¤æ–‡ä»¶ä¸­çš„è´¨é‡é—®é¢˜
   */
  async fixQualityIssues(filePath: string): Promise<void> {
    console.log(`\nğŸ” Analyzing: ${filePath}`)

    const content = fs.readFileSync(filePath, 'utf-8')
    let fixed = content

    // åº”ç”¨ä¿®å¤
    fixed = this.removeConsoleLog(fixed)
    fixed = this.fixVarDeclarations(fixed)
    fixed = this.addStrictEquality(fixed)
    fixed = this.removeUnusedImports(fixed)
    fixed = this.fixAsyncAwait(fixed)

    // å†™å…¥æ–‡ä»¶
    if (fixed !== content) {
      fs.writeFileSync(filePath, fixed, 'utf-8')
      console.log(`   âœ… Quality issues fixed`)
    } else {
      console.log(`   â„¹ï¸  No issues found`)
    }
  }

  /**
   * ç§»é™¤ console.log
   */
  private removeConsoleLog(content: string): string {
    return content.replace(/console\.log\([^)]*\);?\n?/g, '')
  }

  /**
   * ä¿®å¤ var å£°æ˜
   */
  private fixVarDeclarations(content: string): string {
    return content.replace(/\bvar\b/g, 'const')
  }

  /**
   * ä½¿ç”¨ä¸¥æ ¼ç›¸ç­‰
   */
  private addStrictEquality(content: string): string {
    let fixed = content
    fixed = fixed.replace(/([^=!])={2}([^=])/g, '$1===$2')
    fixed = fixed.replace(/([^=!])!={1}([^=])/g, '$1!==$2')
    return fixed
  }

  /**
   * ç§»é™¤æœªä½¿ç”¨çš„å¯¼å…¥
   */
  private removeUnusedImports(content: string): string {
    const lines = content.split('\n')
    const imports: Map<string, string> = new Map()
    const usedImports: Set<string> = new Set()

    // æå–å¯¼å…¥
    for (const line of lines) {
      const match = line.match(/import\s+{([^}]+)}\s+from/)
      if (match) {
        const imported = match[1].split(',').map(s => s.trim())
        imported.forEach(imp => imports.set(imp, line))
      }
    }

    // æ£€æŸ¥ä½¿ç”¨æƒ…å†µ
    for (const [imp] of imports) {
      const regex = new RegExp(`\\b${imp}\\b`)
      if (content.match(regex)?.length > 1) {
        usedImports.add(imp)
      }
    }

    // ç§»é™¤æœªä½¿ç”¨çš„å¯¼å…¥
    let fixed = content
    for (const [imp, line] of imports) {
      if (!usedImports.has(imp)) {
        fixed = fixed.replace(line + '\n', '')
      }
    }

    return fixed
  }

  /**
   * ä¿®å¤ async/await
   */
  private fixAsyncAwait(content: string): string {
    // ä¸º Promise è°ƒç”¨æ·»åŠ  await
    return content.replace(
      /(\w+)\.(then|catch)\(/g,
      'await $1.$2('
    )
  }

  /**
   * æ·»åŠ é”™è¯¯å¤„ç†
   */
  async addErrorHandling(filePath: string): Promise<void> {
    console.log(`\nğŸ›¡ï¸  Adding error handling: ${filePath}`)

    const content = fs.readFileSync(filePath, 'utf-8')
    const lines = content.split('\n')
    const fixed: string[] = []
    let inTryCatch = false

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i]

      // æ£€æµ‹ async å‡½æ•°
      if (line.includes('async function') || line.includes('async (')) {
        fixed.push(line)

        // æŸ¥æ‰¾å‡½æ•°ä½“å¼€å§‹
        let j = i + 1
        while (j < lines.length && !lines[j].includes('{')) {
          fixed.push(lines[j])
          j++
        }

        if (j < lines.length) {
          fixed.push(lines[j])  // {
          fixed.push('  try {')
          i = j
          inTryCatch = true
        }
      } else if (inTryCatch && line.trim() === '}') {
        fixed.push('  } catch (error) {')
        fixed.push('    console.error("Error:", error)')
        fixed.push('    throw error')
        fixed.push('  }')
        fixed.push(line)
        inTryCatch = false
      } else {
        fixed.push(line)
      }
    }

    fs.writeFileSync(filePath, fixed.join('\n'), 'utf-8')
    console.log(`   âœ… Error handling added`)
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const fixer = new CodeQualityFixer()

  // ä¿®å¤è´¨é‡é—®é¢˜
  await fixer.fixQualityIssues('src/app.ts')

  // æ·»åŠ é”™è¯¯å¤„ç†
  await fixer.addErrorHandling('src/api.ts')
}

main()
```

---

## æœ€ä½³å®è·µæ€»ç»“

### 1. å…ˆè¯»åæ”¹

```typescript
// âœ… å¥½çš„åšæ³•
const content = fs.readFileSync(filePath, 'utf-8')
const updated = content.replace(oldText, newText)
fs.writeFileSync(filePath, updated, 'utf-8')
```

### 2. ç²¾ç¡®åŒ¹é…

```typescript
// âœ… å¥½çš„åšæ³•ï¼šæä¾›è¶³å¤Ÿä¸Šä¸‹æ–‡
const updated = content.replace(
  'function oldName() {',
  'function newName() {'
)
```

### 3. æ‰¹é‡æ“ä½œ

```typescript
// âœ… å¥½çš„åšæ³•ï¼šä¸€æ¬¡æ€§åº”ç”¨å¤šä¸ªè§„åˆ™
let updated = content
updated = updated.replace(rule1.pattern, rule1.replacement)
updated = updated.replace(rule2.pattern, rule2.replacement)
fs.writeFileSync(filePath, updated, 'utf-8')
```

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2026-02-19
**ç»´æŠ¤è€…ï¼š** Claude Code
