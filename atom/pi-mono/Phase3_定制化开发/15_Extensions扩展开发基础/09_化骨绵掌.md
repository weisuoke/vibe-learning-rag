# Extensions 扩展开发基础 - 化骨绵掌

> 10个2分钟知识卡片，系统掌握 Extensions 核心知识

---

## 使用说明

**化骨绵掌**：将复杂知识拆分成独立的小卡片，每个卡片2分钟内可以看完。

- 每个卡片独立完整，可单独理解
- 10个卡片形成递进关系，系统学习
- 适合碎片化时间学习和快速复习

---

## 卡片 1：直觉理解 - Extensions 是什么

**一句话：** Extensions 是 pi-mono 的"插件商店"，让你在不修改源码的情况下添加新功能。

**举例：**

想象你买了一台 iPhone：
- 手机本身有基础功能（打电话、发短信）
- App Store 让你安装各种 App（微信、抖音、游戏）
- 每个 App 扩展了手机的能力
- 你可以随时安装、卸载、更新 App

pi-mono 的 Extensions 就是这样：
- pi-mono 本身有基础功能（read、write、bash 工具）
- Extensions 让你添加自定义工具（todo、calculator、deploy）
- 每个 Extension 扩展了 Agent 的能力
- 你可以随时加载、卸载、热重载 Extensions

**代码示例：**

```typescript
// 最简单的 Extension
export default function (pi: ExtensionAPI) {
  console.log("Extension loaded!");
}
```

**应用：** 当你需要项目特定的功能（如数据库查询、API 调用）时，不需要 fork pi-mono，只需写一个 Extension。

---

## 卡片 2：形式化定义 - Extensions 的精确表述

**一句话：** Extensions 是在运行时动态加载的 TypeScript 模块，通过 ExtensionAPI 访问宿主程序的内部能力。

**精确定义：**

```
Extension := (pi: ExtensionAPI) => void

ExtensionAPI := {
  registerTool: (definition: ToolDefinition) => void
  registerCommand: (name: string, config: CommandConfig) => void
  on: <E extends EventType>(event: E, handler: EventHandler<E>) => void
  off: <E extends EventType>(event: E, handler: EventHandler<E>) => void
  ...
}
```

**关键要素：**

1. **TypeScript 模块**：`.ts` 文件，导出默认函数
2. **运行时加载**：使用 jiti 动态加载，无需编译
3. **ExtensionAPI**：统一接口，提供注册和监听能力
4. **类型安全**：完整的 TypeScript 类型定义

**与其他概念的区别：**

| 概念 | 加载时机 | 语言 | 能力 |
|------|---------|------|------|
| **Extension** | 运行时 | TypeScript | 完全控制 |
| **Skill** | 运行时 | Markdown | 提示词封装 |
| **Plugin (Webpack)** | 编译时 | JavaScript | 构建过程 |

**应用：** 理解 Extensions 的形式化定义，有助于设计更好的扩展架构。

---

## 卡片 3：关键概念 1 - 工具注册（registerTool）

**一句话：** registerTool 让你添加新的工具，Agent 可以像使用内置工具一样使用它们。

**核心 API：**

```typescript
pi.registerTool({
  name: "tool_name",           // 工具名称（唯一标识）
  label: "Tool Label",         // UI 显示标签
  description: "...",          // 工具描述（Agent 理解用途）
  parameters: Type.Object({    // 参数 schema（TypeBox）
    param1: Type.String(),
  }),
  async execute(toolCallId, params, signal, onUpdate, ctx) {
    // 执行逻辑
    return {
      content: [{ type: "text", text: "Result" }],
      details: { /* 状态数据 */ },
    };
  },
});
```

**关键点：**

1. **name**：必须唯一，Agent 通过 name 调用工具
2. **parameters**：使用 TypeBox 定义 schema（不是 Zod）
3. **execute**：异步函数，返回 `{ content, details }`
4. **details**：状态数据，会被持久化到 Session

**实际示例：**

```typescript
// 添加一个天气查询工具
pi.registerTool({
  name: "weather",
  description: "Get weather for a city",
  parameters: Type.Object({
    city: Type.String({ description: "City name" }),
  }),
  async execute(toolCallId, params, signal, onUpdate, ctx) {
    const { city } = params as { city: string };
    const weather = await fetchWeather(city);
    return {
      content: [{ type: "text", text: `${city}: ${weather}` }],
      details: { city, weather },
    };
  },
});
```

**应用：** 为项目添加特定的工具（数据库查询、API 调用、部署脚本）。

---

## 卡片 4：关键概念 2 - 事件监听（on/off）

**一句话：** 事件监听让你在关键时刻介入 Agent 的执行流程，可以读取、修改、阻止事件。

**核心 API：**

```typescript
pi.on(eventType, async (event, ctx) => {
  // 1. 读取事件信息
  console.log(event);

  // 2. 阻止事件
  if (shouldBlock) {
    return { block: true, reason: "Blocked" };
  }

  // 3. 转换事件
  if (shouldTransform) {
    return { transform: modifiedEvent };
  }

  // 4. 允许继续（不返回）
});
```

**常用事件：**

| 事件 | 触发时机 | 用途 |
|------|---------|------|
| `tool_call` | 工具调用前 | 拦截、记录、修改 |
| `tool_result` | 工具调用后 | 处理结果 |
| `session_start` | Session 启动 | 初始化状态 |
| `session_fork` | Session 分支 | 重建状态 |
| `input` | 用户输入后 | 转换输入 |
| `agent_turn_start` | Agent 回合开始 | 更新 UI |

**实际示例：**

```typescript
// 安全防护：拦截危险命令
pi.on("tool_call", async (event, ctx) => {
  if (event.toolName === "bash" && event.input.command?.includes("rm -rf")) {
    const ok = await ctx.ui.confirm("Dangerous!", "Allow rm -rf?");
    if (!ok) {
      return { block: true, reason: "Blocked by user" };
    }
  }
});
```

**应用：** 实现安全防护、日志记录、性能监控、工作流控制。

---

## 卡片 5：编程实现 - 状态管理模式

**一句话：** Extensions 的状态必须存储在 tool result details 中，通过 Session 历史重建，以支持分支。

**为什么不用外部文件？**

```typescript
// ❌ 错误：外部文件
const todosFile = "~/.pi/todos.json";
// 问题：Session 分支会共享同一个文件，状态会混乱

// ✅ 正确：details 存储
return {
  content: [...],
  details: { todos: [...todos] }, // 每个分支独立
};
```

**完整模式：**

```typescript
export default function (pi: ExtensionAPI) {
  // 1. 内存状态
  let todos: Todo[] = [];

  // 2. 重建函数
  const reconstructState = (ctx: ExtensionContext) => {
    todos = [];
    for (const entry of ctx.sessionManager.getBranch()) {
      if (entry.type === "message" && entry.message.toolName === "todo") {
        todos = entry.message.details.todos;
      }
    }
  };

  // 3. 监听 Session 事件
  pi.on("session_start", async (_, ctx) => reconstructState(ctx));
  pi.on("session_fork", async (_, ctx) => reconstructState(ctx));

  // 4. 工具执行时保存状态
  pi.registerTool({
    name: "todo",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      todos.push(newTodo);
      return {
        content: [...],
        details: { todos: [...todos] }, // 保存完整状态
      };
    },
  });
}
```

**关键点：**
1. 状态存储在 details（不是外部文件）
2. Session 事件时重建状态
3. 遍历分支历史恢复状态
4. 每次工具调用保存完整状态快照

**应用：** 实现 todo 列表、书签、笔记等有状态的功能。

---

## 卡片 6：对比区分 - Extensions vs Skills vs Prompt Templates

**一句话：** Extensions 是编程控制，Skills 是功能封装，Prompt Templates 是提示词复用。

**对比表：**

| 特性 | Prompt Templates | Skills | Extensions |
|------|-----------------|--------|-----------|
| **语言** | Markdown | Markdown | TypeScript |
| **复杂度** | 低 | 中 | 高 |
| **能力** | 提示词复用 | 功能封装 | 完全控制 |
| **状态管理** | 无 | 无 | 完整支持 |
| **事件监听** | 无 | 无 | 30+ 事件 |
| **UI 定制** | 无 | 无 | 完全支持 |
| **调用方式** | 模板变量 | `/skill:name` | 自动集成 |
| **适用场景** | 简单提示词 | 可复用功能 | 复杂系统集成 |

**选择建议：**

```
需求：复用一段提示词
→ Prompt Templates

需求：封装一个可复用的功能（如代码审查）
→ Skills

需求：添加自定义工具、拦截事件、管理状态
→ Extensions
```

**实际示例：**

```markdown
<!-- Prompt Template: code-review.md -->
请审查以下代码：
{{code}}

关注点：
- 代码质量
- 安全性
- 性能
```

```markdown
<!-- Skill: SKILL.md -->
# Code Review Skill
审查代码并提供改进建议
```

```typescript
// Extension: code-review.ts
export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "code_review",
    // 完整的编程控制
  });
}
```

**应用：** 根据需求选择合适的定制化方式。

---

## 卡片 7：进阶理解 - 事件系统的责任链模式

**一句话：** 多个 Extensions 的事件监听器形成责任链，任何一个可以阻止事件继续传播。

**责任链模式：**

```
事件触发
  ↓
Extension 1: 权限检查
  ├→ 通过 → 继续
  └→ 阻止 → 返回 { block: true }
  ↓
Extension 2: 安全检查
  ├→ 通过 → 继续
  └→ 阻止 → 返回 { block: true }
  ↓
Extension 3: 配额检查
  ├→ 通过 → 继续
  └→ 阻止 → 返回 { block: true }
  ↓
执行工具
```

**代码示例：**

```typescript
// Extension 1: 权限检查
pi.on("tool_call", async (event, ctx) => {
  if (!hasPermission(event)) {
    return { block: true, reason: "No permission" };
  }
  // 通过，继续下一个
});

// Extension 2: 安全检查
pi.on("tool_call", async (event, ctx) => {
  if (isDangerous(event)) {
    return { block: true, reason: "Dangerous" };
  }
  // 通过，继续下一个
});

// Extension 3: 配额检查
pi.on("tool_call", async (event, ctx) => {
  if (exceedsQuota(event)) {
    return { block: true, reason: "Quota exceeded" };
  }
  // 通过，执行工具
});
```

**关键特性：**

1. **短路机制**：任何一个返回 `block: true`，后续监听器不会执行
2. **独立决策**：每个监听器独立判断，不依赖其他监听器
3. **顺序执行**：按注册顺序执行（但注册顺序不确定）
4. **异步支持**：每个监听器都是异步的

**应用：** 实现多层安全检查、审批流程、条件路由。

---

## 卡片 8：高级应用 - 自定义 Provider 集成

**一句话：** Extensions 可以注册自定义 Provider，集成任何 LLM API（如 OpenAI、Anthropic、本地模型）。

**核心 API：**

```typescript
pi.registerProvider({
  id: "my-provider",
  name: "My Custom Provider",
  models: [
    {
      id: "my-model",
      name: "My Model",
      contextWindow: 128000,
      maxOutputTokens: 4096,
    },
  ],
  async createStream(request, signal) {
    // 实现流式响应
    const stream = await fetch("https://api.example.com/chat", {
      method: "POST",
      body: JSON.stringify(request),
      signal,
    });

    // 返回 AsyncIterable<StreamChunk>
    return streamToAsyncIterable(stream);
  },
});
```

**实际示例：**

```typescript
// 集成 Ollama 本地模型
export default function (pi: ExtensionAPI) {
  pi.registerProvider({
    id: "ollama",
    name: "Ollama Local",
    models: [
      { id: "llama3", name: "Llama 3", contextWindow: 8192 },
      { id: "mistral", name: "Mistral", contextWindow: 8192 },
    ],
    async createStream(request, signal) {
      const response = await fetch("http://localhost:11434/api/chat", {
        method: "POST",
        body: JSON.stringify({
          model: request.model,
          messages: request.messages,
          stream: true,
        }),
        signal,
      });

      return parseOllamaStream(response.body);
    },
  });
}
```

**应用场景：**
1. 集成企业内部的 LLM API
2. 使用本地模型（Ollama、LM Studio）
3. 实现自定义的 API 代理和缓存
4. 添加自定义的 token 计费逻辑

**应用：** 在不修改 pi-mono 源码的情况下，支持任何 LLM API。

---

## 卡片 9：在 AI Agent 开发中的使用

**一句话：** Extensions 是构建自定义 AI Agent 的核心机制，提供了完全的可编程性和可扩展性。

**典型应用场景：**

### 1. 安全防护 Agent

```typescript
export default function (pi: ExtensionAPI) {
  // 拦截危险命令
  pi.on("tool_call", async (event, ctx) => {
    if (event.toolName === "bash") {
      const dangerous = [/rm -rf/, /sudo/, /dd if=/];
      for (const pattern of dangerous) {
        if (pattern.test(event.input.command)) {
          const ok = await ctx.ui.confirm("Dangerous!", "Allow?");
          if (!ok) return { block: true, reason: "Blocked" };
        }
      }
    }
  });
}
```

### 2. 工作流自动化 Agent

```typescript
export default function (pi: ExtensionAPI) {
  // 自动创建 git checkpoint
  pi.on("session_fork", async (event, ctx) => {
    await ctx.exec("git stash push -m 'checkpoint before fork'");
  });

  // 自动提交代码
  pi.on("session_exit", async (event, ctx) => {
    const lastMessage = getLastAssistantMessage(ctx);
    const commitMsg = generateCommitMessage(lastMessage);
    await ctx.exec(`git add . && git commit -m "${commitMsg}"`);
  });
}
```

### 3. 团队协作 Agent

```typescript
export default function (pi: ExtensionAPI) {
  // 注册团队工具
  pi.registerTool({
    name: "deploy",
    description: "Deploy to staging/production",
    parameters: Type.Object({
      env: StringEnum(["staging", "production"] as const),
    }),
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      const { env } = params;
      await ctx.exec(`./scripts/deploy.sh ${env}`);
      return {
        content: [{ type: "text", text: `Deployed to ${env}` }],
        details: { env, timestamp: Date.now() },
      };
    },
  });
}
```

### 4. 可观测性 Agent

```typescript
export default function (pi: ExtensionAPI) {
  // 记录所有工具调用
  pi.on("tool_call", async (event, ctx) => {
    console.log(`[${new Date().toISOString()}] ${event.toolName}`);
  });

  // 性能监控
  const timings = new Map();
  pi.on("tool_call", async (event, ctx) => {
    timings.set(event.toolCallId, Date.now());
  });
  pi.on("tool_result", async (event, ctx) => {
    const start = timings.get(event.toolCallId);
    if (start) {
      const duration = Date.now() - start;
      console.log(`[PERF] ${event.toolName}: ${duration}ms`);
    }
  });
}
```

**应用：** Extensions 让你可以构建任何类型的 AI Agent，从简单的工具扩展到复杂的工作流系统。

---

## 卡片 10：总结与延伸

**一句话：** Extensions 是 pi-mono 最强大的定制化机制，掌握它就掌握了构建自定义 AI Agent 的核心能力。

**核心知识回顾：**

1. **本质**：运行时动态加载的 TypeScript 模块
2. **接口**：ExtensionAPI（registerTool, on/off, UI API）
3. **工具注册**：添加自定义工具，扩展 Agent 能力
4. **事件监听**：介入执行流程，实现控制和定制
5. **状态管理**：通过 details 存储，支持 Session 分支
6. **责任链**：多个 Extensions 协作，形成强大功能
7. **Provider 集成**：支持任何 LLM API
8. **实际应用**：安全防护、工作流自动化、团队协作、可观测性

**学习路径：**

```
基础 → 进阶 → 实战
  ↓      ↓      ↓
工具   事件   完整
注册   监听   项目
  ↓      ↓      ↓
状态   UI    生产
管理   定制   部署
```

**下一步学习：**

1. **核心概念深入**：
   - TypeScript 扩展基础
   - 事件监听与响应
   - UI 定制与交互
   - Provider 与模型管理
   - 扩展加载与热重载
   - 扩展开发模式

2. **实战代码练习**：
   - 安全防护扩展
   - 工具增强扩展
   - 命令与快捷键扩展
   - UI 定制扩展
   - 会话管理扩展
   - Git 集成扩展
   - Provider 定制扩展
   - 完整扩展实战

3. **高级主题**：
   - 自定义 Provider 集成
   - MCP Server 集成
   - Sub-Agents 子代理实现
   - 权限控制与沙箱
   - 性能优化与调试

**延伸思考：**

1. **架构模式**：Extensions 体现了哪些设计模式？（插件架构、事件驱动、控制反转）
2. **可扩展性**：如何设计一个可扩展的系统？（开放封闭原则、依赖注入）
3. **状态管理**：为什么不可变性很重要？（时间旅行、并发安全）
4. **事件系统**：发布-订阅模式的优缺点？（解耦 vs 复杂度）

**参考资源：**

- **官方文档**: https://github.com/badlogic/pi-mono/tree/main/packages/coding-agent/docs/extensions.md
- **示例代码**: https://github.com/badlogic/pi-mono/tree/main/packages/coding-agent/examples/extensions
- **社区扩展**: https://github.com/qualisero/awesome-pi-agent
- **类型定义**: `@mariozechner/pi-coding-agent` 包

**最后的建议：**

1. **从简单开始**：先写一个 hello world Extension
2. **阅读示例**：pi-mono 有 60+ 官方示例，都是最佳实践
3. **实践为主**：理论再多不如动手写一个
4. **社区交流**：加入 Discord 社区，学习他人的经验
5. **持续学习**：Extensions 在不断演进，关注最新特性

**记住：Extensions 不仅是技术，更是一种思维方式——如何在不修改源码的情况下扩展系统。这种思维在软件工程中无处不在。**

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: pi-mono 2025-2026 版本
