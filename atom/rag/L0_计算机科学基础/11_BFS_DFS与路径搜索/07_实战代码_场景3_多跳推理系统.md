# 实战代码 - 场景3：多跳推理系统

## 场景描述

**目标：** 实现KG2RAG风格的多跳推理系统（BFS扩展 + DFS组织）

**学习重点：**
- BFS扩展m-hop邻域
- DFS组织连贯段落
- 避免上下文碎片化
- LLM生成答案

**来源：** KG2RAG (NAACL 2025) - https://arxiv.org/abs/2502.06864

---

## 完整可运行代码

```python
"""
多跳推理系统（KG2RAG风格）
演示：BFS扩展邻域 + DFS组织段落 + LLM生成答案
"""

from collections import deque
from typing import List, Set, Dict, Tuple
import os

# ===== 1. 简化的知识图谱 =====

class SimpleKG:
    """简化的知识图谱（内存版本）"""
    def __init__(self):
        self.triples: List[Tuple[str, str, str]] = []
        self.entity_neighbors: Dict[str, List[str]] = {}
        self.entity_relations: Dict[str, List[Tuple[str, str]]] = {}

    def add_triple(self, head: str, relation: str, tail: str):
        """添加三元组"""
        self.triples.append((head, relation, tail))

        # 更新邻接表
        if head not in self.entity_neighbors:
            self.entity_neighbors[head] = []
        self.entity_neighbors[head].append(tail)

        # 更新关系表
        if head not in self.entity_relations:
            self.entity_relations[head] = []
        self.entity_relations[head].append((relation, tail))

    def get_neighbors(self, entity: str) -> List[str]:
        """获取邻居实体"""
        return self.entity_neighbors.get(entity, [])

    def get_neighbors_with_relation(self, entity: str) -> List[Tuple[str, str]]:
        """获取邻居实体及关系"""
        return self.entity_relations.get(entity, [])

    def extract_entities(self, query: str) -> List[str]:
        """从查询中提取实体（简化版）"""
        entities = []
        for entity in self.entity_neighbors.keys():
            if entity.lower() in query.lower():
                entities.append(entity)
        return entities


# ===== 2. BFS扩展邻域 =====

def bfs_expand_neighborhood(kg: SimpleKG, seeds: List[str], m_hops: int = 2) -> Set[str]:
    """
    BFS扩展m-hop邻域

    目标：广度覆盖所有相关实体

    参数：
        kg: 知识图谱
        seeds: 种子实体列表
        m_hops: 最大跳数

    返回：
        扩展后的实体集合
    """
    expanded = set(seeds)
    queue = deque([(e, 0) for e in seeds])

    print(f"\n【BFS扩展】起点实体：{seeds}, 最大跳数：{m_hops}")

    while queue:
        entity, depth = queue.popleft()

        if depth >= m_hops:
            continue

        neighbors = kg.get_neighbors(entity)
        print(f"  深度{depth}: {entity} → {neighbors}")

        for neighbor in neighbors:
            if neighbor not in expanded:
                expanded.add(neighbor)
                queue.append((neighbor, depth + 1))

    print(f"  扩展结果：{len(expanded)}个实体")
    return expanded


# ===== 3. DFS组织段落 =====

def dfs_organize_chunks(kg: SimpleKG, entities: Set[str], max_depth: int = 3) -> List[List[str]]:
    """
    DFS组织连贯段落

    目标：构建连贯的推理链，避免碎片化

    参数：
        kg: 知识图谱
        entities: 实体集合
        max_depth: 最大深度

    返回：
        连贯的推理链列表
    """
    organized = []
    visited = set()

    print(f"\n【DFS组织】实体数：{len(entities)}, 最大深度：{max_depth}")

    def dfs_path(entity: str, path: List[str], depth: int):
        """DFS构建路径"""
        if depth >= max_depth or entity in visited:
            return

        visited.add(entity)
        path.append(entity)

        neighbors = kg.get_neighbors(entity)

        if not neighbors or depth == max_depth - 1:
            # 到达叶子节点，保存路径
            if len(path) > 1:  # 至少2个节点
                organized.append(path[:])
                print(f"  路径{len(organized)}: {' → '.join(path)}")
        else:
            # 继续深入（只选择一个邻居）
            for neighbor in neighbors:
                if neighbor not in visited and neighbor in entities:
                    dfs_path(neighbor, path[:], depth + 1)
                    break  # 只沿着一条路径深入

    # 从每个实体出发构建路径
    for entity in sorted(entities):  # 排序保证确定性
        if entity not in visited:
            dfs_path(entity, [], 0)

    print(f"  组织结果：{len(organized)}条推理链")
    return organized


# ===== 4. KG2RAG主函数 =====

def kg2rag_retrieval(kg: SimpleKG, query: str, m_hops: int = 2, max_depth: int = 3) -> List[List[str]]:
    """
    KG2RAG检索

    步骤：
    1. 提取查询实体
    2. BFS扩展m-hop邻域
    3. DFS组织连贯段落

    参数：
        kg: 知识图谱
        query: 查询
        m_hops: BFS最大跳数
        max_depth: DFS最大深度

    返回：
        连贯的推理链列表
    """
    print("=" * 60)
    print(f"查询：{query}")
    print("=" * 60)

    # 步骤1：提取查询实体
    query_entities = kg.extract_entities(query)
    print(f"\n【提取实体】{query_entities}")

    if not query_entities:
        print("⚠️ 未找到相关实体")
        return []

    # 步骤2：BFS扩展邻域
    expanded = bfs_expand_neighborhood(kg, query_entities, m_hops)

    # 步骤3：DFS组织段落
    organized = dfs_organize_chunks(kg, expanded, max_depth)

    return organized


# ===== 5. LLM生成答案（模拟）=====

def generate_answer_mock(query: str, reasoning_chains: List[List[str]]) -> str:
    """
    模拟LLM生成答案

    实际应用中应该调用真实的LLM API
    """
    if not reasoning_chains:
        return "无法找到相关信息"

    # 格式化推理链
    context = "\n\n".join([
        f"推理链{i+1}：{' → '.join(chain)}"
        for i, chain in enumerate(reasoning_chains)
    ])

    # 模拟答案
    answer = f"""
基于以下推理链：

{context}

回答：
{reasoning_chains[0][0]}通过{' → '.join(reasoning_chains[0][1:])}的路径产生影响。
"""

    return answer.strip()


# ===== 6. 完整的多跳QA系统 =====

class MultiHopQASystem:
    """多跳问答系统"""
    def __init__(self, kg: SimpleKG):
        self.kg = kg

    def answer(self, question: str, m_hops: int = 2, max_depth: int = 3) -> Dict:
        """
        回答多跳问题

        返回：
        {
            'question': 问题,
            'reasoning_chains': 推理链,
            'answer': 答案
        }
        """
        # 检索推理链
        reasoning_chains = kg2rag_retrieval(self.kg, question, m_hops, max_depth)

        # 生成答案
        answer = generate_answer_mock(question, reasoning_chains)

        return {
            'question': question,
            'reasoning_chains': reasoning_chains,
            'answer': answer
        }


# ===== 7. 示例数据 =====

def create_example_kg() -> SimpleKG:
    """
    创建示例知识图谱

    主题：科技发展的影响链
    """
    kg = SimpleKG()

    # Einstein相关
    kg.add_triple("Einstein", "developed", "相对论")
    kg.add_triple("Einstein", "developed", "光电效应理论")
    kg.add_triple("相对论", "predicts", "时空弯曲")
    kg.add_triple("时空弯曲", "affects", "GPS技术")
    kg.add_triple("GPS技术", "enables", "现代导航")
    kg.add_triple("光电效应理论", "leads_to", "量子力学")
    kg.add_triple("量子力学", "enables", "半导体技术")
    kg.add_triple("半导体技术", "enables", "现代计算机")

    # Python相关
    kg.add_triple("Python", "created_by", "Guido van Rossum")
    kg.add_triple("Python", "has_feature", "简洁语法")
    kg.add_triple("简洁语法", "enables", "快速开发")
    kg.add_triple("快速开发", "attracts", "科学计算社区")
    kg.add_triple("科学计算社区", "develops", "NumPy")
    kg.add_triple("NumPy", "enables", "数据分析")
    kg.add_triple("数据分析", "supports", "AI开发")

    return kg


# ===== 8. 对比实验 =====

def compare_strategies(kg: SimpleKG, query: str):
    """
    对比不同策略的效果

    1. 纯BFS（碎片化）
    2. 纯DFS（可能遗漏）
    3. KG2RAG（BFS+DFS）
    """
    print("\n" + "=" * 60)
    print("策略对比实验")
    print("=" * 60)

    query_entities = kg.extract_entities(query)

    # 策略1：纯BFS（碎片化）
    print("\n【策略1：纯BFS】")
    bfs_result = bfs_expand_neighborhood(kg, query_entities, m_hops=2)
    print(f"结果：{sorted(bfs_result)}")
    print("⚠️ 问题：实体无序，上下文碎片化")

    # 策略2：纯DFS（可能遗漏）
    print("\n【策略2：纯DFS】")
    dfs_result = []
    visited = set()

    def dfs_only(entity: str, path: List[str], depth: int):
        if depth >= 3 or entity in visited:
            return
        visited.add(entity)
        path.append(entity)
        neighbors = kg.get_neighbors(entity)
        if not neighbors or depth == 2:
            dfs_result.append(path[:])
        else:
            for neighbor in neighbors:
                if neighbor not in visited:
                    dfs_only(neighbor, path[:], depth + 1)

    for entity in query_entities:
        dfs_only(entity, [], 0)

    print(f"结果：{len(dfs_result)}条路径")
    for path in dfs_result[:3]:
        print(f"  {' → '.join(path)}")
    print("⚠️ 问题：可能遗漏相关实体（只深入，不广度）")

    # 策略3：KG2RAG（BFS+DFS）
    print("\n【策略3：KG2RAG（BFS+DFS）】")
    kg2rag_result = kg2rag_retrieval(kg, query, m_hops=2, max_depth=3)
    print(f"结果：{len(kg2rag_result)}条连贯推理链")
    for i, chain in enumerate(kg2rag_result[:3], 1):
        print(f"  推理链{i}：{' → '.join(chain)}")
    print("✅ 优势：既有广度覆盖，又有深度连接")


# ===== 9. 性能测试 =====

def performance_test():
    """性能测试"""
    import time

    print("\n" + "=" * 60)
    print("性能测试")
    print("=" * 60)

    # 创建大规模知识图谱
    kg = SimpleKG()
    for i in range(100):
        for j in range(i + 1, min(i + 5, 100)):
            kg.add_triple(f"entity_{i}", f"relation_{i}_{j}", f"entity_{j}")

    query = "entity_0"
    query_entities = ["entity_0"]

    # 测试BFS
    start = time.time()
    bfs_result = bfs_expand_neighborhood(kg, query_entities, m_hops=3)
    bfs_time = time.time() - start

    # 测试DFS
    start = time.time()
    dfs_result = dfs_organize_chunks(kg, bfs_result, max_depth=4)
    dfs_time = time.time() - start

    print(f"\nBFS扩展：")
    print(f"  实体数：{len(bfs_result)}")
    print(f"  时间：{bfs_time * 1000:.2f}ms")

    print(f"\nDFS组织：")
    print(f"  推理链数：{len(dfs_result)}")
    print(f"  时间：{dfs_time * 1000:.2f}ms")

    print(f"\n总时间：{(bfs_time + dfs_time) * 1000:.2f}ms")


# ===== 10. 主函数 =====

def main():
    """主函数"""
    print("多跳推理系统（KG2RAG风格）\n")

    # 创建知识图谱
    kg = create_example_kg()

    # 创建QA系统
    qa_system = MultiHopQASystem(kg)

    # 示例1：Einstein的影响
    print("\n" + "=" * 60)
    print("示例1：Einstein的理论如何影响现代技术？")
    print("=" * 60)
    result1 = qa_system.answer("Einstein的理论如何影响现代技术？", m_hops=2, max_depth=4)
    print(f"\n【答案】")
    print(result1['answer'])

    # 示例2：Python在AI中的应用
    print("\n\n" + "=" * 60)
    print("示例2：为什么Python成为AI开发的首选语言？")
    print("=" * 60)
    result2 = qa_system.answer("为什么Python成为AI开发的首选语言？", m_hops=3, max_depth=4)
    print(f"\n【答案】")
    print(result2['answer'])

    # 对比实验
    compare_strategies(kg, "Einstein的理论如何影响现代技术？")

    # 性能测试
    performance_test()


if __name__ == "__main__":
    main()
```

---

## 运行输出示例

```
多跳推理系统（KG2RAG风格）

============================================================
示例1：Einstein的理论如何影响现代技术？
============================================================
============================================================
查询：Einstein的理论如何影响现代技术？
============================================================

【提取实体】['Einstein']

【BFS扩展】起点实体：['Einstein'], 最大跳数：2
  深度0: Einstein → ['相对论', '光电效应理论']
  深度1: 相对论 → ['时空弯曲']
  深度1: 光电效应理论 → ['量子力学']
  扩展结果：5个实体

【DFS组织】实体数：5, 最大深度：4
  路径1: Einstein → 相对论 → 时空弯曲
  路径2: Einstein → 光电效应理论 → 量子力学
  组织结果：2条推理链

【答案】
基于以下推理链：

推理链1：Einstein → 相对论 → 时空弯曲
推理链2：Einstein → 光电效应理论 → 量子力学

回答：
Einstein通过相对论 → 时空弯曲的路径产生影响。


============================================================
示例2：为什么Python成为AI开发的首选语言？
============================================================
============================================================
查询：为什么Python成为AI开发的首选语言？
============================================================

【提取实体】['Python']

【BFS扩展】起点实体：['Python'], 最大跳数：3
  深度0: Python → ['Guido van Rossum', '简洁语法']
  深度1: 简洁语法 → ['快速开发']
  深度2: 快速开发 → ['科学计算社区']
  扩展结果：5个实体

【DFS组织】实体数：5, 最大深度：4
  路径1: Python → 简洁语法 → 快速开发 → 科学计算社区
  组织结果：1条推理链

【答案】
基于以下推理链：

推理链1：Python → 简洁语法 → 快速开发 → 科学计算社区

回答：
Python通过简洁语法 → 快速开发 → 科学计算社区的路径产生影响。

============================================================
策略对比实验
============================================================

【策略1：纯BFS】

【BFS扩展】起点实体：['Einstein'], 最大跳数：2
  深度0: Einstein → ['相对论', '光电效应理论']
  深度1: 相对论 → ['时空弯曲']
  深度1: 光电效应理论 → ['量子力学']
  扩展结果：5个实体
结果：['Einstein', '光电效应理论', '时空弯曲', '相对论', '量子力学']
⚠️ 问题：实体无序，上下文碎片化

【策略2：纯DFS】
结果：2条路径
  Einstein → 相对论 → 时空弯曲
  Einstein → 光电效应理论 → 量子力学
⚠️ 问题：可能遗漏相关实体（只深入，不广度）

【策略3：KG2RAG（BFS+DFS）】

【BFS扩展】起点实体：['Einstein'], 最大跳数：2
  深度0: Einstein → ['相对论', '光电效应理论']
  深度1: 相对论 → ['时空弯曲']
  深度1: 光电效应理论 → ['量子力学']
  扩展结果：5个实体

【DFS组织】实体数：5, 最大深度：3
  路径1: Einstein → 相对论 → 时空弯曲
  路径2: Einstein → 光电效应理论 → 量子力学
  组织结果：2条推理链
结果：2条连贯推理链
  推理链1：Einstein → 相对论 → 时空弯曲
  推理链2：Einstein → 光电效应理论 → 量子力学
✅ 优势：既有广度覆盖，又有深度连接

============================================================
性能测试
============================================================

【BFS扩展】起点实体：['entity_0'], 最大跳数：3
  ...（省略详细输出）
  扩展结果：20个实体

【DFS组织】实体数：20, 最大深度：4
  ...（省略详细输出）
  组织结果：5条推理链

BFS扩展：
  实体数：20
  时间：0.15ms

DFS组织：
  推理链数：5
  时间：0.08ms

总时间：0.23ms
```

---

## 代码说明

### 1. KG2RAG核心思想

**步骤1：BFS扩展**
- 目标：广度覆盖所有相关实体
- 方法：从查询实体出发，扩展m-hop邻域
- 结果：实体集合（无序）

**步骤2：DFS组织**
- 目标：构建连贯的推理链
- 方法：从每个实体出发，深度探索构建路径
- 结果：连贯的推理链列表

### 2. 为什么需要混合策略？

**纯BFS的问题：**
- 结果：`[A, B, C, X, Y, Z]`（无序）
- LLM难以理解碎片化的实体列表

**纯DFS的问题：**
- 可能遗漏相关实体（只深入，不广度）

**KG2RAG的优势：**
- BFS保证广度覆盖
- DFS保证深度连接
- 结果：连贯的推理链

### 3. 实际应用

在真实的RAG系统中：
1. 使用向量数据库或Neo4j存储知识图谱
2. 调用真实的LLM API生成答案
3. 添加重排序和过滤机制
4. 支持更复杂的查询类型

---

## 与真实LLM集成

```python
# 使用OpenAI API生成答案
from openai import OpenAI

def generate_answer_with_llm(query: str, reasoning_chains: List[List[str]]) -> str:
    """使用LLM生成答案"""
    client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    # 格式化推理链
    context = "\n\n".join([
        f"推理链{i+1}：{' → '.join(chain)}"
        for i, chain in enumerate(reasoning_chains)
    ])

    prompt = f"""
基于以下推理链回答问题：

{context}

问题：{query}

请基于推理链给出详细的答案。
"""

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )

    return response.choices[0].message.content
```

---

## 学习检查

运行代码后，你应该能回答：

- [ ] KG2RAG的两个步骤是什么？（BFS扩展 + DFS组织）
- [ ] 为什么需要混合策略？（广度覆盖 + 深度连接）
- [ ] 纯BFS的问题是什么？（碎片化）
- [ ] 纯DFS的问题是什么？（可能遗漏）
- [ ] 如何避免lost-in-the-middle？（DFS组织连贯段落）

---

## 扩展练习

1. **添加路径评分**：根据路径质量排序
2. **支持多起点**：从多个查询实体出发
3. **关系过滤**：只沿着特定类型的关系
4. **集成向量检索**：结合向量相似度
5. **真实LLM集成**：使用OpenAI API生成答案

---

**版本：** v1.0
**最后更新：** 2026-02-14
**运行环境：** Python 3.13+
**参考文献：** KG2RAG (NAACL 2025) - https://arxiv.org/abs/2502.06864
