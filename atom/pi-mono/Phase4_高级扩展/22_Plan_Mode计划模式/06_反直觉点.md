# 反直觉点

> **核心理念：** Plan Mode 的设计决策中有许多反直觉的地方，理解这些反直觉点是深入掌握 pi-mono 哲学的关键。

---

## 反直觉点 1：没有内置 Plan Mode 反而更好

### 直觉认知

"一个 AI 代理工具应该内置规划功能，这样用户才能开箱即用。"

### 反直觉真相

**没有内置 Plan Mode 反而更好，因为：**

1. **灵活性更高**：用户可以实现任何规划模式
2. **可观察性更强**：文件式规划完全透明
3. **核心更简单**：避免核心代码臃肿
4. **可组合性更好**：扩展可以自由组合

### 为什么反直觉？

大多数工具都追求"功能完整"，但 pi-mono 追求"原语完整"。

**类比：**
- **Unix**：提供 `cat`、`grep`、`wc` 等小工具，用户组合使用
- **Windows**：提供 Word、Excel 等大型应用，功能固定

**关键洞察：** 原语的组合能力 > 功能的完整性。

### 实际影响

```typescript
// 直觉：内置 Plan Mode
agent.plan(task); // 黑盒，用户不知道内部逻辑

// 反直觉：扩展实现 Plan Mode
api.registerCommand({
  name: 'plan',
  handler: async () => {
    // 用户完全控制逻辑
    await api.setState({ mode: 'plan' });
    api.disableTools(['write', 'edit']);
  }
});
```

---

## 反直觉点 2：文件优先比内存优先更好

### 直觉认知

"状态应该存储在内存中，这样访问更快、更高效。"

### 反直觉真相

**文件优先比内存优先更好，因为：**

1. **可观察性**：文件可以直接查看
2. **可编辑性**：文件可以手动修改
3. **可版本控制**：文件可以用 Git 追踪
4. **可恢复性**：代理崩溃后状态不丢失

### 为什么反直觉？

传统软件工程强调性能优化，但 AI 代理更需要可观察性。

**性能对比：**
- **内存访问**：纳秒级
- **文件访问**：毫秒级
- **差异**：对 AI 代理来说可以忽略

**可观察性对比：**
- **内存状态**：用户看不到
- **文件状态**：用户随时查看

**关键洞察：** 对 AI 代理来说，可观察性 > 性能。

### 实际影响

```typescript
// 直觉：内存存储
const plan = { goal: 'auth system', tasks: [...] };
// 代理崩溃，计划丢失

// 反直觉：文件存储
await api.tools.write('.pi/plan.md', planContent);
// 代理崩溃，计划仍然存在
// 用户可以用编辑器打开查看
// 可以用 git diff 查看变化
```

---

## 反直觉点 3：禁用工具比启用工具更安全

### 直觉认知

"默认应该启用所有工具，需要时再禁用。"

### 反直觉真相

**在 Plan Mode 中禁用写入工具更安全，因为：**

1. **防止意外修改**：规划阶段不应该修改文件
2. **明确意图**：用户明确知道当前模式
3. **可预测性**：代理行为可预测
4. **错误成本低**：规划错误成本低，执行错误成本高

### 为什么反直觉？

传统软件设计强调"默认开放"，但 AI 代理需要"默认安全"。

**安全性对比：**
- **默认启用**：代理可能意外修改文件
- **默认禁用**：代理无法修改文件，更安全

**关键洞察：** 对 AI 代理来说，安全性 > 便利性。

### 实际影响

```typescript
// 直觉：默认启用所有工具
// 代理可能在规划阶段意外修改文件

// 反直觉：规划模式禁用写入工具
api.disableTools(['write', 'edit', 'delete']);
// 代理无法修改文件，只能读取和分析
```

---

## 反直觉点 4：简单的扩展比复杂的内置功能更强大

### 直觉认知

"内置功能应该尽可能强大和完整。"

### 反直觉真相

**简单的扩展比复杂的内置功能更强大，因为：**

1. **可定制**：用户可以根据需求定制
2. **可组合**：多个扩展可以组合
3. **可维护**：简单扩展易于维护
4. **可理解**：用户可以理解扩展逻辑

### 为什么反直觉？

传统软件追求"功能完整"，但 pi-mono 追求"可组合性"。

**复杂度对比：**
- **复杂内置功能**：1000 行代码，功能固定
- **简单扩展**：50 行代码，可定制

**关键洞察：** 简单 + 可组合 > 复杂 + 固定。

### 实际影响

```typescript
// 直觉：复杂的内置 Plan Mode
// 1000+ 行代码，支持各种规划模式
// 但用户无法定制

// 反直觉：简单的扩展
// 50 行代码，实现基本 Plan Mode
api.registerCommand({
  name: 'plan',
  handler: async () => {
    await api.setState({ mode: 'plan' });
    api.disableTools(['write', 'edit']);
  }
});
// 用户可以根据需求扩展
```

---

## 反直觉点 5：用户控制比代理自动化更重要

### 直觉认知

"AI 代理应该尽可能自动化，减少用户干预。"

### 反直觉真相

**用户控制比代理自动化更重要，因为：**

1. **信任**：用户信任自己控制的系统
2. **可预测**：用户知道会发生什么
3. **可干预**：用户可以随时干预
4. **可理解**：用户理解系统行为

### 为什么反直觉？

AI 领域强调"自动化"，但 pi-mono 强调"用户控制"。

**控制权对比：**
- **代理自动化**：代理决定何时规划、何时执行
- **用户控制**：用户决定何时规划、何时执行

**关键洞察：** 对 AI 代理来说，用户控制 > 自动化。

### 实际影响

```typescript
// 直觉：代理自动决定
agent.execute(task); // 代理自动决定是否需要规划

// 反直觉：用户明确控制
> /plan          // 用户明确进入规划模式
> /execute       // 用户明确退出规划模式
```

---

## 反直觉点 6：Markdown 比 JSON 更适合规划

### 直觉认知

"结构化数据应该用 JSON 存储，这样程序易于解析。"

### 反直觉真相

**Markdown 比 JSON 更适合规划，因为：**

1. **可读性**：人类易于阅读
2. **可编辑性**：任何编辑器都可以编辑
3. **富文本**：支持代码块、表格、图表
4. **协作友好**：团队成员易于理解

### 为什么反直觉？

程序员习惯用 JSON 存储数据，但规划文档主要是给人看的。

**格式对比：**
- **JSON**：程序易解析，人难阅读
- **Markdown**：人易阅读，程序需要解析器

**关键洞察：** 对规划文档来说，可读性 > 可解析性。

### 实际影响

```json
// 直觉：JSON 格式
{
  "goal": "Implement auth system",
  "tasks": [
    { "id": "task-001", "title": "Design schema" }
  ]
}
// 人类难以阅读

// 反直觉：Markdown 格式
# Plan: Implement auth system

## Tasks

- [ ] Task 1: Design schema
- [ ] Task 2: Implement API

// 人类易于阅读和编辑
```

---

## 反直觉点 7：Session 分支比单一 Session 更灵活

### 直觉认知

"应该在一个 Session 中完成所有工作，避免复杂性。"

### 反直觉真相

**Session 分支比单一 Session 更灵活，因为：**

1. **实验性修改**：可以在分支中尝试不同方案
2. **并行开发**：可以同时探索多个方向
3. **回滚机制**：可以随时回到原始 Session
4. **A/B 测试**：可以比较不同实现方案

### 为什么反直觉？

传统开发强调"线性流程"，但 AI 代理需要"探索性流程"。

**流程对比：**
- **线性流程**：规划 → 执行 → 完成
- **探索性流程**：规划 → 分支 A → 分支 B → 选择 → 执行

**关键洞察：** 对 AI 代理来说，探索性 > 线性。

### 实际影响

```typescript
// 直觉：单一 Session
const session = await api.createSession({ labels: ['planning'] });
// 只能探索一个方向

// 反直觉：Session 分支
const branchA = await api.createSession({
  parentId: originalSessionId,
  labels: ['planning', 'approach-a']
});
const branchB = await api.createSession({
  parentId: originalSessionId,
  labels: ['planning', 'approach-b']
});
// 可以同时探索多个方向，然后选择最佳方案
```

---

## 反直觉点 8：事件驱动比直接调用更解耦

### 直觉认知

"直接调用函数更简单直接。"

### 反直觉真相

**事件驱动比直接调用更解耦，因为：**

1. **松耦合**：发送者和接收者解耦
2. **可扩展**：可以添加多个监听器
3. **可组合**：不同扩展可以监听同一事件
4. **可测试**：易于测试和模拟

### 为什么反直觉？

直接调用看起来更简单，但事件驱动更灵活。

**耦合度对比：**
- **直接调用**：调用者需要知道被调用者
- **事件驱动**：调用者只需要触发事件

**关键洞察：** 对扩展系统来说，解耦 > 简单。

### 实际影响

```typescript
// 直觉：直接调用
function enterPlanMode() {
  updateUI();
  logEvent();
  notifyUser();
}

// 反直觉：事件驱动
function enterPlanMode() {
  api.emit('plan:entered', { task });
}

// 其他扩展可以监听事件
api.on('plan:entered', updateUI);
api.on('plan:entered', logEvent);
api.on('plan:entered', notifyUser);
```

---

## 反直觉点 9：Labels 比状态字段更灵活

### 直觉认知

"应该用状态字段表示 Session 状态，如 `status: 'active'`。"

### 反直觉真相

**Labels 比状态字段更灵活，因为：**

1. **多维度**：一个 Session 可以有多个标签
2. **可查询**：可以按标签查询 Session
3. **可组合**：可以组合多个标签查询
4. **可扩展**：可以随时添加新标签

### 为什么反直觉？

传统数据库设计用字段表示状态，但标签系统更灵活。

**灵活性对比：**
- **状态字段**：`status: 'active'`（单一维度）
- **Labels**：`['planning', 'active', 'high-priority']`（多维度）

**关键洞察：** 对 Session 管理来说，多维度 > 单维度。

### 实际影响

```typescript
// 直觉：状态字段
const session = {
  status: 'active' // 只能表示一个状态
};

// 反直觉：Labels
const session = {
  labels: ['planning', 'active', 'high-priority', 'project:auth']
  // 可以表示多个维度
};

// 查询
const sessions = api.getSessions({
  labels: ['planning', 'active', 'high-priority']
});
```

---

## 反直觉点 10：扩展热重载比重启更高效

### 直觉认知

"修改扩展后应该重启代理。"

### 反直觉真相

**扩展热重载比重启更高效，因为：**

1. **无需重启**：修改扩展后立即生效
2. **保留状态**：Session 状态不丢失
3. **快速迭代**：开发扩展更快
4. **用户友好**：用户体验更好

### 为什么反直觉？

传统软件开发需要重启应用，但 pi-mono 支持热重载。

**效率对比：**
- **重启**：需要 10-30 秒，状态丢失
- **热重载**：需要 1-2 秒，状态保留

**关键洞察：** 对扩展开发来说，热重载 > 重启。

### 实际影响

```bash
# 直觉：修改扩展后重启
vi ~/.pi/extensions/plan-mode/index.ts
pi restart  # 需要重启，状态丢失

# 反直觉：修改扩展后热重载
vi ~/.pi/extensions/plan-mode/index.ts
# 扩展自动重载，状态保留
```

---

## 反直觉点总结表

| 反直觉点 | 直觉认知 | 反直觉真相 | 关键洞察 |
|---------|---------|-----------|---------|
| **1. 没有内置 Plan Mode** | 应该内置 | 扩展实现更好 | 原语 > 功能 |
| **2. 文件优先** | 内存更快 | 文件更可观察 | 可观察性 > 性能 |
| **3. 禁用工具** | 默认启用 | 默认禁用更安全 | 安全性 > 便利性 |
| **4. 简单扩展** | 复杂功能 | 简单可组合 | 简单 + 可组合 > 复杂 |
| **5. 用户控制** | 代理自动化 | 用户控制更重要 | 用户控制 > 自动化 |
| **6. Markdown** | JSON 更好 | Markdown 更可读 | 可读性 > 可解析性 |
| **7. Session 分支** | 单一 Session | 分支更灵活 | 探索性 > 线性 |
| **8. 事件驱动** | 直接调用 | 事件更解耦 | 解耦 > 简单 |
| **9. Labels** | 状态字段 | Labels 更灵活 | 多维度 > 单维度 |
| **10. 热重载** | 重启 | 热重载更高效 | 热重载 > 重启 |

---

## 深度反直觉：Pi-mono 的哲学

### 反直觉哲学 1：少即是多（Less is More）

**直觉：** 功能越多越好
**反直觉：** 功能越少越好，只要提供足够的原语

**例子：**
- **Pi-mono 核心**：只提供基本工具（read, write, setState）
- **用户扩展**：构建任何需要的功能

### 反直觉哲学 2：透明优于便利（Transparency over Convenience）

**直觉：** 便利性最重要
**反直觉：** 透明性更重要，即使牺牲便利性

**例子：**
- **文件式规划**：需要手动编辑文件（不便利）
- **但完全透明**：用户知道发生了什么（透明）

### 反直觉哲学 3：用户控制优于自动化（Control over Automation）

**直觉：** 自动化越多越好
**反直觉：** 用户控制更重要，即使需要更多操作

**例子：**
- **用户明确控制**：`/plan` 和 `/execute` 命令
- **而非自动决定**：代理自动判断何时规划

### 反直觉哲学 4：可组合优于完整（Composability over Completeness）

**直觉：** 功能应该完整
**反直觉：** 功能应该可组合，即使不完整

**例子：**
- **Pi-mono**：提供原语，用户组合
- **而非提供**：完整的 Plan Mode 功能

---

## 如何应对反直觉

### 策略 1：理解哲学

不要死记反直觉点，而是理解背后的哲学：
- **极简主义**：核心保持简单
- **可观察性**：状态透明可见
- **用户控制**：用户决定工作流
- **可组合性**：原语自由组合

### 策略 2：实践验证

通过实践验证反直觉点的价值：
- **尝试文件式规划**：体验可观察性
- **创建简单扩展**：体验可组合性
- **使用 Session 分支**：体验探索性

### 策略 3：对比学习

对比 pi-mono 和其他工具：
- **Pi-mono vs. Claude Code**：极简 vs. 完整
- **Pi-mono vs. Oh-my-pi**：原语 vs. 功能
- **理解权衡**：灵活性 vs. 便利性

---

## 常见误区

### 误区 1："Pi-mono 功能不完整"

**错误理解：** Pi-mono 缺少 Plan Mode，功能不完整
**正确理解：** Pi-mono 提供原语，用户构建功能

### 误区 2："文件式规划太慢"

**错误理解：** 文件访问比内存慢，性能差
**正确理解：** 对 AI 代理来说，可观察性 > 性能

### 误区 3："扩展太复杂"

**错误理解：** 创建扩展太复杂，不如内置功能
**正确理解：** 简单扩展（50 行）比复杂内置功能（1000 行）更灵活

### 误区 4："用户控制太麻烦"

**错误理解：** 用户手动控制太麻烦，应该自动化
**正确理解：** 用户控制提供信任和可预测性

---

## 参考资源

### 官方资源

- [What I learned building pi coding agent](https://mariozechner.at/posts/2025-11-30-pi-coding-agent) - Mario Zechner
- [Pi-mono GitHub](https://github.com/badlogic/pi-mono)

### 研究资料

- `temp/03_grok_pi_mono_extensions.md` - Pi-mono 扩展 API
- `temp/04_grok_pi_mono_examples.md` - Pi-mono 扩展示例

---

## 下一步

- **07_实战代码_*.md**：通过实战代码验证反直觉点
- **08_面试必问.md**：准备面试，深入理解反直觉点
