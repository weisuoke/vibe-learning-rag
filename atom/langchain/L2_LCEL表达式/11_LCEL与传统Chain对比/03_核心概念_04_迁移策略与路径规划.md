# 核心概念 04：迁移策略与路径规划

> 系统化的迁移方法论，确保从传统 Chain 到 LCEL 的平滑过渡

---

## 概述

从传统 Chain 迁移到 LCEL 需要系统规划、风险评估、测试验证。本文提供完整的迁移方法论，包括评估、路径选择、模式应用、测试策略和回滚计划。

---

## 1. 迁移评估

### 1.1 代码库扫描

**自动化扫描工具**：

```python
import os
import re
from typing import Dict, List

def scan_legacy_chains(directory: str) -> Dict[str, List[str]]:
    """扫描代码库中的传统 Chain"""
    patterns = {
        "LLMChain": r"from langchain\.chains import.*LLMChain",
        "SequentialChain": r"SequentialChain",
        "RouterChain": r"RouterChain",
        "TransformChain": r"TransformChain"
    }

    results = {key: [] for key in patterns}

    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith('.py'):
                filepath = os.path.join(root, file)
                with open(filepath, 'r') as f:
                    content = f.read()
                    for chain_type, pattern in patterns.items():
                        if re.search(pattern, content):
                            results[chain_type].append(filepath)

    return results

# 使用
results = scan_legacy_chains("./src")
for chain_type, files in results.items():
    print(f"{chain_type}: {len(files)} files")
```

### 1.2 风险评估矩阵

| 风险类型 | 严重程度 | 可能性 | 缓解措施 |
|----------|----------|--------|----------|
| **功能破坏** | 高 | 中 | 充分测试、对比验证 |
| **性能下降** | 中 | 低 | 性能基准测试 |
| **用户影响** | 高 | 低 | 灰度发布、快速回滚 |
| **团队学习** | 中 | 中 | 培训、文档、代码审查 |
| **时间延误** | 中 | 中 | 渐进式迁移、优先级排序 |

### 1.3 资源估算

**小型项目**（<1万行代码）：
- 评估：1天
- 迁移：3-5天
- 测试：2-3天
- 总计：1-2周

**中型项目**（1-10万行代码）：
- 评估：2-3天
- 迁移：2-3周
- 测试：1周
- 总计：1-2月

**大型项目**（>10万行代码）：
- 评估：1周
- 迁移：1-2月
- 测试：2-3周
- 总计：2-4月

---

## 2. 迁移路径

### 2.1 Big Bang 迁移

**定义**：一次性重写所有代码

**适用场景**：
- 小型项目（<1万行）
- 代码质量差，需要重构
- 有充足的测试时间

**优点**：
- 快速完成
- 无历史包袱
- 架构清晰

**缺点**：
- 风险高
- 无法回滚
- 需要停机

**实施步骤**：
1. 停止新功能开发
2. 重写所有 Chain
3. 全面测试
4. 一次性上线

### 2.2 增量迁移（推荐）

**定义**：逐步迁移，保持系统可用

**适用场景**：
- 中大型项目
- 无法停机
- 需要降低风险

**优点**：
- 风险低
- 可以回滚
- 持续交付

**缺点**：
- 周期长
- 需要兼容层
- 代码混杂

**实施步骤**：
1. 识别迁移优先级
2. 逐个模块迁移
3. 每次迁移后测试
4. 逐步替换旧代码

**示例**：
```python
# 第1周：迁移 RAG 检索链
rag_chain = retriever | format_docs | prompt | llm | parser

# 第2周：迁移对话链
conversation_chain = history | prompt | llm | parser

# 第3周：迁移其他功能
# ...
```

### 2.3 Strangler Fig 模式

**定义**：新功能用 LCEL，旧功能保持不变，逐步替换

**适用场景**：
- 大型遗留系统
- 无法停机
- 长期迁移计划

**优点**：
- 风险最低
- 无需停机
- 新旧并存

**缺点**：
- 周期最长
- 代码混杂时间长
- 维护成本高

**实施步骤**：
1. 新功能使用 LCEL
2. 旧功能保持不变
3. 逐步替换旧功能
4. 最终移除旧代码

### 2.4 混合模式

**定义**：用 RunnableLambda 包装旧代码，与 LCEL 混用

**适用场景**：
- 部分代码难以迁移
- 需要快速交付
- 保持兼容性

**示例**：
```python
from langchain_core.runnables import RunnableLambda

# 包装旧代码
def legacy_function(input):
    return old_chain.run(input)

legacy_runnable = RunnableLambda(legacy_function)

# 与 LCEL 组合
chain = prompt | llm | legacy_runnable | parser
```

### 2.5 并行运行模式

**定义**：新旧版本并行运行，对比结果

**适用场景**：
- 高风险系统
- 需要验证正确性
- 有充足资源

**示例**：
```python
# 并行运行新旧版本
old_result = old_chain.run(input)
new_result = new_chain.invoke(input)

# 对比结果
if old_result != new_result:
    log_difference(old_result, new_result)

# 使用新版本结果
return new_result
```

---

## 3. 迁移模式

### 3.1 LLMChain 迁移

**传统方式**：
```python
from langchain.chains import LLMChain

chain = LLMChain(llm=llm, prompt=prompt)
result = chain.run(text="你好")
```

**LCEL 方式**：
```python
from langchain_core.output_parsers import StrOutputParser

chain = prompt | llm | StrOutputParser()
result = chain.invoke({"text": "你好"})
```

### 3.2 SequentialChain 迁移

**传统方式**：
```python
from langchain.chains import SequentialChain

chain = SequentialChain(
    chains=[chain1, chain2],
    input_variables=["text"],
    output_variables=["result"]
)
```

**LCEL 方式**：
```python
chain = chain1 | chain2
```

### 3.3 RouterChain 迁移

**传统方式**：
```python
from langchain.chains.router import RouterChain

router_chain = RouterChain(...)
```

**LCEL 方式**：
```python
from langchain_core.runnables import RunnableBranch

chain = RunnableBranch(
    (lambda x: len(x) < 100, short_chain),
    (lambda x: len(x) < 1000, medium_chain),
    long_chain
)
```

### 3.4 Memory 迁移

**传统方式**：
```python
from langchain.chains import ConversationChain
from langchain.memory import ConversationBufferMemory

memory = ConversationBufferMemory()
chain = ConversationChain(llm=llm, memory=memory)
```

**LCEL 方式**：
```python
from langchain_core.runnables import RunnableWithMessageHistory
from langchain_community.chat_message_histories import ChatMessageHistory

store = {}

def get_session_history(session_id: str):
    if session_id not in store:
        store[session_id] = ChatMessageHistory()
    return store[session_id]

chain = RunnableWithMessageHistory(
    prompt | llm | parser,
    get_session_history
)
```

### 3.5 自定义 Chain 迁移

**传统方式**：
```python
from langchain.chains.base import Chain

class CustomChain(Chain):
    def _call(self, inputs):
        # 自定义逻辑
        return {"output": result}
```

**LCEL 方式**：
```python
from langchain_core.runnables import RunnableLambda

def custom_logic(input):
    # 自定义逻辑
    return result

chain = prompt | llm | RunnableLambda(custom_logic) | parser
```

---

## 4. 测试策略

### 4.1 单元测试

```python
import pytest

def test_lcel_chain():
    """测试 LCEL 链的基本功能"""
    chain = prompt | llm | parser
    result = chain.invoke({"text": "测试"})
    assert isinstance(result, str)
    assert len(result) > 0
```

### 4.2 对比测试

```python
def test_migration_equivalence():
    """测试迁移前后结果一致"""
    test_inputs = [
        {"text": "输入1"},
        {"text": "输入2"},
        {"text": "输入3"}
    ]

    for inp in test_inputs:
        old_result = old_chain.run(**inp)
        new_result = new_chain.invoke(inp)
        assert old_result == new_result, f"Results differ for {inp}"
```

### 4.3 性能测试

```python
import time

def test_performance():
    """测试性能提升"""
    input_data = {"text": "测试文本"}

    # 测试旧版本
    start = time.time()
    old_result = old_chain.run(**input_data)
    old_time = time.time() - start

    # 测试新版本
    start = time.time()
    new_result = new_chain.invoke(input_data)
    new_time = time.time() - start

    print(f"旧版本: {old_time:.2f}s")
    print(f"新版本: {new_time:.2f}s")
    print(f"提升: {old_time / new_time:.2f}x")
```

### 4.4 集成测试

```python
def test_end_to_end():
    """端到端测试"""
    # 模拟真实场景
    user_query = "什么是 LCEL？"
    result = chain.invoke(user_query)

    # 验证结果
    assert "LCEL" in result
    assert len(result) > 50
```

---

## 5. 回滚计划

### 5.1 特性开关

```python
import os

USE_LCEL = os.getenv("USE_LCEL", "false").lower() == "true"

def process_query(input):
    if USE_LCEL:
        return new_chain.invoke(input)
    else:
        return old_chain.run(input)
```

### 5.2 灰度发布

```python
import random

def process_query(input):
    # 10% 流量使用新版本
    if random.random() < 0.1:
        return new_chain.invoke(input)
    else:
        return old_chain.run(input)
```

### 5.3 监控和告警

```python
from langchain_core.callbacks import BaseCallbackHandler

class MonitoringHandler(BaseCallbackHandler):
    def on_chain_error(self, error, **kwargs):
        # 发送告警
        send_alert(f"Chain error: {error}")

    def on_chain_end(self, outputs, **kwargs):
        # 记录指标
        log_metrics(outputs)

# 使用
result = chain.invoke(input, config={"callbacks": [MonitoringHandler()]})
```

### 5.4 快速回滚

```bash
# 回滚到旧版本
export USE_LCEL=false

# 重启服务
systemctl restart app
```

---

## 6. 迁移检查清单

### 6.1 迁移前

- [ ] 完成代码库扫描
- [ ] 评估迁移风险
- [ ] 估算资源需求
- [ ] 选择迁移路径
- [ ] 制定测试计划
- [ ] 准备回滚方案

### 6.2 迁移中

- [ ] 按优先级迁移
- [ ] 编写单元测试
- [ ] 编写对比测试
- [ ] 性能基准测试
- [ ] 代码审查
- [ ] 文档更新

### 6.3 迁移后

- [ ] 全面测试
- [ ] 灰度发布
- [ ] 监控指标
- [ ] 收集反馈
- [ ] 优化性能
- [ ] 清理旧代码

---

## 7. 实战案例

### 7.1 案例：中型 RAG 应用迁移

**背景**：
- 代码量：5万行
- 传统 Chain：50个文件
- 团队：5人
- 时间：4周

**迁移路径**：增量迁移

**第1周**：
- 扫描代码库
- 识别 30 个 LLMChain
- 识别 15 个 SequentialChain
- 识别 5 个 RouterChain

**第2周**：
- 迁移 RAG 检索链（性能瓶颈）
- 性能提升 2.5倍
- 用户满意度提升

**第3周**：
- 迁移对话链
- 添加流式输出
- 用户体验改善

**第4周**：
- 迁移其他功能
- 清理旧代码
- 文档更新

**结果**：
- 性能提升 2.5倍
- 代码量减少 40%
- 维护成本降低 50%

---

## 8. 总结

### 8.1 核心原则

1. **评估优先**：充分评估风险和资源
2. **渐进迁移**：降低风险，保持可用
3. **充分测试**：确保功能正确性
4. **快速回滚**：准备应急预案

### 8.2 推荐路径

- **小型项目**：Big Bang 迁移
- **中型项目**：增量迁移
- **大型项目**：Strangler Fig 模式

### 8.3 成功要素

1. **团队支持**：培训、文档、代码审查
2. **工具支持**：自动化扫描、测试、监控
3. **时间充裕**：不要在紧急项目中迁移
4. **持续优化**：迁移后持续优化性能

---

**下一步**：阅读 `03_核心概念_05_生产环境考量.md` 学习生产环境部署最佳实践
