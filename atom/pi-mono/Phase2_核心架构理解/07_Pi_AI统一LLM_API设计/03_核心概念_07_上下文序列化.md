# 核心概念7：上下文序列化与切换

> 理解如何在不同 LLM Provider 之间无缝迁移对话上下文

---

## 概念定义

**上下文序列化与切换**是指将对话上下文保存为标准格式，并能够在不同 Provider 之间无损转换，实现跨模型的对话延续。

**核心价值：**
- **跨模型切换**：在对话中途切换 Provider
- **上下文保留**：完整保留对话历史
- **无损转换**：不丢失任何信息
- **灵活迁移**：支持导入导出

---

## 核心实现

### 1. 上下文序列化

```typescript
/**
 * 上下文序列化器
 */
class ContextSerializer {
  /**
   * 序列化为 JSON
   */
  serialize(context: Context): string {
    return JSON.stringify(context, null, 2);
  }

  /**
   * 从 JSON 反序列化
   */
  deserialize(json: string): Context {
    return JSON.parse(json);
  }

  /**
   * 序列化为文件
   */
  async saveToFile(context: Context, filePath: string): Promise<void> {
    const json = this.serialize(context);
    await fs.writeFile(filePath, json, 'utf-8');
  }

  /**
   * 从文件加载
   */
  async loadFromFile(filePath: string): Promise<Context> {
    const json = await fs.readFile(filePath, 'utf-8');
    return this.deserialize(json);
  }
}
```

### 2. 跨 Provider 切换

```typescript
/**
 * 跨 Provider 上下文切换
 */
async function switchProvider(
  currentContext: Context,
  fromProvider: string,
  toProvider: string
): Promise<Message> {
  const converter = new MessageConverter();

  // 1. 当前上下文已经是统一格式，直接使用
  console.log(`Switching from ${fromProvider} to ${toProvider}`);

  // 2. 转换为目标 Provider 格式
  let request: any;
  switch (toProvider) {
    case 'openai':
      request = converter.toOpenAI(currentContext);
      break;
    case 'anthropic':
      request = converter.toAnthropic(currentContext);
      break;
    case 'google':
      request = converter.toGoogle(currentContext);
      break;
  }

  // 3. 调用新 Provider
  const adapter = getAdapter(toProvider);
  return adapter.complete(currentContext);
}
```

### 3. 对话历史管理

```typescript
/**
 * 对话历史管理器
 */
class ConversationHistory {
  private messages: Message[] = [];

  /**
   * 添加消息
   */
  add(message: Message): void {
    this.messages.push(message);
  }

  /**
   * 获取完整历史
   */
  getAll(): Message[] {
    return [...this.messages];
  }

  /**
   * 获取最近 N 条消息
   */
  getRecent(count: number): Message[] {
    return this.messages.slice(-count);
  }

  /**
   * 导出为 Context
   */
  toContext(systemPrompt?: string): Context {
    return {
      systemPrompt,
      messages: this.getAll()
    };
  }

  /**
   * 清空历史
   */
  clear(): void {
    this.messages = [];
  }
}
```

---

## 在 AI Agent 中的应用

### 场景1：对话中途切换模型

```typescript
async function switchModelMidConversation(): Promise<void> {
  const history = new ConversationHistory();

  // 1. 使用 OpenAI 开始对话
  history.add({ role: 'user', content: 'Explain quantum computing' });

  const openaiAdapter = getAdapter('openai');
  const response1 = await openaiAdapter.complete(history.toContext());
  history.add(response1);

  console.log('OpenAI:', response1.content);

  // 2. 切换到 Anthropic 继续对话
  history.add({ role: 'user', content: 'Can you give me a code example?' });

  const anthropicAdapter = getAdapter('anthropic');
  const response2 = await anthropicAdapter.complete(history.toContext());
  history.add(response2);

  console.log('Anthropic:', response2.content);
}
```

### 场景2：保存和恢复对话

```typescript
async function saveAndRestoreConversation(): Promise<void> {
  const serializer = new ContextSerializer();
  const history = new ConversationHistory();

  // 1. 进行对话
  history.add({ role: 'user', content: 'Hello' });
  const response = await complete(model, history.toContext());
  history.add(response);

  // 2. 保存对话
  await serializer.saveToFile(
    history.toContext(),
    'conversation.json'
  );

  // 3. 稍后恢复对话
  const restoredContext = await serializer.loadFromFile('conversation.json');
  const newHistory = new ConversationHistory();
  restoredContext.messages.forEach(msg => newHistory.add(msg));

  // 4. 继续对话
  newHistory.add({ role: 'user', content: 'Continue our discussion' });
  const newResponse = await complete(model, newHistory.toContext());
}
```

---

## 学习检查清单

- [ ] 理解上下文序列化的作用
- [ ] 能够实现序列化器
- [ ] 能够实现跨 Provider 切换
- [ ] 能够管理对话历史
- [ ] 能够保存和恢复对话

---

## 参考资源

- [pi-ai Context](https://github.com/badlogic/pi-mono/blob/main/packages/pi-ai/src/types.ts)
- [LangChain Memory](https://js.langchain.com/docs/modules/memory/)

---

**版本：** v1.0
**最后更新：** 2026-02-19
