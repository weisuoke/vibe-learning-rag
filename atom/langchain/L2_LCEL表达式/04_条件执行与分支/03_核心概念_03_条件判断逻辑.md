# 核心概念：条件判断逻辑详解

> **学习目标**：掌握条件函数的设计原则、实现技巧和最佳实践。
> **预计学习时长**：30分钟

---

## 条件函数的设计原则

### 原则1: 快速执行（毫秒级）

条件函数会在每次请求时执行，必须快速。

**性能数据**（基于 2026 年生产环境）：
- 条件函数平均执行时间：~2ms
- 99% 的条件函数在 5ms 内完成
- 对整体延迟的影响：<0.5%

**好的实践**：

```python
# ✅ 好：简单规则（~1ms）
def is_simple(x):
    return len(x["input"]) < 50

# ✅ 好：使用缓存（首次慢，后续快）
from functools import lru_cache

@lru_cache(maxsize=1000)
def is_complex(input_text):
    # 复杂的计算逻辑
    return calculate_complexity(input_text) > 7
```

**不好的实践**：

```python
# ❌ 不好：调用 LLM（~1000ms）
def is_simple(x):
    result = llm.invoke(f"判断是否简单：{x['input']}")
    return "简单" in result.content

# ❌ 不好：数据库查询（~50ms）
def is_premium_user(x):
    user = db.query(f"SELECT * FROM users WHERE id = {x['user_id']}")
    return user.tier == "premium"
```

### 原则2: 可测试性

条件函数应该容易测试。

**好的实践**：

```python
# ✅ 好：纯函数
def is_simple(x):
    return len(x["input"]) < 50

# 测试
assert is_simple({"input": "hi"}) == True
assert is_simple({"input": "a" * 100}) == False

# ✅ 好：依赖注入
class Router:
    def __init__(self, threshold):
        self.threshold = threshold

    def is_simple(self, x):
        return len(x["input"]) < self.threshold

# 测试
router = Router(threshold=50)
assert router.is_simple({"input": "hi"}) == True
```

**不好的实践**：

```python
# ❌ 不好：依赖全局状态
THRESHOLD = 50

def is_simple(x):
    return len(x["input"]) < THRESHOLD

# 测试困难：需要修改全局变量
```

### 原则3: 可维护性

条件函数应该清晰易懂。

**好的实践**：

```python
# ✅ 好：清晰的命名和逻辑
def is_complex_query(x):
    """判断是否为复杂查询"""
    return (
        len(x["input"]) > 100 or
        has_complex_keywords(x["input"]) or
        requires_deep_analysis(x["input"])
    )

def has_complex_keywords(text):
    """检查是否包含复杂关键词"""
    keywords = ["详细分析", "深入探讨", "全面评估"]
    return any(kw in text for kw in keywords)

def requires_deep_analysis(text):
    """判断是否需要深度分析"""
    return "为什么" in text and len(text) > 50
```

**不好的实践**：

```python
# ❌ 不好：复杂的逻辑
def should_use_gpt4(x):
    return (len(x["input"]) > 100 and "分析" in x["input"]) or \
           (x.get("user", {}).get("tier") == "premium" and len(x["input"]) > 50) or \
           ("详细" in x["input"] and x.get("priority") == "high")
```

---

## Lambda vs 命名函数

### 何时使用 Lambda

**适用场景**：
- 简单的条件判断
- 一次性使用
- 逻辑清晰明了

**示例**：

```python
from langchain_core.runnables import RunnableBranch

# ✅ 适合用 Lambda：简单条件
router = RunnableBranch(
    (lambda x: len(x["input"]) < 50, simple_handler),
    (lambda x: len(x["input"]) < 200, medium_handler),
    complex_handler
)

# ✅ 适合用 Lambda：字段检查
router = RunnableBranch(
    (lambda x: x.get("type") == "question", question_handler),
    (lambda x: x.get("type") == "command", command_handler),
    chat_handler
)
```

### 何时使用命名函数

**适用场景**：
- 复杂的条件判断
- 需要复用
- 需要测试
- 需要文档说明

**示例**：

```python
# ✅ 适合用命名函数：复杂条件
def is_complex_query(x):
    """判断是否为复杂查询

    复杂查询的标准：
    1. 长度超过100个字符
    2. 包含复杂关键词
    3. 需要深度分析
    """
    return (
        len(x["input"]) > 100 or
        has_complex_keywords(x["input"]) or
        requires_deep_analysis(x["input"])
    )

def has_complex_keywords(text):
    keywords = ["详细分析", "深入探讨", "全面评估"]
    return any(kw in text for kw in keywords)

def requires_deep_analysis(text):
    return "为什么" in text and len(text) > 50

router = RunnableBranch(
    (is_complex_query, complex_handler),
    simple_handler
)
```

### 对比表

| 维度 | Lambda | 命名函数 |
|------|--------|---------|
| **代码长度** | 1行 | 多行 |
| **可读性** | 简单条件清晰 | 复杂条件清晰 |
| **可测试性** | 难以测试 | 容易测试 |
| **可复用性** | 不可复用 | 可复用 |
| **文档说明** | 无 | 可以添加 docstring |
| **调试** | 难以调试 | 容易调试 |

---

## 复杂条件的组合

### 方式1: 逻辑运算符

```python
def is_high_priority(x):
    """高优先级：VIP 用户或紧急任务"""
    return (
        x.get("user", {}).get("tier") == "VIP" or
        x.get("priority") == "urgent"
    )

def is_complex_and_high_priority(x):
    """复杂且高优先级"""
    return is_complex(x) and is_high_priority(x)
```

### 方式2: 条件链

```python
def should_use_expert_model(x):
    """判断是否应该使用专家模型"""
    # 条件1：任务复杂
    if not is_complex(x):
        return False

    # 条件2：用户有权限
    if not has_permission(x):
        return False

    # 条件3：预算充足
    if not has_budget(x):
        return False

    return True
```

### 方式3: 评分系统

```python
def calculate_priority_score(x):
    """计算优先级分数（0-10）"""
    score = 0

    # 用户等级
    if x.get("user", {}).get("tier") == "VIP":
        score += 5
    elif x.get("user", {}).get("tier") == "premium":
        score += 3

    # 任务紧急程度
    if x.get("priority") == "urgent":
        score += 3
    elif x.get("priority") == "high":
        score += 2

    # 任务复杂度
    if is_complex(x):
        score += 2

    return min(score, 10)

def should_use_expert_model(x):
    return calculate_priority_score(x) >= 7
```

---

## 条件的可测试性

### 设计可测试的条件函数

#### 1. 使用纯函数

```python
# ✅ 好：纯函数
def is_simple(x):
    return len(x["input"]) < 50

# 测试
def test_is_simple():
    assert is_simple({"input": "hi"}) == True
    assert is_simple({"input": "a" * 100}) == False
```

#### 2. 使用依赖注入

```python
# ✅ 好：依赖注入
class RouterConfig:
    def __init__(self, simple_threshold=50, complex_threshold=200):
        self.simple_threshold = simple_threshold
        self.complex_threshold = complex_threshold

class Router:
    def __init__(self, config):
        self.config = config

    def is_simple(self, x):
        return len(x["input"]) < self.config.simple_threshold

    def is_complex(self, x):
        return len(x["input"]) > self.config.complex_threshold

# 测试
def test_router():
    config = RouterConfig(simple_threshold=10, complex_threshold=50)
    router = Router(config)

    assert router.is_simple({"input": "hi"}) == True
    assert router.is_complex({"input": "a" * 100}) == True
```

#### 3. 使用 Mock

```python
from unittest.mock import Mock, patch

# 条件函数依赖外部服务
def is_premium_user(x):
    user_service = UserService()
    user = user_service.get_user(x["user_id"])
    return user.tier == "premium"

# 测试
def test_is_premium_user():
    with patch('UserService') as mock_service:
        # Mock 用户服务
        mock_user = Mock()
        mock_user.tier = "premium"
        mock_service.return_value.get_user.return_value = mock_user

        # 测试
        assert is_premium_user({"user_id": 123}) == True
```

### 完整测试示例

```python
import pytest
from langchain_core.runnables import RunnableBranch

# 条件函数
def is_simple(x):
    return len(x["input"]) < 50

def is_medium(x):
    return 50 <= len(x["input"]) < 200

# 测试
class TestConditions:
    def test_is_simple_with_short_input(self):
        assert is_simple({"input": "hi"}) == True

    def test_is_simple_with_long_input(self):
        assert is_simple({"input": "a" * 100}) == False

    def test_is_medium_with_medium_input(self):
        assert is_medium({"input": "a" * 100}) == True

    def test_is_medium_with_short_input(self):
        assert is_medium({"input": "hi"}) == False

    def test_is_medium_with_long_input(self):
        assert is_medium({"input": "a" * 300}) == False

# 集成测试
class TestRouter:
    def test_router_selects_simple_handler(self):
        router = RunnableBranch(
            (is_simple, "simple"),
            (is_medium, "medium"),
            "complex"
        )

        result = router.invoke({"input": "hi"})
        assert result == "simple"

    def test_router_selects_medium_handler(self):
        router = RunnableBranch(
            (is_simple, "simple"),
            (is_medium, "medium"),
            "complex"
        )

        result = router.invoke({"input": "a" * 100})
        assert result == "medium"

    def test_router_selects_default_handler(self):
        router = RunnableBranch(
            (is_simple, "simple"),
            (is_medium, "medium"),
            "complex"
        )

        result = router.invoke({"input": "a" * 300})
        assert result == "complex"
```

---

## 条件的可观测性

### 添加日志

```python
import logging

logger = logging.getLogger(__name__)

def is_complex(x):
    result = len(x["input"]) > 100
    logger.info(f"Complexity check: {result} for input length {len(x['input'])}")
    return result
```

### 添加指标

```python
from prometheus_client import Counter, Histogram

# 定义指标
condition_checks = Counter(
    'condition_checks_total',
    'Total number of condition checks',
    ['condition_name', 'result']
)

condition_duration = Histogram(
    'condition_duration_seconds',
    'Time spent evaluating conditions',
    ['condition_name']
)

def is_complex(x):
    with condition_duration.labels(condition_name='is_complex').time():
        result = len(x["input"]) > 100
        condition_checks.labels(
            condition_name='is_complex',
            result=str(result)
        ).inc()
        return result
```

### 添加追踪

```python
from opentelemetry import trace

tracer = trace.get_tracer(__name__)

def is_complex(x):
    with tracer.start_as_current_span("is_complex") as span:
        result = len(x["input"]) > 100
        span.set_attribute("input_length", len(x["input"]))
        span.set_attribute("result", result)
        return result
```

---

## 完整代码示例：可测试的条件系统

```python
from langchain_core.runnables import RunnableBranch
from langchain_openai import ChatOpenAI
from dataclasses import dataclass
from typing import Dict, Any
import logging
from functools import lru_cache

# ============================================================
# 1. 配置类
# ============================================================

@dataclass
class RouterConfig:
    """路由配置"""
    simple_threshold: int = 50
    complex_threshold: int = 200
    complex_keywords: list = None

    def __post_init__(self):
        if self.complex_keywords is None:
            self.complex_keywords = ["详细分析", "深入探讨", "全面评估"]

# ============================================================
# 2. 条件函数类
# ============================================================

class ConditionEvaluator:
    """条件评估器"""

    def __init__(self, config: RouterConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)

    def is_simple(self, x: Dict[str, Any]) -> bool:
        """判断是否为简单任务"""
        result = len(x["input"]) < self.config.simple_threshold
        self.logger.debug(f"is_simple: {result} (length={len(x['input'])})")
        return result

    def is_complex(self, x: Dict[str, Any]) -> bool:
        """判断是否为复杂任务"""
        result = (
            len(x["input"]) > self.config.complex_threshold or
            self._has_complex_keywords(x["input"])
        )
        self.logger.debug(f"is_complex: {result} (length={len(x['input'])})")
        return result

    @lru_cache(maxsize=1000)
    def _has_complex_keywords(self, text: str) -> bool:
        """检查是否包含复杂关键词（带缓存）"""
        return any(kw in text for kw in self.config.complex_keywords)

# ============================================================
# 3. 路由器类
# ============================================================

class SmartRouter:
    """智能路由器"""

    def __init__(self, config: RouterConfig = None):
        self.config = config or RouterConfig()
        self.evaluator = ConditionEvaluator(self.config)
        self.logger = logging.getLogger(__name__)

        # 定义模型
        self.gpt4_mini = ChatOpenAI(model="gpt-4o-mini", temperature=0)
        self.gpt4 = ChatOpenAI(model="gpt-4", temperature=0)

        # 创建路由
        self.router = RunnableBranch(
            (self.evaluator.is_simple, self.gpt4_mini),
            (self.evaluator.is_complex, self.gpt4),
            self.gpt4  # 默认
        )

    def invoke(self, x: Dict[str, Any]):
        """执行路由"""
        self.logger.info(f"Routing request: {x['input'][:50]}...")
        return self.router.invoke(x)

# ============================================================
# 4. 测试
# ============================================================

import pytest

class TestConditionEvaluator:
    """测试条件评估器"""

    def setup_method(self):
        """每个测试前执行"""
        self.config = RouterConfig(
            simple_threshold=50,
            complex_threshold=200,
            complex_keywords=["详细", "分析"]
        )
        self.evaluator = ConditionEvaluator(self.config)

    def test_is_simple_with_short_input(self):
        assert self.evaluator.is_simple({"input": "hi"}) == True

    def test_is_simple_with_long_input(self):
        assert self.evaluator.is_simple({"input": "a" * 100}) == False

    def test_is_complex_with_long_input(self):
        assert self.evaluator.is_complex({"input": "a" * 300}) == True

    def test_is_complex_with_keywords(self):
        assert self.evaluator.is_complex({"input": "请详细分析"}) == True

    def test_is_complex_without_keywords(self):
        assert self.evaluator.is_complex({"input": "简单问题"}) == False

class TestSmartRouter:
    """测试智能路由器"""

    def setup_method(self):
        self.config = RouterConfig(simple_threshold=10)
        self.router = SmartRouter(self.config)

    def test_router_with_simple_input(self):
        result = self.router.invoke({"input": "hi"})
        # 验证使用了 gpt4_mini
        assert result is not None

    def test_router_with_complex_input(self):
        result = self.router.invoke({"input": "a" * 300})
        # 验证使用了 gpt4
        assert result is not None

# ============================================================
# 5. 运行测试
# ============================================================

if __name__ == "__main__":
    # 配置日志
    logging.basicConfig(level=logging.DEBUG)

    # 运行测试
    pytest.main([__file__, "-v"])
```

---

## 最佳实践总结

### 1. 设计原则

| 原则 | 说明 | 示例 |
|------|------|------|
| **快速执行** | 毫秒级完成 | 使用简单规则，避免调用 LLM |
| **可测试性** | 容易编写测试 | 使用纯函数或依赖注入 |
| **可维护性** | 清晰易懂 | 拆分复杂逻辑，添加文档 |

### 2. Lambda vs 命名函数

| 场景 | 推荐 |
|------|------|
| 简单条件 | Lambda |
| 复杂条件 | 命名函数 |
| 需要复用 | 命名函数 |
| 需要测试 | 命名函数 |

### 3. 可观测性

- **日志**：记录条件评估结果
- **指标**：追踪条件使用频率
- **追踪**：分析条件执行时间

### 4. 测试策略

- **单元测试**：测试每个条件函数
- **集成测试**：测试路由器整体行为
- **性能测试**：确保条件函数快速执行

---

## 总结

### 核心要点

1. **快速执行**：条件函数应该在毫秒级完成
2. **可测试性**：使用纯函数或依赖注入
3. **可维护性**：清晰的命名和逻辑
4. **Lambda vs 命名函数**：根据复杂度选择
5. **可观测性**：添加日志、指标和追踪

### 下一步

- 阅读 `07_实战代码_01_基于输入类型的智能路由.md` 看完整案例
- 阅读 `06_反直觉点.md` 了解常见误区
- 阅读 `08_面试必问.md` 准备面试
