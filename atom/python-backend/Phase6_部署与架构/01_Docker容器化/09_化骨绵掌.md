# 化骨绵掌

10个2分钟知识卡片，快速掌握 Docker 容器化的核心知识。

---

## 卡片1：容器化直觉理解

**一句话：** Docker 容器是隔离的进程 + 独立的文件系统。

**举例：**
```bash
# 容器本质上是一个进程
docker run -d --name api my-app
# 在宿主机上查看
ps aux | grep python
# user  5678  python app.py  ← 容器内的进程
```

**应用：** AI Agent API 容器化后，每个容器是一个独立的进程，互不影响。

---

## 卡片2：Dockerfile 核心指令

**一句话：** FROM、WORKDIR、COPY、RUN、CMD 是最常用的5个指令。

**举例：**
```dockerfile
FROM python:3.13-slim      # 基础镜像
WORKDIR /app               # 工作目录
COPY requirements.txt .    # 复制文件
RUN pip install -r requirements.txt  # 安装依赖
CMD ["uvicorn", "app.main:app"]      # 启动命令
```

**应用：** 这5个指令足以构建一个基础的 FastAPI 应用镜像。

---

## 卡片3：镜像层缓存

**一句话：** 先复制依赖文件，再复制代码，利用缓存加速构建。

**举例：**
```dockerfile
# ✅ 推荐：先复制依赖文件
COPY requirements.txt .
RUN pip install -r requirements.txt  # 依赖不变时，缓存命中
COPY . .  # 代码修改，只重新执行这一步

# ❌ 不推荐：一次性复制所有文件
COPY . .
RUN pip install -r requirements.txt  # 代码修改，依赖重新安装
```

**应用：** 代码修改后，构建时间从 2 分钟减少到 5 秒。

---

## 卡片4：多阶段构建

**一句话：** Builder 阶段安装构建工具，Runtime 阶段只复制必要文件。

**举例：**
```dockerfile
# Builder 阶段（1GB）
FROM python:3.13-slim AS builder
RUN pip install uv
RUN uv sync --frozen

# Runtime 阶段（200MB）
FROM python:3.13-slim
COPY --from=builder /app/.venv /app/.venv
COPY app/ app/
```

**应用：** 镜像体积从 1GB 优化到 200MB，减少 80%。

---

## 卡片5：网络配置

**一句话：** 使用自定义网络，容器间可以通过容器名通信。

**举例：**
```bash
# 创建自定义网络
docker network create my-network

# 运行容器
docker run -d --name api --network my-network my-app
docker run -d --name db --network my-network postgres:14

# 容器间通信（通过容器名）
docker exec api ping db  # ✅ 成功
```

**应用：** AI Agent API 通过容器名连接数据库：`postgresql://user:pass@db:5432/aiagent`

---

## 卡片6：数据持久化

**一句话：** 容器删除后数据会丢失，使用 Volume 持久化。

**举例：**
```bash
# 创建 Volume
docker volume create postgres_data

# 挂载 Volume
docker run -d \
  --name db \
  -v postgres_data:/var/lib/postgresql/data \
  postgres:14

# 容器删除后，数据还在 Volume 中
```

**应用：** 数据库数据、日志文件、上传文件都要挂载 Volume。

---

## 卡片7：安全最佳实践

**一句话：** 使用非 root 用户运行容器，不硬编码敏感信息。

**举例：**
```dockerfile
# 创建非 root 用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

# 切换到非 root 用户
USER appuser

# ❌ 错误：硬编码 API Key
ENV OPENAI_API_KEY=sk-1234567890

# ✅ 正确：运行时传递
# docker run -e OPENAI_API_KEY=${OPENAI_API_KEY} my-app
```

**应用：** 生产环境所有容器都使用非 root 用户运行。

---

## 卡片8：健康检查

**一句话：** 健康检查确保应用真正可用，不只是进程在运行。

**举例：**
```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1
```

```python
# app/main.py
@app.get("/health")
async def health():
    # 检查数据库连接
    db.execute("SELECT 1")
    # 检查 Redis 连接
    redis.ping()
    return {"status": "healthy"}
```

**应用：** 容器不健康时自动重启，提高可用性。

---

## 卡片9：docker-compose 编排

**一句话：** docker-compose 一条命令启动多个容器（API + 数据库 + Redis）。

**举例：**
```yaml
version: '3.8'
services:
  api:
    build: .
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis
  db:
    image: postgres:14-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data
  redis:
    image: redis:7-alpine

volumes:
  postgres_data:
```

```bash
# 启动所有服务
docker-compose up -d
```

**应用：** 开发和生产环境都使用 docker-compose 编排。

---

## 卡片10：生产环境部署

**一句话：** 生产环境需要健康检查、资源限制、自动重启、日志管理。

**举例：**
```yaml
services:
  api:
    restart: unless-stopped  # 自动重启
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

**应用：** 生产环境配置确保应用高可用和资源使用合理。

---

## 快速参考卡

### Docker 核心命令

```bash
# 镜像管理
docker build -t my-app:v1.0 .
docker images
docker rmi my-app:v1.0

# 容器管理
docker run -d -p 8000:8000 --name api my-app
docker ps
docker logs -f api
docker exec -it api bash
docker stop api
docker rm api

# 网络管理
docker network create my-network
docker network ls
docker network inspect my-network

# Volume 管理
docker volume create my-data
docker volume ls
docker volume inspect my-data

# docker-compose
docker-compose up -d
docker-compose down
docker-compose logs -f
docker-compose ps
```

### Dockerfile 最佳实践

```dockerfile
# 1. 使用官方基础镜像
FROM python:3.13-slim

# 2. 设置工作目录
WORKDIR /app

# 3. 先复制依赖文件（利用缓存）
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 4. 再复制代码
COPY . .

# 5. 使用非 root 用户
USER appuser

# 6. 健康检查
HEALTHCHECK CMD curl -f http://localhost:8000/health

# 7. 启动命令（Exec 形式）
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0"]
```

### 多阶段构建模板

```dockerfile
# Builder 阶段
FROM python:3.13-slim AS builder
WORKDIR /app
RUN pip install uv
COPY pyproject.toml uv.lock ./
RUN uv sync --frozen --no-dev

# Runtime 阶段
FROM python:3.13-slim
WORKDIR /app
COPY --from=builder /app/.venv /app/.venv
COPY app/ app/
ENV PATH="/app/.venv/bin:$PATH"
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0"]
```

### docker-compose 模板

```yaml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    networks:
      - app-network
    volumes:
      - api_logs:/app/logs
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/db
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s

  db:
    image: postgres:14-alpine
    networks:
      - app-network
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_PASSWORD=secret
    healthcheck:
      test: ["CMD-SHELL", "pg_isready"]
      interval: 10s

  redis:
    image: redis:7-alpine
    networks:
      - app-network
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s

networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:
  api_logs:
```

---

## 学习检查清单

完成本知识点学习后，你应该能够：

**基础能力：**
- [ ] 理解容器和镜像的区别
- [ ] 编写基础 Dockerfile
- [ ] 使用多阶段构建优化镜像体积
- [ ] 配置容器网络和数据持久化
- [ ] 使用 docker-compose 编排多容器应用

**进阶能力：**
- [ ] 编写生产级 Dockerfile（非 root 用户、健康检查）
- [ ] 配置资源限制和自动重启
- [ ] 扫描镜像安全漏洞
- [ ] 实现优雅关闭
- [ ] 管理环境变量和密钥

**实战能力：**
- [ ] 容器化完整 AI Agent API
- [ ] 配置 API + PostgreSQL + Redis 多容器应用
- [ ] 编写部署脚本
- [ ] 备份和恢复数据
- [ ] 监控容器资源使用

---

## 总结

**Docker 容器化的核心知识：**
1. 容器 = 隔离的进程 + 独立的文件系统
2. Dockerfile 5个核心指令：FROM、WORKDIR、COPY、RUN、CMD
3. 镜像层缓存：先复制依赖文件，再复制代码
4. 多阶段构建：分离构建和运行环境
5. 网络配置：使用自定义网络
6. 数据持久化：使用 Volume
7. 安全实践：非 root 用户 + 不硬编码敏感信息
8. 健康检查：确保应用真正可用
9. docker-compose：编排多容器应用
10. 生产配置：健康检查 + 资源限制 + 自动重启

**记住：** Docker 容器化是现代 AI Agent 后端开发的基础，掌握这10个知识卡片，就能开始容器化你的应用。

---

**版本：** v1.0
**最后更新：** 2026-02-12
**适用于：** Python 3.13+ / FastAPI / AI Agent 后端开发
