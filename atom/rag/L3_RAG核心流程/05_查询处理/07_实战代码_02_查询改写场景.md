# 实战代码 02：查询改写场景

## 概述

本文提供查询改写的完整可运行代码示例，涵盖基础改写、领域特定改写、缓存优化等实战场景。所有代码基于 Python 3.13+，使用 OpenAI API。

---

## 场景 1：基础查询改写系统

### 需求

构建一个基础的查询改写系统，能够将口语化查询转化为专业表达。

### 完整代码

```python
from openai import OpenAI
from typing import Optional
import time

client = OpenAI()

# 基础改写 Prompt
REWRITE_PROMPT = """你是一个查询优化专家。请将用户的原始查询改写为更适合检索技术文档的形式。

改写要求：
1. 保持原始查询的核心意图不变
2. 使用技术文档中常见的专业术语
3. 补充隐含的上下文信息
4. 增加相关关键词的密度
5. 消除歧义和模糊表达
6. 输出简洁的改写结果，不要解释

原始查询：{query}

改写后的查询："""

def rewrite_query(query: str, temperature: float = 0.3) -> str:
    """基础查询改写"""
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "user", "content": REWRITE_PROMPT.format(query=query)}
        ],
        temperature=temperature,
        max_tokens=100
    )

    return response.choices[0].message.content.strip()

# 测试
if __name__ == "__main__":
    test_queries = [
        "Python 怎么跑得快？",
        "RAG 不准怎么办？",
        "GIL 是什么？",
        "怎么让代码更快？",
        "LangChain 和 LlamaIndex 哪个好？"
    ]

    print("=" * 80)
    print("基础查询改写测试")
    print("=" * 80 + "\n")

    for query in test_queries:
        start_time = time.time()
        rewritten = rewrite_query(query)
        elapsed = (time.time() - start_time) * 1000

        print(f"原始查询: {query}")
        print(f"改写查询: {rewritten}")
        print(f"耗时: {elapsed:.0f}ms\n")
```

### 运行结果

```
================================================================================
基础查询改写测试
================================================================================

原始查询: Python 怎么跑得快？
改写查询: Python 性能优化方法和最佳实践
耗时: 245ms

原始查询: RAG 不准怎么办？
改写查询: 提升 RAG 系统准确性的优化策略和解决方案
耗时: 198ms

原始查询: GIL 是什么？
改写查询: Python 的 Global Interpreter Lock (GIL) 概念解释
耗时: 187ms

原始查询: 怎么让代码更快？
改写查询: 代码性能优化技术和加速方法
耗时: 176ms

原始查询: LangChain 和 LlamaIndex 哪个好？
改写查询: LangChain 和 LlamaIndex 框架对比分析
耗时: 192ms
```

---

## 场景 2：领域特定查询改写

### 需求

根据不同的应用领域（技术、医疗、法律等），使用领域特定的术语进行改写。

### 完整代码

```python
DOMAIN_SPECIFIC_PROMPT = """你是一个 {domain} 领域的查询优化专家。请将用户的原始查询改写为更适合检索 {domain} 文档的形式。

改写要求：
1. 保持原始查询的核心意图不变
2. 使用 {domain} 领域的专业术语
3. 补充 {domain} 相关的上下文信息
4. 增加 {domain} 关键词的密度
5. 消除歧义和模糊表达
6. 输出简洁的改写结果，不要解释

原始查询：{query}

改写后的查询："""

def rewrite_domain_specific(
    query: str,
    domain: str = "技术",
    temperature: float = 0.3
) -> str:
    """领域特定的查询改写"""
    prompt = DOMAIN_SPECIFIC_PROMPT.format(query=query, domain=domain)

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=temperature,
        max_tokens=100
    )

    return response.choices[0].message.content.strip()

# 测试
if __name__ == "__main__":
    test_cases = [
        ("怎么让 Python 跑得快？", "Python 编程"),
        ("头疼怎么办？", "医疗健康"),
        ("合同纠纷怎么处理？", "法律"),
        ("如何提升销售额？", "商业管理")
    ]

    print("=" * 80)
    print("领域特定查询改写测试")
    print("=" * 80 + "\n")

    for query, domain in test_cases:
        rewritten = rewrite_domain_specific(query, domain)

        print(f"领域: {domain}")
        print(f"原始查询: {query}")
        print(f"改写查询: {rewritten}\n")
```

### 运行结果

```
================================================================================
领域特定查询改写测试
================================================================================

领域: Python 编程
原始查询: 怎么让 Python 跑得快？
改写查询: Python 性能优化技术和代码加速方法

领域: 医疗健康
原始查询: 头疼怎么办？
改写查询: 头痛症状的诊断方法和治疗方案

领域: 法律
原始查询: 合同纠纷怎么处理？
改写查询: 合同纠纷的法律处理程序和解决方案

领域: 商业管理
原始查询: 如何提升销售额？
改写查询: 销售业绩提升策略和增长方法
```

---

## 场景 3：带缓存的查询改写

### 需求

对高频查询进行缓存，减少 LLM 调用成本和延迟。

### 完整代码

```python
from functools import lru_cache
from typing import Dict
import json

class CachedQueryRewriter:
    """带缓存的查询改写器"""

    def __init__(self, cache_size: int = 1000):
        self.cache: Dict[str, str] = {}
        self.cache_size = cache_size
        self.hits = 0
        self.misses = 0

    def rewrite(self, query: str) -> Dict[str, any]:
        """改写查询（带缓存）"""
        # 检查缓存
        if query in self.cache:
            self.hits += 1
            return {
                "original": query,
                "rewritten": self.cache[query],
                "from_cache": True,
                "cache_hit_rate": self.get_hit_rate()
            }

        # 缓存未命中，调用 LLM
        self.misses += 1
        rewritten = rewrite_query(query)

        # 更新缓存
        if len(self.cache) >= self.cache_size:
            # 简单的 FIFO 策略
            first_key = next(iter(self.cache))
            del self.cache[first_key]

        self.cache[query] = rewritten

        return {
            "original": query,
            "rewritten": rewritten,
            "from_cache": False,
            "cache_hit_rate": self.get_hit_rate()
        }

    def get_hit_rate(self) -> float:
        """获取缓存命中率"""
        total = self.hits + self.misses
        return self.hits / total if total > 0 else 0.0

    def get_stats(self) -> Dict[str, any]:
        """获取统计信息"""
        return {
            "cache_size": len(self.cache),
            "hits": self.hits,
            "misses": self.misses,
            "hit_rate": self.get_hit_rate()
        }

# 测试
if __name__ == "__main__":
    rewriter = CachedQueryRewriter(cache_size=100)

    # 模拟高频查询
    queries = [
        "Python 性能优化",
        "RAG 系统准确性",
        "Python 性能优化",  # 重复
        "LangChain 使用方法",
        "Python 性能优化",  # 重复
        "RAG 系统准确性",   # 重复
    ]

    print("=" * 80)
    print("带缓存的查询改写测试")
    print("=" * 80 + "\n")

    for i, query in enumerate(queries, 1):
        result = rewriter.rewrite(query)

        print(f"查询 {i}: {query}")
        print(f"改写: {result['rewritten']}")
        print(f"来源: {'缓存' if result['from_cache'] else 'LLM'}")
        print(f"命中率: {result['cache_hit_rate']:.1%}\n")

    # 显示统计信息
    stats = rewriter.get_stats()
    print("=" * 80)
    print("缓存统计")
    print("=" * 80)
    print(f"缓存大小: {stats['cache_size']}")
    print(f"命中次数: {stats['hits']}")
    print(f"未命中次数: {stats['misses']}")
    print(f"命中率: {stats['hit_rate']:.1%}")
```

### 运行结果

```
================================================================================
带缓存的查询改写测试
================================================================================

查询 1: Python 性能优化
改写: Python 性能优化方法和最佳实践
来源: LLM
命中率: 0.0%

查询 2: RAG 系统准确性
改写: RAG 系统准确性提升策略和优化方法
来源: LLM
命中率: 0.0%

查询 3: Python 性能优化
改写: Python 性能优化方法和最佳实践
来源: 缓存
命中率: 33.3%

查询 4: LangChain 使用方法
改写: LangChain 框架使用指南和实践方法
来源: LLM
命中率: 25.0%

查询 5: Python 性能优化
改写: Python 性能优化方法和最佳实践
来源: 缓存
命中率: 40.0%

查询 6: RAG 系统准确性
改写: RAG 系统准确性提升策略和优化方法
来源: 缓存
命中率: 50.0%

================================================================================
缓存统计
================================================================================
缓存大小: 3
命中次数: 3
未命中次数: 3
命中率: 50.0%
```

---

## 场景 4：多轮改写优化

### 需求

通过多轮改写逐步优化查询质量。

### 完整代码

```python
def multi_round_rewrite(
    query: str,
    rounds: int = 2,
    temperature: float = 0.3
) -> Dict[str, any]:
    """多轮改写优化"""
    history = [{"round": 0, "query": query}]
    current_query = query

    for i in range(rounds):
        prompt = f"""请优化以下查询，使其更适合检索技术文档：

当前查询：{current_query}

优化要求：
1. 使用更专业的术语
2. 补充更多相关关键词
3. 保持查询简洁

优化后的查询："""

        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=temperature,
            max_tokens=100
        )

        current_query = response.choices[0].message.content.strip()
        history.append({"round": i + 1, "query": current_query})

    return {
        "original": query,
        "final": current_query,
        "history": history
    }

# 测试
if __name__ == "__main__":
    test_queries = [
        "Python 快一点",
        "RAG 不好用"
    ]

    print("=" * 80)
    print("多轮改写优化测试")
    print("=" * 80 + "\n")

    for query in test_queries:
        result = multi_round_rewrite(query, rounds=3)

        print(f"原始查询: {result['original']}")
        print(f"最终查询: {result['final']}\n")

        print("改写历史:")
        for item in result['history']:
            print(f"  轮次 {item['round']}: {item['query']}")
        print()
```

### 运行结果

```
================================================================================
多轮改写优化测试
================================================================================

原始查询: Python 快一点
最终查询: Python 性能优化技术、代码加速方法和执行效率提升策略

改写历史:
  轮次 0: Python 快一点
  轮次 1: Python 性能优化方法
  轮次 2: Python 性能优化技术和代码加速方法
  轮次 3: Python 性能优化技术、代码加速方法和执行效率提升策略

原始查询: RAG 不好用
最终查询: RAG 系统性能优化、准确性提升和用户体验改进策略

改写历史:
  轮次 0: RAG 不好用
  轮次 1: RAG 系统优化方法
  轮次 2: RAG 系统性能优化和准确性提升方法
  轮次 3: RAG 系统性能优化、准确性提升和用户体验改进策略
```

---

## 场景 5：查询改写与 RAG 集成

### 需求

将查询改写集成到完整的 RAG 流程中。

### 完整代码

```python
import chromadb
from typing import List

# 初始化向量数据库
chroma_client = chromadb.Client()
collection = chroma_client.create_collection("tech_docs")

# 添加示例文档
collection.add(
    documents=[
        "Python 性能优化的核心方法包括：使用内置函数、避免全局变量、使用列表推导式、缓存计算结果。",
        "Python GIL（全局解释器锁）限制了多线程的并行执行，可以使用多进程或异步编程绕过。",
        "使用 Cython 可以将 Python 代码编译为 C 代码，显著提升执行速度。",
        "RAG 系统的准确性优化包括：改进检索策略、优化 Prompt、使用 ReRank、减少幻觉。",
        "LangChain 提供了丰富的 RAG 组件，包括文档加载器、文本分块器、向量存储和检索器。"
    ],
    ids=["doc1", "doc2", "doc3", "doc4", "doc5"]
)

def rag_with_rewrite(
    query: str,
    k: int = 3,
    use_rewrite: bool = True
) -> Dict[str, any]:
    """带查询改写的 RAG"""
    print(f"原始查询: {query}\n")

    # 1. 查询改写（可选）
    if use_rewrite:
        rewritten_query = rewrite_query(query)
        print(f"改写查询: {rewritten_query}\n")
        search_query = rewritten_query
    else:
        search_query = query

    # 2. 检索文档
    results = collection.query(
        query_texts=[search_query],
        n_results=k
    )

    docs = results['documents'][0]
    print(f"检索到 {len(docs)} 个文档:")
    for i, doc in enumerate(docs, 1):
        print(f"  {i}. {doc[:80]}...")

    # 3. 生成答案
    context = "\n\n".join(docs)

    answer_prompt = f"""基于以下上下文回答问题：

上下文：
{context}

问题：{query}

答案："""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": answer_prompt}],
        temperature=0.7
    )

    answer = response.choices[0].message.content.strip()

    return {
        "original_query": query,
        "rewritten_query": rewritten_query if use_rewrite else None,
        "documents": docs,
        "answer": answer
    }

# 测试
if __name__ == "__main__":
    test_queries = [
        "Python 怎么跑得快？",
        "RAG 不准怎么办？"
    ]

    print("=" * 80)
    print("查询改写 + RAG 集成测试")
    print("=" * 80 + "\n")

    for query in test_queries:
        print("【使用查询改写】")
        result_with = rag_with_rewrite(query, use_rewrite=True)
        print(f"\n答案: {result_with['answer']}\n")
        print("-" * 80 + "\n")

        print("【不使用查询改写】")
        result_without = rag_with_rewrite(query, use_rewrite=False)
        print(f"\n答案: {result_without['answer']}\n")
        print("=" * 80 + "\n")
```

### 运行结果

```
================================================================================
查询改写 + RAG 集成测试
================================================================================

【使用查询改写】
原始查询: Python 怎么跑得快？

改写查询: Python 性能优化方法和最佳实践

检索到 3 个文档:
  1. Python 性能优化的核心方法包括：使用内置函数、避免全局变量、使用列表推导式、缓存计算结果。...
  2. 使用 Cython 可以将 Python 代码编译为 C 代码，显著提升执行速度。...
  3. Python GIL（全局解释器锁）限制了多线程的并行执行，可以使用多进程或异步编程绕过。...

答案: Python 性能优化的方法包括：1) 使用内置函数和列表推导式；2) 避免全局变量；3) 缓存计算结果；4) 使用 Cython 编译为 C 代码；5) 使用多进程或异步编程绕过 GIL 限制。

--------------------------------------------------------------------------------

【不使用查询改写】
原始查询: Python 怎么跑得快？

检索到 3 个文档:
  1. Python GIL（全局解释器锁）限制了多线程的并行执行，可以使用多进程或异步编程绕过。...
  2. 使用 Cython 可以将 Python 代码编译为 C 代码，显著提升执行速度。...
  3. Python 性能优化的核心方法包括：使用内置函数、避免全局变量、使用列表推导式、缓存计算结果。...

答案: 可以使用多进程或异步编程绕过 GIL 限制，或使用 Cython 编译代码提升速度。

================================================================================
```

---

## 场景 6：A/B 测试查询改写效果

### 需求

对比查询改写前后的检索效果。

### 完整代码

```python
from typing import List, Dict

def evaluate_retrieval_quality(
    docs: List[str],
    query: str
) -> float:
    """评估检索质量（简化版）"""
    # 简单的相关性评分：检查文档是否包含查询关键词
    query_keywords = set(query.lower().split())
    scores = []

    for doc in docs:
        doc_words = set(doc.lower().split())
        overlap = len(query_keywords & doc_words)
        score = overlap / len(query_keywords) if query_keywords else 0
        scores.append(score)

    return sum(scores) / len(scores) if scores else 0

def ab_test_rewrite(
    test_queries: List[str],
    k: int = 5
) -> Dict[str, any]:
    """A/B 测试查询改写效果"""
    results = []

    for query in test_queries:
        # A组：不使用改写
        original_results = collection.query(
            query_texts=[query],
            n_results=k
        )
        original_docs = original_results['documents'][0]
        original_quality = evaluate_retrieval_quality(original_docs, query)

        # B组：使用改写
        rewritten_query = rewrite_query(query)
        rewritten_results = collection.query(
            query_texts=[rewritten_query],
            n_results=k
        )
        rewritten_docs = rewritten_results['documents'][0]
        rewritten_quality = evaluate_retrieval_quality(rewritten_docs, rewritten_query)

        results.append({
            "query": query,
            "rewritten": rewritten_query,
            "original_quality": original_quality,
            "rewritten_quality": rewritten_quality,
            "improvement": rewritten_quality - original_quality
        })

    return results

# 测试
if __name__ == "__main__":
    test_queries = [
        "Python 快",
        "RAG 不好",
        "怎么优化？"
    ]

    print("=" * 80)
    print("A/B 测试查询改写效果")
    print("=" * 80 + "\n")

    results = ab_test_rewrite(test_queries)

    for result in results:
        print(f"原始查询: {result['query']}")
        print(f"改写查询: {result['rewritten']}")
        print(f"原始质量: {result['original_quality']:.2f}")
        print(f"改写质量: {result['rewritten_quality']:.2f}")
        print(f"提升幅度: {result['improvement']:+.2f}")
        print()

    # 计算平均提升
    avg_improvement = sum(r['improvement'] for r in results) / len(results)
    print("=" * 80)
    print(f"平均提升: {avg_improvement:+.2f}")
```

---

## 总结

### 关键要点

1. **基础改写**：使用 LLM 将口语化查询转化为专业表达
2. **领域特定**：根据应用领域定制改写策略
3. **缓存优化**：对高频查询缓存改写结果，降低成本
4. **多轮优化**：通过多轮改写逐步提升查询质量
5. **RAG 集成**：将改写无缝集成到 RAG 流程
6. **效果评估**：通过 A/B 测试验证改写效果

### 代码特点

- 所有代码可直接运行
- 使用 Python 3.13+ 特性
- 基于 OpenAI API
- 包含完整的测试用例
- 提供性能统计和评估

### 性能优化建议

1. **使用缓存**：对高频查询缓存改写结果
2. **批量处理**：批量改写多个查询
3. **异步调用**：使用异步 API 减少延迟
4. **模型选择**：使用 gpt-4o-mini 降低成本

### 下一步

参考后续的实战代码文件，学习多查询生成、查询分解和 HyDE 的实现。
