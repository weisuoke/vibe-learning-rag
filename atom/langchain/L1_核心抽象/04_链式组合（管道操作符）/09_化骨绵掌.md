# 化骨绵掌：10个知识卡片

每个卡片2分钟速读，全面掌握管道操作符。

---

## 卡片1：管道操作符的本质

**一句话：** 管道操作符 `|` 是 Python `__or__` 方法重载，将多个 Runnable 组合成 RunnableSequence。

**举例：**
```python
# 表面语法
chain = prompt | model | parser

# 实际调用
chain = prompt.__or__(model).__or__(parser)

# 返回类型
type(chain)  # RunnableSequence
```

**应用：** 在 AI Agent 中，用管道操作符快速组合 prompt、model、parser，构建声明式数据流。

---

## 卡片2：数据流方向

**一句话：** 数据从左到右流动，前一个组件的输出自动成为后一个组件的输入。

**举例：**
```python
chain = prompt | model | parser

# 数据流
{"topic": "AI"}  # 输入
  ↓ prompt
ChatPromptValue
  ↓ model
AIMessage
  ↓ parser
"AI 是..."  # 输出
```

**应用：** RAG 系统中，query → retriever → prompt → model → parser，数据单向流动。

---

## 卡片3：类型匹配规则

**一句话：** 左边的输出类型必须严格匹配右边的输入类型，否则运行时报错。

**举例：**
```python
# ✅ 正确：类型匹配
ChatPromptTemplate  # dict → ChatPromptValue
| ChatModel         # ChatPromptValue → AIMessage
| StrOutputParser   # AIMessage → str

# ❌ 错误：类型不匹配
ChatPromptTemplate  # dict → ChatPromptValue
| StrOutputParser   # 期望 AIMessage，得到 ChatPromptValue
```

**应用：** 调试管道时，检查每个步骤的输入输出类型，确保类型链完整。

---

## 卡片4：字典分发数据

**一句话：** 字典可以将输入分发到多个路径，每个键对应一个 Runnable。

**举例：**
```python
chain = (
    {
        "context": retriever,           # 路径1
        "question": RunnablePassthrough()  # 路径2
    }
    | prompt
    | model
    | parser
)

# 数据流
"问题" → 分发 → {"context": [...], "question": "问题"} → prompt
```

**应用：** RAG 中同时获取上下文和保留原始问题，两路数据并行处理后合并。

---

## 卡片5：并行执行（RunnableParallel）

**一句话：** RunnableParallel 同时执行多个独立任务，显著提升性能。

**举例：**
```python
parallel = RunnableParallel(
    summary=summarizer,      # 并行任务1
    translation=translator,  # 并行任务2
    sentiment=analyzer       # 并行任务3
)

# 串行：3秒（1+1+1）
# 并行：1秒（max(1,1,1)）
# 性能提升：3x
```

**应用：** 多源检索、多模型投票、多任务处理等场景，用并行执行降低延迟。

---

## 卡片6：条件路由（RunnableBranch）

**一句话：** RunnableBranch 根据条件动态选择执行路径，实现智能路由。

**举例：**
```python
router = RunnableBranch(
    (lambda x: len(x) < 10, simple_chain),   # 简单任务
    (lambda x: len(x) < 100, medium_chain),  # 中等任务
    complex_chain                             # 复杂任务（默认）
)

# 根据输入长度自动选择合适的处理链
```

**应用：** 根据任务复杂度选择不同模型（gpt-4o-mini vs gpt-4），平衡成本和质量。

---

## 卡片7：四种调用方式

**一句话：** 管道支持 invoke（同步）、ainvoke（异步）、batch（批量）、stream（流式）四种调用方式。

**举例：**
```python
chain = prompt | model | parser

# 1. 同步
result = chain.invoke(input)

# 2. 异步
result = await chain.ainvoke(input)

# 3. 批量
results = chain.batch([input1, input2, input3])

# 4. 流式
for chunk in chain.stream(input):
    print(chunk, end="")
```

**应用：** 对话系统用流式，批量评估用 batch，高并发用异步，单次查询用同步。

---

## 卡片8：错误处理与降级

**一句话：** 错误会中断管道执行，需要实现多级降级策略保证可用性。

**举例：**
```python
def with_fallback(primary, fallback):
    def invoke(input):
        try:
            return primary.invoke(input)
        except Exception:
            return fallback.invoke(input)
    return RunnableLambda(invoke)

# 主路径失败 → 降级路径
resilient_chain = with_fallback(gpt4_chain, gpt35_chain)
```

**应用：** 生产环境中，主模型失败时自动降级到备用模型，保证服务可用性。

---

## 卡片9：设计模式

**一句话：** 管道操作符融合了函数组合、管道模式、责任链、装饰器等多种设计模式。

**举例：**
```python
# 函数组合
chain = f | g | h  # (h ∘ g ∘ f)(x)

# 管道模式
chain = load | clean | transform | save

# 责任链
chain = validator | cache | rate_limiter | model

# 装饰器
chain = with_logging(with_retry(model))
```

**应用：** 理解设计模式有助于构建更优雅、可维护的 AI 系统架构。

---

## 卡片10：生产级最佳实践

**一句话：** 生产环境需要监控、缓存、重试、降级、批处理等完整的工程化能力。

**举例：**
```python
# 生产级链
production_chain = (
    cache_layer              # 缓存
    | with_retry(            # 重试
        with_fallback(       # 降级
            expensive_model,
            cheap_model
        ),
        max_retries=3
    )
)

# 带监控执行
result = production_chain.invoke(
    input,
    config={"callbacks": [monitor, logger]}
)
```

**应用：** 构建企业级 RAG 系统，需要完整的错误处理、性能优化、成本控制策略。

---

## 快速复习表

| 卡片 | 核心概念 | 关键点 |
|------|----------|--------|
| 1 | 本质 | `__or__` 方法重载 |
| 2 | 数据流 | 从左到右，单向流动 |
| 3 | 类型匹配 | 左输出 = 右输入 |
| 4 | 字典分发 | 多路并行处理 |
| 5 | 并行执行 | RunnableParallel 提升性能 |
| 6 | 条件路由 | RunnableBranch 智能选择 |
| 7 | 调用方式 | invoke/ainvoke/batch/stream |
| 8 | 错误处理 | 多级降级保证可用性 |
| 9 | 设计模式 | 函数组合/管道/责任链 |
| 10 | 生产实践 | 监控/缓存/重试/降级 |

---

## 学习路径建议

### 初学者（第1-3天）
- 卡片1-4：掌握基础概念和语法
- 实战：写出 `prompt | model | parser` 基础链

### 进阶者（第4-7天）
- 卡片5-7：掌握高级特性
- 实战：构建完整的 RAG 管道

### 专家级（第8-10天）
- 卡片8-10：掌握生产级模式
- 实战：构建企业级 AI 系统

---

## 常见问题速查

**Q1: 管道操作符和函数组合有什么区别？**
A: 管道从左到右，函数组合从右到左；管道支持异步/批量/流式，函数组合只支持同步。

**Q2: 如何调试管道执行？**
A: 使用 RunnableLambda 插入调试步骤，或使用回调系统追踪每个步骤。

**Q3: 管道执行失败怎么办？**
A: 检查类型匹配、实现错误处理、添加降级策略。

**Q4: 如何提升管道性能？**
A: 使用 RunnableParallel 并行执行、batch 批量处理、缓存重复请求。

**Q5: 生产环境需要注意什么？**
A: 监控、日志、错误处理、降级、成本优化、安全性。

---

## 实战检查清单

完成以下任务，确保掌握管道操作符：

- [ ] 写出 `prompt | model | parser` 基础链
- [ ] 使用字典实现多路数据分发
- [ ] 使用 RunnableParallel 实现并行执行
- [ ] 使用 RunnableBranch 实现条件路由
- [ ] 实现错误处理和降级策略
- [ ] 使用 batch 方法批量处理
- [ ] 使用 stream 方法实现流式输出
- [ ] 使用 ainvoke 实现异步执行
- [ ] 构建完整的 RAG 管道
- [ ] 添加监控和日志系统

---

## 延伸学习

### 下一步学习内容
1. **RunnablePassthrough 与 RunnableLambda**：深入理解数据传递
2. **RunnableParallel 并行执行**：掌握并行优化技巧
3. **RunnableBranch 条件路由**：实现复杂的路由逻辑
4. **LangGraph**：学习有状态的工作流引擎

### 推荐资源
- [LangChain Official Docs](https://python.langchain.com/docs/concepts/)
- [Pinecone LCEL Tutorial](https://www.pinecone.io/learn/series/langchain/langchain-expression-language)
- [Medium Production Guide](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557)

---

**版本**: v1.0
**最后更新**: 2026-02-18
**维护者**: Claude Code

---

[Source: LangChain Official Docs - https://python.langchain.com/docs/concepts/]
[Source: Pinecone LCEL Tutorial - https://www.pinecone.io/learn/series/langchain/langchain-expression-language]
