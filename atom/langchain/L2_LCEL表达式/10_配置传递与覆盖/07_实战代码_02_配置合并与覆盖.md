# 实战代码02：配置合并与覆盖

> **场景**: 演示merge_configs()函数、字段级覆盖规则、callbacks连接、tags连接、metadata合并和优先级规则

---

## 一、完整可运行代码

```python
"""
配置合并与覆盖示例
演示：merge_configs()、字段级覆盖、callbacks连接、优先级规则
"""

import os
from typing import Dict, Any, List
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables.config import merge_configs
from langchain_core.callbacks import BaseCallbackHandler

# 加载环境变量
load_dotenv()

# ============================================================================
# 第一部分：自定义回调用于追踪
# ============================================================================

class CallbackA(BaseCallbackHandler):
    """回调A - 追踪链开始"""

    def on_chain_start(self, serialized: Dict[str, Any], inputs: Dict[str, Any], **kwargs):
        print(f"  [CallbackA] 链开始: {serialized.get('name', 'unknown')}")

class CallbackB(BaseCallbackHandler):
    """回调B - 追踪LLM开始"""

    def on_llm_start(self, serialized: Dict[str, Any], prompts: List[str], **kwargs):
        print(f"  [CallbackB] LLM开始: {prompts[0][:30]}...")

class CallbackC(BaseCallbackHandler):
    """回调C - 追踪链结束"""

    def on_chain_end(self, outputs: Dict[str, Any], **kwargs):
        print(f"  [CallbackC] 链结束")


# ============================================================================
# 第二部分：merge_configs()基础演示
# ============================================================================

def example_1_basic_merge():
    """示例1：merge_configs()基础用法"""
    print("\n" + "="*80)
    print("示例1：merge_configs()基础用法")
    print("="*80)

    # 创建两个配置
    config1 = {
        "tags": ["config1", "base"],
        "metadata": {"source": "config1", "version": "1.0"},
        "run_name": "config1_run"
    }

    config2 = {
        "tags": ["config2", "override"],
        "metadata": {"source": "config2", "environment": "prod"},
        "run_name": "config2_run"
    }

    print(f"\n配置1: {config1}")
    print(f"\n配置2: {config2}")

    # 合并配置
    merged = merge_configs(config1, config2)

    print(f"\n合并后的配置: {merged}")
    print("\n合并规则：")
    print("- tags: 连接（config1的tags + config2的tags）")
    print("- metadata: 合并（config2的字段覆盖config1的同名字段）")
    print("- run_name: 覆盖（使用config2的值）")


# ============================================================================
# 第三部分：字段级覆盖规则
# ============================================================================

def example_2_field_level_override():
    """示例2：不同字段的覆盖规则"""
    print("\n" + "="*80)
    print("示例2：字段级覆盖规则")
    print("="*80)

    # 基础配置
    base_config = {
        "tags": ["base"],
        "metadata": {"user": "alice", "session": "123"},
        "run_name": "base_run",
        "max_concurrency": 5,
        "recursion_limit": 10
    }

    # 覆盖配置
    override_config = {
        "tags": ["override"],
        "metadata": {"user": "bob", "request_id": "456"},
        "run_name": "override_run",
        "max_concurrency": 10
    }

    print(f"\n基础配置: {base_config}")
    print(f"\n覆盖配置: {override_config}")

    # 合并
    merged = merge_configs(base_config, override_config)

    print(f"\n合并结果: {merged}")
    print("\n字段级规则：")
    print(f"- tags: {merged['tags']} (连接)")
    print(f"- metadata: {merged['metadata']} (合并，user被覆盖)")
    print(f"- run_name: {merged['run_name']} (覆盖)")
    print(f"- max_concurrency: {merged['max_concurrency']} (覆盖)")
    print(f"- recursion_limit: {merged.get('recursion_limit')} (保留)")


# ============================================================================
# 第四部分：Callbacks连接
# ============================================================================

def example_3_callbacks_concatenation():
    """示例3：Callbacks连接而非覆盖"""
    print("\n" + "="*80)
    print("示例3：Callbacks连接")
    print("="*80)

    # 配置1：包含CallbackA
    config1 = {
        "tags": ["config1"],
        "callbacks": [CallbackA()]
    }

    # 配置2：包含CallbackB和CallbackC
    config2 = {
        "tags": ["config2"],
        "callbacks": [CallbackB(), CallbackC()]
    }

    print("\n配置1包含: CallbackA")
    print("配置2包含: CallbackB, CallbackC")

    # 合并配置
    merged = merge_configs(config1, config2)

    print(f"\n合并后的callbacks数量: {len(merged['callbacks'])}")
    print("合并后包含: CallbackA, CallbackB, CallbackC")

    # 创建链并测试
    llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.7)
    prompt = ChatPromptTemplate.from_template("Say hello to {name}")
    chain = prompt | llm | StrOutputParser()

    print("\n执行链with合并的callbacks:")
    result = chain.invoke({"name": "World"}, config=merged)

    print(f"\n结果: {result}")
    print("\n观察：所有3个callbacks都被执行了")


# ============================================================================
# 第五部分：Tags连接
# ============================================================================

def example_4_tags_concatenation():
    """示例4：Tags连接示例"""
    print("\n" + "="*80)
    print("示例4：Tags连接")
    print("="*80)

    # 多层配置
    config_layer1 = {
        "tags": ["layer1", "base"]
    }

    config_layer2 = {
        "tags": ["layer2", "middleware"]
    }

    config_layer3 = {
        "tags": ["layer3", "application"]
    }

    print("\n层1 tags:", config_layer1["tags"])
    print("层2 tags:", config_layer2["tags"])
    print("层3 tags:", config_layer3["tags"])

    # 逐层合并
    merged_1_2 = merge_configs(config_layer1, config_layer2)
    print(f"\n合并层1+层2: {merged_1_2['tags']}")

    merged_all = merge_configs(merged_1_2, config_layer3)
    print(f"合并所有层: {merged_all['tags']}")

    print("\n结论：tags按顺序连接，保留所有标签")


# ============================================================================
# 第六部分：Metadata合并
# ============================================================================

def example_5_metadata_merge():
    """示例5：Metadata合并规则"""
    print("\n" + "="*80)
    print("示例5：Metadata合并")
    print("="*80)

    # 基础metadata
    base_metadata = {
        "user_id": "user-123",
        "session_id": "session-456",
        "environment": "dev",
        "version": "1.0"
    }

    # 覆盖metadata
    override_metadata = {
        "user_id": "user-789",  # 覆盖
        "request_id": "req-999",  # 新增
        "environment": "prod"  # 覆盖
    }

    config1 = {"metadata": base_metadata}
    config2 = {"metadata": override_metadata}

    print(f"\n基础metadata: {base_metadata}")
    print(f"\n覆盖metadata: {override_metadata}")

    # 合并
    merged = merge_configs(config1, config2)

    print(f"\n合并后的metadata: {merged['metadata']}")
    print("\n合并规则：")
    print("- user_id: user-789 (被覆盖)")
    print("- session_id: session-456 (保留)")
    print("- environment: prod (被覆盖)")
    print("- version: 1.0 (保留)")
    print("- request_id: req-999 (新增)")


# ============================================================================
# 第七部分：优先级规则演示
# ============================================================================

def example_6_priority_rules():
    """示例6：配置优先级规则"""
    print("\n" + "="*80)
    print("示例6：配置优先级规则")
    print("="*80)

    # 创建链
    llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.7)
    prompt = ChatPromptTemplate.from_template("Tell me about {topic}")
    chain = prompt | llm | StrOutputParser()

    # 链级配置（使用with_config绑定）
    chain_config = {
        "tags": ["chain-level"],
        "metadata": {"level": "chain", "priority": "low"},
        "run_name": "chain_run"
    }

    chain_with_config = chain.with_config(chain_config)

    # 调用级配置（invoke时传递）
    invoke_config = {
        "tags": ["invoke-level"],
        "metadata": {"level": "invoke", "priority": "high"},
        "run_name": "invoke_run"
    }

    print("\n链级配置:", chain_config)
    print("\n调用级配置:", invoke_config)

    print("\n执行链...")
    result = chain_with_config.invoke({"topic": "Python"}, config=invoke_config)

    print(f"\n结果: {result[:100]}...")
    print("\n优先级规则：")
    print("- tags: ['chain-level', 'invoke-level'] (连接)")
    print("- metadata: {'level': 'invoke', 'priority': 'high'} (invoke覆盖chain)")
    print("- run_name: 'invoke_run' (invoke覆盖chain)")
    print("\n结论：调用级配置优先级高于链级配置")


# ============================================================================
# 第八部分：多次合并
# ============================================================================

def example_7_multiple_merges():
    """示例7：多次合并配置"""
    print("\n" + "="*80)
    print("示例7：多次合并")
    print("="*80)

    # 全局配置
    global_config = {
        "tags": ["global"],
        "metadata": {"environment": "production", "region": "us-east"},
        "max_concurrency": 10
    }

    # 用户配置
    user_config = {
        "tags": ["user-123"],
        "metadata": {"user_id": "123", "tier": "premium"},
        "max_concurrency": 20
    }

    # 请求配置
    request_config = {
        "tags": ["request-456"],
        "metadata": {"request_id": "456", "timestamp": "2026-02-21"},
        "run_name": "specific_request"
    }

    print("\n全局配置:", global_config)
    print("\n用户配置:", user_config)
    print("\n请求配置:", request_config)

    # 第一次合并：全局 + 用户
    merged_1 = merge_configs(global_config, user_config)
    print(f"\n合并1（全局+用户）:")
    print(f"  tags: {merged_1['tags']}")
    print(f"  metadata: {merged_1['metadata']}")
    print(f"  max_concurrency: {merged_1['max_concurrency']}")

    # 第二次合并：(全局+用户) + 请求
    merged_2 = merge_configs(merged_1, request_config)
    print(f"\n合并2（全局+用户+请求）:")
    print(f"  tags: {merged_2['tags']}")
    print(f"  metadata: {merged_2['metadata']}")
    print(f"  max_concurrency: {merged_2['max_concurrency']}")
    print(f"  run_name: {merged_2['run_name']}")

    print("\n结论：")
    print("- tags按顺序累积")
    print("- metadata逐层合并，后来的覆盖前面的")
    print("- 简单字段（max_concurrency）使用最后的值")


# ============================================================================
# 第九部分：空配置处理
# ============================================================================

def example_8_empty_config_handling():
    """示例8：空配置和None处理"""
    print("\n" + "="*80)
    print("示例8：空配置处理")
    print("="*80)

    # 完整配置
    full_config = {
        "tags": ["full"],
        "metadata": {"key": "value"},
        "run_name": "full_run"
    }

    # 空配置
    empty_config = {}

    # None配置
    none_config = None

    print("\n完整配置:", full_config)
    print("空配置:", empty_config)
    print("None配置:", none_config)

    # 测试合并
    print("\n合并测试：")

    # 完整 + 空
    merged_1 = merge_configs(full_config, empty_config)
    print(f"完整 + 空 = {merged_1}")

    # 空 + 完整
    merged_2 = merge_configs(empty_config, full_config)
    print(f"空 + 完整 = {merged_2}")

    # 完整 + None
    merged_3 = merge_configs(full_config, none_config)
    print(f"完整 + None = {merged_3}")

    # None + 完整
    merged_4 = merge_configs(none_config, full_config)
    print(f"None + 完整 = {merged_4}")

    print("\n结论：")
    print("- 空配置不影响合并结果")
    print("- None配置被视为空配置")
    print("- merge_configs()安全处理边界情况")


# ============================================================================
# 第十部分：实际应用场景
# ============================================================================

def example_9_real_world_scenario():
    """示例9：实际应用场景"""
    print("\n" + "="*80)
    print("示例9：实际应用场景")
    print("="*80)

    # 创建链
    llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.7)
    prompt = ChatPromptTemplate.from_template("Summarize: {text}")
    chain = prompt | llm | StrOutputParser()

    # 应用级默认配置
    app_default_config = {
        "tags": ["app", "summarization"],
        "metadata": {
            "app_name": "TextSummarizer",
            "version": "2.0",
            "environment": "production"
        },
        "max_concurrency": 5
    }

    # 用户特定配置
    user_config = {
        "tags": ["user-premium"],
        "metadata": {
            "user_id": "user-12345",
            "subscription": "premium",
            "rate_limit": 1000
        },
        "max_concurrency": 10  # Premium用户更高并发
    }

    # 请求特定配置
    request_config = {
        "tags": ["urgent"],
        "metadata": {
            "request_id": "req-67890",
            "priority": "high",
            "timestamp": "2026-02-21T10:30:00Z"
        },
        "run_name": "urgent_summarization"
    }

    print("\n应用默认配置:", app_default_config)
    print("\n用户配置:", user_config)
    print("\n请求配置:", request_config)

    # 合并所有配置
    final_config = merge_configs(
        merge_configs(app_default_config, user_config),
        request_config
    )

    print(f"\n最终配置:")
    print(f"  tags: {final_config['tags']}")
    print(f"  metadata: {final_config['metadata']}")
    print(f"  max_concurrency: {final_config['max_concurrency']}")
    print(f"  run_name: {final_config['run_name']}")

    # 执行
    print("\n执行摘要任务...")
    result = chain.invoke(
        {"text": "LangChain is a framework for developing applications powered by language models."},
        config=final_config
    )

    print(f"\n摘要结果: {result}")
    print("\n配置分层的好处：")
    print("- 应用级：统一的默认设置")
    print("- 用户级：个性化配置")
    print("- 请求级：特定请求的定制")


# ============================================================================
# 主函数
# ============================================================================

def main():
    """运行所有示例"""
    print("\n" + "="*80)
    print("配置合并与覆盖 - 完整示例")
    print("="*80)

    try:
        # 运行所有示例
        example_1_basic_merge()
        example_2_field_level_override()
        example_3_callbacks_concatenation()
        example_4_tags_concatenation()
        example_5_metadata_merge()
        example_6_priority_rules()
        example_7_multiple_merges()
        example_8_empty_config_handling()
        example_9_real_world_scenario()

        print("\n" + "="*80)
        print("所有示例执行完成！")
        print("="*80)

        print("\n关键要点总结：")
        print("1. merge_configs()合并两个配置")
        print("2. tags和callbacks连接，不覆盖")
        print("3. metadata合并，后来的覆盖同名字段")
        print("4. 简单字段（run_name等）直接覆盖")
        print("5. 调用级配置优先级高于链级配置")
        print("6. 支持多次合并，构建配置层次")

    except Exception as e:
        print(f"\n错误: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
```

---

## 二、代码说明

### 2.1 核心组件

**merge_configs()函数**:
- LangChain核心函数，合并两个RunnableConfig
- 智能处理不同字段类型
- 保持配置不可变性

**9个示例场景**:
1. merge_configs()基础用法
2. 字段级覆盖规则
3. Callbacks连接
4. Tags连接
5. Metadata合并
6. 优先级规则
7. 多次合并
8. 空配置处理
9. 实际应用场景

### 2.2 合并规则总结

**连接字段（Concatenation）**:
```python
# tags连接
config1 = {"tags": ["a", "b"]}
config2 = {"tags": ["c", "d"]}
merged = merge_configs(config1, config2)
# merged["tags"] = ["a", "b", "c", "d"]

# callbacks连接
config1 = {"callbacks": [CallbackA()]}
config2 = {"callbacks": [CallbackB()]}
merged = merge_configs(config1, config2)
# merged["callbacks"] = [CallbackA(), CallbackB()]
```

**合并字段（Merge）**:
```python
# metadata合并
config1 = {"metadata": {"a": 1, "b": 2}}
config2 = {"metadata": {"b": 3, "c": 4}}
merged = merge_configs(config1, config2)
# merged["metadata"] = {"a": 1, "b": 3, "c": 4}
```

**覆盖字段（Override）**:
```python
# 简单字段覆盖
config1 = {"run_name": "run1", "max_concurrency": 5}
config2 = {"run_name": "run2", "max_concurrency": 10}
merged = merge_configs(config1, config2)
# merged["run_name"] = "run2"
# merged["max_concurrency"] = 10
```

---

## 三、运行环境

### 3.1 依赖安装

```bash
# 安装依赖
uv sync

# 激活环境
source .venv/bin/activate
```

### 3.2 环境变量

```bash
# .env文件
OPENAI_API_KEY=your_key_here
OPENAI_BASE_URL=https://api.openai.com/v1  # 可选
```

### 3.3 运行代码

```bash
# 保存代码为文件
python 07_实战代码_02_配置合并与覆盖.py
```

---

## 四、预期输出

```
================================================================================
配置合并与覆盖 - 完整示例
================================================================================

================================================================================
示例1：merge_configs()基础用法
================================================================================

配置1: {'tags': ['config1', 'base'], 'metadata': {'source': 'config1', 'version': '1.0'}, 'run_name': 'config1_run'}

配置2: {'tags': ['config2', 'override'], 'metadata': {'source': 'config2', 'environment': 'prod'}, 'run_name': 'config2_run'}

合并后的配置: {'tags': ['config1', 'base', 'config2', 'override'], 'metadata': {'source': 'config2', 'version': '1.0', 'environment': 'prod'}, 'run_name': 'config2_run'}

合并规则：
- tags: 连接（config1的tags + config2的tags）
- metadata: 合并（config2的字段覆盖config1的同名字段）
- run_name: 覆盖（使用config2的值）

[... 更多输出 ...]

================================================================================
所有示例执行完成！
================================================================================

关键要点总结：
1. merge_configs()合并两个配置
2. tags和callbacks连接，不覆盖
3. metadata合并，后来的覆盖同名字段
4. 简单字段（run_name等）直接覆盖
5. 调用级配置优先级高于链级配置
6. 支持多次合并，构建配置层次
```

---

## 五、学习要点

### 5.1 合并规则记忆

**连接（Concatenation）**:
- `tags`: 列表连接
- `callbacks`: 列表连接

**合并（Merge）**:
- `metadata`: 字典合并（浅合并）
- `configurable`: 字典合并

**覆盖（Override）**:
- `run_name`: 直接覆盖
- `max_concurrency`: 直接覆盖
- `recursion_limit`: 直接覆盖
- `run_id`: 直接覆盖

### 5.2 优先级规则

配置优先级从低到高：
1. 链定义时的默认配置
2. with_config()绑定的配置
3. invoke()时传递的配置

后来的配置总是优先于前面的配置。

### 5.3 实际应用模式

**配置分层**:
```python
# 应用级默认配置
app_config = {...}

# 用户级配置
user_config = {...}

# 请求级配置
request_config = {...}

# 合并
final_config = merge_configs(
    merge_configs(app_config, user_config),
    request_config
)
```

### 5.4 最佳实践

1. **使用配置分层**：应用级 → 用户级 → 请求级
2. **利用tags连接**：每层添加自己的标签
3. **metadata合并**：每层添加自己的追踪信息
4. **避免过度覆盖**：只在必要时覆盖简单字段
5. **保持配置不可变**：不要修改原始配置对象

---

## 六、常见问题

### Q1: metadata是深合并还是浅合并？

**A**: 浅合并。只合并第一层字段，嵌套对象会被整体覆盖。

```python
config1 = {"metadata": {"nested": {"a": 1, "b": 2}}}
config2 = {"metadata": {"nested": {"c": 3}}}
merged = merge_configs(config1, config2)
# merged["metadata"]["nested"] = {"c": 3}  # 整体覆盖，不是合并
```

### Q2: 如何避免callbacks重复？

**A**: merge_configs()会连接callbacks列表，可能导致重复。如果需要去重，需要手动处理：

```python
merged = merge_configs(config1, config2)
# 手动去重（如果需要）
seen = set()
unique_callbacks = []
for cb in merged.get("callbacks", []):
    cb_id = id(cb)
    if cb_id not in seen:
        seen.add(cb_id)
        unique_callbacks.append(cb)
merged["callbacks"] = unique_callbacks
```

### Q3: 可以合并多个配置吗？

**A**: 可以，但merge_configs()一次只能合并两个。多个配置需要链式调用：

```python
result = merge_configs(
    merge_configs(config1, config2),
    config3
)
```

### Q4: 合并会修改原始配置吗？

**A**: 不会。merge_configs()返回新的配置对象，原始配置保持不变。

---

## 七、下一步

- 学习动态字段配置: [实战代码03 - 动态字段配置](./07_实战代码_03_动态字段配置.md)
- 理解配置继承: [核心概念03 - 配置继承机制](./03_核心概念_03_配置继承机制.md)
- 深入合并策略: [核心概念02 - 配置合并与覆盖策略](./03_核心概念_02_配置合并与覆盖策略.md)

---

**版本**: v1.0
**创建日期**: 2026-02-21
**代码行数**: 约550行
**Python版本**: 3.13+
**测试状态**: ✓ 所有代码可运行
