# 化骨绵掌

> **10个知识卡片，融入你的编程直觉**

---

## 什么是化骨绵掌？

**化骨绵掌**：武侠小说中的一种内功心法，将武功融入骨髓，成为本能反应。

**本文目标**：
- 将 RunnableParallel 的核心知识浓缩为 10 个卡片
- 每个卡片独立完整，可单独记忆
- 反复阅读，直到成为编程直觉
- 遇到问题时，快速查阅相关卡片

**使用方法**：
1. **首次学习**：完整阅读所有卡片
2. **日常复习**：每天快速浏览 1-2 个卡片
3. **实战应用**：遇到问题时查阅相关卡片
4. **面试准备**：考前快速过一遍所有卡片

---

## 卡片1: 直觉理解

### 核心比喻

**RunnableParallel = 餐厅厨房**

```
订单: "套餐A"
├─ 汤厨师: 做汤 (10分钟)
├─ 主菜厨师: 做主菜 (15分钟)
└─ 甜点厨师: 做甜点 (8分钟)

总时间: max(10, 15, 8) = 15分钟
```

### 关键要素

- **多个厨师** = 多个 Runnable
- **相同订单** = 相同输入
- **同时工作** = 并行执行
- **汇总成一桌菜** = 字典输出

### 代码映射

```python
kitchen = {
    "soup": soup_chef,      # 汤厨师
    "main": main_chef,      # 主菜厨师
    "dessert": dessert_chef,  # 甜点厨师
}

meal = kitchen.invoke({"order": "套餐A"})
# {"soup": "番茄汤", "main": "牛排", "dessert": "提拉米苏"}
```

### 记忆口诀

**多人同时工作，相同任务分发，结果汇总上桌**

---

## 卡片2: 形式化定义

### 数学定义

```
RunnableParallel: (Input, {K₁: R₁, K₂: R₂, ..., Kₙ: Rₙ}) → {K₁: O₁, K₂: O₂, ..., Kₙ: Oₙ}

其中：
- Input: 输入数据
- Kᵢ: 键名（字符串）
- Rᵢ: Runnable 对象
- Oᵢ: Rᵢ(Input) 的输出

执行过程：
1. ∀i ∈ [1, n]: Oᵢ = Rᵢ(Input)  // 并行执行
2. return {K₁: O₁, K₂: O₂, ..., Kₙ: Oₙ}  // 映射为字典
```

### 类型签名

```python
class RunnableParallel(Runnable[Input, Dict[str, Output]]):
    steps: Dict[str, Runnable[Input, Output]]

    def invoke(self, input: Input) -> Dict[str, Output]:
        """并行执行所有步骤，返回字典"""
        pass
```

### 核心性质

1. **并发性**：所有 Runnable 同时执行
2. **独立性**：每个 Runnable 独立运行，不共享状态
3. **确定性**：相同输入总是产生相同输出（如果 Runnable 是确定的）
4. **可组合性**：输出可以作为下一步的输入

### 记忆口诀

**输入分发，并行执行，字典映射，可组合**

---

## 卡片3: 字典语法

### 最简洁的写法

```python
# 字典语法（推荐）
chain = {
    "key1": runnable1,
    "key2": runnable2,
}
```

### 为什么推荐？

1. **简洁**：3 行代码
2. **直观**：键值对一目了然
3. **符合习惯**：Python 原生语法
4. **自动转换**：自动变成 RunnableParallel

### 与管道结合

```python
# 并行 + 串行
chain = {
    "task1": runnable1,
    "task2": runnable2,
} | next_step | another_step
```

### 嵌套使用

```python
# 嵌套并行
chain = {
    "group1": {
        "task1a": runnable1a,
        "task1b": runnable1b,
    },
    "group2": {
        "task2a": runnable2a,
        "task2b": runnable2b,
    },
}
```

### 记忆口诀

**字典最简洁，管道可组合，嵌套能扩展**

---

## 卡片4: 显式构造

### 何时使用显式构造？

```python
from langchain_core.runnables import RunnableParallel

# 显式构造
chain = RunnableParallel(
    task1=runnable1,
    task2=runnable2,
)
```

### 使用场景

1. **语义更清晰**：明确表达"这是并行执行"
2. **代码审查**：更容易被其他开发者理解
3. **类型提示**：IDE 可以提供更好的类型推断
4. **动态构造**：需要动态添加步骤时

### 动态构造示例

```python
# 动态添加步骤
steps = {}
for i in range(n):
    steps[f"task{i}"] = create_runnable(i)

chain = RunnableParallel(**steps)
```

### 等价性

```python
# 完全等价
chain1 = {"key": runnable}
chain2 = RunnableParallel(key=runnable)

type(chain1) == type(chain2)  # True
```

### 记忆口诀

**字典简洁日常用，显式清晰审查用，动态构造必须用**

---

## 卡片5: 输入分发

### 输入如何分发？

```python
chain = {
    "task1": runnable1,
    "task2": runnable2,
    "task3": runnable3,
}

result = chain.invoke({"data": "test"})

# 内部执行：
# runnable1.invoke({"data": "test"})  // 相同输入
# runnable2.invoke({"data": "test"})  // 相同输入
# runnable3.invoke({"data": "test"})  // 相同输入
```

### 输入是复制还是共享？

**答案：复制**

```python
# 每个分支接收输入的副本
# 修改不会影响其他分支

def modify_input(x):
    x["data"] = "modified"
    return x["data"]

chain = {
    "task1": RunnableLambda(modify_input),
    "task2": RunnableLambda(lambda x: x["data"]),
}

result = chain.invoke({"data": "original"})
# {"task1": "modified", "task2": "original"}
# task2 看到的是原始输入，不受 task1 影响
```

### 输入类型要求

```python
# ✅ 所有 Runnable 必须接受相同类型的输入
chain = {
    "task1": runnable1,  # 接受 Dict[str, str]
    "task2": runnable2,  # 接受 Dict[str, str]
}

# ❌ 如果输入类型不同，需要转换
chain = {
    "task1": itemgetter("field1") | runnable1,  # 提取 field1
    "task2": itemgetter("field2") | runnable2,  # 提取 field2
}
```

### 记忆口诀

**相同输入，自动复制，独立执行，互不影响**

---

## 卡片6: 输出合并

### 输出格式

```python
chain = {
    "summary": summary_task,
    "keywords": keywords_task,
    "sentiment": sentiment_task,
}

result = chain.invoke({"text": "..."})

# 输出是字典
print(type(result))  # <class 'dict'>
print(result.keys())  # dict_keys(['summary', 'keywords', 'sentiment'])
```

### 访问输出

```python
# 通过键名访问
summary = result["summary"]
keywords = result["keywords"]
sentiment = result["sentiment"]

# 或者解构
summary, keywords, sentiment = result["summary"], result["keywords"], result["sentiment"]
```

### 输出传递给下一步

```python
# 下一步接收字典输入
chain = {
    "task1": runnable1,
    "task2": runnable2,
} | RunnableLambda(lambda x: f"{x['task1']} + {x['task2']}")

# 或者使用 Prompt 模板
chain = {
    "context": retriever,
    "question": RunnablePassthrough(),
} | ChatPromptTemplate.from_template(
    "上下文: {context}\n问题: {question}"
) | model
```

### 输出类型

```python
# 输出类型是 Dict[str, Any]
# 键名是你定义的字符串
# 值的类型取决于对应 Runnable 的输出类型

chain: RunnableParallel[Input, Dict[str, Output]]
```

### 记忆口诀

**字典输出，键名访问，传递下游，类型明确**

---

## 卡片7: 错误处理

### 默认行为

```python
# 一个失败，全部失败
chain = {
    "task1": task1,  # 成功
    "task2": task2,  # 失败 ❌
    "task3": task3,  # 成功
}

try:
    result = chain.invoke(input)
except Exception as e:
    # task2 失败导致整个链失败
    # task1 和 task3 的结果丢失
    print(f"错误: {e}")
```

### 部分失败容错

```python
from langchain_core.runnables import RunnableLambda

def safe_runnable(func, name):
    """包装函数，捕获错误"""
    def wrapper(x):
        try:
            return {"success": True, "result": func(x)}
        except Exception as e:
            return {"success": False, "error": str(e)}
    return RunnableLambda(wrapper)

# 使用安全包装
chain = {
    "task1": safe_runnable(task1, "任务1"),
    "task2": safe_runnable(task2, "任务2"),
    "task3": safe_runnable(task3, "任务3"),
}

result = chain.invoke(input)
# 所有任务都有结果，失败的任务返回错误信息
```

### 降级策略

```python
def with_fallback(primary, fallback):
    """主任务失败时使用降级方案"""
    def wrapper(x):
        try:
            return primary(x)
        except Exception:
            return fallback(x)
    return RunnableLambda(wrapper)

chain = {
    "task": with_fallback(
        primary=expensive_api,
        fallback=lambda x: "默认值"
    ),
}
```

### 记忆口诀

**默认快速失败，包装部分容错，降级保证可用**

---

## 卡片8: 性能优化

### 优化策略

#### 1. 控制并发数量

```python
# ❌ 错误：无限制并发
chain = {f"task{i}": task for i in range(1000)}

# ✅ 正确：分批并行
async def batch_parallel(tasks, batch_size=10):
    results = {}
    for i in range(0, len(tasks), batch_size):
        batch = dict(list(tasks.items())[i:i+batch_size])
        batch_results = await batch.ainvoke(input)
        results.update(batch_results)
    return results
```

#### 2. 使用缓存

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def cached_retriever(query: str):
    """带缓存的检索器"""
    return expensive_retrieval(query)

chain = {
    "context": RunnableLambda(cached_retriever),
    "question": RunnablePassthrough(),
}
```

#### 3. 批处理优化

```python
# 批量调用 API
chain = {
    "results": RunnableLambda(lambda x: model.batch([
        {"prompt": f"任务{i}: {x['input']}"} for i in range(10)
    ]))
}
```

#### 4. 只并行大任务

```python
# ✅ 好：并行大任务
chain = {
    "api1": expensive_api_call,  # 2秒
    "api2": expensive_api_call,  # 2秒
}

# ❌ 不好：并行微小任务
chain = {
    "add": RunnableLambda(lambda x: x + 1),  # 0.001秒
    "mul": RunnableLambda(lambda x: x * 2),  # 0.001秒
}
```

### 记忆口诀

**控制并发，使用缓存，批量处理，只并行大任务**

---

## 卡片9: RAG 应用

### 基础 RAG 模式

```python
from langchain_core.runnables import RunnablePassthrough

# 最常见的 RAG 模式
rag_chain = (
    {
        "context": retriever,
        "question": RunnablePassthrough(),
    }
    | prompt
    | model
)
```

### 多源检索

```python
# 并行检索多个数据源
rag_chain = (
    {
        "vector_docs": vector_retriever,
        "keyword_docs": keyword_retriever,
        "graph_docs": graph_retriever,
        "question": RunnablePassthrough(),
    }
    | RunnableLambda(lambda x: {
        "context": x["vector_docs"] + x["keyword_docs"] + x["graph_docs"],
        "question": x["question"],
    })
    | prompt
    | model
)
```

### 上下文保持

```python
# 保留所有中间结果
rag_chain = (
    RunnablePassthrough.assign(
        context=retriever
    )
    | RunnablePassthrough.assign(
        answer=prompt | model
    )
    | RunnablePassthrough.assign(
        summary=summary_chain,
        keywords=keywords_chain,
    )
)
```

### 对话式 RAG

```python
# 带历史记录的 RAG
rag_chain = (
    {
        "context": retriever,
        "question": RunnablePassthrough(),
        "history": lambda x: x.get("history", []),
    }
    | ChatPromptTemplate.from_template(
        "历史: {history}\n上下文: {context}\n问题: {question}"
    )
    | model
)
```

### 记忆口诀

**检索保持并行，多源合并串行，上下文逐步扩展**

---

## 卡片10: 最佳实践

### 何时使用 RunnableParallel？

#### ✅ 适合并行

1. **独立任务**
   ```python
   {
       "summary": summary_task,
       "keywords": keywords_task,
       "sentiment": sentiment_task,
   }
   ```

2. **I/O 密集型**
   ```python
   {
       "api1": api_call_1,
       "api2": api_call_2,
       "db": database_query,
   }
   ```

3. **多源检索**
   ```python
   {
       "vector": vector_retriever,
       "keyword": keyword_retriever,
   }
   ```

4. **多模型对比**
   ```python
   {
       "gpt4": gpt4_chain,
       "claude": claude_chain,
   }
   ```

#### ❌ 不适合并行

1. **有依赖关系**
   ```python
   # ❌ 错误
   {"retrieve": retriever, "generate": generator}

   # ✅ 正确
   retriever | generator
   ```

2. **微小任务**
   ```python
   # ❌ 错误：并行开销大于收益
   {"add": lambda x: x+1, "mul": lambda x: x*2}

   # ✅ 正确：串行更快
   (lambda x: x+1) | (lambda x: x*2)
   ```

3. **共享资源**
   ```python
   # ❌ 错误：可能冲突
   {"write1": write_file, "write2": write_file}

   # ✅ 正确：串行访问
   write_file | write_file
   ```

### 命名规范

```python
# ✅ 好的键名
{
    "user_profile": get_profile,
    "recent_posts": get_posts,
    "recommendations": get_recommendations,
}

# ❌ 不好的键名
{
    "data1": get_profile,
    "x": get_posts,
    "result": get_recommendations,
}
```

### 错误处理

```python
# 关键任务：快速失败
{
    "payment": payment_task,  # 失败必须停止
}

# 非关键任务：部分容错
{
    "analytics": safe_runnable(analytics_task),
    "logging": safe_runnable(logging_task),
}
```

### 性能测试

```python
# 总是测试后决策
import time

def benchmark(chain, input):
    start = time.time()
    result = chain.invoke(input)
    return time.time() - start

serial_time = benchmark(serial_chain, input)
parallel_time = benchmark(parallel_chain, input)

if parallel_time < serial_time:
    use_parallel_chain()
else:
    use_serial_chain()
```

### 记忆口诀

**独立I/O适合并行，依赖微小必须串行，命名清晰错误处理，性能测试决策依据**

---

## 快速复习清单

### 10个核心要点

1. **直觉理解** - 餐厅厨房，多人同时工作
2. **形式化定义** - 输入分发，并行执行，字典映射
3. **字典语法** - 最简洁的写法，推荐使用
4. **显式构造** - 语义清晰，动态构造
5. **输入分发** - 相同输入，自动复制，独立执行
6. **输出合并** - 字典输出，键名访问，传递下游
7. **错误处理** - 默认快速失败，包装部分容错
8. **性能优化** - 控制并发，使用缓存，批量处理
9. **RAG 应用** - 检索保持并行，多源合并串行
10. **最佳实践** - 独立I/O适合并行，依赖微小必须串行

---

## 记忆技巧

### 口诀记忆

**并行字典最简洁，输入分发输出合并**
**错误处理要包装，性能优化控并发**
**RAG检索多源并，依赖任务必须串**

### 场景记忆

- **看到多个独立任务** → 想到 RunnableParallel
- **看到 RAG 检索** → 想到并行检索 + 保持问题
- **看到多模型对比** → 想到并行调用
- **看到依赖关系** → 想到串行执行

### 对比记忆

| 场景 | 串行 | 并行 |
|------|------|------|
| 独立任务 | ❌ 慢 | ✅ 快 |
| 依赖任务 | ✅ 必须 | ❌ 不行 |
| I/O 密集 | ❌ 浪费 | ✅ 高效 |
| CPU 密集 | ✅ 可以 | ⚠️ 提升有限 |
| 微小任务 | ✅ 更快 | ❌ 开销大 |

---

## 实战检验

### 测试你的理解

完成以下任务，检验你是否真正掌握：

1. **基础应用**
   - [ ] 使用字典语法创建一个并行链
   - [ ] 使用 RunnablePassthrough 保持上下文
   - [ ] 实现一个简单的 RAG 检索链

2. **进阶应用**
   - [ ] 实现多源检索并合并结果
   - [ ] 添加错误处理和降级策略
   - [ ] 优化性能（缓存、批处理）

3. **生产应用**
   - [ ] 设计一个完整的 RAG 系统
   - [ ] 实现监控和日志记录
   - [ ] 编写单元测试

---

## 下一步学习

掌握化骨绵掌后，你可以：

1. **实战代码** → 看完整的代码示例
2. **核心概念** → 深入技术细节
3. **面试准备** → 学习常见面试问题
4. **生产实践** → 构建真实的 AI 应用

---

## 参考资源

**官方文档**：
- [RunnableParallel API Reference](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.base.RunnableParallel.html)

**2025-2026 最佳实践**：
- [Building Production-Ready AI Pipelines](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557)
- [LangChain Best Practices](https://www.swarnendu.de/blog/langchain-best-practices)

---

**版本**: v1.0
**最后更新**: 2026-02-19
**适用**: LangChain 0.3+, Python 3.13+
