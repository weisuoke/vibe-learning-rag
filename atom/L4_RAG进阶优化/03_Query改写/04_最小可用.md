# 最小可用

掌握以下 20% 的核心知识，就能解决 80% 的 Query改写问题。

---

## 4.1 最简单的 Query改写：Multi-Query

**为什么从 Multi-Query 开始？**
- 实现最简单，效果立竿见影
- 不需要复杂的假设生成
- 适用范围最广

```python
from openai import OpenAI

client = OpenAI()

def simple_multi_query(query: str) -> list[str]:
    """
    最简单的 Multi-Query 实现
    一个函数搞定查询改写
    """
    prompt = f"""将以下查询改写成 3 个不同的版本，保持相同意图：

查询：{query}

直接输出 3 个改写，每行一个："""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.7
    )

    rewritten = response.choices[0].message.content.strip().split('\n')
    return [query] + [q.strip() for q in rewritten if q.strip()][:3]

# 使用
queries = simple_multi_query("Python 性能优化")
# ['Python 性能优化', '如何提升 Python 代码运行速度', 'Python 程序优化技巧', ...]
```

---

## 4.2 最实用的 Query改写：HyDE

**HyDE 的最小实现：**

```python
def simple_hyde(query: str) -> str:
    """
    最简单的 HyDE 实现
    让 LLM 先回答，用答案去检索
    """
    prompt = f"""请简要回答以下问题（100字以内）：

{query}"""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.7,
        max_tokens=150
    )

    return response.choices[0].message.content

# 使用
hyde_doc = simple_hyde("Python 怎么实现异步编程？")
# 用 hyde_doc 的 embedding 去检索，而不是原始问题
```

---

## 4.3 判断是否需要改写

**不是所有查询都需要改写！**

```python
def should_rewrite(query: str) -> bool:
    """
    判断是否需要改写查询

    规则：
    1. 精确查询（错误码、版本号、命令）→ 不改写
    2. 口语化/模糊查询 → 改写
    3. 复杂复合问题 → 分解
    """
    # 精确查询特征
    exact_patterns = [
        r'error\s*:?\s*\w+',      # 错误码
        r'\d+\.\d+(\.\d+)?',      # 版本号
        r'pip\s+install',         # 命令
        r'import\s+\w+',          # 导入语句
    ]

    import re
    for pattern in exact_patterns:
        if re.search(pattern, query, re.IGNORECASE):
            return False  # 精确查询，不改写

    # 口语化特征
    casual_words = ['咋', '怎么', '啥', '为啥', '咋办']
    for word in casual_words:
        if word in query:
            return True  # 口语化，需要改写

    # 默认：短查询可能需要改写
    return len(query) < 20

# 使用示例
print(should_rewrite("Python 3.12 新特性"))  # False
print(should_rewrite("代码跑不动咋办"))       # True
```

---

## 4.4 完整的改写流程

```python
def query_rewrite_pipeline(
    query: str,
    strategy: str = "auto"
) -> list[str]:
    """
    Query改写完整流程

    参数：
    - query: 原始查询
    - strategy: "auto" | "hyde" | "multi" | "none"
    """
    # 1. 判断是否需要改写
    if strategy == "none" or not should_rewrite(query):
        return [query]

    # 2. 选择改写策略
    if strategy == "hyde":
        hyde_doc = simple_hyde(query)
        return [hyde_doc]

    elif strategy == "multi":
        return simple_multi_query(query)

    else:  # auto
        # 自动选择：默认使用 Multi-Query
        return simple_multi_query(query)

# 使用
queries = query_rewrite_pipeline("Python 性能优化", strategy="auto")
```

---

## 4.5 与检索系统集成

```python
def search_with_rewrite(
    query: str,
    vector_store,
    top_k: int = 5
) -> list:
    """
    带 Query改写的检索
    """
    # 1. 改写查询
    queries = query_rewrite_pipeline(query)

    # 2. 多查询检索
    all_results = []
    seen_ids = set()

    for q in queries:
        results = vector_store.search(q, top_k=top_k)
        for doc in results:
            if doc['id'] not in seen_ids:
                all_results.append(doc)
                seen_ids.add(doc['id'])

    # 3. 返回去重后的结果
    return all_results[:top_k]
```

---

## 这些知识足以：

- ✅ 实现基本的 Query改写功能
- ✅ 判断何时需要改写、何时不需要
- ✅ 选择合适的改写策略
- ✅ 与现有检索系统集成
- ✅ 为后续学习高级技术打下基础

---

## 快速参考卡

| 场景 | 推荐策略 | 代码 |
|------|---------|------|
| 模糊查询 | Multi-Query | `simple_multi_query(query)` |
| 开放性问题 | HyDE | `simple_hyde(query)` |
| 精确查询 | 不改写 | `[query]` |
| 不确定 | Auto | `query_rewrite_pipeline(query)` |

---

**下一步：** [05_双重类比](./05_双重类比.md) - 用熟悉的概念理解 Query改写
