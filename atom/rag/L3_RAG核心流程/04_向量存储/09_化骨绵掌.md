# 化骨绵掌

10个2分钟知识卡片，快速掌握向量存储核心知识。

---

## 卡片1：什么是向量存储？

**一句话：** 向量存储是专门存储和检索高维向量的数据库系统。

**核心功能：**
```
1. 持久化：向量保存到磁盘，重启不丢失
2. 索引：加速搜索，避免暴力遍历
3. 相似度搜索：找到最相似的 K 个向量
```

**类比：** 普通数据库像字典（精确查找），向量存储像"找相似的书"（模糊匹配）。

**应用：** RAG 系统的核心组件，存储文档的 Embedding 向量。

---

## 卡片2：为什么需要向量存储？

**一句话：** 因为暴力搜索太慢，Embedding 计算太贵。

**三个原因：**

| 问题 | 解决方案 |
|------|----------|
| 100万向量暴力搜索需要1秒 | 索引加速到5毫秒 |
| 每次查询都重算 Embedding | 持久化存储，只算一次 |
| 需要按条件过滤 | 元数据过滤 |

**应用：** 数据量超过1万条时，向量存储是必需品。

---

## 卡片3：Flat 索引（暴力搜索）

**一句话：** 遍历所有向量，计算距离，返回最近的 K 个。

**代码：**
```python
def flat_search(query, vectors, k):
    distances = [cosine_distance(query, v) for v in vectors]
    return sorted(range(len(distances)), key=lambda i: distances[i])[:k]
```

**特点：**
- ✅ 100% 精确
- ❌ O(N) 复杂度，数据量大时很慢

**应用：** 数据量 < 1万时使用，或作为精度基准。

---

## 卡片4：IVF 索引（聚类索引）

**一句话：** 把向量空间分成多个区域，查询时只搜索最近的几个区域。

**原理：**
```
1. 训练：把 N 个向量聚类成 K 个簇
2. 查询：找到最近的 M 个簇，只在这些簇中搜索
```

**参数：**
- `nlist`：聚类数量（越大越精确，越慢）
- `nprobe`：搜索的聚类数（越大越精确，越慢）

**应用：** 超大规模数据（>1000万），内存有限时使用。

---

## 卡片5：HNSW 索引（图索引）

**一句话：** 构建多层图结构，从粗到细逐层搜索。

**原理：**
```
Layer 2 (稀疏):  A ─────── B
Layer 1 (中等):  A ── C ── B
Layer 0 (稠密):  A─D─C─E─B

查询：从顶层开始，逐层下降，找到最近邻
```

**参数：**
- `M`：每个节点的连接数
- `efConstruction`：构建时的搜索范围

**应用：** 最常用的索引，ChromaDB 默认使用。

---

## 卡片6：相似度度量

**一句话：** 决定"两个向量有多相似"的计算方式。

**三种主流度量：**

| 度量 | 公式 | 特点 | RAG 推荐 |
|------|------|------|----------|
| 余弦 | cos(θ) | 只看方向 | ✅ 首选 |
| L2 | √Σ(a-b)² | 看距离 | 可用 |
| 内积 | Σ(a×b) | 看投影 | 归一化后可用 |

**应用：** RAG 场景首选余弦相似度，对文本语义匹配效果最好。

---

## 卡片7：元数据过滤

**一句话：** 在向量搜索的同时，按条件筛选结果。

**代码：**
```python
# ChromaDB
results = collection.query(
    query_texts=["查询"],
    where={"year": {"$eq": 2024}, "category": {"$eq": "tech"}}
)

# Milvus
results = client.search(
    data=[query_vector],
    filter='year == 2024 and category == "tech"'
)
```

**应用：** 多租户隔离、时效性过滤、权限控制。

---

## 卡片8：ChromaDB 快速上手

**一句话：** 最简单的向量数据库，零配置即可使用。

**代码：**
```python
import chromadb

client = chromadb.Client()
collection = client.create_collection("docs")

# 添加（自动生成 Embedding）
collection.add(ids=["1"], documents=["文本内容"])

# 查询
results = collection.query(query_texts=["查询"], n_results=5)
```

**应用：** 学习、原型开发、小规模生产（<100万）。

---

## 卡片9：Milvus 快速上手

**一句话：** 生产级向量数据库，支持分布式和大规模数据。

**代码：**
```python
from pymilvus import MilvusClient

client = MilvusClient("./milvus.db")
client.create_collection("docs", dimension=384)

# 添加（需要自己生成 Embedding）
client.insert("docs", [{"id": 1, "vector": [...], "text": "内容"}])

# 查询
results = client.search("docs", data=[query_vec], limit=5)
```

**应用：** 大规模生产环境（>100万），需要高可用和分布式。

---

## 卡片10：向量存储选型决策

**一句话：** 根据数据规模、部署方式、团队能力选择。

**决策树：**
```
数据量 < 10万？
  ├─ 是 → ChromaDB（简单可靠）
  └─ 否 → 数据量 < 1000万？
           ├─ 是 → Milvus 单机（功能全面）
           └─ 否 → Milvus 分布式（大规模）

需要托管服务？
  ├─ 是 → Pinecone / Milvus Cloud
  └─ 否 → 自建 Milvus / Qdrant
```

**应用：** 开发用 ChromaDB，生产用 Milvus，两者 API 相似易迁移。

---

## 知识卡片总结

| 卡片 | 核心知识 |
|------|----------|
| 1 | 向量存储 = 持久化 + 索引 + 相似搜索 |
| 2 | 解决暴力搜索慢、重复计算贵的问题 |
| 3 | Flat：精确但慢，小数据量用 |
| 4 | IVF：聚类加速，超大规模用 |
| 5 | HNSW：图加速，最常用 |
| 6 | 余弦相似度是 RAG 首选 |
| 7 | 元数据过滤实现精准检索 |
| 8 | ChromaDB：零配置，适合入门 |
| 9 | Milvus：生产级，适合大规模 |
| 10 | 选型看数据规模和部署方式 |

---

**下一步：** [10_一句话总结](./10_一句话总结.md) - 最终总结
