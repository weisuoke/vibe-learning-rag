# 核心概念 1：事件监听

## 一句话定义

**事件监听是通过 `pi.on()` 方法注册回调函数，在特定事件发生时自动执行自定义逻辑的机制。**

---

## 详细解释

### 什么是事件监听？

事件监听是事件驱动架构的核心机制，它允许你在不修改核心代码的情况下，在特定时刻插入自定义逻辑。

**核心组成：**
1. **事件发布者**：pi-mono 核心代码（发布事件）
2. **事件总线**：EventEmitter（传递事件）
3. **事件监听器**：你的 Extension（接收事件）

**工作流程：**
```
核心代码 → emit('event_name', data) → EventEmitter → on('event_name', handler) → 你的代码
```

### pi.on() 方法详解

`pi.on()` 是 pi-mono 提供的事件监听方法，基于 Node.js 的 EventEmitter 实现。

**方法签名：**
```typescript
interface ExtensionAPI {
  on(event: string, handler: (...args: any[]) => void): void;
}
```

**基础用法：**
```typescript
// 监听 session 启动事件
pi.on('session_start', (session) => {
  console.log('Session started:', session.id);
});
```

**特点：**
- ✅ 类型安全（TypeScript 接口定义）
- ✅ 支持多个监听器（同一事件可以有多个处理器）
- ✅ 按注册顺序执行
- ✅ 自动错误处理（错误不会中断其他监听器）

### 事件处理器注册与注销

#### 注册事件处理器

**基础注册：**
```typescript
pi.on('tool_call', (tool, args) => {
  console.log('Tool called:', tool.name);
});
```

**多个处理器：**
```typescript
// 处理器 1：日志
pi.on('tool_call', (tool, args) => {
  console.log('Tool called:', tool.name);
});

// 处理器 2：监控
pi.on('tool_call', (tool, args) => {
  metrics.track('tool_call', { tool: tool.name });
});

// 处理器 3：详细日志
pi.on('tool_call', (tool, args) => {
  logger.info('Tool args:', JSON.stringify(args));
});
```

**执行顺序：**
- 按注册顺序执行（先注册先执行）
- 同步执行（一个接一个）
- 错误不会中断后续处理器

#### 注销事件处理器

**使用 off() 方法：**
```typescript
// 定义处理器函数
const handler = (session) => {
  console.log('Session started:', session.id);
};

// 注册
pi.on('session_start', handler);

// 注销
pi.off('session_start', handler);
```

**注意事项：**
- 必须使用同一个函数引用
- 匿名函数无法注销（除非保存引用）
- 注销后不再接收事件

**一次性监听器：**
```typescript
// 使用 once() 方法（只执行一次）
pi.once('session_start', (session) => {
  console.log('First session started:', session.id);
});
```

### 事件参数与返回值

#### 事件参数

不同事件有不同的参数，由 ExtensionAPI 接口定义：

**Session Events：**
```typescript
// session_start
pi.on('session_start', (session: Session) => {
  // session.id, session.messages, session.settings
});

// session_switch
pi.on('session_switch', (fromSession: Session, toSession: Session) => {
  // 从一个 session 切换到另一个
});
```

**Agent Events：**
```typescript
// before_agent_start
pi.on('before_agent_start', (messages: Message[]) => {
  // 可以修改 messages 数组
  messages.push({ role: 'system', content: 'Custom instruction' });
});

// agent_start
pi.on('agent_start', () => {
  // Agent 开始运行
});

// agent_end
pi.on('agent_end', (result: AgentResult) => {
  // Agent 运行结束
});
```

**Tool Events：**
```typescript
// tool_call
pi.on('tool_call', (tool: Tool, args: any) => {
  // tool.name, tool.description, args
});

// tool_result
pi.on('tool_result', (tool: Tool, result: any) => {
  // 工具执行结果
});
```

**Message Events：**
```typescript
// message_start
pi.on('message_start', (message: Message) => {
  // 消息开始处理
});

// message_update
pi.on('message_update', (message: Message, delta: string) => {
  // 流式消息更新
});

// message_end
pi.on('message_end', (message: Message) => {
  // 消息处理完成
});
```

#### 返回值

**大多数事件处理器不需要返回值：**
```typescript
pi.on('session_start', (session) => {
  console.log('Session started');
  // 不需要返回值
});
```

**某些事件支持修改参数（通过引用传递）：**
```typescript
// before_agent_start 可以修改 messages 数组
pi.on('before_agent_start', (messages) => {
  messages.push({ role: 'system', content: 'Custom instruction' });
  // 不需要返回值，直接修改 messages
});
```

**Spawn Hooks 需要返回修改后的参数：**
```typescript
pi.registerSpawnHook((command, cwd, env) => {
  env.MY_VAR = 'value';
  return { command, cwd, env }; // 必须返回
});
```

### 错误处理机制

#### 自动错误处理

pi-mono 的事件系统会自动捕获处理器中的错误，不会中断其他监听器：

```typescript
// 处理器 1：会抛出错误
pi.on('tool_call', (tool, args) => {
  throw new Error('Something went wrong');
});

// 处理器 2：仍然会执行
pi.on('tool_call', (tool, args) => {
  console.log('This will still run');
});
```

**错误日志：**
- 错误会被记录到日志
- 不会中断 Agent 运行
- 不会影响其他监听器

#### 手动错误处理

**推荐做法：在处理器中捕获错误**
```typescript
pi.on('tool_call', async (tool, args) => {
  try {
    // 可能抛出错误的代码
    await someAsyncOperation();
  } catch (error) {
    console.error('Error in tool_call handler:', error);
    // 记录错误或发送通知
  }
});
```

**异步处理器：**
```typescript
// 支持异步处理器
pi.on('tool_call', async (tool, args) => {
  await logToDatabase(tool.name, args);
});
```

**注意事项：**
- 异步处理器不会阻塞主流程
- 错误需要在处理器内部捕获
- 避免在处理器中执行耗时操作

### 在 AI Agent 开发中的应用

#### 应用场景 1：监控和日志

```typescript
// 监控 Agent 运行时间
pi.on('agent_start', () => {
  const startTime = Date.now();

  pi.once('agent_end', () => {
    const duration = Date.now() - startTime;
    console.log(`Agent runtime: ${duration}ms`);
  });
});

// 记录所有工具调用
pi.on('tool_call', (tool, args) => {
  logger.info('Tool called', {
    tool: tool.name,
    args: JSON.stringify(args),
    timestamp: new Date().toISOString()
  });
});
```

#### 应用场景 2：状态管理

```typescript
// 跟踪 session 状态
const sessionState = new Map();

pi.on('session_start', (session) => {
  sessionState.set(session.id, {
    startTime: Date.now(),
    toolCalls: 0
  });
});

pi.on('tool_call', (tool, args) => {
  const currentSession = getCurrentSession();
  const state = sessionState.get(currentSession.id);
  if (state) {
    state.toolCalls++;
  }
});

pi.on('session_shutdown', (session) => {
  const state = sessionState.get(session.id);
  console.log('Session stats:', state);
  sessionState.delete(session.id);
});
```

#### 应用场景 3：自定义行为

```typescript
// 在 Agent 启动前注入项目上下文
pi.on('before_agent_start', (messages) => {
  const projectContext = loadProjectContext();
  messages.push({
    role: 'system',
    content: `Project context: ${projectContext}`
  });
});

// 拦截特定工具调用
pi.on('tool_call', (tool, args) => {
  if (tool.name === 'bash' && args.command.includes('rm -rf')) {
    console.warn('Dangerous command detected:', args.command);
    // 可以发送通知或记录日志
  }
});
```

#### 应用场景 4：性能优化

```typescript
// 缓存工具调用结果
const toolCache = new Map();

pi.on('tool_call', (tool, args) => {
  const cacheKey = `${tool.name}:${JSON.stringify(args)}`;
  if (toolCache.has(cacheKey)) {
    console.log('Cache hit for:', tool.name);
  }
});

pi.on('tool_result', (tool, result) => {
  const cacheKey = `${tool.name}:${JSON.stringify(result.args)}`;
  toolCache.set(cacheKey, result);
});
```

---

## 与 2025-2026 最新技术趋势的联系

### typescript-event-emitter (2025)

根据 2025 年更新的 `typescript-event-emitter` 库 [1]，现代事件系统支持 before/after 生命周期钩子模式：

**核心特性：**
- 支持 `before:event` 和 `after:event` 钩子
- 类型安全的事件定义
- 异步事件处理

**在 pi-mono 中的体现：**
```typescript
// pi-mono 的 before_agent_start 就是 before 钩子
pi.on('before_agent_start', (messages) => {
  // 在 Agent 启动前执行
});

// agent_start 是主事件
pi.on('agent_start', () => {
  // Agent 启动时执行
});

// agent_end 是 after 钩子
pi.on('agent_end', (result) => {
  // Agent 结束后执行
});
```

### hookified (2025)

根据 `hookified` 库 [2]，EventEmitter 可以结合异步中间件钩子实现更强大的功能：

**核心特性：**
- 异步中间件链
- 钩子可以修改数据流
- 支持错误处理和重试

**在 pi-mono 中的体现：**
```typescript
// before_agent_start 可以修改消息流
pi.on('before_agent_start', async (messages) => {
  // 异步加载上下文
  const context = await loadContextFromDatabase();
  messages.push({
    role: 'system',
    content: context
  });
});
```

### EventEmitter2 (2025-2026)

根据 `EventEmitter2` 库 [3]，高级事件模式包括：

**核心特性：**
- 命名空间和通配符
- 事件 TTL（生存时间）
- 最大监听器限制

**在 pi-mono 中的应用：**
```typescript
// 使用命名空间组织事件
pi.on('session:start', handler);
pi.on('session:end', handler);

// 使用通配符监听所有 session 事件
pi.on('session:*', handler);
```

---

## 代码示例

### 示例 1：基础事件监听

```typescript
import { ExtensionAPI } from '@mariozechner/pi-agent-core';

export default function myExtension(pi: ExtensionAPI) {
  // 监听 session 启动
  pi.on('session_start', (session) => {
    console.log('=== Session Started ===');
    console.log('Session ID:', session.id);
    console.log('Messages:', session.messages.length);
  });

  // 监听工具调用
  pi.on('tool_call', (tool, args) => {
    console.log('=== Tool Called ===');
    console.log('Tool:', tool.name);
    console.log('Args:', JSON.stringify(args, null, 2));
  });

  // 监听 Agent 结束
  pi.on('agent_end', (result) => {
    console.log('=== Agent Ended ===');
    console.log('Result:', result);
  });
}
```

### 示例 2：多个监听器

```typescript
export default function loggingExtension(pi: ExtensionAPI) {
  // 监听器 1：简单日志
  pi.on('tool_call', (tool, args) => {
    console.log(`[LOG] Tool: ${tool.name}`);
  });

  // 监听器 2：详细日志
  pi.on('tool_call', (tool, args) => {
    console.log(`[DETAIL] Tool: ${tool.name}, Args: ${JSON.stringify(args)}`);
  });

  // 监听器 3：监控
  pi.on('tool_call', (tool, args) => {
    // 发送到监控系统
    sendToMonitoring({
      event: 'tool_call',
      tool: tool.name,
      timestamp: Date.now()
    });
  });
}
```

### 示例 3：注销监听器

```typescript
export default function conditionalExtension(pi: ExtensionAPI) {
  let callCount = 0;

  // 定义处理器函数
  const handler = (tool, args) => {
    callCount++;
    console.log(`Tool call #${callCount}: ${tool.name}`);

    // 达到 10 次后注销
    if (callCount >= 10) {
      console.log('Reached 10 calls, unregistering handler');
      pi.off('tool_call', handler);
    }
  };

  // 注册处理器
  pi.on('tool_call', handler);
}
```

### 示例 4：一次性监听器

```typescript
export default function oneTimeExtension(pi: ExtensionAPI) {
  // 只在第一次 session 启动时执行
  pi.once('session_start', (session) => {
    console.log('First session started:', session.id);
    // 执行一次性初始化
    initializeExtension();
  });

  // 每次都执行
  pi.on('session_start', (session) => {
    console.log('Session started:', session.id);
  });
}
```

### 示例 5：异步处理器

```typescript
export default function asyncExtension(pi: ExtensionAPI) {
  // 异步处理器
  pi.on('tool_call', async (tool, args) => {
    try {
      // 异步操作：记录到数据库
      await logToDatabase({
        tool: tool.name,
        args: args,
        timestamp: new Date()
      });
    } catch (error) {
      console.error('Failed to log to database:', error);
    }
  });

  // 异步处理器：发送通知
  pi.on('agent_end', async (result) => {
    try {
      await sendNotification({
        message: 'Agent completed',
        result: result
      });
    } catch (error) {
      console.error('Failed to send notification:', error);
    }
  });
}
```

### 示例 6：错误处理

```typescript
export default function errorHandlingExtension(pi: ExtensionAPI) {
  // 处理器 1：会抛出错误
  pi.on('tool_call', (tool, args) => {
    if (tool.name === 'dangerous_tool') {
      throw new Error('Dangerous tool detected!');
    }
  });

  // 处理器 2：仍然会执行
  pi.on('tool_call', (tool, args) => {
    console.log('This will still run even if handler 1 throws');
  });

  // 推荐做法：手动捕获错误
  pi.on('tool_call', async (tool, args) => {
    try {
      await riskyOperation(tool, args);
    } catch (error) {
      console.error('Error in tool_call handler:', error);
      // 记录错误或发送通知
    }
  });
}
```

---

## 可视化

### 事件流程图

```
用户输入
  ↓
session_start 事件 → 监听器 1 → 监听器 2 → 监听器 3
  ↓
before_agent_start 事件 → 注入消息
  ↓
agent_start 事件 → 记录开始时间
  ↓
tool_call 事件 → 日志 → 监控 → 缓存
  ↓
tool_result 事件 → 记录结果
  ↓
agent_end 事件 → 记录结束时间 → 计算耗时
  ↓
session_shutdown 事件 → 清理资源
```

### 监听器执行顺序

```
事件触发
  ↓
监听器 1 (同步执行)
  ↓
监听器 2 (同步执行)
  ↓
监听器 3 (异步执行，不阻塞)
  ↓
继续主流程
```

---

## 最佳实践

### 1. 使用具名函数便于注销

```typescript
// ✅ 推荐
const handler = (session) => {
  console.log('Session started');
};
pi.on('session_start', handler);
pi.off('session_start', handler); // 可以注销

// ❌ 不推荐
pi.on('session_start', (session) => {
  console.log('Session started');
});
// 无法注销匿名函数
```

### 2. 在处理器中捕获错误

```typescript
// ✅ 推荐
pi.on('tool_call', async (tool, args) => {
  try {
    await riskyOperation();
  } catch (error) {
    console.error('Error:', error);
  }
});

// ❌ 不推荐
pi.on('tool_call', async (tool, args) => {
  await riskyOperation(); // 错误会被自动捕获，但无法自定义处理
});
```

### 3. 避免在处理器中执行耗时操作

```typescript
// ✅ 推荐：异步处理，不阻塞
pi.on('tool_call', async (tool, args) => {
  // 异步记录，不阻塞主流程
  logToDatabase(tool, args).catch(console.error);
});

// ❌ 不推荐：同步耗时操作
pi.on('tool_call', (tool, args) => {
  // 阻塞主流程
  const result = syncExpensiveOperation();
});
```

### 4. 使用 once() 处理一次性事件

```typescript
// ✅ 推荐
pi.once('session_start', (session) => {
  initializeExtension();
});

// ❌ 不推荐
let initialized = false;
pi.on('session_start', (session) => {
  if (!initialized) {
    initializeExtension();
    initialized = true;
  }
});
```

### 5. 清理资源

```typescript
export default function myExtension(pi: ExtensionAPI) {
  const handlers = [];

  // 注册处理器并保存引用
  const handler1 = (session) => { /* ... */ };
  const handler2 = (tool, args) => { /* ... */ };

  pi.on('session_start', handler1);
  pi.on('tool_call', handler2);

  handlers.push({ event: 'session_start', handler: handler1 });
  handlers.push({ event: 'tool_call', handler: handler2 });

  // 在 Extension 卸载时清理
  pi.on('session_shutdown', () => {
    handlers.forEach(({ event, handler }) => {
      pi.off(event, handler);
    });
  });
}
```

---

## 常见问题

### Q1: 事件监听器的执行顺序是什么？

**A:** 按注册顺序执行。先注册的监听器先执行。

```typescript
pi.on('tool_call', () => console.log('1')); // 第一个执行
pi.on('tool_call', () => console.log('2')); // 第二个执行
pi.on('tool_call', () => console.log('3')); // 第三个执行
```

### Q2: 异步处理器会阻塞主流程吗？

**A:** 不会。异步处理器不会阻塞主流程，但错误需要在处理器内部捕获。

```typescript
pi.on('tool_call', async (tool, args) => {
  await longRunningOperation(); // 不阻塞主流程
});
```

### Q3: 如何在处理器中访问 Extension 的状态？

**A:** 使用闭包或类实例。

```typescript
export default function myExtension(pi: ExtensionAPI) {
  let state = { count: 0 };

  pi.on('tool_call', (tool, args) => {
    state.count++; // 访问 Extension 状态
    console.log('Tool call count:', state.count);
  });
}
```

### Q4: 可以在处理器中修改事件参数吗？

**A:** 某些事件支持（如 before_agent_start），某些不支持。查看 ExtensionAPI 接口定义。

```typescript
// ✅ 支持修改
pi.on('before_agent_start', (messages) => {
  messages.push({ role: 'system', content: 'Custom' });
});

// ❌ 不支持修改（只读）
pi.on('tool_call', (tool, args) => {
  tool.name = 'new_name'; // 无效
});
```

### Q5: 如何调试事件监听器？

**A:** 使用 console.log 或 VS Code Debugger。

```typescript
pi.on('tool_call', (tool, args) => {
  console.log('Tool called:', tool.name); // 简单调试
  debugger; // VS Code 断点
});
```

---

## 参考资料

[1] typescript-event-emitter, https://github.com/piratuks/typescript-event-emitter, 2025年更新

[2] hookified, https://github.com/jaredwray/hookified, EventEmitter 结合异步中间件钩子

[3] EventEmitter2, https://github.com/EventEmitter2/EventEmitter2, 支持命名空间、通配符、TTL

---

**版本：** v1.0
**最后更新：** 2026-02-21
**维护者：** Claude Code
