# Session 管理与分支 - 最小可用知识

> 掌握以下内容，就能开始使用 Pi 的 Session 管理功能

---

## 核心理念

**20% 的核心知识解决 80% 的问题**

Session 管理看似复杂，但日常使用只需要掌握 4 个核心命令：
- `/new` - 创建新会话
- `/resume` - 恢复历史会话
- `/tree` - 导航会话树
- `/fork` - 创建分支

---

## 4.1 创建新会话：/new

### 基本用法

```bash
# 在 pi 交互界面中
/new
```

**作用：**
- 创建一个全新的 Session
- 清空当前对话历史
- 开始新的对话上下文

### 使用场景

**场景 1：切换项目**
```bash
# 当前在项目 A，想切换到项目 B
/new
# 现在可以开始项目 B 的对话
```

**场景 2：清空上下文**
```bash
# 当前对话太长，想重新开始
/new
# 获得干净的上下文
```

**场景 3：并行任务**
```bash
# 保留当前会话，开启新任务
/new
# 两个会话独立进行
```

### TypeScript 实现示例

```typescript
import { SessionManager } from '@mariozechner/pi-agent-core';

// 创建新会话
async function createNewSession() {
  const sessionManager = new SessionManager({
    sessionsDir: '~/.pi/sessions/'
  });

  // 创建新会话
  const newSession = await sessionManager.createSession();

  console.log(`新会话 ID: ${newSession.id}`);
  console.log(`存储路径: ${newSession.filePath}`);

  return newSession;
}
```

---

## 4.2 恢复会话：/resume

### 基本用法

```bash
# 方式 1：交互式选择
/resume

# 方式 2：直接指定 Session ID
/resume abc123
```

**作用：**
- 恢复之前的对话
- 加载完整的上下文
- 继续之前的工作

### 使用场景

**场景 1：跨设备工作**
```bash
# 在电脑 A 上工作
pi
# ... 做了一些工作 ...

# 在电脑 B 上继续
pi
/resume
# 选择之前的会话，继续工作
```

**场景 2：长期项目**
```bash
# 昨天的工作
pi
# ... 开发功能 A ...

# 今天继续
pi
/resume
# 选择昨天的会话，继续开发
```

**场景 3：回顾历史**
```bash
# 查看上周的决策过程
/resume
# 选择上周的会话，回顾讨论
```

### TypeScript 实现示例

```typescript
import { SessionManager } from '@mariozechner/pi-agent-core';

// 恢复会话
async function resumeSession(sessionId?: string) {
  const sessionManager = new SessionManager({
    sessionsDir: '~/.pi/sessions/'
  });

  if (sessionId) {
    // 直接恢复指定会话
    const session = await sessionManager.loadSession(sessionId);
    console.log(`恢复会话: ${session.name || session.id}`);
    return session;
  } else {
    // 列出所有会话供选择
    const sessions = await sessionManager.listSessions();
    console.log('可用会话:');
    sessions.forEach((s, i) => {
      console.log(`${i + 1}. ${s.name || s.id} (${s.lastModified})`);
    });
    return sessions;
  }
}
```

---

## 4.3 导航会话树：/tree

### 基本用法

```bash
# 打开会话树导航器
/tree
```

**作用：**
- 可视化显示会话的树形结构
- 导航到历史任意节点
- 查看分支关系

### 树形视图示例

```
Session: feature-development
├─ 1: User: 帮我实现用户登录功能
│  └─ 2: Assistant: 好的，我来实现...
│     ├─ 3: User: 使用 JWT 认证
│     │  └─ 4: Assistant: 实现 JWT 认证...
│     │     └─ 5: User: 测试通过 ✓
│     └─ 6: User: 改用 Session 认证 (分支)
│        └─ 7: Assistant: 实现 Session 认证...
│           └─ 8: User: 这个方案更好 ✓
```

### 使用场景

**场景 1：时间旅行**
```bash
# 当前在节点 8，想回到节点 4 看看 JWT 方案
/tree
# 使用方向键导航到节点 4
# 按 Enter 跳转
```

**场景 2：对比方案**
```bash
# 想对比 JWT 和 Session 两个方案
/tree
# 查看节点 5 和节点 8 的不同路径
```

**场景 3：查找历史**
```bash
# 记得之前讨论过某个问题，但忘了在哪
/tree
# 使用 Ctrl+O 搜索关键词
# 快速定位到相关节点
```

### 导航操作

| 操作 | 快捷键 | 说明 |
|------|--------|------|
| 上下移动 | ↑/↓ | 在树中移动光标 |
| 展开/折叠 | →/← | 展开或折叠分支 |
| 跳转 | Enter | 跳转到选中的节点 |
| 搜索 | Ctrl+O | 搜索节点内容 |
| 退出 | Esc | 退出树形视图 |

### TypeScript 实现示例

```typescript
import { SessionManager } from '@mariozechner/pi-agent-core';

// 获取会话树
async function getSessionTree(sessionId: string) {
  const sessionManager = new SessionManager({
    sessionsDir: '~/.pi/sessions/'
  });

  const session = await sessionManager.loadSession(sessionId);

  // 构建树形结构
  const tree = buildTree(session.entries);

  return tree;
}

// 构建树形结构
function buildTree(entries: any[]) {
  const nodeMap = new Map();
  const roots: any[] = [];

  // 第一遍：创建所有节点
  entries.forEach(entry => {
    nodeMap.set(entry.id, {
      id: entry.id,
      type: entry.type,
      content: entry.content,
      children: []
    });
  });

  // 第二遍：建立父子关系
  entries.forEach(entry => {
    const node = nodeMap.get(entry.id);
    if (entry.parentId) {
      const parent = nodeMap.get(entry.parentId);
      if (parent) {
        parent.children.push(node);
      }
    } else {
      roots.push(node);
    }
  });

  return roots;
}

// 打印树形结构
function printTree(node: any, prefix = '', isLast = true) {
  const connector = isLast ? '└─' : '├─';
  console.log(`${prefix}${connector} ${node.id}: ${node.type}`);

  const childPrefix = prefix + (isLast ? '   ' : '│  ');
  node.children.forEach((child: any, index: number) => {
    printTree(child, childPrefix, index === node.children.length - 1);
  });
}
```

---

## 4.4 创建分支：/fork

### 基本用法

```bash
# 从当前节点创建分支
/fork
```

**作用：**
- 从当前对话节点创建新分支
- 保留到当前节点的历史
- 开始新的探索路径

### 使用场景

**场景 1：尝试不同方案**
```bash
# 当前实现了方案 A
User: 实现了 JWT 认证
Assistant: 已完成 JWT 认证实现

# 想尝试方案 B，但不想丢失方案 A
/fork
User: 改用 Session 认证试试
# 现在有两个分支：JWT 分支和 Session 分支
```

**场景 2：A/B 测试**
```bash
# 当前有一个基础实现
User: 实现了基础功能

# 想测试两种优化方案
/fork
User: 优化方案 1：使用缓存
# 完成后回到原节点
/tree  # 导航回原节点
/fork
User: 优化方案 2：使用索引
# 现在可以对比两种方案
```

**场景 3：保存检查点**
```bash
# 当前功能已完成
User: 功能 A 已完成并测试通过

# 创建检查点，然后继续开发
/fork
User: 开始开发功能 B
# 如果功能 B 出问题，可以回到功能 A 的检查点
```

### Fork 选择器

当使用 `/fork` 时，Pi 会显示一个选择器：

```
Fork from which point?
1. [Current] User: 实现了 JWT 认证
2. [Parent] Assistant: 好的，我来实现...
3. [Root] User: 帮我实现用户登录功能

Select (1-3):
```

**选项说明：**
- **Current**：从当前节点 Fork（最常用）
- **Parent**：从父节点 Fork
- **Root**：从根节点 Fork（重新开始）

### TypeScript 实现示例

```typescript
import { SessionManager } from '@mariozechner/pi-agent-core';

// Fork 会话
async function forkSession(sessionId: string, fromNodeId: string) {
  const sessionManager = new SessionManager({
    sessionsDir: '~/.pi/sessions/'
  });

  // 加载原会话
  const originalSession = await sessionManager.loadSession(sessionId);

  // 创建新会话
  const forkedSession = await sessionManager.createSession();

  // 复制历史到指定节点
  const historyToFork = getHistoryUpToNode(
    originalSession.entries,
    fromNodeId
  );

  // 写入新会话
  for (const entry of historyToFork) {
    await forkedSession.append(entry);
  }

  console.log(`Fork 完成: ${forkedSession.id}`);
  console.log(`从节点 ${fromNodeId} 创建分支`);

  return forkedSession;
}

// 获取到指定节点的历史
function getHistoryUpToNode(entries: any[], targetNodeId: string) {
  const history: any[] = [];
  const nodeMap = new Map(entries.map(e => [e.id, e]));

  // 从目标节点向上追溯
  let currentId = targetNodeId;
  while (currentId) {
    const node = nodeMap.get(currentId);
    if (!node) break;

    history.unshift(node);
    currentId = node.parentId;
  }

  return history;
}
```

---

## 4.5 会话命名：/name

### 基本用法

```bash
# 为当前会话命名
/name feature-login-implementation
```

**作用：**
- 给会话一个有意义的名称
- 方便后续查找和恢复
- 替代默认的随机 ID

### 使用场景

**场景 1：项目管理**
```bash
# 为不同项目的会话命名
/name project-a-auth
/name project-b-api
/name project-c-ui
```

**场景 2：功能开发**
```bash
# 为不同功能的会话命名
/name feature-user-login
/name feature-payment-integration
/name bugfix-memory-leak
```

### TypeScript 实现示例

```typescript
import { SessionManager } from '@mariozechner/pi-agent-core';

// 命名会话
async function nameSession(sessionId: string, name: string) {
  const sessionManager = new SessionManager({
    sessionsDir: '~/.pi/sessions/'
  });

  const session = await sessionManager.loadSession(sessionId);

  // 添加名称元数据
  await session.append({
    type: 'metadata',
    name: name,
    timestamp: Date.now()
  });

  console.log(`会话已命名: ${name}`);
}
```

---

## 这些知识足以

掌握以上 5 个核心功能后，你就能：

### ✅ 日常开发工作流

```bash
# 1. 开始新项目
pi
/new
/name my-project

# 2. 工作一段时间后保存
# Pi 自动保存，无需手动操作

# 3. 第二天继续
pi
/resume
# 选择 my-project

# 4. 尝试不同方案
/fork
# 实验新方案

# 5. 查看历史决策
/tree
# 导航到历史节点
```

### ✅ 多路径探索

```bash
# 1. 实现基础功能
User: 实现功能 A
Assistant: 已完成

# 2. 尝试优化方案 1
/fork
User: 优化方案 1
Assistant: 已实现

# 3. 回到基础功能
/tree
# 导航回功能 A 节点

# 4. 尝试优化方案 2
/fork
User: 优化方案 2
Assistant: 已实现

# 5. 对比两个方案
/tree
# 查看两个分支的差异
```

### ✅ 团队协作

```bash
# 1. 团队成员 A 创建会话
pi
/new
/name team-project-feature-x
# 工作...

# 2. 团队成员 B 继续
pi
/resume
# 选择 team-project-feature-x
# 继续工作...

# 3. 团队成员 C 查看历史
pi
/resume
# 选择 team-project-feature-x
/tree
# 查看完整的开发历史
```

---

## 实际应用示例

### 示例 1：Bug 修复工作流

```bash
# 1. 创建 Bug 修复会话
pi
/new
/name bugfix-login-error

# 2. 调试和修复
User: 登录功能报错，帮我调试
Assistant: 发现问题在 auth.ts:42...
User: 修复后测试通过

# 3. 保存检查点
/fork
/name bugfix-login-error-checkpoint

# 4. 继续优化
User: 再优化一下错误处理
Assistant: 已优化...

# 5. 如果优化出问题，回到检查点
/tree
# 导航到 checkpoint 节点
```

### 示例 2：功能开发工作流

```bash
# 1. 开始功能开发
pi
/new
/name feature-payment-integration

# 2. 实现基础功能
User: 实现支付宝支付
Assistant: 已实现基础功能

# 3. 尝试不同的错误处理策略
/fork
/name feature-payment-retry-strategy-1
User: 实现重试策略 1
Assistant: 已实现

# 4. 回到基础功能
/tree
# 导航回基础功能节点

# 5. 尝试另一种策略
/fork
/name feature-payment-retry-strategy-2
User: 实现重试策略 2
Assistant: 已实现

# 6. 对比两种策略
/tree
# 查看两个分支，选择更好的方案
```

### 示例 3：学习和实验

```bash
# 1. 学习新技术
pi
/new
/name learning-graphql

# 2. 实验基础用法
User: 教我 GraphQL 基础
Assistant: GraphQL 是...

# 3. 尝试不同的实现方式
/fork
/name graphql-with-apollo
User: 使用 Apollo 实现
Assistant: 已实现

# 4. 回到基础
/tree
# 导航回基础节点

# 5. 尝试另一种实现
/fork
/name graphql-with-relay
User: 使用 Relay 实现
Assistant: 已实现

# 6. 对比学习
/tree
# 查看两种实现的差异
```

---

## 常见问题

### Q1: Session 存储在哪里？

**A:** 默认存储在 `~/.pi/sessions/` 目录，每个 Session 是一个 JSONL 文件。

```bash
# 查看所有 Session
ls ~/.pi/sessions/

# 输出示例
abc123.jsonl
def456.jsonl
feature-login.jsonl
```

### Q2: /fork 和 /new 有什么区别？

**A:**
- `/new`：创建全新的会话，没有历史
- `/fork`：从当前节点创建分支，保留历史

```bash
# /new - 全新开始
/new
# 没有任何历史上下文

# /fork - 保留历史
/fork
# 保留到当前节点的所有历史
```

### Q3: 如何删除不需要的 Session？

**A:** 直接删除 JSONL 文件即可。

```bash
# 删除指定 Session
rm ~/.pi/sessions/abc123.jsonl

# 或在 pi 中使用（如果支持）
/delete abc123
```

### Q4: Session 会自动保存吗？

**A:** 是的，Pi 会自动保存每条消息到 JSONL 文件。

```typescript
// 每次对话都会自动追加到文件
// 无需手动保存
```

### Q5: 可以在不同设备间同步 Session 吗？

**A:** 可以，通过同步 `~/.pi/sessions/` 目录实现。

```bash
# 方式 1：使用 Git
cd ~/.pi/sessions/
git init
git add .
git commit -m "Save sessions"
git push

# 方式 2：使用云同步
# 将 ~/.pi/sessions/ 放在 Dropbox/iCloud 等云盘中

# 方式 3：手动复制
scp ~/.pi/sessions/*.jsonl user@remote:~/.pi/sessions/
```

---

## 快速参考卡

| 命令 | 作用 | 使用场景 |
|------|------|---------|
| `/new` | 创建新会话 | 开始新项目、清空上下文 |
| `/resume` | 恢复会话 | 继续之前的工作、跨设备工作 |
| `/tree` | 导航会话树 | 查看历史、时间旅行、对比方案 |
| `/fork` | 创建分支 | 尝试不同方案、A/B 测试、保存检查点 |
| `/name` | 命名会话 | 方便管理和查找 |

---

## 下一步学习

掌握了最小可用知识后，可以继续学习：

- **核心概念 1 - Session 存储机制**：深入理解 JSONL 格式和存储原理
- **核心概念 2 - 分支导航与 tree 命令**：掌握高级导航技巧
- **核心概念 3 - Fork 与会话创建**：理解 Fork 的底层机制
- **核心概念 5 - Compaction 压缩机制**：了解如何优化 Session 大小

---

## 学习检查清单

完成本节学习后，你应该能够：

- [ ] 使用 `/new` 创建新会话
- [ ] 使用 `/resume` 恢复历史会话
- [ ] 使用 `/tree` 导航会话树
- [ ] 使用 `/fork` 创建分支
- [ ] 使用 `/name` 命名会话
- [ ] 理解 Session 的基本存储位置
- [ ] 在实际项目中应用 Session 管理

---

**版本：** v1.0
**最后更新：** 2026-02-18
**维护者：** Claude Code
