# 核心概念2：邻接表表示

> 用字典存储每个节点的邻居列表 - 稀疏图和知识图谱的标准表示

---

## 一句话定义

**邻接表是用字典存储每个节点的邻居列表的图表示方法，空间复杂度O(V+E)，是稀疏图和大规模知识图谱的标准表示。**

---

## 核心原理

### 基本思想

```python
# 有向图：A → B, A → C, B → C
graph = {
    "A": ["B", "C"],  # A的邻居
    "B": ["C"],       # B的邻居
    "C": []           # C无邻居
}

# 只存储存在的边，不浪费空间
```

**核心规则：**
- 键 = 节点
- 值 = 邻居列表
- 只存储存在的边

---

## 完整实现

```python
from collections import defaultdict
from typing import List, Dict, Set

class Graph:
    """基于邻接表的Graph实现（推荐）"""

    def __init__(self, directed=True):
        self.graph = defaultdict(list)  # 自动初始化空列表
        self.directed = directed

    def add_edge(self, u, v, weight=None):
        """添加边：u → v"""
        # 存储邻居（可选权重）
        if weight is None:
            self.graph[u].append(v)
        else:
            self.graph[u].append((v, weight))

        # 无向图添加反向边
        if not self.directed:
            if weight is None:
                self.graph[v].append(u)
            else:
                self.graph[v].append((u, weight))

    def get_neighbors(self, node):
        """获取邻居 - O(1)"""
        return self.graph[node]

    def has_edge(self, u, v):
        """检查边是否存在 - O(degree)"""
        neighbors = self.graph.get(u, [])
        if not neighbors:
            return False

        # 处理带权重的情况
        if neighbors and isinstance(neighbors[0], tuple):
            return any(neighbor == v for neighbor, _ in neighbors)
        else:
            return v in neighbors

    def remove_edge(self, u, v):
        """删除边"""
        if u in self.graph:
            # 处理带权重的情况
            if self.graph[u] and isinstance(self.graph[u][0], tuple):
                self.graph[u] = [(n, w) for n, w in self.graph[u] if n != v]
            else:
                self.graph[u] = [n for n in self.graph[u] if n != v]

        if not self.directed and v in self.graph:
            if self.graph[v] and isinstance(self.graph[v][0], tuple):
                self.graph[v] = [(n, w) for n, w in self.graph[v] if n != u]
            else:
                self.graph[v] = [n for n in self.graph[v] if n != u]

    def get_all_nodes(self):
        """获取所有节点"""
        nodes = set(self.graph.keys())
        for neighbors in self.graph.values():
            if neighbors and isinstance(neighbors[0], tuple):
                nodes.update(n for n, _ in neighbors)
            else:
                nodes.update(neighbors)
        return list(nodes)

    def degree(self, node):
        """获取节点的度数"""
        return len(self.graph.get(node, []))

# 使用示例
g = Graph(directed=True)
g.add_edge("A", "B")
g.add_edge("A", "C")
g.add_edge("B", "C")

print(f"A的邻居: {g.get_neighbors('A')}")  # ['B', 'C']
print(f"A→B存在: {g.has_edge('A', 'B')}")  # True
print(f"B→A存在: {g.has_edge('B', 'A')}")  # False
print(f"A的度数: {g.degree('A')}")         # 2
```

---

## 时间复杂度分析

| 操作 | 邻接表 | 邻接矩阵 | 说明 |
|------|--------|----------|------|
| **添加边** | O(1) | O(1) | 邻接表追加到列表 |
| **删除边** | O(degree) | O(1) | 邻接表需要查找 |
| **查询边** | O(degree) | O(1) | 邻接表需要遍历邻居 |
| **获取邻居** | O(1) | O(V) | 邻接表直接返回 ⭐ |
| **遍历所有边** | O(E) | O(V²) | 邻接表只遍历存在的边 ⭐ |

**关键优势：**
- ✅ 获取邻居：O(1) - 直接返回列表
- ✅ 遍历边：O(E) - 只遍历存在的边
- ✅ 空间：O(V+E) - 只存储存在的边

---

## 空间复杂度分析

```python
# 空间复杂度：O(V + E)

# 示例：知识图谱
V = 10000  # 实体数
E = 50000  # 关系数

# 邻接表
space = V + E = 60,000 个元素
memory = 60,000 * 8 bytes = 480 KB

# 邻接矩阵
space = V * V = 100,000,000 个元素
memory = 100,000,000 * 4 bytes = 400 MB

# 邻接表节省空间：833倍！
```

**结论：稀疏图使用邻接表节省大量空间！**

---

## 在AI Agent中的应用

### 应用1：知识图谱存储（最常用）⭐⭐⭐⭐⭐

```python
# 知识图谱三元组存储
class KnowledgeGraph:
    def __init__(self):
        self.graph = defaultdict(lambda: defaultdict(list))

    def add_triple(self, subject, predicate, object):
        """添加三元组：(S, P, O)"""
        self.graph[subject][predicate].append(object)

    def query(self, subject, predicate=None):
        """查询：给定主语和关系，返回宾语"""
        if predicate:
            return self.graph[subject][predicate]
        else:
            return dict(self.graph[subject])

# 使用
kg = KnowledgeGraph()
kg.add_triple("张三", "工作于", "阿里巴巴")
kg.add_triple("张三", "居住在", "杭州")
kg.add_triple("阿里巴巴", "位于", "杭州")

print(kg.query("张三", "工作于"))  # ['阿里巴巴']
print(kg.query("张三"))            # {'工作于': ['阿里巴巴'], '居住在': ['杭州']}
```

### 应用2：使用NetworkX（生产级）⭐⭐⭐⭐⭐

```python
import networkx as nx

# 创建有向图（知识图谱）
G = nx.DiGraph()

# 添加带属性的边
G.add_edge("张三", "阿里巴巴", relation="工作于")
G.add_edge("张三", "杭州", relation="居住在")
G.add_edge("阿里巴巴", "杭州", relation="位于")

# 查询
print(list(G.neighbors("张三")))  # ['阿里巴巴', '杭州']
print(G["张三"]["阿里巴巴"])      # {'relation': '工作于'}

# 路径查询
if nx.has_path(G, "张三", "杭州"):
    paths = list(nx.all_simple_paths(G, "张三", "杭州"))
    print(paths)  # [['张三', '杭州'], ['张三', '阿里巴巴', '杭州']]
```

### 应用3：社交网络（无向图）

```python
# 无向图：朋友关系
social = Graph(directed=False)
social.add_edge("Alice", "Bob")
social.add_edge("Bob", "Charlie")
social.add_edge("Alice", "Charlie")

# 查询共同朋友
def common_friends(g, user1, user2):
    friends1 = set(g.get_neighbors(user1))
    friends2 = set(g.get_neighbors(user2))
    return friends1 & friends2

print(common_friends(social, "Alice", "Bob"))  # {'Charlie'}
```

---

## 对比邻接矩阵

| 特性 | 邻接表 | 邻接矩阵 | 推荐 |
|------|--------|----------|------|
| **空间** | O(V+E) | O(V²) | 邻接表 ⭐ |
| **查询边** | O(degree) | O(1) | 看场景 |
| **获取邻居** | O(1) | O(V) | 邻接表 ⭐ |
| **适合场景** | 稀疏图 | 密集图 | 邻接表（99%情况）⭐ |

**选择标准：**
```python
# 实际应用中的图密度
知识图谱：0.001% - 0.01%  → 邻接表 ⭐
社交网络：0.0001% - 0.001% → 邻接表 ⭐
小规模完全图：> 50%       → 邻接矩阵
```

---

## 优化技巧

### 技巧1：使用集合加速查询

```python
class FastGraph:
    def __init__(self):
        self.graph = defaultdict(set)  # 使用set而非list

    def add_edge(self, u, v):
        self.graph[u].add(v)

    def has_edge(self, u, v):
        return v in self.graph[u]  # O(1)平均复杂度
```

### 技巧2：双向索引

```python
class BidirectionalGraph:
    def __init__(self):
        self.out_edges = defaultdict(list)  # 出边
        self.in_edges = defaultdict(list)   # 入边

    def add_edge(self, u, v):
        self.out_edges[u].append(v)
        self.in_edges[v].append(u)

    def get_predecessors(self, node):
        """获取前驱节点 - O(1)"""
        return self.in_edges[node]
```

---

## 实战练习

### 练习1：实现多跳查询

```python
def multi_hop_query(kg, start, relation_path):
    """
    多跳查询
    例如：查询"张三的老板的出生地"
    relation_path = ["工作于", "创始人", "出生于"]
    """
    # TODO: 实现
    pass
```

### 练习2：实现图的深拷贝

```python
def deep_copy_graph(g):
    """深拷贝图"""
    # TODO: 实现
    pass
```

---

## 总结

**邻接表的核心特点：**
1. ✅ O(V+E)空间复杂度 - 节省空间
2. ✅ O(1)获取邻居 - 高效遍历
3. ✅ 适合稀疏图 - 99%的实际应用
4. ❌ O(degree)查询边 - 比邻接矩阵慢

**在AI Agent中的应用：**
- 知识图谱存储（最常用）
- 社交网络
- 推荐系统
- 路径查询和推理

**关键洞察：**
- 邻接表是实际应用的标准选择
- NetworkX是Python的标准图库
- 知识图谱几乎都使用邻接表

---

**下一步：** 学习 `03_核心概念_03_有向图与无向图.md`
