# 10_一句话总结

> **学习目标**：用一句话总结核心，并通过检查清单验证学习效果

---

## 一句话总结

**RunnablePassthrough 透传并扩展数据（保留原输入 + assign 添加字段），RunnableLambda 包装任意函数为标准 Runnable（自定义逻辑 + 链式集成），两者是 LCEL 中实现灵活数据流控制的核心工具。**

---

## 核心记忆点（3 个）

### 1. RunnablePassthrough = 数据保留器

**本质**：输入原样输出，可通过 `assign()` 添加新字段

**记忆口诀**：
```
透传 = 保持不变
assign = 扩展字段
两者结合 = RAG 必备
```

**典型代码**：
```python
# 保留查询 + 添加上下文
chain = RunnablePassthrough.assign(context=retriever)
```

### 2. RunnableLambda = 函数包装器

**本质**：将任意 Python 函数转换为 Runnable

**记忆口诀**：
```
普通函数 → RunnableLambda → 标准 Runnable
同步/异步 → 统一接口 → 链式组合
```

**典型代码**：
```python
# 自定义处理逻辑
chain = RunnableLambda(custom_func) | llm
```

### 3. 两者配合 = 完整数据流

**本质**：Passthrough 保留，Lambda 转换，组合实现复杂逻辑

**记忆口诀**：
```
Passthrough → 保留原始数据
Lambda → 自定义转换
组合 → 灵活控制流
```

**典型代码**：
```python
# 查询改写 + 上下文保留
chain = (
    RunnableLambda(rewrite_query)
    | RunnablePassthrough.assign(context=retriever)
    | llm
)
```

---

## 学习检查清单

### 基础理解（必须全部掌握）

- [ ] **能解释 RunnablePassthrough 的作用**
  - 透传输入数据，保持不变
  - 可通过 assign() 添加新字段
  - 不会丢失原始输入

- [ ] **能解释 RunnableLambda 的作用**
  - 包装任意 Python 函数
  - 转换为标准 Runnable
  - 支持同步和异步函数

- [ ] **理解 assign() 方法的行为**
  - 不替换原输入，而是扩展
  - 添加新键值对到字典
  - 如果键已存在会被覆盖

- [ ] **知道何时使用 RunnablePassthrough**
  - RAG 中保留原始查询
  - 并行处理时保持数据完整性
  - 需要在链中传递中间结果

- [ ] **知道何时使用 RunnableLambda**
  - 需要自定义数据转换
  - 集成外部 API 调用
  - 实现复杂的条件逻辑

### 核心概念（深入理解）

- [ ] **理解 RunnablePassthrough 的透传机制**
  - 输入类型 = 输出类型
  - 不做任何转换（identity function）
  - assign() 是唯一的扩展方式

- [ ] **理解 RunnableLambda 的函数包装**
  - 自动检测同步/异步
  - 统一的 invoke/ainvoke 接口
  - 支持批处理和流式输出

- [ ] **理解数据转换与组合模式**
  - Passthrough + Lambda 的配合
  - 与 RunnableParallel 的集成
  - 链式组合的最佳实践

### 实战能力（能写代码）

- [ ] **能写基础的 RunnablePassthrough 代码**
  ```python
  # 基础透传
  passthrough = RunnablePassthrough()

  # assign 扩展
  chain = RunnablePassthrough.assign(
      new_field=lambda x: process(x)
  )
  ```

- [ ] **能写基础的 RunnableLambda 代码**
  ```python
  # 同步函数
  lambda_sync = RunnableLambda(sync_func)

  # 异步函数
  lambda_async = RunnableLambda(async_func)
  ```

- [ ] **能构建 RAG 数据增强管道**
  ```python
  # 完整 RAG 链
  rag_chain = (
      RunnablePassthrough.assign(context=retriever)
      | prompt
      | llm
      | StrOutputParser()
  )
  ```

- [ ] **能实现自定义数据处理**
  ```python
  # 查询改写 + 检索
  chain = (
      RunnableLambda(rewrite_query)
      | RunnablePassthrough.assign(
          context=retriever,
          metadata=get_metadata
      )
      | llm
  )
  ```

- [ ] **能处理错误和重试**
  ```python
  # 带重试的 Lambda
  safe_lambda = RunnableLambda(risky_func).with_retry(
      stop_after_attempt=3
  )
  ```

### 进阶理解（生产级）

- [ ] **理解类型系统**
  - RunnablePassthrough: `Runnable[Input, Input]`
  - RunnableLambda: `Runnable[Input, Output]`
  - assign() 的类型推断

- [ ] **理解性能优化**
  - 批处理的性能提升
  - 异步函数的优势
  - 避免不必要的数据复制

- [ ] **理解常见陷阱**
  - assign() 键冲突问题
  - Lambda 中的异常处理
  - 同步函数阻塞异步链

- [ ] **理解生产环境最佳实践**
  - 错误处理和重试策略
  - 日志和可观测性
  - 性能监控和优化

---

## 快速参考卡片

### RunnablePassthrough 速查

| 用法 | 代码 | 说明 |
|------|------|------|
| **基础透传** | `RunnablePassthrough()` | 输入原样输出 |
| **添加单字段** | `.assign(key=func)` | 保留输入 + 新字段 |
| **添加多字段** | `.assign(k1=f1, k2=f2)` | 同时添加多个字段 |
| **与检索器组合** | `.assign(context=retriever)` | RAG 标准模式 |
| **并行处理** | `RunnableParallel({...})` | 多路并行扩展 |

### RunnableLambda 速查

| 用法 | 代码 | 说明 |
|------|------|------|
| **同步函数** | `RunnableLambda(func)` | 包装普通函数 |
| **异步函数** | `RunnableLambda(async_func)` | 包装异步函数 |
| **带重试** | `.with_retry(stop_after_attempt=3)` | 自动重试 |
| **带降级** | `.with_fallbacks([fallback])` | 失败降级 |
| **批处理** | `.batch([input1, input2])` | 批量处理 |

### 常见组合模式

| 模式 | 代码结构 | 使用场景 |
|------|----------|----------|
| **RAG 基础** | `Passthrough.assign(context=retriever)` | 保留查询 + 检索 |
| **查询改写** | `Lambda(rewrite) \| Passthrough.assign(...)` | 预处理 + 检索 |
| **并行增强** | `Parallel({original: Pass, processed: Lambda})` | 多路处理 |
| **条件路由** | `Lambda(router) \| RunnableBranch(...)` | 动态路由 |

---

## 核心 API 总结

### RunnablePassthrough

```python
from langchain_core.runnables import RunnablePassthrough

# 1. 构造函数
passthrough = RunnablePassthrough()

# 2. assign() 方法（类方法）
chain = RunnablePassthrough.assign(
    field1=lambda x: compute1(x),
    field2=lambda x: compute2(x)
)

# 3. 调用方法
result = passthrough.invoke(input)
result = await passthrough.ainvoke(input)
results = passthrough.batch([input1, input2])
```

### RunnableLambda

```python
from langchain_core.runnables import RunnableLambda

# 1. 构造函数
lambda_runnable = RunnableLambda(func)

# 2. 错误处理
safe_lambda = lambda_runnable.with_retry(
    stop_after_attempt=3,
    wait_exponential_multiplier=1,
    wait_exponential_max=10
)

fallback_lambda = lambda_runnable.with_fallbacks([
    RunnableLambda(fallback_func)
])

# 3. 调用方法
result = lambda_runnable.invoke(input)
result = await lambda_runnable.ainvoke(input)
results = lambda_runnable.batch([input1, input2])
```

---

## 典型错误与解决方案

### 错误 1：误以为 assign 会替换输入

**错误代码**：
```python
# ❌ 认为 assign 会替换 query
chain = RunnablePassthrough.assign(query="new query")
# 实际：原始 query 会被覆盖，不是替换整个输入
```

**正确理解**：
```python
# ✅ assign 是扩展，不是替换
input_data = {"query": "original", "user": "alice"}
result = RunnablePassthrough.assign(
    context="retrieved"
).invoke(input_data)
# 输出: {"query": "original", "user": "alice", "context": "retrieved"}
```

### 错误 2：Lambda 中忘记错误处理

**错误代码**：
```python
# ❌ 没有错误处理
def risky_func(x):
    return x["key"]  # 如果 key 不存在会崩溃

chain = RunnableLambda(risky_func) | llm
```

**正确代码**：
```python
# ✅ 添加错误处理
def safe_func(x):
    try:
        return x.get("key", "default")
    except Exception as e:
        logger.error(f"Error: {e}")
        return "fallback_value"

chain = RunnableLambda(safe_func) | llm
```

### 错误 3：同步函数阻塞异步链

**错误代码**：
```python
# ❌ 同步函数阻塞
import time

def slow_sync(x):
    time.sleep(5)  # 阻塞整个事件循环
    return x

chain = RunnableLambda(slow_sync) | llm
await chain.ainvoke("input")  # 会阻塞 5 秒
```

**正确代码**：
```python
# ✅ 使用异步函数
import asyncio

async def fast_async(x):
    await asyncio.sleep(5)  # 不阻塞事件循环
    return x

chain = RunnableLambda(fast_async) | llm
await chain.ainvoke("input")  # 不会阻塞其他任务
```

---

## 学习路径建议

### 初学者路径（1-2 天）

1. **第一步：理解基础概念**
   - 阅读 `01_30字核心.md`
   - 阅读 `04_最小可用.md`
   - 理解透传和函数包装的概念

2. **第二步：动手实践**
   - 运行 `07_实战代码_01_基础透传与assign.md` 中的示例
   - 修改代码，观察输出变化
   - 理解 assign() 的行为

3. **第三步：构建简单 RAG**
   - 运行 `07_实战代码_03_RAG数据增强.md` 中的示例
   - 理解数据流动过程
   - 尝试添加自定义字段

### 进阶路径（3-5 天）

1. **深入理解机制**
   - 阅读 `02_第一性原理.md`
   - 阅读 `03_核心概念_*.md` 系列
   - 理解底层实现原理

2. **掌握高级用法**
   - 学习 `07_实战代码_02_Lambda自定义处理.md`
   - 实现异步处理和错误重试
   - 集成外部 API

3. **避免常见陷阱**
   - 阅读 `06_反直觉点.md`
   - 理解类型系统和性能优化
   - 学习生产环境最佳实践

### 专家路径（持续学习）

1. **源码阅读**
   - 阅读 LangChain 源码中的 `passthrough.py`
   - 理解 Runnable 接口的设计
   - 学习类型推断机制

2. **生产实践**
   - 构建完整的 RAG 应用
   - 实现复杂的数据转换管道
   - 优化性能和可观测性

3. **社区贡献**
   - 分享最佳实践
   - 提交 bug 修复
   - 参与社区讨论

---

## 面试准备速查

### 高频问题（必须掌握）

**Q1: RunnablePassthrough 和 RunnableLambda 的区别是什么？**

**标准答案**：
- **RunnablePassthrough**：透传输入，保持不变，可通过 assign() 添加字段
- **RunnableLambda**：包装自定义函数，实现任意转换逻辑
- **使用场景**：Passthrough 用于数据保留，Lambda 用于数据转换

**Q2: assign() 方法的行为是什么？**

**标准答案**：
- 不替换输入，而是扩展输入字典
- 添加新键值对，如果键已存在会被覆盖
- 返回新字典，包含原始输入 + 新字段

**Q3: 如何在 RAG 中使用 RunnablePassthrough？**

**标准答案**：
```python
# 保留原始查询 + 添加检索上下文
rag_chain = (
    RunnablePassthrough.assign(context=retriever)
    | prompt
    | llm
)
```

### 进阶问题（加分项）

**Q4: RunnableLambda 如何处理异步函数？**

**标准答案**：
- 自动检测函数是否为异步
- 提供统一的 invoke/ainvoke 接口
- 异步函数不会阻塞事件循环

**Q5: 如何实现错误处理和重试？**

**标准答案**：
```python
# 使用 with_retry
safe_lambda = RunnableLambda(func).with_retry(
    stop_after_attempt=3
)

# 使用 with_fallbacks
fallback_lambda = RunnableLambda(func).with_fallbacks([
    RunnableLambda(fallback_func)
])
```

---

## 实战检查点

### 能否独立完成以下任务？

- [ ] **任务 1**：构建一个 RAG 链，保留原始查询并添加检索上下文
- [ ] **任务 2**：实现一个查询改写函数，并集成到 RAG 链中
- [ ] **任务 3**：使用 RunnableLambda 调用外部 API，并处理错误
- [ ] **任务 4**：实现并行数据增强，同时添加多个字段
- [ ] **任务 5**：优化异步处理，避免阻塞事件循环

**如果以上任务都能完成，说明已掌握核心知识；否则需要重点学习相关章节。**

---

## 下一步学习建议

### 如果你是初学者

1. **先学习前置知识**
   - `01_Runnable接口与LCEL基础` - 理解 LCEL 基础
   - `04_链式组合（管道操作符）` - 理解链式组合

2. **然后深入本知识点**
   - 从 `04_最小可用.md` 开始
   - 运行 `07_实战代码_*.md` 中的示例
   - 完成实战检查点任务

### 如果你已有基础

1. **深入理解机制**
   - 阅读 `02_第一性原理.md`
   - 阅读 `03_核心概念_*.md` 系列

2. **学习高级用法**
   - 异步处理和错误重试
   - 性能优化和批处理
   - 生产环境最佳实践

### 如果你要应用到生产

1. **学习完整 RAG 实现**
   - `L3_RAG核心流程` 系列
   - `L4_RAG进阶优化` 系列

2. **学习框架集成**
   - `L5_框架与落地` 系列
   - 部署和监控最佳实践

---

## 总结：三个核心要点

### 1. RunnablePassthrough = 数据保留 + 扩展

- 透传输入，保持不变
- assign() 添加新字段
- RAG 中保留查询的标准方式

### 2. RunnableLambda = 函数 → Runnable

- 包装任意 Python 函数
- 支持同步和异步
- 实现自定义转换逻辑

### 3. 两者配合 = 灵活数据流

- Passthrough 保留原始数据
- Lambda 实现自定义转换
- 组合构建复杂管道

---

**记住这一句话**：

> RunnablePassthrough 让数据流动时不丢失信息（透传 + assign），RunnableLambda 让任意函数融入数据流（包装 + 标准化），两者是 LCEL 中实现灵活数据控制的基石。

---

**参考资料**：
- [LangChain RunnablePassthrough 官方文档](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html) (2025)
- [LangChain RunnableLambda 官方文档](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.base.RunnableLambda.html) (2025)
- [Building Production-Ready AI Pipelines](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557) (2026)

---

**版本**：v1.0
**最后更新**：2026-02-18
**预计学习时间**：初学者 1-2 天，进阶 3-5 天
