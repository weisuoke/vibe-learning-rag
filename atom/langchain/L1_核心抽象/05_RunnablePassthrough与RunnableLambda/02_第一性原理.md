# 02_第一性原理

> **学习目标**：从底层设计思想理解 RunnablePassthrough 与 RunnableLambda 的本质和存在理由

---

## 什么是第一性原理？

**第一性原理 = 回到问题的本源，从最基本的真理出发推导解决方案**

不是问"别人怎么做"，而是问：
- 这个问题的本质是什么？
- 为什么需要这个解决方案？
- 如果从零开始设计，会怎么做？

---

## 核心问题：为什么需要 RunnablePassthrough 和 RunnableLambda？

### 问题 1：链式处理中的数据丢失

**场景**：构建一个 RAG 问答系统

```python
# 最简单的想法
retriever = ...  # 检索器
llm = ...        # 大模型

# 直接连接
chain = retriever | llm

# 问题：原始查询丢失了！
result = chain.invoke("什么是 LangChain?")
# retriever 输出：[doc1, doc2, doc3]（文档列表）
# llm 输入：[doc1, doc2, doc3]（只有文档，没有查询！）
# llm 不知道用户问的是什么！
```

**本质问题**：
- 链式处理是单向数据流：A → B → C
- 每个环节只能看到上一个环节的输出
- 如果需要保留原始输入，必须有机制传递

**第一性原理推导**：

```
需求：同时传递原始查询和检索结果
    ↓
方案 1：修改 retriever 的输出格式
    问题：破坏了 retriever 的标准接口
    ↓
方案 2：在链中插入一个"数据保留器"
    ✅ 不修改现有组件
    ✅ 保持接口标准化
    ✅ 灵活组合
    ↓
设计：RunnablePassthrough
    - 透传输入（保留原始数据）
    - assign() 方法（添加新字段）
```

**解决方案**：
```python
from langchain_core.runnables import RunnablePassthrough

# 使用 RunnablePassthrough 保留查询
chain = (
    RunnablePassthrough.assign(context=retriever)  # 保留查询 + 添加上下文
    | prompt  # 现在可以同时访问 query 和 context
    | llm
)

result = chain.invoke({"query": "什么是 LangChain?"})
# 数据流：
# 1. {"query": "什么是 LangChain?"}
# 2. {"query": "什么是 LangChain?", "context": [doc1, doc2, doc3]}
# 3. prompt 可以同时使用 query 和 context
```

---

### 问题 2：自定义逻辑的集成困境

**场景**：需要在链中添加自定义的查询改写逻辑

```python
# 自定义函数
def rewrite_query(query):
    """将简短查询扩展为详细查询"""
    if len(query) < 10:
        return f"请详细解释：{query}"
    return query

# 尝试集成到链中
chain = rewrite_query | retriever | llm  # ❌ 报错！
# TypeError: unsupported operand type(s) for |: 'function' and 'Retriever'
```

**本质问题**：
- LCEL 链要求所有组件实现 Runnable 接口
- 普通 Python 函数不是 Runnable
- 需要一个"适配器"将函数转换为 Runnable

**第一性原理推导**：

```
需求：将任意函数集成到 LCEL 链中
    ↓
方案 1：要求所有函数都实现 Runnable 接口
    问题：太繁琐，用户体验差
    ↓
方案 2：提供一个包装器，自动转换
    ✅ 用户只需写普通函数
    ✅ 框架负责适配
    ✅ 保持链的统一性
    ↓
设计：RunnableLambda
    - 接受任意函数（同步/异步）
    - 自动实现 Runnable 接口
    - 提供统一的调用方式
```

**解决方案**：
```python
from langchain_core.runnables import RunnableLambda

# 包装函数
rewrite_runnable = RunnableLambda(rewrite_query)

# 现在可以集成到链中
chain = rewrite_runnable | retriever | llm  # ✅ 成功！
```

---

## 设计原则

### 原则 1：最小惊讶原则（Principle of Least Astonishment）

**定义**：系统的行为应该符合用户的直觉预期

**RunnablePassthrough 的体现**：
```python
# 直觉：透传 = 输入不变
passthrough = RunnablePassthrough()
result = passthrough.invoke("hello")
assert result == "hello"  # ✅ 符合预期

# 直觉：assign = 添加字段，不是替换
result = RunnablePassthrough.assign(new="value").invoke({"old": "data"})
assert "old" in result  # ✅ 原始数据保留
assert "new" in result  # ✅ 新字段添加
```

**RunnableLambda 的体现**：
```python
# 直觉：包装后的函数行为不变
def add_one(x):
    return x + 1

wrapped = RunnableLambda(add_one)
assert wrapped.invoke(5) == add_one(5)  # ✅ 行为一致
```

---

### 原则 2：组合优于继承（Composition over Inheritance）

**定义**：通过组合小的、独立的组件来构建复杂系统

**体现**：
```python
# 不是通过继承扩展功能
class MyCustomRetriever(Retriever):  # ❌ 复杂
    def _get_relevant_documents(self, query):
        # 自定义逻辑
        pass

# 而是通过组合
chain = (
    RunnableLambda(preprocess)      # 预处理
    | retriever                      # 标准检索器
    | RunnableLambda(postprocess)   # 后处理
)  # ✅ 简单、灵活
```

**优势**：
- ✅ 每个组件职责单一
- ✅ 可以灵活重组
- ✅ 易于测试和维护
- ✅ 不需要理解复杂的继承层次

---

### 原则 3：接口隔离原则（Interface Segregation Principle）

**定义**：客户端不应该依赖它不需要的接口

**RunnablePassthrough 的体现**：
```python
# 只提供必要的接口
class RunnablePassthrough:
    def invoke(self, input):
        return input  # 最简单的实现

    @classmethod
    def assign(cls, **kwargs):
        # 扩展功能，但不强制使用
        pass
```

**RunnableLambda 的体现**：
```python
# 用户只需提供函数，不需要实现完整的 Runnable 接口
def my_func(x):
    return x.upper()

# RunnableLambda 负责实现所有 Runnable 方法
wrapped = RunnableLambda(my_func)
# 自动提供：invoke, ainvoke, batch, abatch, stream, astream 等
```

---

## 底层实现原理

### RunnablePassthrough 的实现

**核心思想**：Identity Function（恒等函数）

```python
# 简化的实现（实际更复杂）
class RunnablePassthrough(Runnable):
    """透传 Runnable：输入 = 输出"""

    def invoke(self, input: Input) -> Input:
        """直接返回输入"""
        return input

    @classmethod
    def assign(cls, **kwargs) -> Runnable:
        """创建一个扩展输入的 Runnable"""
        return RunnableAssign(kwargs)


class RunnableAssign(Runnable):
    """扩展输入的 Runnable"""

    def __init__(self, mappers: dict):
        self.mappers = mappers

    def invoke(self, input: dict) -> dict:
        """保留输入 + 添加新字段"""
        output = input.copy()  # 复制输入（避免修改原对象）

        for key, mapper in self.mappers.items():
            if callable(mapper):
                output[key] = mapper(input)  # 调用函数
            elif isinstance(mapper, Runnable):
                output[key] = mapper.invoke(input)  # 调用 Runnable
            else:
                output[key] = mapper  # 直接赋值

        return output
```

**关键设计决策**：

1. **为什么 assign 是类方法？**
   ```python
   # 类方法：不需要实例化
   chain = RunnablePassthrough.assign(key=func)  # ✅ 简洁

   # 如果是实例方法
   chain = RunnablePassthrough().assign(key=func)  # ❌ 冗余
   ```

2. **为什么 assign 返回新的 Runnable？**
   ```python
   # 不可变设计：不修改原对象
   base = RunnablePassthrough()
   extended = base.assign(key=func)
   # base 和 extended 是不同的对象
   ```

3. **为什么支持多种 mapper 类型？**
   ```python
   # 灵活性：支持函数、Runnable、常量
   chain = RunnablePassthrough.assign(
       const="value",              # 常量
       func=lambda x: x["key"],    # 函数
       runnable=retriever          # Runnable
   )
   ```

---

### RunnableLambda 的实现

**核心思想**：Adapter Pattern（适配器模式）

```python
# 简化的实现
class RunnableLambda(Runnable):
    """将函数包装为 Runnable"""

    def __init__(self, func):
        self.func = func
        self.is_async = asyncio.iscoroutinefunction(func)

    def invoke(self, input: Input) -> Output:
        """同步调用"""
        if self.is_async:
            # 异步函数在同步上下文中调用
            raise RuntimeError("Use ainvoke for async functions")
        return self.func(input)

    async def ainvoke(self, input: Input) -> Output:
        """异步调用"""
        if self.is_async:
            return await self.func(input)
        else:
            # 同步函数在异步上下文中调用
            return self.func(input)

    def batch(self, inputs: list[Input]) -> list[Output]:
        """批量调用"""
        return [self.invoke(input) for input in inputs]

    async def abatch(self, inputs: list[Input]) -> list[Output]:
        """异步批量调用"""
        if self.is_async:
            return await asyncio.gather(*[self.ainvoke(input) for input in inputs])
        else:
            return [self.invoke(input) for input in inputs]
```

**关键设计决策**：

1. **为什么自动检测同步/异步？**
   ```python
   # 用户体验：不需要手动指定
   sync_lambda = RunnableLambda(sync_func)    # 自动识别
   async_lambda = RunnableLambda(async_func)  # 自动识别
   ```

2. **为什么提供 invoke 和 ainvoke？**
   ```python
   # 统一接口：所有 Runnable 都有这两个方法
   result = runnable.invoke(input)      # 同步
   result = await runnable.ainvoke(input)  # 异步
   ```

3. **为什么支持批处理？**
   ```python
   # 性能优化：批量处理更高效
   results = runnable.batch([input1, input2, input3])
   ```

---

## 类型系统设计

### RunnablePassthrough 的类型

```python
from typing import TypeVar

Input = TypeVar("Input")

class RunnablePassthrough(Runnable[Input, Input]):
    """
    类型签名：Runnable[Input, Input]
    含义：输入类型 = 输出类型
    """
    pass

# 使用
passthrough: Runnable[str, str] = RunnablePassthrough()
passthrough: Runnable[dict, dict] = RunnablePassthrough()
# 类型系统自动推断
```

### RunnableLambda 的类型

```python
from typing import TypeVar, Callable

Input = TypeVar("Input")
Output = TypeVar("Output")

class RunnableLambda(Runnable[Input, Output]):
    """
    类型签名：Runnable[Input, Output]
    含义：输入类型和输出类型由函数决定
    """

    def __init__(self, func: Callable[[Input], Output]):
        self.func = func

# 使用
def process(x: str) -> int:
    return len(x)

lambda_runnable: Runnable[str, int] = RunnableLambda(process)
# 类型系统自动推断：str → int
```

### 类型推断的优势

```python
# 编译时类型检查
chain = (
    RunnableLambda(lambda x: x.upper())  # str → str
    | RunnableLambda(lambda x: len(x))   # str → int
    | RunnableLambda(lambda x: x * 2)    # int → int
)

# 类型系统知道：
# - 输入类型：str
# - 输出类型：int
# - 中间类型：str → int

# 如果类型不匹配，IDE 会提示错误
chain = (
    RunnableLambda(lambda x: x.upper())  # str → str
    | RunnableLambda(lambda x: x + 1)    # ❌ 类型错误：str 不能 +1
)
```

---

## 性能考虑

### RunnablePassthrough 的性能

**问题**：assign() 会复制数据吗？

```python
# 实现细节
def invoke(self, input: dict) -> dict:
    output = input.copy()  # 浅拷贝
    # ...
    return output
```

**性能分析**：
- ✅ 浅拷贝：只复制字典结构，不复制值
- ✅ 时间复杂度：O(n)，n 是字典键的数量
- ✅ 空间复杂度：O(n)，但值是引用，不占额外空间

**实际影响**：
```python
# 大数据场景
large_data = {
    "query": "hello",
    "embeddings": np.array([...])  # 1GB 的向量
}

# assign 不会复制 embeddings 数组
result = RunnablePassthrough.assign(context=retriever).invoke(large_data)
# 内存占用：~1GB（不是 2GB）
```

---

### RunnableLambda 的性能

**问题**：包装函数有性能开销吗？

**性能分析**：
```python
import time

def simple_func(x):
    return x + 1

# 直接调用
start = time.time()
for _ in range(1000000):
    simple_func(5)
direct_time = time.time() - start

# 通过 RunnableLambda 调用
wrapped = RunnableLambda(simple_func)
start = time.time()
for _ in range(1000000):
    wrapped.invoke(5)
wrapped_time = time.time() - start

print(f"直接调用: {direct_time:.3f}秒")
print(f"包装调用: {wrapped_time:.3f}秒")
print(f"开销: {(wrapped_time - direct_time) / direct_time * 100:.1f}%")

# 输出示例：
# 直接调用: 0.050秒
# 包装调用: 0.055秒
# 开销: 10.0%
```

**结论**：
- 包装开销：约 10%（可忽略）
- 主要开销来自函数调用本身
- 在实际应用中（LLM 调用、检索等），包装开销可忽略不计

---

## 设计权衡

### 权衡 1：灵活性 vs 性能

**RunnablePassthrough.assign() 的设计**：

```python
# 方案 A：每次都创建新对象（当前实现）
def assign(self, **kwargs):
    return RunnableAssign(kwargs)  # 新对象

# 优点：不可变，线程安全
# 缺点：每次调用都创建对象

# 方案 B：修改现有对象
def assign(self, **kwargs):
    self.mappers.update(kwargs)  # 修改自身
    return self

# 优点：性能更好
# 缺点：可变，不线程安全
```

**选择**：方案 A（灵活性优先）
- 不可变设计更安全
- 性能开销可忽略（对象创建很快）
- 符合函数式编程范式

---

### 权衡 2：自动化 vs 显式控制

**RunnableLambda 的异步检测**：

```python
# 方案 A：自动检测（当前实现）
lambda_runnable = RunnableLambda(func)  # 自动识别同步/异步

# 优点：用户体验好
# 缺点：可能出现意外行为

# 方案 B：显式指定
lambda_runnable = RunnableLambda(func, is_async=True)

# 优点：明确控制
# 缺点：用户体验差
```

**选择**：方案 A（自动化优先）
- 99% 的情况下自动检测正确
- 用户体验更好
- 如果需要显式控制，可以使用其他方法

---

### 权衡 3：简单性 vs 功能完整性

**RunnablePassthrough 的接口**：

```python
# 方案 A：最小接口（当前实现）
class RunnablePassthrough:
    def invoke(self, input):
        return input

    @classmethod
    def assign(cls, **kwargs):
        pass

# 优点：简单易懂
# 缺点：功能有限

# 方案 B：丰富接口
class RunnablePassthrough:
    def invoke(self, input):
        pass

    def assign(self, **kwargs):
        pass

    def filter(self, predicate):
        pass

    def map(self, func):
        pass

    def reduce(self, func):
        pass

# 优点：功能丰富
# 缺点：复杂，学习成本高
```

**选择**：方案 A（简单性优先）
- 80% 的场景只需要 assign()
- 其他功能可以通过组合实现
- 保持接口简洁

---

## 与其他设计模式的关系

### 1. Identity Function（恒等函数）

**RunnablePassthrough 就是恒等函数**：

```python
# 数学定义
f(x) = x

# RunnablePassthrough 实现
class RunnablePassthrough:
    def invoke(self, input):
        return input  # f(x) = x
```

**用途**：
- 占位符：在链中保留位置
- 数据传递：不做任何转换
- 组合基础：与其他 Runnable 组合

---

### 2. Adapter Pattern（适配器模式）

**RunnableLambda 是适配器**：

```
普通函数（不兼容的接口）
    ↓
RunnableLambda（适配器）
    ↓
Runnable 接口（统一接口）
```

**优势**：
- 不修改原函数
- 提供统一接口
- 灵活集成

---

### 3. Decorator Pattern（装饰器模式）

**with_retry() 是装饰器**：

```python
# 原始 Runnable
base = RunnableLambda(func)

# 添加重试功能（装饰）
decorated = base.with_retry(stop_after_attempt=3)

# 不修改原对象，返回新对象
```

**优势**：
- 动态添加功能
- 不修改原对象
- 可以叠加多个装饰器

---

### 4. Builder Pattern（建造者模式）

**链式组合是建造者模式**：

```python
# 逐步构建复杂对象
chain = (
    RunnableLambda(preprocess)      # 步骤 1
    | RunnablePassthrough.assign(context=retriever)  # 步骤 2
    | prompt                         # 步骤 3
    | llm                           # 步骤 4
    | StrOutputParser()             # 步骤 5
)

# 每一步都返回新的 Runnable
# 最终构建出完整的处理管道
```

---

## 哲学思考

### 为什么需要"透传"？

**表面原因**：保留数据

**深层原因**：
1. **信息守恒**：数据流动中不应丢失信息
2. **上下文保持**：后续环节需要访问原始输入
3. **可追溯性**：调试时需要知道原始输入

**类比**：
- 快递包裹：包裹本身（数据）+ 快递单（元数据）
- HTTP 请求：请求体（数据）+ 请求头（元数据）
- 函数调用：参数（数据）+ 调用栈（上下文）

---

### 为什么需要"包装"？

**表面原因**：集成自定义函数

**深层原因**：
1. **抽象统一**：不同的实现，统一的接口
2. **组合能力**：小组件组合成大系统
3. **扩展性**：不修改原有代码，添加新功能

**类比**：
- 电源适配器：不同电压 → 统一接口
- USB 接口：不同设备 → 统一协议
- API 网关：不同服务 → 统一入口

---

## 总结：第一性原理

### 核心问题

1. **数据丢失**：链式处理中如何保留原始输入？
2. **接口不统一**：如何集成任意函数到标准链中？

### 设计原则

1. **最小惊讶**：行为符合直觉
2. **组合优于继承**：小组件灵活组合
3. **接口隔离**：只提供必要的接口

### 实现策略

1. **RunnablePassthrough**：恒等函数 + assign 扩展
2. **RunnableLambda**：适配器模式 + 自动检测

### 设计权衡

1. **灵活性 > 性能**：不可变设计
2. **自动化 > 显式**：自动检测同步/异步
3. **简单性 > 功能**：最小接口

---

## 学习检查

**能否回答以下问题？**

1. **Q**: 为什么需要 RunnablePassthrough？
   - **A**: 解决链式处理中的数据丢失问题，保留原始输入

2. **Q**: 为什么 assign() 是类方法？
   - **A**: 不需要实例化，使用更简洁

3. **Q**: 为什么 RunnableLambda 自动检测同步/异步？
   - **A**: 提升用户体验，99% 的情况下自动检测正确

4. **Q**: RunnablePassthrough.assign() 会复制大数据吗？
   - **A**: 不会，只是浅拷贝字典结构，值是引用

5. **Q**: RunnableLambda 的包装开销大吗？
   - **A**: 约 10%，在实际应用中可忽略不计

**如果以上都能回答，说明已理解第一性原理；否则需要重读相关部分。**

---

**下一步**：
- 学习 `03_核心概念_*.md` 了解详细机制
- 查看 `07_实战代码_*.md` 应用这些原理
- 思考：如果你来设计，会怎么做？

---

**参考资料**：
- [LangChain GitHub 源码](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/runnables/passthrough.py) (2025)
- [Guide to LangChain Runnable Architecture](https://dzone.com/articles/guide-to-langchain-runnable-architecture) (2025)
- [Understanding LangChain Runnables](https://mirascope.com/blog/langchain-runnables) (2025)

---

**版本**：v1.0
**最后更新**：2026-02-18
