# 实战代码 02：RRF融合实现

> **场景**：实现 Reciprocal Rank Fusion (RRF) 算法，融合多路检索结果

---

## 场景概述

**业务需求**：
- 同时运行 BM25 和向量检索
- 使用 RRF 算法融合结果
- 支持多路检索融合
- 可调节 k 参数

**技术要点**：
- RRF 公式：`score = Σ(1/(k + rank_i))`
- 基于排名而非分数
- k 参数默认 60
- 多路结果融合

---

## 完整代码实现

### 1. 基础 RRF 实现

```python
"""
RRF 融合算法实现
"""
from typing import List, Dict, Any
from dataclasses import dataclass
import math


@dataclass
class SearchResult:
    """检索结果"""
    doc_id: str
    content: str
    score: float
    source: str  # "bm25" or "vector"
    rank: int = 0


class RRFFusion:
    """RRF 融合器"""

    def __init__(self, k: int = 60):
        """
        初始化 RRF 融合器

        Args:
            k: RRF 参数，控制排名权重衰减速度
               - k 越大，排名差异影响越小
               - k 越小，排名差异影响越大
               - 默认 60（OpenSearch/Elasticsearch 标准）
        """
        self.k = k

    def fuse(
        self,
        results_list: List[List[SearchResult]],
    ) -> List[SearchResult]:
        """
        融合多路检索结果

        Args:
            results_list: 多路检索结果列表
                         每路结果已按分数排序

        Returns:
            融合后的结果列表
        """
        # 1. 为每路结果分配排名
        for results in results_list:
            for rank, result in enumerate(results, start=1):
                result.rank = rank

        # 2. 计算每个文档的 RRF 分数
        doc_scores: Dict[str, float] = {}
        doc_map: Dict[str, SearchResult] = {}

        for results in results_list:
            for result in results:
                doc_id = result.doc_id

                # RRF 公式：1 / (k + rank)
                rrf_score = 1.0 / (self.k + result.rank)

                # 累加分数（多路融合）
                if doc_id in doc_scores:
                    doc_scores[doc_id] += rrf_score
                else:
                    doc_scores[doc_id] = rrf_score
                    doc_map[doc_id] = result

        # 3. 按 RRF 分数排序
        sorted_docs = sorted(
            doc_scores.items(),
            key=lambda x: x[1],
            reverse=True
        )

        # 4. 构建最终结果
        fused_results = []
        for doc_id, rrf_score in sorted_docs:
            result = doc_map[doc_id]
            result.score = rrf_score  # 更新为 RRF 分数
            fused_results.append(result)

        return fused_results

    def explain_score(
        self,
        doc_id: str,
        results_list: List[List[SearchResult]],
    ) -> Dict[str, Any]:
        """
        解释某个文档的 RRF 分数计算过程

        Args:
            doc_id: 文档 ID
            results_list: 多路检索结果

        Returns:
            分数解释信息
        """
        explanation = {
            "doc_id": doc_id,
            "k": self.k,
            "sources": [],
            "total_score": 0.0
        }

        for i, results in enumerate(results_list):
            for result in results:
                if result.doc_id == doc_id:
                    rrf_score = 1.0 / (self.k + result.rank)
                    explanation["sources"].append({
                        "source": result.source,
                        "rank": result.rank,
                        "original_score": result.score,
                        "rrf_score": rrf_score,
                        "formula": f"1 / ({self.k} + {result.rank}) = {rrf_score:.6f}"
                    })
                    explanation["total_score"] += rrf_score

        return explanation


# 示例使用
if __name__ == "__main__":
    # 模拟 BM25 结果
    bm25_results = [
        SearchResult("doc1", "Python programming", 15.2, "bm25"),
        SearchResult("doc2", "Machine learning", 12.8, "bm25"),
        SearchResult("doc3", "Data science", 10.5, "bm25"),
    ]

    # 模拟向量检索结果
    vector_results = [
        SearchResult("doc2", "Machine learning", 0.92, "vector"),
        SearchResult("doc4", "Deep learning", 0.88, "vector"),
        SearchResult("doc1", "Python programming", 0.85, "vector"),
    ]

    # RRF 融合
    fusion = RRFFusion(k=60)
    fused = fusion.fuse([bm25_results, vector_results])

    print("=== RRF 融合结果 ===")
    for i, result in enumerate(fused, 1):
        print(f"{i}. {result.doc_id}: {result.score:.6f} ({result.source})")

    # 解释分数
    print("\n=== doc2 分数解释 ===")
    explanation = fusion.explain_score("doc2", [bm25_results, vector_results])
    print(f"文档: {explanation['doc_id']}")
    print(f"k 参数: {explanation['k']}")
    for source in explanation["sources"]:
        print(f"  来源: {source['source']}")
        print(f"  排名: {source['rank']}")
        print(f"  原始分数: {source['original_score']}")
        print(f"  RRF 分数: {source['rrf_score']:.6f}")
        print(f"  公式: {source['formula']}")
    print(f"总分: {explanation['total_score']:.6f}")
```

**输出示例**：
```
=== RRF 融合结果 ===
1. doc2: 0.032680 (bm25)
2. doc1: 0.032680 (bm25)
3. doc3: 0.015873 (bm25)
4. doc4: 0.016129 (vector)

=== doc2 分数解释 ===
文档: doc2
k 参数: 60
  来源: bm25
  排名: 2
  原始分数: 12.8
  RRF 分数: 0.016129
  公式: 1 / (60 + 2) = 0.016129
  来源: vector
  排名: 1
  原始分数: 0.92
  RRF 分数: 0.016393
  公式: 1 / (60 + 1) = 0.016393
总分: 0.032522
```

---

### 2. 集成 ChromaDB 的 RRF 实现

```python
"""
集成 ChromaDB 的 RRF 混合检索
"""
import chromadb
from chromadb.utils import embedding_functions
from typing import List, Dict, Any
import os
from dotenv import load_dotenv

load_dotenv()


class HybridSearchWithRRF:
    """混合检索 + RRF 融合"""

    def __init__(
        self,
        collection_name: str = "hybrid_docs",
        k: int = 60
    ):
        """
        初始化混合检索系统

        Args:
            collection_name: 集合名称
            k: RRF 参数
        """
        # 初始化 ChromaDB
        self.client = chromadb.Client()

        # 创建或获取集合
        self.embedding_fn = embedding_functions.OpenAIEmbeddingFunction(
            api_key=os.getenv("OPENAI_API_KEY"),
            model_name="text-embedding-3-small"
        )

        self.collection = self.client.get_or_create_collection(
            name=collection_name,
            embedding_function=self.embedding_fn
        )

        # RRF 融合器
        self.rrf = RRFFusion(k=k)

    def add_documents(
        self,
        documents: List[str],
        metadatas: List[Dict[str, Any]] = None,
        ids: List[str] = None
    ):
        """添加文档"""
        if ids is None:
            ids = [f"doc_{i}" for i in range(len(documents))]

        self.collection.add(
            documents=documents,
            metadatas=metadatas,
            ids=ids
        )

    def bm25_search(
        self,
        query: str,
        top_k: int = 10
    ) -> List[SearchResult]:
        """
        BM25 稀疏检索（简化实现）

        注意：ChromaDB 不原生支持 BM25
        这里使用关键词匹配模拟
        实际生产应使用 Elasticsearch 或 BM25S 库
        """
        # 获取所有文档
        all_docs = self.collection.get()

        # 简单关键词匹配（模拟 BM25）
        query_terms = set(query.lower().split())
        results = []

        for i, doc in enumerate(all_docs["documents"]):
            doc_terms = set(doc.lower().split())
            # 计算交集大小作为分数
            score = len(query_terms & doc_terms)

            if score > 0:
                results.append(SearchResult(
                    doc_id=all_docs["ids"][i],
                    content=doc,
                    score=float(score),
                    source="bm25"
                ))

        # 按分数排序
        results.sort(key=lambda x: x.score, reverse=True)
        return results[:top_k]

    def vector_search(
        self,
        query: str,
        top_k: int = 10
    ) -> List[SearchResult]:
        """向量稠密检索"""
        results = self.collection.query(
            query_texts=[query],
            n_results=top_k
        )

        search_results = []
        for i in range(len(results["ids"][0])):
            search_results.append(SearchResult(
                doc_id=results["ids"][0][i],
                content=results["documents"][0][i],
                score=1.0 - results["distances"][0][i],  # 转换为相似度
                source="vector"
            ))

        return search_results

    def hybrid_search(
        self,
        query: str,
        top_k: int = 10,
        bm25_top_k: int = 20,
        vector_top_k: int = 20
    ) -> List[SearchResult]:
        """
        混合检索 + RRF 融合

        Args:
            query: 查询文本
            top_k: 最终返回结果数
            bm25_top_k: BM25 检索数量
            vector_top_k: 向量检索数量

        Returns:
            融合后的结果
        """
        # 1. 并行运行两种检索
        bm25_results = self.bm25_search(query, bm25_top_k)
        vector_results = self.vector_search(query, vector_top_k)

        print(f"BM25 检索到 {len(bm25_results)} 个结果")
        print(f"向量检索到 {len(vector_results)} 个结果")

        # 2. RRF 融合
        fused_results = self.rrf.fuse([bm25_results, vector_results])

        # 3. 返回 top_k
        return fused_results[:top_k]


# 示例使用
if __name__ == "__main__":
    # 初始化系统
    hybrid_search = HybridSearchWithRRF(
        collection_name="rag_docs",
        k=60
    )

    # 添加文档
    documents = [
        "Python is a high-level programming language",
        "Machine learning is a subset of artificial intelligence",
        "Deep learning uses neural networks with multiple layers",
        "Natural language processing enables computers to understand text",
        "RAG combines retrieval and generation for better AI responses",
        "Vector databases store embeddings for semantic search",
        "BM25 is a ranking function used in information retrieval",
        "Hybrid search combines keyword and semantic search methods"
    ]

    hybrid_search.add_documents(documents)

    # 执行混合检索
    query = "What is machine learning and deep learning?"
    results = hybrid_search.hybrid_search(query, top_k=5)

    print("\n=== 混合检索结果（RRF 融合）===")
    for i, result in enumerate(results, 1):
        print(f"\n{i}. {result.doc_id} (RRF分数: {result.score:.6f})")
        print(f"   来源: {result.source}")
        print(f"   内容: {result.content}")
```

---

### 3. k 参数影响实验

```python
"""
实验：k 参数对 RRF 结果的影响
"""
import matplotlib.pyplot as plt
import numpy as np


def experiment_k_parameter():
    """实验不同 k 值的影响"""

    # 模拟数据
    bm25_results = [
        SearchResult("doc1", "content1", 20.0, "bm25"),
        SearchResult("doc2", "content2", 15.0, "bm25"),
        SearchResult("doc3", "content3", 10.0, "bm25"),
    ]

    vector_results = [
        SearchResult("doc2", "content2", 0.95, "vector"),
        SearchResult("doc4", "content4", 0.90, "vector"),
        SearchResult("doc1", "content1", 0.85, "vector"),
    ]

    # 测试不同 k 值
    k_values = [1, 10, 30, 60, 100, 200]
    results_by_k = {}

    for k in k_values:
        fusion = RRFFusion(k=k)
        fused = fusion.fuse([bm25_results, vector_results])
        results_by_k[k] = fused

    # 打印结果
    print("=== k 参数影响实验 ===\n")
    for k, results in results_by_k.items():
        print(f"k = {k}:")
        for i, result in enumerate(results[:3], 1):
            print(f"  {i}. {result.doc_id}: {result.score:.6f}")
        print()

    # 可视化
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))
    axes = axes.flatten()

    for idx, k in enumerate(k_values):
        results = results_by_k[k]
        doc_ids = [r.doc_id for r in results]
        scores = [r.score for r in results]

        axes[idx].bar(doc_ids, scores)
        axes[idx].set_title(f'k = {k}')
        axes[idx].set_ylabel('RRF Score')
        axes[idx].tick_params(axis='x', rotation=45)

    plt.tight_layout()
    plt.savefig('rrf_k_parameter_experiment.png')
    print("图表已保存: rrf_k_parameter_experiment.png")


if __name__ == "__main__":
    experiment_k_parameter()
```

**实验结论**：
- **k = 1-10**：排名差异影响极大，前几名占绝对优势
- **k = 60**：平衡排名和多样性（标准值）
- **k = 100-200**：排名差异影响减小，更多文档有机会

---

### 4. 多路融合（3路以上）

```python
"""
多路检索融合示例
"""


class MultiSourceRRF:
    """多源 RRF 融合"""

    def __init__(self, k: int = 60):
        self.rrf = RRFFusion(k=k)

    def search_multiple_sources(
        self,
        query: str,
        top_k: int = 10
    ) -> List[SearchResult]:
        """
        从多个来源检索并融合

        来源：
        1. BM25 精确匹配
        2. 向量语义检索
        3. 查询扩展后的向量检索
        """
        # 来源1：BM25
        bm25_results = self._bm25_search(query)

        # 来源2：向量检索
        vector_results = self._vector_search(query)

        # 来源3：查询扩展
        expanded_query = self._expand_query(query)
        expanded_results = self._vector_search(expanded_query)

        # 标记来源
        for r in bm25_results:
            r.source = "bm25"
        for r in vector_results:
            r.source = "vector"
        for r in expanded_results:
            r.source = "expanded"

        # RRF 融合三路结果
        fused = self.rrf.fuse([
            bm25_results,
            vector_results,
            expanded_results
        ])

        return fused[:top_k]

    def _bm25_search(self, query: str) -> List[SearchResult]:
        """BM25 检索（模拟）"""
        # 实际实现...
        return []

    def _vector_search(self, query: str) -> List[SearchResult]:
        """向量检索（模拟）"""
        # 实际实现...
        return []

    def _expand_query(self, query: str) -> str:
        """查询扩展（模拟）"""
        # 实际实现：使用 LLM 扩展查询
        return query + " related concepts"
```

---

## RAG 应用场景

### 场景1：文档问答系统

```python
"""
RAG 文档问答 + RRF
"""
from openai import OpenAI

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))


def rag_qa_with_rrf(
    question: str,
    hybrid_search: HybridSearchWithRRF,
    top_k: int = 3
) -> str:
    """
    RAG 问答（使用 RRF 混合检索）

    Args:
        question: 用户问题
        hybrid_search: 混合检索系统
        top_k: 检索文档数

    Returns:
        生成的答案
    """
    # 1. 混合检索（RRF 融合）
    results = hybrid_search.hybrid_search(question, top_k=top_k)

    # 2. 构建上下文
    context = "\n\n".join([
        f"文档 {i+1}:\n{r.content}"
        for i, r in enumerate(results)
    ])

    # 3. 生成答案
    prompt = f"""基于以下文档回答问题。

文档：
{context}

问题：{question}

答案："""

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "你是一个helpful的助手，基于提供的文档回答问题。"},
            {"role": "user", "content": prompt}
        ],
        temperature=0.7
    )

    return response.choices[0].message.content


# 使用示例
if __name__ == "__main__":
    hybrid_search = HybridSearchWithRRF()
    # ... 添加文档 ...

    question = "What is the difference between machine learning and deep learning?"
    answer = rag_qa_with_rrf(question, hybrid_search)
    print(f"问题: {question}")
    print(f"答案: {answer}")
```

---

## 性能对比

### RRF vs 简单合并

```python
"""
对比 RRF 与简单结果合并
"""


def simple_merge(
    results_list: List[List[SearchResult]]
) -> List[SearchResult]:
    """简单合并：直接拼接并去重"""
    seen = set()
    merged = []

    for results in results_list:
        for result in results:
            if result.doc_id not in seen:
                seen.add(result.doc_id)
                merged.append(result)

    return merged


def compare_fusion_methods():
    """对比融合方法"""
    # 模拟数据
    bm25_results = [
        SearchResult("doc1", "content1", 20.0, "bm25"),
        SearchResult("doc2", "content2", 15.0, "bm25"),
        SearchResult("doc3", "content3", 10.0, "bm25"),
    ]

    vector_results = [
        SearchResult("doc2", "content2", 0.95, "vector"),
        SearchResult("doc4", "content4", 0.90, "vector"),
        SearchResult("doc1", "content1", 0.85, "vector"),
    ]

    # 方法1：简单合并
    simple_merged = simple_merge([bm25_results, vector_results])

    # 方法2：RRF 融合
    rrf = RRFFusion(k=60)
    rrf_fused = rrf.fuse([bm25_results, vector_results])

    print("=== 简单合并 ===")
    for i, r in enumerate(simple_merged, 1):
        print(f"{i}. {r.doc_id}: {r.score:.4f} ({r.source})")

    print("\n=== RRF 融合 ===")
    for i, r in enumerate(rrf_fused, 1):
        print(f"{i}. {r.doc_id}: {r.score:.6f} ({r.source})")


if __name__ == "__main__":
    compare_fusion_methods()
```

**对比结论**：
- **简单合并**：保留原始分数，但不同来源分数不可比
- **RRF 融合**：基于排名，分数可比，更合理

---

## 生产优化建议

### 1. 缓存优化

```python
"""
缓存 RRF 结果
"""
from functools import lru_cache
import hashlib


class CachedRRFFusion(RRFFusion):
    """带缓存的 RRF 融合"""

    @lru_cache(maxsize=1000)
    def fuse_cached(
        self,
        results_tuple: tuple
    ) -> tuple:
        """
        缓存融合结果

        注意：需要将 list 转为 tuple 才能缓存
        """
        results_list = [list(r) for r in results_tuple]
        fused = self.fuse(results_list)
        return tuple(fused)
```

### 2. 并行检索

```python
"""
并行执行多路检索
"""
from concurrent.futures import ThreadPoolExecutor, as_completed


def parallel_hybrid_search(
    query: str,
    hybrid_search: HybridSearchWithRRF,
    top_k: int = 10
) -> List[SearchResult]:
    """并行执行 BM25 和向量检索"""

    with ThreadPoolExecutor(max_workers=2) as executor:
        # 提交任务
        bm25_future = executor.submit(
            hybrid_search.bm25_search, query, 20
        )
        vector_future = executor.submit(
            hybrid_search.vector_search, query, 20
        )

        # 等待完成
        bm25_results = bm25_future.result()
        vector_results = vector_future.result()

    # RRF 融合
    fused = hybrid_search.rrf.fuse([bm25_results, vector_results])
    return fused[:top_k]
```

---

## 研究来源

1. **OpenSearch: Introducing RRF for Hybrid Search**
   - [链接](https://opensearch.org/blog/introducing-reciprocal-rank-fusion-hybrid-search)
   - OpenSearch 2.19 原生支持 RRF

2. **Azure AI Search: RRF Ranking**
   - [链接](https://learn.microsoft.com/en-us/azure/search/hybrid-search-ranking)
   - Azure 混合搜索中的 RRF 实现

3. **Advanced RAG: Understanding RRF**
   - [链接](https://glaforge.dev/posts/2026/02/10/advanced-rag-understanding-reciprocal-rank-fusion-in-hybrid-search)
   - RRF 算法详解

4. **Milvus RRF Ranker**
   - [链接](https://milvus.io/docs/reranking.md)
   - Milvus 向量数据库的 RRF 实现

---

**文件版本**: v1.0
**最后更新**: 2026-02-16
**代码状态**: ✅ 完整可运行
