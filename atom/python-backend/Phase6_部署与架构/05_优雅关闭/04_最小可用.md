# 最小可用知识

> 掌握以下内容，就能在 FastAPI 应用中实现基础的优雅关闭

---

## 核心概念

优雅关闭的最小可用知识包含4个核心部分：

1. **信号处理**：捕获 SIGTERM 信号
2. **请求排空**：停止接收新请求，等待现有请求完成
3. **资源清理**：关闭数据库连接、Redis 连接等
4. **超时控制**：设置最大等待时间

---

## 4.1 信号处理：捕获 SIGTERM

**核心概念：** 操作系统通过信号通知进程终止，我们需要捕获这个信号并启动清理流程。

```python
import signal
import asyncio

# 创建关闭事件
shutdown_event = asyncio.Event()

def signal_handler(signum, frame):
    """信号处理器"""
    print(f"收到信号 {signum}，开始优雅关闭...")
    shutdown_event.set()

# 注册信号处理器
signal.signal(signal.SIGTERM, signal_handler)  # Docker/K8s 发送的信号
signal.signal(signal.SIGINT, signal_handler)   # Ctrl+C 发送的信号
```

**关键点：**
- `SIGTERM`（15）：优雅终止信号，可以捕获
- `SIGINT`（2）：中断信号（Ctrl+C），可以捕获
- `SIGKILL`（9）：强制终止信号，无法捕获
- `shutdown_event`：用于通知其他协程开始关闭

**在 AI Agent 后端中的应用：**
```python
# 在 LLM 流式响应中检查关闭信号
async def stream_llm_response(prompt: str):
    async for chunk in llm.astream(prompt):
        if shutdown_event.is_set():
            # 收到关闭信号，停止生成
            yield {"type": "end", "reason": "shutdown"}
            break
        yield chunk
```

---

## 4.2 请求排空：停止接收新请求

**核心概念：** 在关闭过程中，停止接收新请求，但等待现有请求完成。

```python
from fastapi import FastAPI, Request, HTTPException

app = FastAPI()

# 全局状态
accepting_requests = True
active_requests = 0

@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    """请求排空中间件"""
    global active_requests

    # 如果正在关闭，拒绝新请求
    if not accepting_requests:
        raise HTTPException(
            status_code=503,
            detail="Server is shutting down"
        )

    # 记录活跃请求数
    active_requests += 1
    try:
        response = await call_next(request)
        return response
    finally:
        active_requests -= 1

async def wait_for_requests():
    """等待所有请求完成"""
    global accepting_requests
    accepting_requests = False  # 停止接收新请求

    print(f"等待 {active_requests} 个请求完成...")
    while active_requests > 0:
        await asyncio.sleep(0.1)
    print("所有请求已完成")
```

**关键点：**
- `accepting_requests`：控制是否接收新请求
- `active_requests`：跟踪活跃请求数
- 中间件：在每个请求前后更新计数器
- 等待循环：轮询直到所有请求完成

**在 AI Agent 后端中的应用：**
```python
# 对于长时间运行的 Agent 任务，需要特殊处理
@app.post("/agent/run")
async def run_agent(task: str):
    if not accepting_requests:
        raise HTTPException(503, "Server is shutting down")

    # 标记为长时间任务
    active_requests += 1
    try:
        # Agent 任务可能需要数十秒
        result = await agent.run(task)
        return result
    finally:
        active_requests -= 1
```

---

## 4.3 资源清理：关闭数据库连接

**核心概念：** 在退出前，关闭所有外部连接，避免资源泄漏。

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

# 创建数据库引擎和会话工厂
engine = create_async_engine("postgresql+asyncpg://user:pass@localhost/db")
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def cleanup_database():
    """清理数据库连接"""
    print("关闭数据库连接池...")

    # 等待所有活跃连接完成
    await engine.dispose()

    print("数据库连接池已关闭")
```

**关键点：**
- `engine.dispose()`：关闭连接池，释放所有连接
- 等待活跃连接完成：不会强制中断正在执行的查询
- 避免连接泄漏：确保所有连接都被释放

**在 AI Agent 后端中的应用：**
```python
# 清理所有资源
async def cleanup_all_resources():
    """清理所有资源"""
    # 1. 关闭数据库连接
    await cleanup_database()

    # 2. 关闭 Redis 连接
    if redis_client:
        await redis_client.close()

    # 3. 关闭向量数据库连接
    if vector_db:
        await vector_db.close()

    # 4. 卸载 Embedding 模型
    if embedding_model:
        embedding_model.unload()

    print("所有资源已清理")
```

---

## 4.4 超时控制：避免无限等待

**核心概念：** 设置最大等待时间，避免某些请求卡住导致无法退出。

```python
import asyncio

async def graceful_shutdown(timeout: int = 30):
    """优雅关闭，带超时控制"""
    print(f"开始优雅关闭（超时 {timeout} 秒）...")

    try:
        # 1. 停止接收新请求
        global accepting_requests
        accepting_requests = False

        # 2. 等待现有请求完成（带超时）
        await asyncio.wait_for(
            wait_for_requests(),
            timeout=timeout
        )

        # 3. 清理资源
        await cleanup_all_resources()

        print("优雅关闭完成")

    except asyncio.TimeoutError:
        print(f"优雅关闭超时（{timeout}秒），强制退出")
        # 强制退出
        import os
        os._exit(1)
```

**关键点：**
- `asyncio.wait_for()`：设置超时时间
- `asyncio.TimeoutError`：超时异常
- `os._exit(1)`：强制退出（不执行清理）
- 平衡可靠性和可用性：不能无限等待

**在 AI Agent 后端中的应用：**
```python
# 分阶段超时控制
async def graceful_shutdown_with_stages():
    """分阶段优雅关闭"""
    # 阶段1：等待请求完成（30秒）
    try:
        await asyncio.wait_for(wait_for_requests(), timeout=30)
    except asyncio.TimeoutError:
        print("请求排空超时，取消所有请求")
        # 取消所有活跃请求
        for task in asyncio.all_tasks():
            task.cancel()

    # 阶段2：清理资源（10秒）
    try:
        await asyncio.wait_for(cleanup_all_resources(), timeout=10)
    except asyncio.TimeoutError:
        print("资源清理超时，强制退出")

    # 阶段3：退出
    import sys
    sys.exit(0)
```

---

## 完整的最小可用示例

```python
"""
FastAPI 优雅关闭最小可用示例
演示：信号处理 + 请求排空 + 资源清理 + 超时控制
"""

import signal
import asyncio
from fastapi import FastAPI, Request, HTTPException
from sqlalchemy.ext.asyncio import create_async_engine

# ===== 1. 全局状态 =====
app = FastAPI()
shutdown_event = asyncio.Event()
accepting_requests = True
active_requests = 0

# 数据库引擎（示例）
engine = create_async_engine("postgresql+asyncpg://user:pass@localhost/db")

# ===== 2. 信号处理 =====
def signal_handler(signum, frame):
    """捕获 SIGTERM/SIGINT 信号"""
    print(f"收到信号 {signum}，开始优雅关闭...")
    shutdown_event.set()

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

# ===== 3. 请求排空中间件 =====
@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    """请求排空中间件"""
    global active_requests

    if not accepting_requests:
        raise HTTPException(503, "Server is shutting down")

    active_requests += 1
    try:
        response = await call_next(request)
        return response
    finally:
        active_requests -= 1

# ===== 4. 示例路由 =====
@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/slow")
async def slow_endpoint():
    """模拟慢请求"""
    await asyncio.sleep(5)
    return {"message": "Done"}

# ===== 5. 优雅关闭逻辑 =====
async def wait_for_requests():
    """等待所有请求完成"""
    global accepting_requests
    accepting_requests = False

    print(f"等待 {active_requests} 个请求完成...")
    while active_requests > 0:
        await asyncio.sleep(0.1)
    print("所有请求已完成")

async def cleanup_resources():
    """清理资源"""
    print("关闭数据库连接池...")
    await engine.dispose()
    print("资源清理完成")

async def graceful_shutdown(timeout: int = 30):
    """优雅关闭主流程"""
    print(f"开始优雅关闭（超时 {timeout} 秒）...")

    try:
        # 等待请求完成
        await asyncio.wait_for(wait_for_requests(), timeout=timeout)

        # 清理资源
        await cleanup_resources()

        print("优雅关闭完成")

    except asyncio.TimeoutError:
        print(f"优雅关闭超时（{timeout}秒），强制退出")
        import os
        os._exit(1)

# ===== 6. FastAPI 生命周期事件 =====
@app.on_event("startup")
async def startup_event():
    """应用启动时"""
    print("应用启动")

    # 启动后台任务监听关闭信号
    asyncio.create_task(shutdown_monitor())

@app.on_event("shutdown")
async def shutdown_event_handler():
    """应用关闭时"""
    print("应用关闭")

async def shutdown_monitor():
    """监听关闭信号"""
    await shutdown_event.wait()  # 等待信号
    await graceful_shutdown()    # 执行优雅关闭

# ===== 7. 运行应用 =====
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行示例：**
```bash
# 启动应用
python app.py

# 在另一个终端发送请求
curl http://localhost:8000/slow

# 在请求进行中，发送 SIGTERM 信号
kill -SIGTERM <pid>

# 观察日志：
# 收到信号 15，开始优雅关闭...
# 等待 1 个请求完成...
# 所有请求已完成
# 关闭数据库连接池...
# 资源清理完成
# 优雅关闭完成
```

---

## 这些知识足以

掌握以上4个核心知识点后，你可以：

- ✅ **在 FastAPI 应用中实现基础的优雅关闭**
  - 捕获 SIGTERM 信号
  - 停止接收新请求
  - 等待现有请求完成
  - 关闭数据库连接

- ✅ **避免常见的生产问题**
  - 请求被中断（502 错误）
  - 数据库连接泄漏
  - 数据不一致

- ✅ **为后续学习打基础**
  - 理解优雅关闭的核心流程
  - 掌握信号处理的基本方法
  - 了解资源清理的重要性

---

## 快速检查清单

完成最小可用知识学习后，检查是否能够：

- [ ] 注册 SIGTERM 和 SIGINT 信号处理器
- [ ] 使用 `asyncio.Event` 通知关闭事件
- [ ] 实现请求排空中间件
- [ ] 跟踪活跃请求数
- [ ] 关闭 SQLAlchemy 连接池
- [ ] 使用 `asyncio.wait_for()` 设置超时
- [ ] 处理 `asyncio.TimeoutError` 异常
- [ ] 在 FastAPI 中使用 `@app.on_event("shutdown")`

---

## 下一步学习

掌握最小可用知识后，可以继续学习：

1. **核心概念文件**：深入理解每个组件的原理
   - 03_核心概念_01_信号处理机制.md
   - 03_核心概念_02_请求排空策略.md
   - 03_核心概念_03_资源清理策略.md

2. **实战代码文件**：学习更复杂的实现
   - 07_实战代码_03_数据库连接池优雅关闭.md
   - 07_实战代码_09_生产级优雅关闭系统.md

3. **AI Agent 特定**：处理 AI Agent 的特殊需求
   - 03_核心概念_09_AI_Agent特定清理.md
   - 07_实战代码_08_AI_Agent特定清理.md

---

## 常见问题

### Q1: 为什么需要 `accepting_requests` 标志？

**A:** 因为需要停止接收新请求，但允许现有请求完成。如果不设置这个标志，关闭过程中仍会接收新请求，导致无法退出。

### Q2: 为什么使用 `asyncio.Event` 而不是全局变量？

**A:** `asyncio.Event` 是线程安全的，可以在信号处理器（同步）和协程（异步）之间安全通信。全局变量可能导致竞态条件。

### Q3: 为什么需要超时控制？

**A:** 某些请求可能卡住（网络超时、死锁等），如果无限等待，服务永远无法退出。超时控制确保服务最终会退出。

### Q4: `os._exit(1)` 和 `sys.exit(0)` 有什么区别？

**A:**
- `sys.exit(0)`：正常退出，会执行清理代码（finally 块）
- `os._exit(1)`：强制退出，不执行清理代码，用于超时场景

### Q5: 在 Docker 中如何测试优雅关闭？

**A:**
```bash
# 启动容器
docker run -d --name myapp myapp:latest

# 发送 SIGTERM 信号
docker stop myapp  # 默认等待 10 秒

# 查看日志
docker logs myapp
```

---

## 总结

**最小可用知识的核心：**

1. **信号处理**：`signal.signal(signal.SIGTERM, handler)`
2. **请求排空**：`accepting_requests = False` + `while active_requests > 0`
3. **资源清理**：`await engine.dispose()`
4. **超时控制**：`asyncio.wait_for(task, timeout=30)`

**记住：** 这4个核心知识点是优雅关闭的基础，掌握它们就能实现80%的功能。
