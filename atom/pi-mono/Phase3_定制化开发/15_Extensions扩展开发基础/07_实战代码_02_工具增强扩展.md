# Extensions æ‰©å±•å¼€å‘åŸºç¡€ - å®æˆ˜ä»£ç  02ï¼šå·¥å…·å¢å¼ºæ‰©å±•

> é€šè¿‡ registerTool API æ³¨å†Œè‡ªå®šä¹‰å·¥å…·å’Œè¦†ç›–å†…ç½®å·¥å…·

---

## 1. åœºæ™¯ä»‹ç»

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦å·¥å…·å¢å¼ºæ‰©å±•ï¼Ÿ

åœ¨ AI Agent å¼€å‘ä¸­ï¼Œå†…ç½®å·¥å…·å¯èƒ½æ— æ³•æ»¡è¶³æ‰€æœ‰éœ€æ±‚ï¼š

**åœºæ™¯ 1ï¼šæ·»åŠ æ–°åŠŸèƒ½**
```
éœ€æ±‚ï¼šAgent éœ€è¦æŸ¥è¯¢å¤©æ°”ä¿¡æ¯
é—®é¢˜ï¼šæ²¡æœ‰å†…ç½®çš„å¤©æ°”æŸ¥è¯¢å·¥å…·
è§£å†³ï¼šæ³¨å†Œè‡ªå®šä¹‰ weather å·¥å…·
```

**åœºæ™¯ 2ï¼šå¢å¼ºç°æœ‰å·¥å…·**
```
éœ€æ±‚ï¼šåœ¨è¯»å–æ–‡ä»¶æ—¶è®°å½•è®¿é—®æ—¥å¿—
é—®é¢˜ï¼šå†…ç½® read å·¥å…·æ²¡æœ‰æ—¥å¿—åŠŸèƒ½
è§£å†³ï¼šè¦†ç›– read å·¥å…·ï¼Œæ·»åŠ æ—¥å¿—è®°å½•
```

**åœºæ™¯ 3ï¼šé™åˆ¶å·¥å…·è¡Œä¸º**
```
éœ€æ±‚ï¼šé˜»æ­¢è®¿é—®æ•æ„Ÿæ–‡ä»¶ï¼ˆ.env, secretsï¼‰
é—®é¢˜ï¼šå†…ç½® read å·¥å…·æ²¡æœ‰è®¿é—®æ§åˆ¶
è§£å†³ï¼šè¦†ç›– read å·¥å…·ï¼Œæ·»åŠ è·¯å¾„æ£€æŸ¥
```

### 1.2 å·¥å…·æ³¨å†Œçš„æ ¸å¿ƒæ¦‚å¿µ

**å·¥å…·å®šä¹‰ï¼ˆToolDefinitionï¼‰**ï¼š
```typescript
interface ToolDefinition {
  name: string;              // å·¥å…·åç§°ï¼ˆå”¯ä¸€æ ‡è¯†ï¼‰
  label?: string;            // æ˜¾ç¤ºæ ‡ç­¾
  description: string;       // å·¥å…·æè¿°ï¼ˆLLM ç”¨äºç†è§£å·¥å…·ç”¨é€”ï¼‰
  parameters: TSchema;       // å‚æ•° schemaï¼ˆTypeBoxï¼‰
  execute: ExecuteFunction;  // æ‰§è¡Œå‡½æ•°
  renderCall?: RenderFunction;   // è‡ªå®šä¹‰æ¸²æŸ“ï¼ˆè°ƒç”¨æ—¶ï¼‰
  renderResult?: RenderFunction; // è‡ªå®šä¹‰æ¸²æŸ“ï¼ˆç»“æœæ—¶ï¼‰
}
```

**æ‰§è¡Œå‡½æ•°ï¼ˆExecuteFunctionï¼‰**ï¼š
```typescript
type ExecuteFunction = (
  toolCallId: string,        // å·¥å…·è°ƒç”¨ ID
  params: any,               // å‚æ•°å¯¹è±¡
  signal: AbortSignal,       // å–æ¶ˆä¿¡å·
  onUpdate: UpdateFunction,  // æ›´æ–°å›è°ƒ
  ctx: ToolContext           // å·¥å…·ä¸Šä¸‹æ–‡
) => Promise<ToolResult>;
```

**å·¥å…·ç»“æœï¼ˆToolResultï¼‰**ï¼š
```typescript
interface ToolResult {
  content: Content[];        // è¿”å›å†…å®¹ï¼ˆæ–‡æœ¬ã€å›¾ç‰‡ç­‰ï¼‰
  details?: any;             // é¢å¤–ä¿¡æ¯ï¼ˆç”¨äºçŠ¶æ€æŒä¹…åŒ–ï¼‰
}
```

### 1.3 æŠ€æœ¯è¦ç‚¹

- **TypeBox Schema**ï¼šä½¿ç”¨ TypeBox å®šä¹‰å‚æ•°ç±»å‹ï¼ˆä¸æ˜¯ Zodï¼‰
- **å·¥å…·è¦†ç›–**ï¼šæ³¨å†ŒåŒåå·¥å…·ä¼šè¦†ç›–å†…ç½®å·¥å…·
- **è‡ªå®šä¹‰æ¸²æŸ“**ï¼šå¯é€‰çš„ renderCall/renderResult è‡ªå®šä¹‰æ˜¾ç¤º
- **çŠ¶æ€æŒä¹…åŒ–**ï¼šé€šè¿‡ details å­—æ®µä¿å­˜çŠ¶æ€
- **å¼‚æ­¥æ‰§è¡Œ**ï¼šexecute å‡½æ•°æ˜¯å¼‚æ­¥çš„ï¼Œæ”¯æŒ AbortSignal

---

## 2. å®Œæ•´å®ç°

### 2.1 åŸºç¡€ç‰ˆæœ¬ï¼šhello å·¥å…·

```typescript
/**
 * Hello Tool - æœ€ç®€å•çš„è‡ªå®šä¹‰å·¥å…·ç¤ºä¾‹
 *
 * åŠŸèƒ½ï¼šå‘æŒ‡å®šçš„äººæ‰“æ‹›å‘¼
 */

import { Type } from "@sinclair/typebox";
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "hello",
    label: "Hello",
    description: "A simple greeting tool that says hello to someone",

    // å®šä¹‰å‚æ•° schema
    parameters: Type.Object({
      name: Type.String({
        description: "Name of the person to greet"
      }),
    }),

    // æ‰§è¡Œå‡½æ•°
    async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
      const { name } = params as { name: string };

      return {
        content: [{ type: "text", text: `Hello, ${name}!` }],
        details: { greeted: name },
      };
    },
  });
}
```

### 2.2 è¿›é˜¶ç‰ˆæœ¬ï¼šå¤©æ°”æŸ¥è¯¢å·¥å…·

```typescript
/**
 * Weather Tool - æŸ¥è¯¢å¤©æ°”ä¿¡æ¯
 *
 * åŠŸèƒ½ï¼š
 * - æŸ¥è¯¢æŒ‡å®šåŸå¸‚çš„å¤©æ°”
 * - æ”¯æŒæ¸©åº¦å•ä½é€‰æ‹©ï¼ˆæ‘„æ°åº¦/åæ°åº¦ï¼‰
 * - ç¼“å­˜æŸ¥è¯¢ç»“æœï¼ˆé¿å…é‡å¤è¯·æ±‚ï¼‰
 */

import { Type } from "@sinclair/typebox";
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

// æ¨¡æ‹Ÿå¤©æ°” APIï¼ˆå®é™…åº”ç”¨ä¸­åº”è°ƒç”¨çœŸå® APIï¼‰
interface WeatherData {
  city: string;
  temperature: number;
  condition: string;
  humidity: number;
  windSpeed: number;
}

async function fetchWeather(city: string): Promise<WeatherData> {
  // æ¨¡æ‹Ÿ API å»¶è¿Ÿ
  await new Promise((resolve) => setTimeout(resolve, 500));

  // æ¨¡æ‹Ÿå¤©æ°”æ•°æ®
  return {
    city,
    temperature: Math.floor(Math.random() * 30) + 10,
    condition: ["Sunny", "Cloudy", "Rainy", "Snowy"][Math.floor(Math.random() * 4)],
    humidity: Math.floor(Math.random() * 50) + 30,
    windSpeed: Math.floor(Math.random() * 20) + 5,
  };
}

export default function (pi: ExtensionAPI) {
  // ç¼“å­˜å¤©æ°”æ•°æ®ï¼ˆé¿å…é‡å¤è¯·æ±‚ï¼‰
  const cache = new Map<string, { data: WeatherData; timestamp: number }>();
  const CACHE_TTL = 5 * 60 * 1000; // 5 åˆ†é’Ÿ

  pi.registerTool({
    name: "weather",
    label: "Weather",
    description: "Query weather information for a specific city",

    parameters: Type.Object({
      city: Type.String({
        description: "City name (e.g., 'Beijing', 'New York')"
      }),
      unit: Type.Optional(
        Type.Union([Type.Literal("celsius"), Type.Literal("fahrenheit")], {
          description: "Temperature unit (default: celsius)"
        })
      ),
    }),

    async execute(_toolCallId, params, signal, _onUpdate, _ctx) {
      const { city, unit = "celsius" } = params as {
        city: string;
        unit?: "celsius" | "fahrenheit";
      };

      // æ£€æŸ¥ç¼“å­˜
      const cached = cache.get(city);
      const now = Date.now();

      let weatherData: WeatherData;

      if (cached && now - cached.timestamp < CACHE_TTL) {
        weatherData = cached.data;
      } else {
        // æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
        if (signal.aborted) {
          return {
            content: [{ type: "text", text: "Weather query cancelled" }],
            details: { cancelled: true },
          };
        }

        // è·å–å¤©æ°”æ•°æ®
        try {
          weatherData = await fetchWeather(city);
          cache.set(city, { data: weatherData, timestamp: now });
        } catch (error: any) {
          return {
            content: [
              { type: "text", text: `Failed to fetch weather: ${error.message}` }
            ],
            details: { error: true },
          };
        }
      }

      // è½¬æ¢æ¸©åº¦å•ä½
      let temperature = weatherData.temperature;
      if (unit === "fahrenheit") {
        temperature = Math.round((temperature * 9) / 5 + 32);
      }

      // æ ¼å¼åŒ–è¾“å‡º
      const text = [
        `Weather in ${weatherData.city}:`,
        ``,
        `ğŸŒ¡ï¸  Temperature: ${temperature}Â°${unit === "celsius" ? "C" : "F"}`,
        `â˜ï¸  Condition: ${weatherData.condition}`,
        `ğŸ’§ Humidity: ${weatherData.humidity}%`,
        `ğŸ’¨ Wind Speed: ${weatherData.windSpeed} km/h`,
      ].join("\n");

      return {
        content: [{ type: "text", text }],
        details: {
          city: weatherData.city,
          temperature: weatherData.temperature,
          condition: weatherData.condition,
          cached: !!cached,
        },
      };
    },
  });
}
```

### 2.3 é«˜çº§ç‰ˆæœ¬ï¼šè¦†ç›– read å·¥å…·ï¼ˆæ·»åŠ è®¿é—®æ§åˆ¶ï¼‰

```typescript
/**
 * Read Tool Override - è¦†ç›–å†…ç½® read å·¥å…·
 *
 * åŠŸèƒ½ï¼š
 * - é˜»æ­¢è®¿é—®æ•æ„Ÿæ–‡ä»¶ï¼ˆ.env, secrets, credentialsï¼‰
 * - è®°å½•æ‰€æœ‰æ–‡ä»¶è®¿é—®æ—¥å¿—
 * - ä¿ç•™åŸæœ‰çš„è¯­æ³•é«˜äº®å’Œè¡Œå·æ˜¾ç¤º
 */

import type { TextContent } from "@mariozechner/pi-ai";
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { Type } from "@sinclair/typebox";
import { appendFileSync } from "fs";
import { access, readFile, constants } from "fs/promises";
import { homedir } from "os";
import { join, resolve } from "path";

const LOG_FILE = join(homedir(), ".pi", "agent", "read-access.log");

// æ•æ„Ÿæ–‡ä»¶æ¨¡å¼
const BLOCKED_PATTERNS = [
  /\.env$/,
  /\.env\..+$/,
  /secrets?\.(json|yaml|yml|toml)$/i,
  /credentials?\.(json|yaml|yml|toml)$/i,
  /\/\.ssh\//,
  /\/\.aws\//,
  /\/\.gnupg\//,
];

function isBlockedPath(path: string): boolean {
  return BLOCKED_PATTERNS.some((pattern) => pattern.test(path));
}

function logAccess(path: string, allowed: boolean, reason?: string): void {
  const timestamp = new Date().toISOString();
  const status = allowed ? "ALLOWED" : "BLOCKED";
  const msg = reason ? ` (${reason})` : "";
  const line = `[${timestamp}] ${status}: ${path}${msg}\n`;

  try {
    appendFileSync(LOG_FILE, line);
  } catch {
    // å¿½ç•¥æ—¥å¿—é”™è¯¯
  }
}

const readSchema = Type.Object({
  path: Type.String({
    description: "Path to the file to read (relative or absolute)"
  }),
  offset: Type.Optional(
    Type.Number({
      description: "Line number to start reading from (1-indexed)"
    })
  ),
  limit: Type.Optional(
    Type.Number({
      description: "Maximum number of lines to read"
    })
  ),
});

export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "read", // åŒåè¦†ç›–å†…ç½®å·¥å…·
    label: "read (audited)",
    description:
      "Read the contents of a file with access logging. " +
      "Some sensitive paths (.env, secrets, credentials) are blocked.",
    parameters: readSchema,

    async execute(_toolCallId, params, _signal, _onUpdate, ctx) {
      const { path, offset, limit } = params as {
        path: string;
        offset?: number;
        limit?: number;
      };

      const absolutePath = resolve(ctx.cwd, path);

      // æ£€æŸ¥æ˜¯å¦ä¸ºæ•æ„Ÿè·¯å¾„
      if (isBlockedPath(absolutePath)) {
        logAccess(absolutePath, false, "matches blocked pattern");
        return {
          content: [
            {
              type: "text",
              text:
                `Access denied: "${path}" matches a blocked pattern (sensitive file).\n` +
                `This tool blocks access to .env files, secrets, credentials, ` +
                `and SSH/AWS/GPG directories.`,
            },
          ],
          details: { blocked: true },
        };
      }

      // è®°å½•å…è®¸çš„è®¿é—®
      logAccess(absolutePath, true);

      // æ‰§è¡Œå®é™…çš„æ–‡ä»¶è¯»å–
      try {
        await access(absolutePath, constants.R_OK);
        const content = await readFile(absolutePath, "utf-8");
        const lines = content.split("\n");

        // åº”ç”¨ offset å’Œ limit
        const startLine = offset ? Math.max(0, offset - 1) : 0;
        const endLine = limit ? startLine + limit : lines.length;
        const selectedLines = lines.slice(startLine, endLine);

        // åŸºæœ¬æˆªæ–­ï¼ˆ50KB é™åˆ¶ï¼‰
        let text = selectedLines.join("\n");
        const maxBytes = 50 * 1024;
        if (Buffer.byteLength(text, "utf-8") > maxBytes) {
          text = `${text.slice(0, maxBytes)}\n\n[Output truncated at 50KB]`;
        }

        return {
          content: [{ type: "text", text }] as TextContent[],
          details: { lines: lines.length },
        };
      } catch (error: any) {
        return {
          content: [
            { type: "text", text: `Error reading file: ${error.message}` }
          ] as TextContent[],
          details: { error: true },
        };
      }
    },

    // ä¸æä¾› renderCall/renderResultï¼Œä½¿ç”¨å†…ç½®æ¸²æŸ“å™¨
    // ï¼ˆè‡ªåŠ¨è¯­æ³•é«˜äº®ã€è¡Œå·ã€æˆªæ–­è­¦å‘Šç­‰ï¼‰
  });

  // æ³¨å†ŒæŸ¥çœ‹è®¿é—®æ—¥å¿—çš„å‘½ä»¤
  pi.registerCommand("read-log", {
    description: "View the file access log",
    handler: async (_args, ctx) => {
      try {
        const log = await readFile(LOG_FILE, "utf-8");
        const lines = log.trim().split("\n").slice(-20); // æœ€å 20 æ¡
        ctx.ui.notify(`Recent file access:\n${lines.join("\n")}`, "info");
      } catch {
        ctx.ui.notify("No access log found", "info");
      }
    },
  });
}
```

---

## 3. ä»£ç è§£æ

### 3.1 TypeBox Schema å®šä¹‰

```typescript
import { Type } from "@sinclair/typebox";

// åŸºæœ¬ç±»å‹
Type.String({ description: "å­—ç¬¦ä¸²å‚æ•°" })
Type.Number({ description: "æ•°å­—å‚æ•°" })
Type.Boolean({ description: "å¸ƒå°”å‚æ•°" })

// å¯é€‰å‚æ•°
Type.Optional(Type.String({ description: "å¯é€‰å­—ç¬¦ä¸²" }))

// è”åˆç±»å‹ï¼ˆæšä¸¾ï¼‰
Type.Union([
  Type.Literal("celsius"),
  Type.Literal("fahrenheit")
], { description: "æ¸©åº¦å•ä½" })

// å¯¹è±¡ç±»å‹
Type.Object({
  name: Type.String({ description: "åç§°" }),
  age: Type.Optional(Type.Number({ description: "å¹´é¾„" })),
})

// æ•°ç»„ç±»å‹
Type.Array(Type.String({ description: "å­—ç¬¦ä¸²æ•°ç»„" }))
```

**ä¸ºä»€ä¹ˆä½¿ç”¨ TypeBox è€Œä¸æ˜¯ Zodï¼Ÿ**
- TypeBox ç”Ÿæˆæ ‡å‡†çš„ JSON Schema
- æ›´è½»é‡ï¼ˆæ— è¿è¡Œæ—¶éªŒè¯å¼€é”€ï¼‰
- pi-mono å†…ç½®æ”¯æŒ TypeBox

### 3.2 æ‰§è¡Œå‡½æ•°å‚æ•°

```typescript
async execute(
  toolCallId: string,        // å·¥å…·è°ƒç”¨ IDï¼ˆå”¯ä¸€æ ‡è¯†ï¼‰
  params: any,               // å‚æ•°å¯¹è±¡ï¼ˆå·²éªŒè¯ï¼‰
  signal: AbortSignal,       // å–æ¶ˆä¿¡å·
  onUpdate: UpdateFunction,  // æ›´æ–°å›è°ƒï¼ˆæµå¼è¾“å‡ºï¼‰
  ctx: ToolContext           // å·¥å…·ä¸Šä¸‹æ–‡
) {
  // 1. ç±»å‹æ–­è¨€
  const { city, unit } = params as { city: string; unit?: string };

  // 2. æ£€æŸ¥å–æ¶ˆ
  if (signal.aborted) {
    return { content: [{ type: "text", text: "Cancelled" }] };
  }

  // 3. æ‰§è¡Œé€»è¾‘
  const result = await doSomething();

  // 4. è¿”å›ç»“æœ
  return {
    content: [{ type: "text", text: result }],
    details: { /* é¢å¤–ä¿¡æ¯ */ },
  };
}
```

**ToolContext æ¥å£ï¼š**
```typescript
interface ToolContext {
  cwd: string;               // å½“å‰å·¥ä½œç›®å½•
  session: Session;          // ä¼šè¯å¯¹è±¡
  hasUI: boolean;            // æ˜¯å¦æœ‰ UI å¯ç”¨
  ui: ExtensionUIContext;    // UI ä¸Šä¸‹æ–‡
}
```

### 3.3 å·¥å…·è¦†ç›–æœºåˆ¶

```typescript
// å†…ç½®å·¥å…·ï¼šread, write, edit, bash, glob, grep, ...

// è¦†ç›–å†…ç½®å·¥å…·
pi.registerTool({
  name: "read",  // åŒåè¦†ç›–
  // ... è‡ªå®šä¹‰å®ç°
});

// Agent è°ƒç”¨ read å·¥å…·æ—¶ï¼Œä¼šä½¿ç”¨è‡ªå®šä¹‰å®ç°
```

**è¦†ç›–çš„åº”ç”¨åœºæ™¯ï¼š**
- **è®¿é—®æ§åˆ¶**ï¼šé™åˆ¶æ–‡ä»¶è®¿é—®èŒƒå›´
- **æ—¥å¿—è®°å½•**ï¼šè®°å½•æ‰€æœ‰å·¥å…·è°ƒç”¨
- **æ€§èƒ½ç›‘æ§**ï¼šç»Ÿè®¡å·¥å…·æ‰§è¡Œæ—¶é—´
- **è¿œç¨‹æ‰§è¡Œ**ï¼šå°†å·¥å…·è°ƒç”¨è½¬å‘åˆ°è¿œç¨‹æœåŠ¡å™¨

### 3.4 çŠ¶æ€æŒä¹…åŒ–

```typescript
// é€šè¿‡ details å­—æ®µä¿å­˜çŠ¶æ€
return {
  content: [{ type: "text", text: "Result" }],
  details: {
    // è¿™äº›æ•°æ®ä¼šä¿å­˜åˆ° session ä¸­
    cached: true,
    timestamp: Date.now(),
    metadata: { /* ... */ },
  },
};

// åœ¨åç»­çš„å·¥å…·è°ƒç”¨ä¸­å¯ä»¥è®¿é—®
// ctx.session åŒ…å«å®Œæ•´çš„ä¼šè¯å†å²
```

---

## 4. å˜ä½“ä¸æ‰©å±•

### 4.1 æµå¼è¾“å‡ºå·¥å…·

```typescript
pi.registerTool({
  name: "stream-demo",
  description: "Demonstrates streaming output",
  parameters: Type.Object({
    count: Type.Number({ description: "Number of items to stream" }),
  }),

  async execute(_toolCallId, params, signal, onUpdate, _ctx) {
    const { count } = params as { count: number };

    for (let i = 1; i <= count; i++) {
      if (signal.aborted) break;

      // æµå¼æ›´æ–°
      onUpdate({
        content: [{ type: "text", text: `Item ${i}/${count}\n` }],
      });

      await new Promise((resolve) => setTimeout(resolve, 500));
    }

    return {
      content: [{ type: "text", text: "Stream complete" }],
      details: { count },
    };
  },
});
```

### 4.2 è‡ªå®šä¹‰æ¸²æŸ“å·¥å…·

```typescript
pi.registerTool({
  name: "custom-render",
  description: "Tool with custom rendering",
  parameters: Type.Object({
    data: Type.String({ description: "Data to render" }),
  }),

  async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
    const { data } = params as { data: string };
    return {
      content: [{ type: "text", text: data }],
      details: { length: data.length },
    };
  },

  // è‡ªå®šä¹‰è°ƒç”¨æ—¶çš„æ¸²æŸ“
  renderCall: (params) => {
    return `ğŸ”§ Calling custom-render with: ${JSON.stringify(params)}`;
  },

  // è‡ªå®šä¹‰ç»“æœçš„æ¸²æŸ“
  renderResult: (result) => {
    const text = result.content[0]?.text || "";
    return `âœ… Result (${result.details?.length} chars):\n${text}`;
  },
});
```

### 4.3 æ•°æ®åº“æŸ¥è¯¢å·¥å…·

```typescript
import { Type } from "@sinclair/typebox";
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import sqlite3 from "sqlite3";
import { promisify } from "util";

export default function (pi: ExtensionAPI) {
  const db = new sqlite3.Database(":memory:");
  const dbAll = promisify(db.all.bind(db));

  pi.registerTool({
    name: "sql-query",
    description: "Execute SQL queries on the in-memory database",
    parameters: Type.Object({
      query: Type.String({ description: "SQL query to execute" }),
    }),

    async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
      const { query } = params as { query: string };

      try {
        const rows = await dbAll(query);

        // æ ¼å¼åŒ–ä¸ºè¡¨æ ¼
        const text = rows.length > 0
          ? JSON.stringify(rows, null, 2)
          : "No results";

        return {
          content: [{ type: "text", text }],
          details: { rowCount: rows.length },
        };
      } catch (error: any) {
        return {
          content: [{ type: "text", text: `SQL Error: ${error.message}` }],
          details: { error: true },
        };
      }
    },
  });
}
```

---

## 5. é”™è¯¯å¤„ç†

### 5.1 å‚æ•°éªŒè¯

```typescript
async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
  // TypeBox å·²ç»éªŒè¯äº†å‚æ•°ç±»å‹ï¼Œä½†å¯èƒ½éœ€è¦é¢å¤–éªŒè¯
  const { city } = params as { city: string };

  // éªŒè¯åŸå¸‚åç§°
  if (!city || city.trim().length === 0) {
    return {
      content: [{ type: "text", text: "Error: City name cannot be empty" }],
      details: { error: true, reason: "invalid_input" },
    };
  }

  // éªŒè¯åŸå¸‚åç§°æ ¼å¼
  if (!/^[a-zA-Z\s]+$/.test(city)) {
    return {
      content: [
        { type: "text", text: "Error: City name contains invalid characters" }
      ],
      details: { error: true, reason: "invalid_format" },
    };
  }

  // ç»§ç»­æ‰§è¡Œ...
}
```

### 5.2 å–æ¶ˆå¤„ç†

```typescript
async execute(_toolCallId, params, signal, _onUpdate, _ctx) {
  // é•¿æ—¶é—´æ“ä½œå‰æ£€æŸ¥å–æ¶ˆ
  if (signal.aborted) {
    return {
      content: [{ type: "text", text: "Operation cancelled" }],
      details: { cancelled: true },
    };
  }

  // åœ¨å¾ªç¯ä¸­æ£€æŸ¥å–æ¶ˆ
  for (let i = 0; i < 100; i++) {
    if (signal.aborted) {
      return {
        content: [{ type: "text", text: `Cancelled at step ${i}` }],
        details: { cancelled: true, progress: i },
      };
    }
    await doStep(i);
  }

  // ä½¿ç”¨ AbortSignal ä¸ fetch
  try {
    const response = await fetch(url, { signal });
    // ...
  } catch (error: any) {
    if (error.name === "AbortError") {
      return {
        content: [{ type: "text", text: "Request cancelled" }],
        details: { cancelled: true },
      };
    }
    throw error;
  }
}
```

### 5.3 å¼‚å¸¸å¤„ç†

```typescript
async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
  try {
    const result = await riskyOperation();
    return {
      content: [{ type: "text", text: result }],
      details: { success: true },
    };
  } catch (error: any) {
    // è®°å½•é”™è¯¯
    console.error("Tool execution failed:", error);

    // è¿”å›å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
    return {
      content: [
        {
          type: "text",
          text: `Error: ${error.message}\n\nPlease try again or contact support.`,
        },
      ],
      details: {
        error: true,
        errorType: error.name,
        errorMessage: error.message,
      },
    };
  }
}
```

---

## 6. æœ€ä½³å®è·µ

### 6.1 æè¿°æ¸…æ™°

```typescript
// âœ“ å¥½ï¼šæ¸…æ™°çš„æè¿°
pi.registerTool({
  name: "weather",
  description:
    "Query current weather information for a specific city. " +
    "Returns temperature, condition, humidity, and wind speed. " +
    "Supports both Celsius and Fahrenheit units.",
  // ...
});

// âœ— å·®ï¼šæ¨¡ç³Šçš„æè¿°
pi.registerTool({
  name: "weather",
  description: "Get weather",
  // ...
});
```

### 6.2 å‚æ•°éªŒè¯

```typescript
// âœ“ å¥½ï¼šè¯¦ç»†çš„å‚æ•°æè¿°
parameters: Type.Object({
  city: Type.String({
    description: "City name (e.g., 'Beijing', 'New York', 'London')"
  }),
  unit: Type.Optional(
    Type.Union([Type.Literal("celsius"), Type.Literal("fahrenheit")], {
      description: "Temperature unit (default: celsius)"
    })
  ),
})

// âœ— å·®ï¼šç¼ºå°‘æè¿°
parameters: Type.Object({
  city: Type.String(),
  unit: Type.Optional(Type.String()),
})
```

### 6.3 é”™è¯¯å¤„ç†

```typescript
// âœ“ å¥½ï¼šè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
return {
  content: [
    {
      type: "text",
      text:
        `Failed to fetch weather for "${city}".\n\n` +
        `Error: ${error.message}\n\n` +
        `Please check:\n` +
        `- City name spelling\n` +
        `- Network connection\n` +
        `- API availability`,
    },
  ],
  details: { error: true, city, errorMessage: error.message },
};

// âœ— å·®ï¼šæ¨¡ç³Šçš„é”™è¯¯ä¿¡æ¯
return {
  content: [{ type: "text", text: "Error" }],
  details: { error: true },
};
```

### 6.4 æ€§èƒ½ä¼˜åŒ–

```typescript
// âœ“ å¥½ï¼šä½¿ç”¨ç¼“å­˜
const cache = new Map<string, CachedData>();

async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
  const cached = cache.get(key);
  if (cached && !isExpired(cached)) {
    return cached.data;
  }

  const data = await fetchData();
  cache.set(key, { data, timestamp: Date.now() });
  return data;
}

// âœ— å·®ï¼šæ¯æ¬¡éƒ½é‡æ–°è·å–
async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
  return await fetchData(); // å¯èƒ½å¾ˆæ…¢
}
```

---

## 7. æ€»ç»“

### 7.1 æ ¸å¿ƒè¦ç‚¹

1. **registerTool API**ï¼šæ³¨å†Œè‡ªå®šä¹‰å·¥å…·æˆ–è¦†ç›–å†…ç½®å·¥å…·
2. **TypeBox Schema**ï¼šä½¿ç”¨ TypeBox å®šä¹‰å‚æ•°ç±»å‹
3. **execute å‡½æ•°**ï¼šå¼‚æ­¥æ‰§è¡Œå‡½æ•°ï¼Œæ”¯æŒ AbortSignal
4. **ToolResult**ï¼šè¿”å› content å’Œ details
5. **å·¥å…·è¦†ç›–**ï¼šåŒåå·¥å…·ä¼šè¦†ç›–å†…ç½®å·¥å…·

### 7.2 æ‰©å±•æ–¹å‘

- **æµå¼è¾“å‡º**ï¼šä½¿ç”¨ onUpdate å®ç°å®æ—¶æ›´æ–°
- **è‡ªå®šä¹‰æ¸²æŸ“**ï¼šrenderCall/renderResult è‡ªå®šä¹‰æ˜¾ç¤º
- **çŠ¶æ€æŒä¹…åŒ–**ï¼šé€šè¿‡ details ä¿å­˜çŠ¶æ€
- **è¿œç¨‹å·¥å…·**ï¼šå°†å·¥å…·è°ƒç”¨è½¬å‘åˆ°è¿œç¨‹æœåŠ¡å™¨
- **å·¥å…·ç»„åˆ**ï¼šå¤šä¸ªå·¥å…·åä½œå®Œæˆå¤æ‚ä»»åŠ¡

### 7.3 å®é™…åº”ç”¨

å·¥å…·å¢å¼ºæ‰©å±•é€‚ç”¨äºï¼š
- **API é›†æˆ**ï¼šè°ƒç”¨å¤–éƒ¨ APIï¼ˆå¤©æ°”ã€ç¿»è¯‘ã€æœç´¢ï¼‰
- **æ•°æ®åº“æ“ä½œ**ï¼šæŸ¥è¯¢ã€æ›´æ–°æ•°æ®åº“
- **æ–‡ä»¶å¤„ç†**ï¼šè‡ªå®šä¹‰æ–‡ä»¶è¯»å†™é€»è¾‘
- **è®¿é—®æ§åˆ¶**ï¼šé™åˆ¶å·¥å…·çš„ä½¿ç”¨èŒƒå›´
- **æ—¥å¿—å®¡è®¡**ï¼šè®°å½•æ‰€æœ‰å·¥å…·è°ƒç”¨

---

**ä¸‹ä¸€æ­¥ï¼š** å­¦ä¹  [07_å®æˆ˜ä»£ç _03_å‘½ä»¤ä¸å¿«æ·é”®æ‰©å±•.md](./07_å®æˆ˜ä»£ç _03_å‘½ä»¤ä¸å¿«æ·é”®æ‰©å±•.md)ï¼Œäº†è§£å¦‚ä½•æ³¨å†Œè‡ªå®šä¹‰å‘½ä»¤å’Œå¿«æ·é”®ã€‚
