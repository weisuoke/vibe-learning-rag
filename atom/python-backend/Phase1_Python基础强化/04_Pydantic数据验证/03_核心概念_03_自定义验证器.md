# 核心概念3：自定义验证器

自定义验证器让你能够实现复杂的验证逻辑，超越 Field 的基础约束。

---

## 什么是自定义验证器？

**自定义验证器是用户定义的函数，用于实现复杂的验证逻辑和数据转换。**

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    name: str
    age: int

    @field_validator('name')
    @classmethod
    def name_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('name cannot be empty')
        return v.strip()

# 自动调用验证器
user = User(name="  Alice  ", age=25)
print(user.name)  # "Alice"（去除空格）
```

**核心功能：**
1. **字段验证器**：验证单个字段
2. **模型验证器**：验证整个模型
3. **数据转换**：在验证过程中转换数据
4. **跨字段验证**：验证多个字段之间的关系

---

## 1. field_validator（字段验证器）

### 1.1 基础用法

```python
from pydantic import BaseModel, field_validator, ValidationError

class User(BaseModel):
    name: str
    age: int

    @field_validator('name')
    @classmethod
    def name_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('name cannot be empty')
        return v.strip()

    @field_validator('age')
    @classmethod
    def age_must_be_positive(cls, v):
        if v < 0:
            raise ValueError('age must be positive')
        return v

# 验证通过
user = User(name="  Alice  ", age=25)
print(user.name)  # "Alice"

# 验证失败
try:
    user = User(name="   ", age=-5)
except ValidationError as e:
    print(e)
    # name: Value error, name cannot be empty
    # age: Value error, age must be positive
```

### 1.2 验证多个字段

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    first_name: str
    last_name: str
    email: str

    @field_validator('first_name', 'last_name')
    @classmethod
    def names_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('name cannot be empty')
        return v.strip().title()  # 首字母大写

# 同一个验证器应用到多个字段
user = User(
    first_name="alice",
    last_name="smith",
    email="alice@example.com"
)
print(user.first_name)  # "Alice"
print(user.last_name)   # "Smith"
```

### 1.3 mode='before' 和 mode='after'

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    age: int

    # mode='before'：在类型转换之前执行
    @field_validator('age', mode='before')
    @classmethod
    def convert_age_string(cls, v):
        if isinstance(v, str):
            # 移除非数字字符
            v = ''.join(c for c in v if c.isdigit())
        return v

    # mode='after'：在类型转换之后执行（默认）
    @field_validator('age', mode='after')
    @classmethod
    def age_must_be_positive(cls, v):
        if v < 0:
            raise ValueError('age must be positive')
        return v

# mode='before' 先执行，清理数据
user = User(age="25 years old")
print(user.age)  # 25
```

**执行顺序：**
```
输入数据
    ↓
mode='before' 验证器（数据清理）
    ↓
类型转换（Pydantic 自动）
    ↓
mode='after' 验证器（验证逻辑）
    ↓
最终值
```

### 1.4 访问字段信息

```python
from pydantic import BaseModel, field_validator, FieldValidationInfo

class User(BaseModel):
    name: str
    age: int

    @field_validator('name')
    @classmethod
    def validate_name(cls, v, info: FieldValidationInfo):
        # info.field_name：字段名
        print(f"Validating field: {info.field_name}")

        # info.data：已验证的字段数据
        print(f"Already validated data: {info.data}")

        return v

user = User(name="Alice", age=25)
# 输出：
# Validating field: name
# Already validated data: {}
```

---

## 2. model_validator（模型验证器）

### 2.1 验证整个模型

```python
from pydantic import BaseModel, model_validator

class User(BaseModel):
    username: str
    password: str
    confirm_password: str

    @model_validator(mode='after')
    def check_passwords_match(self):
        # 验证两个密码是否匹配
        if self.password != self.confirm_password:
            raise ValueError('passwords do not match')
        return self

# 验证通过
user = User(
    username="alice",
    password="secret123",
    confirm_password="secret123"
)

# 验证失败
try:
    user = User(
        username="alice",
        password="secret123",
        confirm_password="different"
    )
except ValidationError as e:
    print(e)
    # Value error, passwords do not match
```

### 2.2 mode='before' 和 mode='after'

```python
from pydantic import BaseModel, model_validator
from typing import Any

class User(BaseModel):
    name: str
    age: int

    # mode='before'：在字段验证之前执行
    @model_validator(mode='before')
    @classmethod
    def preprocess_data(cls, data: Any):
        # 数据预处理
        if isinstance(data, dict):
            # 统一字段名（兼容不同格式）
            if 'user_name' in data:
                data['name'] = data.pop('user_name')
            if 'user_age' in data:
                data['age'] = data.pop('user_age')
        return data

    # mode='after'：在字段验证之后执行
    @model_validator(mode='after')
    def validate_model(self):
        # 跨字段验证
        if self.age < 18 and 'admin' in self.name.lower():
            raise ValueError('admin users must be 18+')
        return self

# mode='before' 预处理数据
user = User(user_name="Alice", user_age=25)
print(user.name)  # "Alice"
```

### 2.3 跨字段验证

```python
from pydantic import BaseModel, model_validator
from datetime import date

class Event(BaseModel):
    name: str
    start_date: date
    end_date: date

    @model_validator(mode='after')
    def check_dates(self):
        if self.end_date < self.start_date:
            raise ValueError('end_date must be after start_date')
        return self

# 验证通过
event = Event(
    name="Conference",
    start_date=date(2026, 3, 1),
    end_date=date(2026, 3, 3)
)

# 验证失败
try:
    event = Event(
        name="Conference",
        start_date=date(2026, 3, 3),
        end_date=date(2026, 3, 1)
    )
except ValidationError as e:
    print(e)
    # Value error, end_date must be after start_date
```

---

## 3. 数据转换

### 3.1 字段转换

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    name: str
    email: str

    @field_validator('name')
    @classmethod
    def capitalize_name(cls, v):
        # 自动首字母大写
        return v.strip().title()

    @field_validator('email')
    @classmethod
    def lowercase_email(cls, v):
        # 自动转小写
        return v.strip().lower()

# 自动转换
user = User(name="alice smith", email="ALICE@EXAMPLE.COM")
print(user.name)   # "Alice Smith"
print(user.email)  # "alice@example.com"
```

### 3.2 复杂转换

```python
from pydantic import BaseModel, field_validator
from typing import List

class Article(BaseModel):
    title: str
    tags: str  # 输入是逗号分隔的字符串

    @field_validator('tags')
    @classmethod
    def parse_tags(cls, v):
        # 转换为列表
        if isinstance(v, str):
            return [tag.strip() for tag in v.split(',') if tag.strip()]
        return v

# 自动转换
article = Article(
    title="Python Tutorial",
    tags="python, tutorial, beginner"
)
print(article.tags)  # ['python', 'tutorial', 'beginner']
```

### 3.3 条件转换

```python
from pydantic import BaseModel, field_validator

class Product(BaseModel):
    name: str
    price: float

    @field_validator('price')
    @classmethod
    def round_price(cls, v):
        # 价格四舍五入到小数点后2位
        return round(v, 2)

# 自动转换
product = Product(name="Book", price=19.999)
print(product.price)  # 20.0
```

---

## 4. 验证器链

### 4.1 多个验证器按顺序执行

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    password: str

    @field_validator('password')
    @classmethod
    def password_min_length(cls, v):
        if len(v) < 8:
            raise ValueError('password must be at least 8 characters')
        return v

    @field_validator('password')
    @classmethod
    def password_must_have_digit(cls, v):
        if not any(c.isdigit() for c in v):
            raise ValueError('password must contain at least one digit')
        return v

    @field_validator('password')
    @classmethod
    def password_must_have_uppercase(cls, v):
        if not any(c.isupper() for c in v):
            raise ValueError('password must contain at least one uppercase letter')
        return v

# 所有验证器都会执行
try:
    user = User(password="short")
except ValidationError as e:
    print(e)
    # password must be at least 8 characters
```

### 4.2 验证器执行顺序

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    name: str

    @field_validator('name')
    @classmethod
    def validator1(cls, v):
        print("Validator 1")
        return v

    @field_validator('name')
    @classmethod
    def validator2(cls, v):
        print("Validator 2")
        return v

user = User(name="Alice")
# 输出：
# Validator 1
# Validator 2
```

---

## 5. 复用验证器

### 5.1 提取验证函数

```python
from pydantic import BaseModel, field_validator

def validate_not_empty(v: str) -> str:
    """可复用的验证函数"""
    if not v.strip():
        raise ValueError('cannot be empty')
    return v.strip()

class User(BaseModel):
    first_name: str
    last_name: str

    @field_validator('first_name', 'last_name')
    @classmethod
    def names_not_empty(cls, v):
        return validate_not_empty(v)

class Product(BaseModel):
    name: str
    description: str

    @field_validator('name', 'description')
    @classmethod
    def fields_not_empty(cls, v):
        return validate_not_empty(v)
```

### 5.2 验证器装饰器工厂

```python
from pydantic import BaseModel, field_validator
from typing import Callable

def min_length_validator(min_len: int) -> Callable:
    """创建最小长度验证器"""
    def validator(cls, v):
        if len(v) < min_len:
            raise ValueError(f'must be at least {min_len} characters')
        return v
    return validator

class User(BaseModel):
    username: str
    password: str

    @field_validator('username')
    @classmethod
    def username_min_length(cls, v):
        return min_length_validator(3)(cls, v)

    @field_validator('password')
    @classmethod
    def password_min_length(cls, v):
        return min_length_validator(8)(cls, v)
```

---

## 6. 在 FastAPI 中使用

### 6.1 请求体验证

```python
from fastapi import FastAPI
from pydantic import BaseModel, field_validator, ValidationError

app = FastAPI()

class CreateUserRequest(BaseModel):
    username: str
    password: str
    confirm_password: str

    @field_validator('username')
    @classmethod
    def username_alphanumeric(cls, v):
        if not v.isalnum():
            raise ValueError('username must be alphanumeric')
        return v.lower()

    @field_validator('password')
    @classmethod
    def password_strong(cls, v):
        if len(v) < 8:
            raise ValueError('password must be at least 8 characters')
        if not any(c.isdigit() for c in v):
            raise ValueError('password must contain a digit')
        return v

    @model_validator(mode='after')
    def passwords_match(self):
        if self.password != self.confirm_password:
            raise ValueError('passwords do not match')
        return self

@app.post("/users")
async def create_user(request: CreateUserRequest):
    # FastAPI 自动调用所有验证器
    return {"username": request.username}
```

### 6.2 自定义错误响应

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, field_validator, ValidationError

app = FastAPI()

class User(BaseModel):
    email: str

    @field_validator('email')
    @classmethod
    def email_must_be_valid(cls, v):
        if '@' not in v:
            raise ValueError('invalid email format')
        return v.lower()

@app.post("/users")
async def create_user(user: User):
    return {"email": user.email}

# FastAPI 自动返回 422 错误和详细信息
```

---

## 7. 在 AI Agent 中的应用

### 7.1 LLM 参数验证

```python
from pydantic import BaseModel, field_validator, model_validator
from typing import List, Literal

class Message(BaseModel):
    role: Literal["user", "assistant", "system"]
    content: str

    @field_validator('content')
    @classmethod
    def content_not_empty(cls, v):
        if not v.strip():
            raise ValueError('message content cannot be empty')
        return v.strip()

class ChatRequest(BaseModel):
    messages: List[Message]
    model: str
    temperature: float

    @field_validator('messages')
    @classmethod
    def messages_not_empty(cls, v):
        if not v:
            raise ValueError('messages list cannot be empty')
        return v

    @field_validator('messages')
    @classmethod
    def first_message_must_be_user(cls, v):
        if v and v[0].role != 'user':
            raise ValueError('first message must be from user')
        return v

    @model_validator(mode='after')
    def validate_temperature_for_model(self):
        # 不同模型的温度范围不同
        if 'gpt' in self.model and not (0 <= self.temperature <= 2):
            raise ValueError('GPT temperature must be 0-2')
        if 'claude' in self.model and not (0 <= self.temperature <= 1):
            raise ValueError('Claude temperature must be 0-1')
        return self
```

### 7.2 RAG 查询验证

```python
from pydantic import BaseModel, field_validator
import re

class RAGQuery(BaseModel):
    query: str
    top_k: int

    @field_validator('query')
    @classmethod
    def query_not_empty(cls, v):
        if not v.strip():
            raise ValueError('query cannot be empty')
        return v.strip()

    @field_validator('query')
    @classmethod
    def query_no_sql_injection(cls, v):
        # 简单的 SQL 注入检测
        dangerous_patterns = ['DROP', 'DELETE', 'INSERT', 'UPDATE', '--', ';']
        v_upper = v.upper()
        for pattern in dangerous_patterns:
            if pattern in v_upper:
                raise ValueError(f'query contains dangerous pattern: {pattern}')
        return v

    @field_validator('query')
    @classmethod
    def query_length_reasonable(cls, v):
        if len(v) > 1000:
            raise ValueError('query too long (max 1000 characters)')
        return v
```

### 7.3 Agent 工具参数验证

```python
from pydantic import BaseModel, field_validator, model_validator
from datetime import datetime

class SearchTool(BaseModel):
    query: str
    start_date: str
    end_date: str

    @field_validator('start_date', 'end_date')
    @classmethod
    def validate_date_format(cls, v):
        try:
            datetime.strptime(v, '%Y-%m-%d')
        except ValueError:
            raise ValueError('date must be in YYYY-MM-DD format')
        return v

    @model_validator(mode='after')
    def end_after_start(self):
        start = datetime.strptime(self.start_date, '%Y-%m-%d')
        end = datetime.strptime(self.end_date, '%Y-%m-%d')
        if end < start:
            raise ValueError('end_date must be after start_date')
        return self
```

---

## 8. 高级技巧

### 8.1 条件验证

```python
from pydantic import BaseModel, field_validator, FieldValidationInfo

class User(BaseModel):
    role: str
    admin_code: str = None

    @field_validator('admin_code')
    @classmethod
    def admin_code_required_for_admin(cls, v, info: FieldValidationInfo):
        # 只有 admin 角色需要 admin_code
        if info.data.get('role') == 'admin' and not v:
            raise ValueError('admin_code required for admin role')
        return v
```

### 8.2 异步验证器

```python
from pydantic import BaseModel, field_validator
import asyncio

class User(BaseModel):
    email: str

    @field_validator('email')
    @classmethod
    def email_format(cls, v):
        if '@' not in v:
            raise ValueError('invalid email')
        return v

# 注意：Pydantic 验证器不支持 async
# 如果需要异步验证（如检查数据库），在 FastAPI 路由中处理
```

### 8.3 验证器中访问配置

```python
from pydantic import BaseModel, field_validator, ConfigDict

class User(BaseModel):
    model_config = ConfigDict(
        str_strip_whitespace=True,
        str_to_lower=True
    )

    name: str

    @field_validator('name')
    @classmethod
    def name_not_empty(cls, v):
        # 配置已经自动去除空格和转小写
        if not v:
            raise ValueError('name cannot be empty')
        return v
```

---

## 9. 常见模式

### 9.1 邮箱验证

```python
from pydantic import BaseModel, field_validator
import re

class User(BaseModel):
    email: str

    @field_validator('email')
    @classmethod
    def email_valid(cls, v):
        pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
        if not re.match(pattern, v):
            raise ValueError('invalid email format')
        return v.lower()
```

### 9.2 密码强度验证

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    password: str

    @field_validator('password')
    @classmethod
    def password_strong(cls, v):
        if len(v) < 8:
            raise ValueError('password must be at least 8 characters')
        if not any(c.isupper() for c in v):
            raise ValueError('password must contain uppercase letter')
        if not any(c.islower() for c in v):
            raise ValueError('password must contain lowercase letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('password must contain digit')
        if not any(c in '!@#$%^&*' for c in v):
            raise ValueError('password must contain special character')
        return v
```

### 9.3 URL 验证

```python
from pydantic import BaseModel, field_validator
from urllib.parse import urlparse

class Website(BaseModel):
    url: str

    @field_validator('url')
    @classmethod
    def url_valid(cls, v):
        try:
            result = urlparse(v)
            if not all([result.scheme, result.netloc]):
                raise ValueError('invalid URL')
            if result.scheme not in ['http', 'https']:
                raise ValueError('URL must be http or https')
        except Exception:
            raise ValueError('invalid URL format')
        return v
```

### 9.4 JSON 字符串验证

```python
from pydantic import BaseModel, field_validator
import json

class Config(BaseModel):
    settings: str  # JSON 字符串

    @field_validator('settings')
    @classmethod
    def settings_valid_json(cls, v):
        try:
            json.loads(v)
        except json.JSONDecodeError:
            raise ValueError('settings must be valid JSON')
        return v
```

---

## 10. 最佳实践

### 10.1 验证器命名

```python
# ✅ 好的命名：描述验证的内容
@field_validator('email')
@classmethod
def email_must_be_valid(cls, v):
    ...

# ❌ 不好的命名：不清楚验证什么
@field_validator('email')
@classmethod
def validate(cls, v):
    ...
```

### 10.2 错误消息

```python
# ✅ 好的错误消息：清晰、具体
@field_validator('age')
@classmethod
def age_in_range(cls, v):
    if not 0 <= v <= 150:
        raise ValueError('age must be between 0 and 150')
    return v

# ❌ 不好的错误消息：模糊
@field_validator('age')
@classmethod
def age_valid(cls, v):
    if not 0 <= v <= 150:
        raise ValueError('invalid age')
    return v
```

### 10.3 验证器职责

```python
# ✅ 好的做法：一个验证器一个职责
@field_validator('password')
@classmethod
def password_min_length(cls, v):
    if len(v) < 8:
        raise ValueError('password must be at least 8 characters')
    return v

@field_validator('password')
@classmethod
def password_has_digit(cls, v):
    if not any(c.isdigit() for c in v):
        raise ValueError('password must contain a digit')
    return v

# ❌ 不好的做法：一个验证器多个职责
@field_validator('password')
@classmethod
def password_valid(cls, v):
    if len(v) < 8 or not any(c.isdigit() for c in v):
        raise ValueError('password invalid')
    return v
```

### 10.4 性能考虑

```python
# ✅ 好的做法：先做简单检查
@field_validator('email')
@classmethod
def email_valid(cls, v):
    # 先做简单检查（快）
    if '@' not in v:
        raise ValueError('invalid email')

    # 再做复杂检查（慢）
    if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', v):
        raise ValueError('invalid email format')

    return v

# ❌ 不好的做法：直接做复杂检查
@field_validator('email')
@classmethod
def email_valid(cls, v):
    if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', v):
        raise ValueError('invalid email')
    return v
```

---

## 总结

### 自定义验证器的核心价值

1. **灵活性**：实现任意复杂的验证逻辑
2. **可复用**：验证函数可以在多个模型中复用
3. **数据转换**：在验证过程中转换数据
4. **跨字段验证**：验证多个字段之间的关系

### 验证器类型对比

| 验证器类型 | 作用范围 | 使用场景 |
|-----------|---------|---------|
| `field_validator` | 单个或多个字段 | 字段级验证和转换 |
| `model_validator` | 整个模型 | 跨字段验证、模型级逻辑 |
| `mode='before'` | 类型转换前 | 数据清理、预处理 |
| `mode='after'` | 类型转换后 | 验证逻辑、后处理 |

### 最佳实践总结

1. **清晰命名**：验证器名称描述验证内容
2. **具体错误**：错误消息清晰、具体
3. **单一职责**：一个验证器一个职责
4. **性能优先**：先做简单检查，再做复杂检查
5. **可复用**：提取通用验证函数

### 下一步

- 学习模型继承和复用
- 学习与数据库 ORM 集成
- 学习 Pydantic 的序列化和反序列化

---

**版本：** v1.0
**最后更新：** 2026-02-11
