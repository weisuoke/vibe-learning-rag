# 面试必问

> **MCP Server 集成的高频面试题与优秀答案**

---

## 面试题 1：请解释什么是 MCP，以及它解决了什么问题？

### 普通回答（60分）

"MCP 是 Model Context Protocol 的缩写，是一个让 AI 模型可以调用外部工具的协议。它可以让 AI 访问数据库、文件系统等外部资源。"

**问题**：
- ❌ 没有说明为什么需要 MCP
- ❌ 没有体现 MCP 的核心价值
- ❌ 没有与其他方案对比
- ❌ 过于简单，缺乏深度

---

### 优秀回答（95分）

"MCP（Model Context Protocol）是 Anthropic 在 2024 年推出的开源标准协议，专为 AI Agent 与外部工具的集成而设计。

**它解决的核心问题是 AI 工具集成的碎片化**：

在 MCP 出现之前，每个 AI 平台都有自己的工具集成方案——OpenAI 有 Plugin 系统，Anthropic 有 Tool Use API，Google 有 Function Calling。这导致了 N×M 的复杂度问题：N 个 AI 平台需要与 M 个工具集成，就需要 N×M 个不同的实现。

**MCP 通过三个核心设计解决这个问题**：

1. **统一协议**：基于 JSON-RPC 2.0，所有 AI 平台和工具都遵循同一标准
2. **动态发现**：AI Agent 可以在运行时查询可用工具（tools/list），而不是依赖静态文档
3. **语义清晰**：每个工具都有详细的描述和 JSON Schema，让 AI 能够理解何时、如何使用

**MCP 的三个核心抽象**：
- **Tools**：可执行的操作（如查询数据库、发送邮件）
- **Resources**：可访问的数据源（如文件、配置、知识库）
- **Events**：实时通知（如进度更新、状态变更）

**与传统 API 的关键区别**：
- 传统 REST API 是为人类开发者设计的，需要查文档后编写代码
- MCP 是为 AI Agent 设计的，支持动态发现和自主决策

**实际价值**：
- 对开发者：一次实现，所有 AI 平台都能使用
- 对 AI 平台：访问丰富的工具生态
- 对用户：更强大的 AI Agent

类比来说，MCP 就像 AI 领域的 USB-C 标准——统一接口，降低复杂度，促进生态繁荣。"

**为什么这个回答优秀**：
- ✅ 清晰说明了 MCP 是什么（定义）
- ✅ 深入解释了为什么需要 MCP（问题背景）
- ✅ 详细描述了 MCP 如何解决问题（解决方案）
- ✅ 对比了与传统方案的区别（差异化）
- ✅ 说明了实际价值（影响）
- ✅ 使用了类比帮助理解（USB-C）
- ✅ 体现了对技术的深入理解

---

## 面试题 2：如果让你设计一个 MCP Server，你会如何设计？请说明关键决策点。

### 普通回答（60分）

"我会先定义需要提供哪些工具，然后实现这些工具的逻辑，最后启动一个服务器监听请求。使用 MCP SDK 可以简化开发。"

**问题**：
- ❌ 没有体现设计思考过程
- ❌ 没有说明关键决策点
- ❌ 没有考虑实际场景
- ❌ 缺乏架构层面的思考

---

### 优秀回答（95分）

"设计一个 MCP Server 需要考虑多个维度，我会按照以下流程进行：

**1. 需求分析阶段**

首先明确三个问题：
- **目标用户**：谁会使用这个 Server？（开发者、企业内部、公开服务）
- **核心场景**：解决什么问题？（数据访问、API 集成、工作流自动化）
- **集成方式**：如何被使用？（本地工具、远程服务、Pi-mono 扩展）

**2. 架构设计阶段**

**关键决策 1：选择传输层**
```
决策树：
├─ 本地命令行工具 → stdio（最简单，适合 CLI 场景）
├─ 浏览器访问 → HTTP + SSE（支持 Web 环境）
├─ 远程服务 → HTTP + SSE + 认证（需要安全性）
└─ 混合场景 → 支持多种传输层
```

我会优先选择 stdio，因为：
- 实现简单，无需处理网络层
- 适合大多数 AI 平台（Claude Desktop、Cursor 等）
- 可以后续扩展为 HTTP

**关键决策 2：工具设计原则**

遵循"语义清晰、职责单一"原则：

```typescript
// ❌ 错误：一个工具做太多事
{
  name: "database_operation",
  description: "Do database operations",
  inputSchema: {
    properties: {
      operation: { enum: ["query", "insert", "update", "delete"] },
      // ...
    }
  }
}

// ✅ 正确：每个工具职责单一
{
  name: "query_users",
  description: "Query user records from the database. Use this when you need to find or list users. Returns user ID, name, email, and registration date.",
  inputSchema: { /* 清晰的参数定义 */ }
}
```

**关键决策 3：错误处理策略**

采用"优雅降级"策略：
- 工具级错误：返回错误信息，不抛出异常（避免 Server 崩溃）
- 连接级错误：记录日志，尝试重连
- 数据级错误：提供有意义的错误描述，帮助 AI 理解问题

**3. 实现阶段**

**核心代码结构**：

```typescript
// 1. Server 初始化
const server = new Server(
  { name: "my-server", version: "1.0.0" },
  { capabilities: { tools: {}, resources: {}, logging: {} } }
);

// 2. 工具注册（关键：描述要详细）
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: "search_users",
      description: "Searches user profiles by name, email, or ID. Returns basic user information. Use this when you need to find specific users or verify user existence.",
      inputSchema: {
        type: "object",
        properties: {
          query: {
            type: "string",
            description: "Search term: user name (partial match), email (exact), or user ID (exact)"
          }
        },
        required: ["query"]
      }
    }
  ]
}));

// 3. 工具执行（关键：错误处理）
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    const result = await executeToolLogic(request.params);
    return {
      content: [{ type: "text", text: JSON.stringify(result) }]
    };
  } catch (error) {
    // 不抛出异常，返回错误信息
    return {
      content: [{ type: "text", text: `Error: ${error.message}` }],
      isError: true
    };
  }
});

// 4. 日志通知（关键：使用 stderr 或通知）
server.sendNotification({
  method: "notifications/message",
  params: { level: "info", data: "Server ready" }
});
```

**4. 优化阶段**

**性能优化**：
- 连接池管理（数据库、HTTP 连接）
- 缓存策略（频繁访问的数据）
- 异步处理（避免阻塞）

**安全加固**：
- 输入验证（防止注入攻击）
- 权限控制（限制访问范围）
- 速率限制（防止滥用）

**可观测性**：
- 结构化日志（便于调试）
- 性能指标（响应时间、错误率）
- 健康检查（监控 Server 状态）

**5. 测试策略**

```typescript
// 单元测试：测试工具逻辑
describe('search_users', () => {
  it('should return users matching query', async () => {
    const result = await searchUsers({ query: 'john' });
    expect(result).toHaveLength(2);
  });
});

// 集成测试：测试 MCP 协议
describe('MCP Server', () => {
  it('should complete initialize handshake', async () => {
    const response = await client.initialize();
    expect(response.capabilities).toBeDefined();
  });

  it('should list tools', async () => {
    const { tools } = await client.listTools();
    expect(tools).toContainEqual(
      expect.objectContaining({ name: 'search_users' })
    );
  });
});
```

**6. 部署考虑**

**本地部署**：
```json
// package.json
{
  "name": "my-mcp-server",
  "bin": {
    "my-server": "./dist/index.js"
  }
}
```

**远程部署**：
- 使用 Docker 容器化
- 配置反向代理（Nginx）
- 启用 HTTPS（Let's Encrypt）
- 实现认证机制（JWT/OAuth）

**7. 文档和示例**

提供清晰的文档：
- README：快速开始指南
- API 文档：每个工具的详细说明
- 示例代码：常见使用场景
- 故障排查：常见问题解决方案

**总结关键决策点**：

1. **传输层选择**：stdio vs HTTP（根据使用场景）
2. **工具粒度**：单一职责 vs 通用工具（倾向单一职责）
3. **错误处理**：抛出异常 vs 返回错误（返回错误，避免崩溃）
4. **描述详细度**：简单 vs 详细（必须详细，AI 依赖描述）
5. **性能优化**：提前优化 vs 按需优化（先实现功能，再优化）
6. **安全策略**：开放 vs 严格（根据部署环境决定）

这个设计流程体现了从需求到实现的完整思考，确保 MCP Server 既满足功能需求，又具备良好的可维护性和扩展性。"

**为什么这个回答优秀**：
- ✅ 体现了系统化的设计思维
- ✅ 说明了每个阶段的关键决策点
- ✅ 提供了具体的代码示例
- ✅ 考虑了性能、安全、测试等多个维度
- ✅ 展示了对 MCP 协议的深入理解
- ✅ 体现了实际项目经验
- ✅ 结构清晰，逻辑严密

---

## 面试加分项

### 1. 主动提及实际经验

"在我之前的项目中，我构建了一个 MCP Server 用于集成公司的 CRM 系统。最大的挑战是如何设计工具描述，让 AI 能够准确理解何时使用哪个工具。我们通过 A/B 测试发现，详细的描述可以将工具调用准确率从 60% 提升到 90%。"

### 2. 展示对生态的了解

"MCP 生态正在快速发展。目前社区已经有超过 50 个官方和社区维护的 MCP Server，涵盖文件系统、数据库、API 集成等场景。特别值得关注的是 @modelcontextprotocol/server-filesystem 和 @modelcontextprotocol/server-postgres，它们的实现可以作为最佳实践参考。"

### 3. 讨论技术趋势

"MCP 的设计理念与 LSP（Language Server Protocol）类似，都是通过标准化协议来解决碎片化问题。我认为未来会有更多的 AI 平台采用 MCP，形成统一的工具生态。同时，MCP 可能会扩展支持更多的能力，比如双向通信、状态同步等。"

### 4. 提出改进建议

"虽然 MCP 已经很优秀，但我认为还有一些可以改进的地方：
- 工具版本管理：当工具 Schema 变更时，如何保证向后兼容
- 工具组合：如何让 AI 更好地组合多个工具完成复杂任务
- 性能监控：标准化的性能指标和监控接口"

---

## 常见追问及回答

### 追问 1："MCP 和 OpenAI 的 Function Calling 有什么区别？"

**回答**：

"MCP 和 OpenAI Function Calling 都是让 AI 调用外部工具的机制，但有几个关键区别：

**1. 标准化程度**：
- Function Calling：OpenAI 专有，只能在 OpenAI 平台使用
- MCP：开放标准，任何 AI 平台都可以实现

**2. 发现机制**：
- Function Calling：开发者在每次请求时传递工具定义
- MCP：AI 可以动态查询可用工具（tools/list）

**3. 通信方式**：
- Function Calling：嵌入在 Chat API 的请求/响应中
- MCP：独立的协议，基于 JSON-RPC 2.0

**4. 资源访问**：
- Function Calling：只有工具（函数）
- MCP：工具 + 资源 + 事件（更完整的抽象）

**5. 生态系统**：
- Function Calling：每个工具需要为 OpenAI 单独实现
- MCP：一次实现，所有支持 MCP 的平台都能使用

实际上，你可以用 MCP Server 包装 OpenAI Function Calling，让其他 AI 平台也能使用。"

---

### 追问 2："如何保证 MCP Server 的安全性？"

**回答**：

"MCP Server 的安全性需要从多个层面考虑：

**1. 认证与授权**：
- 使用 JWT 或 OAuth 进行身份验证
- 实现基于角色的访问控制（RBAC）
- 为每个工具设置权限级别

**2. 输入验证**：
- 严格验证所有输入参数（使用 JSON Schema）
- 防止 SQL 注入、命令注入等攻击
- 限制输入大小，防止 DoS 攻击

**3. 沙箱隔离**：
- 使用容器技术隔离 Server 进程
- 限制文件系统访问范围
- 使用最小权限原则

**4. 速率限制**：
- 限制每个客户端的请求频率
- 限制长时间运行的工具
- 实现请求队列和优先级

**5. 审计日志**：
- 记录所有工具调用
- 记录敏感操作（数据修改、删除）
- 定期审查日志，发现异常行为

**6. 传输安全**：
- 使用 HTTPS（TLS 1.3）
- 验证客户端证书（双向 TLS）
- 加密敏感数据

**7. 错误处理**：
- 不在错误信息中泄露敏感信息
- 使用通用错误消息
- 详细错误记录在服务器端日志

示例代码：

```typescript
// 输入验证
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  // 1. 验证工具名称
  if (!ALLOWED_TOOLS.includes(request.params.name)) {
    throw new Error('Tool not allowed');
  }

  // 2. 验证参数
  const validation = validateInput(request.params.arguments);
  if (!validation.valid) {
    throw new Error(`Invalid input: ${validation.error}`);
  }

  // 3. 检查权限
  if (!hasPermission(user, request.params.name)) {
    throw new Error('Permission denied');
  }

  // 4. 速率限制
  if (isRateLimited(user)) {
    throw new Error('Rate limit exceeded');
  }

  // 5. 执行工具（在沙箱中）
  const result = await executeSandboxed(request.params);

  // 6. 审计日志
  auditLog({
    user,
    tool: request.params.name,
    timestamp: Date.now()
  });

  return result;
});
```

安全性是一个持续的过程，需要定期审查和更新安全策略。"

---

## 面试准备建议

### 技术深度

- ✅ 深入理解 MCP 协议规范
- ✅ 熟悉 JSON-RPC 2.0
- ✅ 了解 SSE（Server-Sent Events）
- ✅ 掌握 TypeScript/Node.js

### 实践经验

- ✅ 至少构建过一个 MCP Server
- ✅ 使用过 MCP Inspector 调试
- ✅ 集成过现有的 MCP Server
- ✅ 了解常见的 MCP Server 实现

### 生态了解

- ✅ 关注 MCP 官方仓库和社区
- ✅ 了解主流 AI 平台对 MCP 的支持
- ✅ 熟悉常用的 MCP Server
- ✅ 了解 MCP 的发展趋势

### 软技能

- ✅ 能够清晰解释技术概念
- ✅ 能够对比不同方案的优劣
- ✅ 能够提出改进建议
- ✅ 能够分享实际经验

---

**下一步**: 阅读 [09_化骨绵掌](./09_化骨绵掌.md) 通过 10 张知识卡片快速复习所有核心概念
