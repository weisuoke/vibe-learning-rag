# 化骨绵掌

## 概述

10个2分钟知识卡片，帮助你快速掌握上下文管理器的核心知识。

---

## 卡片1：直觉理解

**一句话：** 上下文管理器是"借东西必须还"的自动化机制。

**举例：**
```python
# 借书（获取资源）
with open("book.txt") as book:
    read(book)  # 读书（使用资源）
# 还书（自动释放）
```

**应用：** 任何需要"获取-使用-释放"的场景都适用。

---

## 卡片2：形式化定义

**一句话：** 实现了 `__enter__` 和 `__exit__` 方法的对象就是上下文管理器。

**举例：**
```python
class MyContext:
    def __enter__(self):
        return "resource"
    def __exit__(self, exc_type, exc_val, exc_tb):
        return False
```

**应用：** 在 FastAPI 中管理数据库会话、文件句柄、锁等资源。

---

## 卡片3：with 语句本质

**一句话：** `with` 是 `try-finally` 的语法糖，保证清理代码一定执行。

**举例：**
```python
# with 语句
with open("file.txt") as f:
    data = f.read()

# 等价于
f = open("file.txt")
try:
    data = f.read()
finally:
    f.close()
```

**应用：** 简化资源管理代码，提高可读性。

---

## 卡片4：__enter__ 返回值

**一句话：** `__enter__` 的返回值赋给 `as` 后的变量，可以是任何对象。

**举例：**
```python
class Demo:
    def __enter__(self):
        return "anything"  # 不一定是 self

with Demo() as value:
    print(value)  # "anything"
```

**应用：** 返回被管理的资源（如文件对象）或管理器本身。

---

## 卡片5：__exit__ 异常处理

**一句话：** `__exit__` 返回 `True` 抑制异常，返回 `False` 传播异常。

**举例：**
```python
def __exit__(self, exc_type, exc_val, exc_tb):
    if exc_type is ValueError:
        return True  # 抑制 ValueError
    return False  # 其他异常继续传播
```

**应用：** 数据库事务回滚后重新抛出异常，让调用者知道失败。

---

## 卡片6：@contextmanager 装饰器

**一句话：** 用生成器函数 + `@contextmanager` 快速创建上下文管理器。

**举例：**
```python
from contextlib import contextmanager

@contextmanager
def timer():
    start = time.time()
    yield  # 暂停点
    print(f"Time: {time.time() - start}s")

with timer():
    expensive_operation()
```

**应用：** 比手动实现类更简洁，适合大多数场景。

---

## 卡片7：contextlib 工具库

**一句话：** `contextlib` 提供了创建和使用上下文管理器的便捷工具。

**举例：**
```python
from contextlib import closing, suppress

# 自动调用 close()
with closing(urlopen("https://example.com")) as page:
    content = page.read()

# 抑制异常
with suppress(FileNotFoundError):
    os.remove("file.txt")
```

**应用：** 使用标准库工具简化常见模式。

---

## 卡片8：ExitStack 动态管理

**一句话：** `ExitStack` 用于动态管理多个上下文管理器。

**举例：**
```python
from contextlib import ExitStack

with ExitStack() as stack:
    files = [stack.enter_context(open(f)) for f in filenames]
    # 处理所有文件
# 所有文件自动关闭
```

**应用：** 批量文件处理、动态数量的资源管理。

---

## 卡片9：异步上下文管理器

**一句话：** 使用 `async with` 和 `@asynccontextmanager` 管理异步资源。

**举例：**
```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def async_db():
    conn = await connect()
    try:
        yield conn
    finally:
        await conn.close()

async with async_db() as conn:
    await conn.execute("SELECT ...")
```

**应用：** FastAPI 异步数据库连接、异步文件操作。

---

## 卡片10：在 AI Agent 中的应用

**一句话：** 上下文管理器是 AI Agent 后端资源管理的核心工具。

**举例：**
```python
# FastAPI 数据库会话
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users/{user_id}")
async def get_user(user_id: int, db: Session = Depends(get_db)):
    return db.query(User).filter(User.id == user_id).first()

# AI 模型推理
@contextmanager
def load_model(name):
    model = load(name)
    model.to("cuda")
    try:
        yield model
    finally:
        model.to("cpu")
        del model
```

**应用：** 数据库会话、AI 模型加载、缓存管理、请求追踪。

---

## 总结

### 核心要点

1. **本质**：自动化的"获取-使用-释放"模式
2. **协议**：`__enter__` 和 `__exit__` 两个方法
3. **语法糖**：`with` 语句简化 `try-finally`
4. **异常安全**：`__exit__` 总是执行
5. **工具库**：`contextlib` 提供便捷工具
6. **异步支持**：`async with` 管理异步资源

### 使用建议

- ✅ 优先使用 `@contextmanager` 装饰器
- ✅ 总是在 `finally` 中清理资源
- ✅ 默认不抑制异常（返回 `False`）
- ✅ 使用 `ExitStack` 管理动态资源
- ❌ 避免在 `__exit__` 中抛出新异常
- ❌ 不要在 `with` 块外使用资源

---

**版本：** v1.0
**最后更新：** 2026-02-11
