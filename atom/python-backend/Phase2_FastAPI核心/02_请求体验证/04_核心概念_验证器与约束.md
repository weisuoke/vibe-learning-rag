# 核心概念2：验证器与约束

> validator、root_validator、自定义验证 - 实现复杂业务规则

---

## 概述

Field 约束可以处理大部分简单验证需求，但对于复杂的业务规则（如跨字段验证、条件验证、自定义格式），我们需要使用 Pydantic 的验证器系统。

---

## 1. @validator - 字段级验证器

### 1.1 基础用法

**`@validator` 用于对单个字段进行自定义验证。**

```python
from pydantic import BaseModel, validator

class User(BaseModel):
    username: str
    email: str

    @validator('username')
    def username_alphanumeric(cls, v):
        if not v.isalnum():
            raise ValueError('must be alphanumeric')
        return v

    @validator('email')
    def email_must_contain_at(cls, v):
        if '@' not in v:
            raise ValueError('must contain @')
        return v

# 使用
user = User(username="alice123", email="alice@example.com")  # ✅
user = User(username="alice@123", email="alice@example.com")  # ❌ username 验证失败
```

### 1.2 访问其他字段值

```python
from pydantic import BaseModel, validator

class User(BaseModel):
    password: str
    confirm_password: str

    @validator('confirm_password')
    def passwords_match(cls, v, values):
        # values 包含已验证的字段
        if 'password' in values and v != values['password']:
            raise ValueError('passwords do not match')
        return v

# 使用
user = User(password="secret123", confirm_password="secret123")  # ✅
user = User(password="secret123", confirm_password="different")  # ❌
```

### 1.3 验证多个字段

```python
from pydantic import BaseModel, validator

class User(BaseModel):
    first_name: str
    last_name: str
    email: str

    @validator('first_name', 'last_name')
    def name_must_not_be_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('must not be empty')
        return v.strip()

    @validator('*')  # 验证所有字段
    def check_all_fields(cls, v):
        if isinstance(v, str) and len(v) > 1000:
            raise ValueError('field too long')
        return v
```

### 1.4 pre 和 always 参数

```python
from pydantic import BaseModel, validator

class User(BaseModel):
    username: str
    age: int

    @validator('username', pre=True)
    def username_to_lower(cls, v):
        # pre=True: 在类型验证前执行（v 可能不是 str）
        if isinstance(v, str):
            return v.lower()
        return v

    @validator('age', always=True)
    def set_default_age(cls, v):
        # always=True: 即使字段未提供也执行
        return v or 18

# 使用
user = User(username="ALICE", age=25)
print(user.username)  # "alice"

user = User(username="BOB")
print(user.age)  # 18
```

---

## 2. @root_validator - 模型级验证器

### 2.1 基础用法

**`@root_validator` 用于验证整个模型，可以访问所有字段。**

```python
from pydantic import BaseModel, root_validator

class DateRange(BaseModel):
    start_date: str
    end_date: str

    @root_validator
    def check_date_range(cls, values):
        start = values.get('start_date')
        end = values.get('end_date')
        if start and end and start > end:
            raise ValueError('start_date must be before end_date')
        return values

# 使用
date_range = DateRange(start_date="2024-01-01", end_date="2024-12-31")  # ✅
date_range = DateRange(start_date="2024-12-31", end_date="2024-01-01")  # ❌
```

### 2.2 pre=True 模式

```python
from pydantic import BaseModel, root_validator

class User(BaseModel):
    username: str
    email: str

    @root_validator(pre=True)
    def normalize_data(cls, values):
        # pre=True: 在字段验证前执行（原始数据）
        if isinstance(values, dict):
            # 数据预处理
            if 'username' in values:
                values['username'] = values['username'].lower()
            if 'email' in values:
                values['email'] = values['email'].lower()
        return values

# 使用
user = User(username="ALICE", email="ALICE@EXAMPLE.COM")
print(user.username)  # "alice"
print(user.email)     # "alice@example.com"
```

### 2.3 条件验证

```python
from pydantic import BaseModel, root_validator
from typing import Optional

class RAGConfig(BaseModel):
    hybrid_search: bool
    bm25_weight: Optional[float] = None
    vector_weight: Optional[float] = None

    @root_validator
    def check_hybrid_weights(cls, values):
        hybrid = values.get('hybrid_search')
        bm25 = values.get('bm25_weight')
        vector = values.get('vector_weight')

        if hybrid:
            # 如果启用混合检索，必须提供权重
            if bm25 is None or vector is None:
                raise ValueError('hybrid_search requires both weights')
            # 权重之和必须为 1.0
            if abs(bm25 + vector - 1.0) > 0.001:
                raise ValueError('weights must sum to 1.0')

        return values

# 使用
config1 = RAGConfig(hybrid_search=False)  # ✅
config2 = RAGConfig(hybrid_search=True, bm25_weight=0.3, vector_weight=0.7)  # ✅
config3 = RAGConfig(hybrid_search=True)  # ❌ 缺少权重
```

---

## 3. 自定义验证逻辑

### 3.1 复杂格式验证

```python
from pydantic import BaseModel, validator
import re

class User(BaseModel):
    username: str
    phone: str

    @validator('username')
    def validate_username(cls, v):
        # 用户名规则：3-20个字符，只能包含字母、数字、下划线
        if not re.match(r'^[a-zA-Z0-9_]{3,20}$', v):
            raise ValueError('invalid username format')
        # 不能以数字开头
        if v[0].isdigit():
            raise ValueError('username cannot start with digit')
        return v

    @validator('phone')
    def validate_phone(cls, v):
        # 手机号格式：xxx-xxxx
        if not re.match(r'^\d{3}-\d{4}$', v):
            raise ValueError('phone must be in format xxx-xxxx')
        return v
```

### 3.2 业务规则验证

```python
from pydantic import BaseModel, validator, root_validator
from typing import List

class Order(BaseModel):
    items: List[str]
    total_price: float
    discount: float = 0.0

    @validator('items')
    def items_not_empty(cls, v):
        if not v:
            raise ValueError('order must have at least one item')
        return v

    @validator('discount')
    def discount_valid(cls, v, values):
        total = values.get('total_price', 0)
        if v < 0:
            raise ValueError('discount cannot be negative')
        if v > total:
            raise ValueError('discount cannot exceed total price')
        return v

    @root_validator
    def check_final_price(cls, values):
        total = values.get('total_price', 0)
        discount = values.get('discount', 0)
        final_price = total - discount

        if final_price < 0:
            raise ValueError('final price cannot be negative')

        # 添加计算字段
        values['final_price'] = final_price
        return values
```

### 3.3 数据转换和规范化

```python
from pydantic import BaseModel, validator

class User(BaseModel):
    username: str
    email: str
    tags: List[str]

    @validator('username', pre=True)
    def normalize_username(cls, v):
        # 转换为小写并去除空格
        if isinstance(v, str):
            return v.lower().strip()
        return v

    @validator('email', pre=True)
    def normalize_email(cls, v):
        if isinstance(v, str):
            return v.lower().strip()
        return v

    @validator('tags', pre=True)
    def normalize_tags(cls, v):
        # 去重并排序
        if isinstance(v, list):
            return sorted(set(tag.lower() for tag in v if isinstance(tag, str)))
        return v

# 使用
user = User(
    username="  ALICE  ",
    email="  ALICE@EXAMPLE.COM  ",
    tags=["Python", "python", "FastAPI", "fastapi"]
)
print(user.username)  # "alice"
print(user.email)     # "alice@example.com"
print(user.tags)      # ["fastapi", "python"]
```

---

## 4. 验证器执行顺序

```python
from pydantic import BaseModel, Field, validator, root_validator

class User(BaseModel):
    username: str = Field(min_length=3)  # 步骤2
    age: int                              # 步骤1

    @validator('username')  # 步骤3
    def username_alphanumeric(cls, v):
        print(f"validator: {v}")
        return v

    @root_validator  # 步骤4
    def check_all(cls, values):
        print(f"root_validator: {values}")
        return values

# 执行顺序：
# 1. 类型验证（age: int）
# 2. Field 约束验证（username: min_length=3）
# 3. @validator 验证
# 4. @root_validator 验证
```

---

## 5. 在 AI Agent 开发中的应用

### 5.1 RAG 参数验证

```python
from pydantic import BaseModel, Field, validator, root_validator
from typing import Optional

class RAGQuery(BaseModel):
    question: str = Field(min_length=1, max_length=500)
    top_k: int = Field(default=5, ge=1, le=20)
    threshold: float = Field(default=0.7, ge=0.0, le=1.0)
    rerank: bool = False
    rerank_top_n: Optional[int] = None

    @validator('question')
    def question_not_only_whitespace(cls, v):
        if not v.strip():
            raise ValueError('question cannot be only whitespace')
        return v.strip()

    @root_validator
    def check_rerank_config(cls, values):
        rerank = values.get('rerank')
        rerank_top_n = values.get('rerank_top_n')

        if rerank and rerank_top_n is None:
            # 如果启用 rerank，设置默认值
            values['rerank_top_n'] = min(values.get('top_k', 5), 10)
        elif not rerank and rerank_top_n is not None:
            # 如果未启用 rerank，忽略 rerank_top_n
            values['rerank_top_n'] = None

        return values
```

### 5.2 Agent 工具参数验证

```python
from pydantic import BaseModel, validator
from typing import Dict, Any

class ToolCall(BaseModel):
    tool_name: str
    parameters: Dict[str, Any]

    @validator('tool_name')
    def tool_name_valid(cls, v):
        # 工具名称只能包含字母、数字、下划线
        if not v.replace('_', '').isalnum():
            raise ValueError('invalid tool name')
        return v

    @validator('parameters')
    def parameters_not_empty(cls, v, values):
        tool_name = values.get('tool_name')
        # 某些工具必须有参数
        required_params_tools = ['search', 'calculate']
        if tool_name in required_params_tools and not v:
            raise ValueError(f'{tool_name} requires parameters')
        return v
```

---

## 6. 最佳实践

### 6.1 选择合适的验证器

| 场景 | 使用 |
|------|------|
| 单字段验证 | `@validator` |
| 跨字段验证 | `@validator`（访问 values）或 `@root_validator` |
| 多字段联合验证 | `@root_validator` |
| 数据预处理 | `@validator(pre=True)` 或 `@root_validator(pre=True)` |
| 条件验证 | `@root_validator` |

### 6.2 错误消息清晰

```python
# ✅ 好的做法
@validator('age')
def age_valid(cls, v):
    if v < 0:
        raise ValueError('age must be non-negative')
    if v > 150:
        raise ValueError('age must be less than 150')
    return v

# ❌ 不好的做法
@validator('age')
def age_valid(cls, v):
    if v < 0 or v > 150:
        raise ValueError('invalid age')  # 不清楚哪里错了
    return v
```

### 6.3 避免重复验证

```python
# ✅ 好的做法：在 validator 中验证
class User(BaseModel):
    username: str

    @validator('username')
    def username_valid(cls, v):
        if len(v) < 3:
            raise ValueError('too short')
        return v

# ❌ 不好的做法：在业务逻辑中重复验证
@app.post("/users")
async def create_user(user: User):
    if len(user.username) < 3:  # 重复验证
        raise HTTPException(400, "username too short")
```

---

## 7. 核心要点总结

1. **@validator** - 字段级验证，可访问其他已验证字段
2. **@root_validator** - 模型级验证，可访问所有字段
3. **pre=True** - 在类型验证前执行，用于数据预处理
4. **always=True** - 即使字段未提供也执行
5. **执行顺序** - 类型 → Field → validator → root_validator

---

## 8. 学习检查清单

- [ ] 使用 @validator 验证单个字段
- [ ] 使用 @validator 访问其他字段值
- [ ] 使用 @root_validator 进行跨字段验证
- [ ] 理解 pre=True 和 always=True 的作用
- [ ] 编写清晰的验证错误消息
- [ ] 在 AI Agent 开发中应用验证器

---

**版本：** v1.0
**最后更新：** 2026-02-11
