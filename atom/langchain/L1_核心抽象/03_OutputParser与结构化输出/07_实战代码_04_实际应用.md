# 实战代码 4：实际应用

展示 OutputParser 在 RAG 系统和 Agent 中的实际应用场景。

---

## 场景 1：RAG 元数据提取

```python
"""
场景：从文档中提取结构化元数据用于 RAG 检索
方法：with_structured_output() + 向量存储
"""

import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_chroma import Chroma
from pydantic import BaseModel, Field
from typing import List
from datetime import datetime

load_dotenv()

print("=== 场景 1：RAG 元数据提取 ===\n")

# 1. 定义文档元数据模型
class DocumentMetadata(BaseModel):
    title: str = Field(description="文档标题")
    author: str = Field(description="作者")
    publish_date: str = Field(description="发布日期 YYYY-MM-DD")
    category: str = Field(description="分类（技术/商业/教育等）")
    keywords: List[str] = Field(description="关键词列表")
    summary: str = Field(description="文档摘要（50字以内）")
    difficulty: str = Field(description="难度级别（初级/中级/高级）")

# 2. 创建元数据提取器
llm = ChatOpenAI(model="gpt-4o", temperature=0)
metadata_extractor = llm.with_structured_output(DocumentMetadata)

# 3. 示例文档
documents = [
    {
        "content": """
        Python 异步编程完全指南
        作者：张三
        发布于 2026-01-15

        本文详细介绍了 Python 中的异步编程概念，包括 async/await 语法、
        事件循环、协程等核心概念。适合有 Python 基础的开发者学习。
        涵盖 asyncio、aiohttp、异步数据库操作等实战内容。
        """,
        "doc_id": "doc_001"
    },
    {
        "content": """
        企业数字化转型策略
        作者：李四
        2026-02-10

        本报告分析了企业数字化转型的关键要素，包括组织架构调整、
        技术栈选择、人才培养等方面。基于 50+ 企业案例研究。
        适合企业管理者和 CTO 阅读。
        """,
        "doc_id": "doc_002"
    }
]

# 4. 提取元数据
print("提取文档元数据...\n")
enriched_docs = []

for doc in documents:
    print(f"处理文档: {doc['doc_id']}")

    # 提取元数据
    metadata = metadata_extractor.invoke(
        f"从以下文档中提取元数据：\n\n{doc['content']}"
    )

    print(f"  标题: {metadata.title}")
    print(f"  分类: {metadata.category}")
    print(f"  关键词: {', '.join(metadata.keywords)}")
    print(f"  难度: {metadata.difficulty}")
    print()

    enriched_docs.append({
        "content": doc["content"],
        "metadata": metadata.dict(),
        "doc_id": doc["doc_id"]
    })

# 5. 存入向量数据库（带元数据）
print("存入向量数据库...\n")

embeddings = OpenAIEmbeddings()
vector_store = Chroma(
    collection_name="documents_with_metadata",
    embedding_function=embeddings
)

# 添加文档（带结构化元数据）
for doc in enriched_docs:
    vector_store.add_texts(
        texts=[doc["content"]],
        metadatas=[doc["metadata"]],
        ids=[doc["doc_id"]]
    )

print("✅ 文档已存入向量数据库\n")

# 6. 基于元数据检索
print("=== 基于元数据检索 ===\n")

# 检索 1：按分类过滤
print("检索 1：查找技术类文档")
results = vector_store.similarity_search(
    query="异步编程",
    k=2,
    filter={"category": "技术"}
)
for i, doc in enumerate(results, 1):
    print(f"  {i}. {doc.metadata['title']}")
    print(f"     分类: {doc.metadata['category']}")
    print(f"     关键词: {', '.join(doc.metadata['keywords'])}")
print()

# 检索 2：按难度过滤
print("检索 2：查找初级难度文档")
results = vector_store.similarity_search(
    query="学习资料",
    k=2,
    filter={"difficulty": "初级"}
)
for i, doc in enumerate(results, 1):
    print(f"  {i}. {doc.metadata['title']}")
    print(f"     难度: {doc.metadata['difficulty']}")
print()

# 预期输出：
# 提取文档元数据...
# 处理文档: doc_001
#   标题: Python 异步编程完全指南
#   分类: 技术
#   关键词: Python, 异步编程, asyncio, 协程
#   难度: 中级
```

---

## 场景 2：Agent 工具响应格式化

```python
"""
场景：Agent 调用工具后格式化响应
方法：结构化工具响应
"""

print("=== 场景 2：Agent 工具响应格式化 ===\n")

from typing import Optional, Literal

# 1. 定义工具响应模型
class WeatherResponse(BaseModel):
    city: str = Field(description="城市名称")
    temperature: float = Field(description="温度（摄氏度）")
    condition: str = Field(description="天气状况")
    humidity: int = Field(description="湿度（百分比）", ge=0, le=100)
    wind_speed: float = Field(description="风速（km/h）", ge=0)
    recommendation: str = Field(description="出行建议")

class SearchResponse(BaseModel):
    query: str = Field(description="搜索查询")
    results_count: int = Field(description="结果数量")
    top_results: List[str] = Field(description="前3个结果标题")
    summary: str = Field(description="结果摘要")

# 2. 模拟工具调用
def call_weather_api(city: str) -> str:
    """模拟天气 API 调用"""
    return f"北京今天晴天，温度 15 度，湿度 60%，风速 10 km/h"

def call_search_api(query: str) -> str:
    """模拟搜索 API 调用"""
    return """
    搜索 "Python 异步编程" 返回 1250 个结果
    前3个结果：
    1. Python asyncio 官方文档
    2. 异步编程最佳实践
    3. async/await 完全指南
    """

# 3. 创建响应格式化器
weather_formatter = llm.with_structured_output(WeatherResponse)
search_formatter = llm.with_structured_output(SearchResponse)

# 4. Agent 工作流
print("Agent 执行任务：查询北京天气\n")

# 步骤 1：调用工具
raw_weather = call_weather_api("北京")
print(f"工具原始响应: {raw_weather}\n")

# 步骤 2：格式化响应
formatted_weather = weather_formatter.invoke(
    f"格式化天气信息并提供出行建议：{raw_weather}"
)
print(f"格式化后的响应:")
print(f"  城市: {formatted_weather.city}")
print(f"  温度: {formatted_weather.temperature}°C")
print(f"  天气: {formatted_weather.condition}")
print(f"  湿度: {formatted_weather.humidity}%")
print(f"  风速: {formatted_weather.wind_speed} km/h")
print(f"  建议: {formatted_weather.recommendation}")
print()

# 步骤 3：Agent 基于结构化数据做决策
if formatted_weather.temperature < 10:
    action = "建议穿厚外套"
elif formatted_weather.condition == "雨天":
    action = "建议带雨伞"
else:
    action = "天气不错，适合出行"

print(f"Agent 决策: {action}\n")

# 预期输出：
# 格式化后的响应:
#   城市: 北京
#   温度: 15.0°C
#   天气: 晴天
#   湿度: 60%
#   风速: 10.0 km/h
#   建议: 天气晴朗，适合户外活动，建议穿轻薄外套
```

---

## 场景 3：多步推理with结构化中间结果

```python
"""
场景：Agent 多步推理，每步都返回结构化结果
方法：链式结构化输出
"""

print("=== 场景 3：多步推理with结构化中间结果 ===\n")

# 1. 定义多步推理的中间结果模型
class Step1_Analysis(BaseModel):
    user_intent: str = Field(description="用户意图")
    required_tools: List[str] = Field(description="需要的工具列表")
    priority: Literal["high", "medium", "low"] = Field(description="优先级")

class Step2_Plan(BaseModel):
    steps: List[str] = Field(description="执行步骤列表")
    estimated_complexity: Literal["simple", "moderate", "complex"] = Field(
        description="复杂度评估"
    )

class Step3_Result(BaseModel):
    success: bool = Field(description="是否成功")
    output: str = Field(description="输出结果")
    next_action: Optional[str] = Field(None, description="下一步行动")

# 2. 创建多步推理链
step1_analyzer = llm.with_structured_output(Step1_Analysis)
step2_planner = llm.with_structured_output(Step2_Plan)
step3_executor = llm.with_structured_output(Step3_Result)

# 3. 用户请求
user_request = "帮我查询北京明天的天气，如果下雨就推荐室内活动"

print(f"用户请求: {user_request}\n")

# 步骤 1：分析意图
print("步骤 1：分析用户意图")
analysis = step1_analyzer.invoke(f"分析用户请求：{user_request}")
print(f"  意图: {analysis.user_intent}")
print(f"  需要工具: {', '.join(analysis.required_tools)}")
print(f"  优先级: {analysis.priority}")
print()

# 步骤 2：制定计划
print("步骤 2：制定执行计划")
plan = step2_planner.invoke(
    f"为以下任务制定计划：{analysis.user_intent}\n可用工具：{', '.join(analysis.required_tools)}"
)
print(f"  复杂度: {plan.estimated_complexity}")
print(f"  执行步骤:")
for i, step in enumerate(plan.steps, 1):
    print(f"    {i}. {step}")
print()

# 步骤 3：执行并返回结果
print("步骤 3：执行任务")
# 模拟执行
execution_log = """
1. 调用天气 API：北京明天多云转晴，温度 18-25 度
2. 判断：不下雨
3. 结论：无需推荐室内活动
"""
result = step3_executor.invoke(f"总结执行结果：{execution_log}")
print(f"  成功: {'✅' if result.success else '❌'}")
print(f"  输出: {result.output}")
if result.next_action:
    print(f"  下一步: {result.next_action}")
print()

# 预期输出：
# 步骤 1：分析用户意图
#   意图: 查询明天天气并根据天气推荐活动
#   需要工具: 天气查询API, 活动推荐系统
#   优先级: medium
#
# 步骤 2：制定执行计划
#   复杂度: moderate
#   执行步骤:
#     1. 调用天气 API 查询北京明天天气
#     2. 判断是否下雨
#     3. 如果下雨，调用活动推荐系统推荐室内活动
#     4. 返回结果给用户
```

---

## 场景 4：批量文档分类

```python
"""
场景：批量分类文档并提取关键信息
方法：结构化分类 + 批量处理
"""

print("=== 场景 4：批量文档分类 ===\n")

# 1. 定义分类模型
class DocumentClassification(BaseModel):
    category: Literal["技术", "商业", "教育", "新闻", "其他"] = Field(
        description="文档分类"
    )
    subcategory: str = Field(description="子分类")
    confidence: float = Field(description="置信度", ge=0, le=1)
    key_entities: List[str] = Field(description="关键实体（人名、地名、组织等）")
    action_items: List[str] = Field(description="行动项（如果有）")

# 2. 创建分类器
classifier = llm.with_structured_output(DocumentClassification)

# 3. 批量文档
documents = [
    "OpenAI 发布 GPT-5 模型，性能提升 50%，支持多模态输入",
    "Python 3.13 新特性：改进的类型系统和性能优化",
    "公司 Q1 财报：营收增长 25%，需要在下周董事会上汇报",
    "机器学习入门课程：从零开始学习神经网络"
]

# 4. 批量分类
print(f"批量分类 {len(documents)} 个文档...\n")
classifications = classifier.batch([
    f"分类以下文档：{doc}" for doc in documents
])

# 5. 输出结果
for i, (doc, classification) in enumerate(zip(documents, classifications), 1):
    print(f"文档 {i}: {doc[:40]}...")
    print(f"  分类: {classification.category} > {classification.subcategory}")
    print(f"  置信度: {classification.confidence:.2%}")
    print(f"  关键实体: {', '.join(classification.key_entities)}")
    if classification.action_items:
        print(f"  行动项: {', '.join(classification.action_items)}")
    print()

# 6. 统计分析
from collections import Counter
category_counts = Counter(c.category for c in classifications)
print("分类统计:")
for category, count in category_counts.items():
    print(f"  {category}: {count} 个文档")

# 预期输出：
# 文档 1: OpenAI 发布 GPT-5 模型...
#   分类: 新闻 > 科技新闻
#   置信度: 95.00%
#   关键实体: OpenAI, GPT-5
#
# 文档 2: Python 3.13 新特性...
#   分类: 技术 > 编程语言
#   置信度: 98.00%
#   关键实体: Python, 3.13
```

---

## 场景 5：对话式 RAG with上下文管理

```python
"""
场景：对话式 RAG，维护结构化对话上下文
方法：结构化对话状态
"""

print("=== 场景 5：对话式 RAG with上下文管理 ===\n")

# 1. 定义对话状态模型
class ConversationState(BaseModel):
    user_query: str = Field(description="用户查询")
    intent: str = Field(description="查询意图")
    entities: List[str] = Field(description="提取的实体")
    context_needed: bool = Field(description="是否需要历史上下文")
    search_keywords: List[str] = Field(description="搜索关键词")

class RAGResponse(BaseModel):
    answer: str = Field(description="回答")
    sources: List[str] = Field(description="来源文档")
    confidence: float = Field(description="置信度", ge=0, le=1)
    follow_up_questions: List[str] = Field(description="建议的后续问题")

# 2. 创建对话管理器
state_analyzer = llm.with_structured_output(ConversationState)
response_generator = llm.with_structured_output(RAGResponse)

# 3. 模拟对话
conversation_history = []

queries = [
    "Python 中如何实现异步编程？",
    "asyncio 和 threading 有什么区别？",  # 需要上下文
    "能给个代码示例吗？"  # 需要上下文
]

for i, query in enumerate(queries, 1):
    print(f"轮次 {i}")
    print(f"用户: {query}\n")

    # 分析查询状态
    state = state_analyzer.invoke(
        f"分析查询（历史：{conversation_history}）：{query}"
    )

    print(f"  意图: {state.intent}")
    print(f"  实体: {', '.join(state.entities) if state.entities else '无'}")
    print(f"  需要上下文: {'是' if state.context_needed else '否'}")
    print(f"  搜索关键词: {', '.join(state.search_keywords)}")
    print()

    # 模拟检索和生成响应
    context = "（模拟检索到的文档内容）"
    response = response_generator.invoke(
        f"基于上下文回答：{query}\n上下文：{context}\n历史：{conversation_history}"
    )

    print(f"  回答: {response.answer}")
    print(f"  置信度: {response.confidence:.2%}")
    print(f"  后续问题:")
    for q in response.follow_up_questions:
        print(f"    - {q}")
    print()

    # 更新历史
    conversation_history.append({
        "query": query,
        "state": state.dict(),
        "response": response.answer
    })

# 预期输出：
# 轮次 1
# 用户: Python 中如何实现异步编程？
#   意图: 技术问答
#   实体: Python, 异步编程
#   需要上下文: 否
#   搜索关键词: Python, async, asyncio
```

---

## 完整运行示例

```python
"""
完整示例：运行所有实际应用场景
"""

def main():
    """运行所有实际应用场景"""
    print("=" * 60)
    print("OutputParser 实际应用演示")
    print("=" * 60)
    print()

    # 场景 1-5 的代码...
    # （在实际运行时，将上面所有场景的代码整合到这里）

    print("=" * 60)
    print("所有实际应用场景演示完成！")
    print("=" * 60)

if __name__ == "__main__":
    main()
```

---

## 关键要点

1. **RAG 元数据提取**：结构化元数据提升检索精度
2. **Agent 工具响应**：标准化工具输出便于决策
3. **多步推理**：每步返回结构化结果便于调试
4. **批量分类**：高效处理大量文档
5. **对话式 RAG**：维护结构化对话状态

---

## 实际应用价值

### RAG 系统
- **精准检索**：基于结构化元数据过滤
- **多维度搜索**：按分类、难度、日期等维度
- **上下文管理**：结构化对话状态

### Agent 系统
- **工具集成**：标准化工具响应格式
- **决策逻辑**：基于结构化数据做判断
- **可观测性**：每步都有结构化日志

### 生产环境
- **类型安全**：编译时类型检查
- **数据验证**：自动验证业务规则
- **可维护性**：结构化数据易于调试

---

**记住**：OutputParser 是 AI 应用从 Demo 到生产的关键基础设施！
