# 面试必问

## 问题："FastAPI 的中间件和依赖注入有什么区别？什么时候用中间件，什么时候用依赖注入？"

**普通回答（❌ 不出彩）：**

"中间件是全局的，依赖注入是局部的。中间件用于日志和认证，依赖注入用于数据库连接。"

**出彩回答（✅ 推荐）：**

> **FastAPI 的中间件和依赖注入是两种不同的横切关注点解决方案，有三个关键区别：**
>
> **1. 作用范围不同：**
> - 中间件是**全局拦截器**，应用到所有路由，无法选择性应用
> - 依赖注入是**局部注入器**，只应用到指定的路由，可以精确控制
>
> **2. 执行时机不同：**
> - 中间件在**请求到达路由之前**和**响应返回之后**执行，是请求的外层包装
> - 依赖注入在**路由处理时**执行，是路由的参数准备阶段
>
> **3. 访问能力不同：**
> - 中间件只能访问**原始请求对象**（Request），无法访问路由参数、请求体等解析后的数据
> - 依赖注入可以访问**解析后的数据**（路径参数、查询参数、请求体），并且可以嵌套依赖
>
> **选择原则：**
>
> | 场景 | 选择 | 原因 |
> |------|------|------|
> | 日志记录所有请求 | 中间件 | 需要应用到所有路由 |
> | CORS 跨域配置 | 中间件 | 需要在路由处理前设置响应头 |
> | 全局认证拦截 | 中间件 | 需要在路由处理前验证 token |
> | 数据库连接管理 | 依赖注入 | 只有部分路由需要数据库 |
> | 获取当前用户信息 | 依赖注入 | 需要解析 token 并查询数据库 |
> | 分页参数解析 | 依赖注入 | 只有列表接口需要分页 |
>
> **在实际工作中的应用：**
>
> 在我们的 AI Agent 后端项目中，我们这样组合使用：
>
> ```python
> # 中间件：全局日志和 CORS
> @app.middleware("http")
> async def log_middleware(request: Request, call_next):
>     print(f"{request.method} {request.url.path}")
>     response = await call_next(request)
>     return response
>
> app.add_middleware(CORSMiddleware, allow_origins=["*"])
>
> # 依赖注入：数据库连接（只有需要的路由才注入）
> def get_db():
>     db = SessionLocal()
>     try:
>         yield db
>     finally:
>         db.close()
>
> # 依赖注入：当前用户（只有需要认证的路由才注入）
> async def get_current_user(
>     token: str = Depends(oauth2_scheme),
>     db: Session = Depends(get_db)
> ):
>     payload = jwt.decode(token, SECRET_KEY)
>     user = db.query(User).filter(User.id == payload["user_id"]).first()
>     if not user:
>         raise HTTPException(401, "User not found")
>     return user
>
> # 路由：组合使用
> @app.get("/api/agent/chat")
> async def chat(
>     message: str,
>     user: User = Depends(get_current_user),  # 依赖注入
>     db: Session = Depends(get_db)            # 依赖注入
> ):
>     # 中间件已经记录了日志和处理了 CORS
>     # 依赖注入已经验证了用户和准备了数据库连接
>     # 这里只需要关注业务逻辑
>     return {"response": "..."}
> ```
>
> **核心思想：** 中间件是"一刀切"的全局处理，依赖注入是"按需注入"的局部处理。两者配合使用，可以构建清晰、高效的 API 架构。

**为什么这个回答出彩？**

1. ✅ **结构清晰**：用三个维度（作用范围、执行时机、访问能力）系统性地对比
2. ✅ **有具体例子**：提供了实际项目中的代码示例，展示如何组合使用
3. ✅ **有决策表格**：给出了明确的选择原则，展示了实战经验
4. ✅ **联系实际应用**：结合 AI Agent 后端开发场景，展示了深度理解

---

## 问题："FastAPI 中间件的执行顺序是怎样的？如果有多个中间件，它们是如何协作的？"

**普通回答（❌ 不出彩）：**

"中间件按注册顺序执行，先注册的先执行。"

**出彩回答（✅ 推荐）：**

> **FastAPI 中间件使用的是洋葱模型（Onion Model），不是简单的线性执行：**
>
> **1. 洋葱模型的执行流程：**
>
> ```
> 请求进入：
> 客户端 → 中间件1 → 中间件2 → 中间件3 → 路由 → 中间件3 → 中间件2 → 中间件1 → 客户端
>          ↓before  ↓before  ↓before  ↓handle ↑after   ↑after   ↑after
> ```
>
> 先注册的中间件在**最外层**，后注册的在**最内层**。请求从外到内，响应从内到外。
>
> **2. 代码示例：**
>
> ```python
> @app.middleware("http")
> async def middleware_1(request: Request, call_next):
>     print("1: before")
>     response = await call_next(request)
>     print("1: after")
>     return response
>
> @app.middleware("http")
> async def middleware_2(request: Request, call_next):
>     print("2: before")
>     response = await call_next(request)
>     print("2: after")
>     return response
>
> @app.get("/test")
> async def test():
>     print("Handler")
>     return {"message": "ok"}
>
> # 输出顺序：
> # 1: before
> # 2: before
> # Handler
> # 2: after
> # 1: after
> ```
>
> **3. 为什么是洋葱模型？**
>
> 因为每个中间件都要：
> - 在请求到达下一层之前做一些事（before）
> - 调用 `await call_next(request)` 让请求继续传递
> - 在响应返回上一层之前做一些事（after）
>
> 这就像剥洋葱，一层一层进去，再一层一层出来。
>
> **4. 实际应用中的顺序设计：**
>
> 在 AI Agent 后端中，我们通常这样安排中间件顺序：
>
> ```python
> # 1. 最外层：日志中间件（记录完整的请求时间）
> @app.middleware("http")
> async def log_middleware(request: Request, call_next):
>     start = time.time()
>     response = await call_next(request)
>     duration = time.time() - start
>     print(f"{request.method} {request.url.path} - {duration:.3f}s")
>     return response
>
> # 2. 第二层：CORS 中间件（处理跨域）
> app.add_middleware(CORSMiddleware, allow_origins=["*"])
>
> # 3. 第三层：认证中间件（验证用户身份）
> @app.middleware("http")
> async def auth_middleware(request: Request, call_next):
>     # 验证 token...
>     response = await call_next(request)
>     return response
>
> # 4. 最内层：限流中间件（防止滥用）
> @app.middleware("http")
> async def rate_limit_middleware(request: Request, call_next):
>     # 检查限流...
>     response = await call_next(request)
>     return response
> ```
>
> **顺序原则：**
> - **日志在最外层**：记录完整的请求时间（包括所有中间件的时间）
> - **CORS 在外层**：确保跨域请求能正常处理
> - **认证在中层**：在业务逻辑前验证身份
> - **限流在内层**：在认证后再检查限流（避免浪费资源）
>
> **5. 与 Express 的对比：**
>
> Express 也是洋葱模型，但 FastAPI 的 `await call_next()` 更明确地表达了这个模型：
>
> ```javascript
> // Express
> app.use((req, res, next) => {
>   console.log('before');
>   next();  // 隐式的洋葱模型
>   console.log('after');
> });
> ```
>
> ```python
> # FastAPI
> @app.middleware("http")
> async def my_middleware(request: Request, call_next):
>     print('before')
>     response = await call_next(request)  # 显式的洋葱模型
>     print('after')
>     return response
> ```

**为什么这个回答出彩？**

1. ✅ **纠正了常见误区**：明确指出不是简单的线性执行
2. ✅ **有可视化说明**：用 ASCII 图展示了执行流程
3. ✅ **有代码验证**：提供了可运行的代码示例
4. ✅ **有实战经验**：给出了实际项目中的顺序设计原则
5. ✅ **有对比分析**：与 Express 对比，展示了深度理解

---

## 总结

面试中关于中间件的问题，核心考察点是：

1. **理解洋葱模型**：不是简单的线性执行
2. **区分中间件和依赖注入**：知道什么时候用什么
3. **实战经验**：能给出合理的中间件顺序设计
4. **深度理解**：能解释为什么这样设计

**记住：** 面试官不只是想听定义，更想听你的理解和实战经验。用具体例子和对比分析，展示你的深度思考。
