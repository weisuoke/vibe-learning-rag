# 核心概念5：配置层级与优先级

## 一句话定义

**配置层级与优先级是指多个配置来源（系统环境变量、.env 文件、默认值）按照优先级规则相互覆盖的机制，让外部配置能够覆盖内部配置，实现灵活的配置管理。**

---

## 为什么需要配置层级与优先级？

### 问题场景

在实际开发中，配置可能来自多个来源：

```python
# 问题：多个配置来源，哪个优先？

# 1. 代码中的默认值
DEBUG = False

# 2. .env 文件中的配置
# DEBUG=True

# 3. 系统环境变量
# export DEBUG=False

# 最终 DEBUG 是 True 还是 False？
```

**如果没有明确的优先级规则：**
- 配置行为不可预测
- 难以在不同环境中覆盖配置
- 部署时无法灵活调整配置

---

## 标准优先级规则

### 优先级顺序

**从高到低：**

```
1. 系统环境变量（最高优先级）
   ↓
2. .env 文件
   ↓
3. 代码中的默认值（最低优先级）
```

**原则：外部配置覆盖内部配置**

---

## 为什么是这个优先级？

### 原因1：部署灵活性

**系统环境变量优先级最高，可以在部署时覆盖任何配置。**

```bash
# 开发时：使用 .env 文件
# .env
DEBUG=True

# 生产部署时：用系统环境变量覆盖
export DEBUG=False
docker run -e DEBUG=False my-app

# 系统环境变量覆盖 .env 文件
```

---

### 原因2：安全性

**敏感信息（如生产环境密钥）不应该存储在 .env 文件中，而应该通过系统环境变量注入。**

```bash
# 开发时：.env 文件（可以提交到 git）
# .env
OPENAI_API_KEY=sk-dev-xxx

# 生产时：系统环境变量（不提交到 git）
export OPENAI_API_KEY=sk-prod-xxx

# 系统环境变量覆盖 .env 文件，保护生产密钥
```

---

### 原因3：默认值兜底

**代码中的默认值优先级最低，作为兜底配置。**

```python
# 默认值：当没有任何外部配置时使用
class Settings(BaseSettings):
    debug: bool = False  # 默认值
    port: int = 8000     # 默认值

# 如果没有设置环境变量或 .env 文件，使用默认值
```

---

## 配置层级的实现

### 实现1：python-dotenv 的优先级

**默认行为：系统环境变量优先**

```python
from dotenv import load_dotenv
import os

# 系统环境变量
# export DEBUG=False

# .env 文件
# DEBUG=True

# 加载 .env 文件（不覆盖已有的系统环境变量）
load_dotenv()

print(os.getenv("DEBUG"))  # False（系统环境变量优先）
```

**强制覆盖：.env 文件优先**

```python
# 强制用 .env 文件覆盖系统环境变量
load_dotenv(override=True)

print(os.getenv("DEBUG"))  # True（.env 文件覆盖系统环境变量）
```

---

### 实现2：Pydantic Settings 的优先级

**自动遵循标准优先级规则**

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    debug: bool = False  # 默认值（优先级最低）

    class Config:
        env_file = ".env"  # .env 文件（优先级中等）

# 系统环境变量（优先级最高）
# export DEBUG=True

settings = Settings()
print(settings.debug)  # True（系统环境变量覆盖 .env 和默认值）
```

---

### 实现3：多层配置文件

**支持多个配置文件的层级覆盖**

```python
from dotenv import load_dotenv

# 1. 加载基础配置（优先级最低）
load_dotenv(".env")

# 2. 加载环境特定配置（覆盖基础配置）
load_dotenv(".env.dev", override=True)

# 3. 加载本地配置（覆盖环境配置）
load_dotenv(".env.local", override=True)

# 4. 系统环境变量（优先级最高，自动覆盖）
```

**配置文件：**

```bash
# .env（基础配置）
APP_NAME=AI Agent API
LOG_LEVEL=INFO
DEBUG=False

# .env.dev（开发环境配置）
DEBUG=True
DATABASE_URL=postgresql://localhost:5432/dev_db

# .env.local（本地配置，不提交到 git）
DATABASE_URL=postgresql://localhost:5433/my_local_db
```

**优先级：**
```
系统环境变量 > .env.local > .env.dev > .env > 默认值
```

---

## 配置优先级的实际应用

### 场景1：本地开发覆盖

**开发者可以用 .env.local 覆盖团队共享的 .env.dev**

```bash
# .env.dev（团队共享，提交到 git）
DATABASE_URL=postgresql://localhost:5432/dev_db
OPENAI_API_KEY=sk-team-dev-xxx

# .env.local（个人配置，不提交到 git）
DATABASE_URL=postgresql://localhost:5433/my_local_db
OPENAI_API_KEY=sk-my-personal-xxx
```

```python
# config.py
from dotenv import load_dotenv

# 加载团队配置
load_dotenv(".env.dev")

# 加载个人配置（覆盖团队配置）
load_dotenv(".env.local", override=True)

# 个人配置优先
```

---

### 场景2：Docker 部署覆盖

**Docker 容器启动时，用环境变量覆盖 .env 文件**

```yaml
# docker-compose.yml
services:
  api:
    build: .
    environment:
      # 系统环境变量（优先级最高）
      - DEBUG=False
      - DATABASE_URL=postgresql://prod-db:5432/prod_db
    env_file:
      # .env 文件（优先级较低）
      - .env.prod
```

**优先级：** `environment` > `env_file` > 默认值

---

### 场景3：Kubernetes 部署覆盖

**Kubernetes 中，ConfigMap 和 Secret 的优先级**

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - name: api
        env:
        # 直接定义的环境变量（优先级最高）
        - name: DEBUG
          value: "False"
        # 从 ConfigMap 读取（优先级中等）
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: api-config
              key: log-level
        # 从 Secret 读取（优先级中等）
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: api-secrets
              key: openai-api-key
```

**优先级：** 直接定义的 `env` > `ConfigMap`/`Secret` > 默认值

---

### 场景4：CI/CD 部署覆盖

**CI/CD 流水线中，用环境变量覆盖配置**

```yaml
# .github/workflows/deploy.yml
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to production
        env:
          # CI/CD 环境变量（优先级最高）
          ENV: prod
          DEBUG: False
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          python deploy.py
```

---

## 配置优先级的验证

### 验证方法1：打印配置来源

```python
import os
from dotenv import load_dotenv

# 加载 .env 文件
load_dotenv()

def print_config_source(key: str, default: str = None):
    """打印配置的来源"""
    value = os.getenv(key, default)

    # 检查配置来源
    if key in os.environ:
        if os.environ[key] == value:
            source = "系统环境变量"
        else:
            source = ".env 文件"
    elif default is not None:
        source = "默认值"
    else:
        source = "未设置"

    print(f"{key}: {value} (来源: {source})")

# 验证配置
print_config_source("DEBUG", "False")
print_config_source("DATABASE_URL")
print_config_source("OPENAI_API_KEY")
```

---

### 验证方法2：Pydantic Settings 的配置来源

```python
from pydantic_settings import BaseSettings
from pydantic import Field

class Settings(BaseSettings):
    debug: bool = Field(False, description="调试模式")
    database_url: str = Field(..., description="数据库连接")

    class Config:
        env_file = ".env"

settings = Settings()

# 打印配置
print(f"DEBUG: {settings.debug}")
print(f"DATABASE_URL: {settings.database_url}")

# 验证配置来源
import os
if "DEBUG" in os.environ:
    print("DEBUG 来源: 系统环境变量")
else:
    print("DEBUG 来源: .env 文件或默认值")
```

---

## 配置优先级的常见误区

### 误区1：.env 文件优先级最高 ❌

**错误理解：** .env 文件是显式配置的，所以优先级最高。

**正确理解：** 系统环境变量优先级最高，.env 文件优先级中等。

```python
# 系统环境变量
export DEBUG=False

# .env 文件
DEBUG=True

# 加载 .env 文件
load_dotenv()

print(os.getenv("DEBUG"))  # False（系统环境变量优先）
```

---

### 误区2：load_dotenv() 会覆盖系统环境变量 ❌

**错误理解：** load_dotenv() 会覆盖已有的系统环境变量。

**正确理解：** load_dotenv() 默认不覆盖系统环境变量，除非使用 `override=True`。

```python
# 系统环境变量
export DEBUG=False

# .env 文件
DEBUG=True

# 默认不覆盖
load_dotenv()
print(os.getenv("DEBUG"))  # False

# 强制覆盖
load_dotenv(override=True)
print(os.getenv("DEBUG"))  # True
```

---

### 误区3：后加载的配置文件优先级更高 ❌

**错误理解：** 后加载的配置文件会覆盖先加载的。

**正确理解：** 需要使用 `override=True` 才能覆盖。

```python
# 加载基础配置
load_dotenv(".env")

# 加载环境配置（不会覆盖）
load_dotenv(".env.dev")

# 需要显式覆盖
load_dotenv(".env.dev", override=True)
```

---

## 配置优先级的最佳实践

### 实践1：明确配置层级

**定义清晰的配置层级结构**

```
系统环境变量（部署时注入）
    ↓
.env.local（个人配置，不提交）
    ↓
.env.{env}（环境配置，提交）
    ↓
.env（基础配置，提交）
    ↓
代码默认值（兜底）
```

---

### 实践2：使用 override=True 显式覆盖

**明确表示覆盖意图**

```python
# 加载基础配置
load_dotenv(".env")

# 显式覆盖
load_dotenv(".env.dev", override=True)
load_dotenv(".env.local", override=True)
```

---

### 实践3：文档化配置优先级

**在 README 中说明配置优先级**

```markdown
## 配置优先级

配置按以下优先级加载（从高到低）：

1. 系统环境变量（最高优先级）
2. `.env.local`（个人配置，不提交到 git）
3. `.env.{ENV}`（环境配置，如 `.env.dev`、`.env.prod`）
4. `.env`（基础配置）
5. 代码默认值（最低优先级）

示例：
```bash
# 开发环境
ENV=dev python app.py  # 加载 .env.dev

# 生产环境（用系统环境变量覆盖）
export DATABASE_URL=postgresql://prod-db:5432/prod_db
ENV=prod python app.py
```
```

---

### 实践4：验证配置优先级

**在应用启动时验证配置来源**

```python
import os
from dotenv import load_dotenv

load_dotenv()

# 验证关键配置的来源
critical_configs = ["DATABASE_URL", "OPENAI_API_KEY", "SECRET_KEY"]

for key in critical_configs:
    value = os.getenv(key)
    if value:
        # 检查是否来自系统环境变量
        if key in os.environ:
            print(f"✅ {key}: 来自系统环境变量")
        else:
            print(f"⚠️  {key}: 来自 .env 文件")
    else:
        print(f"❌ {key}: 未设置")
```

---

## 高级配置层级

### 特性1：配置继承

**子环境继承父环境的配置**

```python
from dotenv import load_dotenv

# 1. 加载全局配置
load_dotenv(".env")

# 2. 加载环境配置（继承并覆盖）
env = os.getenv("ENV", "dev")
load_dotenv(f".env.{env}", override=True)

# 3. 加载本地配置（继承并覆盖）
load_dotenv(".env.local", override=True)
```

---

### 特性2：配置合并

**合并多个配置源**

```python
from dotenv import dotenv_values

# 读取多个配置文件
base_config = dotenv_values(".env")
env_config = dotenv_values(".env.dev")
local_config = dotenv_values(".env.local")

# 合并配置（后者覆盖前者）
config = {**base_config, **env_config, **local_config}

print(config)
```

---

### 特性3：配置验证

**验证配置的完整性和优先级**

```python
from pydantic_settings import BaseSettings
from pydantic import field_validator

class Settings(BaseSettings):
    database_url: str
    debug: bool = False

    @field_validator("debug")
    @classmethod
    def validate_debug(cls, v: bool) -> bool:
        import os
        # 生产环境必须禁用调试模式
        if os.getenv("ENV") == "prod" and v:
            raise ValueError("生产环境不能启用调试模式")
        return v

    class Config:
        env_file = ".env"

settings = Settings()
```

---

## 在 AI Agent 后端中的应用

### 完整示例

```python
# config.py
import os
from enum import Enum
from pydantic import Field, field_validator
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

# 1. 加载基础配置
load_dotenv(".env")

# 2. 加载环境配置
env = os.getenv("ENV", "dev")
load_dotenv(f".env.{env}", override=True)

# 3. 加载本地配置
load_dotenv(".env.local", override=True)

class Environment(str, Enum):
    DEV = "dev"
    TEST = "test"
    PROD = "prod"

class Settings(BaseSettings):
    # 环境标识
    env: Environment = Environment.DEV

    # 应用配置
    app_name: str = "AI Agent API"
    debug: bool = False
    log_level: str = "INFO"

    # 数据库配置
    database_url: str
    database_pool_size: int = 10

    # LLM 配置
    openai_api_key: str
    openai_model: str = "gpt-4"

    # 安全配置
    secret_key: str

    @field_validator("debug")
    @classmethod
    def validate_debug(cls, v: bool, info) -> bool:
        # 生产环境不能启用调试模式
        if info.data.get("env") == Environment.PROD and v:
            raise ValueError("生产环境不能启用调试模式")
        return v

    class Config:
        # 不再需要 env_file，因为已经手动加载
        pass

settings = Settings()

# 打印配置来源
print(f"✅ 环境: {settings.env}")
print(f"✅ 调试模式: {settings.debug}")
print(f"✅ 数据库: {settings.database_url}")

# 验证配置来源
if "DATABASE_URL" in os.environ:
    print("✅ DATABASE_URL 来源: 系统环境变量")
else:
    print("⚠️  DATABASE_URL 来源: .env 文件")
```

**配置文件：**

```bash
# .env（基础配置，提交到 git）
APP_NAME=AI Agent API
LOG_LEVEL=INFO
DATABASE_POOL_SIZE=10
OPENAI_MODEL=gpt-4

# .env.dev（开发环境配置，提交到 git）
ENV=dev
DEBUG=True
DATABASE_URL=postgresql://localhost:5432/dev_db
OPENAI_API_KEY=sk-dev-xxx
SECRET_KEY=dev-secret-key-xxxxxxxxxxxxx

# .env.prod（生产环境配置，不提交到 git）
ENV=prod
DEBUG=False
DATABASE_URL=postgresql://prod-db:5432/prod_db
OPENAI_API_KEY=sk-prod-xxx
SECRET_KEY=prod-secret-key-xxxxxxxxxxxxx

# .env.local（本地配置，不提交到 git）
DATABASE_URL=postgresql://localhost:5433/my_local_db
OPENAI_API_KEY=sk-my-personal-xxx
```

**优先级验证：**

```bash
# 场景1：只有 .env 文件
python app.py
# DATABASE_URL: postgresql://localhost:5432/dev_db（来自 .env.dev）

# 场景2：有 .env.local
python app.py
# DATABASE_URL: postgresql://localhost:5433/my_local_db（来自 .env.local）

# 场景3：有系统环境变量
export DATABASE_URL=postgresql://custom:5432/custom_db
python app.py
# DATABASE_URL: postgresql://custom:5432/custom_db（来自系统环境变量）
```

---

## 总结

**配置层级与优先级的核心原则：**

1. **标准优先级**：系统环境变量 > .env 文件 > 默认值
2. **外部覆盖内部**：外部配置（系统环境变量）优先级最高
3. **显式覆盖**：使用 `override=True` 显式表示覆盖意图
4. **多层继承**：支持多个配置文件的层级覆盖

**优先级规则：**

```
系统环境变量（部署时注入）
    ↓
.env.local（个人配置）
    ↓
.env.{env}（环境配置）
    ↓
.env（基础配置）
    ↓
代码默认值（兜底）
```

**最佳实践：**
- 明确配置层级结构
- 使用 `override=True` 显式覆盖
- 文档化配置优先级
- 验证配置来源
- 生产环境锁定关键配置

**实际应用：**
- 本地开发：.env.local 覆盖团队配置
- Docker 部署：环境变量覆盖 .env 文件
- Kubernetes 部署：ConfigMap/Secret 覆盖默认值
- CI/CD 部署：流水线环境变量覆盖所有配置
