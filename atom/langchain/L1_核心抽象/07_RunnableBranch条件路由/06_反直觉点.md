# 反直觉点

揭示 RunnableBranch 中最容易误解的3个概念。

---

## 误区1：条件会并行评估 ❌

**错误观点**：
"RunnableBranch 会同时评估所有条件，然后选择最匹配的分支执行。"

### 为什么错？

**实际机制**：条件是**顺序评估**的，从上到下逐个检查，**第一个返回 True 的分支立即执行**，后续条件不再评估。

```python
from langchain_core.runnables import RunnableBranch, RunnableLambda

# 示例：条件有副作用
call_count = {"count": 0}

def condition1(x):
    call_count["count"] += 1
    print(f"Condition 1 called (count: {call_count['count']})")
    return x > 100

def condition2(x):
    call_count["count"] += 1
    print(f"Condition 2 called (count: {call_count['count']})")
    return x > 50

branch = RunnableBranch(
    (condition1, RunnableLambda(lambda x: "large")),
    (condition2, RunnableLambda(lambda x: "medium")),
    RunnableLambda(lambda x: "small")
)

# 输入 150
result = branch.invoke(150)
# 输出：
# Condition 1 called (count: 1)
# 结果：large
# 注意：condition2 没有被调用！

# 输入 75
call_count["count"] = 0
result = branch.invoke(75)
# 输出：
# Condition 1 called (count: 1)
# Condition 2 called (count: 2)
# 结果：medium
```

**关键区别**：
- ❌ 并行评估：所有条件都会执行
- ✅ 顺序评估：第一个匹配就停止

### 为什么人们容易这样错？

**心理原因**：
1. **并行思维惯性**：现代编程强调并行优化，容易假设框架会并行评估
2. **与 RunnableParallel 混淆**：LangChain 有并行执行的 Runnable，容易类比错误
3. **switch-case 类比**：某些语言的 switch 会先评估所有 case，导致误解

**日常类比**：
- 错误理解：像多个收银台同时服务，选最快的
- 正确理解：像排队，第一个能处理的窗口就去，不会等所有窗口都评估

### 正确理解

```python
# 条件顺序很重要！
# ❌ 错误：通用条件在前
branch = RunnableBranch(
    (lambda x: x > 0, positive_handler),      # 太通用
    (lambda x: x > 100, very_large_handler),  # 永远不会执行！
    negative_handler
)

# ✅ 正确：从具体到通用
branch = RunnableBranch(
    (lambda x: x > 100, very_large_handler),  # 最具体
    (lambda x: x > 0, positive_handler),      # 较通用
    negative_handler                           # 默认
)
```

**实际影响**：
- 性能：顺序评估可能更快（不需要评估所有条件）
- 逻辑：条件顺序决定了优先级
- 调试：理解执行路径更简单

---

## 误区2：所有匹配的分支都会执行 ❌

**错误观点**：
"如果多个条件都返回 True，对应的分支都会执行。"

### 为什么错？

**实际机制**：只有**第一个匹配的分支**会执行，即使后续条件也返回 True。

```python
from langchain_core.runnables import RunnableBranch, RunnableLambda

# 示例：多个条件都匹配
branch = RunnableBranch(
    (lambda x: "python" in x.lower(),
     RunnableLambda(lambda x: f"Python handler: {x}")),
    (lambda x: "code" in x.lower(),
     RunnableLambda(lambda x: f"Code handler: {x}")),
    (lambda x: len(x) > 0,
     RunnableLambda(lambda x: f"Default handler: {x}"))
)

# 输入包含 "python" 和 "code"
result = branch.invoke("I love Python code")
# 结果：Python handler: I love Python code
# 注意：Code handler 没有执行，即使条件也匹配！
```

**关键区别**：
- ❌ 多分支执行：像多个 if 语句，都会检查
- ✅ 单分支执行：像 if-elif-else，只执行一个

### 为什么人们容易这样错？

**心理原因**：
1. **多 if 语句习惯**：习惯了多个独立的 if 语句都会执行
2. **事件监听类比**：像事件监听器，多个监听器都会触发
3. **过滤器思维**：以为是"过滤"而非"路由"

**日常类比**：
- 错误理解：像多个闹钟，都会响
- 正确理解：像导航选路，只走一条路

### 正确理解

```python
# 如果需要多个分支都执行，使用 RunnableParallel
from langchain_core.runnables import RunnableParallel

# ✅ 多分支并行执行
parallel = RunnableParallel(
    python=python_handler,
    code=code_handler,
    default=default_handler
)

# 所有分支都会执行
result = parallel.invoke("I love Python code")
# 结果：{
#   "python": "...",
#   "code": "...",
#   "default": "..."
# }
```

**实际影响**：
- 逻辑：需要明确是"路由"还是"并行"
- 性能：单分支执行更高效
- 设计：条件互斥性很重要

---

## 误区3：RunnableBranch 已弃用不能用 ❌

**错误观点**：
"官方文档标记为 legacy，说明 RunnableBranch 已经弃用，不应该再使用了。"

### 为什么错？

**实际情况**：
1. **Legacy ≠ Deprecated**：legacy 表示"遗留"，不是"弃用"
2. **仍在维护**：LangChain 团队仍在维护和支持
3. **广泛使用**：生产环境中大量应用仍在使用
4. **推荐替代**：官方推荐 RunnableLambda，但不强制迁移

```python
# ✅ RunnableBranch 仍然可用且稳定
from langchain_core.runnables import RunnableBranch

branch = RunnableBranch(
    (condition1, handler1),
    (condition2, handler2),
    default_handler
)
# 完全没问题！

# ✅ RunnableLambda 是推荐的新方式
from langchain_core.runnables import RunnableLambda

def custom_router(x):
    if condition1(x):
        return handler1.invoke(x)
    elif condition2(x):
        return handler2.invoke(x)
    else:
        return default_handler.invoke(x)

router = RunnableLambda(custom_router)
# 更灵活，但代码更多
```

**官方态度**（2025-2026）：
- ✅ RunnableBranch：简单场景，清晰结构
- ✅ RunnableLambda：复杂逻辑，更灵活
- ❌ 不推荐：强制迁移现有代码

### 为什么人们容易这样错？

**心理原因**：
1. **过度解读**：看到 "legacy" 就以为要废弃
2. **追新心理**：总想用最新的方式
3. **文档误读**：没有仔细理解官方说明

**日常类比**：
- 错误理解：像老款手机，不能用了
- 正确理解：像经典款汽车，仍然好用，只是有了新款

### 正确理解

**何时使用 RunnableBranch**：
```python
# ✅ 适合：简单的条件路由
branch = RunnableBranch(
    (lambda x: x["type"] == "A", handler_a),
    (lambda x: x["type"] == "B", handler_b),
    default_handler
)
```

**何时使用 RunnableLambda**：
```python
# ✅ 适合：复杂的路由逻辑
def complex_router(x):
    # 复杂的条件判断
    score = calculate_score(x)
    context = get_context(x)

    if score > 0.8 and context["urgent"]:
        return urgent_handler.invoke(x)
    elif score > 0.5:
        # 动态选择 handler
        handler = select_handler(context)
        return handler.invoke(x)
    else:
        return default_handler.invoke(x)

router = RunnableLambda(complex_router)
```

**迁移建议**（2025-2026）：
- 新项目：优先考虑 RunnableLambda
- 现有项目：不需要强制迁移
- 简单场景：RunnableBranch 仍然是好选择
- 复杂场景：考虑迁移到 RunnableLambda

**实际影响**：
- 维护性：RunnableBranch 更清晰
- 灵活性：RunnableLambda 更强大
- 学习成本：两者都值得学习

---

## 总结：三个关键认知

| 误区 | 错误理解 | 正确理解 |
|------|----------|----------|
| **评估方式** | 并行评估所有条件 | 顺序评估，第一个匹配就停止 |
| **执行方式** | 所有匹配的分支都执行 | 只执行第一个匹配的分支 |
| **使用状态** | 已弃用不能用 | Legacy 但仍可用，简单场景推荐 |

**记住**：
1. 条件顺序决定优先级（从具体到通用）
2. 只有一个分支会执行（路由而非过滤）
3. Legacy 不等于弃用（仍然是好工具）

---

## 实战检验

测试你是否真正理解了这些反直觉点：

```python
from langchain_core.runnables import RunnableBranch, RunnableLambda

# 问题：以下代码的输出是什么？
branch = RunnableBranch(
    (lambda x: x > 50, RunnableLambda(lambda x: "A")),
    (lambda x: x > 100, RunnableLambda(lambda x: "B")),
    (lambda x: x > 0, RunnableLambda(lambda x: "C")),
    RunnableLambda(lambda x: "D")
)

result = branch.invoke(150)
```

**答案**：`"A"`

**解释**：
- 第一个条件 `x > 50` 匹配（150 > 50）
- 立即执行分支 A，返回 "A"
- 后续条件（包括 `x > 100`）不再评估
- 即使 150 > 100，分支 B 也不会执行

**教训**：条件顺序很重要！应该把 `x > 100` 放在前面。
