# 核心概念1：序列组合原理

> 理解 RunnableSequence 如何将多个组件按顺序组合

---

## 什么是序列组合

**序列组合**（Sequential Composition）是函数式编程中的基本概念，指将多个函数按顺序连接，前一个函数的输出作为后一个函数的输入。

**数学表示**：
```
(f ∘ g ∘ h)(x) = f(g(h(x)))
```

**在 LangChain 中**：
```python
chain = step1 | step2 | step3
result = chain.invoke(input)

# 等价于
result = step3.invoke(step2.invoke(step1.invoke(input)))
```

---

## 为什么需要序列组合

### 问题：AI 应用需要多个步骤

AI 应用通常不是单一步骤，而是多个步骤的组合：

```python
# RAG 应用的步骤
1. 检索相关文档（Retriever）
2. 构建 Prompt（PromptTemplate）
3. 调用 LLM（ChatModel）
4. 解析输出（OutputParser）
```

### 传统方式的痛点

```python
# 手动组合（痛苦）
def rag_pipeline(question: str) -> str:
    # 步骤1：检索
    docs = retriever.invoke(question)

    # 步骤2：构建 prompt
    prompt_value = prompt.invoke({"context": docs, "question": question})

    # 步骤3：调用 LLM
    llm_output = llm.invoke(prompt_value)

    # 步骤4：解析
    final_answer = parser.invoke(llm_output)

    return final_answer
```

**痛点**：
- 代码冗长，难以阅读
- 中间变量多，容易出错
- 难以复用和组合
- 批量处理需要手动实现

### 序列组合的优势

```python
# 使用 RunnableSequence（简洁）
rag_chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
    | llm
    | parser
)

result = rag_chain.invoke(question)
```

**优势**：
- 声明式：描述数据流，而非命令式调用
- 简洁：一行代码表达整个流程
- 可复用：链可以作为组件继续组合
- 自动优化：框架自动处理 batch/stream

---

## 序列组合的实现原理

### 核心数据结构

```python
from typing import List, Any, TypeVar

Input = TypeVar('Input')
Output = TypeVar('Output')

class RunnableSequence:
    """序列组合器"""

    def __init__(self, *steps):
        """
        初始化序列

        Args:
            *steps: 可变数量的 Runnable 组件
        """
        self.steps = list(steps)

    def invoke(self, input: Input) -> Output:
        """
        顺序执行所有步骤

        Args:
            input: 初始输入

        Returns:
            最后一个步骤的输出
        """
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result
```

### 关键设计决策

#### 1. 为什么用列表存储步骤？

```python
# 方案1：嵌套结构（不推荐）
class RunnableSequence:
    def __init__(self, first, second):
        self.first = first
        self.second = second

# a | b | c 会创建嵌套结构
# RunnableSequence(RunnableSequence(a, b), c)

# 方案2：列表结构（推荐）
class RunnableSequence:
    def __init__(self, *steps):
        self.steps = list(steps)

# a | b | c 创建扁平结构
# RunnableSequence(a, b, c)
```

**选择列表的原因**：
- 扁平化：避免深层嵌套
- 易于遍历：可以直接迭代所有步骤
- 易于调试：可以查看所有步骤
- 易于优化：可以批量处理

#### 2. 为什么顺序执行？

```python
def invoke(self, input):
    result = input
    for step in self.steps:
        result = step.invoke(result)  # 顺序执行
    return result
```

**顺序执行的原因**：
- 依赖关系：后一步依赖前一步的输出
- 数据流：数据从左到右流动
- 可预测：执行顺序明确

#### 3. 为什么返回最后一步的输出？

```python
# 只返回最后一步的输出
return result  # 最后一个 step 的输出
```

**原因**：
- 符合函数组合语义：`f(g(h(x)))` 返回 `f` 的输出
- 中间结果可以通过其他方式获取（astream_events）
- 简化接口：调用者只关心最终结果

---

## 手写简化版实现

### 基础版本

```python
from typing import Any, List, Callable

class SimpleRunnable:
    """简化版 Runnable 基类"""

    def invoke(self, input: Any) -> Any:
        """子类必须实现"""
        raise NotImplementedError

    def __or__(self, other: 'SimpleRunnable') -> 'SimpleRunnableSequence':
        """重载 | 操作符"""
        return SimpleRunnableSequence(self, other)


class SimpleRunnableSequence(SimpleRunnable):
    """简化版 RunnableSequence"""

    def __init__(self, *steps: SimpleRunnable):
        # 扁平化：如果步骤本身是 RunnableSequence，展开它
        self.steps: List[SimpleRunnable] = []
        for step in steps:
            if isinstance(step, SimpleRunnableSequence):
                self.steps.extend(step.steps)
            else:
                self.steps.append(step)

    def invoke(self, input: Any) -> Any:
        """顺序执行所有步骤"""
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result

    def __repr__(self) -> str:
        """友好的字符串表示"""
        step_names = [step.__class__.__name__ for step in self.steps]
        return f"SimpleRunnableSequence({' | '.join(step_names)})"


# ===== 示例组件 =====

class AddOne(SimpleRunnable):
    """加1"""
    def invoke(self, input: int) -> int:
        print(f"AddOne: {input} -> {input + 1}")
        return input + 1


class MultiplyTwo(SimpleRunnable):
    """乘2"""
    def invoke(self, input: int) -> int:
        print(f"MultiplyTwo: {input} -> {input * 2}")
        return input * 2


class Square(SimpleRunnable):
    """平方"""
    def invoke(self, input: int) -> int:
        print(f"Square: {input} -> {input ** 2}")
        return input ** 2


# ===== 测试 =====

if __name__ == "__main__":
    # 创建组件
    add_one = AddOne()
    multiply_two = MultiplyTwo()
    square = Square()

    # 使用 | 操作符组合
    chain = add_one | multiply_two | square

    print(f"Chain: {chain}")
    print()

    # 执行
    result = chain.invoke(10)
    # 输出:
    # AddOne: 10 -> 11
    # MultiplyTwo: 11 -> 22
    # Square: 22 -> 484

    print(f"\nFinal result: {result}")  # 484

    # 测试扁平化
    print("\n=== 测试扁平化 ===")
    chain1 = add_one | multiply_two
    chain2 = chain1 | square
    print(f"Chain2: {chain2}")
    # 输出: SimpleRunnableSequence(AddOne | MultiplyTwo | Square)
    # 而不是嵌套的 SimpleRunnableSequence(SimpleRunnableSequence(AddOne | MultiplyTwo) | Square)
```

### 增强版本：支持批处理

```python
import asyncio
from typing import List

class EnhancedRunnable(SimpleRunnable):
    """增强版 Runnable，支持批处理"""

    def batch(self, inputs: List[Any]) -> List[Any]:
        """批量执行（默认实现：串行）"""
        return [self.invoke(input) for input in inputs]

    async def abatch(self, inputs: List[Any]) -> List[Any]:
        """异步批量执行（默认实现：并行）"""
        tasks = [asyncio.to_thread(self.invoke, input) for input in inputs]
        return await asyncio.gather(*tasks)


class EnhancedRunnableSequence(EnhancedRunnable):
    """增强版 RunnableSequence，支持批处理"""

    def __init__(self, *steps: EnhancedRunnable):
        self.steps: List[EnhancedRunnable] = []
        for step in steps:
            if isinstance(step, EnhancedRunnableSequence):
                self.steps.extend(step.steps)
            else:
                self.steps.append(step)

    def invoke(self, input: Any) -> Any:
        """顺序执行所有步骤"""
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result

    def batch(self, inputs: List[Any]) -> List[Any]:
        """批量执行（串行）"""
        return [self.invoke(input) for input in inputs]

    async def abatch(self, inputs: List[Any]) -> List[Any]:
        """异步批量执行（并行）"""
        tasks = [asyncio.to_thread(self.invoke, input) for input in inputs]
        return await asyncio.gather(*tasks)


# ===== 测试批处理 =====

class AddOneEnhanced(EnhancedRunnable):
    def invoke(self, input: int) -> int:
        return input + 1


class MultiplyTwoEnhanced(EnhancedRunnable):
    def invoke(self, input: int) -> int:
        return input * 2


if __name__ == "__main__":
    # 创建链
    add_one = AddOneEnhanced()
    multiply_two = MultiplyTwoEnhanced()

    # 重载 | 操作符
    EnhancedRunnable.__or__ = lambda self, other: EnhancedRunnableSequence(self, other)

    chain = add_one | multiply_two

    # 批量执行
    inputs = [1, 2, 3, 4, 5]
    results = chain.batch(inputs)
    print(f"Batch results: {results}")  # [4, 6, 8, 10, 12]

    # 异步批量执行
    async def test_abatch():
        results = await chain.abatch(inputs)
        print(f"Async batch results: {results}")

    asyncio.run(test_abatch())
```

---

## 与 RunnableParallel 的对比

### RunnableSequence：顺序执行

```python
# 顺序执行：step2 等待 step1 完成
chain = step1 | step2 | step3

# 执行流程
input → step1 → output1 → step2 → output2 → step3 → output3
```

**特点**：
- 步骤有依赖关系
- 后一步需要前一步的输出
- 串行执行

### RunnableParallel：并行执行

```python
# 并行执行：step1、step2、step3 同时执行
parallel = RunnableParallel(
    result1=step1,
    result2=step2,
    result3=step3
)

# 执行流程
input → step1 → output1 ↘
input → step2 → output2 → {result1, result2, result3}
input → step3 → output3 ↗
```

**特点**：
- 步骤独立，无依赖关系
- 所有步骤接收相同输入
- 并行执行，提升性能

### 组合使用

```python
# 序列中嵌入并行
chain = (
    step1  # 顺序执行
    | RunnableParallel(  # 并行执行
        branch1=step2a,
        branch2=step2b
    )
    | step3  # 顺序执行
)

# 执行流程
input → step1 → output1 → step2a → output2a ↘
                        → step2b → output2b → {branch1, branch2} → step3 → final
```

---

## 2025-2026 应用场景

### 场景1：RAG 问答链

**来源**：Towards AI - Master LangChain in 2025

```python
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_chroma import Chroma
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough

# 构建 RAG 链
vectorstore = Chroma(embedding_function=OpenAIEmbeddings())
retriever = vectorstore.as_retriever()

prompt = ChatPromptTemplate.from_template("""
根据以下上下文回答问题：

上下文：{context}
问题：{question}

答案：
""")

llm = ChatOpenAI(model="gpt-4o-mini")
parser = StrOutputParser()

# 序列组合
rag_chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
    | llm
    | parser
)

# 使用
answer = rag_chain.invoke("什么是向量数据库？")
```

**关键点**：
- 检索 → 注入 → 生成 → 解析
- 每一步依赖前一步的输出
- 典型的序列组合场景

### 场景2：多步推理链

**来源**：LangChain 官方文档

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser

# 步骤1：分解问题
decompose_prompt = ChatPromptTemplate.from_template(
    "将以下复杂问题分解为3个子问题：\n{question}"
)

# 步骤2：逐个解决子问题
solve_prompt = ChatPromptTemplate.from_template(
    "解决以下子问题：\n{subquestion}"
)

# 步骤3：合并答案
synthesize_prompt = ChatPromptTemplate.from_template(
    "根据以下子问题的答案，回答原始问题：\n{answers}"
)

llm = ChatOpenAI(model="gpt-4o-mini")
parser = StrOutputParser()

# 序列组合
reasoning_chain = (
    decompose_prompt
    | llm
    | parser
    | solve_prompt
    | llm
    | parser
    | synthesize_prompt
    | llm
    | parser
)
```

**关键点**：
- 分解 → 解决 → 合并
- 多步推理的典型模式
- 每一步都是序列组合

### 场景3：数据处理管道

**来源**：Analytics Vidhya - LCEL Guide

```python
from langchain_community.document_loaders import TextLoader
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_openai import OpenAIEmbeddings
from langchain_chroma import Chroma

# 步骤1：加载文档
loader = TextLoader("document.txt")

# 步骤2：分块
splitter = RecursiveCharacterTextSplitter(chunk_size=1000)

# 步骤3：生成 Embedding
embeddings = OpenAIEmbeddings()

# 步骤4：存储到向量数据库
vectorstore = Chroma(embedding_function=embeddings)

# 序列组合（概念上）
# loader → splitter → embeddings → vectorstore
```

**关键点**：
- 加载 → 分块 → Embedding → 存储
- 数据处理的典型流程
- 每一步转换数据格式

### 场景4：对话系统

**来源**：LangChain 官方文档

```python
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser
from langchain_community.chat_message_histories import ChatMessageHistory

# 步骤1：加载历史
history = ChatMessageHistory()

# 步骤2：构建 prompt
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个友好的助手"),
    MessagesPlaceholder(variable_name="history"),
    ("human", "{input}")
])

# 步骤3：调用 LLM
llm = ChatOpenAI(model="gpt-4o-mini")

# 步骤4：解析输出
parser = StrOutputParser()

# 序列组合
chat_chain = prompt | llm | parser
```

**关键点**：
- 历史 → prompt → LLM → 解析
- 对话系统的基础模式
- 支持多轮对话

---

## 性能优化技巧

### 1. 避免不必要的步骤

```python
# ❌ 不必要的步骤
chain = (
    prompt
    | llm
    | lambda x: x  # 不必要的透传
    | parser
)

# ✅ 移除不必要的步骤
chain = prompt | llm | parser
```

### 2. 合并相似步骤

```python
# ❌ 多个解析步骤
chain = (
    prompt
    | llm
    | parse_step1
    | parse_step2
    | parse_step3
)

# ✅ 合并解析步骤
def combined_parser(x):
    x = parse_step1(x)
    x = parse_step2(x)
    x = parse_step3(x)
    return x

chain = prompt | llm | combined_parser
```

### 3. 使用批处理

```python
# ❌ 循环调用
results = []
for input in inputs:
    results.append(chain.invoke(input))

# ✅ 批处理
results = chain.batch(inputs)
```

---

## 常见问题

### Q1: 序列组合和函数组合有什么区别？

**A**: 序列组合是函数组合的特殊形式，但提供了额外的特性：
- 统一接口（invoke/batch/stream）
- 自动优化（批处理、流式）
- 可观测性（LangSmith 集成）
- 错误处理（with_retry、with_fallbacks）

### Q2: 如何在序列中插入自定义逻辑？

**A**: 使用 RunnableLambda 包装自定义函数：

```python
from langchain_core.runnables import RunnableLambda

def custom_logic(x):
    # 自定义逻辑
    return x.upper()

chain = (
    prompt
    | llm
    | RunnableLambda(custom_logic)  # 插入自定义逻辑
    | parser
)
```

### Q3: 序列组合支持条件分支吗？

**A**: 不支持。如果需要条件分支，使用 RunnableBranch：

```python
from langchain_core.runnables import RunnableBranch

chain = (
    step1
    | RunnableBranch(
        (condition1, branch1),
        (condition2, branch2),
        default_branch
    )
    | step3
)
```

---

## 学习检查清单

完成本节学习后，你应该能够：

- [ ] 理解序列组合的定义和原理
- [ ] 理解为什么需要序列组合
- [ ] 理解 RunnableSequence 的实现原理
- [ ] 能手写简化版的 RunnableSequence
- [ ] 理解序列组合和并行组合的区别
- [ ] 能应用序列组合到实际场景
- [ ] 能优化序列组合的性能

---

## 下一步学习

### 深入理解实现

阅读：
- `03_核心概念_02_管道操作符实现.md` - `|` 的实现原理
- `03_核心概念_03_数据流转机制.md` - 数据如何流转

### 实战应用

阅读：
- `07_实战代码_01_基础序列链构建.md` - RAG 问答链
- `07_实战代码_02_复杂数据流转.md` - 多步骤处理

---

**版本**: v1.0
**最后更新**: 2026-02-18
**参考来源**:
- LangChain 官方文档
- Towards AI - Master LangChain in 2025
- Analytics Vidhya - LCEL Guide
- 函数式编程原理
