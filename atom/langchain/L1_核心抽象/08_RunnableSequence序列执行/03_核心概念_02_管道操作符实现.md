# 核心概念2：管道操作符实现

> 深入理解 `|` 操作符的实现原理

---

## `|` 操作符的魔法

**一句话**：`|` 操作符通过 Python 的 `__or__` 魔法方法实现，自动创建 RunnableSequence。

```python
# 这行代码
chain = prompt | llm | parser

# 实际上调用了
chain = prompt.__or__(llm).__or__(parser)
```

---

## Python 魔法方法基础

### 什么是魔法方法

**魔法方法**（Magic Methods）是 Python 中以双下划线开头和结尾的特殊方法，用于重载运算符。

```python
class Number:
    def __init__(self, value):
        self.value = value

    def __add__(self, other):
        """重载 + 操作符"""
        return Number(self.value + other.value)

    def __or__(self, other):
        """重载 | 操作符"""
        return Number(self.value | other.value)

# 使用
a = Number(5)
b = Number(3)
c = a + b  # 调用 a.__add__(b)
d = a | b  # 调用 a.__or__(b)
```

### 常见的魔法方法

| 操作符 | 魔法方法 | 示例 |
|--------|---------|------|
| `+` | `__add__` | `a + b` → `a.__add__(b)` |
| `-` | `__sub__` | `a - b` → `a.__sub__(b)` |
| `*` | `__mul__` | `a * b` → `a.__mul__(b)` |
| `/` | `__truediv__` | `a / b` → `a.__truediv__(b)` |
| `\|` | `__or__` | `a \| b` → `a.__or__(b)` |
| `&` | `__and__` | `a & b` → `a.__and__(b)` |
| `>>` | `__rshift__` | `a >> b` → `a.__rshift__(b)` |

---

## LangChain 中的 `__or__` 实现

### 基础实现

```python
from typing import TypeVar, Generic

Input = TypeVar('Input')
Output = TypeVar('Output')

class Runnable(Generic[Input, Output]):
    """Runnable 基类"""

    def __or__(self, other: 'Runnable') -> 'RunnableSequence':
        """
        重载 | 操作符

        Args:
            other: 右侧的 Runnable

        Returns:
            RunnableSequence 对象
        """
        return RunnableSequence(self, other)

    def invoke(self, input: Input) -> Output:
        """子类必须实现"""
        raise NotImplementedError
```

### 扁平化优化

**问题**：`a | b | c` 会创建嵌套的 RunnableSequence

```python
# 不优化的情况
a | b | c
# 等价于
(a | b) | c
# 等价于
RunnableSequence(a, b) | c
# 等价于
RunnableSequence(RunnableSequence(a, b), c)  # 嵌套！
```

**解决方案**：扁平化

```python
class Runnable:
    def __or__(self, other: 'Runnable') -> 'RunnableSequence':
        """重载 | 操作符，支持扁平化"""
        # 如果 self 已经是 RunnableSequence，展开它
        if isinstance(self, RunnableSequence):
            if isinstance(other, RunnableSequence):
                # 两边都是 RunnableSequence，合并
                return RunnableSequence(*self.steps, *other.steps)
            else:
                # 只有左边是 RunnableSequence
                return RunnableSequence(*self.steps, other)
        else:
            if isinstance(other, RunnableSequence):
                # 只有右边是 RunnableSequence
                return RunnableSequence(self, *other.steps)
            else:
                # 两边都不是 RunnableSequence
                return RunnableSequence(self, other)
```

**效果**：

```python
# 扁平化后
a | b | c
# 创建
RunnableSequence(a, b, c)  # 扁平！
```

---

## 手写完整实现

### 版本1：基础版本

```python
from typing import Any, List

class SimpleRunnable:
    """简化版 Runnable"""

    def invoke(self, input: Any) -> Any:
        raise NotImplementedError

    def __or__(self, other: 'SimpleRunnable') -> 'SimpleRunnableSequence':
        """重载 | 操作符"""
        return SimpleRunnableSequence(self, other)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}()"


class SimpleRunnableSequence(SimpleRunnable):
    """简化版 RunnableSequence"""

    def __init__(self, *steps: SimpleRunnable):
        self.steps: List[SimpleRunnable] = list(steps)

    def invoke(self, input: Any) -> Any:
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result

    def __repr__(self) -> str:
        step_names = [repr(step) for step in self.steps]
        return f"SimpleRunnableSequence({' | '.join(step_names)})"


# ===== 测试组件 =====

class AddOne(SimpleRunnable):
    def invoke(self, input: int) -> int:
        return input + 1


class MultiplyTwo(SimpleRunnable):
    def invoke(self, input: int) -> int:
        return input * 2


class Square(SimpleRunnable):
    def invoke(self, input: int) -> int:
        return input ** 2


# ===== 测试 =====

if __name__ == "__main__":
    add_one = AddOne()
    multiply_two = MultiplyTwo()
    square = Square()

    # 使用 | 操作符
    chain = add_one | multiply_two | square

    print(f"Chain: {chain}")
    # 输出: SimpleRunnableSequence(AddOne() | MultiplyTwo() | Square())

    result = chain.invoke(10)
    print(f"Result: {result}")  # ((10 + 1) * 2) ** 2 = 484
```

### 版本2：支持扁平化

```python
class FlatRunnable:
    """支持扁平化的 Runnable"""

    def invoke(self, input: Any) -> Any:
        raise NotImplementedError

    def __or__(self, other: 'FlatRunnable') -> 'FlatRunnableSequence':
        """重载 | 操作符，支持扁平化"""
        # 如果 self 是 FlatRunnableSequence，展开它
        if isinstance(self, FlatRunnableSequence):
            if isinstance(other, FlatRunnableSequence):
                return FlatRunnableSequence(*self.steps, *other.steps)
            else:
                return FlatRunnableSequence(*self.steps, other)
        else:
            if isinstance(other, FlatRunnableSequence):
                return FlatRunnableSequence(self, *other.steps)
            else:
                return FlatRunnableSequence(self, other)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}()"


class FlatRunnableSequence(FlatRunnable):
    """支持扁平化的 RunnableSequence"""

    def __init__(self, *steps: FlatRunnable):
        self.steps: List[FlatRunnable] = list(steps)

    def invoke(self, input: Any) -> Any:
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result

    def __repr__(self) -> str:
        step_names = [step.__class__.__name__ for step in self.steps]
        return f"FlatRunnableSequence({' | '.join(step_names)})"


# ===== 测试扁平化 =====

class Add(FlatRunnable):
    def invoke(self, input: int) -> int:
        return input + 1


class Mul(FlatRunnable):
    def invoke(self, input: int) -> int:
        return input * 2


class Pow(FlatRunnable):
    def invoke(self, input: int) -> int:
        return input ** 2


if __name__ == "__main__":
    a = Add()
    b = Mul()
    c = Pow()

    # 测试扁平化
    chain1 = a | b
    print(f"chain1: {chain1}")
    # 输出: FlatRunnableSequence(Add | Mul)

    chain2 = chain1 | c
    print(f"chain2: {chain2}")
    # 输出: FlatRunnableSequence(Add | Mul | Pow)
    # 而不是 FlatRunnableSequence(FlatRunnableSequence(Add | Mul) | Pow)

    # 验证步骤数量
    print(f"chain2 steps: {len(chain2.steps)}")  # 3，而不是 2

    # 执行
    result = chain2.invoke(10)
    print(f"Result: {result}")  # 484
```

---

## 为什么选择 `|` 而不是其他操作符

### 候选操作符对比

| 操作符 | 优点 | 缺点 | 示例 |
|--------|------|------|------|
| `+` | 直观（加法） | 暗示交换律（a+b=b+a） | `a + b + c` |
| `>>` | 表示流向 | 不够直观 | `a >> b >> c` |
| `\|` | Unix 管道，开发者熟悉 | 位或运算符 | `a \| b \| c` |
| `->` | 表示流向 | Python 中用于类型注解 | 不可用 |
| `.then()` | 链式调用 | 不是操作符 | `a.then(b).then(c)` |

### 为什么选择 `|`

**来源**：LangChain 设计文档

1. **Unix 管道传统**：
   ```bash
   # Unix 管道
   cat file.txt | grep "error" | wc -l
   ```
   开发者熟悉这个语法，表示数据流。

2. **视觉直观**：
   ```python
   # | 看起来像管道
   data | process1 | process2 | process3
   ```

3. **可重载**：
   Python 允许重载 `|` 操作符（`__or__`）。

4. **社区先例**：
   - RxJS 使用 `.pipe()`
   - Elixir 使用 `|>`
   - F# 使用 `|>`

### 其他语言的选择

| 语言/框架 | 操作符 | 示例 |
|----------|--------|------|
| **Unix Shell** | `\|` | `cat \| grep \| wc` |
| **Elixir** | `\|>` | `data \|> func1 \|> func2` |
| **F#** | `\|>` | `data \|> func1 \|> func2` |
| **RxJS** | `.pipe()` | `obs.pipe(op1, op2, op3)` |
| **LangChain** | `\|` | `a \| b \| c` |

---

## 类型推断与泛型

### 类型安全的实现

```python
from typing import TypeVar, Generic

Input = TypeVar('Input')
Middle = TypeVar('Middle')
Output = TypeVar('Output')

class TypedRunnable(Generic[Input, Output]):
    """类型安全的 Runnable"""

    def invoke(self, input: Input) -> Output:
        raise NotImplementedError

    def __or__(
        self,
        other: 'TypedRunnable[Output, Middle]'
    ) -> 'TypedRunnableSequence[Input, Middle]':
        """
        重载 | 操作符，保持类型安全

        Args:
            other: 右侧的 Runnable，输入类型必须匹配左侧的输出类型

        Returns:
            RunnableSequence，输入类型是左侧的输入，输出类型是右侧的输出
        """
        return TypedRunnableSequence(self, other)


class TypedRunnableSequence(TypedRunnable[Input, Output]):
    """类型安全的 RunnableSequence"""

    def __init__(self, *steps):
        self.steps = list(steps)

    def invoke(self, input: Input) -> Output:
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result


# ===== 类型安全的组件 =====

class IntToStr(TypedRunnable[int, str]):
    """int → str"""
    def invoke(self, input: int) -> str:
        return str(input)


class StrToUpper(TypedRunnable[str, str]):
    """str → str"""
    def invoke(self, input: str) -> str:
        return input.upper()


class StrToLen(TypedRunnable[str, int]):
    """str → int"""
    def invoke(self, input: str) -> int:
        return len(input)


# ===== 测试类型推断 =====

if __name__ == "__main__":
    int_to_str = IntToStr()
    str_to_upper = StrToUpper()
    str_to_len = StrToLen()

    # 类型安全的组合
    chain: TypedRunnableSequence[int, int] = (
        int_to_str      # int → str
        | str_to_upper  # str → str
        | str_to_len    # str → int
    )  # 整体：int → int

    result = chain.invoke(12345)
    print(f"Result: {result}")  # 5（"12345" 的长度）

    # 类型错误（如果启用类型检查）
    # bad_chain = int_to_str | str_to_len | str_to_upper
    # 错误：str_to_len 输出 int，但 str_to_upper 需要 str
```

---

## 2025-2026 增强特性

### 1. 配置传递

**来源**：LangChain 0.3.x 更新

```python
class ConfigurableRunnable:
    """支持配置传递的 Runnable"""

    def invoke(self, input, config=None):
        """
        执行，支持配置

        Args:
            input: 输入数据
            config: 配置字典（自动传递给所有步骤）
        """
        raise NotImplementedError

    def __or__(self, other):
        return ConfigurableRunnableSequence(self, other)


class ConfigurableRunnableSequence(ConfigurableRunnable):
    """支持配置传递的 RunnableSequence"""

    def __init__(self, *steps):
        self.steps = list(steps)

    def invoke(self, input, config=None):
        """配置自动传递给所有步骤"""
        result = input
        for step in self.steps:
            result = step.invoke(result, config=config)  # 传递配置
        return result
```

**使用示例**：

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

prompt = ChatPromptTemplate.from_template("解释：{topic}")
llm = ChatOpenAI(model="gpt-4o-mini")
parser = StrOutputParser()

chain = prompt | llm | parser

# 配置自动传递给所有步骤
result = chain.invoke(
    {"topic": "AI"},
    config={
        "run_name": "explain_chain",
        "tags": ["production"],
        "max_concurrency": 5
    }
)
```

### 2. 回调系统

**来源**：LangChain 回调系统

```python
class CallbackRunnable:
    """支持回调的 Runnable"""

    def invoke(self, input, config=None):
        config = config or {}
        callbacks = config.get("callbacks", [])

        # 触发开始回调
        for callback in callbacks:
            callback.on_chain_start(self.__class__.__name__, input)

        try:
            # 执行
            output = self._invoke(input)

            # 触发结束回调
            for callback in callbacks:
                callback.on_chain_end(self.__class__.__name__, output)

            return output
        except Exception as e:
            # 触发错误回调
            for callback in callbacks:
                callback.on_chain_error(self.__class__.__name__, e)
            raise

    def _invoke(self, input):
        """子类实现"""
        raise NotImplementedError
```

### 3. 流式支持

**来源**：LangChain LCEL 流式实现

```python
class StreamableRunnable:
    """支持流式的 Runnable"""

    def stream(self, input):
        """
        流式输出

        Yields:
            输出的每个块
        """
        # 默认实现：一次性输出
        yield self.invoke(input)

    def __or__(self, other):
        return StreamableRunnableSequence(self, other)


class StreamableRunnableSequence(StreamableRunnable):
    """支持流式的 RunnableSequence"""

    def __init__(self, *steps):
        self.steps = list(steps)

    def invoke(self, input):
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result

    def stream(self, input):
        """流式执行所有步骤"""
        result = input
        for i, step in enumerate(self.steps):
            if i == len(self.steps) - 1:
                # 最后一个步骤：流式输出
                for chunk in step.stream(result):
                    yield chunk
            else:
                # 中间步骤：完整执行
                result = step.invoke(result)
```

---

## 实战应用

### 应用1：自定义操作符

```python
class CustomRunnable:
    """自定义操作符的 Runnable"""

    def __or__(self, other):
        """| 操作符：创建序列"""
        return RunnableSequence(self, other)

    def __and__(self, other):
        """& 操作符：创建并行"""
        return RunnableParallel(self, other)

    def __rshift__(self, other):
        """>> 操作符：创建条件路由"""
        return RunnableBranch(self, other)


# 使用
chain = step1 | step2  # 序列
parallel = step1 & step2  # 并行
branch = condition >> step1  # 条件路由
```

### 应用2：链式配置

```python
class ChainableRunnable:
    """支持链式配置的 Runnable"""

    def __or__(self, other):
        return ChainableRunnableSequence(self, other)

    def with_retry(self, **kwargs):
        """添加重试"""
        return RunnableWithRetry(self, **kwargs)

    def with_fallbacks(self, fallbacks):
        """添加降级"""
        return RunnableWithFallbacks(self, fallbacks)

    def with_config(self, config):
        """添加配置"""
        self._config = config
        return self


# 链式配置
chain = (
    prompt
    | llm
    | parser
).with_retry(
    stop_after_attempt=3
).with_fallbacks([
    fallback_chain
]).with_config({
    "run_name": "production"
})
```

---

## 常见问题

### Q1: 为什么不用 `.then()` 方法？

**A**: `.then()` 需要显式调用，不如 `|` 简洁：

```python
# 使用 .then()（冗长）
chain = prompt.then(llm).then(parser)

# 使用 |（简洁）
chain = prompt | llm | parser
```

### Q2: `|` 操作符有性能损失吗？

**A**: 没有。`|` 只是创建对象，不增加运行时开销。

### Q3: 如何调试 `|` 操作符？

**A**: 打印中间结果：

```python
chain = prompt | llm | parser
print(f"Chain: {chain}")
print(f"Steps: {chain.steps}")
```

---

## 学习检查清单

- [ ] 理解 Python 魔法方法
- [ ] 理解 `__or__` 的实现
- [ ] 理解扁平化优化
- [ ] 能手写 `__or__` 实现
- [ ] 理解为什么选择 `|`
- [ ] 理解类型推断
- [ ] 了解 2025-2026 增强特性

---

**版本**: v1.0
**最后更新**: 2026-02-18
**参考来源**:
- Python 官方文档 - Data Model
- LangChain 源码
- LangChain 设计文档
