# 核心概念2：版本控制机制

**Alembic 通过 alembic_version 表和线性版本链实现数据库 schema 的版本控制，确保迁移按正确顺序执行且不重复，类似 Git 管理代码变更历史。**

---

## 2.1 alembic_version 表

### 表结构

**Alembic 在数据库中自动创建 `alembic_version` 表，用于追踪当前数据库版本。**

```sql
-- alembic_version 表结构
CREATE TABLE alembic_version (
    version_num VARCHAR(32) NOT NULL,
    CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)
);

-- 示例数据
SELECT * FROM alembic_version;
-- version_num
-- ----------------
-- abc123def456
```

**表特点：**
- 只有一个字段：`version_num`（存储当前迁移的 revision ID）
- 只有一行数据（当前版本）
- 主键约束（确保唯一性）

### 版本追踪原理

**Alembic 通过对比 `alembic_version` 表和迁移脚本的版本链，计算需要执行的迁移。**

```python
# 版本链（迁移脚本）
None -> abc123 -> def456 -> ghi789 -> jkl012

# 当前数据库版本（alembic_version 表）
version_num = 'def456'

# 运行 alembic upgrade head
# Alembic 计算：需要执行 ghi789 和 jkl012
# 跳过：abc123 和 def456（已执行）
```

**执行流程：**
1. 读取 `alembic_version` 表，获取当前版本（`def456`）
2. 读取所有迁移脚本，构建版本链
3. 从当前版本开始，找到通往目标版本的路径
4. 依次执行路径上的迁移
5. 每执行一个迁移，更新 `alembic_version` 表

### 版本更新时机

```python
# 迁移执行过程
def upgrade():
    # 1. 开始执行迁移
    print("Running upgrade abc123 -> def456")

    # 2. 执行迁移操作
    op.add_column('users', sa.Column('avatar', sa.String()))

    # 3. 迁移成功后，Alembic 自动更新 alembic_version 表
    # UPDATE alembic_version SET version_num = 'def456'

    # 4. 如果迁移失败，alembic_version 不会更新
    # 数据库保持在上一个版本
```

**重要特性：**
- ✅ 原子性：迁移成功才更新版本号
- ✅ 幂等性：已执行的迁移不会重复执行
- ✅ 可追溯：随时知道数据库在哪个版本

---

## 2.2 线性版本链

### 版本链的数据结构

**Alembic 使用有向无环图（DAG）管理迁移版本，每个迁移通过 `down_revision` 指向父迁移。**

```python
# 迁移1：第一个迁移
# versions/abc123_create_users.py
revision = 'abc123'
down_revision = None  # 没有父迁移

# 迁移2：依赖迁移1
# versions/def456_add_avatar.py
revision = 'def456'
down_revision = 'abc123'  # 父迁移是 abc123

# 迁移3：依赖迁移2
# versions/ghi789_add_posts.py
revision = 'ghi789'
down_revision = 'def456'  # 父迁移是 def456

# 形成版本链：
# None -> abc123 -> def456 -> ghi789
```

**版本链的特点：**
- 单向链表结构（每个节点指向父节点）
- 有序性（严格的执行顺序）
- 可追溯（可以回溯到任意历史版本）

### 版本链的可视化

```bash
# 查看版本链
alembic history

# 输出：
# ghi789 -> head, add posts table
# def456, add avatar to users
# abc123, create users table
# <base> -> abc123, create users table

# 详细输出
alembic history --verbose

# 输出：
# Rev: ghi789 (head)
# Parent: def456
# Path: /path/to/versions/ghi789_add_posts.py
#
#     add posts table
#
# Rev: def456
# Parent: abc123
# Path: /path/to/versions/def456_add_avatar.py
#
#     add avatar to users
#
# Rev: abc123
# Parent: <base>
# Path: /path/to/versions/abc123_create_users.py
#
#     create users table
```

### 版本链的遍历

**Alembic 通过递归遍历版本链，计算迁移路径。**

```python
# 伪代码：Alembic 的版本链遍历算法
def get_upgrade_path(current_version, target_version):
    """计算从当前版本到目标版本的迁移路径"""
    path = []
    current = target_version

    # 从目标版本向前回溯，直到当前版本
    while current != current_version:
        path.insert(0, current)  # 插入到路径开头
        current = get_down_revision(current)  # 获取父版本

    return path

# 示例：
# 当前版本：abc123
# 目标版本：ghi789
# 计算路径：[def456, ghi789]
```

---

## 2.3 版本标识符（Revision ID）

### Revision ID 的生成

**Alembic 自动生成16位随机字符串作为版本标识符。**

```python
# 生成算法（简化版）
import hashlib
import time

def generate_revision_id():
    # 使用时间戳 + 随机数生成哈希
    data = f"{time.time()}{random.random()}".encode()
    hash_value = hashlib.sha256(data).hexdigest()
    return hash_value[:16]  # 取前16位

# 示例输出：
# abc123def456
# 789ghi012jkl
```

**特点：**
- 16位十六进制字符串
- 全局唯一（碰撞概率极低）
- 不可预测（基于时间戳和随机数）
- 不包含语义信息（纯标识符）

### 自定义 Revision ID

**可以在创建迁移时指定自定义 ID（不推荐）。**

```bash
# 使用自定义 ID
alembic revision --rev-id "001" -m "create users table"

# 生成的迁移文件
# versions/001_create_users_table.py
revision = '001'
down_revision = None
```

**为什么不推荐：**
- ❌ 容易冲突（多人协作时可能使用相同 ID）
- ❌ 需要手动管理（增加维护成本）
- ❌ 不符合 Alembic 的设计理念

**适用场景：**
- ✅ 单人项目，想要有序的版本号（001, 002, 003...）
- ✅ 迁移脚本需要特定命名规范
- ✅ 从其他迁移工具迁移到 Alembic

---

## 2.4 版本指针（head, base, current）

### head：最新版本

**`head` 是一个特殊的版本指针，指向版本链的最新版本。**

```bash
# 升级到最新版本
alembic upgrade head

# 等价于
alembic upgrade ghi789  # 假设 ghi789 是最新版本
```

**head 的动态性：**
```python
# 初始状态
# None -> abc123 (head)

# 创建新迁移后
# None -> abc123 -> def456 (head)

# 再创建新迁移
# None -> abc123 -> def456 -> ghi789 (head)

# head 始终指向最新版本
```

### base：初始版本

**`base` 是一个特殊的版本指针，指向版本链的起点（空数据库状态）。**

```bash
# 回滚到初始状态（删除所有表）
alembic downgrade base

# 等价于
alembic downgrade <empty>  # 空数据库
```

**base 的含义：**
- 数据库没有任何 Alembic 管理的表
- `alembic_version` 表不存在或为空
- 相当于"零版本"

### current：当前版本

**`current` 显示数据库当前所在的版本。**

```bash
# 查看当前版本
alembic current

# 输出：
# def456 (head)
# 或
# abc123
```

**current 的来源：**
```sql
-- current 的值来自 alembic_version 表
SELECT version_num FROM alembic_version;
-- def456
```

### 相对版本指针

**Alembic 支持相对版本指针，用于增量升级或回滚。**

```bash
# 升级1个版本
alembic upgrade +1

# 升级2个版本
alembic upgrade +2

# 回滚1个版本
alembic downgrade -1

# 回滚2个版本
alembic downgrade -2
```

**示例：**
```python
# 当前版本：abc123
# 版本链：None -> abc123 -> def456 -> ghi789 -> jkl012

# 执行 alembic upgrade +2
# 结果：abc123 -> def456 -> ghi789
# 当前版本变为：ghi789

# 执行 alembic downgrade -1
# 结果：ghi789 -> def456
# 当前版本变为：def456
```

---

## 2.5 版本链的分支与合并

### 分支场景

**多人协作时，可能出现版本链分支。**

```python
# 主分支
None -> abc123 -> def456

# 开发者 A 创建迁移
# versions/ghi789_add_avatar.py
revision = 'ghi789'
down_revision = 'def456'

# 开发者 B 同时创建迁移
# versions/jkl012_add_posts.py
revision = 'jkl012'
down_revision = 'def456'  # 也依赖 def456

# 形成分支：
#       abc123
#         |
#       def456
#       /    \
#   ghi789  jkl012
```

### 检测分支

```bash
# Alembic 会检测到分支
alembic upgrade head

# 输出错误：
# ERROR: Multiple head revisions are present for given argument 'head'; please specify a specific target revision, or use --resolve-dependencies
```

### 合并分支

**方式1：手动调整 down_revision**

```python
# 修改其中一个迁移的 down_revision
# versions/jkl012_add_posts.py
revision = 'jkl012'
down_revision = 'ghi789'  # 改为依赖 ghi789

# 形成线性链：
# None -> abc123 -> def456 -> ghi789 -> jkl012
```

**方式2：使用 merge 命令**

```bash
# 创建合并迁移
alembic merge -m "merge branches" ghi789 jkl012

# 生成的合并迁移
# versions/mno345_merge_branches.py
revision = 'mno345'
down_revision = ('ghi789', 'jkl012')  # 多个父版本

def upgrade():
    pass  # 通常为空

def downgrade():
    pass

# 形成菱形结构：
#       abc123
#         |
#       def456
#       /    \
#   ghi789  jkl012
#       \    /
#       mno345
```

---

## 2.6 版本控制的最佳实践

### 1. 频繁同步主分支

```bash
# 开发流程
git checkout main
git pull origin main
alembic upgrade head  # 同步数据库到最新版本

git checkout -b feature/add-avatar
# 修改代码
alembic revision --autogenerate -m "add avatar"
git add .
git commit -m "feat: add avatar field"
git push
```

### 2. 一个 PR 一个迁移

**避免在一个分支中创建多个迁移，减少冲突。**

```bash
# 好的做法：
feature/add-avatar -> 1个迁移
feature/add-posts -> 1个迁移

# 不好的做法：
feature/big-refactor -> 5个迁移（容易冲突）
```

### 3. 迁移脚本尽早合并

```bash
# 创建迁移后立即提 PR
alembic revision --autogenerate -m "add avatar"
git add versions/abc123_add_avatar.py
git commit -m "feat: add avatar migration"
git push
# 立即创建 PR，尽快合并
```

### 4. 使用 pre-commit hook 检查

```bash
# .git/hooks/pre-commit
#!/bin/bash

# 检查迁移脚本的 down_revision 是否正确
python scripts/check_migrations.py

if [ $? -ne 0 ]; then
    echo "Migration check failed!"
    exit 1
fi
```

```python
# scripts/check_migrations.py
import os
import re

def check_migrations():
    """检查迁移脚本的 down_revision 是否形成线性链"""
    versions_dir = "alembic/versions"
    revisions = {}

    # 读取所有迁移脚本
    for filename in os.listdir(versions_dir):
        if not filename.endswith(".py"):
            continue

        with open(os.path.join(versions_dir, filename)) as f:
            content = f.read()

        # 提取 revision 和 down_revision
        revision_match = re.search(r"revision = '(\w+)'", content)
        down_revision_match = re.search(r"down_revision = '(\w+)'|down_revision = None", content)

        if revision_match:
            revision = revision_match.group(1)
            down_revision = down_revision_match.group(1) if down_revision_match and "None" not in down_revision_match.group(0) else None
            revisions[revision] = down_revision

    # 检查是否有多个 head
    heads = [rev for rev, down in revisions.items() if rev not in [d for d in revisions.values() if d]]
    if len(heads) > 1:
        print(f"Error: Multiple heads detected: {heads}")
        return False

    return True

if __name__ == "__main__":
    if not check_migrations():
        exit(1)
```

---

## 2.7 在 AI Agent 后端开发中的应用

### 场景1：多环境版本同步

```bash
# 开发环境
alembic current
# 输出：abc123

alembic upgrade head
# 升级到最新版本

# 测试环境
ssh test-server
alembic current
# 输出：abc123

alembic upgrade head
# 升级到最新版本

# 生产环境
ssh production-server
alembic current
# 输出：abc123

alembic upgrade head
# 升级到最新版本

# 所有环境版本一致！
```

### 场景2：CI/CD 自动化

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Check current database version
        run: |
          alembic current
          echo "Current version: $(alembic current)"

      - name: Run migrations
        run: |
          alembic upgrade head

      - name: Verify migration success
        run: |
          alembic current
          echo "New version: $(alembic current)"
```

### 场景3：版本回滚策略

```bash
# 场景：新迁移导致生产环境问题

# 1. 查看当前版本
alembic current
# 输出：ghi789 (有问题的版本)

# 2. 查看历史版本
alembic history
# ghi789 -> head, add new feature (有问题)
# def456, add avatar
# abc123, create users

# 3. 回滚到上一个稳定版本
alembic downgrade def456

# 4. 验证回滚成功
alembic current
# 输出：def456

# 5. 修复问题后，创建新迁移（不要修改 ghi789）
alembic revision -m "fix issue in ghi789"
alembic upgrade head
```

### 场景4：数据库版本审计

```python
# 记录数据库版本变更历史
# app/services/migration_audit.py
from sqlalchemy import create_engine, text
from datetime import datetime

def log_migration(revision: str, action: str):
    """记录迁移操作到审计表"""
    engine = create_engine(DATABASE_URL)
    with engine.connect() as conn:
        conn.execute(text("""
            INSERT INTO migration_audit (revision, action, timestamp)
            VALUES (:revision, :action, :timestamp)
        """), {
            "revision": revision,
            "action": action,
            "timestamp": datetime.utcnow()
        })
        conn.commit()

# 在迁移脚本中调用
def upgrade():
    op.add_column('users', sa.Column('avatar', sa.String()))
    log_migration('abc123', 'upgrade')

def downgrade():
    op.drop_column('users', 'avatar')
    log_migration('abc123', 'downgrade')
```

---

## 总结

**版本控制机制的核心要点：**

1. **alembic_version 表**：单行单列，存储当前版本号
2. **线性版本链**：有向无环图，每个迁移指向父迁移
3. **版本标识符**：16位随机字符串，全局唯一
4. **版本指针**：head（最新）、base（初始）、current（当前）
5. **分支合并**：手动调整或使用 merge 命令

**在 AI Agent 后端开发中：**
- 通过版本控制确保多环境数据库一致性
- 通过 CI/CD 自动化迁移流程
- 通过版本审计追踪数据库变更历史
- 通过回滚策略应对生产环境问题

**记住：**
> Alembic 的版本控制机制类似 Git，但更简单：只有线性链（或菱形合并），没有复杂的分支策略。核心是 alembic_version 表 + 版本链。
