# 核心概念 8：类型守卫

## 一句话定义

**类型守卫（Type Guard）是通过运行时检查来收窄类型范围的机制，让类型检查器在特定代码块中知道变量的精确类型，是连接静态类型和运行时逻辑的桥梁。**

---

## 为什么需要类型守卫？

### 问题：联合类型的类型不确定

```python
from typing import Union

def process(value: Union[int, str]) -> str:
    # ⚠️ 类型检查器不知道 value 是 int 还是 str
    return value.upper()  # 类型错误：int 没有 upper 方法
```

**类型守卫的解决方案**：

```python
from typing import Union

def process(value: Union[int, str]) -> str:
    if isinstance(value, str):
        # ✅ 类型检查器知道这里 value 是 str
        return value.upper()
    else:
        # ✅ 类型检查器知道这里 value 是 int
        return str(value)
```

---

## 内置类型守卫

### 1. isinstance 检查

```python
from typing import Union

def process(value: Union[int, str, list]) -> str:
    if isinstance(value, int):
        # 类型收窄为 int
        return str(value * 2)
    elif isinstance(value, str):
        # 类型收窄为 str
        return value.upper()
    else:
        # 类型收窄为 list
        return f"List with {len(value)} items"

# 多类型检查
def handle(value: Union[int, str, float]) -> str:
    if isinstance(value, (int, float)):
        # 类型收窄为 int | float
        return f"Number: {value * 2}"
    else:
        # 类型收窄为 str
        return value.upper()
```

### 2. is None 检查

```python
from typing import Optional

def greet(name: Optional[str]) -> str:
    if name is None:
        # 类型收窄为 None
        return "Hello, stranger"
    else:
        # 类型收窄为 str
        return f"Hello, {name.upper()}"

# 反向检查
def greet_v2(name: Optional[str]) -> str:
    if name is not None:
        # 类型收窄为 str
        return f"Hello, {name.upper()}"
    return "Hello, stranger"
```

### 3. 真值检查

```python
from typing import Optional

def process(value: Optional[str]) -> str:
    if value:
        # 类型收窄为 str（非空字符串）
        return value.upper()
    return "Empty"

# 注意：空字符串会被视为 False
def safe_process(value: Optional[str]) -> str:
    if value is not None:
        # ✅ 更安全：包括空字符串
        return value.upper()
    return "None"
```

### 4. hasattr 检查

```python
from typing import Union

class Dog:
    def bark(self) -> str:
        return "Woof!"

class Cat:
    def meow(self) -> str:
        return "Meow!"

def make_sound(animal: Union[Dog, Cat]) -> str:
    if hasattr(animal, 'bark'):
        # ⚠️ 类型检查器可能不会收窄类型
        return animal.bark()  # 类型检查器可能报错
    else:
        return animal.meow()

# ✅ 更好的方式：使用 isinstance
def make_sound_v2(animal: Union[Dog, Cat]) -> str:
    if isinstance(animal, Dog):
        return animal.bark()
    else:
        return animal.meow()
```

---

## 用户定义类型守卫（TypeGuard）

### 1. 基本用法

```python
from typing import TypeGuard

def is_str_list(val: list) -> TypeGuard[list[str]]:
    """检查列表是否全是字符串"""
    return all(isinstance(x, str) for x in val)

def process_items(items: list) -> None:
    if is_str_list(items):
        # ✅ 类型检查器知道 items 是 list[str]
        for item in items:
            print(item.upper())  # ✅ 类型安全
    else:
        print("Not all strings")

# 使用
mixed_list = [1, "hello", 3]
str_list = ["hello", "world"]

process_items(mixed_list)  # "Not all strings"
process_items(str_list)    # "HELLO\nWORLD"
```

### 2. 复杂类型守卫

```python
from typing import TypeGuard, TypedDict

class User(TypedDict):
    name: str
    age: int
    email: str

def is_user(data: dict) -> TypeGuard[User]:
    """检查字典是否是有效的 User"""
    return (
        isinstance(data.get("name"), str) and
        isinstance(data.get("age"), int) and
        isinstance(data.get("email"), str)
    )

def process_user(data: dict) -> str:
    if is_user(data):
        # ✅ 类型检查器知道 data 是 User
        return f"User: {data['name']}, Age: {data['age']}"
    return "Invalid user data"

# 使用
valid_user = {"name": "Alice", "age": 30, "email": "alice@example.com"}
invalid_user = {"name": "Bob", "age": "30"}  # age 是字符串

print(process_user(valid_user))    # "User: Alice, Age: 30"
print(process_user(invalid_user))  # "Invalid user data"
```

### 3. 泛型类型守卫

```python
from typing import TypeVar, TypeGuard

T = TypeVar('T')

def is_list_of(val: list, item_type: type[T]) -> TypeGuard[list[T]]:
    """检查列表是否全是指定类型"""
    return all(isinstance(x, item_type) for x in val)

def process_list(items: list) -> None:
    if is_list_of(items, int):
        # 类型收窄为 list[int]
        total = sum(items)
        print(f"Sum: {total}")
    elif is_list_of(items, str):
        # 类型收窄为 list[str]
        joined = ", ".join(items)
        print(f"Joined: {joined}")
    else:
        print("Mixed types")

# 使用
process_list([1, 2, 3])           # "Sum: 6"
process_list(["a", "b", "c"])     # "Joined: a, b, c"
process_list([1, "a", 3])         # "Mixed types"
```

---

## TypeIs（Python 3.13+）

### 1. TypeIs vs TypeGuard

```python
from typing import TypeGuard, TypeIs

# TypeGuard：只能收窄类型
def is_str_guard(val: object) -> TypeGuard[str]:
    return isinstance(val, str)

# TypeIs：可以收窄和排除类型
def is_str_is(val: object) -> TypeIs[str]:
    return isinstance(val, str)

# 使用 TypeGuard
def process_guard(val: int | str) -> None:
    if is_str_guard(val):
        # val 是 str
        print(val.upper())
    else:
        # val 仍然是 int | str（TypeGuard 不排除类型）
        print(val)  # 类型检查器可能报错

# 使用 TypeIs
def process_is(val: int | str) -> None:
    if is_str_is(val):
        # val 是 str
        print(val.upper())
    else:
        # val 是 int（TypeIs 排除了 str）
        print(val * 2)  # ✅ 类型安全
```

### 2. TypeIs 的优势

```python
from typing import TypeIs

def is_positive(val: int) -> TypeIs[int]:
    """检查是否是正整数"""
    return val > 0

def process_number(val: int) -> None:
    if is_positive(val):
        # val 仍然是 int，但我们知道它是正数
        print(f"Positive: {val}")
    else:
        # val 是 int，但不是正数
        print(f"Non-positive: {val}")
```

---

## 类型收窄（Type Narrowing）

### 1. 基于控制流的收窄

```python
from typing import Optional

def process(value: Optional[str]) -> str:
    # 早期返回模式
    if value is None:
        return "None"

    # 这里 value 自动收窄为 str
    return value.upper()

# 断言收窄
def process_v2(value: Optional[str]) -> str:
    assert value is not None, "Value must not be None"
    # 这里 value 收窄为 str
    return value.upper()
```

### 2. 基于赋值的收窄

```python
from typing import Union

def process(value: Union[int, str]) -> str:
    if isinstance(value, int):
        value = str(value)  # 重新赋值

    # 这里 value 是 str
    return value.upper()
```

### 3. 基于异常的收窄

```python
from typing import Optional

def process(value: Optional[str]) -> str:
    if value is None:
        raise ValueError("Value cannot be None")

    # 这里 value 收窄为 str
    return value.upper()
```

---

## 在 LangChain 中的应用

### 1. 消息类型守卫

```python
from typing import TypeGuard
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, SystemMessage

def is_human_message(msg: BaseMessage) -> TypeGuard[HumanMessage]:
    """检查是否是 HumanMessage"""
    return isinstance(msg, HumanMessage)

def is_ai_message(msg: BaseMessage) -> TypeGuard[AIMessage]:
    """检查是否是 AIMessage"""
    return isinstance(msg, AIMessage)

def process_messages(messages: list[BaseMessage]) -> None:
    for msg in messages:
        if is_human_message(msg):
            # msg 是 HumanMessage
            print(f"Human: {msg.content}")
        elif is_ai_message(msg):
            # msg 是 AIMessage
            print(f"AI: {msg.content}")
        else:
            # msg 是其他类型
            print(f"Other: {msg.content}")

# 使用
messages = [
    HumanMessage(content="Hello"),
    AIMessage(content="Hi there!"),
    SystemMessage(content="System message")
]
process_messages(messages)
```

### 2. Runnable 类型守卫

```python
from typing import TypeGuard, Any
from langchain_core.runnables import Runnable, RunnableLambda

def is_runnable_lambda(runnable: Runnable) -> TypeGuard[RunnableLambda]:
    """检查是否是 RunnableLambda"""
    return isinstance(runnable, RunnableLambda)

def optimize_chain(components: list[Runnable]) -> list[Runnable]:
    """优化链：合并连续的 RunnableLambda"""
    optimized = []
    for component in components:
        if is_runnable_lambda(component):
            # component 是 RunnableLambda
            # 可以访问 RunnableLambda 特有的属性
            print(f"Lambda: {component.func}")
        optimized.append(component)
    return optimized
```

### 3. 配置验证

```python
from typing import TypeGuard, TypedDict, Any

class ValidConfig(TypedDict):
    model: str
    temperature: float
    max_tokens: int

def is_valid_config(config: dict[str, Any]) -> TypeGuard[ValidConfig]:
    """验证配置是否有效"""
    return (
        isinstance(config.get("model"), str) and
        isinstance(config.get("temperature"), (int, float)) and
        isinstance(config.get("max_tokens"), int) and
        0 <= config.get("temperature", 0) <= 2 and
        config.get("max_tokens", 0) > 0
    )

def create_model(config: dict[str, Any]) -> None:
    if is_valid_config(config):
        # config 是 ValidConfig
        print(f"Creating model: {config['model']}")
        print(f"Temperature: {config['temperature']}")
        print(f"Max tokens: {config['max_tokens']}")
    else:
        raise ValueError("Invalid configuration")

# 使用
valid = {"model": "gpt-4", "temperature": 0.7, "max_tokens": 1000}
invalid = {"model": "gpt-4", "temperature": "high"}

create_model(valid)  # ✅
# create_model(invalid)  # ❌ ValueError
```

---

## 实战示例：类型安全的数据验证

```python
"""
类型安全的数据验证
演示：TypeGuard 在实际项目中的应用
"""

from typing import TypeGuard, TypedDict, Literal, Any
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage

# ===== 1. 定义数据类型 =====

Role = Literal["user", "assistant", "system"]

class Message(TypedDict):
    role: Role
    content: str

class Conversation(TypedDict):
    id: str
    messages: list[Message]
    metadata: dict[str, str]

# ===== 2. 定义类型守卫 =====

def is_valid_role(role: str) -> TypeGuard[Role]:
    """检查是否是有效的角色"""
    return role in ["user", "assistant", "system"]

def is_message(data: dict[str, Any]) -> TypeGuard[Message]:
    """检查是否是有效的 Message"""
    return (
        isinstance(data.get("role"), str) and
        is_valid_role(data["role"]) and
        isinstance(data.get("content"), str)
    )

def is_conversation(data: dict[str, Any]) -> TypeGuard[Conversation]:
    """检查是否是有效的 Conversation"""
    if not isinstance(data.get("id"), str):
        return False
    if not isinstance(data.get("messages"), list):
        return False
    if not all(is_message(msg) for msg in data["messages"]):
        return False
    if not isinstance(data.get("metadata"), dict):
        return False
    return True

# ===== 3. 数据处理函数 =====

def process_message(msg: Message) -> BaseMessage:
    """将 Message 转换为 LangChain BaseMessage"""
    role = msg["role"]
    content = msg["content"]

    if role == "user":
        return HumanMessage(content=content)
    elif role == "assistant":
        return AIMessage(content=content)
    else:
        # system 消息
        from langchain_core.messages import SystemMessage
        return SystemMessage(content=content)

def process_conversation(data: dict[str, Any]) -> list[BaseMessage]:
    """处理对话数据"""
    if not is_conversation(data):
        raise ValueError("Invalid conversation data")

    # ✅ 类型检查器知道 data 是 Conversation
    messages = data["messages"]
    return [process_message(msg) for msg in messages]

# ===== 4. 使用示例 =====

print("=== 类型安全的数据验证 ===\n")

# 有效数据
valid_data = {
    "id": "conv-123",
    "messages": [
        {"role": "user", "content": "Hello"},
        {"role": "assistant", "content": "Hi there!"},
        {"role": "user", "content": "How are you?"}
    ],
    "metadata": {"source": "web"}
}

# 无效数据
invalid_data = {
    "id": "conv-456",
    "messages": [
        {"role": "invalid_role", "content": "Hello"}  # 无效角色
    ],
    "metadata": {"source": "web"}
}

# 处理有效数据
try:
    messages = process_conversation(valid_data)
    print("✅ Valid conversation processed:")
    for msg in messages:
        print(f"  - {type(msg).__name__}: {msg.content}")
except ValueError as e:
    print(f"❌ Error: {e}")

print()

# 处理无效数据
try:
    messages = process_conversation(invalid_data)
    print("✅ Invalid conversation processed (should not happen)")
except ValueError as e:
    print(f"❌ Error: {e}")

# ===== 5. 泛型类型守卫 =====

from typing import TypeVar

T = TypeVar('T')

def is_list_of_type(val: list, guard: TypeGuard) -> TypeGuard[list[T]]:
    """检查列表是否全是指定类型"""
    return all(guard(item) for item in val)

def validate_messages(data: list[dict[str, Any]]) -> list[Message]:
    """验证消息列表"""
    if not all(is_message(msg) for msg in data):
        raise ValueError("Invalid messages")

    # ✅ 类型检查器知道所有消息都是 Message
    return data  # type: ignore

# 使用
messages_data = [
    {"role": "user", "content": "Hello"},
    {"role": "assistant", "content": "Hi"}
]

validated = validate_messages(messages_data)
print("\n✅ Messages validated:")
for msg in validated:
    print(f"  - {msg['role']}: {msg['content']}")

# ===== 6. 运行时验证 + 类型守卫 =====

def safe_process_conversation(data: Any) -> list[BaseMessage] | None:
    """安全处理对话（返回 None 而非抛出异常）"""
    if not isinstance(data, dict):
        print("❌ Data is not a dictionary")
        return None

    if not is_conversation(data):
        print("❌ Invalid conversation structure")
        return None

    # ✅ 类型安全
    return [process_message(msg) for msg in data["messages"]]

# 使用
result = safe_process_conversation(valid_data)
if result:
    print("\n✅ Safe processing succeeded")
else:
    print("\n❌ Safe processing failed")

result = safe_process_conversation("not a dict")
if result:
    print("✅ Safe processing succeeded")
else:
    print("❌ Safe processing failed (expected)")
```

**运行输出**：
```
=== 类型安全的数据验证 ===

✅ Valid conversation processed:
  - HumanMessage: Hello
  - AIMessage: Hi there!
  - HumanMessage: How are you?

❌ Error: Invalid conversation data

✅ Messages validated:
  - user: Hello
  - assistant: Hi

✅ Safe processing succeeded

❌ Data is not a dictionary
❌ Safe processing failed (expected)
```

---

## 2025-2026 最佳实践

### 1. 优先使用 TypeIs（Python 3.13+）

```python
from typing import TypeIs

# ✅ 推荐：使用 TypeIs
def is_positive(val: int) -> TypeIs[int]:
    return val > 0

# ❌ 旧方式：使用 TypeGuard
from typing import TypeGuard

def is_positive_old(val: int) -> TypeGuard[int]:
    return val > 0
```

### 2. 类型守卫应该简单明确

```python
# ❌ 复杂的类型守卫
def is_valid_user(data: dict) -> TypeGuard[User]:
    try:
        # 复杂的验证逻辑
        validate_email(data["email"])
        validate_age(data["age"])
        return True
    except:
        return False

# ✅ 简单的类型守卫
def is_valid_user(data: dict) -> TypeGuard[User]:
    return (
        isinstance(data.get("name"), str) and
        isinstance(data.get("age"), int) and
        isinstance(data.get("email"), str)
    )
```

### 3. 结合 Pydantic 进行运行时验证

```python
from pydantic import BaseModel, ValidationError
from typing import TypeGuard

class User(BaseModel):
    name: str
    age: int
    email: str

def is_user(data: dict) -> TypeGuard[dict]:
    """使用 Pydantic 验证"""
    try:
        User(**data)
        return True
    except ValidationError:
        return False

# 使用
data = {"name": "Alice", "age": 30, "email": "alice@example.com"}
if is_user(data):
    # 类型安全
    user = User(**data)
    print(user.name)
```

### 4. 避免过度使用类型守卫

```python
# ❌ 过度使用
def process(value: int | str) -> str:
    if is_int(value):
        return str(value)
    elif is_str(value):
        return value
    else:
        return ""

# ✅ 使用内置检查
def process(value: int | str) -> str:
    if isinstance(value, int):
        return str(value)
    else:
        return value
```

---

## 常见陷阱

### 1. TypeGuard 不验证运行时

```python
from typing import TypeGuard

def is_positive(val: int) -> TypeGuard[int]:
    return True  # ❌ 总是返回 True，但不验证

# 运行时不安全
def process(val: int) -> None:
    if is_positive(val):
        # 类型检查器认为 val 是正数，但实际可能不是
        print(f"Positive: {val}")

process(-5)  # 运行时不会报错
```

### 2. hasattr 不是类型守卫

```python
from typing import Union

class Dog:
    def bark(self) -> str:
        return "Woof!"

class Cat:
    def meow(self) -> str:
        return "Meow!"

def make_sound(animal: Union[Dog, Cat]) -> str:
    if hasattr(animal, 'bark'):
        # ⚠️ 类型检查器不会收窄类型
        return animal.bark()  # 类型错误
    else:
        return animal.meow()

# ✅ 使用 isinstance
def make_sound_v2(animal: Union[Dog, Cat]) -> str:
    if isinstance(animal, Dog):
        return animal.bark()
    else:
        return animal.meow()
```

### 3. 类型守卫的返回值必须是布尔

```python
from typing import TypeGuard

# ❌ 错误：返回值不是布尔
def is_str(val: object) -> TypeGuard[str]:
    return val if isinstance(val, str) else None  # 类型错误

# ✅ 正确：返回布尔值
def is_str(val: object) -> TypeGuard[str]:
    return isinstance(val, str)
```

---

## 学习检查清单

- [ ] 理解类型守卫的作用和原理
- [ ] 掌握内置类型守卫（isinstance, is None）
- [ ] 了解 TypeGuard 的定义和使用
- [ ] 理解 TypeIs 与 TypeGuard 的区别
- [ ] 掌握类型收窄机制
- [ ] 了解 LangChain 中的类型守卫应用
- [ ] 能够创建自定义类型守卫
- [ ] 遵循 2025-2026 最佳实践

---

## 下一步学习

- **核心概念 9**：mypy 与 pyright - 学习类型检查工具
- **核心概念 5**：类型推断机制 - 复习类型推断
- **核心概念 7**：Literal 与 TypedDict - 复习精确类型

---

## 参考资源

1. [PEP 647 – User-Defined Type Guards](https://peps.python.org/pep-0647/) - TypeGuard 规范
2. [PEP 742 – Narrowing types with TypeIs](https://peps.python.org/pep-0742/) - TypeIs 规范（Python 3.13+）
3. [Advanced, Overlooked Python Typing](https://martynassubonis.substack.com/p/advanced-overlooked-python-typing) - TypeGuard 深入讲解
4. [Python typing 官方文档 - TypeGuard](https://docs.python.org/3/library/typing.html#typing.TypeGuard)
5. [Python 3.13 新特性 - TypeIs](https://docs.python.org/3/whatsnew/3.13.html)
6. [Type Narrowing in Python](https://typing.python.org/en/latest/guides/narrowing.html) - 官方指南
