# 自定义Tool - 实战代码01：API调用工具

> 完整可运行的API调用Tool示例，涵盖天气API、新闻API等场景

---

## 概述

API调用是Tool最常见的应用场景之一。本文提供完整的、可直接运行的代码示例。

**涵盖场景：**
1. 天气查询API
2. 新闻搜索API
3. 股票行情API
4. 地理位置API

**技术要点：**
- 异步HTTP客户端（httpx）
- 连接池复用
- 超时处理
- 错误重试
- 参数验证

---

## 环境准备

### 1. 安装依赖

```bash
# 安装必需的库
uv add httpx langchain langchain-openai python-dotenv
```

### 2. 配置API密钥

创建`.env`文件：

```bash
# OpenAI API（用于LLM）
OPENAI_API_KEY=your_openai_key_here

# 天气API（示例使用OpenWeatherMap）
WEATHER_API_KEY=your_weather_api_key

# 新闻API（示例使用NewsAPI）
NEWS_API_KEY=your_news_api_key

# 股票API（示例使用Alpha Vantage）
STOCK_API_KEY=your_stock_api_key
```

---

## 示例1：天气查询Tool

### 完整代码

```python
"""
天气查询Tool示例
演示：调用OpenWeatherMap API获取城市天气信息
"""

import os
import httpx
from typing import Optional
from langchain.tools import tool
from pydantic import BaseModel, Field
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

# 创建全局HTTP客户端（复用连接）
http_client = httpx.AsyncClient(
    limits=httpx.Limits(max_connections=10),
    timeout=httpx.Timeout(10.0)
)

# ===== 1. 定义参数Schema =====
class WeatherInput(BaseModel):
    """天气查询参数"""
    city: str = Field(
        description="城市名称，支持中文和英文，如'北京'、'Beijing'、'上海'、'Shanghai'",
        min_length=1,
        max_length=50
    )
    unit: str = Field(
        default="metric",
        description="温度单位：metric（摄氏度）或imperial（华氏度）",
        pattern=r'^(metric|imperial)$'
    )

# ===== 2. 定义Tool =====
@tool(args_schema=WeatherInput)
async def get_weather(city: str, unit: str = "metric") -> str:
    """获取指定城市的天气信息

    调用OpenWeatherMap API获取实时天气数据，包括：
    - 天气状况（晴天、多云、雨天等）
    - 温度（摄氏度或华氏度）
    - 湿度（百分比）
    - 风速（米/秒）

    适用场景：
    - 用户询问"北京今天天气怎么样？"
    - 用户询问"上海会下雨吗？"
    - 用户询问"广州的温度是多少？"
    - 用户询问"明天需要带伞吗？"

    Args:
        city: 城市名称，支持中文和英文
        unit: 温度单位，metric（摄氏度）或imperial（华氏度）

    Returns:
        天气信息的文本描述

    注意事项：
    - 需要配置WEATHER_API_KEY环境变量
    - 仅支持主要城市
    - 数据更新频率为每小时
    """
    api_key = os.getenv("WEATHER_API_KEY")
    if not api_key:
        return "错误：未配置WEATHER_API_KEY环境变量。请在.env文件中配置API密钥。"

    try:
        # 调用OpenWeatherMap API
        response = await http_client.get(
            "https://api.openweathermap.org/data/2.5/weather",
            params={
                "q": city,
                "appid": api_key,
                "units": unit,
                "lang": "zh_cn"  # 中文描述
            }
        )

        # 检查HTTP状态码
        if response.status_code == 404:
            return f"错误：未找到城市'{city}'。请检查城市名称是否正确。"
        elif response.status_code == 401:
            return "错误：API密钥无效。请检查WEATHER_API_KEY配置。"
        elif response.status_code != 200:
            return f"错误：API请求失败（状态码{response.status_code}）。请稍后重试。"

        # 解析响应
        data = response.json()

        # 提取天气信息
        weather = data["weather"][0]["description"]
        temp = data["main"]["temp"]
        feels_like = data["main"]["feels_like"]
        humidity = data["main"]["humidity"]
        wind_speed = data["wind"]["speed"]

        # 温度单位
        temp_unit = "°C" if unit == "metric" else "°F"

        # 格式化返回结果
        return f"""{city}的天气：
天气状况：{weather}
温度：{temp}{temp_unit}（体感温度{feels_like}{temp_unit}）
湿度：{humidity}%
风速：{wind_speed}m/s
"""

    except httpx.TimeoutException:
        return f"错误：请求超时。建议：请检查网络连接或稍后重试。"

    except httpx.NetworkError:
        return f"错误：网络连接失败。建议：请检查网络连接。"

    except KeyError as e:
        return f"错误：API响应格式异常（缺少字段{e}）。建议：请联系技术支持。"

    except Exception as e:
        return f"错误：{str(e)}。建议：请稍后重试或联系技术支持。"

# ===== 3. 测试Tool =====
async def test_weather_tool():
    """测试天气Tool"""
    print("=== 测试天气Tool ===\n")

    # 测试1：查询北京天气
    print("测试1：查询北京天气")
    result = await get_weather.ainvoke({"city": "北京", "unit": "metric"})
    print(result)
    print()

    # 测试2：查询上海天气（华氏度）
    print("测试2：查询上海天气（华氏度）")
    result = await get_weather.ainvoke({"city": "上海", "unit": "imperial"})
    print(result)
    print()

    # 测试3：查询不存在的城市
    print("测试3：查询不存在的城市")
    result = await get_weather.ainvoke({"city": "不存在的城市", "unit": "metric"})
    print(result)
    print()

# ===== 4. 集成到Agent =====
async def create_weather_agent():
    """创建天气Agent"""
    from langchain_openai import ChatOpenAI
    from langchain.agents import create_tool_calling_agent, AgentExecutor
    from langchain.prompts import ChatPromptTemplate

    # 定义Tools
    tools = [get_weather]

    # 创建LLM
    llm = ChatOpenAI(model="gpt-4", temperature=0)

    # 创建Prompt
    prompt = ChatPromptTemplate.from_messages([
        ("system", "你是一个智能天气助手，可以查询全球主要城市的天气信息。"),
        ("human", "{input}"),
        ("placeholder", "{agent_scratchpad}"),
    ])

    # 创建Agent
    agent = create_tool_calling_agent(llm, tools, prompt)

    # 创建执行器
    agent_executor = AgentExecutor(
        agent=agent,
        tools=tools,
        verbose=True,
        max_iterations=3
    )

    return agent_executor

async def test_weather_agent():
    """测试天气Agent"""
    print("=== 测试天气Agent ===\n")

    agent = await create_weather_agent()

    # 测试问题
    questions = [
        "北京今天天气怎么样？",
        "上海会下雨吗？",
        "广州和深圳的天气对比一下",
    ]

    for question in questions:
        print(f"问题：{question}")
        result = await agent.ainvoke({"input": question})
        print(f"回答：{result['output']}\n")

# ===== 5. 运行示例 =====
if __name__ == "__main__":
    import asyncio

    # 运行测试
    asyncio.run(test_weather_tool())
    # asyncio.run(test_weather_agent())
```

### 运行输出示例

```
=== 测试天气Tool ===

测试1：查询北京天气
北京的天气：
天气状况：晴
温度：25°C（体感温度23°C）
湿度：60%
风速：3.5m/s

测试2：查询上海天气（华氏度）
上海的天气：
天气状况：多云
温度：77°F（体感温度75°F）
湿度：65%
风速：4.2m/s

测试3：查询不存在的城市
错误：未找到城市'不存在的城市'。请检查城市名称是否正确。
```

---

## 示例2：新闻搜索Tool

### 完整代码

```python
"""
新闻搜索Tool示例
演示：调用NewsAPI搜索最新新闻
"""

import os
import httpx
from typing import Optional
from langchain.tools import tool
from pydantic import BaseModel, Field
from dotenv import load_dotenv
from datetime import datetime, timedelta

load_dotenv()

# 全局HTTP客户端
http_client = httpx.AsyncClient(
    limits=httpx.Limits(max_connections=10),
    timeout=httpx.Timeout(10.0)
)

# ===== 1. 定义参数Schema =====
class NewsInput(BaseModel):
    """新闻搜索参数"""
    topic: str = Field(
        description="新闻主题或关键词，如'科技'、'体育'、'人工智能'",
        min_length=1,
        max_length=100
    )
    limit: int = Field(
        default=5,
        description="返回新闻数量",
        ge=1,
        le=20
    )
    language: str = Field(
        default="zh",
        description="新闻语言：zh（中文）或en（英文）",
        pattern=r'^(zh|en)$'
    )

# ===== 2. 定义Tool =====
@tool(args_schema=NewsInput)
async def search_news(topic: str, limit: int = 5, language: str = "zh") -> str:
    """搜索最新新闻

    调用NewsAPI搜索指定主题的最新新闻，返回新闻标题、摘要和发布时间。

    适用场景：
    - 用户询问"最近有什么科技新闻？"
    - 用户询问"今天的体育新闻"
    - 用户询问"人工智能领域的最新动态"

    Args:
        topic: 新闻主题或关键词
        limit: 返回新闻数量，默认5条
        language: 新闻语言，zh（中文）或en（英文）

    Returns:
        新闻列表，每条包含标题、摘要、来源和发布时间

    注意事项：
    - 需要配置NEWS_API_KEY环境变量
    - 免费版API有请求限制
    - 新闻数据可能有延迟
    """
    api_key = os.getenv("NEWS_API_KEY")
    if not api_key:
        return "错误：未配置NEWS_API_KEY环境变量。请在.env文件中配置API密钥。"

    try:
        # 计算查询时间范围（最近7天）
        from_date = (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d")

        # 调用NewsAPI
        response = await http_client.get(
            "https://newsapi.org/v2/everything",
            params={
                "q": topic,
                "apiKey": api_key,
                "language": language,
                "from": from_date,
                "sortBy": "publishedAt",
                "pageSize": limit
            }
        )

        # 检查HTTP状态码
        if response.status_code == 401:
            return "错误：API密钥无效。请检查NEWS_API_KEY配置。"
        elif response.status_code == 429:
            return "错误：API请求次数超限。建议：请稍后重试。"
        elif response.status_code != 200:
            return f"错误：API请求失败（状态码{response.status_code}）。请稍后重试。"

        # 解析响应
        data = response.json()

        if data["totalResults"] == 0:
            return f"未找到关于'{topic}'的新闻。建议：尝试其他关键词。"

        # 格式化新闻列表
        articles = data["articles"]
        news_list = []

        for i, article in enumerate(articles[:limit], 1):
            title = article.get("title", "无标题")
            description = article.get("description", "无摘要")
            source = article.get("source", {}).get("name", "未知来源")
            published_at = article.get("publishedAt", "")

            # 格式化发布时间
            if published_at:
                try:
                    dt = datetime.fromisoformat(published_at.replace("Z", "+00:00"))
                    published_at = dt.strftime("%Y-%m-%d %H:%M")
                except:
                    pass

            news_list.append(f"""新闻{i}：
标题：{title}
摘要：{description}
来源：{source}
时间：{published_at}
""")

        return f"找到{len(articles)}条关于'{topic}'的新闻：\n\n" + "\n".join(news_list)

    except httpx.TimeoutException:
        return "错误：请求超时。建议：请检查网络连接或稍后重试。"

    except httpx.NetworkError:
        return "错误：网络连接失败。建议：请检查网络连接。"

    except Exception as e:
        return f"错误：{str(e)}。建议：请稍后重试或联系技术支持。"

# ===== 3. 测试Tool =====
async def test_news_tool():
    """测试新闻Tool"""
    print("=== 测试新闻Tool ===\n")

    # 测试1：搜索科技新闻
    print("测试1：搜索科技新闻")
    result = await search_news.ainvoke({"topic": "人工智能", "limit": 3})
    print(result)
    print()

    # 测试2：搜索体育新闻
    print("测试2：搜索体育新闻")
    result = await search_news.ainvoke({"topic": "NBA", "limit": 2, "language": "en"})
    print(result)
    print()

if __name__ == "__main__":
    import asyncio
    asyncio.run(test_news_tool())
```

---

## 示例3：股票行情Tool

### 完整代码

```python
"""
股票行情Tool示例
演示：调用Alpha Vantage API获取股票实时行情
"""

import os
import httpx
from langchain.tools import tool
from pydantic import BaseModel, Field
from dotenv import load_dotenv

load_dotenv()

http_client = httpx.AsyncClient(
    limits=httpx.Limits(max_connections=10),
    timeout=httpx.Timeout(10.0)
)

# ===== 1. 定义参数Schema =====
class StockInput(BaseModel):
    """股票查询参数"""
    symbol: str = Field(
        description="股票代码，如'AAPL'（苹果）、'MSFT'（微软）、'GOOGL'（谷歌）",
        min_length=1,
        max_length=10,
        pattern=r'^[A-Z]+$'
    )

# ===== 2. 定义Tool =====
@tool(args_schema=StockInput)
async def get_stock_price(symbol: str) -> str:
    """获取股票实时行情

    调用Alpha Vantage API获取股票的实时价格和基本信息。

    适用场景：
    - 用户询问"苹果股票现在多少钱？"
    - 用户询问"AAPL的股价"
    - 用户询问"微软股票行情"

    Args:
        symbol: 股票代码（大写字母），如AAPL、MSFT、GOOGL

    Returns:
        股票行情信息，包括当前价格、涨跌幅、成交量等

    注意事项：
    - 需要配置STOCK_API_KEY环境变量
    - 免费版API有请求限制（每分钟5次）
    - 数据可能有15-20分钟延迟
    """
    api_key = os.getenv("STOCK_API_KEY")
    if not api_key:
        return "错误：未配置STOCK_API_KEY环境变量。请在.env文件中配置API密钥。"

    try:
        # 调用Alpha Vantage API
        response = await http_client.get(
            "https://www.alphavantage.co/query",
            params={
                "function": "GLOBAL_QUOTE",
                "symbol": symbol,
                "apikey": api_key
            }
        )

        if response.status_code != 200:
            return f"错误：API请求失败（状态码{response.status_code}）。请稍后重试。"

        data = response.json()

        # 检查是否有错误信息
        if "Error Message" in data:
            return f"错误：股票代码'{symbol}'无效。请检查股票代码是否正确。"

        if "Note" in data:
            return "错误：API请求次数超限。建议：请稍后重试（免费版限制每分钟5次）。"

        # 提取股票信息
        quote = data.get("Global Quote", {})

        if not quote:
            return f"错误：未找到股票'{symbol}'的数据。请检查股票代码是否正确。"

        # 解析数据
        price = quote.get("05. price", "N/A")
        change = quote.get("09. change", "N/A")
        change_percent = quote.get("10. change percent", "N/A")
        volume = quote.get("06. volume", "N/A")
        latest_trading_day = quote.get("07. latest trading day", "N/A")

        # 格式化返回结果
        return f"""{symbol}股票行情：
当前价格：${price}
涨跌额：${change}
涨跌幅：{change_percent}
成交量：{volume}
最新交易日：{latest_trading_day}

注意：数据可能有15-20分钟延迟
"""

    except httpx.TimeoutException:
        return "错误：请求超时。建议：请检查网络连接或稍后重试。"

    except httpx.NetworkError:
        return "错误：网络连接失败。建议：请检查网络连接。"

    except Exception as e:
        return f"错误：{str(e)}。建议：请稍后重试或联系技术支持。"

# ===== 3. 测试Tool =====
async def test_stock_tool():
    """测试股票Tool"""
    print("=== 测试股票Tool ===\n")

    # 测试1：查询苹果股票
    print("测试1：查询苹果股票")
    result = await get_stock_price.ainvoke({"symbol": "AAPL"})
    print(result)
    print()

    # 测试2：查询微软股票
    print("测试2：查询微软股票")
    result = await get_stock_price.ainvoke({"symbol": "MSFT"})
    print(result)
    print()

if __name__ == "__main__":
    import asyncio
    asyncio.run(test_stock_tool())
```

---

## 最佳实践总结

### 1. 连接池复用

```python
# ✅ 推荐：模块级别创建客户端
http_client = httpx.AsyncClient(
    limits=httpx.Limits(max_connections=10),
    timeout=httpx.Timeout(10.0)
)

@tool
async def fetch_data(url: str) -> str:
    response = await http_client.get(url)  # 复用连接
    return response.text
```

### 2. 完整的错误处理

```python
@tool
async def api_call(url: str) -> str:
    try:
        response = await http_client.get(url)
        response.raise_for_status()
        return response.text

    except httpx.TimeoutException:
        return "错误：请求超时。建议：请稍后重试。"

    except httpx.HTTPStatusError as e:
        return f"错误：HTTP {e.response.status_code}。建议：检查URL。"

    except httpx.NetworkError:
        return "错误：网络连接失败。建议：检查网络。"

    except Exception as e:
        return f"错误：{str(e)}。建议：联系技术支持。"
```

### 3. 参数验证

```python
class APIInput(BaseModel):
    url: str = Field(
        description="API URL",
        pattern=r'^https?://.+'  # 验证URL格式
    )
    timeout: int = Field(
        default=10,
        ge=1,
        le=60,
        description="超时时间（秒）"
    )
```

### 4. 友好的错误信息

```python
# ❌ 不友好
return "Error: 404"

# ✅ 友好
return "错误：未找到资源。建议：检查URL是否正确。"
```

### 5. 资源清理

```python
# 应用关闭时清理
async def cleanup():
    await http_client.aclose()
```

---

## 常见问题

### 1. API密钥安全

**问题：** 如何安全地管理API密钥？

**解决方案：**
```python
# ✅ 使用环境变量
api_key = os.getenv("API_KEY")

# ❌ 不要硬编码
api_key = "sk-1234567890"  # 危险！
```

### 2. 请求限流

**问题：** API有请求频率限制怎么办？

**解决方案：**
```python
import asyncio
from datetime import datetime, timedelta

class RateLimiter:
    def __init__(self, max_requests: int, time_window: int):
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = []

    async def acquire(self):
        now = datetime.now()
        # 清理过期的请求记录
        self.requests = [t for t in self.requests if now - t < timedelta(seconds=self.time_window)]

        if len(self.requests) >= self.max_requests:
            # 等待到最早的请求过期
            wait_time = (self.requests[0] + timedelta(seconds=self.time_window) - now).total_seconds()
            await asyncio.sleep(wait_time)

        self.requests.append(now)

# 使用限流器
rate_limiter = RateLimiter(max_requests=5, time_window=60)  # 每分钟5次

@tool
async def api_call_with_rate_limit(url: str) -> str:
    await rate_limiter.acquire()
    response = await http_client.get(url)
    return response.text
```

### 3. 超时重试

**问题：** API偶尔超时，如何自动重试？

**解决方案：**
```python
async def retry_async(func, max_retries=3, delay=1.0):
    for attempt in range(max_retries):
        try:
            return await func()
        except httpx.TimeoutException:
            if attempt == max_retries - 1:
                raise
            await asyncio.sleep(delay * (attempt + 1))

@tool
async def api_call_with_retry(url: str) -> str:
    async def fetch():
        response = await http_client.get(url)
        return response.text

    try:
        return await retry_async(fetch, max_retries=3)
    except httpx.TimeoutException:
        return "错误：请求超时（已重试3次）。建议：请稍后重试。"
```

---

## 总结

### 核心要点

1. **连接池复用**：模块级别创建HTTP客户端，性能提升5倍
2. **完整错误处理**：捕获所有可能的异常，返回友好的错误信息
3. **参数验证**：使用Pydantic Schema验证参数
4. **超时控制**：设置合理的超时时间，避免长时间阻塞
5. **资源清理**：应用关闭时清理HTTP客户端

### 快速参考

```python
# 1. 创建HTTP客户端
http_client = httpx.AsyncClient(
    limits=httpx.Limits(max_connections=10),
    timeout=httpx.Timeout(10.0)
)

# 2. 定义Tool
@tool
async def api_call(url: str) -> str:
    try:
        response = await http_client.get(url)
        response.raise_for_status()
        return response.text
    except Exception as e:
        return f"错误：{str(e)}"

# 3. 清理资源
async def cleanup():
    await http_client.aclose()
```

---

**记住：** API调用Tool的关键是连接池复用和完整的错误处理！
