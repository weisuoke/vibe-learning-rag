# 实战代码：优先级调度系统

## 概述

**本文实现完整的优先级调度系统,包括防饥饿机制、加权公平队列、动态优先级调整等生产级特性。**

---

## 实现1:基础优先级调度器

```python
import heapq
import asyncio
from dataclasses import dataclass, field
from typing import Any, Callable, Optional
from datetime import datetime

@dataclass(order=True)
class PriorityTask:
    priority: int
    timestamp: float = field(compare=True)
    task_id: str = field(compare=False)
    func: Callable = field(compare=False)
    args: tuple = field(compare=False)
    kwargs: dict = field(compare=False)

class BasicPriorityScheduler:
    """基础优先级调度器"""

    def __init__(self):
        self.heap = []
        self.counter = 0

    async def add_task(self, func: Callable, priority: int, *args, **kwargs):
        """添加任务"""
        task = PriorityTask(
            priority=priority,
            timestamp=asyncio.get_event_loop().time(),
            task_id=f"task_{self.counter}",
            func=func,
            args=args,
            kwargs=kwargs
        )
        heapq.heappush(self.heap, task)
        self.counter += 1

    async def get_task(self) -> Optional[PriorityTask]:
        """获取任务"""
        if not self.heap:
            return None
        return heapq.heappop(self.heap)

    async def process(self):
        """处理任务"""
        while self.heap:
            task = await self.get_task()
            if task:
                print(f"执行 {task.task_id} (优先级{task.priority})")
                if asyncio.iscoroutinefunction(task.func):
                    await task.func(*task.args, **task.kwargs)
                else:
                    task.func(*task.args, **task.kwargs)

# 测试
async def test_task(name: str):
    await asyncio.sleep(0.1)
    print(f"完成: {name}")

async def main():
    scheduler = BasicPriorityScheduler()

    await scheduler.add_task(test_task, priority=5, name="低优先级")
    await scheduler.add_task(test_task, priority=1, name="高优先级")
    await scheduler.add_task(test_task, priority=3, name="中优先级")

    await scheduler.process()

asyncio.run(main())
```

---

## 实现2:防饥饿优先级调度器

### 优先级老化机制

```python
import time
from typing import Dict

@dataclass(order=True)
class AgingTask:
    adjusted_priority: float
    original_priority: int = field(compare=False)
    timestamp: float = field(compare=False)
    task_id: str = field(compare=False)
    func: Callable = field(compare=False)
    args: tuple = field(compare=False)
    kwargs: dict = field(compare=False)

class AgingPriorityScheduler:
    """防饥饿优先级调度器(老化机制)"""

    def __init__(self, aging_rate: float = 0.1):
        """
        Args:
            aging_rate: 老化速率(每秒降低的优先级)
        """
        self.heap = []
        self.counter = 0
        self.aging_rate = aging_rate

    async def add_task(self, func: Callable, priority: int, *args, **kwargs):
        """添加任务"""
        timestamp = time.time()
        task = AgingTask(
            adjusted_priority=priority,
            original_priority=priority,
            timestamp=timestamp,
            task_id=f"task_{self.counter}",
            func=func,
            args=args,
            kwargs=kwargs
        )
        heapq.heappush(self.heap, task)
        self.counter += 1

    async def get_task(self) -> Optional[AgingTask]:
        """获取任务(考虑老化)"""
        if not self.heap:
            return None

        # 更新所有任务的优先级
        self._update_priorities()

        return heapq.heappop(self.heap)

    def _update_priorities(self):
        """更新优先级"""
        now = time.time()
        updated_heap = []

        for task in self.heap:
            wait_time = now - task.timestamp
            # 优先级随等待时间降低
            adjusted = task.original_priority - (wait_time * self.aging_rate)

            updated_task = AgingTask(
                adjusted_priority=adjusted,
                original_priority=task.original_priority,
                timestamp=task.timestamp,
                task_id=task.task_id,
                func=task.func,
                args=task.args,
                kwargs=task.kwargs
            )
            updated_heap.append(updated_task)

        heapq.heapify(updated_heap)
        self.heap = updated_heap

    async def process(self):
        """处理任务"""
        while self.heap:
            task = await self.get_task()
            if task:
                print(f"执行 {task.task_id} (原始优先级{task.original_priority}, 调整后{task.adjusted_priority:.2f})")
                if asyncio.iscoroutinefunction(task.func):
                    await task.func(*task.args, **task.kwargs)
                else:
                    task.func(*task.args, **task.kwargs)

# 测试
async def main():
    scheduler = AgingPriorityScheduler(aging_rate=1.0)

    # 添加低优先级任务
    await scheduler.add_task(test_task, priority=10, name="低优先级")

    # 等待1秒
    await asyncio.sleep(1)

    # 添加高优先级任务
    for i in range(3):
        await scheduler.add_task(test_task, priority=1, name=f"高优先级{i}")

    # 低优先级任务因为等待时间长,优先级提升
    await scheduler.process()

asyncio.run(main())
```

### 最大等待时间限制

```python
@dataclass(order=True)
class DeadlineTask:
    priority: int
    deadline: float = field(compare=True)
    task_id: str = field(compare=False)
    func: Callable = field(compare=False)
    args: tuple = field(compare=False)
    kwargs: dict = field(compare=False)

class DeadlineScheduler:
    """最大等待时间调度器"""

    def __init__(self, max_wait_seconds: float = 60):
        self.heap = []
        self.counter = 0
        self.max_wait = max_wait_seconds

    async def add_task(self, func: Callable, priority: int, *args, **kwargs):
        """添加任务"""
        deadline = time.time() + self.max_wait
        task = DeadlineTask(
            priority=priority,
            deadline=deadline,
            task_id=f"task_{self.counter}",
            func=func,
            args=args,
            kwargs=kwargs
        )
        heapq.heappush(self.heap, task)
        self.counter += 1

    async def get_task(self) -> Optional[DeadlineTask]:
        """获取任务"""
        if not self.heap:
            return None

        now = time.time()

        # 检查是否有任务超过最大等待时间
        for i, task in enumerate(self.heap):
            if now >= task.deadline:
                # 强制执行超时任务
                self.heap.pop(i)
                heapq.heapify(self.heap)
                return task

        # 正常按优先级执行
        return heapq.heappop(self.heap)

    async def process(self):
        """处理任务"""
        while self.heap:
            task = await self.get_task()
            if task:
                wait_time = time.time() - (task.deadline - self.max_wait)
                print(f"执行 {task.task_id} (等待{wait_time:.1f}秒)")
                if asyncio.iscoroutinefunction(task.func):
                    await task.func(*task.args, **task.kwargs)
                else:
                    task.func(*task.args, **task.kwargs)

# 测试
async def main():
    scheduler = DeadlineScheduler(max_wait_seconds=2)

    # 添加低优先级任务
    await scheduler.add_task(test_task, priority=10, name="低优先级")

    # 等待3秒(超过最大等待时间)
    await asyncio.sleep(3)

    # 添加高优先级任务
    await scheduler.add_task(test_task, priority=1, name="高优先级")

    # 低优先级任务因为超时被强制执行
    await scheduler.process()

asyncio.run(main())
```

---

## 实现3:加权公平队列(WFQ)

```python
from typing import Dict, List

@dataclass
class WeightedTask:
    task_id: str
    weight: int
    executed_time: float
    func: Callable
    args: tuple
    kwargs: dict

class WeightedFairQueue:
    """加权公平队列"""

    def __init__(self):
        self.tasks: Dict[str, WeightedTask] = {}
        self.counter = 0

    async def add_task(self, func: Callable, weight: int = 1, *args, **kwargs):
        """添加任务"""
        task_id = f"task_{self.counter}"
        task = WeightedTask(
            task_id=task_id,
            weight=weight,
            executed_time=0,
            func=func,
            args=args,
            kwargs=kwargs
        )
        self.tasks[task_id] = task
        self.counter += 1

    async def get_task(self) -> Optional[WeightedTask]:
        """获取任务(按权重/执行时间)"""
        if not self.tasks:
            return None

        # 选择 权重/执行时间 最大的任务
        task_id = max(
            self.tasks.keys(),
            key=lambda tid: self.tasks[tid].weight / (self.tasks[tid].executed_time + 1)
        )

        return self.tasks[task_id]

    async def process(self, total_time: float = 10):
        """处理任务"""
        start_time = time.time()

        while time.time() - start_time < total_time and self.tasks:
            task = await self.get_task()
            if not task:
                break

            print(f"执行 {task.task_id} (权重{task.weight}, 已执行{task.executed_time:.1f}秒)")

            # 执行任务
            exec_start = time.time()
            if asyncio.iscoroutinefunction(task.func):
                await task.func(*task.args, **task.kwargs)
            else:
                task.func(*task.args, **task.kwargs)
            exec_time = time.time() - exec_start

            # 更新执行时间
            task.executed_time += exec_time

            # 如果任务完成,移除
            if task.executed_time > 1.0:  # 假设任务完成条件
                del self.tasks[task.task_id]

# 测试
async def main():
    wfq = WeightedFairQueue()

    # 添加不同权重的任务
    await wfq.add_task(test_task, weight=10, name="VIP任务")
    await wfq.add_task(test_task, weight=1, name="普通任务")

    # VIP任务获得10倍的执行机会
    await wfq.process(total_time=5)

asyncio.run(main())
```

---

## 实现4:多租户公平调度

```python
from collections import defaultdict

class MultiTenantScheduler:
    """多租户调度器"""

    def __init__(self):
        self.tenant_queues: Dict[str, List] = defaultdict(list)
        self.tenant_usage: Dict[str, int] = defaultdict(int)

    async def add_task(self, tenant_id: str, func: Callable, priority: int, *args, **kwargs):
        """添加任务"""
        task = PriorityTask(
            priority=priority,
            timestamp=time.time(),
            task_id=f"{tenant_id}_task_{len(self.tenant_queues[tenant_id])}",
            func=func,
            args=args,
            kwargs=kwargs
        )
        heapq.heappush(self.tenant_queues[tenant_id], task)

    async def get_task(self) -> Optional[tuple]:
        """获取任务(公平调度)"""
        if not self.tenant_queues:
            return None

        # 选择使用量最少的租户
        tenant_id = min(
            self.tenant_queues.keys(),
            key=lambda t: self.tenant_usage[t]
        )

        queue = self.tenant_queues[tenant_id]
        if not queue:
            del self.tenant_queues[tenant_id]
            return await self.get_task()

        task = heapq.heappop(queue)
        self.tenant_usage[tenant_id] += 1

        return tenant_id, task

    async def process(self):
        """处理任务"""
        while self.tenant_queues:
            result = await self.get_task()
            if not result:
                break

            tenant_id, task = result
            print(f"[{tenant_id}] 执行 {task.task_id} (使用量{self.tenant_usage[tenant_id]})")

            if asyncio.iscoroutinefunction(task.func):
                await task.func(*task.args, **task.kwargs)
            else:
                task.func(*task.args, **task.kwargs)

# 测试
async def main():
    scheduler = MultiTenantScheduler()

    # 租户A添加10个任务
    for i in range(10):
        await scheduler.add_task("tenant_a", test_task, priority=1, name=f"A{i}")

    # 租户B添加2个任务
    for i in range(2):
        await scheduler.add_task("tenant_b", test_task, priority=1, name=f"B{i}")

    # 公平调度:租户B的任务会优先执行
    await scheduler.process()

asyncio.run(main())
```

---

## 实现5:动态优先级调整

```python
class DynamicPriorityScheduler:
    """动态优先级调度器"""

    def __init__(self):
        self.tasks: Dict[str, AgingTask] = {}
        self.counter = 0

    async def add_task(self, func: Callable, priority: int, *args, **kwargs) -> str:
        """添加任务"""
        task_id = f"task_{self.counter}"
        task = AgingTask(
            adjusted_priority=priority,
            original_priority=priority,
            timestamp=time.time(),
            task_id=task_id,
            func=func,
            args=args,
            kwargs=kwargs
        )
        self.tasks[task_id] = task
        self.counter += 1
        return task_id

    async def update_priority(self, task_id: str, new_priority: int):
        """更新任务优先级"""
        if task_id in self.tasks:
            task = self.tasks[task_id]
            task.original_priority = new_priority
            task.adjusted_priority = new_priority

    async def get_task(self) -> Optional[AgingTask]:
        """获取任务"""
        if not self.tasks:
            return None

        # 选择优先级最高的任务
        task_id = min(
            self.tasks.keys(),
            key=lambda tid: self.tasks[tid].adjusted_priority
        )

        task = self.tasks.pop(task_id)
        return task

    async def process(self):
        """处理任务"""
        while self.tasks:
            task = await self.get_task()
            if task:
                print(f"执行 {task.task_id} (优先级{task.adjusted_priority})")
                if asyncio.iscoroutinefunction(task.func):
                    await task.func(*task.args, **task.kwargs)
                else:
                    task.func(*task.args, **task.kwargs)

# 测试
async def main():
    scheduler = DynamicPriorityScheduler()

    # 添加任务
    task1 = await scheduler.add_task(test_task, priority=5, name="任务1")
    task2 = await scheduler.add_task(test_task, priority=10, name="任务2")

    # 动态提升任务2的优先级
    await scheduler.update_priority(task2, new_priority=1)

    await scheduler.process()

asyncio.run(main())
```

---

## 实现6:完整生产级调度器

```python
from enum import Enum

class TaskStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class ProductionTask:
    task_id: str
    priority: int
    timestamp: float
    func: Callable
    args: tuple
    kwargs: dict
    max_retries: int = 3
    retry_count: int = 0
    status: TaskStatus = TaskStatus.PENDING

class ProductionScheduler:
    """生产级优先级调度器"""

    def __init__(self, num_workers: int = 3, aging_rate: float = 0.1, max_wait: float = 60):
        self.heap = []
        self.num_workers = num_workers
        self.aging_rate = aging_rate
        self.max_wait = max_wait
        self.counter = 0
        self.metrics = {
            'total': 0,
            'completed': 0,
            'failed': 0,
            'retried': 0
        }

    async def add_task(self, func: Callable, priority: int, *args, **kwargs):
        """添加任务"""
        task = ProductionTask(
            task_id=f"task_{self.counter}",
            priority=priority,
            timestamp=time.time(),
            func=func,
            args=args,
            kwargs=kwargs
        )
        heapq.heappush(self.heap, (priority, time.time(), task))
        self.counter += 1
        self.metrics['total'] += 1

    async def worker(self, worker_id: int):
        """工作协程"""
        while True:
            if not self.heap:
                await asyncio.sleep(0.1)
                continue

            # 获取任务
            _, _, task = heapq.heappop(self.heap)

            # 检查超时
            wait_time = time.time() - task.timestamp
            if wait_time > self.max_wait:
                print(f"Worker {worker_id}: 任务{task.task_id}超时")
                self.metrics['failed'] += 1
                continue

            # 执行任务
            task.status = TaskStatus.RUNNING
            print(f"Worker {worker_id}: 执行{task.task_id} (优先级{task.priority})")

            try:
                if asyncio.iscoroutinefunction(task.func):
                    await task.func(*task.args, **task.kwargs)
                else:
                    task.func(*task.args, **task.kwargs)

                task.status = TaskStatus.COMPLETED
                self.metrics['completed'] += 1

            except Exception as e:
                print(f"Worker {worker_id}: 任务{task.task_id}失败: {e}")

                # 重试
                if task.retry_count < task.max_retries:
                    task.retry_count += 1
                    task.status = TaskStatus.PENDING
                    heapq.heappush(self.heap, (task.priority, time.time(), task))
                    self.metrics['retried'] += 1
                else:
                    task.status = TaskStatus.FAILED
                    self.metrics['failed'] += 1

    async def start(self):
        """启动调度器"""
        workers = [
            asyncio.create_task(self.worker(i))
            for i in range(self.num_workers)
        ]
        await asyncio.gather(*workers)

    def get_metrics(self):
        """获取指标"""
        return self.metrics

# 测试
async def main():
    scheduler = ProductionScheduler(num_workers=3, max_wait=10)

    # 添加任务
    for i in range(20):
        priority = 1 if i % 5 == 0 else 5
        await scheduler.add_task(test_task, priority=priority, name=f"任务{i}")

    # 启动调度器
    await asyncio.wait_for(scheduler.start(), timeout=15)

    # 打印指标
    print(scheduler.get_metrics())

asyncio.run(main())
```

---

## 性能测试

```python
import time

async def benchmark_scheduler(scheduler_class, num_tasks: int = 1000):
    """基准测试"""
    scheduler = scheduler_class()

    # 添加任务
    start = time.time()
    for i in range(num_tasks):
        await scheduler.add_task(
            lambda: None,
            priority=i % 10
        )
    add_time = time.time() - start

    # 处理任务
    start = time.time()
    await scheduler.process()
    process_time = time.time() - start

    print(f"{scheduler_class.__name__}:")
    print(f"  添加{num_tasks}个任务: {add_time:.4f}秒")
    print(f"  处理{num_tasks}个任务: {process_time:.4f}秒")
    print(f"  总时间: {add_time + process_time:.4f}秒")

# 运行测试
async def main():
    await benchmark_scheduler(BasicPriorityScheduler, 1000)
    await benchmark_scheduler(AgingPriorityScheduler, 1000)
    await benchmark_scheduler(DeadlineScheduler, 1000)

asyncio.run(main())
```

---

## 总结

### 调度器对比

| 调度器 | 特点 | 适用场景 |
|--------|------|----------|
| 基础优先级 | 简单,快速 | 任务不会饥饿 |
| 优先级老化 | 防饥饿 | 长时间运行系统 |
| 最大等待时间 | 强制执行 | SLO要求严格 |
| 加权公平 | 按权重分配 | 多租户系统 |
| 动态优先级 | 灵活调整 | 需要实时调整 |

### 选择指南

1. **简单场景** → BasicPriorityScheduler
2. **防饥饿** → AgingPriorityScheduler
3. **SLO要求** → DeadlineScheduler
4. **多租户** → MultiTenantScheduler
5. **生产环境** → ProductionScheduler

### 关键洞察

- **防饥饿是必需的**:生产环境必须实现
- **监控指标很重要**:成功率、延迟、重试次数
- **重试机制**:任务失败要能重试
- **超时处理**:长时间等待的任务要强制执行

---

**下一步**:学习[07_实战代码_04_分布式任务队列](./07_实战代码_04_分布式任务队列.md),了解如何构建分布式调度系统。
