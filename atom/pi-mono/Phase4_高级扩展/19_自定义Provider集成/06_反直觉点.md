# 反直觉点

## 误区1：自定义Provider需要修改pi-mono源码

### ❌ 错误认知

"要添加新的LLM Provider，必须修改pi-mono的源码，在`packages/ai/src/providers/`目录下添加新的Provider实现文件。"

### 为什么错？

**技术原因：**
- pi-mono设计了Extension系统，专门用于扩展功能
- `pi.registerProvider()` API允许运行时注册Provider
- models.json配置文件支持声明式添加Provider
- Extension加载机制与核心代码完全解耦

**架构原因：**
- 如果需要修改源码，pi-mono就失去了可扩展性
- 用户无法添加私有Provider（企业内部服务）
- 每次添加Provider都需要重新编译和发布
- 违背了开闭原则（对扩展开放，对修改关闭）

### 为什么会有这个误区？

**心理原因：**
1. **传统软件思维**：习惯了修改源码添加功能
2. **缺乏插件化经验**：不熟悉Extension/Plugin系统
3. **文档不够明显**：可能没有看到Extension文档

**实际案例：**
```typescript
// 错误做法：修改源码
// packages/ai/src/providers/my-provider.ts
export function streamMyProvider(...) { ... }

// packages/ai/src/providers/register-builtins.ts
import { streamMyProvider } from './my-provider.js'
registerApiProvider({ api: 'my-provider', stream: streamMyProvider })
```

### ✅ 正确理解

**简单场景（80%）：**
```json
// ~/.pi/agent/models.json
{
  "providers": [
    {
      "id": "my-provider",
      "baseUrl": "https://api.example.com/v1",
      "apiKeyEnvVar": "MY_API_KEY"
    }
  ],
  "models": [...]
}
```

**复杂场景（20%）：**
```typescript
// ~/.pi/agent/extensions/my-provider/index.ts
export default function(pi) {
  pi.registerProvider('my-provider', {
    baseUrl: 'https://api.example.com/v1',
    api: 'openai-completions',
    models: [...],
    oauth: { ... }
  })
}
```

**核心洞察：**
- 配置优于代码（models.json）
- Extension优于修改源码
- 运行时注册优于编译时注册

---

## 误区2：OAuth认证很复杂，需要实现完整的OAuth服务器

### ❌ 错误认知

"要支持OAuth认证，需要自己搭建OAuth服务器，实现授权端点、Token端点、刷新端点等完整的OAuth 2.0协议。"

### 为什么错？

**技术原因：**
- pi-mono只需要**OAuth客户端**，不需要OAuth服务器
- 企业已有的OAuth服务器（如Okta、Auth0、企业SSO）可以直接使用
- 只需实现3个方法：`login()`, `refreshToken()`, `getApiKey()`
- pi-mono提供了`OAuthLoginCallbacks`简化交互

**实际工作量：**
- OAuth服务器：需要实现10+个端点，处理安全、存储、会话管理（数周工作量）
- OAuth客户端：只需实现3个方法，调用现有OAuth服务器（数小时工作量）

### 为什么会有这个误区？

**心理原因：**
1. **OAuth协议复杂**：OAuth 2.0规范很长，看起来很复杂
2. **混淆客户端和服务器**：不清楚pi-mono是客户端角色
3. **缺乏实践经验**：没有实际集成过OAuth

**实际对比：**
```typescript
// 误区：以为需要实现OAuth服务器
class OAuthServer {
  // 授权端点
  async authorize(req) { ... }
  // Token端点
  async token(req) { ... }
  // 刷新端点
  async refresh(req) { ... }
  // 用户管理
  async createUser(user) { ... }
  // 会话管理
  async createSession(userId) { ... }
  // 数据库
  database: Database
  // 安全
  encryption: Encryption
  // ... 数百行代码
}
```

### ✅ 正确理解

**实际需要：**
```typescript
// 只需实现OAuth客户端的3个方法
oauth: {
  name: 'Company AI (SSO)',

  // 1. 登录流程（调用现有OAuth服务器）
  async login(callbacks) {
    // 请求设备代码
    const deviceCode = await fetch('https://existing-oauth-server.com/device/code', ...)

    // 显示给用户
    callbacks.onDeviceCode({ userCode: deviceCode.user_code, ... })

    // 轮询Token
    const token = await pollForToken(deviceCode.device_code)

    return { access: token.access_token, refresh: token.refresh_token, expires: ... }
  },

  // 2. 刷新Token（调用现有OAuth服务器）
  async refreshToken(credentials) {
    const newToken = await fetch('https://existing-oauth-server.com/token', {
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: credentials.refresh
      })
    })
    return { access: newToken.access_token, ... }
  },

  // 3. 获取API Key（从凭证中提取）
  getApiKey(credentials) {
    return credentials.access
  }
}
```

**核心洞察：**
- pi-mono是OAuth**客户端**，不是服务器
- 使用企业现有的OAuth服务器（Okta、Auth0、企业SSO）
- 只需实现3个方法，调用现有API
- Device Code Flow是最简单的无头认证方式

---

## 误区3：所有Provider都需要实现自定义streamSimple

### ❌ 错误认知

"要添加自定义Provider，必须实现`streamSimple`函数，手动处理流式响应、解析事件、转换格式等复杂逻辑。"

### 为什么错？

**技术原因：**
- pi-mono内置了多种API类型的streamSimple实现
- 如果LLM API是OpenAI兼容的，直接使用`api: 'openai-completions'`
- 如果是Anthropic格式，使用`api: 'anthropic-messages'`
- 只有非标准API才需要自定义streamSimple

**统计数据：**
- 80%的自托管LLM提供OpenAI兼容API（Ollama、vLLM、LiteLLM等）
- 15%使用标准API格式（Anthropic、Google等）
- 只有5%需要自定义streamSimple

### 为什么会有这个误区？

**心理原因：**
1. **过度设计**：以为每个Provider都是独特的
2. **不了解OpenAI兼容性**：不知道大多数LLM都提供OpenAI兼容API
3. **文档理解偏差**：看到streamSimple选项就以为必须实现

**实际案例：**
```typescript
// 误区：以为Ollama需要自定义streamSimple
pi.registerProvider('ollama', {
  baseUrl: 'http://localhost:11434/v1',
  models: [...],
  streamSimple: async (model, context, options) => {
    // 手动实现流式处理
    // 手动解析SSE
    // 手动转换事件格式
    // ... 数百行代码
  }
})
```

### ✅ 正确理解

**大多数场景（95%）：**
```typescript
// Ollama提供OpenAI兼容API，直接使用
pi.registerProvider('ollama', {
  baseUrl: 'http://localhost:11434/v1',
  api: 'openai-completions',  // 使用内置实现
  models: [...]
})

// vLLM也是OpenAI兼容
pi.registerProvider('vllm', {
  baseUrl: 'http://your-vllm-server:8000/v1',
  api: 'openai-completions',
  models: [...]
})

// 甚至可以用models.json配置
{
  "providers": [
    { "id": "ollama", "baseUrl": "http://localhost:11434/v1" }
  ]
}
```

**极少数场景（5%）：**
```typescript
// 只有完全自定义的API格式才需要streamSimple
pi.registerProvider('custom-api', {
  baseUrl: 'https://api.example.com',
  models: [...],
  streamSimple: async (model, context, options) => {
    // 自定义实现
    // 因为API格式完全不兼容OpenAI/Anthropic/Google等
  }
})
```

**核心洞察：**
- 优先检查API是否OpenAI兼容
- 使用内置的API类型（`openai-completions`、`anthropic-messages`等）
- 只有非标准API才需要自定义streamSimple
- 不要重复造轮子

**判断流程：**
```
1. API文档说"OpenAI兼容"？
   → 是：使用 api: 'openai-completions'
   → 否：继续

2. API是Anthropic/Google/Bedrock格式？
   → 是：使用对应的api类型
   → 否：继续

3. API完全自定义格式？
   → 是：实现streamSimple
   → 否：检查是否有compat选项可以调整
```

---

## 总结

### 三个核心反直觉点

1. **扩展性设计**
   - ❌ 修改源码添加Provider
   - ✅ 使用Extension或models.json

2. **OAuth复杂度**
   - ❌ 需要实现OAuth服务器
   - ✅ 只需实现3个客户端方法

3. **API兼容性**
   - ❌ 每个Provider都需要自定义streamSimple
   - ✅ 95%的场景使用内置API类型

### 为什么会有这些误区？

- **传统软件思维**：习惯修改源码
- **协议复杂性**：OAuth看起来很复杂
- **过度设计**：以为每个Provider都是独特的
- **文档理解偏差**：没有充分理解Extension系统

### 正确的思维模式

- **配置优于代码**：能用配置解决的不写代码
- **客户端思维**：pi-mono是OAuth客户端，不是服务器
- **标准优先**：优先使用标准API类型
- **渐进式复杂度**：从简单开始，需要时再增加复杂度
