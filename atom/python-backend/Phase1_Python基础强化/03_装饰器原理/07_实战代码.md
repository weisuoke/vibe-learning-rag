# 实战代码

> 完整可运行的装饰器示例，涵盖 AI Agent 开发的常见场景

---

## 代码组织

实战代码按场景拆分为多个独立文件，每个文件包含完整的可运行示例：

### 场景1：基础装饰器实现
**文件：** `07_实战代码_场景1_基础装饰器.md`

包含：
- 日志装饰器（记录函数调用）
- 计时装饰器（性能监控）
- 计数装饰器（调用统计）
- 异常处理装饰器（统一错误处理）

### 场景2：FastAPI 路由装饰器原理
**文件：** `07_实战代码_场景2_FastAPI路由原理.md`

包含：
- 手写简化版 FastAPI 路由系统
- 理解路由注册机制
- 实现依赖注入
- 完整的 API 应用示例

### 场景3：权限与认证装饰器
**文件：** `07_实战代码_场景3_权限认证.md`

包含：
- JWT 认证装饰器
- 基于角色的权限检查
- API 限流装饰器
- 请求验证装饰器

### 场景4：缓存与性能优化
**文件：** `07_实战代码_场景4_缓存优化.md`

包含：
- 内存缓存装饰器
- 带过期时间的缓存
- LRU 缓存实现
- 异步缓存装饰器

### 场景5：AI Agent 专用装饰器
**文件：** `07_实战代码_场景5_AI_Agent应用.md`

包含：
- 流式响应装饰器
- 重试机制（处理 LLM API 失败）
- Token 计数装饰器
- 对话历史管理装饰器

---

## 运行环境

所有代码示例基于以下环境：

```bash
# Python 版本
Python 3.13+

# 核心依赖
pip install fastapi uvicorn pydantic python-dotenv

# 可选依赖（用于特定示例）
pip install redis python-jose passlib
```

---

## 快速开始

### 1. 基础装饰器示例

```python
from functools import wraps
import time

def timing(func):
    """计时装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        print(f"{func.__name__} 耗时: {elapsed:.4f}秒")
        return result
    return wrapper

@timing
def slow_function():
    time.sleep(1)
    return "Done"

result = slow_function()
# 输出：slow_function 耗时: 1.0012秒
```

### 2. FastAPI 路由示例

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/users")
def get_users():
    return [{"id": 1, "name": "Alice"}]

@app.post("/users", status_code=201)
def create_user(name: str):
    return {"id": 2, "name": name}

# 运行：uvicorn main:app --reload
```

### 3. 权限检查示例

```python
from functools import wraps

def require_permission(permission):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            user_permission = kwargs.get("user_permission", "guest")
            if user_permission != permission:
                raise PermissionError(f"需要 {permission} 权限")
            return func(*args, **kwargs)
        return wrapper
    return decorator

@require_permission("admin")
def delete_user(user_id, user_permission="guest"):
    return f"删除用户 {user_id}"

# 测试
try:
    delete_user(123, user_permission="user")  # 失败
except PermissionError as e:
    print(f"错误: {e}")

delete_user(123, user_permission="admin")  # 成功
```

### 4. 缓存装饰器示例

```python
from functools import wraps

def cache(func):
    cached = {}
    @wraps(func)
    def wrapper(*args):
        if args not in cached:
            print(f"计算: {args}")
            cached[args] = func(*args)
        else:
            print(f"缓存命中: {args}")
        return cached[args]
    return wrapper

@cache
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(5))  # 计算多次
print(fibonacci(5))  # 缓存命中
```

### 5. AI Agent 流式响应示例

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import asyncio

app = FastAPI()

def stream_decorator(func):
    """流式响应装饰器"""
    async def wrapper(*args, **kwargs):
        async def generate():
            async for chunk in func(*args, **kwargs):
                yield chunk
        return StreamingResponse(generate(), media_type="text/plain")
    return wrapper

@app.get("/stream")
@stream_decorator
async def stream_response():
    """模拟 AI 流式输出"""
    for i in range(10):
        await asyncio.sleep(0.1)
        yield f"Token {i}\n"
```

---

## 学习路径

建议按以下顺序学习各个场景：

```
场景1：基础装饰器
  ↓
场景2：FastAPI 路由原理
  ↓
场景3：权限与认证
  ↓
场景4：缓存与性能优化
  ↓
场景5：AI Agent 专用装饰器
```

---

## 代码规范

所有示例代码遵循以下规范：

1. **完整可运行**：可以直接复制运行，无需修改
2. **详细注释**：关键逻辑都有注释说明
3. **输出示例**：包含预期的运行输出
4. **错误处理**：展示常见错误和解决方案
5. **最佳实践**：使用 `@wraps`、类型注解等

---

## 实战项目

完成所有场景学习后，可以尝试以下实战项目：

### 项目1：简单的 API 服务
- 使用 FastAPI 创建 RESTful API
- 添加日志和计时装饰器
- 实现基础的权限检查

### 项目2：带缓存的 AI 问答 API
- 实现 AI 问答端点
- 添加缓存装饰器（避免重复调用 LLM）
- 添加限流装饰器（防止滥用）

### 项目3：完整的 AI Agent 后端
- 实现多个 AI Agent 端点
- 添加 JWT 认证
- 实现流式响应
- 添加性能监控和日志

---

## 调试技巧

### 1. 查看装饰器执行顺序

```python
def trace(name):
    def decorator(func):
        print(f"[定义时] {name} 装饰 {func.__name__}")
        def wrapper(*args, **kwargs):
            print(f"[调用前] {name}")
            result = func(*args, **kwargs)
            print(f"[调用后] {name}")
            return result
        return wrapper
    return decorator

@trace("A")
@trace("B")
def my_function():
    print("  [函数执行]")

my_function()
```

### 2. 检查装饰后的函数

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def my_function():
    """原函数文档"""
    pass

print(f"函数名: {my_function.__name__}")
print(f"文档: {my_function.__doc__}")
```

### 3. 访问原函数

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    wrapper.__wrapped__ = func  # 保存原函数引用
    return wrapper

@my_decorator
def my_function():
    return "原函数"

print(my_function())  # 调用装饰后的函数
print(my_function.__wrapped__())  # 调用原函数
```

---

## 常见问题

### Q1: 装饰器中的变量会被共享吗？

**A:** 是的，闭包变量会被所有调用共享。

```python
def counter(func):
    count = 0  # 共享变量
    def wrapper(*args, **kwargs):
        nonlocal count
        count += 1
        print(f"调用次数: {count}")
        return func(*args, **kwargs)
    return wrapper

@counter
def my_function():
    pass

my_function()  # 调用次数: 1
my_function()  # 调用次数: 2
```

### Q2: 如何为装饰器添加配置？

**A:** 使用装饰器工厂（带参数的装饰器）。

```python
def configurable_decorator(param):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"参数: {param}")
            return func(*args, **kwargs)
        return wrapper
    return decorator

@configurable_decorator(param="value")
def my_function():
    pass
```

### Q3: 装饰器可以修改函数参数吗？

**A:** 可以，在 wrapper 中修改参数。

```python
def modify_args(func):
    def wrapper(*args, **kwargs):
        # 修改参数
        new_args = [arg * 2 for arg in args]
        return func(*new_args, **kwargs)
    return wrapper

@modify_args
def add(a, b):
    return a + b

print(add(1, 2))  # 6 (实际调用 add(2, 4))
```

---

## 性能考虑

### 装饰器的性能开销

```python
import time

def no_decorator(func):
    return func

def simple_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@no_decorator
def func1():
    pass

@simple_decorator
def func2():
    pass

# 测试性能
iterations = 1000000

start = time.time()
for _ in range(iterations):
    func1()
print(f"无装饰器: {time.time() - start:.4f}秒")

start = time.time()
for _ in range(iterations):
    func2()
print(f"简单装饰器: {time.time() - start:.4f}秒")

# 输出：
# 无装饰器: 0.0523秒
# 简单装饰器: 0.1247秒
# 装饰器有约 2-3 倍的性能开销
```

**优化建议：**
1. 避免在装饰器中做复杂计算
2. 缓存装饰器的结果
3. 对性能敏感的代码，考虑不使用装饰器

---

## 下一步

完成实战代码学习后，继续学习：

1. **面试必问** - 掌握装饰器的高频面试题
2. **化骨绵掌** - 深入理解装饰器的各个方面
3. **实际项目** - 在 FastAPI 项目中应用装饰器

---

**记住：** 实践是最好的学习方式，动手写代码比看文档更重要！
