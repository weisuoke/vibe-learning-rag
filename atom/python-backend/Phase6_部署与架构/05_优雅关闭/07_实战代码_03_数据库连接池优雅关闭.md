# 实战代码：数据库连接池优雅关闭

> 完整可运行的 SQLAlchemy 连接池优雅关闭示例

---

## 代码说明

本示例演示如何优雅关闭 SQLAlchemy 数据库连接池，包括：
- 等待活跃连接完成
- 检测连接泄漏
- 监控连接池状态
- 带超时的连接池关闭

**运行环境：**
- Python 3.13+
- SQLAlchemy (async)
- PostgreSQL 或 SQLite

---

## 完整代码

```python
"""
数据库连接池优雅关闭实现
演示：SQLAlchemy 连接池的正确关闭方式

运行方式：
    python 07_实战代码_03_数据库连接池优雅关闭.py

测试方式：
    1. 启动应用
    2. 访问 http://localhost:8000/db-test 创建连接
    3. 按 Ctrl+C 测试优雅关闭
"""

import signal
import asyncio
import sys
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from sqlalchemy.ext.asyncio import (
    create_async_engine,
    AsyncEngine,
    AsyncSession,
)
from sqlalchemy.orm import sessionmaker
from sqlalchemy import text
import uvicorn

# ===== 1. 全局状态 =====
shutdown_event = asyncio.Event()
accepting_requests = True
active_requests = 0

# ===== 2. 连接池管理器 =====
class DatabasePoolManager:
    """数据库连接池管理器"""

    def __init__(self):
        self.engine: AsyncEngine = None
        self.async_session: sessionmaker = None

    async def initialize(self, database_url: str):
        """初始化连接池"""
        print("\n" + "="*60)
        print("初始化数据库连接池")
        print("="*60)

        # 创建引擎
        self.engine = create_async_engine(
            database_url,
            pool_size=10,           # 连接池大小
            max_overflow=20,        # 最大溢出连接数
            pool_timeout=30,        # 获取连接超时时间
            pool_recycle=3600,      # 连接回收时间（秒）
            pool_pre_ping=True,     # 使用前检查连接是否有效
            echo_pool=True,         # 打印连接池日志
        )

        # 创建会话工厂
        self.async_session = sessionmaker(
            self.engine,
            class_=AsyncSession,
            expire_on_commit=False,
        )

        # 测试连接
        try:
            async with self.engine.connect() as conn:
                await conn.execute(text("SELECT 1"))
            print("✓ 数据库连接测试成功")
        except Exception as e:
            print(f"✗ 数据库连接测试失败: {e}")
            raise

        # 显示连接池配置
        print(f"\n连接池配置:")
        print(f"  pool_size: {self.engine.pool.size()}")
        print(f"  max_overflow: 20")
        print(f"  总连接数: 30")

        print("\n" + "="*60 + "\n")

    def get_pool_status(self) -> dict:
        """获取连接池状态"""
        if not self.engine:
            return {}

        pool = self.engine.pool

        return {
            "pool_size": pool.size(),
            "checkedout": pool.checkedout(),
            "overflow": pool.overflow(),
            "idle": pool.size() - pool.checkedout(),
        }

    def check_connection_leak(self, threshold: int = 5) -> bool:
        """检查连接泄漏"""
        if not self.engine:
            return False

        pool = self.engine.pool
        checkedout = pool.checkedout()

        if checkedout > threshold:
            print(f"\n⚠️  警告：检测到连接泄漏")
            print(f"  已签出连接: {checkedout}")
            print(f"  阈值: {threshold}")
            return True

        return False

    async def cleanup(self, timeout: int = 10):
        """优雅关闭连接池"""
        if not self.engine:
            return

        print("\n" + "="*60)
        print("关闭数据库连接池")
        print("="*60)

        # 1. 获取连接池状态
        status = self.get_pool_status()
        print(f"\n关闭前连接池状态:")
        print(f"  连接池大小: {status['pool_size']}")
        print(f"  已签出连接: {status['checkedout']}")
        print(f"  溢出连接: {status['overflow']}")
        print(f"  空闲连接: {status['idle']}")

        # 2. 检查连接泄漏
        if status['checkedout'] > 0:
            print(f"\n⚠️  警告：有 {status['checkedout']} 个连接未归还")
            print("  可能存在连接泄漏")

        # 3. 关闭连接池
        print(f"\n关闭连接池（超时 {timeout}秒）...")

        try:
            await asyncio.wait_for(
                self.engine.dispose(),
                timeout=timeout
            )
            print("✓ 连接池已关闭")

        except asyncio.TimeoutError:
            print(f"✗ 连接池关闭超时（{timeout}秒）")

        except Exception as e:
            print(f"✗ 连接池关闭失败: {e}")

        print("\n" + "="*60 + "\n")

# 创建连接池管理器
db_manager = DatabasePoolManager()

# ===== 3. 信号处理器 =====
def signal_handler(signum, frame):
    """信号处理器"""
    print(f"\n收到信号 {signum}")
    shutdown_event.set()

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

# ===== 4. lifespan 上下文管理器 =====
@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # 启动阶段
    await db_manager.initialize(
        # 使用 SQLite 进行演示
        "sqlite+aiosqlite:///./test.db"
    )

    # 启动关闭监听器
    asyncio.create_task(shutdown_monitor())

    yield

    # 关闭阶段（由 shutdown_monitor 触发）
    pass

app = FastAPI(title="数据库连接池优雅关闭示例", lifespan=lifespan)

# ===== 5. 请求排空中间件 =====
@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    """请求排空中间件"""
    global active_requests

    if not accepting_requests:
        return JSONResponse(
            status_code=503,
            content={"error": "Server is shutting down"}
        )

    active_requests += 1
    try:
        return await call_next(request)
    finally:
        active_requests -= 1

# ===== 6. 示例路由 =====
@app.get("/")
async def root():
    """根路由"""
    return {
        "message": "数据库连接池优雅关闭示例",
        "pool_status": db_manager.get_pool_status()
    }

@app.get("/db-test")
async def db_test():
    """测试数据库连接"""
    # ✅ 正确：使用上下文管理器
    async with db_manager.async_session() as session:
        result = await session.execute(text("SELECT 1 as test"))
        row = result.fetchone()

    return {
        "status": "success",
        "result": row[0] if row else None,
        "pool_status": db_manager.get_pool_status()
    }

@app.get("/db-test-leak")
async def db_test_leak():
    """
    测试连接泄漏（错误示例）

    ⚠️  警告：这是一个错误示例，用于演示连接泄漏
    """
    # ❌ 错误：不使用上下文管理器，连接不会归还
    session = db_manager.async_session()
    result = await session.execute(text("SELECT 1 as test"))
    row = result.fetchone()
    # 忘记关闭 session！

    return {
        "status": "success",
        "result": row[0] if row else None,
        "pool_status": db_manager.get_pool_status(),
        "warning": "这个端点会导致连接泄漏！"
    }

@app.get("/pool-status")
async def pool_status():
    """获取连接池状态"""
    status = db_manager.get_pool_status()
    has_leak = db_manager.check_connection_leak(threshold=5)

    return {
        "pool_status": status,
        "connection_leak": has_leak,
        "requests": {
            "accepting": accepting_requests,
            "active": active_requests,
        }
    }

# ===== 7. 优雅关闭逻辑 =====
async def wait_for_requests(timeout: int = 30):
    """等待所有请求完成"""
    global accepting_requests
    accepting_requests = False

    print(f"\n[请求排空] 停止接收新请求")
    print(f"[请求排空] 当前活跃请求数: {active_requests}")

    start_time = asyncio.get_event_loop().time()

    while active_requests > 0:
        elapsed = asyncio.get_event_loop().time() - start_time
        if elapsed > timeout:
            print(f"[请求排空] 超时（{timeout}秒）")
            break

        await asyncio.sleep(0.1)

    print(f"[请求排空] 完成")

async def graceful_shutdown():
    """优雅关闭"""
    print("\n" + "="*60)
    print("开始优雅关闭")
    print("="*60)

    # 1. 等待请求完成
    await wait_for_requests()

    # 2. 关闭数据库连接池
    await db_manager.cleanup(timeout=10)

    print("="*60)
    print("优雅关闭完成")
    print("="*60 + "\n")

    sys.exit(0)

async def shutdown_monitor():
    """监听关闭信号"""
    await shutdown_event.wait()
    await graceful_shutdown()

# ===== 8. 主函数 =====
def main():
    """主函数"""
    print("="*60)
    print("数据库连接池优雅关闭示例")
    print("="*60 + "\n")

    print("提示：")
    print("  - 访问 http://localhost:8000/ 查看连接池状态")
    print("  - 访问 http://localhost:8000/db-test 测试数据库连接")
    print("  - 访问 http://localhost:8000/db-test-leak 测试连接泄漏")
    print("  - 访问 http://localhost:8000/pool-status 查看详细状态")
    print("  - 按 Ctrl+C 测试优雅关闭")
    print()

    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info"
    )

if __name__ == "__main__":
    main()
```

---

## 运行示例

### 1. 启动应用

```bash
python 07_实战代码_03_数据库连接池优雅关闭.py
```

**预期输出：**
```
============================================================
数据库连接池优雅关闭示例
============================================================

============================================================
初始化数据库连接池
============================================================
✓ 数据库连接测试成功

连接池配置:
  pool_size: 10
  max_overflow: 20
  总连接数: 30

============================================================
```

### 2. 测试数据库连接

```bash
curl http://localhost:8000/db-test
```

**预期输出：**
```json
{
  "status": "success",
  "result": 1,
  "pool_status": {
    "pool_size": 10,
    "checkedout": 0,
    "overflow": 0,
    "idle": 10
  }
}
```

### 3. 测试连接泄漏

```bash
# 多次调用泄漏端点
for i in {1..5}; do curl http://localhost:8000/db-test-leak; done
```

**预期输出：**
```json
{
  "status": "success",
  "result": 1,
  "pool_status": {
    "pool_size": 10,
    "checkedout": 5,
    "overflow": 0,
    "idle": 5
  },
  "warning": "这个端点会导致连接泄漏！"
}
```

### 4. 查看连接池状态

```bash
curl http://localhost:8000/pool-status
```

**预期输出：**
```json
{
  "pool_status": {
    "pool_size": 10,
    "checkedout": 5,
    "overflow": 0,
    "idle": 5
  },
  "connection_leak": true,
  "requests": {
    "accepting": true,
    "active": 0
  }
}
```

**服务器日志：**
```
⚠️  警告：检测到连接泄漏
  已签出连接: 5
  阈值: 5
```

### 5. 测试优雅关闭

按 `Ctrl+C`：

**预期输出：**
```
^C
收到信号 2

============================================================
开始优雅关闭
============================================================

[请求排空] 停止接收新请求
[请求排空] 当前活跃请求数: 0
[请求排空] 完成

============================================================
关闭数据库连接池
============================================================

关闭前连接池状态:
  连接池大小: 10
  已签出连接: 5
  溢出连接: 0
  空闲连接: 5

⚠️  警告：有 5 个连接未归还
  可能存在连接泄漏

关闭连接池（超时 10秒）...
✓ 连接池已关闭

============================================================

============================================================
优雅关闭完成
============================================================
```

---

## 代码解析

### 1. 连接池配置

```python
self.engine = create_async_engine(
    database_url,
    pool_size=10,           # 保持10个空闲连接
    max_overflow=20,        # 最多再创建20个临时连接
    pool_timeout=30,        # 获取连接超时时间
    pool_recycle=3600,      # 连接回收时间
    pool_pre_ping=True,     # 使用前检查连接
)
```

**关键参数：**
- `pool_size`: 连接池大小
- `max_overflow`: 最大溢出连接数
- `pool_pre_ping`: 使用前检查连接是否有效

### 2. 正确使用连接

```python
# ✅ 正确：使用上下文管理器
async with db_manager.async_session() as session:
    result = await session.execute(text("SELECT 1"))
# session 自动关闭，连接归还连接池
```

### 3. 连接泄漏检测

```python
def check_connection_leak(self, threshold: int = 5) -> bool:
    pool = self.engine.pool
    checkedout = pool.checkedout()

    if checkedout > threshold:
        print(f"⚠️  警告：检测到连接泄漏")
        return True

    return False
```

### 4. 优雅关闭连接池

```python
async def cleanup(self, timeout: int = 10):
    # 获取连接池状态
    status = self.get_pool_status()

    # 检查连接泄漏
    if status['checkedout'] > 0:
        print(f"⚠️  警告：有连接未归还")

    # 关闭连接池
    await asyncio.wait_for(
        self.engine.dispose(),
        timeout=timeout
    )
```

---

## 常见连接泄漏原因

### 原因1：忘记关闭 Session

```python
# ❌ 错误
async def bad_example():
    session = async_session()
    result = await session.execute("SELECT * FROM users")
    # 忘记关闭 session！
    return result.fetchall()

# ✅ 正确
async def good_example():
    async with async_session() as session:
        result = await session.execute("SELECT * FROM users")
        return result.fetchall()
```

### 原因2：异常时未关闭

```python
# ❌ 错误
async def bad_example():
    session = async_session()
    result = await session.execute("SELECT * FROM users")
    # 如果这里抛出异常，session 不会关闭
    process_result(result)
    await session.close()

# ✅ 正确
async def good_example():
    async with async_session() as session:
        result = await session.execute("SELECT * FROM users")
        process_result(result)
    # 即使异常，session 也会关闭
```

### 原因3：长时间持有连接

```python
# ❌ 错误
async def bad_example():
    async with async_session() as session:
        result = await session.execute("SELECT * FROM users")
        # 长时间处理，占用连接
        await asyncio.sleep(60)
        return result.fetchall()

# ✅ 正确
async def good_example():
    async with async_session() as session:
        result = await session.execute("SELECT * FROM users")
        data = result.fetchall()
    # 连接已归还，再处理数据
    await asyncio.sleep(60)
    return data
```

---

## 总结

本示例演示了：

1. **连接池初始化**：配置 SQLAlchemy 连接池
2. **连接池监控**：获取连接池状态
3. **连接泄漏检测**：检测未归还的连接
4. **优雅关闭**：等待连接归还后关闭连接池

**关键要点：**
- 使用上下文管理器管理 Session
- 监控连接池状态，检测泄漏
- 优雅关闭时检查未归还的连接
- 设置超时避免无限等待

**下一步：** 学习如何优雅关闭 Redis 连接。
