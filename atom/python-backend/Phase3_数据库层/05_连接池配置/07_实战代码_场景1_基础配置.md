# 实战代码 - 场景1：基础连接池配置

## 场景说明

演示如何在 FastAPI 项目中配置和使用 SQLAlchemy 连接池，包括：
- 创建带连接池的数据库引擎
- 配置连接池参数
- 使用依赖注入管理 Session
- 在路由中执行 CRUD 操作

---

## 完整代码示例

```python
"""
场景1：基础连接池配置
演示：FastAPI + SQLAlchemy 连接池的基础配置和使用
"""

import os
from typing import List, Optional
from datetime import datetime

from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy import create_engine, Column, Integer, String, DateTime
from sqlalchemy.orm import sessionmaker, Session, declarative_base
from pydantic import BaseModel

# ===== 1. 数据库配置 =====

# 从环境变量读取配置（生产环境最佳实践）
DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://user:password@localhost:5432/testdb"
)

# 创建引擎（带连接池）
engine = create_engine(
    DATABASE_URL,
    # 连接池配置
    pool_size=10,              # 常驻连接数：10个
    max_overflow=20,           # 临时连接数：最多20个
    pool_timeout=30,           # 获取连接超时：30秒
    pool_recycle=3600,         # 连接回收时间：1小时
    pool_pre_ping=True,        # 连接前检测：防止使用失效连接

    # 调试配置
    echo=False,                # 不打印SQL（生产环境）
)

# 创建 SessionLocal 类
SessionLocal = sessionmaker(
    autocommit=False,          # 不自动提交
    autoflush=False,           # 不自动刷新
    bind=engine,               # 绑定到引擎（连接池）
)

# 创建 Base 类（用于定义模型）
Base = declarative_base()

# ===== 2. 数据模型 =====

class User(Base):
    """用户模型"""
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

# 创建表（仅用于演示，生产环境应使用 Alembic）
Base.metadata.create_all(bind=engine)

# ===== 3. Pydantic 模型（API 数据验证） =====

class UserCreate(BaseModel):
    """创建用户的请求体"""
    name: str
    email: str

class UserResponse(BaseModel):
    """用户响应"""
    id: int
    name: str
    email: str
    created_at: datetime

    class Config:
        from_attributes = True  # 允许从 ORM 模型创建

# ===== 4. 依赖注入函数 =====

def get_db():
    """
    依赖注入函数：为每个请求提供独立的数据库 Session

    工作流程：
    1. 从连接池获取连接（1-5ms）
    2. 创建 Session
    3. 执行数据库操作
    4. 归还连接到池中
    """
    db = SessionLocal()  # 从连接池获取连接
    try:
        yield db  # 返回 Session 给路由函数
    finally:
        db.close()  # 归还连接到池中

# ===== 5. FastAPI 应用 =====

app = FastAPI(title="连接池配置示例")

# ===== 6. API 路由 =====

@app.get("/")
async def root():
    """根路由"""
    return {"message": "连接池配置示例 API"}

@app.post("/users", response_model=UserResponse)
async def create_user(
    user_data: UserCreate,
    db: Session = Depends(get_db)  # 依赖注入
):
    """
    创建用户

    演示：
    - 使用依赖注入获取 Session
    - 从连接池自动获取连接
    - 执行数据库操作
    - 自动归还连接
    """
    # 检查邮箱是否已存在
    existing_user = db.query(User).filter(User.email == user_data.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="邮箱已存在")

    # 创建用户
    user = User(
        name=user_data.name,
        email=user_data.email,
    )
    db.add(user)
    db.commit()
    db.refresh(user)

    return user

@app.get("/users", response_model=List[UserResponse])
async def list_users(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    """
    获取用户列表

    演示：
    - 分页查询
    - 连接池自动管理连接
    """
    users = db.query(User).offset(skip).limit(limit).all()
    return users

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    db: Session = Depends(get_db)
):
    """
    获取单个用户

    演示：
    - 根据 ID 查询
    - 处理不存在的情况
    """
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="用户不存在")
    return user

@app.put("/users/{user_id}", response_model=UserResponse)
async def update_user(
    user_id: int,
    user_data: UserCreate,
    db: Session = Depends(get_db)
):
    """
    更新用户

    演示：
    - 更新操作
    - 事务管理（自动提交）
    """
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="用户不存在")

    # 更新字段
    user.name = user_data.name
    user.email = user_data.email

    db.commit()
    db.refresh(user)

    return user

@app.delete("/users/{user_id}")
async def delete_user(
    user_id: int,
    db: Session = Depends(get_db)
):
    """
    删除用户

    演示：
    - 删除操作
    - 返回删除结果
    """
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="用户不存在")

    db.delete(user)
    db.commit()

    return {"message": "用户已删除", "user_id": user_id}

# ===== 7. 健康检查端点 =====

@app.get("/health/db")
async def check_db_health():
    """
    数据库健康检查

    演示：
    - 检查连接池状态
    - 测试数据库连接
    """
    try:
        # 获取连接池状态
        pool = engine.pool
        pool_size = pool.size()
        checked_in = pool.checkedin()
        checked_out = pool.checkedout()
        overflow = pool.overflow()

        # 计算使用率
        max_connections = pool_size + engine.pool._max_overflow
        pool_usage = (checked_out + overflow) / max_connections

        # 测试数据库连接
        with engine.connect() as conn:
            conn.execute("SELECT 1")

        return {
            "status": "healthy",
            "pool": {
                "size": pool_size,
                "checked_in": checked_in,
                "checked_out": checked_out,
                "overflow": overflow,
                "usage": f"{pool_usage * 100:.1f}%",
            }
        }

    except Exception as e:
        raise HTTPException(
            status_code=503,
            detail=f"数据库连接失败: {str(e)}"
        )

# ===== 8. 应用启动和关闭事件 =====

@app.on_event("startup")
async def startup_event():
    """
    应用启动时执行

    演示：
    - 连接池预热
    - 打印配置信息
    """
    print("=" * 50)
    print("应用启动")
    print("=" * 50)
    print(f"数据库 URL: {DATABASE_URL}")
    print(f"连接池大小: {engine.pool.size()}")
    print(f"最大溢出: {engine.pool._max_overflow}")
    print("=" * 50)

    # 连接池预热（可选）
    with engine.connect() as conn:
        conn.execute("SELECT 1")
    print("连接池预热完成")

@app.on_event("shutdown")
async def shutdown_event():
    """
    应用关闭时执行

    演示：
    - 关闭连接池
    - 释放资源
    """
    print("=" * 50)
    print("应用关闭")
    print("=" * 50)
    engine.dispose()
    print("连接池已关闭")

# ===== 9. 运行应用 =====

if __name__ == "__main__":
    import uvicorn

    # 运行应用
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info",
    )
```

---

## 运行步骤

### 1. 安装依赖

```bash
# 创建虚拟环境
python -m venv .venv
source .venv/bin/activate  # Linux/Mac
# .venv\Scripts\activate  # Windows

# 安装依赖
pip install fastapi uvicorn sqlalchemy psycopg2-binary pydantic
```

### 2. 配置环境变量

```bash
# .env 文件
DATABASE_URL=postgresql://user:password@localhost:5432/testdb
```

### 3. 运行应用

```bash
python app.py
```

### 4. 测试 API

```bash
# 创建用户
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "email": "alice@example.com"}'

# 获取用户列表
curl http://localhost:8000/users

# 获取单个用户
curl http://localhost:8000/users/1

# 更新用户
curl -X PUT http://localhost:8000/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice Updated", "email": "alice@example.com"}'

# 删除用户
curl -X DELETE http://localhost:8000/users/1

# 健康检查
curl http://localhost:8000/health/db
```

---

## 预期输出

### 应用启动输出

```
==================================================
应用启动
==================================================
数据库 URL: postgresql://user:password@localhost:5432/testdb
连接池大小: 10
最大溢出: 20
==================================================
连接池预热完成
INFO:     Started server process [12345]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
```

### 创建用户响应

```json
{
  "id": 1,
  "name": "Alice",
  "email": "alice@example.com",
  "created_at": "2026-02-11T10:30:00.123456"
}
```

### 健康检查响应

```json
{
  "status": "healthy",
  "pool": {
    "size": 10,
    "checked_in": 8,
    "checked_out": 2,
    "overflow": 0,
    "usage": "6.7%"
  }
}
```

---

## 关键知识点

### 1. 连接池配置

```python
engine = create_engine(
    DATABASE_URL,
    pool_size=10,              # 常驻连接数
    max_overflow=20,           # 临时连接数
    pool_timeout=30,           # 获取连接超时
    pool_recycle=3600,         # 连接回收时间
    pool_pre_ping=True,        # 连接前检测
)
```

**配置说明：**
- `pool_size=10`：始终保持10个连接
- `max_overflow=20`：高峰时最多创建20个临时连接
- `pool_timeout=30`：30秒内无法获取连接，抛出异常
- `pool_recycle=3600`：连接使用超过1小时后回收
- `pool_pre_ping=True`：使用前检测连接是否有效

### 2. 依赖注入

```python
def get_db():
    db = SessionLocal()  # 从连接池获取连接
    try:
        yield db
    finally:
        db.close()  # 归还连接到池中
```

**工作流程：**
1. 请求到达 → 调用 `get_db()`
2. 创建 Session → 从连接池获取连接
3. 执行数据库操作
4. 请求结束 → 执行 `finally` 块
5. 关闭 Session → 归还连接到池中

### 3. 连接池生命周期

```python
# 应用启动
@app.on_event("startup")
async def startup_event():
    # 连接池预热
    with engine.connect() as conn:
        conn.execute("SELECT 1")

# 应用关闭
@app.on_event("shutdown")
async def shutdown_event():
    # 关闭连接池
    engine.dispose()
```

---

## 常见问题

### Q1: 如何查看连接池状态？

```python
pool = engine.pool
print(f"连接池大小: {pool.size()}")
print(f"空闲连接数: {pool.checkedin()}")
print(f"正在使用的连接数: {pool.checkedout()}")
print(f"溢出连接数: {pool.overflow()}")
```

### Q2: 如何处理连接池耗尽？

```python
# 方案1：增大连接池
pool_size=20, max_overflow=40

# 方案2：减少单个请求的连接占用时间
# - 优化查询（添加索引）
# - 只查询需要的字段
# - 使用缓存

# 方案3：使用异步 SQLAlchemy
from sqlalchemy.ext.asyncio import create_async_engine
```

### Q3: 如何在不同环境使用不同配置？

```python
import os

# 从环境变量读取配置
POOL_SIZE = int(os.getenv("POOL_SIZE", "10"))
MAX_OVERFLOW = int(os.getenv("MAX_OVERFLOW", "20"))

engine = create_engine(
    DATABASE_URL,
    pool_size=POOL_SIZE,
    max_overflow=MAX_OVERFLOW,
)
```

---

## 总结

这个示例展示了：
1. ✅ 如何配置 SQLAlchemy 连接池
2. ✅ 如何在 FastAPI 中使用依赖注入管理 Session
3. ✅ 如何实现完整的 CRUD 操作
4. ✅ 如何添加健康检查端点
5. ✅ 如何处理应用启动和关闭事件

**下一步：** 查看场景2（连接池监控）和场景3（高级配置）
