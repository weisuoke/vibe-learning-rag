# 核心概念1：管道操作符实现原理

> 深入理解 `__or__` 方法和 RunnableSequence 的创建机制

---

## 概述

本文档深入探讨管道操作符的底层实现，包括：
- Python `__or__` 魔法方法的工作原理
- RunnableSequence 的创建和组织
- 源码级别的实现细节
- 自定义 Runnable 的实现

---

## 1. Python 魔法方法基础

### 1.1 什么是魔法方法？

**魔法方法**（Magic Methods）是 Python 中以双下划线开头和结尾的特殊方法，用于实现运算符重载和特殊行为。

```python
class Number:
    def __init__(self, value):
        self.value = value

    # 重载 + 运算符
    def __add__(self, other):
        return Number(self.value + other.value)

    # 重载 | 运算符
    def __or__(self, other):
        return Number(self.value | other.value)

# 使用
a = Number(5)
b = Number(3)
c = a + b  # 调用 a.__add__(b)
d = a | b  # 调用 a.__or__(b)
```

### 1.2 `__or__` 方法详解

**`__or__` 方法实现 `|` 运算符的行为**

```python
# 当你写
result = a | b

# Python 实际执行
result = a.__or__(b)

# 如果 a 没有 __or__ 方法，Python 会尝试
result = b.__ror__(a)  # 反向操作
```

**关键点**：
- `a | b` 调用 `a.__or__(b)`
- 左操作数的 `__or__` 方法接收右操作数作为参数
- 返回值可以是任何类型

---

## 2. Runnable 中的 `__or__` 实现

### 2.1 源码位置

**文件**：`langchain-core/runnables/base.py`

**类**：`Runnable`

### 2.2 简化版实现

```python
from typing import Union
from langchain_core.runnables import Runnable, RunnableSequence

class Runnable:
    """Runnable 基类"""

    def __or__(
        self,
        other: Union[
            Runnable,
            Callable,
            dict,
        ],
    ) -> RunnableSequence:
        """
        实现管道操作符 |

        Args:
            other: 右侧的 Runnable 或可转换为 Runnable 的对象

        Returns:
            RunnableSequence: 组合后的序列
        """
        # 1. 将 other 转换为 Runnable（如果需要）
        other_runnable = self._coerce_to_runnable(other)

        # 2. 创建 RunnableSequence
        return RunnableSequence(first=self, last=other_runnable)

    def _coerce_to_runnable(self, other):
        """将各种类型转换为 Runnable"""
        if isinstance(other, Runnable):
            return other
        elif callable(other):
            from langchain_core.runnables import RunnableLambda
            return RunnableLambda(other)
        elif isinstance(other, dict):
            from langchain_core.runnables import RunnableParallel
            return RunnableParallel(other)
        else:
            raise TypeError(f"Cannot convert {type(other)} to Runnable")
```

### 2.3 实际源码（LangChain v0.3）

```python
# langchain-core/runnables/base.py (简化版)

def __or__(
    self,
    other: Union[
        Runnable[Any, Other],
        Callable[[Any], Other],
        Callable[[Iterator[Any]], Iterator[Other]],
        Mapping[str, Union[Runnable[Any, Other], Callable[[Any], Other]]],
    ],
) -> RunnableSerializable[Input, Other]:
    """Compose this Runnable with another object to create a RunnableSequence."""
    return RunnableSequence(self, coerce_to_runnable(other))
```

**关键函数**：`coerce_to_runnable()`

```python
def coerce_to_runnable(thing: RunnableLike) -> Runnable[Input, Output]:
    """
    将各种类型强制转换为 Runnable

    支持的类型：
    - Runnable: 直接返回
    - Callable: 包装为 RunnableLambda
    - dict: 包装为 RunnableParallel
    - Mapping: 包装为 RunnableParallel
    """
    if isinstance(thing, Runnable):
        return thing
    elif callable(thing):
        return RunnableLambda(thing)
    elif isinstance(thing, dict):
        return RunnableParallel(thing)
    else:
        raise TypeError(f"Expected Runnable, callable or dict, got {type(thing)}")
```

---

## 3. RunnableSequence 的创建

### 3.1 RunnableSequence 类结构

```python
from typing import List, Optional
from langchain_core.runnables import Runnable

class RunnableSequence(Runnable):
    """
    一个 Runnable 序列，按顺序执行

    Attributes:
        first: 第一个 Runnable（可选）
        middle: 中间的 Runnable 列表
        last: 最后一个 Runnable
    """

    first: Optional[Runnable] = None
    middle: List[Runnable] = []
    last: Runnable

    def __init__(
        self,
        *steps: Runnable,
        first: Optional[Runnable] = None,
        middle: Optional[List[Runnable]] = None,
        last: Optional[Runnable] = None,
    ):
        """
        创建 RunnableSequence

        可以通过两种方式创建：
        1. RunnableSequence(step1, step2, step3)
        2. RunnableSequence(first=step1, last=step3)
        """
        if steps:
            # 方式1：传入多个步骤
            self.first = steps[0] if len(steps) > 1 else None
            self.middle = list(steps[1:-1]) if len(steps) > 2 else []
            self.last = steps[-1]
        else:
            # 方式2：使用命名参数
            self.first = first
            self.middle = middle or []
            self.last = last

    @property
    def steps(self) -> List[Runnable]:
        """返回所有步骤的列表"""
        if self.first is None:
            return [self.last]
        return [self.first] + self.middle + [self.last]
```

### 3.2 创建过程示例

```python
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema.output_parser import StrOutputParser

# 定义三个 Runnable
prompt = ChatPromptTemplate.from_template("讲一个关于{topic}的笑话")
llm = ChatOpenAI(model="gpt-4o-mini")
parser = StrOutputParser()

# 第一次 | 操作
# prompt | llm
step1 = prompt.__or__(llm)
# 返回: RunnableSequence(first=prompt, last=llm)

# 第二次 | 操作
# (prompt | llm) | parser
step2 = step1.__or__(parser)
# 返回: RunnableSequence(first=prompt, middle=[llm], last=parser)

# 最终结果
chain = prompt | llm | parser
# 等价于: RunnableSequence(first=prompt, middle=[llm], last=parser)
```

### 3.3 序列扁平化

**问题**：如果组合两个 RunnableSequence 会怎样？

```python
# 两个序列
seq1 = a | b | c  # RunnableSequence([a, b, c])
seq2 = d | e | f  # RunnableSequence([d, e, f])

# 组合
combined = seq1 | seq2
```

**朴素实现**：
```python
# 嵌套的 RunnableSequence
RunnableSequence(
    first=RunnableSequence([a, b, c]),
    last=RunnableSequence([d, e, f])
)
```

**优化实现**（扁平化）：
```python
# 扁平化为单个 RunnableSequence
RunnableSequence([a, b, c, d, e, f])
```

**源码实现**：

```python
def __or__(self, other: Runnable) -> RunnableSequence:
    """组合时自动扁平化"""
    other_runnable = coerce_to_runnable(other)

    # 如果 other 也是 RunnableSequence，扁平化
    if isinstance(other_runnable, RunnableSequence):
        return RunnableSequence(
            first=self.first,
            middle=self.middle + [self.last] + [other_runnable.first] + other_runnable.middle,
            last=other_runnable.last
        )
    else:
        # 否则，添加到末尾
        return RunnableSequence(
            first=self.first,
            middle=self.middle + [self.last],
            last=other_runnable
        )
```

---

## 4. 执行机制

### 4.1 invoke() 方法实现

```python
class RunnableSequence(Runnable):
    def invoke(self, input, config=None):
        """
        顺序执行所有步骤

        Args:
            input: 初始输入
            config: 配置对象（可选）

        Returns:
            最后一个步骤的输出
        """
        # 1. 配置传递
        config = config or {}

        # 2. 执行第一个步骤（如果存在）
        if self.first is not None:
            input = self.first.invoke(input, config)

        # 3. 执行中间步骤
        for step in self.middle:
            input = step.invoke(input, config)

        # 4. 执行最后一个步骤
        return self.last.invoke(input, config)
```

### 4.2 stream() 方法实现

```python
class RunnableSequence(Runnable):
    def stream(self, input, config=None):
        """
        流式执行所有步骤

        只有最后一个步骤会流式输出
        """
        config = config or {}

        # 1. 执行前面的步骤（非流式）
        if self.first is not None:
            input = self.first.invoke(input, config)

        for step in self.middle:
            input = step.invoke(input, config)

        # 2. 最后一个步骤流式输出
        for chunk in self.last.stream(input, config):
            yield chunk
```

### 4.3 batch() 方法实现

```python
class RunnableSequence(Runnable):
    def batch(self, inputs, config=None):
        """
        批量执行

        Args:
            inputs: 输入列表
            config: 配置对象（可选）

        Returns:
            输出列表
        """
        config = config or {}

        # 对每个输入执行完整的序列
        return [self.invoke(input, config) for input in inputs]
```

---

## 5. 自定义 Runnable 实现

### 5.1 最小实现

```python
from langchain_core.runnables import Runnable
from typing import Any

class MyRunnable(Runnable):
    """自定义 Runnable 的最小实现"""

    def invoke(self, input: Any, config=None) -> Any:
        """必须实现的方法"""
        # 你的处理逻辑
        return f"Processed: {input}"

# 自动支持 | 操作符（继承自 Runnable）
chain = MyRunnable() | another_runnable
```

### 5.2 完整实现

```python
from langchain_core.runnables import Runnable
from typing import Any, Iterator, Optional

class UpperCaseRunnable(Runnable):
    """将输入转换为大写的 Runnable"""

    def __init__(self, prefix: str = ""):
        self.prefix = prefix

    def invoke(self, input: Any, config: Optional[dict] = None) -> str:
        """同步执行"""
        result = str(input).upper()
        return f"{self.prefix}{result}" if self.prefix else result

    async def ainvoke(self, input: Any, config: Optional[dict] = None) -> str:
        """异步执行"""
        # 简单情况下可以直接调用 invoke
        return self.invoke(input, config)

    def stream(self, input: Any, config: Optional[dict] = None) -> Iterator[str]:
        """流式执行"""
        result = self.invoke(input, config)
        # 逐字符输出
        for char in result:
            yield char

    def batch(self, inputs: list, config: Optional[dict] = None) -> list:
        """批量执行"""
        return [self.invoke(inp, config) for inp in inputs]

# 使用示例
upper = UpperCaseRunnable(prefix=">>> ")
result = upper.invoke("hello world")
print(result)  # >>> HELLO WORLD

# 组合
chain = upper | another_runnable
```

### 5.3 带状态的 Runnable

```python
from langchain_core.runnables import Runnable

class CounterRunnable(Runnable):
    """计数器 Runnable（演示状态管理）"""

    def __init__(self):
        self.count = 0

    def invoke(self, input, config=None):
        """每次调用增加计数"""
        self.count += 1
        return {
            "input": input,
            "count": self.count,
            "message": f"This is call #{self.count}"
        }

# 使用
counter = CounterRunnable()
print(counter.invoke("first"))   # count: 1
print(counter.invoke("second"))  # count: 2
print(counter.invoke("third"))   # count: 3
```

**注意**：Runnable 通常应该是无状态的，以支持并发和缓存。

---

## 6. 高级特性

### 6.1 类型注解

```python
from langchain_core.runnables import Runnable
from typing import TypeVar, Generic

Input = TypeVar("Input")
Output = TypeVar("Output")

class TypedRunnable(Runnable, Generic[Input, Output]):
    """带类型注解的 Runnable"""

    def invoke(self, input: Input, config=None) -> Output:
        # 实现
        pass

# 使用
class StringToInt(TypedRunnable[str, int]):
    def invoke(self, input: str, config=None) -> int:
        return len(input)

# IDE 会提供类型提示
runnable: Runnable[str, int] = StringToInt()
result: int = runnable.invoke("hello")  # IDE 知道 result 是 int
```

### 6.2 配置传递

```python
class ConfigAwareRunnable(Runnable):
    """使用配置的 Runnable"""

    def invoke(self, input, config=None):
        config = config or {}

        # 从配置中获取参数
        verbose = config.get("verbose", False)
        tags = config.get("tags", [])

        if verbose:
            print(f"Processing: {input}")
            print(f"Tags: {tags}")

        # 处理逻辑
        result = self.process(input)

        return result

    def process(self, input):
        return f"Processed: {input}"

# 使用
runnable = ConfigAwareRunnable()
result = runnable.invoke(
    "test",
    config={
        "verbose": True,
        "tags": ["production", "important"]
    }
)
```

### 6.3 错误处理

```python
from langchain_core.runnables import Runnable

class SafeRunnable(Runnable):
    """带错误处理的 Runnable"""

    def __init__(self, fallback_value=None):
        self.fallback_value = fallback_value

    def invoke(self, input, config=None):
        try:
            # 尝试处理
            return self.process(input)
        except Exception as e:
            # 错误处理
            print(f"Error: {e}")
            if self.fallback_value is not None:
                return self.fallback_value
            raise

    def process(self, input):
        # 可能抛出异常的处理逻辑
        if not input:
            raise ValueError("Input cannot be empty")
        return f"Processed: {input}"

# 使用
safe = SafeRunnable(fallback_value="DEFAULT")
result = safe.invoke("")  # 返回 "DEFAULT" 而不是抛出异常
```

---

## 7. 性能优化

### 7.1 延迟初始化

```python
class LazyRunnable(Runnable):
    """延迟初始化的 Runnable"""

    def __init__(self):
        self._model = None

    @property
    def model(self):
        """延迟加载模型"""
        if self._model is None:
            print("Loading model...")
            self._model = self._load_model()
        return self._model

    def _load_model(self):
        # 加载耗时的模型
        import time
        time.sleep(1)  # 模拟加载时间
        return "Loaded Model"

    def invoke(self, input, config=None):
        # 只在第一次调用时加载模型
        return f"{self.model}: {input}"

# 使用
lazy = LazyRunnable()  # 不加载模型
print("Created runnable")
result = lazy.invoke("test")  # 第一次调用时加载
result = lazy.invoke("test2")  # 复用已加载的模型
```

### 7.2 缓存

```python
from functools import lru_cache

class CachedRunnable(Runnable):
    """带缓存的 Runnable"""

    @lru_cache(maxsize=128)
    def _cached_process(self, input_str: str):
        """缓存处理结果"""
        print(f"Processing: {input_str}")
        # 耗时的处理
        return f"Result: {input_str}"

    def invoke(self, input, config=None):
        # 将输入转换为可哈希的类型
        input_str = str(input)
        return self._cached_process(input_str)

# 使用
cached = CachedRunnable()
result1 = cached.invoke("test")  # 处理并缓存
result2 = cached.invoke("test")  # 从缓存返回（不打印 "Processing"）
```

---

## 8. 调试技巧

### 8.1 打印中间结果

```python
class DebugRunnable(Runnable):
    """调试用的 Runnable"""

    def __init__(self, name: str, wrapped: Runnable):
        self.name = name
        self.wrapped = wrapped

    def invoke(self, input, config=None):
        print(f"[{self.name}] Input: {input}")
        output = self.wrapped.invoke(input, config)
        print(f"[{self.name}] Output: {output}")
        return output

# 使用
chain = (
    DebugRunnable("Step1", step1)
    | DebugRunnable("Step2", step2)
    | DebugRunnable("Step3", step3)
)

result = chain.invoke(input)
# 输出:
# [Step1] Input: ...
# [Step1] Output: ...
# [Step2] Input: ...
# [Step2] Output: ...
# [Step3] Input: ...
# [Step3] Output: ...
```

### 8.2 性能分析

```python
import time

class TimedRunnable(Runnable):
    """测量执行时间的 Runnable"""

    def __init__(self, name: str, wrapped: Runnable):
        self.name = name
        self.wrapped = wrapped

    def invoke(self, input, config=None):
        start = time.time()
        output = self.wrapped.invoke(input, config)
        elapsed = time.time() - start
        print(f"[{self.name}] Took {elapsed:.3f}s")
        return output

# 使用
chain = (
    TimedRunnable("Retrieval", retriever)
    | TimedRunnable("LLM", llm)
    | TimedRunnable("Parser", parser)
)

result = chain.invoke(query)
# 输出:
# [Retrieval] Took 0.234s
# [LLM] Took 1.567s
# [Parser] Took 0.012s
```

---

## 9. 实战示例

### 9.1 自定义文本处理管道

```python
from langchain_core.runnables import Runnable

class TextCleaner(Runnable):
    """清理文本"""
    def invoke(self, input, config=None):
        return input.strip().lower()

class TextTokenizer(Runnable):
    """分词"""
    def invoke(self, input, config=None):
        return input.split()

class TextCounter(Runnable):
    """统计词频"""
    def invoke(self, input, config=None):
        from collections import Counter
        return dict(Counter(input))

# 组合成管道
text_pipeline = TextCleaner() | TextTokenizer() | TextCounter()

# 使用
text = "  Hello World Hello Python  "
result = text_pipeline.invoke(text)
print(result)  # {'hello': 2, 'world': 1, 'python': 1}
```

### 9.2 自定义 RAG 组件

```python
from langchain_core.runnables import Runnable
from typing import List, Dict

class DocumentRetriever(Runnable):
    """文档检索器"""
    def __init__(self, docs: List[str]):
        self.docs = docs

    def invoke(self, input: str, config=None) -> List[str]:
        # 简单的关键词匹配
        query = input.lower()
        return [doc for doc in self.docs if query in doc.lower()]

class ContextFormatter(Runnable):
    """上下文格式化器"""
    def invoke(self, input: List[str], config=None) -> Dict:
        return {
            "context": "\n\n".join(input),
            "num_docs": len(input)
        }

# 组合
docs = [
    "Python is a programming language",
    "LangChain is a framework for LLMs",
    "LCEL is the expression language"
]

rag_pipeline = (
    DocumentRetriever(docs)
    | ContextFormatter()
)

result = rag_pipeline.invoke("LangChain")
print(result)
# {
#   'context': 'LangChain is a framework for LLMs',
#   'num_docs': 1
# }
```

---

## 10. 总结

### 核心要点

1. **`__or__` 方法**：
   - 实现 `|` 操作符
   - 接收右操作数，返回 RunnableSequence
   - 自动类型转换（callable → RunnableLambda，dict → RunnableParallel）

2. **RunnableSequence**：
   - 管理多个 Runnable 的顺序执行
   - 自动扁平化嵌套序列
   - 支持 invoke、stream、batch 等方法

3. **自定义 Runnable**：
   - 继承 Runnable 基类
   - 实现 invoke 方法
   - 自动支持 `|` 操作符

4. **性能优化**：
   - 延迟初始化
   - 缓存结果
   - 批量处理

### 学习检查

完成本文档学习后，你应该能够：

- [ ] 解释 `a | b` 背后的执行流程
- [ ] 理解 RunnableSequence 的创建机制
- [ ] 实现自定义 Runnable
- [ ] 使用调试技巧排查问题
- [ ] 优化 Runnable 的性能

---

**版本**: v1.0
**最后更新**: 2026-02-19
**维护者**: Claude Code

**参考资源**:
- [LangChain Runnable 源码](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/runnables/base.py)
- [管道操作符深度解析](https://medium.com/@MichaelHashimoto/why-the-pipe-character-works-in-langchains-lcel-b4e8685855f5)

**下一步**: 阅读 `03_核心概念_02_数据流转机制.md` 理解数据如何在管道中流转
