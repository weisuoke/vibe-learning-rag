# 核心概念 03 - API 测试与端到端测试

## 什么是 API 测试？

### 定义

**API 测试（API Test）**：测试 HTTP 端点的行为，验证请求和响应

**核心特征**：
- **黑盒测试**：从外部测试 API，不关心内部实现
- **完整请求**：测试完整的 HTTP 请求-响应周期
- **真实场景**：模拟客户端调用 API
- **快速反馈**：不需要启动浏览器或真实服务器

### API 测试的价值

```python
# 单元测试：只测试函数
def test_create_user_logic():
    user = create_user("alice", "alice@example.com")
    assert user.username == "alice"

# API 测试：测试完整的 HTTP 端点
def test_create_user_api(client):
    response = client.post("/api/users", json={
        "username": "alice",
        "email": "alice@example.com"
    })
    assert response.status_code == 201
    assert response.json()["username"] == "alice"

# API 测试能发现：
# - 路由配置错误
# - 请求验证问题
# - 响应序列化问题
# - 认证授权问题
```

---

## FastAPI TestClient

### 基本用法

**TestClient 模拟 HTTP 请求**

```python
# app/main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello World"}

@app.get("/items/{item_id}")
def read_item(item_id: int):
    return {"item_id": item_id}

# tests/test_api.py
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_read_root():
    """测试：根路径"""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}

def test_read_item():
    """测试：获取商品"""
    response = client.get("/items/42")
    assert response.status_code == 200
    assert response.json() == {"item_id": 42}
```

### HTTP 方法测试

```python
# GET 请求
def test_get_request(client):
    response = client.get("/api/users")
    assert response.status_code == 200

# POST 请求
def test_post_request(client):
    response = client.post("/api/users", json={
        "username": "alice",
        "email": "alice@example.com"
    })
    assert response.status_code == 201

# PUT 请求
def test_put_request(client):
    response = client.put("/api/users/1", json={
        "email": "new@example.com"
    })
    assert response.status_code == 200

# DELETE 请求
def test_delete_request(client):
    response = client.delete("/api/users/1")
    assert response.status_code == 204

# PATCH 请求
def test_patch_request(client):
    response = client.patch("/api/users/1", json={
        "email": "new@example.com"
    })
    assert response.status_code == 200
```

### 请求参数测试

```python
# 查询参数
def test_query_params(client):
    response = client.get("/api/users?page=1&limit=10")
    assert response.status_code == 200

# 路径参数
def test_path_params(client):
    response = client.get("/api/users/123")
    assert response.status_code == 200

# 请求头
def test_headers(client):
    response = client.get("/api/users", headers={
        "Authorization": "Bearer token123",
        "Content-Type": "application/json"
    })
    assert response.status_code == 200

# 请求体
def test_request_body(client):
    response = client.post("/api/users", json={
        "username": "alice",
        "email": "alice@example.com"
    })
    assert response.status_code == 201
```

### 响应验证

```python
def test_response_status_code(client):
    """测试：响应状态码"""
    response = client.get("/api/users")
    assert response.status_code == 200

def test_response_json(client):
    """测试：响应 JSON"""
    response = client.get("/api/users/1")
    data = response.json()
    assert data["id"] == 1
    assert "username" in data

def test_response_headers(client):
    """测试：响应头"""
    response = client.get("/api/users")
    assert response.headers["content-type"] == "application/json"

def test_response_cookies(client):
    """测试：响应 Cookie"""
    response = client.post("/api/login", json={
        "username": "alice",
        "password": "password"
    })
    assert "session_id" in response.cookies
```

---

## 测试认证和授权

### JWT 认证测试

```python
# app/auth.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt

security = HTTPBearer()

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """获取当前用户"""
    try:
        token = credentials.credentials
        payload = jwt.decode(token, "secret", algorithms=["HS256"])
        return payload["user_id"]
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )

# app/main.py
@app.get("/api/users/me")
def read_current_user(user_id: int = Depends(get_current_user)):
    return {"user_id": user_id}

# tests/test_auth.py
import jwt

@pytest.fixture
def auth_token():
    """生成测试 token"""
    payload = {"user_id": 1}
    return jwt.encode(payload, "secret", algorithm="HS256")

def test_protected_endpoint_with_token(client, auth_token):
    """测试：使用有效 token 访问受保护端点"""
    response = client.get(
        "/api/users/me",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200
    assert response.json()["user_id"] == 1

def test_protected_endpoint_without_token(client):
    """测试：不带 token 访问受保护端点"""
    response = client.get("/api/users/me")
    assert response.status_code == 403  # Forbidden

def test_protected_endpoint_with_invalid_token(client):
    """测试：使用无效 token"""
    response = client.get(
        "/api/users/me",
        headers={"Authorization": "Bearer invalid_token"}
    )
    assert response.status_code == 401  # Unauthorized
```

### 权限测试

```python
# app/auth.py
def require_admin(user_id: int = Depends(get_current_user)):
    """要求管理员权限"""
    user = get_user(user_id)
    if not user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin required"
        )
    return user

# app/main.py
@app.delete("/api/users/{user_id}")
def delete_user(
    user_id: int,
    current_user: User = Depends(require_admin)
):
    # 删除用户
    return {"message": "User deleted"}

# tests/test_permissions.py
def test_admin_can_delete_user(client, admin_token):
    """测试：管理员可以删除用户"""
    response = client.delete(
        "/api/users/123",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    assert response.status_code == 200

def test_regular_user_cannot_delete_user(client, user_token):
    """测试：普通用户不能删除用户"""
    response = client.delete(
        "/api/users/123",
        headers={"Authorization": f"Bearer {user_token}"}
    )
    assert response.status_code == 403
```

---

## 测试异步端点

### 异步测试基础

```python
# app/main.py
import asyncio
from fastapi import FastAPI

app = FastAPI()

@app.get("/api/async-data")
async def get_async_data():
    """异步端点"""
    await asyncio.sleep(0.1)  # 模拟异步操作
    return {"data": "async result"}

# tests/test_async.py
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_async_endpoint():
    """测试：异步端点"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/api/async-data")
        assert response.status_code == 200
        assert response.json() == {"data": "async result"}
```

### 测试流式响应

```python
# app/main.py
from fastapi import FastAPI
from fastapi.responses import StreamingResponse

app = FastAPI()

async def generate_stream():
    """生成流式数据"""
    for i in range(5):
        yield f"data: {i}\n\n"
        await asyncio.sleep(0.1)

@app.get("/api/stream")
async def stream_data():
    """流式端点"""
    return StreamingResponse(generate_stream(), media_type="text/event-stream")

# tests/test_streaming.py
@pytest.mark.asyncio
async def test_streaming_response():
    """测试：流式响应"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        async with client.stream("GET", "/api/stream") as response:
            assert response.status_code == 200

            chunks = []
            async for chunk in response.aiter_text():
                chunks.append(chunk)

            # 验证收到了所有数据
            assert len(chunks) == 5
            assert "data: 0" in chunks[0]
            assert "data: 4" in chunks[4]
```

---

## AI Agent API 测试

### 场景1：测试聊天端点

```python
# app/api/chat.py
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class ChatRequest(BaseModel):
    message: str
    conversation_id: str | None = None

class ChatResponse(BaseModel):
    reply: str
    conversation_id: str

@app.post("/api/chat", response_model=ChatResponse)
async def chat(request: ChatRequest):
    """聊天端点"""
    # 调用 Agent
    reply = await agent.run(request.message)
    return ChatResponse(
        reply=reply,
        conversation_id=request.conversation_id or "new_id"
    )

# tests/test_chat_api.py
from unittest.mock import AsyncMock, patch

@pytest.mark.asyncio
async def test_chat_endpoint():
    """测试：聊天端点"""
    # Mock Agent
    with patch("app.api.chat.agent") as mock_agent:
        mock_agent.run = AsyncMock(return_value="这是回复")

        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post("/api/chat", json={
                "message": "你好"
            })

            assert response.status_code == 200
            data = response.json()
            assert data["reply"] == "这是回复"
            assert "conversation_id" in data

@pytest.mark.asyncio
async def test_chat_endpoint_with_conversation_id():
    """测试：带对话 ID 的聊天"""
    with patch("app.api.chat.agent") as mock_agent:
        mock_agent.run = AsyncMock(return_value="继续对话")

        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post("/api/chat", json={
                "message": "继续",
                "conversation_id": "existing_id"
            })

            assert response.status_code == 200
            assert response.json()["conversation_id"] == "existing_id"
```

### 场景2：测试 RAG 检索端点

```python
# app/api/search.py
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class SearchRequest(BaseModel):
    query: str
    k: int = 3

class SearchResponse(BaseModel):
    results: list[str]

@app.post("/api/search", response_model=SearchResponse)
async def search(request: SearchRequest):
    """检索端点"""
    results = await vector_store.similarity_search(request.query, k=request.k)
    return SearchResponse(
        results=[doc.page_content for doc in results]
    )

# tests/test_search_api.py
@pytest.mark.asyncio
async def test_search_endpoint():
    """测试：检索端点"""
    # Mock 向量存储
    with patch("app.api.search.vector_store") as mock_store:
        mock_doc = Mock()
        mock_doc.page_content = "RAG 是检索增强生成"
        mock_store.similarity_search = AsyncMock(return_value=[mock_doc])

        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post("/api/search", json={
                "query": "什么是 RAG",
                "k": 1
            })

            assert response.status_code == 200
            data = response.json()
            assert len(data["results"]) == 1
            assert "RAG" in data["results"][0]
```

### 场景3：测试流式聊天端点

```python
# app/api/chat_stream.py
from fastapi import FastAPI
from fastapi.responses import StreamingResponse

app = FastAPI()

async def generate_chat_stream(message: str):
    """生成流式聊天响应"""
    async for chunk in agent.astream(message):
        yield f"data: {chunk}\n\n"

@app.post("/api/chat/stream")
async def chat_stream(message: str):
    """流式聊天端点"""
    return StreamingResponse(
        generate_chat_stream(message),
        media_type="text/event-stream"
    )

# tests/test_chat_stream_api.py
@pytest.mark.asyncio
async def test_chat_stream_endpoint():
    """测试：流式聊天端点"""
    # Mock Agent 流式输出
    async def mock_stream(message):
        for chunk in ["这", "是", "流", "式", "回", "复"]:
            yield chunk

    with patch("app.api.chat_stream.agent") as mock_agent:
        mock_agent.astream = mock_stream

        async with AsyncClient(app=app, base_url="http://test") as client:
            async with client.stream("POST", "/api/chat/stream?message=你好") as response:
                assert response.status_code == 200

                chunks = []
                async for chunk in response.aiter_text():
                    chunks.append(chunk)

                # 验证收到了流式数据
                assert len(chunks) > 0
                full_response = "".join(chunks)
                assert "data:" in full_response
```

---

## 端到端测试（E2E）

### 什么是 E2E 测试？

**端到端测试（End-to-End Test）**：测试完整的用户场景，从开始到结束

**特点**：
- 测试完整的业务流程
- 使用真实的依赖（数据库、缓存、外部 API）
- 最接近真实使用场景
- 运行最慢，但最有价值

### E2E 测试示例

```python
# tests/test_e2e_user_flow.py
import pytest
from fastapi.testclient import TestClient
from app.main import app
from app.database import Base, engine

@pytest.fixture(scope="module")
def client():
    """E2E 测试客户端"""
    # 创建测试数据库
    Base.metadata.create_all(engine)
    yield TestClient(app)
    # 清理
    Base.metadata.drop_all(engine)

def test_complete_user_flow(client):
    """测试：完整的用户流程"""

    # 1. 注册用户
    response = client.post("/api/auth/register", json={
        "username": "alice",
        "email": "alice@example.com",
        "password": "password123"
    })
    assert response.status_code == 201
    user_id = response.json()["id"]

    # 2. 登录
    response = client.post("/api/auth/login", json={
        "username": "alice",
        "password": "password123"
    })
    assert response.status_code == 200
    token = response.json()["access_token"]

    # 3. 获取用户信息
    response = client.get(
        "/api/users/me",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 200
    assert response.json()["username"] == "alice"

    # 4. 更新用户信息
    response = client.put(
        "/api/users/me",
        headers={"Authorization": f"Bearer {token}"},
        json={"email": "newemail@example.com"}
    )
    assert response.status_code == 200

    # 5. 验证更新
    response = client.get(
        "/api/users/me",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert response.json()["email"] == "newemail@example.com"

    # 6. 登出
    response = client.post(
        "/api/auth/logout",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 200

    # 7. 验证 token 已失效
    response = client.get(
        "/api/users/me",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 401
```

### AI Agent E2E 测试

```python
# tests/test_e2e_agent_flow.py
@pytest.mark.asyncio
async def test_complete_agent_conversation():
    """测试：完整的 Agent 对话流程"""

    async with AsyncClient(app=app, base_url="http://test") as client:
        # 1. 开始对话
        response = await client.post("/api/chat", json={
            "message": "你好"
        })
        assert response.status_code == 200
        conversation_id = response.json()["conversation_id"]

        # 2. 继续对话
        response = await client.post("/api/chat", json={
            "message": "什么是 RAG?",
            "conversation_id": conversation_id
        })
        assert response.status_code == 200
        assert "RAG" in response.json()["reply"]

        # 3. 检索相关文档
        response = await client.post("/api/search", json={
            "query": "RAG 的应用场景",
            "k": 3
        })
        assert response.status_code == 200
        assert len(response.json()["results"]) == 3

        # 4. 基于检索结果继续对话
        response = await client.post("/api/chat", json={
            "message": "详细解释一下",
            "conversation_id": conversation_id
        })
        assert response.status_code == 200

        # 5. 获取对话历史
        response = await client.get(f"/api/conversations/{conversation_id}")
        assert response.status_code == 200
        history = response.json()["messages"]
        assert len(history) >= 6  # 至少3轮对话
```

---

## 测试最佳实践

### 1. 使用 fixture 管理测试客户端

```python
# conftest.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

@pytest.fixture
def client():
    """测试客户端"""
    return TestClient(app)

@pytest.fixture
def auth_client(client):
    """认证客户端"""
    # 登录获取 token
    response = client.post("/api/auth/login", json={
        "username": "test",
        "password": "password"
    })
    token = response.json()["access_token"]

    # 返回带认证头的客户端
    class AuthClient:
        def __init__(self, client, token):
            self.client = client
            self.token = token

        def get(self, url, **kwargs):
            headers = kwargs.get("headers", {})
            headers["Authorization"] = f"Bearer {self.token}"
            kwargs["headers"] = headers
            return self.client.get(url, **kwargs)

        # 其他 HTTP 方法...

    return AuthClient(client, token)
```

### 2. 测试错误处理

```python
def test_404_error(client):
    """测试：404 错误"""
    response = client.get("/api/nonexistent")
    assert response.status_code == 404
    assert "error" in response.json()

def test_validation_error(client):
    """测试：验证错误"""
    response = client.post("/api/users", json={
        "username": "a"  # 太短
    })
    assert response.status_code == 422
    errors = response.json()["detail"]
    assert any("username" in str(e) for e in errors)

def test_authentication_error(client):
    """测试：认证错误"""
    response = client.get("/api/users/me")
    assert response.status_code == 403

def test_authorization_error(client, user_token):
    """测试：授权错误"""
    response = client.delete(
        "/api/users/123",
        headers={"Authorization": f"Bearer {user_token}"}
    )
    assert response.status_code == 403
```

### 3. 参数化 API 测试

```python
@pytest.mark.parametrize("endpoint,method,expected_status", [
    ("/api/users", "GET", 200),
    ("/api/users/1", "GET", 200),
    ("/api/users", "POST", 201),
    ("/api/users/1", "PUT", 200),
    ("/api/users/1", "DELETE", 204),
])
def test_api_endpoints(client, endpoint, method, expected_status):
    """测试：API 端点（参数化）"""
    response = getattr(client, method.lower())(endpoint)
    assert response.status_code == expected_status
```

### 4. 测试数据清理

```python
@pytest.fixture
def clean_database(db_session):
    """清理数据库"""
    yield db_session
    # 测试后清理所有数据
    db_session.query(User).delete()
    db_session.query(Post).delete()
    db_session.commit()

def test_with_clean_database(client, clean_database):
    """测试：使用干净的数据库"""
    response = client.post("/api/users", json={
        "username": "alice"
    })
    assert response.status_code == 201
```

---

## 测试覆盖率和报告

### 生成覆盖率报告

```bash
# 运行测试并生成覆盖率报告
pytest --cov=app --cov-report=html tests/

# 查看 HTML 报告
open htmlcov/index.html
```

### 覆盖率配置

```ini
# pytest.ini
[pytest]
addopts =
    --cov=app
    --cov-report=term-missing
    --cov-report=html
    --cov-fail-under=80

# .coveragerc
[run]
omit =
    */tests/*
    */migrations/*
    */venv/*
```

---

## 总结

### 核心要点

1. **API 测试**：测试 HTTP 端点，使用 TestClient
2. **认证测试**：测试 JWT、权限、受保护端点
3. **异步测试**：测试异步端点、流式响应
4. **E2E 测试**：测试完整的用户场景

### AI Agent 应用

- 测试聊天端点
- 测试 RAG 检索端点
- 测试流式输出端点
- 测试完整的对话流程

### 下一步

掌握了 API 测试和 E2E 测试后，继续学习：
- 实战代码示例
- 生产级测试最佳实践
- CI/CD 集成
