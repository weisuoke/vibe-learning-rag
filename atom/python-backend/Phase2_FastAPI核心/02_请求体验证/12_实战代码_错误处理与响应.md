# 实战代码：错误处理与响应

> 完整可运行的验证错误处理示例

---

## 场景概述

本文提供3个错误处理场景，展示如何自定义验证错误格式、提供友好的错误消息和实现多语言错误响应。

---

## 场景1：自定义错误响应格式

### 需求

- 自定义验证错误的响应格式
- 提供更友好的错误消息
- 添加错误代码和时间戳
- 支持多个错误的聚合显示

### 完整代码

```python
"""
场景1：自定义错误响应格式
演示如何自定义 FastAPI 的验证错误响应
"""

from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel, Field, validator
from typing import List, Dict, Any
from datetime import datetime

app = FastAPI(title="自定义错误响应 API")

# ===== 自定义错误响应模型 =====

class ErrorDetail(BaseModel):
    """单个错误详情"""
    field: str
    message: str
    error_code: str
    value: Any = None

class ErrorResponse(BaseModel):
    """错误响应模型"""
    success: bool = False
    error_count: int
    errors: List[ErrorDetail]
    timestamp: str
    path: str

# ===== 自定义异常处理器 =====

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """自定义验证错误处理器"""

    errors = []
    for error in exc.errors():
        # 提取字段路径
        field_path = ".".join(str(loc) for loc in error["loc"][1:])  # 跳过 "body"

        # 提取错误值
        error_value = None
        try:
            body = await request.json()
            # 尝试获取错误字段的值
            value = body
            for loc in error["loc"][1:]:
                if isinstance(value, dict) and loc in value:
                    value = value[loc]
                else:
                    value = None
                    break
            error_value = value
        except:
            pass

        # 构建友好的错误消息
        error_type = error["type"]
        error_msg = error["msg"]

        # 自定义错误消息
        if error_type == "value_error.missing":
            error_msg = f"字段 '{field_path}' 是必需的"
        elif error_type == "type_error.integer":
            error_msg = f"字段 '{field_path}' 必须是整数"
        elif error_type == "type_error.float":
            error_msg = f"字段 '{field_path}' 必须是浮点数"
        elif error_type == "type_error.str":
            error_msg = f"字段 '{field_path}' 必须是字符串"
        elif error_type == "type_error.bool":
            error_msg = f"字段 '{field_path}' 必须是布尔值"
        elif "min_length" in error_type:
            min_len = error.get("ctx", {}).get("limit_value", "")
            error_msg = f"字段 '{field_path}' 长度不能少于 {min_len} 个字符"
        elif "max_length" in error_type:
            max_len = error.get("ctx", {}).get("limit_value", "")
            error_msg = f"字段 '{field_path}' 长度不能超过 {max_len} 个字符"
        elif "greater_than_equal" in error_type:
            min_val = error.get("ctx", {}).get("limit_value", "")
            error_msg = f"字段 '{field_path}' 必须大于等于 {min_val}"
        elif "less_than_equal" in error_type:
            max_val = error.get("ctx", {}).get("limit_value", "")
            error_msg = f"字段 '{field_path}' 必须小于等于 {max_val}"

        errors.append(ErrorDetail(
            field=field_path,
            message=error_msg,
            error_code=error_type,
            value=error_value
        ))

    # 构建错误响应
    error_response = ErrorResponse(
        error_count=len(errors),
        errors=errors,
        timestamp=datetime.now().isoformat(),
        path=request.url.path
    )

    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content=error_response.dict()
    )

# ===== 测试模型 =====

class User(BaseModel):
    username: str = Field(min_length=3, max_length=20)
    email: str
    age: int = Field(ge=18, le=150)
    bio: str = Field(default="", max_length=500)

@app.post("/users")
async def create_user(user: User):
    """创建用户"""
    return {"message": "用户创建成功", "username": user.username}

if __name__ == "__main__":
    import uvicorn
    print("场景1：自定义错误响应格式")
    print("访问 http://localhost:8000/docs 测试")
    print("\n测试错误请求：")
    print('POST /users')
    print('{"username": "ab", "age": 15}')
    print("\n期望响应：")
    print('{')
    print('  "success": false,')
    print('  "error_count": 3,')
    print('  "errors": [')
    print('    {"field": "username", "message": "字段 \'username\' 长度不能少于 3 个字符", ...},')
    print('    {"field": "email", "message": "字段 \'email\' 是必需的", ...},')
    print('    {"field": "age", "message": "字段 \'age\' 必须大于等于 18", ...}')
    print('  ],')
    print('  "timestamp": "2024-01-01T00:00:00",')
    print('  "path": "/users"')
    print('}')
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 场景2：多语言错误消息

### 需求

- 支持中文和英文错误消息
- 根据请求头的 Accept-Language 返回对应语言
- 提供错误消息模板系统
- 支持参数化错误消息

### 完整代码

```python
"""
场景2：多语言错误消息
演示如何实现多语言错误响应
"""

from fastapi import FastAPI, Request, Header, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from datetime import datetime

app = FastAPI(title="多语言错误消息 API")

# ===== 错误消息模板 =====

ERROR_MESSAGES = {
    "zh": {
        "value_error.missing": "字段 '{field}' 是必需的",
        "type_error.integer": "字段 '{field}' 必须是整数",
        "type_error.str": "字段 '{field}' 必须是字符串",
        "value_error.any_str.min_length": "字段 '{field}' 长度不能少于 {min_length} 个字符",
        "value_error.any_str.max_length": "字段 '{field}' 长度不能超过 {max_length} 个字符",
        "value_error.number.not_ge": "字段 '{field}' 必须大于等于 {limit_value}",
        "value_error.number.not_le": "字段 '{field}' 必须小于等于 {limit_value}",
        "value_error.email": "字段 '{field}' 必须是有效的邮箱地址",
        "default": "字段 '{field}' 验证失败: {msg}"
    },
    "en": {
        "value_error.missing": "Field '{field}' is required",
        "type_error.integer": "Field '{field}' must be an integer",
        "type_error.str": "Field '{field}' must be a string",
        "value_error.any_str.min_length": "Field '{field}' must have at least {min_length} characters",
        "value_error.any_str.max_length": "Field '{field}' must have at most {max_length} characters",
        "value_error.number.not_ge": "Field '{field}' must be greater than or equal to {limit_value}",
        "value_error.number.not_le": "Field '{field}' must be less than or equal to {limit_value}",
        "value_error.email": "Field '{field}' must be a valid email address",
        "default": "Field '{field}' validation failed: {msg}"
    }
}

def get_error_message(error_type: str, field: str, context: Dict[str, Any], lang: str = "zh") -> str:
    """获取错误消息"""
    messages = ERROR_MESSAGES.get(lang, ERROR_MESSAGES["zh"])
    template = messages.get(error_type, messages["default"])

    # 构建参数字典
    params = {"field": field, "msg": ""}
    params.update(context)

    try:
        return template.format(**params)
    except KeyError:
        return messages["default"].format(field=field, msg=error_type)

def parse_accept_language(accept_language: Optional[str]) -> str:
    """解析 Accept-Language 头"""
    if not accept_language:
        return "zh"

    # 简化的语言解析（实际应用中应该更完善）
    lang = accept_language.split(",")[0].split("-")[0].lower()
    return "en" if lang == "en" else "zh"

# ===== 自定义异常处理器 =====

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(
    request: Request,
    exc: RequestValidationError
):
    """多语言验证错误处理器"""

    # 获取语言偏好
    accept_language = request.headers.get("Accept-Language")
    lang = parse_accept_language(accept_language)

    errors = []
    for error in exc.errors():
        field_path = ".".join(str(loc) for loc in error["loc"][1:])
        error_type = error["type"]
        context = error.get("ctx", {})

        error_msg = get_error_message(error_type, field_path, context, lang)

        errors.append({
            "field": field_path,
            "message": error_msg,
            "type": error_type
        })

    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "success": False,
            "errors": errors,
            "language": lang
        }
    )

# ===== 测试模型 =====

class User(BaseModel):
    username: str = Field(min_length=3, max_length=20)
    email: str
    age: int = Field(ge=18, le=150)

@app.post("/users")
async def create_user(user: User):
    """创建用户"""
    return {"message": "用户创建成功", "username": user.username}

if __name__ == "__main__":
    import uvicorn
    print("场景2：多语言错误消息")
    print("访问 http://localhost:8000/docs 测试")
    print("\n测试中文错误（默认）：")
    print('POST /users')
    print('{"username": "ab"}')
    print("\n测试英文错误（添加 Accept-Language: en）：")
    print('curl -H "Accept-Language: en" -X POST ...')
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 场景3：错误聚合和建议

### 需求

- 聚合相关错误（如多个字段的相同错误）
- 提供修复建议
- 显示错误的严重程度
- 提供文档链接

### 完整代码

```python
"""
场景3：错误聚合和建议
演示如何提供智能的错误提示和修复建议
"""

from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel, Field, validator
from typing import List, Dict, Any, Optional
from datetime import datetime

app = FastAPI(title="智能错误提示 API")

# ===== 错误建议系统 =====

def get_error_suggestion(error_type: str, field: str, value: Any) -> Optional[str]:
    """根据错误类型提供修复建议"""

    suggestions = {
        "value_error.missing": f"请提供 '{field}' 字段的值",
        "type_error.integer": f"'{field}' 应该是数字，而不是 '{type(value).__name__}'",
        "type_error.str": f"'{field}' 应该是字符串，而不是 '{type(value).__name__}'",
        "value_error.any_str.min_length": f"'{field}' 太短了，请输入更多字符",
        "value_error.any_str.max_length": f"'{field}' 太长了，请缩短内容",
        "value_error.number.not_ge": f"'{field}' 的值太小了，请增加数值",
        "value_error.number.not_le": f"'{field}' 的值太大了，请减少数值",
        "value_error.email": f"'{field}' 不是有效的邮箱格式，请检查是否包含 @ 符号"
    }

    return suggestions.get(error_type)

def get_error_severity(error_type: str) -> str:
    """获取错误严重程度"""
    if "missing" in error_type:
        return "critical"  # 必需字段缺失
    elif "type_error" in error_type:
        return "high"  # 类型错误
    else:
        return "medium"  # 验证错误

def get_doc_link(field: str) -> str:
    """获取文档链接"""
    # 简化示例，实际应该根据字段返回真实的文档链接
    return f"https://docs.example.com/api/fields#{field}"

# ===== 自定义异常处理器 =====

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(
    request: Request,
    exc: RequestValidationError
):
    """智能错误提示处理器"""

    errors = []
    error_summary = {
        "critical": 0,
        "high": 0,
        "medium": 0
    }

    for error in exc.errors():
        field_path = ".".join(str(loc) for loc in error["loc"][1:])
        error_type = error["type"]
        error_msg = error["msg"]

        # 获取错误值
        error_value = None
        try:
            body = await request.json()
            value = body
            for loc in error["loc"][1:]:
                if isinstance(value, dict) and loc in value:
                    value = value[loc]
                else:
                    value = None
                    break
            error_value = value
        except:
            pass

        # 获取严重程度
        severity = get_error_severity(error_type)
        error_summary[severity] += 1

        # 获取修复建议
        suggestion = get_error_suggestion(error_type, field_path, error_value)

        # 获取文档链接
        doc_link = get_doc_link(field_path)

        errors.append({
            "field": field_path,
            "message": error_msg,
            "type": error_type,
            "severity": severity,
            "value": error_value,
            "suggestion": suggestion,
            "doc_link": doc_link
        })

    # 构建响应
    response = {
        "success": False,
        "error_count": len(errors),
        "error_summary": error_summary,
        "errors": errors,
        "timestamp": datetime.now().isoformat(),
        "help": "请根据建议修复错误，或访问文档链接了解更多信息"
    }

    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content=response
    )

# ===== 测试模型 =====

class User(BaseModel):
    username: str = Field(min_length=3, max_length=20)
    email: str
    age: int = Field(ge=18, le=150)
    bio: str = Field(default="", max_length=500)

    @validator('username')
    def username_alphanumeric(cls, v):
        if not v.isalnum():
            raise ValueError('用户名只能包含字母和数字')
        return v

@app.post("/users")
async def create_user(user: User):
    """创建用户"""
    return {"message": "用户创建成功", "username": user.username}

if __name__ == "__main__":
    import uvicorn
    print("场景3：错误聚合和建议")
    print("访问 http://localhost:8000/docs 测试")
    print("\n测试错误请求：")
    print('POST /users')
    print('{"username": "ab", "age": 15}')
    print("\n期望响应包含：")
    print("- 错误数量和严重程度统计")
    print("- 每个错误的修复建议")
    print("- 文档链接")
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 场景4：结构化错误日志

### 需求

- 记录验证错误到日志系统
- 包含请求上下文信息
- 支持错误追踪和分析
- 区分用户错误和系统错误

### 完整代码

```python
"""
场景4：结构化错误日志
演示如何记录和追踪验证错误
"""

from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel, Field
from typing import Dict, Any
from datetime import datetime
import json
import uuid

app = FastAPI(title="错误日志 API")

# ===== 日志系统（简化示例）=====

class ErrorLogger:
    """错误日志记录器"""

    def __init__(self):
        self.logs = []

    def log_validation_error(
        self,
        request_id: str,
        path: str,
        method: str,
        errors: list,
        user_agent: str = None,
        ip_address: str = None
    ):
        """记录验证错误"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "request_id": request_id,
            "error_type": "validation_error",
            "path": path,
            "method": method,
            "error_count": len(errors),
            "errors": errors,
            "user_agent": user_agent,
            "ip_address": ip_address
        }

        self.logs.append(log_entry)

        # 实际应用中应该写入日志文件或发送到日志服务
        print(f"[ERROR LOG] {json.dumps(log_entry, indent=2, ensure_ascii=False)}")

    def get_error_stats(self) -> Dict[str, Any]:
        """获取错误统计"""
        total_errors = len(self.logs)
        if total_errors == 0:
            return {"total_errors": 0}

        # 统计最常见的错误字段
        field_errors = {}
        for log in self.logs:
            for error in log.get("errors", []):
                field = error.get("field", "unknown")
                field_errors[field] = field_errors.get(field, 0) + 1

        # 统计最常见的错误类型
        type_errors = {}
        for log in self.logs:
            for error in log.get("errors", []):
                error_type = error.get("type", "unknown")
                type_errors[error_type] = type_errors.get(error_type, 0) + 1

        return {
            "total_errors": total_errors,
            "most_common_fields": sorted(field_errors.items(), key=lambda x: x[1], reverse=True)[:5],
            "most_common_types": sorted(type_errors.items(), key=lambda x: x[1], reverse=True)[:5]
        }

# 全局日志记录器
error_logger = ErrorLogger()

# ===== 自定义异常处理器 =====

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(
    request: Request,
    exc: RequestValidationError
):
    """带日志记录的验证错误处理器"""

    # 生成请求ID
    request_id = str(uuid.uuid4())

    # 提取错误信息
    errors = []
    for error in exc.errors():
        field_path = ".".join(str(loc) for loc in error["loc"][1:])
        errors.append({
            "field": field_path,
            "message": error["msg"],
            "type": error["type"]
        })

    # 记录错误日志
    error_logger.log_validation_error(
        request_id=request_id,
        path=request.url.path,
        method=request.method,
        errors=errors,
        user_agent=request.headers.get("user-agent"),
        ip_address=request.client.host if request.client else None
    )

    # 返回错误响应
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "success": False,
            "request_id": request_id,
            "errors": errors,
            "message": "请求验证失败，错误已记录"
        }
    )

# ===== 测试模型 =====

class User(BaseModel):
    username: str = Field(min_length=3, max_length=20)
    email: str
    age: int = Field(ge=18, le=150)

@app.post("/users")
async def create_user(user: User):
    """创建用户"""
    return {"message": "用户创建成功", "username": user.username}

@app.get("/admin/error-stats")
async def get_error_stats():
    """获取错误统计（管理员端点）"""
    return error_logger.get_error_stats()

if __name__ == "__main__":
    import uvicorn
    print("场景4：结构化错误日志")
    print("访问 http://localhost:8000/docs 测试")
    print("\n测试流程：")
    print("1. 发送错误请求到 POST /users")
    print("2. 查看控制台的错误日志")
    print("3. 访问 GET /admin/error-stats 查看统计")
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 核心要点

1. **自定义格式** - 使用 @app.exception_handler 自定义错误响应格式
2. **友好消息** - 提供清晰、可操作的错误消息
3. **多语言支持** - 根据 Accept-Language 返回对应语言的错误
4. **智能建议** - 提供修复建议和文档链接
5. **错误日志** - 记录验证错误用于分析和优化

---

## 最佳实践

1. **一致性** - 保持错误响应格式的一致性
2. **可操作性** - 错误消息应该告诉用户如何修复
3. **上下文** - 提供足够的上下文信息（字段、值、约束）
4. **隐私** - 不要在错误消息中暴露敏感信息
5. **可追踪** - 使用请求ID追踪错误

---

**版本：** v1.0
**最后更新：** 2026-02-11
