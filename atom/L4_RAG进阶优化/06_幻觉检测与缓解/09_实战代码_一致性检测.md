# 实战代码：一致性检测

> 完整可运行的一致性检测示例，演示如何在 RAG 系统中检测幻觉

---

## 场景说明

**目标：** 构建一个完整的一致性检测系统，检测 LLM 生成答案与检索文档之间的矛盾

**应用场景：**
- 文档问答系统
- 事实验证系统
- 内容审核系统

**技术栈：**
- `sentence-transformers`：NLI 模型
- `openai`：LLM 生成
- `chromadb`：向量存储（可选）

---

## 完整代码

```python
"""
一致性检测实战示例
演示：如何使用 NLI 模型检测 RAG 系统中的幻觉
"""

from sentence_transformers import CrossEncoder
from openai import OpenAI
import os
from typing import List, Dict, Tuple
import json
from datetime import datetime

# ===== 配置 =====
class Config:
    """配置类"""
    # API 配置
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    OPENAI_BASE_URL = os.getenv("OPENAI_BASE_URL", "https://api.openai.com/v1")

    # NLI 模型配置
    NLI_MODEL = "cross-encoder/nli-deberta-v3-base"

    # 阈值配置
    CONSISTENCY_THRESHOLD = 0.7  # 一致性阈值
    HIGH_CONFIDENCE_THRESHOLD = 0.85  # 高置信度阈值
    LOW_CONFIDENCE_THRESHOLD = 0.5  # 低置信度阈值


# ===== 一致性检测器 =====
class ConsistencyChecker:
    """
    一致性检测器
    使用 NLI 模型检测答案与文档的一致性
    """

    def __init__(self, model_name: str = Config.NLI_MODEL):
        """
        初始化检测器

        Args:
            model_name: NLI 模型名称
        """
        print(f"[初始化] 加载 NLI 模型: {model_name}")
        self.model = CrossEncoder(model_name)
        print("[初始化] ✓ 模型加载完成\n")

    def check_single(self, premise: str, hypothesis: str) -> Dict[str, float]:
        """
        检查单个文档与答案的一致性

        Args:
            premise: 前提（检索文档）
            hypothesis: 假设（生成答案）

        Returns:
            包含三个分数的字典
        """
        # NLI 模型推理
        scores = self.model.predict([(premise, hypothesis)])

        return {
            'contradiction': float(scores[0][0]),
            'neutral': float(scores[0][1]),
            'entailment': float(scores[0][2])
        }

    def check_multi(
        self,
        answer: str,
        docs: List[str],
        aggregation: str = 'max'
    ) -> Dict[str, any]:
        """
        检查答案与多个文档的一致性

        Args:
            answer: 生成的答案
            docs: 检索到的多个文档
            aggregation: 聚合方式 ('max', 'mean', 'min')

        Returns:
            聚合后的一致性结果
        """
        if not docs:
            return {
                'entailment': 0.0,
                'contradiction': 0.0,
                'neutral': 1.0,
                'best_doc_idx': -1
            }

        # 检查答案与每个文档的一致性
        all_scores = []
        for doc in docs:
            scores = self.check_single(doc, answer)
            all_scores.append(scores)

        # 聚合分数
        entailment_scores = [s['entailment'] for s in all_scores]

        if aggregation == 'max':
            best_idx = entailment_scores.index(max(entailment_scores))
            result = all_scores[best_idx].copy()
            result['best_doc_idx'] = best_idx
        elif aggregation == 'mean':
            result = {
                'contradiction': sum(s['contradiction'] for s in all_scores) / len(all_scores),
                'neutral': sum(s['neutral'] for s in all_scores) / len(all_scores),
                'entailment': sum(s['entailment'] for s in all_scores) / len(all_scores),
                'best_doc_idx': entailment_scores.index(max(entailment_scores))
            }
        else:  # min
            worst_idx = entailment_scores.index(min(entailment_scores))
            result = all_scores[worst_idx].copy()
            result['best_doc_idx'] = worst_idx

        return result

    def check_sentence_level(
        self,
        answer: str,
        docs: List[str]
    ) -> List[Dict[str, any]]:
        """
        句子级别的一致性检测

        Args:
            answer: 生成的答案
            docs: 检索到的文档

        Returns:
            每个句子的检测结果
        """
        # 简单的句子分割
        sentences = [s.strip() + '。' for s in answer.split('。') if s.strip()]

        results = []
        for sentence in sentences:
            scores = self.check_multi(sentence, docs, aggregation='max')
            results.append({
                'sentence': sentence,
                'entailment': scores['entailment'],
                'contradiction': scores['contradiction'],
                'neutral': scores['neutral'],
                'best_doc_idx': scores['best_doc_idx'],
                'is_consistent': scores['entailment'] >= Config.CONSISTENCY_THRESHOLD
            })

        return results


# ===== RAG 系统（带一致性检测）=====
class RAGWithConsistencyCheck:
    """
    带一致性检测的 RAG 系统
    """

    def __init__(self):
        """初始化 RAG 系统"""
        print("[初始化] RAG 系统")
        self.client = OpenAI(
            api_key=Config.OPENAI_API_KEY,
            base_url=Config.OPENAI_BASE_URL
        )
        self.checker = ConsistencyChecker()
        print("[初始化] ✓ RAG 系统初始化完成\n")

    def generate_answer(
        self,
        query: str,
        docs: List[str],
        model: str = "gpt-4"
    ) -> str:
        """
        生成答案

        Args:
            query: 用户查询
            docs: 检索到的文档
            model: LLM 模型

        Returns:
            生成的答案
        """
        # 构建 Prompt
        context = "\n\n".join([
            f"文档{i+1}: {doc}"
            for i, doc in enumerate(docs)
        ])

        prompt = f"""基于以下文档回答问题：

{context}

问题：{query}

要求：严格基于文档内容回答，不要添加文档中没有的信息。

答案："""

        # 调用 LLM
        response = self.client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )

        return response.choices[0].message.content

    def process_with_check(
        self,
        query: str,
        docs: List[str],
        threshold: float = Config.CONSISTENCY_THRESHOLD
    ) -> Dict[str, any]:
        """
        处理查询并进行一致性检测

        Args:
            query: 用户查询
            docs: 检索到的文档
            threshold: 一致性阈值

        Returns:
            包含答案和检测结果的字典
        """
        print(f"[查询] {query}")
        print(f"[检索] 找到 {len(docs)} 个文档\n")

        # 1. 生成答案
        print("[生成] 正在生成答案...")
        answer = self.generate_answer(query, docs)
        print(f"[生成] ✓ 答案生成完成\n")

        # 2. 一致性检测
        print("[检测] 正在进行一致性检测...")
        consistency_result = self.checker.check_multi(answer, docs, aggregation='max')
        entailment_score = consistency_result['entailment']
        print(f"[检测] ✓ 一致性分数: {entailment_score:.2f}\n")

        # 3. 句子级别检测
        print("[检测] 正在进行句子级别检测...")
        sentence_results = self.checker.check_sentence_level(answer, docs)
        print(f"[检测] ✓ 检测了 {len(sentence_results)} 个句子\n")

        # 4. 决策
        if entailment_score >= threshold:
            status = "approved"
            final_answer = answer
            message = "一致性检测通过"
        elif entailment_score >= Config.LOW_CONFIDENCE_THRESHOLD:
            status = "warning"
            final_answer = f"（不太确定）{answer}"
            message = "一致性分数较低，建议谨慎参考"
        else:
            status = "rejected"
            final_answer = "抱歉，我对这个答案不够确定"
            message = "一致性检测未通过"

        return {
            'query': query,
            'answer': answer,
            'final_answer': final_answer,
            'status': status,
            'message': message,
            'consistency_score': entailment_score,
            'sentence_results': sentence_results,
            'best_doc_idx': consistency_result['best_doc_idx'],
            'threshold': threshold
        }


# ===== 测试用例 =====
def test_case_1_consistent():
    """
    测试用例1：一致的情况
    """
    print("=" * 60)
    print("测试用例1：一致的情况")
    print("=" * 60 + "\n")

    docs = [
        "Python 3.9 于 2020 年 10 月 5 日正式发布。",
        "Python 3.9 新增了字典合并运算符 |，可以方便地合并两个字典。",
        "Python 3.9 改进了类型提示功能，支持使用内置集合类型作为泛型。"
    ]

    query = "Python 3.9 有什么新特性？"

    rag = RAGWithConsistencyCheck()
    result = rag.process_with_check(query, docs)

    print_result(result)


def test_case_2_contradictory():
    """
    测试用例2：矛盾的情况
    """
    print("\n" + "=" * 60)
    print("测试用例2：矛盾的情况（模拟）")
    print("=" * 60 + "\n")

    # 注意：这个测试用例是模拟的，实际 LLM 可能不会生成矛盾的答案
    # 我们直接构造一个矛盾的答案来测试检测功能

    docs = [
        "Python 3.9 于 2020 年 10 月 5 日发布。"
    ]

    # 模拟一个矛盾的答案
    answer = "Python 3.9 于 2021 年发布。"

    checker = ConsistencyChecker()
    scores = checker.check_single(docs[0], answer)

    print(f"[文档] {docs[0]}")
    print(f"[答案] {answer}\n")
    print(f"[检测结果]")
    print(f"  蕴含分数: {scores['entailment']:.2f}")
    print(f"  矛盾分数: {scores['contradiction']:.2f}")
    print(f"  中立分数: {scores['neutral']:.2f}\n")

    if scores['contradiction'] > 0.5:
        print("[判断] ✗ 检测到矛盾！")
    else:
        print("[判断] ✓ 未检测到明显矛盾")


def test_case_3_neutral():
    """
    测试用例3：中立的情况
    """
    print("\n" + "=" * 60)
    print("测试用例3：中立的情况")
    print("=" * 60 + "\n")

    docs = [
        "Python 3.9 于 2020 年 10 月 5 日发布。"
    ]

    answer = "Python 是一种流行的编程语言。"

    checker = ConsistencyChecker()
    scores = checker.check_single(docs[0], answer)

    print(f"[文档] {docs[0]}")
    print(f"[答案] {answer}\n")
    print(f"[检测结果]")
    print(f"  蕴含分数: {scores['entailment']:.2f}")
    print(f"  矛盾分数: {scores['contradiction']:.2f}")
    print(f"  中立分数: {scores['neutral']:.2f}\n")

    if scores['neutral'] > 0.5:
        print("[判断] ⚪ 答案与文档无关（中立）")


def test_case_4_sentence_level():
    """
    测试用例4：句子级别检测
    """
    print("\n" + "=" * 60)
    print("测试用例4：句子级别检测")
    print("=" * 60 + "\n")

    docs = [
        "Python 3.9 于 2020 年 10 月 5 日发布。",
        "Python 3.9 新增了字典合并运算符 |。"
    ]

    # 包含一个正确句子和一个可能不准确的句子
    answer = "Python 3.9 在 2020 年发布。新增了字典合并运算符。"

    checker = ConsistencyChecker()
    sentence_results = checker.check_sentence_level(answer, docs)

    print(f"[答案] {answer}\n")
    print(f"[句子级别检测结果]\n")

    for i, result in enumerate(sentence_results, 1):
        status = "✓" if result['is_consistent'] else "✗"
        print(f"句子{i}: {result['sentence']}")
        print(f"  {status} 蕴含分数: {result['entailment']:.2f}")
        print(f"  最佳匹配: 文档{result['best_doc_idx'] + 1}")
        print(f"  是否一致: {result['is_consistent']}\n")


# ===== 工具函数 =====
def print_result(result: Dict[str, any]):
    """
    打印检测结果

    Args:
        result: 检测结果字典
    """
    print("[最终结果]")
    print("=" * 60)
    print(f"状态: {result['status']}")
    print(f"消息: {result['message']}")
    print(f"一致性分数: {result['consistency_score']:.2f}")
    print(f"阈值: {result['threshold']}")
    print(f"\n原始答案:\n{result['answer']}")
    print(f"\n最终答案:\n{result['final_answer']}")

    print(f"\n句子级别检测:")
    for i, sent_result in enumerate(result['sentence_results'], 1):
        status = "✓" if sent_result['is_consistent'] else "✗"
        print(f"  {status} 句子{i}: {sent_result['sentence'][:50]}...")
        print(f"     一致性: {sent_result['entailment']:.2f}")

    print("=" * 60)


def save_result_to_json(result: Dict[str, any], filename: str = "consistency_check_result.json"):
    """
    保存检测结果到 JSON 文件

    Args:
        result: 检测结果
        filename: 文件名
    """
    # 添加时间戳
    result['timestamp'] = datetime.now().isoformat()

    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(result, f, ensure_ascii=False, indent=2)

    print(f"\n[保存] ✓ 结果已保存到 {filename}")


# ===== 主函数 =====
def main():
    """
    主函数：运行所有测试用例
    """
    print("\n" + "=" * 60)
    print("一致性检测实战示例")
    print("=" * 60 + "\n")

    # 检查环境变量
    if not Config.OPENAI_API_KEY:
        print("错误：未设置 OPENAI_API_KEY 环境变量")
        print("请运行：export OPENAI_API_KEY='your-api-key'")
        return

    # 运行测试用例
    try:
        # 测试用例1：完整的 RAG 流程（需要 API）
        test_case_1_consistent()

        # 测试用例2：矛盾检测（不需要 API）
        test_case_2_contradictory()

        # 测试用例3：中立检测（不需要 API）
        test_case_3_neutral()

        # 测试用例4：句子级别检测（不需要 API）
        test_case_4_sentence_level()

    except Exception as e:
        print(f"\n[错误] {str(e)}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
```

---

## 运行说明

### 1. 安装依赖

```bash
# 安装必需的库
pip install sentence-transformers openai

# 或使用 uv（推荐）
uv add sentence-transformers openai
```

### 2. 设置环境变量

```bash
# 设置 OpenAI API Key
export OPENAI_API_KEY='your-api-key-here'

# 可选：设置自定义 API 端点
export OPENAI_BASE_URL='https://your-proxy.com/v1'
```

### 3. 运行代码

```bash
python 09_实战代码_一致性检测.py
```

---

## 预期输出

```
============================================================
一致性检测实战示例
============================================================

[初始化] 加载 NLI 模型: cross-encoder/nli-deberta-v3-base
[初始化] ✓ 模型加载完成

[初始化] RAG 系统
[初始化] ✓ RAG 系统初始化完成

============================================================
测试用例1：一致的情况
============================================================

[查询] Python 3.9 有什么新特性？
[检索] 找到 3 个文档

[生成] 正在生成答案...
[生成] ✓ 答案生成完成

[检测] 正在进行一致性检测...
[检测] ✓ 一致性分数: 0.87

[检测] 正在进行句子级别检测...
[检测] ✓ 检测了 3 个句子

[最终结果]
============================================================
状态: approved
消息: 一致性检测通过
一致性分数: 0.87
阈值: 0.7

原始答案:
Python 3.9 于 2020 年 10 月 5 日发布，主要新特性包括：新增了字典合并运算符 |，可以方便地合并两个字典；改进了类型提示功能，支持使用内置集合类型作为泛型。

最终答案:
Python 3.9 于 2020 年 10 月 5 日发布，主要新特性包括：新增了字典合并运算符 |，可以方便地合并两个字典；改进了类型提示功能，支持使用内置集合类型作为泛型。

句子级别检测:
  ✓ 句子1: Python 3.9 于 2020 年 10 月 5 日发布，主要新特性包括：新增了字典合并运算符 |，可以方便地合并两个字典。...
     一致性: 0.88
  ✓ 句子2: 改进了类型提示功能，支持使用内置集合类型作为泛型。...
     一致性: 0.85
============================================================

============================================================
测试用例2：矛盾的情况（模拟）
============================================================

[文档] Python 3.9 于 2020 年 10 月 5 日发布。
[答案] Python 3.9 于 2021 年发布。

[检测结果]
  蕴含分数: 0.08
  矛盾分数: 0.78
  中立分数: 0.14

[判断] ✗ 检测到矛盾！

============================================================
测试用例3：中立的情况
============================================================

[文档] Python 3.9 于 2020 年 10 月 5 日发布。
[答案] Python 是一种流行的编程语言。

[检测结果]
  蕴含分数: 0.12
  矛盾分数: 0.05
  中立分数: 0.83

[判断] ⚪ 答案与文档无关（中立）

============================================================
测试用例4：句子级别检测
============================================================

[答案] Python 3.9 在 2020 年发布。新增了字典合并运算符。

[句子级别检测结果]

句子1: Python 3.9 在 2020 年发布。
  ✓ 蕴含分数: 0.85
  最佳匹配: 文档1
  是否一致: True

句子2: 新增了字典合并运算符。
  ✓ 蕴含分数: 0.82
  最佳匹配: 文档2
  是否一致: True
```

---

## 代码说明

### 核心组件

#### 1. ConsistencyChecker

**功能：** 使用 NLI 模型检测一致性

**关键方法：**
- `check_single()`: 检查单个文档与答案的一致性
- `check_multi()`: 检查多个文档与答案的一致性
- `check_sentence_level()`: 句子级别的一致性检测

#### 2. RAGWithConsistencyCheck

**功能：** 完整的 RAG 系统，集成一致性检测

**流程：**
1. 生成答案
2. 一致性检测
3. 句子级别检测
4. 根据分数决策

### 关键参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `CONSISTENCY_THRESHOLD` | 0.7 | 一致性阈值 |
| `HIGH_CONFIDENCE_THRESHOLD` | 0.85 | 高置信度阈值 |
| `LOW_CONFIDENCE_THRESHOLD` | 0.5 | 低置信度阈值 |

### 聚合方式

| 方式 | 说明 | 适用场景 |
|------|------|----------|
| `max` | 取最高蕴含分数 | 乐观策略，只要有一个文档支持就通过 |
| `mean` | 取平均分数 | 平衡策略，综合考虑所有文档 |
| `min` | 取最低蕴含分数 | 保守策略，所有文档都要支持 |

---

## 扩展建议

### 1. 添加缓存

```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def cached_check(doc_hash: str, answer_hash: str):
    return checker.check_single(doc, answer)
```

### 2. 批量检测

```python
def batch_check(answers: List[str], docs: List[str]):
    pairs = [(doc, answer) for answer in answers for doc in docs]
    scores = nli_model.predict(pairs)
    return scores
```

### 3. 异步检测

```python
import asyncio

async def async_check(answer: str, docs: List[str]):
    loop = asyncio.get_event_loop()
    result = await loop.run_in_executor(
        None,
        checker.check_multi,
        answer,
        docs
    )
    return result
```

### 4. 集成到生产环境

```python
# 添加日志
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 添加监控
from prometheus_client import Counter, Histogram

consistency_checks = Counter('consistency_checks_total', 'Total consistency checks')
consistency_score = Histogram('consistency_score', 'Consistency score distribution')
```

---

## 总结

**本示例展示了：**

1. ✅ 完整的一致性检测流程
2. ✅ 单文档和多文档检测
3. ✅ 句子级别的精细检测
4. ✅ 不同聚合策略的应用
5. ✅ 实际的决策逻辑

**关键要点：**

- NLI 模型可以有效检测矛盾
- 句子级别检测更精细
- 需要设置合理的阈值
- 不同场景使用不同策略

**下一步：**

- 学习引用溯源系统
- 学习多策略缓解
- 构建端到端 RAG 系统
