# 核心概念3：全局异常中间件

> 使用中间件实现统一的错误处理架构，类似 Express 的全局错误中间件

---

## 一句话定义

**全局异常中间件是在请求处理流程中拦截所有异常的机制，通过中间件统一处理错误响应格式、日志记录、告警通知等横切关注点。**

---

## 为什么需要全局异常中间件？

### 问题：异常处理器还不够统一

即使使用了 `@app.exception_handler()`，仍然存在一些问题：

```python
# 问题1：每个异常处理器都要写相同的日志逻辑
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    logger.error(f"参数错误: {exc}")  # 重复的日志逻辑
    return JSONResponse(status_code=400, content={"error": str(exc)})

@app.exception_handler(KeyError)
async def key_error_handler(request: Request, exc: KeyError):
    logger.error(f"键错误: {exc}")  # 重复的日志逻辑
    return JSONResponse(status_code=400, content={"error": str(exc)})

# 问题2：无法统一添加响应头
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": exc.detail}
        # 每个处理器都要手动添加 request_id、timestamp 等
    )
```

---

### 解决方案：全局异常中间件

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
import time
import uuid

class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    """全局异常处理中间件"""

    async def dispatch(self, request: Request, call_next):
        # 生成请求 ID
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        try:
            # 执行请求处理
            response = await call_next(request)

            # 添加统一的响应头
            response.headers["X-Request-ID"] = request_id
            return response

        except Exception as exc:
            # 统一处理所有异常
            logger.error(
                f"请求异常: {exc}",
                extra={
                    "request_id": request_id,
                    "path": request.url.path,
                    "method": request.method
                }
            )

            # 返回统一的错误响应
            return JSONResponse(
                status_code=500,
                content={
                    "error": "服务器内部错误",
                    "request_id": request_id,
                    "timestamp": time.time()
                }
            )

app = FastAPI()
app.add_middleware(ErrorHandlingMiddleware)
```

**优势：**
- 所有请求都经过中间件，统一处理
- 自动添加 request_id、timestamp 等
- 集中管理日志、告警、监控
- 不需要在每个异常处理器中重复代码

---

## 全局异常中间件的基本用法

### 1. 创建中间件类

```python
from starlette.middleware.base import BaseHTTPMiddleware

class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        try:
            response = await call_next(request)
            return response
        except Exception as exc:
            # 处理异常
            return JSONResponse(
                status_code=500,
                content={"error": str(exc)}
            )
```

---

### 2. 注册中间件

```python
app = FastAPI()
app.add_middleware(ErrorHandlingMiddleware)
```

**注意：** 中间件的注册顺序很重要，后注册的先执行。

---

### 3. 访问请求信息

```python
class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # 可以访问请求的所有信息
        path = request.url.path
        method = request.method
        client_ip = request.client.host

        try:
            response = await call_next(request)
            return response
        except Exception as exc:
            logger.error(f"{method} {path} 失败: {exc}")
            return JSONResponse(status_code=500, content={"error": "服务器错误"})
```

---

## 实战示例

### 示例1：统一错误响应格式

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from datetime import datetime
import uuid

class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    """统一错误响应格式"""

    async def dispatch(self, request: Request, call_next):
        # 生成请求 ID
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        try:
            response = await call_next(request)
            # 为所有响应添加 request_id
            response.headers["X-Request-ID"] = request_id
            return response

        except Exception as exc:
            # 统一的错误响应格式
            return JSONResponse(
                status_code=500,
                content={
                    "success": False,
                    "error": "服务器内部错误",
                    "request_id": request_id,
                    "timestamp": datetime.utcnow().isoformat(),
                    "path": request.url.path,
                    "method": request.method
                },
                headers={"X-Request-ID": request_id}
            )

app = FastAPI()
app.add_middleware(ErrorHandlingMiddleware)
```

---

### 示例2：记录请求日志和异常

```python
import logging
import time

logger = logging.getLogger(__name__)

class LoggingMiddleware(BaseHTTPMiddleware):
    """记录所有请求和异常"""

    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        # 记录请求开始
        start_time = time.time()
        logger.info(
            f"请求开始: {request.method} {request.url.path}",
            extra={"request_id": request_id}
        )

        try:
            response = await call_next(request)

            # 记录请求成功
            duration = time.time() - start_time
            logger.info(
                f"请求成功: {request.method} {request.url.path} "
                f"[{response.status_code}] {duration:.3f}s",
                extra={"request_id": request_id}
            )

            response.headers["X-Request-ID"] = request_id
            return response

        except Exception as exc:
            # 记录请求失败
            duration = time.time() - start_time
            logger.error(
                f"请求失败: {request.method} {request.url.path} "
                f"{duration:.3f}s - {exc}",
                extra={"request_id": request_id},
                exc_info=True
            )

            return JSONResponse(
                status_code=500,
                content={
                    "error": "服务器内部错误",
                    "request_id": request_id
                },
                headers={"X-Request-ID": request_id}
            )

app = FastAPI()
app.add_middleware(LoggingMiddleware)
```

---

### 示例3：区分不同类型的异常

```python
from fastapi import HTTPException
from sqlalchemy.exc import SQLAlchemyError
from openai import OpenAIError

class SmartErrorMiddleware(BaseHTTPMiddleware):
    """智能区分不同类型的异常"""

    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        try:
            response = await call_next(request)
            response.headers["X-Request-ID"] = request_id
            return response

        except HTTPException as exc:
            # HTTPException 已经有明确的状态码和错误信息
            return JSONResponse(
                status_code=exc.status_code,
                content={
                    "error": exc.detail,
                    "request_id": request_id
                },
                headers={"X-Request-ID": request_id}
            )

        except SQLAlchemyError as exc:
            # 数据库错误
            logger.error(f"数据库错误: {exc}", extra={"request_id": request_id})
            return JSONResponse(
                status_code=500,
                content={
                    "error": "数据库操作失败",
                    "code": "DATABASE_ERROR",
                    "request_id": request_id
                },
                headers={"X-Request-ID": request_id}
            )

        except OpenAIError as exc:
            # OpenAI API 错误
            logger.error(f"OpenAI 错误: {exc}", extra={"request_id": request_id})
            return JSONResponse(
                status_code=503,
                content={
                    "error": "AI 服务暂时不可用",
                    "code": "AI_SERVICE_ERROR",
                    "request_id": request_id
                },
                headers={"X-Request-ID": request_id}
            )

        except Exception as exc:
            # 其他未知错误
            logger.error(
                f"未知错误: {exc}",
                extra={"request_id": request_id},
                exc_info=True
            )
            return JSONResponse(
                status_code=500,
                content={
                    "error": "服务器内部错误",
                    "request_id": request_id
                },
                headers={"X-Request-ID": request_id}
            )

app = FastAPI()
app.add_middleware(SmartErrorMiddleware)
```

---

### 示例4：生产级错误处理中间件

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from datetime import datetime
import uuid
import time
import traceback
import logging

logger = logging.getLogger(__name__)

class ProductionErrorMiddleware(BaseHTTPMiddleware):
    """生产级错误处理中间件"""

    def __init__(self, app, debug: bool = False):
        super().__init__(app)
        self.debug = debug

    async def dispatch(self, request: Request, call_next):
        # 1. 生成请求 ID
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        # 2. 记录请求开始
        start_time = time.time()

        try:
            # 3. 执行请求
            response = await call_next(request)

            # 4. 记录成功请求
            duration = time.time() - start_time
            logger.info(
                f"{request.method} {request.url.path} [{response.status_code}] {duration:.3f}s",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "status_code": response.status_code,
                    "duration": duration
                }
            )

            # 5. 添加响应头
            response.headers["X-Request-ID"] = request_id
            return response

        except Exception as exc:
            # 6. 记录异常
            duration = time.time() - start_time
            logger.error(
                f"{request.method} {request.url.path} 失败: {exc}",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "duration": duration,
                    "exception_type": type(exc).__name__
                },
                exc_info=True
            )

            # 7. 构建错误响应
            error_response = {
                "success": False,
                "error": self._get_error_message(exc),
                "code": self._get_error_code(exc),
                "request_id": request_id,
                "timestamp": datetime.utcnow().isoformat()
            }

            # 8. 开发环境添加详细信息
            if self.debug:
                error_response["details"] = {
                    "exception_type": type(exc).__name__,
                    "exception_message": str(exc),
                    "traceback": traceback.format_exc()
                }

            # 9. 返回错误响应
            return JSONResponse(
                status_code=self._get_status_code(exc),
                content=error_response,
                headers={"X-Request-ID": request_id}
            )

    def _get_status_code(self, exc: Exception) -> int:
        """根据异常类型返回状态码"""
        if isinstance(exc, HTTPException):
            return exc.status_code
        elif isinstance(exc, SQLAlchemyError):
            return 500
        elif isinstance(exc, OpenAIError):
            return 503
        else:
            return 500

    def _get_error_code(self, exc: Exception) -> str:
        """根据异常类型返回错误码"""
        if isinstance(exc, HTTPException):
            return "HTTP_ERROR"
        elif isinstance(exc, SQLAlchemyError):
            return "DATABASE_ERROR"
        elif isinstance(exc, OpenAIError):
            return "AI_SERVICE_ERROR"
        else:
            return "INTERNAL_ERROR"

    def _get_error_message(self, exc: Exception) -> str:
        """根据异常类型返回错误信息"""
        if isinstance(exc, HTTPException):
            return exc.detail
        elif isinstance(exc, SQLAlchemyError):
            return "数据库操作失败"
        elif isinstance(exc, OpenAIError):
            return "AI 服务暂时不可用"
        else:
            return "服务器内部错误"

# 使用
app = FastAPI()
app.add_middleware(ProductionErrorMiddleware, debug=False)
```

---

## 中间件 vs 异常处理器

### 对比

| 特性 | 异常处理器 | 全局中间件 |
|------|-----------|-----------|
| 注册方式 | `@app.exception_handler()` | `app.add_middleware()` |
| 作用范围 | 特定异常类型 | 所有请求 |
| 执行时机 | 异常发生时 | 请求前后 |
| 访问请求 | 可以 | 可以 |
| 访问响应 | 不可以 | 可以 |
| 修改响应头 | 可以 | 可以 |
| 记录日志 | 需要每个处理器都写 | 统一处理 |
| 适用场景 | 精细化错误处理 | 统一横切关注点 |

---

### 组合使用

```python
# 1. 全局中间件：统一添加 request_id、记录日志
app.add_middleware(LoggingMiddleware)

# 2. 异常处理器：精细化处理特定异常
@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    return JSONResponse(
        status_code=404,
        content={"error": "用户不存在", "user_id": exc.user_id}
    )

@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_error_handler(request: Request, exc: SQLAlchemyError):
    return JSONResponse(
        status_code=500,
        content={"error": "数据库操作失败"}
    )
```

**执行顺序：**
```
请求 → 中间件 → 路由 → 异常处理器 → 中间件 → 响应
```

---

## 与 Express 的对比

### Express 错误中间件

```javascript
// Express: 全局错误中间件
app.use((err, req, res, next) => {
  // 记录日志
  console.error(err);

  // 返回错误响应
  res.status(err.status || 500).json({
    error: err.message,
    requestId: req.id
  });
});
```

### FastAPI 全局中间件

```python
# FastAPI: 全局异常中间件
class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        try:
            response = await call_next(request)
            return response
        except Exception as exc:
            logger.error(exc)
            return JSONResponse(
                status_code=500,
                content={"error": str(exc), "requestId": request.state.request_id}
            )

app.add_middleware(ErrorHandlingMiddleware)
```

**对比：**

| 特性 | Express | FastAPI |
|------|---------|---------|
| 注册方式 | `app.use((err, req, res, next) => {})` | `app.add_middleware(Middleware)` |
| 错误捕获 | 自动捕获 | 需要 try/except |
| 请求 ID | 需要手动添加 | 可以在中间件中添加 |
| 异步支持 | 需要 async/await | 原生支持 |

---

## 在 AI Agent 开发中的应用

### 场景1：统一添加 request_id 用于追踪

```python
class RequestTrackingMiddleware(BaseHTTPMiddleware):
    """为每个请求添加 request_id，用于追踪 AI 对话"""

    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        try:
            response = await call_next(request)
            response.headers["X-Request-ID"] = request_id
            return response
        except Exception as exc:
            logger.error(f"请求 {request_id} 失败: {exc}")
            return JSONResponse(
                status_code=500,
                content={"error": "服务器错误", "request_id": request_id}
            )

app.add_middleware(RequestTrackingMiddleware)

# 在路由中使用 request_id
@app.post("/chat")
async def chat(request: Request, message: str):
    request_id = request.state.request_id
    logger.info(f"[{request_id}] 用户消息: {message}")

    response = await llm.generate(message)

    logger.info(f"[{request_id}] AI 回复: {response}")
    return {"reply": response, "request_id": request_id}
```

---

### 场景2：记录 LLM 调用的详细日志

```python
class LLMLoggingMiddleware(BaseHTTPMiddleware):
    """记录所有 LLM 相关请求的详细日志"""

    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        # 只记录 LLM 相关的路由
        if request.url.path.startswith("/chat") or request.url.path.startswith("/generate"):
            start_time = time.time()

            try:
                response = await call_next(request)
                duration = time.time() - start_time

                # 记录成功的 LLM 调用
                logger.info(
                    f"LLM 调用成功",
                    extra={
                        "request_id": request_id,
                        "path": request.url.path,
                        "duration": duration,
                        "status_code": response.status_code
                    }
                )

                response.headers["X-Request-ID"] = request_id
                return response

            except Exception as exc:
                duration = time.time() - start_time

                # 记录失败的 LLM 调用
                logger.error(
                    f"LLM 调用失败: {exc}",
                    extra={
                        "request_id": request_id,
                        "path": request.url.path,
                        "duration": duration,
                        "exception_type": type(exc).__name__
                    }
                )

                return JSONResponse(
                    status_code=503,
                    content={
                        "error": "AI 服务暂时不可用",
                        "request_id": request_id
                    }
                )
        else:
            # 非 LLM 路由，正常处理
            response = await call_next(request)
            return response

app.add_middleware(LLMLoggingMiddleware)
```

---

## 最佳实践

### 1. 中间件顺序很重要

```python
# ✅ 正确的顺序
app.add_middleware(CORSMiddleware)  # 最外层：CORS
app.add_middleware(LoggingMiddleware)  # 记录日志
app.add_middleware(ErrorHandlingMiddleware)  # 错误处理

# 执行顺序：CORS → Logging → ErrorHandling → 路由 → ErrorHandling → Logging → CORS
```

---

### 2. 避免在中间件中做耗时操作

```python
# ❌ 差：在中间件中做耗时操作
class SlowMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # 耗时操作会阻塞所有请求
        await asyncio.sleep(1)
        response = await call_next(request)
        return response

# ✅ 好：只做必要的操作
class FastMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id
        response = await call_next(request)
        response.headers["X-Request-ID"] = request_id
        return response
```

---

### 3. 生产环境不要暴露详细错误

```python
# ✅ 好：根据环境返回不同的错误信息
class ErrorMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, debug: bool = False):
        super().__init__(app)
        self.debug = debug

    async def dispatch(self, request: Request, call_next):
        try:
            response = await call_next(request)
            return response
        except Exception as exc:
            logger.error(f"错误: {exc}", exc_info=True)

            if self.debug:
                # 开发环境：返回详细错误
                return JSONResponse(
                    status_code=500,
                    content={
                        "error": str(exc),
                        "traceback": traceback.format_exc()
                    }
                )
            else:
                # 生产环境：返回通用错误
                return JSONResponse(
                    status_code=500,
                    content={"error": "服务器内部错误"}
                )

# 使用
app.add_middleware(ErrorMiddleware, debug=settings.DEBUG)
```

---

## 小结

**全局异常中间件的核心价值：**

1. **统一处理**：所有请求都经过中间件，统一添加 request_id、timestamp 等
2. **集中管理**：日志、告警、监控等横切关注点集中在一个地方
3. **灵活扩展**：可以轻松添加新的功能（如限流、认证等）
4. **生产可靠**：统一的错误响应格式，便于前端解析和用户理解

**三层异常处理架构：**
```
HTTPException（快速抛错）
    ↓
exception_handler（精细化处理）
    ↓
全局中间件（统一横切关注点）
```

---

**相关文档：**
- [Starlette 中间件文档](https://www.starlette.io/middleware/)
- [FastAPI 中间件指南](https://fastapi.tiangolo.com/tutorial/middleware/)
