# docker-compose编排 - 最小可用

掌握以下内容，就能开始使用 docker-compose：

---

## 4.1 基础配置结构

**核心：** docker-compose.yml 的三大核心部分

```yaml
version: '3.8'  # 版本号（可选，推荐 3.8）

services:       # 服务定义（必需）
  api:
    image: my-api
    ports:
      - "8000:8000"

volumes:        # 数据卷定义（可选）
  data:

networks:       # 网络定义（可选）
  default:
```

**前端类比：**
```json
// package.json 的基础结构
{
  "name": "my-project",      // version
  "scripts": {...},          // services
  "dependencies": {...},     // volumes
  "devDependencies": {...}   // networks
}
```

**最小可用示例：**
```yaml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
```

**这就够了！** 可以启动一个 FastAPI 应用。

---

## 4.2 服务定义（Services）

**核心：** 每个服务 = 一个容器

```yaml
services:
  api:
    # 方式1：使用现有镜像
    image: python:3.13-slim

    # 方式2：构建镜像
    build: .

    # 方式3：指定 Dockerfile 路径
    build:
      context: .
      dockerfile: Dockerfile.dev

    # 端口映射（主机:容器）
    ports:
      - "8000:8000"

    # 环境变量
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb

    # 依赖关系
    depends_on:
      - db
```

**前端类比：**
```javascript
// Express 应用配置
const app = express();
app.listen(8000);  // ports

process.env.DATABASE_URL;  // environment

// 启动前等待数据库连接
await connectDB();  // depends_on
```

**实际应用：**
```yaml
# AI Agent API 服务
services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - DATABASE_URL=postgresql://user:pass@db:5432/agent_db
    depends_on:
      - db
```

---

## 4.3 依赖管理（Depends_on）

**核心：** 控制启动顺序

```yaml
services:
  api:
    depends_on:
      - db      # 简单依赖：等待容器启动

  db:
    image: postgres:14-alpine
```

**问题：** `depends_on` 只等待容器启动，不等待服务就绪！

**解决：** 使用健康检查

```yaml
services:
  api:
    depends_on:
      db:
        condition: service_healthy  # 等待健康检查通过

  db:
    image: postgres:14-alpine
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
      timeout: 3s
      retries: 5
```

**前端类比：**
```javascript
// 简单依赖（不推荐）
async function startApp() {
  await startDB();  // 只等待启动，不等待就绪
  await startAPI();
}

// 健康检查（推荐）
async function startApp() {
  await startDB();
  await waitForDBReady();  // 等待就绪
  await startAPI();
}
```

**实际应用：**
```yaml
# AI Agent 开发环境
services:
  api:
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started

  db:
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s

  redis:
    image: redis:7-alpine
```

---

## 4.4 数据持久化（Volumes）

**核心：** 容器删除后数据不丢失

**两种方式：**

### 方式1：命名卷（推荐用于数据库）

```yaml
services:
  db:
    image: postgres:14-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 命名卷

volumes:
  postgres_data:  # 定义命名卷
```

**特点：**
- ✅ Docker 管理，跨平台兼容
- ✅ 性能好
- ✅ 适合生产环境

### 方式2：绑定挂载（推荐用于开发）

```yaml
services:
  api:
    volumes:
      - .:/app  # 绑定挂载（主机路径:容器路径）
```

**特点：**
- ✅ 直接映射主机目录
- ✅ 代码修改立即生效（热重载）
- ✅ 适合开发环境

**前端类比：**
```javascript
// 命名卷 = localStorage（浏览器管理）
localStorage.setItem('data', value);

// 绑定挂载 = 直接读写文件（直接访问）
fs.writeFileSync('./data.json', value);
```

**实际应用：**
```yaml
services:
  # API：代码热重载
  api:
    volumes:
      - .:/app  # 绑定挂载

  # 数据库：数据持久化
  db:
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 命名卷

volumes:
  postgres_data:
```

---

## 4.5 环境变量管理

**核心：** 配置与代码分离

**三种方式：**

### 方式1：直接定义

```yaml
services:
  api:
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
      - REDIS_URL=redis://redis:6379
```

### 方式2：引用 .env 文件

```yaml
services:
  api:
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
```

**.env 文件：**
```bash
DATABASE_URL=postgresql://user:pass@db:5432/mydb
OPENAI_API_KEY=sk-xxx
```

### 方式3：env_file

```yaml
services:
  api:
    env_file:
      - .env
      - .env.local
```

**前端类比：**
```javascript
// 方式1：直接定义
const config = {
  databaseUrl: 'postgresql://...'
};

// 方式2：环境变量
const config = {
  databaseUrl: process.env.DATABASE_URL
};

// 方式3：配置文件
import config from './config.json';
```

**实际应用：**
```yaml
# docker-compose.yml
services:
  api:
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
```

**.env 文件：**
```bash
# 数据库配置
DATABASE_URL=postgresql://user:pass@db:5432/agent_db

# API 密钥（敏感信息）
OPENAI_API_KEY=sk-xxx

# 应用配置
DEBUG=true
LOG_LEVEL=info
```

---

## 常用命令速查

### 启动和停止

```bash
# 启动所有服务（前台）
docker-compose up

# 启动所有服务（后台）
docker-compose up -d

# 停止所有服务
docker-compose down

# 停止并删除数据卷
docker-compose down -v
```

### 查看状态

```bash
# 查看运行中的服务
docker-compose ps

# 查看日志
docker-compose logs

# 查看特定服务的日志
docker-compose logs api

# 实时查看日志
docker-compose logs -f
```

### 重启和重建

```bash
# 重启服务
docker-compose restart

# 重启特定服务
docker-compose restart api

# 重建镜像
docker-compose build

# 重建并启动
docker-compose up --build
```

### 执行命令

```bash
# 在运行中的容器执行命令
docker-compose exec api bash

# 在新容器中执行命令
docker-compose run api python manage.py migrate
```

---

## 最小可用完整示例

### 场景：FastAPI + PostgreSQL 开发环境

**项目结构：**
```
my-ai-agent/
├── docker-compose.yml
├── Dockerfile
├── .env
├── requirements.txt
└── app/
    └── main.py
```

**docker-compose.yml：**
```yaml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - .:/app
    command: uvicorn app.main:app --host 0.0.0.0 --reload

  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
      timeout: 3s
      retries: 5

volumes:
  postgres_data:
```

**Dockerfile：**
```dockerfile
FROM python:3.13-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0"]
```

**app/main.py：**
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello from AI Agent API"}

@app.get("/health")
async def health():
    return {"status": "healthy"}
```

**使用：**
```bash
# 1. 启动环境
docker-compose up

# 2. 访问 API
curl http://localhost:8000

# 3. 查看日志
docker-compose logs -f

# 4. 停止环境
docker-compose down
```

---

## 这些知识足以：

1. ✅ **搭建本地开发环境**
   - FastAPI + PostgreSQL
   - 代码热重载
   - 数据持久化

2. ✅ **管理多个服务**
   - 定义服务依赖
   - 配置健康检查
   - 控制启动顺序

3. ✅ **环境配置管理**
   - 使用环境变量
   - 分离敏感信息
   - 支持多环境

4. ✅ **日常开发操作**
   - 启动/停止服务
   - 查看日志
   - 重建镜像

5. ✅ **为后续学习打基础**
   - 理解核心概念
   - 掌握基本配置
   - 能够独立实践

---

## 下一步学习

**已掌握：** 20% 的核心知识

**可以做：** 80% 的日常开发任务

**进阶学习：**
1. 网络配置（自定义网络、服务发现）
2. 资源限制（CPU、内存限制）
3. 多环境配置（开发/测试/生产）
4. 日志管理（日志驱动、日志聚合）
5. 生产优化（优雅关闭、监控集成）

---

## 常见问题

### Q1: 为什么修改代码后没有生效？

**A:** 检查是否配置了代码热重载：

```yaml
services:
  api:
    volumes:
      - .:/app  # 映射代码目录
    command: uvicorn app.main:app --reload  # 启用热重载
```

### Q2: 数据库数据丢失了怎么办？

**A:** 确保使用了命名卷：

```yaml
services:
  db:
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 命名卷

volumes:
  postgres_data:  # 定义卷
```

**注意：** `docker-compose down -v` 会删除数据卷！

### Q3: 如何查看容器内部？

**A:** 使用 exec 命令：

```bash
# 进入容器
docker-compose exec api bash

# 查看数据库
docker-compose exec db psql -U user -d mydb
```

### Q4: 如何只启动部分服务？

**A:** 指定服务名：

```bash
# 只启动 API 和数据库
docker-compose up api db

# 只启动数据库
docker-compose up db
```

### Q5: 如何清理所有容器和数据？

**A:** 使用 down 命令：

```bash
# 停止并删除容器
docker-compose down

# 停止并删除容器和数据卷
docker-compose down -v

# 停止并删除容器、数据卷、镜像
docker-compose down -v --rmi all
```

---

**版本：** v1.0
**最后更新：** 2026-02-12
**预计学习时间：** 30-60 分钟
