# 核心概念 05：状态持久化机制

> 深入理解 Agent Core 如何使用 JSONL 格式实现状态持久化和分支管理

---

## 概念定义

**状态持久化机制**是指 Agent Core 将对话历史、工具调用记录和执行状态保存到磁盘的机制，使用 JSONL（JSON Lines）格式实现追加写入、树形分支和跨 Provider 可移植。

**一句话：** 状态持久化就是把 Agent 的"记忆"写入文件，支持恢复、分支和迁移。

---

## JSONL 格式详解

### 什么是 JSONL？

**JSONL（JSON Lines）** = 每行一个 JSON 对象

```jsonl
{"id":"msg-1","type":"user","content":"创建 hello.ts"}
{"id":"msg-2","type":"assistant","content":"我来创建文件"}
{"id":"msg-3","type":"tool","name":"write","params":{"path":"hello.ts"}}
{"id":"msg-4","type":"tool_result","output":"File created"}
```

**与 JSON 的对比：**

```json
// JSON 格式（单个对象）
{
  "messages": [
    {"id":"msg-1","type":"user","content":"创建 hello.ts"},
    {"id":"msg-2","type":"assistant","content":"我来创建文件"},
    {"id":"msg-3","type":"tool","name":"write","params":{"path":"hello.ts"}},
    {"id":"msg-4","type":"tool_result","output":"File created"}
  ]
}

// JSONL 格式（每行一个对象）
{"id":"msg-1","type":"user","content":"创建 hello.ts"}
{"id":"msg-2","type":"assistant","content":"我来创建文件"}
{"id":"msg-3","type":"tool","name":"write","params":{"path":"hello.ts"}}
{"id":"msg-4","type":"tool_result","output":"File created"}
```

---

### JSONL 的优势

**1. 追加写入 O(1)**

```typescript
// JSON：需要重写整个文件 O(n)
const data = JSON.parse(fs.readFileSync('session.json'));
data.messages.push(newMessage);
fs.writeFileSync('session.json', JSON.stringify(data));

// JSONL：直接追加一行 O(1)
fs.appendFileSync('session.jsonl', JSON.stringify(newMessage) + '\n');
```

**性能对比：**
- 100 条消息：JSON 重写 ~10ms，JSONL 追加 ~0.1ms
- 1000 条消息：JSON 重写 ~100ms，JSONL 追加 ~0.1ms
- 10000 条消息：JSON 重写 ~1000ms，JSONL 追加 ~0.1ms

---

**2. 完整历史保留**

```jsonl
// JSONL 是追加日志，永不删除
{"id":"msg-1","content":"创建文件","timestamp":1708300000}
{"id":"msg-2","content":"文件已创建","timestamp":1708300001}
{"id":"msg-3","content":"修改文件","timestamp":1708300002}
{"id":"msg-4","content":"文件已修改","timestamp":1708300003}

// 可以完整回放 Agent 的思考过程
// 支持时间旅行调试
```

---

**3. 树形结构支持**

```jsonl
// 主线
{"id":"msg-1","content":"创建文件"}
{"id":"msg-2","parentId":"msg-1","content":"文件已创建"}

// 分支（从 msg-1 分叉）
{"id":"msg-3","parentId":"msg-1","content":"改用 TypeScript"}
{"id":"msg-4","parentId":"msg-3","content":"TypeScript 文件已创建"}

// 单文件存储多个分支！
```

---

**4. 易于解析**

```typescript
// 逐行读取，不需要加载整个文件
const lines = fs.readFileSync('session.jsonl', 'utf-8').split('\n');
for (const line of lines) {
  if (line.trim()) {
    const entry = JSON.parse(line);
    console.log(entry);
  }
}

// 或使用流式读取（内存友好）
const stream = fs.createReadStream('session.jsonl');
const rl = readline.createInterface({ input: stream });
for await (const line of rl) {
  const entry = JSON.parse(line);
  // 处理每个条目
}
```

---

## Session 文件结构

### Session Entry 类型

```typescript
// Session 条目的基础接口
interface SessionEntry {
  id: string;              // 唯一标识
  parentId?: string;       // 父条目 ID（用于分支）
  timestamp: number;       // 时间戳
  type: EntryType;         // 条目类型
}

// 条目类型
type EntryType =
  | 'user'           // 用户消息
  | 'assistant'      // 助手响应
  | 'tool'           // 工具调用
  | 'tool_result'    // 工具结果
  | 'system'         // 系统消息
  | 'metadata';      // 元数据
```

---

### 用户消息

```typescript
interface UserEntry extends SessionEntry {
  type: 'user';
  content: string;         // 用户输入
  metadata?: {
    source?: string;       // 来源（cli, web, api）
    userId?: string;       // 用户 ID
  };
}

// 示例
{
  "id": "msg-1",
  "type": "user",
  "content": "创建 hello.ts",
  "timestamp": 1708300000,
  "metadata": {
    "source": "cli",
    "userId": "user-123"
  }
}
```

---

### 助手响应

```typescript
interface AssistantEntry extends SessionEntry {
  type: 'assistant';
  content: string;         // 助手回复
  toolCalls?: ToolCall[];  // 工具调用（如果有）
  thinking?: string;       // 思考过程（Anthropic 特有）
}

// 示例
{
  "id": "msg-2",
  "parentId": "msg-1",
  "type": "assistant",
  "content": "我来创建文件",
  "timestamp": 1708300001,
  "toolCalls": [
    {
      "id": "call-1",
      "name": "write",
      "params": {
        "path": "hello.ts",
        "content": "console.log('hello')"
      }
    }
  ]
}
```

---

### 工具调用

```typescript
interface ToolEntry extends SessionEntry {
  type: 'tool';
  name: string;            // 工具名称
  params: any;             // 工具参数
  toolCallId: string;      // 关联的工具调用 ID
}

// 示例
{
  "id": "msg-3",
  "parentId": "msg-2",
  "type": "tool",
  "name": "write",
  "params": {
    "path": "hello.ts",
    "content": "console.log('hello')"
  },
  "toolCallId": "call-1",
  "timestamp": 1708300002
}
```

---

### 工具结果

```typescript
interface ToolResultEntry extends SessionEntry {
  type: 'tool_result';
  toolCallId: string;      // 关联的工具调用 ID
  output: string;          // 返回给 LLM 的内容
  details?: any;           // 返回给 UI 的详细信息
  success: boolean;        // 是否成功
}

// 示例
{
  "id": "msg-4",
  "parentId": "msg-3",
  "type": "tool_result",
  "toolCallId": "call-1",
  "output": "File written: hello.ts",
  "details": {
    "path": "hello.ts",
    "bytes": 23,
    "lines": 1
  },
  "success": true,
  "timestamp": 1708300003
}
```

---

## 追加写入实现

### Session Writer 类

```typescript
class SessionWriter {
  private filePath: string;
  private writeStream: fs.WriteStream;

  constructor(sessionId: string) {
    this.filePath = path.join(SESSION_DIR, `${sessionId}.jsonl`);
    this.writeStream = fs.createWriteStream(this.filePath, { flags: 'a' });
  }

  // 追加条目
  append(entry: SessionEntry): void {
    const line = JSON.stringify(entry) + '\n';
    this.writeStream.write(line);
  }

  // 追加用户消息
  appendUser(content: string, parentId?: string): string {
    const entry: UserEntry = {
      id: generateId(),
      parentId,
      type: 'user',
      content,
      timestamp: Date.now()
    };
    this.append(entry);
    return entry.id;
  }

  // 追加助手响应
  appendAssistant(
    content: string,
    parentId: string,
    toolCalls?: ToolCall[]
  ): string {
    const entry: AssistantEntry = {
      id: generateId(),
      parentId,
      type: 'assistant',
      content,
      toolCalls,
      timestamp: Date.now()
    };
    this.append(entry);
    return entry.id;
  }

  // 追加工具调用
  appendTool(
    name: string,
    params: any,
    toolCallId: string,
    parentId: string
  ): string {
    const entry: ToolEntry = {
      id: generateId(),
      parentId,
      type: 'tool',
      name,
      params,
      toolCallId,
      timestamp: Date.now()
    };
    this.append(entry);
    return entry.id;
  }

  // 追加工具结果
  appendToolResult(
    toolCallId: string,
    output: string,
    details: any,
    success: boolean,
    parentId: string
  ): string {
    const entry: ToolResultEntry = {
      id: generateId(),
      parentId,
      type: 'tool_result',
      toolCallId,
      output,
      details,
      success,
      timestamp: Date.now()
    };
    this.append(entry);
    return entry.id;
  }

  // 关闭写入流
  close(): void {
    this.writeStream.end();
  }
}
```

---

### 使用示例

```typescript
// 创建 Session Writer
const writer = new SessionWriter('session-123');

// 追加用户消息
const userId = writer.appendUser('创建 hello.ts');

// 追加助手响应
const assistantId = writer.appendAssistant(
  '我来创建文件',
  userId,
  [{ id: 'call-1', name: 'write', params: {...} }]
);

// 追加工具调用
const toolId = writer.appendTool(
  'write',
  { path: 'hello.ts', content: "console.log('hello')" },
  'call-1',
  assistantId
);

// 追加工具结果
writer.appendToolResult(
  'call-1',
  'File written: hello.ts',
  { path: 'hello.ts', bytes: 23 },
  true,
  toolId
);

// 关闭
writer.close();
```

---

## 树形分支实现

### 分支的概念

**分支**是指从某个历史点开始的新对话路径。

```
主线：
msg-1 (用户) → msg-2 (助手) → msg-3 (工具) → msg-4 (结果)

分支（从 msg-2 分叉）：
msg-1 (用户) → msg-2 (助手) → msg-5 (用户，parentId=msg-2)
                              → msg-6 (助手，parentId=msg-5)
```

---

### 分支实现

```typescript
// JSONL 文件内容
{"id":"msg-1","type":"user","content":"创建文件"}
{"id":"msg-2","parentId":"msg-1","type":"assistant","content":"文件已创建"}
{"id":"msg-3","parentId":"msg-2","type":"user","content":"修改文件"}
{"id":"msg-4","parentId":"msg-3","type":"assistant","content":"文件已修改"}

// 创建分支（从 msg-2 分叉）
{"id":"msg-5","parentId":"msg-2","type":"user","content":"改用 TypeScript"}
{"id":"msg-6","parentId":"msg-5","type":"assistant","content":"TypeScript 文件已创建"}

// 树形结构：
//        msg-1
//          |
//        msg-2
//        /   \
//    msg-3   msg-5
//      |       |
//    msg-4   msg-6
```

---

### 分支管理类

```typescript
class SessionBranch {
  private entries: Map<string, SessionEntry>;
  private children: Map<string, string[]>;  // parentId → childIds

  constructor(entries: SessionEntry[]) {
    this.entries = new Map();
    this.children = new Map();

    // 构建索引
    for (const entry of entries) {
      this.entries.set(entry.id, entry);

      if (entry.parentId) {
        if (!this.children.has(entry.parentId)) {
          this.children.set(entry.parentId, []);
        }
        this.children.get(entry.parentId)!.push(entry.id);
      }
    }
  }

  // 获取某个条目的所有子条目
  getChildren(entryId: string): SessionEntry[] {
    const childIds = this.children.get(entryId) || [];
    return childIds.map(id => this.entries.get(id)!);
  }

  // 获取从根到某个条目的路径
  getPath(entryId: string): SessionEntry[] {
    const path: SessionEntry[] = [];
    let currentId: string | undefined = entryId;

    while (currentId) {
      const entry = this.entries.get(currentId);
      if (!entry) break;

      path.unshift(entry);
      currentId = entry.parentId;
    }

    return path;
  }

  // 获取所有分支点（有多个子节点的条目）
  getBranchPoints(): SessionEntry[] {
    const branchPoints: SessionEntry[] = [];

    for (const [parentId, childIds] of this.children.entries()) {
      if (childIds.length > 1) {
        const entry = this.entries.get(parentId);
        if (entry) {
          branchPoints.push(entry);
        }
      }
    }

    return branchPoints;
  }

  // 获取所有叶子节点（没有子节点的条目）
  getLeaves(): SessionEntry[] {
    const leaves: SessionEntry[] = [];

    for (const entry of this.entries.values()) {
      const childIds = this.children.get(entry.id) || [];
      if (childIds.length === 0) {
        leaves.push(entry);
      }
    }

    return leaves;
  }

  // 创建新分支
  createBranch(fromEntryId: string, newEntry: SessionEntry): void {
    newEntry.parentId = fromEntryId;
    this.entries.set(newEntry.id, newEntry);

    if (!this.children.has(fromEntryId)) {
      this.children.set(fromEntryId, []);
    }
    this.children.get(fromEntryId)!.push(newEntry.id);
  }
}
```

---

### 分支使用示例

```typescript
// 加载 Session
const entries = loadSession('session-123.jsonl');
const branch = new SessionBranch(entries);

// 获取分支点
const branchPoints = branch.getBranchPoints();
console.log('分支点:', branchPoints.map(e => e.id));
// ['msg-2']

// 获取 msg-2 的所有子节点
const children = branch.getChildren('msg-2');
console.log('子节点:', children.map(e => e.id));
// ['msg-3', 'msg-5']

// 获取从根到 msg-4 的路径
const path = branch.getPath('msg-4');
console.log('路径:', path.map(e => e.id));
// ['msg-1', 'msg-2', 'msg-3', 'msg-4']

// 创建新分支
branch.createBranch('msg-2', {
  id: 'msg-7',
  type: 'user',
  content: '删除文件',
  timestamp: Date.now()
});
```

---

## Context 对象结构

### Context 的作用

**Context** 是 Agent 的"工作记忆"，包含当前对话的所有消息。

```typescript
interface Context {
  messages: Message[];     // 消息数组
  metadata?: {
    sessionId: string;     // Session ID
    provider: string;      // LLM Provider
    model: string;         // 模型名称
    startTime: number;     // 开始时间
  };
}

interface Message {
  role: 'user' | 'assistant' | 'tool';
  content: string;
  toolCalls?: ToolCall[];
  toolCallId?: string;
}
```

---

### Context 与 Session 的关系

```
Session（持久化）          Context（内存）
┌─────────────────┐       ┌─────────────────┐
│ JSONL 文件       │  →   │ Message 数组     │
│ (完整历史)       │       │ (当前对话)       │
└─────────────────┘       └─────────────────┘

Session 包含：              Context 包含：
- 所有历史消息              - 当前分支的消息
- 所有分支                  - 用于 LLM 调用
- 元数据                    - 动态更新
```

---

### 从 Session 构建 Context

```typescript
function buildContext(
  sessionPath: string,
  branchLeafId?: string
): Context {
  // 1. 加载 Session
  const entries = loadSession(sessionPath);
  const branch = new SessionBranch(entries);

  // 2. 确定叶子节点
  const leafId = branchLeafId || branch.getLeaves()[0].id;

  // 3. 获取从根到叶子的路径
  const path = branch.getPath(leafId);

  // 4. 转换为 Message 格式
  const messages: Message[] = [];

  for (const entry of path) {
    if (entry.type === 'user') {
      messages.push({
        role: 'user',
        content: entry.content
      });
    } else if (entry.type === 'assistant') {
      messages.push({
        role: 'assistant',
        content: entry.content,
        toolCalls: entry.toolCalls
      });
    } else if (entry.type === 'tool_result') {
      messages.push({
        role: 'tool',
        content: entry.output,
        toolCallId: entry.toolCallId
      });
    }
  }

  return {
    messages,
    metadata: {
      sessionId: path.basename(sessionPath, '.jsonl'),
      provider: 'anthropic',
      model: 'claude-opus-4',
      startTime: path[0].timestamp
    }
  };
}
```

---

## 实际应用场景

### 场景 1：新会话

```typescript
// 创建新 Session
const sessionId = generateSessionId();
const writer = new SessionWriter(sessionId);

// 用户消息
const userId = writer.appendUser('创建 hello.ts');

// 助手响应
const assistantId = writer.appendAssistant(
  '我来创建文件',
  userId,
  [{ id: 'call-1', name: 'write', params: {...} }]
);

// 工具执行
const toolId = writer.appendTool('write', {...}, 'call-1', assistantId);
writer.appendToolResult('call-1', 'File created', {...}, true, toolId);

// Session 文件：~/.pi/sessions/{sessionId}.jsonl
```

---

### 场景 2：恢复会话

```typescript
// 加载现有 Session
const context = buildContext('~/.pi/sessions/session-123.jsonl');

// 继续对话
const agent = new Agent({
  provider,
  context: context.messages  // 恢复上下文
});

// 新消息会追加到同一个 JSONL 文件
```

---

### 场景 3：创建分支

```typescript
// 用户想尝试不同方案
// 从 msg-2 创建分支

// 主线：msg-1 → msg-2 → msg-3 → msg-4
// 分支：msg-1 → msg-2 → msg-5 → msg-6

const writer = new SessionWriter('session-123');

// 追加分支消息（parentId 指向 msg-2）
const branchUserId = writer.appendUser('改用 TypeScript', 'msg-2');
const branchAssistantId = writer.appendAssistant(
  'TypeScript 文件已创建',
  branchUserId
);

// 同一个文件，多个分支！
```

---

### 场景 4：时间旅行调试

```typescript
// 回到历史某个时刻
const context = buildContext('session-123.jsonl', 'msg-2');

// Context 只包含 msg-1 和 msg-2
// 可以从这个点重新开始
```

---

## 性能优化

### 1. 批量写入

```typescript
class SessionWriter {
  private buffer: SessionEntry[] = [];
  private bufferSize = 10;

  append(entry: SessionEntry): void {
    this.buffer.push(entry);

    if (this.buffer.length >= this.bufferSize) {
      this.flush();
    }
  }

  flush(): void {
    if (this.buffer.length === 0) return;

    const lines = this.buffer.map(e => JSON.stringify(e) + '\n').join('');
    this.writeStream.write(lines);
    this.buffer = [];
  }

  close(): void {
    this.flush();
    this.writeStream.end();
  }
}
```

---

### 2. 索引缓存

```typescript
class SessionIndex {
  private index: Map<string, number>;  // id → line number

  constructor(sessionPath: string) {
    this.index = new Map();
    this.buildIndex(sessionPath);
  }

  private buildIndex(sessionPath: string): void {
    const lines = fs.readFileSync(sessionPath, 'utf-8').split('\n');
    lines.forEach((line, index) => {
      if (line.trim()) {
        const entry = JSON.parse(line);
        this.index.set(entry.id, index);
      }
    });
  }

  getLineNumber(entryId: string): number | undefined {
    return this.index.get(entryId);
  }
}
```

---

### 3. 流式读取

```typescript
async function* streamSession(sessionPath: string): AsyncGenerator<SessionEntry> {
  const stream = fs.createReadStream(sessionPath);
  const rl = readline.createInterface({ input: stream });

  for await (const line of rl) {
    if (line.trim()) {
      yield JSON.parse(line);
    }
  }
}

// 使用
for await (const entry of streamSession('session-123.jsonl')) {
  console.log(entry);
  // 不需要一次性加载整个文件
}
```

---

## 总结

**状态持久化机制的核心要点：**

1. **JSONL 格式**：每行一个 JSON 对象，追加写入 O(1)
2. **追加日志**：永不删除，保留完整历史
3. **树形分支**：通过 parentId 实现分支，单文件存储
4. **Context 构建**：从 Session 提取当前分支的消息
5. **性能优化**：批量写入、索引缓存、流式读取

**关键洞察：**
- JSONL 是追加日志，不是数据库
- 树形结构通过 parentId 实现，无需多文件
- Session 是持久化，Context 是工作记忆
- 追加写入 O(1) 性能优于 JSON 重写 O(n)

**下一步：** 理解状态持久化后，学习状态恢复与迁移（核心概念 06）。
