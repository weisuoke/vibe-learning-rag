# 实战代码 - 场景2：技术文档检索

> 使用摘要链实现技术文档的全局理解和精准检索

---

## 场景描述

**需求**：构建一个技术文档检索系统，支持对长篇技术文档（20K-100K tokens）进行全局理解和问答。

**挑战**：
- 技术文档内容密集，需要全局理解
- 用户查询可能涉及多个章节的综合信息
- 直接塞入全文会超出上下文窗口或引发Context Rot

**解决方案**：使用摘要链（Summary Chain）

---

## 完整实现

### 步骤1：环境准备

```python
# 安装依赖
# uv add langchain langchain-openai chromadb pypdf python-dotenv

from langchain_openai import ChatOpenAI
from langchain.chains.summarize import load_summarize_chain
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.docstore.document import Document
from langchain.prompts import PromptTemplate
from dotenv import load_dotenv
from typing import List, Dict
import os

# 加载环境变量
load_dotenv()
```

### 步骤2：技术文档加载

```python
class TechDocLoader:
    """技术文档加载器"""

    def __init__(self, doc_path: str):
        self.doc_path = doc_path

    def load(self) -> str:
        """加载技术文档"""
        with open(self.doc_path, 'r', encoding='utf-8') as f:
            text = f.read()
        return text

    def extract_code_blocks(self, text: str) -> List[Dict]:
        """提取代码块"""
        import re

        # 匹配Markdown代码块
        pattern = r'```(\w+)?\n(.*?)```'
        matches = re.findall(pattern, text, re.DOTALL)

        code_blocks = []
        for language, code in matches:
            code_blocks.append({
                "language": language or "unknown",
                "code": code.strip()
            })

        return code_blocks
```

### 步骤3：多层次摘要生成

```python
class MultiLevelSummarizer:
    """多层次摘要生成器"""

    def __init__(self, model="gpt-4o-mini"):
        self.llm = ChatOpenAI(model=model, temperature=0)

    def generate_summaries(self, text: str) -> Dict:
        """生成多层次摘要"""

        # 第一层：整体摘要（最粗）
        level1_summary = self._generate_summary(text, chunk_size=8000)

        # 第二层：分段摘要（中等）
        level2_summaries = self._generate_chunk_summaries(text, chunk_size=4000)

        # 第三层：详细摘要（最细）
        level3_summaries = self._generate_chunk_summaries(text, chunk_size=2000)

        return {
            "level1": {
                "description": "整体摘要",
                "summary": level1_summary
            },
            "level2": {
                "description": "分段摘要",
                "summaries": level2_summaries
            },
            "level3": {
                "description": "详细摘要",
                "summaries": level3_summaries
            }
        }

    def _generate_summary(self, text: str, chunk_size: int) -> str:
        """生成单个摘要"""
        splitter = RecursiveCharacterTextSplitter(
            chunk_size=chunk_size,
            chunk_overlap=int(chunk_size * 0.1)
        )
        chunks = splitter.split_text(text)
        docs = [Document(page_content=chunk) for chunk in chunks]

        # 使用refine策略进行迭代式摘要
        chain = load_summarize_chain(
            self.llm,
            chain_type="refine",
            verbose=False
        )

        summary = chain.run(docs)
        return summary

    def _generate_chunk_summaries(
        self,
        text: str,
        chunk_size: int
    ) -> List[Dict]:
        """生成分块摘要"""
        splitter = RecursiveCharacterTextSplitter(
            chunk_size=chunk_size,
            chunk_overlap=int(chunk_size * 0.1)
        )
        chunks = splitter.split_text(text)

        summaries = []
        for i, chunk in enumerate(chunks):
            summary = self.llm.predict(
                f"Summarize the following technical content:\n\n{chunk}\n\nSummary:"
            )
            summaries.append({
                "chunk_index": i,
                "summary": summary,
                "original_length": len(chunk)
            })

        return summaries
```

### 步骤4：Chain of Summaries (CoS) 实现

```python
class ChainOfSummaries:
    """基于黑格尔辩证法的迭代提问摘要"""

    def __init__(self, model="gpt-4o-mini"):
        self.llm = ChatOpenAI(model=model, temperature=0)

    def generate(self, text: str) -> Dict:
        """生成CoS摘要"""

        # 辩证法三阶段问题（针对技术文档）
        questions = [
            {
                "stage": "Thesis（正题）",
                "question": "What is the main technical concept or solution presented in this document?"
            },
            {
                "stage": "Antithesis（反题）",
                "question": "What are the limitations, challenges, or alternative approaches mentioned?"
            },
            {
                "stage": "Synthesis（合题）",
                "question": "What is the recommended approach and best practices?"
            }
        ]

        summaries = []
        for q in questions:
            prompt = f"{q['question']}\n\nDocument: {text}\n\nAnswer:"
            answer = self.llm.predict(prompt)

            summaries.append({
                "stage": q["stage"],
                "question": q["question"],
                "answer": answer
            })

        # 综合摘要
        final_summary = "\n\n".join([
            f"**{s['stage']}**: {s['answer']}"
            for s in summaries
        ])

        return {
            "dialectical_summaries": summaries,
            "final_summary": final_summary
        }
```

### 步骤5：技术文档问答系统

```python
class TechDocQASystem:
    """技术文档问答系统"""

    def __init__(self, doc_path: str):
        self.loader = TechDocLoader(doc_path)
        self.text = self.loader.load()

        # 生成多层次摘要
        self.summarizer = MultiLevelSummarizer()
        self.summaries = self.summarizer.generate_summaries(self.text)

        # 生成CoS摘要
        self.cos = ChainOfSummaries()
        self.cos_summary = self.cos.generate(self.text)

        self.llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

    def answer(self, question: str, use_level: int = 2) -> Dict:
        """回答问题"""

        # 根据问题类型选择摘要层级
        if "overview" in question.lower() or "summary" in question.lower():
            # 全局理解问题：使用Level 1
            context = self.summaries["level1"]["summary"]
        elif "detail" in question.lower() or "specific" in question.lower():
            # 详细问题：使用Level 3
            context = "\n\n".join([
                s["summary"]
                for s in self.summaries["level3"]["summaries"]
            ])
        else:
            # 默认：使用Level 2
            context = "\n\n".join([
                s["summary"]
                for s in self.summaries["level2"]["summaries"]
            ])

        # 生成答案
        prompt = f"""
        Based on the following technical documentation summary, answer the question:

        Documentation Summary:
        {context}

        Question: {question}

        Please provide a detailed technical answer with examples if applicable.

        Answer:
        """

        answer = self.llm.predict(prompt)

        return {
            "question": question,
            "answer": answer,
            "summary_level_used": use_level,
            "context_length": len(context)
        }

    def get_technical_overview(self) -> Dict:
        """获取技术概览"""

        # 使用CoS摘要
        overview = self.cos_summary["final_summary"]

        # 提取关键技术点
        tech_points_prompt = f"""
        Based on the following technical summary, extract:
        1. Key Technologies
        2. Architecture Overview
        3. Implementation Approach
        4. Best Practices

        Summary: {overview}

        Technical Points:
        """

        tech_points = self.llm.predict(tech_points_prompt)

        return {
            "overview": overview,
            "technical_points": tech_points,
            "dialectical_analysis": self.cos_summary["dialectical_summaries"]
        }
```

### 步骤6：完整示例

```python
def main():
    """完整示例"""

    # 1. 加载技术文档
    print("加载技术文档...")
    qa_system = TechDocQASystem("technical_doc.md")

    print(f"文档总长度: {len(qa_system.text)} 字符")

    # 2. 获取技术概览
    print("\n=== 技术概览 ===")
    overview = qa_system.get_technical_overview()

    print(f"\n整体概览:\n{overview['overview']}")
    print(f"\n技术要点:\n{overview['technical_points']}")

    # 3. 测试问答
    questions = [
        "What is the main architecture of this system?",
        "What are the key implementation details?",
        "What are the best practices mentioned?",
        "What are the performance considerations?"
    ]

    for question in questions:
        print(f"\n问题: {question}")
        result = qa_system.answer(question)

        print(f"答案: {result['answer']}")
        print(f"使用摘要层级: Level {result['summary_level_used']}")
        print(f"上下文长度: {result['context_length']} 字符")

if __name__ == "__main__":
    main()
```

---

## 2026年生产级优化

### 优化1：Chain of Density (CoD) 实现

```python
class ChainOfDensity:
    """密度递增的摘要链"""

    def __init__(self, model="gpt-4o-mini"):
        self.llm = ChatOpenAI(model=model, temperature=0)

    def generate(
        self,
        text: str,
        num_iterations: int = 5
    ) -> List[Dict]:
        """生成CoD摘要"""

        summaries = []
        current_text = text

        for i in range(num_iterations):
            # 密度递增
            density = 0.2 + (i * 0.2)  # 0.2, 0.4, 0.6, 0.8, 1.0

            prompt = f"""
            Summarize the following technical document with density {density:.1f}:

            Density Guidelines:
            - 0.2: Very sparse, only main concepts (2-3 sentences)
            - 0.4: Sparse, key technologies (4-5 sentences)
            - 0.6: Medium, important details (6-7 sentences)
            - 0.8: Dense, most technical details (8-9 sentences)
            - 1.0: Very dense, comprehensive technical summary (10+ sentences)

            Document: {current_text}

            Technical Summary:
            """

            summary = self.llm.predict(prompt)

            summaries.append({
                "iteration": i + 1,
                "density": density,
                "summary": summary,
                "length": len(summary.split())
            })

            # 下一轮基于当前摘要
            current_text = summary

        return summaries


class AdvancedTechDocQASystem(TechDocQASystem):
    """使用CoD的高级技术文档问答系统"""

    def __init__(self, doc_path: str):
        super().__init__(doc_path)

        # 生成CoD摘要
        self.cod = ChainOfDensity()
        self.cod_summaries = self.cod.generate(self.text)

    def answer_with_adaptive_density(self, question: str) -> Dict:
        """根据问题复杂度自适应选择摘要密度"""

        # 分析问题复杂度
        complexity = self._analyze_question_complexity(question)

        # 根据复杂度选择摘要密度
        if complexity == "simple":
            # 简单问题：使用低密度摘要
            context = self.cod_summaries[0]["summary"]  # density 0.2
        elif complexity == "medium":
            # 中等问题：使用中密度摘要
            context = self.cod_summaries[2]["summary"]  # density 0.6
        else:
            # 复杂问题：使用高密度摘要
            context = self.cod_summaries[4]["summary"]  # density 1.0

        # 生成答案
        prompt = f"""
        Based on the following technical summary, answer the question:

        Summary: {context}

        Question: {question}

        Answer:
        """

        answer = self.llm.predict(prompt)

        return {
            "question": question,
            "answer": answer,
            "complexity": complexity,
            "density_used": self.cod_summaries[
                0 if complexity == "simple" else
                2 if complexity == "medium" else 4
            ]["density"]
        }

    def _analyze_question_complexity(self, question: str) -> str:
        """分析问题复杂度"""
        # 简单启发式规则
        if len(question.split()) < 10:
            return "simple"
        elif len(question.split()) < 20:
            return "medium"
        else:
            return "complex"
```

### 优化2：缓存优化

```python
from functools import lru_cache
import hashlib

class CachedTechDocQASystem(TechDocQASystem):
    """带缓存的技术文档问答系统"""

    def __init__(self, doc_path: str):
        super().__init__(doc_path)
        self._summary_cache = {}

    @lru_cache(maxsize=100)
    def _cached_answer(self, question_hash: str, level: int) -> str:
        """缓存答案"""
        # 实际答案生成逻辑
        pass

    def answer(self, question: str, use_level: int = 2) -> Dict:
        """回答问题（带缓存）"""

        # 计算问题哈希
        question_hash = hashlib.md5(
            f"{question}_{use_level}".encode()
        ).hexdigest()

        # 检查缓存
        if question_hash in self._summary_cache:
            print("使用缓存答案")
            return self._summary_cache[question_hash]

        # 生成答案
        result = super().answer(question, use_level)

        # 缓存结果
        self._summary_cache[question_hash] = result

        return result
```

### 优化3：批量问答

```python
from concurrent.futures import ThreadPoolExecutor

class BatchTechDocQASystem(TechDocQASystem):
    """批量技术文档问答系统"""

    def batch_answer(
        self,
        questions: List[str],
        max_workers: int = 5
    ) -> List[Dict]:
        """批量回答问题"""

        def process_question(question):
            return self.answer(question)

        # 并行处理
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            results = list(executor.map(process_question, questions))

        return results
```

---

## 性能评估

### 评估代码

```python
import time

def evaluate_tech_doc_qa(qa_system, test_questions, ground_truth):
    """评估技术文档问答系统"""

    metrics = {
        "accuracy": 0.0,
        "avg_answer_time": 0.0,
        "compression_ratio": 0.0,
        "summary_quality": 0.0
    }

    total_answer_time = 0
    original_length = len(qa_system.text)
    summary_length = len(qa_system.summaries["level1"]["summary"])

    for question, truth in zip(test_questions, ground_truth):
        # 答案生成时间
        start_time = time.time()
        result = qa_system.answer(question)
        answer_time = time.time() - start_time
        total_answer_time += answer_time

    metrics["avg_answer_time"] = total_answer_time / len(test_questions)
    metrics["compression_ratio"] = original_length / summary_length

    return metrics
```

---

## 常见问题

### Q1: 如何选择合适的摘要层级？

**A**: 根据问题类型选择

```python
def select_summary_level(question: str) -> int:
    """根据问题类型选择摘要层级"""

    # 全局理解问题 → Level 1
    if any(keyword in question.lower() for keyword in ["overview", "summary", "main"]):
        return 1

    # 详细问题 → Level 3
    elif any(keyword in question.lower() for keyword in ["detail", "specific", "how"]):
        return 3

    # 默认 → Level 2
    else:
        return 2
```

### Q2: 如何处理代码块？

**A**: 单独提取和索引代码块

```python
def extract_and_index_code_blocks(text: str) -> Dict:
    """提取并索引代码块"""
    import re

    # 提取代码块
    pattern = r'```(\w+)?\n(.*?)```'
    matches = re.findall(pattern, text, re.DOTALL)

    code_blocks = []
    for i, (language, code) in enumerate(matches):
        code_blocks.append({
            "id": i,
            "language": language or "unknown",
            "code": code.strip(),
            "summary": summarize_code(code)  # 生成代码摘要
        })

    return {"code_blocks": code_blocks}

def summarize_code(code: str) -> str:
    """生成代码摘要"""
    llm = ChatOpenAI(model="gpt-4o-mini")
    prompt = f"Summarize what this code does:\n\n{code}\n\nSummary:"
    return llm.predict(prompt)
```

### Q3: 如何评估摘要质量？

**A**: 使用多个指标

```python
def evaluate_summary_quality(original: str, summary: str) -> Dict:
    """评估摘要质量"""

    metrics = {
        "compression_ratio": len(original) / len(summary),
        "information_retention": calculate_retention(original, summary),
        "coherence": calculate_coherence(summary),
        "relevance": calculate_relevance(original, summary)
    }

    return metrics

def calculate_retention(original: str, summary: str) -> float:
    """计算信息保留率"""
    # 使用BERTScore或ROUGE
    from rouge import Rouge

    rouge = Rouge()
    scores = rouge.get_scores(summary, original)
    return scores[0]["rouge-l"]["f"]
```

---

## 核心记忆

### 关键点

1. **多层次摘要**：Level 1（粗）→ Level 2（中）→ Level 3（细）
2. **CoS摘要**：基于黑格尔辩证法的迭代提问
3. **CoD摘要**：密度递增的摘要链
4. **自适应选择**：根据问题类型选择摘要层级

### 2026年技术

1. **Chain of Summaries (CoS)**：信息密度提升3倍
2. **Chain of Density (CoD)**：准确率提升18%
3. **自适应密度选择**：根据问题复杂度动态调整

### 生产级配置

- Level 1 chunk size: 8000 tokens
- Level 2 chunk size: 4000 tokens
- Level 3 chunk size: 2000 tokens
- Compression ratio: 3-10x
- 缓存: LRU缓存，maxsize=100

---

**版本**: v1.0 (2025-2026 Research Edition)
**最后更新**: 2026-02-17
**代码行数**: ~250行
