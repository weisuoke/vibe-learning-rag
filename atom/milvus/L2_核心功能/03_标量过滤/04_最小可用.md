# 最小可用

> 掌握以下内容，就能开始使用标量过滤，解决80%的实际问题

---

## 4.1 基础比较运算符

**核心知识**：掌握6个最常用的比较运算符

```python
from pymilvus import Collection, connections

# 连接到 Milvus
connections.connect("default", host="localhost", port="19530")
collection = Collection("my_collection")

# 1. 等于 ==
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr="category == 'tech'"  # 精确匹配
)

# 2. 不等于 !=
expr = "status != 'deleted'"

# 3. 大于 >
expr = "price > 100"

# 4. 小于 <
expr = "age < 18"

# 5. 大于等于 >=
expr = "score >= 60"

# 6. 小于等于 <=
expr = "year <= 2024"
```

**记忆技巧**：与 Python 的比较运算符完全一致。

---

## 4.2 IN 运算符（多值匹配）

**核心知识**：一次匹配多个可能的值

```python
# 匹配多个分类
expr = "category in ['tech', 'ai', 'ml']"

# 匹配多个ID
expr = "user_id in [101, 102, 103]"

# 注意：字符串用单引号，列表用方括号
```

**使用场景**：
- 多分类筛选
- 白名单过滤
- 批量ID查询

---

## 4.3 AND/OR 组合条件

**核心知识**：使用 `and` 和 `or` 组合多个条件

```python
# AND：所有条件都必须满足
expr = "year == 2024 and category == 'tech' and price < 100"

# OR：满足任一条件即可
expr = "category == 'tech' or category == 'ai'"

# 混合使用（注意优先级）
expr = "(category == 'tech' or category == 'ai') and year == 2024"
```

**优先级规则**：
- `and` 优先级高于 `or`
- 使用括号 `()` 明确优先级

---

## 4.4 字符串模糊匹配

**核心知识**：使用 `like` 进行模糊匹配

```python
# % 匹配任意多个字符
expr = "title like 'Python%'"      # 以 Python 开头
expr = "title like '%教程'"         # 以 教程 结尾
expr = "title like '%机器学习%'"    # 包含 机器学习

# _ 匹配单个字符
expr = "code like 'A_01'"          # A 后跟任意一个字符，再跟 01
```

**注意事项**：
- 字符串必须用单引号 `'`
- `%` 和 `_` 是通配符
- 区分大小写

---

## 4.5 完整示例：混合检索

**核心知识**：将向量检索与标量过滤结合

```python
from pymilvus import Collection, connections
import numpy as np

# 1. 连接到 Milvus
connections.connect("default", host="localhost", port="19530")

# 2. 获取 Collection
collection = Collection("documents")

# 3. 准备查询向量（实际应用中从 Embedding 模型获取）
query_vector = np.random.rand(768).tolist()

# 4. 构建过滤表达式
expr = """
    year == 2024
    and category in ['tech', 'ai']
    and status == 'published'
"""

# 5. 执行混合检索
results = collection.search(
    data=[query_vector],              # 查询向量
    anns_field="embedding",           # 向量字段名
    param={
        "metric_type": "L2",          # 距离度量
        "params": {"nprobe": 10}      # 索引参数
    },
    limit=10,                         # 返回Top 10
    expr=expr,                        # 标量过滤条件
    output_fields=["title", "year", "category"]  # 返回字段
)

# 6. 处理结果
for hits in results:
    for hit in hits:
        print(f"ID: {hit.id}, 距离: {hit.distance}")
        print(f"标题: {hit.entity.get('title')}")
        print(f"年份: {hit.entity.get('year')}")
        print(f"分类: {hit.entity.get('category')}")
        print("---")
```

**关键参数说明**：
- `data`: 查询向量列表
- `anns_field`: Collection 中的向量字段名
- `expr`: 标量过滤表达式
- `limit`: 返回结果数量
- `output_fields`: 需要返回的标量字段

---

## 这些知识足以

掌握以上5个核心知识点，你就能：

✅ **实现基础混合检索**
- 在向量检索基础上添加业务条件
- 过滤掉不符合要求的结果

✅ **处理常见业务场景**
- 时间范围筛选（`year >= 2024`）
- 分类过滤（`category in ['tech', 'ai']`）
- 状态过滤（`status == 'published'`）
- 权限控制（`user_id == 123`）

✅ **构建 RAG 检索系统**
- 实现多租户知识库（按 user_id 过滤）
- 实现时间范围检索（按 publish_time 过滤）
- 实现分类检索（按 category 过滤）

✅ **为后续学习打基础**
- 理解标量过滤的基本原理
- 掌握表达式语法的核心规则
- 为学习高级特性（标量索引、复杂表达式）做准备

---

## 快速参考卡

| 运算符 | 语法 | 示例 | 说明 |
|--------|------|------|------|
| `==` | `field == value` | `year == 2024` | 等于 |
| `!=` | `field != value` | `status != 'deleted'` | 不等于 |
| `>` | `field > value` | `price > 100` | 大于 |
| `<` | `field < value` | `age < 18` | 小于 |
| `>=` | `field >= value` | `score >= 60` | 大于等于 |
| `<=` | `field <= value` | `year <= 2024` | 小于等于 |
| `in` | `field in [v1, v2]` | `category in ['tech', 'ai']` | 多值匹配 |
| `like` | `field like 'pattern'` | `title like 'Python%'` | 模糊匹配 |
| `and` | `expr1 and expr2` | `year == 2024 and category == 'tech'` | 逻辑与 |
| `or` | `expr1 or expr2` | `category == 'tech' or category == 'ai'` | 逻辑或 |

---

## 下一步学习

掌握最小可用知识后，建议：

1. **运行实战代码**：[场景1: 基础标量过滤](./07_实战代码_场景1_基础标量过滤.md)
2. **理解核心概念**：[过滤表达式语法](./03_核心概念_1_过滤表达式语法.md)
3. **避开常见误区**：[反直觉点](./06_反直觉点.md)
4. **应用到 RAG**：[场景4: RAG混合检索](./07_实战代码_场景4_RAG混合检索.md)
