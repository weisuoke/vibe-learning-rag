# JWT认证 - 实战代码05：RBAC权限控制

## 概述

本章实现基于角色的访问控制（RBAC），为不同用户分配不同的权限。

---

## RBAC基础

### 什么是RBAC？

**RBAC（Role-Based Access Control）**：基于角色的访问控制

**核心概念：**
- **用户（User）**：系统的使用者
- **角色（Role）**：一组权限的集合（如admin、user、guest）
- **权限（Permission）**：具体的操作权限（如read、write、delete）

**关系：**
```
用户 → 拥有 → 角色 → 包含 → 权限
```

---

## 数据库模型

### 用户角色模型

```python
"""
RBAC数据库模型
演示：User、Role关系
"""

from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, Table
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

# 用户-角色关联表（多对多）
user_roles = Table(
    'user_roles',
    Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True)
)


class User(Base):
    """用户模型"""
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, nullable=False)
    username = Column(String, unique=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)

    # 关系：用户可以有多个角色
    roles = relationship("Role", secondary=user_roles, back_populates="users")


class Role(Base):
    """角色模型"""
    __tablename__ = "roles"

    id = Column(Integer, primary_key=True)
    name = Column(String, unique=True, nullable=False)  # admin, user, guest
    description = Column(String)

    # 关系：角色可以分配给多个用户
    users = relationship("User", secondary=user_roles, back_populates="roles")
```

---

## 角色检查依赖

### 创建角色检查函数

```python
"""
角色检查依赖
演示：检查用户是否拥有指定角色
"""

from fastapi import Depends, HTTPException
from enum import Enum


class RoleEnum(str, Enum):
    """角色枚举"""
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"


def require_role(required_role: RoleEnum):
    """
    创建角色检查依赖

    Args:
        required_role: 需要的角色

    Returns:
        依赖函数
    """
    async def role_checker(
        current_user: User = Depends(get_current_user)
    ) -> User:
        """检查用户角色"""
        # 获取用户的所有角色名称
        user_roles = [role.name for role in current_user.roles]

        # 检查是否拥有所需角色
        if required_role.value not in user_roles:
            raise HTTPException(
                status_code=403,
                detail=f"需要 {required_role.value} 角色"
            )

        return current_user

    return role_checker


# 使用示例
@app.get("/admin/users")
async def list_users(
    current_user: User = Depends(require_role(RoleEnum.ADMIN))
):
    """管理员端点：列出所有用户"""
    users = db.query(User).all()
    return {"users": users}
```

---

## 角色层级

### 实现角色继承

```python
"""
角色层级
演示：高级角色自动拥有低级角色的权限
"""

# 角色层级定义
ROLE_HIERARCHY = {
    RoleEnum.GUEST: 1,
    RoleEnum.USER: 2,
    RoleEnum.ADMIN: 3
}


def require_role_or_higher(minimum_role: RoleEnum):
    """
    检查用户是否拥有指定角色或更高角色

    Args:
        minimum_role: 最低要求的角色

    Returns:
        依赖函数
    """
    async def role_checker(
        current_user: User = Depends(get_current_user)
    ) -> User:
        """检查用户角色层级"""
        # 获取用户的最高角色层级
        user_max_level = 0
        for role in current_user.roles:
            level = ROLE_HIERARCHY.get(role.name, 0)
            user_max_level = max(user_max_level, level)

        # 检查是否满足最低要求
        required_level = ROLE_HIERARCHY.get(minimum_role.value, 0)

        if user_max_level < required_level:
            raise HTTPException(
                status_code=403,
                detail=f"需要 {minimum_role.value} 或更高角色"
            )

        return current_user

    return role_checker


# 使用示例
@app.get("/user/profile")
async def get_profile(
    current_user: User = Depends(require_role_or_higher(RoleEnum.USER))
):
    """用户端点：USER、ADMIN都可以访问"""
    return {"user": current_user}


@app.delete("/admin/user/{user_id}")
async def delete_user(
    user_id: int,
    current_user: User = Depends(require_role_or_higher(RoleEnum.ADMIN))
):
    """管理员端点：只有ADMIN可以访问"""
    # 删除用户逻辑
    pass
```

---

## JWT中包含角色

### 在Token中存储角色

```python
"""
JWT中包含角色
演示：生成Token时包含用户角色
"""

def create_access_token(user: User) -> str:
    """生成包含角色的Access Token"""
    # 获取用户的所有角色
    roles = [role.name for role in user.roles]

    expire = datetime.utcnow() + timedelta(minutes=15)

    payload = {
        "user_id": user.id,
        "username": user.username,
        "roles": roles,  # 包含角色列表
        "exp": expire
    }

    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


# 验证时从Token中获取角色
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """获取当前用户（包含角色）"""
    try:
        payload = jwt.decode(
            credentials.credentials,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )

        # Token中包含角色信息
        return {
            "user_id": payload["user_id"],
            "username": payload["username"],
            "roles": payload.get("roles", [])
        }

    except JWTError:
        raise HTTPException(401, "无效的Token")


# 基于Token中的角色检查
def require_role_from_token(required_role: RoleEnum):
    """从Token中检查角色（无需查询数据库）"""
    async def role_checker(
        current_user: dict = Depends(get_current_user)
    ) -> dict:
        if required_role.value not in current_user.get("roles", []):
            raise HTTPException(403, f"需要 {required_role.value} 角色")

        return current_user

    return role_checker
```

---

## 完整RBAC系统

### 完整实现

```python
"""
完整的RBAC系统
演示：用户、角色、权限完整实现
"""

from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy import create_engine, Column, Integer, String, Boolean, ForeignKey, Table
from sqlalchemy.orm import sessionmaker, Session, relationship
from sqlalchemy.ext.declarative import declarative_base
from jose import jwt
from datetime import datetime, timedelta
from enum import Enum
import os

app = FastAPI()

# 数据库设置
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./rbac.db")
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()

SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"


# ===== 数据库模型 =====

user_roles = Table(
    'user_roles',
    Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True)
)


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, nullable=False)
    username = Column(String, unique=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)

    roles = relationship("Role", secondary=user_roles, back_populates="users")


class Role(Base):
    __tablename__ = "roles"

    id = Column(Integer, primary_key=True)
    name = Column(String, unique=True, nullable=False)
    description = Column(String)

    users = relationship("User", secondary=user_roles, back_populates="roles")


Base.metadata.create_all(bind=engine)


# ===== 角色枚举 =====

class RoleEnum(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"


ROLE_HIERARCHY = {
    RoleEnum.GUEST: 1,
    RoleEnum.USER: 2,
    RoleEnum.ADMIN: 3
}


# ===== 依赖函数 =====

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """获取当前用户"""
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload["user_id"]

        user = db.query(User).filter(User.id == user_id).first()
        if not user or not user.is_active:
            raise HTTPException(401, "用户不存在或已禁用")

        return user

    except JWTError:
        raise HTTPException(401, "无效的Token")


def require_role(required_role: RoleEnum):
    """检查用户是否拥有指定角色"""
    async def role_checker(current_user: User = Depends(get_current_user)) -> User:
        user_roles = [role.name for role in current_user.roles]

        if required_role.value not in user_roles:
            raise HTTPException(403, f"需要 {required_role.value} 角色")

        return current_user

    return role_checker


def require_role_or_higher(minimum_role: RoleEnum):
    """检查用户是否拥有指定角色或更高角色"""
    async def role_checker(current_user: User = Depends(get_current_user)) -> User:
        user_max_level = 0
        for role in current_user.roles:
            level = ROLE_HIERARCHY.get(role.name, 0)
            user_max_level = max(user_max_level, level)

        required_level = ROLE_HIERARCHY.get(minimum_role.value, 0)

        if user_max_level < required_level:
            raise HTTPException(403, f"需要 {minimum_role.value} 或更高角色")

        return current_user

    return role_checker


# ===== 路由端点 =====

@app.get("/public")
async def public_route():
    """公开端点：无需认证"""
    return {"message": "公开内容"}


@app.get("/user/profile")
async def user_profile(
    current_user: User = Depends(require_role_or_higher(RoleEnum.USER))
):
    """用户端点：USER或ADMIN可访问"""
    return {
        "user_id": current_user.id,
        "username": current_user.username,
        "roles": [role.name for role in current_user.roles]
    }


@app.get("/admin/users")
async def list_users(
    current_user: User = Depends(require_role(RoleEnum.ADMIN)),
    db: Session = Depends(get_db)
):
    """管理员端点：只有ADMIN可访问"""
    users = db.query(User).all()

    return {
        "users": [
            {
                "id": u.id,
                "username": u.username,
                "roles": [r.name for r in u.roles]
            }
            for u in users
        ]
    }


@app.post("/admin/user/{user_id}/role")
async def assign_role(
    user_id: int,
    role_name: RoleEnum,
    current_user: User = Depends(require_role(RoleEnum.ADMIN)),
    db: Session = Depends(get_db)
):
    """管理员端点：分配角色"""
    # 查找用户
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(404, "用户不存在")

    # 查找或创建角色
    role = db.query(Role).filter(Role.name == role_name.value).first()
    if not role:
        role = Role(name=role_name.value)
        db.add(role)

    # 分配角色
    if role not in user.roles:
        user.roles.append(role)
        db.commit()

    return {"message": f"已将 {role_name.value} 角色分配给用户 {user.username}"}


@app.delete("/admin/user/{user_id}/role/{role_name}")
async def revoke_role(
    user_id: int,
    role_name: RoleEnum,
    current_user: User = Depends(require_role(RoleEnum.ADMIN)),
    db: Session = Depends(get_db)
):
    """管理员端点：撤销角色"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(404, "用户不存在")

    role = db.query(Role).filter(Role.name == role_name.value).first()
    if role and role in user.roles:
        user.roles.remove(role)
        db.commit()

    return {"message": f"已撤销用户 {user.username} 的 {role_name.value} 角色"}
```

---

## 在AI Agent API中的应用

### AI Agent权限控制

```python
"""
AI Agent权限控制
演示：不同角色有不同的AI Agent使用权限
"""

class AgentModel(str, Enum):
    """AI模型枚举"""
    GPT_3_5 = "gpt-3.5-turbo"  # 免费用户
    GPT_4 = "gpt-4"            # 付费用户
    GPT_4_TURBO = "gpt-4-turbo"  # 高级用户


# 角色与模型的映射
ROLE_MODEL_MAP = {
    RoleEnum.GUEST: [AgentModel.GPT_3_5],
    RoleEnum.USER: [AgentModel.GPT_3_5, AgentModel.GPT_4],
    RoleEnum.ADMIN: [AgentModel.GPT_3_5, AgentModel.GPT_4, AgentModel.GPT_4_TURBO]
}


@app.post("/agent/chat")
async def chat(
    message: str,
    model: AgentModel = AgentModel.GPT_3_5,
    current_user: User = Depends(require_role_or_higher(RoleEnum.GUEST)),
    db: Session = Depends(get_db)
):
    """AI Agent对话（基于角色的模型访问控制）"""
    # 获取用户的最高角色
    user_max_role = None
    user_max_level = 0
    for role in current_user.roles:
        level = ROLE_HIERARCHY.get(role.name, 0)
        if level > user_max_level:
            user_max_level = level
            user_max_role = role.name

    # 检查用户是否有权使用该模型
    allowed_models = ROLE_MODEL_MAP.get(user_max_role, [])
    if model not in allowed_models:
        raise HTTPException(
            403,
            f"您的角色 ({user_max_role}) 无权使用 {model.value} 模型"
        )

    # 调用AI Agent
    response = f"使用 {model.value} 回复: {message}"

    return {
        "user_id": current_user.id,
        "model": model.value,
        "message": message,
        "response": response
    }


@app.get("/agent/models")
async def list_available_models(
    current_user: User = Depends(get_current_user)
):
    """列出用户可用的AI模型"""
    # 获取用户的最高角色
    user_max_role = None
    user_max_level = 0
    for role in current_user.roles:
        level = ROLE_HIERARCHY.get(role.name, 0)
        if level > user_max_level:
            user_max_level = level
            user_max_role = role.name

    # 获取可用模型
    allowed_models = ROLE_MODEL_MAP.get(user_max_role, [])

    return {
        "user_role": user_max_role,
        "available_models": [m.value for m in allowed_models]
    }
```

---

## 测试RBAC

### 测试脚本

```bash
#!/bin/bash

# 1. 创建用户并分配角色
echo "=== 创建用户 ==="
# 假设已有注册和登录端点

# 2. 登录获取Token（普通用户）
USER_TOKEN=$(curl -s -X POST "http://localhost:8000/login" \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "password"}' \
  | jq -r '.access_token')

# 3. 登录获取Token（管理员）
ADMIN_TOKEN=$(curl -s -X POST "http://localhost:8000/login" \
  -H "Content-Type: application/json" \
  -d '{"email": "admin@example.com", "password": "password"}' \
  | jq -r '.access_token')

# 4. 普通用户访问用户端点（应该成功）
echo -e "\n=== 普通用户访问用户端点 ==="
curl -X GET "http://localhost:8000/user/profile" \
  -H "Authorization: Bearer $USER_TOKEN"

# 5. 普通用户访问管理员端点（应该失败）
echo -e "\n=== 普通用户访问管理员端点 ==="
curl -X GET "http://localhost:8000/admin/users" \
  -H "Authorization: Bearer $USER_TOKEN"

# 6. 管理员访问管理员端点（应该成功）
echo -e "\n=== 管理员访问管理员端点 ==="
curl -X GET "http://localhost:8000/admin/users" \
  -H "Authorization: Bearer $ADMIN_TOKEN"

# 7. 测试AI Agent模型访问
echo -e "\n=== 普通用户使用GPT-3.5 ==="
curl -X POST "http://localhost:8000/agent/chat?message=你好&model=gpt-3.5-turbo" \
  -H "Authorization: Bearer $USER_TOKEN"

echo -e "\n=== 普通用户尝试使用GPT-4-Turbo（应该失败）==="
curl -X POST "http://localhost:8000/agent/chat?message=你好&model=gpt-4-turbo" \
  -H "Authorization: Bearer $USER_TOKEN"
```

---

## 总结

**本章实现了：**
1. RBAC数据库模型
2. 角色检查依赖
3. 角色层级（继承）
4. JWT中包含角色
5. 完整RBAC系统
6. AI Agent权限控制

**关键点：**
- 用户可以有多个角色
- 角色有层级关系
- JWT中包含角色信息
- 依赖注入实现权限检查
- AI Agent基于角色控制模型访问

**下一步：**
- 学习手写JWT实现
- 学习生产级最佳实践
- 学习完整AI Agent API
