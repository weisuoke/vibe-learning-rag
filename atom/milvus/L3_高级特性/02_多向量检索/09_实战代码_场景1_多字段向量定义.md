# 实战代码 - 场景1：多字段向量定义

> 创建包含多个向量字段的 Collection

---

## 场景描述

**目标：** 创建一个文档问答系统的 Collection，包含文本向量和图片向量两个字段

**应用场景：**
- 技术文档检索（文字说明 + 代码截图）
- 产品手册检索（文字描述 + 产品图片）
- 教程检索（文字教程 + 示意图）

---

## 完整代码

```python
"""
多字段向量定义 - 完整示例
演示：创建包含多个向量字段的 Collection
"""

import os
from pymilvus import (
    connections,
    Collection,
    CollectionSchema,
    FieldSchema,
    DataType,
    utility
)
from openai import OpenAI
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

# ===== 1. 连接到 Milvus =====
print("=== 连接到 Milvus ===")
connections.connect(
    alias="default",
    host=os.getenv("MILVUS_HOST", "localhost"),
    port=os.getenv("MILVUS_PORT", "19530")
)
print("✅ 连接成功")

# ===== 2. 定义 Schema（多个向量字段）=====
print("\n=== 定义 Schema ===")

# 定义字段
fields = [
    # 主键
    FieldSchema(
        name="doc_id",
        dtype=DataType.INT64,
        is_primary=True,
        auto_id=True,
        description="文档ID（自动生成）"
    ),

    # 标量字段
    FieldSchema(
        name="title",
        dtype=DataType.VARCHAR,
        max_length=200,
        description="文档标题"
    ),

    FieldSchema(
        name="content",
        dtype=DataType.VARCHAR,
        max_length=5000,
        description="文档内容"
    ),

    FieldSchema(
        name="image_url",
        dtype=DataType.VARCHAR,
        max_length=500,
        description="图片URL"
    ),

    FieldSchema(
        name="category",
        dtype=DataType.VARCHAR,
        max_length=100,
        description="文档分类"
    ),

    # 向量字段1：文本向量（OpenAI Embedding）
    FieldSchema(
        name="text_vector",
        dtype=DataType.FLOAT_VECTOR,
        dim=1536,  # text-embedding-3-small 的维度
        description="文本内容的向量表示"
    ),

    # 向量字段2：图片向量（CLIP Embedding）
    FieldSchema(
        name="image_vector",
        dtype=DataType.FLOAT_VECTOR,
        dim=512,  # CLIP ViT-B/32 的维度
        description="图片的向量表示"
    ),
]

# 创建 Schema
schema = CollectionSchema(
    fields=fields,
    description="文档问答知识库（多向量检索）",
    enable_dynamic_field=False  # 不启用动态字段
)

print(f"✅ Schema 定义完成")
print(f"   - 标量字段：4个（title, content, image_url, category）")
print(f"   - 向量字段：2个（text_vector, image_vector）")

# ===== 3. 创建 Collection =====
print("\n=== 创建 Collection ===")

collection_name = "doc_qa_multi_vector"

# 删除已存在的 Collection（如果有）
if utility.has_collection(collection_name):
    print(f"⚠️  Collection '{collection_name}' 已存在，删除中...")
    utility.drop_collection(collection_name)

# 创建新 Collection
collection = Collection(
    name=collection_name,
    schema=schema,
    using="default"
)

print(f"✅ Collection '{collection_name}' 创建成功")

# ===== 4. 为每个向量字段创建索引 =====
print("\n=== 创建索引 ===")

# 为 text_vector 创建 HNSW 索引
print("创建 text_vector 索引...")
text_index_params = {
    "index_type": "HNSW",
    "metric_type": "COSINE",
    "params": {
        "M": 16,              # HNSW 参数：每个节点的最大连接数
        "efConstruction": 200  # 构建索引时的搜索深度
    }
}

collection.create_index(
    field_name="text_vector",
    index_params=text_index_params
)
print("✅ text_vector 索引创建完成（HNSW, COSINE）")

# 为 image_vector 创建 HNSW 索引
print("创建 image_vector 索引...")
image_index_params = {
    "index_type": "HNSW",
    "metric_type": "COSINE",
    "params": {
        "M": 16,
        "efConstruction": 200
    }
}

collection.create_index(
    field_name="image_vector",
    index_params=image_index_params
)
print("✅ image_vector 索引创建完成（HNSW, COSINE）")

# ===== 5. 准备测试数据 =====
print("\n=== 准备测试数据 ===")

# 初始化 OpenAI 客户端
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def get_text_embedding(text):
    """生成文本向量"""
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    return response.data[0].embedding

def get_image_embedding_mock(image_url):
    """
    生成图片向量（Mock）
    实际应用中应该使用 CLIP 等模型
    这里为了演示，使用随机向量
    """
    import random
    return [random.random() for _ in range(512)]

# 准备文档数据
docs = [
    {
        "title": "Python 安装教程",
        "content": "Python 是一种高级编程语言。安装步骤：1. 下载安装包 2. 运行安装程序 3. 配置环境变量",
        "image_url": "https://example.com/python_install.png",
        "category": "教程"
    },
    {
        "title": "Java 入门指南",
        "content": "Java 是一种面向对象的编程语言。特点：跨平台、强类型、自动内存管理",
        "image_url": "https://example.com/java_intro.png",
        "category": "教程"
    },
    {
        "title": "Docker 容器化部署",
        "content": "Docker 是一个容器化平台。使用 Dockerfile 定义镜像，使用 docker-compose 编排服务",
        "image_url": "https://example.com/docker_deploy.png",
        "category": "运维"
    },
]

# 生成向量
print("生成向量...")
for doc in docs:
    # 生成文本向量
    doc["text_vector"] = get_text_embedding(doc["content"])
    # 生成图片向量（Mock）
    doc["image_vector"] = get_image_embedding_mock(doc["image_url"])

print(f"✅ 已为 {len(docs)} 个文档生成向量")

# ===== 6. 插入数据 =====
print("\n=== 插入数据 ===")

insert_result = collection.insert(docs)
print(f"✅ 插入成功，插入了 {len(insert_result.primary_keys)} 条数据")
print(f"   主键列表：{insert_result.primary_keys}")

# ===== 7. 加载 Collection =====
print("\n=== 加载 Collection ===")
collection.load()
print("✅ Collection 已加载到内存")

# ===== 8. 查看 Collection 信息 =====
print("\n=== Collection 信息 ===")
print(f"Collection 名称：{collection.name}")
print(f"文档数量：{collection.num_entities}")
print(f"Schema：")
for field in collection.schema.fields:
    print(f"  - {field.name}: {field.dtype} (dim={field.params.get('dim', 'N/A')})")

# ===== 9. 验证数据 =====
print("\n=== 验证数据 ===")

# 查询所有文档
query_result = collection.query(
    expr="doc_id >= 0",
    output_fields=["doc_id", "title", "category"],
    limit=10
)

print(f"查询结果（共 {len(query_result)} 条）：")
for doc in query_result:
    print(f"  - ID: {doc['doc_id']}, 标题: {doc['title']}, 分类: {doc['category']}")

# ===== 10. 测试单字段检索 =====
print("\n=== 测试单字段检索 ===")

# 测试查询
test_query = "如何安装 Python？"
print(f"查询：{test_query}")

# 生成查询向量
query_embedding = get_text_embedding(test_query)

# 只检索 text_vector
search_results = collection.search(
    data=[query_embedding],
    anns_field="text_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=3,
    output_fields=["title", "content"]
)

print("\ntext_vector 检索结果（Top 3）：")
for i, hit in enumerate(search_results[0], 1):
    print(f"{i}. {hit.entity.get('title')}")
    print(f"   相似度：{hit.distance:.4f}")
    print(f"   内容：{hit.entity.get('content')[:50]}...")

print("\n" + "="*60)
print("✅ 多字段向量定义完成！")
print("="*60)

# ===== 11. 清理（可选）=====
# 如果需要清理，取消下面的注释
# print("\n=== 清理 ===")
# collection.release()
# utility.drop_collection(collection_name)
# print(f"✅ Collection '{collection_name}' 已删除")
```

---

## 运行输出示例

```
=== 连接到 Milvus ===
✅ 连接成功

=== 定义 Schema ===
✅ Schema 定义完成
   - 标量字段：4个（title, content, image_url, category）
   - 向量字段：2个（text_vector, image_vector）

=== 创建 Collection ===
✅ Collection 'doc_qa_multi_vector' 创建成功

=== 创建索引 ===
创建 text_vector 索引...
✅ text_vector 索引创建完成（HNSW, COSINE）
创建 image_vector 索引...
✅ image_vector 索引创建完成（HNSW, COSINE）

=== 准备测试数据 ===
生成向量...
✅ 已为 3 个文档生成向量

=== 插入数据 ===
✅ 插入成功，插入了 3 条数据
   主键列表：[449646258995855360, 449646258995855361, 449646258995855362]

=== 加载 Collection ===
✅ Collection 已加载到内存

=== Collection 信息 ===
Collection 名称：doc_qa_multi_vector
文档数量：3
Schema：
  - doc_id: DataType.INT64 (dim=N/A)
  - title: DataType.VARCHAR (dim=N/A)
  - content: DataType.VARCHAR (dim=N/A)
  - image_url: DataType.VARCHAR (dim=N/A)
  - category: DataType.VARCHAR (dim=N/A)
  - text_vector: DataType.FLOAT_VECTOR (dim=1536)
  - image_vector: DataType.FLOAT_VECTOR (dim=512)

=== 验证数据 ===
查询结果（共 3 条）：
  - ID: 449646258995855360, 标题: Python 安装教程, 分类: 教程
  - ID: 449646258995855361, 标题: Java 入门指南, 分类: 教程
  - ID: 449646258995855362, 标题: Docker 容器化部署, 分类: 运维

=== 测试单字段检索 ===
查询：如何安装 Python？

text_vector 检索结果（Top 3）：
1. Python 安装教程
   相似度：0.8756
   内容：Python 是一种高级编程语言。安装步骤：1. 下载安装包 2. 运行安装程序...
2. Java 入门指南
   相似度：0.6234
   内容：Java 是一种面向对象的编程语言。特点：跨平台、强类型、自动内存管理...
3. Docker 容器化部署
   相似度：0.4521
   内容：Docker 是一个容器化平台。使用 Dockerfile 定义镜像，使用 docker-compose...

============================================================
✅ 多字段向量定义完成！
============================================================
```

---

## 代码详解

### 1. Schema 定义的关键点

```python
# ✅ 正确：明确指定维度
FieldSchema(
    name="text_vector",
    dtype=DataType.FLOAT_VECTOR,
    dim=1536,  # 必须指定维度
    description="文本内容的向量表示"
)

# ❌ 错误：不指定维度
FieldSchema(
    name="text_vector",
    dtype=DataType.FLOAT_VECTOR,
    # 缺少 dim 参数，会报错
)
```

### 2. 不同向量字段可以有不同维度

```python
# text_vector：1536维（OpenAI Embedding）
FieldSchema(name="text_vector", dtype=DataType.FLOAT_VECTOR, dim=1536)

# image_vector：512维（CLIP Embedding）
FieldSchema(name="image_vector", dtype=DataType.FLOAT_VECTOR, dim=512)

# 完全没问题！每个向量字段独立
```

### 3. 每个向量字段需要单独创建索引

```python
# 为 text_vector 创建索引
collection.create_index(
    field_name="text_vector",
    index_params={
        "index_type": "HNSW",
        "metric_type": "COSINE",
        "params": {"M": 16, "efConstruction": 200}
    }
)

# 为 image_vector 创建索引
collection.create_index(
    field_name="image_vector",
    index_params={
        "index_type": "HNSW",
        "metric_type": "COSINE",
        "params": {"M": 16, "efConstruction": 200}
    }
)

# 不同字段可以使用不同的索引类型和参数
```

### 4. 插入数据时必须提供所有向量字段

```python
# ✅ 正确：提供所有向量字段
doc = {
    "title": "Python 教程",
    "content": "...",
    "text_vector": [0.1, 0.2, ...],  # 1536维
    "image_vector": [0.3, 0.4, ...]  # 512维
}

# ❌ 错误：缺少 image_vector
doc = {
    "title": "Python 教程",
    "content": "...",
    "text_vector": [0.1, 0.2, ...],
    # 缺少 image_vector，插入会失败
}
```

---

## 扩展：使用真实的 CLIP Embedding

```python
"""
使用真实的 CLIP 模型生成图片向量
需要安装：pip install torch torchvision clip-by-openai pillow
"""

import torch
import clip
from PIL import Image

# 加载 CLIP 模型
device = "cuda" if torch.cuda.is_available() else "cpu"
clip_model, preprocess = clip.load("ViT-B/32", device=device)

def get_image_embedding_real(image_path):
    """使用 CLIP 生成图片向量"""
    # 加载图片
    image = preprocess(Image.open(image_path)).unsqueeze(0).to(device)

    # 生成向量
    with torch.no_grad():
        image_features = clip_model.encode_image(image)

    # 转换为列表
    return image_features.squeeze().cpu().tolist()

# 使用
image_embedding = get_image_embedding_real("python_logo.png")
print(f"图片向量维度：{len(image_embedding)}")  # 512
```

---

## 常见问题

### Q1：如何修改已创建的 Schema？

**答：** 不能修改，只能重新创建

```python
# 1. 导出数据
old_collection = Collection("old_name")
data = old_collection.query(expr="id >= 0", output_fields=["*"])

# 2. 删除旧 Collection
utility.drop_collection("old_name")

# 3. 创建新 Collection（新 Schema）
new_collection = Collection("new_name", schema=new_schema)

# 4. 重新插入数据
new_collection.insert(data)
```

### Q2：向量维度选错了怎么办？

**答：** 必须重新创建 Collection

```python
# ❌ 错误：维度不匹配
FieldSchema(name="text_vector", dtype=DataType.FLOAT_VECTOR, dim=768)
# 但实际 Embedding 是 1536 维

# 解决方案：
# 1. 删除 Collection
# 2. 修改 Schema（dim=1536）
# 3. 重新创建 Collection
# 4. 重新插入数据
```

### Q3：可以只为部分向量字段创建索引吗？

**答：** 可以，但不推荐

```python
# 只为 text_vector 创建索引
collection.create_index("text_vector", index_params)

# image_vector 没有索引

# 后果：
# - 可以检索 text_vector（使用索引，快）
# - 不能检索 image_vector（没有索引，会报错）
```

---

## 总结

**多字段向量定义的关键步骤：**

1. **定义 Schema**：为每个向量字段指定维度
2. **创建 Collection**：使用定义好的 Schema
3. **创建索引**：为每个向量字段单独创建索引
4. **插入数据**：提供所有向量字段的值
5. **加载 Collection**：加载到内存后才能检索

**注意事项：**
- 向量维度必须与 Embedding 模型一致
- 每个向量字段需要单独创建索引
- 插入数据时必须提供所有向量字段
- Schema 创建后不能修改

---

**继续学习：** [10_实战代码_场景2_混合检索实现.md](./10_实战代码_场景2_混合检索实现.md)
