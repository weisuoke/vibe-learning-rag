# 一句话总结

**Plan Mode 是 pi-mono 极简哲学的体现：不提供黑盒规划功能，而是提供原语让你构建任何需要的规划工作流——文件式、扩展式或 Session 集成式，选择权在你手中。**

---

## 核心洞察

### Pi-mono 的哲学

Pi-mono 的作者 Mario Zechner 在博客中写道：

> "I don't want to force a planning mode on users. Instead, I provide the primitives to build any planning workflow you need. Write plans to files, use extensions, or integrate with CLI tools - the choice is yours."

这句话揭示了 pi-mono 的核心设计理念：

1. **No black-box orchestration**：避免黑盒编排
2. **Observability first**：文件优先，状态可见
3. **User control**：用户控制工作流
4. **Composability**：可组合的扩展系统

### Plan Mode 的本质

Plan Mode 不是一个功能，而是一种**模式**：

- **模式**：一种工作流程，可以通过多种方式实现
- **非功能**：不是内置的、固定的、黑盒的功能
- **可实现**：通过文件、扩展或 Session 实现
- **可定制**：根据你的需求定制规划流程

### 三种实现方式的本质

| 方式 | 本质 | 优势 | 适用场景 |
|------|------|------|----------|
| **文件式** | 将计划写入文件 | 最大可观察性 | 简单任务、快速原型 |
| **扩展式** | 注册命令和工具 | 最佳用户体验 | 频繁使用、团队协作 |
| **Session 集成** | 使用 Session 管理状态 | 状态持久化 | 复杂任务、长期项目 |

### 与其他工具的对比

**Pi-mono vs. Oh-my-pi:**
- **Pi-mono**：提供原语，用户构建
- **Oh-my-pi**：提供内置 `/plan` 命令

**Pi-mono vs. Claude Code:**
- **Pi-mono**：扩展实现，用户控制
- **Claude Code**：内置 Plan Mode，集成体验

**Pi-mono 的优势：**
- 最大灵活性
- 最大可观察性
- 最大用户控制
- 最小核心复杂度

### 为什么这种设计更好？

1. **透明性**：计划存储在文件中，用户可见可编辑
2. **灵活性**：用户选择适合自己的规划模式
3. **可组合**：与其他扩展组合使用
4. **可控性**：用户决定何时规划、何时执行
5. **简单性**：核心保持简单，复杂性在扩展中

### 关键教训

**不要问"Pi-mono 有 Plan Mode 吗？"**

而是问：

- "我如何用 pi-mono 实现我需要的规划工作流？"
- "文件式、扩展式还是 Session 集成式更适合我？"
- "我需要什么样的规划模式？"

**Plan Mode 不是功能，而是你构建的工作流。**

---

## 延伸阅读

- **02_第一性原理.md**：深入理解为什么 Plan Mode 不是内置功能
- **03_核心概念_*.md**：学习三种实现方式的技术细节
- **07_实战代码_*.md**：查看完整的可运行代码示例

---

## 参考资源

- [What I learned building pi coding agent](https://mariozechner.at/posts/2025-11-30-pi-coding-agent) - Mario Zechner, 2025-11-30
- [Pi-mono GitHub Repository](https://github.com/badlogic/pi-mono) - Official repository
- [Pi-mono Extension Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md) - Extension API guide
