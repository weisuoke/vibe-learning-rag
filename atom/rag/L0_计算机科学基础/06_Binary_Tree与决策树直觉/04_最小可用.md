# Binary Tree 与决策树直觉 - 最小可用知识

> 掌握以下 20% 的核心知识，就能解决 80% 的二叉树问题

---

## 核心理念

**最小可用 = 能立即上手 + 覆盖常见场景 + 为进阶打基础**

学完本文档，你将能够：
- ✅ 创建和操作二叉树
- ✅ 实现四种遍历算法
- ✅ 在 AI Agent 中应用决策树
- ✅ 解决 80% 的实际问题

---

## 1. 二叉树的基本定义

### 1.1 核心概念

**Binary Tree = 节点 + 左右指针**

```python
class TreeNode:
    def __init__(self, val):
        self.val = val          # 节点值
        self.left = None        # 左子节点
        self.right = None       # 右子节点
```

**关键特性：**
- 每个节点最多有 2 个子节点
- 左右子节点有顺序（左 ≠ 右）
- 递归定义：每个子树也是二叉树

### 1.2 创建二叉树

```python
# 创建一个简单的二叉树
#       1
#      / \
#     2   3
#    / \
#   4   5

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
```

**这些知识足以：**
- 理解二叉树的基本结构
- 手动构建简单的二叉树
- 为学习遍历算法打基础

---

## 2. 四种遍历方式（递归版本）

### 2.1 前序遍历（Pre-order）

**顺序：根 → 左 → 右**

```python
def preorder(root):
    """前序遍历：先访问根节点"""
    if not root:
        return []

    # 根 → 左 → 右
    return [root.val] + preorder(root.left) + preorder(root.right)

# 示例输出：[1, 2, 4, 5, 3]
```

**应用场景：**
- 复制树结构
- 序列化树
- 行为树执行（先决策再执行）

### 2.2 中序遍历（In-order）

**顺序：左 → 根 → 右**

```python
def inorder(root):
    """中序遍历：根节点在中间"""
    if not root:
        return []

    # 左 → 根 → 右
    return inorder(root.left) + [root.val] + inorder(root.right)

# 示例输出：[4, 2, 5, 1, 3]
```

**应用场景：**
- 二叉搜索树（BST）排序输出
- 有序访问节点

### 2.3 后序遍历（Post-order）

**顺序：左 → 右 → 根**

```python
def postorder(root):
    """后序遍历：根节点在最后"""
    if not root:
        return []

    # 左 → 右 → 根
    return postorder(root.left) + postorder(root.right) + [root.val]

# 示例输出：[4, 5, 2, 3, 1]
```

**应用场景：**
- 删除树（先删子节点再删父节点）
- 计算表达式树
- 决策树剪枝

### 2.4 层序遍历（Level-order）

**顺序：逐层访问**

```python
from collections import deque

def levelorder(root):
    """层序遍历：广度优先"""
    if not root:
        return []

    result = []
    queue = deque([root])  # 使用队列

    while queue:
        node = queue.popleft()
        result.append(node.val)

        # 先左后右入队
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

    return result

# 示例输出：[1, 2, 3, 4, 5]
```

**应用场景：**
- 打印树的层次结构
- TreeRAG 分层检索
- 最短路径问题

**这些知识足以：**
- 实现四种基本遍历
- 理解不同遍历的语义
- 解决大部分树遍历问题

---

## 3. 树的高度计算

### 3.1 高度定义

**高度 = 节点到叶子的最长路径长度**

```python
def height(root):
    """计算树的高度"""
    if not root:
        return 0

    # 递归计算左右子树高度
    left_height = height(root.left)
    right_height = height(root.right)

    # 返回较大的高度 + 1
    return max(left_height, right_height) + 1

# 示例：
#       1          高度 = 3
#      / \
#     2   3        高度 = 2
#    / \
#   4   5          高度 = 1
```

**关键理解：**
- 空树高度 = 0
- 叶子节点高度 = 1
- 高度决定了树的性能（O(h) 操作）

### 3.2 平衡树的重要性

**平衡树：左右子树高度差 ≤ 1**

```python
def is_balanced(root):
    """判断是否为平衡树"""
    def check(node):
        if not node:
            return 0, True  # (高度, 是否平衡)

        left_h, left_bal = check(node.left)
        right_h, right_bal = check(node.right)

        # 检查平衡条件
        balanced = left_bal and right_bal and abs(left_h - right_h) <= 1
        height = max(left_h, right_h) + 1

        return height, balanced

    _, is_bal = check(root)
    return is_bal
```

**为什么重要：**
- 平衡树：O(log n) 查找
- 不平衡树：O(n) 查找（退化为链表）

**这些知识足以：**
- 计算树的高度
- 判断树是否平衡
- 理解平衡树的重要性

---

## 4. AI Agent 中的决策树

### 4.1 决策树基本概念

**决策树 = 分类规则的树形表示**

```python
from sklearn.tree import DecisionTreeClassifier
from sklearn.datasets import load_iris

# 1. 加载数据
iris = load_iris()
X, y = iris.data, iris.target

# 2. 训练决策树
clf = DecisionTreeClassifier(max_depth=3)
clf.fit(X, y)

# 3. 预测
predictions = clf.predict([[5.1, 3.5, 1.4, 0.2]])
print(f"预测类别: {predictions[0]}")  # 输出: 0 (Setosa)
```

**核心参数：**
- `max_depth`：树的最大深度（防止过拟合）
- `min_samples_split`：分裂所需的最小样本数
- `criterion`：分裂标准（'gini' 或 'entropy'）

### 4.2 决策树的可解释性

```python
from sklearn.tree import export_text

# 导出决策规则
tree_rules = export_text(clf, feature_names=iris.feature_names)
print(tree_rules)

# 输出示例：
# |--- petal width (cm) <= 0.80
# |   |--- class: 0
# |--- petal width (cm) >  0.80
# |   |--- petal width (cm) <= 1.75
# |   |   |--- class: 1
# |   |--- petal width (cm) >  1.75
# |   |   |--- class: 2
```

**核心优势：**
- 决策路径清晰可追溯
- 适合需要解释的 AI 系统
- 可以转换为 if-else 规则

### 4.3 在 AI Agent 中的应用

**场景1：意图分类**

```python
# 训练意图分类器
from sklearn.feature_extraction.text import TfidfVectorizer

# 示例数据
texts = [
    "查询天气",
    "设置闹钟",
    "播放音乐",
    "今天天气怎么样",
    "明天早上7点叫我",
    "放一首周杰伦的歌"
]
labels = [0, 1, 2, 0, 1, 2]  # 0=天气, 1=闹钟, 2=音乐

# 特征提取
vectorizer = TfidfVectorizer()
X = vectorizer.fit_transform(texts)

# 训练决策树
clf = DecisionTreeClassifier(max_depth=5)
clf.fit(X, labels)

# 预测新输入
new_text = ["明天会下雨吗"]
X_new = vectorizer.transform(new_text)
intent = clf.predict(X_new)[0]
print(f"意图: {['天气', '闹钟', '音乐'][intent]}")  # 输出: 天气
```

**场景2：行为决策**

```python
# 简单的行为树节点
class BehaviorNode:
    def execute(self):
        """返回 SUCCESS, FAILURE, RUNNING"""
        pass

class Selector(BehaviorNode):
    """选择器：依次尝试子节点，直到成功"""
    def __init__(self, children):
        self.children = children

    def execute(self):
        for child in self.children:
            result = child.execute()
            if result != "FAILURE":
                return result
        return "FAILURE"

class Sequence(BehaviorNode):
    """序列：依次执行子节点，直到失败"""
    def __init__(self, children):
        self.children = children

    def execute(self):
        for child in self.children:
            result = child.execute()
            if result != "SUCCESS":
                return result
        return "SUCCESS"

# 示例：AI Agent 决策树
# Selector
#   ├─ Sequence (处理紧急任务)
#   │   ├─ 检查是否有紧急任务
#   │   └─ 执行紧急任务
#   └─ Sequence (处理普通任务)
#       ├─ 检查是否有普通任务
#       └─ 执行普通任务
```

**这些知识足以：**
- 使用 sklearn 训练决策树分类器
- 理解决策树的可解释性
- 在 AI Agent 中应用决策树
- 实现简单的行为树系统

---

## 5. 常用操作速查

### 5.1 查找节点

```python
def search(root, target):
    """在二叉树中查找目标值"""
    if not root:
        return None

    if root.val == target:
        return root

    # 递归查找左右子树
    left_result = search(root.left, target)
    if left_result:
        return left_result

    return search(root.right, target)
```

### 5.2 计算节点数

```python
def count_nodes(root):
    """计算二叉树的节点数"""
    if not root:
        return 0

    return 1 + count_nodes(root.left) + count_nodes(root.right)
```

### 5.3 计算叶子节点数

```python
def count_leaves(root):
    """计算叶子节点数"""
    if not root:
        return 0

    # 叶子节点：没有左右子节点
    if not root.left and not root.right:
        return 1

    return count_leaves(root.left) + count_leaves(root.right)
```

### 5.4 打印树结构

```python
def print_tree(root, level=0, prefix="Root: "):
    """打印树的结构"""
    if root:
        print(" " * (level * 4) + prefix + str(root.val))
        if root.left or root.right:
            if root.left:
                print_tree(root.left, level + 1, "L--- ")
            else:
                print(" " * ((level + 1) * 4) + "L--- None")

            if root.right:
                print_tree(root.right, level + 1, "R--- ")
            else:
                print(" " * ((level + 1) * 4) + "R--- None")

# 输出示例：
# Root: 1
#     L--- 2
#         L--- 4
#         R--- 5
#     R--- 3
```

---

## 完整示例：从零到实战

### 示例1：构建和遍历二叉树

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

# 1. 构建二叉树
#       1
#      / \
#     2   3
#    / \
#   4   5

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

# 2. 四种遍历
def preorder(root):
    if not root:
        return []
    return [root.val] + preorder(root.left) + preorder(root.right)

def inorder(root):
    if not root:
        return []
    return inorder(root.left) + [root.val] + inorder(root.right)

def postorder(root):
    if not root:
        return []
    return postorder(root.left) + postorder(root.right) + [root.val]

from collections import deque

def levelorder(root):
    if not root:
        return []
    result, queue = [], deque([root])
    while queue:
        node = queue.popleft()
        result.append(node.val)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return result

# 3. 测试
print("前序遍历:", preorder(root))    # [1, 2, 4, 5, 3]
print("中序遍历:", inorder(root))     # [4, 2, 5, 1, 3]
print("后序遍历:", postorder(root))   # [4, 5, 2, 3, 1]
print("层序遍历:", levelorder(root))  # [1, 2, 3, 4, 5]

# 4. 计算高度
def height(root):
    if not root:
        return 0
    return max(height(root.left), height(root.right)) + 1

print("树的高度:", height(root))  # 3
```

### 示例2：AI Agent 意图分类

```python
from sklearn.tree import DecisionTreeClassifier
from sklearn.feature_extraction.text import TfidfVectorizer

# 1. 准备训练数据
texts = [
    "查询天气", "今天天气怎么样", "明天会下雨吗",
    "设置闹钟", "明天早上7点叫我", "提醒我开会",
    "播放音乐", "放一首周杰伦的歌", "我想听音乐"
]
labels = [0, 0, 0, 1, 1, 1, 2, 2, 2]  # 0=天气, 1=闹钟, 2=音乐

# 2. 特征提取
vectorizer = TfidfVectorizer()
X = vectorizer.fit_transform(texts)

# 3. 训练决策树
clf = DecisionTreeClassifier(max_depth=5)
clf.fit(X, labels)

# 4. 预测新输入
def predict_intent(text):
    X_new = vectorizer.transform([text])
    intent_id = clf.predict(X_new)[0]
    intents = ["天气查询", "闹钟设置", "音乐播放"]
    return intents[intent_id]

# 5. 测试
print(predict_intent("后天天气如何"))      # 天气查询
print(predict_intent("下午3点提醒我"))     # 闹钟设置
print(predict_intent("来首轻音乐"))        # 音乐播放
```

---

## 学习检查清单

完成本文档学习后，你应该能够：

### 基础操作
- [ ] 定义 TreeNode 类
- [ ] 手动构建简单的二叉树
- [ ] 实现四种遍历算法（递归版本）
- [ ] 计算树的高度

### 核心理解
- [ ] 理解前序/中序/后序/层序的区别
- [ ] 理解递归在树操作中的应用
- [ ] 理解平衡树的重要性
- [ ] 理解决策树的可解释性

### AI Agent 应用
- [ ] 使用 sklearn 训练决策树分类器
- [ ] 理解决策树在意图分类中的应用
- [ ] 理解行为树的基本概念
- [ ] 能够实现简单的行为树节点

---

## 下一步学习建议

### 如果你已经掌握了最小可用知识

**进阶方向1：深入算法**
- 学习遍历的迭代实现（使用栈）
- 学习 AVL 树的旋转操作
- 学习二叉搜索树（BST）

**进阶方向2：AI Agent 应用**
- 学习决策树的信息增益和剪枝
- 学习行为树的选择器和序列节点
- 学习 TreeRAG 分层检索

**进阶方向3：实战项目**
- 实现一个表达式计算器（表达式树）
- 实现一个文件系统（目录树）
- 实现一个 AI Agent 意图分类器

### 推荐学习路径

1. **巩固基础**（1-2 天）
   - 反复练习四种遍历算法
   - 手写树的高度计算
   - 理解递归的执行过程

2. **实战练习**（3-5 天）
   - LeetCode 树相关题目（简单难度）
   - 实现决策树分类器
   - 实现简单的行为树系统

3. **深入学习**（1-2 周）
   - 学习 AVL 树和红黑树
   - 学习决策树的高级算法
   - 学习 TreeRAG 分层检索

---

## 常见问题

### Q1: 为什么要学习四种遍历？

**答：** 不同遍历对应不同的算法语义：
- 前序：先决策再执行（行为树）
- 中序：有序访问（BST 排序）
- 后序：自底向上聚合（删除树）
- 层序：广度优先（分层检索）

### Q2: 递归太难理解怎么办？

**答：** 三步理解递归：
1. **基础情况**：空树返回什么？
2. **递归情况**：假设子树已经处理好，如何处理当前节点？
3. **信任递归**：不要试图在脑海中展开递归，相信递归会正确处理子树

### Q3: 什么时候用决策树？

**答：** 决策树适合：
- 需要可解释的模型
- 特征是离散的或可以离散化
- 数据量不是特别大
- 需要快速训练和预测

### Q4: 如何选择树的最大深度？

**答：** 经验法则：
- 小数据集（< 1000）：max_depth = 3-5
- 中等数据集（1000-10000）：max_depth = 5-10
- 大数据集（> 10000）：max_depth = 10-20
- 使用交叉验证选择最优深度

---

## 总结

**最小可用知识 = 20% 核心 + 80% 效果**

掌握以下内容，你就能解决大部分二叉树问题：

1. **数据结构**：TreeNode 类定义
2. **遍历算法**：四种遍历的递归实现
3. **高度计算**：递归计算树的高度
4. **决策树**：sklearn DecisionTreeClassifier
5. **行为树**：选择器和序列节点

**核心思想：**
- 二叉树是递归定义的
- 遍历顺序决定算法语义
- 平衡树保证性能
- 决策树提供可解释性

**下一步：**
- 练习四种遍历算法
- 实现决策树分类器
- 学习 AVL 树和 TreeRAG

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+, AI Agent 开发, RAG 系统
**学习时间**: 20-30 分钟
