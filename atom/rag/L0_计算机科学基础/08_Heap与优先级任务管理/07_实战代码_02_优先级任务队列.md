# 实战代码02: 优先级任务队列

## 核心目标

**实现一个生产级的优先级任务队列,支持多级优先级、FIFO保证、Aging机制和线程安全。**

---

## 1. 基础实现

```python
import heapq
from enum import IntEnum
from dataclasses import dataclass, field
from typing import Any, Callable
import time

class Priority(IntEnum):
    """优先级定义"""
    URGENT = 0
    HIGH = 1
    NORMAL = 2
    LOW = 3

@dataclass(order=True)
class Task:
    """任务定义"""
    priority: int
    timestamp: float = field(compare=False)
    counter: int = field(compare=False)
    task_id: str = field(compare=False)
    action: Callable = field(compare=False)

class PriorityTaskQueue:
    """优先级任务队列"""

    def __init__(self):
        self.queue = []
        self.counter = 0

    def submit(self, priority: Priority, task_id: str, action: Callable):
        """提交任务"""
        task = Task(
            priority=priority.value,
            timestamp=time.time(),
            counter=self.counter,
            task_id=task_id,
            action=action
        )
        heapq.heappush(self.queue, task)
        self.counter += 1

    def execute_next(self):
        """执行下一个任务"""
        if not self.queue:
            return None

        task = heapq.heappop(self.queue)
        return task.action()

    def size(self):
        """队列大小"""
        return len(self.queue)

# 使用示例
queue = PriorityTaskQueue()
queue.submit(Priority.NORMAL, "task1", lambda: print("Normal task"))
queue.submit(Priority.URGENT, "task2", lambda: print("Urgent task"))
queue.submit(Priority.HIGH, "task3", lambda: print("High priority task"))

while queue.size() > 0:
    queue.execute_next()
```

---

## 2. 线程安全版本

```python
from queue import PriorityQueue
import threading

class ThreadSafePriorityQueue:
    """线程安全的优先级队列"""

    def __init__(self, maxsize=0):
        self.pq = PriorityQueue(maxsize=maxsize)
        self.counter = 0
        self.lock = threading.Lock()

    def submit(self, priority: Priority, task_id: str, action: Callable):
        """提交任务"""
        with self.lock:
            count = self.counter
            self.counter += 1

        task = (priority.value, count, task_id, action)
        self.pq.put(task)

    def execute_next(self, timeout=None):
        """执行下一个任务"""
        try:
            priority, _, task_id, action = self.pq.get(timeout=timeout)
            return action()
        except:
            return None
```

---

## 3. Aging机制

```python
class AgingPriorityQueue:
    """带Aging机制的优先级队列"""

    def __init__(self, age_interval=10):
        self.queue = []
        self.counter = 0
        self.age_interval = age_interval

    def submit(self, priority: Priority, task_id: str, action: Callable):
        """提交任务"""
        task = Task(
            priority=priority.value,
            timestamp=time.time(),
            counter=self.counter,
            task_id=task_id,
            action=action
        )
        heapq.heappush(self.queue, task)
        self.counter += 1

    def apply_aging(self):
        """应用Aging机制"""
        current_time = time.time()
        aged_queue = []

        while self.queue:
            task = heapq.heappop(self.queue)
            wait_time = current_time - task.timestamp
            age_boost = int(wait_time / self.age_interval)
            new_priority = max(0, task.priority - age_boost)

            aged_task = Task(
                priority=new_priority,
                timestamp=task.timestamp,
                counter=task.counter,
                task_id=task.task_id,
                action=task.action
            )
            aged_queue.append(aged_task)

        self.queue = aged_queue
        heapq.heapify(self.queue)
```

---

## 4. RAG应用:AI Agent任务调度

```python
class AgentTaskScheduler:
    """AI Agent任务调度器"""

    def __init__(self):
        self.task_queue = []
        self.counter = 0
        self.metrics = {
            'submitted': 0,
            'executed': 0,
            'wait_times': []
        }

    def submit_task(self, priority: Priority, task_id: str, action: Callable):
        """提交任务"""
        task = Task(
            priority=priority.value,
            timestamp=time.time(),
            counter=self.counter,
            task_id=task_id,
            action=action
        )
        heapq.heappush(self.task_queue, task)
        self.counter += 1
        self.metrics['submitted'] += 1

    def execute_next(self):
        """执行下一个任务"""
        if not self.task_queue:
            return None

        task = heapq.heappop(self.task_queue)
        wait_time = time.time() - task.timestamp
        self.metrics['wait_times'].append(wait_time)
        self.metrics['executed'] += 1

        print(f"Executing {task.task_id} (priority={task.priority}, wait={wait_time:.2f}s)")
        return task.action()

    def get_metrics(self):
        """获取指标"""
        if not self.metrics['wait_times']:
            return self.metrics

        return {
            **self.metrics,
            'avg_wait_time': sum(self.metrics['wait_times']) / len(self.metrics['wait_times']),
            'max_wait_time': max(self.metrics['wait_times']),
        }

# 使用示例
scheduler = AgentTaskScheduler()

# 模拟AI Agent任务
scheduler.submit_task(Priority.URGENT, "user_query", lambda: "Query processed")
scheduler.submit_task(Priority.HIGH, "tool_call", lambda: "Tool executed")
scheduler.submit_task(Priority.NORMAL, "memory_update", lambda: "Memory updated")
scheduler.submit_task(Priority.LOW, "logging", lambda: "Log written")

# 执行所有任务
while scheduler.task_queue:
    scheduler.execute_next()

print(scheduler.get_metrics())
```

---

## 5. 一句话总结

**优先级任务队列使用heap实现O(log n)的插入和提取,支持多级优先级、FIFO保证、Aging机制防止饥饿,广泛应用于操作系统调度、Web服务器和AI Agent任务管理。**
