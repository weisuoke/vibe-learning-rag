# 化骨绵掌

将工具调用与状态管理拆分成 10 个 2 分钟知识卡片，每个独立完整，形成递进学习体系。

---

## 卡片1：工具调用的本质

**一句话：** 工具调用是让 LLM 能够执行外部操作的桥梁，通过 JSON 格式传递参数和结果。

**举例：**
```typescript
// LLM 生成的工具调用
{
  "name": "read",
  "parameters": {
    "path": "./config.json"
  }
}

// Agent 执行后返回
{
  "output": "{ \"port\": 3000, \"host\": \"localhost\" }",
  "error": false
}
```

**应用：** 在 Pi-mono 中，所有工具（read、write、edit、bash）都遵循这个模式：LLM 生成 JSON → Agent 解析执行 → 返回结果。

---

## 卡片2：TypeBox Schema 定义

**一句话：** TypeBox 是轻量级的 Schema 定义库，同时生成 JSON Schema（给 LLM）和 TypeScript 类型（给代码）。

**举例：**
```typescript
import { Type, Static } from '@sinclair/typebox';

// 定义 Schema
const schema = Type.Object({
  path: Type.String({ minLength: 1 }),
  lines: Type.Optional(Type.Object({
    start: Type.Number({ minimum: 1 }),
    end: Type.Number({ minimum: 1 })
  }))
});

// 自动推导 TypeScript 类型
type Params = Static<typeof schema>;
// 等价于: { path: string; lines?: { start: number; end: number } }

// 生成 JSON Schema（给 LLM）
const jsonSchema = schema;
```

**应用：** Pi-mono 使用 TypeBox 而非 Zod，因为更轻量（bundle size 小 10 倍）、更快（验证速度快 2-3 倍）[4]。

---

## 卡片3：AJV 验证器

**一句话：** AJV 是高性能的 JSON Schema 验证器，在工具执行前拦截错误参数。

**举例：**
```typescript
import Ajv from 'ajv';

const ajv = new Ajv();
const validate = ajv.compile(schema);

// 验证参数
const params = { path: './config.json' };
const valid = validate(params);

if (!valid) {
  console.error(validate.errors);
  // [{ instancePath: '/path', message: 'must be string' }]
}
```

**应用：** Pi-mono 在工具注册时预编译验证器，避免运行时编译开销，提升性能。

---

## 卡片4：自纠正机制

**一句话：** 验证失败时返回错误信息给 LLM（不抛异常），让其自动修正，80% 成功率 [3]。

**举例：**
```typescript
// 第一次调用（错误）
{ "name": "read", "params": { "path": "/etc/passwd" } }

// 返回错误（不抛异常）
{
  "output": "Error: Path must be within working directory",
  "error": true
}

// LLM 看到错误，自动修正
{ "name": "read", "params": { "path": "./config.json" } }

// 验证通过，执行成功
```

**应用：** 这是 Pi-mono 可靠性的关键：错误即反馈，让 Agent 能自我修复。

---

## 卡片5：工具注册与发现

**一句话：** 工具注册是将工具的 Schema 和执行函数注册到 Registry，供 Agent 动态调用。

**举例：**
```typescript
class ToolRegistry {
  private tools = new Map<string, Tool>();

  register(tool: Tool) {
    // 预编译验证器
    tool.validator = ajv.compile(tool.schema);
    this.tools.set(tool.name, tool);
  }

  get(name: string): Tool | undefined {
    return this.tools.get(name);
  }

  list(): string[] {
    return Array.from(this.tools.keys());
  }
}

// 注册工具
registry.register({
  name: 'read',
  schema: ReadToolSchema,
  execute: async (params) => { /* ... */ }
});
```

**应用：** Pi-mono 在启动时注册所有工具，Agent 运行时动态查找和调用。

---

## 卡片6：JSONL 追加写入

**一句话：** JSONL 格式每行一个 JSON 对象，支持 O(1) 追加写入，不受文件大小影响。

**举例：**
```typescript
import { appendFile } from 'fs/promises';

// 追加一条消息（O(1) 操作）
const entry = {
  id: '123',
  timestamp: Date.now(),
  type: 'user',
  content: 'Hello'
};

await appendFile(
  'session.jsonl',
  JSON.stringify(entry) + '\n'
);

// 对比：JSON 需要读取整个文件（O(n) 操作）
const data = JSON.parse(await readFile('session.json'));
data.messages.push(entry);
await writeFile('session.json', JSON.stringify(data));
```

**应用：** Pi-mono 使用 JSONL 实现高性能的会话持久化，每次写入 < 1ms。

---

## 卡片7：树形分支结构

**一句话：** 通过 parentId 字段实现树形结构，支持对话分支（用户回退重试）。

**举例：**
```typescript
// 线性对话
{ "id": "1", "parentId": null, "content": "创建项目" }
{ "id": "2", "parentId": "1", "content": "添加功能" }

// 用户回退到消息1，重新尝试
{ "id": "3", "parentId": "1", "content": "修复 bug" }

// 形成树形结构
//     1
//    / \
//   2   3

// 读取分支2的历史
function getHistory(entries, branchId) {
  const history = [];
  let currentId = branchId;

  while (currentId) {
    const entry = entries.find(e => e.id === currentId);
    history.unshift(entry);
    currentId = entry.parentId;
  }

  return history;  // [1, 2]
}
```

**应用：** Pi-mono 支持用户回退重试，每个分支独立，互不影响。

---

## 卡片8：上下文构建

**一句话：** 从 JSONL 文件提取特定分支的消息，构建 LLM 的上下文窗口。

**举例：**
```typescript
async function buildContext(
  sessionPath: string,
  branchId: string
): Promise<Message[]> {
  // 1. 读取所有消息
  const content = await readFile(sessionPath, 'utf-8');
  const entries = content
    .split('\n')
    .filter(line => line.trim())
    .map(line => JSON.parse(line));

  // 2. 回溯到根节点
  const history = [];
  let currentId = branchId;

  while (currentId) {
    const entry = entries.find(e => e.id === currentId);
    if (!entry) break;
    history.unshift(entry);
    currentId = entry.parentId;
  }

  // 3. 转换为 LLM 消息格式
  return history.map(e => ({
    role: e.type === 'user' ? 'user' : 'assistant',
    content: e.content
  }));
}
```

**应用：** Pi-mono 在每次 LLM 调用前构建上下文，确保对话连续性。

---

## 卡片9：并行工具执行

**一句话：** LLM 可以一次生成多个工具调用，Agent 并行执行提升效率。

**举例：**
```typescript
// LLM 生成多个工具调用
const toolCalls = [
  { name: 'read', params: { path: './package.json' } },
  { name: 'read', params: { path: './tsconfig.json' } },
  { name: 'bash', params: { command: 'git status' } }
];

// 并行执行（使用 Promise.all）
const results = await Promise.all(
  toolCalls.map(call => executeTool(call.name, call.params))
);

// 返回所有结果给 LLM
// [
//   { output: '{ "name": "my-app", ... }' },
//   { output: '{ "compilerOptions": { ... } }' },
//   { output: 'On branch main\n...' }
// ]
```

**应用：** Pi-mono 支持并行工具执行，读取多个文件时性能提升 3-5 倍。

---

## 卡片10：生产环境考量

**一句话：** 生产环境需要考虑数据库持久化、可观测性、性能优化和崩溃恢复。

**举例：**
```typescript
// 开发环境：JSONL 文件
await appendFile('session.jsonl', JSON.stringify(entry) + '\n');

// 生产环境：数据库 + JSONL 归档
await db.sessions.create({
  id: entry.id,
  userId: user.id,
  content: entry.content,
  metadata: entry.metadata
});

// 定期归档到 JSONL（冷数据）
if (session.lastAccessTime < Date.now() - 30 * 24 * 3600 * 1000) {
  await archiveToJSONL(session);
  await db.sessions.delete(session.id);
}

// 可观测性：记录指标
metrics.record('tool_execution_time', executionTime);
metrics.record('tool_validation_errors', errorCount);

// 崩溃恢复：从 JSONL 恢复会话
if (crashed) {
  const entries = await loadSession(sessionPath);
  const lastEntry = entries[entries.length - 1];
  await resumeFrom(lastEntry.id);
}
```

**应用：** Pi-mono 的 JSONL 设计天然支持崩溃恢复，生产环境可扩展为混合存储（数据库 + JSONL）[6][10]。

---

## 学习路径建议

### 快速入门（20 分钟）
阅读卡片 1-4，理解工具调用的核心机制：
- 卡片1：工具调用本质
- 卡片2：TypeBox Schema
- 卡片3：AJV 验证
- 卡片4：自纠正机制

### 深入理解（40 分钟）
阅读卡片 5-8，理解状态管理的完整设计：
- 卡片5：工具注册
- 卡片6：JSONL 追加
- 卡片7：树形分支
- 卡片8：上下文构建

### 进阶优化（20 分钟）
阅读卡片 9-10，理解性能优化和生产部署：
- 卡片9：并行执行
- 卡片10：生产环境

---

## 知识卡片速查表

| 卡片 | 主题 | 核心概念 | 应用场景 |
|------|------|---------|---------|
| 1 | 工具调用本质 | JSON 参数传递 | 理解工具调用流程 |
| 2 | TypeBox Schema | 双重生成（JSON Schema + TS 类型） | 定义工具参数 |
| 3 | AJV 验证器 | 高性能验证 | 拦截错误参数 |
| 4 | 自纠正机制 | 错误即反馈 | 提升可靠性 |
| 5 | 工具注册 | 动态查找和调用 | 扩展工具系统 |
| 6 | JSONL 追加 | O(1) 写入性能 | 高频状态写入 |
| 7 | 树形分支 | parentId 关联 | 支持对话分支 |
| 8 | 上下文构建 | 分支回溯 | 构建 LLM 上下文 |
| 9 | 并行执行 | Promise.all | 性能优化 |
| 10 | 生产环境 | 混合存储 + 可观测性 | 生产部署 |

---

**参考文献：**
- [3] Microsoft Agent-Lightning: https://github.com/microsoft/agent-lightning
- [4] TypeBox vs Zod: https://github.com/colinhacks/zod/issues/2482
- [6] Google ADK Context Management: https://github.com/google/adk-python/discussions/826
- [10] Persistent Agent States: https://x.com/NabbilKhan/status/2022064415856538016
