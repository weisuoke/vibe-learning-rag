# 化骨绵掌

将数据一致性与持久化的核心知识拆分成 10 个独立的 2 分钟知识卡片，每个卡片独立完整，可单独理解。

---

## 卡片1：一致性级别的本质

**一句话：** 一致性级别控制的是"读取时能看到多新的数据"，是性能和实时性的权衡。

**举例：**
```python
# Strong：必须看到最新数据（慢）
results = collection.search(data=[query], consistency_level="Strong")

# Eventually：可以看到稍旧的数据（快）
results = collection.search(data=[query], consistency_level="Eventually")
```

**应用：** 实时客服用 Strong，历史查询用 Eventually，通用场景用 Bounded。

---

## 卡片2：WAL 的工作原理

**一句话：** WAL 是"先记账，再转账"的机制，确保数据不丢失。

**举例：**
```
用户插入数据
    ↓
1. 写入 WAL（顺序写，快）
    ↓
2. 写入内存（快速响应）
    ↓
3. 异步刷新到磁盘（后台慢速写）
```

**应用：** 大规模数据导入时，WAL 确保即使系统崩溃也不会丢失数据。

---

## 卡片3：Compaction 的三种类型

**一句话：** Minor 合并小文件，Major 删除无效数据，Full 全量优化。

**举例：**
- **Minor**：10 个小 Segment → 1 个大 Segment
- **Major**：删除 50% 已删除数据，回收空间
- **Full**：重新组织所有数据，最优化

**应用：** 每天自动 Minor，每周手动 Full，确保长期稳定运行。

---

## 卡片4：Segment 的生命周期

**一句话：** Segment 从 Growing（可写）→ Sealed（已封闭）→ Flushed（已持久化）→ Indexed（已索引）。

**举例：**
```python
# Growing：正在写入
collection.insert(data)

# Sealed：达到大小阈值，封闭
# Flushed：刷新到磁盘
collection.flush()

# Indexed：构建索引
collection.create_index(...)
```

**应用：** 理解 Segment 生命周期，优化数据写入和查询性能。

---

## 卡片5：MVCC 多版本并发控制

**一句话：** MVCC 允许多个版本的数据同时存在，支持并发读写和时间旅行查询。

**举例：**
```python
# 插入数据（版本 1）
collection.insert(data_v1)
timestamp_v1 = int(time.time() * 1000)

# 插入数据（版本 2）
collection.insert(data_v2)

# 时间旅行查询（查询版本 1）
results = collection.search(data=[query], travel_timestamp=timestamp_v1)
```

**应用：** 支持历史版本查询，实现数据审计和回滚功能。

---

## 卡片6：一致性级别的性能差异

**一句话：** Strong 比 Eventually 慢 3-5 倍，Bounded 是最佳平衡。

**举例：**
| 一致性级别 | 查询延迟 | 性能比 |
|-----------|---------|--------|
| Strong | 150ms | 4.4x |
| Bounded | 86ms | 2.5x |
| Eventually | 34ms | 1.0x |

**应用：** 99% 的场景使用 Bounded 即可，只有极端场景才需要 Strong。

---

## 卡片7：WAL 的崩溃恢复流程

**一句话：** 系统崩溃后，Milvus 自动从 WAL 读取未刷新的操作并重放，恢复到崩溃前的状态。

**举例：**
```
系统崩溃
    ↓
重启后，读取 WAL
    ↓
重放未刷新的操作
    ↓
恢复到崩溃前的状态
```

**应用：** 用户无感知，自动恢复，确保数据可靠性。

---

## 卡片8：Compaction 的触发条件

**一句话：** 小 Segment 数量 > 10 个触发 Minor，删除数据比例 > 20% 触发 Major。

**举例：**
```python
# 自动触发条件
if small_segments_count > 10:
    trigger_minor_compaction()

if deleted_ratio > 0.2:
    trigger_major_compaction()

# 手动触发
utility.do_compact(collection_name="my_collection")
```

**应用：** 理解触发条件，合理配置 Compaction 策略。

---

## 卡片9：Segment 的查询路由

**一句话：** 查询时，Milvus 根据过滤条件筛选 Segment，并行查询，最后合并结果。

**举例：**
```
查询请求
    ↓
筛选 Segment（根据时间范围、分区等）
    ↓
并行查询所有候选 Segment
    ↓
合并结果，返回 Top-K
```

**应用：** 使用分区和时间过滤，减少扫描的 Segment 数量，提升查询性能。

---

## 卡片10：数据一致性与持久化的最佳实践

**一句话：** 使用 Bounded 一致性、定期 Compaction、监控 WAL 和 Segment 状态。

**举例：**
```python
# 1. 使用 Bounded 一致性（推荐）
results = collection.search(data=[query], consistency_level="Bounded")

# 2. 定期 Compaction（每周一次）
schedule.every().sunday.at("03:00").do(lambda: utility.do_compact("my_collection"))

# 3. 监控 Segment 状态
segments = utility.get_query_segment_info("my_collection")
print(f"Segment 数量: {len(segments)}")

# 4. 批量插入优化
collection.insert(batch_data)  # 批量大小 1000-5000
```

**应用：** 遵循最佳实践，确保 RAG 系统长期稳定运行。

---

## 知识卡片总结

| 卡片 | 主题 | 核心要点 |
|------|------|---------|
| 1 | 一致性级别本质 | 性能 vs 实时性的权衡 |
| 2 | WAL 工作原理 | 先记账，再转账 |
| 3 | Compaction 类型 | Minor、Major、Full |
| 4 | Segment 生命周期 | Growing → Sealed → Flushed → Indexed |
| 5 | MVCC 机制 | 多版本并发控制 |
| 6 | 性能差异 | Strong 慢 4-5 倍 |
| 7 | 崩溃恢复 | 自动从 WAL 恢复 |
| 8 | Compaction 触发 | 自动 + 手动 |
| 9 | 查询路由 | 筛选 + 并行 + 合并 |
| 10 | 最佳实践 | Bounded + Compaction + 监控 |

---

## 学习路径建议

**第一遍：快速浏览**
- 阅读所有卡片的"一句话"，建立整体认知
- 时间：10 分钟

**第二遍：深入理解**
- 阅读每个卡片的详细内容和举例
- 运行代码示例，验证理解
- 时间：30 分钟

**第三遍：实战应用**
- 在自己的 RAG 项目中应用这些知识
- 根据业务场景选择合适的一致性级别
- 配置 Compaction 策略
- 监控系统状态
- 时间：1-2 小时

---

## 常见问题速查

**Q1：如何选择一致性级别？**
A：实时场景用 Strong，历史场景用 Eventually，通用场景用 Bounded。

**Q2：WAL 会占用多少空间？**
A：通常不超过数据的 10%，自动清理。

**Q3：Compaction 会影响查询吗？**
A：不会，使用 MVCC 保证并发安全。

**Q4：如何监控 Segment 状态？**
A：使用 `utility.get_query_segment_info()` 查看。

**Q5：删除数据后空间为什么没释放？**
A：需要运行 Compaction 才能物理删除数据。

---

## 进阶学习建议

1. **深入理解 MVCC**：学习分布式系统的版本控制机制
2. **研究 Compaction 算法**：了解 LSM-Tree 的合并策略
3. **学习分布式一致性**：研究 Raft、Paxos 等一致性协议
4. **性能调优实战**：在生产环境中优化一致性和性能
5. **监控与运维**：建立完善的监控和告警体系

通过这 10 个知识卡片，你已经掌握了 Milvus 数据一致性与持久化的核心知识！
