# 核心概念03：任务状态管理

> 深入理解任务状态机设计、数据库模型、进度追踪和结果存储

---

## 什么是任务状态管理？

### 定义

**任务状态管理 = 状态机设计 + 数据库持久化 + 状态查询接口**

任务状态管理是追踪长任务执行状态、进度和结果的系统，确保任务的可追溯性和可恢复性。

### 核心问题

```
问题1：如何知道任务是否完成？
解决：状态机（pending → running → completed/failed）

问题2：如何知道任务进度？
解决：进度字段（0.0-100.0）

问题3：任务失败后如何恢复？
解决：持久化存储（数据库）

问题4：如何查询任务历史？
解决：查询接口（API端点）
```

---

## 任务状态机设计

### 1. 基础状态机

```
┌─────────┐
│ PENDING │  待处理（任务已创建，等待执行）
└────┬────┘
     │
     ↓
┌─────────┐
│ RUNNING │  执行中（Worker正在处理）
└────┬────┘
     │
     ├──────────┐
     ↓          ↓
┌───────────┐ ┌─────────┐
│ COMPLETED │ │ FAILED  │  完成/失败（最终状态）
└───────────┘ └─────────┘
```

**状态说明**：

| 状态 | 含义 | 可转换到 | 是否最终状态 |
|------|------|---------|-------------|
| **PENDING** | 任务已创建，等待Worker执行 | RUNNING | ❌ |
| **RUNNING** | Worker正在执行任务 | COMPLETED, FAILED | ❌ |
| **COMPLETED** | 任务成功完成 | - | ✅ |
| **FAILED** | 任务执行失败 | - | ✅ |

---

### 2. 扩展状态机（包含重试）

```
┌─────────┐
│ PENDING │
└────┬────┘
     │
     ↓
┌─────────┐
│ RUNNING │
└────┬────┘
     │
     ├──────────┬──────────┐
     ↓          ↓          ↓
┌───────────┐ ┌─────────┐ ┌─────────┐
│ COMPLETED │ │ RETRY   │ │ FAILED  │
└───────────┘ └────┬────┘ └─────────┘
                   │
                   ↓
              ┌─────────┐
              │ RUNNING │  重新执行
              └─────────┘
```

**扩展状态**：

| 状态 | 含义 | 可转换到 | 是否最终状态 |
|------|------|---------|-------------|
| **PENDING** | 任务已创建 | RUNNING | ❌ |
| **RUNNING** | 执行中 | COMPLETED, RETRY, FAILED | ❌ |
| **RETRY** | 等待重试 | RUNNING | ❌ |
| **COMPLETED** | 成功完成 | - | ✅ |
| **FAILED** | 最终失败 | - | ✅ |

---

### 3. 完整状态机（生产级）

```
┌─────────┐
│ PENDING │
└────┬────┘
     │
     ↓
┌─────────┐
│ RUNNING │
└────┬────┘
     │
     ├──────────┬──────────┬──────────┐
     ↓          ↓          ↓          ↓
┌───────────┐ ┌─────────┐ ┌─────────┐ ┌──────────┐
│ COMPLETED │ │ RETRY   │ │ FAILED  │ │ CANCELED │
└───────────┘ └────┬────┘ └─────────┘ └──────────┘
                   │
                   ↓
              ┌─────────┐
              │ RUNNING │
              └─────────┘
```

**完整状态**：

| 状态 | 含义 | 可转换到 | 是否最终状态 |
|------|------|---------|-------------|
| **PENDING** | 任务已创建 | RUNNING, CANCELED | ❌ |
| **RUNNING** | 执行中 | COMPLETED, RETRY, FAILED, CANCELED | ❌ |
| **RETRY** | 等待重试 | RUNNING, FAILED | ❌ |
| **COMPLETED** | 成功完成 | - | ✅ |
| **FAILED** | 最终失败 | - | ✅ |
| **CANCELED** | 用户取消 | - | ✅ |

---

## 数据库模型设计

### 1. 基础任务模型

```python
# app/models/task.py
from sqlalchemy import Column, Integer, String, Float, DateTime, Text, Enum
from sqlalchemy.sql import func
from app.core.database import Base
import enum

class TaskStatus(str, enum.Enum):
    """任务状态枚举"""
    PENDING = "pending"
    RUNNING = "running"
    RETRY = "retry"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELED = "canceled"

class Task(Base):
    """任务模型"""
    __tablename__ = "tasks"

    # 主键
    id = Column(Integer, primary_key=True, index=True)

    # Celery任务ID
    task_id = Column(String, unique=True, index=True, nullable=False)

    # 任务类型
    task_type = Column(String, index=True, nullable=False)
    # 例如：document_process, batch_generate, vector_search

    # 任务状态
    status = Column(
        Enum(TaskStatus),
        default=TaskStatus.PENDING,
        index=True,
        nullable=False
    )

    # 进度（0.0-100.0）
    progress = Column(Float, default=0.0, nullable=False)

    # 任务结果（JSON格式）
    result = Column(Text, nullable=True)

    # 错误信息
    error = Column(Text, nullable=True)

    # 重试次数
    retry_count = Column(Integer, default=0, nullable=False)

    # 时间戳
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    updated_at = Column(DateTime, onupdate=func.now())
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)

    def __repr__(self):
        return f"<Task(id={self.id}, task_id={self.task_id}, status={self.status})>"
```

**字段说明**：

| 字段 | 类型 | 说明 | 索引 |
|------|------|------|------|
| `id` | Integer | 主键 | ✅ |
| `task_id` | String | Celery任务ID | ✅ 唯一 |
| `task_type` | String | 任务类型 | ✅ |
| `status` | Enum | 任务状态 | ✅ |
| `progress` | Float | 进度（0-100） | ❌ |
| `result` | Text | 结果（JSON） | ❌ |
| `error` | Text | 错误信息 | ❌ |
| `retry_count` | Integer | 重试次数 | ❌ |
| `created_at` | DateTime | 创建时间 | ❌ |
| `updated_at` | DateTime | 更新时间 | ❌ |
| `started_at` | DateTime | 开始时间 | ❌ |
| `completed_at` | DateTime | 完成时间 | ❌ |

---

### 2. 扩展任务模型（包含用户和元数据）

```python
# app/models/task.py
from sqlalchemy import Column, Integer, String, Float, DateTime, Text, Enum, ForeignKey, JSON
from sqlalchemy.orm import relationship

class Task(Base):
    """扩展任务模型"""
    __tablename__ = "tasks"

    # 基础字段
    id = Column(Integer, primary_key=True, index=True)
    task_id = Column(String, unique=True, index=True, nullable=False)
    task_type = Column(String, index=True, nullable=False)
    status = Column(Enum(TaskStatus), default=TaskStatus.PENDING, index=True)
    progress = Column(Float, default=0.0)

    # 用户关联
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=True)
    user = relationship("User", back_populates="tasks")

    # 任务参数（JSON格式）
    params = Column(JSON, nullable=True)
    # 例如：{"files": ["/path/to/file1.pdf", "/path/to/file2.pdf"]}

    # 任务结果（JSON格式）
    result = Column(JSON, nullable=True)
    # 例如：{"files_processed": 10, "total_words": 10000}

    # 错误信息
    error = Column(Text, nullable=True)

    # 元数据（JSON格式）
    metadata = Column(JSON, nullable=True)
    # 例如：{"source": "web", "ip": "192.168.1.1"}

    # 重试信息
    retry_count = Column(Integer, default=0)
    max_retries = Column(Integer, default=3)

    # 时间戳
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, onupdate=func.now())
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)

    # 任务优先级
    priority = Column(Integer, default=0, index=True)
    # 数字越大优先级越高

    # 任务标签
    tags = Column(JSON, nullable=True)
    # 例如：["urgent", "high-priority"]
```

---

### 3. 数据库迁移

```bash
# 创建迁移
alembic revision --autogenerate -m "create tasks table"

# 执行迁移
alembic upgrade head
```

```python
# alembic/versions/xxx_create_tasks_table.py
def upgrade():
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('task_id', sa.String(), nullable=False),
        sa.Column('task_type', sa.String(), nullable=False),
        sa.Column('status', sa.Enum('pending', 'running', 'retry', 'completed', 'failed', 'canceled', name='taskstatus'), nullable=False),
        sa.Column('progress', sa.Float(), nullable=False),
        sa.Column('result', sa.Text(), nullable=True),
        sa.Column('error', sa.Text(), nullable=True),
        sa.Column('retry_count', sa.Integer(), nullable=False),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=True),
        sa.Column('started_at', sa.DateTime(), nullable=True),
        sa.Column('completed_at', sa.DateTime(), nullable=True),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_tasks_task_id'), 'tasks', ['task_id'], unique=True)
    op.create_index(op.f('ix_tasks_task_type'), 'tasks', ['task_type'], unique=False)
    op.create_index(op.f('ix_tasks_status'), 'tasks', ['status'], unique=False)
```

---

## 状态更新与查询

### 1. 创建任务

```python
# app/services/task_service.py
from app.models.task import Task, TaskStatus
from app.core.database import SessionLocal
from datetime import datetime

def create_task(task_type: str, task_id: str, params: dict = None) -> Task:
    """创建任务记录"""
    db = SessionLocal()

    task = Task(
        task_id=task_id,
        task_type=task_type,
        status=TaskStatus.PENDING,
        progress=0.0,
        params=params,
        created_at=datetime.utcnow()
    )

    db.add(task)
    db.commit()
    db.refresh(task)
    db.close()

    return task
```

---

### 2. 更新任务状态

```python
def update_task_status(
    task_id: str,
    status: TaskStatus,
    progress: float = None,
    error: str = None
) -> Task:
    """更新任务状态"""
    db = SessionLocal()

    task = db.query(Task).filter(Task.task_id == task_id).first()

    if not task:
        db.close()
        raise ValueError(f"Task {task_id} not found")

    # 更新状态
    task.status = status
    task.updated_at = datetime.utcnow()

    # 更新进度
    if progress is not None:
        task.progress = progress

    # 更新错误信息
    if error:
        task.error = error

    # 更新时间戳
    if status == TaskStatus.RUNNING and not task.started_at:
        task.started_at = datetime.utcnow()

    if status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELED]:
        task.completed_at = datetime.utcnow()

    db.commit()
    db.refresh(task)
    db.close()

    return task
```

---

### 3. 更新任务进度

```python
def update_task_progress(task_id: str, progress: float, message: str = None):
    """更新任务进度"""
    db = SessionLocal()

    task = db.query(Task).filter(Task.task_id == task_id).first()

    if not task:
        db.close()
        return

    # 更新进度
    task.progress = min(max(progress, 0.0), 100.0)  # 限制在0-100
    task.updated_at = datetime.utcnow()

    # 更新元数据中的消息
    if message:
        if not task.metadata:
            task.metadata = {}
        task.metadata['message'] = message

    db.commit()
    db.close()
```

---

### 4. 查询任务

```python
def get_task(task_id: str) -> Task:
    """查询单个任务"""
    db = SessionLocal()
    task = db.query(Task).filter(Task.task_id == task_id).first()
    db.close()
    return task

def get_tasks_by_status(status: TaskStatus, limit: int = 100) -> List[Task]:
    """查询指定状态的任务"""
    db = SessionLocal()
    tasks = db.query(Task).filter(Task.status == status).limit(limit).all()
    db.close()
    return tasks

def get_user_tasks(user_id: int, limit: int = 100) -> List[Task]:
    """查询用户的任务"""
    db = SessionLocal()
    tasks = db.query(Task).filter(Task.user_id == user_id).order_by(Task.created_at.desc()).limit(limit).all()
    db.close()
    return tasks

def get_running_tasks() -> List[Task]:
    """查询所有运行中的任务"""
    db = SessionLocal()
    tasks = db.query(Task).filter(Task.status == TaskStatus.RUNNING).all()
    db.close()
    return tasks
```

---

## 进度追踪

### 1. 进度计算

```python
def calculate_progress(completed: int, total: int) -> float:
    """计算进度百分比"""
    if total == 0:
        return 0.0
    return (completed / total) * 100.0

# 示例
total_files = 100
processed_files = 30
progress = calculate_progress(processed_files, total_files)  # 30.0
```

---

### 2. 分步进度更新

```python
# app/tasks.py
from app.celery_app import app
from app.services.task_service import update_task_progress

@app.task(bind=True)
def process_documents(self, db_task_id: int, files: List[str]):
    """处理文档并更新进度"""
    total = len(files)

    for i, file in enumerate(files):
        # 步骤1：解析PDF（33%）
        content = parse_pdf(file)
        progress = ((i + 0.33) / total) * 100
        update_task_progress(self.request.id, progress, f"解析文件 {i+1}/{total}")

        # 步骤2：生成Embedding（66%）
        embedding = generate_embedding(content)
        progress = ((i + 0.66) / total) * 100
        update_task_progress(self.request.id, progress, f"生成Embedding {i+1}/{total}")

        # 步骤3：保存到向量库（100%）
        save_to_vectordb(embedding)
        progress = ((i + 1) / total) * 100
        update_task_progress(self.request.id, progress, f"保存到向量库 {i+1}/{total}")

    return {"files_processed": total}
```

---

### 3. 进度推送

```python
# app/main.py
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import asyncio
import json

app = FastAPI()

@app.get("/tasks/{task_id}/progress")
async def get_task_progress(task_id: str):
    """查询任务进度（轮询）"""
    task = get_task(task_id)

    if not task:
        return {"error": "Task not found"}

    return {
        "task_id": task_id,
        "status": task.status.value,
        "progress": task.progress,
        "message": task.metadata.get('message') if task.metadata else None
    }

@app.get("/tasks/{task_id}/stream")
async def stream_task_progress(task_id: str):
    """实时推送任务进度（SSE）"""
    async def generate():
        while True:
            task = get_task(task_id)

            if not task:
                yield f"data: {json.dumps({'error': 'Task not found'})}\n\n"
                break

            data = {
                "task_id": task_id,
                "status": task.status.value,
                "progress": task.progress,
                "message": task.metadata.get('message') if task.metadata else None
            }

            yield f"data: {json.dumps(data)}\n\n"

            # 任务完成，停止推送
            if task.status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELED]:
                break

            await asyncio.sleep(1)

    return StreamingResponse(generate(), media_type="text/event-stream")
```

---

## 结果存储策略

### 1. 小结果存储（<1MB）

```python
# 直接存储在数据库中
task.result = json.dumps({
    "files_processed": 10,
    "total_words": 10000,
    "summary": "处理完成"
})
```

---

### 2. 大结果存储（>1MB）

```python
# 存储在对象存储（S3/MinIO）
import boto3

def save_large_result(task_id: str, result: dict):
    """保存大结果到S3"""
    s3 = boto3.client('s3')

    # 上传到S3
    key = f"task-results/{task_id}.json"
    s3.put_object(
        Bucket='my-bucket',
        Key=key,
        Body=json.dumps(result)
    )

    # 数据库中存储S3路径
    task = get_task(task_id)
    task.result = json.dumps({
        "type": "s3",
        "bucket": "my-bucket",
        "key": key
    })
    save_task(task)

def get_large_result(task_id: str) -> dict:
    """从S3获取大结果"""
    task = get_task(task_id)
    result_meta = json.loads(task.result)

    if result_meta['type'] == 's3':
        s3 = boto3.client('s3')
        obj = s3.get_object(
            Bucket=result_meta['bucket'],
            Key=result_meta['key']
        )
        return json.loads(obj['Body'].read())

    return result_meta
```

---

### 3. 流式结果存储

```python
# 存储在Redis Stream
import redis

def save_streaming_result(task_id: str, chunk: dict):
    """保存流式结果到Redis Stream"""
    r = redis.Redis()
    r.xadd(f"task:{task_id}:stream", chunk)

def get_streaming_results(task_id: str):
    """获取流式结果"""
    r = redis.Redis()
    results = r.xrange(f"task:{task_id}:stream")
    return [json.loads(result[1][b'data']) for result in results]
```

---

## 任务取消

### 1. 取消任务

```python
def cancel_task(task_id: str):
    """取消任务"""
    from celery.result import AsyncResult

    # 更新数据库状态
    update_task_status(task_id, TaskStatus.CANCELED)

    # 撤销Celery任务
    result = AsyncResult(task_id, app=app)
    result.revoke(terminate=True)
```

---

### 2. Worker检查取消状态

```python
@app.task(bind=True)
def process_documents(self, db_task_id: int, files: List[str]):
    """处理文档（支持取消）"""
    for i, file in enumerate(files):
        # 检查任务是否被取消
        task = get_task(self.request.id)
        if task.status == TaskStatus.CANCELED:
            print("任务已取消，停止执行")
            return {"status": "canceled"}

        # 处理文件
        process_file(file)

        # 更新进度
        progress = (i + 1) / len(files) * 100
        update_task_progress(self.request.id, progress)

    return {"files_processed": len(files)}
```

---

## 任务清理

### 1. 清理过期任务

```python
from datetime import datetime, timedelta

def cleanup_old_tasks(days: int = 30):
    """清理N天前的已完成任务"""
    db = SessionLocal()

    cutoff_date = datetime.utcnow() - timedelta(days=days)

    # 删除已完成的旧任务
    db.query(Task).filter(
        Task.status.in_([TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELED]),
        Task.completed_at < cutoff_date
    ).delete()

    db.commit()
    db.close()

# 定时任务
@app.task
def scheduled_cleanup():
    """定时清理任务"""
    cleanup_old_tasks(days=30)
```

---

### 2. 清理孤儿任务

```python
def cleanup_orphan_tasks():
    """清理孤儿任务（Worker已停止但状态仍为RUNNING）"""
    from celery.result import AsyncResult

    db = SessionLocal()

    # 查询所有RUNNING状态的任务
    running_tasks = db.query(Task).filter(Task.status == TaskStatus.RUNNING).all()

    for task in running_tasks:
        # 检查Celery任务状态
        result = AsyncResult(task.task_id, app=app)

        if result.state == 'PENDING':
            # Celery中不存在，标记为失败
            task.status = TaskStatus.FAILED
            task.error = "Worker stopped unexpectedly"
            task.completed_at = datetime.utcnow()

    db.commit()
    db.close()
```

---

## 最佳实践

### 1. 状态转换验证

```python
def validate_status_transition(current: TaskStatus, new: TaskStatus) -> bool:
    """验证状态转换是否合法"""
    valid_transitions = {
        TaskStatus.PENDING: [TaskStatus.RUNNING, TaskStatus.CANCELED],
        TaskStatus.RUNNING: [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.RETRY, TaskStatus.CANCELED],
        TaskStatus.RETRY: [TaskStatus.RUNNING, TaskStatus.FAILED],
        TaskStatus.COMPLETED: [],
        TaskStatus.FAILED: [],
        TaskStatus.CANCELED: []
    }

    return new in valid_transitions.get(current, [])

def update_task_status_safe(task_id: str, new_status: TaskStatus):
    """安全更新任务状态（验证转换）"""
    task = get_task(task_id)

    if not validate_status_transition(task.status, new_status):
        raise ValueError(f"Invalid status transition: {task.status} -> {new_status}")

    update_task_status(task_id, new_status)
```

---

### 2. 事务性更新

```python
from sqlalchemy.orm import Session

def update_task_with_transaction(db: Session, task_id: str, updates: dict):
    """事务性更新任务"""
    try:
        task = db.query(Task).filter(Task.task_id == task_id).with_for_update().first()

        if not task:
            raise ValueError(f"Task {task_id} not found")

        # 更新字段
        for key, value in updates.items():
            setattr(task, key, value)

        task.updated_at = datetime.utcnow()

        db.commit()
        return task

    except Exception as e:
        db.rollback()
        raise e
```

---

### 3. 索引优化

```python
# 创建复合索引
op.create_index(
    'ix_tasks_status_created_at',
    'tasks',
    ['status', 'created_at']
)

# 查询优化
def get_recent_failed_tasks(limit: int = 100):
    """查询最近失败的任务（使用复合索引）"""
    db = SessionLocal()
    tasks = db.query(Task).filter(
        Task.status == TaskStatus.FAILED
    ).order_by(
        Task.created_at.desc()
    ).limit(limit).all()
    db.close()
    return tasks
```

---

## 总结

### 任务状态管理核心要点

1. **状态机设计**：明确状态转换规则
2. **数据库持久化**：确保任务可追溯
3. **进度追踪**：实时更新进度（0-100%）
4. **结果存储**：根据大小选择存储策略
5. **任务清理**：定期清理过期任务

### 实现检查清单

- [ ] 设计状态机（pending → running → completed/failed）
- [ ] 创建数据库模型（Task表）
- [ ] 实现CRUD操作（创建、查询、更新、删除）
- [ ] 实现进度追踪（分步更新）
- [ ] 实现结果存储（小结果/大结果）
- [ ] 实现任务取消（撤销Celery任务）
- [ ] 实现任务清理（定时清理过期任务）

---

**记住**：任务状态管理是长任务处理的核心，确保任务的可追溯性和可恢复性。
