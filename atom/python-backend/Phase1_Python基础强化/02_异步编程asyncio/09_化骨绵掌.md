# 化骨绵掌：10个2分钟知识卡片

> 快速掌握 asyncio 的核心知识点

---

## 卡片1：事件循环是什么？

**一句话：** 事件循环是 asyncio 的核心调度器，负责管理和执行所有协程任务。

**举例：**
```python
import asyncio

async def main():
    print("Hello, asyncio!")

# asyncio.run() 创建事件循环并运行主函数
asyncio.run(main())
```

**类比：** 事件循环就像餐厅的服务员，不断轮询"哪个任务可以继续执行"，在等待 I/O 时去服务其他客人。

**应用：** FastAPI 自动管理事件循环，每个请求在同一个事件循环中执行，实现高并发。

---

## 卡片2：async def 和 await 的关系

**一句话：** `async def` 定义可以暂停的函数，`await` 暂停当前函数并让出控制权。

**举例：**
```python
async def fetch_data():
    await asyncio.sleep(1)  # 暂停1秒，让事件循环处理其他任务
    return "data"

# 必须 await 才能执行
result = await fetch_data()
```

**关键点：**
- `async def` 只是声明，调用时返回协程对象（不执行）
- `await` 才真正执行协程
- 只能在 `async def` 函数内使用 `await`

**应用：** 在 FastAPI 路由中，使用 `async def` 定义路由函数，用 `await` 调用数据库查询和 API。

---

## 卡片3：串行 vs 并发执行

**一句话：** 连续 `await` 是串行执行，`asyncio.gather()` 是并发执行。

**对比：**
```python
# 串行：总耗时 3 秒
user1 = await fetch_user(1)  # 1秒
user2 = await fetch_user(2)  # 1秒
user3 = await fetch_user(3)  # 1秒

# 并发：总耗时 1 秒
users = await asyncio.gather(
    fetch_user(1),
    fetch_user(2),
    fetch_user(3)
)
```

**性能提升：** 3倍

**应用：** 并发调用多个 LLM API，获取多个模型的回答，总耗时等于最慢的那个。

---

## 卡片4：Task 是什么？

**一句话：** Task 是协程的包装器，创建后立即加入事件循环在后台运行。

**举例：**
```python
# 创建 Task，不等待
task = asyncio.create_task(send_email())

# 继续执行其他操作
print("继续处理...")

# 稍后等待 Task 完成
await task
```

**对比：**
- 协程对象：必须 `await` 才执行
- Task 对象：创建后立即在后台运行

**应用：** FastAPI 的 BackgroundTasks，在后台发送邮件、记录日志，不阻塞响应。

---

## 卡片5：异步不是并行

**一句话：** 异步是单线程并发（在等待时做其他事），并行是多线程/多进程（真正同时执行）。

**对比：**
```
异步（单线程）：
任务A: [等待]     [继续]
任务B:   [等待]     [继续]
任务C:     [等待]     [继续]

并行（多线程）：
线程1: [任务A执行中...]
线程2: [任务B执行中...]
线程3: [任务C执行中...]
```

**适用场景：**
- 异步：I/O 密集型（API 调用、数据库查询）
- 并行：CPU 密集型（图像处理、数学计算）

**应用：** AI Agent 的 LLM API 调用用异步，图像预处理用多进程。

---

## 卡片6：await 不会阻塞整个程序

**一句话：** `await` 只阻塞当前协程，不阻塞事件循环，其他协程可以继续执行。

**可视化：**
```
同步代码（阻塞整个程序）：
请求1: [========等待========] 完成
请求2:                      [========等待========] 完成

异步代码（只阻塞当前协程）：
请求1: [等待]     [继续]
请求2:   [等待]     [继续]
请求3:     [等待]     [继续]
```

**关键洞察：** `await` 是"让出控制权"，不是"阻塞等待"。

**应用：** FastAPI 可以同时处理 1000+ 个请求，因为每个请求的 `await` 只暂停当前请求的协程。

---

## 卡片7：asyncio.gather() 的错误处理

**一句话：** 默认任何一个任务失败就抛出异常，使用 `return_exceptions=True` 继续执行所有任务。

**举例：**
```python
# 默认行为：任何一个失败就停止
results = await asyncio.gather(
    task1(),
    task2(),  # 如果失败，整体失败
    task3()
)

# 继续执行：收集所有结果和异常
results = await asyncio.gather(
    task1(),
    task2(),
    task3(),
    return_exceptions=True
)

for result in results:
    if isinstance(result, Exception):
        print(f"失败: {result}")
```

**应用：** 并发调用多个 LLM API，即使某个 API 失败，其他 API 的结果仍然可用。

---

## 卡片8：超时控制

**一句话：** 使用 `asyncio.wait_for()` 设置超时，超时后抛出 `asyncio.TimeoutError`。

**举例：**
```python
try:
    result = await asyncio.wait_for(
        slow_operation(),
        timeout=5.0  # 5秒超时
    )
except asyncio.TimeoutError:
    print("操作超时")
```

**最佳实践：**
- 数据库查询：5-10秒
- LLM API 调用：30-60秒
- 文件上传：根据文件大小动态设置

**应用：** 防止某个慢请求拖垮整个系统，及时返回错误给用户。

---

## 卡片9：异步生成器（流式响应）

**一句话：** 异步生成器用 `async def` + `yield` 定义，用 `async for` 消费，实现流式输出。

**举例：**
```python
# 定义异步生成器
async def stream_response():
    for i in range(10):
        await asyncio.sleep(0.1)
        yield f"Chunk {i}"

# 消费异步生成器
async for chunk in stream_response():
    print(chunk)
```

**FastAPI 应用：**
```python
from fastapi.responses import StreamingResponse

@app.get("/stream")
async def stream():
    return StreamingResponse(
        stream_response(),
        media_type="text/plain"
    )
```

**应用：** AI Agent 的流式对话，逐字输出回答，用户体验更好。

---

## 卡片10：何时用异步、何时用同步？

**一句话：** I/O 时间占比 > 50% 用异步，否则用同步（或多进程）。

**判断标准：**
```python
# ✅ 用异步：I/O 密集型
async def call_api():
    response = await client.get(url)  # 网络 I/O
    data = await db.query(sql)        # 数据库 I/O
    return data

# ❌ 不用异步：CPU 密集型
def process_image(image):
    result = complex_algorithm(image)  # CPU 计算
    return result
```

**性能对比：**
- I/O 密集型用异步：提升 3-10 倍
- CPU 密集型用异步：提升 0-1.1 倍（甚至更慢）
- CPU 密集型用多进程：提升 N 倍（N = CPU 核心数）

**应用：** AI Agent 的 LLM API 调用用异步，文本预处理用同步，图像处理用多进程。

---

## 快速参考表

| 概念 | 语法 | 用途 |
|------|------|------|
| 定义异步函数 | `async def func():` | 创建可暂停的函数 |
| 等待异步操作 | `await func()` | 暂停当前协程 |
| 并发执行 | `asyncio.gather()` | 同时执行多个任务 |
| 后台任务 | `asyncio.create_task()` | 创建不阻塞的任务 |
| 超时控制 | `asyncio.wait_for()` | 设置操作超时 |
| 运行主函数 | `asyncio.run()` | 启动事件循环 |
| 流式输出 | `async def` + `yield` | 异步生成器 |
| 异常处理 | `try-except` | 捕获异步异常 |

---

## 常见误区速查

| 误区 | 正确理解 |
|------|---------|
| async def 自动并发 | 需要 gather/create_task |
| 异步一定更快 | 只在 I/O 密集型有优势 |
| await 阻塞整个程序 | 只阻塞当前协程 |
| 协程会自动执行 | 必须 await 或 create_task |
| 异步 = 并行 | 异步是单线程并发 |

---

## 学习路径

```
1. 理解事件循环 → 2. 掌握 async/await → 3. 学会并发执行
   ↓                    ↓                      ↓
4. 使用 Task → 5. 处理异常和超时 → 6. 实现流式响应
   ↓                    ↓                      ↓
7. 在 FastAPI 中应用 → 8. 优化性能 → 9. 生产环境部署
```

---

## 实战检查清单

完成以下任务，确保你真正掌握了 asyncio：

- [ ] 编写一个异步函数，使用 `await` 调用
- [ ] 使用 `asyncio.gather()` 并发执行 3 个任务
- [ ] 创建一个后台任务，不等待其完成
- [ ] 为异步操作设置 5 秒超时
- [ ] 处理 `asyncio.gather()` 中的异常
- [ ] 实现一个异步生成器，用于流式输出
- [ ] 在 FastAPI 中创建一个异步路由
- [ ] 实现带重试的异步 API 调用
- [ ] 并发查询数据库和调用 API
- [ ] 实现 AI Agent 的流式对话

---

## 下一步学习

完成本知识点后，建议：

1. **立即实践**：在实际项目中应用 asyncio
2. **继续学习**：Phase2_FastAPI核心 - 路由与依赖注入
3. **深入理解**：阅读 asyncio 源码，理解底层实现
4. **性能优化**：学习如何监控和优化异步代码性能

---

**记住：** asyncio 的核心是"在等待 I/O 时，让 CPU 去做其他事情"。理解这一点，你就理解了异步编程的全部。
