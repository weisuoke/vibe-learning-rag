# 化骨绵掌

> 10 个 2 分钟卡片，帮助你完全掌握 Session 存储与树形结构

---

## 使用说明

**化骨绵掌**是一种学习方法：
- 每个卡片 2 分钟
- 10 个卡片 = 20 分钟
- 每天复习一遍，连续 7 天
- 知识就会"化入骨髓"

**复习方法：**
1. 读卡片正面（问题）
2. 尝试回答
3. 翻到背面（答案）
4. 检查自己的理解

---

## 卡片 1：直觉理解 - 会话是什么

### 正面

**会话（Session）的本质是什么？**

### 背面

**会话 = 消息序列 + 时间顺序 + 分支关系**

**类比：**
- 像一本日记：按时间记录对话
- 像一棵树：可以有多个分支
- 像 Git 历史：可以回溯和分支

**三个核心需求：**
1. **持久化**：对话需要保存
2. **可追溯**：可以查看历史
3. **可分支**：可以探索不同路径

**记忆锚点：**
> 会话就是"带分支的对话历史"

---

## 卡片 2：JSONL 格式定义

### 正面

**什么是 JSONL 格式？为什么用它？**

### 背面

**JSONL = JSON Lines**

每行一个独立的 JSON 对象：
```jsonl
{"id": "1", "content": "Hello"}
{"id": "2", "content": "World"}
```

**为什么用 JSONL？**

| 特性 | JSONL | JSON Array |
|------|-------|------------|
| 追加写入 | ✅ O(1) | ❌ O(n) |
| 流式处理 | ✅ 逐行 | ❌ 全部加载 |
| 错误恢复 | ✅ 单行错误 | ❌ 整个文件 |

**性能对比：**
- 1000 条消息追加：JSONL 100ms vs JSON Array 5000ms
- 快 50 倍！

**记忆锚点：**
> JSONL = 日志文件 = 只追加不修改

---

## 卡片 3：追加写入机制

### 正面

**追加写入（Append-only）是如何工作的？**

### 背面

**核心思想：只在文件末尾添加，不修改现有内容**

**代码示例：**
```typescript
// 追加新条目
function appendEntry(entry: SessionEntry): void {
  const line = JSON.stringify(entry) + '\n';
  fs.appendFileSync('session.jsonl', line);
}
```

**三大优势：**
1. **性能**：O(1) 复杂度，与文件大小无关
2. **并发**：多进程可以同时追加
3. **可靠**：写入失败不影响历史数据

**懒刷新优化：**
```typescript
// 批量写入，减少磁盘 I/O
private writeBuffer: string[] = [];

append(entry): void {
  this.writeBuffer.push(JSON.stringify(entry));
  this.scheduleFlush();  // 延迟刷新
}
```

**记忆锚点：**
> 追加写入 = 只能往后翻页的笔记本

---

## 卡片 4：id/parentId 树形结构

### 正面

**如何用 id/parentId 表示树形结构？**

### 背面

**核心设计：每个节点有 id 和 parentId**

```typescript
interface SessionEntry {
  id: string;           // 当前节点 ID
  parentId: string | null; // 父节点 ID
  content?: string;
}
```

**扁平存储：**
```jsonl
{"id": "root", "parentId": null}
{"id": "msg1", "parentId": "root"}
{"id": "msg2", "parentId": "msg1"}
{"id": "msg3", "parentId": "msg2"}
{"id": "msg4", "parentId": "msg2"}
```

**树形结构：**
```
root
└── msg1
    └── msg2
        ├── msg3
        └── msg4
```

**为什么优秀？**
- 简单：只需两个字段
- 灵活：支持任意分支
- 高效：追加写入友好

**记忆锚点：**
> id/parentId = 链表指针 = 接龙游戏

---

## 卡片 5：树的构建算法

### 正面

**如何从扁平的 JSONL 构建树？**

### 背面

**两步法：**

**步骤 1：建立映射**
```typescript
// ID 映射
const entryMap = new Map<string, Entry>();
for (const entry of entries) {
  entryMap.set(entry.id, entry);
}

// 父子关系映射
const childrenMap = new Map<string, Entry[]>();
for (const entry of entries) {
  if (entry.parentId) {
    if (!childrenMap.has(entry.parentId)) {
      childrenMap.set(entry.parentId, []);
    }
    childrenMap.get(entry.parentId).push(entry);
  }
}
```

**步骤 2：递归构建**
```typescript
function buildTree(id: string): TreeNode {
  const entry = entryMap.get(id);
  const children = childrenMap.get(id) || [];

  return {
    entry,
    children: children.map(child => buildTree(child.id))
  };
}
```

**复杂度：** O(n) 时间，O(n) 空间

**记忆锚点：**
> 映射 + 递归 = 树

---

## 卡片 6：分支的概念

### 正面

**什么是分支？如何创建分支？**

### 背面

**分支 = 从历史节点开始的新路径**

**Leaf Pointer（叶子指针）：**
```typescript
class SessionManager {
  private leafId: string;  // 当前活跃节点

  addMessage(content: string): string {
    const id = generateId();
    const entry = {
      id,
      parentId: this.leafId,  // 父节点是当前叶子
      content
    };

    appendToFile(entry);
    this.leafId = id;  // 更新叶子指针
    return id;
  }

  branch(branchFromId: string): void {
    this.leafId = branchFromId;  // 只移动指针
  }
}
```

**关键理解：**
- 分支不创建新文件
- 所有分支在同一个 JSONL 文件中
- 分支只是移动叶子指针

**类比：**
- Git 分支：从某个 commit 开始新的开发
- 平行宇宙：从某个时间点分叉

**记忆锚点：**
> 分支 = 移动指针 ≠ 创建文件

---

## 卡片 7：分支摘要

### 正面

**为什么需要分支摘要？如何生成？**

### 背面

**为什么需要？**
- 用户创建分支时可能忘记之前的上下文
- 摘要帮助快速回忆

**生成流程：**

1. **收集上下文**
```typescript
const context = getBranch(branchFromId);
```

2. **调用 LLM**
```typescript
const prompt = `请为以下对话生成简洁摘要：\n${context}`;
const summary = await llm.complete(prompt);
```

3. **跟踪文件**
```typescript
const readFiles = extractReadFiles(context);
const modifiedFiles = extractModifiedFiles(context);
```

4. **存储摘要**
```typescript
const summaryEntry = {
  type: 'branch_summary',
  id: generateId(),
  parentId: branchFromId,
  summary,
  readFiles,
  modifiedFiles
};
appendToFile(summaryEntry);
```

**记忆锚点：**
> 分支摘要 = 上下文快照

---

## 卡片 8：Session 上下文构建

### 正面

**如何从树中提取消息序列用于 LLM 调用？**

### 背面

**核心流程：**

1. **获取当前分支**
```typescript
const branch = getBranch(leafId);
// 从叶子到根的路径
```

2. **提取消息**
```typescript
const messages = branch
  .filter(e => e.type === 'user' || e.type === 'assistant')
  .map(e => ({
    role: e.type,
    content: e.content
  }));
```

3. **应用限制**
```typescript
// 按数量限制
if (maxMessages) {
  messages = messages.slice(-maxMessages);
}

// 按 Token 限制
if (maxTokens) {
  messages = limitByTokens(messages, maxTokens);
}
```

4. **格式化为 API 格式**
```typescript
const apiMessages = messages.map(m => ({
  role: m.role,
  content: m.content
}));
```

**记忆锚点：**
> 上下文 = 从叶子到根 + 过滤 + 限制

---

## 卡片 9：在 Pi-mono 中的应用

### 正面

**Pi-mono 如何使用 Session 存储？**

### 背面

**核心文件：**
- `session-manager.ts`：会话管理器（1400+ 行）
- `agent-session.ts`：Agent 会话
- `branch-summarization.ts`：分支摘要

**关键方法：**

```typescript
class SessionManager {
  // 添加消息
  appendMessage(entry: SessionEntry): void {
    this.writeBuffer.push(JSON.stringify(entry));
    this.scheduleFlush();
  }

  // 创建分支
  branch(branchFromId: string): void {
    this.leafId = branchFromId;
    this.flush();
  }

  // 构建上下文
  buildSessionContext(): Message[] {
    const branch = this.getBranch(this.leafId);
    return branch
      .filter(e => e.type === 'user' || e.type === 'assistant')
      .map(e => ({ role: e.type, content: e.content }));
  }

  // 获取树
  getTree(): SessionTreeNode {
    const root = this.entries.find(e => e.parentId === null);
    return this.buildSubtree(root.id);
  }
}
```

**设计哲学：**
- 极简主义：单文件、无数据库
- 高性能：追加写入、O(1) 操作
- 易调试：文本格式、可直接查看

**记忆锚点：**
> Pi-mono = JSONL + id/parentId + Leaf Pointer

---

## 卡片 10：总结与延伸

### 正面

**Session 存储的核心要点和延伸方向？**

### 背面

**核心要点：**

1. **JSONL 格式**：每行一个 JSON，支持追加写入
2. **id/parentId**：树形结构的最简表示
3. **追加写入**：O(1) 性能，不修改历史
4. **Leaf Pointer**：跟踪当前活跃节点
5. **分支管理**：移动指针，不创建文件
6. **上下文构建**：从叶子到根提取消息

**设计哲学：**
> 用最简单的方式解决复杂问题

**延伸方向：**

1. **Compaction（压缩）**
   - 将旧消息压缩为摘要
   - 减少文件大小

2. **分片（Sharding）**
   - 按时间或大小分片
   - 保持单文件简单性

3. **索引（Indexing）**
   - 创建索引文件
   - 加速查询

4. **可视化**
   - Web 界面
   - 交互式导航

**实际应用：**
- AI 对话系统
- 代码生成工具
- 协作编辑器
- 版本控制系统

**记忆锚点：**
> 简单 ≠ 简陋，极简 = 强大

---

## 复习计划

### 第 1 天：理解概念
- 卡片 1-3：会话、JSONL、追加写入
- 重点：理解为什么选择 JSONL

### 第 2 天：树形结构
- 卡片 4-5：id/parentId、树构建
- 重点：理解如何从扁平到树形

### 第 3 天：分支管理
- 卡片 6-7：分支、分支摘要
- 重点：理解分支不创建文件

### 第 4 天：上下文构建
- 卡片 8-9：上下文、Pi-mono 应用
- 重点：理解从树到消息序列

### 第 5 天：综合复习
- 卡片 1-10：全部复习
- 重点：串联所有知识点

### 第 6 天：实践应用
- 尝试实现一个简单的 SessionManager
- 参考实战代码章节

### 第 7 天：深度理解
- 阅读 Pi-mono 源码
- 理解实际应用中的细节

---

## 自测问题

### 基础问题

1. JSONL 和 JSON Array 的主要区别是什么？
2. id/parentId 如何表示树形结构？
3. 什么是 Leaf Pointer？
4. 分支创建时发生了什么？

### 进阶问题

1. 为什么追加写入比重写整个文件快？
2. 如何从扁平的 JSONL 构建树？
3. 如何限制上下文长度？
4. 分支摘要的作用是什么？

### 高级问题

1. 如果会话文件非常大，如何优化？
2. 如何实现分支合并？（提示：Pi-mono 不支持）
3. 如何实现实时协作？
4. 如何迁移到数据库？

---

## 记忆技巧

### 1. 类比记忆

- JSONL = 日志文件
- id/parentId = 链表指针
- 分支 = Git 分支
- Leaf Pointer = Git HEAD

### 2. 口诀记忆

**JSONL 三大优势：**
> 追加快、流式读、错误少

**树构建两步法：**
> 先映射、后递归

**分支创建三不：**
> 不创建文件、不复制数据、不修改历史

### 3. 图像记忆

**树形结构：**
```
        root (树根)
         |
       msg1 (树干)
         |
       msg2 (分叉点)
       /   \
    msg3   msg4 (两个分支)
```

**追加写入：**
```
[已有内容] ← 不动
[已有内容] ← 不动
[新内容]   ← 只追加这里
```

---

## 完成标志

**你已经完全掌握 Session 存储与树形结构，如果你能：**

- ✅ 解释为什么用 JSONL 而不是 JSON 数组
- ✅ 画出 id/parentId 的树形结构
- ✅ 说明分支创建的原理
- ✅ 实现一个简单的 SessionManager
- ✅ 在面试中自信地回答相关问题

**恭喜你！** 你已经掌握了 Pi-mono Session 存储的核心知识。

---

## 下一步

1. **实践**：实现一个完整的 SessionManager
2. **阅读源码**：深入 Pi-mono 的实现细节
3. **扩展应用**：将这个设计应用到其他场景
4. **分享知识**：教别人是最好的学习方式

---

**记住：** 知识只有通过实践才能真正掌握。

**祝你学习愉快！** 🎉
