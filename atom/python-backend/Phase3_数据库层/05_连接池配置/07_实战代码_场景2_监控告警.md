# 实战代码 - 场景2：连接池监控与告警

## 场景说明

演示如何监控连接池状态并实现告警机制，包括：
- 实时监控连接池指标
- Prometheus 指标集成
- 慢查询日志
- 连接池事件监听
- 告警通知

---

## 完整代码示例

```python
"""
场景2：连接池监控与告警
演示：如何监控连接池状态并实现告警机制
"""

import os
import time
import logging
from typing import Dict, Any
from datetime import datetime

from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy import create_engine, event, Column, Integer, String
from sqlalchemy.orm import sessionmaker, Session, declarative_base
from prometheus_client import Counter, Gauge, Histogram, generate_latest, CONTENT_TYPE_LATEST
from fastapi.responses import Response

# ===== 1. 日志配置 =====

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ===== 2. 数据库配置 =====

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://user:password@localhost:5432/testdb"
)

engine = create_engine(
    DATABASE_URL,
    pool_size=10,
    max_overflow=20,
    pool_timeout=30,
    pool_recycle=3600,
    pool_pre_ping=True,
    echo=False,
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ===== 3. Prometheus 指标定义 =====

# 连接池指标
pool_size_gauge = Gauge('db_pool_size', '连接池大小')
pool_checked_in_gauge = Gauge('db_pool_checked_in', '空闲连接数')
pool_checked_out_gauge = Gauge('db_pool_checked_out', '正在使用的连接数')
pool_overflow_gauge = Gauge('db_pool_overflow', '溢出连接数')
pool_usage_gauge = Gauge('db_pool_usage', '连接池使用率')

# 连接事件计数器
connection_checkout_counter = Counter('db_connection_checkout_total', '连接获取次数')
connection_checkin_counter = Counter('db_connection_checkin_total', '连接归还次数')
connection_connect_counter = Counter('db_connection_connect_total', '连接创建次数')
connection_error_counter = Counter('db_connection_error_total', '连接错误次数')

# 连接等待时间
connection_wait_histogram = Histogram(
    'db_connection_wait_seconds',
    '连接等待时间（秒）',
    buckets=[0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0, 10.0]
)

# 连接使用时间
connection_usage_histogram = Histogram(
    'db_connection_usage_seconds',
    '连接使用时间（秒）',
    buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 5.0, 10.0, 30.0, 60.0]
)

# 查询耗时
query_duration_histogram = Histogram(
    'db_query_duration_seconds',
    '查询耗时（秒）',
    buckets=[0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0, 10.0]
)

# 慢查询计数器
slow_query_counter = Counter('db_slow_query_total', '慢查询次数')

# ===== 4. 连接池监控函数 =====

def update_pool_metrics():
    """
    更新连接池指标
    """
    try:
        pool = engine.pool
        pool_size = pool.size()
        checked_in = pool.checkedin()
        checked_out = pool.checkedout()
        overflow = pool.overflow()

        # 更新 Prometheus 指标
        pool_size_gauge.set(pool_size)
        pool_checked_in_gauge.set(checked_in)
        pool_checked_out_gauge.set(checked_out)
        pool_overflow_gauge.set(overflow)

        # 计算使用率
        max_connections = pool_size + engine.pool._max_overflow
        if max_connections > 0:
            pool_usage = (checked_out + overflow) / max_connections
            pool_usage_gauge.set(pool_usage)

    except Exception as e:
        logger.error(f"更新连接池指标失败: {e}")

# ===== 5. 连接池事件监听 =====

@event.listens_for(engine, "connect")
def receive_connect(dbapi_conn, connection_record):
    """
    连接创建时触发
    """
    connection_record.info['connect_time'] = time.time()
    connection_connect_counter.inc()
    logger.info(f"新连接创建: {id(dbapi_conn)}")
    update_pool_metrics()

@event.listens_for(engine, "checkout")
def receive_checkout(dbapi_conn, connection_record, connection_proxy):
    """
    连接被获取时触发
    """
    checkout_time = time.time()
    connection_record.info['checkout_time'] = checkout_time

    # 计算等待时间
    checkin_time = connection_record.info.get('checkin_time', checkout_time)
    wait_time = checkout_time - checkin_time

    # 记录等待时间
    connection_wait_histogram.observe(wait_time)
    connection_checkout_counter.inc()

    # 记录慢获取（超过 100ms）
    if wait_time > 0.1:
        logger.warning(f"连接获取慢: {wait_time:.3f}s")

    update_pool_metrics()

@event.listens_for(engine, "checkin")
def receive_checkin(dbapi_conn, connection_record):
    """
    连接被归还时触发
    """
    checkin_time = time.time()
    connection_record.info['checkin_time'] = checkin_time

    # 计算连接使用时间
    checkout_time = connection_record.info.get('checkout_time', checkin_time)
    usage_time = checkin_time - checkout_time

    # 记录使用时间
    connection_usage_histogram.observe(usage_time)
    connection_checkin_counter.inc()

    # 记录长时间占用（超过 10 秒）
    if usage_time > 10:
        logger.warning(f"连接长时间占用: {usage_time:.3f}s")

    update_pool_metrics()

# ===== 6. 查询监控 =====

@event.listens_for(engine, "before_cursor_execute")
def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    """
    查询执行前触发
    """
    conn.info.setdefault('query_start_time', []).append(time.time())
    conn.info.setdefault('query_statement', []).append(statement)

@event.listens_for(engine, "after_cursor_execute")
def after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    """
    查询执行后触发
    """
    # 计算查询时间
    total_time = time.time() - conn.info['query_start_time'].pop()
    query_statement = conn.info['query_statement'].pop()

    # 记录查询时间
    query_duration_histogram.observe(total_time)

    # 记录慢查询（超过 100ms）
    if total_time > 0.1:
        slow_query_counter.inc()
        logger.warning(
            f"慢查询 ({total_time:.3f}s): {query_statement[:200]}"
        )

    # 记录所有查询（调试模式）
    if logger.level == logging.DEBUG:
        logger.debug(
            f"查询 ({total_time:.3f}s): {query_statement[:100]}"
        )

# ===== 7. 数据模型 =====

class User(Base):
    """用户模型"""
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)

Base.metadata.create_all(bind=engine)

# ===== 8. 依赖注入 =====

def get_db():
    """依赖注入函数"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ===== 9. FastAPI 应用 =====

app = FastAPI(title="连接池监控示例")

# ===== 10. 监控端点 =====

@app.get("/metrics")
async def metrics():
    """
    Prometheus 指标端点

    演示：
    - 暴露 Prometheus 指标
    - 供 Prometheus 抓取
    """
    return Response(
        content=generate_latest(),
        media_type=CONTENT_TYPE_LATEST
    )

@app.get("/health/db")
async def check_db_health():
    """
    数据库健康检查

    演示：
    - 检查连接池状态
    - 判断健康状态
    - 返回详细信息
    """
    try:
        # 获取连接池状态
        pool = engine.pool
        pool_size = pool.size()
        checked_in = pool.checkedin()
        checked_out = pool.checkedout()
        overflow = pool.overflow()

        # 计算使用率
        max_connections = pool_size + engine.pool._max_overflow
        pool_usage = (checked_out + overflow) / max_connections

        # 判断健康状态
        if pool_usage > 0.9:
            status = "critical"
            message = "连接池使用率过高（>90%）"
        elif pool_usage > 0.8:
            status = "warning"
            message = "连接池使用率较高（>80%）"
        elif checked_in == 0:
            status = "warning"
            message = "无空闲连接"
        else:
            status = "healthy"
            message = "数据库连接正常"

        # 测试数据库连接
        with engine.connect() as conn:
            conn.execute("SELECT 1")

        return {
            "status": status,
            "message": message,
            "timestamp": datetime.utcnow().isoformat(),
            "pool": {
                "size": pool_size,
                "checked_in": checked_in,
                "checked_out": checked_out,
                "overflow": overflow,
                "usage": f"{pool_usage * 100:.1f}%",
                "max_connections": max_connections,
            }
        }

    except Exception as e:
        logger.error(f"健康检查失败: {e}")
        raise HTTPException(
            status_code=503,
            detail=f"数据库连接失败: {str(e)}"
        )

@app.get("/pool/status")
async def get_pool_status():
    """
    获取连接池详细状态

    演示：
    - 返回连接池的详细信息
    - 包含历史统计数据
    """
    pool = engine.pool

    return {
        "timestamp": datetime.utcnow().isoformat(),
        "pool": {
            "size": pool.size(),
            "checked_in": pool.checkedin(),
            "checked_out": pool.checkedout(),
            "overflow": pool.overflow(),
            "status": pool.status(),
        },
        "config": {
            "pool_size": engine.pool._pool.maxsize if hasattr(engine.pool, '_pool') else None,
            "max_overflow": engine.pool._max_overflow,
            "timeout": engine.pool._timeout,
            "recycle": engine.pool._recycle,
        }
    }

# ===== 11. 测试端点（模拟不同场景） =====

@app.get("/test/normal")
async def test_normal(db: Session = Depends(get_db)):
    """
    正常查询（快速）

    演示：
    - 正常的数据库查询
    - 连接快速归还
    """
    users = db.query(User).limit(10).all()
    return {"count": len(users), "message": "正常查询"}

@app.get("/test/slow")
async def test_slow(db: Session = Depends(get_db)):
    """
    慢查询（模拟）

    演示：
    - 触发慢查询告警
    - 记录慢查询日志
    """
    import time
    time.sleep(0.2)  # 模拟慢查询
    users = db.query(User).limit(10).all()
    return {"count": len(users), "message": "慢查询"}

@app.get("/test/long-connection")
async def test_long_connection(db: Session = Depends(get_db)):
    """
    长时间占用连接（模拟）

    演示：
    - 触发长时间占用告警
    - 记录连接使用时间
    """
    import time
    time.sleep(15)  # 模拟长时间占用
    users = db.query(User).limit(10).all()
    return {"count": len(users), "message": "长时间占用连接"}

# ===== 12. 定期监控任务 =====

import asyncio

async def periodic_monitoring():
    """
    定期监控任务（每 60 秒）

    演示：
    - 定期检查连接池状态
    - 记录日志
    - 触发告警
    """
    while True:
        try:
            # 更新指标
            update_pool_metrics()

            # 获取连接池状态
            pool = engine.pool
            pool_size = pool.size()
            checked_in = pool.checkedin()
            checked_out = pool.checkedout()
            overflow = pool.overflow()

            # 计算使用率
            max_connections = pool_size + engine.pool._max_overflow
            pool_usage = (checked_out + overflow) / max_connections

            # 记录状态
            logger.info(
                f"连接池状态: size={pool_size}, "
                f"checked_in={checked_in}, "
                f"checked_out={checked_out}, "
                f"overflow={overflow}, "
                f"usage={pool_usage * 100:.1f}%"
            )

            # 告警检查
            if pool_usage > 0.9:
                logger.error(f"🚨 连接池使用率过高: {pool_usage * 100:.1f}%")
                # 这里可以发送告警通知（邮件、Slack、钉钉等）

            if checked_in == 0:
                logger.error("🚨 无空闲连接")

        except Exception as e:
            logger.error(f"定期监控失败: {e}")

        await asyncio.sleep(60)

# ===== 13. 应用启动和关闭事件 =====

@app.on_event("startup")
async def startup_event():
    """应用启动时执行"""
    logger.info("=" * 50)
    logger.info("应用启动 - 连接池监控已启用")
    logger.info("=" * 50)

    # 初始化指标
    update_pool_metrics()

    # 启动定期监控任务
    asyncio.create_task(periodic_monitoring())

    logger.info("定期监控任务已启动")

@app.on_event("shutdown")
async def shutdown_event():
    """应用关闭时执行"""
    logger.info("=" * 50)
    logger.info("应用关闭")
    logger.info("=" * 50)
    engine.dispose()

# ===== 14. 运行应用 =====

if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info",
    )
```

---

## Prometheus 配置

### prometheus.yml

```yaml
# Prometheus 配置文件
global:
  scrape_interval: 15s  # 每 15 秒抓取一次指标

scrape_configs:
  - job_name: 'fastapi-app'
    static_configs:
      - targets: ['localhost:8000']
    metrics_path: '/metrics'
```

---

## Grafana 仪表板配置

### 连接池监控面板

```json
{
  "dashboard": {
    "title": "数据库连接池监控",
    "panels": [
      {
        "title": "连接池使用率",
        "targets": [
          {
            "expr": "db_pool_usage * 100"
          }
        ]
      },
      {
        "title": "连接数趋势",
        "targets": [
          {
            "expr": "db_pool_checked_in",
            "legendFormat": "空闲连接"
          },
          {
            "expr": "db_pool_checked_out",
            "legendFormat": "使用中连接"
          },
          {
            "expr": "db_pool_overflow",
            "legendFormat": "溢出连接"
          }
        ]
      },
      {
        "title": "查询耗时分布",
        "targets": [
          {
            "expr": "rate(db_query_duration_seconds_bucket[5m])"
          }
        ]
      },
      {
        "title": "慢查询次数",
        "targets": [
          {
            "expr": "rate(db_slow_query_total[5m])"
          }
        ]
      }
    ]
  }
}
```

---

## 运行和测试

### 1. 启动应用

```bash
python app.py
```

### 2. 查看 Prometheus 指标

```bash
curl http://localhost:8000/metrics
```

**输出示例：**
```
# HELP db_pool_size 连接池大小
# TYPE db_pool_size gauge
db_pool_size 10.0

# HELP db_pool_checked_in 空闲连接数
# TYPE db_pool_checked_in gauge
db_pool_checked_in 8.0

# HELP db_pool_checked_out 正在使用的连接数
# TYPE db_pool_checked_out gauge
db_pool_checked_out 2.0

# HELP db_pool_usage 连接池使用率
# TYPE db_pool_usage gauge
db_pool_usage 0.067

# HELP db_query_duration_seconds 查询耗时（秒）
# TYPE db_query_duration_seconds histogram
db_query_duration_seconds_bucket{le="0.001"} 10.0
db_query_duration_seconds_bucket{le="0.005"} 25.0
db_query_duration_seconds_bucket{le="0.01"} 45.0
```

### 3. 健康检查

```bash
curl http://localhost:8000/health/db
```

**输出示例：**
```json
{
  "status": "healthy",
  "message": "数据库连接正常",
  "timestamp": "2026-02-11T10:30:00.123456",
  "pool": {
    "size": 10,
    "checked_in": 8,
    "checked_out": 2,
    "overflow": 0,
    "usage": "6.7%",
    "max_connections": 30
  }
}
```

### 4. 测试不同场景

```bash
# 正常查询
curl http://localhost:8000/test/normal

# 慢查询（触发告警）
curl http://localhost:8000/test/slow

# 长时间占用连接（触发告警）
curl http://localhost:8000/test/long-connection
```

---

## 日志输出示例

```
2026-02-11 10:30:00 - __main__ - INFO - ==================================================
2026-02-11 10:30:00 - __main__ - INFO - 应用启动 - 连接池监控已启用
2026-02-11 10:30:00 - __main__ - INFO - ==================================================
2026-02-11 10:30:00 - __main__ - INFO - 定期监控任务已启动
2026-02-11 10:30:00 - __main__ - INFO - 新连接创建: 140234567890123
2026-02-11 10:31:00 - __main__ - INFO - 连接池状态: size=10, checked_in=8, checked_out=2, overflow=0, usage=6.7%
2026-02-11 10:32:15 - __main__ - WARNING - 慢查询 (0.215s): SELECT * FROM users LIMIT 10
2026-02-11 10:33:30 - __main__ - WARNING - 连接长时间占用: 15.123s
2026-02-11 10:35:00 - __main__ - ERROR - 🚨 连接池使用率过高: 92.3%
```

---

## 告警规则配置

### Prometheus 告警规则

```yaml
# alerts.yml
groups:
  - name: database_alerts
    rules:
      # 连接池使用率过高
      - alert: HighPoolUsage
        expr: db_pool_usage > 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "连接池使用率过高"
          description: "连接池使用率 {{ $value | humanizePercentage }}，超过 80%"

      # 连接池使用率严重过高
      - alert: CriticalPoolUsage
        expr: db_pool_usage > 0.9
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "连接池使用率严重过高"
          description: "连接池使用率 {{ $value | humanizePercentage }}，超过 90%"

      # 无空闲连接
      - alert: NoIdleConnections
        expr: db_pool_checked_in == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "无空闲连接"
          description: "连接池中无空闲连接，所有连接都在使用中"

      # 慢查询频率过高
      - alert: HighSlowQueryRate
        expr: rate(db_slow_query_total[5m]) > 10
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "慢查询频率过高"
          description: "慢查询频率 {{ $value }} 次/秒，超过阈值"
```

---

## 关键知识点

### 1. Prometheus 指标类型

```python
# Counter：只增不减的计数器
connection_checkout_counter = Counter('db_connection_checkout_total', '连接获取次数')

# Gauge：可增可减的仪表盘
pool_usage_gauge = Gauge('db_pool_usage', '连接池使用率')

# Histogram：直方图（记录分布）
query_duration_histogram = Histogram('db_query_duration_seconds', '查询耗时')
```

### 2. 事件监听

```python
# 连接创建
@event.listens_for(engine, "connect")
def receive_connect(dbapi_conn, connection_record):
    pass

# 连接获取
@event.listens_for(engine, "checkout")
def receive_checkout(dbapi_conn, connection_record, connection_proxy):
    pass

# 连接归还
@event.listens_for(engine, "checkin")
def receive_checkin(dbapi_conn, connection_record):
    pass
```

### 3. 定期监控

```python
async def periodic_monitoring():
    while True:
        # 检查连接池状态
        update_pool_metrics()

        # 触发告警
        if pool_usage > 0.9:
            logger.error("连接池使用率过高")

        await asyncio.sleep(60)
```

---

## 总结

这个示例展示了：
1. ✅ 如何使用 Prometheus 监控连接池
2. ✅ 如何监听连接池事件
3. ✅ 如何记录慢查询日志
4. ✅ 如何实现定期监控和告警
5. ✅ 如何配置 Grafana 仪表板

**下一步：** 查看场景3（高级配置：读写分离、异步连接池）
