# 实战代码

一个完整可运行的检索器实现示例，覆盖向量检索、关键词检索、混合检索三种模式。

---

## 完整示例：多模式检索器

```python
"""
检索器设计 - 实战代码示例
演示：向量检索、关键词检索、混合检索的完整实现

运行前安装依赖：
pip install langchain langchain-openai langchain-community chromadb rank_bm25
"""

import os
from typing import List, Literal
from dataclasses import dataclass

from langchain_core.documents import Document
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings
from langchain_community.retrievers import BM25Retriever
from langchain.retrievers import EnsembleRetriever

# ===== 1. 准备测试数据 =====
print("=" * 50)
print("1. 准备测试数据")
print("=" * 50)

# 模拟企业知识库文档
documents = [
    Document(
        page_content="年假政策：入职满一年可享受5天年假，满三年10天，满五年15天。申请年假需提前3天在OA系统提交。",
        metadata={"source": "HR手册", "type": "policy", "year": 2024}
    ),
    Document(
        page_content="请假流程：1. 登录OA系统 2. 点击请假申请 3. 选择请假类型 4. 填写请假时间 5. 提交审批",
        metadata={"source": "HR手册", "type": "process", "year": 2024}
    ),
    Document(
        page_content="Python asyncio 是 Python 的异步编程库，用于编写并发代码。使用 async/await 语法定义协程。",
        metadata={"source": "技术文档", "type": "tutorial", "year": 2024}
    ),
    Document(
        page_content="Python asyncio 异常处理：使用 try/except 捕获协程中的异常，或使用 asyncio.gather(return_exceptions=True)。",
        metadata={"source": "技术文档", "type": "tutorial", "year": 2024}
    ),
    Document(
        page_content="ERR_CONNECTION_REFUSED 错误通常表示目标服务器拒绝连接。检查：1. 服务是否启动 2. 端口是否正确 3. 防火墙设置",
        metadata={"source": "故障排查", "type": "troubleshooting", "year": 2024}
    ),
    Document(
        page_content="公司成立于2010年，总部位于北京，是一家专注于人工智能技术的科技公司。",
        metadata={"source": "公司介绍", "type": "about", "year": 2024}
    ),
    Document(
        page_content="报销流程：1. 收集发票 2. 填写报销单 3. 部门经理审批 4. 财务审核 5. 打款到工资卡",
        metadata={"source": "财务手册", "type": "process", "year": 2024}
    ),
    Document(
        page_content="Python 多线程编程使用 threading 模块，但由于 GIL 限制，CPU 密集型任务建议使用 multiprocessing。",
        metadata={"source": "技术文档", "type": "tutorial", "year": 2024}
    ),
]

print(f"加载了 {len(documents)} 个文档")
for i, doc in enumerate(documents):
    print(f"  [{i+1}] {doc.page_content[:40]}...")


# ===== 2. 创建向量检索器 =====
print("\n" + "=" * 50)
print("2. 创建向量检索器")
print("=" * 50)

# 初始化 Embedding 模型
embeddings = OpenAIEmbeddings(model="text-embedding-3-small")

# 创建向量存储
vectorstore = Chroma.from_documents(
    documents=documents,
    embedding=embeddings,
    collection_name="demo_collection"
)

# 创建向量检索器
vector_retriever = vectorstore.as_retriever(
    search_type="similarity",
    search_kwargs={"k": 3}
)

print("向量检索器创建完成")


# ===== 3. 创建关键词检索器（BM25） =====
print("\n" + "=" * 50)
print("3. 创建关键词检索器（BM25）")
print("=" * 50)

bm25_retriever = BM25Retriever.from_documents(documents, k=3)

print("BM25 检索器创建完成")


# ===== 4. 创建混合检索器 =====
print("\n" + "=" * 50)
print("4. 创建混合检索器")
print("=" * 50)

# 为混合检索创建更大 K 值的检索器
vector_retriever_for_hybrid = vectorstore.as_retriever(search_kwargs={"k": 5})
bm25_retriever_for_hybrid = BM25Retriever.from_documents(documents, k=5)

hybrid_retriever = EnsembleRetriever(
    retrievers=[vector_retriever_for_hybrid, bm25_retriever_for_hybrid],
    weights=[0.5, 0.5]  # 各占 50%
)

print("混合检索器创建完成（向量 50% + BM25 50%）")


# ===== 5. 创建 MMR 检索器 =====
print("\n" + "=" * 50)
print("5. 创建 MMR 检索器（多样性）")
print("=" * 50)

mmr_retriever = vectorstore.as_retriever(
    search_type="mmr",
    search_kwargs={
        "k": 3,
        "fetch_k": 10,
        "lambda_mult": 0.5
    }
)

print("MMR 检索器创建完成")


# ===== 6. 测试不同检索器 =====
print("\n" + "=" * 50)
print("6. 测试检索效果")
print("=" * 50)

def test_retriever(retriever, query: str, name: str):
    """测试检索器并打印结果"""
    print(f"\n--- {name} ---")
    print(f"查询: {query}")
    results = retriever.invoke(query)
    print(f"返回 {len(results)} 个结果:")
    for i, doc in enumerate(results):
        print(f"  [{i+1}] {doc.page_content[:60]}...")
        print(f"      来源: {doc.metadata.get('source', 'N/A')}")

# 测试1：语义查询（向量检索擅长）
query1 = "如何申请休假？"
print("\n" + "=" * 30)
print("测试1：语义查询")
print("=" * 30)
test_retriever(vector_retriever, query1, "向量检索")
test_retriever(bm25_retriever, query1, "BM25 检索")
test_retriever(hybrid_retriever, query1, "混合检索")

# 测试2：精确关键词查询（BM25 擅长）
query2 = "ERR_CONNECTION_REFUSED"
print("\n" + "=" * 30)
print("测试2：精确关键词查询")
print("=" * 30)
test_retriever(vector_retriever, query2, "向量检索")
test_retriever(bm25_retriever, query2, "BM25 检索")
test_retriever(hybrid_retriever, query2, "混合检索")

# 测试3：复杂查询（混合检索最佳）
query3 = "Python asyncio 异常处理"
print("\n" + "=" * 30)
print("测试3：复杂查询")
print("=" * 30)
test_retriever(vector_retriever, query3, "向量检索")
test_retriever(bm25_retriever, query3, "BM25 检索")
test_retriever(hybrid_retriever, query3, "混合检索")


# ===== 7. 带相似度分数的检索 =====
print("\n" + "=" * 50)
print("7. 带相似度分数的检索")
print("=" * 50)

query = "年假怎么申请"
results_with_scores = vectorstore.similarity_search_with_score(query, k=5)

print(f"查询: {query}")
print("结果（带相似度分数）:")
for doc, score in results_with_scores:
    print(f"  相似度: {score:.4f} | {doc.page_content[:50]}...")


# ===== 8. 带阈值过滤的检索 =====
print("\n" + "=" * 50)
print("8. 带阈值过滤的检索")
print("=" * 50)

def retrieve_with_threshold(query: str, threshold: float = 0.5, k: int = 5):
    """带相似度阈值的检索"""
    results = vectorstore.similarity_search_with_score(query, k=k)
    filtered = [(doc, score) for doc, score in results if score >= threshold]
    return filtered

query = "量子计算研究进展"  # 知识库中没有相关内容
threshold = 0.5

print(f"查询: {query}")
print(f"阈值: {threshold}")

results = retrieve_with_threshold(query, threshold=threshold)
if results:
    print(f"找到 {len(results)} 个相关结果")
    for doc, score in results:
        print(f"  相似度: {score:.4f} | {doc.page_content[:50]}...")
else:
    print("没有找到相关内容（所有结果相似度低于阈值）")


# ===== 9. 带元数据过滤的检索 =====
print("\n" + "=" * 50)
print("9. 带元数据过滤的检索")
print("=" * 50)

# 只搜索技术文档
query = "异步编程"
results = vectorstore.similarity_search(
    query,
    k=3,
    filter={"type": "tutorial"}  # 只搜索 tutorial 类型
)

print(f"查询: {query}")
print(f"过滤条件: type = tutorial")
print(f"结果:")
for doc in results:
    print(f"  [{doc.metadata['type']}] {doc.page_content[:50]}...")


# ===== 10. 封装成可复用的检索器类 =====
print("\n" + "=" * 50)
print("10. 封装成可复用的检索器类")
print("=" * 50)

@dataclass
class RetrieverConfig:
    """检索器配置"""
    mode: Literal["vector", "bm25", "hybrid", "mmr"] = "hybrid"
    k: int = 5
    score_threshold: float = 0.0
    mmr_lambda: float = 0.5
    hybrid_weights: tuple = (0.5, 0.5)


class SmartRetriever:
    """智能检索器：支持多种检索模式"""

    def __init__(self, documents: List[Document], config: RetrieverConfig = None):
        self.config = config or RetrieverConfig()
        self.documents = documents

        # 初始化向量存储
        self.embeddings = OpenAIEmbeddings(model="text-embedding-3-small")
        self.vectorstore = Chroma.from_documents(
            documents=documents,
            embedding=self.embeddings
        )

        # 初始化 BM25
        self.bm25 = BM25Retriever.from_documents(documents, k=self.config.k)

    def retrieve(self, query: str) -> List[Document]:
        """根据配置执行检索"""
        if self.config.mode == "vector":
            return self._vector_search(query)
        elif self.config.mode == "bm25":
            return self._bm25_search(query)
        elif self.config.mode == "hybrid":
            return self._hybrid_search(query)
        elif self.config.mode == "mmr":
            return self._mmr_search(query)
        else:
            raise ValueError(f"Unknown mode: {self.config.mode}")

    def _vector_search(self, query: str) -> List[Document]:
        """向量检索"""
        if self.config.score_threshold > 0:
            results = self.vectorstore.similarity_search_with_score(
                query, k=self.config.k
            )
            return [doc for doc, score in results
                    if score >= self.config.score_threshold]
        return self.vectorstore.similarity_search(query, k=self.config.k)

    def _bm25_search(self, query: str) -> List[Document]:
        """BM25 检索"""
        return self.bm25.invoke(query)

    def _hybrid_search(self, query: str) -> List[Document]:
        """混合检索"""
        vec_retriever = self.vectorstore.as_retriever(
            search_kwargs={"k": self.config.k}
        )
        hybrid = EnsembleRetriever(
            retrievers=[vec_retriever, self.bm25],
            weights=list(self.config.hybrid_weights)
        )
        return hybrid.invoke(query)

    def _mmr_search(self, query: str) -> List[Document]:
        """MMR 多样性检索"""
        return self.vectorstore.max_marginal_relevance_search(
            query,
            k=self.config.k,
            fetch_k=self.config.k * 4,
            lambda_mult=self.config.mmr_lambda
        )


# 使用示例
config = RetrieverConfig(mode="hybrid", k=3)
smart_retriever = SmartRetriever(documents, config)

query = "如何处理 Python 异步异常"
results = smart_retriever.retrieve(query)

print(f"SmartRetriever 测试")
print(f"模式: {config.mode}")
print(f"查询: {query}")
print(f"结果:")
for doc in results:
    print(f"  - {doc.page_content[:50]}...")


# ===== 清理 =====
print("\n" + "=" * 50)
print("示例运行完成！")
print("=" * 50)
```

---

## 运行输出示例

```
==================================================
1. 准备测试数据
==================================================
加载了 8 个文档
  [1] 年假政策：入职满一年可享受5天年假，满三年10天，满五年15天...
  [2] 请假流程：1. 登录OA系统 2. 点击请假申请 3. 选择请假类型...
  ...

==================================================
6. 测试检索效果
==================================================

==============================
测试1：语义查询
==============================

--- 向量检索 ---
查询: 如何申请休假？
返回 3 个结果:
  [1] 年假政策：入职满一年可享受5天年假，满三年10天，满五年15天...
      来源: HR手册
  [2] 请假流程：1. 登录OA系统 2. 点击请假申请 3. 选择请假类型...
      来源: HR手册

==============================
测试2：精确关键词查询
==============================

--- BM25 检索 ---
查询: ERR_CONNECTION_REFUSED
返回 3 个结果:
  [1] ERR_CONNECTION_REFUSED 错误通常表示目标服务器拒绝连接...
      来源: 故障排查

--- 向量检索 ---
查询: ERR_CONNECTION_REFUSED
返回 3 个结果:
  [1] Python asyncio 是 Python 的异步编程库...  ← 语义相关但不精确
      来源: 技术文档
```

---

## 关键代码说明

| 代码片段 | 作用 |
|----------|------|
| `vectorstore.as_retriever()` | 创建向量检索器 |
| `BM25Retriever.from_documents()` | 创建 BM25 检索器 |
| `EnsembleRetriever` | 组合多个检索器 |
| `search_type="mmr"` | 启用 MMR 多样性检索 |
| `similarity_search_with_score()` | 获取带分数的结果 |
| `filter={"type": "tutorial"}` | 元数据过滤 |

---

**下一步：** [08_面试必问](./08_面试必问.md) - 检索器相关的高频面试问题
