# 实战代码1：固定窗口实现

> 手写固定窗口算法的完整实现

---

## 内存版本

```python
"""
固定窗口限流器 - 内存版本
适用场景：单机应用、开发环境
"""
import time
from typing import Optional, Dict


class FixedWindowLimiter:
    """固定窗口限流器"""

    def __init__(self, limit: int, window: int):
        self.limit = limit
        self.window = window
        self.count = 0
        self.window_start = time.time()

    def acquire(self) -> bool:
        """尝试获取配额"""
        now = time.time()

        # 检查是否进入新窗口
        if now - self.window_start >= self.window:
            self.count = 0
            self.window_start = now

        # 检查是否超过限制
        if self.count < self.limit:
            self.count += 1
            return True

        return False

    def get_status(self) -> Dict:
        """获取当前状态"""
        now = time.time()
        elapsed = now - self.window_start
        remaining = max(0, self.window - elapsed)

        return {
            "count": self.count,
            "limit": self.limit,
            "window_remaining": remaining,
            "reset_at": self.window_start + self.window
        }


# 测试
if __name__ == "__main__":
    limiter = FixedWindowLimiter(limit=5, window=10)

    for i in range(10):
        if limiter.acquire():
            print(f"请求{i}: ✅")
        else:
            print(f"请求{i}: ❌")
        time.sleep(1)
```

---

## Redis 版本

```python
"""
固定窗口限流器 - Redis 版本
适用场景：分布式环境、生产环境
"""
import redis
import time
from typing import Dict


class RedisFixedWindowLimiter:
    """基于 Redis 的固定窗口限流器"""

    def __init__(
        self,
        redis_client: redis.Redis,
        key_prefix: str,
        limit: int,
        window: int
    ):
        self.redis = redis_client
        self.key_prefix = key_prefix
        self.limit = limit
        self.window = window

    def _get_window_key(self) -> str:
        """获取当前窗口的 Redis key"""
        now = int(time.time())
        window_start = now - (now % self.window)
        return f"{self.key_prefix}:{window_start}"

    def acquire(self) -> bool:
        """尝试获取配额"""
        key = self._get_window_key()

        # 使用 Redis 管道保证原子性
        pipe = self.redis.pipeline()
        pipe.incr(key)
        pipe.expire(key, self.window)
        results = pipe.execute()

        count = results[0]
        return count <= self.limit

    def get_status(self) -> Dict:
        """获取当前状态"""
        key = self._get_window_key()
        count = int(self.redis.get(key) or 0)
        ttl = self.redis.ttl(key)

        return {
            "count": count,
            "limit": self.limit,
            "window_remaining": max(0, ttl),
            "key": key
        }


# 测试
if __name__ == "__main__":
    redis_client = redis.Redis(host='localhost', port=6379, db=0)

    limiter = RedisFixedWindowLimiter(
        redis_client=redis_client,
        key_prefix="user:123:rate_limit",
        limit=5,
        window=10
    )

    for i in range(10):
        if limiter.acquire():
            print(f"请求{i}: ✅")
        else:
            print(f"请求{i}: ❌")

        status = limiter.get_status()
        print(f"  状态: {status['count']}/{status['limit']}")

        time.sleep(1)
```

---

## Lua 脚本优化版本

```python
"""
固定窗口限流器 - Lua 脚本优化版本
使用 Lua 脚本保证原子性，减少网络往返
"""
import redis
import time
from typing import Dict


class RedisFixedWindowLimiterLua:
    """基于 Redis + Lua 的固定窗口限流器"""

    LUA_SCRIPT = """
    local key = KEYS[1]
    local limit = tonumber(ARGV[1])
    local window = tonumber(ARGV[2])

    -- 获取当前计数
    local current = redis.call('incr', key)

    -- 如果是第一个请求，设置过期时间
    if current == 1 then
        redis.call('expire', key, window)
    end

    -- 检查是否超过限制
    if current > limit then
        return 0  -- 拒绝
    end

    return 1  -- 允许
    """

    def __init__(
        self,
        redis_client: redis.Redis,
        key_prefix: str,
        limit: int,
        window: int
    ):
        self.redis = redis_client
        self.key_prefix = key_prefix
        self.limit = limit
        self.window = window

        # 注册 Lua 脚本
        self.script_sha = self.redis.script_load(self.LUA_SCRIPT)

    def _get_window_key(self) -> str:
        """获取当前窗口的 Redis key"""
        now = int(time.time())
        window_start = now - (now % self.window)
        return f"{self.key_prefix}:{window_start}"

    def acquire(self) -> bool:
        """尝试获取配额"""
        key = self._get_window_key()

        # 执行 Lua 脚本
        result = self.redis.evalsha(
            self.script_sha,
            1,  # 1个key
            key,
            self.limit,
            self.window
        )

        return result == 1

    def get_status(self) -> Dict:
        """获取当前状态"""
        key = self._get_window_key()
        count = int(self.redis.get(key) or 0)
        ttl = self.redis.ttl(key)

        return {
            "count": count,
            "limit": self.limit,
            "window_remaining": max(0, ttl)
        }


# 测试
if __name__ == "__main__":
    redis_client = redis.Redis(host='localhost', port=6379, db=0)

    limiter = RedisFixedWindowLimiterLua(
        redis_client=redis_client,
        key_prefix="user:123:rate_limit",
        limit=5,
        window=10
    )

    for i in range(10):
        if limiter.acquire():
            print(f"请求{i}: ✅")
        else:
            print(f"请求{i}: ❌")

        status = limiter.get_status()
        print(f"  状态: {status['count']}/{status['limit']}")

        time.sleep(1)
```

---

## FastAPI 集成

```python
"""
固定窗口限流器 - FastAPI 集成
"""
from fastapi import FastAPI, Depends, HTTPException, Request
from typing import Annotated
import redis

app = FastAPI()
redis_client = redis.Redis(host='localhost', port=6379, db=0)


async def rate_limit(request: Request):
    """限流依赖"""
    # 从请求中获取用户ID
    user_id = request.headers.get("X-User-ID", "anonymous")

    # 创建限流器
    limiter = RedisFixedWindowLimiterLua(
        redis_client=redis_client,
        key_prefix=f"user:{user_id}:rate_limit",
        limit=10,  # 每分钟10个请求
        window=60
    )

    # 检查限流
    if not limiter.acquire():
        status = limiter.get_status()
        raise HTTPException(
            status_code=429,
            detail={
                "error": "Rate limit exceeded",
                "limit": status["limit"],
                "used": status["count"],
                "reset_in": status["window_remaining"]
            }
        )


@app.post("/chat")
async def chat(
    message: str,
    _: None = Depends(rate_limit)
):
    """聊天接口"""
    return {"response": f"Echo: {message}"}


@app.get("/status")
async def status(request: Request):
    """查询限流状态"""
    user_id = request.headers.get("X-User-ID", "anonymous")

    limiter = RedisFixedWindowLimiterLua(
        redis_client=redis_client,
        key_prefix=f"user:{user_id}:rate_limit",
        limit=10,
        window=60
    )

    return limiter.get_status()


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 测试脚本

```python
"""
固定窗口限流器 - 测试脚本
"""
import asyncio
import httpx
import time


async def test_rate_limit():
    """测试限流"""
    async with httpx.AsyncClient() as client:
        print("=== 测试固定窗口限流 ===\n")

        # 发送20个请求（限流是10个/分钟）
        for i in range(20):
            try:
                response = await client.post(
                    "http://localhost:8000/chat",
                    json={"message": f"Hello {i}"},
                    headers={"X-User-ID": "user123"}
                )

                if response.status_code == 200:
                    print(f"请求{i}: ✅ 通过")
                elif response.status_code == 429:
                    print(f"请求{i}: ❌ 被限流")
                    print(f"  详情: {response.json()}")

            except Exception as e:
                print(f"请求{i}: ❌ 错误: {e}")

            time.sleep(0.5)

        # 查询状态
        print("\n=== 查询限流状态 ===")
        response = await client.get(
            "http://localhost:8000/status",
            headers={"X-User-ID": "user123"}
        )
        print(f"状态: {response.json()}")


async def test_boundary_burst():
    """测试窗口边界问题"""
    async with httpx.AsyncClient() as client:
        print("\n=== 测试窗口边界问题 ===\n")

        # 在第59秒发送10个请求
        print("第59秒：发送10个请求")
        for i in range(10):
            response = await client.post(
                "http://localhost:8000/chat",
                json={"message": f"Hello {i}"},
                headers={"X-User-ID": "user456"}
            )
            print(f"  请求{i}: {'✅' if response.status_code == 200 else '❌'}")

        # 等待1秒，进入新窗口
        print("\n等待1秒，进入新窗口...")
        time.sleep(1)

        # 在第1秒又发送10个请求
        print("\n第1秒：发送10个请求")
        for i in range(10):
            response = await client.post(
                "http://localhost:8000/chat",
                json={"message": f"Hello {i}"},
                headers={"X-User-ID": "user456"}
            )
            print(f"  请求{i}: {'✅' if response.status_code == 200 else '❌'}")

        print("\n❌ 问题：2秒内通过了20个请求！")


if __name__ == "__main__":
    asyncio.run(test_rate_limit())
    asyncio.run(test_boundary_burst())
```

---

## 性能测试

```python
"""
固定窗口限流器 - 性能测试
"""
import time


def benchmark_memory():
    """内存版本性能测试"""
    limiter = FixedWindowLimiter(limit=10000, window=60)

    start = time.time()
    for _ in range(100000):
        limiter.acquire()
    elapsed = time.time() - start

    print(f"内存版本:")
    print(f"  100000次 acquire: {elapsed:.3f}秒")
    print(f"  平均延迟: {elapsed / 100000 * 1000:.3f}ms")
    print(f"  QPS: {100000 / elapsed:.0f}")


def benchmark_redis():
    """Redis 版本性能测试"""
    redis_client = redis.Redis()
    limiter = RedisFixedWindowLimiterLua(
        redis_client=redis_client,
        key_prefix="benchmark",
        limit=10000,
        window=60
    )

    start = time.time()
    for _ in range(10000):
        limiter.acquire()
    elapsed = time.time() - start

    print(f"\nRedis 版本:")
    print(f"  10000次 acquire: {elapsed:.3f}秒")
    print(f"  平均延迟: {elapsed / 10000 * 1000:.3f}ms")
    print(f"  QPS: {10000 / elapsed:.0f}")


if __name__ == "__main__":
    benchmark_memory()
    benchmark_redis()
```

---

## 完整示例：AI Agent API

```python
"""
完整示例：AI Agent API with 固定窗口限流
"""
from fastapi import FastAPI, Depends, HTTPException, Request
from pydantic import BaseModel
from enum import Enum
import redis
import os

app = FastAPI(title="AI Agent API")
redis_client = redis.Redis(
    host=os.getenv("REDIS_HOST", "localhost"),
    port=int(os.getenv("REDIS_PORT", 6379)),
    db=0
)


class UserTier(str, Enum):
    FREE = "free"
    BASIC = "basic"
    PRO = "pro"


class ChatRequest(BaseModel):
    message: str


class ChatResponse(BaseModel):
    response: str
    tokens_used: int


# 不同等级的每日配额
DAILY_LIMITS = {
    UserTier.FREE: 10,
    UserTier.BASIC: 100,
    UserTier.PRO: 1000
}


def get_daily_limiter(user_id: str, user_tier: UserTier):
    """获取每日限流器"""
    limit = DAILY_LIMITS[user_tier]

    return RedisFixedWindowLimiterLua(
        redis_client=redis_client,
        key_prefix=f"user:{user_id}:daily",
        limit=limit,
        window=86400  # 24小时
    )


async def check_daily_limit(request: Request):
    """检查每日配额"""
    user_id = request.headers.get("X-User-ID", "anonymous")
    user_tier = UserTier(request.headers.get("X-User-Tier", "free"))

    limiter = get_daily_limiter(user_id, user_tier)

    if not limiter.acquire():
        status = limiter.get_status()
        raise HTTPException(
            status_code=429,
            detail={
                "error": "Daily quota exceeded",
                "tier": user_tier,
                "limit": status["limit"],
                "used": status["count"],
                "reset_in": status["window_remaining"]
            }
        )


@app.post("/chat", response_model=ChatResponse)
async def chat(
    request: ChatRequest,
    _: None = Depends(check_daily_limit)
):
    """聊天接口"""
    # 模拟 LLM 调用
    response_text = f"Echo: {request.message}"
    tokens_used = len(request.message) + len(response_text)

    return ChatResponse(
        response=response_text,
        tokens_used=tokens_used
    )


@app.get("/quota")
async def get_quota(request: Request):
    """查询配额"""
    user_id = request.headers.get("X-User-ID", "anonymous")
    user_tier = UserTier(request.headers.get("X-User-Tier", "free"))

    limiter = get_daily_limiter(user_id, user_tier)
    status = limiter.get_status()

    return {
        "tier": user_tier,
        "limit": status["limit"],
        "used": status["count"],
        "remaining": status["limit"] - status["count"],
        "reset_in": status["window_remaining"]
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 总结

固定窗口算法的完整实现包括：
1. **内存版本**：单机环境，性能高
2. **Redis 版本**：分布式环境，支持共享状态
3. **Lua 脚本优化**：保证原子性，减少网络往返
4. **FastAPI 集成**：依赖注入方式
5. **测试脚本**：验证限流是否生效
6. **性能测试**：对比不同版本的性能
7. **完整示例**：AI Agent API with 每日配额限流

**记住：** 固定窗口适合粗粒度限流（每天、每月），不适合细粒度限流（每秒、每分钟）。
