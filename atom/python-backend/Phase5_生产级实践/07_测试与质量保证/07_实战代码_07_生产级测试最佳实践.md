# 实战代码 07 - 生产级测试最佳实践

## 测试组织结构

### 推荐的目录结构

```
project/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── api/
│   ├── models/
│   ├── services/
│   └── utils/
├── tests/
│   ├── __init__.py
│   ├── conftest.py              # 全局 fixture
│   ├── unit/                    # 单元测试
│   │   ├── __init__.py
│   │   ├── conftest.py
│   │   ├── test_utils.py
│   │   └── test_services.py
│   ├── integration/             # 集成测试
│   │   ├── __init__.py
│   │   ├── conftest.py
│   │   ├── test_database.py
│   │   └── test_repositories.py
│   ├── api/                     # API 测试
│   │   ├── __init__.py
│   │   ├── conftest.py
│   │   ├── test_users_api.py
│   │   └── test_auth_api.py
│   ├── e2e/                     # 端到端测试
│   │   ├── __init__.py
│   │   ├── conftest.py
│   │   └── test_user_flow.py
│   ├── fixtures/                # 共享 fixture
│   │   ├── __init__.py
│   │   ├── database.py
│   │   └── users.py
│   └── helpers/                 # 测试辅助函数
│       ├── __init__.py
│       ├── auth.py
│       └── factories.py
├── pytest.ini
└── .coveragerc
```

---

## 配置文件

### pytest.ini

```ini
# pytest.ini
[pytest]
# 测试目录
testpaths = tests

# 测试文件模式
python_files = test_*.py *_test.py

# 测试类模式
python_classes = Test*

# 测试函数模式
python_functions = test_*

# 默认选项
addopts =
    -v
    --tb=short
    --strict-markers
    --cov=app
    --cov-report=term-missing
    --cov-report=html
    --cov-fail-under=80
    -p no:warnings

# 异步测试模式
asyncio_mode = auto

# 自定义标记
markers =
    unit: Unit tests
    integration: Integration tests
    api: API tests
    e2e: End-to-end tests
    slow: Slow tests (> 1s)
    fast: Fast tests (< 0.1s)
    smoke: Smoke tests
    regression: Regression tests
    security: Security tests

# 最小 Python 版本
minversion = 7.0

# 日志配置
log_cli = false
log_cli_level = INFO
log_cli_format = %(asctime)s [%(levelname)8s] %(message)s
log_cli_date_format = %Y-%m-%d %H:%M:%S

# 超时配置（需要 pytest-timeout）
timeout = 300
timeout_method = thread
```

### .coveragerc

```ini
# .coveragerc
[run]
source = app
omit =
    */tests/*
    */migrations/*
    */__pycache__/*
    */venv/*
    */.venv/*
    */site-packages/*

[report]
precision = 2
show_missing = True
skip_covered = False

exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    if TYPE_CHECKING:
    @abstractmethod

[html]
directory = htmlcov
```

---

## 共享 Fixture

### 数据库 Fixture

```python
# tests/fixtures/database.py
"""数据库 fixture"""
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from app.database import Base

@pytest.fixture(scope="session")
def db_engine():
    """数据库引擎（会话级别）"""
    engine = create_engine("sqlite:///:memory:", echo=False)
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)
    engine.dispose()

@pytest.fixture(scope="function")
def db_session(db_engine):
    """数据库会话（函数级别）"""
    connection = db_engine.connect()
    transaction = connection.begin()
    SessionLocal = sessionmaker(bind=connection)
    session = SessionLocal()

    yield session

    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture
def db_with_data(db_session):
    """带测试数据的数据库"""
    from tests.helpers.factories import UserFactory, PostFactory

    # 创建测试数据
    users = UserFactory.create_batch(5, db_session)
    posts = PostFactory.create_batch(10, db_session, users=users)

    yield db_session, users, posts
```

### 用户 Fixture

```python
# tests/fixtures/users.py
"""用户 fixture"""
import pytest
from app.models.user import User
from app.auth.password import hash_password

@pytest.fixture
def test_user(db_session):
    """测试用户"""
    user = User(
        username="testuser",
        email="test@example.com",
        hashed_password=hash_password("password123"),
        is_active=True,
        is_admin=False
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user

@pytest.fixture
def admin_user(db_session):
    """管理员用户"""
    user = User(
        username="admin",
        email="admin@example.com",
        hashed_password=hash_password("adminpass"),
        is_active=True,
        is_admin=True
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user

@pytest.fixture
def multiple_users(db_session):
    """多个用户"""
    users = []
    for i in range(5):
        user = User(
            username=f"user{i}",
            email=f"user{i}@example.com",
            hashed_password=hash_password("password123"),
            is_active=True,
            is_admin=False
        )
        db_session.add(user)
        users.append(user)

    db_session.commit()
    for user in users:
        db_session.refresh(user)

    return users
```

### API 客户端 Fixture

```python
# tests/conftest.py
"""全局 conftest"""
import pytest
from fastapi.testclient import TestClient
from app.main import app
from app.dependencies import get_db

@pytest.fixture
def client(db_session):
    """测试客户端"""
    def override_get_db():
        try:
            yield db_session
        finally:
            pass

    app.dependency_overrides[get_db] = override_get_db
    yield TestClient(app)
    app.dependency_overrides.clear()

@pytest.fixture
def auth_client(client, test_user):
    """认证客户端"""
    from tests.helpers.auth import login_user

    token = login_user(client, "testuser", "password123")

    class AuthClient:
        def __init__(self, client, token):
            self.client = client
            self.token = token
            self.headers = {"Authorization": f"Bearer {token}"}

        def get(self, url, **kwargs):
            kwargs.setdefault("headers", {}).update(self.headers)
            return self.client.get(url, **kwargs)

        def post(self, url, **kwargs):
            kwargs.setdefault("headers", {}).update(self.headers)
            return self.client.post(url, **kwargs)

        def put(self, url, **kwargs):
            kwargs.setdefault("headers", {}).update(self.headers)
            return self.client.put(url, **kwargs)

        def delete(self, url, **kwargs):
            kwargs.setdefault("headers", {}).update(self.headers)
            return self.client.delete(url, **kwargs)

    return AuthClient(client, token)
```

---

## 测试辅助函数

### Factory 模式

```python
# tests/helpers/factories.py
"""测试数据工厂"""
from typing import List
from app.models.user import User
from app.models.post import Post
from app.auth.password import hash_password

class UserFactory:
    """用户工厂"""

    @staticmethod
    def create(
        db_session,
        username: str = "testuser",
        email: str = "test@example.com",
        password: str = "password123",
        is_active: bool = True,
        is_admin: bool = False
    ) -> User:
        """创建用户"""
        user = User(
            username=username,
            email=email,
            hashed_password=hash_password(password),
            is_active=is_active,
            is_admin=is_admin
        )
        db_session.add(user)
        db_session.commit()
        db_session.refresh(user)
        return user

    @staticmethod
    def create_batch(
        db_session,
        count: int,
        **kwargs
    ) -> List[User]:
        """批量创建用户"""
        users = []
        for i in range(count):
            user = UserFactory.create(
                db_session,
                username=f"user{i}",
                email=f"user{i}@example.com",
                **kwargs
            )
            users.append(user)
        return users


class PostFactory:
    """文章工厂"""

    @staticmethod
    def create(
        db_session,
        user: User,
        title: str = "Test Post",
        content: str = "Test content"
    ) -> Post:
        """创建文章"""
        post = Post(
            title=title,
            content=content,
            user_id=user.id
        )
        db_session.add(post)
        db_session.commit()
        db_session.refresh(post)
        return post

    @staticmethod
    def create_batch(
        db_session,
        count: int,
        users: List[User],
        **kwargs
    ) -> List[Post]:
        """批量创建文章"""
        posts = []
        for i in range(count):
            user = users[i % len(users)]
            post = PostFactory.create(
                db_session,
                user=user,
                title=f"Post {i}",
                content=f"Content {i}",
                **kwargs
            )
            posts.append(post)
        return posts
```

### 认证辅助函数

```python
# tests/helpers/auth.py
"""认证辅助函数"""
from fastapi.testclient import TestClient
from app.auth.jwt import create_access_token

def login_user(client: TestClient, username: str, password: str) -> str:
    """登录用户并返回 token"""
    response = client.post("/api/auth/login", json={
        "username": username,
        "password": password
    })
    return response.json()["access_token"]

def get_auth_headers(user_id: int) -> dict:
    """获取认证头"""
    token = create_access_token(data={"sub": user_id})
    return {"Authorization": f"Bearer {token}"}

def create_test_token(user_id: int, **claims) -> str:
    """创建测试 token"""
    data = {"sub": user_id, **claims}
    return create_access_token(data=data)
```

---

## 测试标记使用

### 标记测试

```python
# tests/unit/test_services.py
"""服务层测试"""
import pytest

@pytest.mark.unit
@pytest.mark.fast
def test_calculate_total():
    """测试：计算总数"""
    from app.services.calculator import calculate_total
    assert calculate_total([1, 2, 3]) == 6

@pytest.mark.unit
@pytest.mark.slow
def test_process_large_dataset():
    """测试：处理大数据集"""
    import time
    time.sleep(1.5)  # 模拟慢速操作
    assert True

@pytest.mark.integration
def test_database_connection(db_session):
    """测试：数据库连接"""
    from app.models.user import User
    user = User(username="test", email="test@example.com")
    db_session.add(user)
    db_session.commit()
    assert user.id is not None

@pytest.mark.api
def test_api_endpoint(client):
    """测试：API 端点"""
    response = client.get("/api/users")
    assert response.status_code == 200

@pytest.mark.e2e
def test_complete_user_flow(client):
    """测试：完整用户流程"""
    # 注册 → 登录 → 操作 → 登出
    pass

@pytest.mark.smoke
def test_application_starts(client):
    """测试：应用启动"""
    response = client.get("/health")
    assert response.status_code == 200

@pytest.mark.security
def test_sql_injection_protection(client):
    """测试：SQL 注入防护"""
    response = client.get("/api/users?username=admin' OR '1'='1")
    assert response.status_code != 200 or "error" in response.json()
```

### 运行特定标记的测试

```bash
# 只运行单元测试
pytest -m unit

# 只运行快速测试
pytest -m fast

# 运行单元测试和集成测试
pytest -m "unit or integration"

# 排除慢速测试
pytest -m "not slow"

# 运行冒烟测试
pytest -m smoke

# 运行安全测试
pytest -m security
```

---

## CI/CD 集成

### GitHub Actions 配置

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        python-version: [3.11, 3.12, 3.13]

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install uv
        uv sync

    - name: Run linting
      run: |
        uv run ruff check .
        uv run mypy app

    - name: Run tests
      run: |
        uv run pytest tests/ -v --cov=app --cov-report=xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: true

    - name: Run security checks
      run: |
        uv run bandit -r app/

  smoke-tests:
    runs-on: ubuntu-latest
    needs: test

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: 3.13

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install uv
        uv sync

    - name: Run smoke tests
      run: |
        uv run pytest tests/ -m smoke -v
```

### GitLab CI 配置

```yaml
# .gitlab-ci.yml
stages:
  - test
  - coverage
  - deploy

variables:
  PYTHON_VERSION: "3.13"

before_script:
  - python -m pip install --upgrade pip
  - pip install uv
  - uv sync

test:unit:
  stage: test
  script:
    - uv run pytest tests/unit/ -v --junitxml=report.xml
  artifacts:
    reports:
      junit: report.xml

test:integration:
  stage: test
  script:
    - uv run pytest tests/integration/ -v --junitxml=report.xml
  artifacts:
    reports:
      junit: report.xml

test:api:
  stage: test
  script:
    - uv run pytest tests/api/ -v --junitxml=report.xml
  artifacts:
    reports:
      junit: report.xml

coverage:
  stage: coverage
  script:
    - uv run pytest tests/ --cov=app --cov-report=html --cov-report=term
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    paths:
      - htmlcov/
```

---

## 性能测试

### 使用 pytest-benchmark

```python
# tests/performance/test_benchmarks.py
"""性能测试"""
import pytest

def test_text_processing_performance(benchmark):
    """测试：文本处理性能"""
    from app.utils.text import process_text

    text = "Hello world " * 1000

    result = benchmark(process_text, text)

    assert result is not None

def test_database_query_performance(benchmark, db_session):
    """测试：数据库查询性能"""
    from app.models.user import User
    from tests.helpers.factories import UserFactory

    # 准备数据
    UserFactory.create_batch(db_session, 100)

    def query_users():
        return db_session.query(User).all()

    result = benchmark(query_users)

    assert len(result) == 100

@pytest.mark.parametrize("size", [10, 100, 1000])
def test_list_processing_performance(benchmark, size):
    """测试：列表处理性能（参数化）"""
    from app.utils.processing import process_list

    data = list(range(size))

    result = benchmark(process_list, data)

    assert len(result) == size
```

**运行性能测试**：

```bash
# 运行性能测试
pytest tests/performance/ --benchmark-only

# 生成性能报告
pytest tests/performance/ --benchmark-only --benchmark-json=benchmark.json

# 对比性能
pytest tests/performance/ --benchmark-compare=benchmark.json
```

---

## 测试数据管理

### 使用 Faker 生成测试数据

```python
# tests/helpers/data_generators.py
"""测试数据生成器"""
from faker import Faker
from typing import List

fake = Faker()

def generate_user_data(count: int = 1) -> List[dict]:
    """生成用户数据"""
    users = []
    for _ in range(count):
        users.append({
            "username": fake.user_name(),
            "email": fake.email(),
            "first_name": fake.first_name(),
            "last_name": fake.last_name(),
            "phone": fake.phone_number(),
            "address": fake.address()
        })
    return users

def generate_post_data(count: int = 1) -> List[dict]:
    """生成文章数据"""
    posts = []
    for _ in range(count):
        posts.append({
            "title": fake.sentence(),
            "content": fake.text(max_nb_chars=1000),
            "tags": [fake.word() for _ in range(3)]
        })
    return posts

def generate_random_text(min_length: int = 10, max_length: int = 100) -> str:
    """生成随机文本"""
    return fake.text(max_nb_chars=max_length)


# 使用示例
def test_with_generated_data():
    """测试：使用生成的数据"""
    users = generate_user_data(count=5)

    assert len(users) == 5
    assert all("username" in u for u in users)
    assert all("email" in u for u in users)
```

### 使用 JSON 文件存储测试数据

```python
# tests/data/users.json
[
    {
        "username": "alice",
        "email": "alice@example.com",
        "role": "admin"
    },
    {
        "username": "bob",
        "email": "bob@example.com",
        "role": "user"
    }
]

# tests/helpers/data_loaders.py
"""测试数据加载器"""
import json
from pathlib import Path

def load_test_data(filename: str) -> dict | list:
    """加载测试数据"""
    data_dir = Path(__file__).parent.parent / "data"
    file_path = data_dir / filename

    with open(file_path, "r") as f:
        return json.load(f)


# 使用示例
def test_with_json_data():
    """测试：使用 JSON 数据"""
    users = load_test_data("users.json")

    assert len(users) == 2
    assert users[0]["username"] == "alice"
```

---

## 测试报告

### 生成 HTML 报告

```bash
# 安装 pytest-html
uv add --dev pytest-html

# 生成 HTML 报告
pytest tests/ --html=report.html --self-contained-html
```

### 生成 JUnit XML 报告

```bash
# 生成 JUnit XML 报告（用于 CI/CD）
pytest tests/ --junitxml=report.xml
```

### 生成 Allure 报告

```bash
# 安装 allure-pytest
uv add --dev allure-pytest

# 生成 Allure 数据
pytest tests/ --alluredir=allure-results

# 查看报告
allure serve allure-results
```

---

## 测试最佳实践总结

### 1. 测试组织

- ✅ 按类型组织测试（unit、integration、api、e2e）
- ✅ 使用清晰的命名约定
- ✅ 共享 fixture 放在 conftest.py
- ✅ 使用 Factory 模式生成测试数据

### 2. 测试编写

- ✅ 每个测试只测试一个功能点
- ✅ 使用描述性的测试名称
- ✅ 测试成功和失败场景
- ✅ 测试边界条件和异常情况

### 3. 测试运行

- ✅ 使用标记分类测试
- ✅ 快速测试优先运行
- ✅ 并行运行独立测试
- ✅ 定期运行完整测试套件

### 4. 测试维护

- ✅ 保持测试代码简洁
- ✅ 避免测试间依赖
- ✅ 定期重构测试代码
- ✅ 删除过时的测试

### 5. CI/CD 集成

- ✅ 每次提交运行测试
- ✅ PR 合并前运行完整测试
- ✅ 监控测试覆盖率
- ✅ 自动生成测试报告

### 6. 性能考虑

- ✅ 使用内存数据库加速测试
- ✅ Mock 外部依赖
- ✅ 并行运行测试
- ✅ 定期检查测试性能

---

## 常用命令速查

```bash
# 运行所有测试
pytest

# 运行特定目录
pytest tests/unit/

# 运行特定文件
pytest tests/unit/test_services.py

# 运行特定测试
pytest tests/unit/test_services.py::test_calculate_total

# 运行标记的测试
pytest -m unit
pytest -m "unit and fast"
pytest -m "not slow"

# 详细输出
pytest -v

# 显示 print 输出
pytest -s

# 失败时停止
pytest -x

# 只运行失败的测试
pytest --lf

# 并行运行
pytest -n auto

# 生成覆盖率报告
pytest --cov=app --cov-report=html

# 生成 HTML 报告
pytest --html=report.html

# 性能测试
pytest --benchmark-only

# 调试模式
pytest --pdb
```

---

## 总结

### 核心要点

1. **组织结构**：清晰的目录结构和命名约定
2. **共享资源**：使用 fixture 和 factory 模式
3. **测试分类**：使用标记分类不同类型的测试
4. **CI/CD 集成**：自动化测试和报告
5. **性能优化**：并行运行、Mock 依赖
6. **持续维护**：定期重构和更新测试

### 最佳实践

- 保持测试简单和独立
- 使用描述性命名
- 测试关键路径和边界条件
- 集成 CI/CD 自动化
- 监控测试覆盖率和性能
- 定期审查和重构测试代码
