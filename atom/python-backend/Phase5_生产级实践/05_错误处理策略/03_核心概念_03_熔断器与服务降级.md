# 核心概念3：熔断器与服务降级

**熔断器是一种防止故障服务雪崩的保护机制，通过监控失败率自动切断对故障服务的调用，并在服务恢复后自动重新启用。**

---

## 为什么需要熔断器？

**问题：** 依赖服务故障导致大量重试，加剧负载，引发雪崩效应

```python
# ❌ 没有熔断器
async def call_llm(prompt: str):
    # LLM 服务已经挂了，但还在不断重试
    return await retry_with_backoff(
        _call_llm_internal,
        max_attempts=3,
        prompt=prompt
    )

# 场景：LLM 服务挂了
# 1. 100 个用户请求 → 300 次重试 → 加剧 LLM 服务负载
# 2. LLM 服务无法恢复 → 雪崩效应
# 3. 用户等待 7 秒 → 糟糕的用户体验
```

**解决方案：** 熔断器

```python
# ✅ 有熔断器
llm_breaker = CircuitBreaker(failure_threshold=0.5, timeout=30)

async def call_llm(prompt: str):
    return await llm_breaker.call(
        retry_with_backoff,
        max_attempts=3,
        func=_call_llm_internal,
        prompt=prompt
    )

# 场景：LLM 服务挂了
# 1. 前 5 个用户请求 → 失败率 > 50% → 熔断器打开
# 2. 后续请求 → 立即返回错误（不再重试）
# 3. 30 秒后 → 熔断器进入半开状态 → 尝试恢复
# 4. 服务恢复 → 熔断器关闭 → 正常工作
```

---

## Circuit Breaker 模式

### 三状态状态机

熔断器有三种状态：

```
Closed（关闭）
  ↓ 失败率 > 阈值
Open（打开/熔断）
  ↓ 等待超时时间
Half-Open（半开）
  ↓ 测试请求成功
Closed（关闭）
```

**状态说明：**

1. **Closed（关闭）**：正常状态，请求正常通过
   - 监控失败率
   - 失败率超过阈值 → 进入 Open 状态

2. **Open（打开）**：熔断状态，拒绝所有请求
   - 立即返回错误（不调用服务）
   - 等待超时时间（如 30 秒）
   - 超时后 → 进入 Half-Open 状态

3. **Half-Open（半开）**：测试状态，允许少量请求通过
   - 允许一个测试请求通过
   - 测试请求成功 → 进入 Closed 状态
   - 测试请求失败 → 回到 Open 状态

---

### 状态转换示例

```python
# 初始状态：Closed
# 请求1：成功 → 保持 Closed
# 请求2：成功 → 保持 Closed
# 请求3：失败 → 保持 Closed（失败率 33%）
# 请求4：失败 → 保持 Closed（失败率 50%）
# 请求5：失败 → 进入 Open（失败率 60% > 50%）

# Open 状态（30 秒）
# 请求6-100：立即返回错误（不调用服务）

# 30 秒后：进入 Half-Open
# 请求101：测试请求 → 成功 → 进入 Closed
# 请求102：正常请求 → 成功 → 保持 Closed
```

---

## 手写熔断器实现

### 基础版本

```python
"""
基础熔断器实现
支持：三状态状态机、失败率监控、自动恢复
"""

import time
from enum import Enum
from typing import Callable, TypeVar, Awaitable

T = TypeVar('T')

class CircuitState(Enum):
    """熔断器状态"""
    CLOSED = "closed"      # 关闭（正常）
    OPEN = "open"          # 打开（熔断）
    HALF_OPEN = "half_open"  # 半开（测试）

class CircuitBreakerOpenError(Exception):
    """熔断器打开错误"""
    pass

class CircuitBreaker:
    """熔断器"""
    def __init__(
        self,
        failure_threshold: float = 0.5,  # 失败率阈值（50%）
        timeout: int = 30,               # 熔断超时（秒）
        min_calls: int = 5               # 最小调用次数
    ):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.min_calls = min_calls

        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None

    async def call(self, func: Callable[..., Awaitable[T]], *args, **kwargs) -> T:
        """调用函数（带熔断保护）"""
        # Open 状态：检查是否可以恢复
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitState.HALF_OPEN
                print(f"熔断器进入半开状态，尝试恢复")
            else:
                raise CircuitBreakerOpenError("服务暂时不可用（熔断中）")

        try:
            result = await func(*args, **kwargs)
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise

    def on_success(self):
        """成功回调"""
        self.success_count += 1

        # Half-Open 状态 → 成功 → Closed 状态
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.CLOSED
            self.failure_count = 0
            self.success_count = 0
            print(f"熔断器恢复正常")

    def on_failure(self):
        """失败回调"""
        self.failure_count += 1
        self.last_failure_time = time.time()

        # Half-Open 状态 → 失败 → Open 状态
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.OPEN
            print(f"熔断器重新打开")
            return

        # Closed 状态 → 失败率过高 → Open 状态
        total = self.failure_count + self.success_count
        if total >= self.min_calls:
            failure_rate = self.failure_count / total
            if failure_rate > self.failure_threshold:
                self.state = CircuitState.OPEN
                print(f"熔断器打开（失败率 {failure_rate:.2%}）")

    def get_state(self) -> dict:
        """获取熔断器状态"""
        total = self.failure_count + self.success_count
        failure_rate = self.failure_count / total if total > 0 else 0

        return {
            "state": self.state.value,
            "failure_count": self.failure_count,
            "success_count": self.success_count,
            "failure_rate": failure_rate,
            "last_failure_time": self.last_failure_time
        }

# 使用示例
llm_breaker = CircuitBreaker(failure_threshold=0.5, timeout=30, min_calls=5)

async def call_llm_with_breaker(prompt: str):
    """调用 LLM（带熔断保护）"""
    return await llm_breaker.call(_call_llm_internal, prompt)
```

---

### 完整版本：带降级策略

```python
"""
完整熔断器实现
支持：三状态状态机、失败率监控、自动恢复、降级策略
"""

import time
from enum import Enum
from typing import Callable, TypeVar, Awaitable, Optional
import structlog

T = TypeVar('T')
logger = structlog.get_logger()

class CircuitState(Enum):
    """熔断器状态"""
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreakerOpenError(Exception):
    """熔断器打开错误"""
    pass

class CircuitBreaker:
    """熔断器（带降级策略）"""
    def __init__(
        self,
        name: str,
        failure_threshold: float = 0.5,
        timeout: int = 30,
        min_calls: int = 5,
        fallback: Optional[Callable] = None
    ):
        self.name = name
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.min_calls = min_calls
        self.fallback = fallback

        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None

    async def call(self, func: Callable[..., Awaitable[T]], *args, **kwargs) -> T:
        """调用函数（带熔断保护）"""
        # Open 状态：检查是否可以恢复
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitState.HALF_OPEN
                logger.info(
                    "circuit_breaker_half_open",
                    name=self.name,
                    state="half_open"
                )
            else:
                # 熔断状态：返回降级响应
                if self.fallback:
                    logger.warning(
                        "circuit_breaker_fallback",
                        name=self.name,
                        state="open"
                    )
                    return await self.fallback(*args, **kwargs)
                raise CircuitBreakerOpenError(f"{self.name} 服务暂时不可用")

        try:
            result = await func(*args, **kwargs)
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise

    def on_success(self):
        """成功回调"""
        self.success_count += 1

        # Half-Open 状态 → 成功 → Closed 状态
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.CLOSED
            self.failure_count = 0
            self.success_count = 0
            logger.info(
                "circuit_breaker_closed",
                name=self.name,
                state="closed"
            )

    def on_failure(self):
        """失败回调"""
        self.failure_count += 1
        self.last_failure_time = time.time()

        # Half-Open 状态 → 失败 → Open 状态
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.OPEN
            logger.warning(
                "circuit_breaker_reopened",
                name=self.name,
                state="open"
            )
            return

        # Closed 状态 → 失败率过高 → Open 状态
        total = self.failure_count + self.success_count
        if total >= self.min_calls:
            failure_rate = self.failure_count / total
            if failure_rate > self.failure_threshold:
                self.state = CircuitState.OPEN
                logger.error(
                    "circuit_breaker_opened",
                    name=self.name,
                    state="open",
                    failure_rate=failure_rate,
                    failure_count=self.failure_count,
                    success_count=self.success_count
                )

    def get_state(self) -> dict:
        """获取熔断器状态"""
        total = self.failure_count + self.success_count
        failure_rate = self.failure_count / total if total > 0 else 0

        return {
            "name": self.name,
            "state": self.state.value,
            "failure_count": self.failure_count,
            "success_count": self.success_count,
            "failure_rate": failure_rate,
            "last_failure_time": self.last_failure_time
        }

    def reset(self):
        """重置熔断器"""
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        logger.info("circuit_breaker_reset", name=self.name)
```

---

## 服务降级策略

### 什么是服务降级？

**服务降级**：当依赖服务不可用时，返回降级响应（缓存、默认值、简化版本）

**降级策略：**
1. **返回缓存**：返回之前缓存的结果
2. **返回默认值**：返回预设的默认响应
3. **返回简化版本**：返回功能简化的响应
4. **返回友好提示**：告知用户服务暂时不可用

---

### 降级策略示例

#### 策略1：返回缓存

```python
import redis

redis_client = redis.Redis()

async def fallback_from_cache(prompt: str):
    """降级策略：返回缓存"""
    cached = redis_client.get(f"llm:{prompt}")
    if cached:
        logger.info("fallback_cache_hit", prompt=prompt)
        return cached.decode()

    logger.warning("fallback_cache_miss", prompt=prompt)
    return "抱歉，服务暂时不可用，请稍后重试"

llm_breaker = CircuitBreaker(
    name="LLM",
    failure_threshold=0.5,
    timeout=30,
    fallback=fallback_from_cache
)
```

---

#### 策略2：返回默认值

```python
async def fallback_default_response(prompt: str):
    """降级策略：返回默认响应"""
    return "抱歉，AI 服务暂时不可用，请稍后重试。您可以尝试：\n1. 刷新页面\n2. 稍后再试\n3. 联系客服"

llm_breaker = CircuitBreaker(
    name="LLM",
    failure_threshold=0.5,
    timeout=30,
    fallback=fallback_default_response
)
```

---

#### 策略3：返回简化版本

```python
async def fallback_simple_response(prompt: str):
    """降级策略：返回简化版本（基于规则）"""
    # 简单的规则匹配
    if "你好" in prompt or "hello" in prompt.lower():
        return "你好！我是 AI 助手。"

    if "天气" in prompt:
        return "抱歉，我暂时无法查询天气信息。"

    return "抱歉，服务暂时不可用，请稍后重试。"

llm_breaker = CircuitBreaker(
    name="LLM",
    failure_threshold=0.5,
    timeout=30,
    fallback=fallback_simple_response
)
```

---

#### 策略4：多级降级

```python
async def fallback_multi_level(prompt: str):
    """降级策略：多级降级"""
    # 第1级：尝试从缓存获取
    cached = redis_client.get(f"llm:{prompt}")
    if cached:
        logger.info("fallback_level_1_cache", prompt=prompt)
        return cached.decode()

    # 第2级：尝试使用备用 LLM（如本地模型）
    try:
        response = await call_local_llm(prompt)
        logger.info("fallback_level_2_local", prompt=prompt)
        return response
    except Exception:
        pass

    # 第3级：返回规则匹配响应
    if "你好" in prompt:
        logger.info("fallback_level_3_rule", prompt=prompt)
        return "你好！我是 AI 助手。"

    # 第4级：返回默认响应
    logger.warning("fallback_level_4_default", prompt=prompt)
    return "抱歉，服务暂时不可用，请稍后重试。"

llm_breaker = CircuitBreaker(
    name="LLM",
    failure_threshold=0.5,
    timeout=30,
    fallback=fallback_multi_level
)
```

---

## 在 AI Agent API 中的应用

### 场景1：LLM 服务熔断

```python
from openai import AsyncOpenAI, Timeout, RateLimitError, APIError

client = AsyncOpenAI()

async def _call_llm_internal(prompt: str) -> str:
    """内部 LLM 调用"""
    response = await client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        timeout=30.0
    )
    return response.choices[0].message.content

async def fallback_llm_response(prompt: str):
    """LLM 降级响应"""
    # 尝试从缓存获取
    cached = redis_client.get(f"llm:{prompt}")
    if cached:
        return cached.decode()

    # 返回默认响应
    return "抱歉，AI 服务暂时不可用，请稍后重试。"

# 创建熔断器
llm_breaker = CircuitBreaker(
    name="OpenAI",
    failure_threshold=0.5,
    timeout=30,
    min_calls=5,
    fallback=fallback_llm_response
)

async def call_llm(prompt: str) -> str:
    """调用 LLM（带熔断保护）"""
    return await llm_breaker.call(_call_llm_internal, prompt)

# 使用示例
@app.post("/chat")
async def chat(message: str):
    try:
        response = await call_llm(message)
        return {"response": response}
    except CircuitBreakerOpenError:
        return {"response": "AI 服务暂时不可用，请稍后重试"}
```

---

### 场景2：向量数据库熔断

```python
import chromadb

async def _vector_search_internal(query: str, top_k: int = 5):
    """内部向量检索"""
    client = chromadb.Client()
    collection = client.get_collection("documents")

    results = collection.query(
        query_texts=[query],
        n_results=top_k
    )
    return results

async def fallback_vector_search(query: str, top_k: int = 5):
    """向量检索降级响应"""
    # 返回空结果
    return {"documents": [], "metadatas": [], "distances": []}

# 创建熔断器
vector_breaker = CircuitBreaker(
    name="VectorDB",
    failure_threshold=0.5,
    timeout=30,
    min_calls=5,
    fallback=fallback_vector_search
)

async def vector_search(query: str, top_k: int = 5):
    """向量检索（带熔断保护）"""
    return await vector_breaker.call(_vector_search_internal, query, top_k)
```

---

### 场景3：多服务协作熔断

```python
# 创建多个熔断器
llm_breaker = CircuitBreaker(name="LLM", failure_threshold=0.5, timeout=30)
vector_breaker = CircuitBreaker(name="VectorDB", failure_threshold=0.5, timeout=30)
db_breaker = CircuitBreaker(name="Database", failure_threshold=0.5, timeout=30)

@app.post("/rag-chat")
async def rag_chat(message: str):
    """RAG 对话（多服务协作）"""
    try:
        # 1. 向量检索（带熔断）
        results = await vector_breaker.call(vector_search, message)

        # 2. 构建上下文
        context = "\n".join(results["documents"][0])

        # 3. LLM 生成（带熔断）
        prompt = f"上下文：{context}\n\n问题：{message}"
        response = await llm_breaker.call(call_llm, prompt)

        # 4. 保存对话（带熔断）
        await db_breaker.call(
            save_conversation,
            {"message": message, "response": response}
        )

        return {"response": response}
    except CircuitBreakerOpenError as e:
        return {"error": str(e)}
```

---

## 熔断器监控

### 监控端点

```python
@app.get("/health/circuit-breakers")
async def get_circuit_breakers_status():
    """获取所有熔断器状态"""
    return {
        "llm": llm_breaker.get_state(),
        "vector_db": vector_breaker.get_state(),
        "database": db_breaker.get_state()
    }

# 响应示例：
# {
#   "llm": {
#     "name": "LLM",
#     "state": "closed",
#     "failure_count": 2,
#     "success_count": 98,
#     "failure_rate": 0.02,
#     "last_failure_time": 1707724800.0
#   },
#   "vector_db": {
#     "name": "VectorDB",
#     "state": "open",
#     "failure_count": 10,
#     "success_count": 5,
#     "failure_rate": 0.67,
#     "last_failure_time": 1707724850.0
#   }
# }
```

---

### 手动控制熔断器

```python
@app.post("/admin/circuit-breakers/{name}/reset")
async def reset_circuit_breaker(name: str):
    """手动重置熔断器"""
    breakers = {
        "llm": llm_breaker,
        "vector_db": vector_breaker,
        "database": db_breaker
    }

    if name not in breakers:
        raise HTTPException(status_code=404, detail="熔断器不存在")

    breakers[name].reset()
    return {"message": f"{name} 熔断器已重置"}
```

---

## 熔断器的最佳实践

### 1. 失败率阈值：50%

**推荐：** 50% 失败率阈值

**理由：**
- 太低（10%）：正常波动也会触发熔断
- 太高（90%）：服务已经严重故障才熔断

```python
CircuitBreaker(failure_threshold=0.5)
```

---

### 2. 熔断超时：30 秒

**推荐：** 30 秒熔断超时

**理由：**
- 太短（5s）：服务可能还没恢复
- 太长（5min）：用户等待时间过长

```python
CircuitBreaker(timeout=30)
```

---

### 3. 最小调用次数：5 次

**推荐：** 5 次最小调用次数

**理由：**
- 太少（1次）：单次失败就熔断，过于敏感
- 太多（100次）：需要很多失败才熔断，反应慢

```python
CircuitBreaker(min_calls=5)
```

---

### 4. 为每个依赖服务创建独立熔断器

```python
# ✅ 正确：每个服务独立熔断器
llm_breaker = CircuitBreaker(name="LLM")
vector_breaker = CircuitBreaker(name="VectorDB")
db_breaker = CircuitBreaker(name="Database")

# ❌ 错误：所有服务共用一个熔断器
global_breaker = CircuitBreaker(name="Global")
```

---

### 5. 提供降级策略

```python
# ✅ 正确：提供降级策略
llm_breaker = CircuitBreaker(
    name="LLM",
    fallback=fallback_response
)

# ❌ 错误：没有降级策略，直接抛出异常
llm_breaker = CircuitBreaker(name="LLM")
```

---

## 熔断器 vs 重试机制

| 特性 | 重试机制 | 熔断器 |
|------|---------|--------|
| **目的** | 自动恢复临时故障 | 防止雪崩效应 |
| **触发条件** | 单次请求失败 | 失败率超过阈值 |
| **作用范围** | 单个请求 | 所有请求 |
| **恢复方式** | 立即重试 | 等待超时后测试 |
| **适用场景** | 临时性错误（网络抖动） | 持续性故障（服务挂了） |

**协作使用：**
```python
# 重试机制 + 熔断器
@retry(stop=stop_after_attempt(3))
async def call_llm_with_retry(prompt: str):
    return await llm_breaker.call(_call_llm_internal, prompt)

# 流程：
# 1. 请求失败 → 重试 3 次
# 2. 重试失败 → 熔断器记录失败
# 3. 失败率 > 50% → 熔断器打开
# 4. 后续请求 → 立即返回错误（不再重试）
```

---

## 总结

**熔断器的核心价值：**
1. **防止雪崩**：减少对故障服务的请求，给它恢复的机会
2. **快速失败**：立即返回错误，而非等待超时
3. **自动恢复**：服务恢复后，自动重新启用
4. **服务降级**：返回降级响应，保障用户体验

**三状态状态机：**
- **Closed**：正常状态，请求正常通过
- **Open**：熔断状态，拒绝所有请求
- **Half-Open**：测试状态，允许少量请求通过

**降级策略：**
- 返回缓存
- 返回默认值
- 返回简化版本
- 多级降级

**最佳实践：**
- 失败率阈值：50%
- 熔断超时：30 秒
- 最小调用次数：5 次
- 每个服务独立熔断器
- 提供降级策略

**在 AI Agent API 中的应用：**
- LLM 服务熔断（OpenAI、Anthropic）
- 向量数据库熔断（Chroma、Milvus）
- 数据库熔断（PostgreSQL）
- 多服务协作熔断
