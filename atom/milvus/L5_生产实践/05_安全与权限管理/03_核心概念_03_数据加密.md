# 核心概念3：数据加密（TLS/SSL）

**数据加密通过 TLS/SSL 协议保护数据在网络传输中的安全，防止中间人攻击和数据窃听，是生产环境的必备安全措施。**

---

## 什么是数据加密？

### 定义

**数据加密 = 将明文数据转换为密文，防止未授权访问**

```
明文数据：可以直接阅读的数据
密文数据：经过加密算法处理，无法直接阅读

加密过程：
明文 + 密钥 → 加密算法 → 密文

解密过程：
密文 + 密钥 → 解密算法 → 明文
```

### 为什么需要加密？

**场景：客户端与 Milvus 服务器通信**

```
没有加密（HTTP）：
客户端 --[明文数据]--> 网络 --[被窃听]--> 服务器
❌ 用户名和密码是明文
❌ 查询内容可被看到
❌ 返回结果可被窃取

有加密（HTTPS/TLS）：
客户端 --[加密数据]--> 网络 --[无法解密]--> 服务器
✅ 用户名和密码被加密
✅ 查询内容无法读取
✅ 返回结果被保护
```

---

## TLS/SSL 协议

### 什么是 TLS？

**TLS（Transport Layer Security）= 传输层安全协议**

- **前身**：SSL（Secure Sockets Layer）
- **当前版本**：TLS 1.3（推荐）、TLS 1.2（兼容）
- **作用**：在客户端和服务器之间建立加密通道

### TLS 的三大功能

#### 1. 加密（Encryption）

```
作用：保护数据内容不被窃听

示例：
明文：password=Milvus123!
加密后：8f3a9b2c1d4e5f6a7b8c9d0e1f2a3b4c
```

#### 2. 身份验证（Authentication）

```
作用：验证服务器身份，防止假冒

客户端验证：
1. 服务器出示证书
2. 客户端检查证书是否由可信 CA 签发
3. 检查证书是否过期
4. 检查证书域名是否匹配
```

#### 3. 完整性（Integrity）

```
作用：防止数据被篡改

机制：
1. 发送方计算数据的哈希值
2. 接收方重新计算哈希值
3. 比较两个哈希值是否一致
4. 不一致 → 数据被篡改
```

### TLS 握手过程

```
客户端                                服务器
  │                                    │
  │  1. ClientHello                    │
  │  （支持的加密套件）                 │
  ├───────────────────────────────────>│
  │                                    │
  │  2. ServerHello                    │
  │  （选择的加密套件 + 证书）          │
  │<───────────────────────────────────┤
  │                                    │
  │  3. 验证证书                        │
  │  （检查 CA、有效期、域名）          │
  │                                    │
  │  4. ClientKeyExchange              │
  │  （加密的预主密钥）                 │
  ├───────────────────────────────────>│
  │                                    │
  │  5. 生成会话密钥                    │
  │  （双方使用相同算法）               │
  │                                    │
  │  6. Finished                       │
  │  （握手完成）                       │
  │<──────────────────────────────────>│
  │                                    │
  │  7. 加密通信                        │
  │  （使用会话密钥）                   │
  │<══════════════════════════════════>│
```

---

## Milvus TLS 配置

### 服务端配置

#### 1. 生成证书

```bash
# 方案1：使用 OpenSSL 生成自签名证书（开发/测试环境）

# 生成 CA 私钥
openssl genrsa -out ca.key 4096

# 生成 CA 证书
openssl req -new -x509 -days 365 -key ca.key -out ca.crt \
  -subj "/C=CN/ST=Beijing/L=Beijing/O=MyCompany/CN=Milvus CA"

# 生成服务器私钥
openssl genrsa -out server.key 4096

# 生成服务器证书签名请求（CSR）
openssl req -new -key server.key -out server.csr \
  -subj "/C=CN/ST=Beijing/L=Beijing/O=MyCompany/CN=milvus.example.com"

# 使用 CA 签发服务器证书
openssl x509 -req -days 365 -in server.csr \
  -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out server.crt

# 生成 PEM 格式（Milvus 需要）
cat server.crt server.key > server.pem

echo "✅ 证书生成完成"
```

```bash
# 方案2：使用 Let's Encrypt（生产环境）

# 安装 certbot
sudo apt-get install certbot

# 获取证书
sudo certbot certonly --standalone \
  -d milvus.example.com \
  --email admin@example.com \
  --agree-tos

# 证书位置：
# /etc/letsencrypt/live/milvus.example.com/fullchain.pem
# /etc/letsencrypt/live/milvus.example.com/privkey.pem
```

#### 2. 配置 Milvus

```yaml
# milvus.yaml
proxy:
  tls:
    enabled: true
    serverPemPath: /path/to/server.pem
    serverKeyPath: /path/to/server.key
    caPemPath: /path/to/ca.crt  # 可选，用于双向认证
```

#### 3. 重启 Milvus

```bash
# Docker
docker restart milvus-standalone

# Docker Compose
docker-compose restart

# Kubernetes
kubectl rollout restart deployment/milvus
```

### 客户端配置

#### 基本 TLS 连接

```python
from pymilvus import connections

# 启用 TLS
connections.connect(
    alias="default",
    host="milvus.example.com",
    port="19530",
    user="admin",
    password="SecurePass123!",
    secure=True,  # 启用 TLS
    server_pem_path="/path/to/server.pem"  # 服务器证书
)

print("✅ TLS 连接成功")
```

#### 双向认证（mTLS）

```python
# 双向认证：客户端也需要证书
connections.connect(
    alias="default",
    host="milvus.example.com",
    port="19530",
    secure=True,
    server_pem_path="/path/to/server.pem",
    client_pem_path="/path/to/client.pem",  # 客户端证书
    client_key_path="/path/to/client.key",  # 客户端私钥
    ca_pem_path="/path/to/ca.pem"           # CA 证书
)

print("✅ mTLS 连接成功")
```

---

## TLS 性能优化

### 1. 连接复用

```python
# ❌ 错误：每次查询都创建新连接
def search_bad(query):
    connections.connect(
        host="milvus.example.com",
        secure=True,
        user="user",
        password="pass"
    )
    results = collection.search(...)
    connections.disconnect("default")
    return results
# 每次都要 TLS 握手，性能极差

# ✅ 正确：复用连接
connections.connect(
    alias="default",
    host="milvus.example.com",
    secure=True,
    user="user",
    password="pass"
)

def search_good(query):
    results = collection.search(...)
    return results
# 只握手一次，性能提升 10 倍
```

### 2. 使用 TLS 1.3

```yaml
# milvus.yaml
proxy:
  tls:
    enabled: true
    minVersion: "1.3"  # TLS 1.3 握手更快
    serverPemPath: /path/to/server.pem
    serverKeyPath: /path/to/server.key
```

**TLS 1.3 优势：**
- 握手只需 1-RTT（TLS 1.2 需要 2-RTT）
- 连接建立时间减少 50%
- 更安全的加密套件

### 3. 硬件加速

```yaml
# 使用支持 AES-NI 的 CPU
proxy:
  tls:
    enabled: true
    cipherSuites:
      - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256  # 硬件加速
      - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
```

---

## 证书管理

### 证书有效期

```python
import ssl
import socket
from datetime import datetime

def check_certificate_expiry(host, port=19530):
    """检查证书有效期"""
    context = ssl.create_default_context()
    with socket.create_connection((host, port)) as sock:
        with context.wrap_socket(sock, server_hostname=host) as ssock:
            cert = ssock.getpeercert()

            # 获取过期时间
            not_after = cert['notAfter']
            expiry_date = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')

            # 计算剩余天数
            days_left = (expiry_date - datetime.now()).days

            print(f"证书过期时间：{expiry_date}")
            print(f"剩余天数：{days_left}")

            if days_left < 30:
                print("⚠️ 证书即将过期，请及时更新！")

# 使用
check_certificate_expiry("milvus.example.com")
```

### 证书自动更新

```bash
# 使用 Let's Encrypt 自动更新

# 1. 安装自动更新脚本
sudo crontab -e

# 2. 添加定时任务（每天检查）
0 0 * * * certbot renew --quiet --post-hook "docker restart milvus-standalone"

# 3. 测试自动更新
sudo certbot renew --dry-run
```

---

## 在 RAG 系统中的应用

### 场景1：生产环境 RAG API

```python
from flask import Flask, request, jsonify
from pymilvus import connections, Collection
import os

app = Flask(__name__)

# 应用启动时建立 TLS 连接
@app.before_first_request
def init_milvus():
    connections.connect(
        alias="default",
        host=os.getenv("MILVUS_HOST"),
        port=os.getenv("MILVUS_PORT"),
        user=os.getenv("MILVUS_USER"),
        password=os.getenv("MILVUS_PASSWORD"),
        secure=True,  # 启用 TLS
        server_pem_path=os.getenv("MILVUS_TLS_CERT")
    )
    print("✅ Milvus TLS 连接已建立")

@app.route("/search", methods=["POST"])
def search():
    """搜索接口"""
    data = request.json
    query_vector = data["vector"]

    collection = Collection("docs")
    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        limit=10
    )

    return jsonify({
        "results": [{"id": hit.id, "distance": hit.distance} for hit in results[0]]
    })

if __name__ == "__main__":
    # API 也使用 HTTPS
    app.run(
        host="0.0.0.0",
        port=5000,
        ssl_context=('/path/to/api_cert.pem', '/path/to/api_key.pem')
    )
```

### 场景2：金融 RAG 系统

```python
class SecureFinancialRAG:
    """金融行业 RAG 系统（必须加密）"""

    def __init__(self):
        # 强制 TLS 连接
        connections.connect(
            alias="default",
            host=os.getenv("MILVUS_HOST"),
            user=os.getenv("MILVUS_USER"),
            password=os.getenv("MILVUS_PASSWORD"),
            secure=True,  # 必须启用
            server_pem_path=os.getenv("MILVUS_TLS_CERT")
        )

        # 验证 TLS 是否启用
        if not self._verify_tls():
            raise Exception("❌ TLS 未启用，拒绝连接")

    def _verify_tls(self):
        """验证 TLS 是否启用"""
        # 检查连接是否使用 TLS
        # 实际实现需要检查连接属性
        return True

    def search(self, query):
        """搜索（所有数据都加密传输）"""
        collection = Collection("financial_docs")
        results = collection.search(...)
        return results

# 使用
rag = SecureFinancialRAG()
results = rag.search("查询客户财务数据")
# ✅ 所有通信都通过 TLS 加密
```

---

## 常见问题

### 1. 证书验证失败

```python
# 错误信息
# ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED]

# 原因：
# - 证书过期
# - 证书域名不匹配
# - 证书不是由可信 CA 签发

# 解决方案1：使用正确的证书
connections.connect(
    host="milvus.example.com",  # 必须与证书域名一致
    secure=True,
    server_pem_path="/path/to/valid_cert.pem"
)

# 解决方案2：跳过验证（仅用于开发环境）
import ssl
ssl._create_default_https_context = ssl._create_unverified_context
# ⚠️ 生产环境禁止使用！
```

### 2. 性能下降

```
问题：启用 TLS 后性能下降 20%

原因：
- 每次连接都要 TLS 握手
- 加密/解密开销

解决方案：
1. 使用连接池，复用连接
2. 启用 TLS 1.3
3. 使用硬件加速（AES-NI）
4. 在负载均衡层终止 TLS
```

### 3. 证书管理复杂

```
问题：证书过期导致服务中断

解决方案：
1. 使用 Let's Encrypt 自动更新
2. 设置证书过期告警（提前 30 天）
3. 使用证书管理工具（cert-manager）
```

---

## 小结

**数据加密（TLS）的核心要点：**

1. **定义**：保护数据传输安全，防止窃听和篡改
2. **TLS 功能**：加密、身份验证、完整性
3. **配置**：服务端启用 TLS，客户端使用 secure=True
4. **证书管理**：生成、更新、监控证书有效期
5. **性能优化**：连接复用、TLS 1.3、硬件加速
6. **RAG 应用**：生产环境必须启用 TLS
7. **合规要求**：金融、医疗等行业强制要求

**下一步：** 学习实战代码，实现完整的安全架构
