# 反直觉点

## 误区1：Collection 不需要创建索引就能检索 ❌

### 为什么错？

**Milvus 必须先创建索引才能执行向量检索！**

```python
from pymilvus import Collection

collection = Collection("documents")

# 插入数据
data = [{"id": 1, "embedding": [0.1] * 768, "title": "文档1"}]
collection.insert(data)
collection.flush()

# 加载 Collection
collection.load()

# ❌ 错误：没有创建索引就检索
try:
    results = collection.search(
        data=[[0.1] * 768],
        anns_field="embedding",
        param={"metric_type": "L2"},
        limit=10
    )
except Exception as e:
    print(f"错误: {e}")
    # 输出：index not exist
```

**正确做法：**
```python
# ✅ 正确：先创建索引
index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "L2",
    "params": {"nlist": 128}
}

collection.create_index(
    field_name="embedding",
    index_params=index_params
)

# 然后加载
collection.load()

# 现在可以检索了
results = collection.search(
    data=[[0.1] * 768],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10
)
```

### 为什么人们容易这样错？

**心理原因：**
- 传统数据库（如 MySQL）可以在没有索引的情况下查询（只是慢）
- 以为 Milvus 也可以"先用着，后优化"
- 不理解向量检索的特殊性

**技术原因：**
- 向量检索必须依赖索引结构（如 IVF、HNSW）
- 没有索引，Milvus 无法进行高效的相似度计算
- 这是向量数据库的根本特性，不是可选优化

### 正确理解

**向量检索的流程：**
```
插入数据 → 创建索引 → 加载到内存 → 执行检索
```

**类比：**
- 传统数据库：没有索引 = 全表扫描（慢但能用）
- 向量数据库：没有索引 = 无法检索（直接报错）

---

## 误区2：向量维度可以随时修改 ❌

### 为什么错？

**Schema 一旦创建，向量维度不可修改！**

```python
from pymilvus import Collection, CollectionSchema, FieldSchema, DataType

# 创建 Collection（768维）
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768)
]

schema = CollectionSchema(fields=fields)
collection = Collection(name="documents", schema=schema)

# ❌ 错误：尝试插入1536维向量
data = [{
    "id": 1,
    "embedding": [0.1] * 1536  # 维度不匹配！
}]

try:
    collection.insert(data)
except Exception as e:
    print(f"错误: {e}")
    # 输出：vector dimension mismatch
```

**如果需要修改维度，必须：**
```python
# 1. 创建新的 Collection（新维度）
new_fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=1536)
]

new_schema = CollectionSchema(fields=new_fields)
new_collection = Collection(name="documents_v2", schema=new_schema)

# 2. 迁移数据（需要重新生成 Embedding）
# 3. 删除旧 Collection
```

### 为什么人们容易这样错？

**心理原因：**
- 以为 Schema 像配置文件一样可以随时修改
- 不理解向量维度是索引结构的基础
- 低估了修改维度的影响

**技术原因：**
- 向量索引（如 IVF、HNSW）是基于固定维度构建的
- 修改维度 = 重建整个索引结构
- Milvus 选择禁止修改以避免数据不一致

### 正确理解

**Schema 的不可变性：**

| 属性 | 是否可修改 |
|------|-----------|
| 向量维度 | ❌ 不可修改 |
| 字段类型 | ❌ 不可修改 |
| 主键字段 | ❌ 不可修改 |
| 字段名称 | ❌ 不可修改 |
| 字段描述 | ✅ 可修改（Milvus 2.3+） |
| 添加新字段 | ⚠️ 有限支持（动态 Schema） |

**最佳实践：**
- 在创建 Collection 前仔细规划 Schema
- 向量维度必须与 Embedding 模型一致
- 如果需要修改，创建新 Collection 并迁移数据

---

## 误区3：Milvus 支持向量的 UPDATE 操作 ❌

### 为什么错？

**Milvus 不支持直接更新向量！只能删除后重新插入。**

```python
from pymilvus import Collection

collection = Collection("documents")

# 插入数据
data = [{"id": 1, "embedding": [0.1] * 768, "title": "旧标题"}]
collection.insert(data)

# ❌ 错误：Milvus 没有 update 方法
# collection.update({"id": 1, "title": "新标题"})  # 不存在！

# ✅ 正确：删除 + 插入
# 1. 删除旧数据
collection.delete(expr="id == 1")

# 2. 插入新数据
new_data = [{"id": 1, "embedding": [0.2] * 768, "title": "新标题"}]
collection.insert(new_data)
```

**注意：Milvus 2.3+ 支持标量字段的 upsert（插入或更新）**
```python
# Milvus 2.3+ 支持 upsert
data = [{"id": 1, "embedding": [0.2] * 768, "title": "新标题"}]
collection.upsert(data)  # 如果 id=1 存在则更新，否则插入
```

### 为什么人们容易这样错？

**心理原因：**
- 传统数据库都支持 UPDATE 操作
- 以为向量数据库也应该支持
- 不理解向量索引的特殊性

**技术原因：**
- 向量索引是全局优化的结构
- 更新一个向量可能需要重建部分索引
- 删除+插入的成本与更新相当，设计更简单

### 正确理解

**Milvus 的数据操作：**

| 操作 | 是否支持 | 说明 |
|------|---------|------|
| INSERT | ✅ 支持 | 插入新数据 |
| DELETE | ✅ 支持 | 根据表达式删除 |
| UPDATE | ❌ 不支持 | 需要删除+插入 |
| UPSERT | ✅ 支持（2.3+） | 插入或更新 |
| QUERY | ✅ 支持 | 标量查询 |
| SEARCH | ✅ 支持 | 向量检索 |

**最佳实践：**
```python
def update_document(collection, doc_id, new_embedding, new_metadata):
    """更新文档（删除+插入）"""
    # 1. 删除旧数据
    collection.delete(expr=f"id == {doc_id}")

    # 2. 插入新数据
    data = [{
        "id": doc_id,
        "embedding": new_embedding,
        **new_metadata
    }]
    collection.insert(data)

    # 3. 刷新数据
    collection.flush()
```

---

## 误区4：Collection 创建后立即可以检索 ❌

### 为什么错？

**Collection 创建后需要：插入数据 → 创建索引 → 加载到内存，才能检索！**

```python
from pymilvus import Collection, CollectionSchema, FieldSchema, DataType

# 1. 创建 Collection
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768)
]

schema = CollectionSchema(fields=fields)
collection = Collection(name="documents", schema=schema)

# ❌ 错误：立即检索
try:
    results = collection.search(
        data=[[0.1] * 768],
        anns_field="embedding",
        param={"metric_type": "L2"},
        limit=10
    )
except Exception as e:
    print(f"错误: {e}")
    # 输出：collection not loaded 或 index not exist
```

**正确流程：**
```python
# 1. 创建 Collection
collection = Collection(name="documents", schema=schema)

# 2. 插入数据
data = [{"id": i, "embedding": [0.1] * 768} for i in range(100)]
collection.insert(data)
collection.flush()

# 3. 创建索引
index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "L2",
    "params": {"nlist": 128}
}
collection.create_index(field_name="embedding", index_params=index_params)

# 4. 加载到内存
collection.load()

# 5. 现在可以检索了
results = collection.search(
    data=[[0.1] * 768],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10
)
```

### 为什么人们容易这样错？

**心理原因：**
- 以为创建 Collection 就像创建数据库表，立即可用
- 不理解向量检索需要索引和内存加载
- 忽略了向量数据库的特殊性

**技术原因：**
- 向量检索必须依赖索引
- 索引必须加载到内存才能快速检索
- 这是向量数据库的性能保证

### 正确理解

**Collection 的完整生命周期：**
```
创建 Collection
    ↓
插入数据
    ↓
创建索引（必需）
    ↓
加载到内存（必需）
    ↓
执行检索
    ↓
释放内存（可选）
    ↓
删除 Collection（可选）
```

**类比：**
- 创建 Collection = 搭建书架
- 插入数据 = 把书放到书架上
- 创建索引 = 制作索引卡片
- 加载到内存 = 把书拿到阅览桌
- 执行检索 = 在阅览桌上查找

---

## 误区5：所有字段都可以作为主键 ❌

### 为什么错？

**主键字段只能是 INT64 或 VARCHAR 类型！**

```python
from pymilvus import FieldSchema, DataType

# ❌ 错误：FLOAT 不能作为主键
try:
    pk_field = FieldSchema(
        name="id",
        dtype=DataType.FLOAT,  # 错误！
        is_primary=True
    )
except Exception as e:
    print(f"错误: {e}")

# ❌ 错误：VECTOR 不能作为主键
try:
    pk_field = FieldSchema(
        name="embedding",
        dtype=DataType.FLOAT_VECTOR,  # 错误！
        dim=768,
        is_primary=True
    )
except Exception as e:
    print(f"错误: {e}")

# ✅ 正确：INT64 可以作为主键
pk_field = FieldSchema(
    name="id",
    dtype=DataType.INT64,  # 正确
    is_primary=True
)

# ✅ 正确：VARCHAR 可以作为主键
pk_field = FieldSchema(
    name="doc_id",
    dtype=DataType.VARCHAR,  # 正确
    max_length=50,
    is_primary=True
)
```

### 为什么人们容易这样错？

**心理原因：**
- 以为任何唯一的字段都可以作为主键
- 不理解主键类型的限制
- 想用向量本身作为主键（向量是唯一的）

**技术原因：**
- 主键需要支持高效的精确匹配查询
- INT64 和 VARCHAR 有成熟的索引结构
- 向量不适合作为主键（相似度查询 ≠ 精确匹配）

### 正确理解

**主键的要求：**
1. 类型：只能是 `INT64` 或 `VARCHAR`
2. 唯一性：值必须唯一
3. 非空：不能为空
4. 数量：每个 Collection 有且只有一个主键

**主键类型选择：**

| 场景 | 推荐类型 | 示例 |
|------|---------|------|
| 自增ID | INT64 | 1, 2, 3, ... |
| UUID | VARCHAR | "550e8400-e29b-41d4-a716-..." |
| 文档ID | VARCHAR | "doc_001", "doc_002", ... |
| 时间戳 | INT64 | 1234567890 |
| 用户ID | INT64 或 VARCHAR | 12345 或 "user_12345" |

---

## 总结

**5个最常见的误区：**

1. **误区1**：Collection 不需要创建索引就能检索
   - **真相**：必须先创建索引才能检索

2. **误区2**：向量维度可以随时修改
   - **真相**：Schema 一旦创建，维度不可修改

3. **误区3**：Milvus 支持向量的 UPDATE 操作
   - **真相**：只能删除后重新插入（或使用 upsert）

4. **误区4**：Collection 创建后立即可以检索
   - **真相**：需要插入数据 → 创建索引 → 加载到内存

5. **误区5**：所有字段都可以作为主键
   - **真相**：主键只能是 INT64 或 VARCHAR

**记住这3个核心原则：**
1. **索引是必需的**：没有索引无法检索
2. **Schema 是不可变的**：创建前仔细规划
3. **加载是必需的**：检索前必须加载到内存

掌握了这些反直觉点，就能避免90%的常见错误！
