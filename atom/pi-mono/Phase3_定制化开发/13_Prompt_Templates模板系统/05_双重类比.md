# 双重类比

## 为什么需要双重类比？

理解新技术最快的方式是将其与已知事物类比。对于 Pi-mono 的 Prompt Templates，我们提供两种类比：

1. **TypeScript/Node.js 类比** - 连接你的编程知识
2. **日常生活类比** - 连接你的生活经验

通过双重类比，你可以从不同角度理解同一个概念，加深记忆和理解。

---

## 核心概念的双重类比

### 1. Prompt Templates 整体

#### TypeScript/Node.js 类比

**Prompt Templates 就像 Handlebars/EJS 模板引擎**

```typescript
// Handlebars 模板
const template = Handlebars.compile('Hello, {{name}}!');
const result = template({ name: 'World' });
// 输出: "Hello, World!"

// Pi-mono Prompt Template
// 文件: ~/.pi/agent/prompts/hello.md
// 内容: Hello, $1!
// 调用: /hello World
// 输出: "Hello, World!"
```

**相似点：**
- 都是模板系统
- 都支持变量替换
- 都可以复用

**不同点：**
- Handlebars 使用 `{{variable}}` 语法，Pi-mono 使用 `$1` 语法
- Handlebars 需要编程调用，Pi-mono 使用命令行调用
- Handlebars 需要编译，Pi-mono 直接替换

---

#### 日常生活类比

**Prompt Templates 就像邮件模板**

```
邮件模板：
主题：关于 [项目名称] 的进度更新
正文：
亲爱的 [收件人]，

我想向您汇报 [项目名称] 的最新进展...

最好的祝愿，
[发件人]

使用时：
- [项目名称] → "网站重构"
- [收件人] → "张经理"
- [发件人] → "李工程师"

结果：
主题：关于网站重构的进度更新
正文：
亲爱的张经理，

我想向您汇报网站重构的最新进展...

最好的祝愿，
李工程师
```

**相似点：**
- 都是预定义的内容框架
- 都有需要填入的变量
- 都可以多次使用

---

### 2. Markdown 模板

#### TypeScript/Node.js 类比

**Markdown 模板就像 README.md 文件**

```typescript
// 项目的 README.md
# Project Name

## Installation
```bash
npm install
```

## Usage
```typescript
import { foo } from './foo';
foo();
```

// Pi-mono Prompt Template
// 文件: ~/.pi/agent/prompts/readme.md
---
description: Generate README for project
---
# $1

## Installation
```bash
npm install
```

## Usage
```typescript
import { $2 } from './$2';
$2();
```
```

**相似点：**
- 都使用 Markdown 格式
- 都易于阅读和编辑
- 都支持代码块、列表等富文本

**不同点：**
- README 是静态文档，Prompt Template 是动态模板
- README 不支持变量，Prompt Template 支持变量替换

---

#### 日常生活类比

**Markdown 模板就像填空题**

```
填空题：
我的名字是 _______，我来自 _______，我喜欢 _______。

填入答案：
我的名字是 张三，我来自 北京，我喜欢 编程。

Markdown 模板：
---
description: Self introduction
---
我的名字是 $1，我来自 $2，我喜欢 $3。

调用：
/intro 张三 北京 编程

输出：
我的名字是 张三，我来自 北京，我喜欢 编程。
```

**相似点：**
- 都有固定的框架
- 都有需要填入的空白
- 都可以生成完整的内容

---

### 3. YAML Frontmatter

#### TypeScript/Node.js 类比

**YAML Frontmatter 就像 package.json 的元数据**

```typescript
// package.json
{
  "name": "my-project",
  "version": "1.0.0",
  "description": "My awesome project",
  "main": "index.js"
}

// Pi-mono Prompt Template
---
description: Review GitHub PRs
author: team@example.com
version: 1.0.0
tags: [code-review, pr, github]
---
Template content here...
```

**相似点：**
- 都存储元数据
- 都使用结构化格式
- 都易于解析

**不同点：**
- package.json 使用 JSON 格式，Frontmatter 使用 YAML 格式
- package.json 是独立文件，Frontmatter 嵌入在 Markdown 文件中

---

#### 日常生活类比

**YAML Frontmatter 就像书的封面信息**

```
书的封面：
书名：《深入理解 TypeScript》
作者：张三
出版社：技术出版社
ISBN：978-1234567890
简介：本书深入讲解 TypeScript...

正文：
第一章：TypeScript 基础
...

Prompt Template：
---
description: Review GitHub PRs
author: team@example.com
version: 1.0.0
---
You are given GitHub PR URLs: $@
...
```

**相似点：**
- 都在内容前面提供元信息
- 都帮助理解内容的背景
- 都可以被索引和搜索

---

### 4. Bash 风格变量替换

#### TypeScript/Node.js 类比

**Bash 风格变量就像函数参数**

```typescript
// TypeScript 函数
function greet(name: string, age: number) {
  return `Hello, ${name}! You are ${age} years old.`;
}

greet('Alice', 25);
// 输出: "Hello, Alice! You are 25 years old."

// Bash 脚本
#!/bin/bash
echo "Hello, $1! You are $2 years old."
# 调用: ./greet.sh Alice 25
# 输出: "Hello, Alice! You are 25 years old."

// Pi-mono Prompt Template
---
description: Greet user
---
Hello, $1! You are $2 years old.
# 调用: /greet Alice 25
# 输出: "Hello, Alice! You are 25 years old."
```

**相似点：**
- 都支持位置参数
- 都可以传递多个参数
- 都可以在内容中引用参数

**不同点：**
- TypeScript 使用命名参数，Bash 使用位置参数
- TypeScript 有类型检查，Bash 没有
- TypeScript 需要编译，Bash 直接执行

---

#### 日常生活类比

**Bash 风格变量就像点餐单**

```
点餐单：
第 1 项：_______
第 2 项：_______
第 3 项：_______
总价：_______ 元

填写：
第 1 项：汉堡
第 2 项：薯条
第 3 项：可乐
总价：35 元

Prompt Template：
---
description: Order food
---
第 1 项：$1
第 2 项：$2
第 3 项：$3
总价：$4 元

调用：
/order 汉堡 薯条 可乐 35

输出：
第 1 项：汉堡
第 2 项：薯条
第 3 项：可乐
总价：35 元
```

**相似点：**
- 都按顺序填入信息
- 都有固定的位置
- 都可以生成完整的结果

---

### 5. 多源加载

#### TypeScript/Node.js 类比

**多源加载就像 Node.js 的模块解析**

```typescript
// Node.js 模块解析顺序
import { foo } from 'foo';

// 解析顺序：
// 1. ./node_modules/foo (项目级别)
// 2. ../node_modules/foo (父目录)
// 3. /usr/local/lib/node_modules/foo (全局)

// Pi-mono Prompt Templates 加载顺序
/template-name

// 解析顺序：
// 1. ./.pi/prompts/template-name.md (项目级别)
// 2. ~/.pi/agent/prompts/template-name.md (全局)
// 3. 显式路径 (如果指定)
```

**相似点：**
- 都有多个搜索路径
- 都有优先级顺序
- 都支持项目级别和全局级别

**不同点：**
- Node.js 向上递归搜索，Pi-mono 只搜索两个固定位置
- Node.js 有复杂的解析算法，Pi-mono 简单直接

---

#### 日常生活类比

**多源加载就像找工具**

```
找工具的顺序：
1. 先在工作台上找（项目级别）
2. 再在工具箱里找（个人级别）
3. 最后去仓库找（全局级别）

找到第一个就停止搜索。

Prompt Templates 加载：
1. 先在项目目录找 ./.pi/prompts/
2. 再在个人目录找 ~/.pi/agent/prompts/
3. 最后在显式路径找（如果指定）

找到第一个就停止搜索。
```

**相似点：**
- 都有多个搜索位置
- 都有优先级顺序
- 都是找到第一个就停止

---

### 6. 命令行调用

#### TypeScript/Node.js 类比

**命令行调用就像 npm scripts**

```typescript
// package.json
{
  "scripts": {
    "test": "jest",
    "build": "tsc",
    "start": "node dist/index.js"
  }
}

// 调用
npm run test
npm run build
npm run start

// Pi-mono Prompt Templates
// 模板定义
~/.pi/agent/prompts/test.md
~/.pi/agent/prompts/build.md
~/.pi/agent/prompts/start.md

// 调用
/test
/build
/start
```

**相似点：**
- 都使用简短的命令名
- 都可以传递参数
- 都是命令行风格

**不同点：**
- npm scripts 执行 Shell 命令，Prompt Templates 展开模板
- npm scripts 需要 package.json，Prompt Templates 只需要文件

---

#### 日常生活类比

**命令行调用就像快捷键**

```
快捷键：
Ctrl+C → 复制
Ctrl+V → 粘贴
Ctrl+S → 保存

按下快捷键，执行对应操作。

Prompt Templates：
/pr → 展开 PR 审查模板
/issue → 展开问题分析模板
/test → 展开测试生成模板

输入命令，展开对应模板。
```

**相似点：**
- 都是简短的触发方式
- 都执行预定义的操作
- 都提高效率

---

## 完整工作流的双重类比

### TypeScript/Node.js 类比

**Prompt Templates 工作流就像 Express 中间件**

```typescript
// Express 中间件
app.use('/api', (req, res, next) => {
  // 1. 解析请求
  const { userId, action } = req.body;

  // 2. 加载模板
  const template = loadTemplate(action);

  // 3. 填充变量
  const result = template.render({ userId });

  // 4. 返回结果
  res.json({ result });
});

// Pi-mono Prompt Templates 工作流
// 1. 用户输入命令
/pr https://github.com/user/repo/pull/123

// 2. Pi 解析命令
// - 模板名: pr
// - 参数: https://github.com/user/repo/pull/123

// 3. 加载模板
// - 搜索 ./.pi/prompts/pr.md
// - 搜索 ~/.pi/agent/prompts/pr.md
// - 找到第一个

// 4. 替换变量
// - $1 → https://github.com/user/repo/pull/123

// 5. 展开模板
// - 将替换后的内容发送给 LLM
```

**相似点：**
- 都有请求解析
- 都有模板加载
- 都有变量替换
- 都有结果返回

---

### 日常生活类比

**Prompt Templates 工作流就像自动回复**

```
自动回复设置：
触发词：订单查询
回复模板：
您好，您的订单号是 [订单号]，
当前状态是 [状态]，
预计送达时间是 [时间]。

使用流程：
1. 客户发送：订单查询 12345
2. 系统识别：触发词 = "订单查询"，参数 = "12345"
3. 系统查询：订单号 12345 的信息
4. 系统填充：
   - [订单号] → 12345
   - [状态] → 配送中
   - [时间] → 明天下午 3 点
5. 系统回复：
   您好，您的订单号是 12345，
   当前状态是 配送中，
   预计送达时间是 明天下午 3 点。

Prompt Templates 流程：
1. 用户输入：/pr https://github.com/user/repo/pull/123
2. Pi 识别：模板名 = "pr"，参数 = "https://..."
3. Pi 加载：pr.md 模板
4. Pi 替换：$1 → https://...
5. Pi 展开：将替换后的内容发送给 LLM
```

**相似点：**
- 都有触发机制
- 都有模板匹配
- 都有变量替换
- 都有自动响应

---

## 高级特性的双重类比

### 1. 参数切片 (`${@:N}`)

#### TypeScript/Node.js 类比

**参数切片就像数组切片**

```typescript
// TypeScript 数组切片
const args = ['file1.ts', 'file2.ts', 'file3.ts', 'file4.ts'];

const first = args[0];           // 'file1.ts'
const rest = args.slice(1);      // ['file2.ts', 'file3.ts', 'file4.ts']
const middle = args.slice(1, 3); // ['file2.ts', 'file3.ts']

// Bash 参数切片
# $1 = 'file1.ts'
# ${@:2} = 'file2.ts file3.ts file4.ts'
# ${@:2:2} = 'file2.ts file3.ts'

// Pi-mono Prompt Template
---
description: Compare files
---
Base file: $1
Files to compare: ${@:2}

# 调用: /compare file1.ts file2.ts file3.ts file4.ts
# 输出:
# Base file: file1.ts
# Files to compare: file2.ts file3.ts file4.ts
```

**相似点：**
- 都可以获取部分参数
- 都支持起始位置和长度
- 都可以灵活组合

---

#### 日常生活类比

**参数切片就像分配任务**

```
任务分配：
第一个人：负责总协调（$1）
其他人：负责具体执行（${@:2}）

示例：
团队成员：张三、李四、王五、赵六

分配：
第一个人（张三）：负责总协调
其他人（李四、王五、赵六）：负责具体执行

Prompt Template：
---
description: Assign tasks
---
总协调：$1
执行团队：${@:2}

调用：
/assign 张三 李四 王五 赵六

输出：
总协调：张三
执行团队：李四 王五 赵六
```

**相似点：**
- 都是分组处理
- 都有特殊角色和普通角色
- 都可以灵活分配

---

### 2. 所有参数 (`$@`)

#### TypeScript/Node.js 类比

**所有参数就像 Rest 参数**

```typescript
// TypeScript Rest 参数
function processFiles(...files: string[]) {
  console.log(`Processing ${files.length} files:`);
  files.forEach(file => console.log(`- ${file}`));
}

processFiles('a.ts', 'b.ts', 'c.ts');
// 输出:
// Processing 3 files:
// - a.ts
// - b.ts
// - c.ts

// Bash 所有参数
#!/bin/bash
echo "Processing files: $@"
# 调用: ./process.sh a.ts b.ts c.ts
# 输出: Processing files: a.ts b.ts c.ts

// Pi-mono Prompt Template
---
description: Process files
---
Processing files: $@

# 调用: /process a.ts b.ts c.ts
# 输出: Processing files: a.ts b.ts c.ts
```

**相似点：**
- 都可以接收任意数量的参数
- 都可以统一处理
- 都很灵活

---

#### 日常生活类比

**所有参数就像购物清单**

```
购物清单：
需要购买的物品：[所有物品]

填写：
需要购买的物品：苹果、香蕉、橙子、牛奶、面包

Prompt Template：
---
description: Shopping list
---
需要购买的物品：$@

调用：
/shopping 苹果 香蕉 橙子 牛奶 面包

输出：
需要购买的物品：苹果 香蕉 橙子 牛奶 面包
```

**相似点：**
- 都可以包含任意数量的项目
- 都是列表形式
- 都可以一次性处理

---

## 对比表格总结

### Prompt Templates vs. 其他模板系统

| 特性 | Pi-mono Templates | Handlebars | Jinja2 | 日常类比 |
|------|-------------------|------------|--------|---------|
| **格式** | Markdown + YAML | HTML/文本 | HTML/文本 | 邮件模板 |
| **变量语法** | `$1`, `$@` | `{{var}}` | `{{var}}` | 填空题 |
| **加载方式** | 文件系统 | 编程加载 | 编程加载 | 找工具 |
| **调用方式** | 命令行 `/name` | 编程调用 | 编程调用 | 快捷键 |
| **学习成本** | 零（Bash 语法） | 中（新语法） | 中（新语法） | - |
| **版本控制** | 原生支持（Git） | 需要额外管理 | 需要额外管理 | - |
| **团队协作** | 原生支持（Git） | 需要额外工具 | 需要额外工具 | - |

---

### 变量语法对比

| 语法 | Pi-mono | TypeScript | Bash | 日常类比 |
|------|---------|------------|------|---------|
| **第一个参数** | `$1` | `args[0]` | `$1` | 第一项 |
| **所有参数** | `$@` | `...args` | `$@` | 所有项 |
| **参数切片** | `${@:2}` | `args.slice(1)` | `${@:2}` | 剩余项 |
| **参数范围** | `${@:2:3}` | `args.slice(1, 4)` | `${@:2:3}` | 中间项 |

---

## 记忆技巧

### 1. 联想记忆

**Markdown 模板 = README.md**
- 看到 Markdown，想到 README
- 看到 YAML frontmatter，想到 package.json
- 看到 `$1`，想到 Bash 脚本

### 2. 对比记忆

**Pi-mono vs. Handlebars**
- Pi-mono: `$1` (Bash 风格)
- Handlebars: `{{variable}}` (Mustache 风格)

**Pi-mono vs. Node.js**
- Pi-mono: 文件系统加载
- Node.js: 模块系统加载

### 3. 场景记忆

**邮件模板场景**
- 模板 = 邮件模板
- 变量 = 收件人、主题等
- 调用 = 发送邮件

**点餐场景**
- 模板 = 点餐单
- 变量 = 菜品、数量等
- 调用 = 下单

---

## 2025-2026 年的实践验证

### GitHub 社区的类比

根据 [Awesome AI System Prompts](https://github.com/dontriskit/awesome-ai-system-prompts) 的实践，社区普遍将 Prompt Templates 类比为：

1. **代码模块** - 可复用、可组合、可版本控制
2. **配置文件** - 结构化、易于编辑、易于管理
3. **Shell 脚本** - 命令行风格、参数传递、快速执行

### Reddit 社区的类比

根据 [Reddit: 大型代理提示存储与模板变量](https://www.reddit.com/r/PromptEngineering/comments/1n3ybtu/how_are_you_storing_and_managing_larger_prompts/) 的讨论，社区将 Prompt Templates 类比为：

1. **Markdown 文档** - 易读、易写、易维护
2. **模板引擎** - 变量替换、逻辑控制、输出生成
3. **版本控制** - Git 管理、历史追踪、团队协作

---

## 总结

**双重类比的价值：**

1. **TypeScript/Node.js 类比** - 帮助你快速理解技术实现
2. **日常生活类比** - 帮助你理解使用场景和价值

**记住这些核心类比：**
- Prompt Templates = Handlebars + Bash + 邮件模板
- Markdown 模板 = README.md + 填空题
- YAML Frontmatter = package.json + 书的封面
- Bash 变量 = 函数参数 + 点餐单
- 多源加载 = Node.js 模块解析 + 找工具
- 命令行调用 = npm scripts + 快捷键

**通过双重类比，你可以从多个角度理解 Prompt Templates，加深记忆和理解。**

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
