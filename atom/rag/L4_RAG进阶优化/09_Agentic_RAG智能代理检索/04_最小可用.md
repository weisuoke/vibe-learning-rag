# 最小可用

> 掌握以下内容，就能开始使用 Agentic RAG

---

## 核心理念

**20% 的核心知识解决 80% 的问题**

Agentic RAG 看起来复杂，但实际上只需要掌握以下核心内容，就能构建一个基本可用的系统。

---

## 4.1 理解 RTPM 框架

**RTPM** 是 Agentic RAG 的核心架构，必须理解：

### R - Reflection（反思）

**核心思想**：代理能够评估自己的输出质量，发现问题并改进

**最小实现**：
```python
def simple_reflection(query, result):
    # 评估结果质量
    quality_score = evaluate_quality(result)

    if quality_score < 0.8:
        # 质量不够，改进查询
        improved_query = improve_query(query, result)
        result = retrieve(improved_query)

    return result
```

**关键点**：
- 设置质量阈值（如 0.8）
- 不满意就重试（最多 3-5 次）
- 记录每次尝试的结果

### T - Tool Use（工具使用）

**核心思想**：代理能够调用多种工具，而不仅仅是向量检索

**最小实现**：
```python
tools = {
    "vector_search": vector_search_tool,
    "keyword_search": keyword_search_tool,
    "web_api": web_api_tool,
}

def use_tool(query, tool_name):
    tool = tools[tool_name]
    return tool.execute(query)
```

**关键点**：
- 至少准备 2-3 种工具
- 根据查询类型选择工具
- 工具调用失败要有降级方案

### P - Planning（规划）

**核心思想**：将复杂查询分解为多个子任务

**最小实现**：
```python
def simple_planning(complex_query):
    # 使用 LLM 分解任务
    plan = llm.generate(f"将以下查询分解为子任务：{complex_query}")

    # 执行每个子任务
    results = []
    for subtask in plan:
        result = execute_subtask(subtask)
        results.append(result)

    # 合成最终答案
    final_answer = synthesize(results)
    return final_answer
```

**关键点**：
- 使用 LLM 做任务分解
- 子任务独立执行
- 最后合成结果

### M - Multi-Agent（多代理）

**核心思想**：多个专业代理协同工作

**最小实现**：
```python
# 定义专业代理
retrieval_agent = Agent("检索专家")
evaluation_agent = Agent("评估专家")
generation_agent = Agent("生成专家")

def multi_agent_rag(query):
    # 1. 检索代理获取文档
    docs = retrieval_agent.retrieve(query)

    # 2. 评估代理评估质量
    quality = evaluation_agent.evaluate(docs)

    # 3. 如果质量够好，生成代理生成答案
    if quality > 0.8:
        answer = generation_agent.generate(docs, query)
        return answer
    else:
        # 质量不够，重新检索
        return multi_agent_rag(query)
```

**关键点**：
- 2-3 个代理足够（不要过度设计）
- 明确每个代理的职责
- 代理之间通过简单接口通信

---

## 4.2 选择合适的框架

**快速原型开发**：使用 LangChain

```python
from langchain.agents import create_react_agent
from langchain_openai import ChatOpenAI
from langchain.tools import Tool

# 1. 定义工具
tools = [
    Tool(
        name="VectorSearch",
        func=vector_search,
        description="语义检索工具"
    ),
    Tool(
        name="KeywordSearch",
        func=keyword_search,
        description="关键词检索工具"
    ),
]

# 2. 创建 ReAct agent
llm = ChatOpenAI(model="gpt-4")
agent = create_react_agent(llm, tools, prompt)

# 3. 执行查询
result = agent.invoke({"input": "用户查询"})
```

**生产级部署**：使用 LangGraph

```python
from langgraph.graph import StateGraph

# 1. 定义状态
class AgentState(TypedDict):
    query: str
    docs: List[str]
    answer: str

# 2. 定义节点
def retrieval_node(state):
    docs = retrieve(state["query"])
    return {"docs": docs}

def generation_node(state):
    answer = generate(state["docs"], state["query"])
    return {"answer": answer}

# 3. 构建图
workflow = StateGraph(AgentState)
workflow.add_node("retrieve", retrieval_node)
workflow.add_node("generate", generation_node)
workflow.add_edge("retrieve", "generate")
workflow.set_entry_point("retrieve")

# 4. 编译并执行
app = workflow.compile()
result = app.invoke({"query": "用户查询"})
```

---

## 4.3 实现基础 Routing Agent

**目标**：根据查询类型选择合适的检索策略

**最小实现**：

```python
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate

# 1. 定义路由 prompt
router_prompt = PromptTemplate.from_template("""
分析以下查询，选择最合适的检索策略：
- vector_search: 语义相似度检索
- keyword_search: 精确关键词匹配
- hybrid_search: 混合检索

查询：{query}

只返回策略名称，不要解释。
""")

# 2. 创建路由器
llm = ChatOpenAI(model="gpt-4")

def route_query(query):
    prompt = router_prompt.format(query=query)
    strategy = llm.invoke(prompt).content.strip()
    return strategy

# 3. 执行检索
def agentic_retrieve(query):
    strategy = route_query(query)

    if strategy == "vector_search":
        return vector_search(query)
    elif strategy == "keyword_search":
        return keyword_search(query)
    else:
        return hybrid_search(query)
```

**关键点**：
- 使用 LLM 做路由决策
- 准备 2-3 种检索策略
- 路由逻辑简单清晰

---

## 4.4 实现基础 ReAct Agent

**目标**：实现思考-行动-观察-反思循环

**最小实现**：

```python
from langchain.agents import create_react_agent
from langchain_openai import ChatOpenAI
from langchain.tools import Tool

# 1. 定义工具
def vector_search_tool(query: str) -> str:
    """语义检索工具"""
    docs = vector_search(query)
    return "\n".join(docs)

def keyword_search_tool(query: str) -> str:
    """关键词检索工具"""
    docs = keyword_search(query)
    return "\n".join(docs)

tools = [
    Tool(
        name="VectorSearch",
        func=vector_search_tool,
        description="用于语义相似度检索"
    ),
    Tool(
        name="KeywordSearch",
        func=keyword_search_tool,
        description="用于精确关键词匹配"
    ),
]

# 2. 定义 ReAct prompt
react_prompt = """
你是一个智能检索代理。使用以下工具回答用户问题：

{tools}

使用以下格式：

Question: 用户的问题
Thought: 思考应该使用哪个工具
Action: 工具名称
Action Input: 工具输入
Observation: 工具输出
... (重复 Thought/Action/Observation 直到有答案)
Thought: 我现在知道最终答案了
Final Answer: 最终答案

Question: {input}
{agent_scratchpad}
"""

# 3. 创建 agent
llm = ChatOpenAI(model="gpt-4")
agent = create_react_agent(llm, tools, react_prompt)

# 4. 执行查询
from langchain.agents import AgentExecutor

agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=5,  # 最多迭代 5 次
    verbose=True,  # 显示推理过程
)

result = agent_executor.invoke({"input": "用户查询"})
```

**关键点**：
- 设置最大迭代次数（3-5 次）
- 使用 verbose=True 查看推理过程
- 工具描述要清晰准确

---

## 4.5 成本控制

**问题**：Agentic RAG 成本是传统 RAG 的 3.6 倍

**解决方案**：

### 策略1：设置最大迭代次数

```python
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=3,  # 限制为 3 次
    max_execution_time=30,  # 限制为 30 秒
)
```

### 策略2：使用更便宜的模型做路由

```python
# 路由决策用 GPT-3.5
router_llm = ChatOpenAI(model="gpt-3.5-turbo")

# 生成答案用 GPT-4
generator_llm = ChatOpenAI(model="gpt-4")
```

### 策略3：缓存常见查询

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def cached_retrieve(query):
    return retrieve(query)
```

### 策略4：动态选择策略

```python
def adaptive_rag(query):
    complexity = evaluate_complexity(query)

    if complexity == "simple":
        # 简单查询用传统 RAG
        return traditional_rag(query)
    else:
        # 复杂查询用 Agentic RAG
        return agentic_rag(query)
```

---

## 4.6 错误处理

**问题**：代理可能陷入无限循环或工具调用失败

**解决方案**：

### 策略1：超时控制

```python
import time

def agentic_rag_with_timeout(query, timeout=60):
    start_time = time.time()

    for i in range(max_iterations):
        if time.time() - start_time > timeout:
            raise TimeoutError("Agentic RAG 超时")

        # 执行检索
        result = agent.retrieve(query)

        # 评估质量
        if is_good_enough(result):
            return result
```

### 策略2：工具调用失败降级

```python
def safe_tool_call(tool, query):
    try:
        return tool.execute(query)
    except Exception as e:
        logger.error(f"工具调用失败: {e}")
        # 降级到默认工具
        return default_tool.execute(query)
```

### 策略3：记录推理过程

```python
def agentic_rag_with_logging(query):
    logs = []

    for i in range(max_iterations):
        thought = agent.think(query)
        logs.append({"step": i, "thought": thought})

        action = agent.act(thought)
        logs.append({"step": i, "action": action})

        observation = agent.observe(action)
        logs.append({"step": i, "observation": observation})

    # 保存日志
    save_logs(logs)
    return result
```

---

## 这些知识足以

完成以上内容后，你能够：

1. **理解核心概念**：
   - 掌握 RTPM 框架的四个组件
   - 理解每个组件的作用和实现方式

2. **构建基础系统**：
   - 使用 LangChain 构建 Routing Agent
   - 使用 LangChain 构建 ReAct Agent
   - 使用 LangGraph 构建生产级系统

3. **控制成本和风险**：
   - 设置最大迭代次数和超时
   - 使用更便宜的模型做路由
   - 缓存常见查询结果
   - 实现错误处理和降级

4. **为后续学习打基础**：
   - 理解了核心概念，可以深入学习每个组件
   - 掌握了基础实现，可以学习高级优化
   - 建立了成本意识，可以学习生产级部署

---

## 快速上手步骤

### 步骤1：安装依赖（5分钟）

```bash
# 安装 LangChain
uv add langchain langchain-openai

# 安装向量数据库
uv add chromadb

# 安装环境变量管理
uv add python-dotenv
```

### 步骤2：配置 API 密钥（2分钟）

```bash
# 创建 .env 文件
echo "OPENAI_API_KEY=your_key_here" > .env
```

### 步骤3：构建第一个 Routing Agent（10分钟）

```python
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate
from dotenv import load_dotenv

load_dotenv()

# 路由器
router_prompt = PromptTemplate.from_template("""
选择检索策略：vector_search 或 keyword_search

查询：{query}
""")

llm = ChatOpenAI(model="gpt-4")

def route_query(query):
    prompt = router_prompt.format(query=query)
    return llm.invoke(prompt).content.strip()

# 测试
print(route_query("什么是 Python？"))  # vector_search
print(route_query("Python 3.11 发布时间"))  # keyword_search
```

### 步骤4：构建第一个 ReAct Agent（15分钟）

```python
from langchain.agents import create_react_agent, AgentExecutor
from langchain_openai import ChatOpenAI
from langchain.tools import Tool

# 定义工具
tools = [
    Tool(
        name="Search",
        func=lambda q: f"搜索结果：{q}",
        description="搜索工具"
    ),
]

# 创建 agent
llm = ChatOpenAI(model="gpt-4")
agent = create_react_agent(llm, tools, react_prompt)

# 执行
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=3,
    verbose=True,
)

result = agent_executor.invoke({"input": "什么是 RAG？"})
print(result)
```

---

## 常见问题

### Q1：必须使用 GPT-4 吗？

**A**：不是必须的，但推荐：
- **路由决策**：GPT-3.5 足够
- **推理和规划**：GPT-4 更好
- **生成答案**：GPT-4 更准确

### Q2：最少需要几个工具？

**A**：2-3 个工具足够：
- 向量检索（必需）
- 关键词检索（推荐）
- 重排序器（可选）

### Q3：如何判断查询是否需要 Agentic RAG？

**A**：简单规则：
- 查询包含"比较"、"分析"、"总结" → Agentic RAG
- 查询是简单问题（"什么是X？"）→ 传统 RAG

### Q4：如何调试代理的推理过程？

**A**：使用 verbose=True：
```python
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,  # 显示推理过程
)
```

### Q5：代理陷入无限循环怎么办？

**A**：设置最大迭代次数：
```python
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=3,  # 最多 3 次
    max_execution_time=30,  # 最多 30 秒
)
```

---

## 下一步学习

完成最小可用知识后，建议按以下顺序深入学习：

1. **核心概念深化**：
   - 学习 5 个核心概念文件
   - 理解每个概念的原理和实现

2. **实战代码练习**：
   - 运行 5 个实战场景代码
   - 修改代码适配自己的数据

3. **生产级优化**：
   - 学习成本控制策略
   - 实现错误处理和重试
   - 添加日志和监控

4. **框架选择**：
   - 对比 LangChain、LangGraph、LlamaIndex
   - 根据场景选择合适的框架

---

## 参考资源

### 官方文档
1. LangChain: https://docs.langchain.com
2. LangGraph: https://langchain-ai.github.io/langgraph
3. OpenAI API: https://platform.openai.com/docs

### 教程
1. LangChain ReAct Agent: https://docs.langchain.com/oss/python/langchain/agents
2. LangGraph Agentic RAG: https://docs.langchain.com/oss/python/langgraph/agentic-rag

### 示例代码
1. LangChain Examples: https://github.com/langchain-ai/langchain/tree/master/templates
2. LangGraph Examples: https://github.com/langchain-ai/langgraph/tree/main/examples

---

**版本**: v1.0
**创建时间**: 2026-02-17
**适用人群**: 初学者、快速原型开发
**预计学习时间**: 2-3 天
