# Session 管理与分支 - 核心概念 06：树形结构原理

> 深入理解 id/parentId 链接机制、树形结构构建和 Context 重建

---

## 概述

Pi Session 的树形结构是其核心设计：
- 使用 id/parentId 链接节点
- 支持原地分支（in-place branching）
- 实现时间旅行和多路径探索
- 高效的 Context 重建

---

## 1. id/parentId 链接机制

### 1.1 基本原理

```typescript
// 每个 Entry 都有 id 和 parentId
interface SessionEntry {
  id: string;           // 唯一标识
  parentId?: string;    // 父节点 ID
  type: string;
  content: any;
}

// 示例：线性对话
const linearEntries = [
  { id: '1', type: 'message', content: 'A' },
  { id: '2', parentId: '1', type: 'message', content: 'B' },
  { id: '3', parentId: '2', type: 'message', content: 'C' }
];

// 树形结构：
// 1 -> 2 -> 3

// 示例：分支对话
const branchedEntries = [
  { id: '1', type: 'message', content: 'A' },
  { id: '2', parentId: '1', type: 'message', content: 'B' },
  { id: '3', parentId: '1', type: 'message', content: 'C' }
];

// 树形结构：
//     ┌─ 2
// 1 ──┤
//     └─ 3
```

### 1.2 TypeScript 实现

```typescript
class TreeBuilder {
  // 从扁平列表构建树
  buildTree(entries: SessionEntry[]): TreeNode[] {
    // 1. 创建节点映射
    const nodeMap = new Map<string, TreeNode>();

    entries.forEach(entry => {
      nodeMap.set(entry.id, {
        ...entry,
        children: []
      });
    });

    // 2. 建立父子关系
    const roots: TreeNode[] = [];

    entries.forEach(entry => {
      const node = nodeMap.get(entry.id)!;

      if (entry.parentId) {
        const parent = nodeMap.get(entry.parentId);
        if (parent) {
          parent.children.push(node);
        } else {
          // 父节点不存在，作为根节点
          roots.push(node);
        }
      } else {
        // 没有父节点，是根节点
        roots.push(node);
      }
    });

    return roots;
  }
}
```

---

## 2. 原地分支（In-Place Branching）

### 2.1 什么是原地分支？

**传统分支（Git 模型）：**
```
main.jsonl:
  { id: '1', content: 'A' }
  { id: '2', content: 'B' }

branch-a.jsonl:  // 新文件
  { id: '1', content: 'A' }
  { id: '2', content: 'B' }
  { id: '3', content: 'C' }

branch-b.jsonl:  // 新文件
  { id: '1', content: 'A' }
  { id: '2', content: 'B' }
  { id: '4', content: 'D' }
```

**原地分支（Pi 模型）：**
```
session.jsonl:  // 单文件
  { id: '1', content: 'A' }
  { id: '2', parentId: '1', content: 'B' }
  { id: '3', parentId: '2', content: 'C' }  // 分支 A
  { id: '4', parentId: '2', content: 'D' }  // 分支 B
```

### 2.2 优势

```typescript
// 优势对比
const advantages = {
  storage: {
    git: '多个文件，有重复',
    pi: '单个文件，无重复'
  },

  creation: {
    git: '需要复制文件',
    pi: '只追加新条目'
  },

  navigation: {
    git: '需要切换文件',
    pi: '在同一文件中导航'
  },

  history: {
    git: '分散在多个文件',
    pi: '集中在一个文件'
  }
};
```

---

## 3. Entry 类型系统

### 3.1 核心 Entry 类型

```typescript
type EntryType =
  | 'message'              // 用户或 Agent 消息
  | 'tool_call'            // 工具调用
  | 'tool_result'          // 工具结果
  | 'compaction'           // 压缩条目
  | 'branch_summary'       // 分支摘要
  | 'metadata'             // 元数据
  | 'fork_metadata'        // Fork 元数据
  | 'label';               // 标签

// 每种类型的结构
interface MessageEntry extends SessionEntry {
  type: 'message';
  role: 'user' | 'assistant';
  content: string;
}

interface ToolCallEntry extends SessionEntry {
  type: 'tool_call';
  tool: string;
  args: Record<string, any>;
}

interface ToolResultEntry extends SessionEntry {
  type: 'tool_result';
  tool: string;
  result: any;
  success: boolean;
}

interface CompactionEntry extends SessionEntry {
  type: 'compaction';
  summary: string;
  compressedCount: number;
  strategy: 'summarize' | 'truncate';
}
```

### 3.2 Entry 类型的树形关系

```typescript
// 示例：完整的对话树
const complexTree = [
  // 根节点
  { id: '1', type: 'message', role: 'user', content: '实现功能 A' },

  // 第一层
  { id: '2', parentId: '1', type: 'message', role: 'assistant', content: '好的' },

  // 工具调用链
  { id: '3', parentId: '2', type: 'tool_call', tool: 'write', args: {...} },
  { id: '4', parentId: '3', type: 'tool_result', tool: 'write', result: 'success' },

  // 分支 A
  { id: '5', parentId: '1', type: 'message', role: 'user', content: '改用方案 B' },
  { id: '6', parentId: '5', type: 'message', role: 'assistant', content: '好的' },

  // 元数据
  { id: '7', parentId: '1', type: 'label', label: 'checkpoint-1' }
];

// 树形结构：
//                    ┌─ 2 ─ 3 ─ 4
// 1 (实现功能 A) ────┼─ 5 ─ 6
//                    └─ 7 (label)
```

---

## 4. Context 构建过程

### 4.1 从节点到 Context

```typescript
class ContextBuilder {
  // 构建到指定节点的 Context
  buildContext(entries: SessionEntry[], targetNodeId: string): Message[] {
    // 1. 获取到目标节点的路径
    const path = this.getPathToNode(entries, targetNodeId);

    // 2. 过滤出消息类型
    const messages = path.filter(e => e.type === 'message');

    // 3. 转换为 LLM 格式
    return messages.map(e => ({
      role: e.role,
      content: e.content
    }));
  }

  // 获取到节点的完整路径
  private getPathToNode(
    entries: SessionEntry[],
    targetNodeId: string
  ): SessionEntry[] {
    const nodeMap = new Map(entries.map(e => [e.id, e]));
    const path: SessionEntry[] = [];

    // 从目标节点向上追溯
    let currentId: string | undefined = targetNodeId;
    while (currentId) {
      const node = nodeMap.get(currentId);
      if (!node) break;

      path.unshift(node);  // 添加到路径开头
      currentId = node.parentId;
    }

    return path;
  }
}
```

### 4.2 Context 优化

```typescript
class OptimizedContextBuilder extends ContextBuilder {
  // 构建优化的 Context（包含 Compaction）
  buildOptimizedContext(
    entries: SessionEntry[],
    targetNodeId: string
  ): Message[] {
    const path = this.getPathToNode(entries, targetNodeId);

    // 查找最近的 Compaction
    const lastCompaction = this.findLastCompaction(path);

    if (lastCompaction) {
      // 使用 Compaction 摘要 + 最近消息
      const recentMessages = path
        .slice(path.indexOf(lastCompaction) + 1)
        .filter(e => e.type === 'message');

      return [
        { role: 'system', content: lastCompaction.summary },
        ...recentMessages.map(e => ({
          role: e.role,
          content: e.content
        }))
      ];
    } else {
      // 没有 Compaction，返回完整路径
      return path
        .filter(e => e.type === 'message')
        .map(e => ({
          role: e.role,
          content: e.content
        }));
    }
  }

  private findLastCompaction(path: SessionEntry[]): CompactionEntry | null {
    for (let i = path.length - 1; i >= 0; i--) {
      if (path[i].type === 'compaction') {
        return path[i] as CompactionEntry;
      }
    }
    return null;
  }
}
```

---

## 5. 树形遍历算法

### 5.1 深度优先遍历（DFS）

```typescript
class TreeTraversal {
  // 深度优先遍历
  dfs(node: TreeNode, callback: (node: TreeNode) => void) {
    callback(node);

    for (const child of node.children) {
      this.dfs(child, callback);
    }
  }

  // 使用示例：打印所有节点
  printTree(root: TreeNode) {
    this.dfs(root, (node) => {
      console.log(`${node.id}: ${node.content}`);
    });
  }

  // 查找节点
  findNode(root: TreeNode, targetId: string): TreeNode | null {
    if (root.id === targetId) return root;

    for (const child of root.children) {
      const found = this.findNode(child, targetId);
      if (found) return found;
    }

    return null;
  }
}
```

### 5.2 广度优先遍历（BFS）

```typescript
class TreeTraversal {
  // 广度优先遍历
  bfs(root: TreeNode, callback: (node: TreeNode) => void) {
    const queue: TreeNode[] = [root];

    while (queue.length > 0) {
      const node = queue.shift()!;
      callback(node);

      queue.push(...node.children);
    }
  }

  // 按层级遍历
  levelOrder(root: TreeNode): TreeNode[][] {
    const levels: TreeNode[][] = [];
    const queue: Array<{ node: TreeNode; level: number }> = [
      { node: root, level: 0 }
    ];

    while (queue.length > 0) {
      const { node, level } = queue.shift()!;

      if (!levels[level]) {
        levels[level] = [];
      }
      levels[level].push(node);

      for (const child of node.children) {
        queue.push({ node: child, level: level + 1 });
      }
    }

    return levels;
  }
}
```

---

## 6. 分支分析

### 6.1 识别分支点

```typescript
class BranchAnalyzer {
  // 找出所有分支点
  findBranchPoints(entries: SessionEntry[]): string[] {
    const childrenCount = new Map<string, number>();

    // 统计每个节点的子节点数
    for (const entry of entries) {
      if (entry.parentId) {
        const count = childrenCount.get(entry.parentId) || 0;
        childrenCount.set(entry.parentId, count + 1);
      }
    }

    // 找出有多个子节点的节点（分支点）
    const branchPoints: string[] = [];
    for (const [nodeId, count] of childrenCount) {
      if (count > 1) {
        branchPoints.push(nodeId);
      }
    }

    return branchPoints;
  }

  // 获取节点的所有分支
  getBranches(entries: SessionEntry[], nodeId: string): SessionEntry[][] {
    const branches: SessionEntry[][] = [];

    // 找出所有直接子节点
    const children = entries.filter(e => e.parentId === nodeId);

    // 对每个子节点，获取其完整分支
    for (const child of children) {
      const branch = this.getBranchFromNode(entries, child.id);
      branches.push(branch);
    }

    return branches;
  }

  private getBranchFromNode(
    entries: SessionEntry[],
    startNodeId: string
  ): SessionEntry[] {
    const branch: SessionEntry[] = [];
    const nodeMap = new Map(entries.map(e => [e.id, e]));

    // 从起始节点开始，收集所有后代
    const collectDescendants = (nodeId: string) => {
      const node = nodeMap.get(nodeId);
      if (!node) return;

      branch.push(node);

      // 递归收集子节点
      const children = entries.filter(e => e.parentId === nodeId);
      for (const child of children) {
        collectDescendants(child.id);
      }
    };

    collectDescendants(startNodeId);
    return branch;
  }
}
```

### 6.2 分支统计

```typescript
class BranchStatistics {
  // 统计分支信息
  analyzeBranches(entries: SessionEntry[]): BranchStats {
    const analyzer = new BranchAnalyzer();
    const branchPoints = analyzer.findBranchPoints(entries);

    const stats: BranchStats = {
      totalNodes: entries.length,
      branchPoints: branchPoints.length,
      branches: [],
      maxDepth: 0,
      avgBranchLength: 0
    };

    // 分析每个分支点
    for (const branchPoint of branchPoints) {
      const branches = analyzer.getBranches(entries, branchPoint);

      for (const branch of branches) {
        stats.branches.push({
          startNode: branchPoint,
          length: branch.length,
          depth: this.calculateDepth(entries, branch[0].id)
        });
      }
    }

    // 计算统计信息
    stats.maxDepth = Math.max(...stats.branches.map(b => b.depth));
    stats.avgBranchLength = stats.branches.reduce((sum, b) => sum + b.length, 0) / stats.branches.length;

    return stats;
  }

  private calculateDepth(entries: SessionEntry[], nodeId: string): number {
    const nodeMap = new Map(entries.map(e => [e.id, e]));
    let depth = 0;
    let currentId: string | undefined = nodeId;

    while (currentId) {
      const node = nodeMap.get(currentId);
      if (!node) break;

      depth++;
      currentId = node.parentId;
    }

    return depth;
  }
}

interface BranchStats {
  totalNodes: number;
  branchPoints: number;
  branches: Array<{
    startNode: string;
    length: number;
    depth: number;
  }>;
  maxDepth: number;
  avgBranchLength: number;
}
```

---

## 7. 实战示例

### 示例 1：完整的树形结构管理器

```typescript
class TreeManager {
  private entries: SessionEntry[] = [];

  // 添加节点
  addNode(entry: SessionEntry): void {
    this.entries.push(entry);
  }

  // 构建树
  buildTree(): TreeNode[] {
    const builder = new TreeBuilder();
    return builder.buildTree(this.entries);
  }

  // 获取到节点的路径
  getPath(targetNodeId: string): SessionEntry[] {
    const builder = new ContextBuilder();
    return builder['getPathToNode'](this.entries, targetNodeId);
  }

  // 获取分支点
  getBranchPoints(): string[] {
    const analyzer = new BranchAnalyzer();
    return analyzer.findBranchPoints(this.entries);
  }

  // 获取统计信息
  getStatistics(): BranchStats {
    const stats = new BranchStatistics();
    return stats.analyzeBranches(this.entries);
  }

  // 可视化树形结构
  visualize(): string {
    const tree = this.buildTree();
    return this.renderTree(tree);
  }

  private renderTree(nodes: TreeNode[], indent = '', isLast = true): string {
    let output = '';

    nodes.forEach((node, index) => {
      const isLastChild = index === nodes.length - 1;
      const connector = isLastChild ? '└─' : '├─';
      const childIndent = indent + (isLastChild ? '   ' : '│  ');

      output += `${indent}${connector} ${node.id}: ${node.content}\n`;

      if (node.children.length > 0) {
        output += this.renderTree(node.children, childIndent, isLastChild);
      }
    });

    return output;
  }
}

// 使用示例
async function demonstrateTreeManager() {
  const manager = new TreeManager();

  // 添加节点
  manager.addNode({ id: '1', type: 'message', content: '实现功能 A' });
  manager.addNode({ id: '2', parentId: '1', type: 'message', content: '方案 A' });
  manager.addNode({ id: '3', parentId: '1', type: 'message', content: '方案 B' });
  manager.addNode({ id: '4', parentId: '2', type: 'message', content: '完成 A' });
  manager.addNode({ id: '5', parentId: '3', type: 'message', content: '完成 B' });

  // 可视化
  console.log('树形结构:');
  console.log(manager.visualize());

  // 获取路径
  console.log('\n到节点 4 的路径:');
  const path = manager.getPath('4');
  path.forEach(e => console.log(`  ${e.id}: ${e.content}`));

  // 获取分支点
  console.log('\n分支点:');
  const branchPoints = manager.getBranchPoints();
  console.log(`  ${branchPoints.join(', ')}`);

  // 获取统计信息
  console.log('\n统计信息:');
  const stats = manager.getStatistics();
  console.log(`  总节点数: ${stats.totalNodes}`);
  console.log(`  分支点数: ${stats.branchPoints}`);
  console.log(`  最大深度: ${stats.maxDepth}`);
  console.log(`  平均分支长度: ${stats.avgBranchLength.toFixed(2)}`);
}
```

### 示例 2：树形差异比较

```typescript
class TreeDiff {
  // 比较两个分支的差异
  compareBranches(
    entries: SessionEntry[],
    branchId1: string,
    branchId2: string
  ): BranchDiff {
    const analyzer = new BranchAnalyzer();

    // 获取两个分支
    const branch1 = analyzer['getBranchFromNode'](entries, branchId1);
    const branch2 = analyzer['getBranchFromNode'](entries, branchId2);

    // 找出共同祖先
    const commonAncestor = this.findCommonAncestor(entries, branchId1, branchId2);

    // 计算差异
    return {
      commonAncestor,
      branch1Only: branch1.filter(e => !branch2.find(b => b.id === e.id)),
      branch2Only: branch2.filter(e => !branch1.find(b => b.id === e.id)),
      branch1Length: branch1.length,
      branch2Length: branch2.length
    };
  }

  private findCommonAncestor(
    entries: SessionEntry[],
    nodeId1: string,
    nodeId2: string
  ): string | null {
    const builder = new ContextBuilder();

    // 获取两个节点的路径
    const path1 = builder['getPathToNode'](entries, nodeId1);
    const path2 = builder['getPathToNode'](entries, nodeId2);

    // 找出最后一个共同节点
    for (let i = Math.min(path1.length, path2.length) - 1; i >= 0; i--) {
      if (path1[i].id === path2[i].id) {
        return path1[i].id;
      }
    }

    return null;
  }
}

interface BranchDiff {
  commonAncestor: string | null;
  branch1Only: SessionEntry[];
  branch2Only: SessionEntry[];
  branch1Length: number;
  branch2Length: number;
}
```

---

## 8. 性能优化

### 8.1 缓存优化

```typescript
class CachedTreeBuilder extends TreeBuilder {
  private treeCache = new Map<string, TreeNode[]>();
  private pathCache = new Map<string, SessionEntry[]>();

  buildTree(entries: SessionEntry[]): TreeNode[] {
    const cacheKey = this.getCacheKey(entries);

    if (this.treeCache.has(cacheKey)) {
      return this.treeCache.get(cacheKey)!;
    }

    const tree = super.buildTree(entries);
    this.treeCache.set(cacheKey, tree);

    return tree;
  }

  private getCacheKey(entries: SessionEntry[]): string {
    // 使用最后一个条目的 ID 作为缓存键
    return entries[entries.length - 1]?.id || 'empty';
  }

  clearCache(): void {
    this.treeCache.clear();
    this.pathCache.clear();
  }
}
```

### 8.2 增量更新

```typescript
class IncrementalTreeBuilder {
  private currentTree: TreeNode[] = [];
  private nodeMap = new Map<string, TreeNode>();

  // 增量添加节点
  addNode(entry: SessionEntry): void {
    const newNode: TreeNode = {
      ...entry,
      children: []
    };

    this.nodeMap.set(entry.id, newNode);

    if (entry.parentId) {
      const parent = this.nodeMap.get(entry.parentId);
      if (parent) {
        parent.children.push(newNode);
      } else {
        // 父节点不存在，作为根节点
        this.currentTree.push(newNode);
      }
    } else {
      // 没有父节点，是根节点
      this.currentTree.push(newNode);
    }
  }

  getTree(): TreeNode[] {
    return this.currentTree;
  }
}
```

---

## 学习检查清单

完成本节学习后，你应该能够：

- [ ] 理解 id/parentId 链接机制
- [ ] 理解原地分支的优势
- [ ] 理解不同 Entry 类型的作用
- [ ] 实现 Context 构建算法
- [ ] 实现树形遍历算法（DFS/BFS）
- [ ] 分析分支结构和统计信息
- [ ] 实现树形差异比较
- [ ] 应用性能优化技术

---

**版本：** v1.0
**最后更新：** 2026-02-18
**维护者：** Claude Code
