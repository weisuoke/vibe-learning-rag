# 实战代码2：多对多场景 - 对话标签系统

> 完整的对话标签系统实现，演示多对多关系

---

## 场景描述

实现一个 AI Agent 的对话标签系统，包含：
- 对话管理
- 标签管理
- 多对多关系（对话 ↔ 标签）
- 标签统计和查询
- FastAPI 集成

---

## 完整代码

```python
"""
AI Agent 对话标签系统
演示多对多关系的完整实现
"""

from datetime import datetime
from typing import List, Optional
from sqlalchemy import Column, Integer, String, DateTime, Table, ForeignKey, create_engine, func
from sqlalchemy.orm import relationship, DeclarativeBase, Session

# ===== 1. 基础配置 =====

class Base(DeclarativeBase):
    pass

# ===== 2. 中间表定义 =====

conversation_tags = Table(
    'conversation_tags',
    Base.metadata,
    Column('conversation_id', ForeignKey('conversations.id'), primary_key=True),
    Column('tag_id', ForeignKey('tags.id'), primary_key=True),
    Column('created_at', DateTime, default=datetime.utcnow)
)

# ===== 3. 数据模型 =====

class Conversation(Base):
    """对话模型"""
    __tablename__ = 'conversations'

    id = Column(Integer, primary_key=True)
    title = Column(String(200), nullable=False)
    content = Column(String(1000))
    created_at = Column(DateTime, default=datetime.utcnow)

    # 多对多：对话的标签
    tags = relationship(
        "Tag",
        secondary=conversation_tags,
        back_populates="conversations",
        lazy='selectin'
    )

    def __repr__(self):
        return f"<Conversation(id={self.id}, title='{self.title}')>"


class Tag(Base):
    """标签模型"""
    __tablename__ = 'tags'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), unique=True, nullable=False, index=True)
    color = Column(String(7), default="#3B82F6")  # 标签颜色
    description = Column(String(200))
    created_at = Column(DateTime, default=datetime.utcnow)

    # 多对多：标签的对话
    conversations = relationship(
        "Conversation",
        secondary=conversation_tags,
        back_populates="tags",
        lazy='selectin'
    )

    def __repr__(self):
        return f"<Tag(id={self.id}, name='{self.name}')>"


# ===== 4. 数据库初始化 =====

def init_db(db_url: str = "sqlite:///./tags.db"):
    engine = create_engine(db_url, echo=True)
    Base.metadata.create_all(engine)
    return engine


# ===== 5. CRUD 操作 =====

class ConversationService:
    def __init__(self, session: Session):
        self.session = session

    def create_conversation(self, title: str, content: str = "") -> Conversation:
        conv = Conversation(title=title, content=content)
        self.session.add(conv)
        self.session.commit()
        self.session.refresh(conv)
        return conv

    def get_conversation(self, conversation_id: int) -> Optional[Conversation]:
        return self.session.get(Conversation, conversation_id)

    def add_tag_to_conversation(self, conversation_id: int, tag_id: int) -> bool:
        conv = self.get_conversation(conversation_id)
        tag = self.session.get(Tag, tag_id)
        if conv and tag and tag not in conv.tags:
            conv.tags.append(tag)
            self.session.commit()
            return True
        return False

    def remove_tag_from_conversation(self, conversation_id: int, tag_id: int) -> bool:
        conv = self.get_conversation(conversation_id)
        tag = self.session.get(Tag, tag_id)
        if conv and tag and tag in conv.tags:
            conv.tags.remove(tag)
            self.session.commit()
            return True
        return False

    def get_conversations_by_tag(self, tag_name: str) -> List[Conversation]:
        tag = self.session.query(Tag).filter(Tag.name == tag_name).first()
        return tag.conversations if tag else []


class TagService:
    def __init__(self, session: Session):
        self.session = session

    def create_tag(self, name: str, color: str = "#3B82F6", description: str = "") -> Tag:
        tag = Tag(name=name, color=color, description=description)
        self.session.add(tag)
        self.session.commit()
        self.session.refresh(tag)
        return tag

    def get_tag(self, tag_id: int) -> Optional[Tag]:
        return self.session.get(Tag, tag_id)

    def get_tag_by_name(self, name: str) -> Optional[Tag]:
        return self.session.query(Tag).filter(Tag.name == name).first()

    def list_tags(self) -> List[Tag]:
        return self.session.query(Tag).all()

    def get_tag_stats(self):
        """获取标签统计信息"""
        return self.session.query(
            Tag.name,
            func.count(conversation_tags.c.conversation_id).label('count')
        ).outerjoin(
            conversation_tags, Tag.id == conversation_tags.c.tag_id
        ).group_by(Tag.id).all()


# ===== 6. 使用示例 =====

def main():
    engine = init_db()
    session = Session(engine)

    conv_service = ConversationService(session)
    tag_service = TagService(session)

    print("=== 1. 创建标签 ===")
    tag1 = tag_service.create_tag("编程", "#FF5733", "编程相关")
    tag2 = tag_service.create_tag("教育", "#33FF57", "教育相关")
    tag3 = tag_service.create_tag("AI", "#3357FF", "AI相关")
    print(f"创建标签: {tag1.name}, {tag2.name}, {tag3.name}")

    print("\n=== 2. 创建对话 ===")
    conv1 = conv_service.create_conversation("Python学习", "学习Python基础")
    conv2 = conv_service.create_conversation("AI Agent开发", "开发AI Agent")
    conv3 = conv_service.create_conversation("FastAPI教程", "FastAPI入门")
    print(f"创建对话: {conv1.title}, {conv2.title}, {conv3.title}")

    print("\n=== 3. 建立多对多关系 ===")
    conv_service.add_tag_to_conversation(conv1.id, tag1.id)
    conv_service.add_tag_to_conversation(conv1.id, tag2.id)
    conv_service.add_tag_to_conversation(conv2.id, tag1.id)
    conv_service.add_tag_to_conversation(conv2.id, tag3.id)
    conv_service.add_tag_to_conversation(conv3.id, tag1.id)
    print("建立关联完成")

    print("\n=== 4. 查询对话的标签 ===")
    for conv in [conv1, conv2, conv3]:
        print(f"{conv.title}: {[tag.name for tag in conv.tags]}")

    print("\n=== 5. 查询标签的对话 ===")
    for tag in [tag1, tag2, tag3]:
        print(f"{tag.name}: {[conv.title for conv in tag.conversations]}")

    print("\n=== 6. 查询带特定标签的对话 ===")
    programming_convs = conv_service.get_conversations_by_tag("编程")
    print(f"带'编程'标签的对话: {[c.title for c in programming_convs]}")

    print("\n=== 7. 标签统计 ===")
    stats = tag_service.get_tag_stats()
    for name, count in stats:
        print(f"{name}: {count} 个对话")

    print("\n=== 8. 移除标签 ===")
    conv_service.remove_tag_from_conversation(conv1.id, tag2.id)
    print(f"{conv1.title} 的标签: {[tag.name for tag in conv1.tags]}")

    session.close()


if __name__ == "__main__":
    main()
```

---

## 运行输出

```
=== 1. 创建标签 ===
创建标签: 编程, 教育, AI

=== 2. 创建对话 ===
创建对话: Python学习, AI Agent开发, FastAPI教程

=== 3. 建立多对多关系 ===
建立关联完成

=== 4. 查询对话的标签 ===
Python学习: ['编程', '教育']
AI Agent开发: ['编程', 'AI']
FastAPI教程: ['编程']

=== 5. 查询标签的对话 ===
编程: ['Python学习', 'AI Agent开发', 'FastAPI教程']
教育: ['Python学习']
AI: ['AI Agent开发']

=== 6. 查询带特定标签的对话 ===
带'编程'标签的对话: ['Python学习', 'AI Agent开发', 'FastAPI教程']

=== 7. 标签统计 ===
编程: 3 个对话
教育: 1 个对话
AI: 1 个对话

=== 8. 移除标签 ===
Python学习 的标签: ['编程']
```

---

## FastAPI 集成

```python
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel

app = FastAPI()

class TagCreate(BaseModel):
    name: str
    color: str = "#3B82F6"
    description: str = ""

class ConversationCreate(BaseModel):
    title: str
    content: str = ""

def get_db():
    engine = init_db()
    session = Session(engine)
    try:
        yield session
    finally:
        session.close()

@app.post("/tags")
def create_tag(tag: TagCreate, db: Session = Depends(get_db)):
    service = TagService(db)
    return service.create_tag(tag.name, tag.color, tag.description)

@app.get("/tags")
def list_tags(db: Session = Depends(get_db)):
    service = TagService(db)
    return service.list_tags()

@app.get("/tags/{tag_name}/conversations")
def get_tag_conversations(tag_name: str, db: Session = Depends(get_db)):
    service = ConversationService(db)
    return service.get_conversations_by_tag(tag_name)

@app.post("/conversations/{conversation_id}/tags/{tag_id}")
def add_tag(conversation_id: int, tag_id: int, db: Session = Depends(get_db)):
    service = ConversationService(db)
    if service.add_tag_to_conversation(conversation_id, tag_id):
        return {"message": "Tag added successfully"}
    raise HTTPException(status_code=400, detail="Failed to add tag")

@app.delete("/conversations/{conversation_id}/tags/{tag_id}")
def remove_tag(conversation_id: int, tag_id: int, db: Session = Depends(get_db)):
    service = ConversationService(db)
    if service.remove_tag_from_conversation(conversation_id, tag_id):
        return {"message": "Tag removed successfully"}
    raise HTTPException(status_code=400, detail="Failed to remove tag")
```

---

## 关键技术点

### 1. 中间表定义

```python
conversation_tags = Table(
    'conversation_tags',
    Base.metadata,
    Column('conversation_id', ForeignKey('conversations.id'), primary_key=True),
    Column('tag_id', ForeignKey('tags.id'), primary_key=True),
    Column('created_at', DateTime, default=datetime.utcnow)  # 额外字段
)
```

### 2. 多对多关系

```python
class Conversation(Base):
    tags = relationship(
        "Tag",
        secondary=conversation_tags,  # 指定中间表
        back_populates="conversations",
        lazy='selectin'
    )

class Tag(Base):
    conversations = relationship(
        "Conversation",
        secondary=conversation_tags,
        back_populates="tags",
        lazy='selectin'
    )
```

### 3. 添加和移除关系

```python
# 添加标签
conv.tags.append(tag)
session.commit()

# 移除标签
conv.tags.remove(tag)
session.commit()
```

### 4. 查询优化

```python
# 查询带特定标签的对话
tag = session.query(Tag).filter(Tag.name == "编程").first()
conversations = tag.conversations  # 自动 JOIN 查询

# 标签统计
session.query(
    Tag.name,
    func.count(conversation_tags.c.conversation_id)
).outerjoin(conversation_tags).group_by(Tag.id).all()
```

---

## 总结

这个示例展示了：
1. ✅ 完整的多对多关系定义
2. ✅ 中间表的使用
3. ✅ 添加和移除关系
4. ✅ 双向查询（对话→标签，标签→对话）
5. ✅ 标签统计
6. ✅ FastAPI 集成

**适用场景：**
- 对话标签系统
- 文章分类系统
- 用户角色系统
- 任何需要多对多关系的场景
