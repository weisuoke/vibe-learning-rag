# 反直觉点

> 健康检查端点的常见误区和反直觉认知

---

## 误区1：健康检查应该检查所有可能的问题 ❌

### 为什么错？

**错误观点：** "健康检查应该尽可能详细，检查所有依赖服务、所有配置、所有功能"

**正确理解：**
- 健康检查会被**频繁调用**（每 5-10 秒一次）
- 过于详细的检查会**严重影响性能**
- 健康检查应该**快速返回**（< 100ms）
- 详细的检查应该由**监控系统**（Prometheus）负责

**代码对比：**

```python
# ❌ 错误：检查太详细，影响性能
@app.get("/health")
async def health():
    # 检查数据库所有表
    for table in all_tables:
        await db.execute(f"SELECT COUNT(*) FROM {table}")

    # 检查所有外部 API
    for api in external_apis:
        await check_api(api)

    # 运行端到端测试
    await run_e2e_tests()

    return {"status": "healthy"}

# ✅ 正确：只检查关键依赖，快速返回
@app.get("/health")
async def health():
    """只检查进程是否存活"""
    return {"status": "healthy"}

@app.get("/ready")
async def ready():
    """只检查关键依赖，使用缓存"""
    # 缓存 30 秒，避免频繁检查
    if time.time() - cache["last_check"] < 30:
        return cache["result"]

    # 只检查关键依赖
    checks = {
        "database": await check_database(),  # 简单的 SELECT 1
        "redis": await check_redis(),        # 简单的 PING
    }

    cache.update({"last_check": time.time(), "result": checks})
    return checks
```

### 为什么人们容易这样错？

**心理原因：** "更详细 = 更准确"的直觉

在日常生活中，体检越详细越好（全面体检比简单体检更准确）。但在健康检查中：
- **体检**：一年一次，可以花几小时
- **健康检查**：每 5 秒一次，必须在 100ms 内完成

**类比：**
- **体检** = 详细的监控系统（Prometheus + Grafana）
- **健康检查** = 快速的心跳检测（只看是否存活）

### 正确做法

**分层检查：**

```python
# 层次1：Liveness（最快，几毫秒）
@app.get("/health")
async def health():
    return {"status": "healthy"}

# 层次2：Readiness（快速，< 100ms，带缓存）
@app.get("/ready")
async def ready():
    # 只检查关键依赖，使用缓存
    return await get_cached_health_status()

# 层次3：Deep Health（详细，几秒，手动触发）
@app.get("/health/deep")
async def deep_health():
    # 详细检查，只在调试时使用
    return await run_comprehensive_checks()
```

---

## 误区2：健康检查失败应该立即重启服务 ❌

### 为什么错？

**错误观点：** "健康检查失败 = 服务有问题 = 应该立即重启"

**正确理解：**
- 健康检查失败可能是**短暂抖动**（网络波动、依赖服务短暂不可用）
- 立即重启会导致**频繁重启**，反而影响可用性
- 应该**连续失败多次**才触发重启（failureThreshold）
- **Liveness 失败**才重启，**Readiness 失败**只停止流量

**配置对比：**

```yaml
# ❌ 错误：失败一次就重启
livenessProbe:
  httpGet:
    path: /health
    port: 8000
  periodSeconds: 5
  failureThreshold: 1  # 失败 1 次就重启 ❌

# ✅ 正确：连续失败 3 次才重启
livenessProbe:
  httpGet:
    path: /health
    port: 8000
  periodSeconds: 10
  failureThreshold: 3  # 连续失败 3 次才重启 ✅
  timeoutSeconds: 5
```

### 为什么人们容易这样错？

**心理原因：** "快速响应 = 更可靠"的直觉

在日常生活中，发现问题应该立即处理（发现火灾立即灭火）。但在分布式系统中：
- **短暂抖动**很常见（网络波动、依赖服务重启）
- **频繁重启**会导致服务不稳定
- **连续失败**才说明真的有问题

**类比：**
- **立即重启** = 咳嗽一声就去医院（过度反应）
- **连续失败才重启** = 连续咳嗽一周才去医院（合理判断）

### 正确做法

**区分 Liveness 和 Readiness：**

```yaml
# Liveness：连续失败 3 次才重启（避免误重启）
livenessProbe:
  httpGet:
    path: /health
    port: 8000
  initialDelaySeconds: 30  # 给启动时间
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3      # 连续失败 3 次（30 秒）才重启

# Readiness：连续失败 2 次停止流量（更敏感）
readinessProbe:
  httpGet:
    path: /ready
    port: 8000
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 2      # 连续失败 2 次（10 秒）停止流量
```

**关键区别：**
- **Liveness 失败** → 重启 Pod（破坏性操作，要谨慎）
- **Readiness 失败** → 停止流量（非破坏性，可以更敏感）

---

## 误区3：/health 和 /ready 应该返回相同的结果 ❌

### 为什么错？

**错误观点：** "健康检查就是健康检查，/health 和 /ready 应该一样"

**正确理解：**
- **/health（Liveness）**：检查**进程是否存活**
- **/ready（Readiness）**：检查**服务是否准备好接收流量**
- 两者的**检查内容**和**失败处理**完全不同

**代码对比：**

```python
# ❌ 错误：/health 和 /ready 返回相同结果
@app.get("/health")
async def health():
    # 检查所有依赖服务
    if not await check_database():
        raise HTTPException(503)
    if not await check_redis():
        raise HTTPException(503)
    return {"status": "healthy"}

@app.get("/ready")
async def ready():
    # 和 /health 一样
    if not await check_database():
        raise HTTPException(503)
    if not await check_redis():
        raise HTTPException(503)
    return {"status": "ready"}

# ✅ 正确：/health 和 /ready 检查不同内容
@app.get("/health")
async def health():
    """
    Liveness：只检查进程是否存活
    失败 → Kubernetes 重启 Pod
    """
    return {"status": "healthy"}

@app.get("/ready")
async def ready():
    """
    Readiness：检查是否准备好接收流量
    失败 → 负载均衡器停止发流量（但不重启）
    """
    # 检查依赖服务
    if not await check_database():
        raise HTTPException(503, "Database not ready")
    if not await check_redis():
        raise HTTPException(503, "Redis not ready")

    return {"status": "ready"}
```

### 为什么人们容易这样错？

**心理原因：** "健康 = 准备好"的直觉

在日常生活中，"健康"和"准备好"似乎是一回事（健康的人就准备好工作了）。但在分布式系统中：
- **健康（Liveness）** = 进程还活着（心跳正常）
- **准备好（Readiness）** = 可以处理请求（厨房准备好了）

**类比：**
- **Liveness** = 医生检查心跳（人还活着吗？）
- **Readiness** = 餐厅检查厨房（可以接待客人吗？）

一个人可以心跳正常（Liveness OK）但还没准备好工作（Readiness Not OK，比如刚起床）。

### 正确做法

**明确区分两者的职责：**

| 维度 | /health (Liveness) | /ready (Readiness) |
|------|-------------------|-------------------|
| **检查内容** | 进程是否存活 | 依赖服务是否可用 |
| **检查速度** | 极快（< 10ms） | 快速（< 100ms） |
| **失败处理** | 重启 Pod | 停止流量 |
| **失败阈值** | 连续失败 3 次 | 连续失败 2 次 |
| **使用场景** | 检测死锁、内存泄漏 | 检测依赖服务故障 |

**实际场景：**

```python
# 场景1：数据库连接断了
# - /health → 200 OK（进程还活着）
# - /ready → 503（数据库不可用，停止流量）
# - 结果：Pod 不重启，但不接收新流量

# 场景2：进程死锁了
# - /health → 超时（进程无响应）
# - /ready → 超时
# - 结果：Kubernetes 重启 Pod

# 场景3：服务刚启动，数据库连接还没建立
# - /health → 200 OK（进程已启动）
# - /ready → 503（数据库连接还没建立）
# - 结果：Pod 运行，但不接收流量，等待准备好
```

---

## 误区4：健康检查不需要缓存，实时检查更准确 ❌

### 为什么错？

**错误观点：** "每次健康检查都应该实时检查依赖服务，这样最准确"

**正确理解：**
- 健康检查会被**频繁调用**（每 5-10 秒）
- 每次都检查依赖服务会**严重影响性能**
- **短暂抖动**会导致误报（依赖服务短暂不可用）
- **缓存**可以平滑短暂抖动，提高稳定性

**代码对比：**

```python
# ❌ 错误：每次都实时检查
@app.get("/ready")
async def ready():
    # 每次都查询数据库（每 5 秒一次）
    await db.execute("SELECT 1")

    # 每次都 ping Redis（每 5 秒一次）
    await redis.ping()

    # 每次都调用外部 API（每 5 秒一次）
    await check_external_api()

    return {"status": "ready"}

# ✅ 正确：使用缓存，定期更新
health_cache = {"last_check": 0, "checks": {}}
CACHE_TTL = 30  # 缓存 30 秒

@app.get("/ready")
async def ready():
    now = time.time()

    # 如果缓存未过期，直接返回
    if now - health_cache["last_check"] < CACHE_TTL:
        checks = health_cache["checks"]
    else:
        # 缓存过期，执行实际检查
        checks = {
            "database": await check_database(),
            "redis": await check_redis(),
        }
        health_cache.update({
            "last_check": now,
            "checks": checks
        })

    if not all(checks.values()):
        raise HTTPException(503, detail=checks)

    return {"status": "ready", "checks": checks}
```

### 为什么人们容易这样错？

**心理原因：** "实时 = 更准确"的直觉

在日常生活中，实时信息更准确（实时股价比延迟股价更准确）。但在健康检查中：
- **实时检查**会导致频繁查询依赖服务（影响性能）
- **短暂抖动**会导致误报（依赖服务短暂不可用）
- **缓存**可以平滑抖动，提高稳定性

**类比：**
- **实时检查** = 每秒测一次体温（过度检查，影响休息）
- **缓存检查** = 每小时测一次体温（合理频率，不影响休息）

### 正确做法

**使用缓存 + 异步更新：**

```python
import asyncio
from datetime import datetime, timedelta

class HealthChecker:
    def __init__(self):
        self.cache = {
            "database": {"status": True, "last_check": datetime.min},
            "redis": {"status": True, "last_check": datetime.min},
        }
        self.cache_ttl = timedelta(seconds=30)

    async def check_database(self) -> bool:
        """检查数据库（带缓存）"""
        now = datetime.now()
        cache = self.cache["database"]

        # 如果缓存未过期，直接返回
        if now - cache["last_check"] < self.cache_ttl:
            return cache["status"]

        # 执行实际检查
        try:
            await db.execute("SELECT 1")
            status = True
        except Exception:
            status = False

        # 更新缓存
        self.cache["database"] = {
            "status": status,
            "last_check": now
        }

        return status

    async def get_health_status(self) -> dict:
        """获取整体健康状态"""
        checks = {
            "database": await self.check_database(),
            "redis": await self.check_redis(),
        }
        return checks

# 使用
health_checker = HealthChecker()

@app.get("/ready")
async def ready():
    checks = await health_checker.get_health_status()

    if not all(checks.values()):
        raise HTTPException(503, detail=checks)

    return {"status": "ready", "checks": checks}
```

**缓存时间建议：**
- **关键依赖**（数据库）：30-60 秒
- **可选依赖**（Redis）：60-120 秒
- **外部 API**：120-300 秒（更长，避免频繁调用）

---

## 误区5：健康检查端点不需要监控 ❌

### 为什么错？

**错误观点：** "健康检查是用来监控服务的，不需要再监控健康检查本身"

**正确理解：**
- 健康检查本身也可能**失败或变慢**
- 健康检查的**响应时间**是重要的性能指标
- 健康检查的**成功率**反映服务稳定性
- 应该暴露健康检查指标给 **Prometheus**

**代码对比：**

```python
# ❌ 错误：没有监控健康检查本身
@app.get("/ready")
async def ready():
    checks = await check_all_dependencies()
    if not all(checks.values()):
        raise HTTPException(503)
    return {"status": "ready"}

# ✅ 正确：监控健康检查的性能和成功率
from prometheus_client import Counter, Histogram

health_check_total = Counter(
    'health_check_total',
    'Total health check requests',
    ['endpoint', 'status']
)

health_check_duration = Histogram(
    'health_check_duration_seconds',
    'Health check duration',
    ['endpoint']
)

@app.get("/ready")
async def ready():
    start_time = time.time()

    try:
        checks = await check_all_dependencies()

        if not all(checks.values()):
            health_check_total.labels(endpoint='ready', status='failure').inc()
            raise HTTPException(503)

        health_check_total.labels(endpoint='ready', status='success').inc()
        return {"status": "ready"}

    finally:
        # 记录健康检查耗时
        duration = time.time() - start_time
        health_check_duration.labels(endpoint='ready').observe(duration)
```

### 为什么人们容易这样错？

**心理原因：** "监控工具不需要被监控"的直觉

在日常生活中，体检设备不需要体检（温度计不需要测温度）。但在分布式系统中：
- **健康检查变慢** = 依赖服务响应变慢（性能问题）
- **健康检查失败率高** = 服务不稳定（可靠性问题）
- **监控健康检查**可以提前发现问题

**类比：**
- **不监控健康检查** = 不检查体检设备是否准确（可能误诊）
- **监控健康检查** = 定期校准体检设备（确保准确）

### 正确做法

**暴露健康检查指标：**

```python
from prometheus_client import Counter, Histogram, Gauge

# 定义指标
health_check_total = Counter(
    'health_check_total',
    'Total health check requests',
    ['endpoint', 'status']
)

health_check_duration = Histogram(
    'health_check_duration_seconds',
    'Health check duration',
    ['endpoint'],
    buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 5.0]
)

dependency_status = Gauge(
    'dependency_status',
    'Dependency health status (1=healthy, 0=unhealthy)',
    ['service']
)

@app.get("/ready")
async def ready():
    start_time = time.time()

    try:
        # 检查依赖服务
        checks = {
            "database": await check_database(),
            "redis": await check_redis(),
        }

        # 更新依赖状态指标
        for service, status in checks.items():
            dependency_status.labels(service=service).set(1 if status else 0)

        # 判断整体状态
        if not all(checks.values()):
            health_check_total.labels(endpoint='ready', status='failure').inc()
            raise HTTPException(503)

        health_check_total.labels(endpoint='ready', status='success').inc()
        return {"status": "ready", "checks": checks}

    finally:
        # 记录健康检查耗时
        duration = time.time() - start_time
        health_check_duration.labels(endpoint='ready').observe(duration)
```

**监控告警规则：**

```yaml
# Prometheus 告警规则
groups:
  - name: health_check
    rules:
      # 健康检查成功率低于 95%
      - alert: HealthCheckLowSuccessRate
        expr: |
          rate(health_check_total{status="success"}[5m])
          /
          rate(health_check_total[5m])
          < 0.95
        for: 5m
        annotations:
          summary: "Health check success rate is low"

      # 健康检查响应时间超过 1 秒
      - alert: HealthCheckSlow
        expr: |
          histogram_quantile(0.95,
            rate(health_check_duration_seconds_bucket[5m])
          ) > 1.0
        for: 5m
        annotations:
          summary: "Health check is slow"
```

---

## 总结：健康检查的5个反直觉点

| 误区 | 直觉 | 真相 |
|------|------|------|
| 1. 检查越详细越好 | 更详细 = 更准确 | 健康检查要快速，详细检查交给监控系统 |
| 2. 失败应该立即重启 | 快速响应 = 更可靠 | 连续失败才重启，避免误重启 |
| 3. /health 和 /ready 一样 | 健康 = 准备好 | Liveness 检查存活，Readiness 检查就绪 |
| 4. 不需要缓存 | 实时 = 更准确 | 缓存可以平滑抖动，提高稳定性 |
| 5. 不需要监控健康检查 | 监控工具不需要被监控 | 健康检查本身也需要监控 |

---

## 在 AI Agent 后端中的特殊误区

### 误区6：LLM API 失败应该返回不健康 ❌

**错误观点：** "LLM API 不可用 = 服务不可用"

**正确理解：**
- LLM API 可能**短暂不可用**（限流、维护）
- 可以使用**降级策略**（返回缓存结果、使用备用模型）
- 应该返回 **degraded**（降级）而非 **unhealthy**（不健康）

```python
@app.get("/ready")
async def ready():
    checks = {
        "database": await check_database(),      # 核心依赖
        "llm_api": await check_llm_api(),        # 可降级依赖
    }

    # 数据库失败 → 不健康
    if not checks["database"]:
        raise HTTPException(503, "Database unavailable")

    # LLM API 失败 → 降级但可用
    if not checks["llm_api"]:
        return {
            "status": "degraded",  # 降级状态
            "message": "LLM API unavailable, using fallback",
            "checks": checks
        }

    return {"status": "healthy", "checks": checks}
```

**关键点：** 区分核心依赖和可降级依赖。
