# 实战代码：综合应用

> AI Agent 开发中的后台任务综合应用示例，展示真实场景的完整实现

---

## 示例1：文档问答系统

### 场景描述
用户上传文档后，后台解析文档、生成 Embedding、存储到向量数据库，然后可以进行问答。

### 完整代码

```python
"""
示例1：文档问答系统
演示：完整的 RAG 文档处理流程
"""

from fastapi import FastAPI, BackgroundTasks, UploadFile, File, HTTPException
from pydantic import BaseModel
from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import os
import tempfile
import logging
import asyncio

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# ===== 1. 数据库配置 =====
DATABASE_URL = "sqlite:///./documents.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()

class Document(Base):
    __tablename__ = "documents"
    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, index=True)
    content = Column(Text)
    status = Column(String, default="processing")  # processing, completed, failed
    created_at = Column(DateTime, default=datetime.now)
    error_message = Column(Text, nullable=True)

Base.metadata.create_all(bind=engine)

# ===== 2. 模拟的 AI 服务 =====
async def extract_text_from_file(file_path: str) -> str:
    """从文件中提取文本"""
    logger.info(f"提取文本: {file_path}")

    # 模拟文本提取
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    await asyncio.sleep(1)  # 模拟处理时间
    return content

async def generate_embedding(text: str) -> list:
    """生成文本的 Embedding"""
    logger.info(f"生成 Embedding，文本长度: {len(text)}")

    # 模拟 Embedding 生成
    await asyncio.sleep(2)

    # 返回模拟的向量（实际应该调用 OpenAI API）
    return [0.1] * 1536

async def store_to_vectordb(doc_id: int, embedding: list):
    """存储到向量数据库"""
    logger.info(f"存储到向量数据库: doc_id={doc_id}")

    # 模拟存储
    await asyncio.sleep(1)

    logger.info(f"存储完成: doc_id={doc_id}")

# ===== 3. 后台任务：处理文档 =====
async def process_document(doc_id: int, file_path: str):
    """处理文档的完整流程"""
    db = SessionLocal()

    try:
        # 1. 提取文本
        logger.info(f"开始处理文档: doc_id={doc_id}")
        text = await extract_text_from_file(file_path)

        # 更新文档内容
        document = db.query(Document).filter(Document.id == doc_id).first()
        document.content = text
        db.commit()

        # 2. 生成 Embedding
        embedding = await generate_embedding(text)

        # 3. 存储到向量数据库
        await store_to_vectordb(doc_id, embedding)

        # 4. 更新状态为完成
        document.status = "completed"
        db.commit()

        logger.info(f"文档处理完成: doc_id={doc_id}")

    except Exception as e:
        logger.error(f"文档处理失败: doc_id={doc_id}, 错误: {e}")

        # 更新状态为失败
        document = db.query(Document).filter(Document.id == doc_id).first()
        document.status = "failed"
        document.error_message = str(e)
        db.commit()

    finally:
        db.close()

        # 清理临时文件
        if os.path.exists(file_path):
            os.remove(file_path)
            logger.info(f"临时文件已删除: {file_path}")

# ===== 4. API 端点 =====
@app.post("/upload")
async def upload_document(
    file: UploadFile = File(...),
    background_tasks: BackgroundTasks = None
):
    """上传文档"""
    # 1. 保存到临时文件
    with tempfile.NamedTemporaryFile(delete=False, suffix=".txt") as temp_file:
        content = await file.read()
        temp_file.write(content)
        temp_file_path = temp_file.name

    # 2. 创建数据库记录
    db = SessionLocal()
    try:
        document = Document(
            filename=file.filename,
            status="processing"
        )
        db.add(document)
        db.commit()
        db.refresh(document)

        doc_id = document.id

    finally:
        db.close()

    # 3. 添加后台任务
    background_tasks.add_task(process_document, doc_id, temp_file_path)

    return {
        "message": "文档上传成功，正在后台处理",
        "document_id": doc_id,
        "filename": file.filename
    }

@app.get("/documents/{doc_id}")
async def get_document(doc_id: int):
    """获取文档信息"""
    db = SessionLocal()
    try:
        document = db.query(Document).filter(Document.id == doc_id).first()

        if not document:
            raise HTTPException(status_code=404, detail="文档不存在")

        return {
            "id": document.id,
            "filename": document.filename,
            "status": document.status,
            "content_length": len(document.content) if document.content else 0,
            "created_at": document.created_at.isoformat(),
            "error_message": document.error_message
        }
    finally:
        db.close()

@app.get("/documents")
async def list_documents():
    """列出所有文档"""
    db = SessionLocal()
    try:
        documents = db.query(Document).all()

        return {
            "documents": [
                {
                    "id": doc.id,
                    "filename": doc.filename,
                    "status": doc.status,
                    "created_at": doc.created_at.isoformat()
                }
                for doc in documents
            ]
        }
    finally:
        db.close()

class QuestionRequest(BaseModel):
    question: str
    document_id: int

@app.post("/ask")
async def ask_question(request: QuestionRequest):
    """问答接口"""
    db = SessionLocal()
    try:
        # 1. 检查文档状态
        document = db.query(Document).filter(
            Document.id == request.document_id
        ).first()

        if not document:
            raise HTTPException(status_code=404, detail="文档不存在")

        if document.status != "completed":
            raise HTTPException(
                status_code=400,
                detail=f"文档尚未处理完成，当前状态: {document.status}"
            )

        # 2. 模拟问答（实际应该调用 LLM）
        logger.info(f"问答: {request.question}")

        answer = f"根据文档《{document.filename}》的内容，{request.question}的答案是..."

        return {
            "question": request.question,
            "answer": answer,
            "document_id": document.id,
            "document_name": document.filename
        }

    finally:
        db.close()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 运行方式

```bash
# 1. 安装依赖
uv add sqlalchemy

# 2. 运行服务
python examples/comprehensive/01_document_qa.py

# 3. 上传文档
echo "这是一篇关于 Python 的文档。Python 是一种高级编程语言。" > test.txt
curl -X POST "http://localhost:8000/upload" \
  -F "file=@test.txt"

# 4. 查询文档状态
curl "http://localhost:8000/documents/1"

# 5. 问答
curl -X POST "http://localhost:8000/ask" \
  -H "Content-Type: application/json" \
  -d '{
    "question": "什么是 Python",
    "document_id": 1
  }'
```

---

## 示例2：用户通知系统

### 场景描述
用户执行操作后，通过多种渠道（邮件、短信、推送）发送通知。

### 完整代码

```python
"""
示例2：用户通知系统
演示：多渠道通知发送
"""

from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel, EmailStr
from enum import Enum
import asyncio
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# ===== 1. 通知类型 =====
class NotificationType(str, Enum):
    EMAIL = "email"
    SMS = "sms"
    PUSH = "push"

# ===== 2. 通知服务 =====
async def send_email_notification(email: str, subject: str, body: str):
    """发送邮件通知"""
    logger.info(f"发送邮件: {email}")
    await asyncio.sleep(1)
    logger.info(f"邮件发送成功: {email}")

async def send_sms_notification(phone: str, message: str):
    """发送短信通知"""
    logger.info(f"发送短信: {phone}")
    await asyncio.sleep(1)
    logger.info(f"短信发送成功: {phone}")

async def send_push_notification(user_id: int, title: str, body: str):
    """发送推送通知"""
    logger.info(f"发送推送: user_id={user_id}")
    await asyncio.sleep(1)
    logger.info(f"推送发送成功: user_id={user_id}")

# ===== 3. 后台任务：发送所有通知 =====
async def send_all_notifications(
    user_id: int,
    email: str,
    phone: str,
    notification_types: list[NotificationType],
    subject: str,
    message: str
):
    """并发发送所有类型的通知"""
    tasks = []

    if NotificationType.EMAIL in notification_types:
        tasks.append(send_email_notification(email, subject, message))

    if NotificationType.SMS in notification_types:
        tasks.append(send_sms_notification(phone, message))

    if NotificationType.PUSH in notification_types:
        tasks.append(send_push_notification(user_id, subject, message))

    # 并发执行所有通知
    await asyncio.gather(*tasks)

    logger.info(f"所有通知发送完成: user_id={user_id}")

# ===== 4. API 端点 =====
class NotificationRequest(BaseModel):
    user_id: int
    email: EmailStr
    phone: str
    notification_types: list[NotificationType]
    subject: str
    message: str

@app.post("/notify")
async def send_notification(
    request: NotificationRequest,
    background_tasks: BackgroundTasks
):
    """发送通知"""
    background_tasks.add_task(
        send_all_notifications,
        request.user_id,
        request.email,
        request.phone,
        request.notification_types,
        request.subject,
        request.message
    )

    return {
        "message": "通知任务已提交",
        "user_id": request.user_id,
        "notification_types": request.notification_types
    }

# ===== 5. 预定义通知模板 =====
class EventType(str, Enum):
    USER_REGISTERED = "user_registered"
    ORDER_CREATED = "order_created"
    PAYMENT_SUCCESS = "payment_success"

NOTIFICATION_TEMPLATES = {
    EventType.USER_REGISTERED: {
        "subject": "欢迎注册",
        "message": "感谢您注册我们的服务！",
        "types": [NotificationType.EMAIL, NotificationType.PUSH]
    },
    EventType.ORDER_CREATED: {
        "subject": "订单创建成功",
        "message": "您的订单已创建，订单号：{order_id}",
        "types": [NotificationType.EMAIL, NotificationType.SMS, NotificationType.PUSH]
    },
    EventType.PAYMENT_SUCCESS: {
        "subject": "支付成功",
        "message": "您的支付已成功，金额：{amount}",
        "types": [NotificationType.EMAIL, NotificationType.SMS]
    }
}

class EventNotificationRequest(BaseModel):
    user_id: int
    email: EmailStr
    phone: str
    event_type: EventType
    context: dict = {}

@app.post("/notify/event")
async def send_event_notification(
    request: EventNotificationRequest,
    background_tasks: BackgroundTasks
):
    """根据事件类型发送通知"""
    template = NOTIFICATION_TEMPLATES[request.event_type]

    # 格式化消息
    message = template["message"].format(**request.context)

    background_tasks.add_task(
        send_all_notifications,
        request.user_id,
        request.email,
        request.phone,
        template["types"],
        template["subject"],
        message
    )

    return {
        "message": "事件通知已提交",
        "event_type": request.event_type
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 运行方式

```bash
# 1. 运行服务
python examples/comprehensive/02_notification_system.py

# 2. 发送自定义通知
curl -X POST "http://localhost:8000/notify" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "email": "user@example.com",
    "phone": "+86 138 0000 0000",
    "notification_types": ["email", "sms", "push"],
    "subject": "测试通知",
    "message": "这是一条测试消息"
  }'

# 3. 发送事件通知
curl -X POST "http://localhost:8000/notify/event" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "email": "user@example.com",
    "phone": "+86 138 0000 0000",
    "event_type": "order_created",
    "context": {"order_id": "12345"}
  }'
```

---

## 示例3：AI Agent 对话系统

### 场景描述
用户发起对话，立即返回响应，后台记录对话历史、更新统计、发送通知。

### 完整代码

```python
"""
示例3：AI Agent 对话系统
演示：对话处理 + 后台任务
"""

from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime, Float
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import asyncio
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# ===== 1. 数据库配置 =====
DATABASE_URL = "sqlite:///./conversations.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()

class Conversation(Base):
    __tablename__ = "conversations"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, index=True)
    message = Column(Text)
    response = Column(Text)
    response_time = Column(Float)  # 响应时间（秒）
    created_at = Column(DateTime, default=datetime.now)

class UserStats(Base):
    __tablename__ = "user_stats"
    user_id = Column(Integer, primary_key=True, index=True)
    total_conversations = Column(Integer, default=0)
    total_tokens = Column(Integer, default=0)
    last_conversation_at = Column(DateTime)

Base.metadata.create_all(bind=engine)

# ===== 2. AI 服务（模拟）=====
async def generate_ai_response(message: str) -> str:
    """生成 AI 响应"""
    logger.info(f"生成响应: {message}")

    # 模拟 AI 处理
    await asyncio.sleep(0.5)

    return f"我理解你的问题：{message}。这是我的回答..."

# ===== 3. 后台任务 =====
async def save_conversation(
    user_id: int,
    message: str,
    response: str,
    response_time: float
):
    """保存对话记录"""
    db = SessionLocal()
    try:
        conversation = Conversation(
            user_id=user_id,
            message=message,
            response=response,
            response_time=response_time
        )
        db.add(conversation)
        db.commit()

        logger.info(f"对话已保存: user_id={user_id}")

    finally:
        db.close()

async def update_user_stats(user_id: int, tokens: int):
    """更新用户统计"""
    db = SessionLocal()
    try:
        stats = db.query(UserStats).filter(
            UserStats.user_id == user_id
        ).first()

        if stats:
            stats.total_conversations += 1
            stats.total_tokens += tokens
            stats.last_conversation_at = datetime.now()
        else:
            stats = UserStats(
                user_id=user_id,
                total_conversations=1,
                total_tokens=tokens,
                last_conversation_at=datetime.now()
            )
            db.add(stats)

        db.commit()

        logger.info(f"用户统计已更新: user_id={user_id}")

    finally:
        db.close()

async def check_usage_limit(user_id: int):
    """检查使用限制并发送通知"""
    db = SessionLocal()
    try:
        stats = db.query(UserStats).filter(
            UserStats.user_id == user_id
        ).first()

        if stats and stats.total_conversations >= 100:
            logger.warning(
                f"用户达到使用限制: user_id={user_id}, "
                f"conversations={stats.total_conversations}"
            )
            # 这里可以发送通知

    finally:
        db.close()

# ===== 4. API 端点 =====
class ChatRequest(BaseModel):
    user_id: int
    message: str

@app.post("/chat")
async def chat(
    request: ChatRequest,
    background_tasks: BackgroundTasks
):
    """对话接口"""
    import time
    start_time = time.time()

    # 1. 生成响应
    response = await generate_ai_response(request.message)

    response_time = time.time() - start_time

    # 2. 添加后台任务
    # 保存对话记录
    background_tasks.add_task(
        save_conversation,
        request.user_id,
        request.message,
        response,
        response_time
    )

    # 更新用户统计
    tokens = len(request.message) + len(response)
    background_tasks.add_task(
        update_user_stats,
        request.user_id,
        tokens
    )

    # 检查使用限制
    background_tasks.add_task(
        check_usage_limit,
        request.user_id
    )

    # 3. 立即返回响应
    return {
        "response": response,
        "response_time": response_time
    }

@app.get("/stats/{user_id}")
async def get_user_stats(user_id: int):
    """获取用户统计"""
    db = SessionLocal()
    try:
        stats = db.query(UserStats).filter(
            UserStats.user_id == user_id
        ).first()

        if not stats:
            return {
                "user_id": user_id,
                "total_conversations": 0,
                "total_tokens": 0
            }

        return {
            "user_id": user_id,
            "total_conversations": stats.total_conversations,
            "total_tokens": stats.total_tokens,
            "last_conversation_at": stats.last_conversation_at.isoformat()
        }

    finally:
        db.close()

@app.get("/history/{user_id}")
async def get_conversation_history(user_id: int, limit: int = 10):
    """获取对话历史"""
    db = SessionLocal()
    try:
        conversations = db.query(Conversation).filter(
            Conversation.user_id == user_id
        ).order_by(
            Conversation.created_at.desc()
        ).limit(limit).all()

        return {
            "conversations": [
                {
                    "id": conv.id,
                    "message": conv.message,
                    "response": conv.response,
                    "response_time": conv.response_time,
                    "created_at": conv.created_at.isoformat()
                }
                for conv in conversations
            ]
        }

    finally:
        db.close()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 运行方式

```bash
# 1. 运行服务
python examples/comprehensive/03_ai_agent.py

# 2. 发起对话
curl -X POST "http://localhost:8000/chat" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "什么是 FastAPI？"
  }'

# 3. 查看用户统计
curl "http://localhost:8000/stats/1"

# 4. 查看对话历史
curl "http://localhost:8000/history/1?limit=5"
```

---

## 总结

### 综合应用的关键模式

1. **文档处理流程**
   - 上传 → 解析 → 生成 Embedding → 存储
   - 状态跟踪（processing, completed, failed）
   - 错误处理和重试

2. **多渠道通知**
   - 并发发送（asyncio.gather）
   - 模板化消息
   - 事件驱动通知

3. **对话系统**
   - 快速响应 + 后台记录
   - 统计和分析
   - 使用限制检查

### 最佳实践总结

1. **状态管理**
   - 使用数据库记录任务状态
   - 提供状态查询接口
   - 错误信息记录

2. **并发优化**
   - 使用 asyncio.gather 并发执行
   - 批量处理相似任务
   - 避免阻塞操作

3. **资源清理**
   - 使用 try-finally 确保清理
   - 临时文件及时删除
   - 数据库连接正确关闭

4. **用户体验**
   - 立即返回响应
   - 提供进度查询
   - 错误友好提示

5. **监控和日志**
   - 记录关键操作
   - 统计执行时间
   - 错误追踪

---

**版本：** v1.0
**最后更新：** 2026-02-11
