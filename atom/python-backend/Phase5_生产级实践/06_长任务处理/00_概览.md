# 长任务处理 - 概览

## 知识点定位

**阶段**: Phase5_生产级实践
**编号**: 06
**难度**: ⭐⭐⭐⭐ (中高级)
**预计学习时间**: 建议分配充足时间深入理解

---

## 为什么需要学习长任务处理？

在 AI Agent 开发中，你会经常遇到这些场景：

### 场景1：批量文档处理
```python
# 用户上传100个PDF文档，需要解析并生成Embedding
# 这个过程可能需要5-10分钟
@app.post("/upload-documents")
async def upload_documents(files: List[UploadFile]):
    # ❌ 错误做法：直接在请求中处理
    for file in files:
        parse_pdf(file)  # 每个文件30秒
        generate_embedding(file)  # 每个文件20秒
    return {"status": "done"}  # 用户等待10分钟？浏览器超时！
```

### 场景2：复杂Agent推理
```python
# AI Agent需要执行多步推理，每步调用LLM
# 总耗时可能超过2分钟
@app.post("/complex-query")
async def complex_query(question: str):
    # ❌ 错误做法：同步执行
    step1 = await agent.plan(question)      # 30秒
    step2 = await agent.execute(step1)      # 60秒
    step3 = await agent.summarize(step2)    # 30秒
    return {"answer": step3}  # 用户等待2分钟，体验极差
```

### 场景3：大规模向量检索
```python
# 在百万级向量库中检索相似文档
@app.post("/search")
async def search(query: str):
    # ❌ 错误做法：阻塞等待
    results = await vector_db.search(query, top_k=1000)  # 可能需要1分钟
    return {"results": results}
```

**问题**：HTTP请求有超时限制（通常30-60秒），长时间任务会导致：
- 浏览器/客户端超时
- 用户体验差（不知道进度）
- 服务器资源浪费（连接占用）
- 无法取消或重试

---

## 长任务处理解决什么问题？

### 核心问题

**将耗时操作从HTTP请求中解耦，实现异步执行和进度追踪**

### 解决方案架构

```
┌─────────────┐
│   客户端     │
│  (浏览器)    │
└──────┬──────┘
       │ 1. 提交任务
       ↓
┌─────────────────────────────────────┐
│         FastAPI 服务器               │
│  ┌──────────────────────────────┐  │
│  │  POST /tasks                 │  │
│  │  - 创建任务记录              │  │
│  │  - 返回 task_id              │  │
│  │  - 立即响应（<1秒）          │  │
│  └──────────────────────────────┘  │
│              │                       │
│              │ 2. 发送到队列         │
│              ↓                       │
│  ┌──────────────────────────────┐  │
│  │      任务队列 (Redis)        │  │
│  │  - Celery / ARQ              │  │
│  └──────────────────────────────┘  │
│              │                       │
│              │ 3. Worker 执行        │
│              ↓                       │
│  ┌──────────────────────────────┐  │
│  │      Worker 进程             │  │
│  │  - 执行耗时任务              │  │
│  │  - 更新任务状态              │  │
│  │  - 推送进度                  │  │
│  └──────────────────────────────┘  │
│              │                       │
│              │ 4. 进度推送           │
│              ↓                       │
│  ┌──────────────────────────────┐  │
│  │   WebSocket / SSE            │  │
│  │  - 实时推送进度              │  │
│  │  - 任务完成通知              │  │
│  └──────────────────────────────┘  │
└─────────────────────────────────────┘
       │ 5. 接收进度更新
       ↓
┌─────────────┐
│   客户端     │
│  显示进度条  │
└─────────────┘
```

---

## 本知识点涵盖的内容

### 1. 任务队列基础
- **Celery**: 功能强大的分布式任务队列
- **ARQ**: 轻量级异步任务队列
- **Redis Queue**: 简单的任务队列
- 何时选择哪种方案

### 2. 实时通信技术
- **WebSocket**: 双向实时通信
- **Server-Sent Events (SSE)**: 单向服务器推送
- 两者的对比与选择

### 3. 任务状态管理
- 任务状态机设计
- 数据库模型设计
- 进度追踪（0-100%）
- 结果存储策略

### 4. 错误处理与重试
- 任务失败类型
- 重试策略（指数退避）
- 死信队列（DLQ）
- 优雅降级

### 5. 生产级最佳实践
- 任务超时控制
- 资源限制
- 监控与告警
- 性能优化

---

## 与 AI Agent 开发的关系

| 应用场景 | 技术选型 | 典型耗时 |
|---------|---------|---------|
| **文档批量处理** | Celery + WebSocket | 5-30分钟 |
| 上传100个PDF，解析并生成Embedding | | |
| **复杂Agent推理** | ARQ + SSE | 1-5分钟 |
| 多步骤推理链，每步调用LLM | | |
| **批量内容生成** | Celery + 数据库轮询 | 10-60分钟 |
| 生成100篇文章摘要 | | |
| **大规模向量检索** | BackgroundTasks + SSE | 30秒-2分钟 |
| 在百万级向量库中检索 | | |
| **定时任务** | Celery Beat | 持续运行 |
| 每天凌晨更新知识库 | | |

---

## 前端开发类比

如果你熟悉前端开发，可以这样理解：

| 后端概念 | 前端类比 | 说明 |
|---------|---------|------|
| **Celery任务队列** | Web Worker | 在后台线程执行耗时任务 |
| **WebSocket** | WebSocket API | 双向实时通信 |
| **SSE** | EventSource API | 服务器单向推送事件 |
| **任务状态** | Promise状态 | pending → running → completed/failed |
| **进度推送** | Progress事件 | 上传/下载进度条 |
| **重试机制** | fetch retry | 失败后自动重试 |

---

## 学习目标

完成本知识点学习后，你将能够：

- [ ] 理解为什么需要长任务处理（HTTP超时问题）
- [ ] 掌握Celery的基本使用（任务定义、调用、结果获取）
- [ ] 了解ARQ作为轻量级替代方案
- [ ] 实现WebSocket实时进度推送
- [ ] 实现SSE流式进度更新
- [ ] 设计任务状态管理系统（数据库模型）
- [ ] 实现错误处理与重试机制
- [ ] 构建生产级长任务处理系统

---

## 前置知识

在学习本知识点前，你应该已经掌握：

- ✅ **Phase2_FastAPI核心**：路由、依赖注入、BackgroundTasks
- ✅ **Phase3_数据库层**：SQLAlchemy ORM、Session管理
- ✅ **Phase4_AI_Agent开发**：LangChain集成、流式输出
- ✅ **Python异步编程**：async/await、asyncio

---

## 后续学习

学完本知识点后，建议继续学习：

- → **测试与质量保证**：如何测试异步任务
- → **Docker容器化**：如何部署Celery Worker
- → **监控与告警**：如何监控任务队列健康状态

---

## 快速开始

### 最简单的例子

```python
# 1. 安装依赖
# uv add celery redis

# 2. 定义任务
from celery import Celery

app = Celery('tasks', broker='redis://localhost:6379/0')

@app.task
def process_document(file_path: str):
    # 耗时操作
    import time
    time.sleep(60)  # 模拟1分钟的处理
    return {"status": "done", "file": file_path}

# 3. 调用任务
result = process_document.delay("/path/to/file.pdf")
print(f"任务ID: {result.id}")

# 4. 查询结果
print(f"任务状态: {result.status}")
print(f"任务结果: {result.result}")
```

**关键点**：
- 任务定义：`@app.task` 装饰器
- 异步调用：`.delay()` 方法
- 结果查询：`result.status` 和 `result.result`

---

## 常见误区预警

### 误区1："BackgroundTasks可以处理所有异步任务" ❌

**错误理解**：FastAPI的BackgroundTasks可以处理任何耗时任务

**正确理解**：
- BackgroundTasks只适合**30秒以内**的任务
- 超过30秒会导致请求超时
- 应该用Celery等任务队列

### 误区2："WebSocket比SSE更好" ❌

**错误理解**：WebSocket是双向通信，所以一定比SSE好

**正确理解**：
- 进度推送只需要**单向通信**，SSE更简单
- WebSocket需要处理连接管理、心跳等
- SSE自动重连，更适合进度推送

### 误区3："任务队列一定要用Celery" ❌

**错误理解**：Celery是标准方案，必须用它

**正确理解**：
- 简单场景可以用**ARQ**或**Redis Queue**
- Celery功能强大但配置复杂
- 根据实际需求选择

---

## 学习路线图

```
1. 理解问题
   ↓
2. 学习任务队列基础（Celery/ARQ）
   ↓
3. 学习实时通信（WebSocket/SSE）
   ↓
4. 设计任务状态管理
   ↓
5. 实现错误处理与重试
   ↓
6. 构建生产级系统
```

---

## 本文档结构

本知识点包含以下文档：

### 基础维度（9个文件）
- `01_30字核心.md` - 一句话核心定义
- `02_第一性原理.md` - 从根本理解为什么需要
- `04_最小可用.md` - 20%核心知识
- `05_双重类比.md` - 前端类比 + 日常生活类比
- `06_反直觉点.md` - 3个常见误区
- `08_面试必问.md` - 高频面试题
- `09_化骨绵掌.md` - 10个2分钟知识卡片
- `10_一句话总结.md` - 精炼总结

### 核心概念（5个文件）
- `03_核心概念_01_任务队列基础(Celery_ARQ).md`
- `03_核心概念_02_WebSocket实时通信.md`
- `03_核心概念_03_任务状态管理.md`
- `03_核心概念_04_SSE与异步任务模式.md`
- `03_核心概念_05_错误处理与重试机制.md`

### 实战代码（5个文件）
- `07_实战代码_场景1_Celery基础任务队列.md`
- `07_实战代码_场景2_WebSocket进度推送.md`
- `07_实战代码_场景3_任务状态追踪系统.md`
- `07_实战代码_场景4_SSE流式进度更新.md`
- `07_实战代码_场景5_生产级长任务系统.md`

---

**建议学习顺序**：按照文件编号顺序学习，先理解概念，再看实战代码。

---

**版本**: v1.0
**最后更新**: 2026-02-12
**维护者**: Claude Code
