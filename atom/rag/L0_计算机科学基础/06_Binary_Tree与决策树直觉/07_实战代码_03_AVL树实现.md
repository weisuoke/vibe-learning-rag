# AVL树实现 - 实战代码

> 自平衡二叉树、旋转操作

---

## 完整代码

```python
"""
AVL树实现
演示：自平衡二叉搜索树的插入、删除、旋转操作
"""

class AVLNode:
    """AVL树节点"""
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    """AVL树"""
    def __init__(self):
        self.root = None
    
    # ===== 1. 辅助函数 =====
    def get_height(self, node):
        """获取节点高度"""
        if not node:
            return 0
        return node.height
    
    def update_height(self, node):
        """更新节点高度"""
        if not node:
            return
        node.height = max(self.get_height(node.left), 
                         self.get_height(node.right)) + 1
    
    def get_balance_factor(self, node):
        """获取平衡因子"""
        if not node:
            return 0
        return self.get_height(node.left) - self.get_height(node.right)
    
    # ===== 2. 旋转操作 =====
    def left_rotate(self, node):
        """左旋"""
        new_root = node.right
        node.right = new_root.left
        new_root.left = node
        
        self.update_height(node)
        self.update_height(new_root)
        
        return new_root
    
    def right_rotate(self, node):
        """右旋"""
        new_root = node.left
        node.left = new_root.right
        new_root.right = node
        
        self.update_height(node)
        self.update_height(new_root)
        
        return new_root
    
    # ===== 3. 平衡操作 =====
    def balance(self, node):
        """平衡节点"""
        if not node:
            return None
        
        self.update_height(node)
        bf = self.get_balance_factor(node)
        
        # 左子树过高
        if bf > 1:
            if self.get_balance_factor(node.left) >= 0:
                # LL情况：右旋
                return self.right_rotate(node)
            else:
                # LR情况：左右旋
                node.left = self.left_rotate(node.left)
                return self.right_rotate(node)
        
        # 右子树过高
        if bf < -1:
            if self.get_balance_factor(node.right) <= 0:
                # RR情况：左旋
                return self.left_rotate(node)
            else:
                # RL情况：右左旋
                node.right = self.right_rotate(node.right)
                return self.left_rotate(node)
        
        return node
    
    # ===== 4. 插入操作 =====
    def insert(self, val):
        """插入节点"""
        self.root = self._insert_recursive(self.root, val)
    
    def _insert_recursive(self, node, val):
        # 标准BST插入
        if not node:
            return AVLNode(val)
        
        if val < node.val:
            node.left = self._insert_recursive(node.left, val)
        elif val > node.val:
            node.right = self._insert_recursive(node.right, val)
        else:
            return node  # 重复值
        
        # 平衡节点
        return self.balance(node)
    
    # ===== 5. 删除操作 =====
    def delete(self, val):
        """删除节点"""
        self.root = self._delete_recursive(self.root, val)
    
    def _delete_recursive(self, node, val):
        if not node:
            return None
        
        if val < node.val:
            node.left = self._delete_recursive(node.left, val)
        elif val > node.val:
            node.right = self._delete_recursive(node.right, val)
        else:
            # 找到要删除的节点
            if not node.left:
                return node.right
            elif not node.right:
                return node.left
            else:
                # 两个子节点：找右子树最小节点
                min_node = self._find_min(node.right)
                node.val = min_node.val
                node.right = self._delete_recursive(node.right, min_node.val)
        
        # 平衡节点
        return self.balance(node)
    
    def _find_min(self, node):
        """找到最小节点"""
        while node.left:
            node = node.left
        return node
    
    # ===== 6. 查找操作 =====
    def search(self, val):
        """查找节点"""
        return self._search_recursive(self.root, val)
    
    def _search_recursive(self, node, val):
        if not node:
            return False
        if node.val == val:
            return True
        elif val < node.val:
            return self._search_recursive(node.left, val)
        else:
            return self._search_recursive(node.right, val)
    
    # ===== 7. 遍历操作 =====
    def inorder(self):
        """中序遍历（有序输出）"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node, result):
        if not node:
            return
        self._inorder_recursive(node.left, result)
        result.append(node.val)
        self._inorder_recursive(node.right, result)
    
    # ===== 8. 验证平衡 =====
    def is_balanced(self):
        """判断是否平衡"""
        def check(node):
            if not node:
                return 0, True
            left_h, left_bal = check(node.left)
            right_h, right_bal = check(node.right)
            balanced = left_bal and right_bal and abs(left_h - right_h) <= 1
            height = max(left_h, right_h) + 1
            return height, balanced
        _, is_bal = check(self.root)
        return is_bal
    
    # ===== 9. 打印树结构 =====
    def print_tree(self):
        """打印树结构"""
        self._print_tree_recursive(self.root, 0, "Root: ")
    
    def _print_tree_recursive(self, node, level, prefix):
        if node:
            print(" " * (level * 4) + prefix + 
                  f"{node.val} (h={node.height}, bf={self.get_balance_factor(node)})")
            if node.left or node.right:
                if node.left:
                    self._print_tree_recursive(node.left, level + 1, "L--- ")
                else:
                    print(" " * ((level + 1) * 4) + "L--- None")
                
                if node.right:
                    self._print_tree_recursive(node.right, level + 1, "R--- ")
                else:
                    print(" " * ((level + 1) * 4) + "R--- None")

# ===== 测试代码 =====
if __name__ == "__main__":
    print("=== AVL树测试 ===\n")
    
    avl = AVLTree()
    
    # 1. 插入节点
    print("插入节点: 10, 20, 30, 40, 50, 25")
    for val in [10, 20, 30, 40, 50, 25]:
        avl.insert(val)
        print(f"\n插入 {val} 后:")
        avl.print_tree()
        print(f"平衡: {avl.is_balanced()}")
    
    # 2. 中序遍历（有序）
    print("\n中序遍历（有序）:", avl.inorder())
    
    # 3. 查找
    print("\n查找 30:", avl.search(30))
    print("查找 60:", avl.search(60))
    
    # 4. 删除节点
    print("\n删除 30:")
    avl.delete(30)
    avl.print_tree()
    print("平衡:", avl.is_balanced())
    print("中序遍历:", avl.inorder())
```

## 运行输出

```
=== AVL树测试 ===

插入节点: 10, 20, 30, 40, 50, 25

插入 10 后:
Root: 10 (h=1, bf=0)

插入 20 后:
Root: 10 (h=2, bf=-1)
    L--- None
    R--- 20 (h=1, bf=0)

插入 30 后:
Root: 20 (h=2, bf=0)
    L--- 10 (h=1, bf=0)
    R--- 30 (h=1, bf=0)
平衡: True

插入 40 后:
Root: 20 (h=3, bf=-1)
    L--- 10 (h=1, bf=0)
    R--- 30 (h=2, bf=-1)
        L--- None
        R--- 40 (h=1, bf=0)
平衡: True

插入 50 后:
Root: 20 (h=3, bf=-1)
    L--- 10 (h=1, bf=0)
    R--- 40 (h=2, bf=0)
        L--- 30 (h=1, bf=0)
        R--- 50 (h=1, bf=0)
平衡: True

插入 25 后:
Root: 20 (h=3, bf=-1)
    L--- 10 (h=1, bf=0)
    R--- 40 (h=2, bf=0)
        L--- 30 (h=2, bf=1)
            L--- 25 (h=1, bf=0)
            R--- None
        R--- 50 (h=1, bf=0)
平衡: True

中序遍历（有序）: [10, 20, 25, 30, 40, 50]

查找 30: True
查找 60: False

删除 30:
Root: 20 (h=3, bf=-1)
    L--- 10 (h=1, bf=0)
    R--- 40 (h=2, bf=0)
        L--- 25 (h=1, bf=0)
        R--- 50 (h=1, bf=0)
平衡: True
中序遍历: [10, 20, 25, 40, 50]
```

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+
