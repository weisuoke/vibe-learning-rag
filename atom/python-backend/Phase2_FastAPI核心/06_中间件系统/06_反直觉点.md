# 反直觉点

这里列出 FastAPI 中间件系统中最常见的 3 个误区。

---

## 误区1：中间件会自动应用到所有路由 ❌

**错误观点：** "我添加了认证中间件，所有路由都会自动验证认证"

**为什么错？**

中间件确实会应用到所有路由，但这不意味着你可以不做任何判断。中间件需要你自己决定哪些路径需要认证，哪些不需要。

```python
# ❌ 错误：所有路由都要求认证，包括登录接口
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    token = request.headers.get("authorization")
    if not token:
        return JSONResponse({"error": "Unauthorized"}, status_code=401)
    # 验证 token...
    response = await call_next(request)
    return response

@app.post("/login")  # 登录接口也要求认证，死循环！
async def login(username: str, password: str):
    return {"token": "..."}

# ✅ 正确：在中间件中判断路径
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 公开路径不需要认证
    public_paths = ["/login", "/register", "/docs", "/openapi.json"]
    if request.url.path in public_paths:
        return await call_next(request)

    # 其他路径需要认证
    token = request.headers.get("authorization")
    if not token:
        return JSONResponse({"error": "Unauthorized"}, status_code=401)

    response = await call_next(request)
    return response
```

**为什么人们容易这样错？**

因为"中间件应用到所有路由"这个说法容易让人误解为"中间件会自动处理所有情况"。实际上，中间件只是给你一个拦截所有请求的机会，具体逻辑还是要你自己写。

**正确理解：**

中间件是一个**拦截器**，不是**自动化工具**。它给你机会在每个请求前后做事情，但具体做什么、对哪些路由做，都要你自己决定。

---

## 误区2：中间件的执行顺序是注册顺序 ❌

**错误观点：** "先注册的中间件先执行"

**为什么错？**

中间件的执行顺序是**洋葱模型**，不是简单的注册顺序。先注册的中间件在**最外层**，后注册的在**最内层**。

```python
# 注册顺序
@app.middleware("http")
async def middleware_1(request: Request, call_next):
    print("1: before")
    response = await call_next(request)
    print("1: after")
    return response

@app.middleware("http")
async def middleware_2(request: Request, call_next):
    print("2: before")
    response = await call_next(request)
    print("2: after")
    return response

@app.get("/test")
async def test():
    print("Handler")
    return {"message": "ok"}

# 执行顺序（洋葱模型）：
# 1: before  ← 先注册的在最外层
# 2: before  ← 后注册的在内层
# Handler    ← 路由处理
# 2: after   ← 后注册的先返回
# 1: after   ← 先注册的后返回
```

**为什么人们容易这样错？**

因为在其他框架（如 Express）中，中间件的执行顺序确实是注册顺序。但 FastAPI 使用的是洋葱模型，这是一个更强大的模型，但也更容易混淆。

**正确理解：**

想象中间件是俄罗斯套娃：
- 先注册的是**最外层**的娃娃
- 后注册的是**最内层**的娃娃
- 请求从外到内，响应从内到外

**实际影响：**

```python
# 如果你想让日志中间件记录完整的请求时间（包括其他中间件的时间）
# 应该把日志中间件放在最外层（最先注册）

# ✅ 正确：日志中间件最先注册
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    start = time.time()
    response = await call_next(request)
    duration = time.time() - start
    print(f"Total time: {duration:.3f}s")  # 包括所有中间件的时间
    return response

@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 认证逻辑...
    response = await call_next(request)
    return response

# ❌ 错误：日志中间件最后注册
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 认证逻辑...
    response = await call_next(request)
    return response

@app.middleware("http")
async def log_middleware(request: Request, call_next):
    start = time.time()
    response = await call_next(request)
    duration = time.time() - start
    print(f"Total time: {duration:.3f}s")  # 不包括认证中间件的时间
    return response
```

---

## 误区3：中间件可以修改请求体 ❌

**错误观点：** "我可以在中间件中修改 `request.body`，然后传给路由"

**为什么错？**

在 FastAPI 中，`request.body()` 是一个**异步生成器**，只能读取一次。读取后就消耗了，路由处理函数就读不到了。

```python
# ❌ 错误：在中间件中读取请求体
@app.middleware("http")
async def log_body_middleware(request: Request, call_next):
    body = await request.body()  # 读取请求体
    print(f"Body: {body}")

    response = await call_next(request)
    return response

@app.post("/users")
async def create_user(user: User):  # Pydantic 无法读取请求体，因为已经被消耗了
    return {"user": user}

# ✅ 正确：不要在中间件中读取请求体
# 如果需要记录请求体，使用依赖注入或路由装饰器
```

**为什么人们容易这样错？**

因为在 Express 中，`req.body` 是一个普通对象，可以随意读取和修改。但在 FastAPI 中，请求体是流式读取的，读取后就消耗了。

**正确理解：**

如果你需要在中间件中访问请求体，有两种方法：

**方法1：使用 `request.body()` 并重新设置**

```python
@app.middleware("http")
async def log_body_middleware(request: Request, call_next):
    # 读取请求体
    body = await request.body()
    print(f"Body: {body}")

    # 重新设置请求体（使用 receive）
    async def receive():
        return {"type": "http.request", "body": body}

    request._receive = receive

    response = await call_next(request)
    return response
```

**方法2：使用依赖注入（推荐）**

```python
# 在路由中使用依赖注入记录请求体
async def log_body(body: dict = Body(...)):
    print(f"Body: {body}")
    return body

@app.post("/users")
async def create_user(body: dict = Depends(log_body)):
    return {"user": body}
```

**最佳实践：**

- 中间件用于处理**请求元数据**（headers、path、method）
- 依赖注入用于处理**请求体**（body、form data）

---

## 额外误区：中间件可以捕获所有异常 ⚠️

**半对半错的观点：** "我在中间件中用 try-except 包裹 `call_next()`，就能捕获所有异常"

**为什么半对半错？**

你可以捕获路由处理函数中的异常，但捕获不了其他中间件中的异常（在你之前执行的中间件）。

```python
@app.middleware("http")
async def error_handler_middleware(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except Exception as e:
        # 可以捕获路由处理函数和后续中间件的异常
        # 但捕获不了之前中间件的异常
        print(f"Error: {e}")
        return JSONResponse(
            {"error": "Internal server error"},
            status_code=500
        )

@app.middleware("http")
async def buggy_middleware(request: Request, call_next):
    raise ValueError("Bug!")  # 这个异常捕获不到
    response = await call_next(request)
    return response

@app.get("/test")
async def test():
    raise ValueError("Bug in handler")  # 这个异常可以捕获
    return {"message": "ok"}
```

**正确理解：**

- 中间件只能捕获**内层**的异常（后续中间件和路由处理函数）
- 不能捕获**外层**的异常（之前的中间件）
- 如果要捕获所有异常，应该使用 FastAPI 的**异常处理器**

```python
# ✅ 正确：使用异常处理器
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    print(f"Global error: {exc}")
    return JSONResponse(
        {"error": "Internal server error"},
        status_code=500
    )
```

---

## 总结

| 误区 | 正确理解 |
|------|----------|
| 中间件自动应用到所有路由 | 中间件给你拦截机会，但逻辑要自己写 |
| 执行顺序是注册顺序 | 洋葱模型：先注册在外层，后注册在内层 |
| 可以修改请求体 | 请求体只能读一次，需要特殊处理 |
| 可以捕获所有异常 | 只能捕获内层异常，用异常处理器更好 |

---

**记住：** 中间件不是魔法，它只是一个拦截器。理解了洋葱模型和请求流的本质，就不会被这些误区困扰。
