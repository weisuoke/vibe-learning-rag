# 实战代码 04: 复杂 UI 定制案例

> **学习目标**: 构建一个完整的终端聊天应用
> **阅读时间**: 120 分钟
> **难度级别**: ⭐⭐⭐⭐⭐ (专家)
> **代码语言**: TypeScript

---

## 场景概述

**目标**: 构建一个功能完整的终端聊天应用

**功能需求**:
- 消息历史显示（差分渲染）
- 多行消息输入（自定义编辑器）
- 实时状态指示器（Widget）
- 加载动画（Widget）
- 错误提示（Notification）
- 键盘快捷键

**技术栈**:
- 差分渲染系统
- 自定义编辑器
- Widget 系统
- 事件处理
- 状态管理

---

## 应用架构

### 整体架构

```
ChatApplication
├── DiffRenderer (差分渲染)
├── MessageHistory (消息历史)
├── MessageEditor (消息编辑器)
├── WidgetManager (Widget 管理)
│   ├── StatusBar (状态栏)
│   ├── LoadingSpinner (加载指示器)
│   └── ErrorNotification (错误提示)
└── EventHandler (事件处理)
```

### 数据流

```
User Input → EventHandler → State Update → Render
                ↓
            API Call → Loading → Response → State Update → Render
```

---

## 完整实现

### 1. 应用状态

```typescript
// app-state.ts
export interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export interface AppState {
  messages: Message[];
  inputValue: string;
  isLoading: boolean;
  error: string | null;
  status: 'idle' | 'sending' | 'receiving';
}

export function createInitialState(): AppState {
  return {
    messages: [],
    inputValue: '',
    isLoading: false,
    error: null,
    status: 'idle'
  };
}
```

### 2. 消息历史组件

```typescript
// message-history.ts
import { Message } from './app-state';
import { Component, RenderContext } from './types';

export class MessageHistory implements Component {
  private messages: Message[];
  private maxHeight: number;
  private scrollOffset: number = 0;

  constructor(messages: Message[], maxHeight: number) {
    this.messages = messages;
    this.maxHeight = maxHeight;
    this.updateScroll();
  }

  setMessages(messages: Message[]): void {
    this.messages = messages;
    this.updateScroll();
  }

  render(ctx: RenderContext): string {
    const visibleMessages = this.messages.slice(
      Math.max(0, this.messages.length - this.maxHeight),
      this.messages.length
    );

    return visibleMessages.map(msg => this.renderMessage(msg)).join('\n');
  }

  private renderMessage(msg: Message): string {
    const time = msg.timestamp.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit'
    });

    const roleColor = msg.role === 'user' ? '\x1b[36m' : '\x1b[32m';
    const roleName = msg.role === 'user' ? 'You' : 'AI';
    const reset = '\x1b[0m';

    const header = `${roleColor}[${time}] ${roleName}:${reset}`;
    const content = msg.content.split('\n').map(line => `  ${line}`).join('\n');

    return `${header}\n${content}`;
  }

  private updateScroll(): void {
    // 自动滚动到最新消息
    if (this.messages.length > this.maxHeight) {
      this.scrollOffset = this.messages.length - this.maxHeight;
    }
  }

  getSize(): { width: number; height: number } {
    return {
      width: 80,
      height: Math.min(this.messages.length * 3, this.maxHeight)
    };
  }
}
```

### 3. 主应用类

```typescript
// chat-application.ts
import { DiffRenderer } from './renderer';
import { Buffer } from './buffer';
import { MessageHistory } from './message-history';
import { MultiLineEditor } from './multi-line-editor';
import { WidgetManager } from './widget-manager';
import { LoadingSpinner, StatusBar, ErrorNotification } from './widgets';
import { AppState, createInitialState, Message } from './app-state';
import { KeyEvent } from './types';

export class ChatApplication {
  private state: AppState;
  private renderer: DiffRenderer;
  private messageHistory: MessageHistory;
  private editor: MultiLineEditor;
  private widgetManager: WidgetManager;
  private terminal: { width: number; height: number };

  // Widgets
  private statusBar: StatusBar;
  private loadingSpinner: LoadingSpinner;
  private errorNotification: ErrorNotification;

  constructor() {
    this.terminal = { width: 80, height: 24 };
    this.state = createInitialState();

    // 初始化组件
    this.renderer = new DiffRenderer(this.terminal.height, this.terminal.width);
    this.messageHistory = new MessageHistory([], this.terminal.height - 6);
    this.editor = new MultiLineEditor();
    this.widgetManager = new WidgetManager(this.terminal);

    // 初始化 Widgets
    this.statusBar = new StatusBar(
      { type: 'anchor', anchor: 'bottom-left' }
    );
    this.loadingSpinner = new LoadingSpinner(
      { type: 'anchor', anchor: 'bottom-right', offset: { x: -1, y: -1 } }
    );
    this.errorNotification = new ErrorNotification(
      { type: 'anchor', anchor: 'top-right', offset: { x: -1, y: 1 } }
    );

    this.widgetManager.add(this.statusBar, 5);
    this.widgetManager.add(this.loadingSpinner, 10);
    this.widgetManager.add(this.errorNotification, 20);

    this.updateStatus();
  }

  async start(): Promise<void> {
    // 清屏并隐藏光标
    process.stdout.write('\x1b[2J\x1b[H\x1b[?25l');

    // 初始渲染
    this.render();

    // 设置输入处理
    process.stdin.setRawMode(true);
    process.stdin.resume();
    process.stdin.on('data', (data) => this.handleInput(data));

    // 欢迎消息
    this.addMessage({
      id: Date.now().toString(),
      role: 'assistant',
      content: 'Welcome to Terminal Chat! Type your message and press Ctrl+Enter to send.',
      timestamp: new Date()
    });
  }

  private handleInput(data: Buffer): void {
    const key = this.parseKey(data);

    // Ctrl+C: 退出
    if (key.ctrl && key.name === 'c') {
      this.cleanup();
      process.exit(0);
    }

    // Ctrl+Enter: 发送消息
    if (key.ctrl && key.name === 'return') {
      this.sendMessage();
      return;
    }

    // 传递给编辑器
    if (this.editor.handleKey(key)) {
      this.state.inputValue = this.editor.getValue();
      this.render();
    }
  }

  private parseKey(data: Buffer): KeyEvent {
    const str = data.toString();
    const code = data[0];

    // Ctrl+C
    if (code === 3) {
      return { name: 'c', sequence: str, ctrl: true, meta: false, shift: false };
    }

    // Ctrl+Enter (Ctrl+J or Ctrl+M)
    if (code === 10 || code === 13) {
      return { name: 'return', sequence: str, ctrl: true, meta: false, shift: false };
    }

    // Enter
    if (str === '\r' || str === '\n') {
      return { name: 'return', sequence: str, ctrl: false, meta: false, shift: false };
    }

    // Backspace
    if (code === 127 || code === 8) {
      return { name: 'backspace', sequence: str, ctrl: false, meta: false, shift: false };
    }

    // Arrow keys
    if (str === '\x1b[A') return { name: 'up', sequence: str, ctrl: false, meta: false, shift: false };
    if (str === '\x1b[B') return { name: 'down', sequence: str, ctrl: false, meta: false, shift: false };
    if (str === '\x1b[C') return { name: 'right', sequence: str, ctrl: false, meta: false, shift: false };
    if (str === '\x1b[D') return { name: 'left', sequence: str, ctrl: false, meta: false, shift: false };

    // 普通字符
    return { name: '', sequence: str, ctrl: false, meta: false, shift: false };
  }

  private async sendMessage(): Promise<void> {
    const content = this.editor.getValue().trim();
    if (!content) return;

    // 添加用户消息
    this.addMessage({
      id: Date.now().toString(),
      role: 'user',
      content,
      timestamp: new Date()
    });

    // 清空输入
    this.editor.setValue('');
    this.state.inputValue = '';

    // 显示加载状态
    this.state.isLoading = true;
    this.state.status = 'sending';
    this.loadingSpinner.show();
    this.updateStatus();
    this.render();

    try {
      // 模拟 API 调用
      const response = await this.callAPI(content);

      // 添加 AI 响应
      this.addMessage({
        id: Date.now().toString(),
        role: 'assistant',
        content: response,
        timestamp: new Date()
      });

      this.state.error = null;
    } catch (error) {
      this.state.error = error instanceof Error ? error.message : 'Unknown error';
      this.errorNotification.show(this.state.error);
    } finally {
      this.state.isLoading = false;
      this.state.status = 'idle';
      this.loadingSpinner.hide();
      this.updateStatus();
      this.render();
    }
  }

  private async callAPI(message: string): Promise<string> {
    // 模拟 API 延迟
    await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));

    // 模拟响应
    const responses = [
      'That\'s an interesting question! Let me think about it...',
      'I understand what you\'re asking. Here\'s my perspective...',
      'Great point! I\'d like to add that...',
      'Let me help you with that...'
    ];

    return responses[Math.floor(Math.random() * responses.length)];
  }

  private addMessage(message: Message): void {
    this.state.messages.push(message);
    this.messageHistory.setMessages(this.state.messages);
  }

  private updateStatus(): void {
    const messageCount = this.state.messages.length;
    const status = this.state.status === 'idle' ? 'Ready' : 'Sending...';
    this.statusBar.setStatus(`${status} | Messages: ${messageCount} | Ctrl+Enter: Send | Ctrl+C: Exit`);
  }

  private render(): void {
    const buffer = new Buffer(this.terminal.height, this.terminal.width);

    // 渲染消息历史
    const historyContent = this.messageHistory.render({
      width: this.terminal.width,
      height: this.terminal.height - 6,
      focused: false
    });

    const historyLines = historyContent.split('\n');
    historyLines.forEach((line, i) => {
      for (let col = 0; col < Math.min(line.length, this.terminal.width); col++) {
        buffer.setCell(i, col, { char: line[col] || ' ' });
      }
    });

    // 渲染分隔线
    const separatorRow = this.terminal.height - 5;
    for (let col = 0; col < this.terminal.width; col++) {
      buffer.setCell(separatorRow, col, { char: '─', fg: 8 });
    }

    // 渲染编辑器
    const editorContent = this.editor.render({
      width: this.terminal.width,
      height: 3,
      focused: true
    });

    const editorLines = editorContent.content.split('\n');
    editorLines.forEach((line, i) => {
      const row = separatorRow + 1 + i;
      for (let col = 0; col < Math.min(line.length, this.terminal.width); col++) {
        buffer.setCell(row, col, { char: line[col] || ' ' });
      }
    });

    // 渲染 Widgets
    const widgetOutput = this.widgetManager.render({
      width: this.terminal.width,
      height: this.terminal.height,
      focused: false
    });

    // 应用渲染
    this.renderer.render(buffer);

    // 输出 Widgets (在差分渲染之后)
    if (widgetOutput) {
      process.stdout.write(widgetOutput);
    }
  }

  private cleanup(): void {
    process.stdout.write('\x1b[?25h');  // 显示光标
    process.stdout.write('\x1b[2J\x1b[H');  // 清屏
  }
}
```

### 4. Widget 实现

```typescript
// widgets.ts
import { BaseWidget } from './base-widget';
import { RenderContext, OverlayPosition } from './types';

export class StatusBar extends BaseWidget {
  private status: string = '';

  constructor(position: OverlayPosition) {
    super(position);
  }

  setStatus(status: string): void {
    this.status = status;
  }

  render(ctx: RenderContext): string {
    if (!this.visible) return '';
    return `\x1b[44m\x1b[37m ${this.status.padEnd(ctx.width - 2)} \x1b[0m`;
  }

  getSize(): { width: number; height: number } {
    return { width: 80, height: 1 };
  }
}

export class LoadingSpinner extends BaseWidget {
  private frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
  private currentFrame = 0;
  private interval?: NodeJS.Timeout;

  constructor(position: OverlayPosition) {
    super(position);
  }

  show(): void {
    super.show();
    this.startAnimation();
  }

  hide(): void {
    super.hide();
    this.stopAnimation();
  }

  private startAnimation(): void {
    this.interval = setInterval(() => {
      this.currentFrame = (this.currentFrame + 1) % this.frames.length;
    }, 80);
  }

  private stopAnimation(): void {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = undefined;
    }
  }

  render(ctx: RenderContext): string {
    if (!this.visible) return '';
    return `\x1b[33m${this.frames[this.currentFrame]} Loading...\x1b[0m`;
  }

  getSize(): { width: number; height: number } {
    return { width: 12, height: 1 };
  }
}

export class ErrorNotification extends BaseWidget {
  private message: string = '';
  private autoHideTimer?: NodeJS.Timeout;

  constructor(position: OverlayPosition) {
    super(position);
    this.visible = false;
  }

  show(message: string, duration: number = 3000): void {
    this.message = message;
    super.show();

    if (this.autoHideTimer) {
      clearTimeout(this.autoHideTimer);
    }

    this.autoHideTimer = setTimeout(() => {
      this.hide();
    }, duration);
  }

  render(ctx: RenderContext): string {
    if (!this.visible) return '';

    const border = '─'.repeat(this.message.length + 4);
    return `\x1b[31m┌${border}┐\n│ ✗ ${this.message} │\n└${border}┘\x1b[0m`;
  }

  getSize(): { width: number; height: number } {
    return {
      width: this.message.length + 6,
      height: 3
    };
  }
}
```

### 5. 主入口

```typescript
// index.ts
import { ChatApplication } from './chat-application';

async function main() {
  const app = new ChatApplication();

  // 处理退出信号
  process.on('SIGINT', () => {
    process.stdout.write('\x1b[?25h\x1b[2J\x1b[H');
    process.exit(0);
  });

  await app.start();
}

main().catch(error => {
  console.error('Application error:', error);
  process.exit(1);
});
```

---

## 运行应用

### 项目设置

```bash
mkdir terminal-chat
cd terminal-chat
npm init -y
npm install --save-dev typescript @types/node

cat > tsconfig.json << 'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true
  }
}
EOF
```

### 编译和运行

```bash
npx tsc
node dist/index.js
```

### 使用说明

**键盘快捷键**:
- `Enter`: 换行
- `Ctrl+Enter`: 发送消息
- `Ctrl+C`: 退出应用
- `↑/↓/←/→`: 光标移动
- `Backspace`: 删除字符

---

## 扩展想法

### 1. 添加命令系统

```typescript
class CommandHandler {
  private commands = new Map<string, (args: string[]) => void>();

  register(name: string, handler: (args: string[]) => void): void {
    this.commands.set(name, handler);
  }

  execute(input: string): boolean {
    if (!input.startsWith('/')) return false;

    const [command, ...args] = input.slice(1).split(' ');
    const handler = this.commands.get(command);

    if (handler) {
      handler(args);
      return true;
    }

    return false;
  }
}

// 使用
commandHandler.register('clear', () => {
  this.state.messages = [];
  this.render();
});

commandHandler.register('help', () => {
  this.addMessage({
    role: 'assistant',
    content: 'Available commands:\n/clear - Clear chat history\n/help - Show this message'
  });
});
```

### 2. 添加消息搜索

```typescript
class MessageSearch {
  search(messages: Message[], query: string): Message[] {
    return messages.filter(msg =>
      msg.content.toLowerCase().includes(query.toLowerCase())
    );
  }

  highlight(content: string, query: string): string {
    const regex = new RegExp(`(${query})`, 'gi');
    return content.replace(regex, '\x1b[43m$1\x1b[0m');
  }
}
```

### 3. 添加主题系统

```typescript
interface Theme {
  userColor: string;
  assistantColor: string;
  backgroundColor: string;
  borderColor: string;
}

const themes = {
  dark: {
    userColor: '\x1b[36m',
    assistantColor: '\x1b[32m',
    backgroundColor: '\x1b[40m',
    borderColor: '\x1b[90m'
  },
  light: {
    userColor: '\x1b[34m',
    assistantColor: '\x1b[32m',
    backgroundColor: '\x1b[47m',
    borderColor: '\x1b[37m'
  }
};
```

---

## 总结

### 核心实现

**1. 应用架构**: 清晰的组件分层
**2. 状态管理**: 集中式状态管理
**3. 事件处理**: 键盘输入处理
**4. 差分渲染**: 高性能渲染
**5. Widget 系统**: 丰富的 UI 组件

### 关键技术

**1. 组件集成**: 多个组件协同工作
**2. 异步处理**: API 调用和加载状态
**3. 错误处理**: 优雅的错误提示
**4. 用户体验**: 流畅的交互

### 学到的经验

**1. 架构设计**: 模块化、可扩展
**2. 状态管理**: 单一数据源
**3. 性能优化**: 差分渲染 + Widget
**4. 用户体验**: 反馈 + 动画

### 下一步

- **性能优化**: 阅读 **07_实战代码_05_性能优化实战.md**
- **实战练习**: 添加更多功能
- **源码参考**: `sourcecode/pi-mono/packages/tui/test/chat-simple.ts`

---

**记住**: 复杂应用的关键是良好的架构设计和清晰的组件边界！

---

**版本**: v1.0
**最后更新**: 2026-02-21
**维护者**: Claude Code
