# 最小可用

## 核心目标

**5分钟内实现一个可用的队列系统，能够处理AI Agent的基本任务调度需求。**

---

## 最简单的FIFO队列

### Python内置队列（推荐新手）

```python
from queue import Queue

# 创建队列
task_queue = Queue()

# 入队
task_queue.put("任务1")
task_queue.put("任务2")
task_queue.put("任务3")

# 出队
task = task_queue.get()
print(task)  # "任务1"

# 检查是否为空
is_empty = task_queue.empty()
print(is_empty)  # False

# 获取队列大小
size = task_queue.qsize()
print(size)  # 2
```

**优点**：
- 线程安全，可用于多线程环境
- 内置阻塞机制，`get()`会等待直到有元素

**缺点**：
- 不支持异步(async/await)
- 无法查看队列内容

---

## 最简单的异步队列

### asyncio.Queue（推荐AI Agent开发）

```python
import asyncio

async def producer(queue):
    """生产者：添加任务到队列"""
    for i in range(5):
        await queue.put(f"任务{i}")
        print(f"添加: 任务{i}")
        await asyncio.sleep(0.1)

async def consumer(queue):
    """消费者：从队列取出任务并处理"""
    while True:
        task = await queue.get()
        print(f"处理: {task}")
        await asyncio.sleep(0.2)
        queue.task_done()

async def main():
    queue = asyncio.Queue()

    # 启动生产者和消费者
    await asyncio.gather(
        producer(queue),
        consumer(queue)
    )

# 运行
asyncio.run(main())
```

**输出**：
```
添加: 任务0
处理: 任务0
添加: 任务1
添加: 任务2
处理: 任务1
添加: 任务3
添加: 任务4
处理: 任务2
处理: 任务3
处理: 任务4
```

**为什么用异步队列？**
- AI Agent通常需要调用LLM API（I/O密集型）
- 异步队列可以在等待API响应时处理其他任务
- 提高并发性能

---

## 最简单的优先级队列

### heapq实现（5行代码）

```python
import heapq

# 创建优先级队列
pq = []

# 入队：(优先级, 任务)
heapq.heappush(pq, (3, "低优先级任务"))
heapq.heappush(pq, (1, "高优先级任务"))
heapq.heappush(pq, (2, "中优先级任务"))

# 出队：优先级最小的先出
priority, task = heapq.heappop(pq)
print(f"优先级{priority}: {task}")  # 优先级1: 高优先级任务

priority, task = heapq.heappop(pq)
print(f"优先级{priority}: {task}")  # 优先级2: 中优先级任务
```

**关键点**：
- 数字越小，优先级越高
- 自动维护堆结构，无需手动排序

---

## AI Agent任务调度最小示例

### 场景：限流的LLM API调用队列

```python
import asyncio
from typing import List

class RateLimitedQueue:
    """限流队列：每秒最多处理N个任务"""

    def __init__(self, rate_limit: int = 10):
        self.queue = asyncio.Queue()
        self.rate_limit = rate_limit
        self.interval = 1.0 / rate_limit

    async def add_task(self, task):
        """添加任务到队列"""
        await self.queue.put(task)

    async def process(self):
        """处理队列中的任务"""
        while True:
            task = await self.queue.get()
            await self._execute(task)
            await asyncio.sleep(self.interval)  # 限流
            self.queue.task_done()

    async def _execute(self, task):
        """执行单个任务（模拟LLM API调用）"""
        print(f"执行任务: {task}")
        await asyncio.sleep(0.1)  # 模拟API调用

# 使用示例
async def main():
    queue = RateLimitedQueue(rate_limit=5)  # 每秒5个请求

    # 启动消费者
    asyncio.create_task(queue.process())

    # 添加任务
    for i in range(10):
        await queue.add_task(f"LLM请求{i}")

    # 等待所有任务完成
    await queue.queue.join()

asyncio.run(main())
```

**输出**（每秒5个）：
```
执行任务: LLM请求0
执行任务: LLM请求1
执行任务: LLM请求2
执行任务: LLM请求3
执行任务: LLM请求4
[等待0.2秒]
执行任务: LLM请求5
...
```

---

## 快速选择指南

### 何时使用哪种队列？

| 场景 | 推荐队列 | 代码 |
|------|----------|------|
| 多线程任务调度 | `queue.Queue` | `from queue import Queue` |
| 异步I/O任务 | `asyncio.Queue` | `import asyncio` |
| 任务有优先级 | `heapq` | `import heapq` |
| 简单FIFO | `collections.deque` | `from collections import deque` |

### 一句话决策

- **同步 + 多线程** → `queue.Queue`
- **异步 + 单线程** → `asyncio.Queue`
- **需要优先级** → `heapq`
- **简单场景** → `list` 或 `deque`

---

## 常见错误与修复

### 错误1：忘记task_done()

```python
# ❌ 错误：queue.join()永远不会结束
async def consumer(queue):
    while True:
        task = await queue.get()
        await process(task)
        # 忘记调用 task_done()

# ✅ 正确
async def consumer(queue):
    while True:
        task = await queue.get()
        await process(task)
        queue.task_done()  # 必须调用
```

### 错误2：混用同步和异步队列

```python
# ❌ 错误：在异步函数中使用同步队列
async def worker():
    from queue import Queue
    q = Queue()
    q.get()  # 会阻塞整个事件循环

# ✅ 正确：使用异步队列
async def worker():
    q = asyncio.Queue()
    await q.get()  # 不会阻塞事件循环
```

### 错误3：优先级队列忘记元组

```python
# ❌ 错误：直接push任务
heapq.heappush(pq, "任务")  # 无法比较字符串

# ✅ 正确：使用(优先级, 任务)元组
heapq.heappush(pq, (1, "任务"))
```

---

## 5分钟实战：构建AI Agent任务队列

### 需求
- 支持异步任务
- 限流：每秒最多10个请求
- 优先级：紧急任务优先

### 完整代码

```python
import asyncio
import heapq
from dataclasses import dataclass, field
from typing import Any

@dataclass(order=True)
class PriorityTask:
    priority: int
    task: Any = field(compare=False)

class AgentTaskQueue:
    def __init__(self, rate_limit: int = 10):
        self.queue = asyncio.PriorityQueue()
        self.rate_limit = rate_limit
        self.interval = 1.0 / rate_limit

    async def add_task(self, task: str, priority: int = 5):
        """添加任务（优先级1-10，1最高）"""
        await self.queue.put(PriorityTask(priority, task))

    async def process(self):
        """处理任务"""
        while True:
            priority_task = await self.queue.get()
            await self._execute(priority_task.task)
            await asyncio.sleep(self.interval)
            self.queue.task_done()

    async def _execute(self, task):
        """执行任务（模拟LLM调用）"""
        print(f"执行: {task}")
        await asyncio.sleep(0.1)

# 使用
async def main():
    queue = AgentTaskQueue(rate_limit=5)

    # 启动处理器
    asyncio.create_task(queue.process())

    # 添加任务
    await queue.add_task("普通任务1", priority=5)
    await queue.add_task("紧急任务", priority=1)
    await queue.add_task("普通任务2", priority=5)

    await queue.queue.join()

asyncio.run(main())
```

**输出**：
```
执行: 紧急任务      # 优先级1先执行
执行: 普通任务1     # 优先级5
执行: 普通任务2     # 优先级5
```

---

## 下一步

### 已掌握
✅ 基本队列操作（入队、出队）
✅ 异步队列使用
✅ 优先级队列实现
✅ 限流队列设计

### 继续学习
- **第一性原理** → 理解队列为什么存在
- **核心概念** → 深入FIFO、优先级、循环队列
- **实战代码** → 分布式队列、生产级实践

---

## 记忆卡片

### 队列三要素
1. **入队(enqueue)**：添加元素到队尾
2. **出队(dequeue)**：移除队首元素
3. **查看(peek)**：查看队首元素但不移除

### 选择决策树
```
需要优先级？
├─ 是 → heapq 或 asyncio.PriorityQueue
└─ 否 → 需要异步？
    ├─ 是 → asyncio.Queue
    └─ 否 → queue.Queue 或 deque
```

### 关键API对比

| 操作 | queue.Queue | asyncio.Queue | heapq |
|------|-------------|---------------|-------|
| 入队 | `put(item)` | `await put(item)` | `heappush(heap, item)` |
| 出队 | `get()` | `await get()` | `heappop(heap)` |
| 大小 | `qsize()` | `qsize()` | `len(heap)` |
| 空检查 | `empty()` | `empty()` | `not heap` |

---

**关键洞察**：最小可用不是最简陋，而是用最少代码解决80%的问题。在AI Agent开发中，`asyncio.Queue` + 限流机制就能满足大部分需求。
