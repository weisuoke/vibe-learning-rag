# 核心概念5：设计模式

## 概述

管道操作符体现了多种经典设计模式，理解这些模式有助于更好地使用和扩展 LangChain。

**一句话定义**：管道操作符融合了函数组合、管道模式、责任链模式等多种设计模式，提供声明式的组件编排能力。

---

## 1. 函数组合模式（Function Composition）

### 1.1 数学基础

**函数组合**：将多个函数组合成一个新函数

```
f: A → B
g: B → C
g ∘ f: A → C

(g ∘ f)(x) = g(f(x))
```

### 1.2 在 LangChain 中的实现

```python
# 数学表示
# parser ∘ model ∘ prompt

# LangChain 实现
chain = prompt | model | parser

# 等价于
def composed(input):
    return parser(model(prompt(input)))
```

### 1.3 函数组合的特性

**结合律**：
```python
# (f | g) | h = f | (g | h)
chain1 = (prompt | model) | parser
chain2 = prompt | (model | parser)
# chain1 和 chain2 等价
```

**单位元**：
```python
from langchain_core.runnables import RunnablePassthrough

# identity | f = f | identity = f
chain = RunnablePassthrough() | processor
# 等价于
chain = processor
```

### 1.4 在 AI Agent 中的应用

```python
# 组合多个小函数成为复杂功能
preprocess = normalize | tokenize | embed
postprocess = parse | validate | format

# 完整流程
pipeline = preprocess | model | postprocess
```

---

## 2. 管道模式（Pipeline Pattern）

### 2.1 模式定义

**管道模式**：将数据处理分解为一系列独立的阶段，每个阶段处理数据并传递给下一个阶段。

**特点**：
- 每个阶段独立
- 数据单向流动
- 可以插入/删除阶段

### 2.2 Unix 管道的启发

```bash
# Unix 管道
cat file.txt | grep "error" | wc -l

# LangChain 管道
chain = loader | filter | counter
```

### 2.3 管道的优势

```python
# ✅ 好：管道模式
chain = (
    load_data
    | clean_data
    | transform_data
    | validate_data
    | save_data
)

# ❌ 差：命令式
data = load_data()
data = clean_data(data)
data = transform_data(data)
data = validate_data(data)
save_data(data)
```

**优势**：
1. **声明式**：描述"做什么"而非"怎么做"
2. **可组合**：可以轻松重组管道
3. **可测试**：每个阶段可独立测试
4. **可扩展**：插入新阶段不影响其他代码

### 2.4 在 AI Agent 中的应用

```python
# RAG 管道
rag_pipeline = (
    query_understanding    # 阶段1: 理解查询
    | retrieval           # 阶段2: 检索文档
    | reranking           # 阶段3: 重排序
    | context_building    # 阶段4: 构建上下文
    | generation          # 阶段5: 生成答案
    | post_processing     # 阶段6: 后处理
)
```

---

## 3. 责任链模式（Chain of Responsibility）

### 3.1 模式定义

**责任链模式**：将请求沿着处理者链传递，直到某个处理者处理它。

**特点**：
- 请求者不知道哪个处理者会处理请求
- 处理者可以决定是否传递请求
- 动态组合处理者链

### 3.2 在 LangChain 中的体现

```python
# 每个 Runnable 都是一个处理者
chain = handler1 | handler2 | handler3

# 请求沿着链传递
result = chain.invoke(request)

# 执行流程:
# request → handler1 → handler2 → handler3 → result
```

### 3.3 条件责任链

```python
from langchain_core.runnables import RunnableBranch

# 根据条件选择处理者
conditional_chain = RunnableBranch(
    (is_simple, simple_handler),    # 简单请求
    (is_complex, complex_handler),  # 复杂请求
    default_handler                  # 默认处理
)

# 请求会被路由到合适的处理者
```

### 3.4 在 AI Agent 中的应用

```python
# 多级处理链
agent_chain = (
    input_validator      # 验证输入
    | cache_checker      # 检查缓存
    | rate_limiter       # 限流
    | model              # 调用模型
    | output_validator   # 验证输出
    | cache_saver        # 保存缓存
)

# 每个处理者可以决定是否继续
```

---

## 4. 装饰器模式（Decorator Pattern）

### 4.1 模式定义

**装饰器模式**：动态地给对象添加额外的职责，而不改变其接口。

### 4.2 在 LangChain 中的实现

```python
from langchain_core.runnables import RunnableLambda

def with_logging(runnable):
    """添加日志功能"""
    def log_invoke(input):
        print(f"输入: {input}")
        result = runnable.invoke(input)
        print(f"输出: {result}")
        return result
    return RunnableLambda(log_invoke)

def with_retry(runnable, max_retries=3):
    """添加重试功能"""
    def retry_invoke(input):
        for i in range(max_retries):
            try:
                return runnable.invoke(input)
            except Exception as e:
                if i == max_retries - 1:
                    raise
                print(f"重试 {i+1}/{max_retries}")
        return None
    return RunnableLambda(retry_invoke)

# 使用装饰器
chain = (
    prompt
    | with_logging(model)           # 添加日志
    | with_retry(parser, max_retries=3)  # 添加重试
)
```

### 4.3 在 AI Agent 中的应用

```python
# 为 LLM 调用添加多个装饰器
enhanced_model = (
    with_caching(
        with_rate_limiting(
            with_cost_tracking(
                with_logging(model)
            )
        )
    )
)

chain = prompt | enhanced_model | parser
```

---

## 5. 策略模式（Strategy Pattern）

### 5.1 模式定义

**策略模式**：定义一系列算法，将每个算法封装起来，并使它们可以互换。

### 5.2 在 LangChain 中的实现

```python
# 定义多个策略
simple_strategy = simple_prompt | fast_model | parser
complex_strategy = detailed_prompt | powerful_model | parser
balanced_strategy = balanced_prompt | balanced_model | parser

# 根据条件选择策略
def select_strategy(input):
    if len(input) < 10:
        return simple_strategy
    elif len(input) < 100:
        return balanced_strategy
    else:
        return complex_strategy

# 使用
strategy = select_strategy(user_input)
result = strategy.invoke(user_input)
```

### 5.3 动态策略切换

```python
from langchain_core.runnables import RunnableBranch

# 动态选择策略
adaptive_chain = RunnableBranch(
    (lambda x: len(x) < 10, simple_strategy),
    (lambda x: len(x) < 100, balanced_strategy),
    complex_strategy
)

result = adaptive_chain.invoke(user_input)
```

### 5.4 在 AI Agent 中的应用

```python
# 根据任务类型选择不同的处理策略
task_router = RunnableBranch(
    (is_translation_task, translation_chain),
    (is_summarization_task, summarization_chain),
    (is_qa_task, qa_chain),
    default_chain
)
```

---

## 6. 建造者模式（Builder Pattern）

### 6.1 模式定义

**建造者模式**：将复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。

### 6.2 在 LangChain 中的实现

```python
class ChainBuilder:
    """链构建器"""

    def __init__(self):
        self.steps = []

    def add_prompt(self, template):
        self.steps.append(ChatPromptTemplate.from_template(template))
        return self

    def add_model(self, model_name):
        self.steps.append(ChatOpenAI(model=model_name))
        return self

    def add_parser(self):
        self.steps.append(StrOutputParser())
        return self

    def add_validator(self, validator):
        self.steps.append(validator)
        return self

    def build(self):
        """构建最终的链"""
        chain = self.steps[0]
        for step in self.steps[1:]:
            chain = chain | step
        return chain

# 使用建造者
chain = (
    ChainBuilder()
    .add_prompt("讲个笑话")
    .add_model("gpt-4o-mini")
    .add_parser()
    .add_validator(length_validator)
    .build()
)
```

### 6.3 在 AI Agent 中的应用

```python
class RAGChainBuilder:
    """RAG 链构建器"""

    def __init__(self):
        self.retriever = None
        self.prompt = None
        self.model = None
        self.parser = None

    def with_retriever(self, retriever):
        self.retriever = retriever
        return self

    def with_prompt(self, template):
        self.prompt = ChatPromptTemplate.from_template(template)
        return self

    def with_model(self, model):
        self.model = model
        return self

    def with_parser(self, parser):
        self.parser = parser
        return self

    def build(self):
        """构建 RAG 链"""
        return (
            {
                "context": self.retriever,
                "question": RunnablePassthrough()
            }
            | self.prompt
            | self.model
            | self.parser
        )

# 使用
rag_chain = (
    RAGChainBuilder()
    .with_retriever(vector_store.as_retriever())
    .with_prompt("基于上下文回答：{context}\n\n问题：{question}")
    .with_model(ChatOpenAI(model="gpt-4o-mini"))
    .with_parser(StrOutputParser())
    .build()
)
```

---

## 7. 组合模式（Composite Pattern）

### 7.1 模式定义

**组合模式**：将对象组合成树形结构以表示"部分-整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

### 7.2 在 LangChain 中的体现

```python
# 单个 Runnable（叶子节点）
prompt = ChatPromptTemplate.from_template("test")
model = ChatOpenAI()
parser = StrOutputParser()

# 组合 Runnable（组合节点）
sub_chain = prompt | model
full_chain = sub_chain | parser

# 两者都实现 Runnable 接口，使用方式一致
result1 = prompt.invoke(input)      # 叶子节点
result2 = full_chain.invoke(input)  # 组合节点
```

### 7.3 树形结构

```python
# 构建树形结构
preprocessing = normalize | tokenize
processing = model | parser
postprocessing = validate | format

# 组合成完整流程
pipeline = preprocessing | processing | postprocessing

# 树形结构:
#         pipeline
#        /    |    \
#   preproc  proc  postproc
#    /  \    /  \    /  \
#  norm tok mod par val fmt
```

### 7.4 在 AI Agent 中的应用

```python
# 复杂的组合结构
retrieval_chain = (
    query_expansion
    | RunnableParallel(
        vector=vector_retriever,
        keyword=keyword_retriever
    )
    | merge_results
)

generation_chain = (
    prompt_builder
    | model
    | parser
)

# 组合成完整的 RAG 系统
rag_system = (
    {
        "context": retrieval_chain,  # 组合节点
        "question": RunnablePassthrough()
    }
    | generation_chain  # 组合节点
)
```

---

## 8. 模板方法模式（Template Method Pattern）

### 8.1 模式定义

**模板方法模式**：定义算法的骨架，将某些步骤延迟到子类中实现。

### 8.2 在 LangChain 中的实现

```python
from langchain_core.runnables import Runnable

class BaseProcessor(Runnable):
    """处理器基类（模板）"""

    def invoke(self, input):
        """模板方法"""
        # 步骤1: 预处理（子类可重写）
        input = self.preprocess(input)

        # 步骤2: 核心处理（子类必须实现）
        result = self.process(input)

        # 步骤3: 后处理（子类可重写）
        result = self.postprocess(result)

        return result

    def preprocess(self, input):
        """预处理（钩子方法）"""
        return input

    def process(self, input):
        """核心处理（抽象方法）"""
        raise NotImplementedError

    def postprocess(self, result):
        """后处理（钩子方法）"""
        return result

# 具体实现
class TextProcessor(BaseProcessor):
    def process(self, input):
        return input.upper()

class NumberProcessor(BaseProcessor):
    def preprocess(self, input):
        return int(input)

    def process(self, input):
        return input * 2

# 使用
text_chain = TextProcessor() | next_step
number_chain = NumberProcessor() | next_step
```

---

## 9. 观察者模式（Observer Pattern）

### 9.1 模式定义

**观察者模式**：定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会收到通知。

### 9.2 在 LangChain 中的实现（回调系统）

```python
from langchain.callbacks.base import BaseCallbackHandler

class LoggingObserver(BaseCallbackHandler):
    """日志观察者"""

    def on_chain_start(self, serialized, inputs, **kwargs):
        print(f"链开始: {inputs}")

    def on_chain_end(self, outputs, **kwargs):
        print(f"链结束: {outputs}")

class MetricsObserver(BaseCallbackHandler):
    """指标观察者"""

    def __init__(self):
        self.call_count = 0
        self.total_time = 0

    def on_llm_start(self, serialized, prompts, **kwargs):
        self.start_time = time.time()

    def on_llm_end(self, response, **kwargs):
        self.call_count += 1
        self.total_time += time.time() - self.start_time

# 注册多个观察者
chain = prompt | model | parser

result = chain.invoke(
    input,
    config={
        "callbacks": [
            LoggingObserver(),
            MetricsObserver()
        ]
    }
)
```

### 9.3 在 AI Agent 中的应用

```python
# 监控 Agent 执行
class AgentMonitor(BaseCallbackHandler):
    """Agent 监控器"""

    def on_tool_start(self, serialized, input_str, **kwargs):
        print(f"工具调用: {serialized['name']}")

    def on_tool_end(self, output, **kwargs):
        print(f"工具输出: {output}")

    def on_agent_action(self, action, **kwargs):
        print(f"Agent 动作: {action}")

agent_chain = agent_executor

result = agent_chain.invoke(
    input,
    config={"callbacks": [AgentMonitor()]}
)
```

---

## 10. 适配器模式（Adapter Pattern）

### 10.1 模式定义

**适配器模式**：将一个类的接口转换成客户希望的另一个接口，使得原本不兼容的类可以一起工作。

### 10.2 在 LangChain 中的实现

```python
from langchain_core.runnables import RunnableLambda

# 旧接口
def old_function(text: str) -> str:
    return text.upper()

# 新接口（Runnable）
class NewInterface(Runnable):
    def invoke(self, input: dict) -> dict:
        return {"result": input["text"].upper()}

# 适配器：将旧接口适配到新接口
def adapt_old_to_new(func):
    """适配器函数"""
    def wrapper(input: dict) -> dict:
        text = input["text"]
        result = func(text)
        return {"result": result}
    return RunnableLambda(wrapper)

# 使用适配器
adapted_function = adapt_old_to_new(old_function)

chain = prompt | adapted_function | parser
```

### 10.3 在 AI Agent 中的应用

```python
# 适配第三方 API
def adapt_external_api(api_function):
    """适配外部 API 到 Runnable 接口"""
    def wrapper(input):
        # 转换输入格式
        api_input = {
            "query": input["question"],
            "max_results": 5
        }

        # 调用外部 API
        api_response = api_function(api_input)

        # 转换输出格式
        return {
            "results": api_response["data"],
            "count": len(api_response["data"])
        }

    return RunnableLambda(wrapper)

# 使用
external_search = adapt_external_api(third_party_search_api)

chain = (
    query_builder
    | external_search  # 适配后的外部 API
    | result_processor
)
```

---

## 11. 设计模式总结

### 11.1 模式对照表

| 设计模式 | LangChain 体现 | 核心价值 | 使用场景 |
|----------|----------------|----------|----------|
| **函数组合** | `a \| b \| c` | 组合小函数成大函数 | 所有管道 |
| **管道模式** | RunnableSequence | 数据单向流动 | 数据处理流程 |
| **责任链** | 请求沿链传递 | 动态处理请求 | 多级处理 |
| **装饰器** | 包装 Runnable | 添加额外功能 | 日志、重试、缓存 |
| **策略** | RunnableBranch | 算法可互换 | 条件路由 |
| **建造者** | ChainBuilder | 分步构建复杂对象 | 复杂链构建 |
| **组合** | 嵌套 Runnable | 树形结构 | 复杂组合 |
| **模板方法** | BaseProcessor | 定义算法骨架 | 自定义处理器 |
| **观察者** | 回调系统 | 事件通知 | 监控、日志 |
| **适配器** | RunnableLambda | 接口转换 | 集成第三方 |

### 11.2 模式组合使用

```python
# 组合多种模式
chain = (
    # 适配器模式：适配输入
    adapt_input
    # 装饰器模式：添加日志
    | with_logging(
        # 策略模式：根据条件选择
        RunnableBranch(
            (is_simple, simple_chain),
            (is_complex, complex_chain),
            default_chain
        )
    )
    # 装饰器模式：添加缓存
    | with_caching(
        # 管道模式：数据处理流程
        preprocessor | model | postprocessor
    )
    # 适配器模式：适配输出
    | adapt_output
)

# 观察者模式：监控执行
result = chain.invoke(
    input,
    config={"callbacks": [monitor]}
)
```

---

## 12. 在 AI Agent 中的综合应用

### 12.1 完整的 RAG 系统

```python
# 组合多种设计模式
rag_system = (
    # 适配器：适配用户输入
    input_adapter
    # 装饰器：添加日志
    | with_logging(
        # 策略：根据查询类型选择检索策略
        RunnableBranch(
            (is_factual_query, factual_retrieval),
            (is_opinion_query, opinion_retrieval),
            default_retrieval
        )
    )
    # 管道：构建上下文
    | {
        "context": (
            # 组合：多源检索
            RunnableParallel(
                vector=vector_retriever,
                keyword=keyword_retriever
            )
            | merge_and_rerank
        ),
        "question": RunnablePassthrough()
    }
    # 管道：生成答案
    | prompt
    | with_retry(model, max_retries=3)  # 装饰器：重试
    | parser
    # 责任链：后处理
    | fact_checker
    | citation_adder
    | formatter
)

# 观察者：监控
result = rag_system.invoke(
    query,
    config={"callbacks": [metrics_collector, logger]}
)
```

---

## 13. 学习检查

完成本节后，检查是否掌握：

- [ ] 理解函数组合模式在管道中的体现
- [ ] 掌握管道模式的特点和优势
- [ ] 理解责任链模式的应用场景
- [ ] 能使用装饰器模式添加额外功能
- [ ] 掌握策略模式实现条件路由
- [ ] 理解建造者模式构建复杂链
- [ ] 能识别和应用多种设计模式

---

[Source: LangChain Official Docs - https://python.langchain.com/docs/concepts/]
[Source: DZone Architecture Guide - https://dzone.com/articles/guide-to-langchain-runnable-architecture]
