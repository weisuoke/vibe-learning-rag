# 实战代码 2：复杂场景

展示嵌套结构、Union 类型、条件字段等复杂场景的完整可运行代码。

---

## 场景 1：嵌套 Pydantic 模型

```python
"""
场景：提取公司信息（包含嵌套的地址和员工）
方法：嵌套 Pydantic 模型
"""

import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field
from typing import List

load_dotenv()

print("=== 场景 1：嵌套 Pydantic 模型 ===\n")

# 1. 定义嵌套模型
class Address(BaseModel):
    street: str = Field(description="街道地址")
    city: str = Field(description="城市")
    country: str = Field(description="国家")

class Employee(BaseModel):
    name: str = Field(description="员工姓名")
    position: str = Field(description="职位")
    salary: float = Field(description="薪资", gt=0)

class Company(BaseModel):
    name: str = Field(description="公司名称")
    address: Address = Field(description="公司地址")
    employees: List[Employee] = Field(description="员工列表")
    founded_year: int = Field(description="成立年份", ge=1800, le=2026)

# 2. 创建结构化 LLM
llm = ChatOpenAI(model="gpt-4o", temperature=0)
structured_llm = llm.with_structured_output(Company)

# 3. 测试复杂输入
text = """
TechCorp 是一家科技公司，位于北京市海淀区中关村大街1号，中国。
公司成立于 2010 年。
员工包括：
- 张三，CEO，年薪 500000
- 李四，CTO，年薪 400000
- 王五，工程师，年薪 200000
"""

print(f"输入文本:\n{text}\n")
result = structured_llm.invoke(f"从以下文本提取公司信息：\n{text}")

print(f"输出:\n{result}\n")
print("详细信息:")
print(f"  公司名称: {result.name}")
print(f"  地址: {result.address.city}, {result.address.country}")
print(f"  成立年份: {result.founded_year}")
print(f"  员工数量: {len(result.employees)}")
for emp in result.employees:
    print(f"    - {emp.name} ({emp.position}): ¥{emp.salary:,.0f}")
print()

# 预期输出：
# Company(
#     name='TechCorp',
#     address=Address(street='中关村大街1号', city='北京市海淀区', country='中国'),
#     employees=[
#         Employee(name='张三', position='CEO', salary=500000.0),
#         Employee(name='李四', position='CTO', salary=400000.0),
#         Employee(name='王五', position='工程师', salary=200000.0)
#     ],
#     founded_year=2010
# )
```

---

## 场景 2：Union 类型（多种响应类型）

```python
"""
场景：API 响应可能是成功或失败
方法：Union 类型
"""

print("=== 场景 2：Union 类型 ===\n")

from typing import Union, Literal

class SuccessResponse(BaseModel):
    status: Literal["success"] = "success"
    data: dict = Field(description="响应数据")
    message: str = Field(description="成功消息")

class ErrorResponse(BaseModel):
    status: Literal["error"] = "error"
    error_code: str = Field(description="错误代码")
    error_message: str = Field(description="错误消息")

# Union 类型
APIResponse = Union[SuccessResponse, ErrorResponse]

# 注意：with_structured_output 不直接支持 Union
# 需要使用 PydanticOutputParser
from langchain.output_parsers import PydanticOutputParser
from langchain.prompts import PromptTemplate

# 创建一个包装模型
class ResponseWrapper(BaseModel):
    response: Union[SuccessResponse, ErrorResponse] = Field(
        description="API 响应（成功或失败）"
    )

parser = PydanticOutputParser(pydantic_object=ResponseWrapper)
prompt = PromptTemplate(
    template="解析以下 API 响应：{text}\n\n{format_instructions}",
    input_variables=["text"],
    partial_variables={"format_instructions": parser.get_format_instructions()}
)

chain = prompt | llm | parser

# 测试成功响应
success_text = "API 调用成功，返回用户数据：{'user_id': 123, 'name': 'Alice'}"
print(f"输入: {success_text}")
result = chain.invoke({"text": success_text})
print(f"输出: {result.response}")
print(f"类型: {type(result.response).__name__}\n")

# 测试失败响应
error_text = "API 调用失败，错误代码 404，错误消息：用户不存在"
print(f"输入: {error_text}")
result = chain.invoke({"text": error_text})
print(f"输出: {result.response}")
print(f"类型: {type(result.response).__name__}\n")

# 预期输出：
# 输入: API 调用成功...
# 输出: SuccessResponse(status='success', data={'user_id': 123, 'name': 'Alice'}, message='...')
# 类型: SuccessResponse
#
# 输入: API 调用失败...
# 输出: ErrorResponse(status='error', error_code='404', error_message='用户不存在')
# 类型: ErrorResponse
```

---

## 场景 3：条件字段验证

```python
"""
场景：根据用户类型验证不同字段
方法：Pydantic 验证器
"""

print("=== 场景 3：条件字段验证 ===\n")

from pydantic import field_validator, model_validator
from typing import Optional

class User(BaseModel):
    name: str = Field(description="用户名")
    user_type: Literal["student", "teacher", "admin"] = Field(description="用户类型")
    student_id: Optional[str] = Field(None, description="学号（学生必填）")
    employee_id: Optional[str] = Field(None, description="工号（教师和管理员必填）")
    grade: Optional[int] = Field(None, description="年级（学生必填）")

    @model_validator(mode='after')
    def validate_fields(self):
        """根据用户类型验证字段"""
        if self.user_type == "student":
            if not self.student_id:
                raise ValueError("学生必须提供学号")
            if not self.grade:
                raise ValueError("学生必须提供年级")
        elif self.user_type in ["teacher", "admin"]:
            if not self.employee_id:
                raise ValueError(f"{self.user_type} 必须提供工号")
        return self

structured_llm = llm.with_structured_output(User)

# 测试不同类型的用户
test_cases = [
    "张三，学生，学号 2021001，三年级",
    "李四，教师，工号 T001",
    "王五，管理员，工号 A001"
]

for text in test_cases:
    print(f"输入: {text}")
    try:
        result = structured_llm.invoke(f"提取用户信息：{text}")
        print(f"✅ 输出: {result}\n")
    except Exception as e:
        print(f"❌ 验证失败: {e}\n")

# 预期输出：
# 输入: 张三，学生，学号 2021001，三年级
# ✅ 输出: User(name='张三', user_type='student', student_id='2021001', employee_id=None, grade=3)
```

---

## 场景 4：递归嵌套结构

```python
"""
场景：组织架构树（递归嵌套）
方法：自引用 Pydantic 模型
"""

print("=== 场景 4：递归嵌套结构 ===\n")

from typing import Optional, List
from pydantic import BaseModel, Field

class Department(BaseModel):
    name: str = Field(description="部门名称")
    manager: str = Field(description="部门经理")
    sub_departments: Optional[List['Department']] = Field(
        None,
        description="子部门列表"
    )

# 更新前向引用
Department.model_rebuild()

structured_llm = llm.with_structured_output(Department)

text = """
公司组织架构：
- 技术部，经理：张三
  - 前端组，经理：李四
  - 后端组，经理：王五
    - API 组，经理：赵六
    - 数据库组，经理：钱七
- 市场部，经理：孙八
"""

print(f"输入:\n{text}\n")
result = structured_llm.invoke(f"提取组织架构：\n{text}")

def print_department(dept: Department, indent=0):
    """递归打印部门结构"""
    prefix = "  " * indent
    print(f"{prefix}- {dept.name} (经理: {dept.manager})")
    if dept.sub_departments:
        for sub in dept.sub_departments:
            print_department(sub, indent + 1)

print("输出:")
print_department(result)
print()

# 预期输出：
# - 技术部 (经理: 张三)
#   - 前端组 (经理: 李四)
#   - 后端组 (经理: 王五)
#     - API 组 (经理: 赵六)
#     - 数据库组 (经理: 钱七)
# - 市场部 (经理: 孙八)
```

---

## 场景 5：复杂验证规则

```python
"""
场景：订单信息（复杂业务规则验证）
方法：多个验证器
"""

print("=== 场景 5：复杂验证规则 ===\n")

from datetime import datetime
from pydantic import field_validator, model_validator

class OrderItem(BaseModel):
    product_name: str = Field(description="产品名称")
    quantity: int = Field(description="数量", gt=0)
    unit_price: float = Field(description="单价", gt=0)

    @property
    def total_price(self) -> float:
        return self.quantity * self.unit_price

class Order(BaseModel):
    order_id: str = Field(description="订单号")
    customer_name: str = Field(description="客户姓名")
    items: List[OrderItem] = Field(description="订单项列表")
    discount: float = Field(0, description="折扣", ge=0, le=1)
    order_date: str = Field(description="订单日期 (YYYY-MM-DD)")

    @field_validator('order_id')
    @classmethod
    def validate_order_id(cls, v):
        """验证订单号格式"""
        if not v.startswith('ORD-'):
            raise ValueError("订单号必须以 'ORD-' 开头")
        return v

    @field_validator('order_date')
    @classmethod
    def validate_date(cls, v):
        """验证日期格式"""
        try:
            datetime.strptime(v, '%Y-%m-%d')
        except ValueError:
            raise ValueError("日期格式必须是 YYYY-MM-DD")
        return v

    @model_validator(mode='after')
    def validate_order(self):
        """验证订单总金额"""
        if len(self.items) == 0:
            raise ValueError("订单至少要有一个商品")
        total = sum(item.total_price for item in self.items)
        if total < 10:
            raise ValueError("订单总金额不能低于 10 元")
        return self

    @property
    def subtotal(self) -> float:
        return sum(item.total_price for item in self.items)

    @property
    def total(self) -> float:
        return self.subtotal * (1 - self.discount)

structured_llm = llm.with_structured_output(Order)

text = """
订单信息：
订单号：ORD-20260218-001
客户：张三
订单日期：2026-02-18
商品：
1. Python 编程书，数量 2，单价 89.00
2. 鼠标，数量 1，单价 129.00
折扣：10%
"""

print(f"输入:\n{text}\n")
result = structured_llm.invoke(f"提取订单信息：\n{text}")

print(f"输出: {result}\n")
print("订单详情:")
print(f"  订单号: {result.order_id}")
print(f"  客户: {result.customer_name}")
print(f"  日期: {result.order_date}")
print(f"  商品:")
for item in result.items:
    print(f"    - {item.product_name}: {item.quantity} x ¥{item.unit_price} = ¥{item.total_price}")
print(f"  小计: ¥{result.subtotal:.2f}")
print(f"  折扣: {result.discount * 100:.0f}%")
print(f"  总计: ¥{result.total:.2f}")
print()

# 预期输出：
# 订单详情:
#   订单号: ORD-20260218-001
#   客户: 张三
#   日期: 2026-02-18
#   商品:
#     - Python 编程书: 2 x ¥89.0 = ¥178.0
#     - 鼠标: 1 x ¥129.0 = ¥129.0
#   小计: ¥307.00
#   折扣: 10%
#   总计: ¥276.30
```

---

## 场景 6：动态字段（额外属性）

```python
"""
场景：允许额外的未定义字段
方法：Pydantic extra='allow'
"""

print("=== 场景 6：动态字段 ===\n")

from pydantic import ConfigDict

class FlexiblePerson(BaseModel):
    model_config = ConfigDict(extra='allow')  # 允许额外字段

    name: str = Field(description="姓名")
    age: int = Field(description="年龄")
    # 其他字段会被保留在 __pydantic_extra__ 中

structured_llm = llm.with_structured_output(FlexiblePerson)

text = "Alice, 25 years old, hobby: reading, city: Beijing, job: engineer"
print(f"输入: {text}")
result = structured_llm.invoke(f"提取信息：{text}")

print(f"输出: {result}")
print(f"定义的字段: name={result.name}, age={result.age}")
if hasattr(result, '__pydantic_extra__'):
    print(f"额外字段: {result.__pydantic_extra__}")
print()

# 预期输出：
# 输出: FlexiblePerson(name='Alice', age=25, hobby='reading', city='Beijing', job='engineer')
# 定义的字段: name=Alice, age=25
# 额外字段: {'hobby': 'reading', 'city': 'Beijing', 'job': 'engineer'}
```

---

## 完整运行示例

```python
"""
完整示例：运行所有复杂场景
"""

def main():
    """运行所有复杂场景"""
    print("=" * 60)
    print("OutputParser 复杂场景演示")
    print("=" * 60)
    print()

    # 场景 1-6 的代码...
    # （在实际运行时，将上面所有场景的代码整合到这里）

    print("=" * 60)
    print("所有复杂场景演示完成！")
    print("=" * 60)

if __name__ == "__main__":
    main()
```

---

## 关键要点

1. **嵌套模型**：使用嵌套 Pydantic 模型处理复杂结构
2. **Union 类型**：处理多种可能的响应类型
3. **条件验证**：使用 `@model_validator` 实现条件逻辑
4. **递归结构**：自引用模型处理树形结构
5. **复杂验证**：组合多个验证器实现业务规则
6. **动态字段**：使用 `extra='allow'` 保留未定义字段

---

**记住**：复杂场景需要更精心的 Pydantic 模型设计，但 LLM 通常能很好地理解和填充这些结构！
