# 反直觉点

向量存储最容易踩的 3 个坑。

---

## 误区1：向量维度越高越好 ❌

### 错误观点

"1536 维比 384 维好，3072 维更好，维度越高信息越丰富。"

### 为什么错？

**维度高不等于效果好，还要考虑：**

1. **存储成本**：维度翻倍，存储翻倍
   ```
   100万向量：
   - 384维：100万 × 384 × 4 bytes = 1.5 GB
   - 1536维：100万 × 1536 × 4 bytes = 6 GB
   - 3072维：100万 × 3072 × 4 bytes = 12 GB
   ```

2. **搜索速度**：维度越高，计算越慢
   ```
   余弦相似度计算：O(D)
   D = 384：快
   D = 3072：慢 8 倍
   ```

3. **维度灾难**：高维空间中，所有点都"差不多远"
   ```
   低维：点之间距离差异明显，容易区分
   高维：点之间距离趋于相同，难以区分
   ```

### 为什么人们容易这样错？

- 直觉上"信息越多越好"
- 类比图片分辨率：4K 比 1080P 清晰
- 但向量不是图片，高维不等于高质量

### 正确理解

```python
# 选择维度的正确思路

# 1. 看 Embedding 模型的原生维度
# text-embedding-3-small: 1536维
# all-MiniLM-L6-v2: 384维

# 2. 看实际效果（在你的数据上测试）
# 有时 384 维效果不比 1536 差

# 3. 看资源限制
# 内存有限 → 选低维度
# 追求极致效果 → 选高维度

# 最佳实践：从低维度开始，效果不够再升级
```

---

## 误区2：索引精度 100% 才能用 ❌

### 错误观点

"HNSW/IVF 是近似搜索，可能漏掉结果，不如用 Flat 暴力搜索。"

### 为什么错？

**1. 近似搜索的精度已经很高**

| 索引类型 | 召回率 | 说明 |
|----------|--------|------|
| Flat | 100% | 精确，但慢 |
| HNSW | 98-99% | 几乎精确，快 |
| IVF | 95-98% | 足够好，很快 |

**2. RAG 本身就是"近似"的**

```
RAG 流程中的"近似"：
1. Embedding 本身就是近似表示（有信息损失）
2. Top-K 只取前几个（可能漏掉第 K+1 个好结果）
3. LLM 生成也有随机性

→ 索引的 2% 误差在整体误差中微不足道
```

**3. 速度差异巨大**

```
100万数据查询：
- Flat：1000ms
- HNSW：5ms

用户愿意等 1 秒换 2% 精度提升吗？
大多数场景：不愿意
```

### 为什么人们容易这样错？

- 追求完美的心理
- 不了解 RAG 整体流程的"近似"本质
- 没有实际测试过速度差异

### 正确理解

```python
# 索引选择的正确思路

# 小数据量（< 1万）：用 Flat，简单可靠
# 中等数据量（1万-100万）：用 HNSW，速度和精度平衡
# 大数据量（> 100万）：必须用索引，否则无法使用

# 关键：在你的数据上测试，看实际召回率
# 如果 HNSW 召回率 98%，而 Flat 是 100%
# 但 HNSW 快 200 倍，选 HNSW
```

---

## 误区3：向量存储可以替代传统数据库 ❌

### 错误观点

"既然向量存储也能存元数据，就不需要 MySQL/PostgreSQL 了。"

### 为什么错？

**1. 向量存储不擅长的事情**

| 操作 | 传统数据库 | 向量存储 |
|------|-----------|----------|
| 精确查询 | ✅ 毫秒级 | ❌ 不是设计目标 |
| 复杂 JOIN | ✅ 支持 | ❌ 不支持 |
| 事务 ACID | ✅ 完整支持 | ⚠️ 有限支持 |
| 聚合统计 | ✅ 高效 | ❌ 不支持 |
| 更新频繁 | ✅ 高效 | ⚠️ 需要重建索引 |

**2. 实际架构中两者配合使用**

```
┌─────────────────────────────────────────────────────┐
│                    RAG 系统架构                      │
│                                                     │
│  ┌─────────────┐         ┌─────────────┐           │
│  │   MySQL     │         │  ChromaDB   │           │
│  │             │         │             │           │
│  │ - 用户信息   │         │ - 文档向量   │           │
│  │ - 权限配置   │  配合    │ - 语义检索   │           │
│  │ - 操作日志   │ ←────→  │ - 相似匹配   │           │
│  │ - 业务数据   │         │             │           │
│  └─────────────┘         └─────────────┘           │
│                                                     │
│  精确查询、事务、统计      语义搜索、相似匹配          │
└─────────────────────────────────────────────────────┘
```

**3. 元数据过滤的局限**

```python
# 向量存储的元数据过滤
# 只支持简单条件，不支持复杂查询

# ✅ 支持
where={"year": 2024, "category": "tech"}

# ❌ 不支持
# - 子查询
# - JOIN
# - GROUP BY
# - 复杂聚合
```

### 为什么人们容易这样错？

- 看到向量存储支持元数据，以为功能完整
- 想简化架构，减少组件
- 不了解两者的设计目标不同

### 正确理解

```python
# 正确的架构思路

# 向量存储：专门做语义搜索
# 传统数据库：做其他所有事情

# 典型流程：
# 1. 从 MySQL 获取用户权限
# 2. 用权限作为过滤条件，在向量存储中搜索
# 3. 搜索结果的详细信息从 MySQL 获取

def search_with_permission(user_id, query):
    # 1. 从 MySQL 获取用户权限
    permissions = mysql.query(
        "SELECT accessible_docs FROM users WHERE id = ?",
        user_id
    )

    # 2. 在向量存储中搜索（带权限过滤）
    results = vector_store.search(
        query=query,
        filter={"doc_id": {"$in": permissions}}
    )

    # 3. 从 MySQL 获取详细信息
    details = mysql.query(
        "SELECT * FROM documents WHERE id IN ?",
        [r.id for r in results]
    )

    return details
```

---

## 误区总结

| 误区 | 正确理解 |
|------|----------|
| 维度越高越好 | 维度要平衡效果、成本、速度 |
| 必须 100% 精度 | 98% 精度 + 200倍速度更实用 |
| 可以替代传统数据库 | 两者配合使用，各司其职 |

---

**核心洞察**：向量存储是专门为语义搜索设计的工具，不是万能数据库。理解它的边界，才能用好它。

---

**下一步：** [07_实战代码](./07_实战代码.md) - 完整可运行的代码示例
