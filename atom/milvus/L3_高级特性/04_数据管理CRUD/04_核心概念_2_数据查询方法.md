# 核心概念 2: 数据查询方法

> 深入理解 Milvus 的查询机制，掌握 Query、Search 和混合检索的最佳实践

---

## 概述

Milvus 提供两种主要的查询方式：
1. **Query**：精确查询（标量匹配）
2. **Search**：向量检索（相似度匹配）

理解这两种查询方式的区别和使用场景，是构建高效向量数据库应用的关键。

**本章内容**：
1. Query：精确查询
2. Search：向量检索
3. 查询表达式（expr）
4. 混合检索（Search + expr）
5. 分页查询
6. 性能优化

---

## 1. Query：精确查询

### 1.1 什么是 Query？

**定义**：Query 是基于标量字段的精确查询，类似于 SQL 的 SELECT 语句。

**特点**：
- 使用表达式（expr）指定查询条件
- 返回所有匹配的数据
- 不使用向量索引
- 全表扫描，性能 O(n)

### 1.2 基本用法

```python
from pymilvus import Collection

collection = Collection("my_collection")

# 基本查询
results = collection.query(
    expr="id in [1, 2, 3]",  # 查询条件
    output_fields=["id", "text"]  # 返回字段
)

# 打印结果
for result in results:
    print(f"ID: {result['id']}, Text: {result['text']}")
```

### 1.3 查询表达式

**支持的操作符**：

| 操作符 | 说明 | 示例 |
|--------|------|------|
| `==` | 等于 | `id == 1` |
| `!=` | 不等于 | `id != 1` |
| `>` | 大于 | `price > 100` |
| `>=` | 大于等于 | `price >= 100` |
| `<` | 小于 | `price < 100` |
| `<=` | 小于等于 | `price <= 100` |
| `in` | 在列表中 | `id in [1, 2, 3]` |
| `not in` | 不在列表中 | `id not in [1, 2, 3]` |
| `and` | 逻辑与 | `price > 100 and category == "tech"` |
| `or` | 逻辑或 | `price < 50 or price > 200` |
| `like` | 模糊匹配 | `text like "hello%"` |

**示例**：

```python
# 单条件查询
results = collection.query(expr="id == 1")

# 范围查询
results = collection.query(expr="price > 100 and price < 200")

# IN 查询
results = collection.query(expr="id in [1, 2, 3, 4, 5]")

# 字符串匹配
results = collection.query(expr='category == "tech"')

# 复杂条件
results = collection.query(
    expr='(price > 100 and category == "tech") or (price < 50 and category == "book")'
)

# 模糊匹配
results = collection.query(expr='text like "hello%"')
```

### 1.4 指定返回字段

```python
# 返回所有字段
results = collection.query(
    expr="id in [1, 2, 3]",
    output_fields=["*"]  # 所有字段
)

# 返回指定字段
results = collection.query(
    expr="id in [1, 2, 3]",
    output_fields=["id", "text"]  # 只返回 id 和 text
)

# 不返回向量字段（节省带宽）
results = collection.query(
    expr="id in [1, 2, 3]",
    output_fields=["id", "text"]  # 不包含 embedding
)
```

### 1.5 Query 的性能特征

**性能模型**：
```
Query 时间 = 数据量 × 扫描速度
```

**性能数据**：
- 小数据集（< 10万条）：< 100ms
- 中数据集（10万-100万条）：100ms - 1s
- 大数据集（> 100万条）：> 1s

**优化策略**：
1. 使用分区（Partition）减少扫描范围
2. 使用标量索引（Scalar Index）加速过滤
3. 只返回必要的字段

---

## 2. Search：向量检索

### 2.1 什么是 Search？

**定义**：Search 是基于向量相似度的检索，返回最相似的 Top-K 数据。

**特点**：
- 使用向量（data）作为查询条件
- 返回最相似的 Top-K 数据
- 使用向量索引加速
- 性能 O(log n)

### 2.2 基本用法

```python
import numpy as np

# 准备查询向量
query_vector = np.random.rand(128).tolist()

# 向量检索
results = collection.search(
    data=[query_vector],  # 查询向量（可以是多个）
    anns_field="embedding",  # 向量字段名
    param={"metric_type": "L2", "params": {"nprobe": 10}},  # 检索参数
    limit=5,  # 返回 Top-5
    output_fields=["id", "text"]  # 返回字段
)

# 打印结果
for hits in results:
    for hit in hits:
        print(f"ID: {hit.id}, Distance: {hit.distance}, Text: {hit.entity.get('text')}")
```

### 2.3 相似度度量

**支持的度量类型**：

| 度量类型 | 说明 | 范围 | 适用场景 |
|---------|------|------|---------|
| `L2` | 欧氏距离 | [0, ∞) | 通用场景 |
| `IP` | 内积 | (-∞, ∞) | 归一化向量 |
| `COSINE` | 余弦相似度 | [-1, 1] | 文本相似度 |

**示例**：

```python
# L2 距离（欧氏距离）
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=5
)

# 内积（IP）
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "IP", "params": {"nprobe": 10}},
    limit=5
)

# 余弦相似度
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "COSINE", "params": {"nprobe": 10}},
    limit=5
)
```

### 2.4 检索参数

**IVF 索引参数**：

```python
# nprobe：搜索的聚类数量
# nprobe 越大，召回率越高，但速度越慢
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},  # 搜索 10 个聚类
    limit=5
)
```

**HNSW 索引参数**：

```python
# ef：搜索时的候选集大小
# ef 越大，召回率越高，但速度越慢
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"ef": 64}},  # 候选集大小 64
    limit=5
)
```

### 2.5 批量检索

```python
# 批量检索（多个查询向量）
query_vectors = [
    np.random.rand(128).tolist(),
    np.random.rand(128).tolist(),
    np.random.rand(128).tolist()
]

results = collection.search(
    data=query_vectors,  # 3 个查询向量
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=5
)

# 结果是嵌套列表
for i, hits in enumerate(results):
    print(f"查询 {i + 1} 的结果:")
    for hit in hits:
        print(f"  ID: {hit.id}, Distance: {hit.distance}")
```

### 2.6 Search 的性能特征

**性能模型**：
```
Search 时间 = 索引查找时间 + 距离计算时间 + 排序时间
```

**性能数据**：
- FLAT 索引：O(n)，精确但慢
- IVF 索引：O(log n)，快但近似
- HNSW 索引：O(log n)，最快且准确

**优化策略**：
1. 选择合适的索引类型（HNSW 适合高性能场景）
2. 调整索引参数（nprobe/ef 平衡性能和准确率）
3. 减少 Top-K（只返回必要的结果）

---

## 3. Query vs Search 对比

### 3.1 核心区别

| 特性 | Query | Search |
|------|-------|--------|
| **查询方式** | 标量查询（expr） | 向量检索（data） |
| **查询条件** | 表达式 | 向量 |
| **返回结果** | 所有匹配 | Top-K 最相似 |
| **使用索引** | 不使用向量索引 | 使用向量索引 |
| **性能** | O(n) 全表扫描 | O(log n) 索引加速 |
| **适用场景** | 按 ID 查询、条件过滤 | 相似度检索、推荐系统 |

### 3.2 使用场景

**使用 Query 的场景**：
- 按主键查询：`id in [1, 2, 3]`
- 条件过滤：`price > 100 and category == "tech"`
- 精确匹配：`text == "hello"`

**使用 Search 的场景**：
- 相似度检索：找到最相似的文档
- 推荐系统：推荐相似的商品
- 图像搜索：找到相似的图片

### 3.3 选择建议

```python
# 场景 1: 按 ID 查询 → 使用 Query
results = collection.query(expr="id in [1, 2, 3]")

# 场景 2: 相似度检索 → 使用 Search
results = collection.search(data=[query_vector], anns_field="embedding", limit=5)

# 场景 3: 混合检索 → 使用 Search + expr
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=5,
    expr="category == 'tech'"  # 标量过滤
)
```

---

## 4. 混合检索（Search + expr）

### 4.1 什么是混合检索？

**定义**：混合检索 = 向量检索 + 标量过滤

**执行顺序**：
```
1. 向量检索（找到候选集）
   ↓
2. 标量过滤（过滤候选集）
   ↓
3. 返回 Top-K
```

### 4.2 基本用法

```python
# 混合检索
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr="category == 'tech' and price < 100"  # 标量过滤
)
```

### 4.3 复杂过滤条件

```python
# 多条件过滤
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="(category == 'tech' and price < 100) or (category == 'book' and price < 50)"
)

# 范围过滤
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="price >= 50 and price <= 200"
)

# IN 过滤
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="category in ['tech', 'book', 'music']"
)
```

### 4.4 性能优化

**策略 1: 先向量后标量**（Milvus 默认）

```
优势：利用向量索引快速找到候选集
劣势：如果标量过滤条件很严格，可能需要检索更多数据
```

**策略 2: 增加 limit**

```python
# 如果标量过滤条件很严格，增加 limit
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=100,  # 增加 limit，确保过滤后有足够的结果
    expr="category == 'rare_category'"
)
```

### 4.5 在 RAG 中的应用

```python
def rag_search(collection, query_text, category=None, top_k=5):
    """RAG 混合检索"""
    from sentence_transformers import SentenceTransformer

    # 生成查询向量
    model = SentenceTransformer('all-MiniLM-L6-v2')
    query_vector = model.encode([query_text])[0].tolist()

    # 构建过滤条件
    expr = None
    if category:
        expr = f"category == '{category}'"

    # 混合检索
    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param={"metric_type": "L2", "params": {"nprobe": 10}},
        limit=top_k,
        expr=expr,
        output_fields=["id", "text", "category"]
    )

    return results[0]

# 使用
results = rag_search(collection, "什么是机器学习？", category="tech", top_k=5)
for hit in results:
    print(f"Text: {hit.entity.get('text')}, Distance: {hit.distance}")
```

---

## 5. 分页查询

### 5.1 Query 分页

```python
def query_with_pagination(collection, expr, page_size=100):
    """Query 分页查询"""
    offset = 0
    while True:
        # 查询一页
        results = collection.query(
            expr=expr,
            output_fields=["id", "text"],
            limit=page_size,
            offset=offset
        )

        if not results:
            break

        # 处理结果
        for result in results:
            print(result)

        offset += page_size

# 使用
query_with_pagination(collection, "price > 100", page_size=100)
```

### 5.2 Search 分页

**注意**：Search 不支持 offset 参数，需要使用其他方法。

**方法 1: 增加 limit**

```python
# 一次性检索更多结果
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=100,  # 一次性返回 100 条
    output_fields=["id", "text"]
)

# 在应用层分页
page_size = 10
for page in range(0, len(results[0]), page_size):
    page_results = results[0][page:page + page_size]
    print(f"第 {page // page_size + 1} 页:")
    for hit in page_results:
        print(f"  ID: {hit.id}, Distance: {hit.distance}")
```

**方法 2: 使用 range_filter**

```python
# 使用距离范围过滤
# 第一页：距离 0-0.5
results_page1 = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10, "range_filter": 0, "radius": 0.5}},
    limit=10
)

# 第二页：距离 0.5-1.0
results_page2 = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10, "range_filter": 0.5, "radius": 1.0}},
    limit=10
)
```

---

## 6. 性能优化

### 6.1 Query 优化

**优化 1: 使用分区**

```python
# 不使用分区：扫描所有数据
results = collection.query(expr="id in [1, 2, 3]")

# 使用分区：只扫描指定分区
results = collection.query(
    expr="id in [1, 2, 3]",
    partition_names=["partition_2024"]  # 只扫描 partition_2024
)
```

**优化 2: 只返回必要字段**

```python
# 返回所有字段（包括向量）
results = collection.query(expr="id in [1, 2, 3]", output_fields=["*"])

# 只返回必要字段（不包括向量）
results = collection.query(expr="id in [1, 2, 3]", output_fields=["id", "text"])
```

**优化 3: 使用标量索引**

```python
# 为标量字段创建索引
collection.create_index(
    field_name="category",
    index_params={"index_type": "STL_SORT"}  # 标量索引
)

# 查询时自动使用索引
results = collection.query(expr="category == 'tech'")
```

### 6.2 Search 优化

**优化 1: 选择合适的索引类型**

```python
# FLAT：精确但慢
index_params = {"index_type": "FLAT", "metric_type": "L2"}

# IVF_FLAT：快但近似
index_params = {"index_type": "IVF_FLAT", "metric_type": "L2", "params": {"nlist": 128}}

# HNSW：最快且准确
index_params = {"index_type": "HNSW", "metric_type": "L2", "params": {"M": 16, "efConstruction": 200}}
```

**优化 2: 调整检索参数**

```python
# 低召回率，高性能
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 5}},  # 小 nprobe
    limit=5
)

# 高召回率，低性能
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 50}},  # 大 nprobe
    limit=5
)
```

**优化 3: 批量检索**

```python
# 单次检索
for query_vector in query_vectors:
    results = collection.search(data=[query_vector], anns_field="embedding", limit=5)

# 批量检索（更快）
results = collection.search(data=query_vectors, anns_field="embedding", limit=5)
```

### 6.3 混合检索优化

**优化 1: 先向量后标量**

```python
# Milvus 默认策略：先向量检索，再标量过滤
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="category == 'tech'"
)
```

**优化 2: 增加 limit**

```python
# 如果标量过滤条件很严格，增加 limit
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=100,  # 增加 limit
    expr="category == 'rare_category'"
)
```

**优化 3: 使用分区**

```python
# 结合分区和标量过滤
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="category == 'tech'",
    partition_names=["partition_2024"]  # 只搜索指定分区
)
```

---

## 总结

### 核心要点

1. **Query 用于精确查询**：按 ID、条件过滤
2. **Search 用于相似度检索**：找到最相似的 Top-K
3. **混合检索结合两者优势**：向量检索 + 标量过滤
4. **选择合适的查询方式**：根据场景选择
5. **性能优化很重要**：分区、索引、批量操作

### 最佳实践

1. **按 ID 查询用 Query**：`collection.query(expr="id in [1, 2, 3]")`
2. **相似度检索用 Search**：`collection.search(data=[query_vector], limit=5)`
3. **复杂场景用混合检索**：`collection.search(data=[query_vector], expr="category == 'tech'")`
4. **使用分区优化性能**：`partition_names=["partition_2024"]`
5. **只返回必要字段**：`output_fields=["id", "text"]`

### 性能优化清单

- [ ] 根据场景选择 Query 或 Search
- [ ] 使用分区减少扫描范围
- [ ] 为标量字段创建索引
- [ ] 选择合适的向量索引类型
- [ ] 调整检索参数（nprobe/ef）
- [ ] 批量检索提升性能
- [ ] 只返回必要的字段

---

**下一步**: 学习 [05_核心概念_3_数据删除与Upsert.md](./05_核心概念_3_数据删除与Upsert.md) 深入理解删除和更新操作
