# 实战代码 - 场景3: 复杂查询与过滤

> 掌握复杂查询表达式和混合检索，实现高级数据过滤

---

## 场景描述

**目标**：实现一个支持复杂查询条件的搜索系统，包括多条件过滤、范围查询、混合检索等。

**功能需求**：
1. 多条件组合查询
2. 范围查询和模糊匹配
3. 混合检索（向量 + 标量）
4. 分页和排序
5. 查询性能优化

---

## 完整代码

```python
"""
Milvus 复杂查询与过滤示例
演示各种高级查询场景
"""

from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType, utility
import numpy as np
from sentence_transformers import SentenceTransformer
from typing import List, Dict, Optional
import time


class AdvancedQueryManager:
    """高级查询管理器"""

    def __init__(self, collection_name="products", dim=384):
        self.collection_name = collection_name
        self.dim = dim
        self.collection = None
        self.model = None

    def connect(self, host="localhost", port="19530"):
        """连接到 Milvus"""
        connections.connect(alias="default", host=host, port=port)
        print(f"✓ 已连接到 Milvus")

    def create_collection(self):
        """创建 Collection"""
        if utility.has_collection(self.collection_name):
            utility.drop_collection(self.collection_name)

        fields = [
            FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=False),
            FieldSchema(name="name", dtype=DataType.VARCHAR, max_length=500),
            FieldSchema(name="description", dtype=DataType.VARCHAR, max_length=2000),
            FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=100),
            FieldSchema(name="price", dtype=DataType.FLOAT),
            FieldSchema(name="stock", dtype=DataType.INT64),
            FieldSchema(name="rating", dtype=DataType.FLOAT),
            FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=self.dim)
        ]

        schema = CollectionSchema(fields=fields, description="商品数据库")
        self.collection = Collection(name=self.collection_name, schema=schema)

        # 创建索引
        index_params = {
            "index_type": "IVF_FLAT",
            "metric_type": "L2",
            "params": {"nlist": 128}
        }
        self.collection.create_index(field_name="embedding", index_params=index_params)

        print(f"✓ Collection 创建成功")

    def load_model(self, model_name='all-MiniLM-L6-v2'):
        """加载 Embedding 模型"""
        self.model = SentenceTransformer(model_name)
        print("✓ 模型加载成功")

    def insert_sample_data(self):
        """插入示例数据"""
        products = [
            {"id": 1, "name": "iPhone 15 Pro", "description": "最新款苹果手机，A17芯片", "category": "手机", "price": 7999.0, "stock": 50, "rating": 4.8},
            {"id": 2, "name": "MacBook Pro", "description": "M3芯片笔记本电脑", "category": "电脑", "price": 12999.0, "stock": 30, "rating": 4.9},
            {"id": 3, "name": "AirPods Pro", "description": "主动降噪无线耳机", "category": "耳机", "price": 1999.0, "stock": 100, "rating": 4.7},
            {"id": 4, "name": "iPad Air", "description": "轻薄平板电脑", "category": "平板", "price": 4799.0, "stock": 60, "rating": 4.6},
            {"id": 5, "name": "Apple Watch", "description": "智能手表", "category": "手表", "price": 2999.0, "stock": 80, "rating": 4.5},
            {"id": 6, "name": "Samsung Galaxy S24", "description": "三星旗舰手机", "category": "手机", "price": 6999.0, "stock": 40, "rating": 4.7},
            {"id": 7, "name": "Dell XPS 15", "description": "高性能笔记本", "category": "电脑", "price": 11999.0, "stock": 25, "rating": 4.6},
            {"id": 8, "name": "Sony WH-1000XM5", "description": "索尼降噪耳机", "category": "耳机", "price": 2499.0, "stock": 70, "rating": 4.8},
            {"id": 9, "name": "Kindle Paperwhite", "description": "电子书阅读器", "category": "阅读器", "price": 998.0, "stock": 120, "rating": 4.5},
            {"id": 10, "name": "Nintendo Switch", "description": "任天堂游戏机", "category": "游戏机", "price": 2099.0, "stock": 90, "rating": 4.9}
        ]

        # 生成 Embedding
        texts = [f"{p['name']} {p['description']}" for p in products]
        embeddings = self.model.encode(texts).tolist()

        # 准备数据
        data = [
            [p["id"] for p in products],
            [p["name"] for p in products],
            [p["description"] for p in products],
            [p["category"] for p in products],
            [p["price"] for p in products],
            [p["stock"] for p in products],
            [p["rating"] for p in products],
            embeddings
        ]

        self.collection.insert(data)
        self.collection.flush()
        self.collection.load()

        print(f"✓ 已插入 {len(products)} 个商品")

    # ============================================================
    # 场景 1: 单条件查询
    # ============================================================

    def query_by_category(self, category: str):
        """按类别查询"""
        print(f"\n【场景1】按类别查询: {category}")

        results = self.collection.query(
            expr=f"category == '{category}'",
            output_fields=["id", "name", "price", "category"]
        )

        print(f"找到 {len(results)} 个商品:")
        for r in results:
            print(f"  - {r['name']} (¥{r['price']})")

        return results

    def query_by_price_range(self, min_price: float, max_price: float):
        """按价格范围查询"""
        print(f"\n【场景1】按价格范围查询: ¥{min_price} - ¥{max_price}")

        results = self.collection.query(
            expr=f"price >= {min_price} and price <= {max_price}",
            output_fields=["id", "name", "price"]
        )

        print(f"找到 {len(results)} 个商品:")
        for r in results:
            print(f"  - {r['name']} (¥{r['price']})")

        return results

    # ============================================================
    # 场景 2: 多条件组合查询
    # ============================================================

    def query_with_multiple_conditions(self, category: str, min_price: float, max_price: float, min_rating: float):
        """多条件组合查询"""
        print(f"\n【场景2】多条件查询:")
        print(f"  类别: {category}")
        print(f"  价格: ¥{min_price} - ¥{max_price}")
        print(f"  评分: >= {min_rating}")

        expr = f"category == '{category}' and price >= {min_price} and price <= {max_price} and rating >= {min_rating}"

        results = self.collection.query(
            expr=expr,
            output_fields=["id", "name", "price", "rating", "category"]
        )

        print(f"找到 {len(results)} 个商品:")
        for r in results:
            print(f"  - {r['name']} (¥{r['price']}, 评分: {r['rating']})")

        return results

    def query_with_or_conditions(self, categories: List[str]):
        """OR 条件查询"""
        print(f"\n【场景2】OR 条件查询: {categories}")

        # 构建 IN 表达式
        expr = f"category in {categories}"

        results = self.collection.query(
            expr=expr,
            output_fields=["id", "name", "category", "price"]
        )

        print(f"找到 {len(results)} 个商品:")
        for r in results:
            print(f"  - {r['name']} ({r['category']}, ¥{r['price']})")

        return results

    # ============================================================
    # 场景 3: 混合检索（向量 + 标量）
    # ============================================================

    def hybrid_search(self, query_text: str, category: Optional[str] = None,
                     max_price: Optional[float] = None, top_k: int = 5):
        """混合检索"""
        print(f"\n【场景3】混合检索:")
        print(f"  查询: {query_text}")
        if category:
            print(f"  类别: {category}")
        if max_price:
            print(f"  最高价格: ¥{max_price}")

        # 生成查询向量
        query_embedding = self.model.encode([query_text])[0].tolist()

        # 构建过滤条件
        conditions = []
        if category:
            conditions.append(f"category == '{category}'")
        if max_price:
            conditions.append(f"price <= {max_price}")

        expr = " and ".join(conditions) if conditions else None

        # 执行检索
        results = self.collection.search(
            data=[query_embedding],
            anns_field="embedding",
            param={"metric_type": "L2", "params": {"nprobe": 10}},
            limit=top_k,
            expr=expr,
            output_fields=["id", "name", "price", "category", "rating"]
        )

        print(f"找到 {len(results[0])} 个相似商品:")
        for i, hit in enumerate(results[0]):
            print(f"  {i+1}. {hit.entity.get('name')} (¥{hit.entity.get('price')}, 距离: {hit.distance:.4f})")

        return results[0]

    def hybrid_search_with_complex_filter(self, query_text: str, top_k: int = 5):
        """复杂过滤条件的混合检索"""
        print(f"\n【场景3】复杂过滤的混合检索:")
        print(f"  查询: {query_text}")
        print(f"  过滤: (类别=手机或电脑) AND (价格<10000) AND (评分>=4.7)")

        query_embedding = self.model.encode([query_text])[0].tolist()

        # 复杂过滤条件
        expr = "(category == '手机' or category == '电脑') and price < 10000 and rating >= 4.7"

        results = self.collection.search(
            data=[query_embedding],
            anns_field="embedding",
            param={"metric_type": "L2", "params": {"nprobe": 10}},
            limit=top_k,
            expr=expr,
            output_fields=["id", "name", "price", "category", "rating"]
        )

        print(f"找到 {len(results[0])} 个商品:")
        for i, hit in enumerate(results[0]):
            print(f"  {i+1}. {hit.entity.get('name')} ({hit.entity.get('category')}, ¥{hit.entity.get('price')}, 评分: {hit.entity.get('rating')})")

        return results[0]

    # ============================================================
    # 场景 4: 批量查询
    # ============================================================

    def batch_query_by_ids(self, ids: List[int]):
        """批量按 ID 查询"""
        print(f"\n【场景4】批量查询 {len(ids)} 个商品")

        results = self.collection.query(
            expr=f"id in {ids}",
            output_fields=["id", "name", "price"]
        )

        print(f"找到 {len(results)} 个商品:")
        for r in results:
            print(f"  - ID {r['id']}: {r['name']} (¥{r['price']})")

        return results

    def batch_search(self, queries: List[str], top_k: int = 3):
        """批量向量检索"""
        print(f"\n【场景4】批量检索 {len(queries)} 个查询")

        # 生成查询向量
        query_embeddings = self.model.encode(queries).tolist()

        # 批量检索
        results = self.collection.search(
            data=query_embeddings,
            anns_field="embedding",
            param={"metric_type": "L2", "params": {"nprobe": 10}},
            limit=top_k,
            output_fields=["id", "name", "price"]
        )

        for i, (query, hits) in enumerate(zip(queries, results)):
            print(f"\n查询 {i+1}: {query}")
            for j, hit in enumerate(hits):
                print(f"  {j+1}. {hit.entity.get('name')} (¥{hit.entity.get('price')})")

        return results

    # ============================================================
    # 场景 5: 性能优化
    # ============================================================

    def benchmark_query_performance(self):
        """查询性能基准测试"""
        print(f"\n【场景5】查询性能基准测试")
        print("=" * 60)

        # 测试 1: Query 性能
        print("\n测试 1: Query 性能")
        start = time.time()
        for _ in range(100):
            self.collection.query(
                expr="category == '手机'",
                output_fields=["id", "name"]
            )
        elapsed = time.time() - start
        print(f"  100次查询耗时: {elapsed:.2f}秒")
        print(f"  平均延迟: {elapsed * 10:.2f}ms")

        # 测试 2: Search 性能
        print("\n测试 2: Search 性能")
        query_embedding = self.model.encode(["手机"])[0].tolist()
        start = time.time()
        for _ in range(100):
            self.collection.search(
                data=[query_embedding],
                anns_field="embedding",
                param={"metric_type": "L2", "params": {"nprobe": 10}},
                limit=5
            )
        elapsed = time.time() - start
        print(f"  100次检索耗时: {elapsed:.2f}秒")
        print(f"  平均延迟: {elapsed * 10:.2f}ms")

        # 测试 3: 混合检索性能
        print("\n测试 3: 混合检索性能")
        start = time.time()
        for _ in range(100):
            self.collection.search(
                data=[query_embedding],
                anns_field="embedding",
                param={"metric_type": "L2", "params": {"nprobe": 10}},
                limit=5,
                expr="price < 5000"
            )
        elapsed = time.time() - start
        print(f"  100次混合检索耗时: {elapsed:.2f}秒")
        print(f"  平均延迟: {elapsed * 10:.2f}ms")

    # ============================================================
    # 场景 6: 高级查询工具
    # ============================================================

    def build_query_builder(self):
        """查询构建器"""
        return QueryBuilder(self.collection)


class QueryBuilder:
    """查询构建器"""

    def __init__(self, collection):
        self.collection = collection
        self.conditions = []
        self.output_fields = ["*"]
        self.limit = None
        self.offset = 0

    def where(self, field: str, operator: str, value):
        """添加条件"""
        if operator == "==":
            self.conditions.append(f"{field} == '{value}'" if isinstance(value, str) else f"{field} == {value}")
        elif operator == "!=":
            self.conditions.append(f"{field} != '{value}'" if isinstance(value, str) else f"{field} != {value}")
        elif operator == ">":
            self.conditions.append(f"{field} > {value}")
        elif operator == ">=":
            self.conditions.append(f"{field} >= {value}")
        elif operator == "<":
            self.conditions.append(f"{field} < {value}")
        elif operator == "<=":
            self.conditions.append(f"{field} <= {value}")
        elif operator == "in":
            self.conditions.append(f"{field} in {value}")
        return self

    def select(self, *fields):
        """选择返回字段"""
        self.output_fields = list(fields)
        return self

    def limit_results(self, limit: int):
        """限制返回数量"""
        self.limit = limit
        return self

    def offset_results(self, offset: int):
        """设置偏移量"""
        self.offset = offset
        return self

    def execute(self):
        """执行查询"""
        expr = " and ".join(self.conditions) if self.conditions else None

        results = self.collection.query(
            expr=expr,
            output_fields=self.output_fields,
            limit=self.limit,
            offset=self.offset
        )

        return results


def main():
    """主函数"""
    print("=" * 60)
    print("Milvus 复杂查询与过滤示例")
    print("=" * 60)

    # 初始化
    manager = AdvancedQueryManager()
    manager.connect()
    manager.create_collection()
    manager.load_model()
    manager.insert_sample_data()

    # 场景 1: 单条件查询
    print("\n" + "=" * 60)
    print("场景 1: 单条件查询")
    print("=" * 60)

    manager.query_by_category("手机")
    manager.query_by_price_range(2000, 5000)

    # 场景 2: 多条件组合查询
    print("\n" + "=" * 60)
    print("场景 2: 多条件组合查询")
    print("=" * 60)

    manager.query_with_multiple_conditions("手机", 5000, 10000, 4.7)
    manager.query_with_or_conditions(["手机", "电脑", "平板"])

    # 场景 3: 混合检索
    print("\n" + "=" * 60)
    print("场景 3: 混合检索")
    print("=" * 60)

    manager.hybrid_search("高性能笔记本", category="电脑", max_price=15000, top_k=3)
    manager.hybrid_search_with_complex_filter("智能设备", top_k=5)

    # 场景 4: 批量查询
    print("\n" + "=" * 60)
    print("场景 4: 批量查询")
    print("=" * 60)

    manager.batch_query_by_ids([1, 3, 5, 7])
    manager.batch_search(["手机", "耳机", "电脑"], top_k=2)

    # 场景 5: 性能测试
    print("\n" + "=" * 60)
    print("场景 5: 性能测试")
    print("=" * 60)

    manager.benchmark_query_performance()

    # 场景 6: 查询构建器
    print("\n" + "=" * 60)
    print("场景 6: 查询构建器")
    print("=" * 60)

    builder = manager.build_query_builder()
    results = (builder
               .where("category", "==", "手机")
               .where("price", "<", 8000)
               .where("rating", ">=", 4.7)
               .select("id", "name", "price", "rating")
               .limit_results(5)
               .execute())

    print(f"\n使用查询构建器找到 {len(results)} 个商品:")
    for r in results:
        print(f"  - {r['name']} (¥{r['price']}, 评分: {r['rating']})")

    print("\n" + "=" * 60)
    print("示例完成！")
    print("=" * 60)


if __name__ == "__main__":
    main()
```

---

## 查询表达式速查表

### 比较运算符

| 运算符 | 说明 | 示例 |
|--------|------|------|
| `==` | 等于 | `category == 'tech'` |
| `!=` | 不等于 | `category != 'obsolete'` |
| `>` | 大于 | `price > 100` |
| `>=` | 大于等于 | `price >= 100` |
| `<` | 小于 | `price < 1000` |
| `<=` | 小于等于 | `price <= 1000` |

### 逻辑运算符

| 运算符 | 说明 | 示例 |
|--------|------|------|
| `and` | 逻辑与 | `price > 100 and category == 'tech'` |
| `or` | 逻辑或 | `category == 'tech' or category == 'science'` |
| `not` | 逻辑非 | `not (price > 1000)` |

### 集合运算符

| 运算符 | 说明 | 示例 |
|--------|------|------|
| `in` | 在集合中 | `category in ['tech', 'science']` |
| `not in` | 不在集合中 | `category not in ['obsolete']` |

### 字符串运算符

| 运算符 | 说明 | 示例 |
|--------|------|------|
| `like` | 模糊匹配 | `name like 'iPhone%'` |

---

## 性能优化技巧

### 1. 使用 IN 代替多个 OR

```python
# 慢：多个 OR
expr = "category == 'tech' or category == 'science' or category == 'business'"

# 快：使用 IN
expr = "category in ['tech', 'science', 'business']"
```

### 2. 先过滤再检索

```python
# 慢：先检索大量数据，再过滤
results = collection.search(data=[vector], limit=1000, expr="price < 100")

# 快：增加 limit，让 Milvus 内部优化
results = collection.search(data=[vector], limit=10, expr="price < 100")
```

### 3. 只返回必要字段

```python
# 慢：返回所有字段
results = collection.query(expr="category == 'tech'", output_fields=["*"])

# 快：只返回需要的字段
results = collection.query(expr="category == 'tech'", output_fields=["id", "name"])
```

---

## 总结

### 核心要点

1. **Query 用于精确查询**：支持复杂的表达式
2. **Search 用于相似度检索**：返回 Top-K
3. **混合检索结合两者**：向量 + 标量过滤
4. **查询构建器简化代码**：链式调用
5. **性能优化很重要**：选择合适的查询方式

### 最佳实践

1. **使用 IN 代替多个 OR**
2. **只返回必要的字段**
3. **批量查询提升性能**
4. **使用查询构建器**
5. **性能基准测试**

---

**下一步**: 学习 [12_实战代码_场景4_Upsert与数据更新.md](./12_实战代码_场景4_Upsert与数据更新.md)
