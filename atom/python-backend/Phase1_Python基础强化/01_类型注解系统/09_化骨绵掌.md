# 化骨绵掌

将类型注解系统拆分成10个2分钟知识卡片，每个独立完整。

---

## 卡片1：类型注解的本质

**一句话：** 类型注解是存储在函数/变量的 `__annotations__` 属性中的元数据，运行时不影响代码执行。

**举例：**
```python
def greet(name: str) -> str:
    return f"Hello, {name}"

# 查看类型注解
print(greet.__annotations__)
# {'name': <class 'str'>, 'return': <class 'str'>}

# 运行时不检查类型
result = greet(123)  # 不报错
print(result)  # Hello, 123
```

**应用：** FastAPI 读取 `__annotations__` 来生成 API 文档和验证请求。

---

## 卡片2：基础类型注解语法

**一句话：** 使用 `: 类型` 注解变量和参数，使用 `-> 类型` 注解返回值。

**举例：**
```python
# 变量注解
name: str = "Alice"
age: int = 25
price: float = 99.99
is_active: bool = True

# 函数注解
def calculate(x: int, y: float) -> float:
    return x + y

# 类属性注解
class User:
    name: str
    age: int

    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age
```

**应用：** 在 FastAPI 路由中定义参数类型，自动验证和转换。

---

## 卡片3：Optional 类型的正确使用

**一句话：** `Optional[T]` 表示值可以是 T 或 None，使用时必须检查 None。

**举例：**
```python
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    users = {1: "Alice", 2: "Bob"}
    return users.get(user_id)  # 可能返回 None

# ❌ 错误：不检查 None
name = find_user(999)
print(name.upper())  # AttributeError: 'NoneType' object has no attribute 'upper'

# ✅ 正确：检查 None
name = find_user(999)
if name is not None:
    print(name.upper())
else:
    print("User not found")

# ✅ 或使用默认值
name = find_user(999) or "Unknown"
print(name.upper())
```

**应用：** 数据库查询结果、API 响应中的可选字段。

---

## 卡片4：List 和 Dict 的类型注解

**一句话：** 使用 `list[T]` 和 `dict[K, V]` 指定容器内元素的类型。

**举例：**
```python
# Python 3.9+ 写法
names: list[str] = ["Alice", "Bob", "Charlie"]
scores: dict[str, int] = {"Alice": 95, "Bob": 87}

# 旧写法（兼容性更好）
from typing import List, Dict
names: List[str] = ["Alice", "Bob"]
scores: Dict[str, int] = {"Alice": 95}

# 嵌套类型
users: list[dict[str, str]] = [
    {"name": "Alice", "email": "alice@example.com"},
    {"name": "Bob", "email": "bob@example.com"}
]

# 函数使用
def get_top_scores(scores: dict[str, int], n: int) -> list[tuple[str, int]]:
    sorted_scores = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    return sorted_scores[:n]
```

**应用：** API 响应列表、配置字典、批量数据处理。

---

## 卡片5：Union 类型处理多种可能

**一句话：** `Union[A, B]` 表示值可以是 A 或 B 类型，Python 3.10+ 可以用 `A | B`。

**举例：**
```python
from typing import Union

# 旧写法
def process_id(user_id: Union[int, str]) -> str:
    if isinstance(user_id, int):
        return f"ID: {user_id}"
    else:
        return f"Username: {user_id}"

# Python 3.10+ 新写法
def process_id(user_id: int | str) -> str:
    if isinstance(user_id, int):
        return f"ID: {user_id}"
    else:
        return f"Username: {user_id}"

# 多种类型
def parse_value(value: int | float | str) -> float:
    if isinstance(value, str):
        return float(value)
    return float(value)

# 使用
result1 = process_id(123)  # "ID: 123"
result2 = process_id("alice")  # "Username: alice"
```

**应用：** 处理灵活的输入格式、API 参数的多种类型。

---

## 卡片6：Pydantic 模型定义

**一句话：** Pydantic BaseModel 结合类型注解实现运行时数据验证和转换。

**举例：**
```python
from pydantic import BaseModel, Field, validator
from typing import Optional

class User(BaseModel):
    id: int
    name: str = Field(..., min_length=1, max_length=50)
    email: str
    age: Optional[int] = Field(None, ge=0, le=150)
    is_active: bool = True

    @validator('email')
    def validate_email(cls, v):
        if '@' not in v:
            raise ValueError('Invalid email')
        return v.lower()

# 使用
user = User(
    id=1,
    name="Alice",
    email="ALICE@EXAMPLE.COM",
    age=25
)
print(user.email)  # alice@example.com（自动转小写）

# 验证失败
try:
    bad_user = User(id=1, name="", email="invalid", age=200)
except ValueError as e:
    print(e)  # 详细的验证错误
```

**应用：** FastAPI 请求体验证、配置文件解析、数据库模型。

---

## 卡片7：泛型（Generic）的使用

**一句话：** 泛型允许定义可复用的类型模板，适用于任何类型。

**举例：**
```python
from typing import TypeVar, Generic, List, Optional

T = TypeVar('T')

class Stack(Generic[T]):
    def __init__(self):
        self._items: List[T] = []

    def push(self, item: T) -> None:
        self._items.append(item)

    def pop(self) -> Optional[T]:
        return self._items.pop() if self._items else None

    def peek(self) -> Optional[T]:
        return self._items[-1] if self._items else None

# 使用
int_stack = Stack[int]()
int_stack.push(1)
int_stack.push(2)
print(int_stack.pop())  # 2（类型：Optional[int]）

str_stack = Stack[str]()
str_stack.push("hello")
str_stack.push("world")
print(str_stack.pop())  # "world"（类型：Optional[str]）

# IDE 知道类型，提供智能提示
value = int_stack.pop()
if value is not None:
    print(value + 10)  # ✅ IDE 知道 value 是 int
```

**应用：** 缓存系统、数据结构、通用工具类。

---

## 卡片8：mypy 静态类型检查

**一句话：** mypy 在编写代码时检查类型一致性，发现潜在错误。

**举例：**
```python
# app.py
def divide(a: int, b: int) -> float:
    return a / b

result = divide(10, 2)  # ✅ 类型正确
result = divide("10", 2)  # ❌ mypy 报错

# 运行 mypy
# $ mypy app.py
# app.py:5: error: Argument 1 to "divide" has incompatible type "str"; expected "int"

# 配置 mypy
# pyproject.toml
[tool.mypy]
python_version = "3.13"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true  # 强制所有函数有类型注解

# 忽略特定错误
result = divide("10", 2)  # type: ignore

# 按模块配置
[[tool.mypy.overrides]]
module = "app.api.*"
disallow_untyped_defs = true
```

**应用：** CI/CD 集成、pre-commit hook、IDE 实时检查。

---

## 卡片9：Protocol 结构化类型

**一句话：** Protocol 定义结构化类型（duck typing），只要对象有指定方法就符合类型。

**举例：**
```python
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> str:
        ...

class Circle:
    def draw(self) -> str:
        return "Drawing circle"

class Square:
    def draw(self) -> str:
        return "Drawing square"

def render(shape: Drawable) -> None:
    print(shape.draw())

# 使用
circle = Circle()
square = Square()
render(circle)  # ✅ Circle 有 draw 方法
render(square)  # ✅ Square 有 draw 方法

# 不需要继承 Drawable，只要有 draw 方法即可
class Triangle:
    def draw(self) -> str:
        return "Drawing triangle"

render(Triangle())  # ✅ 也可以

# 对比传统继承
from abc import ABC, abstractmethod

class DrawableABC(ABC):
    @abstractmethod
    def draw(self) -> str:
        pass

class CircleABC(DrawableABC):  # 必须继承
    def draw(self) -> str:
        return "Drawing circle"
```

**应用：** 定义接口、插件系统、依赖注入。

---

## 卡片10：FastAPI 中的类型注解

**一句话：** FastAPI 利用类型注解实现自动验证、文档生成和依赖注入。

**举例：**
```python
from fastapi import FastAPI, Query, Path, Body, Depends
from pydantic import BaseModel, Field
from typing import Optional, List

app = FastAPI()

# 1. 路径参数
@app.get("/users/{user_id}")
async def get_user(
    user_id: int = Path(..., ge=1)  # 路径参数，必须 >= 1
):
    return {"user_id": user_id}

# 2. 查询参数
@app.get("/search")
async def search(
    q: str = Query(..., min_length=1),  # 必填查询参数
    limit: int = Query(10, ge=1, le=100),  # 可选，默认10，范围1-100
    offset: int = 0  # 可选，默认0
):
    return {"q": q, "limit": limit, "offset": offset}

# 3. 请求体
class CreateUserRequest(BaseModel):
    name: str = Field(..., min_length=1)
    email: str
    age: int = Field(..., ge=0, le=150)

@app.post("/users")
async def create_user(user: CreateUserRequest):
    # FastAPI 自动验证请求体
    return {"name": user.name, "email": user.email}

# 4. 响应模型
class UserResponse(BaseModel):
    id: int
    name: str
    email: str

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user_detail(user_id: int) -> UserResponse:
    # FastAPI 自动验证返回值
    return UserResponse(id=user_id, name="Alice", email="alice@example.com")

# 5. 依赖注入
async def get_current_user(token: str = Query(...)) -> dict:
    # 验证 token，返回用户信息
    return {"user_id": 1, "name": "Alice"}

@app.get("/me")
async def get_me(current_user: dict = Depends(get_current_user)):
    # current_user 由 get_current_user 提供
    return current_user

# 访问文档：http://localhost:8000/docs
# FastAPI 自动生成交互式 API 文档
```

**应用：** 构建类型安全的 REST API、自动生成 OpenAPI 文档。

---

## 知识卡片总结

### 基础层（卡片1-3）
- **卡片1**：类型注解的本质（元数据）
- **卡片2**：基础语法（变量、函数、类）
- **卡片3**：Optional 类型（处理 None）

### 进阶层（卡片4-6）
- **卡片4**：容器类型（List、Dict）
- **卡片5**：Union 类型（多种可能）
- **卡片6**：Pydantic 模型（运行时验证）

### 高级层（卡片7-9）
- **卡片7**：泛型（Generic）
- **卡片8**：mypy 静态检查
- **卡片9**：Protocol（结构化类型）

### 实战层（卡片10）
- **卡片10**：FastAPI 集成（完整应用）

---

## 学习路径

```
基础语法 → Optional/Union → 容器类型 → Pydantic
    ↓
mypy 检查 → 泛型 → Protocol → FastAPI 实战
```

**每天学习建议：**
- 第1天：卡片1-3（基础）
- 第2天：卡片4-6（进阶）
- 第3天：卡片7-9（高级）
- 第4天：卡片10（实战）
- 第5天：综合练习

---

## 快速参考

### 常用类型

```python
# 基础类型
x: int
y: str
z: float
flag: bool

# 可选类型
value: Optional[int]  # int 或 None
value: int | None  # Python 3.10+

# 容器类型
names: list[str]
ages: dict[str, int]
tags: set[str]
coords: tuple[float, float]

# 联合类型
id: int | str  # int 或 str
result: int | float | None

# 函数类型
from typing import Callable
func: Callable[[int, str], bool]  # (int, str) -> bool

# 任意类型
from typing import Any
data: Any
```

### 常用模式

```python
# 1. 可选参数
def func(x: int, y: Optional[str] = None) -> str:
    pass

# 2. 列表处理
def process(items: list[str]) -> list[int]:
    return [len(item) for item in items]

# 3. 字典处理
def merge(d1: dict[str, int], d2: dict[str, int]) -> dict[str, int]:
    return {**d1, **d2}

# 4. Pydantic 模型
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int

# 5. FastAPI 路由
from fastapi import FastAPI
app = FastAPI()

@app.post("/users", response_model=User)
async def create_user(user: User) -> User:
    return user
```

### mypy 命令

```bash
# 检查单个文件
mypy app.py

# 检查整个项目
mypy app/

# 严格模式
mypy --strict app/

# 忽略缺失的导入
mypy --ignore-missing-imports app/

# 生成报告
mypy --html-report ./mypy-report app/
```

---

## 实战练习

### 练习1：基础类型注解

```python
# 为以下函数添加类型注解
def calculate_total(price, quantity, tax_rate=0.1):
    return price * quantity * (1 + tax_rate)

# 答案
def calculate_total(price: float, quantity: int, tax_rate: float = 0.1) -> float:
    return price * quantity * (1 + tax_rate)
```

### 练习2：Pydantic 模型

```python
# 定义一个 Book 模型，包含：
# - title（必填，字符串，1-100字符）
# - author（必填，字符串）
# - price（必填，浮点数，>= 0）
# - isbn（可选，字符串）

# 答案
from pydantic import BaseModel, Field
from typing import Optional

class Book(BaseModel):
    title: str = Field(..., min_length=1, max_length=100)
    author: str
    price: float = Field(..., ge=0)
    isbn: Optional[str] = None
```

### 练习3：FastAPI 路由

```python
# 创建一个 POST /books 端点，接收 Book 模型，返回创建的书籍

# 答案
from fastapi import FastAPI
app = FastAPI()

@app.post("/books", response_model=Book)
async def create_book(book: Book) -> Book:
    # 保存到数据库（省略）
    return book
```

---

## 常见错误和解决方案

### 错误1：忘记处理 Optional

```python
# ❌ 错误
def get_name(user_id: int) -> Optional[str]:
    return find_user(user_id)

name = get_name(1)
print(name.upper())  # 可能 AttributeError

# ✅ 正确
name = get_name(1)
if name is not None:
    print(name.upper())
```

### 错误2：类型不匹配

```python
# ❌ 错误
def add(a: int, b: int) -> int:
    return str(a + b)  # 返回 str，期望 int

# ✅ 正确
def add(a: int, b: int) -> int:
    return a + b
```

### 错误3：过度使用 Any

```python
# ❌ 不好
def process(data: Any) -> Any:
    return data

# ✅ 好
def process(data: dict[str, int]) -> list[int]:
    return list(data.values())
```

---

## 下一步学习

完成这10个知识卡片后，你应该能够：

1. ✅ 为函数和变量添加类型注解
2. ✅ 使用 Optional、Union、List、Dict 等类型
3. ✅ 定义 Pydantic 模型进行数据验证
4. ✅ 使用 mypy 进行静态类型检查
5. ✅ 在 FastAPI 中应用类型注解

**继续学习：**
- 高级类型：Literal、TypedDict、NewType
- 类型守卫：isinstance、TypeGuard
- 协变和逆变：Covariant、Contravariant
- 类型别名：简化复杂类型定义
