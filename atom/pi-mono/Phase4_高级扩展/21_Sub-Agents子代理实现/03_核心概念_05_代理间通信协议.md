# 核心概念 05：代理间通信协议

## 1. 通信机制

### 1.1 JSON Mode 输出

**Sub-Agents 使用 JSON mode 输出结构化结果。**

```typescript
// 启动参数
spawn('pi', [
  '--mode', 'json',  // 关键：JSON 输出模式
  ...
]);

// 输出格式
{
  "type": "message_end",
  "message": {
    "role": "assistant",
    "content": [{ "type": "text", "text": "..." }],
    "usage": { "input": 1000, "output": 500 }
  }
}
```

### 1.2 事件流协议

**通过 stdout 接收 JSON 事件流。**

```typescript
// 事件类型
- message_end: Assistant 消息完成
- tool_result_end: 工具调用结果
- 其他事件（忽略）

// 解析流程
proc.stdout.on('data', (data) => {
  buffer += data.toString();
  const lines = buffer.split("\n");

  for (const line of lines) {
    const event = JSON.parse(line);
    if (event.type === "message_end") {
      processMessage(event.message);
    }
  }
});
```

---

## 2. 通信模式

### 2.1 单向通信

**主 Agent → Sub-Agent → 主 Agent**

```typescript
// 1. 主 Agent 发送任务
Task: "Find authentication code"

// 2. Sub-Agent 执行并输出
Output: "Found auth code in src/auth.ts"

// 3. 主 Agent 接收结果
Result: { content: "Found auth code...", usage: {...} }
```

**特点**：
- 无双向交互
- 无实时通信
- 简单可靠

### 2.2 Chain Mode 通信

**通过文本传递上下文。**

```typescript
// Step 1 → Step 2
Step 1 Output: "Found 5 files"
Step 2 Input: "Based on Found 5 files, create plan"

// Step 2 → Step 3
Step 2 Output: "Plan: 1. Refactor, 2. Test"
Step 3 Input: "Implement: Plan: 1. Refactor, 2. Test"
```

---

## 3. 2025-2026 协议对比

根据最新研究，业界主流通信协议：

[Source: Google A2A协议](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/)

| 协议 | 类型 | 特点 | 适用场景 |
|------|------|------|---------|
| **A2A** | Agent-to-Agent | 双向通信、任务委托 | 多 Agent 协作 |
| **MCP** | Model Context Protocol | 工具发现、上下文传递 | 工具集成 |
| **ACP** | Agent Communication | HTTP 原生、多模态 | 企业系统 |
| **Pi-mono** | JSON 输出 | 单向、简单 | 开发工具 |

[Source: MCP、ACP与A2A综述](https://camunda.com/blog/2025/05/mcp-acp-a2a-growing-world-inter-agent-communication/)

**Pi-mono 的定位**：
- ✅ 简单：JSON 输出，无需复杂协议
- ✅ 可靠：单向通信，无状态
- ⚠️ 有限：无双向交互、无实时通信

---

## 4. 消息格式

### 4.1 Message 结构

```typescript
interface Message {
  role: "user" | "assistant" | "tool_result";
  content: ContentPart[];
  usage?: Usage;
  model?: string;
  stopReason?: string;
}

interface ContentPart {
  type: "text" | "toolCall";
  text?: string;
  name?: string;
  arguments?: Record<string, any>;
}
```

### 4.2 提取最终输出

```typescript
function getFinalOutput(messages: Message[]): string {
  // 从后往前找第一个 assistant 消息
  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i];
    if (msg.role === "assistant") {
      for (const part of msg.content) {
        if (part.type === "text") return part.text;
      }
    }
  }
  return "";
}
```

---

## 5. 数据序列化

### 5.1 任务描述序列化

```typescript
// 简单文本
task: "Find authentication code"

// 包含上下文（Chain Mode）
task: "Based on Found auth code in src/auth.ts, create plan"

// 复杂任务
task: "Find auth code. Focus on: 1) JWT tokens, 2) OAuth, 3) Session"
```

### 5.2 结果反序列化

```typescript
// JSON 解析
const event = JSON.parse(line);

// 提取内容
const message = event.message;
const text = message.content.find(p => p.type === "text")?.text;

// 提取 usage
const usage = message.usage;
```

---

## 6. 流式更新

### 6.1 实时进度

```typescript
// onUpdate 回调
const emitUpdate = () => {
  if (onUpdate) {
    onUpdate({
      content: [{ type: "text", text: currentOutput }],
      details: { mode: "single", results: [currentResult] }
    });
  }
};

// 在关键节点调用
proc.stdout.on('data', () => {
  processEvent(event);
  emitUpdate();  // 实时更新
});
```

### 6.2 进度显示

```typescript
// Parallel Mode 进度
"Parallel: 2/3 done, 1 running..."

// Chain Mode 进度
"Chain: Step 2/3 (planner) running..."
```

---

## 7. 错误传播

### 7.1 错误消息

```typescript
// LLM 错误
{
  stopReason: "error",
  errorMessage: "API rate limit exceeded"
}

// 进程错误
{
  exitCode: 1,
  stderr: "Command not found: pi"
}
```

### 7.2 错误处理

```typescript
if (result.exitCode !== 0 || result.stopReason === "error") {
  return {
    content: [{ type: "text", text: errorMsg }],
    isError: true
  };
}
```

---

## 8. 性能考虑

### 8.1 通信开销

```typescript
// JSON 解析开销
每个事件: ~0.1ms
总开销: 可忽略

// 网络开销
本地进程: 无网络开销
stdout/stderr: 管道通信，极快
```

### 8.2 缓冲策略

```typescript
// 行缓冲
let buffer = "";
proc.stdout.on('data', (data) => {
  buffer += data.toString();
  const lines = buffer.split("\n");
  buffer = lines.pop() || "";  // 保留不完整行

  for (const line of lines) {
    processLine(line);
  }
});
```

---

## 9. 未来演进

### 9.1 双向通信

```typescript
// 未来可能支持
Sub-Agent → 主 Agent: "Need more context"
主 Agent → Sub-Agent: "Here is additional info"
```

### 9.2 协议标准化

**可能采用 A2A 或 MCP 协议**：
- 标准化消息格式
- 支持工具发现
- 跨平台互操作

---

## 10. 总结

### 核心要点

1. **JSON Mode**：结构化输出
2. **事件流**：stdout 接收事件
3. **单向通信**：简单可靠
4. **文本传递**：Chain Mode 上下文
5. **流式更新**：实时进度

### 关键洞察

- **简单 = 可靠**：JSON 输出足够
- **单向 = 无状态**：无复杂状态管理
- **文本 = 通用**：易于理解和调试
- **未来 = 标准化**：可能采用 A2A/MCP

---

**参考资源**：
- [Google A2A协议](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/)
- [MCP、ACP与A2A综述](https://camunda.com/blog/2025/05/mcp-acp-a2a-growing-world-inter-agent-communication/)
- [代理互操作协议调研](https://arxiv.org/html/2505.02279v1)
