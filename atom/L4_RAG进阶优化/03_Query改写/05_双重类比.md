# 双重类比

用前端开发和日常生活的类比，帮助理解 Query改写的核心概念。

---

## 类比1：Query改写 = 搜索框智能补全

### 前端类比：搜索框自动补全

```
用户输入: "py 异步"
    ↓
搜索框智能补全:
    - "Python 异步编程"
    - "Python asyncio 教程"
    - "Python async await 用法"
    ↓
用户选择或系统自动使用补全后的查询
```

**相似性：**
- 都是将不完整/模糊的输入转换为更精确的查询
- 都是为了提升搜索结果的相关性
- 都发生在实际搜索之前

```javascript
// 前端：搜索框自动补全
const suggestions = await fetchSuggestions(userInput);
const finalQuery = suggestions[0] || userInput;
const results = await search(finalQuery);
```

```python
# RAG：Query改写
rewritten_queries = multi_query_rewrite(user_query)
results = search_with_multiple_queries(rewritten_queries)
```

### 日常生活类比：问路时的翻译

```
你问路: "那个卖咖啡的地方怎么走？"
    ↓
本地人理解并翻译: "你是说星巴克吗？往前走 100 米右转"
    ↓
你得到了准确的指引
```

**相似性：**
- 你的表达（"卖咖啡的地方"）不够精确
- 本地人帮你翻译成精确的名称（"星巴克"）
- 翻译后才能得到准确的结果

---

## 类比2：HyDE = 先写答案再找相似

### 前端类比：以图搜图

```
传统搜索: 用关键词搜索图片
    "蓝色天空 白云" → 搜索结果可能不准确

以图搜图: 先有一张图，找相似的图
    上传一张蓝天白云的图 → 找到相似的图片
```

**HyDE 的思路完全一样：**

```
传统检索: 用问题找答案
    "Python 怎么异步" → 可能找不到最相关的文档

HyDE: 先生成一个"答案"，用答案找答案
    LLM 生成假设答案 → 用这个答案找相似的真实文档
```

```javascript
// 前端：以图搜图
const referenceImage = await generateSimilarImage(description);
const similarImages = await searchByImage(referenceImage);
```

```python
# RAG：HyDE
hypothetical_answer = llm.generate(query)  # 生成假设答案
similar_docs = vector_search(hypothetical_answer)  # 用答案检索
```

### 日常生活类比：用样品找货

```
你想买一件衣服，但不知道叫什么名字:
    ❌ 描述: "那种上面有扣子、领子尖尖的衣服" → 店员可能听不懂
    ✅ 拿样品: 拿一件类似的衣服给店员看 → 店员立刻找到同款
```

**HyDE 就是"先造一个样品"：**
- 用户的问题 = 你的描述（可能不精确）
- LLM 生成的假设答案 = 你拿的样品
- 用样品找货 = 用假设答案检索

---

## 类比3：Multi-Query = 多关键词搜索

### 前端类比：搜索引擎的同义词扩展

```
用户搜索: "手机"
    ↓
搜索引擎自动扩展:
    - "手机"
    - "智能手机"
    - "移动电话"
    - "iPhone"
    - "Android 手机"
    ↓
合并所有结果，去重排序
```

**Multi-Query 做的是同样的事：**

```python
# 用户查询
query = "Python 性能优化"

# Multi-Query 扩展
expanded_queries = [
    "Python 性能优化",
    "Python 代码加速",
    "Python 运行效率提升",
    "Python profiling 分析"
]

# 分别搜索，合并结果
```

```javascript
// 前端：多关键词搜索
const keywords = expandKeywords(userQuery);
const allResults = await Promise.all(
    keywords.map(kw => search(kw))
);
const mergedResults = dedupeAndRank(allResults.flat());
```

### 日常生活类比：找餐厅的多种问法

```
你想找一家吃饭的地方:
    问法1: "附近有什么好吃的？"
    问法2: "这附近有餐厅吗？"
    问法3: "哪里可以吃午饭？"
    问法4: "推荐一下吃饭的地方"
    ↓
每种问法可能得到不同的推荐
    ↓
综合所有推荐，选择最好的
```

---

## 类比4：Query Decomposition = 拆分复杂任务

### 前端类比：复杂表单的分步提交

```
复杂表单: 一次性填写所有信息
    ❌ 用户体验差，容易出错

分步表单: 拆分成多个步骤
    Step 1: 基本信息
    Step 2: 联系方式
    Step 3: 偏好设置
    ✅ 每步简单，整体完成
```

**Query Decomposition 的思路：**

```
复杂问题: "比较 React 和 Vue 在大型项目中的优缺点"
    ↓
拆分为子问题:
    Q1: "React 在大型项目中的优点"
    Q2: "React 在大型项目中的缺点"
    Q3: "Vue 在大型项目中的优点"
    Q4: "Vue 在大型项目中的缺点"
    ↓
分别检索，综合答案
```

```javascript
// 前端：分步表单
const steps = [
    { name: 'basic', fields: ['name', 'email'] },
    { name: 'contact', fields: ['phone', 'address'] },
    { name: 'preferences', fields: ['theme', 'language'] }
];
// 每步单独验证和提交
```

```python
# RAG：Query Decomposition
sub_queries = decompose_query(complex_query)
results = {q: search(q) for q in sub_queries}
final_answer = synthesize(results)
```

### 日常生活类比：做菜的步骤分解

```
复杂任务: "做一道红烧肉"
    ↓
分解为子任务:
    1. 准备食材（五花肉、调料）
    2. 切块焯水
    3. 炒糖色
    4. 加调料炖煮
    ↓
每个子任务都有明确的做法
    ↓
按顺序完成，最终做出红烧肉
```

---

## 类比5：Step-back Prompting = 先学基础再解决问题

### 前端类比：先看文档再写代码

```
遇到问题: "React useEffect 的 cleanup 函数为什么不执行？"
    ↓
Step-back: 先了解基础
    "useEffect 的生命周期是什么？"
    "cleanup 函数什么时候被调用？"
    ↓
有了基础知识，再解决具体问题
```

```javascript
// 前端开发的思路
// 1. 先查文档了解基础
const docs = await fetchDocs('useEffect lifecycle');
// 2. 再解决具体问题
const solution = await searchWithContext(docs, specificQuestion);
```

### 日常生活类比：先学原理再修东西

```
问题: "为什么我的自行车刹车不灵？"
    ↓
Step-back: 先了解原理
    "自行车刹车的工作原理是什么？"
    → 刹车皮摩擦轮圈产生制动力
    ↓
有了原理知识:
    → 检查刹车皮是否磨损
    → 检查刹车线是否松了
    → 找到具体原因并修复
```

---

## 类比总结表

| Query改写技术 | 前端类比 | 日常生活类比 |
|--------------|---------|-------------|
| **Query改写整体** | 搜索框自动补全 | 问路时的翻译 |
| **HyDE** | 以图搜图 | 用样品找货 |
| **Multi-Query** | 同义词扩展搜索 | 多种问法找餐厅 |
| **Query Decomposition** | 分步表单 | 做菜步骤分解 |
| **Step-back Prompting** | 先看文档再写代码 | 先学原理再修东西 |
| **Query Expansion** | 搜索建议词 | 问路时补充地标 |

---

## 代码对照

| 概念 | 前端代码 | RAG 代码 |
|------|---------|---------|
| 查询改写 | `autocomplete(input)` | `rewrite_query(query)` |
| HyDE | `searchByImage(refImg)` | `search(hyde_doc)` |
| Multi-Query | `Promise.all(queries.map(search))` | `[search(q) for q in queries]` |
| 结果融合 | `dedupeAndRank(results)` | `rrf_fusion(results)` |

---

**下一步：** [06_反直觉点](./06_反直觉点.md) - 避开 Query改写的常见误区
