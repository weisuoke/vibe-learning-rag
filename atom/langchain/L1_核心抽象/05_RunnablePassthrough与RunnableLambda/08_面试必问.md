# 08_面试必问

> **学习目标**：掌握 RunnablePassthrough 与 RunnableLambda 的高频面试题和标准答案

---

## 面试题分类

### 基础概念题（必考）

适用于：初级/中级岗位，考察基础理解

### 实战应用题（高频）

适用于：中级/高级岗位，考察实际经验

### 原理深入题（加分）

适用于：高级/专家岗位，考察深度理解

---

## 基础概念题

### 问题 1：RunnablePassthrough 和 RunnableLambda 的区别是什么？

**难度**：⭐⭐ 基础

**考察点**：基本概念理解

**标准答案**：

RunnablePassthrough 和 RunnableLambda 是 LangChain LCEL 中的两个核心数据转换工具，主要区别如下：

**RunnablePassthrough**：
- **作用**：透传输入数据，保持不变
- **核心方法**：`assign()` 用于添加新字段
- **使用场景**：RAG 中保留原始查询并添加检索上下文
- **类型签名**：`Runnable[Input, Input]`（输入类型 = 输出类型）

**RunnableLambda**：
- **作用**：将任意 Python 函数包装为标准 Runnable
- **核心功能**：实现自定义数据转换逻辑
- **使用场景**：查询预处理、数据后处理、外部 API 集成
- **类型签名**：`Runnable[Input, Output]`（输入输出类型可不同）

**代码示例**：
```python
from langchain_core.runnables import RunnablePassthrough, RunnableLambda

# RunnablePassthrough：保留输入 + 添加字段
chain1 = RunnablePassthrough.assign(context=retriever)

# RunnableLambda：自定义转换
def process(x):
    return x.upper()

chain2 = RunnableLambda(process)
```

**关键点**：
- Passthrough 用于数据保留，Lambda 用于数据转换
- Passthrough 输入输出类型相同，Lambda 可以不同
- 两者常配合使用构建复杂管道

---

### 问题 2：RunnablePassthrough.assign() 的行为是什么？

**难度**：⭐⭐ 基础

**考察点**：assign() 方法的理解

**标准答案**：

`RunnablePassthrough.assign()` 是**扩展**输入，而不是替换输入。

**核心行为**：
1. **保留原始输入**：所有原始字段都保留
2. **添加新字段**：通过 kwargs 指定的新字段会被添加
3. **覆盖同名字段**：如果新字段与原字段同名，会被覆盖

**代码示例**：
```python
from langchain_core.runnables import RunnablePassthrough

# 输入数据
input_data = {
    "query": "什么是 LangChain?",
    "user": "alice"
}

# 使用 assign 添加字段
chain = RunnablePassthrough.assign(
    context="检索结果",
    timestamp="2026-02-18"
)

result = chain.invoke(input_data)

# 输出结果
print(result)
# {
#     "query": "什么是 LangChain?",  # 保留
#     "user": "alice",                # 保留
#     "context": "检索结果",          # 新增
#     "timestamp": "2026-02-18"       # 新增
# }
```

**常见误区**：
- ❌ 认为 assign 会替换整个输入
- ❌ 认为 assign 只保留指定的字段
- ✅ 正确理解：assign 是 `{...input, **new_fields}` 的行为

**面试加分点**：
- 提到浅拷贝机制（不复制值，只复制引用）
- 提到键冲突时的覆盖行为
- 举例说明在 RAG 中的典型用法

---

## 实战应用题

### 问题 3：如何在 RAG 管道中使用 RunnablePassthrough？

**难度**：⭐⭐⭐ 中级

**考察点**：实际应用能力

**标准答案**：

在 RAG 管道中，RunnablePassthrough 主要用于保留原始查询的同时添加检索上下文。

**完整示例**：
```python
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_core.output_parsers import StrOutputParser
from langchain_chroma import Chroma

# 1. 初始化组件
llm = ChatOpenAI(model="gpt-4o-mini")
embeddings = OpenAIEmbeddings()

# 2. 创建向量存储和检索器
vectorstore = Chroma(
    collection_name="docs",
    embedding_function=embeddings
)
retriever = vectorstore.as_retriever(search_kwargs={"k": 3})

# 3. 创建 Prompt 模板
prompt = ChatPromptTemplate.from_template("""
根据以下上下文回答问题：

上下文：
{context}

问题：{query}

答案：
""")

# 4. 构建 RAG 链
rag_chain = (
    RunnablePassthrough.assign(
        context=lambda x: retriever.invoke(x["query"])
    )
    | prompt
    | llm
    | StrOutputParser()
)

# 5. 使用
answer = rag_chain.invoke({"query": "什么是 LangChain?"})
print(answer)
```

**数据流动**：
```
输入: {"query": "什么是 LangChain?"}
  ↓
RunnablePassthrough.assign(context=retriever)
  ↓
{"query": "什么是 LangChain?", "context": [doc1, doc2, doc3]}
  ↓
prompt（填充模板）
  ↓
llm（生成答案）
  ↓
StrOutputParser()（提取文本）
  ↓
输出: "LangChain 是一个用于构建 LLM 应用的框架..."
```

**关键点**：
- 使用 lambda 函数从输入中提取 query 字段
- retriever 的输出自动赋值给 context 字段
- prompt 模板可以同时访问 query 和 context

**面试加分点**：
- 提到可以添加多个字段（如元数据、时间戳）
- 提到错误处理（如检索失败的情况）
- 提到性能优化（如批处理、缓存）

---

### 问题 4：如何使用 RunnableLambda 实现查询改写？

**难度**：⭐⭐⭐ 中级

**考察点**：自定义逻辑集成

**标准答案**：

使用 RunnableLambda 可以将查询改写函数集成到 RAG 管道中，提高检索质量。

**完整示例**：
```python
from langchain_core.runnables import RunnableLambda, RunnablePassthrough
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# 1. 定义查询改写函数
def rewrite_query(input_dict):
    """
    将简短查询扩展为更详细的检索查询
    """
    query = input_dict["query"]

    # 简单的改写逻辑（实际可以用 LLM）
    if len(query) < 10:
        rewritten = f"请详细解释：{query}，包括定义、用途和示例"
    else:
        rewritten = query

    return {
        "query": rewritten,
        "original_query": query  # 保留原始查询
    }

# 2. 构建链
rag_chain = (
    RunnableLambda(rewrite_query)  # 改写查询
    | RunnablePassthrough.assign(
        context=lambda x: retriever.invoke(x["query"])
    )
    | prompt
    | llm
)

# 3. 使用
answer = rag_chain.invoke({"query": "RAG"})

# 内部流程：
# 1. "RAG" → 改写为 "请详细解释：RAG，包括定义、用途和示例"
# 2. 用改写后的查询检索
# 3. 生成答案
```

**高级版本（使用 LLM 改写）**：
```python
# 使用 LLM 进行查询改写
rewrite_llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
rewrite_prompt = ChatPromptTemplate.from_template(
    "将以下查询改写为更详细的检索查询：\n\n{query}\n\n改写后的查询："
)

async def llm_rewrite_query(input_dict):
    """使用 LLM 改写查询"""
    query = input_dict["query"]

    # 调用 LLM 改写
    rewrite_chain = rewrite_prompt | rewrite_llm | StrOutputParser()
    rewritten = await rewrite_chain.ainvoke({"query": query})

    return {
        "query": rewritten,
        "original_query": query
    }

# 集成到 RAG 链
rag_chain = (
    RunnableLambda(llm_rewrite_query)
    | RunnablePassthrough.assign(context=retriever)
    | prompt
    | llm
)
```

**关键点**：
- 改写函数返回字典，包含改写后的查询和原始查询
- 使用 RunnableLambda 包装函数为 Runnable
- 可以使用简单规则或 LLM 进行改写

**面试加分点**：
- 提到异步处理（使用 async/await）
- 提到错误处理和降级策略
- 提到查询改写的评估方法

---

### 问题 5：如何处理 RunnableLambda 中的异常和重试？

**难度**：⭐⭐⭐⭐ 高级

**考察点**：生产环境最佳实践

**标准答案**：

在生产环境中，RunnableLambda 中的异常处理和重试机制至关重要，主要有两种方式：

**方式 1：函数内部处理**：
```python
import logging
from langchain_core.runnables import RunnableLambda

logger = logging.getLogger(__name__)

def safe_api_call(input_dict):
    """
    带错误处理的 API 调用
    """
    try:
        # 调用外部 API
        response = requests.get(
            "https://api.example.com/data",
            timeout=5
        )
        response.raise_for_status()
        return response.json()

    except requests.Timeout:
        logger.error("API 调用超时")
        return {"error": "timeout", "fallback": "default_value"}

    except requests.HTTPError as e:
        logger.error(f"API 返回错误: {e}")
        return {"error": "http_error", "fallback": "default_value"}

    except Exception as e:
        logger.error(f"未知错误: {e}")
        return {"error": "unknown", "fallback": "default_value"}

# 使用
chain = RunnableLambda(safe_api_call) | llm
```

**方式 2：使用 with_retry()**：
```python
import httpx
from langchain_core.runnables import RunnableLambda

async def risky_api_call(input_dict):
    """
    可能失败的 API 调用
    """
    async with httpx.AsyncClient(timeout=5.0) as client:
        response = await client.get("https://api.example.com/data")
        response.raise_for_status()
        return response.json()

# 添加重试机制
safe_api_call = RunnableLambda(risky_api_call).with_retry(
    stop_after_attempt=3,              # 最多重试 3 次
    wait_exponential_multiplier=1,     # 指数退避
    wait_exponential_max=10,           # 最大等待 10 秒
    retry_if_exception_type=(          # 只重试特定异常
        httpx.TimeoutException,
        httpx.HTTPStatusError
    )
)

# 集成到链中
chain = safe_api_call | RunnablePassthrough.assign(context=retriever) | llm
```

**方式 3：组合使用（推荐）**：
```python
import httpx
from langchain_core.runnables import RunnableLambda

async def api_call_with_fallback(input_dict):
    """
    带降级策略的 API 调用
    """
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.get("https://api.example.com/data")
            response.raise_for_status()
            return response.json()
    except Exception as e:
        logger.warning(f"主 API 失败: {e}，使用降级策略")
        # 降级策略：使用缓存或默认值
        return get_cached_data() or {"fallback": True}

# 添加重试 + 降级
safe_call = (
    RunnableLambda(api_call_with_fallback)
    .with_retry(stop_after_attempt=3)
    .with_fallbacks([
        RunnableLambda(lambda x: {"fallback": "complete_failure"})
    ])
)
```

**最佳实践**：
1. **分层错误处理**：
   - 函数内部：处理预期的错误（超时、4xx 错误）
   - with_retry：处理临时性错误（网络抖动、5xx 错误）
   - with_fallbacks：处理完全失败的情况

2. **只重试可恢复的错误**：
   ```python
   # ✅ 重试临时性错误
   retry_if_exception_type=(
       httpx.TimeoutException,
       httpx.NetworkError,
       httpx.HTTPStatusError  # 5xx 错误
   )

   # ❌ 不要重试永久性错误（如 4xx）
   ```

3. **添加日志和监控**：
   ```python
   def monitored_api_call(input_dict):
       start_time = time.time()
       try:
           result = api_call(input_dict)
           logger.info(f"API 调用成功，耗时: {time.time() - start_time:.2f}秒")
           return result
       except Exception as e:
           logger.error(f"API 调用失败: {e}")
           raise
   ```

**面试加分点**：
- 提到指数退避的重要性
- 提到监控和告警
- 提到降级策略和熔断机制
- 提到成本控制（避免无限重试）

---

## 原理深入题

### 问题 6：RunnablePassthrough.assign() 的实现原理是什么？

**难度**：⭐⭐⭐⭐⭐ 专家

**考察点**：源码理解和设计思想

**标准答案**：

`RunnablePassthrough.assign()` 的实现基于以下核心原理：

**1. 类方法设计**：
```python
class RunnablePassthrough(Runnable):
    @classmethod
    def assign(cls, **kwargs) -> Runnable:
        """
        类方法，不需要实例化
        返回一个新的 RunnableAssign 对象
        """
        return RunnableAssign(kwargs)
```

**为什么是类方法？**
- 不需要实例化，使用更简洁
- 符合函数式编程范式
- 返回新对象，保持不可变性

**2. RunnableAssign 实现**：
```python
class RunnableAssign(Runnable):
    def __init__(self, mappers: dict):
        self.mappers = mappers

    def invoke(self, input: dict) -> dict:
        # 1. 浅拷贝输入（避免修改原对象）
        output = input.copy()

        # 2. 遍历所有 mapper
        for key, mapper in self.mappers.items():
            if callable(mapper):
                # 如果是函数，调用函数
                output[key] = mapper(input)
            elif isinstance(mapper, Runnable):
                # 如果是 Runnable，调用 invoke
                output[key] = mapper.invoke(input)
            else:
                # 否则直接赋值
                output[key] = mapper

        return output
```

**3. 性能考虑**：
- **浅拷贝**：只复制字典结构，不复制值（引用）
- **时间复杂度**：O(n + m)，n 是输入字典大小，m 是 mapper 数量
- **空间复杂度**：O(n)，但值是引用，不占额外空间

**4. 类型推断**：
```python
from typing import TypeVar, Dict

Input = TypeVar("Input", bound=Dict)

class RunnableAssign(Runnable[Input, Input]):
    """
    类型签名：Runnable[Input, Input]
    输入类型 = 输出类型（都是字典）
    """
    pass
```

**5. 设计权衡**：
- **不可变 vs 性能**：选择不可变（每次创建新对象）
- **灵活性 vs 复杂度**：支持多种 mapper 类型（函数、Runnable、常量）
- **简单性 vs 功能**：只提供 assign，不提供 filter、map 等

**面试加分点**：
- 提到浅拷贝的性能优势
- 提到不可变设计的线程安全性
- 提到类型系统的作用
- 对比其他可能的设计方案

---

### 问题 7：同步函数在异步链中会有什么问题？如何解决？

**难度**：⭐⭐⭐⭐⭐ 专家

**考察点**：异步编程理解

**标准答案**：

同步函数在异步链中会阻塞整个事件循环，导致性能严重下降。

**问题演示**：
```python
import time
import asyncio
from langchain_core.runnables import RunnableLambda

# 同步函数（阻塞）
def slow_sync(x):
    time.sleep(5)  # 阻塞整个事件循环
    return x

# 异步链
chain = RunnableLambda(slow_sync) | llm

# 并发测试
async def test():
    tasks = [
        chain.ainvoke("request 1"),
        chain.ainvoke("request 2"),
        chain.ainvoke("request 3")
    ]

    start = time.time()
    results = await asyncio.gather(*tasks)
    elapsed = time.time() - start

    print(f"耗时: {elapsed:.2f}秒")
    # 输出: 耗时: 15.00秒（串行执行！）
    # 期望: 耗时: 5.00秒（并行执行）
```

**原因分析**：
1. **事件循环阻塞**：`time.sleep()` 是同步阻塞调用
2. **无法并发**：阻塞期间，事件循环无法处理其他任务
3. **性能下降**：吞吐量降低 N 倍（N 是并发数）

**解决方案 1：使用异步函数**：
```python
import asyncio

async def fast_async(x):
    await asyncio.sleep(5)  # 异步非阻塞
    return x

chain = RunnableLambda(fast_async) | llm

# 并发测试
async def test():
    tasks = [
        chain.ainvoke("request 1"),
        chain.ainvoke("request 2"),
        chain.ainvoke("request 3")
    ]

    start = time.time()
    results = await asyncio.gather(*tasks)
    elapsed = time.time() - start

    print(f"耗时: {elapsed:.2f}秒")
    # 输出: 耗时: 5.00秒（并行执行！）
```

**解决方案 2：使用 asyncio.to_thread()**：
```python
import asyncio

def slow_sync(x):
    time.sleep(5)
    return x

async def async_wrapper(x):
    # 在线程池中运行同步函数
    return await asyncio.to_thread(slow_sync, x)

chain = RunnableLambda(async_wrapper) | llm
```

**解决方案 3：使用异步库**：
```python
# ❌ 同步 HTTP 库
import requests

def sync_fetch(url):
    return requests.get(url).json()

# ✅ 异步 HTTP 库
import httpx

async def async_fetch(url):
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.json()
```

**性能对比**：
```
场景：10 个并发请求，每个请求耗时 1 秒

同步版本：
- 总耗时：10 秒（串行）
- 吞吐量：1 请求/秒

异步版本：
- 总耗时：1 秒（并行）
- 吞吐量：10 请求/秒

性能提升：10 倍
```

**最佳实践**：
1. **优先使用异步**：在异步链中始终使用异步函数
2. **使用异步库**：httpx、aiofiles、asyncpg 等
3. **避免阻塞操作**：time.sleep、requests、open 等
4. **必要时使用线程池**：asyncio.to_thread() 包装同步函数

**面试加分点**：
- 提到事件循环的工作原理
- 提到 GIL 的影响
- 提到性能监控和分析方法
- 提到生产环境的实际案例

---

## 快速复习卡片

### 卡片 1：核心区别

**Q**: RunnablePassthrough vs RunnableLambda？

**A**:
- **Passthrough**：透传 + assign 扩展
- **Lambda**：函数包装 + 自定义转换
- **配合使用**：Passthrough 保留，Lambda 转换

---

### 卡片 2：assign() 行为

**Q**: assign() 会替换输入吗？

**A**:
- ❌ 不会替换
- ✅ 扩展输入（保留所有原始字段）
- ⚠️ 同名字段会被覆盖

---

### 卡片 3：异步处理

**Q**: 同步函数在异步链中的问题？

**A**:
- **问题**：阻塞事件循环
- **影响**：性能下降 10x+
- **解决**：使用异步函数

---

### 卡片 4：错误处理

**Q**: 如何处理 Lambda 中的异常？

**A**:
- **方式 1**：函数内部 try-except
- **方式 2**：with_retry() 自动重试
- **方式 3**：with_fallbacks() 降级策略

---

### 卡片 5：RAG 应用

**Q**: RAG 中如何使用 Passthrough？

**A**:
```python
chain = (
    RunnablePassthrough.assign(context=retriever)
    | prompt
    | llm
)
```

---

## 面试准备建议

### 初级岗位（1-2 年经验）

**重点准备**：
- 基础概念题（问题 1-2）
- 简单的 RAG 示例
- assign() 的基本用法

**加分项**：
- 能写出完整的 RAG 代码
- 理解数据流动过程

---

### 中级岗位（2-5 年经验）

**重点准备**：
- 实战应用题（问题 3-5）
- 查询改写和错误处理
- 异步处理基础

**加分项**：
- 有生产环境经验
- 能优化性能
- 理解最佳实践

---

### 高级岗位（5+ 年经验）

**重点准备**：
- 原理深入题（问题 6-7）
- 源码理解
- 设计权衡

**加分项**：
- 能设计复杂系统
- 能解决性能瓶颈
- 有架构经验

---

## 总结

**必须掌握的 3 个问题**：
1. RunnablePassthrough 和 RunnableLambda 的区别
2. assign() 的行为（扩展而非替换）
3. RAG 中的典型用法

**加分的 2 个问题**：
1. 异步处理和性能优化
2. 错误处理和重试机制

---

**参考资料**：
- [LangChain 官方文档](https://python.langchain.com/docs/concepts/lcel/) (2025)
- [Building Production-Ready AI Pipelines](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557) (2026)
- [LangChain Best Practices](https://www.swarnendu.de/blog/langchain-best-practices) (2025)

---

**版本**：v1.0
**最后更新**：2026-02-18
