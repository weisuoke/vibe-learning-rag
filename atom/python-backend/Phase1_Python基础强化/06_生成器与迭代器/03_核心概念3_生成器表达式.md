# 核心概念3：生成器表达式

> 理解生成器表达式：最简洁的惰性求值语法

---

## 什么是生成器表达式？

**生成器表达式**是创建生成器的最简洁方式，语法类似列表推导式，但使用圆括号 `()` 而非方括号 `[]`。

**核心特征：**
1. 语法：`(expression for item in iterable if condition)`
2. 返回生成器对象（不是列表）
3. 惰性求值（按需计算）
4. 内存高效（不存储全部结果）

---

## 一句话定义

**生成器表达式是使用圆括号的列表推导式语法创建生成器的简洁方式，实现惰性求值和内存高效的数据处理。**

---

## 基本语法

### 列表推导式 vs 生成器表达式

```python
# 列表推导式：立即计算全部，使用 []
squares_list = [x**2 for x in range(5)]
print(squares_list)  # [0, 1, 4, 9, 16]
print(type(squares_list))  # <class 'list'>

# 生成器表达式：惰性计算，使用 ()
squares_gen = (x**2 for x in range(5))
print(squares_gen)  # <generator object <genexpr> at 0x...>
print(type(squares_gen))  # <class 'generator'>

# 使用生成器
for square in squares_gen:
    print(square)  # 0, 1, 4, 9, 16
```

**唯一区别：括号类型**
- `[]` = 列表推导式（立即计算）
- `()` = 生成器表达式（惰性计算）

---

## 完整语法结构

```python
# 基本形式
gen = (expression for item in iterable)

# 带条件过滤
gen = (expression for item in iterable if condition)

# 多层循环
gen = (expression for item1 in iterable1 for item2 in iterable2)

# 多层循环 + 条件
gen = (expression for item1 in iterable1 if condition1
                  for item2 in iterable2 if condition2)
```

### 示例

```python
# 1. 基本形式
squares = (x**2 for x in range(10))

# 2. 带条件过滤
even_squares = (x**2 for x in range(10) if x % 2 == 0)

# 3. 多层循环
pairs = ((x, y) for x in range(3) for y in range(3))

# 4. 复杂表达式
processed = (item.strip().upper() for item in lines if item)
```

---

## 内存对比

### 实际测试

```python
import sys

# 列表推导式：占用大量内存
list_comp = [x for x in range(1_000_000)]
print(f"列表大小: {sys.getsizeof(list_comp) / 1024 / 1024:.2f} MB")

# 生成器表达式：几乎不占内存
gen_exp = (x for x in range(1_000_000))
print(f"生成器大小: {sys.getsizeof(gen_exp)} 字节")
```

**输出：**
```
列表大小: 8.00 MB
生成器大小: 128 字节
```

**内存差异：约 60000 倍！**

---

## 性能对比

### 场景1：只需要前几个元素

```python
import time

# 列表推导式：计算全部 100 万个
start = time.time()
squares_list = [x**2 for x in range(1_000_000)]
first_10 = squares_list[:10]
print(f"列表方式: {time.time() - start:.3f}s")

# 生成器表达式：只计算前 10 个
start = time.time()
squares_gen = (x**2 for x in range(1_000_000))
first_10 = [next(squares_gen) for _ in range(10)]
print(f"生成器方式: {time.time() - start:.6f}s")
```

**输出：**
```
列表方式: 0.123s
生成器方式: 0.000002s
```

### 场景2：需要全部元素

```python
# 如果需要全部元素，列表推导式更快
import time

# 列表推导式
start = time.time()
result = sum([x**2 for x in range(1_000_000)])
print(f"列表方式: {time.time() - start:.3f}s")

# 生成器表达式
start = time.time()
result = sum(x**2 for x in range(1_000_000))
print(f"生成器方式: {time.time() - start:.3f}s")
```

**结论：**
- 只需要部分元素 → 生成器表达式更快
- 需要全部元素 → 两者性能相近，但生成器更省内存

---

## 实际应用场景

### 场景1：过滤大数据集

```python
# 从大文件中过滤特定行
def filter_log_errors(filename):
    """只返回包含 ERROR 的行"""
    with open(filename) as f:
        return (line.strip() for line in f if 'ERROR' in line)

# 使用
for error_line in filter_log_errors('app.log'):
    print(error_line)
```

### 场景2：数据转换

```python
# 转换数据格式
data = ['1', '2', '3', '4', '5']

# 转换为整数并平方
squares = (int(x)**2 for x in data)

for square in squares:
    print(square)  # 1, 4, 9, 16, 25
```

### 场景3：链式处理

```python
# 多步数据处理
numbers = range(100)

# 链式处理：过滤 → 转换 → 再过滤
result = (x * 2 for x in (x for x in numbers if x % 2 == 0) if x > 10)

for num in result:
    print(num)
```

### 场景4：与内置函数结合

```python
# sum()
total = sum(x**2 for x in range(100))

# max()
maximum = max(x**2 for x in range(100))

# any()
has_even = any(x % 2 == 0 for x in range(10))

# all()
all_positive = all(x > 0 for x in range(1, 10))

# sorted()
sorted_squares = sorted(x**2 for x in range(-5, 5))
```

---

## 生成器表达式 vs 生成器函数

### 何时使用生成器表达式？

```python
# ✅ 适合用生成器表达式的场景
# 1. 简单的转换
squares = (x**2 for x in range(10))

# 2. 简单的过滤
evens = (x for x in range(10) if x % 2 == 0)

# 3. 简单的组合
pairs = ((x, y) for x in range(3) for y in range(3))
```

### 何时使用生成器函数？

```python
# ✅ 适合用生成器函数的场景
# 1. 复杂的逻辑
def complex_generator(data):
    for item in data:
        if condition1(item):
            processed = process1(item)
        else:
            processed = process2(item)
        if condition2(processed):
            yield processed

# 2. 需要多个 yield
def multi_yield():
    yield from range(5)
    yield from range(10, 15)

# 3. 需要状态管理
def stateful_generator():
    state = initialize_state()
    while True:
        value = compute(state)
        yield value
        state = update_state(state)
```

---

## 在 AI Agent 开发中的应用

### 应用1：批量处理数据

```python
# 批量处理用户数据
def process_users(users):
    """批量处理用户数据（内存高效）"""
    return (
        {
            'id': user.id,
            'name': user.name.upper(),
            'email': user.email.lower()
        }
        for user in users
        if user.is_active
    )

# 使用
for processed_user in process_users(db.query(User).all()):
    send_email(processed_user)
```

### 应用2：流式数据转换

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse

app = FastAPI()

@app.get("/stream-data")
async def stream_data():
    """流式返回处理后的数据"""
    data = fetch_large_dataset()

    # 使用生成器表达式转换数据
    processed = (
        f"data: {item['value']}\n\n"
        for item in data
        if item['status'] == 'active'
    )

    return StreamingResponse(
        processed,
        media_type="text/event-stream"
    )
```

### 应用3：数据管道

```python
# 构建数据处理管道
def build_pipeline(filename):
    """构建数据处理管道"""
    # 读取文件
    lines = (line.strip() for line in open(filename))

    # 过滤空行
    non_empty = (line for line in lines if line)

    # 解析 JSON
    import json
    records = (json.loads(line) for line in non_empty)

    # 过滤有效记录
    valid = (r for r in records if r.get('status') == 'valid')

    # 提取字段
    result = (
        {'id': r['id'], 'value': r['value']}
        for r in valid
    )

    return result

# 使用
for record in build_pipeline('data.jsonl'):
    process(record)
```

---

## 常见模式

### 模式1：条件表达式

```python
# 在表达式中使用条件
result = (
    x if x > 0 else -x  # 绝对值
    for x in range(-5, 5)
)
```

### 模式2：嵌套生成器

```python
# 展平嵌套列表
nested = [[1, 2], [3, 4], [5, 6]]
flattened = (item for sublist in nested for item in sublist)
list(flattened)  # [1, 2, 3, 4, 5, 6]
```

### 模式3：多重过滤

```python
# 多个过滤条件
result = (
    x
    for x in range(100)
    if x % 2 == 0  # 偶数
    if x % 3 == 0  # 3的倍数
    if x > 10      # 大于10
)
```

### 模式4：元组解包

```python
# 处理键值对
data = [('a', 1), ('b', 2), ('c', 3)]
values = (v for k, v in data if k != 'b')
```

---

## 最佳实践

### 实践1：括号可以省略

```python
# 在函数调用中，括号可以省略
sum((x**2 for x in range(10)))  # 有括号
sum(x**2 for x in range(10))    # 省略括号（推荐）

# 但在其他地方不能省略
gen = (x**2 for x in range(10))  # 必须有括号
```

### 实践2：保持简洁

```python
# ✅ 推荐：简洁的生成器表达式
squares = (x**2 for x in range(10))

# ❌ 不推荐：复杂的生成器表达式
complex = (
    process(transform(x)) if condition1(x) else alternative(x)
    for x in data
    if condition2(x) and condition3(x)
)
# 应该改用生成器函数
```

### 实践3：命名清晰

```python
# ✅ 推荐：清晰的变量名
active_users = (user for user in users if user.is_active)

# ❌ 不推荐：模糊的变量名
gen = (x for x in data if x.status)
```

---

## 常见陷阱

### 陷阱1：循环变量的闭包问题

```python
# ❌ 错误：循环变量被共享
funcs = [lambda: i for i in range(5)]
print([f() for f in funcs])  # [4, 4, 4, 4, 4]（都是最后的值）

# ✅ 正确：使用默认参数
funcs = [lambda i=i: i for i in range(5)]
print([f() for f in funcs])  # [0, 1, 2, 3, 4]

# ✅ 或者使用生成器表达式
gen = (i for i in range(5))
print(list(gen))  # [0, 1, 2, 3, 4]
```

### 陷阱2：生成器只能遍历一次

```python
# ❌ 错误：尝试多次遍历
gen = (x for x in range(5))
list1 = list(gen)  # [0, 1, 2, 3, 4]
list2 = list(gen)  # []（生成器已耗尽）

# ✅ 正确：每次重新创建
def create_gen():
    return (x for x in range(5))

list1 = list(create_gen())
list2 = list(create_gen())
```

### 陷阱3：过早求值

```python
# ❌ 错误：立即转换为列表
gen = (x**2 for x in range(1_000_000))
result = list(gen)  # 失去了生成器的优势

# ✅ 正确：保持生成器
gen = (x**2 for x in range(1_000_000))
for item in gen:  # 按需处理
    process(item)
```

---

## 性能优化技巧

### 技巧1：使用生成器表达式替代 filter + map

```python
# ❌ 传统方式：filter + map
result = map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(100)))

# ✅ 生成器表达式：更清晰
result = (x**2 for x in range(100) if x % 2 == 0)
```

### 技巧2：避免不必要的中间列表

```python
# ❌ 不推荐：创建中间列表
data = [x for x in range(1000)]
result = [x**2 for x in data if x % 2 == 0]

# ✅ 推荐：直接使用生成器
result = (x**2 for x in range(1000) if x % 2 == 0)
```

### 技巧3：与 itertools 结合

```python
import itertools

# 取前 N 个元素
gen = (x**2 for x in range(1_000_000))
first_10 = list(itertools.islice(gen, 10))

# 跳过前 N 个元素
gen = (x for x in range(100))
after_10 = itertools.islice(gen, 10, None)

# 链接多个生成器
gen1 = (x for x in range(5))
gen2 = (x for x in range(10, 15))
combined = itertools.chain(gen1, gen2)
```

---

## 总结

### 核心要点

1. **生成器表达式 = 列表推导式 + 圆括号**
2. **惰性求值：按需计算，不存储全部结果**
3. **内存高效：适合处理大数据集**
4. **一次性：遍历后不可重用**
5. **简洁：适合简单的转换和过滤**

### 选择指南

| 场景 | 推荐方案 |
|------|---------|
| 小数据集，需要多次访问 | 列表推导式 |
| 大数据集，只遍历一次 | 生成器表达式 |
| 简单转换/过滤 | 生成器表达式 |
| 复杂逻辑 | 生成器函数 |
| 需要随机访问 | 列表推导式 |
| 需要知道长度 | 列表推导式 |
| 流式处理 | 生成器表达式 |
| 内存受限 | 生成器表达式 |

### 最佳实践

- ✅ 简单场景用生成器表达式
- ✅ 复杂逻辑用生成器函数
- ✅ 函数调用中省略外层括号
- ✅ 保持表达式简洁易读
- ✅ 与内置函数结合使用
- ❌ 不要过度复杂化表达式
- ❌ 不要假设可以多次遍历
- ❌ 不要过早转换为列表

---

**版本：** v1.0
**最后更新：** 2026-02-11
