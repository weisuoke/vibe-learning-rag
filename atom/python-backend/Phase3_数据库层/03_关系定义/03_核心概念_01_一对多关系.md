# 核心概念1：一对多关系

> 最常用的关系类型，90%的场景都是一对多

---

## 概述

**一对多关系**是数据库中最常见的关系类型，表示一个父对象可以关联多个子对象，但每个子对象只能属于一个父对象。

**典型场景：**
- 用户 → 对话（一个用户有多个对话）
- 对话 → 消息（一个对话有多条消息）
- 部门 → 员工（一个部门有多个员工）
- 文章 → 评论（一篇文章有多条评论）

---

## 1. 基本定义

### 1.1 最简单的一对多

```python
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

# "一"的一方（父表）
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)

    # relationship：访问所有对话
    conversations = relationship("Conversation", back_populates="user")

# "多"的一方（子表）
class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)
    title = Column(String)

    # 外键：指向父表
    user_id = Column(Integer, ForeignKey('users.id'))

    # relationship：访问所属用户
    user = relationship("User", back_populates="conversations")
```

**关键点：**
1. **外键在"多"的一方**：`Conversation.user_id`
2. **两边都要定义 relationship**：`User.conversations` 和 `Conversation.user`
3. **使用 back_populates 建立双向关系**

### 1.2 使用方式

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import Session

# 创建数据库
engine = create_engine("sqlite:///./test.db")
Base.metadata.create_all(engine)

# 创建会话
session = Session(engine)

# 创建用户和对话
user = User(name="Alice")
conv1 = Conversation(title="对话1", user=user)
conv2 = Conversation(title="对话2", user=user)

session.add(user)
session.commit()

# 访问关系
print(user.conversations)  # [conv1, conv2]
print(conv1.user)          # user
print(conv1.user.name)     # "Alice"
```

---

## 2. relationship() 参数详解

### 2.1 back_populates - 双向关系

**作用：** 建立双向关系，让两边都能访问对方

```python
class User(Base):
    conversations = relationship("Conversation", back_populates="user")

class Conversation(Base):
    user = relationship("User", back_populates="conversations")

# 双向访问
user.conversations  # 用户的所有对话
conversation.user   # 对话属于哪个用户
```

**为什么推荐 back_populates 而非 backref？**

| 特性 | back_populates | backref |
|-----|---------------|---------|
| 定义方式 | 两边都要显式定义 | 只需一边定义 |
| 可读性 | ✅ 更清晰 | ❌ 反向关系隐藏 |
| 类型提示 | ✅ 支持 | ❌ 难以支持 |
| 独立配置 | ✅ 两边可以不同 | ❌ 受限 |

### 2.2 lazy - 加载策略

**作用：** 控制何时加载关联数据

```python
# lazy='select'（默认）：访问时才查询
class User(Base):
    conversations = relationship("Conversation", lazy='select')

user = session.get(User, 1)        # SELECT * FROM users WHERE id=1
print(user.conversations)          # SELECT * FROM conversations WHERE user_id=1

# lazy='joined'：立即 JOIN 查询
class User(Base):
    conversations = relationship("Conversation", lazy='joined')

user = session.get(User, 1)        # SELECT * FROM users LEFT JOIN conversations ...
print(user.conversations)          # 不再查询，数据已加载

# lazy='selectin'：批量 IN 查询（推荐）
class User(Base):
    conversations = relationship("Conversation", lazy='selectin')

users = session.query(User).all()  # SELECT * FROM users
for user in users:
    print(user.conversations)      # SELECT * FROM conversations WHERE user_id IN (1,2,3...)
```

**选择建议：**

| 策略 | 查询时机 | 适用场景 | 优点 | 缺点 |
|-----|---------|---------|------|------|
| `lazy='select'` | 访问时查询 | 默认，简单场景 | 灵活，按需加载 | 可能产生 N+1 问题 |
| `lazy='joined'` | 立即 JOIN | 总是需要关联数据 | 一次查询完成 | 可能加载不需要的数据 |
| `lazy='selectin'` | 批量 IN 查询 | 循环访问（推荐） | 避免 N+1，性能好 | 需要两次查询 |

### 2.3 cascade - 级联操作

**作用：** 控制删除父对象时如何处理子对象

```python
class User(Base):
    conversations = relationship(
        "Conversation",
        back_populates="user",
        cascade="all, delete-orphan"  # 删除用户时删除所有对话
    )

# 删除用户
user = session.get(User, 1)
session.delete(user)
session.commit()  # 自动删除所有 conversations
```

**常用级联选项：**

| 选项 | 行为 | 适用场景 |
|-----|-----|---------|
| `"save-update"` | 保存父对象时自动保存子对象 | 默认行为 |
| `"delete"` | 删除父对象时删除子对象 | 一般依赖关系 |
| `"delete-orphan"` | 子对象脱离父对象时删除 | 强依赖关系 |
| `"all"` | 所有操作都级联 | 等于 `"save-update, merge, delete"` |
| `"all, delete-orphan"` | 所有操作都级联 + 删除孤儿 | 最常用（强依赖） |

**示例：**

```python
# cascade="all, delete-orphan"
class User(Base):
    conversations = relationship(
        "Conversation",
        cascade="all, delete-orphan"
    )

user = User(name="Alice")
conv1 = Conversation(title="对话1")
conv2 = Conversation(title="对话2")

user.conversations.append(conv1)
user.conversations.append(conv2)

session.add(user)
session.commit()

# 删除用户，自动删除所有对话
session.delete(user)
session.commit()  # conv1 和 conv2 也被删除

# 移除对话，自动删除
user.conversations.remove(conv1)
session.commit()  # conv1 被删除（delete-orphan）
```

### 2.4 order_by - 排序

**作用：** 指定关联对象的默认排序

```python
from sqlalchemy import desc

class User(Base):
    # 按创建时间倒序
    conversations = relationship(
        "Conversation",
        order_by="Conversation.created_at.desc()"
    )

class Conversation(Base):
    created_at = Column(DateTime, default=datetime.utcnow)

# 访问时自动排序
user.conversations  # 按创建时间倒序
```

### 2.5 foreign_keys - 指定外键

**作用：** 当有多个外键时，明确指定使用哪个

```python
class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)

    # 两个外键指向同一个表
    creator_id = Column(Integer, ForeignKey('users.id'))
    assignee_id = Column(Integer, ForeignKey('users.id'))

    # 需要明确指定外键
    creator = relationship(
        "User",
        foreign_keys=[creator_id],
        back_populates="created_conversations"
    )

    assignee = relationship(
        "User",
        foreign_keys=[assignee_id],
        back_populates="assigned_conversations"
    )

class User(Base):
    created_conversations = relationship(
        "Conversation",
        foreign_keys="Conversation.creator_id",
        back_populates="creator"
    )

    assigned_conversations = relationship(
        "Conversation",
        foreign_keys="Conversation.assignee_id",
        back_populates="assignee"
    )
```

---

## 3. 避免 N+1 查询问题

### 3.1 什么是 N+1 问题？

```python
# 产生 N+1 问题的代码
users = session.query(User).all()  # 1次查询
for user in users:
    print(user.conversations)  # N次查询（每个用户一次）

# 总共 1 + N 次查询
```

**SQL 执行：**
```sql
-- 第1次查询
SELECT * FROM users;

-- 第2次查询（user_id=1）
SELECT * FROM conversations WHERE user_id = 1;

-- 第3次查询（user_id=2）
SELECT * FROM conversations WHERE user_id = 2;

-- ...
-- 第N+1次查询（user_id=N）
SELECT * FROM conversations WHERE user_id = N;
```

### 3.2 解决方案1：lazy='selectin'

```python
class User(Base):
    conversations = relationship(
        "Conversation",
        lazy='selectin'  # 使用 selectin 策略
    )

users = session.query(User).all()  # 1次查询
for user in users:
    print(user.conversations)  # 不再查询，数据已加载

# 总共 2 次查询
```

**SQL 执行：**
```sql
-- 第1次查询
SELECT * FROM users;

-- 第2次查询（批量加载）
SELECT * FROM conversations WHERE user_id IN (1, 2, 3, ..., N);
```

### 3.2 解决方案2：joinedload

```python
from sqlalchemy.orm import joinedload

users = session.query(User).options(
    joinedload(User.conversations)
).all()

# 总共 1 次查询（LEFT JOIN）
```

**SQL 执行：**
```sql
SELECT * FROM users
LEFT JOIN conversations ON users.id = conversations.user_id;
```

### 3.3 解决方案3：selectinload

```python
from sqlalchemy.orm import selectinload

users = session.query(User).options(
    selectinload(User.conversations)
).all()

# 总共 2 次查询（IN 查询）
```

**SQL 执行：**
```sql
-- 第1次查询
SELECT * FROM users;

-- 第2次查询
SELECT * FROM conversations WHERE user_id IN (1, 2, 3, ..., N);
```

### 3.4 方案对比

| 方案 | 查询次数 | SQL 类型 | 适用场景 | 优点 | 缺点 |
|-----|---------|---------|---------|------|------|
| lazy='select' | 1 + N | 单表查询 | 不循环访问 | 灵活 | N+1 问题 |
| lazy='selectin' | 2 | IN 查询 | 循环访问（推荐） | 性能好 | 需要两次查询 |
| lazy='joined' | 1 | LEFT JOIN | 总是需要关联数据 | 一次查询 | 可能加载不需要的数据 |
| joinedload | 1 | LEFT JOIN | 局部优化 | 一次查询 | 可能加载不需要的数据 |
| selectinload | 2 | IN 查询 | 局部优化 | 性能好 | 需要两次查询 |

**推荐做法：**
- **默认使用 `lazy='selectin'`**：适用于大多数场景
- **特殊场景使用 `joinedload` 或 `selectinload`**：局部优化

---

## 4. 手写实现：理解一对多的本质

### 4.1 不使用 ORM 的实现

```python
import sqlite3

# 创建数据库
conn = sqlite3.connect(':memory:')
cursor = conn.cursor()

# 创建表
cursor.execute('''
    CREATE TABLE users (
        id INTEGER PRIMARY KEY,
        name TEXT
    )
''')

cursor.execute('''
    CREATE TABLE conversations (
        id INTEGER PRIMARY KEY,
        title TEXT,
        user_id INTEGER,
        FOREIGN KEY (user_id) REFERENCES users(id)
    )
''')

# 插入数据
cursor.execute("INSERT INTO users (name) VALUES ('Alice')")
user_id = cursor.lastrowid

cursor.execute("INSERT INTO conversations (title, user_id) VALUES ('对话1', ?)", (user_id,))
cursor.execute("INSERT INTO conversations (title, user_id) VALUES ('对话2', ?)", (user_id,))

conn.commit()

# 查询用户的所有对话（手动 JOIN）
cursor.execute('''
    SELECT conversations.id, conversations.title
    FROM conversations
    WHERE conversations.user_id = ?
''', (user_id,))

conversations = cursor.fetchall()
print(conversations)  # [(1, '对话1'), (2, '对话2')]
```

### 4.2 简化版 ORM 实现

```python
class SimpleORM:
    """简化版 ORM，演示一对多关系的实现原理"""

    def __init__(self, db_path=':memory:'):
        self.conn = sqlite3.connect(db_path)
        self.cursor = self.conn.cursor()

    def create_tables(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                name TEXT
            )
        ''')
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS conversations (
                id INTEGER PRIMARY KEY,
                title TEXT,
                user_id INTEGER,
                FOREIGN KEY (user_id) REFERENCES users(id)
            )
        ''')
        self.conn.commit()

    def create_user(self, name):
        self.cursor.execute("INSERT INTO users (name) VALUES (?)", (name,))
        self.conn.commit()
        return self.cursor.lastrowid

    def create_conversation(self, title, user_id):
        self.cursor.execute(
            "INSERT INTO conversations (title, user_id) VALUES (?, ?)",
            (title, user_id)
        )
        self.conn.commit()
        return self.cursor.lastrowid

    def get_user_conversations(self, user_id):
        """模拟 relationship：获取用户的所有对话"""
        self.cursor.execute(
            "SELECT id, title FROM conversations WHERE user_id = ?",
            (user_id,)
        )
        return self.cursor.fetchall()

    def get_conversation_user(self, conversation_id):
        """模拟 relationship：获取对话的用户"""
        self.cursor.execute('''
            SELECT users.id, users.name
            FROM users
            JOIN conversations ON users.id = conversations.user_id
            WHERE conversations.id = ?
        ''', (conversation_id,))
        return self.cursor.fetchone()

# 使用
orm = SimpleORM()
orm.create_tables()

user_id = orm.create_user("Alice")
conv1_id = orm.create_conversation("对话1", user_id)
conv2_id = orm.create_conversation("对话2", user_id)

# 访问关系
conversations = orm.get_user_conversations(user_id)
print(f"用户的对话: {conversations}")

user = orm.get_conversation_user(conv1_id)
print(f"对话的用户: {user}")
```

**输出：**
```
用户的对话: [(1, '对话1'), (2, '对话2')]
对话的用户: (1, 'Alice')
```

### 4.3 带懒加载的实现

```python
class LazyRelationship:
    """演示懒加载的实现原理"""

    def __init__(self, orm, user_id):
        self.orm = orm
        self.user_id = user_id
        self._conversations = None  # 缓存

    def __iter__(self):
        """访问时才加载数据"""
        if self._conversations is None:
            print(f"[懒加载] 查询用户 {self.user_id} 的对话")
            self._conversations = self.orm.get_user_conversations(self.user_id)
        return iter(self._conversations)

    def __repr__(self):
        if self._conversations is None:
            return "<LazyRelationship: 未加载>"
        return f"<LazyRelationship: {self._conversations}>"

class User:
    def __init__(self, orm, user_id, name):
        self.orm = orm
        self.id = user_id
        self.name = name
        self._conversations = LazyRelationship(orm, user_id)

    @property
    def conversations(self):
        return self._conversations

# 使用
orm = SimpleORM()
orm.create_tables()

user_id = orm.create_user("Alice")
orm.create_conversation("对话1", user_id)
orm.create_conversation("对话2", user_id)

user = User(orm, user_id, "Alice")

print(user.conversations)  # <LazyRelationship: 未加载>

# 访问时才加载
for conv in user.conversations:
    print(conv)

# 输出：
# [懒加载] 查询用户 1 的对话
# (1, '对话1')
# (2, '对话2')
```

---

## 5. 在 AI Agent 开发中的应用

### 5.1 用户-对话关系

```python
from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String, unique=True, nullable=False)
    email = Column(String, unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 一对多：用户的对话
    conversations = relationship(
        "Conversation",
        back_populates="user",
        lazy='selectin',  # 避免 N+1 问题
        cascade="all, delete-orphan",  # 删除用户时删除所有对话
        order_by="Conversation.created_at.desc()"  # 按创建时间倒序
    )

class Conversation(Base):
    __tablename__ = 'conversations'

    id = Column(Integer, primary_key=True)
    title = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # 外键
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)

    # 多对一：对话属于哪个用户
    user = relationship("User", back_populates="conversations")
```

### 5.2 对话-消息关系

```python
class Conversation(Base):
    __tablename__ = 'conversations'

    id = Column(Integer, primary_key=True)
    title = Column(String, nullable=False)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)

    # 一对多：对话的消息
    messages = relationship(
        "Message",
        back_populates="conversation",
        lazy='selectin',
        cascade="all, delete-orphan",
        order_by="Message.created_at"  # 按创建时间正序
    )

    user = relationship("User", back_populates="conversations")

class Message(Base):
    __tablename__ = 'messages'

    id = Column(Integer, primary_key=True)
    role = Column(String, nullable=False)  # 'user' or 'assistant'
    content = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 外键
    conversation_id = Column(Integer, ForeignKey('conversations.id'), nullable=False)

    # 多对一：消息属于哪个对话
    conversation = relationship("Conversation", back_populates="messages")
```

### 5.3 完整使用示例

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import Session

# 创建数据库
engine = create_engine("sqlite:///./ai_agent.db")
Base.metadata.create_all(engine)

# 创建会话
session = Session(engine)

# 创建用户
user = User(username="alice", email="alice@example.com")

# 创建对话
conv1 = Conversation(title="Python学习", user=user)
conv2 = Conversation(title="AI Agent开发", user=user)

# 创建消息
msg1 = Message(role="user", content="什么是Python?", conversation=conv1)
msg2 = Message(role="assistant", content="Python是一种编程语言", conversation=conv1)
msg3 = Message(role="user", content="如何开发AI Agent?", conversation=conv2)

session.add(user)
session.commit()

# 访问关系
print(f"用户: {user.username}")
print(f"对话数: {len(user.conversations)}")

for conv in user.conversations:
    print(f"\n对话: {conv.title}")
    print(f"消息数: {len(conv.messages)}")
    for msg in conv.messages:
        print(f"  {msg.role}: {msg.content}")

# 输出：
# 用户: alice
# 对话数: 2
#
# 对话: AI Agent开发
# 消息数: 1
#   user: 如何开发AI Agent?
#
# 对话: Python学习
# 消息数: 2
#   user: 什么是Python?
#   assistant: Python是一种编程语言
```

---

## 6. 最佳实践

### 6.1 推荐配置

```python
class User(Base):
    conversations = relationship(
        "Conversation",
        back_populates="user",
        lazy='selectin',  # 避免 N+1 问题
        cascade="all, delete-orphan",  # 自动删除关联数据
        order_by="Conversation.created_at.desc()"  # 默认排序
    )
```

### 6.2 避免的配置

```python
# ❌ 不推荐：使用 backref
class User(Base):
    conversations = relationship("Conversation", backref="user")

# ❌ 不推荐：不指定 lazy（默认 select，可能 N+1）
class User(Base):
    conversations = relationship("Conversation")

# ❌ 不推荐：不指定 cascade（手动删除关联数据）
class User(Base):
    conversations = relationship("Conversation")
```

### 6.3 检查清单

- [ ] 外键定义在"多"的一方
- [ ] 两边都定义 relationship
- [ ] 使用 back_populates 而非 backref
- [ ] 指定 lazy='selectin' 避免 N+1
- [ ] 根据业务需求配置 cascade
- [ ] 如需排序，指定 order_by

---

## 总结

**一对多关系的核心要点：**

1. **外键在"多"的一方**：`Conversation.user_id`
2. **两边都要定义 relationship**：`User.conversations` 和 `Conversation.user`
3. **使用 back_populates**：显式双向关系
4. **使用 lazy='selectin'**：避免 N+1 问题
5. **配置 cascade**：自动处理关联数据
6. **指定 order_by**：默认排序

**记忆口诀：**
> 外键放多方，两边都定义，
> back_populates 清晰，selectin 避免 N+1，
> cascade 自动删，order_by 排序。
