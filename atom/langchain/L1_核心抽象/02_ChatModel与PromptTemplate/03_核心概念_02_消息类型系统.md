# 核心概念 02: 消息类型系统

> **本文目标**: 深入理解 LangChain 的消息类型系统，掌握每种消息类型的作用和使用场景

---

## 概述

**消息类型系统**是 ChatModel 的核心设计，它通过不同的消息类型来表达对话中的不同角色和语义。理解消息类型系统是掌握 LangChain 对话能力的关键。

**核心理念**: 用类型表达语义，让模型理解消息的角色和意图。

---

## 1. 消息类型层次结构

### 1.1 类型继承关系

```python
from langchain_core.messages import (
    BaseMessage,       # 抽象基类
    SystemMessage,     # 系统消息
    HumanMessage,      # 用户消息
    AIMessage,         # AI 消息
    ToolMessage,       # 工具消息（2025+）
    ChatMessage,       # 通用消息（不推荐）
)

# 继承关系
BaseMessage (抽象基类)
├── SystemMessage    # role="system"
├── HumanMessage     # role="user"
├── AIMessage        # role="assistant"
├── ToolMessage      # role="tool"
└── ChatMessage      # role=自定义（不推荐使用）
```

### 1.2 BaseMessage 的核心属性

```python
from langchain_core.messages import BaseMessage
from typing import Optional, List, Dict, Any

class BaseMessage:
    """所有消息的基类"""

    # 核心属性
    content: str | List[Dict[str, Any]]  # 消息内容
    type: str                             # 消息类型标识

    # 可选属性
    name: Optional[str] = None            # 发送者名称
    id: Optional[str] = None              # 消息唯一标识（2025+）

    # 元数据
    additional_kwargs: Dict[str, Any] = {}     # 额外参数
    response_metadata: Dict[str, Any] = {}     # 响应元数据（2025+）

    # 方法
    def __str__(self) -> str:
        """字符串表示"""
        return f"{self.type}: {self.content}"

    def dict(self) -> Dict[str, Any]:
        """转换为字典"""
        pass

    def json(self) -> str:
        """转换为 JSON"""
        pass
```

**实际示例**:

```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content="你好",
    name="张三",
    id="msg_123",
    additional_kwargs={"user_id": "user_456"}
)

print(f"类型: {message.type}")        # "human"
print(f"内容: {message.content}")     # "你好"
print(f"名称: {message.name}")        # "张三"
print(f"ID: {message.id}")            # "msg_123"
print(f"额外参数: {message.additional_kwargs}")  # {"user_id": "user_456"}
```

---

## 2. SystemMessage - 系统指令

### 2.1 定义和作用

**SystemMessage** 用于定义 AI 的角色、行为规则和约束条件。

```python
from langchain_core.messages import SystemMessage

system_msg = SystemMessage(content="你是专业的Python开发者")
```

**核心作用**:

1. **角色定义**: 告诉 AI 它是谁
2. **行为规则**: 定义 AI 应该如何回答
3. **约束条件**: 限制 AI 的输出范围
4. **输出格式**: 指定输出的格式要求

### 2.2 使用场景

**场景1: 定义专业角色**

```python
SystemMessage(content="""你是一位资深的Python开发者，拥有10年以上的开发经验。
你的回答应该：
- 准确、专业
- 包含代码示例
- 遵循PEP 8规范
- 使用类型注解
""")
```

**场景2: 定义行为规则**

```python
SystemMessage(content="""你是客服助手，请遵循以下规则：
1. 始终保持礼貌和专业
2. 不确定时说"我需要确认一下"
3. 不要承诺无法实现的功能
4. 每次回答后询问"还有其他问题吗？"
""")
```

**场景3: 定义输出格式**

```python
SystemMessage(content="""你是数据分析助手。
输出格式要求：
- 使用Markdown格式
- 数据用表格展示
- 关键指标用加粗
- 结论放在最后
""")
```

**场景4: 定义约束条件**

```python
SystemMessage(content="""你是教育助手，面向小学生。
约束条件：
- 使用简单的语言
- 避免专业术语
- 多用比喻和例子
- 回答不超过100字
""")
```

### 2.3 最佳实践

**✅ 推荐做法**:

```python
# 1. 明确角色
SystemMessage(content="你是Python专家")

# 2. 具体规则
SystemMessage(content="""你是Python专家。
回答要求：
- 代码要有类型注解
- 包含docstring
- 遵循PEP 8
""")

# 3. 示例引导（Few-shot）
SystemMessage(content="""你是情感分类助手。
示例：
输入: "这个产品很好" → 输出: "正面"
输入: "这个产品很差" → 输出: "负面"
""")
```

**❌ 不推荐做法**:

```python
# 1. 过于模糊
SystemMessage(content="你是助手")  # 太笼统

# 2. 过于冗长
SystemMessage(content="你是..." * 1000)  # 浪费 tokens

# 3. 自相矛盾
SystemMessage(content="你要简洁，但要详细解释每个细节")  # 矛盾

# 4. 包含敏感信息
SystemMessage(content="API密钥是: sk-...")  # 安全风险
```

### 2.4 2025-2026 新特性

**结构化系统消息**:

```python
from pydantic import BaseModel

class SystemConfig(BaseModel):
    role: str
    tone: str
    constraints: List[str]
    output_format: str

config = SystemConfig(
    role="Python专家",
    tone="专业、友好",
    constraints=["使用类型注解", "遵循PEP 8"],
    output_format="Markdown"
)

system_msg = SystemMessage(content=config.model_dump_json())
```

---

## 3. HumanMessage - 用户输入

### 3.1 定义和作用

**HumanMessage** 表示用户的输入或问题。

```python
from langchain_core.messages import HumanMessage

human_msg = HumanMessage(content="什么是装饰器？")
```

**核心作用**:

1. **用户问题**: 用户想要询问的内容
2. **用户指令**: 用户想要 AI 执行的任务
3. **用户反馈**: 用户对 AI 回复的反馈

### 3.2 基础用法

**文本消息**:

```python
# 简单问题
HumanMessage(content="Python 和 JavaScript 有什么区别？")

# 复杂指令
HumanMessage(content="""请帮我写一个Python函数：
- 功能：计算斐波那契数列
- 要求：使用递归实现
- 包含：类型注解和docstring
""")

# 带名称的消息
HumanMessage(
    content="我需要帮助",
    name="张三"  # 标识发送者
)
```

### 3.3 多模态消息（2025+）

**文本 + 图像**:

```python
HumanMessage(content=[
    {"type": "text", "text": "这张图片是什么？"},
    {
        "type": "image_url",
        "image_url": {"url": "https://example.com/image.jpg"}
    }
])
```

**文本 + 多张图像**:

```python
HumanMessage(content=[
    {"type": "text", "text": "对比这两张图片的差异"},
    {"type": "image_url", "image_url": {"url": "https://example.com/img1.jpg"}},
    {"type": "image_url", "image_url": {"url": "https://example.com/img2.jpg"}}
])
```

**文本 + Base64 图像**:

```python
import base64

with open("image.jpg", "rb") as f:
    image_data = base64.b64encode(f.read()).decode()

HumanMessage(content=[
    {"type": "text", "text": "分析这张图片"},
    {
        "type": "image_url",
        "image_url": {
            "url": f"data:image/jpeg;base64,{image_data}"
        }
    }
])
```

**文本 + 视频（2026+）**:

```python
HumanMessage(content=[
    {"type": "text", "text": "总结这个视频的内容"},
    {
        "type": "video_url",
        "video_url": {"url": "https://example.com/video.mp4"}
    }
])
```

### 3.4 最佳实践

**✅ 推荐做法**:

```python
# 1. 清晰的问题
HumanMessage(content="Python中装饰器的作用是什么？")

# 2. 具体的指令
HumanMessage(content="写一个函数，输入列表，输出去重后的列表")

# 3. 提供上下文
HumanMessage(content="""我在使用Flask开发Web应用。
问题：如何实现用户认证？
要求：使用JWT token
""")
```

**❌ 不推荐做法**:

```python
# 1. 过于模糊
HumanMessage(content="帮我")  # 不知道要帮什么

# 2. 多个问题混在一起
HumanMessage(content="Python是什么？JavaScript是什么？Rust是什么？")
# 应该分成多条消息

# 3. 包含敏感信息
HumanMessage(content="我的密码是123456，帮我...")  # 安全风险
```

---

## 4. AIMessage - AI 回复

### 4.1 定义和作用

**AIMessage** 表示 AI 的回复或响应。

```python
from langchain_core.messages import AIMessage

ai_msg = AIMessage(content="装饰器是一种设计模式...")
```

**核心作用**:

1. **AI 回复**: AI 对用户问题的回答
2. **对话历史**: 保存 AI 的历史回复
3. **工具调用**: AI 决定调用哪些工具（2025+）

### 4.2 基础用法

**简单回复**:

```python
AIMessage(content="Python是一种解释型编程语言")
```

**带元数据的回复**:

```python
from langchain_openai import ChatOpenAI

model = ChatOpenAI(model="gpt-4o-mini")
response = model.invoke([HumanMessage(content="你好")])

# response 是 AIMessage
print(response.content)  # "你好！有什么可以帮你的吗？"
print(response.response_metadata)
# {
#   'token_usage': {
#     'prompt_tokens': 10,
#     'completion_tokens': 15,
#     'total_tokens': 25
#   },
#   'model_name': 'gpt-4o-mini',
#   'finish_reason': 'stop'
# }
```

### 4.3 工具调用（2025+）

**AI 决定调用工具**:

```python
# AI 的回复包含工具调用
AIMessage(
    content="我需要搜索相关信息",
    tool_calls=[
        {
            "id": "call_abc123",
            "name": "web_search",
            "args": {"query": "Python装饰器"}
        }
    ]
)
```

**实际示例**:

```python
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool

@tool
def web_search(query: str) -> str:
    """搜索网络信息"""
    return f"搜索结果: {query}..."

# 绑定工具到模型
model = ChatOpenAI(model="gpt-4o-mini")
model_with_tools = model.bind_tools([web_search])

# AI 决定是否调用工具
response = model_with_tools.invoke([
    HumanMessage(content="搜索Python装饰器的最新教程")
])

# 检查是否有工具调用
if response.tool_calls:
    print(f"AI 决定调用工具: {response.tool_calls[0]['name']}")
    print(f"参数: {response.tool_calls[0]['args']}")
```

### 4.4 在对话历史中的使用

```python
from langchain_core.messages import HumanMessage, AIMessage

# 构建对话历史
history = [
    HumanMessage(content="我叫张三"),
    AIMessage(content="你好张三！很高兴认识你。"),
    HumanMessage(content="我喜欢Python"),
    AIMessage(content="Python是很棒的语言！你在用Python做什么项目吗？"),
    HumanMessage(content="我叫什么名字？")
]

# AI 能从历史中找到答案
response = model.invoke(history)
print(response.content)  # "你叫张三"
```

---

## 5. ToolMessage - 工具结果（2025+）

### 5.1 定义和作用

**ToolMessage** 用于传递工具执行的结果给 AI。

```python
from langchain_core.messages import ToolMessage

tool_msg = ToolMessage(
    content="搜索结果: Python装饰器是...",
    tool_call_id="call_abc123"  # 对应 AIMessage 中的 tool_call id
)
```

**核心作用**:

1. **工具结果**: 传递工具执行的结果
2. **上下文补充**: 为 AI 提供额外信息
3. **Agent 循环**: 支持 Agent 的推理循环

### 5.2 完整的工具调用流程

```python
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage, ToolMessage
from langchain_core.tools import tool

# 1. 定义工具
@tool
def get_weather(city: str) -> str:
    """获取城市天气"""
    return f"{city}的天气是晴天，温度25度"

# 2. 绑定工具到模型
model = ChatOpenAI(model="gpt-4o-mini")
model_with_tools = model.bind_tools([get_weather])

# 3. 用户提问
messages = [HumanMessage(content="北京的天气怎么样？")]

# 4. AI 决定调用工具
response = model_with_tools.invoke(messages)
print(f"AI 回复: {response.content}")
print(f"工具调用: {response.tool_calls}")

# 5. 执行工具
if response.tool_calls:
    tool_call = response.tool_calls[0]
    tool_result = get_weather.invoke(tool_call["args"])

    # 6. 构建 ToolMessage
    messages.append(response)  # 添加 AI 的回复
    messages.append(ToolMessage(
        content=tool_result,
        tool_call_id=tool_call["id"]
    ))

    # 7. AI 基于工具结果生成最终回复
    final_response = model_with_tools.invoke(messages)
    print(f"最终回复: {final_response.content}")
    # "北京的天气是晴天，温度25度"
```

### 5.3 多工具调用

```python
# AI 可以同时调用多个工具
AIMessage(
    content="我需要搜索和计算",
    tool_calls=[
        {
            "id": "call_1",
            "name": "web_search",
            "args": {"query": "Python"}
        },
        {
            "id": "call_2",
            "name": "calculator",
            "args": {"expression": "2+2"}
        }
    ]
)

# 对应的 ToolMessage
messages.extend([
    ToolMessage(content="搜索结果: ...", tool_call_id="call_1"),
    ToolMessage(content="计算结果: 4", tool_call_id="call_2")
])
```

### 5.4 错误处理

```python
# 工具执行失败
try:
    result = tool.invoke(args)
    tool_msg = ToolMessage(content=result, tool_call_id=call_id)
except Exception as e:
    # 传递错误信息
    tool_msg = ToolMessage(
        content=f"工具执行失败: {str(e)}",
        tool_call_id=call_id,
        additional_kwargs={"error": True}
    )
```

---

## 6. ChatMessage - 通用消息（不推荐）

### 6.1 定义

**ChatMessage** 是一个通用的消息类型，可以指定任意角色。

```python
from langchain_core.messages import ChatMessage

msg = ChatMessage(
    content="这是一条消息",
    role="custom_role"  # 自定义角色
)
```

### 6.2 为什么不推荐？

1. **语义不明确**: 自定义角色可能不被模型理解
2. **类型不安全**: 没有类型检查
3. **不符合规范**: 大多数模型只支持 system/user/assistant/tool

**推荐做法**: 使用专门的消息类型（SystemMessage/HumanMessage/AIMessage/ToolMessage）

---

## 7. 消息类型的选择标准

### 7.1 决策树

```
需要定义 AI 行为？
├─ 是 → SystemMessage
└─ 否 → 是用户输入？
    ├─ 是 → HumanMessage
    └─ 否 → 是 AI 回复？
        ├─ 是 → AIMessage
        └─ 否 → 是工具结果？
            ├─ 是 → ToolMessage
            └─ 否 → 考虑是否真的需要这条消息
```

### 7.2 使用场景对照表

| 场景 | 消息类型 | 示例 |
|------|----------|------|
| 定义 AI 角色 | SystemMessage | "你是Python专家" |
| 定义行为规则 | SystemMessage | "回答要简洁" |
| 用户提问 | HumanMessage | "什么是装饰器？" |
| 用户指令 | HumanMessage | "写一个函数" |
| 用户上传图片 | HumanMessage | content=[text, image] |
| AI 回答问题 | AIMessage | "装饰器是..." |
| AI 调用工具 | AIMessage | tool_calls=[...] |
| 工具执行结果 | ToolMessage | "搜索结果: ..." |
| 对话历史 | HumanMessage + AIMessage | 交替出现 |

### 7.3 常见错误

**错误1: 用 HumanMessage 定义行为**

```python
# ❌ 错误
messages = [
    HumanMessage(content="你是Python专家，请回答：什么是装饰器？")
]

# ✅ 正确
messages = [
    SystemMessage(content="你是Python专家"),
    HumanMessage(content="什么是装饰器？")
]
```

**错误2: 用 AIMessage 作为用户输入**

```python
# ❌ 错误
messages = [
    AIMessage(content="什么是装饰器？")  # 这是用户问题，不是 AI 回复
]

# ✅ 正确
messages = [
    HumanMessage(content="什么是装饰器？")
]
```

**错误3: 忘记 tool_call_id**

```python
# ❌ 错误
ToolMessage(content="结果")  # 缺少 tool_call_id

# ✅ 正确
ToolMessage(content="结果", tool_call_id="call_123")
```

---

## 8. 实际应用模式

### 8.1 基础对话模式

```python
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage

model = ChatOpenAI(model="gpt-4o-mini")

messages = [
    SystemMessage(content="你是友好的助手"),
    HumanMessage(content="你好")
]

response = model.invoke(messages)
print(response.content)
```

### 8.2 多轮对话模式

```python
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage

messages = [
    SystemMessage(content="你是Python专家"),
    HumanMessage(content="什么是装饰器？"),
    AIMessage(content="装饰器是一种设计模式..."),
    HumanMessage(content="能举个例子吗？")
]

response = model.invoke(messages)
```

### 8.3 工具调用模式（2025+）

```python
from langchain_core.tools import tool
from langchain_core.messages import HumanMessage, ToolMessage

@tool
def calculator(expression: str) -> str:
    """计算数学表达式"""
    return str(eval(expression))

model_with_tools = model.bind_tools([calculator])

# 第一轮：用户提问
messages = [HumanMessage(content="2+2等于多少？")]
response = model_with_tools.invoke(messages)

# 第二轮：执行工具
if response.tool_calls:
    tool_call = response.tool_calls[0]
    result = calculator.invoke(tool_call["args"])

    messages.append(response)
    messages.append(ToolMessage(
        content=result,
        tool_call_id=tool_call["id"]
    ))

    # 第三轮：生成最终回复
    final_response = model_with_tools.invoke(messages)
    print(final_response.content)  # "2+2等于4"
```

### 8.4 多模态对话模式（2025+）

```python
from langchain_core.messages import HumanMessage

# 文本 + 图像
message = HumanMessage(content=[
    {"type": "text", "text": "这张图片中有什么？"},
    {"type": "image_url", "image_url": {"url": "https://example.com/image.jpg"}}
])

response = model.invoke([message])
print(response.content)
```

---

## 9. 性能和成本优化

### 9.1 消息长度管理

```python
# 问题：历史消息无限增长
history = []
for i in range(1000):
    history.append(HumanMessage(content=f"问题{i}"))
    history.append(AIMessage(content=f"回答{i}"))
# 最终超过 context window

# 解决：限制历史长度
MAX_HISTORY = 10
history = history[-MAX_HISTORY:]  # 只保留最近10条
```

### 9.2 Token 计数

```python
from langchain.callbacks import get_openai_callback

with get_openai_callback() as cb:
    response = model.invoke(messages)
    print(f"Prompt tokens: {cb.prompt_tokens}")
    print(f"Completion tokens: {cb.completion_tokens}")
    print(f"Total tokens: {cb.total_tokens}")
    print(f"Cost: ${cb.total_cost}")
```

### 9.3 消息压缩

```python
# 压缩历史消息
from langchain.memory import ConversationSummaryMemory

memory = ConversationSummaryMemory(llm=model)
memory.save_context(
    {"input": "我叫张三"},
    {"output": "你好张三"}
)
# 自动总结历史，减少 tokens
```

---

## 检查清单

完成本节学习后，你应该能够：

- [ ] 理解消息类型的继承关系
- [ ] 正确使用 SystemMessage 定义行为
- [ ] 正确使用 HumanMessage 表示用户输入
- [ ] 正确使用 AIMessage 表示 AI 回复
- [ ] 理解 ToolMessage 的作用（2025+）
- [ ] 知道何时使用哪种消息类型
- [ ] 避免常见的消息类型使用错误
- [ ] 实现基础的多轮对话
- [ ] 实现工具调用流程（2025+）
- [ ] 处理多模态消息（2025+）

---

**下一步**: 阅读 `03_核心概念_03_PromptTemplate基础.md` 学习模板系统的设计和使用
