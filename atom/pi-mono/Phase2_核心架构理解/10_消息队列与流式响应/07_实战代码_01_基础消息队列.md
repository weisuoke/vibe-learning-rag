# 实战代码 01：基础消息队列

> **目标**: 手写一个完整的消息队列实现，支持入队、出队、优先级管理。

---

## 完整代码实现

```typescript
/**
 * 消息队列实战示例
 * 演示：基础消息队列的完整实现
 */

// ===== 1. 消息类型定义 =====

/**
 * 消息类型枚举
 */
export enum MessageType {
  USER = 'user',
  ASSISTANT = 'assistant',
  TOOL_CALL = 'tool-call',
  TOOL_RESULT = 'tool-result',
  STEERING = 'steering',
  FOLLOW_UP = 'follow-up'
}

/**
 * 消息优先级（数字越小优先级越高）
 */
export enum MessagePriority {
  CRITICAL = 0,   // Steering message
  HIGH = 1,       // User message
  NORMAL = 2,     // Tool results
  LOW = 3         // Background tasks
}

/**
 * 消息状态
 */
export enum MessageStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

/**
 * 基础消息接口
 */
export interface Message {
  id: string;
  type: MessageType;
  priority: MessagePriority;
  status: MessageStatus;
  content: string;
  timestamp: number;
  parentId?: string;
  metadata?: Record<string, any>;
}

// ===== 2. 消息队列实现 =====

/**
 * 基础消息队列类
 * 支持优先级、去重、状态管理
 */
export class MessageQueue {
  // 优先级队列（按优先级分组）
  private queue: Map<MessagePriority, Message[]>;

  // 正在处理的消息 ID
  private processing: Set<string>;

  // 已完成的消息 ID
  private completed: Set<string>;

  // 队列最大大小
  private maxSize: number;

  constructor(maxSize: number = 1000) {
    this.queue = new Map([
      [MessagePriority.CRITICAL, []],
      [MessagePriority.HIGH, []],
      [MessagePriority.NORMAL, []],
      [MessagePriority.LOW, []]
    ]);
    this.processing = new Set();
    this.completed = new Set();
    this.maxSize = maxSize;
  }

  /**
   * 入队：添加消息到队列
   */
  enqueue(message: Message): void {
    // 1. 检查队列大小
    if (this.size() >= this.maxSize) {
      throw new Error(`Queue is full (max size: ${this.maxSize})`);
    }

    // 2. 去重检查
    if (this.completed.has(message.id)) {
      console.warn(`Message ${message.id} already processed, skipping`);
      return;
    }

    if (this.processing.has(message.id)) {
      console.warn(`Message ${message.id} is being processed, skipping`);
      return;
    }

    // 3. 根据优先级添加到对应队列
    const priorityQueue = this.queue.get(message.priority);
    if (!priorityQueue) {
      throw new Error(`Invalid priority: ${message.priority}`);
    }

    priorityQueue.push(message);
    console.log(`Enqueued message ${message.id} (${message.type}, priority: ${message.priority})`);
  }

  /**
   * 出队：获取下一个待处理消息
   */
  dequeue(): Message | null {
    // 按优先级顺序查找
    for (const priority of [
      MessagePriority.CRITICAL,
      MessagePriority.HIGH,
      MessagePriority.NORMAL,
      MessagePriority.LOW
    ]) {
      const priorityQueue = this.queue.get(priority);
      if (priorityQueue && priorityQueue.length > 0) {
        const message = priorityQueue.shift()!;
        this.processing.add(message.id);
        console.log(`Dequeued message ${message.id} (${message.type})`);
        return message;
      }
    }

    return null;
  }

  /**
   * 查看队首消息（不移除）
   */
  peek(): Message | null {
    for (const priority of [
      MessagePriority.CRITICAL,
      MessagePriority.HIGH,
      MessagePriority.NORMAL,
      MessagePriority.LOW
    ]) {
      const priorityQueue = this.queue.get(priority);
      if (priorityQueue && priorityQueue.length > 0) {
        return priorityQueue[0];
      }
    }

    return null;
  }

  /**
   * 标记消息为已完成
   */
  markCompleted(messageId: string): void {
    this.processing.delete(messageId);
    this.completed.add(messageId);
    console.log(`Message ${messageId} marked as completed`);
  }

  /**
   * 标记消息为失败
   */
  markFailed(messageId: string): void {
    this.processing.delete(messageId);
    console.log(`Message ${messageId} marked as failed`);
  }

  /**
   * 取消消息
   */
  cancel(messageId: string): boolean {
    // 从所有优先级队列中移除
    for (const priorityQueue of this.queue.values()) {
      const index = priorityQueue.findIndex(m => m.id === messageId);
      if (index !== -1) {
        priorityQueue.splice(index, 1);
        console.log(`Message ${messageId} cancelled`);
        return true;
      }
    }

    return false;
  }

  /**
   * 清空队列
   */
  clear(): void {
    for (const priorityQueue of this.queue.values()) {
      priorityQueue.length = 0;
    }
    this.processing.clear();
    console.log('Queue cleared');
  }

  /**
   * 获取队列大小
   */
  size(): number {
    let total = 0;
    for (const priorityQueue of this.queue.values()) {
      total += priorityQueue.length;
    }
    return total;
  }

  /**
   * 检查队列是否为空
   */
  isEmpty(): boolean {
    return this.size() === 0;
  }

  /**
   * 获取指定优先级的消息数量
   */
  sizeByPriority(priority: MessagePriority): number {
    return this.queue.get(priority)?.length || 0;
  }

  /**
   * 获取所有待处理消息
   */
  getAllPending(): Message[] {
    const messages: Message[] = [];
    for (const priorityQueue of this.queue.values()) {
      messages.push(...priorityQueue);
    }
    return messages;
  }

  /**
   * 获取正在处理的消息 ID
   */
  getProcessing(): string[] {
    return Array.from(this.processing);
  }

  /**
   * 获取队列状态
   */
  getStatus(): QueueStatus {
    return {
      totalSize: this.size(),
      criticalCount: this.sizeByPriority(MessagePriority.CRITICAL),
      highCount: this.sizeByPriority(MessagePriority.HIGH),
      normalCount: this.sizeByPriority(MessagePriority.NORMAL),
      lowCount: this.sizeByPriority(MessagePriority.LOW),
      processingCount: this.processing.size,
      completedCount: this.completed.size
    };
  }
}

/**
 * 队列状态接口
 */
export interface QueueStatus {
  totalSize: number;
  criticalCount: number;
  highCount: number;
  normalCount: number;
  lowCount: number;
  processingCount: number;
  completedCount: number;
}

// ===== 3. 使用示例 =====

/**
 * 示例：基础使用
 */
function example1_BasicUsage() {
  console.log('=== 示例 1：基础使用 ===\n');

  // 创建消息队列
  const queue = new MessageQueue();

  // 添加不同类型的消息
  queue.enqueue({
    id: 'msg-001',
    type: MessageType.USER,
    priority: MessagePriority.HIGH,
    status: MessageStatus.PENDING,
    content: '帮我重构这个函数',
    timestamp: Date.now()
  });

  queue.enqueue({
    id: 'msg-002',
    type: MessageType.TOOL_RESULT,
    priority: MessagePriority.NORMAL,
    status: MessageStatus.PENDING,
    content: 'Tool result: file read successfully',
    timestamp: Date.now()
  });

  // 查看队列状态
  console.log('Queue status:', queue.getStatus());

  // 出队并处理
  const message = queue.dequeue();
  if (message) {
    console.log(`Processing: ${message.content}`);
    queue.markCompleted(message.id);
  }

  console.log('\n');
}

/**
 * 示例：优先级处理
 */
function example2_PriorityHandling() {
  console.log('=== 示例 2：优先级处理 ===\n');

  const queue = new MessageQueue();

  // 添加不同优先级的消息
  queue.enqueue({
    id: 'msg-003',
    type: MessageType.TOOL_RESULT,
    priority: MessagePriority.NORMAL,
    status: MessageStatus.PENDING,
    content: 'Normal priority message',
    timestamp: Date.now()
  });

  queue.enqueue({
    id: 'msg-004',
    type: MessageType.STEERING,
    priority: MessagePriority.CRITICAL,
    status: MessageStatus.PENDING,
    content: 'Stop! Critical message',
    timestamp: Date.now()
  });

  queue.enqueue({
    id: 'msg-005',
    type: MessageType.USER,
    priority: MessagePriority.HIGH,
    status: MessageStatus.PENDING,
    content: 'High priority message',
    timestamp: Date.now()
  });

  // 出队（按优先级顺序）
  console.log('Dequeue order:');
  while (!queue.isEmpty()) {
    const message = queue.dequeue();
    if (message) {
      console.log(`- ${message.type} (priority: ${message.priority}): ${message.content}`);
      queue.markCompleted(message.id);
    }
  }

  console.log('\n');
}

/**
 * 示例：去重机制
 */
function example3_Deduplication() {
  console.log('=== 示例 3：去重机制 ===\n');

  const queue = new MessageQueue();

  // 添加消息
  queue.enqueue({
    id: 'msg-006',
    type: MessageType.USER,
    priority: MessagePriority.HIGH,
    status: MessageStatus.PENDING,
    content: 'First message',
    timestamp: Date.now()
  });

  // 处理消息
  const message = queue.dequeue();
  if (message) {
    queue.markCompleted(message.id);
  }

  // 尝试添加相同 ID 的消息（会被去重）
  queue.enqueue({
    id: 'msg-006',
    type: MessageType.USER,
    priority: MessagePriority.HIGH,
    status: MessageStatus.PENDING,
    content: 'Duplicate message',
    timestamp: Date.now()
  });

  console.log('Queue size after deduplication:', queue.size());
  console.log('\n');
}

/**
 * 示例：取消消息
 */
function example4_CancelMessage() {
  console.log('=== 示例 4：取消消息 ===\n');

  const queue = new MessageQueue();

  // 添加多个消息
  queue.enqueue({
    id: 'msg-007',
    type: MessageType.USER,
    priority: MessagePriority.HIGH,
    status: MessageStatus.PENDING,
    content: 'Message 1',
    timestamp: Date.now()
  });

  queue.enqueue({
    id: 'msg-008',
    type: MessageType.USER,
    priority: MessagePriority.HIGH,
    status: MessageStatus.PENDING,
    content: 'Message 2',
    timestamp: Date.now()
  });

  console.log('Queue size before cancel:', queue.size());

  // 取消消息
  queue.cancel('msg-008');

  console.log('Queue size after cancel:', queue.size());
  console.log('\n');
}

// ===== 4. 运行所有示例 =====

function runAllExamples() {
  example1_BasicUsage();
  example2_PriorityHandling();
  example3_Deduplication();
  example4_CancelMessage();
}

// 运行示例
runAllExamples();
```

---

## 运行输出示例

```
=== 示例 1：基础使用 ===

Enqueued message msg-001 (user, priority: 1)
Enqueued message msg-002 (tool-result, priority: 2)
Queue status: {
  totalSize: 2,
  criticalCount: 0,
  highCount: 1,
  normalCount: 1,
  lowCount: 0,
  processingCount: 0,
  completedCount: 0
}
Dequeued message msg-001 (user)
Processing: 帮我重构这个函数
Message msg-001 marked as completed


=== 示例 2：优先级处理 ===

Enqueued message msg-003 (tool-result, priority: 2)
Enqueued message msg-004 (steering, priority: 0)
Enqueued message msg-005 (user, priority: 1)
Dequeue order:
Dequeued message msg-004 (steering)
- steering (priority: 0): Stop! Critical message
Message msg-004 marked as completed
Dequeued message msg-005 (user)
- user (priority: 1): High priority message
Message msg-005 marked as completed
Dequeued message msg-003 (tool-result)
- tool-result (priority: 2): Normal priority message
Message msg-003 marked as completed


=== 示例 3：去重机制 ===

Enqueued message msg-006 (user, priority: 1)
Dequeued message msg-006 (user)
Message msg-006 marked as completed
Message msg-006 already processed, skipping
Queue size after deduplication: 0


=== 示例 4：取消消息 ===

Enqueued message msg-007 (user, priority: 1)
Enqueued message msg-008 (user, priority: 1)
Queue size before cancel: 2
Message msg-008 cancelled
Queue size after cancel: 1
```

---

## 核心要点

1. **优先级队列**：使用 Map 按优先级分组，确保 Steering > User > Tool results
2. **去重机制**：使用 Set 记录已处理和正在处理的消息 ID
3. **状态管理**：跟踪消息的处理状态（pending、processing、completed）
4. **队列操作**：enqueue、dequeue、peek、cancel、clear
5. **性能优化**：按优先级分组，避免每次排序

---

## 扩展练习

1. **添加超时机制**：消息在队列中超过一定时间自动取消
2. **添加重试机制**：失败的消息自动重新入队
3. **添加持久化**：将队列状态保存到文件或数据库
4. **添加监控**：记录队列的性能指标（入队速度、出队速度、平均等待时间）

---

**版本**: v1.0
**最后更新**: 2026-02-19
**维护者**: Claude Code
