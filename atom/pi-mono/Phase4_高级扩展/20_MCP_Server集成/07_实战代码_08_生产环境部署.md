# 实战代码 08：生产环境部署

> **将 MCP 扩展打包为 npm 模块，实现生产级部署和管理**

---

## 概述

生产环境部署是将 MCP 扩展从开发环境推向实际应用的关键步骤。本文实现完整的生产部署方案，包括 npm 打包、配置管理、错误处理和性能优化。

```
生产环境部署核心：
├─ npm 打包 → package.json + pi manifest
├─ 配置管理 → settings.json + 环境变量
├─ 错误处理 → 日志 + 监控
└─ 性能优化 → 缓存 + 资源管理
```

**本质**：生产环境部署是将开发完成的 MCP 扩展转化为可靠、可维护、可扩展的生产级服务的过程。

[Source: Pi Packages Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/packages.md)

---

## npm 包结构

### 完整 package.json

创建 `package.json`:

```json
{
  "name": "@myorg/mcp-weather-extension",
  "version": "1.0.0",
  "description": "Weather MCP server integration for pi-mono",
  "keywords": ["pi-package", "mcp", "weather"],
  "author": "Your Name <your.email@example.com>",
  "license": "MIT",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist",
    "extensions",
    "skills",
    "README.md"
  ],
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "prepublishOnly": "npm run build",
    "test": "jest"
  },
  "pi": {
    "extensions": ["./extensions"],
    "skills": ["./skills"],
    "video": "https://example.com/demo.mp4",
    "image": "https://example.com/screenshot.png"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "dotenv": "^16.0.0"
  },
  "peerDependencies": {
    "@mariozechner/pi-coding-agent": "*",
    "@sinclair/typebox": "*"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0",
    "jest": "^29.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/myorg/mcp-weather-extension.git"
  }
}
```

[Source: Pi Packages Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/packages.md)

### 目录结构

```
mcp-weather-extension/
├── package.json              # npm 包配置
├── tsconfig.json             # TypeScript 配置
├── .npmignore                # npm 发布忽略文件
├── README.md                 # 文档
├── LICENSE                   # 许可证
├── src/                      # 源代码
│   ├── index.ts              # 扩展入口
│   ├── mcp-client.ts         # MCP 客户端
│   └── tools.ts              # 工具定义
├── extensions/               # 编译后的扩展
│   └── index.js
├── skills/                   # 技能文件
│   └── weather/
│       └── SKILL.md
├── dist/                     # 编译输出
│   ├── index.js
│   └── index.d.ts
└── tests/                    # 测试文件
    └── index.test.ts
```

### TypeScript 配置

创建 `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### 依赖管理策略

```typescript
// ✅ 核心包使用 peerDependencies
{
  "peerDependencies": {
    "@mariozechner/pi-coding-agent": "*",
    "@mariozechner/pi-ai": "*",
    "@sinclair/typebox": "*"
  }
}

// ✅ 第三方运行时依赖使用 dependencies
{
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "dotenv": "^16.0.0"
  }
}

// ✅ 打包其他 pi 包
{
  "dependencies": {
    "shitty-extensions": "^1.0.1"
  },
  "bundledDependencies": ["shitty-extensions"],
  "pi": {
    "extensions": [
      "extensions",
      "node_modules/shitty-extensions/extensions"
    ]
  }
}
```

[Source: Pi Packages Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/packages.md)

---

## 配置管理

### settings.json 配置

**全局配置** (`~/.pi/agent/settings.json`):

```json
{
  "packages": [
    "npm:@myorg/mcp-weather-extension@1.0.0"
  ],
  "mcpServers": {
    "weather": {
      "command": "node",
      "args": ["/path/to/weather-server/dist/index.js"],
      "env": {
        "WEATHER_API_KEY": "${WEATHER_API_KEY}"
      }
    }
  }
}
```

**项目配置** (`.pi/settings.json`):

```json
{
  "packages": [
    {
      "source": "npm:@myorg/mcp-weather-extension",
      "extensions": ["extensions/*.ts"],
      "skills": ["skills/weather"]
    }
  ]
}
```

[Source: Pi Packages Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/packages.md)

### 环境变量管理

创建 `.env.example`:

```bash
# MCP Server Configuration
WEATHER_API_KEY=your_api_key_here
WEATHER_SERVER_PATH=/path/to/weather-server/dist/index.js

# Logging
LOG_LEVEL=info
LOG_FILE=/var/log/mcp-weather.log

# Performance
CACHE_TTL=300000
MAX_CONNECTIONS=10
```

**加载环境变量**:

```typescript
import dotenv from 'dotenv';
import path from 'path';

// 加载环境变量
dotenv.config();

// 配置验证
export const config = {
  weatherApiKey: process.env.WEATHER_API_KEY || '',
  weatherServerPath: process.env.WEATHER_SERVER_PATH || '',
  logLevel: process.env.LOG_LEVEL || 'info',
  logFile: process.env.LOG_FILE || '/tmp/mcp-weather.log',
  cacheTTL: parseInt(process.env.CACHE_TTL || '300000'),
  maxConnections: parseInt(process.env.MAX_CONNECTIONS || '10'),
};

// 验证必需配置
if (!config.weatherApiKey) {
  throw new Error('WEATHER_API_KEY is required');
}

if (!config.weatherServerPath) {
  throw new Error('WEATHER_SERVER_PATH is required');
}
```

### 配置优先级

```typescript
/**
 * 配置加载优先级：
 * 1. 环境变量
 * 2. 项目配置 (.pi/settings.json)
 * 3. 全局配置 (~/.pi/agent/settings.json)
 * 4. 默认值
 */
export function loadConfig(): Config {
  const envConfig = loadEnvConfig();
  const projectConfig = loadProjectConfig();
  const globalConfig = loadGlobalConfig();
  const defaultConfig = getDefaultConfig();

  return {
    ...defaultConfig,
    ...globalConfig,
    ...projectConfig,
    ...envConfig,
  };
}
```

---

## 错误处理与日志

### 错误处理策略

```typescript
import type { ExtensionAPI } from '@mariozechner/pi-coding-agent';

export class ErrorHandler {
  /**
   * 包装异步函数，添加错误处理
   */
  static wrapAsync<T>(
    fn: () => Promise<T>,
    context: string
  ): Promise<T | null> {
    return fn().catch((error) => {
      console.error(`[${context}] Error:`, error);

      // 记录错误到日志文件
      this.logError(context, error);

      // 发送通知（如果可用）
      if (this.notificationHandler) {
        this.notificationHandler(
          `Error in ${context}: ${error.message}`,
          'error'
        );
      }

      return null;
    });
  }

  /**
   * 工具执行错误处理
   */
  static handleToolError(
    toolName: string,
    error: any
  ): { content: any[]; isError: boolean } {
    const errorMessage = error instanceof Error
      ? error.message
      : String(error);

    // 分类错误
    const errorType = this.classifyError(error);

    // 记录详细错误
    this.logError(`tool:${toolName}`, error);

    return {
      content: [
        {
          type: 'text',
          text: `Tool execution failed: ${errorMessage}`,
        },
      ],
      isError: true,
      details: {
        toolName,
        errorType,
        timestamp: Date.now(),
        stack: error.stack,
      },
    };
  }

  /**
   * 错误分类
   */
  private static classifyError(error: any): string {
    const message = error.message || String(error);

    if (message.includes('ECONNREFUSED')) {
      return 'ConnectionError';
    } else if (message.includes('timeout')) {
      return 'TimeoutError';
    } else if (message.includes('not found')) {
      return 'NotFoundError';
    } else if (message.includes('permission')) {
      return 'PermissionError';
    }

    return 'UnknownError';
  }

  /**
   * 记录错误到文件
   */
  private static logError(context: string, error: any): void {
    const logEntry = {
      timestamp: new Date().toISOString(),
      context,
      message: error.message || String(error),
      stack: error.stack,
    };

    // 写入日志文件
    fs.appendFileSync(
      config.logFile,
      JSON.stringify(logEntry) + '\n'
    );
  }

  private static notificationHandler: any = null;

  static setNotificationHandler(handler: any): void {
    this.notificationHandler = handler;
  }
}
```

### 日志记录模式

```typescript
export class Logger {
  private static level: string = config.logLevel;

  static debug(message: string, ...args: any[]): void {
    if (this.shouldLog('debug')) {
      console.error(`[DEBUG] ${message}`, ...args);
    }
  }

  static info(message: string, ...args: any[]): void {
    if (this.shouldLog('info')) {
      console.error(`[INFO] ${message}`, ...args);
    }
  }

  static warn(message: string, ...args: any[]): void {
    if (this.shouldLog('warn')) {
      console.error(`[WARN] ${message}`, ...args);
    }
  }

  static error(message: string, ...args: any[]): void {
    if (this.shouldLog('error')) {
      console.error(`[ERROR] ${message}`, ...args);
    }
  }

  private static shouldLog(level: string): boolean {
    const levels = ['debug', 'info', 'warn', 'error'];
    const currentIndex = levels.indexOf(this.level);
    const messageIndex = levels.indexOf(level);
    return messageIndex >= currentIndex;
  }
}
```

---

## 性能优化

### 缓存策略

```typescript
export class CacheManager {
  private cache = new Map<string, { data: any; timestamp: number }>();
  private readonly ttl: number;

  constructor(ttl: number = config.cacheTTL) {
    this.ttl = ttl;
  }

  /**
   * 获取缓存
   */
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) {
      return null;
    }

    // 检查是否过期
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data as T;
  }

  /**
   * 设置缓存
   */
  set(key: string, data: any): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
    });
  }

  /**
   * 清除过期缓存
   */
  cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * 清空所有缓存
   */
  clear(): void {
    this.cache.clear();
  }
}
```

### 连接池管理

```typescript
export class ConnectionPool {
  private connections: any[] = [];
  private available: any[] = [];
  private readonly maxConnections: number;

  constructor(maxConnections: number = config.maxConnections) {
    this.maxConnections = maxConnections;
  }

  /**
   * 获取连接
   */
  async acquire(): Promise<any> {
    // 如果有可用连接，直接返回
    if (this.available.length > 0) {
      return this.available.pop();
    }

    // 如果未达到最大连接数，创建新连接
    if (this.connections.length < this.maxConnections) {
      const connection = await this.createConnection();
      this.connections.push(connection);
      return connection;
    }

    // 等待可用连接
    return this.waitForConnection();
  }

  /**
   * 释放连接
   */
  release(connection: any): void {
    this.available.push(connection);
  }

  /**
   * 关闭所有连接
   */
  async closeAll(): Promise<void> {
    for (const connection of this.connections) {
      await this.closeConnection(connection);
    }
    this.connections = [];
    this.available = [];
  }

  private async createConnection(): Promise<any> {
    // 实现连接创建逻辑
    return {};
  }

  private async closeConnection(connection: any): Promise<void> {
    // 实现连接关闭逻辑
  }

  private async waitForConnection(): Promise<any> {
    return new Promise((resolve) => {
      const interval = setInterval(() => {
        if (this.available.length > 0) {
          clearInterval(interval);
          resolve(this.available.pop());
        }
      }, 100);
    });
  }
}
```

### 懒加载

```typescript
export class LazyLoader {
  private loaded = new Map<string, any>();

  /**
   * 懒加载模块
   */
  async load<T>(name: string, loader: () => Promise<T>): Promise<T> {
    if (this.loaded.has(name)) {
      return this.loaded.get(name) as T;
    }

    const module = await loader();
    this.loaded.set(name, module);
    return module;
  }

  /**
   * 卸载模块
   */
  unload(name: string): void {
    this.loaded.delete(name);
  }
}
```

---

## 发布与部署

### 发布到 npm

```bash
# 1. 登录 npm
npm login

# 2. 构建项目
npm run build

# 3. 测试打包
npm pack

# 4. 发布
npm publish --access public

# 5. 验证发布
npm view @myorg/mcp-weather-extension
```

[Source: Pi Packages Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/packages.md)

### 版本管理

```bash
# 补丁版本（bug 修复）
npm version patch

# 次版本（新功能）
npm version minor

# 主版本（破坏性变更）
npm version major

# 发布新版本
git push && git push --tags
npm publish
```

### 安装和更新

```bash
# 全局安装
pi install npm:@myorg/mcp-weather-extension@1.0.0

# 项目安装
pi install -l npm:@myorg/mcp-weather-extension

# 更新所有包
pi update

# 列出已安装包
pi list

# 移除包
pi remove npm:@myorg/mcp-weather-extension
```

[Source: Pi Packages Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/packages.md)

### 生产环境最佳实践

```typescript
// ✅ 使用环境变量
const apiKey = process.env.API_KEY;

// ✅ 验证配置
if (!apiKey) {
  throw new Error('API_KEY is required');
}

// ✅ 添加健康检查
export async function healthCheck(): Promise<boolean> {
  try {
    // 检查 MCP 服务器连接
    await mcpClient.ping();
    return true;
  } catch (error) {
    Logger.error('Health check failed:', error);
    return false;
  }
}

// ✅ 优雅关闭
process.on('SIGTERM', async () => {
  Logger.info('Received SIGTERM, shutting down gracefully');

  // 关闭连接
  await connectionPool.closeAll();

  // 清理缓存
  cacheManager.clear();

  process.exit(0);
});

// ✅ 监控和告警
export function setupMonitoring(): void {
  setInterval(async () => {
    const healthy = await healthCheck();
    if (!healthy) {
      // 发送告警
      Logger.error('Service unhealthy');
    }
  }, 60000); // 每分钟检查一次
}
```

[Source: The AI SRE Revolution](https://thamizhelango.medium.com/the-ai-sre-revolution-how-pi-mono-can-automate-60-of-your-azure-operations-and-why-you-still-e09f4f6575fa)

---

## 总结

### 核心要点

1. **npm 打包**：完整的 package.json + pi manifest
2. **配置管理**：环境变量 + settings.json 优先级
3. **错误处理**：分类错误 + 详细日志
4. **性能优化**：缓存 + 连接池 + 懒加载
5. **生产部署**：版本管理 + 健康检查 + 优雅关闭

### 关键约束

- ✅ 使用 peerDependencies 声明核心包
- ✅ 环境变量管理敏感信息
- ✅ 完整的错误处理和日志
- ✅ 性能优化（缓存、连接池）
- ✅ 健康检查和监控

### 下一步

- 阅读 [07_实战代码_09_发现与配置Servers](./07_实战代码_09_发现与配置Servers.md) 学习服务器发现
- 阅读 [07_实战代码_10_常用Server集成](./07_实战代码_10_常用Server集成.md) 学习常用服务器

---

**参考资源**：
- [Pi Packages Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/packages.md)
- [The AI SRE Revolution](https://thamizhelango.medium.com/the-ai-sre-revolution-how-pi-mono-can-automate-60-of-your-azure-operations-and-why-you-still-e09f4f6575fa)
- [npm Publishing Guide](https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry)
