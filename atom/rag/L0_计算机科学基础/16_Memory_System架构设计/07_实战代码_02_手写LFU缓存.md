# 实战代码：手写LFU缓存

> **从零实现生产级 LFU 缓存**

---

## 学习目标

- 掌握 LFU 缓存的实现原理
- 理解频率计数的数据结构设计
- 能够手写 O(1) 时间复杂度的 LFU 缓存
- 了解 LFU 与 LRU 的区别

---

## 实现1：简单版本（O(n) 淘汰）

```python
from collections import defaultdict
from typing import Any, Optional

class SimpleLFUCache:
    """简单 LFU 缓存（O(n) 淘汰）"""

    def __init__(self, capacity: int):
        """
        初始化 LFU 缓存

        Args:
            capacity: 缓存容量
        """
        if capacity <= 0:
            raise ValueError("Capacity must be positive")

        self.capacity = capacity
        self.cache: dict[str, Any] = {}
        self.freq: dict[str, int] = defaultdict(int)

    def get(self, key: str) -> Optional[Any]:
        """
        获取缓存值

        Args:
            key: 缓存键

        Returns:
            缓存值，如果不存在返回 None
        """
        if key not in self.cache:
            return None

        # 增加访问频率
        self.freq[key] += 1
        return self.cache[key]

    def put(self, key: str, value: Any) -> None:
        """
        存入缓存

        Args:
            key: 缓存键
            value: 缓存值
        """
        if self.capacity == 0:
            return

        if key in self.cache:
            # 更新已有数据
            self.cache[key] = value
            self.freq[key] += 1
        else:
            # 新增数据
            if len(self.cache) >= self.capacity:
                # 找到频率最低的键（O(n)）
                min_freq_key = min(self.freq, key=self.freq.get)
                del self.cache[min_freq_key]
                del self.freq[min_freq_key]

            self.cache[key] = value
            self.freq[key] = 1

    def size(self) -> int:
        """获取当前缓存大小"""
        return len(self.cache)

# 测试
if __name__ == "__main__":
    cache = SimpleLFUCache(capacity=2)

    cache.put("A", 1)
    cache.put("B", 2)

    # A 访问 5 次
    for _ in range(5):
        cache.get("A")

    # B 访问 1 次
    cache.get("B")

    print(f"A 频率: {cache.freq['A']}")  # 6
    print(f"B 频率: {cache.freq['B']}")  # 2

    # 添加 C，应该淘汰 B（频率最低）
    cache.put("C", 3)

    print(f"A: {cache.get('A')}")  # 1（保留）
    print(f"B: {cache.get('B')}")  # None（被淘汰）
    print(f"C: {cache.get('C')}")  # 3（新增）
```

**问题**：淘汰操作是 O(n)，性能不够好。

---

## 实现2：优化版本（O(1) 操作）

### 数据结构设计

```python
from collections import defaultdict
from typing import Any, Optional

class Node:
    """双向链表节点"""
    def __init__(self, key: str = "", value: Any = None):
        self.key = key
        self.value = value
        self.freq = 1
        self.prev: Optional[Node] = None
        self.next: Optional[Node] = None

class DoublyLinkedList:
    """双向链表（存储相同频率的键）"""
    def __init__(self):
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0

    def add_to_head(self, node: Node) -> None:
        """添加到头部"""
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node
        self.size += 1

    def remove_node(self, node: Node) -> None:
        """移除节点"""
        node.prev.next = node.next
        node.next.prev = node.prev
        self.size -= 1

    def remove_tail(self) -> Optional[Node]:
        """移除尾部节点"""
        if self.size == 0:
            return None
        node = self.tail.prev
        self.remove_node(node)
        return node

    def is_empty(self) -> bool:
        """检查是否为空"""
        return self.size == 0

class LFUCache:
    """LFU 缓存（O(1) 实现）"""

    def __init__(self, capacity: int):
        """
        初始化 LFU 缓存

        Args:
            capacity: 缓存容量
        """
        if capacity <= 0:
            raise ValueError("Capacity must be positive")

        self.capacity = capacity
        self.min_freq = 0
        self.key_map: dict[str, Node] = {}  # key → Node
        self.freq_map: dict[int, DoublyLinkedList] = defaultdict(DoublyLinkedList)

    def _update_freq(self, node: Node) -> None:
        """更新节点频率"""
        # 从旧频率链表中移除
        old_freq = node.freq
        self.freq_map[old_freq].remove_node(node)

        # 如果旧频率链表为空且是最小频率，更新最小频率
        if self.freq_map[old_freq].is_empty() and old_freq == self.min_freq:
            self.min_freq += 1

        # 增加频率
        node.freq += 1

        # 添加到新频率链表
        self.freq_map[node.freq].add_to_head(node)

    def get(self, key: str) -> Optional[Any]:
        """
        O(1) 获取缓存值

        Args:
            key: 缓存键

        Returns:
            缓存值，如果不存在返回 None
        """
        if key not in self.key_map:
            return None

        node = self.key_map[key]
        self._update_freq(node)
        return node.value

    def put(self, key: str, value: Any) -> None:
        """
        O(1) 存入缓存

        Args:
            key: 缓存键
            value: 缓存值
        """
        if self.capacity == 0:
            return

        if key in self.key_map:
            # 更新已有数据
            node = self.key_map[key]
            node.value = value
            self._update_freq(node)
        else:
            # 新增数据
            if len(self.key_map) >= self.capacity:
                # 淘汰最小频率的最久未使用的节点
                min_freq_list = self.freq_map[self.min_freq]
                removed = min_freq_list.remove_tail()
                if removed:
                    del self.key_map[removed.key]

            # 创建新节点
            node = Node(key, value)
            self.key_map[key] = node
            self.freq_map[1].add_to_head(node)
            self.min_freq = 1

    def delete(self, key: str) -> bool:
        """
        删除缓存

        Args:
            key: 缓存键

        Returns:
            是否删除成功
        """
        if key not in self.key_map:
            return False

        node = self.key_map[key]
        self.freq_map[node.freq].remove_node(node)
        del self.key_map[key]

        # 更新最小频率
        if self.freq_map[node.freq].is_empty() and node.freq == self.min_freq:
            self.min_freq += 1

        return True

    def clear(self) -> None:
        """清空缓存"""
        self.key_map.clear()
        self.freq_map.clear()
        self.min_freq = 0

    def size(self) -> int:
        """获取当前缓存大小"""
        return len(self.key_map)

    def get_freq(self, key: str) -> int:
        """获取键的访问频率"""
        if key not in self.key_map:
            return 0
        return self.key_map[key].freq

    def __repr__(self) -> str:
        return f"LFUCache(capacity={self.capacity}, size={self.size()}, min_freq={self.min_freq})"

# 测试
if __name__ == "__main__":
    cache = LFUCache(capacity=2)

    cache.put("A", 1)
    cache.put("B", 2)

    # A 访问 5 次
    for _ in range(5):
        cache.get("A")

    # B 访问 1 次
    cache.get("B")

    print(f"A 频率: {cache.get_freq('A')}")  # 6
    print(f"B 频率: {cache.get_freq('B')}")  # 2

    # 添加 C，应该淘汰 B（频率最低）
    cache.put("C", 3)

    print(f"A: {cache.get('A')}")  # 1（保留，频率=7）
    print(f"B: {cache.get('B')}")  # None（被淘汰）
    print(f"C: {cache.get('C')}")  # 3（新增，频率=2）

    print(cache)  # LFUCache(capacity=2, size=2, min_freq=2)
```

---

## 扩展1：带频率衰减的 LFU

```python
import time
from typing import Any, Optional

class LFUWithDecay:
    """带频率衰减的 LFU 缓存"""

    def __init__(self, capacity: int, decay_interval: int = 3600):
        """
        初始化

        Args:
            capacity: 缓存容量
            decay_interval: 衰减间隔（秒）
        """
        self.capacity = capacity
        self.decay_interval = decay_interval
        self.cache: dict[str, Any] = {}
        self.freq: dict[str, int] = {}
        self.last_access: dict[str, float] = {}

    def _decay_freq(self, key: str) -> None:
        """衰减频率"""
        if key not in self.last_access:
            return

        now = time.time()
        elapsed = now - self.last_access[key]
        decay_factor = int(elapsed / self.decay_interval)

        if decay_factor > 0:
            self.freq[key] = max(1, self.freq[key] - decay_factor)

    def get(self, key: str) -> Optional[Any]:
        """获取缓存（带频率衰减）"""
        if key not in self.cache:
            return None

        # 衰减频率
        self._decay_freq(key)

        # 增加频率
        self.freq[key] += 1
        self.last_access[key] = time.time()

        return self.cache[key]

    def put(self, key: str, value: Any) -> None:
        """存入缓存"""
        if len(self.cache) >= self.capacity and key not in self.cache:
            # 衰减所有键的频率
            for k in list(self.cache.keys()):
                self._decay_freq(k)

            # 淘汰频率最低的
            min_freq_key = min(self.freq, key=self.freq.get)
            del self.cache[min_freq_key]
            del self.freq[min_freq_key]
            del self.last_access[min_freq_key]

        self.cache[key] = value
        self.freq[key] = self.freq.get(key, 0) + 1
        self.last_access[key] = time.time()

# 测试频率衰减
if __name__ == "__main__":
    cache = LFUWithDecay(capacity=3, decay_interval=2)

    cache.put("A", 1)
    for _ in range(10):
        cache.get("A")  # A 频率 = 11

    print(f"A 初始频率: {cache.freq['A']}")  # 11

    # 等待 4 秒（2个衰减周期）
    time.sleep(4)

    cache.get("A")  # 触发衰减
    print(f"A 衰减后频率: {cache.freq['A']}")  # 11 - 2 + 1 = 10
```

---

## 扩展2：带统计的 LFU 缓存

```python
from dataclasses import dataclass

@dataclass
class LFUStats:
    """LFU 缓存统计"""
    hits: int = 0
    misses: int = 0
    evictions: int = 0
    total_freq: int = 0

    @property
    def hit_rate(self) -> float:
        """命中率"""
        total = self.hits + self.misses
        return self.hits / total if total > 0 else 0.0

    @property
    def avg_freq(self) -> float:
        """平均频率"""
        return self.total_freq / self.hits if self.hits > 0 else 0.0

class MonitoredLFUCache(LFUCache):
    """带监控的 LFU 缓存"""

    def __init__(self, capacity: int):
        super().__init__(capacity)
        self.stats = LFUStats()

    def get(self, key: str) -> Optional[Any]:
        """获取缓存（记录统计）"""
        result = super().get(key)

        if result is not None:
            self.stats.hits += 1
            self.stats.total_freq += self.key_map[key].freq
        else:
            self.stats.misses += 1

        return result

    def put(self, key: str, value: Any) -> None:
        """存入缓存（记录淘汰）"""
        will_evict = (key not in self.key_map and len(self.key_map) >= self.capacity)

        super().put(key, value)

        if will_evict:
            self.stats.evictions += 1

    def get_stats(self) -> LFUStats:
        """获取统计信息"""
        return self.stats

    def reset_stats(self) -> None:
        """重置统计"""
        self.stats = LFUStats()

# 测试统计
if __name__ == "__main__":
    cache = MonitoredLFUCache(capacity=3)

    # 模拟访问
    cache.put("A", 1)
    cache.put("B", 2)
    cache.put("C", 3)

    # A 访问 10 次
    for _ in range(10):
        cache.get("A")

    # B 访问 5 次
    for _ in range(5):
        cache.get("B")

    # C 访问 1 次
    cache.get("C")

    # 未命中
    cache.get("D")

    # 添加 D，淘汰 C
    cache.put("D", 4)

    stats = cache.get_stats()
    print(f"命中: {stats.hits}")  # 16
    print(f"未命中: {stats.misses}")  # 1
    print(f"淘汰: {stats.evictions}")  # 1
    print(f"命中率: {stats.hit_rate:.2%}")  # 94.12%
    print(f"平均频率: {stats.avg_freq:.2f}")  # ~3.5
```

---

## 完整测试套件

```python
import unittest

class TestLFUCache(unittest.TestCase):
    """LFU 缓存测试"""

    def setUp(self):
        """测试前准备"""
        self.cache = LFUCache(capacity=2)

    def test_basic_operations(self):
        """测试基本操作"""
        self.cache.put("a", 1)
        self.cache.put("b", 2)

        self.assertEqual(self.cache.get("a"), 1)
        self.assertEqual(self.cache.get("b"), 2)
        self.assertIsNone(self.cache.get("c"))

    def test_eviction_by_frequency(self):
        """测试按频率淘汰"""
        self.cache.put("a", 1)
        self.cache.put("b", 2)

        # a 访问 5 次
        for _ in range(5):
            self.cache.get("a")

        # b 访问 1 次
        self.cache.get("b")

        # 添加 c，应该淘汰 b（频率最低）
        self.cache.put("c", 3)

        self.assertEqual(self.cache.get("a"), 1)
        self.assertIsNone(self.cache.get("b"))
        self.assertEqual(self.cache.get("c"), 3)

    def test_same_frequency_lru(self):
        """测试相同频率时按 LRU 淘汰"""
        self.cache.put("a", 1)
        self.cache.put("b", 2)

        # a 和 b 都访问 1 次（频率相同）
        self.cache.get("a")
        self.cache.get("b")

        # 再次访问 b（b 变成最近使用）
        self.cache.get("b")

        # 添加 c，应该淘汰 a（频率相同，但 a 更久未使用）
        self.cache.put("c", 3)

        self.assertIsNone(self.cache.get("a"))
        self.assertEqual(self.cache.get("b"), 2)
        self.assertEqual(self.cache.get("c"), 3)

    def test_update_existing(self):
        """测试更新已有数据"""
        self.cache.put("a", 1)
        self.cache.put("a", 10)

        self.assertEqual(self.cache.get("a"), 10)

    def test_delete(self):
        """测试删除"""
        self.cache.put("a", 1)
        self.assertTrue(self.cache.delete("a"))
        self.assertIsNone(self.cache.get("a"))
        self.assertFalse(self.cache.delete("a"))

    def test_clear(self):
        """测试清空"""
        self.cache.put("a", 1)
        self.cache.put("b", 2)
        self.cache.clear()

        self.assertEqual(self.cache.size(), 0)
        self.assertIsNone(self.cache.get("a"))

    def test_capacity_zero(self):
        """测试容量为0"""
        with self.assertRaises(ValueError):
            LFUCache(capacity=0)

if __name__ == "__main__":
    unittest.main()
```

---

## 性能基准测试

```python
import time
import random

def benchmark_lfu_cache():
    """性能基准测试"""
    cache = LFUCache(capacity=1000)

    # 测试写入性能
    start = time.time()
    for i in range(10000):
        cache.put(f"key_{i}", f"value_{i}")
    write_time = time.time() - start

    # 测试读取性能（命中）
    start = time.time()
    for i in range(10000):
        cache.get(f"key_{i % 1000}")
    read_hit_time = time.time() - start

    # 测试读取性能（未命中）
    start = time.time()
    for i in range(10000):
        cache.get(f"nonexistent_{i}")
    read_miss_time = time.time() - start

    print(f"写入 10000 次: {write_time:.3f}秒 ({10000/write_time:.0f} ops/s)")
    print(f"读取 10000 次（命中）: {read_hit_time:.3f}秒 ({10000/read_hit_time:.0f} ops/s)")
    print(f"读取 10000 次（未命中）: {read_miss_time:.3f}秒 ({10000/read_miss_time:.0f} ops/s)")

if __name__ == "__main__":
    benchmark_lfu_cache()
```

---

## LRU vs LFU 对比测试

```python
def compare_lru_lfu():
    """对比 LRU 和 LFU 性能"""
    from collections import OrderedDict

    # LRU 缓存
    lru_cache = OrderedDict()
    lru_capacity = 100

    # LFU 缓存
    lfu_cache = LFUCache(capacity=100)

    # 模拟访问模式：80% 访问热点数据，20% 访问冷数据
    access_pattern = []
    hot_keys = [f"hot_{i}" for i in range(20)]  # 20个热点
    cold_keys = [f"cold_{i}" for i in range(200)]  # 200个冷数据

    for _ in range(10000):
        if random.random() < 0.8:
            key = random.choice(hot_keys)
        else:
            key = random.choice(cold_keys)
        access_pattern.append(key)

    # 测试 LRU
    lru_hits = 0
    for key in access_pattern:
        if key in lru_cache:
            lru_hits += 1
            lru_cache.move_to_end(key)
        else:
            if len(lru_cache) >= lru_capacity:
                lru_cache.popitem(last=False)
            lru_cache[key] = f"value_{key}"

    # 测试 LFU
    lfu_hits = 0
    for key in access_pattern:
        if lfu_cache.get(key) is not None:
            lfu_hits += 1
        else:
            lfu_cache.put(key, f"value_{key}")

    print(f"LRU 命中率: {lru_hits / len(access_pattern):.2%}")
    print(f"LFU 命中率: {lfu_hits / len(access_pattern):.2%}")

if __name__ == "__main__":
    compare_lru_lfu()
```

**输出示例**：
```
LRU 命中率: 65%
LFU 命中率: 78%  ← LFU 在热点数据场景下更优
```

---

## AI Agent 应用示例

### 热门问题缓存

```python
class HotQuestionCache:
    """热门问题缓存（LFU 策略）"""

    def __init__(self, capacity: int = 100):
        self.cache = LFUCache(capacity=capacity)

    def get_answer(self, question: str) -> Optional[str]:
        """获取问题答案"""
        return self.cache.get(question)

    def cache_answer(self, question: str, answer: str) -> None:
        """缓存问题答案"""
        self.cache.put(question, answer)

    def get_hot_questions(self, top_n: int = 10) -> list:
        """获取最热门的问题"""
        questions = sorted(
            self.cache.key_map.items(),
            key=lambda x: x[1].freq,
            reverse=True
        )
        return [(q, node.freq) for q, node in questions[:top_n]]

# 使用示例
hot_cache = HotQuestionCache(capacity=100)

# 模拟用户提问
questions = [
    "什么是 RAG？",
    "如何实现 LRU 缓存？",
    "什么是 RAG？",  # 重复
    "Python 如何异步编程？",
    "什么是 RAG？",  # 重复
    "什么是 RAG？",  # 重复
]

for q in questions:
    answer = hot_cache.get_answer(q)
    if answer is None:
        answer = f"答案：{q}"
        hot_cache.cache_answer(q, answer)

# 获取热门问题
hot = hot_cache.get_hot_questions(top_n=3)
for question, freq in hot:
    print(f"{question}: {freq} 次访问")
```

**输出**：
```
什么是 RAG？: 5 次访问
如何实现 LRU 缓存？: 2 次访问
Python 如何异步编程？: 2 次访问
```

---

## 总结

### LRU vs LFU

| 特性 | LRU | LFU |
|------|-----|-----|
| **淘汰依据** | 最久未使用 | 访问频率最低 |
| **实现复杂度** | 简单 | 复杂 |
| **时间复杂度** | O(1) | O(1) |
| **适用场景** | 时间局部性强 | 热点数据明显 |
| **新数据处理** | 友好 | 不友好（频率低） |
| **历史数据** | 容易淘汰 | 难以淘汰 |

### 关键要点

1. **数据结构**：频率 → 双向链表 + 哈希表
2. **最小频率**：维护 min_freq 加速淘汰
3. **时间复杂度**：所有操作 O(1)
4. **频率衰减**：避免历史数据长期占据
5. **应用场景**：热点数据缓存、API 限流

### 下一步

- 实现多级缓存系统
- 学习语义缓存
- 实践 AI Agent 记忆管理

---

## 参考资源

- [LeetCode 460: LFU Cache](https://leetcode.com/problems/lfu-cache/)
- [Redis LFU Implementation](https://redis.io/blog/lfu-vs-lru-how-to-choose-the-right-cache-eviction-policy)
- [W-TinyLFU Paper](https://arxiv.org/abs/1512.00727)
