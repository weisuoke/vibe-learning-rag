# 面试必问

## 问题 1："请解释 pi-mono 的事件系统与钩子机制"

### 普通回答（❌ 不出彩）

"pi-mono 的事件系统基于 EventEmitter，可以监听各种事件，比如 session_start、tool_call 等。钩子就是在特定时刻执行的回调函数。"

**问题：**
- 过于简单，没有深度
- 没有说明设计理念
- 没有联系实际应用
- 没有展示对架构的理解

---

### 出彩回答（✅ 推荐）

> **pi-mono 的事件系统与钩子机制有三层含义：**
>
> **1. 架构层面：双层事件总线设计**
>
> pi-mono 采用双层事件总线架构，分别服务于不同的通信需求：
>
> - **pi.on()** - 生命周期事件总线：用于监听 Agent 运行时的预定义事件（40+ 生命周期钩子），如 session_start、before_agent_start、tool_call 等。这是核心代码与扩展之间的单向通信机制。
>
> - **pi.events** - 自定义事件总线：用于扩展之间的双向通信，支持用户自定义事件名称和参数。这是扩展间松耦合协作的基础。
>
> 这种设计遵循了**关注点分离**原则：生命周期事件用于观察和增强核心流程，自定义事件用于模块间协作。
>
> **2. 实现层面：基于 Node.js EventEmitter**
>
> 底层实现基于 Node.js 的 EventEmitter，但做了以下增强：
>
> - **类型安全**：通过 TypeScript 接口定义所有事件类型和参数
> - **错误隔离**：事件处理器中的错误会被自动捕获，不会中断 Agent 运行
> - **异步支持**：支持异步事件处理器，不阻塞主流程
> - **Spawn Hooks**：特殊的命令拦截机制，可以在 bash 命令执行前修改 command、cwd、env
>
> 例如，before_agent_start 钩子允许修改消息数组：
>
> ```typescript
> pi.on('before_agent_start', (messages) => {
>   messages.push({
>     role: 'system',
>     content: 'Project context: TypeScript + React'
>   });
> });
> ```
>
> **3. 应用层面：可扩展的插件架构**
>
> 事件系统是 pi-mono 可扩展性的核心，支持：
>
> - **非侵入式扩展**：无需修改核心代码即可添加功能
> - **模块化开发**：每个 Extension 独立开发和部署
> - **松耦合协作**：通过事件实现扩展间通信，避免直接依赖
>
> **实际应用场景：**
>
> 1. **监控和日志**：监听 tool_call 事件记录所有工具调用
> 2. **上下文注入**：在 before_agent_start 注入项目特定的上下文
> 3. **环境配置**：通过 Spawn Hooks 注入开发环境变量
> 4. **扩展协作**：数据提供者通过 pi.events.emit('data-ready') 发布数据，多个消费者订阅处理
>
> **与其他框架的对比：**
>
> - 类似 Express 的中间件机制，但更灵活（不需要 next()）
> - 类似 React 的生命周期钩子，但用于 Agent 运行时
> - 类似微服务的事件驱动架构，但在单进程内实现

---

### 为什么这个回答出彩？

1. ✅ **多层次解释**：从架构、实现、应用三个层面全面阐述
2. ✅ **展示深度理解**：说明了双层事件总线的设计理念和关注点分离
3. ✅ **具体代码示例**：提供了实际的代码示例
4. ✅ **联系实际应用**：列举了 4 个实际应用场景
5. ✅ **对比分析**：与其他框架进行对比，展示广度
6. ✅ **技术细节**：提到了类型安全、错误隔离、异步支持等实现细节

---

## 问题 2："Spawn Hooks 和普通事件监听有什么区别？"

### 普通回答（❌ 不出彩）

"Spawn Hooks 是用来拦截 bash 命令的，普通事件监听是监听各种事件的。Spawn Hooks 可以修改命令，事件监听只能观察。"

**问题：**
- 只说了表面区别
- 没有说明为什么需要这种区别
- 没有深入到设计理念
- 没有实际应用场景

---

### 出彩回答（✅ 推荐）

> **Spawn Hooks 和普通事件监听的区别体现在三个维度：**
>
> **1. 设计目的不同**
>
> - **普通事件监听（pi.on）**：观察者模式，用于**监控和响应**事件，不能阻止或修改事件本身。核心代码发布事件，扩展被动接收。
>
> - **Spawn Hooks**：拦截器模式，用于**拦截和修改**命令执行，可以在命令执行前修改参数或阻止执行。这是一种主动干预机制。
>
> **2. 作用范围不同**
>
> | 特性 | 普通事件监听 | Spawn Hooks |
> |------|------------|-------------|
> | 触发范围 | 所有工具（bash, read, write, edit） | 仅 bash 工具 |
> | 修改能力 | 不能修改（只读） | 可以修改 command、cwd、env |
> | 返回值 | 无需返回值 | 必须返回 { command, cwd, env } |
> | 执行时机 | 事件发生时 | 命令执行前 |
>
> **3. 使用场景不同**
>
> **普通事件监听的典型场景：**
>
> ```typescript
> // 场景 1：监控所有工具调用
> pi.on('tool_call', (tool, args) => {
>   logger.info('Tool called:', tool.name);
>   metrics.track('tool_call', { tool: tool.name });
> });
>
> // 场景 2：在 Agent 启动前注入上下文
> pi.on('before_agent_start', (messages) => {
>   messages.push({
>     role: 'system',
>     content: loadProjectContext()
>   });
> });
> ```
>
> **Spawn Hooks 的典型场景：**
>
> ```typescript
> // 场景 1：注入环境变量
> pi.registerSpawnHook((command, cwd, env) => {
>   env.NODE_ENV = 'development';
>   env.PROJECT_ROOT = cwd;
>   return { command, cwd, env };
> });
>
> // 场景 2：安全过滤
> pi.registerSpawnHook((command, cwd, env) => {
>   if (command.includes('rm -rf /')) {
>     console.error('Dangerous command blocked');
>     return { command: 'echo "Blocked"', cwd, env };
>   }
>   return { command, cwd, env };
> });
> ```
>
> **为什么需要这种区别？**
>
> 1. **关注点分离**：普通事件用于观察和增强，Spawn Hooks 用于控制和修改
> 2. **安全性**：bash 命令执行涉及系统安全，需要特殊的拦截机制
> 3. **灵活性**：不同的需求需要不同的机制，观察不需要修改能力，修改需要特殊的接口
>
> **实际应用中的协作：**
>
> ```typescript
> // 使用 tool_call 监控所有工具
> pi.on('tool_call', (tool, args) => {
>   if (tool.name === 'bash') {
>     console.log('Bash command will be executed:', args.command);
>   }
> });
>
> // 使用 Spawn Hook 修改 bash 命令
> pi.registerSpawnHook((command, cwd, env) => {
>   console.log('Intercepting bash command:', command);
>   env.MY_VAR = 'value';
>   return { command, cwd, env };
> });
> ```
>
> **常见误区：**
>
> ❌ "Spawn Hooks 可以拦截所有工具" - 错误，只拦截 bash
> ❌ "普通事件监听可以修改参数" - 错误，只有特定钩子（如 before_agent_start）可以修改
> ❌ "Spawn Hooks 可以阻止 Agent 启动" - 错误，只能修改命令，不能阻止流程

---

### 为什么这个回答出彩？

1. ✅ **结构化对比**：从设计目的、作用范围、使用场景三个维度系统对比
2. ✅ **表格总结**：用表格清晰展示关键区别
3. ✅ **代码示例**：提供了两种机制的实际代码示例
4. ✅ **深入理解**：说明了为什么需要这种区别（关注点分离、安全性、灵活性）
5. ✅ **协作示例**：展示了两种机制如何协同工作
6. ✅ **常见误区**：指出了常见的错误理解

---

## 面试技巧

### 1. 展示系统性思维

不要只回答表面问题，要从多个层面（架构、实现、应用）系统性地阐述。

### 2. 联系实际应用

每个概念都要联系实际应用场景，展示你的实战经验。

### 3. 对比分析

与其他框架或技术进行对比，展示你的技术广度。

### 4. 指出常见误区

主动指出常见误区，展示你的深度理解。

### 5. 使用具体代码

用具体的代码示例支撑你的观点，而不是空谈概念。

---

## 延伸问题

面试官可能会继续追问：

### Q1: "如何设计一个高性能的事件系统？"

**关键点：**
- 事件队列和批处理
- 异步处理和非阻塞
- 错误隔离和容错
- 内存管理和清理

### Q2: "如果有多个 Spawn Hooks，执行顺序是什么？"

**关键点：**
- 按注册顺序执行
- 每个 Hook 接收前一个 Hook 的输出
- 最后一个 Hook 的输出是实际执行的参数
- 如果某个 Hook 抛出错误，后续 Hook 不会执行

### Q3: "事件系统如何保证类型安全？"

**关键点：**
- TypeScript 接口定义所有事件类型
- 泛型支持灵活的事件参数
- 编译时类型检查
- 运行时参数验证（可选）

---

**版本：** v1.0
**最后更新：** 2026-02-21
**维护者：** Claude Code
