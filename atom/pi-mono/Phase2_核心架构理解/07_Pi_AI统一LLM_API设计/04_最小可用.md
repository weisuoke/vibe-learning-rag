# 最小可用知识

> 掌握 20% 核心知识，解决 80% 的问题

---

## 核心理念

**Pi AI 统一 LLM API = Provider Adapter + 统一消息格式 + 工具调用标准化**

掌握以下内容，就能理解和使用 Pi AI 的核心功能。

---

## 4.1 Provider Adapter 模式

**一句话：** 每个 LLM Provider 一个适配器，统一接口调用。

### 核心接口

```typescript
interface ProviderAdapter {
  // 同步调用（等待完整响应）
  complete(context: Context): Promise<Message>;

  // 流式调用（实时返回增量内容）
  stream(context: Context): AsyncGenerator<StreamEvent>;
}
```

### 使用示例

```typescript
import { getModel, complete } from '@mariozechner/pi-ai';

// 1. 获取模型（自动选择对应的 Provider Adapter）
const model = getModel('openai', 'gpt-4o-mini');

// 2. 构建上下文
const context = {
  systemPrompt: 'You are a helpful assistant.',
  messages: [
    { role: 'user', content: 'Hello!' }
  ]
};

// 3. 调用（统一接口，无需关心底层 Provider）
const response = await complete(model, context);
console.log(response.content);
```

**关键点：**
- `getModel()` 自动选择对应的 Adapter
- `complete()` 和 `stream()` 是统一接口
- 切换 Provider 只需修改 `getModel()` 的参数

---

## 4.2 统一消息格式

**一句话：** 内部使用标准格式，自动转换为 Provider 特定格式。

### 核心类型

```typescript
// Context：对话上下文
interface Context {
  systemPrompt?: string;           // 系统提示
  messages: Message[];              // 消息列表
  tools?: Tool[];                   // 可用工具
  temperature?: number;             // 温度参数
  maxTokens?: number;               // 最大 Token 数
}

// Message：单条消息
interface Message {
  role: 'user' | 'assistant' | 'system';
  content: string | ContentBlock[];
}

// ContentBlock：内容块（支持多模态）
type ContentBlock =
  | { type: 'text', text: string }
  | { type: 'image', source: ImageSource }
  | { type: 'tool_use', id: string, name: string, input: any }
  | { type: 'tool_result', tool_use_id: string, content: string };
```

### 格式转换示例

```typescript
// Pi AI 内部格式
const piMessage = {
  role: 'user',
  content: [
    { type: 'text', text: 'Hello' },
    { type: 'image', source: { url: 'https://...' } }
  ]
};

// 自动转换为 OpenAI 格式
const openaiMessage = {
  role: 'user',
  content: [
    { type: 'text', text: 'Hello' },
    { type: 'image_url', image_url: { url: 'https://...' } }
  ]
};

// 自动转换为 Anthropic 格式
const anthropicMessage = {
  role: 'user',
  content: [
    { type: 'text', text: 'Hello' },
    { type: 'image', source: { type: 'url', url: 'https://...' } }
  ]
};
```

**关键点：**
- 开发者只需使用 Pi AI 内部格式
- Adapter 自动处理格式转换
- 支持多模态内容（文本、图片、工具调用）

---

## 4.3 工具调用标准化

**一句话：** 使用 TypeBox 定义工具 schema，自动验证参数。

### 定义工具

```typescript
import { Type } from '@sinclair/typebox';

// 1. 定义工具 schema
const weatherTool = {
  name: 'get_weather',
  description: 'Get current weather for a location',
  parameters: Type.Object({
    location: Type.String({ description: 'City name' }),
    unit: Type.Optional(Type.Union([
      Type.Literal('celsius'),
      Type.Literal('fahrenheit')
    ]))
  })
};

// 2. 注册工具
const context = {
  systemPrompt: 'You are a helpful assistant.',
  messages: [{ role: 'user', content: 'What is the weather in Tokyo?' }],
  tools: [weatherTool]
};

// 3. 调用（LLM 会自动选择工具）
const response = await complete(model, context);

// 4. 处理工具调用
if (response.toolCalls) {
  for (const toolCall of response.toolCalls) {
    console.log(`Tool: ${toolCall.name}`);
    console.log(`Args: ${JSON.stringify(toolCall.input)}`);
    // 执行工具...
  }
}
```

**关键点：**
- TypeBox 自动生成 JSON Schema
- 自动验证工具参数
- 统一的工具调用格式

---

## 4.4 流式响应处理

**一句话：** 使用 `stream()` 实时获取增量内容。

### 流式调用示例

```typescript
import { getModel, stream } from '@mariozechner/pi-ai';

const model = getModel('openai', 'gpt-4o-mini');
const context = {
  systemPrompt: 'You are a helpful assistant.',
  messages: [{ role: 'user', content: 'Write a poem about TypeScript' }]
};

// 流式调用
for await (const event of stream(model, context)) {
  if (event.type === 'start') {
    console.log('Stream started');
  } else if (event.type === 'delta') {
    // 增量内容
    process.stdout.write(event.delta.content);
  } else if (event.type === 'end') {
    console.log('\nStream ended');
    console.log(`Tokens: ${event.usage.totalTokens}`);
  }
}
```

**关键点：**
- `stream()` 返回 AsyncGenerator
- 三种事件：`start`、`delta`、`end`
- 实时输出，无需等待完整响应

---

## 4.5 切换 Provider

**一句话：** 一行代码切换 Provider，无需修改其他代码。

### 切换示例

```typescript
// 使用 OpenAI
const openaiModel = getModel('openai', 'gpt-4o-mini');
const response1 = await complete(openaiModel, context);

// 切换到 Anthropic（代码完全相同）
const anthropicModel = getModel('anthropic', 'claude-opus-4');
const response2 = await complete(anthropicModel, context);

// 切换到本地模型（代码完全相同）
const ollamaModel = getModel('ollama', 'llama3.2');
const response3 = await complete(ollamaModel, context);
```

**关键点：**
- 只需修改 `getModel()` 参数
- 其他代码完全不变
- 支持 25+ Provider

---

## 这些知识足以

掌握以上 5 个核心知识点，你就能：

### 使用层面
- ✅ 调用任意 LLM Provider
- ✅ 在不同 Provider 之间切换
- ✅ 处理流式响应
- ✅ 使用工具调用
- ✅ 处理多模态内容

### 理解层面
- ✅ 理解 Provider Adapter 模式
- ✅ 理解统一消息格式的价值
- ✅ 理解工具调用的标准化
- ✅ 理解流式响应的事件架构

### 应用层面
- ✅ 为项目选择合适的 Provider
- ✅ 实现多模型策略
- ✅ 优化成本和性能
- ✅ 构建生产级 Agent

---

## 快速参考卡

### 核心 API

```typescript
// 1. 获取模型
const model = getModel(provider, modelName);

// 2. 同步调用
const response = await complete(model, context);

// 3. 流式调用
for await (const event of stream(model, context)) {
  // 处理事件
}

// 4. 构建上下文
const context = {
  systemPrompt: 'System prompt',
  messages: [{ role: 'user', content: 'User message' }],
  tools: [/* 工具定义 */],
  temperature: 0.7,
  maxTokens: 1000
};
```

### 支持的 Provider

| Provider | 模型示例 | 特点 |
|----------|---------|------|
| `openai` | `gpt-4o`, `gpt-4o-mini` | 快速、稳定 |
| `anthropic` | `claude-opus-4`, `claude-sonnet-4` | 强大、准确 |
| `google` | `gemini-2.0-flash` | 多模态 |
| `github` | `gpt-4o` | 免费额度 |
| `ollama` | `llama3.2`, `qwen2.5` | 本地部署 |

### 常用配置

```typescript
// 温度（创意程度）
temperature: 0.0  // 确定性输出
temperature: 0.7  // 平衡
temperature: 1.0  // 创意输出

// 最大 Token 数
maxTokens: 1000   // 短回复
maxTokens: 4000   // 中等回复
maxTokens: 8000   // 长回复

// 工具调用
tools: [toolDef]  // 启用工具
tools: undefined  // 禁用工具
```

---

## 进阶学习

掌握最小可用知识后，可以深入学习：

### 深入理解
- **02_第一性原理** - 理解设计原理
- **03_核心概念_01-08** - 8 个核心概念详解

### 实战应用
- **07_实战代码_01-07** - 7 个实战场景
- **08_面试必问** - 高频面试问题

### 扩展能力
- **19 - 自定义 Provider 集成** - 添加新 Provider
- **25 - 构建自定义 Coding Agent** - 构建 Agent

---

## 学习检查清单

完成最小可用知识学习后，你应该能够：

- [ ] 使用 `getModel()` 获取模型
- [ ] 使用 `complete()` 进行同步调用
- [ ] 使用 `stream()` 进行流式调用
- [ ] 构建 `Context` 对象
- [ ] 定义工具 schema（TypeBox）
- [ ] 处理工具调用响应
- [ ] 在不同 Provider 之间切换
- [ ] 处理流式响应事件
- [ ] 配置温度和最大 Token 数
- [ ] 理解 Provider Adapter 模式

---

## 参考资源

### 官方文档
- [pi-ai README](https://github.com/badlogic/pi-mono/blob/main/packages/pi-ai/README.md) - 完整 API 文档

### 示例代码
- [pi-ai examples](https://github.com/badlogic/pi-mono/tree/main/packages/pi-ai/examples) - 官方示例

### 相关知识点
- **03 - Provider 与 Model 切换** - 使用者视角
- **08 - Agent Core 运行时机制** - Agent 如何使用 Pi AI

---

**版本：** v1.0
**最后更新：** 2026-02-19
