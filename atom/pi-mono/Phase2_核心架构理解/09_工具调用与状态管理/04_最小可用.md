# 最小可用知识

掌握以下内容，就能开始构建基本的工具调用和状态管理系统：

## 4.1 TypeBox Schema 定义

**核心：** 使用 TypeBox 定义工具参数的类型约束，生成 JSON Schema 供 LLM 理解。

```typescript
import { Type, Static } from '@sinclair/typebox';

// 定义工具参数 schema
const ReadToolSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    description: '要读取的文件路径'
  }),
  lines: Type.Optional(Type.Object({
    start: Type.Number({ minimum: 1 }),
    end: Type.Number({ minimum: 1 })
  }))
});

// 自动推导 TypeScript 类型
type ReadToolParams = Static<typeof ReadToolSchema>;

// 生成 JSON Schema 供 LLM 使用
const jsonSchema = ReadToolSchema;
```

**为什么重要：** Schema 是 LLM 和工具之间的契约，定义了参数格式和约束。

---

## 4.2 AJV 验证器

**核心：** 使用 AJV 编译 schema 并验证参数，捕获格式错误。

```typescript
import Ajv from 'ajv';

const ajv = new Ajv();
const validate = ajv.compile(ReadToolSchema);

function validateParams(params: unknown): params is ReadToolParams {
  const valid = validate(params);
  if (!valid) {
    console.error('验证失败:', validate.errors);
    return false;
  }
  return true;
}
```

**为什么重要：** 验证器在执行前拦截错误参数，避免运行时崩溃。

---

## 4.3 自纠正模式

**核心：** 验证失败时，将错误信息返回给 LLM，让其自动修正（80%成功率）[3]。

```typescript
async function executeTool(name: string, params: unknown) {
  // 验证参数
  if (!validateParams(params)) {
    // 不抛出异常，而是返回错误信息给 LLM
    return {
      output: `参数验证失败:\n${JSON.stringify(validate.errors, null, 2)}`,
      error: true
    };
  }

  // 执行工具
  return await tools[name].execute(params);
}
```

**为什么重要：** 自纠正机制让 Agent 能从错误中学习，无需人工干预。

---

## 4.4 JSONL 追加写入

**核心：** 使用 JSONL 格式追加写入会话消息，O(1) 性能，支持树形分支。

```typescript
import { appendFile } from 'fs/promises';

interface SessionEntry {
  id: string;
  parentId?: string;  // 树形结构的关键
  timestamp: number;
  type: 'user' | 'assistant' | 'tool_result';
  content: string;
}

async function appendToSession(entry: SessionEntry, path: string) {
  // 追加一行 JSON，不需要读取整个文件
  await appendFile(path, JSON.stringify(entry) + '\n');
}
```

**为什么重要：** JSONL 追加写入避免了读取-修改-写入的性能开销 [5]。

---

## 4.5 会话恢复

**核心：** 从 JSONL 文件重建会话历史，支持分支导航。

```typescript
import { readFile } from 'fs/promises';

async function loadSession(path: string): Promise<SessionEntry[]> {
  const content = await readFile(path, 'utf-8');
  return content
    .split('\n')
    .filter(line => line.trim())
    .map(line => JSON.parse(line));
}

function buildConversationHistory(
  entries: SessionEntry[],
  branchId: string
): SessionEntry[] {
  // 从指定分支回溯到根节点
  const history: SessionEntry[] = [];
  let currentId: string | undefined = branchId;

  while (currentId) {
    const entry = entries.find(e => e.id === currentId);
    if (!entry) break;
    history.unshift(entry);
    currentId = entry.parentId;
  }

  return history;
}
```

**为什么重要：** 会话恢复让 Agent 能在崩溃后继续工作，保持上下文连续性 [10]。

---

## 这些知识足以：

- ✅ 定义基本的工具 schema（read、write、edit）
- ✅ 实现参数验证和错误处理
- ✅ 构建自纠正的工具执行循环
- ✅ 实现基于 JSONL 的会话持久化
- ✅ 支持会话恢复和分支管理
- ✅ 为生产环境的 Agent 系统打基础

---

## 下一步学习

掌握最小可用知识后，可以深入学习：

1. **工具注册与发现** - 动态加载工具，预编译验证器
2. **并行工具执行** - 同时调用多个工具，提升效率
3. **上下文优化** - Token 窗口管理，智能压缩
4. **生产环境部署** - 数据库持久化，可观测性，性能优化

---

**参考文献：**
- [3] Microsoft Agent-Lightning: https://github.com/microsoft/agent-lightning
- [5] Vercel AI Message Persistence: https://github.com/vercel/ai/discussions/4845
- [10] Persistent Agent States: https://x.com/NabbilKhan/status/2022064415856538016
