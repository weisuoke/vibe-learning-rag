# 实战代码 07：工具包装与转换

> **实现 MCP 工具到 pi 工具的完整转换流程**

---

## 概述

工具包装与转换是将 MCP Server 的工具转换为 pi-mono 可用工具的关键技术。本文实现完整的转换系统，包括参数映射、结果格式化和错误处理。

```
工具包装与转换核心：
├─ Schema 转换 → MCP Schema 到 TypeBox
├─ 参数映射 → 类型转换 + 验证
├─ 结果格式化 → content + details
└─ 错误转换 → MCP 错误到 pi 错误
```

**本质**：工具包装与转换是 MCP 与 pi-mono 之间的适配层，通过标准化的转换模式，让 MCP 工具能够无缝集成到 pi-mono 的工具系统中。

---

## 完整转换系统实现

### Schema 转换器

创建 `src/schema-converter.ts`:

```typescript
import { Type, TSchema } from "@sinclair/typebox";
import { StringEnum } from "@mariozechner/pi-ai";

export class SchemaConverter {
  /**
   * 转换 MCP Schema 到 TypeBox Schema
   */
  static convertMCPSchemaToTypeBox(mcpSchema: any): TSchema {
    if (!mcpSchema || typeof mcpSchema !== "object") {
      return Type.Object({});
    }

    if (mcpSchema.type === "object") {
      return this.convertObjectSchema(mcpSchema);
    }

    return this.convertType(mcpSchema);
  }

  /**
   * 转换对象 Schema
   */
  private static convertObjectSchema(schema: any): TSchema {
    const properties: Record<string, TSchema> = {};
    const required = schema.required || [];

    for (const [key, value] of Object.entries(schema.properties || {})) {
      const prop = value as any;
      let typeboxType = this.convertType(prop);

      // 处理可选字段
      if (!required.includes(key)) {
        typeboxType = Type.Optional(typeboxType);
      }

      properties[key] = typeboxType;
    }

    return Type.Object(properties);
  }

  /**
   * 转换单个类型
   */
  private static convertType(prop: any): TSchema {
    const options = {
      description: prop.description,
      default: prop.default,
    };

    switch (prop.type) {
      case "string":
        if (prop.enum) {
          return StringEnum(prop.enum as string[], options);
        }
        return Type.String({
          ...options,
          minLength: prop.minLength,
          maxLength: prop.maxLength,
          pattern: prop.pattern,
        });

      case "number":
        return Type.Number({
          ...options,
          minimum: prop.minimum,
          maximum: prop.maximum,
          exclusiveMinimum: prop.exclusiveMinimum,
          exclusiveMaximum: prop.exclusiveMaximum,
        });

      case "integer":
        return Type.Integer({
          ...options,
          minimum: prop.minimum,
          maximum: prop.maximum,
        });

      case "boolean":
        return Type.Boolean(options);

      case "array":
        return Type.Array(this.convertType(prop.items || {}), {
          ...options,
          minItems: prop.minItems,
          maxItems: prop.maxItems,
        });

      case "object":
        return this.convertObjectSchema(prop);

      case "null":
        return Type.Null();

      default:
        return Type.Any();
    }
  }
}
```

### 工具包装器

创建 `src/tool-wrapper.ts`:

```typescript
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { SchemaConverter } from "./schema-converter.js";

export interface MCPTool {
  name: string;
  title?: string;
  description: string;
  inputSchema: any;
}

export class ToolWrapper {
  /**
   * 包装 MCP 工具为 pi 工具
   */
  static wrapMCPTool(
    pi: ExtensionAPI,
    mcpClient: Client,
    mcpTool: MCPTool,
    prefix: string = "mcp"
  ): void {
    // 转换 Schema
    const schema = SchemaConverter.convertMCPSchemaToTypeBox(
      mcpTool.inputSchema
    );

    // 注册 pi 工具
    pi.registerTool({
      name: `${prefix}_${mcpTool.name}`,
      label: mcpTool.title || mcpTool.name,
      description: mcpTool.description,
      parameters: schema,

      async execute(toolCallId, params, signal, onUpdate, ctx) {
        try {
          // 调用 MCP 工具
          const result = await mcpClient.callTool({
            name: mcpTool.name,
            arguments: params,
          });

          // 转换结果
          return ToolWrapper.convertMCPResultToPiResult(result, mcpTool.name);
        } catch (error) {
          // 转换错误
          return ToolWrapper.convertMCPErrorToPiError(error, mcpTool.name);
        }
      },
    });
  }

  /**
   * 转换 MCP 结果到 pi 结果
   */
  static convertMCPResultToPiResult(mcpResult: any, toolName: string): any {
    return {
      content: mcpResult.content.map((item: any) => {
        if (item.type === "text") {
          return {
            type: "text",
            text: item.text,
          };
        } else if (item.type === "image") {
          return {
            type: "image",
            data: item.data,
            mimeType: item.mimeType || "image/png",
          };
        } else if (item.type === "resource") {
          return {
            type: "text",
            text: `Resource: ${item.resource.uri}`,
          };
        }
        return item;
      }),
      details: {
        mcpTool: toolName,
        mcpResult: mcpResult,
      },
      isError: mcpResult.isError || false,
    };
  }

  /**
   * 转换 MCP 错误到 pi 错误
   */
  static convertMCPErrorToPiError(error: any, toolName: string): any {
    const errorMessage =
      error instanceof Error ? error.message : String(error);

    return {
      content: [
        {
          type: "text",
          text: `MCP tool error (${toolName}): ${errorMessage}`,
        },
      ],
      isError: true,
      details: {
        mcpTool: toolName,
        errorType: error.constructor?.name || "Error",
        originalError: errorMessage,
      },
    };
  }

  /**
   * 批量包装工具
   */
  static wrapAllMCPTools(
    pi: ExtensionAPI,
    mcpClient: Client,
    tools: MCPTool[],
    prefix: string = "mcp"
  ): void {
    for (const tool of tools) {
      this.wrapMCPTool(pi, mcpClient, tool, prefix);
    }
  }
}
```

### 完整扩展实现

创建 `index.ts`:

```typescript
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { ToolWrapper } from "./tool-wrapper.js";

export default function (pi: ExtensionAPI) {
  const clients = new Map<string, Client>();

  // 服务器配置
  const servers = [
    {
      id: "weather",
      command: "node",
      args: ["/path/to/weather-server/build/index.js"],
    },
    {
      id: "github",
      command: "node",
      args: ["/path/to/github-server/build/index.js"],
      env: { GITHUB_TOKEN: process.env.GITHUB_TOKEN || "" },
    },
  ];

  // 会话启动时连接并包装工具
  pi.on("session_start", async (_event, ctx) => {
    for (const serverConfig of servers) {
      try {
        // 创建客户端
        const client = new Client({
          name: `${serverConfig.id}-client`,
          version: "1.0.0",
        });

        // 创建传输
        const transport = new StdioClientTransport({
          command: serverConfig.command,
          args: serverConfig.args,
          env: serverConfig.env,
        });

        // 连接
        await client.connect(transport);
        clients.set(serverConfig.id, client);

        // 获取工具列表
        const toolsResult = await client.listTools();

        // 批量包装工具
        ToolWrapper.wrapAllMCPTools(
          pi,
          client,
          toolsResult.tools,
          serverConfig.id
        );

        ctx.ui.notify(
          `Connected to ${serverConfig.id}: ${toolsResult.tools.length} tools`,
          "success"
        );
      } catch (error) {
        ctx.ui.notify(
          `Failed to connect to ${serverConfig.id}: ${error}`,
          "error"
        );
      }
    }
  });

  // 会话关闭时清理
  pi.on("session_shutdown", async (_event, ctx) => {
    for (const [id, client] of clients.entries()) {
      try {
        await client.close();
        clients.delete(id);
      } catch (error) {
        console.error(`Error closing ${id}:`, error);
      }
    }
  });
}
```

---

## 高级转换特性

### 复杂类型转换

```typescript
// 嵌套对象
const nestedSchema = {
  type: "object",
  properties: {
    user: {
      type: "object",
      properties: {
        name: { type: "string" },
        age: { type: "integer" },
      },
      required: ["name"],
    },
  },
};

// 转换为
Type.Object({
  user: Type.Object({
    name: Type.String(),
    age: Type.Optional(Type.Integer()),
  }),
});

// 数组类型
const arraySchema = {
  type: "array",
  items: {
    type: "object",
    properties: {
      id: { type: "string" },
      value: { type: "number" },
    },
  },
};

// 转换为
Type.Array(
  Type.Object({
    id: Type.String(),
    value: Type.Number(),
  })
);
```

### 枚举类型处理

```typescript
// MCP 枚举
const enumSchema = {
  type: "string",
  enum: ["open", "closed", "pending"],
  default: "open",
};

// 转换为 TypeBox
StringEnum(["open", "closed", "pending"] as const, {
  default: "open",
});
```

### 结果增强

```typescript
/**
 * 增强结果，添加额外信息
 */
static enhanceResult(result: any, toolName: string): any {
  return {
    ...result,
    content: [
      ...result.content,
      {
        type: "text",
        text: `\n---\nTool: ${toolName}\nTimestamp: ${new Date().toISOString()}`,
      },
    ],
    details: {
      ...result.details,
      executedAt: Date.now(),
      toolName,
    },
  };
}
```

### 错误分类

```typescript
/**
 * 分类错误类型
 */
static classifyError(error: any): string {
  const message = error.message || String(error);

  if (message.includes("timeout")) {
    return "TimeoutError";
  } else if (message.includes("connection")) {
    return "ConnectionError";
  } else if (message.includes("not found")) {
    return "NotFoundError";
  } else if (message.includes("permission")) {
    return "PermissionError";
  }

  return "UnknownError";
}
```

---

## 测试与验证

### 单元测试

```typescript
import { SchemaConverter } from "./schema-converter";
import { Type } from "@sinclair/typebox";

describe("SchemaConverter", () => {
  test("converts string schema", () => {
    const mcpSchema = {
      type: "string",
      description: "A string field",
      minLength: 1,
      maxLength: 100,
    };

    const result = SchemaConverter.convertMCPSchemaToTypeBox(mcpSchema);
    expect(result).toBeDefined();
  });

  test("converts object schema with required fields", () => {
    const mcpSchema = {
      type: "object",
      properties: {
        name: { type: "string" },
        age: { type: "integer" },
      },
      required: ["name"],
    };

    const result = SchemaConverter.convertMCPSchemaToTypeBox(mcpSchema);
    expect(result).toBeDefined();
  });

  test("converts enum schema", () => {
    const mcpSchema = {
      type: "string",
      enum: ["a", "b", "c"],
    };

    const result = SchemaConverter.convertMCPSchemaToTypeBox(mcpSchema);
    expect(result).toBeDefined();
  });
});
```

### 集成测试

```typescript
// 测试完整转换流程
async function testToolWrapping() {
  const pi = createMockExtensionAPI();
  const mcpClient = createMockMCPClient();

  const mcpTool = {
    name: "test_tool",
    description: "A test tool",
    inputSchema: {
      type: "object",
      properties: {
        input: { type: "string" },
      },
      required: ["input"],
    },
  };

  ToolWrapper.wrapMCPTool(pi, mcpClient, mcpTool);

  // 验证工具已注册
  expect(pi.tools.has("mcp_test_tool")).toBe(true);
}
```

---

## 最佳实践

### Schema 转换

```typescript
// ✅ 处理所有类型
switch (prop.type) {
  case "string":
  case "number":
  case "integer":
  case "boolean":
  case "array":
  case "object":
  case "null":
    return convertSpecificType(prop);
  default:
    return Type.Any(); // 兜底
}

// ✅ 保留所有元数据
return Type.String({
  description: prop.description,
  minLength: prop.minLength,
  maxLength: prop.maxLength,
  pattern: prop.pattern,
  default: prop.default,
});
```

### 结果转换

```typescript
// ✅ 处理所有内容类型
content: mcpResult.content.map((item: any) => {
  switch (item.type) {
    case "text":
      return { type: "text", text: item.text };
    case "image":
      return { type: "image", data: item.data, mimeType: item.mimeType };
    case "resource":
      return { type: "text", text: `Resource: ${item.resource.uri}` };
    default:
      return item;
  }
});
```

### 错误处理

```typescript
// ✅ 详细的错误信息
catch (error) {
  return {
    content: [{
      type: "text",
      text: `MCP tool error (${toolName}): ${error instanceof Error ? error.message : String(error)}`,
    }],
    isError: true,
    details: {
      mcpTool: toolName,
      errorType: error.constructor?.name || "Error",
      originalError: error,
      timestamp: Date.now(),
    },
  };
}
```

---

## 总结

### 核心要点

1. **Schema 转换**：MCP Schema 到 TypeBox Schema 的完整映射
2. **参数映射**：类型转换 + 可选字段处理
3. **结果格式化**：content + details 标准格式
4. **错误转换**：统一错误处理和格式化
5. **批量包装**：支持批量转换多个工具

### 关键约束

- ✅ 处理所有 MCP Schema 类型
- ✅ 保留所有元数据（description、default 等）
- ✅ 转换所有内容类型（text、image、resource）
- ✅ 提供详细的错误信息
- ✅ 支持嵌套对象和数组

### 下一步

- 阅读 [07_实战代码_08_生产环境部署](./07_实战代码_08_生产环境部署.md) 学习生产部署
- 阅读 [07_实战代码_09_发现与配置Servers](./07_实战代码_09_发现与配置Servers.md) 学习服务器配置

---

**参考资源**：
- [pi-mono Extensions Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md)
- [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [TypeBox Documentation](https://github.com/sinclairzx81/typebox)
