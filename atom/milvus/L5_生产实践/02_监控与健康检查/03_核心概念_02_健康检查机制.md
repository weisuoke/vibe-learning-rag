# 核心概念2：健康检查机制

> 理解健康检查如何实时检测 Milvus 服务状态，实现自动故障发现和恢复

---

## 什么是健康检查机制？

**健康检查机制是通过定期调用 HTTP 端点（Liveness 和 Readiness 探针）检测 Milvus 服务是否存活和就绪，在发现异常时自动触发重启或停止流量，保障服务可用性。**

---

## 1. 健康检查的两种探针

### 1.1 Liveness 探针（存活探针）

**定义：** 检测容器/进程是否还活着（没有死锁、崩溃）

**作用：**
- 判断服务是否需要重启
- 失败 → 容器被杀死并重启

**检查内容：**
- 进程是否响应
- 是否陷入死锁
- 是否发生致命错误

**Milvus 的 Liveness 端点：**

```bash
# Liveness 探针端点
GET http://localhost:9091/healthz

# 响应示例
HTTP/1.1 200 OK
Content-Type: text/plain

OK
```

**响应状态码：**
- `200 OK`：服务存活，正常运行
- `500 Internal Server Error`：服务死亡，需要重启

---

### 1.2 Readiness 探针（就绪探针）

**定义：** 检测服务是否准备好接收流量

**作用：**
- 判断服务是否可以处理请求
- 失败 → 停止发送流量，但不重启容器

**检查内容：**
- 依赖服务是否可用（etcd、MinIO、Pulsar）
- Collection 是否已加载
- 资源是否充足

**Milvus 的 Readiness 端点：**

```bash
# Readiness 探针端点
GET http://localhost:9091/readyz

# 响应示例（就绪）
HTTP/1.1 200 OK
Content-Type: application/json

{
  "status": "ready",
  "components": {
    "etcd": "healthy",
    "minio": "healthy",
    "pulsar": "healthy"
  }
}

# 响应示例（未就绪）
HTTP/1.1 503 Service Unavailable
Content-Type: application/json

{
  "status": "not_ready",
  "reason": "etcd connection failed"
}
```

---

### 1.3 两种探针的区别

| 维度 | Liveness 探针 | Readiness 探针 |
|------|--------------|---------------|
| **检查目标** | 进程是否存活 | 服务是否就绪 |
| **失败后果** | 重启容器 | 停止发送流量 |
| **检查频率** | 较低（30-60秒） | 较高（5-10秒） |
| **超时时间** | 较长（10-30秒） | 较短（3-5秒） |
| **失败阈值** | 较高（3-5次） | 较低（1-3次） |
| **使用场景** | 检测死锁、崩溃 | 检测依赖、负载 |

**类比理解：**

```
Liveness 探针 = 检查人是否还活着
- 失败 → 送医院抢救（重启）

Readiness 探针 = 检查人是否能工作
- 失败 → 请假休息（停止接收任务）
```

---

## 2. 健康检查的实现原理

### 2.1 HTTP 健康检查

**最常见的健康检查方式：**

```python
"""
HTTP 健康检查实现
"""

from flask import Flask, jsonify
import requests

app = Flask(__name__)

# 全局状态
is_alive = True
is_ready = True
dependencies_status = {
    "etcd": "unknown",
    "minio": "unknown",
    "pulsar": "unknown"
}

@app.route('/healthz', methods=['GET'])
def liveness():
    """
    Liveness 探针：检查服务是否存活
    """
    if is_alive:
        return "OK", 200
    else:
        return "Service is dead", 500

@app.route('/readyz', methods=['GET'])
def readiness():
    """
    Readiness 探针：检查服务是否就绪
    """
    if not is_ready:
        return jsonify({
            "status": "not_ready",
            "reason": "Service is initializing"
        }), 503

    # 检查依赖服务
    for service, status in dependencies_status.items():
        if status != "healthy":
            return jsonify({
                "status": "not_ready",
                "reason": f"{service} is not healthy",
                "components": dependencies_status
            }), 503

    # 所有检查通过
    return jsonify({
        "status": "ready",
        "components": dependencies_status
    }), 200

def check_dependencies():
    """
    检查依赖服务的健康状态
    """
    # 检查 etcd
    try:
        response = requests.get("http://etcd:2379/health", timeout=2)
        dependencies_status["etcd"] = "healthy" if response.status_code == 200 else "unhealthy"
    except:
        dependencies_status["etcd"] = "unhealthy"

    # 检查 MinIO
    try:
        response = requests.get("http://minio:9000/minio/health/live", timeout=2)
        dependencies_status["minio"] = "healthy" if response.status_code == 200 else "unhealthy"
    except:
        dependencies_status["minio"] = "unhealthy"

    # 检查 Pulsar
    try:
        response = requests.get("http://pulsar:8080/admin/v2/brokers/health", timeout=2)
        dependencies_status["pulsar"] = "healthy" if response.status_code == 200 else "unhealthy"
    except:
        dependencies_status["pulsar"] = "unhealthy"

if __name__ == '__main__':
    # 启动前检查依赖
    check_dependencies()
    is_ready = all(status == "healthy" for status in dependencies_status.values())

    # 启动健康检查服务
    app.run(host='0.0.0.0', port=9091)
```

---

### 2.2 TCP 健康检查

**检查端口是否可连接：**

```python
"""
TCP 健康检查实现
"""

import socket

def tcp_health_check(host: str, port: int, timeout: int = 3) -> bool:
    """
    TCP 健康检查：尝试连接指定端口

    Args:
        host: 主机地址
        port: 端口号
        timeout: 超时时间（秒）

    Returns:
        True: 端口可连接
        False: 端口不可连接
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((host, port))
        sock.close()

        return result == 0  # 0 表示连接成功
    except Exception as e:
        print(f"TCP health check failed: {e}")
        return False

# 使用示例
if __name__ == "__main__":
    # 检查 Milvus 端口
    is_healthy = tcp_health_check("localhost", 19530)
    print(f"Milvus is {'healthy' if is_healthy else 'unhealthy'}")
```

---

### 2.3 命令执行健康检查

**在容器内执行命令检查：**

```bash
# Docker 健康检查配置
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:9091/healthz"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 60s
```

**Kubernetes 健康检查配置：**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: milvus
spec:
  containers:
  - name: milvus
    image: milvusdb/milvus:latest
    ports:
    - containerPort: 19530

    # Liveness 探针
    livenessProbe:
      httpGet:
        path: /healthz
        port: 9091
      initialDelaySeconds: 60  # 启动后等待 60 秒再开始检查
      periodSeconds: 30        # 每 30 秒检查一次
      timeoutSeconds: 10       # 超时时间 10 秒
      failureThreshold: 3      # 连续失败 3 次才判定为不健康

    # Readiness 探针
    readinessProbe:
      httpGet:
        path: /readyz
        port: 9091
      initialDelaySeconds: 30  # 启动后等待 30 秒再开始检查
      periodSeconds: 10        # 每 10 秒检查一次
      timeoutSeconds: 5        # 超时时间 5 秒
      failureThreshold: 2      # 连续失败 2 次才判定为未就绪
```

---

## 3. 健康检查的最佳实践

### 3.1 检查频率配置

**推荐配置：**

| 探针类型 | 初始延迟 | 检查间隔 | 超时时间 | 失败阈值 |
|---------|---------|---------|---------|---------|
| Liveness | 60-120秒 | 30-60秒 | 10-30秒 | 3-5次 |
| Readiness | 30-60秒 | 5-10秒 | 3-5秒 | 1-3次 |

**配置原则：**
- **初始延迟**：给服务足够的启动时间
- **检查间隔**：Readiness 更频繁（快速发现问题）
- **超时时间**：避免误判（网络抖动）
- **失败阈值**：避免因偶发故障而重启

---

### 3.2 检查内容设计

**Liveness 探针应该检查：**
- ✅ 进程是否响应（最基本）
- ✅ 是否陷入死锁
- ❌ 不要检查依赖服务（依赖故障不应导致重启）
- ❌ 不要检查业务逻辑（业务错误不应导致重启）

**Readiness 探针应该检查：**
- ✅ 依赖服务是否可用（etcd、MinIO、Pulsar）
- ✅ 必要的资源是否加载（Collection）
- ✅ 系统资源是否充足（内存、磁盘）
- ✅ 是否能处理请求

---

### 3.3 避免常见错误

#### 错误1：Liveness 检查过于复杂

```python
# ❌ 错误示例：Liveness 检查依赖服务
@app.route('/healthz')
def liveness():
    # 不应该检查依赖服务
    if not check_etcd():
        return "etcd is down", 500  # 会导致不必要的重启

    if not check_minio():
        return "minio is down", 500

    return "OK", 200

# ✅ 正确示例：Liveness 只检查进程本身
@app.route('/healthz')
def liveness():
    # 只检查进程是否响应
    return "OK", 200
```

**原因：** 依赖服务故障时，重启 Milvus 无法解决问题，反而会导致服务不断重启。

---

#### 错误2：检查频率过高

```yaml
# ❌ 错误示例：检查频率过高
livenessProbe:
  httpGet:
    path: /healthz
    port: 9091
  periodSeconds: 1  # 每秒检查一次，太频繁
  timeoutSeconds: 1
  failureThreshold: 1  # 失败 1 次就重启，太敏感

# ✅ 正确示例：合理的检查频率
livenessProbe:
  httpGet:
    path: /healthz
    port: 9091
  periodSeconds: 30  # 每 30 秒检查一次
  timeoutSeconds: 10
  failureThreshold: 3  # 连续失败 3 次才重启
```

**原因：** 检查频率过高会增加系统负担，失败阈值过低会导致误判。

---

#### 错误3：初始延迟不足

```yaml
# ❌ 错误示例：初始延迟不足
livenessProbe:
  httpGet:
    path: /healthz
    port: 9091
  initialDelaySeconds: 10  # Milvus 启动需要更长时间
  periodSeconds: 30

# ✅ 正确示例：足够的初始延迟
livenessProbe:
  httpGet:
    path: /healthz
    port: 9091
  initialDelaySeconds: 90  # 给 Milvus 足够的启动时间
  periodSeconds: 30
```

**原因：** Milvus 启动需要加载索引、连接依赖服务，需要足够的时间。

---

## 4. 健康检查的高级用法

### 4.1 自定义健康检查逻辑

```python
"""
自定义健康检查逻辑
"""

from pymilvus import connections, utility
from flask import Flask, jsonify
import time

app = Flask(__name__)

class MilvusHealthChecker:
    def __init__(self):
        self.last_check_time = 0
        self.check_interval = 10  # 缓存 10 秒
        self.cached_status = {
            "liveness": True,
            "readiness": False,
            "details": {}
        }

    def check_liveness(self) -> bool:
        """
        Liveness 检查：只检查进程是否响应
        """
        try:
            # 简单的响应检查
            return True
        except Exception as e:
            print(f"Liveness check failed: {e}")
            return False

    def check_readiness(self) -> dict:
        """
        Readiness 检查：检查服务是否就绪
        """
        # 使用缓存避免频繁检查
        current_time = time.time()
        if current_time - self.last_check_time < self.check_interval:
            return self.cached_status

        details = {}

        # 1. 检查 Milvus 连接
        try:
            connections.connect(
                alias="health_check",
                host="localhost",
                port="19530",
                timeout=3
            )
            details["milvus_connection"] = "healthy"
        except Exception as e:
            details["milvus_connection"] = f"unhealthy: {str(e)}"
            self.cached_status = {
                "liveness": True,
                "readiness": False,
                "details": details
            }
            self.last_check_time = current_time
            return self.cached_status

        # 2. 检查 Collection 是否加载
        try:
            collections = utility.list_collections()
            loaded_collections = [
                col for col in collections
                if utility.load_state(col).name == "Loaded"
            ]
            details["collections"] = {
                "total": len(collections),
                "loaded": len(loaded_collections)
            }
        except Exception as e:
            details["collections"] = f"error: {str(e)}"

        # 3. 检查内存使用
        try:
            import psutil
            memory = psutil.virtual_memory()
            details["memory"] = {
                "used_percent": memory.percent,
                "available_gb": memory.available / (1024**3)
            }

            # 内存使用超过 90% 视为未就绪
            if memory.percent > 90:
                self.cached_status = {
                    "liveness": True,
                    "readiness": False,
                    "details": details,
                    "reason": "Memory usage too high"
                }
                self.last_check_time = current_time
                return self.cached_status
        except Exception as e:
            details["memory"] = f"error: {str(e)}"

        # 4. 检查磁盘空间
        try:
            import psutil
            disk = psutil.disk_usage('/')
            details["disk"] = {
                "used_percent": disk.percent,
                "free_gb": disk.free / (1024**3)
            }

            # 磁盘使用超过 95% 视为未就绪
            if disk.percent > 95:
                self.cached_status = {
                    "liveness": True,
                    "readiness": False,
                    "details": details,
                    "reason": "Disk space too low"
                }
                self.last_check_time = current_time
                return self.cached_status
        except Exception as e:
            details["disk"] = f"error: {str(e)}"

        # 所有检查通过
        self.cached_status = {
            "liveness": True,
            "readiness": True,
            "details": details
        }
        self.last_check_time = current_time

        # 断开连接
        try:
            connections.disconnect("health_check")
        except:
            pass

        return self.cached_status

# 创建健康检查器
health_checker = MilvusHealthChecker()

@app.route('/healthz', methods=['GET'])
def liveness():
    """Liveness 探针"""
    if health_checker.check_liveness():
        return "OK", 200
    else:
        return "Service is dead", 500

@app.route('/readyz', methods=['GET'])
def readiness():
    """Readiness 探针"""
    status = health_checker.check_readiness()

    if status["readiness"]:
        return jsonify({
            "status": "ready",
            "details": status["details"]
        }), 200
    else:
        return jsonify({
            "status": "not_ready",
            "reason": status.get("reason", "Unknown"),
            "details": status["details"]
        }), 503

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=9091)
```

---

### 4.2 健康检查监控

```python
"""
监控健康检查的成功率和延迟
"""

import time
import requests
from prometheus_client import Counter, Histogram, start_http_server

# Prometheus 指标
health_check_total = Counter(
    'health_check_total',
    'Total number of health checks',
    ['probe_type', 'status']
)

health_check_duration = Histogram(
    'health_check_duration_seconds',
    'Health check duration in seconds',
    ['probe_type']
)

def monitor_health_check(url: str, probe_type: str):
    """
    监控健康检查

    Args:
        url: 健康检查 URL
        probe_type: 探针类型（liveness 或 readiness）
    """
    start_time = time.time()

    try:
        response = requests.get(url, timeout=5)
        duration = time.time() - start_time

        # 记录指标
        status = "success" if response.status_code == 200 else "failure"
        health_check_total.labels(probe_type=probe_type, status=status).inc()
        health_check_duration.labels(probe_type=probe_type).observe(duration)

        print(f"[{probe_type}] Status: {response.status_code}, Duration: {duration:.3f}s")

    except Exception as e:
        duration = time.time() - start_time

        # 记录失败
        health_check_total.labels(probe_type=probe_type, status="error").inc()
        health_check_duration.labels(probe_type=probe_type).observe(duration)

        print(f"[{probe_type}] Error: {e}, Duration: {duration:.3f}s")

if __name__ == "__main__":
    # 启动 Prometheus 指标服务
    start_http_server(8000)

    # 定期检查
    while True:
        monitor_health_check("http://localhost:9091/healthz", "liveness")
        monitor_health_check("http://localhost:9091/readyz", "readiness")
        time.sleep(10)
```

---

## 5. 在 RAG 系统中的应用

### 5.1 RAG 服务的健康检查

```python
"""
RAG 服务的健康检查实现
"""

from flask import Flask, jsonify
from pymilvus import connections, Collection
import openai

app = Flask(__name__)

class RAGHealthChecker:
    def __init__(self):
        self.milvus_host = "localhost"
        self.milvus_port = "19530"
        self.collection_name = "knowledge_base"

    def check_milvus(self) -> dict:
        """检查 Milvus 连接和 Collection 状态"""
        try:
            connections.connect(
                alias="health_check",
                host=self.milvus_host,
                port=self.milvus_port,
                timeout=3
            )

            # 检查 Collection 是否存在
            collection = Collection(self.collection_name)

            # 检查 Collection 是否加载
            if not collection.is_loaded:
                return {
                    "status": "unhealthy",
                    "reason": f"Collection {self.collection_name} is not loaded"
                }

            # 检查向量数量
            num_entities = collection.num_entities
            if num_entities == 0:
                return {
                    "status": "warning",
                    "reason": "Collection is empty"
                }

            connections.disconnect("health_check")

            return {
                "status": "healthy",
                "num_entities": num_entities
            }

        except Exception as e:
            return {
                "status": "unhealthy",
                "reason": str(e)
            }

    def check_openai(self) -> dict:
        """检查 OpenAI API 连接"""
        try:
            # 简单的 API 调用测试
            response = openai.Embedding.create(
                model="text-embedding-3-small",
                input="health check"
            )

            return {
                "status": "healthy",
                "model": "text-embedding-3-small"
            }

        except Exception as e:
            return {
                "status": "unhealthy",
                "reason": str(e)
            }

    def check_readiness(self) -> dict:
        """综合健康检查"""
        components = {}

        # 检查 Milvus
        milvus_status = self.check_milvus()
        components["milvus"] = milvus_status

        # 检查 OpenAI
        openai_status = self.check_openai()
        components["openai"] = openai_status

        # 判断整体状态
        all_healthy = all(
            comp["status"] == "healthy"
            for comp in components.values()
        )

        return {
            "ready": all_healthy,
            "components": components
        }

# 创建健康检查器
rag_health_checker = RAGHealthChecker()

@app.route('/healthz', methods=['GET'])
def liveness():
    """Liveness 探针"""
    return "OK", 200

@app.route('/readyz', methods=['GET'])
def readiness():
    """Readiness 探针"""
    status = rag_health_checker.check_readiness()

    if status["ready"]:
        return jsonify({
            "status": "ready",
            "components": status["components"]
        }), 200
    else:
        return jsonify({
            "status": "not_ready",
            "components": status["components"]
        }), 503

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

---

## 6. 故障场景与处理

### 6.1 常见故障场景

#### 场景1：依赖服务故障

**现象：** Readiness 探针失败，服务停止接收流量

**处理：**
1. 检查依赖服务状态（etcd、MinIO、Pulsar）
2. 修复依赖服务
3. Readiness 探针自动恢复，服务重新接收流量

**不会触发重启**（因为是 Readiness 失败，不是 Liveness 失败）

---

#### 场景2：服务死锁

**现象：** Liveness 探针失败，容器被重启

**处理：**
1. Kubernetes 自动重启容器
2. 新容器启动后，Liveness 探针恢复
3. Readiness 探针检查通过后，开始接收流量

---

#### 场景3：资源不足

**现象：** Readiness 探针失败（内存或磁盘不足）

**处理：**
1. 停止接收新流量
2. 运维人员收到告警
3. 扩容资源或清理数据
4. Readiness 探针恢复

---

## 小结

**健康检查机制的核心要点：**

1. **两种探针**：Liveness（存活）和 Readiness（就绪）
2. **不同作用**：Liveness 失败 → 重启；Readiness 失败 → 停止流量
3. **检查内容**：Liveness 检查进程；Readiness 检查依赖和资源
4. **配置原则**：合理的频率、超时、阈值
5. **避免误区**：Liveness 不检查依赖；检查频率不要过高

**在 RAG 系统中：**
- 检查 Milvus 连接和 Collection 状态
- 检查 OpenAI API 可用性
- 检查系统资源（内存、磁盘）
- 实现自动故障恢复

---

**下一步：** [03_核心概念_03_Grafana可视化](./03_核心概念_03_Grafana可视化.md)
