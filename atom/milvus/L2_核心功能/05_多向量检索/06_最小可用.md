# 最小可用

> 掌握以下内容，就能开始使用多向量检索

---

## 核心知识（20%解决80%问题）

### 6.1 定义多个向量字段

**一句话：** 在 Schema 中定义多个 `DataType.FLOAT_VECTOR` 字段

```python
from pymilvus import CollectionSchema, FieldSchema, DataType

# 定义包含多个向量字段的 Schema
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=1000),

    # 向量字段1：文本向量（OpenAI Embedding）
    FieldSchema(name="text_vector", dtype=DataType.FLOAT_VECTOR, dim=1536),

    # 向量字段2：标题向量（BGE Embedding）
    FieldSchema(name="title_vector", dtype=DataType.FLOAT_VECTOR, dim=768),
]

schema = CollectionSchema(fields=fields, description="多向量检索示例")
```

**关键点：**
- 每个向量字段可以有不同的维度
- 每个向量字段可以使用不同的 Embedding 模型
- 向量字段数量没有硬性限制（但建议不超过5个）

---

### 6.2 为每个向量字段创建索引

**一句话：** 每个向量字段都需要单独创建索引

```python
from pymilvus import Collection

collection = Collection("multi_vector_demo")

# 为 text_vector 创建 HNSW 索引
collection.create_index(
    field_name="text_vector",
    index_params={
        "index_type": "HNSW",
        "metric_type": "COSINE",
        "params": {"M": 16, "efConstruction": 200}
    }
)

# 为 title_vector 创建 IVF_FLAT 索引
collection.create_index(
    field_name="title_vector",
    index_params={
        "index_type": "IVF_FLAT",
        "metric_type": "L2",
        "params": {"nlist": 128}
    }
)
```

**关键点：**
- 不同向量字段可以使用不同的索引类型
- 不同向量字段可以使用不同的度量方式
- 必须为每个向量字段创建索引才能检索

---

### 6.3 同时检索多个向量字段

**一句话：** 使用 `hybrid_search()` 或多次 `search()` + 手动融合

```python
# 方法1：使用 hybrid_search（Milvus 2.4+）
from pymilvus import AnnSearchRequest, RRFRanker

# 定义多个检索请求
req1 = AnnSearchRequest(
    data=[text_embedding],  # 查询向量1
    anns_field="text_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=10
)

req2 = AnnSearchRequest(
    data=[title_embedding],  # 查询向量2
    anns_field="title_vector",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10
)

# 使用 RRF 融合
results = collection.hybrid_search(
    reqs=[req1, req2],
    rerank=RRFRanker(),
    limit=5,
    output_fields=["text"]
)
```

**关键点：**
- `hybrid_search()` 是 Milvus 2.4+ 的新特性
- 支持 RRF（Reciprocal Rank Fusion）自动融合
- 可以指定每个检索请求的参数

---

### 6.4 手动实现 RRF 融合（兼容旧版本）

**一句话：** 分别检索后手动计算 RRF 分数

```python
# 分别检索两个向量字段
results1 = collection.search(
    data=[text_embedding],
    anns_field="text_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=10,
    output_fields=["id", "text"]
)

results2 = collection.search(
    data=[title_embedding],
    anns_field="title_vector",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    output_fields=["id", "text"]
)

# 手动实现 RRF 融合
def rrf_fusion(results_list, k=60):
    """RRF 融合算法"""
    scores = {}
    for results in results_list:
        for rank, hit in enumerate(results[0]):
            doc_id = hit.id
            # RRF 公式：1 / (k + rank)
            scores[doc_id] = scores.get(doc_id, 0) + 1 / (k + rank + 1)

    # 按分数排序
    sorted_docs = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    return sorted_docs[:5]  # 返回 Top 5

# 融合结果
final_results = rrf_fusion([results1, results2])
print(f"融合后的 Top 5: {final_results}")
```

**关键点：**
- RRF 不依赖原始相似度分数，只看排名
- `k` 是平滑参数，通常设为 60
- 适合融合不同度量方式的结果

---

### 6.5 实际应用：RAG 多模态检索

**一句话：** 在文档问答中同时检索文本和图片

```python
# 场景：用户问题 "如何安装 Python？"
user_query = "如何安装 Python？"

# 1. 生成查询向量
text_embedding = get_text_embedding(user_query)  # OpenAI Embedding
image_embedding = get_image_embedding(user_query)  # CLIP Embedding

# 2. 混合检索
req1 = AnnSearchRequest(
    data=[text_embedding],
    anns_field="text_vector",
    param={"metric_type": "COSINE"},
    limit=10
)

req2 = AnnSearchRequest(
    data=[image_embedding],
    anns_field="image_vector",
    param={"metric_type": "COSINE"},
    limit=10
)

results = collection.hybrid_search(
    reqs=[req1, req2],
    rerank=RRFRanker(),
    limit=3,
    output_fields=["text", "image_url"]
)

# 3. 构建 RAG 上下文
context = "\n".join([hit.entity.get("text") for hit in results[0]])

# 4. 调用 LLM 生成答案
answer = llm.generate(f"根据以下内容回答：{user_query}\n\n{context}")
```

**关键点：**
- 文本和图片使用不同的 Embedding 模型
- RRF 融合提升检索准确率
- 最终结果包含文本和图片信息

---

## 这些知识足以

掌握以上5个核心知识点，你就能：

✅ **创建多向量 Collection** - 定义多个向量字段
✅ **实现混合检索** - 同时检索多个向量字段
✅ **融合检索结果** - 使用 RRF 算法
✅ **应用到 RAG** - 实现多模态文档检索
✅ **优化检索准确率** - 通过多向量提升效果

---

## 快速上手步骤

```python
# 1. 创建 Collection（2个向量字段）
from pymilvus import Collection, CollectionSchema, FieldSchema, DataType

fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=1000),
    FieldSchema(name="text_vector", dtype=DataType.FLOAT_VECTOR, dim=1536),
    FieldSchema(name="title_vector", dtype=DataType.FLOAT_VECTOR, dim=768),
]
schema = CollectionSchema(fields=fields)
collection = Collection("quick_start", schema=schema)

# 2. 创建索引
collection.create_index("text_vector", {"index_type": "HNSW", "metric_type": "COSINE"})
collection.create_index("title_vector", {"index_type": "HNSW", "metric_type": "COSINE"})

# 3. 插入数据
data = [
    {"text": "Python 安装教程", "text_vector": [...], "title_vector": [...]},
    {"text": "Java 入门指南", "text_vector": [...], "title_vector": [...]},
]
collection.insert(data)
collection.load()

# 4. 混合检索
from pymilvus import AnnSearchRequest, RRFRanker

req1 = AnnSearchRequest(data=[[...]], anns_field="text_vector", param={"metric_type": "COSINE"}, limit=5)
req2 = AnnSearchRequest(data=[[...]], anns_field="title_vector", param={"metric_type": "COSINE"}, limit=5)

results = collection.hybrid_search(reqs=[req1, req2], rerank=RRFRanker(), limit=3)
```

---

## 下一步学习

- **核心概念** - 深入理解多字段向量、混合检索、加权融合
- **实战代码** - 4个完整场景示例
- **反直觉点** - 避免常见误区

---

**继续学习：** [02_第一性原理.md](./02_第一性原理.md)
