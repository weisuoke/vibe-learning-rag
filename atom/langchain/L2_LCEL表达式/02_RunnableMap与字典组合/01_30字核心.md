# 30字核心

> **一句话掌握 RunnableParallel 的本质**

---

## 核心定义

**RunnableParallel 是 LCEL 的并行组合原语，通过字典语法实现多个 Runnable 的并发执行和结果映射。**

---

## 为什么是这30字？

### 1. **RunnableParallel** - 官方名称
- 这是 LangChain 官方的类名
- `RunnableMap` 是它的别名（已废弃）
- 2025-2026 文档统一使用 `RunnableParallel`

### 2. **LCEL 的并行组合原语** - 定位
- LCEL 有两大核心组合原语：
  - `RunnableSequence` - 串行执行（`|` 操作符）
  - `RunnableParallel` - 并行执行（字典语法）
- 它是构建复杂 AI 链的基础工具

### 3. **字典语法** - 使用方式
- 最简洁的写法：`{"key": runnable}`
- 自动转换为 `RunnableParallel` 实例
- 符合 Python 开发者的直觉

### 4. **并发执行** - 执行模式
- 多个 Runnable 同时运行
- 不是串行等待，而是并行处理
- 底层使用 `asyncio.gather()` 实现

### 5. **结果映射** - 输出格式
- 输入：相同的输入分发到所有分支
- 输出：字典格式 `{"key": result}`
- 键名由你定义，结果自动映射

---

## 一个最小示例

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# 定义两个独立的任务
model = ChatOpenAI(model="gpt-4")

# 字典语法 = RunnableParallel
chain = {
    "summary": ChatPromptTemplate.from_template("总结: {text}") | model,
    "keywords": ChatPromptTemplate.from_template("关键词: {text}") | model,
}

# 并行执行，返回字典
result = chain.invoke({"text": "LangChain 是一个 AI 应用开发框架"})
# result = {
#     "summary": "LangChain 框架简介...",
#     "keywords": "AI, 框架, 开发..."
# }
```

**关键点**：
- 两个任务同时执行（不是先总结再提取关键词）
- 相同输入 `{"text": "..."}` 分发到两个分支
- 返回字典，键名是你定义的 `"summary"` 和 `"keywords"`

---

## 与其他概念的对比

| 概念 | 执行模式 | 输入 | 输出 | 使用场景 |
|------|----------|------|------|----------|
| **RunnableParallel** | 并行 | 相同输入 | 字典 | 独立任务 |
| **RunnableSequence** | 串行 | 链式传递 | 单值 | 依赖任务 |
| **RunnableBranch** | 条件 | 相同输入 | 单值 | 分支逻辑 |

---

## 为什么需要并行执行？

### 场景1: RAG 检索
```python
# 同时检索多个数据源
retrieval = {
    "docs": vector_store.as_retriever(),
    "web": web_search_tool,
    "database": sql_query_tool,
}
# 3个检索同时进行，节省时间
```

### 场景2: 多模型对比
```python
# 同时调用多个模型
comparison = {
    "gpt4": ChatOpenAI(model="gpt-4"),
    "claude": ChatAnthropic(model="claude-3"),
    "gemini": ChatGoogleGenerativeAI(model="gemini-pro"),
}
# 3个模型并行调用，快速对比
```

### 场景3: 多任务处理
```python
# 同时执行多个分析任务
analysis = {
    "sentiment": sentiment_chain,
    "entities": entity_extraction_chain,
    "summary": summarization_chain,
}
# 3个任务并行，提高效率
```

---

## 性能提升

**串行执行**：
```
任务1 (2s) → 任务2 (2s) → 任务3 (2s) = 6秒
```

**并行执行**：
```
任务1 (2s) ┐
任务2 (2s) ├→ 最慢的任务决定总时间 = 2秒
任务3 (2s) ┘
```

**提升幅度**：
- 2个任务：理论提升 50%
- 3个任务：理论提升 67%
- N个任务：理论提升 (N-1)/N

**实际提升**（2025-2026 数据）：
- I/O 密集型（API 调用）：40-50% 提升
- CPU 密集型（本地计算）：20-30% 提升
- 混合型：30-40% 提升

---

## 两种等价写法

### 写法1: 字典字面量（推荐）
```python
chain = {
    "task1": runnable1,
    "task2": runnable2,
} | next_step
```

### 写法2: 显式构造
```python
from langchain_core.runnables import RunnableParallel

chain = RunnableParallel(
    task1=runnable1,
    task2=runnable2,
) | next_step
```

**推荐使用字典语法**：
- 更简洁
- 更符合 Python 习惯
- 与 LCEL 管道操作符 `|` 完美配合

---

## 核心要点总结

1. **并行组合原语** - LCEL 的两大核心之一
2. **字典语法** - 最简洁的使用方式
3. **并发执行** - 多个任务同时运行
4. **相同输入** - 输入自动分发到所有分支
5. **字典输出** - 结果按键名映射
6. **性能提升** - I/O 密集型任务提升 40-50%

---

## 下一步学习

- **第一性原理** → 理解并行执行的底层逻辑
- **核心概念** → 深入字典式并行执行、键值映射、结果合并
- **实战代码** → RAG 检索、多任务处理、上下文保持
- **最小可用** → 20%核心知识快速上手

---

## 参考资源

**官方文档**：
- [RunnableParallel API Reference](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.base.RunnableParallel.html)
- [LCEL Primitives](https://reference.langchain.com/python/langchain_core/runnables)

**2025-2026 最佳实践**：
- [Building Production-Ready AI Pipelines with LangChain Runnables](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557)
- [LangChain Best Practices](https://www.swarnendu.de/blog/langchain-best-practices)

---

**版本**: v1.0
**最后更新**: 2026-02-19
**适用**: LangChain 0.3+, Python 3.13+
