# 化骨绵掌

> 10个2分钟知识卡片，碎片化掌握文档加载与解析

---

## 卡片1：什么是文档加载？

**一句话：** 文档加载就是把文件从磁盘读到内存里。

**举例：**
```python
# 最简单的文档加载
with open("notes.txt", "r") as f:
    content = f.read()

# 这就是加载！把文件内容变成了 Python 字符串
```

**日常类比：** 从书架上把书取下来，拿在手里准备阅读。

**应用：** RAG 系统的第一步，没有加载就没有后续的一切。

---

## 卡片2：什么是文档解析？

**一句话：** 文档解析是从文件格式中提取出纯文本内容。

**举例：**
```
PDF 文件内部：
%PDF-1.4
1 0 obj << /Type /Catalog >> endobj
...（二进制数据）

解析后：
"第一章 退款政策\n客户可在7天内申请退款..."
```

**日常类比：** 把外语书翻译成你能看懂的语言。

**关键区别：**
- 加载 = 读取文件（物理操作）
- 解析 = 提取内容（逻辑操作）

---

## 卡片3：Document 对象

**一句话：** Document 是 RAG 系统中表示文档的统一数据结构。

**结构：**
```python
Document(
    page_content="文本内容...",  # 主要内容
    metadata={                   # 元数据
        "source": "policy.pdf",
        "page": 1
    }
)
```

**为什么重要：**
- 不同格式 → 统一输出
- 后续处理只需关心一种格式
- 元数据用于答案溯源

**前端类比：** 标准化的 API 响应格式 `{ data, meta }`

---

## 卡片4：Loader 是什么？

**一句话：** Loader 是负责加载特定格式文档的组件。

**设计模式：**
```
BaseLoader（基类）
    ├── PDFLoader
    ├── DocxLoader
    ├── HTMLLoader
    ├── MarkdownLoader
    └── TextLoader
```

**统一接口：**
```python
# 所有 Loader 用法一致
loader = AnyLoader("file.xxx")
documents = loader.load()  # 返回 List[Document]
```

**好处：** 学会一个，会用全部。

---

## 卡片5：PDF 为什么难解析？

**一句话：** PDF 是为打印设计的，不是为文本提取设计的。

**PDF 内部结构：**
```
"Hello" 在 PDF 中可能是：
(H) Tj 100 700 Td
(e) Tj 110 700 Td
(l) Tj 120 700 Td
(l) Tj 130 700 Td
(o) Tj 140 700 Td

每个字符都是独立的绘制指令！
```

**常见问题：**
- 文本顺序错乱
- 表格变成散乱文字
- 扫描版需要 OCR

**应对：** 选择合适的解析库，接受不完美。

---

## 卡片6：5种核心格式对比

**一句话：** 不同格式难度不同，需要不同的解析策略。

| 格式 | 难度 | 推荐库 | 注意事项 |
|-----|------|-------|---------|
| TXT | ⭐ | 内置 open() | 注意编码 |
| Markdown | ⭐ | 直接读取 | 是否保留格式 |
| HTML | ⭐⭐ | BeautifulSoup | 去除噪音标签 |
| Word | ⭐⭐ | python-docx | 处理样式 |
| PDF | ⭐⭐⭐ | pypdf/pdfplumber | 最复杂 |

**记住：** 从简单的开始，效果不好再换复杂的。

---

## 卡片7：元数据的作用

**一句话：** 元数据是"关于文档的信息"，用于追踪和过滤。

**常用元数据：**
```python
metadata = {
    "source": "policy.pdf",    # 来源文件
    "page": 1,                 # 页码
    "file_type": "pdf",        # 文件类型
    "created_at": "2024-01-15" # 创建时间
}
```

**三大用途：**
1. **答案溯源**：告诉用户答案来自哪里
2. **过滤检索**：只搜索特定来源
3. **权限控制**：根据来源控制访问

**前端类比：** HTTP Headers

---

## 卡片8：预处理的重要性

**一句话：** 原始文档有很多噪音，需要清理后才能用。

**常见噪音：**
```
- 多余空白：  "这是   一段   文字"
- 页眉页脚：  "第 1 页 / 共 10 页"
- 特殊字符：  "\x00", "\ufeff"
- 无意义内容：空页、版权声明
```

**预处理代码：**
```python
import re
text = re.sub(r'\s+', ' ', text)  # 清理空白
text = re.sub(r'第\s*\d+\s*页.*?共\s*\d+\s*页', '', text)  # 移除页码
```

**记住：** 垃圾进，垃圾出。预处理决定检索质量。

---

## 卡片9：批量加载模式

**一句话：** 实际项目中需要批量加载整个目录的文档。

**代码模式：**
```python
from pathlib import Path

def load_directory(dir_path):
    loader_map = {
        '.pdf': PDFLoader,
        '.txt': TextLoader,
        '.docx': DocxLoader,
    }

    all_docs = []
    for file in Path(dir_path).rglob('*'):
        ext = file.suffix.lower()
        if ext in loader_map:
            docs = loader_map[ext](str(file)).load()
            all_docs.extend(docs)

    return all_docs
```

**关键点：**
- 根据扩展名选择 Loader
- 递归遍历子目录
- 异常处理不能少

---

## 卡片10：与后续环节的衔接

**一句话：** 文档加载是 RAG 流程的第一步，输出给分块器。

**完整流程：**
```
文档加载 → 文本分块 → 向量化 → 存储 → 检索 → 生成
   ↑
 你在这里
```

**输出格式：**
```python
# 文档加载的输出
documents = [
    Document(page_content="...", metadata={...}),
    Document(page_content="...", metadata={...}),
    ...
]

# 传给分块器
from langchain.text_splitter import RecursiveCharacterTextSplitter
splitter = RecursiveCharacterTextSplitter(chunk_size=500)
chunks = splitter.split_documents(documents)

# chunks 再传给向量化...
```

**记住：** 文档加载质量直接影响后续所有环节！

---

## 知识卡片总结

| 卡片 | 核心知识点 |
|-----|----------|
| 1 | 加载 = 读取文件到内存 |
| 2 | 解析 = 提取纯文本 |
| 3 | Document = page_content + metadata |
| 4 | Loader = 统一接口的格式解析器 |
| 5 | PDF 最难，因为是为打印设计 |
| 6 | 5种格式难度不同 |
| 7 | 元数据用于溯源和过滤 |
| 8 | 预处理清理噪音 |
| 9 | 批量加载用 Path.rglob() |
| 10 | 输出给分块器继续处理 |

---

**下一步：** [10_一句话总结](./10_一句话总结.md) - 用一句话总结文档加载与解析
