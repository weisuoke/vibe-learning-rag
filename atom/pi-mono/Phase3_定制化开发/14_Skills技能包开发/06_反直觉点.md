# 反直觉点

## 反直觉点 1：技能不是代码，是提示词

### 直觉认知

**大多数人认为：**
```
Skills = 可执行的代码模块
就像 npm 包一样，包含 JavaScript/TypeScript 代码
```

### 实际情况

**Skills 实际上是：**
```
Skills = 结构化的提示词模板
包含的是 Markdown 文本，不是可执行代码
```

### 为什么反直觉？

**原因 1：命名误导**
- "Skills" 这个词让人联想到"技能"、"能力"
- 在编程中，"能力"通常由代码实现
- 但 Skills 是通过提示词引导 LLM 实现能力

**原因 2：调用方式类似**
```typescript
// npm 包调用
import { myFunction } from 'my-package';
myFunction();

// Skills 调用
/skill:my-skill
```
- 调用方式看起来很像函数调用
- 但实际上是文本展开和注入

**原因 3：效果类似**
- Skills 确实能实现特定功能
- 但不是通过代码执行，而是通过 LLM 理解和生成

### 深层原因

**来自 agent-session.ts:883-907 的实现：**
```typescript
private _expandSkillCommand(text: string): string {
  // 1. 解析技能名称
  const skillName = text.slice(7).split(" ")[0];

  // 2. 查找技能
  const skill = this.resourceLoader.getSkills().skills.find(s => s.name === skillName);

  // 3. 读取文件内容（注意：是读取文本，不是执行代码）
  const content = readFileSync(skill.filePath, 'utf-8');
  const body = stripFrontmatter(content).trim();

  // 4. 展开为 XML 块（注入到 System Prompt）
  const skillBlock = `<skill name="${skill.name}" location="${skill.filePath}">
References are relative to ${skill.baseDir}.

${body}
</skill>`;

  return args ? `${skillBlock}\n\n${args}` : skillBlock;
}
```

**关键点：**
- 没有 `eval()` 或 `Function()` 调用
- 没有代码编译或执行
- 只是文本读取和字符串拼接
- 最终注入到 LLM 的上下文中

### 实际影响

**影响 1：性能特征不同**
```
代码执行：
- 执行速度：毫秒级
- 确定性：100%
- 资源消耗：CPU/内存

提示词引导：
- 执行速度：秒级（LLM 推理）
- 确定性：高但非 100%
- 资源消耗：API 调用
```

**影响 2：调试方式不同**
```
代码调试：
- 断点调试
- 单元测试
- 错误堆栈

提示词调试：
- 查看展开后的提示词
- 测试不同输入
- 分析 LLM 输出
```

**影响 3：能力边界不同**
```
代码能力：
- 精确的数学计算
- 确定性的逻辑判断
- 高性能的数据处理

提示词能力：
- 自然语言理解
- 创意性生成
- 灵活的推理
```

---

## 反直觉点 2：技能加载是启动时一次性的，不是动态的

### 直觉认知

**大多数人认为：**
```
技能应该像 npm 包一样，可以动态导入
需要时才加载，不需要时不占用资源
```

### 实际情况

**Skills 实际上是：**
```
启动时一次性扫描所有技能目录
加载所有技能到内存
运行时不再扫描文件系统
```

### 为什么反直觉？

**原因 1：现代模块系统的习惯**
```typescript
// 动态导入（现代 JavaScript）
const module = await import('./my-module.js');

// 懒加载（React）
const Component = lazy(() => import('./Component'));
```
- 现代开发习惯是按需加载
- 但 Skills 是启动时全量加载

**原因 2：性能考虑的误解**
- 直觉上认为：加载所有技能会很慢
- 实际上：技能文件很小（几 KB），加载很快
- 启动时加载避免了运行时的 I/O 开销

### 深层原因

**来自 skills.ts:146-230 的实现：**
```typescript
export function loadSkillsFromDir(options: LoadSkillsFromDirOptions): LoadSkillsResult {
  const { dir, source } = options;
  return loadSkillsFromDirInternal(dir, source, true);
}

function loadSkillsFromDirInternal(
  dir: string,
  source: string,
  includeRootFiles: boolean,
  ignoreMatcher?: IgnoreMatcher,
  rootDir?: string,
): LoadSkillsResult {
  const skills: Skill[] = [];
  const diagnostics: ResourceDiagnostic[] = [];

  // 递归扫描目录
  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    if (entry.isDirectory()) {
      // 递归扫描子目录
      const subResult = loadSkillsFromDirInternal(fullPath, source, false, ig, root);
      skills.push(...subResult.skills);
    } else if (entry.name === "SKILL.md") {
      // 加载技能文件
      const result = loadSkillFromFile(fullPath, source);
      if (result.skill) {
        skills.push(result.skill);
      }
    }
  }

  return { skills, diagnostics };
}
```

**关键点：**
- 使用 `readdirSync`（同步读取）
- 递归扫描所有子目录
- 一次性加载所有技能
- 返回技能数组（存储在内存中）

### 实际影响

**影响 1：添加新技能需要重启**
```bash
# 添加新技能
mkdir -p ~/.pi/agent/skills/new-skill
cat > ~/.pi/agent/skills/new-skill/SKILL.md << 'EOF'
---
name: new-skill
description: A new skill
---
...
EOF

# ❌ 不会立即生效
/skill:new-skill  # 找不到技能

# ✅ 需要重启 pi
exit
pi
/skill:new-skill  # 现在可以使用了
```

**影响 2：修改技能需要重启**
```bash
# 修改技能文件
vim ~/.pi/agent/skills/my-skill/SKILL.md

# ❌ 修改不会立即生效
/skill:my-skill  # 仍然使用旧版本

# ✅ 需要重启 pi
exit
pi
/skill:my-skill  # 现在使用新版本
```

**影响 3：技能列表是静态的**
```typescript
// 技能列表在启动时确定
const skills = resourceLoader.getSkills().skills;

// 运行时不会改变
// 即使文件系统中的技能发生变化
```

### 为什么这样设计？

**原因 1：简单性**
- 避免文件监听的复杂性
- 避免热重载的状态管理
- 启动时加载，逻辑清晰

**原因 2：性能**
- 避免运行时的文件系统 I/O
- 技能文件很小，全量加载开销小
- 查找技能时直接在内存中查找

**原因 3：一致性**
- 避免运行时技能列表变化导致的不一致
- 确保会话期间技能列表稳定

---

## 反直觉点 3：技能调用不是函数调用，是文本展开

### 直觉认知

**大多数人认为：**
```
/skill:my-skill args
↓
调用 my-skill 函数，传入 args 参数
↓
返回执行结果
```

### 实际情况

**Skills 调用实际上是：**
```
/skill:my-skill args
↓
读取 SKILL.md 文件内容
↓
展开为 XML 块 + args
↓
注入到 LLM 的上下文中
↓
LLM 理解并生成响应
```

### 为什么反直觉？

**原因 1：调用语法类似函数**
```bash
# 看起来像函数调用
/skill:code-review src/app.ts

# 实际上是文本展开
<skill name="code-review" location="...">
You are an expert code reviewer...
</skill>

src/app.ts
```

**原因 2：有参数传递**
```bash
# 看起来像传递参数
/skill:greet Alice

# 实际上是文本拼接
<skill name="greet" location="...">
You are a friendly assistant...
</skill>

Alice
```

**原因 3：有返回结果**
```bash
# 看起来像函数返回值
/skill:code-review src/app.ts
→ [代码审查报告]

# 实际上是 LLM 生成的文本
```

### 深层原因

**来自 agent-session.ts:883-907 的实现：**
```typescript
private _expandSkillCommand(text: string): string {
  if (!text.startsWith("/skill:")) return text;

  const spaceIndex = text.indexOf(" ");
  const skillName = spaceIndex === -1 ? text.slice(7) : text.slice(7, spaceIndex);
  const args = spaceIndex === -1 ? "" : text.slice(spaceIndex + 1).trim();

  const skill = this.resourceLoader.getSkills().skills.find((s) => s.name === skillName);
  if (!skill) return text; // 找不到技能，返回原文本

  const content = readFileSync(skill.filePath, 'utf-8');
  const body = stripFrontmatter(content).trim();

  // 关键：展开为 XML 块
  const skillBlock = `<skill name="${skill.name}" location="${skill.filePath}">
References are relative to ${skill.baseDir}.

${body}
</skill>`;

  // 关键：拼接参数
  return args ? `${skillBlock}\n\n${args}` : skillBlock;
}
```

**关键点：**
- 没有函数调用
- 只是字符串拼接
- 返回的是文本，不是执行结果
- 这个文本会被发送给 LLM

### 实际影响

**影响 1：参数是自由文本**
```bash
# ✅ 可以传递任意文本
/skill:code-review src/app.ts
/skill:code-review "请重点关注性能问题"
/skill:code-review
```typescript
function add(a, b) {
  return a + b;
}
```

# ❌ 没有类型检查
# ❌ 没有参数验证
```

**影响 2：返回值是 LLM 生成的**
```bash
# 同样的调用，可能得到不同的结果
/skill:code-review src/app.ts
→ 结果 1: [详细的代码审查报告]

/skill:code-review src/app.ts
→ 结果 2: [简短的代码审查报告]

# 因为 LLM 生成是非确定性的
```

**影响 3：调试需要查看展开后的文本**
```bash
# 调试技能时，需要查看展开后的文本
# 而不是查看"函数调用"

# 可以通过日志查看展开后的内容
# 或者手动模拟展开过程
```

---

## 反直觉点 4：技能组合不是函数组合，是提示词嵌套

### 直觉认知

**大多数人认为：**
```typescript
// 函数组合
const result = compose(
  skill3,
  skill2,
  skill1
)(input);
```

### 实际情况

**Skills 组合实际上是：**
```markdown
<!-- parent-skill/SKILL.md -->
You are a planning assistant.

Step 1: Use /skill:explore to understand the codebase
Step 2: Use /skill:plan to generate a plan
Step 3: Present the plan to the user
```

### 为什么反直觉？

**原因 1：看起来像函数调用**
```markdown
Use /skill:explore to understand the codebase
```
- 看起来像调用 explore 函数
- 实际上是让 LLM 理解"应该调用 explore 技能"

**原因 2：执行顺序不是自动的**
```markdown
Step 1: /skill:explore
Step 2: /skill:plan
```
- 看起来像顺序执行
- 实际上是 LLM 理解并决定何时调用

**原因 3：数据传递不是显式的**
```markdown
Use /skill:explore to understand the codebase
Then use /skill:plan based on the exploration results
```
- 看起来像数据传递
- 实际上是 LLM 的上下文理解

### 深层原因

**技能组合的实际机制：**
```
1. 用户调用父技能
   /skill:parent-skill

2. 父技能展开
   <skill name="parent-skill">
   Step 1: Use /skill:explore
   Step 2: Use /skill:plan
   </skill>

3. LLM 理解父技能的指令
   "我需要先调用 explore，再调用 plan"

4. LLM 生成调用子技能的命令
   /skill:explore

5. 子技能展开
   <skill name="explore">
   ...
   </skill>

6. LLM 执行子技能逻辑
   [探索代码库]

7. LLM 继续执行父技能的下一步
   /skill:plan

8. 重复步骤 5-6
```

**关键点：**
- 不是自动的函数调用链
- 是 LLM 理解和执行的过程
- 依赖 LLM 的推理能力
- 可能出现执行顺序错误

### 实际影响

**影响 1：组合不是确定性的**
```markdown
<!-- 父技能定义 -->
Step 1: /skill:explore
Step 2: /skill:plan

<!-- 可能的执行情况 -->
情况 1: explore → plan ✅
情况 2: plan → explore ❌（顺序错误）
情况 3: explore → explore → plan ❌（重复调用）
情况 4: explore ❌（忘记调用 plan）
```

**影响 2：需要明确的指令**
```markdown
<!-- ❌ 不够明确 -->
Use explore and plan skills

<!-- ✅ 明确的指令 -->
Step 1: First, use /skill:explore to understand the codebase
Step 2: Wait for the exploration results
Step 3: Then, use /skill:plan to generate an implementation plan
Step 4: Present the plan to the user for approval
```

**影响 3：错误处理依赖 LLM**
```markdown
<!-- 父技能需要处理错误 -->
Step 1: Use /skill:explore
Step 2: If exploration fails, ask the user for more context
Step 3: If exploration succeeds, use /skill:plan
Step 4: If planning fails, try a simpler approach
```

---

## 反直觉点 5：技能没有版本管理，只有文件替换

### 直觉认知

**大多数人认为：**
```bash
# npm 包有版本管理
npm install my-package@1.2.3
npm install my-package@latest

# 可以同时安装多个版本
node_modules/
  my-package-v1/
  my-package-v2/
```

### 实际情况

**Skills 实际上是：**
```bash
# 技能没有版本号
~/.pi/agent/skills/my-skill/SKILL.md

# 只能有一个版本
# 更新就是替换文件
```

### 为什么反直觉？

**原因 1：Git 可以管理版本**
```bash
# 技能可以用 Git 管理
cd ~/.pi/agent/skills/my-skill
git log  # 查看历史版本
git checkout v1.0.0  # 切换版本
```
- 但这是 Git 的版本管理，不是 Skills 系统的
- Skills 系统本身不感知版本

**原因 2：YAML frontmatter 可以添加版本字段**
```yaml
---
name: my-skill
description: My skill
version: 1.2.3  # 可以添加，但不会被使用
---
```
- 可以添加 version 字段
- 但 Skills 系统不会读取或使用它

**原因 3：目录名可以包含版本**
```bash
~/.pi/agent/skills/my-skill-v1/SKILL.md
~/.pi/agent/skills/my-skill-v2/SKILL.md
```
- 可以通过目录名区分版本
- 但这是手动管理，不是系统支持

### 深层原因

**来自 skills.ts:66-80 的接口定义：**
```typescript
export interface SkillFrontmatter {
  name?: string;
  description?: string;
  "disable-model-invocation"?: boolean;
  [key: string]: unknown;  // 可以有其他字段，但不会被使用
}

export interface Skill {
  name: string;
  description: string;
  filePath: string;
  baseDir: string;
  source: string;
  disableModelInvocation: boolean;
  // 注意：没有 version 字段
}
```

**关键点：**
- Skill 接口没有 version 字段
- 加载逻辑不处理版本
- 技能名称是唯一标识符
- 同名技能会被覆盖（项目技能覆盖全局技能）

### 实际影响

**影响 1：更新技能会影响所有项目**
```bash
# 更新全局技能
cd ~/.pi/agent/skills/code-review
git pull

# ❌ 所有使用这个技能的项目都会受影响
# ❌ 无法回滚到旧版本（除非手动 git checkout）
```

**影响 2：需要手动管理版本**
```bash
# 方案 1：使用不同的技能名称
~/.pi/agent/skills/code-review-v1/SKILL.md
~/.pi/agent/skills/code-review-v2/SKILL.md

# 方案 2：使用 Git 分支
cd ~/.pi/agent/skills/code-review
git checkout v1.0.0

# 方案 3：使用项目级技能
./.pi/skills/code-review/SKILL.md  # 项目特定版本
```

**影响 3：技能兼容性需要手动测试**
```bash
# npm 包有语义化版本
# 可以通过版本号判断兼容性

# Skills 没有版本号
# 需要手动测试兼容性
```

---

## 总结：为什么这些设计是反直觉的？

### 根本原因：Skills 不是代码，是提示词

**代码的特性：**
- 确定性执行
- 类型安全
- 版本管理
- 动态加载
- 函数组合

**提示词的特性：**
- LLM 解释执行
- 自由文本
- 文件替换
- 启动时加载
- 上下文嵌套

### 设计哲学：极简主义

**Pi-mono 的选择：**
1. **简单性 > 功能性**
   - 不实现复杂的版本管理
   - 不实现动态加载
   - 不实现类型系统

2. **文件系统 > 数据库**
   - 使用文件系统存储
   - 使用 Git 管理版本
   - 使用目录结构组织

3. **文本展开 > 代码执行**
   - 技能是提示词，不是代码
   - 调用是文本展开，不是函数调用
   - 组合是提示词嵌套，不是函数组合

### 理解这些反直觉点的价值

**价值 1：避免错误的期望**
- 不要期望技能像代码一样确定性执行
- 不要期望技能有类型安全
- 不要期望技能有自动版本管理

**价值 2：正确使用技能**
- 技能适合自然语言任务
- 技能适合灵活的推理
- 技能适合创意性生成

**价值 3：设计更好的技能**
- 提供明确的指令
- 处理不确定性
- 手动管理版本

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
