# 面试必问

## 问题1："请解释 Python 的上下文管理器是什么，以及它的工作原理"

### 普通回答（❌ 不出彩）

"上下文管理器是 Python 中用 `with` 语句管理资源的一种方式，可以自动关闭文件。它有 `__enter__` 和 `__exit__` 两个方法。"

**问题：**
- 太简单，没有深度
- 只提到文件，没有说明通用性
- 没有解释为什么需要上下文管理器

---

### 出彩回答（✅ 推荐）

> **上下文管理器有三层含义：**
>
> **1. 协议层面**：上下文管理器是实现了 `__enter__` 和 `__exit__` 方法的对象。`__enter__` 在进入 `with` 块时调用，返回值赋给 `as` 后的变量；`__exit__` 在退出时调用，接收异常信息（`exc_type`, `exc_val`, `exc_tb`），返回 `True` 可以抑制异常。
>
> **2. 设计模式层面**：上下文管理器是"资源获取即初始化"（RAII）模式的 Python 实现，确保资源在使用后一定被释放，即使发生异常。它本质上是 `try-finally` 的语法糖，但更简洁和可复用。
>
> **3. 实际应用层面**：除了文件和数据库连接，上下文管理器还可以用于：
> - 事务管理（自动提交/回滚）
> - 锁管理（自动获取/释放）
> - 临时状态修改（自动恢复）
> - 性能监控（自动计时）
>
> **与 `try-finally` 的区别**：
> - 代码更简洁：`with open()` vs 5行 `try-finally`
> - 可复用性更好：封装成类或用 `@contextmanager` 装饰器
> - 语义更清晰：`with` 明确表示资源的生命周期范围
>
> **在实际工作中的应用**：
> 在 FastAPI 项目中，我们用上下文管理器管理数据库会话：
> ```python
> @contextmanager
> def get_db():
>     db = SessionLocal()
>     try:
>         yield db
>     except Exception:
>         db.rollback()
>         raise
>     finally:
>         db.close()
> ```
> 这样每个请求自动获取连接，请求结束后自动释放，即使发生异常也能正确回滚和关闭连接。

### 为什么这个回答出彩？

1. ✅ **多层次解释**：从协议、设计模式、实际应用三个层面解释
2. ✅ **对比说明**：与 `try-finally` 对比，突出优势
3. ✅ **扩展应用**：不只是文件，还有事务、锁、状态等
4. ✅ **实际案例**：给出 FastAPI 中的真实应用代码
5. ✅ **异常处理**：提到 `__exit__` 的异常处理机制

---

## 问题2："`@contextmanager` 装饰器是如何工作的？"

### 普通回答（❌ 不出彩）

"`@contextmanager` 是一个装饰器，可以把生成器函数变成上下文管理器。`yield` 前面是 `__enter__`，后面是 `__exit__`。"

**问题：**
- 只说了表面现象，没有解释原理
- 没有说明为什么要用生成器
- 没有提到异常处理

---

### 出彩回答（✅ 推荐）

> **`@contextmanager` 的工作原理：**
>
> **1. 本质**：`@contextmanager` 将生成器函数转换为上下文管理器类，自动实现 `__enter__` 和 `__exit__` 方法。
>
> **2. 执行流程**：
> ```python
> @contextmanager
> def my_context():
>     print("1. Setup")      # __enter__ 阶段
>     yield "resource"       # 暂停，返回值给 with 块
>     print("2. Cleanup")    # __exit__ 阶段
> ```
>
> 等价于：
> ```python
> class MyContext:
>     def __enter__(self):
>         print("1. Setup")
>         return "resource"
>
>     def __exit__(self, exc_type, exc_val, exc_tb):
>         print("2. Cleanup")
>         return False
> ```
>
> **3. 异常处理机制**：
> - `yield` 前的代码在 `try` 块中执行
> - `yield` 后的代码在 `finally` 块中执行
> - 如果 `with` 块抛出异常，会在 `yield` 处重新抛出
>
> ```python
> @contextmanager
> def safe_context():
>     try:
>         yield
>     except ValueError as e:
>         print(f"Caught: {e}")
>         # 不重新抛出 = 抑制异常
>     finally:
>         print("Cleanup")
> ```
>
> **4. 为什么用生成器**：
> - 生成器天然支持"暂停-恢复"机制（`yield`）
> - 代码更简洁：不需要写类和两个方法
> - 局部变量自动保存：`yield` 前后可以访问同一个变量
>
> **5. 实际应用**：
> ```python
> @contextmanager
> def transaction(db):
>     """数据库事务管理"""
>     try:
>         yield db
>         db.commit()  # 成功则提交
>     except Exception:
>         db.rollback()  # 失败则回滚
>         raise
> ```

### 为什么这个回答出彩？

1. ✅ **原理解释**：说明了装饰器如何转换生成器
2. ✅ **等价代码**：展示了与类实现的对应关系
3. ✅ **异常机制**：详细说明了异常如何在 `yield` 处传递
4. ✅ **设计动机**：解释了为什么选择生成器而不是类
5. ✅ **实际案例**：给出数据库事务管理的实用示例

---

## 问题3："上下文管理器的 `__exit__` 方法返回 `True` 和 `False` 有什么区别？"

### 普通回答（❌ 不出彩）

"返回 `True` 会抑制异常，返回 `False` 会传播异常。"

**问题：**
- 只说了结果，没有解释为什么
- 没有给出使用场景
- 没有说明默认行为

---

### 出彩回答（✅ 推荐）

> **`__exit__` 返回值的含义：**
>
> **1. 返回 `False`（默认）**：异常继续传播
> ```python
> def __exit__(self, exc_type, exc_val, exc_tb):
>     self.cleanup()
>     return False  # 或者不写 return（默认 None，等价于 False）
> ```
> 这是最常见的行为，类似 `try-finally`：清理资源，但不处理异常。
>
> **2. 返回 `True`**：抑制异常（异常不会向外传播）
> ```python
> def __exit__(self, exc_type, exc_val, exc_tb):
>     if exc_type is ValueError:
>         print(f"Handled: {exc_val}")
>         return True  # 抑制 ValueError
>     return False  # 其他异常继续传播
> ```
>
> **3. 使用场景对比**：
>
> | 场景 | 返回值 | 原因 |
> |------|--------|------|
> | 文件管理 | `False` | 只负责关闭文件，不处理业务异常 |
> | 数据库连接 | `False` | 只负责关闭连接，异常应该向上传播 |
> | 数据库事务 | `False` | 回滚后重新抛出异常，让调用者知道失败 |
> | 错误重试 | `True` | 捕获特定异常并重试，成功后抑制异常 |
> | 测试断言 | `True` | 捕获预期异常，验证后抑制 |
>
> **4. 实际案例**：
>
> ```python
> # 案例1：数据库事务（返回 False）
> @contextmanager
> def transaction(db):
>     try:
>         yield db
>         db.commit()
>     except Exception:
>         db.rollback()
>         raise  # 重新抛出，让调用者知道失败
>
> # 案例2：自动重试（返回 True）
> @contextmanager
> def auto_retry(max_retries=3):
>     for i in range(max_retries):
>         try:
>             yield
>             break  # 成功则退出
>         except Exception as e:
>             if i == max_retries - 1:
>                 raise  # 最后一次重试失败，抛出异常
>             print(f"Retry {i+1}/{max_retries}")
>
> with auto_retry():
>     unstable_api_call()  # 自动重试
> ```
>
> **5. 最佳实践**：
> - 默认返回 `False`：大多数情况下不应该抑制异常
> - 只在明确需要时返回 `True`：如错误恢复、测试断言
> - 选择性抑制：检查 `exc_type`，只抑制特定异常

### 为什么这个回答出彩？

1. ✅ **对比说明**：清晰对比两种返回值的行为
2. ✅ **场景分析**：用表格总结不同场景的选择
3. ✅ **实际案例**：给出数据库事务和自动重试的代码
4. ✅ **最佳实践**：提供实用的决策指南
5. ✅ **深度理解**：说明了为什么大多数情况返回 `False`

---

## 加分项：主动扩展

**如果面试官追问："在 FastAPI 中如何使用上下文管理器？"**

> 在 FastAPI 中，上下文管理器主要用于依赖注入系统管理数据库会话：
>
> ```python
> # 1. 定义数据库会话上下文管理器
> def get_db():
>     db = SessionLocal()
>     try:
>         yield db  # 提供给路由函数使用
>     finally:
>         db.close()  # 请求结束后自动关闭
>
> # 2. 在路由中使用（依赖注入）
> @app.get("/users/{user_id}")
> async def get_user(
>     user_id: int,
>     db: Session = Depends(get_db)  # 自动注入
> ):
>     user = db.query(User).filter(User.id == user_id).first()
>     return user
> # db 会话自动关闭
>
> # 3. 也可以手动使用
> @app.post("/users")
> async def create_user(user: UserCreate):
>     with get_db() as db:
>         new_user = User(**user.dict())
>         db.add(new_user)
>         db.commit()
>         return new_user
> ```
>
> FastAPI 的 `Depends` 会自动处理生成器函数，将其转换为上下文管理器，确保每个请求都有独立的数据库会话，并在请求结束后自动清理。

---

**版本：** v1.0
**最后更新：** 2026-02-11
