# 化骨绵掌

将 Milvus Partition 拆分成 10 个 2 分钟知识卡片，快速掌握核心要点。

---

## 卡片1：Partition 的本质

**一句话：** Partition 是 Collection 内的逻辑分组，每条数据都有一个 partition 标签。

**举例：**
```python
# Partition 的本质
Collection {
    data: [
        {id: 1, vector: [...], partition: "_default"},
        {id: 2, vector: [...], partition: "partition_2024"},
        {id: 3, vector: [...], partition: "partition_2024"}
    ]
}
```

**应用：** 在 RAG 系统中，按月创建分区，将文档按上传时间自动路由到对应分区，实现时间范围查询优化。

---

## 卡片2：Partition Pruning 机制

**一句话：** Partition Pruning 通过指定分区名，跳过无关分区，只检索相关分区。

**举例：**
```python
# 无 Partition Pruning：检索所有分区（1000万条）
results = collection.search(query_vector, limit=5)  # 500ms

# 有 Partition Pruning：只检索1个分区（100万条）
results = collection.search(
    query_vector,
    partition_names=["partition_2024_02"],  # 50ms
    limit=5
)
# 性能提升 10倍！
```

**应用：** 在新闻检索系统中，用户查询"最近一个月的新闻"，只检索最近1个月的分区，跳过其他11个月的分区。

---

## 卡片3：分区命名策略

**一句话：** 根据业务特征选择分区命名策略：时间、租户、类别。

**举例：**
```python
# 时间分区
"partition_2024_01", "partition_2024_02", ...

# 租户分区
"tenant_company_a", "tenant_company_b", ...

# 类别分区
"category_tech", "category_finance", ...
```

**应用：**
- 时间分区：新闻、日志、监控数据
- 租户分区：SaaS 多租户系统
- 类别分区：电商推荐、内容分类

---

## 卡片4：分区数量控制

**一句话：** 分区数量推荐 10-200 个，避免分区过多导致管理复杂。

**举例：**
```python
# 推荐的分区数量
数据规模 < 100万条    → 1-10 个分区
数据规模 100万-1000万 → 10-50 个分区
数据规模 > 1000万     → 50-200 个分区

# ❌ 错误：按天分区（365个分区）
# ✅ 正确：按月分区（12个分区）
```

**应用：** 在设计分区策略时，优先考虑管理复杂度，避免分区爆炸。

---

## 卡片5：分区 vs 标量过滤

**一句话：** Partition 是粗粒度过滤（跳过整个分区），标量过滤是细粒度过滤（分区内筛选）。

**举例：**
```python
# 组合使用（最优）
results = collection.search(
    query_vector,
    partition_names=["region_beijing"],  # 粗粒度：地区分区
    expr='category == "electronics" and price < 500',  # 细粒度：类别和价格
    limit=10
)

# 性能提升：5.3倍
```

**应用：** 在电商推荐系统中，按地区分区（Partition）+ 按类别和价格过滤（标量过滤），获得最佳性能。

---

## 卡片6：多租户隔离

**一句话：** 使用分区实现多租户数据隔离，比应用层过滤更安全。

**举例：**
```python
# 租户注册
collection.create_partition(f"tenant_{tenant_id}")

# 强制租户隔离
results = collection.search(
    query_vector,
    partition_names=[f"tenant_{tenant_id}"],  # 只能访问自己的分区
    limit=10
)
```

**应用：** 在 SaaS 知识库系统中，每个客户的数据存储在独立分区，实现存储层隔离，即使应用层有 bug 也无法跨租户访问。

---

## 卡片7：冷热数据分离

**一句话：** 只加载热数据分区到内存，冷数据按需加载，节省内存。

**举例：**
```python
# 只加载最近3个月的分区（热数据）
hot_partitions = ["partition_2024_10", "partition_2024_11", "partition_2024_12"]
for name in hot_partitions:
    collection.partition(name).load()

# 冷数据按需加载
def search_cold_data(partition_name, query_vector):
    partition = collection.partition(partition_name)
    partition.load()  # 临时加载
    results = collection.search(query_vector, partition_names=[partition_name])
    partition.release()  # 用完释放
    return results
```

**应用：** 在新闻检索系统中，只加载最近3个月的分区，节省 75% 内存。

---

## 卡片8：时间范围查询

**一句话：** 根据时间范围动态确定要检索的分区列表。

**举例：**
```python
def search_by_time_range(query_vector, start_date, end_date):
    # 生成时间范围内的分区列表
    partition_names = []
    current = start_date
    while current <= end_date:
        partition_name = f"partition_{current.strftime('%Y_%m')}"
        if collection.has_partition(partition_name):
            partition_names.append(partition_name)
        current = next_month(current)

    # 只检索时间范围内的分区
    results = collection.search(
        query_vector,
        partition_names=partition_names,
        limit=10
    )
    return results
```

**应用：** 用户查询"2024年1月到3月的数据"，只检索这3个月的分区。

---

## 卡片9：RAG 系统的分区策略

**一句话：** 在 RAG 系统中，优先使用租户分区，时间作为标量过滤。

**举例：**
```python
# RAG 多租户知识库
class RAGSystem:
    def upload_document(self, tenant_id, doc_text):
        # 插入到租户分区
        partition = collection.partition(f"tenant_{tenant_id}")
        embedding = get_embedding(doc_text)
        partition.insert([[embedding], [doc_text]])

    def search(self, tenant_id, query):
        # 只检索当前租户的分区
        query_embedding = get_embedding(query)
        results = collection.search(
            query_embedding,
            partition_names=[f"tenant_{tenant_id}"],  # 租户隔离
            limit=5
        )
        return results
```

**应用：** 在 SaaS RAG 系统中，每个客户的文档存储在独立分区，实现数据隔离和检索加速。

---

## 卡片10：分区管理最佳实践

**一句话：** 遵循最佳实践，避免常见误区。

**最佳实践：**
1. ✅ 插入时明确指定分区
2. ✅ 检索时明确指定分区
3. ✅ 控制分区数量在 10-200 个
4. ✅ 每个分区大小在 10万-1000万 条
5. ✅ 组合使用分区和标量过滤
6. ✅ 只加载常用分区到内存
7. ✅ 定期检查分区大小和使用情况

**常见误区：**
1. ❌ 分区越多越好（会增加管理复杂度）
2. ❌ 可以随时修改数据所属分区（需要删除+重新插入）
3. ❌ 不指定分区就不检索 _default（会检索所有分区）
4. ❌ Partition 可以替代标量过滤（两者互补）

**应用：** 在设计和使用分区时，遵循这些最佳实践，避免踩坑。

---

## 快速回顾

### 核心概念

| 概念 | 要点 | 性能提升 |
|------|------|---------|
| Partition Pruning | 跳过无关分区 | 3-10x |
| 时间分区 | 按月/周/天分区 | 5-10x |
| 租户分区 | 按租户隔离 | 3-5x |
| 冷热分离 | 只加载热数据 | 节省 50-80% 内存 |
| 混合检索 | 分区 + 标量过滤 | 5.3x |

### 使用场景

| 场景 | 分区策略 | 适用系统 |
|------|---------|---------|
| 时间序列数据 | 按时间分区 | 新闻、日志、监控 |
| 多租户系统 | 按租户分区 | SaaS、知识库 |
| 地域数据 | 按地区分区 | 电商、推荐 |
| 类别数据 | 按类别分区 | 内容分类 |

### 关键参数

| 参数 | 推荐值 | 说明 |
|------|--------|------|
| 分区数量 | 10-200 | 避免过多 |
| 分区大小 | 100万条 | 最优大小 |
| 热数据分区 | 3-5个 | 常驻内存 |
| 检索分区数 | 1-5个 | 单次检索 |

---

## 学习检查清单

完成以下检查，确保你已掌握 Partition 的核心知识：

- [ ] 理解 Partition 的本质（逻辑分组）
- [ ] 理解 Partition Pruning 的工作原理
- [ ] 掌握三种分区命名策略（时间/租户/类别）
- [ ] 知道如何控制分区数量（10-200）
- [ ] 理解分区和标量过滤的区别和组合使用
- [ ] 掌握多租户隔离的实现方法
- [ ] 理解冷热数据分离策略
- [ ] 掌握时间范围查询的实现
- [ ] 了解 RAG 系统的分区策略
- [ ] 遵循分区管理最佳实践

---

## 下一步学习

掌握这 10 个知识卡片后，建议：

1. **实践练习**：跟着实战代码场景动手实践
2. **性能测试**：对比有分区和无分区的性能差异
3. **项目应用**：在实际项目中应用分区策略
4. **深入学习**：学习混合检索、数据管理等高级特性

---

**记住**：Partition 是 Milvus 性能优化的核心机制，通过合理的分区策略，可以将检索性能提升 3-10 倍，内存占用减少 50-80%。
