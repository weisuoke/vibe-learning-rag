# 核心概念09：向量数据库选型对比

> 对比主流向量数据库，选择最适合的方案

---

## 概述

2025-2026年，主流向量数据库包括：Milvus、Qdrant、Weaviate、ChromaDB。

**选择标准**：
- 数据规模
- 部署难度
- 特色功能
- 生态集成

---

## 1. 四大主流数据库

### 1.1 ChromaDB

**定位**：轻量级向量数据库

**核心特点**：
- 零配置，开箱即用
- 自动持久化
- Python原生
- 适合中小规模（<100万向量）

**快速开始**：
```python
import chromadb

client = chromadb.PersistentClient(path="./chroma_db")
collection = client.get_or_create_collection(
    name="documents",
    metadata={"hnsw:space": "cosine"}
)

# 添加文档
collection.add(
    documents=["Python编程", "机器学习"],
    ids=["doc1", "doc2"]
)

# 查询
results = collection.query(
    query_texts=["学习编程"],
    n_results=2
)
```

**优点**：
- ✅ 零配置
- ✅ 快速原型
- ✅ Python友好

**缺点**：
- ❌ 规模受限（<100万）
- ❌ 无分布式
- ❌ 功能简单

**适用场景**：
- 个人项目
- 快速原型
- 学习测试

---

### 1.2 Qdrant

**定位**：高性能向量数据库

**核心特点**：
- Rust实现，性能优异
- 高性能过滤
- 易于部署
- 适合中型规模（100万-1000万向量）

**快速开始**：
```python
from qdrant_client import QdrantClient
from qdrant_client.models import Distance, VectorParams

client = QdrantClient(host="localhost", port=6333)

# 创建集合
client.create_collection(
    collection_name="documents",
    vectors_config=VectorParams(size=1536, distance=Distance.COSINE)
)

# 添加向量
client.upsert(
    collection_name="documents",
    points=[
        {"id": 1, "vector": [0.1, 0.2, ...], "payload": {"text": "Python编程"}},
        {"id": 2, "vector": [0.2, 0.3, ...], "payload": {"text": "机器学习"}}
    ]
)

# 查询
results = client.search(
    collection_name="documents",
    query_vector=[0.15, 0.25, ...],
    limit=10
)
```

**优点**：
- ✅ 高性能（Rust）
- ✅ 强大的过滤功能
- ✅ 易于部署（Docker）
- ✅ 活跃社区

**缺点**：
- ❌ 分布式功能有限
- ❌ 生态不如Milvus

**适用场景**：
- 生产中小规模
- 需要高性能过滤
- 单机或小集群

---

### 1.3 Milvus

**定位**：大规模分布式向量数据库

**核心特点**：
- 分布式架构
- GPU加速
- 多种索引（HNSW、IVF、DiskANN）
- 适合大规模（>1000万向量）

**快速开始**：
```python
from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType

connections.connect(host="localhost", port="19530")

# 定义Schema
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=1536),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=1000)
]
schema = CollectionSchema(fields, description="documents")

# 创建集合
collection = Collection(name="documents", schema=schema)

# 创建索引
index_params = {
    "metric_type": "COSINE",
    "index_type": "HNSW",
    "params": {"M": 16, "efConstruction": 200}
}
collection.create_index(field_name="embedding", index_params=index_params)

# 插入数据
collection.insert([
    [1, 2],  # ids
    [[0.1, 0.2, ...], [0.2, 0.3, ...]],  # embeddings
    ["Python编程", "机器学习"]  # texts
])

# 查询
collection.load()
results = collection.search(
    data=[[0.15, 0.25, ...]],
    anns_field="embedding",
    param={"metric_type": "COSINE", "params": {"ef": 64}},
    limit=10
)
```

**优点**：
- ✅ 大规模支持（>10亿）
- ✅ 分布式架构
- ✅ GPU加速
- ✅ 多种索引算法
- ✅ 活跃社区

**缺点**：
- ❌ 部署复杂
- ❌ 学习曲线陡峭
- ❌ 资源占用大

**适用场景**：
- 生产大规模
- 需要分布式
- 有运维团队

---

### 1.4 Weaviate

**定位**：混合搜索向量数据库

**核心特点**：
- Vector + 关键词混合搜索
- GraphQL API
- 内置Embedding模型
- 适合任意规模

**快速开始**：
```python
import weaviate

client = weaviate.Client("http://localhost:8080")

# 创建Schema
schema = {
    "class": "Document",
    "vectorizer": "text2vec-openai",
    "properties": [
        {"name": "text", "dataType": ["text"]}
    ]
}
client.schema.create_class(schema)

# 添加数据（自动Embedding）
client.data_object.create(
    class_name="Document",
    data_object={"text": "Python编程"}
)

# 混合搜索
results = client.query.get("Document", ["text"]).with_hybrid(
    query="学习编程",
    alpha=0.6  # 60%向量 + 40%关键词
).with_limit(10).do()
```

**优点**：
- ✅ 混合搜索（Vector + BM25）
- ✅ GraphQL API
- ✅ 内置Embedding
- ✅ 易于使用

**缺点**：
- ❌ 性能不如Qdrant
- ❌ 社区较小

**适用场景**：
- 需要混合搜索
- GraphQL生态
- 快速集成

---

## 2. 性能对比

### 2.1 基准测试（2025-2026）

**测试条件**：
- 100万向量，768维
- Top-10检索
- 单机部署

| 数据库 | 查询延迟 | 召回率 | 内存占用 | QPS |
|--------|---------|--------|---------|-----|
| **ChromaDB** | 15ms | 96% | 3.2GB | 500 |
| **Qdrant** | 8ms | 97% | 3.5GB | 1000 |
| **Milvus** | 10ms | 97% | 4.0GB | 800 |
| **Weaviate** | 12ms | 96% | 3.8GB | 600 |

**来源**：Medium/Firecrawl Benchmark 2025

---

### 2.2 大规模测试（1000万向量）

| 数据库 | 查询延迟 | 召回率 | 内存占用 | 分布式 |
|--------|---------|--------|---------|--------|
| **Qdrant** | 25ms | 95% | 35GB | 有限 |
| **Milvus** | 20ms | 96% | 40GB | 完整 |
| **Weaviate** | 30ms | 94% | 38GB | 有限 |

---

## 3. 功能对比

### 3.1 索引算法支持

| 数据库 | HNSW | IVF | DiskANN | 其他 |
|--------|------|-----|---------|------|
| **ChromaDB** | ✅ | ❌ | ❌ | - |
| **Qdrant** | ✅ | ❌ | ❌ | - |
| **Milvus** | ✅ | ✅ | ✅ | IVF-PQ, Flat |
| **Weaviate** | ✅ | ❌ | ❌ | - |

---

### 3.2 特色功能

| 功能 | ChromaDB | Qdrant | Milvus | Weaviate |
|------|----------|--------|--------|----------|
| **混合搜索** | ❌ | ✅ | ✅ | ✅ |
| **GPU加速** | ❌ | ❌ | ✅ | ❌ |
| **分布式** | ❌ | 有限 | ✅ | 有限 |
| **过滤查询** | ✅ | ✅ | ✅ | ✅ |
| **GraphQL** | ❌ | ❌ | ❌ | ✅ |
| **内置Embedding** | ✅ | ❌ | ❌ | ✅ |

---

## 4. 部署对比

### 4.1 部署难度

**ChromaDB**：
```bash
# 零配置
pip install chromadb
# 直接使用，无需启动服务
```

**Qdrant**：
```bash
# Docker部署
docker run -p 6333:6333 qdrant/qdrant
```

**Milvus**：
```bash
# Docker Compose部署
wget https://github.com/milvus-io/milvus/releases/download/v2.5.0/milvus-standalone-docker-compose.yml -O docker-compose.yml
docker-compose up -d
```

**Weaviate**：
```bash
# Docker部署
docker run -p 8080:8080 semitechnologies/weaviate:latest
```

---

### 4.2 运维复杂度

| 数据库 | 部署 | 监控 | 扩展 | 备份 |
|--------|------|------|------|------|
| **ChromaDB** | ⭐ | ⭐ | ⭐ | ⭐ |
| **Qdrant** | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ |
| **Milvus** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **Weaviate** | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ |

---

## 5. 生态集成

### 5.1 LangChain集成

**所有数据库都支持LangChain**：
```python
from langchain.vectorstores import Chroma, Qdrant, Milvus, Weaviate

# ChromaDB
vectorstore = Chroma(persist_directory="./chroma_db")

# Qdrant
vectorstore = Qdrant(client=qdrant_client, collection_name="docs")

# Milvus
vectorstore = Milvus(collection_name="docs", connection_args={"host": "localhost"})

# Weaviate
vectorstore = Weaviate(client=weaviate_client, index_name="Document")
```

---

### 5.2 云服务支持

| 数据库 | 云服务 | 托管方案 |
|--------|--------|---------|
| **ChromaDB** | ❌ | 自托管 |
| **Qdrant** | ✅ | Qdrant Cloud |
| **Milvus** | ✅ | Zilliz Cloud |
| **Weaviate** | ✅ | Weaviate Cloud |

---

## 6. 选择决策树

```
数据规模？
├─ <10万 → ChromaDB（零配置）
├─ 10万-100万
│   ├─ 需要混合搜索？
│   │   ├─ 是 → Weaviate
│   │   └─ 否 → Qdrant
├─ 100万-1000万
│   ├─ 需要高性能过滤？
│   │   ├─ 是 → Qdrant
│   │   └─ 否 → Milvus
└─ >1000万 → Milvus（分布式）
```

---

## 7. 实际案例

### 7.1 个人知识库（ChromaDB）

```python
import chromadb
from openai import OpenAI

client = OpenAI()
chroma_client = chromadb.PersistentClient(path="./knowledge_base")
collection = chroma_client.get_or_create_collection("notes")

# 添加笔记
def add_note(text):
    embedding = client.embeddings.create(
        input=text,
        model="text-embedding-3-small"
    ).data[0].embedding

    collection.add(
        documents=[text],
        embeddings=[embedding],
        ids=[str(hash(text))]
    )

# 搜索笔记
def search_notes(query):
    query_embedding = client.embeddings.create(
        input=query,
        model="text-embedding-3-small"
    ).data[0].embedding

    results = collection.query(
        query_embeddings=[query_embedding],
        n_results=5
    )

    return results['documents'][0]
```

---

### 7.2 企业文档库（Qdrant）

```python
from qdrant_client import QdrantClient
from qdrant_client.models import Distance, VectorParams, PointStruct

client = QdrantClient(host="localhost", port=6333)

# 创建集合
client.create_collection(
    collection_name="enterprise_docs",
    vectors_config=VectorParams(size=1536, distance=Distance.COSINE)
)

# 批量插入
points = [
    PointStruct(
        id=i,
        vector=embedding,
        payload={"text": text, "category": category}
    )
    for i, (embedding, text, category) in enumerate(documents)
]

client.upsert(collection_name="enterprise_docs", points=points)

# 过滤查询
results = client.search(
    collection_name="enterprise_docs",
    query_vector=query_embedding,
    query_filter={"category": "tech"},
    limit=10
)
```

---

### 7.3 大规模推荐（Milvus）

```python
from pymilvus import connections, Collection

connections.connect(host="localhost", port="19530")
collection = Collection("products")

# 创建IVF-PQ索引
index_params = {
    "metric_type": "COSINE",
    "index_type": "IVF_PQ",
    "params": {"nlist": 2048, "m": 8, "nbits": 8}
}
collection.create_index(field_name="embedding", index_params=index_params)

# 批量查询
collection.load()
results = collection.search(
    data=user_embeddings,  # 批量查询
    anns_field="embedding",
    param={"metric_type": "COSINE", "params": {"nprobe": 16}},
    limit=20
)
```

---

## 8. 2025-2026趋势

### 8.1 性能优化

- **Qdrant**：Rust性能持续优化
- **Milvus**：GPU加速、DiskANN集成
- **Weaviate**：混合搜索优化

---

### 8.2 新功能

- **多模态支持**：文本、图片、音频统一检索
- **流式更新**：实时索引更新
- **边缘部署**：轻量化版本

---

## 总结

### 核心要点

1. **ChromaDB**：零配置，适合原型
2. **Qdrant**：高性能，适合中型生产
3. **Milvus**：大规模，适合企业级
4. **Weaviate**：混合搜索，适合特定场景

### 选择建议

| 场景 | 推荐 | 原因 |
|------|------|------|
| 个人项目 | ChromaDB | 零配置 |
| 中型生产 | Qdrant | 高性能 |
| 大规模 | Milvus | 分布式 |
| 混合搜索 | Weaviate | 特色功能 |

### 下一步

学习 `03_核心概念_10_混合检索策略.md`，了解混合检索。
