# 核心概念 5：类型推断机制

## 一句话定义

**类型推断是类型检查器根据代码上下文自动推导变量和表达式类型的机制，让开发者无需显式标注所有类型，同时保持类型安全，是 Python 类型系统的核心特性。**

---

## 为什么需要类型推断？

### 问题：显式类型注解的冗余

如果所有类型都需要显式标注，代码会变得冗长：

```python
# ❌ 过度注解（冗余）
x: int = 42
y: int = x + 10
z: int = y * 2
result: int = z - 5

name: str = "Alice"
greeting: str = f"Hello, {name}"
upper_greeting: str = greeting.upper()
```

**类型推断的解决方案**：

```python
# ✅ 类型推断（简洁）
x = 42  # 推断为 int
y = x + 10  # 推断为 int
z = y * 2  # 推断为 int
result = z - 5  # 推断为 int

name = "Alice"  # 推断为 str
greeting = f"Hello, {name}"  # 推断为 str
upper_greeting = greeting.upper()  # 推断为 str
```

**好处**：
- ✅ 代码更简洁
- ✅ 保持类型安全
- ✅ 减少维护成本
- ✅ 类型检查器自动验证

---

## 类型推断的基本规则

### 1. 字面量推断

```python
# 整数字面量
x = 42  # 推断为 int

# 浮点数字面量
y = 3.14  # 推断为 float

# 字符串字面量
name = "Alice"  # 推断为 str

# 布尔字面量
flag = True  # 推断为 bool

# 列表字面量
numbers = [1, 2, 3]  # 推断为 list[int]
mixed = [1, "two", 3.0]  # 推断为 list[int | str | float]

# 字典字面量
data = {"name": "Alice", "age": 30}  # 推断为 dict[str, str | int]

# 元组字面量
point = (10, 20)  # 推断为 tuple[int, int]
```

### 2. 表达式推断

```python
# 算术运算
a = 10
b = 20
c = a + b  # 推断为 int

# 字符串操作
text = "hello"
upper = text.upper()  # 推断为 str

# 列表操作
numbers = [1, 2, 3]
first = numbers[0]  # 推断为 int
```

### 3. 函数返回值推断

```python
# 函数有类型注解
def add(a: int, b: int) -> int:
    return a + b

result = add(10, 20)  # 推断为 int

# 函数无类型注解（推断为 Any）
def process(x):
    return x.upper()

output = process("hello")  # 推断为 Any（不安全）
```

### 4. 泛型推断

```python
from typing import TypeVar, Generic

T = TypeVar('T')

class Box(Generic[T]):
    def __init__(self, value: T):
        self.value = value

    def get(self) -> T:
        return self.value

# 泛型推断
int_box = Box(42)  # 推断为 Box[int]
value = int_box.get()  # 推断为 int

str_box = Box("hello")  # 推断为 Box[str]
text = str_box.get()  # 推断为 str
```

---

## mypy 的类型推断

### 1. 基础推断

```python
# mypy 推断示例
x = 42  # mypy 推断为 int
y = x + 10  # mypy 推断为 int

def double(n: int) -> int:
    return n * 2

result = double(x)  # mypy 推断为 int
```

### 2. 推断失败的情况

```python
# 空容器推断失败
empty_list = []  # mypy 推断为 list[Any]
empty_dict = {}  # mypy 推断为 dict[Any, Any]

# ✅ 显式类型注解
empty_list: list[int] = []
empty_dict: dict[str, int] = {}

# 或者通过使用推断类型
numbers = [1, 2, 3]  # 推断为 list[int]
more_numbers = []  # 推断为 list[int]（如果后续添加 int）
more_numbers.append(4)
```

### 3. 条件分支推断

```python
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    if user_id > 0:
        return f"User {user_id}"
    return None

# mypy 推断
user = find_user(1)  # 推断为 str | None

if user is not None:
    # mypy 知道这里 user 是 str
    print(user.upper())  # ✅ 类型正确
```

### 4. 类型收窄（Type Narrowing）

```python
from typing import Union

def process(value: Union[int, str]) -> str:
    if isinstance(value, int):
        # mypy 知道这里 value 是 int
        return str(value * 2)
    else:
        # mypy 知道这里 value 是 str
        return value.upper()
```

---

## pyright 的类型推断

### 1. 更强的推断能力

pyright 通常比 mypy 有更强的类型推断能力：

```python
# pyright 可以推断更复杂的类型
def get_value():
    return {"name": "Alice", "age": 30}

data = get_value()
# pyright 推断为 dict[str, str | int]
# mypy 可能推断为 dict[str, Any]

name = data["name"]
# pyright 推断为 str | int
# mypy 推断为 Any
```

### 2. 泛型推断

```python
from typing import TypeVar, Callable

T = TypeVar('T')

def map_list(items: list[T], fn: Callable[[T], T]) -> list[T]:
    return [fn(item) for item in items]

# pyright 推断
numbers = [1, 2, 3]
doubled = map_list(numbers, lambda x: x * 2)
# pyright 推断为 list[int]

# mypy 也能推断，但 pyright 更准确
```

### 3. 推断配置

```json
// pyrightconfig.json
{
  "typeCheckingMode": "strict",
  "reportUnknownVariableType": true,
  "reportUnknownMemberType": true
}
```

---

## LangChain 中的类型推断

### 1. Runnable 类型推断

```python
from langchain_core.runnables import RunnableLambda

# 定义类型明确的函数
def to_upper(text: str) -> str:
    return text.upper()

def count_words(text: str) -> int:
    return len(text.split())

# 类型推断
upper_runnable = RunnableLambda(to_upper)
# 推断为：Runnable[str, str]

counter_runnable = RunnableLambda(count_words)
# 推断为：Runnable[str, int]

# 组合时自动推断
chain = upper_runnable | counter_runnable
# 推断为：Runnable[str, int]
```

### 2. LCEL 管道推断

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_openai import ChatOpenAI

# 每个组件的类型都会被推断
prompt = ChatPromptTemplate.from_template("Tell me about {topic}")
# 推断为：Runnable[dict, PromptValue]

model = ChatOpenAI(model="gpt-4o-mini")
# 推断为：Runnable[PromptValue, AIMessage]

parser = StrOutputParser()
# 推断为：Runnable[AIMessage, str]

# 组合时自动推断整个链的类型
chain = prompt | model | parser
# 推断为：Runnable[dict, str]
```

### 3. input_schema 和 output_schema

LangChain 的 Runnable 提供了 `input_schema` 和 `output_schema` 属性，用于运行时类型检查：

```python
from langchain_core.runnables import RunnableLambda
from pydantic import BaseModel

class UserInput(BaseModel):
    name: str
    age: int

class UserOutput(BaseModel):
    greeting: str

def greet_user(input: UserInput) -> UserOutput:
    return UserOutput(greeting=f"Hello, {input.name}!")

# 创建 Runnable
runnable = RunnableLambda(greet_user)

# 自动生成 schema
print(runnable.input_schema)
# <class 'UserInput'>

print(runnable.output_schema)
# <class 'UserOutput'>

# 运行时验证
try:
    runnable.invoke({"name": "Alice"})  # ❌ 缺少 age 字段
except Exception as e:
    print(f"Validation error: {e}")
```

---

## 类型推断的最佳实践

### 1. 何时需要显式类型注解

```python
# ✅ 函数签名必须注解
def process(data: dict[str, Any]) -> list[str]:
    result = []  # 局部变量可以推断
    for key, value in data.items():
        result.append(str(value))
    return result

# ✅ 空容器需要注解
empty_list: list[int] = []
empty_dict: dict[str, str] = {}

# ✅ 类属性需要注解
class User:
    name: str
    age: int

    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

# ❌ 局部变量不需要注解（可推断）
def calculate():
    x = 42  # 不需要注解
    y = x * 2  # 不需要注解
    return y
```

### 2. 利用类型推断简化代码

```python
# ❌ 过度注解
def process_data(items: list[str]) -> list[int]:
    result: list[int] = []
    for item: str in items:
        length: int = len(item)
        result.append(length)
    return result

# ✅ 利用推断
def process_data(items: list[str]) -> list[int]:
    result = []  # 推断为 list[int]
    for item in items:  # 推断为 str
        length = len(item)  # 推断为 int
        result.append(length)
    return result
```

### 3. 使用 reveal_type 调试推断

```python
# mypy 调试工具
from typing import reveal_type

x = 42
reveal_type(x)  # mypy 输出：Revealed type is "builtins.int"

numbers = [1, 2, 3]
reveal_type(numbers)  # Revealed type is "builtins.list[builtins.int]"

# pyright 使用相同的方式
```

---

## 类型推断的局限性

### 1. 动态代码推断失败

```python
# 动态属性访问
def get_attr(obj, name):
    return getattr(obj, name)

# 类型检查器无法推断返回类型
result = get_attr(some_object, "some_attr")  # 推断为 Any

# ✅ 使用泛型改进
from typing import TypeVar

T = TypeVar('T')

def get_attr(obj: T, name: str) -> Any:
    return getattr(obj, name)
```

### 2. 复杂泛型推断

```python
from typing import TypeVar, Callable

T = TypeVar('T')
U = TypeVar('U')

def compose(f: Callable[[T], U], g: Callable[[U], V]) -> Callable[[T], V]:
    return lambda x: g(f(x))

# 类型检查器可能无法完全推断
result = compose(str, len)  # 推断可能不准确
```

### 3. 第三方库类型缺失

```python
# 第三方库没有类型注解
import some_library

result = some_library.process(data)  # 推断为 Any

# ✅ 使用 type stubs
# 安装 types-some-library
# pip install types-some-library
```

---

## mypy vs pyright 推断对比

### 对比表

| 特性 | mypy | pyright |
|------|------|---------|
| 基础推断 | ✅ 良好 | ✅ 优秀 |
| 泛型推断 | ✅ 良好 | ✅ 更强 |
| 类型收窄 | ✅ 支持 | ✅ 更准确 |
| 推断速度 | 中等 | 快（3-5倍） |
| 错误提示 | 详细 | 更详细 |
| 配置复杂度 | 中等 | 简单 |
| 2025-2026 推荐 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

### 实际对比示例

```python
from typing import Union

def process(value: Union[int, str, None]) -> str:
    if value is None:
        return "None"
    elif isinstance(value, int):
        return str(value * 2)
    else:
        return value.upper()

# mypy 推断
# - 第一个分支：value 是 None
# - 第二个分支：value 是 int
# - 第三个分支：value 是 str

# pyright 推断（更准确）
# - 第一个分支：value 是 None
# - 第二个分支：value 是 int
# - 第三个分支：value 是 str（排除了 None 和 int）
```

---

## 实战示例：类型推断在 LangChain 中的应用

```python
"""
类型推断在 LangChain 中的应用
演示：如何利用类型推断构建类型安全的管道
"""

from langchain_core.runnables import RunnableLambda, RunnableParallel
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_openai import ChatOpenAI

# ===== 1. 定义类型明确的函数 =====

def format_query(topic: str) -> dict:
    """格式化查询（类型推断：str -> dict）"""
    return {"topic": topic, "style": "concise"}

def extract_topic(data: dict) -> str:
    """提取主题（类型推断：dict -> str）"""
    return data["topic"]

def count_words(text: str) -> int:
    """计数单词（类型推断：str -> int）"""
    return len(text.split())

def format_result(count: int) -> str:
    """格式化结果（类型推断：int -> str）"""
    return f"Word count: {count}"

# ===== 2. 构建 Runnable（自动推断类型）=====

# 每个 Runnable 的类型都会被自动推断
formatter = RunnableLambda(format_query)
# 推断为：Runnable[str, dict]

extractor = RunnableLambda(extract_topic)
# 推断为：Runnable[dict, str]

counter = RunnableLambda(count_words)
# 推断为：Runnable[str, int]

result_formatter = RunnableLambda(format_result)
# 推断为：Runnable[int, str]

# ===== 3. 组合管道（类型自动验证）=====

# 简单链
simple_chain = formatter | extractor
# 推断为：Runnable[str, str]

# 完整链
full_chain = formatter | extractor | counter | result_formatter
# 推断为：Runnable[str, str]

# ===== 4. 并行组合（类型推断）=====

parallel = RunnableParallel(
    original=extractor,
    word_count=extractor | counter,
    formatted=extractor | counter | result_formatter
)
# 推断为：Runnable[dict, dict[str, str | int]]

# ===== 5. 使用 LangChain 组件（类型推断）=====

prompt = ChatPromptTemplate.from_template("Explain {topic} in one sentence")
# 推断为：Runnable[dict, PromptValue]

model = ChatOpenAI(model="gpt-4o-mini")
# 推断为：Runnable[PromptValue, AIMessage]

parser = StrOutputParser()
# 推断为：Runnable[AIMessage, str]

# 完整的 LLM 链
llm_chain = prompt | model | parser
# 推断为：Runnable[dict, str]

# ===== 6. 组合所有组件 =====

# 最终管道：str -> dict -> str
final_chain = formatter | llm_chain
# 推断为：Runnable[str, str]

# ===== 7. 使用管道 =====

print("=== 类型推断示例 ===\n")

# 使用简单链
result = simple_chain.invoke("Python")
print(f"Simple chain result: {result}")
print(f"Type: {type(result)}\n")

# 使用完整链
result = full_chain.invoke("Python")
print(f"Full chain result: {result}")
print(f"Type: {type(result)}\n")

# 使用并行链
result = parallel.invoke({"topic": "Python", "style": "concise"})
print(f"Parallel result: {result}")
print(f"Type: {type(result)}\n")

# 使用 LLM 链
result = final_chain.invoke("Python")
print(f"LLM chain result: {result}")
print(f"Type: {type(result)}")

# ===== 8. 类型检查验证 =====

# ✅ 类型正确（编译时验证）
output: str = final_chain.invoke("Python")

# ❌ 类型错误（编译时发现）
# output: int = final_chain.invoke("Python")
# 类型检查器报错：Cannot assign str to int

# ❌ 输入类型错误
# output = final_chain.invoke(42)
# 类型检查器报错：Argument of type "int" cannot be assigned to parameter of type "str"
```

**运行输出**：
```
=== 类型推断示例 ===

Simple chain result: Python
Type: <class 'str'>

Full chain result: Word count: 6
Type: <class 'str'>

Parallel result: {'original': 'Python', 'word_count': 6, 'formatted': 'Word count: 6'}
Type: <class 'dict'>

LLM chain result: Python is a high-level, interpreted programming language known for its simplicity and readability.
Type: <class 'str'>
```

---

## 2025-2026 最佳实践

### 1. 优先使用 pyright

```bash
# pyright 推断更准确，速度更快
uv run pyright src/

# mypy 作为备选
uv run mypy src/
```

### 2. 配置严格模式

```json
// pyrightconfig.json
{
  "typeCheckingMode": "strict",
  "reportUnknownVariableType": true,
  "reportUnknownMemberType": true,
  "reportUnknownArgumentType": true
}
```

```ini
# mypy.ini
[mypy]
strict = True
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
```

### 3. 使用 reveal_type 调试

```python
from typing import reveal_type

# 调试类型推断
x = [1, 2, 3]
reveal_type(x)  # 查看推断的类型

chain = prompt | model | parser
reveal_type(chain)  # 查看链的类型
```

### 4. 渐进式类型注解

```python
# 优先给公共 API 加类型注解
def public_api(input: str) -> dict[str, Any]:
    # 内部变量可以依赖推断
    result = {}
    processed = _internal_process(input)
    result["data"] = processed
    return result

# 内部函数可以逐步添加
def _internal_process(input):
    return input.strip().lower()
```

---

## 常见陷阱

### 1. 过度依赖推断

```python
# ❌ 空容器推断失败
empty_list = []  # 推断为 list[Any]
empty_list.append("hello")  # 类型不安全

# ✅ 显式注解
empty_list: list[str] = []
empty_list.append("hello")  # 类型安全
```

### 2. 忽略推断警告

```python
# ⚠️ 类型检查器警告
def process(x):  # 警告：Missing type annotation
    return x.upper()

# ✅ 添加类型注解
def process(x: str) -> str:
    return x.upper()
```

### 3. 混淆推断和运行时检查

```python
# ❌ 类型推断不是运行时检查
def add(a: int, b: int) -> int:
    return a + b

result = add("hello", "world")  # 运行时不会报错！

# ✅ 需要显式运行时检查
def add(a: int, b: int) -> int:
    if not isinstance(a, int) or not isinstance(b, int):
        raise TypeError("Arguments must be integers")
    return a + b
```

---

## 学习检查清单

- [ ] 理解类型推断的作用和好处
- [ ] 掌握基本的类型推断规则
- [ ] 了解 mypy 和 pyright 的推断差异
- [ ] 知道何时需要显式类型注解
- [ ] 理解 LangChain 中的类型推断
- [ ] 掌握 input_schema 和 output_schema
- [ ] 能够使用 reveal_type 调试推断
- [ ] 遵循 2025-2026 最佳实践

---

## 下一步学习

- **核心概念 9**：mypy 与 pyright - 深入学习类型检查工具
- **核心概念 4**：Runnable 泛型设计 - 复习 LangChain 类型系统
- **核心概念 8**：类型守卫 - 学习类型收窄技术

---

## 参考资源

1. [Python typing 官方文档](https://docs.python.org/3/library/typing.html) - 类型推断规范
2. [mypy 类型推断文档](https://mypy.readthedocs.io/en/stable/type_inference_and_annotations.html)
3. [pyright 类型推断文档](https://github.com/microsoft/pyright/blob/main/docs/type-concepts.md)
4. [Mypy vs pyright in practice](https://discuss.python.org/t/mypy-vs-pyright-in-practice/75984) - 2025 讨论
5. [LangChain Runnables 文档](https://reference.langchain.com/python/langchain_core/runnables) - 类型推断应用
