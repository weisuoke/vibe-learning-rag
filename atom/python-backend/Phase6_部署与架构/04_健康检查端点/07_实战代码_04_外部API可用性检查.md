# å®æˆ˜ä»£ç 4ï¼šå¤–éƒ¨APIå¯ç”¨æ€§æ£€æŸ¥

> HTTP å®¢æˆ·ç«¯å¥åº·æ£€æŸ¥çš„å®Œæ•´å®ç°

---

## æ¦‚è¿°

æœ¬æ–‡æä¾›å¤–éƒ¨ API å¯ç”¨æ€§æ£€æŸ¥çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬ï¼š
- HTTP è¿æ¥æ£€æŸ¥
- æœ€å°è¯·æ±‚æ£€æŸ¥
- è¶…æ—¶ä¸é‡è¯•æœºåˆ¶
- ç†”æ–­å™¨æ¨¡å¼
- å®Œæ•´çš„å¤–éƒ¨ API å¥åº·æ£€æŸ¥å™¨

---

## å®Œæ•´ä»£ç 

```python
"""
å¤–éƒ¨ API å¯ç”¨æ€§æ£€æŸ¥å®ç°
æ¼”ç¤ºï¼šHTTP å®¢æˆ·ç«¯å¥åº·æ£€æŸ¥
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Optional
import httpx
import asyncio
import time
from datetime import datetime, timedelta

# ===== 1. FastAPI åº”ç”¨ =====

app = FastAPI(title="External API Health Check")

# ===== 2. å“åº”æ¨¡å‹ =====

class APIHealthResponse(BaseModel):
    """API å¥åº·æ£€æŸ¥å“åº”"""
    healthy: bool
    duration_ms: int
    status_code: Optional[int] = None
    error: Optional[str] = None

# ===== 3. ç®€å•è¿æ¥æ£€æŸ¥ =====

async def check_api_connection(url: str) -> bool:
    """
    ç®€å•çš„ API è¿æ¥æ£€æŸ¥

    åªæ£€æŸ¥èƒ½å¦è¿æ¥åˆ° API
    """
    try:
        async with httpx.AsyncClient() as client:
            response = await asyncio.wait_for(
                client.head(url),
                timeout=3.0
            )
            return response.status_code < 500
    except Exception as e:
        print(f"âŒ API connection check failed: {e}")
        return False

@app.get("/health/api/connection")
async def health_api_connection():
    """ç®€å•çš„ API è¿æ¥æ£€æŸ¥"""
    start_time = time.time()

    # æ£€æŸ¥ç¤ºä¾‹ API
    url = "https://api.github.com"
    healthy = await check_api_connection(url)

    duration_ms = int((time.time() - start_time) * 1000)

    if not healthy:
        raise HTTPException(503, f"API {url} unavailable")

    return {
        "healthy": healthy,
        "duration_ms": duration_ms,
        "url": url
    }

# ===== 4. æœ€å°è¯·æ±‚æ£€æŸ¥ =====

async def check_api_minimal_request(url: str) -> APIHealthResponse:
    """
    æœ€å°è¯·æ±‚æ£€æŸ¥

    å‘é€ä¸€ä¸ªæœ€å°çš„è¯·æ±‚æ¥æ£€æŸ¥ API åŠŸèƒ½
    """
    start_time = time.time()

    try:
        async with httpx.AsyncClient() as client:
            response = await asyncio.wait_for(
                client.get(url),
                timeout=5.0
            )

            duration_ms = int((time.time() - start_time) * 1000)

            # åˆ¤æ–­å¥åº·çŠ¶æ€
            healthy = response.status_code < 500

            return APIHealthResponse(
                healthy=healthy,
                duration_ms=duration_ms,
                status_code=response.status_code
            )

    except asyncio.TimeoutError:
        duration_ms = int((time.time() - start_time) * 1000)
        return APIHealthResponse(
            healthy=False,
            duration_ms=duration_ms,
            error="Request timeout"
        )
    except Exception as e:
        duration_ms = int((time.time() - start_time) * 1000)
        return APIHealthResponse(
            healthy=False,
            duration_ms=duration_ms,
            error=str(e)
        )

@app.get("/health/api/minimal", response_model=APIHealthResponse)
async def health_api_minimal():
    """æœ€å°è¯·æ±‚æ£€æŸ¥"""
    url = "https://api.github.com"
    result = await check_api_minimal_request(url)

    if not result.healthy:
        raise HTTPException(503, detail=result.dict())

    return result

# ===== 5. å¸¦é‡è¯•çš„å¥åº·æ£€æŸ¥ =====

async def check_api_with_retry(
    url: str,
    max_retries: int = 2,
    retry_delay: float = 0.5
) -> APIHealthResponse:
    """
    å¸¦é‡è¯•çš„ API å¥åº·æ£€æŸ¥

    å¦‚æœç¬¬ä¸€æ¬¡å¤±è´¥ï¼Œä¼šé‡è¯•æŒ‡å®šæ¬¡æ•°
    """
    for attempt in range(max_retries + 1):
        start_time = time.time()

        try:
            async with httpx.AsyncClient() as client:
                response = await asyncio.wait_for(
                    client.head(url),
                    timeout=3.0
                )

            duration_ms = int((time.time() - start_time) * 1000)

            return APIHealthResponse(
                healthy=response.status_code < 500,
                duration_ms=duration_ms,
                status_code=response.status_code
            )

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)

            if attempt < max_retries:
                # é‡è¯•å‰ç­‰å¾…
                print(f"âš ï¸  API check failed (attempt {attempt + 1}/{max_retries + 1}), retrying...")
                await asyncio.sleep(retry_delay)
            else:
                # æœ€åä¸€æ¬¡é‡è¯•å¤±è´¥
                print(f"âŒ API check failed after {max_retries + 1} attempts")
                return APIHealthResponse(
                    healthy=False,
                    duration_ms=duration_ms,
                    error=str(e)
                )

@app.get("/health/api/retry", response_model=APIHealthResponse)
async def health_api_retry():
    """å¸¦é‡è¯•çš„ API å¥åº·æ£€æŸ¥"""
    url = "https://api.github.com"
    result = await check_api_with_retry(url, max_retries=2, retry_delay=0.5)

    if not result.healthy:
        raise HTTPException(503, detail=result.dict())

    return result

# ===== 6. ç†”æ–­å™¨æ¨¡å¼ =====

class CircuitBreaker:
    """
    ç†”æ–­å™¨æ¨¡å¼

    å½“è¿ç»­å¤±è´¥æ¬¡æ•°è¶…è¿‡é˜ˆå€¼æ—¶ï¼Œæ‰“å¼€ç†”æ–­å™¨ï¼Œå¿«é€Ÿå¤±è´¥
    """

    def __init__(
        self,
        failure_threshold: int = 5,
        timeout: int = 60,
        half_open_timeout: int = 30
    ):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.half_open_timeout = half_open_timeout

        self.failure_count = 0
        self.last_failure_time = None
        self.state = "closed"  # closed, open, half_open

    async def call(self, func, *args, **kwargs):
        """
        é€šè¿‡ç†”æ–­å™¨è°ƒç”¨å‡½æ•°

        Args:
            func: è¦è°ƒç”¨çš„å‡½æ•°
            *args: å‡½æ•°å‚æ•°
            **kwargs: å‡½æ•°å…³é”®å­—å‚æ•°

        Returns:
            å‡½æ•°è¿”å›å€¼

        Raises:
            Exception: å¦‚æœç†”æ–­å™¨æ‰“å¼€æˆ–å‡½æ•°è°ƒç”¨å¤±è´¥
        """
        # å¦‚æœç†”æ–­å™¨æ‰“å¼€
        if self.state == "open":
            # æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›å…¥åŠå¼€çŠ¶æ€
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "half_open"
                print("ğŸ”„ Circuit breaker entering half-open state")
            else:
                # å¿«é€Ÿå¤±è´¥
                raise Exception("Circuit breaker is open")

        try:
            # è°ƒç”¨å‡½æ•°
            result = await func(*args, **kwargs)

            # å¦‚æœæ˜¯åŠå¼€çŠ¶æ€ï¼Œæ¢å¤åˆ°å…³é—­çŠ¶æ€
            if self.state == "half_open":
                self.state = "closed"
                self.failure_count = 0
                print("âœ… Circuit breaker closed")

            return result

        except Exception as e:
            # è®°å½•å¤±è´¥
            self.failure_count += 1
            self.last_failure_time = time.time()

            # å¦‚æœè¿ç»­å¤±è´¥æ¬¡æ•°è¶…è¿‡é˜ˆå€¼ï¼Œæ‰“å¼€ç†”æ–­å™¨
            if self.failure_count >= self.failure_threshold:
                self.state = "open"
                print(f"âš ï¸  Circuit breaker opened after {self.failure_count} failures")

            raise e

    def get_state(self) -> Dict:
        """è·å–ç†”æ–­å™¨çŠ¶æ€"""
        return {
            "state": self.state,
            "failure_count": self.failure_count,
            "last_failure_time": self.last_failure_time
        }

# åˆ›å»ºç†”æ–­å™¨å®ä¾‹
api_breaker = CircuitBreaker(failure_threshold=5, timeout=60)

async def check_api_with_breaker(url: str) -> APIHealthResponse:
    """
    ä½¿ç”¨ç†”æ–­å™¨æ£€æŸ¥ API

    å¦‚æœç†”æ–­å™¨æ‰“å¼€ï¼Œå¿«é€Ÿå¤±è´¥
    """
    start_time = time.time()

    try:
        # é€šè¿‡ç†”æ–­å™¨è°ƒç”¨
        async def _check():
            async with httpx.AsyncClient() as client:
                response = await asyncio.wait_for(
                    client.head(url),
                    timeout=3.0
                )
                if response.status_code >= 500:
                    raise Exception(f"API returned {response.status_code}")
                return response

        response = await api_breaker.call(_check)

        duration_ms = int((time.time() - start_time) * 1000)

        return APIHealthResponse(
            healthy=True,
            duration_ms=duration_ms,
            status_code=response.status_code
        )

    except Exception as e:
        duration_ms = int((time.time() - start_time) * 1000)
        return APIHealthResponse(
            healthy=False,
            duration_ms=duration_ms,
            error=str(e)
        )

@app.get("/health/api/breaker", response_model=APIHealthResponse)
async def health_api_breaker():
    """ä½¿ç”¨ç†”æ–­å™¨çš„ API å¥åº·æ£€æŸ¥"""
    url = "https://api.github.com"
    result = await check_api_with_breaker(url)

    if not result.healthy:
        raise HTTPException(503, detail=result.dict())

    return result

@app.get("/health/api/breaker/state")
async def health_api_breaker_state():
    """è·å–ç†”æ–­å™¨çŠ¶æ€"""
    return api_breaker.get_state()

# ===== 7. å®Œæ•´çš„å¤–éƒ¨ API å¥åº·æ£€æŸ¥å™¨ =====

class ExternalAPIHealthChecker:
    """å®Œæ•´çš„å¤–éƒ¨ API å¥åº·æ£€æŸ¥å™¨"""

    def __init__(self, url: str):
        self.url = url
        self.cache = {
            "last_check": 0,
            "result": None
        }
        self.cache_ttl = 300  # ç¼“å­˜ 5 åˆ†é’Ÿï¼ˆå¤–éƒ¨ API ç¼“å­˜æ—¶é—´æ›´é•¿ï¼‰
        self.breaker = CircuitBreaker(failure_threshold=5, timeout=60)

    async def check(self, use_cache: bool = True) -> APIHealthResponse:
        """
        æ‰§è¡Œå¤–éƒ¨ API å¥åº·æ£€æŸ¥

        Args:
            use_cache: æ˜¯å¦ä½¿ç”¨ç¼“å­˜

        Returns:
            APIHealthResponse: å¥åº·æ£€æŸ¥ç»“æœ
        """
        # æ£€æŸ¥ç¼“å­˜
        if use_cache and self.cache["result"]:
            now = time.time()
            if now - self.cache["last_check"] < self.cache_ttl:
                print("âœ… Using cached API health status")
                return self.cache["result"]

        print(f"ğŸ” Performing API health check: {self.url}")
        start_time = time.time()

        try:
            # é€šè¿‡ç†”æ–­å™¨è°ƒç”¨
            async def _check():
                async with httpx.AsyncClient() as client:
                    response = await asyncio.wait_for(
                        client.head(self.url),
                        timeout=3.0
                    )
                    if response.status_code >= 500:
                        raise Exception(f"API returned {response.status_code}")
                    return response

            response = await self.breaker.call(_check)

            duration_ms = int((time.time() - start_time) * 1000)

            result = APIHealthResponse(
                healthy=True,
                duration_ms=duration_ms,
                status_code=response.status_code
            )

            # æ›´æ–°ç¼“å­˜
            self.cache = {
                "last_check": time.time(),
                "result": result
            }

            return result

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            result = APIHealthResponse(
                healthy=False,
                duration_ms=duration_ms,
                error=str(e)
            )

            # ä¸ç¼“å­˜å¤±è´¥ç»“æœ
            return result

# åˆ›å»ºå…¨å±€å¥åº·æ£€æŸ¥å™¨
github_api_checker = ExternalAPIHealthChecker("https://api.github.com")

@app.get("/health/api/complete", response_model=APIHealthResponse)
async def health_api_complete():
    """å®Œæ•´çš„å¤–éƒ¨ API å¥åº·æ£€æŸ¥ï¼ˆå¸¦ç¼“å­˜å’Œç†”æ–­å™¨ï¼‰"""
    result = await github_api_checker.check(use_cache=True)

    if not result.healthy:
        raise HTTPException(503, detail=result.dict())

    return result

# ===== 8. å¤šä¸ªå¤–éƒ¨ API æ£€æŸ¥ =====

class MultiAPIHealthChecker:
    """å¤šä¸ªå¤–éƒ¨ API å¥åº·æ£€æŸ¥å™¨"""

    def __init__(self):
        self.apis = {}

    def register(self, name: str, url: str, critical: bool = False):
        """æ³¨å†Œå¤–éƒ¨ API"""
        self.apis[name] = {
            "checker": ExternalAPIHealthChecker(url),
            "critical": critical
        }

    async def check_all(self) -> Dict:
        """æ£€æŸ¥æ‰€æœ‰å¤–éƒ¨ API"""
        results = {}
        critical_failed = False

        for name, config in self.apis.items():
            try:
                result = await config["checker"].check(use_cache=True)
                results[name] = {
                    "healthy": result.healthy,
                    "duration_ms": result.duration_ms,
                    "status_code": result.status_code,
                    "error": result.error
                }

                # å¦‚æœæ˜¯æ ¸å¿ƒ API ä¸”å¤±è´¥
                if config["critical"] and not result.healthy:
                    critical_failed = True

            except Exception as e:
                results[name] = {
                    "healthy": False,
                    "error": str(e)
                }

                if config["critical"]:
                    critical_failed = True

        return {
            "results": results,
            "critical_failed": critical_failed
        }

# åˆ›å»ºå¤š API æ£€æŸ¥å™¨
multi_api_checker = MultiAPIHealthChecker()

# æ³¨å†Œå¤–éƒ¨ API
multi_api_checker.register("github", "https://api.github.com", critical=False)
multi_api_checker.register("httpbin", "https://httpbin.org", critical=False)

@app.get("/health/api/all")
async def health_api_all():
    """æ£€æŸ¥æ‰€æœ‰å¤–éƒ¨ API"""
    result = await multi_api_checker.check_all()

    if result["critical_failed"]:
        raise HTTPException(503, detail=result)

    return result

# ===== 9. å¯åŠ¨å’Œå…³é—­äº‹ä»¶ =====

@app.on_event("startup")
async def startup():
    """åº”ç”¨å¯åŠ¨"""
    print("ğŸš€ Starting application...")

    # æµ‹è¯•å¤–éƒ¨ API è¿æ¥
    try:
        result = await github_api_checker.check(use_cache=False)
        if result.healthy:
            print("âœ… GitHub API connection successful")
        else:
            print(f"âŒ GitHub API connection failed: {result.error}")
    except Exception as e:
        print(f"âŒ GitHub API connection failed: {e}")

@app.on_event("shutdown")
async def shutdown():
    """åº”ç”¨å…³é—­"""
    print("ğŸ‘‹ Shutting down application...")

# ===== 10. è¿è¡Œè¯´æ˜ =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("å¤–éƒ¨ API å¯ç”¨æ€§æ£€æŸ¥å®ç°")
    print("=" * 50)
    print()
    print("ç«¯ç‚¹ï¼š")
    print("  /health/api/connection  - ç®€å•è¿æ¥æ£€æŸ¥")
    print("  /health/api/minimal     - æœ€å°è¯·æ±‚æ£€æŸ¥")
    print("  /health/api/retry       - å¸¦é‡è¯•çš„æ£€æŸ¥")
    print("  /health/api/breaker     - ä½¿ç”¨ç†”æ–­å™¨çš„æ£€æŸ¥")
    print("  /health/api/breaker/state - ç†”æ–­å™¨çŠ¶æ€")
    print("  /health/api/complete    - å®Œæ•´æ£€æŸ¥ï¼ˆå¸¦ç¼“å­˜å’Œç†”æ–­å™¨ï¼‰")
    print("  /health/api/all         - æ£€æŸ¥æ‰€æœ‰å¤–éƒ¨ API")
    print()
    print("æµ‹è¯•å‘½ä»¤ï¼š")
    print("  curl http://localhost:8000/health/api/connection")
    print("  curl http://localhost:8000/health/api/complete")
    print("  curl http://localhost:8000/health/api/all")
    print()
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## è¿è¡Œç¤ºä¾‹

### 1. å®‰è£…ä¾èµ–

```bash
# ä½¿ç”¨ uv å®‰è£…ä¾èµ–
uv add fastapi uvicorn[standard] httpx
```

### 2. å¯åŠ¨æœåŠ¡

```bash
python main.py
```

### 3. æµ‹è¯•ç«¯ç‚¹

**ç®€å•è¿æ¥æ£€æŸ¥ï¼š**

```bash
curl http://localhost:8000/health/api/connection
```

**è¾“å‡ºï¼š**

```json
{
  "healthy": true,
  "duration_ms": 150,
  "url": "https://api.github.com"
}
```

**æœ€å°è¯·æ±‚æ£€æŸ¥ï¼š**

```bash
curl http://localhost:8000/health/api/minimal
```

**è¾“å‡ºï¼š**

```json
{
  "healthy": true,
  "duration_ms": 200,
  "status_code": 200,
  "error": null
}
```

**å¸¦é‡è¯•çš„æ£€æŸ¥ï¼š**

```bash
curl http://localhost:8000/health/api/retry
```

**ä½¿ç”¨ç†”æ–­å™¨çš„æ£€æŸ¥ï¼š**

```bash
curl http://localhost:8000/health/api/breaker
```

**ç†”æ–­å™¨çŠ¶æ€ï¼š**

```bash
curl http://localhost:8000/health/api/breaker/state
```

**è¾“å‡ºï¼š**

```json
{
  "state": "closed",
  "failure_count": 0,
  "last_failure_time": null
}
```

**å®Œæ•´æ£€æŸ¥ï¼š**

```bash
curl http://localhost:8000/health/api/complete
```

**æ£€æŸ¥æ‰€æœ‰å¤–éƒ¨ APIï¼š**

```bash
curl http://localhost:8000/health/api/all
```

**è¾“å‡ºï¼š**

```json
{
  "results": {
    "github": {
      "healthy": true,
      "duration_ms": 150,
      "status_code": 200,
      "error": null
    },
    "httpbin": {
      "healthy": true,
      "duration_ms": 120,
      "status_code": 200,
      "error": null
    }
  },
  "critical_failed": false
}
```

---

## å…³é”®è¦ç‚¹

### 1. è¿æ¥æ£€æŸ¥ vs æœ€å°è¯·æ±‚

**è¿æ¥æ£€æŸ¥ï¼ˆHEADï¼‰ï¼š**
- æœ€å¿«ï¼ˆ100-200msï¼‰
- åªæ£€æŸ¥è¿æ¥
- ä¸æ¶ˆè€—èµ„æº

**æœ€å°è¯·æ±‚ï¼ˆGETï¼‰ï¼š**
- è¾ƒæ…¢ï¼ˆ200-500msï¼‰
- æ£€æŸ¥å®Œæ•´åŠŸèƒ½
- æ›´å‡†ç¡®

### 2. è¶…æ—¶è®¾ç½®

```python
# å¤–éƒ¨ API è¶…æ—¶åº”è¯¥æ›´çŸ­
await asyncio.wait_for(
    client.head(url),
    timeout=3.0  # 3 ç§’è¶…æ—¶
)
```

### 3. é‡è¯•ç­–ç•¥

```python
# é‡è¯• 2 æ¬¡ï¼Œæ¯æ¬¡é—´éš” 0.5 ç§’
for attempt in range(3):
    try:
        result = await check_api()
        return result
    except Exception:
        if attempt < 2:
            await asyncio.sleep(0.5)
```

### 4. ç†”æ–­å™¨æ¨¡å¼

**çŠ¶æ€è½¬æ¢ï¼š**

```
closed (å…³é—­) â†’ open (æ‰“å¼€) â†’ half_open (åŠå¼€) â†’ closed
```

**å…³é”®å‚æ•°ï¼š**
- `failure_threshold`ï¼šè¿ç»­å¤±è´¥å¤šå°‘æ¬¡æ‰“å¼€ç†”æ–­å™¨
- `timeout`ï¼šç†”æ–­å™¨æ‰“å¼€å¤šä¹…åè¿›å…¥åŠå¼€çŠ¶æ€
- `half_open_timeout`ï¼šåŠå¼€çŠ¶æ€æŒç»­æ—¶é—´

### 5. ç¼“å­˜ç­–ç•¥

```python
# å¤–éƒ¨ API ç¼“å­˜æ—¶é—´æ›´é•¿ï¼ˆ5 åˆ†é’Ÿï¼‰
cache_ttl = 300
```

---

## åœ¨ AI Agent åç«¯ä¸­çš„åº”ç”¨

### LLM API å¥åº·æ£€æŸ¥

```python
class LLMAPIHealthChecker(ExternalAPIHealthChecker):
    """LLM API å¥åº·æ£€æŸ¥å™¨"""

    def __init__(self, api_key: str):
        super().__init__("https://api.openai.com")
        self.api_key = api_key

    async def check(self, use_cache: bool = True) -> APIHealthResponse:
        """æ£€æŸ¥ LLM API"""
        # ä½¿ç”¨ç¼“å­˜
        if use_cache and self.cache["result"]:
            now = time.time()
            if now - self.cache["last_check"] < self.cache_ttl:
                return self.cache["result"]

        start_time = time.time()

        try:
            # åªæ£€æŸ¥è¿æ¥ï¼Œä¸å‘é€çœŸå®è¯·æ±‚
            async with httpx.AsyncClient() as client:
                response = await asyncio.wait_for(
                    client.head(
                        self.url,
                        headers={"Authorization": f"Bearer {self.api_key}"}
                    ),
                    timeout=3.0
                )

            duration_ms = int((time.time() - start_time) * 1000)

            result = APIHealthResponse(
                healthy=response.status_code < 500,
                duration_ms=duration_ms,
                status_code=response.status_code
            )

            # æ›´æ–°ç¼“å­˜
            self.cache = {
                "last_check": time.time(),
                "result": result
            }

            return result

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            return APIHealthResponse(
                healthy=False,
                duration_ms=duration_ms,
                error=str(e)
            )
```

### æ¨èé…ç½®

```python
# LLM API ä½œä¸ºå¯é€‰ä¾èµ–
@app.get("/ready")
async def ready():
    checks = {
        "database": await check_database(),  # æ ¸å¿ƒä¾èµ–
        "llm_api": await check_llm_api(),    # å¯é€‰ä¾èµ–
    }

    # æ•°æ®åº“å¤±è´¥ â†’ ä¸å¯ç”¨
    if not checks["database"]:
        raise HTTPException(503, "Database unavailable")

    # LLM API å¤±è´¥ â†’ é™çº§ä½†å¯ç”¨
    if not checks["llm_api"]:
        return {
            "status": "degraded",
            "message": "LLM API unavailable, using cached responses",
            "checks": checks
        }

    return {"status": "healthy", "checks": checks}
```

---

## æ€»ç»“

å¤–éƒ¨ API å¯ç”¨æ€§æ£€æŸ¥çš„å…³é”®ï¼š

1. **è¿æ¥æ£€æŸ¥**ï¼šä½¿ç”¨ HEAD è¯·æ±‚å¿«é€Ÿæ£€æŸ¥
2. **è¶…æ—¶æœºåˆ¶**ï¼šè®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´ï¼ˆ3ç§’ï¼‰
3. **é‡è¯•ç­–ç•¥**ï¼šçŸ­æš‚æŠ–åŠ¨æ—¶é‡è¯•
4. **ç†”æ–­å™¨**ï¼šè¿ç»­å¤±è´¥æ—¶å¿«é€Ÿå¤±è´¥
5. **é•¿ç¼“å­˜**ï¼šå¤–éƒ¨ API ç¼“å­˜ 5 åˆ†é’Ÿ
6. **å¯é€‰ä¾èµ–**ï¼šå¤–éƒ¨ API å¤±è´¥æ—¶é™çº§è€Œéä¸å¯ç”¨

åœ¨ AI Agent åç«¯ä¸­ï¼Œå¤–éƒ¨ APIï¼ˆå¦‚ LLM APIï¼‰é€šå¸¸æ˜¯å¯é€‰ä¾èµ–ï¼Œå¤±è´¥æ—¶åº”è¯¥é™çº§è¿è¡Œï¼ˆä½¿ç”¨ç¼“å­˜å“åº”ï¼‰è€Œä¸æ˜¯å®Œå…¨ä¸å¯ç”¨ã€‚
