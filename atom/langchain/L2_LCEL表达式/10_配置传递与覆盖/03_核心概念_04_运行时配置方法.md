# 核心概念04：运行时配置方法

> **本节目标**: 掌握with_config()方法和RunnableBinding类的使用

---

## 一、with_config()方法

### 1.1 方法签名

```python
# langchain_core/runnables/base.py:500-550
def with_config(
    self,
    config: Optional[RunnableConfig] = None,
    **kwargs: Any
) -> Runnable:
    """
    返回绑定了配置的新Runnable

    参数:
        config: 要绑定的配置
        **kwargs: 额外的配置参数

    返回:
        RunnableBinding实例
    """
```

### 1.2 基本用法

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# 创建链
prompt = ChatPromptTemplate.from_template("Tell me about {topic}")
llm = ChatOpenAI()
chain = prompt | llm

# 绑定配置
chain_with_config = chain.with_config({
    "tags": ["production"],
    "max_concurrency": 5
})

# 使用绑定的配置
result = chain_with_config.invoke({"topic": "AI"})
# 自动使用tags=["production"], max_concurrency=5
```

### 1.3 配置参数

```python
# 方式1：使用config字典
chain_with_config = chain.with_config({
    "tags": ["test"],
    "metadata": {"user": "alice"}
})

# 方式2：使用kwargs
chain_with_config = chain.with_config(
    tags=["test"],
    metadata={"user": "alice"}
)

# 两种方式等价
```

---

## 二、RunnableBinding类

### 2.1 类定义

```python
# langchain_core/runnables/binding.py
class RunnableBinding(Runnable):
    """
    绑定配置到Runnable的包装器

    属性:
        bound: 被包装的Runnable
        config: 绑定的配置
        kwargs: 额外的参数
    """
    bound: Runnable
    config: RunnableConfig
    kwargs: Dict[str, Any]
```

### 2.2 工作原理

```python
# with_config内部实现
def with_config(self, config=None, **kwargs):
    return RunnableBinding(
        bound=self,
        config=config or {},
        kwargs=kwargs
    )

# RunnableBinding.invoke实现
def invoke(self, input, config=None):
    # 合并绑定的配置和调用时的配置
    merged_config = merge_configs(self.config, config)
    # 调用被包装的Runnable
    return self.bound.invoke(input, merged_config)
```

### 2.3 特性

1. **不可变性**: with_config()不修改原始Runnable
2. **延迟绑定**: 配置在invoke时才应用
3. **可组合**: 可以多次调用with_config()

```python
# 不可变性
original_chain = prompt | llm
configured_chain = original_chain.with_config({"tags": ["test"]})

# original_chain不受影响
result1 = original_chain.invoke(input)  # 无tags
result2 = configured_chain.invoke(input)  # 有tags=["test"]

# 可组合
chain1 = chain.with_config({"tags": ["base"]})
chain2 = chain1.with_config({"tags": ["extra"]})
# chain2使用tags=["base", "extra"]
```

---

## 三、延迟绑定 vs 急切绑定

### 3.1 延迟绑定（with_config）

```python
# 延迟绑定：配置在invoke时才应用
chain_with_config = chain.with_config({
    "tags": ["delayed"],
    "max_concurrency": 5
})

# 此时配置还未应用，只是创建了包装器
print(type(chain_with_config))  # RunnableBinding

# 配置在invoke时应用
result = chain_with_config.invoke(input)
```

**优势**:
- 轻量级：只创建包装器，不立即执行
- 灵活：可以在invoke时覆盖配置
- 可重用：同一个配置链可以多次使用

### 3.2 急切绑定（直接传递）

```python
# 急切绑定：配置立即应用
config = {"tags": ["eager"], "max_concurrency": 5}
result = chain.invoke(input, config=config)
# 配置立即应用到这次调用
```

**优势**:
- 简单：不需要创建中间对象
- 明确：配置只用于这次调用

### 3.3 选择建议

```python
# 使用with_config：配置需要重用
production_chain = chain.with_config({
    "tags": ["production"],
    "max_concurrency": 3
})
result1 = production_chain.invoke(input1)
result2 = production_chain.invoke(input2)

# 使用直接传递：配置只用一次
result = chain.invoke(input, config={
    "tags": ["one-time"],
    "metadata": {"request_id": "123"}
})
```

---

## 四、invoke时配置覆盖

### 4.1 配置合并规则

```python
# 绑定配置
chain_with_config = chain.with_config({
    "tags": ["bound"],
    "max_concurrency": 10,
    "metadata": {"env": "prod"}
})

# invoke时传递配置
result = chain_with_config.invoke(
    input,
    config={
        "tags": ["invoke"],
        "max_concurrency": 5,
        "metadata": {"user": "alice"}
    }
)

# 实际使用的配置：merge_configs(bound_config, invoke_config)
# {
#     "tags": ["bound", "invoke"],      # 连接
#     "max_concurrency": 5,             # invoke覆盖
#     "metadata": {                     # 合并
#         "env": "prod",
#         "user": "alice"
#     }
# }
```

### 4.2 优先级

invoke时的配置优先级更高：

```python
# 绑定max_concurrency=10
chain_with_config = chain.with_config({"max_concurrency": 10})

# invoke时覆盖为5
result = chain_with_config.invoke(input, config={"max_concurrency": 5})
# 实际使用5
```

### 4.3 部分覆盖

```python
# 只覆盖需要的字段
chain_with_config = chain.with_config({
    "tags": ["base"],
    "max_concurrency": 10,
    "recursion_limit": 25
})

# 只覆盖max_concurrency
result = chain_with_config.invoke(
    input,
    config={"max_concurrency": 5}
)
# tags和recursion_limit保持不变
```

---

## 五、batch操作中的配置

### 5.1 批处理配置

```python
# 为所有输入使用相同配置
chain_with_config = chain.with_config({
    "tags": ["batch"],
    "max_concurrency": 5
})

inputs = [{"topic": "AI"}, {"topic": "ML"}, {"topic": "DL"}]
results = chain_with_config.batch(inputs)
# 所有输入使用相同配置
```

### 5.2 每个输入不同配置

```python
# 为每个输入指定不同配置
inputs = [
    {"topic": "AI"},
    {"topic": "ML"},
    {"topic": "DL"}
]

configs = [
    {"tags": ["ai"], "metadata": {"priority": "high"}},
    {"tags": ["ml"], "metadata": {"priority": "medium"}},
    {"tags": ["dl"], "metadata": {"priority": "low"}}
]

results = chain.batch(inputs, config=configs)
# 每个输入使用对应的配置
```

### 5.3 批处理并发控制

```python
# 使用max_concurrency控制并发
chain_with_config = chain.with_config({"max_concurrency": 3})

# 批处理100个输入，最多同时处理3个
inputs = [{"topic": f"topic-{i}"} for i in range(100)]
results = chain_with_config.batch(inputs)
```

---

## 六、streaming操作中的配置

### 6.1 流式配置

```python
# 绑定配置
chain_with_config = chain.with_config({
    "tags": ["streaming"],
    "metadata": {"user": "alice"}
})

# 流式执行
for chunk in chain_with_config.stream(input):
    print(chunk)
    # 每个chunk使用相同配置
```

### 6.2 astream异步流式

```python
# 异步流式
chain_with_config = chain.with_config({
    "tags": ["async-streaming"],
    "max_concurrency": 5
})

async for chunk in chain_with_config.astream(input):
    print(chunk)
```

### 6.3 流式配置覆盖

```python
# 绑定基础配置
chain_with_config = chain.with_config({"tags": ["base"]})

# stream时覆盖
for chunk in chain_with_config.stream(
    input,
    config={"tags": ["override"], "metadata": {"session": "123"}}
):
    print(chunk)
# 使用tags=["base", "override"]
```

---

## 七、多次with_config

### 7.1 链式with_config

```python
# 多次调用with_config
chain1 = chain.with_config({"tags": ["layer1"]})
chain2 = chain1.with_config({"tags": ["layer2"]})
chain3 = chain2.with_config({"tags": ["layer3"]})

# 配置累积
result = chain3.invoke(input)
# 使用tags=["layer1", "layer2", "layer3"]
```

### 7.2 配置覆盖

```python
# 后来的配置覆盖前面的
chain1 = chain.with_config({"max_concurrency": 10})
chain2 = chain1.with_config({"max_concurrency": 5})

result = chain2.invoke(input)
# 使用max_concurrency=5
```

### 7.3 实际应用

```python
# 环境配置
env_chain = chain.with_config({
    "tags": ["production"],
    "max_concurrency": 3
})

# 功能配置
feature_chain = env_chain.with_config({
    "tags": ["chat"],
    "metadata": {"feature": "chat"}
})

# 用户配置
user_chain = feature_chain.with_config({
    "tags": ["user-123"],
    "metadata": {"user_id": "user-123"}
})

# 最终配置包含所有层级
result = user_chain.invoke(input)
```

---

## 八、实际应用场景

### 8.1 环境特定配置

```python
def get_chain_for_env(env: str):
    """根据环境返回配置好的链"""
    base_chain = prompt | llm | parser

    if env == "production":
        return base_chain.with_config({
            "tags": ["production"],
            "max_concurrency": 3,
            "recursion_limit": 10
        })
    elif env == "staging":
        return base_chain.with_config({
            "tags": ["staging"],
            "max_concurrency": 5,
            "recursion_limit": 25
        })
    else:  # development
        return base_chain.with_config({
            "tags": ["development"],
            "max_concurrency": 10,
            "recursion_limit": 50
        })

# 使用
prod_chain = get_chain_for_env("production")
result = prod_chain.invoke(input)
```

### 8.2 用户特定配置

```python
def get_user_chain(user_id: str, user_tier: str):
    """根据用户返回配置好的链"""
    base_chain = prompt | llm | parser

    # 基础用户配置
    config = {
        "tags": [f"user-{user_id}", user_tier],
        "metadata": {
            "user_id": user_id,
            "user_tier": user_tier
        }
    }

    # 根据用户等级调整并发
    if user_tier == "premium":
        config["max_concurrency"] = 10
    else:
        config["max_concurrency"] = 3

    return base_chain.with_config(config)

# 使用
premium_chain = get_user_chain("user-123", "premium")
free_chain = get_user_chain("user-456", "free")
```

### 8.3 功能特定配置

```python
# 聊天功能
chat_chain = base_chain.with_config({
    "tags": ["chat"],
    "metadata": {"feature": "chat"},
    "max_concurrency": 5
})

# 搜索功能
search_chain = base_chain.with_config({
    "tags": ["search"],
    "metadata": {"feature": "search"},
    "max_concurrency": 10
})

# 总结功能
summary_chain = base_chain.with_config({
    "tags": ["summary"],
    "metadata": {"feature": "summary"},
    "max_concurrency": 3
})
```

---

## 九、性能考虑

### 9.1 with_config开销

```python
# with_config开销很小
import time

# 创建1000个配置链
start = time.time()
chains = [chain.with_config({"tags": [f"chain-{i}"]}) for i in range(1000)]
end = time.time()
print(f"创建1000个配置链耗时: {end - start:.3f}秒")
# 通常 < 0.01秒
```

### 9.2 配置重用

```python
# ✓ 好：重用配置链
prod_chain = chain.with_config({"tags": ["prod"], "max_concurrency": 3})
for input in inputs:
    result = prod_chain.invoke(input)

# ❌ 差：每次创建新配置链
for input in inputs:
    configured_chain = chain.with_config({"tags": ["prod"]})
    result = configured_chain.invoke(input)
```

---

## 十、常见陷阱

### 10.1 误以为会修改原链

```python
# ❌ 误解
chain = prompt | llm
chain.with_config({"tags": ["test"]})  # 返回值被忽略
result = chain.invoke(input)  # chain没有tags

# ✓ 正确
chain = prompt | llm
configured_chain = chain.with_config({"tags": ["test"]})
result = configured_chain.invoke(input)  # configured_chain有tags
```

### 10.2 配置覆盖顺序混淆

```python
# 记住：invoke时的配置优先级更高
chain_with_config = chain.with_config({"max_concurrency": 10})
result = chain_with_config.invoke(input, config={"max_concurrency": 5})
# 使用5，不是10
```

### 10.3 忘记配置合并规则

```python
# tags是连接，不是覆盖
chain_with_config = chain.with_config({"tags": ["base"]})
result = chain_with_config.invoke(input, config={"tags": ["invoke"]})
# tags=["base", "invoke"]，不是["invoke"]
```

---

## 十一、2025-2026更新

根据研究材料（temp/07_binding_performance.md）：

- **性能优化**: LangChain 1.0优化了RunnableBinding的内存占用
- **配置工厂问题**: Issue #30531讨论了配置工厂传播问题
- **并行执行增强**: 更好的并发控制和批处理优化

---

## 十二、最佳实践

### 12.1 配置工厂模式

```python
def create_configured_chain(
    env: str,
    feature: str,
    **extra_config
) -> Runnable:
    """配置工厂"""
    base_config = {
        "tags": [env, feature],
        "metadata": {"env": env, "feature": feature}
    }

    # 合并额外配置
    final_config = merge_configs(base_config, extra_config)

    return chain.with_config(final_config)

# 使用
prod_chat_chain = create_configured_chain(
    "production",
    "chat",
    max_concurrency=5
)
```

### 12.2 配置验证

```python
def with_validated_config(chain: Runnable, config: RunnableConfig) -> Runnable:
    """验证并绑定配置"""
    # 验证
    if "max_concurrency" in config:
        assert 1 <= config["max_concurrency"] <= 100

    # 绑定
    return chain.with_config(config)
```

### 12.3 配置文档化

```python
def create_production_chain() -> Runnable:
    """
    创建生产环境链

    配置:
        - tags: ["production"]
        - max_concurrency: 3
        - recursion_limit: 10
    """
    return chain.with_config({
        "tags": ["production"],
        "max_concurrency": 3,
        "recursion_limit": 10
    })
```

---

## 十三、下一步

- 可配置字段: [核心概念05 - 可配置字段系统](./03_核心概念_05_可配置字段系统.md)
- 可配置替代: [核心概念06 - 可配置替代方案](./03_核心概念_06_可配置替代方案.md)
- 实战练习: [实战代码01 - 基础配置传递](./07_实战代码_01_基础配置传递.md)
