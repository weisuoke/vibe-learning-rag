# docker-compose编排 - 核心概念：资源限制与扩展

## 概述

**资源限制与扩展** 是生产环境部署的关键配置。合理的资源限制可以防止单个容器占用过多资源，影响其他服务；而扩展配置则支持服务的水平扩展和负载均衡。

**本文涵盖：**
1. deploy 部署配置
2. resources 资源限制（CPU、内存）
3. replicas 副本数配置
4. 日志配置和管理
5. 重启策略和优雅关闭
6. 扩展和负载均衡

---

## 1. deploy 部署配置

### 1.1 基本配置

```yaml
services:
  api:
    image: my-api:latest
    deploy:
      replicas: 3  # 副本数
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
```

**注意：** `deploy` 配置主要用于 Docker Swarm，在 docker-compose 中部分功能有限。

### 1.2 完整配置

```yaml
services:
  api:
    deploy:
      # 副本数
      replicas: 3

      # 更新策略
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback

      # 回滚策略
      rollback_config:
        parallelism: 1
        delay: 5s

      # 重启策略
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

      # 资源限制
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

      # 放置约束
      placement:
        constraints:
          - node.role == worker
```

---

## 2. resources 资源限制

### 2.1 CPU 限制

```yaml
services:
  api:
    deploy:
      resources:
        limits:
          cpus: '1'  # 最多使用1个CPU核心
        reservations:
          cpus: '0.5'  # 保证至少0.5个CPU核心
```

**说明：**
- `limits`：最大可用资源
- `reservations`：保证的最小资源
- CPU 单位：核心数（可以是小数）

**示例：**
```yaml
# 限制为2个CPU核心
cpus: '2'

# 限制为0.5个CPU核心（50%）
cpus: '0.5'

# 限制为1.5个CPU核心
cpus: '1.5'
```

### 2.2 内存限制

```yaml
services:
  api:
    deploy:
      resources:
        limits:
          memory: 1G  # 最多使用1GB内存
        reservations:
          memory: 512M  # 保证至少512MB内存
```

**内存单位：**
- `b`：字节
- `k` 或 `K`：KB
- `m` 或 `M`：MB
- `g` 或 `G`：GB

**示例：**
```yaml
# 1GB
memory: 1G
memory: 1024M

# 512MB
memory: 512M
memory: 524288K

# 2GB
memory: 2G
```

### 2.3 在 docker-compose 中的替代方案

**docker-compose 不完全支持 `deploy`，可以使用旧版语法：**

```yaml
services:
  api:
    # CPU 限制（旧版语法）
    cpus: 1.0
    cpu_shares: 1024

    # 内存限制（旧版语法）
    mem_limit: 1g
    memswap_limit: 2g
    mem_reservation: 512m
```

**前端类比：**
```javascript
// 资源限制 = 浏览器内存限制
const maxMemory = 1024 * 1024 * 1024;  // 1GB

if (usedMemory > maxMemory) {
  throw new Error('Out of memory');
}
```

---

## 3. replicas 副本数配置

### 3.1 基本副本配置

```yaml
services:
  api:
    image: my-api:latest
    deploy:
      replicas: 3  # 启动3个实例
```

**注意：** 不能同时使用 `container_name` 和 `replicas`。

### 3.2 使用 docker-compose up --scale

```yaml
services:
  api:
    image: my-api:latest
    # 不设置 container_name
```

**启动多个实例：**
```bash
# 启动3个 API 实例
docker-compose up --scale api=3

# 查看运行中的容器
docker-compose ps

# 输出
NAME                    STATUS
myproject_api_1         Up
myproject_api_2         Up
myproject_api_3         Up
```

### 3.3 负载均衡

```yaml
services:
  # 负载均衡器
  nginx:
    image: nginx
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - api

  # API 服务（多个实例）
  api:
    image: my-api:latest
    # 不暴露端口（通过 nginx 访问）
```

**nginx.conf：**
```nginx
upstream api_backend {
    server api:8000;  # Docker 内置 DNS 轮询
}

server {
    listen 80;

    location / {
        proxy_pass http://api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

---

## 4. 日志配置和管理

### 4.1 日志驱动

```yaml
services:
  api:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

**常用日志驱动：**

| 驱动 | 说明 | 适用场景 |
|------|------|---------|
| `json-file` | JSON 格式（默认） | 开发环境 |
| `syslog` | 系统日志 | 集中日志管理 |
| `journald` | systemd 日志 | Linux 系统 |
| `gelf` | Graylog 格式 | 日志聚合 |
| `fluentd` | Fluentd 格式 | 日志聚合 |
| `none` | 不记录日志 | 不需要日志的服务 |

### 4.2 json-file 配置

```yaml
services:
  api:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"    # 单个日志文件最大10MB
        max-file: "3"      # 最多保留3个日志文件
        compress: "true"   # 压缩旧日志
```

**日志位置：**
```bash
# 查看日志文件位置
docker inspect --format='{{.LogPath}}' <container_name>

# 输出示例
/var/lib/docker/containers/<container_id>/<container_id>-json.log
```

### 4.3 syslog 配置

```yaml
services:
  api:
    logging:
      driver: "syslog"
      options:
        syslog-address: "tcp://192.168.0.42:514"
        tag: "{{.Name}}/{{.ID}}"
```

### 4.4 禁用日志

```yaml
services:
  api:
    logging:
      driver: "none"
```

### 4.5 查看日志

```bash
# 查看所有服务日志
docker-compose logs

# 查看特定服务日志
docker-compose logs api

# 实时查看日志
docker-compose logs -f api

# 查看最近100行日志
docker-compose logs --tail=100 api

# 查看带时间戳的日志
docker-compose logs -t api
```

---

## 5. 重启策略和优雅关闭

### 5.1 重启策略

```yaml
services:
  api:
    restart: unless-stopped
```

**重启策略：**

| 策略 | 说明 | 适用场景 |
|------|------|---------|
| `no` | 不自动重启（默认） | 开发环境、一次性任务 |
| `always` | 总是重启 | 生产环境（但会在手动停止后也重启） |
| `on-failure` | 失败时重启 | 需要区分正常退出和异常退出 |
| `unless-stopped` | 除非手动停止，否则重启 | 生产环境（推荐） |

**示例：**
```yaml
services:
  # 开发环境：不自动重启
  api-dev:
    restart: "no"

  # 生产环境：除非手动停止，否则重启
  api-prod:
    restart: unless-stopped

  # 初始化任务：失败时重启
  migration:
    restart: on-failure
```

### 5.2 优雅关闭

```yaml
services:
  api:
    stop_grace_period: 30s  # 优雅关闭等待时间
    stop_signal: SIGTERM    # 停止信号
```

**工作流程：**
```
1. docker-compose down
   ↓
2. 发送 SIGTERM 信号
   ↓
3. 等待 stop_grace_period（30秒）
   ↓
4. 如果容器还在运行，发送 SIGKILL 强制停止
```

**FastAPI 优雅关闭：**
```python
import signal
import sys

def signal_handler(sig, frame):
    print('Graceful shutdown...')
    # 关闭数据库连接
    db.close()
    # 关闭 Redis 连接
    redis_client.close()
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)
```

### 5.3 健康检查 + 重启策略

```yaml
services:
  api:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped
```

**行为：**
- 健康检查失败 → 容器标记为 unhealthy
- 如果配置了 `restart: unless-stopped` → 容器重启
- 重启后重新进行健康检查

---

## 6. 扩展和负载均衡

### 6.1 水平扩展

```bash
# 启动3个 API 实例
docker-compose up --scale api=3 -d

# 扩展到5个实例
docker-compose up --scale api=5 -d

# 缩减到2个实例
docker-compose up --scale api=2 -d
```

### 6.2 负载均衡配置

**方案1：Nginx 负载均衡**

```yaml
services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - api

  api:
    image: my-api:latest
```

**nginx.conf：**
```nginx
upstream api_backend {
    # 负载均衡策略：轮询（默认）
    server api:8000;

    # 其他策略
    # least_conn;  # 最少连接
    # ip_hash;     # IP 哈希
}

server {
    listen 80;

    location / {
        proxy_pass http://api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

**方案2：HAProxy 负载均衡**

```yaml
services:
  haproxy:
    image: haproxy:alpine
    ports:
      - "80:80"
    volumes:
      - ./haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro
    depends_on:
      - api

  api:
    image: my-api:latest
```

**haproxy.cfg：**
```
frontend http_front
    bind *:80
    default_backend api_backend

backend api_backend
    balance roundrobin
    server api1 api:8000 check
```

### 6.3 自动扩展（需要 Docker Swarm 或 Kubernetes）

**Docker Swarm：**
```yaml
version: '3.8'

services:
  api:
    image: my-api:latest
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
```

**Kubernetes：**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

---

## 7. 在 AI Agent 开发中的应用

### 7.1 开发环境配置

```yaml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/agent_db
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - .:/app
    # 开发环境：不限制资源
    restart: "no"
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  db:
    image: postgres:14-alpine
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  postgres_data:
```

### 7.2 测试环境配置

```yaml
version: '3.8'

services:
  api:
    image: my-api:test
    # 测试环境：适度限制资源
    cpus: 0.5
    mem_limit: 512m
    restart: on-failure
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"

  db:
    image: postgres:14-alpine
    cpus: 0.25
    mem_limit: 256m
    restart: on-failure
```

### 7.3 生产环境配置

```yaml
version: '3.8'

services:
  # Nginx 负载均衡
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - api
    restart: always
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"

  # API 服务（多个实例）
  api:
    image: my-api:latest
    # 生产环境：严格限制资源
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/agent_prod
      - REDIS_URL=redis://redis:6379
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped
    stop_grace_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
        compress: "true"

  # 数据库
  db:
    image: postgres:14-alpine
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 10s
    restart: always
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Redis
  redis:
    image: redis:7-alpine
    deploy:
      resources:
        limits:
          cpus: '0.25'
          memory: 256M
    volumes:
      - redis_data:/data
    restart: always
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"

  # 监控
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    restart: always

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    volumes:
      - grafana_data:/var/lib/grafana
    restart: always

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:
```

---

## 8. 最佳实践

### 8.1 资源限制

```yaml
# ✅ 推荐：根据服务特点设置
services:
  # API：CPU 密集
  api:
    cpus: 1.0
    mem_limit: 1g

  # 数据库：内存密集
  db:
    cpus: 0.5
    mem_limit: 2g

  # Redis：内存密集
  redis:
    cpus: 0.25
    mem_limit: 512m

# ❌ 不推荐：所有服务相同限制
services:
  api:
    cpus: 1.0
    mem_limit: 1g
  db:
    cpus: 1.0
    mem_limit: 1g
```

### 8.2 日志管理

```yaml
# ✅ 推荐：限制日志大小
services:
  api:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        compress: "true"

# ❌ 不推荐：不限制日志
services:
  api:
    # 没有日志配置，可能占满磁盘
```

### 8.3 重启策略

```yaml
# ✅ 推荐：根据环境选择
services:
  # 开发环境
  api-dev:
    restart: "no"

  # 生产环境
  api-prod:
    restart: unless-stopped

# ❌ 不推荐：所有环境都用 always
services:
  api:
    restart: always  # 手动停止后也会重启
```

### 8.4 优雅关闭

```yaml
# ✅ 推荐：设置优雅关闭时间
services:
  api:
    stop_grace_period: 30s
    stop_signal: SIGTERM

# ❌ 不推荐：没有优雅关闭
services:
  api:
    # 没有 stop_grace_period，立即强制停止
```

---

## 9. 常见问题

### Q1: 如何查看容器资源使用情况？

**A:** 使用 docker stats

```bash
# 查看所有容器资源使用
docker stats

# 查看特定容器
docker stats <container_name>

# 输出示例
CONTAINER    CPU %    MEM USAGE / LIMIT    MEM %    NET I/O
api          2.5%     256MB / 1GB          25%      1.2MB / 800KB
db           1.2%     512MB / 2GB          25%      500KB / 300KB
```

### Q2: 容器超过内存限制会怎样？

**A:** 容器会被 OOM Killer 杀死

```yaml
services:
  api:
    mem_limit: 512m  # 限制512MB

# 如果超过限制，容器会被杀死并重启（如果配置了 restart）
```

### Q3: 如何防止容器占用过多资源？

**A:** 设置资源限制

```yaml
services:
  api:
    cpus: 1.0        # CPU 限制
    mem_limit: 1g    # 内存限制
    pids_limit: 100  # 进程数限制
```

### Q4: 日志文件太大怎么办？

**A:** 配置日志轮转

```yaml
services:
  api:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"    # 单个文件最大10MB
        max-file: "3"      # 最多保留3个文件
        compress: "true"   # 压缩旧日志
```

### Q5: 如何实现零停机部署？

**A:** 使用滚动更新（需要 Docker Swarm 或 Kubernetes）

```yaml
# Docker Swarm
services:
  api:
    deploy:
      replicas: 3
      update_config:
        parallelism: 1  # 每次更新1个实例
        delay: 10s      # 更新间隔10秒
        failure_action: rollback  # 失败时回滚
```

---

## 10. 监控和告警

### 10.1 Prometheus 监控

```yaml
services:
  # Prometheus
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    restart: always

  # Node Exporter（主机监控）
  node-exporter:
    image: prom/node-exporter
    ports:
      - "9100:9100"
    restart: always

  # cAdvisor（容器监控）
  cadvisor:
    image: gcr.io/cadvisor/cadvisor
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
    restart: always
```

**prometheus.yml：**
```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'node'
    static_configs:
      - targets: ['node-exporter:9100']

  - job_name: 'cadvisor'
    static_configs:
      - targets: ['cadvisor:8080']
```

### 10.2 Grafana 可视化

```yaml
services:
  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
    depends_on:
      - prometheus
    restart: always

volumes:
  grafana_data:
```

---

## 11. 总结

**资源限制与扩展的核心要素：**
1. **deploy**：部署配置（副本数、资源限制）
2. **resources**：CPU 和内存限制
3. **replicas**：副本数配置
4. **logging**：日志配置和管理
5. **restart**：重启策略
6. **stop_grace_period**：优雅关闭

**在 AI Agent 开发中：**
- 开发环境：不限制资源，方便调试
- 测试环境：适度限制资源，模拟生产
- 生产环境：严格限制资源，防止资源耗尽

**最佳实践：**
- ✅ 根据服务特点设置资源限制
- ✅ 配置日志轮转，防止磁盘占满
- ✅ 使用 `unless-stopped` 重启策略
- ✅ 设置优雅关闭时间
- ✅ 使用负载均衡实现水平扩展
- ❌ 不要所有服务用相同限制
- ❌ 不要忽略日志管理
- ❌ 不要在生产环境用 `restart: always`

---

**版本：** v1.0
**最后更新：** 2026-02-12
