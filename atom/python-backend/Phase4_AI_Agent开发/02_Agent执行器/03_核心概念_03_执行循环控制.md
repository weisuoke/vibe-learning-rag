# Agent执行器 - 核心概念3：执行循环控制

> 深入理解 Agent 的循环控制机制

---

## 什么是执行循环控制？

**执行循环控制**是 Agent执行器 管理 ReAct 循环的机制，包括：
- 循环的启动和终止
- 迭代次数控制
- 早停策略
- 错误处理和重试

**核心目标**：确保 Agent 能够正确执行任务，同时避免无限循环和资源浪费。

---

## 执行循环的完整流程

### 基础循环结构

```python
def agent_loop(question: str, tools: list, llm, max_iterations: int = 10):
    """Agent 执行循环的基础结构"""

    # 1. 初始化
    context = [f"Question: {question}"]
    iterations = 0
    done = False

    # 2. 循环执行
    while not done and iterations < max_iterations:
        iterations += 1

        # 3. Thought: LLM 思考
        thought = llm.invoke(context)

        # 4. 判断是否完成
        if "Final Answer:" in thought:
            done = True
            return extract_final_answer(thought)

        # 5. Action: 解析并执行工具
        action, action_input = parse_action(thought)
        observation = execute_tool(action, action_input, tools)

        # 6. 更新上下文
        context.append(f"Thought: {thought}")
        context.append(f"Observation: {observation}")

    # 7. 达到最大迭代次数
    return "达到最大迭代次数，任务未完成"
```

---

## 三种停止条件

### 停止条件1：LLM 返回 Final Answer

**定义**：LLM 认为任务已完成，返回最终答案。

**判断方式**：
```python
if "Final Answer:" in thought:
    final_answer = thought.split("Final Answer:")[1].strip()
    return final_answer
```

**示例**：
```
Thought: 我已经获取到订单信息，可以回答用户了
Final Answer: 您的订单12345已发货，预计明天到达
```

**关键**：
- LLM 必须明确输出 "Final Answer:"
- Prompt 中要说明什么时候应该返回 Final Answer

---

### 停止条件2：达到最大迭代次数

**定义**：执行次数达到预设的上限，强制停止。

**判断方式**：
```python
if iterations >= max_iterations:
    return "达到最大迭代次数，任务未完成"
```

**为什么需要**：
- 防止无限循环
- 控制成本（每次迭代都要调用 LLM）
- 控制响应时间

**如何设置**：
```python
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=10,  # 根据任务复杂度设置
)
```

**推荐值**：
- 简单任务：5-10 次
- 复杂任务：10-20 次
- 超过 20 次通常说明任务设计有问题

---

### 停止条件3：遇到错误

**定义**：工具调用失败、解析错误、超时等异常情况。

**判断方式**：
```python
try:
    observation = execute_tool(action, action_input, tools)
except Exception as e:
    return f"执行失败：{str(e)}"
```

**常见错误**：
1. **工具不存在**：LLM 选择了不存在的工具
2. **参数错误**：工具参数格式不正确
3. **工具执行失败**：数据库连接失败、API 调用超时等
4. **解析错误**：无法解析 LLM 的输出

---

## 最大迭代次数（max_iterations）

### 为什么需要限制迭代次数？

**问题场景**：
```python
# 没有限制迭代次数
while True:
    thought = llm.invoke(context)
    # 如果 LLM 一直不返回 Final Answer，会无限循环
```

**后果**：
- 成本失控（每次迭代都要调用 LLM）
- 响应时间过长（用户等待超时）
- 资源浪费（占用服务器资源）

---

### 如何设置 max_iterations？

**基于任务复杂度**：

```python
# 简单任务：查询单个信息
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=5,  # 5次足够
)

# 中等任务：查询多个信息并计算
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=10,  # 10次
)

# 复杂任务：多步骤分析和处理
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=20,  # 20次
)
```

---

### 实际案例分析

**案例1：简单查询（3次迭代）**

```
用户问题："订单12345什么时候到？"

迭代1:
Thought: 需要查询订单信息
Action: query_order("12345")
Observation: 订单已发货，预计明天到达

迭代2:
Thought: 已获取信息，可以回答
Final Answer: 您的订单已发货，预计明天到达

总迭代次数：2次
```

---

**案例2：复杂分析（8次迭代）**

```
用户问题："上个月销售额最高的产品是什么？"

迭代1:
Thought: 需要查询销售数据
Action: query_sales_data("last_month")
Observation: 获取到100条销售记录

迭代2:
Thought: 需要按产品分组
Action: group_by_product(data)
Observation: 产品A: 50条, 产品B: 30条, 产品C: 20条

迭代3:
Thought: 需要计算每个产品的总销售额
Action: calculate_sum(product_A_sales)
Observation: 产品A总销售额: 50000

迭代4:
Thought: 继续计算产品B
Action: calculate_sum(product_B_sales)
Observation: 产品B总销售额: 30000

迭代5:
Thought: 继续计算产品C
Action: calculate_sum(product_C_sales)
Observation: 产品C总销售额: 20000

迭代6:
Thought: 需要找出最高的
Action: find_max([50000, 30000, 20000])
Observation: 最大值: 50000

迭代7:
Thought: 已得出结论
Final Answer: 上个月销售额最高的产品是产品A，销售额50000元

总迭代次数：7次
```

**优化建议**：提供高层工具 `query_sales_summary`，可以减少到 2-3 次迭代。

---

## 早停策略（early_stopping_method）

### 什么是早停策略？

**定义**：当达到 max_iterations 时，如何处理未完成的任务。

**两种策略**：
1. **force**：强制停止，返回错误信息
2. **generate**：让 LLM 基于当前信息生成答案

---

### force 策略

**行为**：达到 max_iterations 后，直接返回错误。

```python
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=10,
    early_stopping_method="force",  # 强制停止
)

# 如果达到10次迭代还没完成
# 返回："Agent stopped due to iteration limit or time limit."
```

**优点**：
- 明确告知任务未完成
- 不会生成不准确的答案

**缺点**：
- 用户体验差（没有得到任何答案）
- 浪费了前面的执行结果

---

### generate 策略（推荐）

**行为**：达到 max_iterations 后，让 LLM 基于当前信息生成答案。

```python
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=10,
    early_stopping_method="generate",  # 生成答案
)

# 如果达到10次迭代还没完成
# LLM 会基于已有信息生成一个答案
```

**优点**：
- 用户体验好（至少得到了部分答案）
- 利用了前面的执行结果

**缺点**：
- 答案可能不完整或不准确

**推荐**：生产环境使用 `generate`，开发环境使用 `force`（便于发现问题）。

---

### 对比示例

**场景**：用户问"上个月销售额最高的产品是什么？"，max_iterations=3

**force 策略**：
```
迭代1: 查询销售数据
迭代2: 按产品分组
迭代3: 计算产品A销售额
达到最大迭代次数

返回："Agent stopped due to iteration limit."
```

**generate 策略**：
```
迭代1: 查询销售数据
迭代2: 按产品分组
迭代3: 计算产品A销售额
达到最大迭代次数

LLM 生成答案："根据目前的数据，产品A的销售额为50000元，但我还没有完成所有产品的计算，所以无法确定是否是最高的。"
```

---

## 错误处理

### 常见错误类型

#### 1. 工具不存在

**错误**：LLM 选择了不存在的工具。

```python
# LLM 输出
Action: query_product  # 但这个工具不存在
Action Input: A001

# 处理
if action_name not in tools:
    observation = f"错误：工具 {action_name} 不存在。可用工具：{list(tools.keys())}"
    context.append(f"Observation: {observation}")
    # 继续循环，让 LLM 重新选择
```

---

#### 2. 参数解析错误

**错误**：无法解析 LLM 的输出。

```python
# LLM 输出（格式错误）
Thought: 需要查询订单
Action query_order  # 缺少冒号
Action Input: 12345

# 处理
try:
    action, action_input = parse_action(thought)
except Exception as e:
    observation = f"解析错误：{str(e)}。请使用正确的格式：Action: tool_name"
    context.append(f"Observation: {observation}")
    # 继续循环，让 LLM 重新输出
```

---

#### 3. 工具执行失败

**错误**：工具执行过程中出错。

```python
# 工具执行
try:
    observation = tool.run(action_input)
except Exception as e:
    observation = f"工具执行失败：{str(e)}"
    context.append(f"Observation: {observation}")
    # 继续循环，让 LLM 根据错误信息调整策略
```

---

### 错误处理策略

#### 策略1：返回错误信息，继续循环

```python
# 推荐：让 Agent 知道发生了什么，自己调整策略
if action_name not in tools:
    observation = f"错误：工具 {action_name} 不存在"
    context.append(f"Observation: {observation}")
    # 继续循环
```

**优点**：
- Agent 可以根据错误信息调整策略
- 可能通过其他方式完成任务

---

#### 策略2：立即停止

```python
# 严格模式：遇到错误立即停止
if action_name not in tools:
    return f"执行失败：工具 {action_name} 不存在"
```

**优点**：
- 快速失败，节省成本
- 便于调试

**缺点**：
- 用户体验差
- 无法利用已有结果

---

### handle_parsing_errors 参数

**作用**：自动处理解析错误。

```python
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    handle_parsing_errors=True,  # 自动处理解析错误
)
```

**行为**：
- 如果无法解析 LLM 输出，自动返回错误信息给 LLM
- LLM 会重新生成输出
- 避免因解析错误导致整个任务失败

**推荐**：生产环境开启，提高稳定性。

---

## 中间步骤（intermediate_steps）

### 什么是中间步骤？

**定义**：Agent 执行过程中的所有 Action 和 Observation。

**作用**：
- 记录执行过程
- 调试和分析
- 审计和监控

---

### 如何获取中间步骤？

```python
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    return_intermediate_steps=True,  # 返回中间步骤
)

result = executor.invoke({"input": "订单12345什么时候到？"})

# 查看中间步骤
for action, observation in result["intermediate_steps"]:
    print(f"Action: {action.tool} - {action.tool_input}")
    print(f"Observation: {observation}")
```

**输出示例**：
```
Action: query_order - 12345
Observation: 订单已发货，预计明天到达
```

---

### 中间步骤的应用

#### 1. 调试

```python
# 查看 Agent 的执行路径
result = executor.invoke({"input": "问题"})

print("执行路径：")
for i, (action, observation) in enumerate(result["intermediate_steps"]):
    print(f"步骤{i+1}: {action.tool}({action.tool_input}) -> {observation}")
```

---

#### 2. 监控

```python
# 统计工具调用次数
tool_usage = {}
for action, observation in result["intermediate_steps"]:
    tool_name = action.tool
    tool_usage[tool_name] = tool_usage.get(tool_name, 0) + 1

print(f"工具调用统计：{tool_usage}")
# 输出：{'query_order': 1, 'query_logistics': 1}
```

---

#### 3. 审计

```python
# 记录执行日志
import logging

logger = logging.getLogger(__name__)

result = executor.invoke({"input": "问题"})

logger.info(f"问题：{result['input']}")
logger.info(f"答案：{result['output']}")
logger.info(f"迭代次数：{len(result['intermediate_steps'])}")

for i, (action, observation) in enumerate(result["intermediate_steps"]):
    logger.info(f"步骤{i+1}: {action.tool}({action.tool_input})")
    logger.info(f"结果: {observation}")
```

---

## 超时控制

### 为什么需要超时控制？

**问题**：
- Agent 可能执行很长时间（特别是工具调用慢）
- 用户等待超时
- 占用服务器资源

**解决**：设置超时时间，超时后强制停止。

---

### 实现超时控制

```python
import asyncio

async def run_agent_with_timeout(question: str, timeout: float = 30.0):
    """运行 Agent，设置超时时间"""
    try:
        result = await asyncio.wait_for(
            executor.ainvoke({"input": question}),
            timeout=timeout
        )
        return result["output"]
    except asyncio.TimeoutError:
        return "执行超时，请稍后重试"
```

---

### 在 FastAPI 中使用

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import asyncio

app = FastAPI()

class Question(BaseModel):
    question: str
    timeout: float = 30.0  # 默认30秒超时

@app.post("/agent")
async def run_agent(question: Question):
    try:
        result = await asyncio.wait_for(
            executor.ainvoke({"input": question.question}),
            timeout=question.timeout
        )
        return {"answer": result["output"]}
    except asyncio.TimeoutError:
        raise HTTPException(status_code=504, detail="Agent 执行超时")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

---

## 实际应用案例

### 案例1：智能客服（严格控制）

```python
from langchain.agents import AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain.tools import tool

# 定义工具
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    return "订单已发货"

# 创建 Agent
llm = ChatOpenAI(model="gpt-4", temperature=0)
tools = [query_order]
agent = create_react_agent(llm, tools, prompt)

# 严格控制：简单任务，快速响应
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=5,              # 最多5次迭代
    early_stopping_method="generate",  # 友好的早停
    handle_parsing_errors=True,    # 处理解析错误
    verbose=False,                 # 生产环境关闭日志
)

# 使用
result = executor.invoke({"input": "订单12345什么时候到？"})
```

---

### 案例2：数据分析（宽松控制）

```python
# 宽松控制：复杂任务，允许更多迭代
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=20,             # 最多20次迭代
    early_stopping_method="generate",
    handle_parsing_errors=True,
    return_intermediate_steps=True,  # 返回中间步骤，便于分析
    verbose=True,                  # 开发环境开启日志
)

# 使用
result = executor.invoke({"input": "分析上个月的销售数据"})

# 分析执行过程
print(f"迭代次数：{len(result['intermediate_steps'])}")
for i, (action, observation) in enumerate(result['intermediate_steps']):
    print(f"步骤{i+1}: {action.tool}")
```

---

### 案例3：生产环境最佳实践

```python
import asyncio
import logging
from fastapi import FastAPI, HTTPException

app = FastAPI()
logger = logging.getLogger(__name__)

# 创建 Agent（全局变量）
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=10,
    early_stopping_method="generate",
    handle_parsing_errors=True,
    return_intermediate_steps=True,
    verbose=False,
)

@app.post("/agent")
async def run_agent(question: str):
    try:
        # 1. 超时控制
        result = await asyncio.wait_for(
            executor.ainvoke({"input": question}),
            timeout=30.0
        )

        # 2. 记录日志
        logger.info(f"问题：{question}")
        logger.info(f"答案：{result['output']}")
        logger.info(f"迭代次数：{len(result['intermediate_steps'])}")

        # 3. 监控指标
        iterations = len(result['intermediate_steps'])
        if iterations >= 10:
            logger.warning(f"达到最大迭代次数：{question}")

        # 4. 返回结果
        return {
            "answer": result["output"],
            "iterations": iterations,
        }

    except asyncio.TimeoutError:
        logger.error(f"超时：{question}")
        raise HTTPException(status_code=504, detail="执行超时")

    except Exception as e:
        logger.error(f"失败：{question}, 错误：{str(e)}")
        raise HTTPException(status_code=500, detail="执行失败")
```

---

## 执行循环控制的最佳实践

### 1. 合理设置 max_iterations

```python
# 根据任务复杂度设置
simple_executor = AgentExecutor(max_iterations=5)   # 简单任务
medium_executor = AgentExecutor(max_iterations=10)  # 中等任务
complex_executor = AgentExecutor(max_iterations=20) # 复杂任务
```

---

### 2. 使用 generate 早停策略

```python
# 生产环境推荐
executor = AgentExecutor(
    early_stopping_method="generate",  # 友好的早停
)
```

---

### 3. 开启错误处理

```python
executor = AgentExecutor(
    handle_parsing_errors=True,  # 自动处理解析错误
)
```

---

### 4. 添加超时控制

```python
# FastAPI 中使用
result = await asyncio.wait_for(
    executor.ainvoke({"input": question}),
    timeout=30.0
)
```

---

### 5. 记录中间步骤

```python
# 开发环境
executor = AgentExecutor(
    return_intermediate_steps=True,
    verbose=True,
)

# 生产环境
executor = AgentExecutor(
    return_intermediate_steps=True,  # 记录日志
    verbose=False,                   # 不打印到控制台
)
```

---

### 6. 监控和告警

```python
# 监控迭代次数
iterations = len(result['intermediate_steps'])
if iterations >= max_iterations * 0.8:
    logger.warning(f"接近最大迭代次数：{iterations}/{max_iterations}")

# 监控响应时间
import time
start_time = time.time()
result = executor.invoke({"input": question})
elapsed_time = time.time() - start_time
if elapsed_time > 10:
    logger.warning(f"响应时间过长：{elapsed_time}秒")
```

---

## 学习检查清单

完成本文档学习后，你应该能够：

- [ ] 理解执行循环的完整流程
- [ ] 掌握三种停止条件（Final Answer、max_iterations、错误）
- [ ] 合理设置 max_iterations 参数
- [ ] 理解 force 和 generate 早停策略的区别
- [ ] 处理常见的执行错误
- [ ] 使用 intermediate_steps 调试和监控
- [ ] 实现超时控制
- [ ] 应用执行循环控制的最佳实践

---

**版本：** v1.0
**最后更新：** 2026-02-12
**维护者：** Claude Code
