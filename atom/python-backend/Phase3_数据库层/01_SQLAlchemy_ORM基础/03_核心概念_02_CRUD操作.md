# 核心概念2：CRUD 操作

深入理解 SQLAlchemy 的增删改查操作。

---

## 1. 什么是 CRUD？

**CRUD** 是数据库操作的四个基本功能：
- **C**reate（创建）：插入新数据
- **R**ead（读取）：查询数据
- **U**pdate（更新）：修改数据
- **D**elete（删除）：删除数据

**在 SQLAlchemy 中：**
- 所有 CRUD 操作都通过 Session 执行
- 操作对象而非 SQL 语句
- 需要显式 commit 才能持久化

---

## 2. Create（创建）

### 2.1 创建单个对象

```python
from sqlalchemy.orm import Session

# 创建对象
user = User(name="Alice", email="alice@example.com")

# 添加到 Session
session.add(user)

# 提交到数据库
session.commit()

# 刷新对象，获取数据库生成的 ID
session.refresh(user)
print(user.id)  # 1
```

**类比前端：** 就像 Prisma 的 `create()`

```typescript
// Prisma
const user = await prisma.user.create({
  data: { name: "Alice", email: "alice@example.com" }
})
```

### 2.2 创建多个对象

```python
# 方法1：add_all
users = [
    User(name="Alice", email="alice@example.com"),
    User(name="Bob", email="bob@example.com"),
    User(name="Charlie", email="charlie@example.com")
]
session.add_all(users)
session.commit()

# 方法2：bulk_insert_mappings（更高效）
session.bulk_insert_mappings(User, [
    {"name": "Alice", "email": "alice@example.com"},
    {"name": "Bob", email="bob@example.com"},
    {"name": "Charlie", "email": "charlie@example.com"}
])
session.commit()
```

**性能对比：**

| 方法 | 性能 | 返回对象 | 触发事件 |
|------|------|----------|----------|
| `add()` | 慢 | ✅ | ✅ |
| `add_all()` | 中 | ✅ | ✅ |
| `bulk_insert_mappings()` | 快 | ❌ | ❌ |

### 2.3 在 AI Agent 开发中的应用

```python
# 创建对话和第一条消息
@app.post("/conversations")
def create_conversation(
    title: str,
    first_message: str,
    db: Session = Depends(get_db)
):
    # 创建对话
    conversation = Conversation(
        title=title,
        user_id=current_user.id
    )
    db.add(conversation)
    db.flush()  # 获取 conversation.id，但不提交

    # 创建第一条消息
    message = Message(
        conversation_id=conversation.id,
        role="user",
        content=first_message
    )
    db.add(message)
    db.commit()  # 一起提交

    db.refresh(conversation)
    return conversation
```

---

## 3. Read（查询）

### 3.1 基本查询

```python
# 查询所有
users = session.query(User).all()

# 查询第一个
user = session.query(User).first()

# 按 ID 查询
user = session.query(User).get(1)

# 按条件查询
user = session.query(User).filter(User.email == "alice@example.com").first()

# 查询多个条件
users = session.query(User)\
    .filter(User.age > 18)\
    .filter(User.is_active == True)\
    .all()
```

### 3.2 过滤条件

```python
# 等于
session.query(User).filter(User.name == "Alice")

# 不等于
session.query(User).filter(User.name != "Alice")

# 大于/小于
session.query(User).filter(User.age > 18)
session.query(User).filter(User.age >= 18)

# IN
session.query(User).filter(User.name.in_(["Alice", "Bob"]))

# NOT IN
session.query(User).filter(~User.name.in_(["Alice", "Bob"]))

# LIKE
session.query(User).filter(User.name.like("%Alice%"))

# IS NULL
session.query(User).filter(User.email == None)

# IS NOT NULL
session.query(User).filter(User.email != None)

# AND
from sqlalchemy import and_
session.query(User).filter(and_(User.age > 18, User.is_active == True))

# OR
from sqlalchemy import or_
session.query(User).filter(or_(User.name == "Alice", User.name == "Bob"))
```

### 3.3 排序和分页

```python
# 排序
users = session.query(User).order_by(User.name).all()  # 升序
users = session.query(User).order_by(User.name.desc()).all()  # 降序

# 多字段排序
users = session.query(User)\
    .order_by(User.age.desc(), User.name)\
    .all()

# 分页
users = session.query(User)\
    .order_by(User.id)\
    .limit(10)\
    .offset(20)\
    .all()  # 第 3 页，每页 10 条

# 计数
count = session.query(User).count()
```

### 3.4 选择特定字段

```python
# 只查询特定字段
results = session.query(User.name, User.email).all()
for name, email in results:
    print(name, email)

# 使用 with_entities
results = session.query(User).with_entities(User.name, User.email).all()

# 查询单个字段
names = session.query(User.name).all()  # [('Alice',), ('Bob',)]
names = [name for (name,) in session.query(User.name).all()]  # ['Alice', 'Bob']
```

### 3.5 聚合查询

```python
from sqlalchemy import func

# COUNT
count = session.query(func.count(User.id)).scalar()

# SUM
total_age = session.query(func.sum(User.age)).scalar()

# AVG
avg_age = session.query(func.avg(User.age)).scalar()

# MAX/MIN
max_age = session.query(func.max(User.age)).scalar()
min_age = session.query(func.min(User.age)).scalar()

# GROUP BY
results = session.query(
    User.age,
    func.count(User.id).label('count')
).group_by(User.age).all()

for age, count in results:
    print(f"Age {age}: {count} users")
```

### 3.6 在 AI Agent 开发中的应用

```python
# 查询用户最近的 10 条对话
@app.get("/conversations")
def get_conversations(
    skip: int = 0,
    limit: int = 10,
    db: Session = Depends(get_db)
):
    conversations = db.query(Conversation)\
        .filter(Conversation.user_id == current_user.id)\
        .filter(Conversation.is_archived == False)\
        .order_by(Conversation.created_at.desc())\
        .offset(skip)\
        .limit(limit)\
        .all()
    return conversations

# 搜索对话
@app.get("/conversations/search")
def search_conversations(
    q: str,
    db: Session = Depends(get_db)
):
    conversations = db.query(Conversation)\
        .filter(Conversation.user_id == current_user.id)\
        .filter(Conversation.title.like(f"%{q}%"))\
        .order_by(Conversation.created_at.desc())\
        .all()
    return conversations

# 统计用户的对话数
@app.get("/conversations/stats")
def get_stats(db: Session = Depends(get_db)):
    total = db.query(func.count(Conversation.id))\
        .filter(Conversation.user_id == current_user.id)\
        .scalar()

    archived = db.query(func.count(Conversation.id))\
        .filter(Conversation.user_id == current_user.id)\
        .filter(Conversation.is_archived == True)\
        .scalar()

    return {
        "total": total,
        "active": total - archived,
        "archived": archived
    }
```

---

## 4. Update（更新）

### 4.1 更新单个对象

```python
# 方法1：查询 → 修改 → 提交
user = session.query(User).filter(User.id == 1).first()
user.name = "Alice Smith"
user.email = "alice.smith@example.com"
session.commit()

# 方法2：使用 update()（更高效）
session.query(User)\
    .filter(User.id == 1)\
    .update({"name": "Alice Smith", "email": "alice.smith@example.com"})
session.commit()
```

**性能对比：**

| 方法 | 性能 | 触发事件 | 返回对象 |
|------|------|----------|----------|
| 查询 → 修改 → 提交 | 慢 | ✅ | ✅ |
| `update()` | 快 | ❌ | ❌ |

### 4.2 批量更新

```python
# 更新多个对象
session.query(User)\
    .filter(User.age < 18)\
    .update({"is_active": False})
session.commit()

# 使用表达式更新
session.query(User)\
    .filter(User.age > 18)\
    .update({"age": User.age + 1})
session.commit()
```

### 4.3 部分更新

```python
# 只更新提供的字段
def update_user(user_id: int, **kwargs):
    session.query(User)\
        .filter(User.id == user_id)\
        .update(kwargs)
    session.commit()

# 使用
update_user(1, name="Alice Smith")  # 只更新 name
update_user(1, email="alice@example.com", is_active=True)  # 更新多个字段
```

### 4.4 在 AI Agent 开发中的应用

```python
# 更新对话标题
@app.patch("/conversations/{conversation_id}")
def update_conversation(
    conversation_id: UUID,
    title: Optional[str] = None,
    is_archived: Optional[bool] = None,
    db: Session = Depends(get_db)
):
    # 查询对话
    conversation = db.query(Conversation)\
        .filter(Conversation.id == conversation_id)\
        .filter(Conversation.user_id == current_user.id)\
        .first()

    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    # 更新字段
    if title is not None:
        conversation.title = title
    if is_archived is not None:
        conversation.is_archived = is_archived

    db.commit()
    db.refresh(conversation)
    return conversation

# 批量归档对话
@app.post("/conversations/archive")
def archive_conversations(
    conversation_ids: List[UUID],
    db: Session = Depends(get_db)
):
    db.query(Conversation)\
        .filter(Conversation.id.in_(conversation_ids))\
        .filter(Conversation.user_id == current_user.id)\
        .update({"is_archived": True}, synchronize_session=False)
    db.commit()
    return {"archived": len(conversation_ids)}
```

---

## 5. Delete（删除）

### 5.1 删除单个对象

```python
# 方法1：查询 → 删除 → 提交
user = session.query(User).filter(User.id == 1).first()
session.delete(user)
session.commit()

# 方法2：使用 delete()（更高效）
session.query(User)\
    .filter(User.id == 1)\
    .delete()
session.commit()
```

### 5.2 批量删除

```python
# 删除多个对象
session.query(User)\
    .filter(User.is_active == False)\
    .delete()
session.commit()

# 删除所有（危险！）
session.query(User).delete()
session.commit()
```

### 5.3 软删除

```python
# 推荐：使用软删除而非真删除
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    name = Column(String(50))
    deleted_at = Column(DateTime, nullable=True)  # 软删除标记

# 软删除
user = session.query(User).filter(User.id == 1).first()
user.deleted_at = datetime.utcnow()
session.commit()

# 查询时排除已删除的
users = session.query(User)\
    .filter(User.deleted_at == None)\
    .all()
```

### 5.4 级联删除

```python
# 定义级联删除
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    conversations = relationship("Conversation", cascade="all, delete-orphan")

class Conversation(Base):
    __tablename__ = "conversations"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))

# 删除用户时，自动删除所有对话
user = session.query(User).filter(User.id == 1).first()
session.delete(user)  # 自动删除所有 conversations
session.commit()
```

### 5.5 在 AI Agent 开发中的应用

```python
# 删除对话（软删除）
@app.delete("/conversations/{conversation_id}")
def delete_conversation(
    conversation_id: UUID,
    db: Session = Depends(get_db)
):
    conversation = db.query(Conversation)\
        .filter(Conversation.id == conversation_id)\
        .filter(Conversation.user_id == current_user.id)\
        .first()

    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    # 软删除
    conversation.deleted_at = datetime.utcnow()
    db.commit()
    return {"message": "Conversation deleted"}

# 永久删除对话
@app.delete("/conversations/{conversation_id}/permanent")
def permanent_delete_conversation(
    conversation_id: UUID,
    db: Session = Depends(get_db)
):
    # 删除所有消息
    db.query(Message)\
        .filter(Message.conversation_id == conversation_id)\
        .delete()

    # 删除对话
    db.query(Conversation)\
        .filter(Conversation.id == conversation_id)\
        .filter(Conversation.user_id == current_user.id)\
        .delete()

    db.commit()
    return {"message": "Conversation permanently deleted"}
```

---

## 6. 事务管理

### 6.1 基本事务

```python
try:
    # 开始事务（隐式）
    user = User(name="Alice")
    session.add(user)

    conversation = Conversation(title="新对话", user=user)
    session.add(conversation)

    session.commit()  # 提交事务
except Exception as e:
    session.rollback()  # 回滚事务
    raise e
```

### 6.2 嵌套事务（Savepoint）

```python
try:
    user = User(name="Alice")
    session.add(user)

    # 创建 Savepoint
    savepoint = session.begin_nested()

    try:
        conversation = Conversation(title="新对话", user=user)
        session.add(conversation)
        session.commit()  # 提交 Savepoint
    except:
        savepoint.rollback()  # 回滚到 Savepoint
        # user 仍然存在

    session.commit()  # 提交主事务
except:
    session.rollback()  # 回滚主事务
```

### 6.3 显式事务

```python
# 使用 begin()
with session.begin():
    user = User(name="Alice")
    session.add(user)
    # 自动 commit 或 rollback
```

### 6.4 在 AI Agent 开发中的应用

```python
# 创建对话和消息（原子操作）
@app.post("/conversations")
def create_conversation_with_message(
    title: str,
    first_message: str,
    db: Session = Depends(get_db)
):
    try:
        # 创建对话
        conversation = Conversation(
            title=title,
            user_id=current_user.id
        )
        db.add(conversation)
        db.flush()  # 获取 ID，但不提交

        # 创建第一条消息
        message = Message(
            conversation_id=conversation.id,
            role="user",
            content=first_message
        )
        db.add(message)

        # 调用 AI 生成回复
        ai_response = generate_ai_response(first_message)

        # 创建 AI 回复消息
        ai_message = Message(
            conversation_id=conversation.id,
            role="assistant",
            content=ai_response
        )
        db.add(ai_message)

        db.commit()  # 要么全成功，要么全失败
        db.refresh(conversation)
        return conversation
    except Exception as e:
        db.rollback()  # 回滚所有更改
        raise HTTPException(status_code=500, detail=str(e))
```

---

## 7. 查询优化

### 7.1 只查询需要的字段

```python
# ❌ 查询所有字段
users = session.query(User).all()

# ✅ 只查询需要的字段
users = session.query(User.id, User.name).all()
```

### 7.2 使用 exists()

```python
# ❌ 查询后判断是否存在
user = session.query(User).filter(User.email == "alice@example.com").first()
if user:
    print("User exists")

# ✅ 使用 exists()
from sqlalchemy import exists
user_exists = session.query(
    exists().where(User.email == "alice@example.com")
).scalar()
if user_exists:
    print("User exists")
```

### 7.3 批量操作

```python
# ❌ 循环插入
for i in range(1000):
    user = User(name=f"User{i}")
    session.add(user)
    session.commit()  # 1000 次提交

# ✅ 批量插入
users = [User(name=f"User{i}") for i in range(1000)]
session.add_all(users)
session.commit()  # 1 次提交

# ✅✅ 使用 bulk_insert_mappings（最快）
session.bulk_insert_mappings(User, [
    {"name": f"User{i}"} for i in range(1000)
])
session.commit()
```

### 7.4 使用索引

```python
# 为常用查询字段添加索引
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    email = Column(String(100), unique=True, index=True)  # 索引
    created_at = Column(DateTime, default=datetime.utcnow, index=True)  # 索引

# 查询时会使用索引
users = session.query(User)\
    .filter(User.email == "alice@example.com")\
    .first()  # 使用 email 索引
```

---

## 8. 完整示例：AI Agent CRUD 操作

```python
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List, Optional
from uuid import UUID
from datetime import datetime

app = FastAPI()

# ===== Create =====

@app.post("/conversations", response_model=ConversationResponse)
def create_conversation(
    data: ConversationCreate,
    db: Session = Depends(get_db)
):
    """创建对话"""
    conversation = Conversation(
        title=data.title,
        user_id=current_user.id
    )
    db.add(conversation)
    db.commit()
    db.refresh(conversation)
    return conversation

@app.post("/conversations/{conversation_id}/messages", response_model=MessageResponse)
def create_message(
    conversation_id: UUID,
    data: MessageCreate,
    db: Session = Depends(get_db)
):
    """创建消息"""
    # 验证对话存在
    conversation = db.query(Conversation)\
        .filter(Conversation.id == conversation_id)\
        .filter(Conversation.user_id == current_user.id)\
        .first()

    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    # 创建消息
    message = Message(
        conversation_id=conversation_id,
        role=data.role,
        content=data.content
    )
    db.add(message)
    db.commit()
    db.refresh(message)
    return message

# ===== Read =====

@app.get("/conversations", response_model=List[ConversationResponse])
def get_conversations(
    skip: int = 0,
    limit: int = 10,
    archived: Optional[bool] = None,
    db: Session = Depends(get_db)
):
    """查询对话列表"""
    query = db.query(Conversation)\
        .filter(Conversation.user_id == current_user.id)

    if archived is not None:
        query = query.filter(Conversation.is_archived == archived)

    conversations = query\
        .order_by(Conversation.created_at.desc())\
        .offset(skip)\
        .limit(limit)\
        .all()

    return conversations

@app.get("/conversations/{conversation_id}", response_model=ConversationDetailResponse)
def get_conversation(
    conversation_id: UUID,
    db: Session = Depends(get_db)
):
    """查询对话详情"""
    conversation = db.query(Conversation)\
        .filter(Conversation.id == conversation_id)\
        .filter(Conversation.user_id == current_user.id)\
        .first()

    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    return conversation

@app.get("/conversations/{conversation_id}/messages", response_model=List[MessageResponse])
def get_messages(
    conversation_id: UUID,
    skip: int = 0,
    limit: int = 50,
    db: Session = Depends(get_db)
):
    """查询消息列表"""
    # 验证对话存在
    conversation = db.query(Conversation)\
        .filter(Conversation.id == conversation_id)\
        .filter(Conversation.user_id == current_user.id)\
        .first()

    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    # 查询消息
    messages = db.query(Message)\
        .filter(Message.conversation_id == conversation_id)\
        .order_by(Message.created_at)\
        .offset(skip)\
        .limit(limit)\
        .all()

    return messages

# ===== Update =====

@app.patch("/conversations/{conversation_id}", response_model=ConversationResponse)
def update_conversation(
    conversation_id: UUID,
    data: ConversationUpdate,
    db: Session = Depends(get_db)
):
    """更新对话"""
    conversation = db.query(Conversation)\
        .filter(Conversation.id == conversation_id)\
        .filter(Conversation.user_id == current_user.id)\
        .first()

    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    # 更新字段
    if data.title is not None:
        conversation.title = data.title
    if data.is_archived is not None:
        conversation.is_archived = data.is_archived

    db.commit()
    db.refresh(conversation)
    return conversation

# ===== Delete =====

@app.delete("/conversations/{conversation_id}")
def delete_conversation(
    conversation_id: UUID,
    permanent: bool = False,
    db: Session = Depends(get_db)
):
    """删除对话"""
    conversation = db.query(Conversation)\
        .filter(Conversation.id == conversation_id)\
        .filter(Conversation.user_id == current_user.id)\
        .first()

    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    if permanent:
        # 永久删除
        db.query(Message)\
            .filter(Message.conversation_id == conversation_id)\
            .delete()
        db.delete(conversation)
    else:
        # 软删除
        conversation.deleted_at = datetime.utcnow()

    db.commit()
    return {"message": "Conversation deleted"}
```

---

## 总结

**CRUD 操作的核心要点：**

1. **Create**：使用 `add()` 或 `add_all()`，批量操作用 `bulk_insert_mappings()`
2. **Read**：使用 `query()` + `filter()` + `all()`/`first()`，支持丰富的过滤条件
3. **Update**：查询后修改或使用 `update()`，批量更新更高效
4. **Delete**：使用 `delete()` 或 `session.delete()`，推荐软删除
5. **事务**：显式 `commit()` 和 `rollback()`，保证数据一致性
6. **优化**：只查询需要的字段，使用索引，批量操作

**在 AI Agent 开发中的应用：**
- 创建对话和消息（原子操作）
- 查询对话列表（分页、排序、筛选）
- 更新对话标题和状态
- 软删除对话（保留历史记录）
- 事务保证数据一致性

---

**记住：** 所有 CRUD 操作都需要显式 `commit()`，异常时要 `rollback()`。
