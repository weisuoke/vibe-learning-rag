# 核心概念：请求排空策略

> 深入理解如何停止接收新请求、等待现有请求完成

---

## 什么是请求排空？

**请求排空（Request Draining）** 是优雅关闭的核心步骤，指在收到关闭信号后：
1. **停止接收新请求**：拒绝新的连接和请求
2. **等待现有请求完成**：让正在处理的请求正常完成
3. **超时控制**：设置最大等待时间，避免无限等待

**类比：**
- **前端视角**：类似于 Express 的 `server.close()`，停止接收新连接但等待现有连接完成
- **日常视角**：类似于餐厅打烊，翻牌子为"打烊中"，但让已入座的顾客吃完

---

## 为什么需要请求排空？

### 问题场景：没有请求排空

```python
# 没有请求排空的"伪优雅关闭"
def signal_handler(signum, frame):
    print("收到信号，立即退出")
    sys.exit(0)  # 立即退出

# 问题：
# 1. 正在处理的请求被中断 → 用户收到 502 错误
# 2. 数据库事务未提交 → 数据不一致
# 3. LLM 流式响应被截断 → 用户体验差
# 4. 文件写入未完成 → 文件损坏
```

**实际后果：**
```
用户视角：
- 请求突然失败（502 Bad Gateway）
- 需要重新发起请求
- 可能导致重复操作（如重复下单）

服务端视角：
- 数据不一致（事务未提交）
- 资源泄漏（连接未关闭）
- 日志不完整（请求未记录）
```

### 解决方案：请求排空

```python
# 有请求排空的优雅关闭
accepting_requests = True  # 是否接收新请求
active_requests = 0        # 活跃请求数

@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    global active_requests

    # 1. 检查是否正在关闭
    if not accepting_requests:
        raise HTTPException(503, "Server is shutting down")

    # 2. 记录活跃请求数
    active_requests += 1
    try:
        response = await call_next(request)
        return response
    finally:
        active_requests -= 1

async def graceful_shutdown():
    global accepting_requests

    # 1. 停止接收新请求
    accepting_requests = False

    # 2. 等待现有请求完成
    while active_requests > 0:
        await asyncio.sleep(0.1)

    # 3. 清理资源
    await cleanup_resources()
```

**效果：**
```
用户视角：
- 正在处理的请求正常完成
- 新请求收到 503 错误（可以重试）
- 无感知服务重启

服务端视角：
- 数据一致性保证
- 资源正确释放
- 日志完整
```

---

## 请求排空的核心组件

### 1. 请求状态标志

**作用：** 控制是否接收新请求

```python
# 全局标志
accepting_requests = True  # 是否接收新请求

def signal_handler(signum, frame):
    global accepting_requests
    accepting_requests = False  # 停止接收新请求
```

**为什么需要全局标志？**
- 需要在信号处理器和中间件之间共享状态
- 需要原子性操作（读写不会被中断）
- 需要在所有请求处理前检查

### 2. 活跃请求计数器

**作用：** 跟踪正在处理的请求数量

```python
# 全局计数器
active_requests = 0  # 活跃请求数

@app.middleware("http")
async def request_counter(request: Request, call_next):
    global active_requests

    # 请求开始：计数器+1
    active_requests += 1
    try:
        response = await call_next(request)
        return response
    finally:
        # 请求结束：计数器-1
        active_requests -= 1
```

**为什么需要计数器？**
- 需要知道何时所有请求都完成了
- 需要在日志中显示等待的请求数
- 需要在超时时决定是否强制退出

### 3. 请求排空中间件

**作用：** 在每个请求前检查是否正在关闭

```python
@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    global active_requests

    # 1. 检查是否正在关闭
    if not accepting_requests:
        # 返回 503 错误
        raise HTTPException(
            status_code=503,
            detail="Server is shutting down, please retry later"
        )

    # 2. 记录活跃请求数
    active_requests += 1
    try:
        # 3. 处理请求
        response = await call_next(request)
        return response
    finally:
        # 4. 请求完成，计数器-1
        active_requests -= 1
```

**为什么使用中间件？**
- 中间件在所有路由前执行
- 可以拦截所有请求
- 可以统一处理关闭逻辑

### 4. 等待循环

**作用：** 等待所有活跃请求完成

```python
async def wait_for_requests(timeout: int = 30):
    """等待所有请求完成"""
    global accepting_requests
    accepting_requests = False  # 停止接收新请求

    print(f"等待 {active_requests} 个请求完成...")

    start_time = asyncio.get_event_loop().time()
    while active_requests > 0:
        # 检查超时
        elapsed = asyncio.get_event_loop().time() - start_time
        if elapsed > timeout:
            print(f"等待超时（{timeout}秒），还有 {active_requests} 个请求未完成")
            break

        # 短暂休眠，避免忙等待
        await asyncio.sleep(0.1)

    print("所有请求已完成")
```

**为什么使用轮询？**
- 简单直观，易于理解
- 可以随时检查超时
- 可以在日志中显示进度

---

## 请求排空的实现策略

### 策略1：简单计数器（推荐）

**适用场景：** 大多数 FastAPI 应用

```python
"""
简单计数器策略
优点：实现简单，性能好
缺点：无法区分不同类型的请求
"""

accepting_requests = True
active_requests = 0

@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    global active_requests

    if not accepting_requests:
        raise HTTPException(503, "Server is shutting down")

    active_requests += 1
    try:
        return await call_next(request)
    finally:
        active_requests -= 1

async def wait_for_requests():
    global accepting_requests
    accepting_requests = False

    while active_requests > 0:
        await asyncio.sleep(0.1)
```

**优点：**
- 实现简单
- 性能开销小
- 适用于大多数场景

**缺点：**
- 无法区分不同类型的请求（快请求 vs 慢请求）
- 无法单独取消某个请求
- 无法获取请求详情

### 策略2：请求跟踪器

**适用场景：** 需要详细跟踪每个请求

```python
"""
请求跟踪器策略
优点：可以跟踪每个请求的详情
缺点：实现复杂，性能开销大
"""

from typing import Dict, Set
import uuid

accepting_requests = True
active_requests: Dict[str, dict] = {}  # 请求ID -> 请求信息

@app.middleware("http")
async def request_tracker(request: Request, call_next):
    if not accepting_requests:
        raise HTTPException(503, "Server is shutting down")

    # 生成请求ID
    request_id = str(uuid.uuid4())

    # 记录请求信息
    active_requests[request_id] = {
        "path": request.url.path,
        "method": request.method,
        "start_time": asyncio.get_event_loop().time(),
    }

    try:
        response = await call_next(request)
        return response
    finally:
        # 移除请求记录
        active_requests.pop(request_id, None)

async def wait_for_requests():
    global accepting_requests
    accepting_requests = False

    while active_requests:
        # 显示等待的请求
        print(f"等待 {len(active_requests)} 个请求:")
        for req_id, info in active_requests.items():
            elapsed = asyncio.get_event_loop().time() - info["start_time"]
            print(f"  - {info['method']} {info['path']} ({elapsed:.1f}s)")

        await asyncio.sleep(1)
```

**优点：**
- 可以跟踪每个请求的详情
- 可以在日志中显示等待的请求
- 可以单独取消某个请求

**缺点：**
- 实现复杂
- 性能开销大（需要维护字典）
- 内存占用高

### 策略3：分类计数器

**适用场景：** 需要区分不同类型的请求

```python
"""
分类计数器策略
优点：可以区分不同类型的请求
缺点：需要手动分类
"""

accepting_requests = True
request_counters = {
    "fast": 0,    # 快请求（<1秒）
    "normal": 0,  # 普通请求（1-10秒）
    "slow": 0,    # 慢请求（>10秒）
}

@app.middleware("http")
async def categorized_counter(request: Request, call_next):
    if not accepting_requests:
        raise HTTPException(503, "Server is shutting down")

    # 根据路径分类
    if request.url.path.startswith("/api/fast"):
        category = "fast"
    elif request.url.path.startswith("/api/slow"):
        category = "slow"
    else:
        category = "normal"

    request_counters[category] += 1
    try:
        return await call_next(request)
    finally:
        request_counters[category] -= 1

async def wait_for_requests():
    global accepting_requests
    accepting_requests = False

    while sum(request_counters.values()) > 0:
        print(f"等待请求: fast={request_counters['fast']}, "
              f"normal={request_counters['normal']}, "
              f"slow={request_counters['slow']}")
        await asyncio.sleep(0.5)
```

**优点：**
- 可以区分不同类型的请求
- 可以针对不同类型设置不同的超时时间
- 性能开销适中

**缺点：**
- 需要手动分类
- 分类逻辑可能复杂

---

## 处理不同类型的请求

### 1. 普通 HTTP 请求

```python
@app.get("/api/users")
async def get_users():
    # 普通请求，等待完成即可
    users = await db.query(User).all()
    return users

# 优雅关闭时：
# - 停止接收新请求
# - 等待现有请求完成（通常很快）
```

### 2. 长时间运行的请求

```python
@app.post("/api/process-document")
async def process_document(doc_id: int):
    # 长时间运行的请求（可能需要数十秒）
    doc = await db.get_document(doc_id)

    # 检查是否正在关闭
    if shutdown_event.is_set():
        raise HTTPException(503, "Server is shutting down")

    # 处理文档
    result = await process_large_document(doc)

    return result

# 优雅关闭时：
# - 停止接收新请求
# - 等待现有请求完成（可能需要较长时间）
# - 设置合理的超时时间（如60秒）
```

### 3. 流式响应

```python
@app.get("/api/stream")
async def stream_response():
    async def generate():
        for i in range(100):
            # 检查是否正在关闭
            if shutdown_event.is_set():
                yield json.dumps({"type": "end", "reason": "shutdown"})
                break

            yield json.dumps({"type": "chunk", "data": i})
            await asyncio.sleep(0.1)

    return StreamingResponse(generate())

# 优雅关闭时：
# - 停止接收新请求
# - 发送结束标记给现有流式响应
# - 等待流式响应完成
```

### 4. WebSocket 连接

```python
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()

    try:
        while not shutdown_event.is_set():
            data = await websocket.receive_text()
            await websocket.send_text(f"Echo: {data}")
    except WebSocketDisconnect:
        pass
    finally:
        # 优雅关闭时，发送关闭消息
        if shutdown_event.is_set():
            await websocket.send_text(json.dumps({
                "type": "close",
                "reason": "server_shutdown"
            }))
        await websocket.close()

# 优雅关闭时：
# - 停止接收新 WebSocket 连接
# - 向现有连接发送关闭消息
# - 等待连接关闭
```

---

## 超时控制

### 1. 固定超时

```python
async def wait_for_requests_with_timeout(timeout: int = 30):
    """等待请求完成，带固定超时"""
    global accepting_requests
    accepting_requests = False

    try:
        await asyncio.wait_for(
            wait_for_all_requests(),
            timeout=timeout
        )
        print("所有请求已完成")
    except asyncio.TimeoutError:
        print(f"等待超时（{timeout}秒），还有 {active_requests} 个请求未完成")
        # 强制退出或取消请求

async def wait_for_all_requests():
    """等待所有请求完成（无超时）"""
    while active_requests > 0:
        await asyncio.sleep(0.1)
```

### 2. 分阶段超时

```python
async def wait_for_requests_staged():
    """分阶段等待请求完成"""
    global accepting_requests
    accepting_requests = False

    # 阶段1：等待快请求（10秒）
    print("阶段1：等待快请求完成...")
    try:
        await asyncio.wait_for(
            wait_until_requests_below(threshold=5),
            timeout=10
        )
    except asyncio.TimeoutError:
        print("快请求等待超时")

    # 阶段2：等待普通请求（20秒）
    print("阶段2：等待普通请求完成...")
    try:
        await asyncio.wait_for(
            wait_until_requests_below(threshold=0),
            timeout=20
        )
    except asyncio.TimeoutError:
        print("普通请求等待超时，取消剩余请求")
        # 取消剩余请求

async def wait_until_requests_below(threshold: int):
    """等待请求数降到阈值以下"""
    while active_requests > threshold:
        await asyncio.sleep(0.1)
```

### 3. 动态超时

```python
async def wait_for_requests_dynamic():
    """根据请求类型动态调整超时"""
    global accepting_requests
    accepting_requests = False

    # 根据请求类型计算超时时间
    if request_counters["slow"] > 0:
        timeout = 60  # 有慢请求，等待60秒
    elif request_counters["normal"] > 0:
        timeout = 30  # 有普通请求，等待30秒
    else:
        timeout = 10  # 只有快请求，等待10秒

    print(f"动态超时时间: {timeout}秒")

    try:
        await asyncio.wait_for(
            wait_for_all_requests(),
            timeout=timeout
        )
    except asyncio.TimeoutError:
        print(f"等待超时（{timeout}秒）")
```

---

## 完整示例：生产级请求排空

```python
"""
生产级请求排空实现
演示：完整的请求排空流程
"""

import asyncio
import time
from typing import Dict, Optional
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse

app = FastAPI()

# ===== 1. 全局状态 =====
accepting_requests = True
active_requests = 0
shutdown_event = asyncio.Event()

# 请求统计
request_stats = {
    "total_received": 0,
    "total_completed": 0,
    "total_rejected": 0,
}

# ===== 2. 请求排空中间件 =====
@app.middleware("http")
async def request_draining_middleware(request: Request, call_next):
    """请求排空中间件"""
    global active_requests

    # 1. 检查是否正在关闭
    if not accepting_requests:
        request_stats["total_rejected"] += 1
        return JSONResponse(
            status_code=503,
            content={
                "error": "Server is shutting down",
                "message": "Please retry in a few seconds",
                "retry_after": 10,  # 建议10秒后重试
            },
            headers={"Retry-After": "10"}
        )

    # 2. 记录请求
    request_stats["total_received"] += 1
    active_requests += 1

    # 3. 记录请求开始时间
    start_time = time.time()

    try:
        # 4. 处理请求
        response = await call_next(request)

        # 5. 记录请求完成
        request_stats["total_completed"] += 1

        # 6. 添加响应头
        response.headers["X-Request-Duration"] = f"{time.time() - start_time:.3f}"

        return response

    finally:
        # 7. 请求完成，计数器-1
        active_requests -= 1

# ===== 3. 示例路由 =====
@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/fast")
async def fast_endpoint():
    """快请求（<1秒）"""
    await asyncio.sleep(0.5)
    return {"message": "Fast response"}

@app.get("/normal")
async def normal_endpoint():
    """普通请求（1-5秒）"""
    await asyncio.sleep(3)
    return {"message": "Normal response"}

@app.get("/slow")
async def slow_endpoint():
    """慢请求（>5秒）"""
    # 检查是否正在关闭
    for i in range(10):
        if shutdown_event.is_set():
            raise HTTPException(503, "Server is shutting down")
        await asyncio.sleep(1)

    return {"message": "Slow response"}

@app.get("/stats")
async def get_stats():
    """获取请求统计"""
    return {
        "accepting_requests": accepting_requests,
        "active_requests": active_requests,
        "stats": request_stats,
    }

# ===== 4. 请求排空逻辑 =====
async def wait_for_requests(timeout: int = 30):
    """等待所有请求完成"""
    global accepting_requests
    accepting_requests = False

    print(f"\n========== 开始请求排空 ==========")
    print(f"当前活跃请求数: {active_requests}")
    print(f"超时时间: {timeout}秒")

    start_time = asyncio.get_event_loop().time()

    while active_requests > 0:
        # 计算已等待时间
        elapsed = asyncio.get_event_loop().time() - start_time

        # 检查超时
        if elapsed > timeout:
            print(f"\n⚠️  请求排空超时（{timeout}秒）")
            print(f"还有 {active_requests} 个请求未完成")
            break

        # 显示进度
        if int(elapsed) % 5 == 0:  # 每5秒显示一次
            print(f"等待中... 剩余 {active_requests} 个请求 ({elapsed:.1f}s)")

        await asyncio.sleep(0.1)

    if active_requests == 0:
        print(f"\n✓ 所有请求已完成")
    else:
        print(f"\n✗ 还有 {active_requests} 个请求未完成")

    print(f"========== 请求排空结束 ==========\n")

    # 返回是否成功
    return active_requests == 0

# ===== 5. 优雅关闭 =====
async def graceful_shutdown():
    """优雅关闭"""
    print("\n========== 开始优雅关闭 ==========")

    # 1. 设置关闭标志
    shutdown_event.set()

    # 2. 等待请求完成
    success = await wait_for_requests(timeout=30)

    # 3. 显示统计
    print("\n请求统计:")
    print(f"  总接收: {request_stats['total_received']}")
    print(f"  总完成: {request_stats['total_completed']}")
    print(f"  总拒绝: {request_stats['total_rejected']}")

    # 4. 清理资源
    print("\n清理资源...")
    # await cleanup_resources()

    print("========== 优雅关闭完成 ==========\n")

    # 5. 退出
    import sys
    sys.exit(0 if success else 1)

# ===== 6. 信号处理 =====
import signal

def signal_handler(signum, frame):
    """信号处理器"""
    print(f"\n收到信号 {signum}")
    asyncio.create_task(graceful_shutdown())

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

# ===== 7. 启动应用 =====
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试请求排空：**
```bash
# 1. 启动应用
python app.py

# 2. 发送多个请求
curl http://localhost:8000/fast &
curl http://localhost:8000/normal &
curl http://localhost:8000/slow &

# 3. 立即发送 SIGTERM
kill -SIGTERM $(pgrep -f "python app.py")

# 观察日志：
# 收到信号 15
# ========== 开始请求排空 ==========
# 当前活跃请求数: 3
# 超时时间: 30秒
# 等待中... 剩余 3 个请求 (0.0s)
# 等待中... 剩余 2 个请求 (5.0s)
# 等待中... 剩余 1 个请求 (10.0s)
# ✓ 所有请求已完成
# ========== 请求排空结束 ==========
```

---

## 总结

### 核心要点

1. **请求排空的三个步骤**：
   - 停止接收新请求
   - 等待现有请求完成
   - 超时控制

2. **实现策略**：
   - 简单计数器（推荐）
   - 请求跟踪器（详细跟踪）
   - 分类计数器（区分类型）

3. **不同类型的请求**：
   - 普通 HTTP 请求：等待完成
   - 长时间请求：检查关闭信号
   - 流式响应：发送结束标记
   - WebSocket：发送关闭消息

4. **超时控制**：
   - 固定超时（简单）
   - 分阶段超时（灵活）
   - 动态超时（智能）

### 检查清单

- [ ] 实现了请求状态标志
- [ ] 实现了活跃请求计数器
- [ ] 实现了请求排空中间件
- [ ] 实现了等待循环
- [ ] 设置了合理的超时时间
- [ ] 处理了不同类型的请求
- [ ] 测试了请求排空流程

---

**下一步**：学习 **03_核心概念_03_资源清理策略.md**，了解如何清理数据库连接、Redis 连接等资源。
