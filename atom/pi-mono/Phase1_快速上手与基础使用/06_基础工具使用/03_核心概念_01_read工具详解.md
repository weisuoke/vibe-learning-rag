# read 工具详解

> 深入理解 Pi 的文件读取工具：设计哲学、实现细节、高级特性

---

## 概述

**read 工具**是 Pi 的 4 个基础工具之一，负责读取文件内容。它看似简单，但包含了许多精心设计的特性。

**核心职责：**
- 读取文件内容
- 支持行范围读取
- 支持图片文件
- 提供内部资源访问（pi-internal://）

---

## 设计哲学

### 1. 只读原则

**read 工具永远不修改文件**

```typescript
// read 工具的语义
const content = await read("src/app.ts")
// 保证：文件内容不会被修改
// 保证：可以反复读取
// 保证：不会产生副作用
```

**为什么重要？**
- 安全性：Agent 可以放心地读取任何文件
- 可预测性：读取操作不会改变系统状态
- 可重复性：多次读取得到相同结果

---

### 2. 简单接口

**最小化参数，最大化灵活性**

```typescript
// 基本用法
await read("path/to/file.ts")

// 行范围读取（通过 Agent 理解，不是显式参数）
// Agent 可以请求特定行范围
await read("path/to/file.ts")  // Agent 在提示中说明需要哪些行
```

**设计权衡：**
- ✅ 接口简单，易于理解
- ✅ 减少 token 消耗（参数定义更短）
- ⚠️ 高级功能需要 Agent 理解

---

### 3. 多格式支持

**不仅仅是文本文件**

```typescript
// 文本文件
await read("src/app.ts")        // TypeScript
await read("package.json")      // JSON
await read("README.md")         // Markdown

// 图片文件（返回 base64）
await read("assets/logo.png")   // PNG
await read("assets/icon.jpg")   // JPEG

// 配置文件
await read(".env")              // 环境变量
await read("tsconfig.json")     // TypeScript 配置
```

---

## 实现细节

### 1. 核心实现

**基于 Node.js fs 模块**

```typescript
// 简化的实现（实际更复杂）
class ReadTool {
  async execute(path: string): Promise<string> {
    // 1. 检查文件是否存在
    if (!fs.existsSync(path)) {
      throw new Error(`File not found: ${path}`)
    }

    // 2. 检查是否是图片
    if (this.isImage(path)) {
      return this.readImage(path)
    }

    // 3. 读取文本文件
    return fs.readFileSync(path, 'utf-8')
  }

  private isImage(path: string): boolean {
    const ext = path.split('.').pop()?.toLowerCase()
    return ['png', 'jpg', 'jpeg', 'gif', 'webp'].includes(ext || '')
  }

  private readImage(path: string): string {
    const buffer = fs.readFileSync(path)
    const base64 = buffer.toString('base64')
    const ext = path.split('.').pop()
    return `data:image/${ext};base64,${base64}`
  }
}
```

**来源：**
- [pi-mono read.ts implementation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/src/core/tools/read.ts) - 核心实现，2026

---

### 2. 行范围读取

**优化大文件读取**

```typescript
// 实际实现支持行范围
class ReadTool {
  async execute(
    path: string,
    options?: { startLine?: number; endLine?: number }
  ): Promise<string> {
    const content = fs.readFileSync(path, 'utf-8')

    // 如果指定了行范围
    if (options?.startLine !== undefined || options?.endLine !== undefined) {
      const lines = content.split('\n')
      const start = options.startLine || 0
      const end = options.endLine || lines.length
      return lines.slice(start, end).join('\n')
    }

    return content
  }
}
```

**使用场景：**
```typescript
// 场景 1：只读取文件开头
await read("large-file.ts", { endLine: 50 })  // 前 50 行

// 场景 2：只读取特定范围
await read("large-file.ts", { startLine: 100, endLine: 200 })  // 100-200 行

// 场景 3：只读取文件结尾
await read("large-file.ts", { startLine: -50 })  // 最后 50 行
```

**优势：**
- 节省 token（不读取整个大文件）
- 提高效率（只读取需要的部分）
- 降低成本（减少 API 调用开销）

---

### 3. pi-internal:// URL Scheme

**访问内部资源**

Pi 引入了 `pi-internal://` URL scheme，用于访问 coding agent 内部的文档和资源。

```typescript
// 访问内部文档
await read("pi-internal://docs/extensions.md")
await read("pi-internal://docs/skills.md")
await read("pi-internal://docs/prompt-templates.md")

// 访问内部配置
await read("pi-internal://config/default-settings.json")
```

**实现原理：**

```typescript
class ReadTool {
  async execute(path: string): Promise<string> {
    // 检查是否是 pi-internal:// URL
    if (path.startsWith('pi-internal://')) {
      return this.readInternalResource(path)
    }

    // 普通文件读取
    return fs.readFileSync(path, 'utf-8')
  }

  private readInternalResource(url: string): string {
    // 移除 pi-internal:// 前缀
    const resourcePath = url.replace('pi-internal://', '')

    // 从 coding-agent 包内部读取
    const internalPath = path.join(__dirname, '../../../', resourcePath)
    return fs.readFileSync(internalPath, 'utf-8')
  }
}
```

**使用场景：**
- Agent 需要查看扩展文档
- Agent 需要了解 Skills 的使用方法
- Agent 需要参考 Prompt Templates

**来源：**
- [pi-mono CHANGELOG](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/CHANGELOG.md) - pi-internal:// 引入记录，2026
- [pi-mono system-prompt.ts](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/src/core/system-prompt.ts) - 内部资源引用逻辑，2026

---

## 高级特性

### 1. 图片读取

**支持多种图片格式**

```typescript
// 读取图片文件
const imageData = await read("assets/screenshot.png")

// 返回格式：data URL
// data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...
```

**实际应用：**
- Agent 可以"看到"图片
- 用于 UI 设计分析
- 用于截图调试

**示例场景：**
```typescript
// Agent 工作流
// 1. 读取设计稿
const design = await read("design/mockup.png")

// 2. 分析设计
// Agent 使用视觉能力分析图片

// 3. 生成代码
await write("src/components/Button.tsx", generatedCode)
```

---

### 2. 错误处理

**清晰的错误信息**

```typescript
class ReadTool {
  async execute(path: string): Promise<string> {
    try {
      // 检查文件是否存在
      if (!fs.existsSync(path)) {
        throw new Error(`File not found: ${path}`)
      }

      // 检查是否是目录
      if (fs.statSync(path).isDirectory()) {
        throw new Error(`Cannot read directory: ${path}. Use bash ls instead.`)
      }

      // 检查文件大小
      const stats = fs.statSync(path)
      if (stats.size > 10 * 1024 * 1024) {  // 10MB
        throw new Error(`File too large: ${path} (${stats.size} bytes)`)
      }

      // 读取文件
      return fs.readFileSync(path, 'utf-8')
    } catch (error) {
      // 提供有用的错误信息
      if (error.code === 'ENOENT') {
        throw new Error(`File not found: ${path}`)
      }
      if (error.code === 'EACCES') {
        throw new Error(`Permission denied: ${path}`)
      }
      throw error
    }
  }
}
```

**错误类型：**
- 文件不存在（ENOENT）
- 权限不足（EACCES）
- 文件过大
- 路径是目录

---

### 3. 编码处理

**自动检测文件编码**

```typescript
class ReadTool {
  async execute(path: string): Promise<string> {
    // 默认使用 UTF-8
    try {
      return fs.readFileSync(path, 'utf-8')
    } catch (error) {
      // 如果 UTF-8 失败，尝试其他编码
      if (error.message.includes('invalid UTF-8')) {
        // 尝试 Latin-1
        return fs.readFileSync(path, 'latin1')
      }
      throw error
    }
  }
}
```

---

## 与 Extensions 集成

### 1. 覆盖 read 工具

**通过 Extensions 自定义 read 行为**

```typescript
// 示例：添加缓存
extensions.register({
  name: "cached-read",
  tool: {
    name: "read",
    override: true,
    execute: async (path: string) => {
      // 检查缓存
      if (cache.has(path)) {
        return cache.get(path)
      }

      // 读取文件
      const content = fs.readFileSync(path, 'utf-8')

      // 缓存结果
      cache.set(path, content)

      return content
    }
  }
})
```

---

### 2. 添加 read hooks

**在读取前后插入逻辑**

```typescript
// 示例：记录读取日志
extensions.register({
  name: "read-logger",
  hooks: {
    beforeRead: async (path: string) => {
      console.log(`Reading: ${path}`)
      return path
    },
    afterRead: async (path: string, content: string) => {
      console.log(`Read ${content.length} bytes from ${path}`)
    }
  }
})
```

---

### 3. 远程文件读取

**通过 Extensions 支持远程文件**

```typescript
// 示例：SSH 远程读取
extensions.register({
  name: "ssh-read",
  tool: {
    name: "read",
    override: true,
    execute: async (path: string) => {
      // 如果路径以 ssh:// 开头
      if (path.startsWith('ssh://')) {
        const { host, remotePath } = parseSSHUrl(path)
        return await ssh.readFile(host, remotePath)
      }

      // 否则使用默认实现
      return fs.readFileSync(path, 'utf-8')
    }
  }
})

// 使用
await read("ssh://server.com/path/to/file.ts")
```

**来源：**
- [pi-mono extensions.md](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md) - 扩展文档，2026

---

## 实际应用场景

### 场景 1：代码审查

```typescript
// 1. 读取要审查的文件
const code = await read("src/payment.ts")

// 2. Agent 分析代码
// - 检查安全漏洞
// - 检查代码风格
// - 检查逻辑错误

// 3. 提供反馈
// Agent 输出审查结果
```

---

### 场景 2：理解项目结构

```typescript
// 1. 读取 package.json
const pkg = await read("package.json")

// 2. 读取 README
const readme = await read("README.md")

// 3. 读取主入口文件
const main = await read("src/index.ts")

// 4. Agent 理解项目结构
// - 依赖关系
// - 项目目的
// - 代码组织
```

---

### 场景 3：调试问题

```typescript
// 1. 读取错误日志
const log = await read("error.log")

// 2. 读取相关代码
const code = await read("src/problematic-module.ts")

// 3. 读取测试文件
const test = await read("src/problematic-module.test.ts")

// 4. Agent 分析问题
// - 定位错误原因
// - 提出修复方案
```

---

### 场景 4：生成文档

```typescript
// 1. 读取源代码
const source = await read("src/api.ts")

// 2. Agent 分析 API
// - 提取函数签名
// - 理解参数和返回值
// - 识别使用示例

// 3. 生成文档
await write("docs/api.md", generatedDocs)
```

---

## 性能优化

### 1. 大文件处理

**策略：分批读取**

```typescript
// 不好的做法：一次读取整个大文件
const content = await read("huge-file.ts")  // 可能消耗大量 token

// 好的做法：分批读取
const header = await read("huge-file.ts")  // Agent 请求前 100 行
// Agent 分析 header，决定是否需要读取更多

const middle = await read("huge-file.ts")  // Agent 请求 100-200 行
// 继续分析...
```

---

### 2. 缓存策略

**避免重复读取**

```typescript
// Agent 的智能缓存
// 1. 第一次读取
const content1 = await read("src/app.ts")

// 2. 如果文件没有修改，Agent 可以使用缓存
// 不需要再次调用 read

// 3. 如果文件被修改（通过 write 或 edit）
await edit("src/app.ts", old, new)
// Agent 知道缓存失效，需要重新读取
const content2 = await read("src/app.ts")
```

---

### 3. 选择性读取

**只读取需要的部分**

```typescript
// 场景：查找特定函数
// 不好的做法：读取整个文件
const content = await read("src/large-module.ts")
// 然后在内存中搜索函数

// 好的做法：使用 bash grep
await bash("grep -n 'function targetFunction' src/large-module.ts")
// 得到行号后，只读取相关行
const relevantPart = await read("src/large-module.ts")  // Agent 请求特定行范围
```

---

## 与其他工具的协作

### read + edit

**最常见的组合**

```typescript
// 1. 读取文件
const content = await read("src/app.ts")

// 2. Agent 分析内容，决定修改

// 3. 精确修改
await edit("src/app.ts", oldCode, newCode)
```

---

### read + write

**理解后创建**

```typescript
// 1. 读取现有代码
const existing = await read("src/user.ts")

// 2. Agent 理解模式

// 3. 创建类似的新文件
await write("src/product.ts", newCode)
```

---

### read + bash

**读取后验证**

```typescript
// 1. 读取配置
const config = await read("tsconfig.json")

// 2. Agent 检查配置

// 3. 运行类型检查
await bash("tsc --noEmit")
```

---

## 常见问题

### Q1: read 工具能读取二进制文件吗？

**A:** 可以读取图片（返回 base64），但不建议读取其他二进制文件（如 .exe、.zip）。

```typescript
// ✅ 支持：图片
await read("logo.png")  // 返回 base64

// ❌ 不支持：其他二进制
await read("app.exe")  // 可能返回乱码
```

---

### Q2: read 工具有文件大小限制吗？

**A:** 有。通常限制在 10MB 左右，具体取决于实现。

```typescript
// 如果文件太大
await read("huge-file.ts")  // 可能抛出 "File too large" 错误

// 解决方案：分批读取或使用 bash
await bash("head -n 100 huge-file.ts")  // 只读取前 100 行
```

---

### Q3: read 工具能读取目录吗？

**A:** 不能。读取目录应该使用 bash ls。

```typescript
// ❌ 错误
await read("src/")  // 抛出错误

// ✅ 正确
await bash("ls -la src/")  // 列出目录内容
```

---

### Q4: read 工具能读取远程文件吗？

**A:** 默认不能，但可以通过 Extensions 扩展。

```typescript
// 默认：只能读取本地文件
await read("src/app.ts")  // ✅

// 通过 Extension：支持远程文件
await read("ssh://server.com/app.ts")  // ✅（需要 SSH Extension）
await read("https://example.com/file.ts")  // ✅（需要 HTTP Extension）
```

---

### Q5: read 工具会修改文件吗？

**A:** 永远不会。read 工具是只读的。

```typescript
// 保证：read 不会修改文件
await read("src/app.ts")
// 文件内容保持不变

// 修改文件应该用 edit 或 write
await edit("src/app.ts", old, new)
```

---

## 2025-2026 最新发展

### pi-internal:// URL Scheme

2026 年引入的 `pi-internal://` URL scheme 是 read 工具的重要增强：

**用途：**
- 访问 coding agent 内部文档
- 访问默认配置
- 访问示例代码

**示例：**
```typescript
// 查看扩展文档
await read("pi-internal://docs/extensions.md")

// 查看 Skills 文档
await read("pi-internal://docs/skills.md")

// 查看默认设置
await read("pi-internal://config/default-settings.json")
```

**来源：**
- [pi-mono CHANGELOG](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/CHANGELOG.md) - pi-internal:// 引入，2026

---

### oh-my-pi 的增强

oh-my-pi fork 对 read 工具进行了增强：

**增强内容：**
- 更好的错误处理
- 自动编码检测
- 性能优化

**来源：**
- [oh-my-pi CHANGELOG](https://github.com/can1357/oh-my-pi/blob/main/packages/coding-agent/CHANGELOG.md) - read tool 增强，2026

---

## 设计权衡

### 优势

1. **简单接口** - 只需要一个参数（路径）
2. **安全性** - 只读，不会修改文件
3. **多格式支持** - 文本、图片、配置文件
4. **可扩展** - 通过 Extensions 定制

### 劣势

1. **大文件处理** - 一次读取整个文件可能消耗大量 token
2. **编码问题** - 非 UTF-8 文件可能出现乱码
3. **二进制限制** - 只支持图片，不支持其他二进制文件

### Pi 的选择

**宁可接口简单，也不要参数复杂。**

高级功能（如行范围读取）通过 Agent 理解实现，而不是显式参数。

---

## 最佳实践

### 1. 先读后改

```typescript
// ✅ 好的做法
await read("src/app.ts")  // 先读取
await edit("src/app.ts", old, new)  // 再修改

// ❌ 不好的做法
await edit("src/app.ts", old, new)  // 没有先读取，可能修改错误
```

---

### 2. 分批读取大文件

```typescript
// ✅ 好的做法
await read("large-file.ts")  // Agent 请求前 100 行
// 分析后决定是否需要更多

// ❌ 不好的做法
await read("large-file.ts")  // 一次读取整个文件（可能很大）
```

---

### 3. 使用 bash 辅助

```typescript
// ✅ 好的做法
await bash("find src -name '*.ts'")  // 先找到文件
await read("src/target.ts")  // 再读取

// ❌ 不好的做法
// 盲目读取，可能读错文件
await read("src/target.ts")
```

---

### 4. 缓存意识

```typescript
// Agent 应该意识到缓存
// 1. 第一次读取
await read("src/app.ts")

// 2. 如果没有修改，不需要再次读取
// Agent 使用缓存

// 3. 如果修改了，需要重新读取
await edit("src/app.ts", old, new)
await read("src/app.ts")  // 重新读取
```

---

## 延伸阅读

### 官方文档
- [pi-mono read.ts](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/src/core/tools/read.ts) - 核心实现
- [pi-mono extensions.md](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md) - 扩展文档

### 社区资源
- [oh-my-pi](https://github.com/can1357/oh-my-pi) - 增强版 Pi
- [Pi Anatomy Analysis](https://medium.com/@shivam.agarwal.in/agentic-ai-pi-anatomy-of-a-minimal-coding-agent-powering-openclaw-5ecd4dd6b440) - 架构分析

---

## 下一步学习

完成 read 工具学习后，建议学习：

### 其他工具
- [03_核心概念_02_write工具详解](./03_核心概念_02_write工具详解.md) - write 工具深入
- [03_核心概念_03_edit工具详解](./03_核心概念_03_edit工具详解.md) - edit 工具深入
- [03_核心概念_04_bash工具详解](./03_核心概念_04_bash工具详解.md) - bash 工具深入

### 实战应用
- [07_实战代码_01_read工具实战](./07_实战代码_01_read工具实战.md) - read 工具实战
- [07_实战代码_05_工具组合模式](./07_实战代码_05_工具组合模式.md) - 工具组合

---

**版本：** v1.0
**最后更新：** 2026-02-19
**维护者：** Claude Code
