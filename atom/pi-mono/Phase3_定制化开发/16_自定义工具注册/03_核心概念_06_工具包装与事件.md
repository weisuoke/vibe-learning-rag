# 核心概念 06：工具包装与事件

> **事件驱动架构 - 扩展工具行为的强大机制**

## 概述

Pi-mono 使用事件系统来支持工具调用的监听和拦截。通过 tool_call 和 tool_result 事件,Extension 可以在工具执行前后添加自定义逻辑,实现日志记录、性能监控、权限检查等功能。

---

## 工具包装机制

### wrapRegisteredTool

**源码位置**:
```
sourcecode/pi-mono/packages/coding-agent/src/core/extensions/wrapper.ts
```

**作用**: 将注册的工具包装成可监听的工具

**流程**:
```
原始工具 → wrapRegisteredTool → 包装后的工具
```

**包装后的工具**:
- 调用前触发 tool_call 事件
- 执行原始工具的 execute 函数
- 调用后触发 tool_result 事件

---

## 事件系统

### tool_call 事件

**触发时机**: 工具执行前

**事件数据**:
```typescript
interface ToolCallEvent {
  tool: ToolDefinition;      // 工具定义
  params: any;                // 调用参数
  context: ExtensionContext;  // 执行上下文
}
```

**用途**:
- 记录工具调用日志
- 验证参数
- 权限检查
- 性能监控(记录开始时间)

### tool_result 事件

**触发时机**: 工具执行后

**事件数据**:
```typescript
interface ToolResultEvent {
  tool: ToolDefinition;       // 工具定义
  params: any;                 // 调用参数
  result: AgentToolResult;     // 执行结果
  context: ExtensionContext;   // 执行上下文
}
```

**用途**:
- 记录工具结果日志
- 性能监控(计算执行时间)
- 错误追踪
- 结果后处理

---

## 监听事件

### 基本用法

```typescript
export const myExtension: Extension = {
  name: 'my-extension',
  version: '1.0.0',
  
  async activate(context) {
    // 监听工具调用
    context.on('tool_call', (event) => {
      context.logger.info('Tool called:', event.tool.name);
      context.logger.info('Parameters:', event.params);
    });
    
    // 监听工具结果
    context.on('tool_result', (event) => {
      context.logger.info('Tool result:', event.result.content);
    });
  }
};
```

### 性能监控示例

```typescript
export const performanceExtension: Extension = {
  name: 'performance-extension',
  version: '1.0.0',
  
  async activate(context) {
    // 记录开始时间
    context.on('tool_call', (event) => {
      const startTime = Date.now();
      event.context.session.set(`tool_start_${event.tool.name}`, startTime);
    });
    
    // 计算执行时间
    context.on('tool_result', (event) => {
      const startTime = event.context.session.get(`tool_start_${event.tool.name}`);
      if (startTime) {
        const duration = Date.now() - startTime;
        context.logger.info(`Tool ${event.tool.name} took ${duration}ms`);
        
        // 清理
        event.context.session.delete(`tool_start_${event.tool.name}`);
      }
    });
  }
};
```

### 错误追踪示例

```typescript
export const errorTrackingExtension: Extension = {
  name: 'error-tracking-extension',
  version: '1.0.0',
  
  async activate(context) {
    context.on('tool_result', (event) => {
      // 检查是否有错误
      if (event.result.metadata?.error) {
        context.logger.error('Tool failed:', {
          tool: event.tool.name,
          params: event.params,
          error: event.result.content
        });
        
        // 可以发送到错误追踪服务
        // await sendToErrorTracking({...});
      }
    });
  }
};
```

---

## 实战应用

### 应用 1: 工具使用统计

```typescript
export const statsExtension: Extension = {
  name: 'stats-extension',
  version: '1.0.0',
  
  async activate(context) {
    // 初始化统计
    const stats = context.session.get('tool_stats') || {};
    
    context.on('tool_call', (event) => {
      const toolName = event.tool.name;
      stats[toolName] = (stats[toolName] || 0) + 1;
      context.session.set('tool_stats', stats);
    });
    
    // 注册查看统计的工具
    context.registerTool({
      name: 'show-stats',
      description: 'Show tool usage statistics',
      parameters: Type.Object({}),
      execute: async () => {
        const stats = context.session.get('tool_stats') || {};
        const lines = Object.entries(stats)
          .map(([tool, count]) => `${tool}: ${count}`)
          .join('\n');
        return { content: lines || 'No tools used yet' };
      }
    });
  }
};
```

### 应用 2: 工具调用审计

```typescript
export const auditExtension: Extension = {
  name: 'audit-extension',
  version: '1.0.0',
  
  async activate(context) {
    const auditLog = [];
    
    context.on('tool_call', (event) => {
      auditLog.push({
        type: 'call',
        tool: event.tool.name,
        params: event.params,
        timestamp: new Date().toISOString()
      });
    });
    
    context.on('tool_result', (event) => {
      auditLog.push({
        type: 'result',
        tool: event.tool.name,
        success: !event.result.metadata?.error,
        timestamp: new Date().toISOString()
      });
    });
    
    // 定期保存审计日志
    setInterval(() => {
      if (auditLog.length > 0) {
        fs.appendFileSync('audit.log', JSON.stringify(auditLog) + '\n');
        auditLog.length = 0;
      }
    }, 60000);  // 每分钟保存一次
  }
};
```

---

## 最佳实践

### 1. 不要阻塞事件处理

```typescript
// ✅ 正确: 异步处理不阻塞
context.on('tool_call', async (event) => {
  // 不要 await 长时间操作
  logToService(event).catch(err => {
    context.logger.error('Failed to log:', err);
  });
});

// ❌ 错误: 阻塞事件处理
context.on('tool_call', async (event) => {
  await longRunningOperation();  // 会延迟工具执行
});
```

### 2. 处理事件监听器中的错误

```typescript
// ✅ 正确
context.on('tool_result', (event) => {
  try {
    processResult(event.result);
  } catch (error) {
    context.logger.error('Event handler error:', error);
  }
});
```

### 3. 清理资源

```typescript
// ✅ 正确: 在 deactivate 中清理
export const myExtension: Extension = {
  async activate(context) {
    const interval = setInterval(() => {
      // 定期任务
    }, 60000);
    
    context.session.set('interval', interval);
  },
  
  async deactivate(context) {
    const interval = context.session.get('interval');
    if (interval) {
      clearInterval(interval);
    }
  }
};
```

---

## 总结

**工具包装与事件的关键要点**:

1. **wrapRegisteredTool**: 包装工具,添加事件触发
2. **tool_call 事件**: 工具执行前触发
3. **tool_result 事件**: 工具执行后触发
4. **应用场景**: 日志记录、性能监控、错误追踪、统计分析

**最佳实践**:
- 不要阻塞事件处理
- 处理事件监听器中的错误
- 清理资源

理解工具包装与事件系统,你就能扩展工具的行为,实现强大的监控和审计功能!
