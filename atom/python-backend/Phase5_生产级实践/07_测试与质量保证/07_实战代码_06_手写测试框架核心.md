# 实战代码 06 - 手写测试框架核心

## 为什么要手写测试框架？

### 学习目标

通过手写一个简化版的测试框架，深入理解：
1. pytest 如何发现测试
2. fixture 机制如何工作
3. 断言增强如何实现
4. 测试报告如何生成

### 不是为了替代 pytest

**重要**：这个手写框架仅用于学习，生产环境请使用 pytest。

---

## 第一步：测试发现

### 实现测试发现机制

```python
# minitest/discovery.py
"""测试发现"""
import os
import importlib.util
from pathlib import Path
from typing import List, Callable

class TestDiscovery:
    """测试发现器"""

    def __init__(self, test_dir: str = "tests"):
        self.test_dir = test_dir

    def discover_test_files(self) -> List[Path]:
        """发现测试文件"""
        test_files = []
        test_path = Path(self.test_dir)

        if not test_path.exists():
            return test_files

        # 递归查找所有 test_*.py 文件
        for file_path in test_path.rglob("test_*.py"):
            test_files.append(file_path)

        return test_files

    def load_module(self, file_path: Path):
        """加载模块"""
        spec = importlib.util.spec_from_file_location(
            file_path.stem,
            file_path
        )
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

    def discover_test_functions(self, module) -> List[Callable]:
        """发现测试函数"""
        test_functions = []

        for name in dir(module):
            if name.startswith("test_"):
                obj = getattr(module, name)
                if callable(obj):
                    test_functions.append(obj)

        return test_functions

    def discover_all_tests(self) -> List[tuple]:
        """发现所有测试"""
        all_tests = []

        for file_path in self.discover_test_files():
            try:
                module = self.load_module(file_path)
                test_functions = self.discover_test_functions(module)

                for test_func in test_functions:
                    all_tests.append((file_path, test_func))

            except Exception as e:
                print(f"Error loading {file_path}: {e}")

        return all_tests


# 使用示例
if __name__ == "__main__":
    discovery = TestDiscovery()

    # 发现测试文件
    test_files = discovery.discover_test_files()
    print(f"Found {len(test_files)} test files:")
    for file in test_files:
        print(f"  - {file}")

    # 发现所有测试
    all_tests = discovery.discover_all_tests()
    print(f"\nFound {len(all_tests)} tests:")
    for file_path, test_func in all_tests:
        print(f"  - {file_path.name}::{test_func.__name__}")
```

### 测试发现器

```python
# tests/test_discovery.py
"""测试发现器测试"""

def test_discovery_finds_test_files():
    """测试：发现测试文件"""
    from minitest.discovery import TestDiscovery

    discovery = TestDiscovery()
    test_files = discovery.discover_test_files()

    assert len(test_files) > 0
    assert all(f.name.startswith("test_") for f in test_files)


def test_discovery_finds_test_functions():
    """测试：发现测试函数"""
    from minitest.discovery import TestDiscovery
    from pathlib import Path

    discovery = TestDiscovery()
    module = discovery.load_module(Path(__file__))
    test_functions = discovery.discover_test_functions(module)

    assert len(test_functions) >= 2
    assert all(f.__name__.startswith("test_") for f in test_functions)
```

---

## 第二步：测试运行器

### 实现测试运行器

```python
# minitest/runner.py
"""测试运行器"""
import time
from typing import List, Callable
from dataclasses import dataclass
from enum import Enum

class TestStatus(Enum):
    """测试状态"""
    PASSED = "PASSED"
    FAILED = "FAILED"
    ERROR = "ERROR"
    SKIPPED = "SKIPPED"

@dataclass
class TestResult:
    """测试结果"""
    name: str
    status: TestStatus
    duration: float
    error: Exception | None = None
    traceback: str | None = None

class TestRunner:
    """测试运行器"""

    def __init__(self):
        self.results: List[TestResult] = []

    def run_test(self, test_func: Callable) -> TestResult:
        """运行单个测试"""
        start_time = time.time()

        try:
            # 运行测试
            test_func()

            # 测试通过
            duration = time.time() - start_time
            return TestResult(
                name=test_func.__name__,
                status=TestStatus.PASSED,
                duration=duration
            )

        except AssertionError as e:
            # 断言失败
            duration = time.time() - start_time
            import traceback
            return TestResult(
                name=test_func.__name__,
                status=TestStatus.FAILED,
                duration=duration,
                error=e,
                traceback=traceback.format_exc()
            )

        except Exception as e:
            # 其他错误
            duration = time.time() - start_time
            import traceback
            return TestResult(
                name=test_func.__name__,
                status=TestStatus.ERROR,
                duration=duration,
                error=e,
                traceback=traceback.format_exc()
            )

    def run_tests(self, tests: List[Callable]) -> List[TestResult]:
        """运行多个测试"""
        self.results = []

        for test_func in tests:
            result = self.run_test(test_func)
            self.results.append(result)

        return self.results

    def print_results(self):
        """打印测试结果"""
        print("\n" + "=" * 70)
        print("TEST RESULTS")
        print("=" * 70)

        for result in self.results:
            status_symbol = {
                TestStatus.PASSED: "✓",
                TestStatus.FAILED: "✗",
                TestStatus.ERROR: "E",
                TestStatus.SKIPPED: "S"
            }[result.status]

            print(f"{status_symbol} {result.name} ({result.duration:.3f}s)")

            if result.status in [TestStatus.FAILED, TestStatus.ERROR]:
                print(f"  Error: {result.error}")
                if result.traceback:
                    print(f"  {result.traceback}")

        # 统计
        passed = sum(1 for r in self.results if r.status == TestStatus.PASSED)
        failed = sum(1 for r in self.results if r.status == TestStatus.FAILED)
        errors = sum(1 for r in self.results if r.status == TestStatus.ERROR)
        total = len(self.results)

        print("\n" + "=" * 70)
        print(f"Total: {total} | Passed: {passed} | Failed: {failed} | Errors: {errors}")
        print("=" * 70)


# 使用示例
if __name__ == "__main__":
    # 定义测试
    def test_addition():
        assert 1 + 1 == 2

    def test_subtraction():
        assert 5 - 3 == 2

    def test_failing():
        assert 1 + 1 == 3  # 这个会失败

    # 运行测试
    runner = TestRunner()
    runner.run_tests([test_addition, test_subtraction, test_failing])
    runner.print_results()
```

---

## 第三步：Fixture 机制

### 实现简单的 Fixture

```python
# minitest/fixtures.py
"""Fixture 机制"""
from typing import Callable, Dict, Any
from functools import wraps
import inspect

class FixtureRegistry:
    """Fixture 注册表"""

    def __init__(self):
        self.fixtures: Dict[str, Callable] = {}
        self.fixture_cache: Dict[str, Any] = {}

    def register(self, name: str, func: Callable):
        """注册 fixture"""
        self.fixtures[name] = func

    def get(self, name: str) -> Any:
        """获取 fixture 值"""
        # 检查缓存
        if name in self.fixture_cache:
            return self.fixture_cache[name]

        # 执行 fixture 函数
        if name in self.fixtures:
            fixture_func = self.fixtures[name]

            # 检查 fixture 是否依赖其他 fixture
            sig = inspect.signature(fixture_func)
            kwargs = {}
            for param_name in sig.parameters:
                if param_name in self.fixtures:
                    kwargs[param_name] = self.get(param_name)

            # 执行 fixture
            value = fixture_func(**kwargs)

            # 缓存结果
            self.fixture_cache[name] = value
            return value

        raise ValueError(f"Fixture '{name}' not found")

    def clear_cache(self):
        """清除缓存"""
        self.fixture_cache.clear()


# 全局 fixture 注册表
_fixture_registry = FixtureRegistry()


def fixture(func: Callable) -> Callable:
    """Fixture 装饰器"""
    _fixture_registry.register(func.__name__, func)

    @wraps(func)
    def wrapper():
        return _fixture_registry.get(func.__name__)

    return wrapper


def inject_fixtures(test_func: Callable) -> Callable:
    """注入 fixture 到测试函数"""
    @wraps(test_func)
    def wrapper():
        # 获取测试函数的参数
        sig = inspect.signature(test_func)
        kwargs = {}

        for param_name in sig.parameters:
            if param_name in _fixture_registry.fixtures:
                kwargs[param_name] = _fixture_registry.get(param_name)

        # 运行测试
        result = test_func(**kwargs)

        # 清除 fixture 缓存
        _fixture_registry.clear_cache()

        return result

    return wrapper


# 使用示例
if __name__ == "__main__":
    # 定义 fixture
    @fixture
    def sample_data():
        return {"name": "Alice", "age": 25}

    @fixture
    def sample_list():
        return [1, 2, 3, 4, 5]

    @fixture
    def computed_value(sample_data):
        # 依赖其他 fixture
        return sample_data["age"] * 2

    # 定义测试
    @inject_fixtures
    def test_with_fixture(sample_data):
        assert sample_data["name"] == "Alice"

    @inject_fixtures
    def test_with_multiple_fixtures(sample_data, sample_list):
        assert len(sample_list) == 5
        assert sample_data["age"] == 25

    @inject_fixtures
    def test_with_dependent_fixture(computed_value):
        assert computed_value == 50

    # 运行测试
    test_with_fixture()
    test_with_multiple_fixtures()
    test_with_dependent_fixture()

    print("All tests passed!")
```

---

## 第四步：断言增强

### 实现断言增强

```python
# minitest/assertions.py
"""断言增强"""
import ast
import inspect

class AssertionError(Exception):
    """增强的断言错误"""
    pass

def enhanced_assert(condition, message=None):
    """增强的断言"""
    if not condition:
        # 获取调用栈
        frame = inspect.currentframe().f_back
        code = frame.f_code
        filename = code.co_filename
        lineno = frame.f_lineno

        # 读取源代码
        with open(filename, 'r') as f:
            lines = f.readlines()
            source_line = lines[lineno - 1].strip()

        # 构建错误消息
        error_msg = f"\nAssertion failed at {filename}:{lineno}\n"
        error_msg += f"  {source_line}\n"

        if message:
            error_msg += f"  Message: {message}\n"

        # 尝试解析表达式
        try:
            # 提取 assert 后的表达式
            if "enhanced_assert(" in source_line:
                expr_start = source_line.index("enhanced_assert(") + len("enhanced_assert(")
                expr_end = source_line.rindex(")")
                expr = source_line[expr_start:expr_end].split(",")[0].strip()

                # 评估表达式的值
                local_vars = frame.f_locals
                global_vars = frame.f_globals

                try:
                    left, op, right = parse_comparison(expr)
                    left_val = eval(left, global_vars, local_vars)
                    right_val = eval(right, global_vars, local_vars)

                    error_msg += f"  Left:  {left} = {repr(left_val)}\n"
                    error_msg += f"  Right: {right} = {repr(right_val)}\n"
                except:
                    pass

        except:
            pass

        raise AssertionError(error_msg)

def parse_comparison(expr: str) -> tuple:
    """解析比较表达式"""
    operators = ["==", "!=", "<", ">", "<=", ">=", "in", "not in"]

    for op in operators:
        if op in expr:
            parts = expr.split(op, 1)
            return parts[0].strip(), op, parts[1].strip()

    return expr, "", ""


# 使用示例
if __name__ == "__main__":
    # 测试增强断言
    def test_enhanced_assert():
        x = 5
        y = 10

        # 这个会通过
        enhanced_assert(x < y)

        # 这个会失败，显示详细信息
        try:
            enhanced_assert(x > y, "x should be greater than y")
        except AssertionError as e:
            print(e)

    test_enhanced_assert()
```

---

## 第五步：完整的测试框架

### 整合所有组件

```python
# minitest/framework.py
"""完整的测试框架"""
from minitest.discovery import TestDiscovery
from minitest.runner import TestRunner, TestStatus
from minitest.fixtures import inject_fixtures, _fixture_registry
from typing import List
import sys

class MiniTest:
    """迷你测试框架"""

    def __init__(self, test_dir: str = "tests"):
        self.discovery = TestDiscovery(test_dir)
        self.runner = TestRunner()

    def run(self) -> int:
        """运行所有测试"""
        print("=" * 70)
        print("MiniTest - A Simple Testing Framework")
        print("=" * 70)

        # 发现测试
        all_tests = self.discovery.discover_all_tests()
        print(f"\nDiscovered {len(all_tests)} tests\n")

        if not all_tests:
            print("No tests found!")
            return 0

        # 运行测试
        for file_path, test_func in all_tests:
            # 注入 fixture
            wrapped_test = inject_fixtures(test_func)

            # 运行测试
            result = self.runner.run_test(wrapped_test)

            # 实时显示结果
            status_symbol = {
                TestStatus.PASSED: "✓",
                TestStatus.FAILED: "✗",
                TestStatus.ERROR: "E"
            }[result.status]

            print(f"{status_symbol} {file_path.name}::{result.name}")

        # 打印总结
        self.runner.print_results()

        # 返回退出码
        failed = sum(
            1 for r in self.runner.results
            if r.status in [TestStatus.FAILED, TestStatus.ERROR]
        )
        return 1 if failed > 0 else 0


def main():
    """主函数"""
    minitest = MiniTest()
    exit_code = minitest.run()
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
```

---

## 使用示例

### 创建测试文件

```python
# tests/test_example.py
"""示例测试"""
from minitest.fixtures import fixture

@fixture
def sample_data():
    """示例数据 fixture"""
    return {"name": "Alice", "age": 25}

@fixture
def sample_list():
    """示例列表 fixture"""
    return [1, 2, 3, 4, 5]

def test_basic_assertion():
    """测试：基本断言"""
    assert 1 + 1 == 2

def test_with_fixture(sample_data):
    """测试：使用 fixture"""
    assert sample_data["name"] == "Alice"
    assert sample_data["age"] == 25

def test_with_multiple_fixtures(sample_data, sample_list):
    """测试：使用多个 fixture"""
    assert len(sample_list) == 5
    assert sample_data["age"] == 25

def test_string_operations():
    """测试：字符串操作"""
    text = "Hello, World!"
    assert "Hello" in text
    assert text.startswith("Hello")
    assert text.endswith("!")

def test_list_operations():
    """测试：列表操作"""
    numbers = [1, 2, 3, 4, 5]
    assert len(numbers) == 5
    assert sum(numbers) == 15
    assert max(numbers) == 5

def test_failing_example():
    """测试：失败示例"""
    # 这个测试会失败
    assert 1 + 1 == 3
```

### 运行测试

```bash
# 运行测试框架
python -m minitest.framework
```

**输出示例**：

```
======================================================================
MiniTest - A Simple Testing Framework
======================================================================

Discovered 6 tests

✓ test_example.py::test_basic_assertion
✓ test_example.py::test_with_fixture
✓ test_example.py::test_with_multiple_fixtures
✓ test_example.py::test_string_operations
✓ test_example.py::test_list_operations
✗ test_example.py::test_failing_example

======================================================================
TEST RESULTS
======================================================================
✓ test_basic_assertion (0.001s)
✓ test_with_fixture (0.001s)
✓ test_with_multiple_fixtures (0.001s)
✓ test_string_operations (0.001s)
✓ test_list_operations (0.001s)
✗ test_failing_example (0.001s)
  Error: assert 1 + 1 == 3

======================================================================
Total: 6 | Passed: 5 | Failed: 1 | Errors: 0
======================================================================
```

---

## 对比 pytest

### 功能对比

| 功能 | MiniTest | pytest |
|------|----------|--------|
| 测试发现 | ✓ 基础实现 | ✓ 完整实现 |
| 测试运行 | ✓ 基础实现 | ✓ 完整实现 |
| Fixture | ✓ 简化版 | ✓ 完整实现 |
| 断言增强 | ✓ 基础实现 | ✓ 完整实现 |
| 参数化 | ✗ 未实现 | ✓ 完整实现 |
| 插件系统 | ✗ 未实现 | ✓ 完整实现 |
| 并行运行 | ✗ 未实现 | ✓ 完整实现 |
| 覆盖率 | ✗ 未实现 | ✓ 完整实现 |

### MiniTest 的局限性

1. **功能简化**：只实现了核心功能
2. **性能较差**：没有优化
3. **错误处理不完善**：缺少边界情况处理
4. **缺少高级特性**：参数化、标记、插件等

### 为什么使用 pytest？

1. **功能完整**：支持所有测试场景
2. **性能优化**：经过多年优化
3. **生态丰富**：大量插件和工具
4. **社区支持**：活跃的社区和文档

---

## 扩展练习

### 练习1：实现参数化测试

```python
# minitest/parametrize.py
"""参数化测试"""
from typing import List, Any
from functools import wraps

def parametrize(argnames: str, argvalues: List[Any]):
    """参数化装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper():
            # 解析参数名
            param_names = [name.strip() for name in argnames.split(",")]

            # 运行每组参数
            for values in argvalues:
                if not isinstance(values, tuple):
                    values = (values,)

                # 构建参数字典
                kwargs = dict(zip(param_names, values))

                # 运行测试
                func(**kwargs)

        # 标记为参数化测试
        wrapper._parametrized = True
        wrapper._param_count = len(argvalues)

        return wrapper

    return decorator


# 使用示例
@parametrize("a,b,expected", [
    (1, 2, 3),
    (2, 3, 5),
    (5, 5, 10),
])
def test_addition(a, b, expected):
    assert a + b == expected
```

### 练习2：实现测试标记

```python
# minitest/marks.py
"""测试标记"""
from functools import wraps

def mark(name: str):
    """标记装饰器"""
    def decorator(func):
        if not hasattr(func, "_marks"):
            func._marks = []
        func._marks.append(name)
        return func
    return decorator


# 使用示例
@mark("slow")
def test_slow_operation():
    import time
    time.sleep(1)
    assert True

@mark("integration")
def test_database_connection():
    # 测试数据库连接
    assert True
```

### 练习3：实现 Setup/Teardown

```python
# minitest/hooks.py
"""Setup/Teardown 钩子"""

class TestHooks:
    """测试钩子"""

    def __init__(self):
        self.setup_functions = []
        self.teardown_functions = []

    def setup(self, func):
        """注册 setup 函数"""
        self.setup_functions.append(func)
        return func

    def teardown(self, func):
        """注册 teardown 函数"""
        self.teardown_functions.append(func)
        return func

    def run_setup(self):
        """运行所有 setup"""
        for func in self.setup_functions:
            func()

    def run_teardown(self):
        """运行所有 teardown"""
        for func in self.teardown_functions:
            func()


# 全局钩子
_hooks = TestHooks()

def setup(func):
    return _hooks.setup(func)

def teardown(func):
    return _hooks.teardown(func)


# 使用示例
@setup
def setup_database():
    print("Setting up database...")

@teardown
def teardown_database():
    print("Tearing down database...")
```

---

## 学到了什么？

### 核心概念

1. **测试发现**：通过文件名和函数名模式匹配
2. **测试运行**：捕获异常、记录结果、生成报告
3. **Fixture 机制**：依赖注入、缓存、清理
4. **断言增强**：解析表达式、显示详细信息

### pytest 的优势

1. **成熟稳定**：经过多年实战验证
2. **功能丰富**：支持各种测试场景
3. **性能优化**：并行运行、智能缓存
4. **生态完善**：插件、工具、文档

### 实践建议

1. **生产环境使用 pytest**：不要重复造轮子
2. **理解原理**：知道框架如何工作
3. **合理使用**：选择合适的工具和模式
4. **持续学习**：关注测试最佳实践

---

## 总结

### 核心要点

1. **测试框架原理**：发现、运行、报告
2. **Fixture 机制**：依赖注入、缓存管理
3. **断言增强**：详细的错误信息
4. **pytest 优势**：功能完整、性能优化

### 最佳实践

- 理解原理，但使用成熟工具
- 不要重复造轮子
- 关注测试质量，而非框架实现
- 持续学习和改进
