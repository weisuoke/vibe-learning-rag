# 核心概念 02 - 集成测试与数据库测试

## 什么是集成测试？

### 定义

**集成测试（Integration Test）**：测试多个组件协作时的行为

**与单元测试的区别**：

| 维度 | 单元测试 | 集成测试 |
|------|----------|----------|
| 测试范围 | 单个函数/类 | 多个组件协作 |
| 依赖 | Mock 所有依赖 | 使用真实依赖 |
| 速度 | 毫秒级 | 秒级 |
| 隔离性 | 完全隔离 | 部分隔离 |
| 定位问题 | 精确到函数 | 精确到模块 |

### 集成测试的价值

```python
# 单元测试：每个函数都通过
def test_save_user():
    """测试：保存用户"""
    user = User(username="alice")
    assert user.username == "alice"  # ✅ 通过

def test_query_user():
    """测试：查询用户"""
    users = query_users()
    assert isinstance(users, list)  # ✅ 通过

# 但集成测试可能失败
def test_save_and_query_user(db_session):
    """测试：保存后查询用户"""
    user = User(username="alice")
    db_session.add(user)
    db_session.commit()

    found = db_session.query(User).filter_by(username="alice").first()
    assert found is not None  # ❌ 失败！数据库配置错误
```

**集成测试发现的问题**：
- 组件间接口不匹配
- 数据库配置错误
- 事务管理问题
- 缓存一致性问题
- 并发问题

---

## 数据库测试策略

### 策略1：使用测试数据库

**原理**：为测试创建独立的数据库

```python
# conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.database import Base

@pytest.fixture(scope="session")
def test_engine():
    """测试数据库引擎"""
    # 使用内存数据库（最快）
    engine = create_engine("sqlite:///:memory:")

    # 或使用独立的测试数据库
    # engine = create_engine("postgresql://localhost/test_db")

    # 创建所有表
    Base.metadata.create_all(engine)

    yield engine

    # 清理
    Base.metadata.drop_all(engine)
    engine.dispose()

@pytest.fixture
def db_session(test_engine):
    """数据库会话"""
    Session = sessionmaker(bind=test_engine)
    session = Session()

    yield session

    # 每个测试后回滚
    session.rollback()
    session.close()
```

**使用示例**：

```python
# tests/test_user.py
def test_create_user(db_session):
    """测试：创建用户"""
    user = User(username="alice", email="alice@example.com")
    db_session.add(user)
    db_session.commit()

    assert user.id is not None

def test_query_user(db_session):
    """测试：查询用户"""
    # 准备数据
    user = User(username="alice", email="alice@example.com")
    db_session.add(user)
    db_session.commit()

    # 查询
    found = db_session.query(User).filter_by(username="alice").first()
    assert found is not None
    assert found.email == "alice@example.com"
```

### 策略2：事务回滚

**原理**：每个测试在事务中运行，测试后回滚

```python
# conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

@pytest.fixture(scope="session")
def engine():
    """数据库引擎"""
    return create_engine("postgresql://localhost/test_db")

@pytest.fixture(scope="session")
def tables(engine):
    """创建表"""
    Base.metadata.create_all(engine)
    yield
    Base.metadata.drop_all(engine)

@pytest.fixture
def db_session(engine, tables):
    """数据库会话（事务回滚）"""
    connection = engine.connect()
    transaction = connection.begin()
    Session = sessionmaker(bind=connection)
    session = Session()

    yield session

    # 回滚事务（撤销所有修改）
    session.close()
    transaction.rollback()
    connection.close()
```

**好处**：
- 每个测试都有干净的数据库状态
- 测试之间完全隔离
- 不需要手动清理数据

### 策略3：测试数据 Factory

**原理**：使用工厂模式创建测试数据

```python
# tests/factories.py
class UserFactory:
    """用户工厂"""

    @staticmethod
    def create(
        username: str = "test_user",
        email: str = "test@example.com",
        **kwargs
    ) -> User:
        """创建用户"""
        return User(username=username, email=email, **kwargs)

    @staticmethod
    def create_batch(count: int, **kwargs) -> list[User]:
        """批量创建用户"""
        return [
            UserFactory.create(
                username=f"user_{i}",
                email=f"user_{i}@example.com",
                **kwargs
            )
            for i in range(count)
        ]

# tests/test_user.py
def test_query_multiple_users(db_session):
    """测试：查询多个用户"""
    # 使用工厂创建测试数据
    users = UserFactory.create_batch(10)
    for user in users:
        db_session.add(user)
    db_session.commit()

    # 查询
    found = db_session.query(User).all()
    assert len(found) == 10
```

---

## SQLAlchemy 测试最佳实践

### 1. 测试模型定义

```python
# app/models/user.py
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import validates
from app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)

    @validates("username")
    def validate_username(self, key, value):
        if len(value) < 3:
            raise ValueError("Username must be at least 3 characters")
        return value

# tests/test_user_model.py
def test_user_model_creation():
    """测试：用户模型创建"""
    user = User(username="alice", email="alice@example.com")
    assert user.username == "alice"
    assert user.email == "alice@example.com"

def test_user_model_validation():
    """测试：用户名验证"""
    with pytest.raises(ValueError, match="at least 3 characters"):
        User(username="ab", email="test@example.com")

def test_user_model_persistence(db_session):
    """测试：用户持久化"""
    user = User(username="alice", email="alice@example.com")
    db_session.add(user)
    db_session.commit()

    # 验证 ID 已生成
    assert user.id is not None

    # 验证可以查询到
    found = db_session.query(User).filter_by(id=user.id).first()
    assert found.username == "alice"
```

### 2. 测试关系

```python
# app/models/post.py
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from app.database import Base

class Post(Base):
    __tablename__ = "posts"

    id = Column(Integer, primary_key=True)
    title = Column(String(200), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    # 关系
    user = relationship("User", back_populates="posts")

# app/models/user.py (添加反向关系)
class User(Base):
    # ... 其他字段
    posts = relationship("Post", back_populates="user")

# tests/test_relationships.py
def test_user_posts_relationship(db_session):
    """测试：用户-文章关系"""
    # 创建用户
    user = User(username="alice", email="alice@example.com")
    db_session.add(user)
    db_session.commit()

    # 创建文章
    post1 = Post(title="Post 1", user_id=user.id)
    post2 = Post(title="Post 2", user_id=user.id)
    db_session.add_all([post1, post2])
    db_session.commit()

    # 测试关系
    assert len(user.posts) == 2
    assert user.posts[0].title == "Post 1"
    assert post1.user.username == "alice"
```

### 3. 测试查询

```python
# app/repositories/user_repository.py
from sqlalchemy.orm import Session
from app.models.user import User

class UserRepository:
    def __init__(self, session: Session):
        self.session = session

    def get_by_username(self, username: str) -> User | None:
        """根据用户名查询用户"""
        return self.session.query(User).filter_by(username=username).first()

    def get_active_users(self) -> list[User]:
        """获取活跃用户"""
        return self.session.query(User).filter_by(is_active=True).all()

# tests/test_user_repository.py
def test_get_by_username(db_session):
    """测试：根据用户名查询"""
    # 准备数据
    user = User(username="alice", email="alice@example.com")
    db_session.add(user)
    db_session.commit()

    # 测试查询
    repo = UserRepository(db_session)
    found = repo.get_by_username("alice")

    assert found is not None
    assert found.username == "alice"

def test_get_by_username_not_found(db_session):
    """测试：用户不存在"""
    repo = UserRepository(db_session)
    found = repo.get_by_username("nonexistent")
    assert found is None

def test_get_active_users(db_session):
    """测试：获取活跃用户"""
    # 准备数据
    active_user = User(username="alice", email="alice@example.com", is_active=True)
    inactive_user = User(username="bob", email="bob@example.com", is_active=False)
    db_session.add_all([active_user, inactive_user])
    db_session.commit()

    # 测试查询
    repo = UserRepository(db_session)
    active_users = repo.get_active_users()

    assert len(active_users) == 1
    assert active_users[0].username == "alice"
```

### 4. 测试事务

```python
# app/services/user_service.py
from sqlalchemy.orm import Session
from app.models.user import User

class UserService:
    def __init__(self, session: Session):
        self.session = session

    def create_user_with_profile(self, username: str, email: str, bio: str):
        """创建用户和个人资料（事务）"""
        try:
            # 创建用户
            user = User(username=username, email=email)
            self.session.add(user)
            self.session.flush()  # 获取 user.id

            # 创建个人资料
            profile = Profile(user_id=user.id, bio=bio)
            self.session.add(profile)

            # 提交事务
            self.session.commit()
            return user
        except Exception as e:
            # 回滚事务
            self.session.rollback()
            raise

# tests/test_user_service.py
def test_create_user_with_profile_success(db_session):
    """测试：创建用户和个人资料（成功）"""
    service = UserService(db_session)
    user = service.create_user_with_profile(
        username="alice",
        email="alice@example.com",
        bio="Hello"
    )

    # 验证用户已创建
    assert user.id is not None

    # 验证个人资料已创建
    profile = db_session.query(Profile).filter_by(user_id=user.id).first()
    assert profile is not None
    assert profile.bio == "Hello"

def test_create_user_with_profile_rollback(db_session):
    """测试：创建失败时回滚"""
    service = UserService(db_session)

    # 模拟失败（例如：bio 太长）
    with pytest.raises(Exception):
        service.create_user_with_profile(
            username="alice",
            email="alice@example.com",
            bio="x" * 10000  # 超过限制
        )

    # 验证用户未创建（事务已回滚）
    user = db_session.query(User).filter_by(username="alice").first()
    assert user is None
```

---

## Mock 与 Stub

### 什么是 Mock？

**Mock**：模拟对象，用于替代真实的依赖

**使用场景**：
- 外部 API 调用
- 慢速操作（文件 I/O、网络请求）
- 不确定性操作（随机数、时间）
- 难以触发的场景（异常、边界条件）

### unittest.mock 基础

```python
from unittest.mock import Mock, patch, MagicMock

# 1. 创建 Mock 对象
mock_obj = Mock()
mock_obj.method.return_value = 42
assert mock_obj.method() == 42

# 2. 验证调用
mock_obj.method(1, 2, key="value")
mock_obj.method.assert_called_once_with(1, 2, key="value")

# 3. Mock 属性
mock_obj.name = "test"
assert mock_obj.name == "test"

# 4. Mock 异常
mock_obj.method.side_effect = ValueError("Error")
with pytest.raises(ValueError):
    mock_obj.method()
```

### Mock 外部 API

```python
# app/services/llm_service.py
import openai

class LLMService:
    def get_completion(self, prompt: str) -> str:
        """调用 OpenAI API"""
        response = openai.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}]
        )
        return response.choices[0].message.content

# tests/test_llm_service.py
from unittest.mock import Mock, patch

def test_get_completion():
    """测试：获取 LLM 回复（Mock）"""
    # Mock OpenAI API 响应
    mock_response = Mock()
    mock_response.choices = [Mock()]
    mock_response.choices[0].message.content = "这是测试回复"

    with patch("openai.chat.completions.create") as mock_create:
        mock_create.return_value = mock_response

        # 调用服务
        service = LLMService()
        result = service.get_completion("你好")

        # 验证结果
        assert result == "这是测试回复"

        # 验证 API 被正确调用
        mock_create.assert_called_once_with(
            model="gpt-4",
            messages=[{"role": "user", "content": "你好"}]
        )
```

### Mock 数据库查询

```python
# app/services/user_service.py
class UserService:
    def __init__(self, session):
        self.session = session

    def get_user_count(self) -> int:
        """获取用户数量"""
        return self.session.query(User).count()

# tests/test_user_service.py
from unittest.mock import Mock

def test_get_user_count():
    """测试：获取用户数量（Mock）"""
    # Mock session
    mock_session = Mock()
    mock_session.query.return_value.count.return_value = 100

    # 测试
    service = UserService(mock_session)
    count = service.get_user_count()

    assert count == 100
    mock_session.query.assert_called_once_with(User)
```

### Stub vs Mock

**Stub**：提供预定义的返回值

```python
# Stub
class StubUserRepository:
    def get_by_id(self, user_id: int) -> User:
        return User(id=user_id, username="test")

def test_with_stub():
    repo = StubUserRepository()
    user = repo.get_by_id(1)
    assert user.username == "test"
```

**Mock**：验证交互

```python
# Mock
def test_with_mock():
    mock_repo = Mock()
    mock_repo.get_by_id.return_value = User(id=1, username="test")

    service = UserService(mock_repo)
    user = service.get_user(1)

    # 验证交互
    mock_repo.get_by_id.assert_called_once_with(1)
```

---

## AI Agent 中的集成测试应用

### 场景1：测试 RAG 检索链

```python
# app/rag/retrieval_chain.py
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings

class RetrievalChain:
    def __init__(self, vector_store: Chroma):
        self.vector_store = vector_store

    def retrieve(self, query: str, k: int = 3) -> list[str]:
        """检索相关文档"""
        results = self.vector_store.similarity_search(query, k=k)
        return [doc.page_content for doc in results]

# tests/test_retrieval_chain.py
import pytest
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings

@pytest.fixture
def vector_store():
    """测试向量存储"""
    documents = [
        "RAG 是检索增强生成技术",
        "Embedding 是文本向量化",
        "LangChain 是 AI 开发框架"
    ]
    embeddings = OpenAIEmbeddings()
    return Chroma.from_texts(documents, embeddings)

def test_retrieval_chain(vector_store):
    """测试：RAG 检索链"""
    chain = RetrievalChain(vector_store)
    results = chain.retrieve("什么是 RAG", k=1)

    assert len(results) == 1
    assert "RAG" in results[0]

def test_retrieval_chain_multiple_results(vector_store):
    """测试：检索多个结果"""
    chain = RetrievalChain(vector_store)
    results = chain.retrieve("AI 开发", k=2)

    assert len(results) == 2
```

### 场景2：测试对话记忆管理

```python
# app/agent/memory.py
from langchain.memory import ConversationBufferMemory

class ConversationManager:
    def __init__(self):
        self.memory = ConversationBufferMemory()

    def add_message(self, role: str, content: str):
        """添加消息"""
        if role == "user":
            self.memory.chat_memory.add_user_message(content)
        else:
            self.memory.chat_memory.add_ai_message(content)

    def get_history(self) -> list[dict]:
        """获取历史消息"""
        return self.memory.chat_memory.messages

# tests/test_conversation_manager.py
def test_conversation_manager():
    """测试：对话管理器"""
    manager = ConversationManager()

    # 添加消息
    manager.add_message("user", "你好")
    manager.add_message("assistant", "你好！有什么可以帮助你的吗？")

    # 获取历史
    history = manager.get_history()

    assert len(history) == 2
    assert history[0].content == "你好"
    assert history[1].content == "你好！有什么可以帮助你的吗？"

def test_conversation_manager_multiple_turns():
    """测试：多轮对话"""
    manager = ConversationManager()

    # 多轮对话
    for i in range(5):
        manager.add_message("user", f"问题 {i}")
        manager.add_message("assistant", f"回答 {i}")

    history = manager.get_history()
    assert len(history) == 10
```

### 场景3：测试 Agent 工具调用

```python
# app/agent/tools.py
from langchain.tools import Tool

def search_documents(query: str) -> str:
    """搜索文档工具"""
    # 实际实现会调用向量数据库
    return f"搜索结果: {query}"

def calculator(expression: str) -> str:
    """计算器工具"""
    try:
        result = eval(expression)
        return str(result)
    except Exception as e:
        return f"计算错误: {e}"

# 创建工具列表
tools = [
    Tool(
        name="search",
        func=search_documents,
        description="搜索文档"
    ),
    Tool(
        name="calculator",
        func=calculator,
        description="执行数学计算"
    )
]

# tests/test_agent_tools.py
def test_search_tool():
    """测试：搜索工具"""
    result = search_documents("RAG")
    assert "RAG" in result

def test_calculator_tool():
    """测试：计算器工具"""
    result = calculator("2 + 3")
    assert result == "5"

def test_calculator_tool_error():
    """测试：计算器错误处理"""
    result = calculator("invalid")
    assert "错误" in result

def test_tools_integration():
    """测试：工具集成"""
    # 测试所有工具都可用
    assert len(tools) == 2
    assert tools[0].name == "search"
    assert tools[1].name == "calculator"

    # 测试工具调用
    search_result = tools[0].func("test")
    calc_result = tools[1].func("1 + 1")

    assert "test" in search_result
    assert calc_result == "2"
```

---

## 集成测试的最佳实践

### 1. 测试隔离

**每个测试都应该独立运行**

```python
# ✅ 好的做法
@pytest.fixture
def clean_db(db_session):
    """每个测试都有干净的数据库"""
    yield db_session
    db_session.query(User).delete()
    db_session.commit()

def test_create_user(clean_db):
    user = User(username="alice")
    clean_db.add(user)
    clean_db.commit()

def test_query_user(clean_db):
    # 不依赖上一个测试
    user = User(username="bob")
    clean_db.add(user)
    clean_db.commit()
    # ...
```

### 2. 测试数据管理

**使用 Factory 或 Fixture 管理测试数据**

```python
# conftest.py
@pytest.fixture
def sample_users(db_session):
    """创建示例用户"""
    users = [
        User(username=f"user_{i}", email=f"user_{i}@example.com")
        for i in range(10)
    ]
    db_session.add_all(users)
    db_session.commit()
    return users

def test_query_users(db_session, sample_users):
    """测试：查询用户"""
    users = db_session.query(User).all()
    assert len(users) == 10
```

### 3. 测试性能

**集成测试应该快速**

```python
# ✅ 使用内存数据库
engine = create_engine("sqlite:///:memory:")

# ✅ 限制测试数据量
users = UserFactory.create_batch(10)  # 而非 10000

# ✅ 使用事务回滚而非删除数据
@pytest.fixture
def db_session(engine):
    connection = engine.connect()
    transaction = connection.begin()
    session = Session(bind=connection)
    yield session
    transaction.rollback()
```

### 4. 测试覆盖关键路径

**不需要测试所有组合，重点测试关键路径**

```python
# ✅ 测试关键路径
def test_user_registration_flow(db_session):
    """测试：用户注册流程"""
    # 1. 创建用户
    user = User(username="alice", email="alice@example.com")
    db_session.add(user)
    db_session.commit()

    # 2. 验证用户已创建
    found = db_session.query(User).filter_by(username="alice").first()
    assert found is not None

    # 3. 验证可以登录
    assert found.check_password("password")

# ❌ 不需要测试所有边界条件（单元测试已覆盖）
```

---

## 总结

### 核心要点

1. **集成测试**：测试多个组件协作，使用真实依赖
2. **数据库测试**：使用测试数据库、事务回滚、测试数据工厂
3. **Mock**：隔离外部依赖，提高测试速度和稳定性
4. **SQLAlchemy**：测试模型、关系、查询、事务

### AI Agent 应用

- 测试 RAG 检索链
- 测试对话记忆管理
- 测试 Agent 工具调用
- 测试多组件协作

### 下一步

掌握了集成测试和数据库测试后，继续学习：
- API 测试与端到端测试
- 异步测试
- 性能测试
