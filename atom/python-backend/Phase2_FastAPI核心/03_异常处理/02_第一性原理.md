# 第一性原理

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

---

## FastAPI 异常处理的第一性原理

### 1. 最基础的定义

**异常处理 = 当程序出错时，告诉用户发生了什么 + 如何处理**

仅此而已！没有更基础的了。

在 Web API 中：
- **出错**：数据库连接失败、用户未授权、LLM 调用超时...
- **告诉用户**：返回 HTTP 状态码（404、500）+ 错误信息
- **如何处理**：统一的错误响应格式，方便前端解析

---

### 2. 为什么需要异常处理？

**核心问题：程序总会出错，如何让错误可控、可理解、可追踪？**

#### 问题1：没有异常处理会怎样？

```python
# ❌ 没有异常处理
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = db.query(User).filter(User.id == user_id).first()
    return user.name  # 如果 user 是 None，直接崩溃！
```

**结果：**
- 用户看到 500 Internal Server Error（不知道发生了什么）
- 开发者看到 `AttributeError: 'NoneType' object has no attribute 'name'`（需要翻日志）
- 前端无法区分是网络问题还是用户不存在

#### 问题2：手动处理每个错误太繁琐

```python
# ❌ 手动处理，代码重复
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            return JSONResponse(
                status_code=404,
                content={"error": "User not found"}
            )
        return user
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )
```

**问题：**
- 每个路由都要写 try/except
- 错误响应格式不统一
- 无法集中管理错误日志

#### 问题3：不同类型的错误需要不同处理

- **业务错误**（用户不存在）→ 404，前端显示友好提示
- **系统错误**（数据库崩溃）→ 500，记录日志，通知运维
- **第三方错误**（OpenAI 超时）→ 503，前端显示"服务暂时不可用"

**如何区分和统一处理？**

---

### 3. 异常处理的三层价值

#### 价值1：用户体验 - 友好的错误提示

**没有异常处理：**
```json
{
  "detail": "Internal Server Error"
}
```
用户：？？？发生了什么？

**有异常处理：**
```json
{
  "error": "用户不存在",
  "code": "USER_NOT_FOUND",
  "message": "未找到 ID 为 123 的用户，请检查用户 ID 是否正确"
}
```
用户：哦，原来是用户 ID 错了！

#### 价值2：开发效率 - 统一的错误处理逻辑

**类比 Express 错误中间件：**
```javascript
// Express: 所有错误都会被这个中间件捕获
app.use((err, req, res, next) => {
  res.status(err.status || 500).json({
    error: err.message
  });
});
```

**FastAPI 同样的思路：**
```python
# FastAPI: 所有 HTTPException 都会被自动处理
@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": exc.detail}
    )
```

**好处：**
- 路由代码只关注业务逻辑，不用写 try/except
- 错误处理逻辑集中在一个地方，易于维护
- 修改错误格式只需改一处

#### 价值3：生产可靠性 - 可追踪、可监控

**在 AI Agent 开发中：**
```python
@app.exception_handler(OpenAIError)
async def openai_error_handler(request, exc):
    # 1. 记录详细日志
    logger.error(f"OpenAI API 调用失败: {exc}", extra={
        "request_id": request.state.request_id,
        "user_id": request.state.user_id,
        "model": "gpt-4"
    })

    # 2. 发送告警（生产环境）
    if settings.ENV == "production":
        alert_service.send("OpenAI API 异常", exc)

    # 3. 返回友好错误
    return JSONResponse(
        status_code=503,
        content={"error": "AI 服务暂时不可用，请稍后重试"}
    )
```

**价值：**
- 所有 OpenAI 错误都会被记录和告警
- 可以统计 API 失败率、响应时间
- 快速定位问题（哪个用户、哪个请求、什么时间）

---

### 4. 从第一性原理推导 FastAPI 异常处理架构

**推理链：**

```
1. 程序会出错（事实）
   ↓
2. 需要告诉用户发生了什么（用户体验）
   ↓
3. 不同错误需要不同处理（业务需求）
   ↓
4. 手动处理每个错误太繁琐（开发效率）
   ↓
5. 需要一个统一的错误处理机制（架构设计）
   ↓
6. FastAPI 提供三层机制：
   - HTTPException：快速抛错（类似 throw new Error）
   - exception_handler：捕获特定异常（类似 Express 错误中间件）
   - 全局中间件：统一错误格式（类似 Express app.use）
   ↓
7. 最终架构：
   业务代码抛异常 → 异常处理器捕获 → 统一格式返回 → 记录日志
```

---

### 5. 一句话总结第一性原理

**异常处理是将程序错误转换为用户可理解的信息，通过统一的机制提升用户体验、开发效率和系统可靠性。**

---

## 与 Express 的对比

| 概念 | Express | FastAPI | 第一性原理 |
|------|---------|---------|-----------|
| 抛出错误 | `throw new Error()` | `raise HTTPException()` | 告诉系统出错了 |
| 捕获错误 | 错误中间件 | `@app.exception_handler()` | 统一处理错误 |
| 错误传播 | `next(err)` | 自动传播 | 错误向上冒泡 |
| 错误格式 | 手动设置 | 自动设置 | 统一响应格式 |

---

## 在 AI Agent 开发中的体现

### 场景1：LLM 调用失败

**第一性原理：** LLM API 会超时、限流、余额不足，需要区分处理

```python
from openai import OpenAI, OpenAIError, RateLimitError

@app.post("/chat")
async def chat(message: str):
    try:
        response = openai.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": message}]
        )
        return {"reply": response.choices[0].message.content}
    except RateLimitError:
        # 限流 → 429，告诉用户稍后重试
        raise HTTPException(status_code=429, detail="请求过于频繁，请稍后重试")
    except OpenAIError as e:
        # 其他错误 → 503，记录日志
        logger.error(f"OpenAI API 错误: {e}")
        raise HTTPException(status_code=503, detail="AI 服务暂时不可用")
```

### 场景2：数据库异常

**第一性原理：** 数据库会连接失败、查询超时，需要统一处理

```python
from sqlalchemy.exc import SQLAlchemyError

@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_exception_handler(request, exc):
    logger.error(f"数据库错误: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "数据库操作失败，请稍后重试"}
    )
```

### 场景3：业务逻辑错误

**第一性原理：** 业务规则会被违反（用户未授权、资源不存在），需要友好提示

```python
class UserNotFoundError(Exception):
    pass

@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request, exc):
    return JSONResponse(
        status_code=404,
        content={
            "error": "用户不存在",
            "code": "USER_NOT_FOUND",
            "message": str(exc)
        }
    )
```

---

## 关键洞察

1. **异常处理不是可选的**：程序总会出错，不处理只会让问题更严重
2. **统一比分散好**：集中处理比每个路由都写 try/except 更高效
3. **区分错误类型**：业务错误、系统错误、第三方错误需要不同处理
4. **用户体验优先**：错误信息要让用户看得懂，而不是技术术语
5. **生产环境必备**：日志、告警、监控都依赖异常处理

---

**下一步：** 学习 FastAPI 的三层异常处理机制（HTTPException、exception_handler、全局中间件）
