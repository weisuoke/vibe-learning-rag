# 第一性原理

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题，而不是通过类比或经验。

---

## 装饰器的第一性原理

### 1. 最基础的定义

**装饰器 = 接收函数作为参数，返回新函数的函数**

```python
def decorator(func):
    def new_func():
        # 做一些事情
        return func()
    return new_func
```

仅此而已！没有更基础的了。

装饰器不是什么魔法，它只是：
- 输入：一个函数
- 输出：一个新函数（通常包装了原函数）

---

### 2. 为什么需要装饰器？

**核心问题：如何在不修改原函数代码的情况下，为函数添加额外功能？**

想象你有100个函数，现在需要为每个函数添加日志记录：

```python
# ❌ 方案1：修改每个函数（糟糕）
def get_user():
    print("LOG: get_user called")  # 添加日志
    return {"id": 1, "name": "Alice"}

def create_order():
    print("LOG: create_order called")  # 添加日志
    return {"order_id": 123}

# 问题：
# 1. 需要修改100个函数
# 2. 日志逻辑和业务逻辑混在一起
# 3. 如果要改日志格式，又要改100次
```

```python
# ✅ 方案2：使用装饰器（优雅）
def log_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"LOG: {func.__name__} called")
        return func(*args, **kwargs)
    return wrapper

@log_decorator
def get_user():
    return {"id": 1, "name": "Alice"}

@log_decorator
def create_order():
    return {"order_id": 123}

# 优势：
# 1. 原函数代码不变
# 2. 日志逻辑独立
# 3. 修改日志只需改装饰器
```

**从第一性原理看：装饰器解决了"关注点分离"的问题。**

---

### 3. 装饰器的三层价值

#### 价值1：代码复用（DRY原则）

**问题**：相同的逻辑在多处重复

**装饰器解决**：把重复逻辑提取到装饰器中

```python
# 场景：多个 API 端点都需要检查用户权限

# ❌ 没有装饰器：每个函数都重复权限检查
def get_user_profile(user_id: int):
    if not check_permission():  # 重复
        raise Exception("No permission")
    return get_profile(user_id)

def delete_user(user_id: int):
    if not check_permission():  # 重复
        raise Exception("No permission")
    return delete(user_id)

# ✅ 使用装饰器：权限检查逻辑只写一次
@require_permission
def get_user_profile(user_id: int):
    return get_profile(user_id)

@require_permission
def delete_user(user_id: int):
    return delete(user_id)
```

#### 价值2：关注点分离（SoC原则）

**问题**：业务逻辑和横切关注点（日志、权限、缓存）混在一起

**装饰器解决**：把横切关注点从业务逻辑中分离出来

```python
# 横切关注点：日志、计时、缓存、权限...
# 这些功能与业务逻辑无关，但每个函数都需要

@log_request        # 日志记录
@timing             # 性能监控
@cache              # 结果缓存
@require_auth       # 权限检查
def get_ai_response(prompt: str):
    # 这里只关注业务逻辑：调用 AI 生成回复
    return call_openai_api(prompt)

# 业务逻辑清晰，横切关注点独立管理
```

#### 价值3：声明式编程（Declarative）

**问题**：命令式代码冗长，意图不清晰

**装饰器解决**：用声明的方式表达意图

```python
# FastAPI 的路由装饰器是声明式编程的典范

# ❌ 命令式（如果没有装饰器）
def handle_chat():
    return {"message": "Hello"}

app.add_route("/chat", handle_chat, methods=["POST"])

# ✅ 声明式（使用装饰器）
@app.post("/chat")
def handle_chat():
    return {"message": "Hello"}

# 一眼就能看出：
# - 这是一个 POST 端点
# - 路径是 /chat
# - 处理函数是 handle_chat
```

---

### 4. 从第一性原理推导 FastAPI 路由装饰器

**推理链：**

```
1. 前提：Web 框架需要把 URL 映射到处理函数
   ↓
2. 传统方式：手动注册路由（命令式）
   app.add_route("/users", get_users, methods=["GET"])
   ↓
3. 问题：路由定义和函数定义分离，不直观
   ↓
4. 改进：能否在函数定义时就声明路由？
   ↓
5. 解决方案：装饰器！
   @app.get("/users")
   def get_users(): ...
   ↓
6. 装饰器做了什么？
   - 接收函数 get_users
   - 把函数注册到路由表：routes["/users"]["GET"] = get_users
   - 返回原函数（或包装后的函数）
   ↓
7. 结果：声明式路由定义，代码更清晰
```

**FastAPI 装饰器的简化实现：**

```python
class FastAPI:
    def __init__(self):
        self.routes = {}

    def get(self, path: str):
        """路由装饰器工厂"""
        def decorator(func):
            # 注册路由
            self.routes[path] = {"method": "GET", "handler": func}
            return func
        return decorator

app = FastAPI()

@app.get("/users")  # 等价于：get_users = app.get("/users")(get_users)
def get_users():
    return [{"id": 1, "name": "Alice"}]

# 装饰器执行后：
# app.routes = {"/users": {"method": "GET", "handler": get_users}}
```

---

### 5. 一句话总结第一性原理

**装饰器是函数式编程中的高阶函数，通过函数组合实现代码复用和关注点分离，是 Python 元编程的基础工具。**

---

## 从第一性原理理解 `@` 语法糖

```python
# 这两种写法完全等价：

# 方式1：使用 @ 语法糖
@decorator
def func():
    pass

# 方式2：手动调用装饰器
def func():
    pass
func = decorator(func)
```

**`@` 只是语法糖，让代码更简洁易读。**

---

## 装饰器的执行时机（重要！）

```python
def my_decorator(func):
    print(f"装饰器执行：装饰 {func.__name__}")
    def wrapper():
        print(f"wrapper 执行：调用 {func.__name__}")
        return func()
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

# 输出：装饰器执行：装饰 say_hello
# 注意：这是在定义时就执行了，不是调用时！

say_hello()
# 输出：
# wrapper 执行：调用 say_hello
# Hello!
```

**关键点：**
- **装饰器在函数定义时执行**（模块导入时）
- **wrapper 在函数调用时执行**（运行时）

这就是为什么 FastAPI 能在启动时就知道所有路由！

---

## 总结：装饰器的本质

从第一性原理看，装饰器是：

1. **函数式编程**：函数是一等公民，可以作为参数和返回值
2. **高阶函数**：接收函数，返回函数
3. **闭包**：内部函数可以访问外部函数的变量
4. **语法糖**：`@` 让代码更简洁
5. **元编程**：在定义时修改函数行为

**在 AI Agent 开发中，装饰器是构建 API 的核心模式。**
