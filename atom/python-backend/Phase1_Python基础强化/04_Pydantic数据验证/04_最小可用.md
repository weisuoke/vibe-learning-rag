# 最小可用

掌握以下内容，就能开始使用 Pydantic：

---

## 4.1 定义基础模型

**核心：** 继承 `BaseModel`，用类型注解定义字段

```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
    email: str

# 创建实例，自动验证
user = User(name="Alice", age=25, email="alice@example.com")
print(user.name)  # Alice
print(user.age)   # 25
```

**自动转换：**
```python
# 字符串自动转换为整数
user = User(name="Bob", age="30", email="bob@example.com")
print(user.age)  # 30 (int)
print(type(user.age))  # <class 'int'>
```

**在 AI Agent 中：**
```python
class ChatMessage(BaseModel):
    role: str
    content: str

# 验证 LLM 消息格式
message = ChatMessage(role="user", content="Hello")
```

---

## 4.2 可选字段和默认值

**核心：** 使用 `Optional` 或 `= None` 定义可选字段

```python
from typing import Optional
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
    email: Optional[str] = None  # 可选字段
    is_active: bool = True       # 默认值

# 可选字段可以不传
user1 = User(name="Alice", age=25)
print(user1.email)  # None
print(user1.is_active)  # True

# 也可以传值
user2 = User(name="Bob", age=30, email="bob@example.com", is_active=False)
print(user2.email)  # bob@example.com
```

**在 AI Agent 中：**
```python
class ChatRequest(BaseModel):
    messages: list
    model: str = "gpt-3.5-turbo"  # 默认模型
    temperature: float = 0.7       # 默认温度
    max_tokens: Optional[int] = None  # 可选限制
```

---

## 4.3 Field 验证规则

**核心：** 使用 `Field` 添加验证约束

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str = Field(..., min_length=1, max_length=50)
    age: int = Field(..., ge=0, le=150)  # ge: >=, le: <=
    email: str = Field(..., pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")

# 验证失败会抛出异常
try:
    user = User(name="", age=200, email="invalid")
except ValidationError as e:
    print(e)
```

**常用验证规则：**
```python
class Product(BaseModel):
    name: str = Field(..., min_length=1)      # 最小长度
    price: float = Field(..., gt=0)           # gt: >
    stock: int = Field(0, ge=0)               # 默认0，>=0
    tags: list = Field(default_factory=list)  # 默认空列表
```

**在 AI Agent 中：**
```python
class RAGQuery(BaseModel):
    query: str = Field(..., min_length=1, max_length=1000)
    top_k: int = Field(5, ge=1, le=20)  # 检索数量限制
```

---

## 4.4 嵌套模型

**核心：** 模型可以嵌套其他模型

```python
from pydantic import BaseModel
from typing import List

class Address(BaseModel):
    street: str
    city: str
    country: str

class User(BaseModel):
    name: str
    age: int
    address: Address  # 嵌套模型

# 创建嵌套数据
user = User(
    name="Alice",
    age=25,
    address={
        "street": "123 Main St",
        "city": "New York",
        "country": "USA"
    }
)
print(user.address.city)  # New York
```

**列表嵌套：**
```python
class Team(BaseModel):
    name: str
    members: List[User]  # 用户列表

team = Team(
    name="Dev Team",
    members=[
        {"name": "Alice", "age": 25, "address": {...}},
        {"name": "Bob", "age": 30, "address": {...}}
    ]
)
```

**在 AI Agent 中：**
```python
class Message(BaseModel):
    role: str
    content: str

class ChatRequest(BaseModel):
    messages: List[Message]  # 消息列表
    model: str

request = ChatRequest(
    messages=[
        {"role": "user", "content": "Hello"},
        {"role": "assistant", "content": "Hi!"}
    ],
    model="gpt-4"
)
```

---

## 4.5 在 FastAPI 中使用

**核心：** FastAPI 自动使用 Pydantic 验证请求和响应

```python
from fastapi import FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class CreateUserRequest(BaseModel):
    name: str = Field(..., min_length=1)
    age: int = Field(..., ge=0)
    email: str

class UserResponse(BaseModel):
    id: int
    name: str
    age: int
    email: str

@app.post("/users", response_model=UserResponse)
async def create_user(request: CreateUserRequest):
    # FastAPI 自动：
    # 1. 解析请求体 JSON
    # 2. 用 Pydantic 验证数据
    # 3. 转换为 CreateUserRequest 对象
    # 4. 验证失败自动返回 422 错误

    # 你的业务逻辑
    user_id = 1  # 假设保存到数据库

    # 返回响应（自动验证和序列化）
    return UserResponse(
        id=user_id,
        name=request.name,
        age=request.age,
        email=request.email
    )
```

**自动生成的功能：**
- ✅ 请求体验证（类型、范围、格式）
- ✅ 自动类型转换
- ✅ 验证失败返回详细错误信息
- ✅ 自动生成 API 文档（Swagger UI）
- ✅ 响应数据验证和序列化

**在 AI Agent 中：**
```python
@app.post("/chat")
async def chat(request: ChatRequest) -> ChatResponse:
    # request 已经是验证过的 ChatRequest 对象
    # 直接使用，不需要手动验证
    messages = request.messages
    model = request.model

    # 调用 LLM
    response = await llm.chat(messages, model)

    # 返回响应（自动验证）
    return ChatResponse(message=response)
```

---

## 这些知识足以：

**基础能力：**
- ✅ 定义数据模型并自动验证
- ✅ 使用可选字段和默认值
- ✅ 添加基本验证规则（长度、范围）
- ✅ 处理嵌套数据结构
- ✅ 在 FastAPI 中自动验证请求

**实际应用：**
- ✅ 构建 RESTful API 端点
- ✅ 验证 LLM 请求/响应格式
- ✅ 处理复杂的 JSON 数据
- ✅ 自动生成 API 文档
- ✅ 减少 80% 的手动验证代码

**为后续学习打基础：**
- → 自定义验证器（复杂验证逻辑）
- → 模型配置（Config 类）
- → 数据序列化和反序列化
- → 与数据库 ORM 集成
- → 高级类型（Literal, Union, Discriminated Union）

---

## 快速参考

### 基础模板

```python
from pydantic import BaseModel, Field
from typing import Optional, List

class MyModel(BaseModel):
    # 必填字段
    required_field: str

    # 可选字段
    optional_field: Optional[str] = None

    # 默认值
    default_field: int = 0

    # 验证规则
    validated_field: str = Field(..., min_length=1, max_length=100)

    # 嵌套模型
    nested: OtherModel

    # 列表
    items: List[str] = Field(default_factory=list)
```

### FastAPI 模板

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Request(BaseModel):
    field1: str
    field2: int

class Response(BaseModel):
    result: str

@app.post("/endpoint", response_model=Response)
async def endpoint(request: Request):
    # 自动验证 request
    return Response(result="success")
```

---

**版本：** v1.0
**最后更新：** 2026-02-11
