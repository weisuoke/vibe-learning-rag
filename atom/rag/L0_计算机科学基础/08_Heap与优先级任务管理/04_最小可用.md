# 最小可用知识

## 核心目标

**5分钟掌握Heap的最小必要知识，能够在RAG系统中实现基本的优先级队列和Top-K检索。**

---

## 1. 最小概念集

### 1.1 什么是Heap？

**一句话定义：** Heap是用数组存储的"半有序"完全二叉树，只保证父节点优于子节点，不保证兄弟节点之间的顺序。

**两种类型：**
- **Min-heap（最小堆）**：父节点 ≤ 子节点，根节点是最小值
- **Max-heap（最大堆）**：父节点 ≥ 子节点，根节点是最大值

**可视化：**
```
Min-heap示例：
       5
      / \
     10  15
    / \  /
   20 25 30

数组表示：[5, 10, 15, 20, 25, 30]
索引关系：parent(i) = (i-1)//2
         left(i) = 2*i+1
         right(i) = 2*i+2
```

### 1.2 核心操作

**只需记住两个操作：**

1. **Heapify-up（上浮）**：新元素插入末尾后，与父节点比较并交换，直到满足heap性质
2. **Heapify-down（下沉）**：删除根节点后，末尾元素移到根，与较小子节点交换，直到满足heap性质

**时间复杂度：**
- Insert（插入）：O(log n)
- Extract-min/max（删除根）：O(log n)
- Peek（查看根）：O(1)
- Build heap（建堆）：O(n)

### 1.3 Python实现

**使用标准库heapq（最简单）：**

```python
import heapq

# 创建min-heap
heap = []

# 插入元素
heapq.heappush(heap, 5)
heapq.heappush(heap, 10)
heapq.heappush(heap, 3)

print(heap)  # [3, 10, 5] - 数组表示，不是排序数组

# 弹出最小值
min_val = heapq.heappop(heap)
print(min_val)  # 3

# 查看最小值（不删除）
print(heap[0])  # 5

# 从数组建堆
arr = [20, 10, 30, 5, 15]
heapq.heapify(arr)
print(arr)  # [5, 10, 30, 20, 15] - 已是合法min-heap
```

**Max-heap实现（Python 3.14+）：**

```python
import heapq

# Python 3.14新增max-heap函数
heap = []
heapq.heappush_max(heap, 5)
heapq.heappush_max(heap, 10)
heapq.heappush_max(heap, 3)

max_val = heapq.heappop_max(heap)
print(max_val)  # 10
```

**Max-heap实现（Python 3.13及以下）：**

```python
import heapq

# 使用负值模拟max-heap
heap = []
heapq.heappush(heap, -5)
heapq.heappush(heap, -10)
heapq.heappush(heap, -3)

max_val = -heapq.heappop(heap)
print(max_val)  # 10
```

---

## 2. 最小实战场景

### 场景1：优先级任务队列（AI Agent调度）

**需求：** AI Agent需要处理不同优先级的任务，高优先级任务先执行。

```python
import heapq
from dataclasses import dataclass
from typing import Any

@dataclass
class Task:
    priority: int  # 数字越小优先级越高
    task_id: str
    payload: Any

    def __lt__(self, other):
        return self.priority < other.priority

# 创建优先级队列
task_queue = []

# 添加任务
heapq.heappush(task_queue, Task(priority=2, task_id="task1", payload="Normal task"))
heapq.heappush(task_queue, Task(priority=0, task_id="task2", payload="Urgent task"))
heapq.heappush(task_queue, Task(priority=1, task_id="task3", payload="High priority task"))

# 按优先级执行任务
while task_queue:
    task = heapq.heappop(task_queue)
    print(f"Executing {task.task_id}: {task.payload}")

# 输出：
# Executing task2: Urgent task
# Executing task3: High priority task
# Executing task1: Normal task
```

**RAG应用：** 在多租户RAG系统中，付费用户查询优先级高于免费用户。

### 场景2：Top-K文档检索（RAG核心）

**需求：** 从大量文档中找出相似度最高的K个文档。

```python
import heapq

def top_k_documents(documents, query_embedding, k=3):
    """
    使用min-heap找出Top-K最相似文档

    Args:
        documents: [(doc_id, embedding), ...]
        query_embedding: 查询向量
        k: 返回文档数量

    Returns:
        Top-K文档列表
    """
    # 计算相似度（简化为点积）
    def similarity(emb1, emb2):
        return sum(a * b for a, b in zip(emb1, emb2))

    # 使用min-heap维护Top-K
    heap = []

    for doc_id, doc_embedding in documents:
        score = similarity(query_embedding, doc_embedding)

        if len(heap) < k:
            # 堆未满，直接插入
            heapq.heappush(heap, (score, doc_id))
        elif score > heap[0][0]:
            # 新文档分数更高，替换堆顶
            heapq.heapreplace(heap, (score, doc_id))

    # 返回结果（按分数降序）
    return sorted(heap, reverse=True)

# 示例数据
documents = [
    ("doc1", [0.1, 0.2, 0.3]),
    ("doc2", [0.9, 0.8, 0.7]),
    ("doc3", [0.5, 0.5, 0.5]),
    ("doc4", [0.8, 0.9, 0.8]),
    ("doc5", [0.2, 0.1, 0.2]),
]

query = [0.8, 0.8, 0.8]

top_docs = top_k_documents(documents, query, k=3)
print("Top-3 documents:")
for score, doc_id in top_docs:
    print(f"  {doc_id}: {score:.2f}")

# 输出：
# Top-3 documents:
#   doc4: 2.05
#   doc2: 2.04
#   doc3: 1.20
```

**为什么用min-heap找最大值？**
- 堆顶是最小值，容易判断是否需要替换
- 只需维护K个元素，空间复杂度O(K)
- 时间复杂度O(n log K)，优于排序的O(n log n)

### 场景3：合并K个有序列表（多路归并）

**需求：** 合并多个已排序的文档列表（如多个索引的检索结果）。

```python
import heapq

def merge_k_sorted_lists(lists):
    """
    合并K个有序列表

    Args:
        lists: [[1,4,5], [1,3,4], [2,6]]

    Returns:
        合并后的有序列表
    """
    # 使用min-heap维护每个列表的当前最小值
    heap = []
    result = []

    # 初始化：将每个列表的第一个元素加入堆
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst[0], i, 0))  # (值, 列表索引, 元素索引)

    # 不断取出最小值，并加入该列表的下一个元素
    while heap:
        val, list_idx, elem_idx = heapq.heappop(heap)
        result.append(val)

        # 如果该列表还有元素，加入下一个
        if elem_idx + 1 < len(lists[list_idx]):
            next_val = lists[list_idx][elem_idx + 1]
            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))

    return result

# 示例：合并3个检索结果
search_results = [
    [1, 4, 5],    # 索引1的结果
    [1, 3, 4],    # 索引2的结果
    [2, 6]        # 索引3的结果
]

merged = merge_k_sorted_lists(search_results)
print(merged)  # [1, 1, 2, 3, 4, 4, 5, 6]
```

**RAG应用：** 混合检索（BM25 + 向量检索）时，需要合并多个排序结果。

---

## 3. 最小记忆点

### 3.1 三个关键不等式

```python
# Min-heap性质
heap[i] <= heap[2*i + 1]  # 父节点 <= 左子节点
heap[i] <= heap[2*i + 2]  # 父节点 <= 右子节点

# Max-heap性质
heap[i] >= heap[2*i + 1]  # 父节点 >= 左子节点
heap[i] >= heap[2*i + 2]  # 父节点 >= 右子节点
```

### 3.2 两个核心操作

```python
def heapify_up(heap, i):
    """上浮：新元素插入后调整"""
    while i > 0:
        parent = (i - 1) // 2
        if heap[i] < heap[parent]:  # Min-heap
            heap[i], heap[parent] = heap[parent], heap[i]
            i = parent
        else:
            break

def heapify_down(heap, i):
    """下沉：删除根节点后调整"""
    n = len(heap)
    while 2 * i + 1 < n:
        left = 2 * i + 1
        right = 2 * i + 2
        smallest = i

        if heap[left] < heap[smallest]:
            smallest = left
        if right < n and heap[right] < heap[smallest]:
            smallest = right

        if smallest != i:
            heap[i], heap[smallest] = heap[smallest], heap[i]
            i = smallest
        else:
            break
```

### 3.3 一个反直觉点

**Top-K最大值用min-heap，Top-K最小值用max-heap！**

```python
# 找3个最大值 - 使用min-heap
def top_k_largest(nums, k):
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:  # 比堆顶大才替换
            heapq.heapreplace(heap, num)
    return heap

# 找3个最小值 - 使用max-heap（负值模拟）
def top_k_smallest(nums, k):
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, -num)
        elif num < -heap[0]:  # 比堆顶小才替换
            heapq.heapreplace(heap, -num)
    return [-x for x in heap]
```

---

## 4. 最小调试技巧

### 4.1 验证heap性质

```python
def is_valid_min_heap(heap):
    """检查数组是否满足min-heap性质"""
    n = len(heap)
    for i in range(n):
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and heap[i] > heap[left]:
            return False
        if right < n and heap[i] > heap[right]:
            return False

    return True

# 测试
heap1 = [5, 10, 15, 20, 25]
print(is_valid_min_heap(heap1))  # True

heap2 = [5, 3, 15, 20, 25]
print(is_valid_min_heap(heap2))  # False (3 < 5)
```

### 4.2 可视化heap结构

```python
def print_heap(heap):
    """打印heap的树形结构"""
    if not heap:
        return

    n = len(heap)
    height = 0
    temp = n
    while temp > 0:
        height += 1
        temp //= 2

    index = 0
    for level in range(height):
        level_size = 2 ** level
        for _ in range(level_size):
            if index >= n:
                break
            print(f"{heap[index]:3}", end=" ")
            index += 1
        print()

# 示例
heap = [5, 10, 15, 20, 25, 30, 35]
print_heap(heap)
# 输出：
#   5
#  10  15
#  20  25  30  35
```

---

## 5. 最小陷阱清单

### 陷阱1：误以为heap是排序数组

```python
# ❌ 错误理解
heap = [5, 10, 15, 20, 25]
print(heap[2])  # 15 - 不是第3小的元素！

# ✅ 正确理解
# heap只保证heap[0]是最小值
# 其他元素只保证父子关系，不保证全局顺序
```

### 陷阱2：直接修改heap数组

```python
# ❌ 错误做法
heap = [5, 10, 15]
heap[0] = 20  # 直接修改破坏了heap性质
print(heap)  # [20, 10, 15] - 不再是合法heap

# ✅ 正确做法
heap = [5, 10, 15]
heapq.heappop(heap)  # 删除最小值
heapq.heappush(heap, 20)  # 插入新值
print(heap)  # [10, 20, 15] - 仍是合法heap
```

### 陷阱3：忘记Python heapq只支持min-heap

```python
# ❌ 错误：期望max-heap
heap = [10, 5, 20]
heapq.heapify(heap)
print(heap[0])  # 5 - 是最小值，不是最大值

# ✅ 正确：使用负值或Python 3.14新函数
# 方法1：负值（Python 3.13及以下）
heap = [-10, -5, -20]
heapq.heapify(heap)
print(-heap[0])  # 20 - 最大值

# 方法2：Python 3.14新函数
heap = [10, 5, 20]
heapq.heapify_max(heap)
print(heap[0])  # 20 - 最大值
```

---

## 6. 最小学习路径

### 第1步：理解heap性质（5分钟）
- 画出min-heap和max-heap的树形结构
- 理解数组索引关系：parent, left, right
- 验证几个数组是否满足heap性质

### 第2步：使用heapq库（10分钟）
- 练习heappush、heappop、heapify
- 实现优先级队列
- 解决Top-K问题

### 第3步：手写heapify操作（15分钟）
- 实现heapify_up
- 实现heapify_down
- 理解为什么是O(log n)

### 第4步：应用到RAG场景（10分钟）
- 实现Top-K文档检索
- 实现多路归并
- 理解在AI Agent中的应用

**总计：40分钟掌握最小可用知识**

---

## 7. 快速参考卡

```python
# ============ Python heapq速查 ============

import heapq

# 创建heap
heap = []

# 插入元素
heapq.heappush(heap, 5)

# 弹出最小值
min_val = heapq.heappop(heap)

# 查看最小值（不删除）
min_val = heap[0]

# 从数组建堆
arr = [3, 1, 4, 1, 5]
heapq.heapify(arr)  # O(n)

# 弹出并插入（原子操作）
heapq.heapreplace(heap, 10)  # 先pop再push

# 插入并弹出（原子操作）
heapq.heappushpop(heap, 10)  # 先push再pop

# Top-K最大值
top_k = heapq.nlargest(k, arr)

# Top-K最小值
top_k = heapq.nsmallest(k, arr)

# ============ 时间复杂度 ============
# heappush:      O(log n)
# heappop:       O(log n)
# heapify:       O(n)
# heapreplace:   O(log n)
# nlargest:      O(n log k)
# nsmallest:     O(n log k)

# ============ 空间复杂度 ============
# heap本身:      O(n)
# Top-K:         O(k)
```

---

## 8. 一句话总结

**Heap是用数组实现的半有序树，通过heapify维护父子关系，实现O(log n)的优先级队列操作，是AI Agent任务调度和RAG Top-K检索的基础工具。**

---

## 下一步学习

掌握最小可用知识后，可以深入学习：

1. **第一性原理** → 理解为什么heap是最优的优先级队列实现
2. **核心概念** → 深入学习堆化操作、堆排序、Top-K算法
3. **实战代码** → 手写MinHeap、实现AI Agent调度器、Beam Search应用
4. **面试必问** → 准备heap相关的高频面试题
5. **化骨绵掌** → 掌握10个核心知识点，融会贯通

**记住：** 先用起来（heapq库），再理解原理（heapify操作），最后优化应用（RAG场景）。
