# 核心概念：链式组合模式

> **本节目标**：深入理解LCEL的四种核心组合模式，掌握RunnableSequence、RunnableParallel、RunnableBranch和RunnablePassthrough的原理与实战应用。

---

## 一、RunnableSequence：顺序组合

### 1.1 核心原理

**RunnableSequence** 是LCEL最基础的组合模式，通过管道操作符 `|` 实现顺序执行。

**执行流程**：
```
input → Runnable1 → output1 → Runnable2 → output2 → Runnable3 → final_output
```

**源码实现**（简化）：
```python
class RunnableSequence(Runnable[Input, Output]):
    """顺序执行多个Runnable"""

    def __init__(self, *steps: Runnable):
        self.steps = steps

    def invoke(self, input: Input) -> Output:
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result
```

### 1.2 基础用法

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

# 定义组件
prompt = ChatPromptTemplate.from_template("总结：{text}")
llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
parser = StrOutputParser()

# 顺序组合
chain = prompt | llm | parser

# 执行
result = chain.invoke({"text": "LangChain是一个LLM应用开发框架"})
print(result)  # "LangChain是用于构建LLM应用的框架"
```

### 1.3 高级特性

**自动类型推导**：
```python
# LCEL自动推导输入输出类型
chain = prompt | llm | parser
# Input: dict → Output: str
```

**流式支持**：
```python
# 自动支持流式输出
for chunk in chain.stream({"text": "..."}):
    print(chunk, end="", flush=True)
```

**批处理支持**：
```python
# 自动支持批量处理
results = chain.batch([
    {"text": "文本1"},
    {"text": "文本2"}
])
```

### 1.4 实战场景：RAG问答链

```python
from langchain_community.vectorstores import Chroma
from langchain_core.runnables import RunnablePassthrough

# 检索器
retriever = vectorstore.as_retriever()

# 格式化文档
def format_docs(docs):
    return "\n\n".join(doc.page_content for doc in docs)

# RAG链
rag_chain = (
    {"context": retriever | format_docs, "question": RunnablePassthrough()}
    | prompt
    | llm
    | parser
)

# 使用
answer = rag_chain.invoke("什么是LCEL？")
```

---

## 二、RunnableParallel：并发执行

### 2.1 核心原理

**RunnableParallel** 并发执行多个独立的Runnable，返回字典结果。

**性能优势**：
- 串行：Time = T1 + T2 + T3
- 并行：Time = max(T1, T2, T3)
- **实测提升**：40-50%

**源码实现**（简化）：
```python
class RunnableParallel(Runnable[Input, Dict[str, Output]]):
    """并发执行多个Runnable"""

    def __init__(self, steps: Dict[str, Runnable]):
        self.steps = steps

    async def ainvoke(self, input: Input) -> Dict[str, Output]:
        # 并发执行所有步骤
        tasks = {
            key: runnable.ainvoke(input)
            for key, runnable in self.steps.items()
        }
        results = await asyncio.gather(*tasks.values())
        return dict(zip(tasks.keys(), results))
```

### 2.2 基础用法

```python
from langchain_core.runnables import RunnableParallel

# 定义并行分支
parallel = RunnableParallel({
    "summary": summary_chain,
    "keywords": keyword_chain,
    "sentiment": sentiment_chain
})

# 执行（并发）
result = parallel.invoke({"text": "..."})
# {
#   "summary": "...",
#   "keywords": ["...", "..."],
#   "sentiment": "positive"
# }
```

### 2.3 字典语法糖

```python
# 方式1：显式RunnableParallel
parallel = RunnableParallel({
    "branch_a": chain_a,
    "branch_b": chain_b
})

# 方式2：字典语法糖（推荐）
parallel = {
    "branch_a": chain_a,
    "branch_b": chain_b
}

# 两者等价
```

### 2.4 实战场景：多维度分析

```python
# 场景：同时进行多种分析
analysis_chain = (
    RunnableParallel({
        "summary": prompt_summary | llm | parser,
        "keywords": prompt_keywords | llm | parser,
        "sentiment": prompt_sentiment | llm | parser,
        "category": prompt_category | llm | parser
    })
)

# 一次调用，获取所有分析结果
results = analysis_chain.invoke({"text": article_text})
```

### 2.5 嵌套使用

```python
# 并行 + 顺序组合
chain = (
    input_processing
    | RunnableParallel({
        "path_a": step_a1 | step_a2,
        "path_b": step_b1 | step_b2
    })
    | merge_results
)
```

---

## 三、RunnableBranch：条件路由

### 3.1 核心原理

**RunnableBranch** 根据条件选择执行路径，类似if-elif-else。

**关键特性**：
- 确定性路由（vs Agent的非确定性）
- 可审计（合规要求）
- 高性能（无LLM调用）

**源码实现**（简化）：
```python
class RunnableBranch(Runnable[Input, Output]):
    """条件路由"""

    def __init__(self, branches: List[Tuple[Callable, Runnable]], default: Runnable):
        self.branches = branches
        self.default = default

    def invoke(self, input: Input) -> Output:
        for condition, runnable in self.branches:
            if condition(input):
                return runnable.invoke(input)
        return self.default.invoke(input)
```

### 3.2 基础用法

```python
from langchain_core.runnables import RunnableBranch

# 定义条件和分支
branch = RunnableBranch(
    [
        (lambda x: x["score"] > 0.8, high_confidence_chain),
        (lambda x: x["score"] > 0.5, medium_confidence_chain)
    ],
    low_confidence_chain  # 默认分支
)

# 执行
result = branch.invoke({"text": "...", "score": 0.9})
# 执行 high_confidence_chain
```

### 3.3 实战场景：智能路由

```python
# 场景：根据查询复杂度路由到不同模型
def is_simple_query(input: dict) -> bool:
    return len(input["query"].split()) < 5

def is_complex_query(input: dict) -> bool:
    return "分析" in input["query"] or "比较" in input["query"]

# 智能路由链
smart_router = RunnableBranch(
    [
        (is_simple_query, fast_model_chain),      # 简单查询 → 快速模型
        (is_complex_query, powerful_model_chain)  # 复杂查询 → 强大模型
    ],
    standard_model_chain  # 默认 → 标准模型
)
```

### 3.4 与Agent的对比

| 特性 | RunnableBranch | Agent |
|------|----------------|-------|
| **决策方式** | 确定性规则 | LLM决策 |
| **性能** | 快（无LLM调用） | 慢（需LLM） |
| **成本** | 低 | 高 |
| **可审计性** | 高（规则明确） | 低（黑盒） |
| **灵活性** | 低（需预定义） | 高（自适应） |
| **适用场景** | 明确规则 | 复杂推理 |

---

## 四、RunnablePassthrough：数据透传

### 4.1 核心原理

**RunnablePassthrough** 将输入原样传递到输出，常用于并行分支中保留原始数据。

**源码实现**：
```python
class RunnablePassthrough(Runnable[Input, Input]):
    """透传输入"""

    def invoke(self, input: Input) -> Input:
        return input
```

### 4.2 基础用法

```python
from langchain_core.runnables import RunnablePassthrough

# 场景：RAG中同时需要context和question
rag_chain = (
    {
        "context": retriever | format_docs,  # 检索context
        "question": RunnablePassthrough()     # 保留原始question
    }
    | prompt
    | llm
)

# 输入
result = rag_chain.invoke("什么是LCEL？")
# prompt接收：{"context": "...", "question": "什么是LCEL？"}
```

### 4.3 assign方法

```python
# 添加新字段而不覆盖原有字段
chain = (
    RunnablePassthrough.assign(
        context=retriever | format_docs
    )
    | prompt
    | llm
)

# 输入：{"question": "..."}
# prompt接收：{"question": "...", "context": "..."}
```

### 4.4 实战场景：多步骤增强

```python
# 逐步增强输入数据
enhanced_chain = (
    RunnablePassthrough.assign(
        keywords=keyword_extractor
    ).assign(
        context=lambda x: retriever.invoke(x["keywords"])
    ).assign(
        summary=summarizer
    )
    | final_processor
)

# 输入：{"text": "..."}
# 输出：{"text": "...", "keywords": [...], "context": "...", "summary": "..."}
```

---

## 五、组合模式最佳实践

### 5.1 选择合适的模式

| 场景 | 推荐模式 | 原因 |
|------|----------|------|
| 顺序处理 | RunnableSequence | 简单清晰 |
| 独立操作 | RunnableParallel | 性能提升40-50% |
| 条件分支 | RunnableBranch | 确定性、可审计 |
| 保留数据 | RunnablePassthrough | 避免数据丢失 |

### 5.2 性能优化技巧

**技巧1：识别可并行操作**
```python
# ❌ 串行（慢）
summary = summary_chain.invoke(text)
keywords = keyword_chain.invoke(text)
# 总时间：T1 + T2

# ✅ 并行（快）
results = RunnableParallel({
    "summary": summary_chain,
    "keywords": keyword_chain
}).invoke(text)
# 总时间：max(T1, T2)
```

**技巧2：避免过度并行**
```python
# ❌ 过度并行（资源耗尽）
parallel = RunnableParallel({
    f"task_{i}": chain for i in range(1000)
})

# ✅ 控制并发数
from langchain_core.runnables import gather_with_concurrency

results = await gather_with_concurrency(
    max_concurrency=10,
    *tasks
)
```

### 5.3 可读性优化

**技巧1：使用中间变量**
```python
# ❌ 难以阅读
chain = (retriever | format_docs | {"context": RunnablePassthrough(), "question": lambda x: x} | prompt | llm | parser)

# ✅ 清晰易读
retrieval = retriever | format_docs
context_and_question = {
    "context": retrieval,
    "question": RunnablePassthrough()
}
generation = prompt | llm | parser

chain = context_and_question | generation
```

**技巧2：添加配置标记**
```python
# 为每个阶段添加名称
chain = (
    retrieval.with_config(run_name="retrieval")
    | generation.with_config(run_name="generation")
    | validation.with_config(run_name="validation")
)
# LangSmith中清晰显示每个阶段
```

### 5.4 错误处理

```python
# 为关键步骤添加错误处理
chain = (
    retrieval
    | generation.with_retry(stop_after_attempt=3)
    | validation
).with_fallbacks([fallback_chain])
```

---

## 六、综合实战案例

### 场景：智能客服系统

```python
from langchain_core.runnables import (
    RunnableSequence,
    RunnableParallel,
    RunnableBranch,
    RunnablePassthrough,
    RunnableLambda
)

# 1. 意图识别
intent_classifier = prompt_intent | llm | parser

# 2. 条件路由
def is_faq(x): return x["intent"] == "faq"
def is_complaint(x): return x["intent"] == "complaint"

router = RunnableBranch(
    [
        (is_faq, faq_chain),
        (is_complaint, complaint_chain)
    ],
    general_chain
)

# 3. 并行增强
enhancer = RunnableParallel({
    "response": router,
    "sentiment": sentiment_chain,
    "keywords": keyword_chain
})

# 4. 完整链
customer_service_chain = (
    RunnablePassthrough.assign(
        intent=intent_classifier
    )
    | enhancer
    | response_formatter
)

# 使用
result = customer_service_chain.invoke({
    "question": "如何退货？",
    "user_id": "123"
})
```

---

## 七、总结

### 核心要点

1. **RunnableSequence**：顺序执行，清晰简单
2. **RunnableParallel**：并发执行，性能提升40-50%
3. **RunnableBranch**：条件路由，确定性决策
4. **RunnablePassthrough**：数据透传，保留原始信息

### 选择指南

```
需要顺序处理？ → RunnableSequence
操作可并行？ → RunnableParallel
需要条件分支？ → RunnableBranch
需要保留数据？ → RunnablePassthrough
```

### 最佳实践

- ✅ 优先使用LCEL而非传统Chain
- ✅ 识别并行机会以提升性能
- ✅ 使用RunnableBranch实现确定性路由
- ✅ 添加配置标记以便调试
- ✅ 为关键步骤添加错误处理

---

**下一步**：学习【错误处理策略】，掌握RunnableRetry和RunnableWithFallbacks的使用。
