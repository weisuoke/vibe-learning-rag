# 最小可用

掌握以下内容，就能开始使用 SQLAlchemy 的关系定义：

## 4.1 一对多关系的基本定义

**最常用的关系类型，90%的场景都是一对多**

```python
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

# "一"的一方（父表）
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)

    # relationship 定义：访问所有对话
    conversations = relationship("Conversation", back_populates="user")

# "多"的一方（子表）
class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)
    title = Column(String)

    # 外键：指向父表
    user_id = Column(Integer, ForeignKey('users.id'))

    # relationship 定义：访问所属用户
    user = relationship("User", back_populates="conversations")
```

**使用方式：**

```python
# 创建用户和对话
user = User(name="Alice")
conv1 = Conversation(title="对话1", user=user)
conv2 = Conversation(title="对话2", user=user)

session.add(user)
session.commit()

# 访问关系
print(user.conversations)  # [conv1, conv2]
print(conv1.user)          # user
```

**关键点：**
- 外键放在"多"的一方（`Conversation.user_id`）
- 两边都要定义 `relationship()`
- 使用 `back_populates` 建立双向关系

---

## 4.2 多对多关系的基本定义

**需要中间表，用于标签、分类等场景**

```python
from sqlalchemy import Table

# 中间表（关联表）
conversation_tags = Table(
    'conversation_tags',
    Base.metadata,
    Column('conversation_id', ForeignKey('conversations.id'), primary_key=True),
    Column('tag_id', ForeignKey('tags.id'), primary_key=True)
)

class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)
    title = Column(String)

    # 多对多关系：通过 secondary 指定中间表
    tags = relationship("Tag", secondary=conversation_tags, back_populates="conversations")

class Tag(Base):
    __tablename__ = 'tags'
    id = Column(Integer, primary_key=True)
    name = Column(String)

    # 反向关系
    conversations = relationship("Conversation", secondary=conversation_tags, back_populates="tags")
```

**使用方式：**

```python
# 创建对话和标签
conv = Conversation(title="Python学习")
tag1 = Tag(name="编程")
tag2 = Tag(name="教育")

# 建立多对多关系
conv.tags.append(tag1)
conv.tags.append(tag2)

session.add(conv)
session.commit()

# 访问关系
print(conv.tags)        # [tag1, tag2]
print(tag1.conversations)  # [conv]
```

**关键点：**
- 需要创建中间表（`Table` 对象，不是 `Base` 子类）
- 使用 `secondary` 参数指定中间表
- 两边都要定义 `relationship()`

---

## 4.3 加载策略（lazy loading）

**控制何时加载关联数据，影响性能**

```python
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)

    # lazy='select'（默认）：访问时才查询
    conversations = relationship("Conversation", lazy='select')

    # lazy='joined'：立即 JOIN 查询
    # conversations = relationship("Conversation", lazy='joined')

    # lazy='selectin'：用 IN 查询（推荐）
    # conversations = relationship("Conversation", lazy='selectin')
```

**对比：**

```python
# lazy='select'（默认）
user = session.get(User, 1)        # SELECT * FROM users WHERE id=1
print(user.conversations)          # SELECT * FROM conversations WHERE user_id=1

# lazy='joined'
user = session.get(User, 1)        # SELECT * FROM users LEFT JOIN conversations ...
print(user.conversations)          # 不再查询，数据已加载

# lazy='selectin'（推荐）
users = session.query(User).all()  # SELECT * FROM users
for user in users:
    print(user.conversations)      # SELECT * FROM conversations WHERE user_id IN (1,2,3...)
```

**选择建议：**
- **默认用 `lazy='select'`**：简单场景
- **用 `lazy='selectin'`**：循环访问关系（避免 N+1 问题）
- **用 `lazy='joined'`**：总是需要关联数据

---

## 4.4 级联操作（cascade）

**删除父对象时，自动处理子对象**

```python
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)

    # cascade='all, delete-orphan'：删除用户时删除所有对话
    conversations = relationship(
        "Conversation",
        back_populates="user",
        cascade="all, delete-orphan"
    )

class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User", back_populates="conversations")
```

**使用方式：**

```python
user = User(name="Alice")
conv1 = Conversation(title="对话1")
conv2 = Conversation(title="对话2")

user.conversations.append(conv1)
user.conversations.append(conv2)

session.add(user)
session.commit()

# 删除用户，自动删除所有对话
session.delete(user)
session.commit()  # conv1 和 conv2 也被删除
```

**常用级联选项：**
- `"all, delete-orphan"`：删除父对象时删除所有子对象，子对象脱离父对象时也删除
- `"all"`：删除父对象时删除所有子对象
- `"save-update"`（默认）：保存父对象时自动保存子对象
- `"delete"`：删除父对象时删除子对象

---

## 4.5 在 FastAPI 中使用

**完整的 API 端点示例**

```python
from fastapi import FastAPI, Depends
from sqlalchemy import create_engine
from sqlalchemy.orm import Session, sessionmaker

# 数据库配置
engine = create_engine("sqlite:///./test.db")
SessionLocal = sessionmaker(bind=engine)
Base.metadata.create_all(engine)

app = FastAPI()

# 依赖注入：获取数据库会话
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# API 端点：获取用户及其对话
@app.get("/users/{user_id}")
def get_user(user_id: int, db: Session = Depends(get_db)):
    user = db.get(User, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # 返回用户和对话
    return {
        "id": user.id,
        "name": user.name,
        "conversations": [
            {"id": c.id, "title": c.title}
            for c in user.conversations
        ]
    }

# API 端点：创建对话
@app.post("/users/{user_id}/conversations")
def create_conversation(
    user_id: int,
    title: str,
    db: Session = Depends(get_db)
):
    user = db.get(User, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # 创建对话
    conversation = Conversation(title=title, user=user)
    db.add(conversation)
    db.commit()
    db.refresh(conversation)

    return {"id": conversation.id, "title": conversation.title}
```

---

## 这些知识足以：

- ✅ 定义一对多关系（用户-对话）
- ✅ 定义多对多关系（对话-标签）
- ✅ 选择合适的加载策略（避免 N+1 问题）
- ✅ 配置级联操作（自动删除关联数据）
- ✅ 在 FastAPI 中使用关系定义
- ✅ 为后续学习一对一、自引用关系打基础

---

## 快速参考

| 关系类型 | 外键位置 | relationship 配置 | 使用场景 |
|---------|---------|------------------|---------|
| 一对多 | "多"的一方 | `back_populates` | 用户-对话、对话-消息 |
| 多对多 | 中间表 | `secondary` | 对话-标签、用户-角色 |
| 一对一 | 任意一方 | `uselist=False` | 用户-个人资料 |

| 加载策略 | 查询时机 | 适用场景 |
|---------|---------|---------|
| `lazy='select'` | 访问时查询 | 默认，简单场景 |
| `lazy='selectin'` | 批量 IN 查询 | 循环访问（推荐） |
| `lazy='joined'` | 立即 JOIN | 总是需要关联数据 |

| 级联选项 | 行为 | 适用场景 |
|---------|-----|---------|
| `"all, delete-orphan"` | 删除父对象删除子对象，子对象脱离父对象也删除 | 强依赖关系 |
| `"all"` | 删除父对象删除子对象 | 一般依赖关系 |
| `"save-update"` | 保存父对象自动保存子对象 | 默认行为 |
