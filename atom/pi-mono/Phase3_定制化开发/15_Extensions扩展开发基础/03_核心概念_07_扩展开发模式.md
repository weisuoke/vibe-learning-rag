# Extensions 扩展开发基础 - 核心概念 07：扩展开发模式

> 深入理解 Extensions 开发的最佳实践、设计模式和常见陷阱

---

## 概述

本文档深入讲解 Extensions 开发的核心模式和最佳实践，包括：
- 状态持久化模式（details 字段）
- Session 感知的状态重建
- 错误处理模式
- 异步模式和 AbortSignal
- 最佳实践和反模式

---

## 1. 状态持久化模式

### 1.1 为什么需要 details 存储？

**核心问题：Session 分支需要独立状态**

```
主 Session: todos = [A, B, C]
  ↓ fork
  ├── Session 1: 删除 B → todos = [A, C]
  └── Session 2: 添加 D → todos = [A, B, C, D]

如果使用外部文件：
  ~/.pi/todos.json = [A, C, D]  ← 状态混乱！

如果使用 details：
  Session 1: details = { todos: [A, C] }
  Session 2: details = { todos: [A, B, C, D] }  ← 状态独立！
```

### 1.2 完整的状态持久化模式

**标准模式：**

```typescript
export default function (pi: ExtensionAPI) {
  // 1. 内存状态
  let state = {
    items: [],
    nextId: 1,
  };

  // 2. 重建函数
  const reconstructState = (ctx: ExtensionContext) => {
    state = { items: [], nextId: 1 };

    // 遍历当前分支的历史
    for (const entry of ctx.sessionManager.getBranch()) {
      if (entry.type !== "message") continue;
      const msg = entry.message;

      // 找到我们的工具调用结果
      if (msg.role === "toolResult" && msg.toolName === "my_tool") {
        const details = msg.details as typeof state;
        if (details) {
          state = { ...details };
        }
      }
    }
  };

  // 3. 监听 Session 事件
  pi.on("session_start", async (_, ctx) => reconstructState(ctx));
  pi.on("session_switch", async (_, ctx) => reconstructState(ctx));
  pi.on("session_fork", async (_, ctx) => reconstructState(ctx));
  pi.on("session_tree", async (_, ctx) => reconstructState(ctx));

  // 4. 工具执行时保存状态
  pi.registerTool({
    name: "my_tool",
    description: "My tool with state",
    parameters: Type.Object({
      action: StringEnum(["add", "list"] as const),
      item: Type.Optional(Type.String()),
    }),

    async execute(toolCallId, params, signal, onUpdate, ctx) {
      const { action, item } = params as {
        action: "add" | "list";
        item?: string;
      };

      switch (action) {
        case "add":
          if (item) {
            state.items.push({ id: state.nextId++, text: item });
          }
          break;

        case "list":
          // 列出所有项目
          break;
      }

      // 关键：保存完整状态到 details
      return {
        content: [{ type: "text", text: "Done" }],
        details: { ...state }, // 深拷贝状态
      };
    },
  });
}
```

### 1.3 状态重建的优化

**增量重建（只处理新消息）：**

```typescript
export default function (pi: ExtensionAPI) {
  let state = { items: [], nextId: 1 };
  let lastProcessedIndex = 0;

  const reconstructState = (ctx: ExtensionContext) => {
    const branch = ctx.sessionManager.getBranch();

    // 只处理新消息
    for (let i = lastProcessedIndex; i < branch.length; i++) {
      const entry = branch[i];
      if (entry.type !== "message") continue;
      const msg = entry.message;

      if (msg.role === "toolResult" && msg.toolName === "my_tool") {
        const details = msg.details as typeof state;
        if (details) {
          state = { ...details };
        }
      }
    }

    lastProcessedIndex = branch.length;
  };

  // Session 切换时需要完全重建
  pi.on("session_switch", async (_, ctx) => {
    lastProcessedIndex = 0;
    reconstructState(ctx);
  });

  // Session fork 时需要完全重建
  pi.on("session_fork", async (_, ctx) => {
    lastProcessedIndex = 0;
    reconstructState(ctx);
  });

  // 其他事件可以增量重建
  pi.on("tool_result", async (event, ctx) => {
    if (event.toolName === "my_tool") {
      reconstructState(ctx);
    }
  });
}
```

---

## 2. 错误处理模式

### 2.1 工具执行错误处理

**完整的错误处理：**

```typescript
pi.registerTool({
  name: "my_tool",
  description: "Tool with error handling",
  parameters: Type.Object({
    url: Type.String(),
  }),

  async execute(toolCallId, params, signal, onUpdate, ctx) {
    const { url } = params as { url: string };

    try {
      // 1. 参数验证
      if (!url.startsWith("http")) {
        return {
          content: [{ type: "text", text: "Error: Invalid URL" }],
          details: { error: "invalid_url", url },
        };
      }

      // 2. 执行操作
      const response = await fetch(url, { signal });

      // 3. 检查响应
      if (!response.ok) {
        return {
          content: [
            {
              type: "text",
              text: `Error: HTTP ${response.status}`,
            },
          ],
          details: { error: "http_error", status: response.status },
        };
      }

      // 4. 处理结果
      const data = await response.json();

      return {
        content: [{ type: "text", text: JSON.stringify(data) }],
        details: { data },
      };
    } catch (error) {
      // 5. 区分错误类型
      if (error.name === "AbortError") {
        return {
          content: [{ type: "text", text: "Request cancelled" }],
          details: { cancelled: true },
        };
      }

      if (error instanceof TypeError) {
        return {
          content: [{ type: "text", text: "Network error" }],
          details: { error: "network_error" },
        };
      }

      // 6. 记录未知错误
      console.error("Tool execution failed:", error);

      return {
        content: [{ type: "text", text: `Error: ${error.message}` }],
        details: { error: error.message, stack: error.stack },
      };
    }
  },
});
```

### 2.2 事件处理器错误处理

**安全的事件处理器：**

```typescript
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    try {
      // 处理事件
      if (shouldBlock(event)) {
        return { block: true, reason: "Blocked" };
      }
    } catch (error) {
      // 记录错误但不阻止其他处理器
      console.error("Event handler error:", error);

      // 可选：通知用户
      ctx.ui.notify(`Extension error: ${error.message}`, "error");

      // 不返回 block，允许其他处理器继续
    }
  });
}
```

### 2.3 全局错误处理

**捕获未处理的错误：**

```typescript
export default function (pi: ExtensionAPI) {
  // 捕获未处理的 Promise 拒绝
  process.on("unhandledRejection", (error) => {
    console.error("[Extension] Unhandled rejection:", error);
  });

  // 捕获未捕获的异常
  process.on("uncaughtException", (error) => {
    console.error("[Extension] Uncaught exception:", error);
  });

  // 返回清理函数
  return () => {
    // 移除监听器
    process.removeAllListeners("unhandledRejection");
    process.removeAllListeners("uncaughtException");
  };
}
```

---

## 3. 异步模式

### 3.1 AbortSignal 支持

**正确使用 AbortSignal：**

```typescript
pi.registerTool({
  name: "long_task",
  parameters: Type.Object({
    steps: Type.Number(),
  }),

  async execute(toolCallId, params, signal, onUpdate, ctx) {
    const { steps } = params as { steps: number };

    for (let i = 0; i < steps; i++) {
      // 1. 检查取消信号
      if (signal.aborted) {
        return {
          content: [{ type: "text", text: "Task cancelled" }],
          details: { cancelled: true, completedSteps: i },
        };
      }

      // 2. 执行步骤
      await performStep(i);

      // 3. 发送进度更新
      onUpdate({
        content: [
          {
            type: "text",
            text: `Step ${i + 1}/${steps} completed`,
          },
        ],
      });
    }

    return {
      content: [{ type: "text", text: "All steps completed" }],
      details: { completedSteps: steps },
    };
  },
});
```

**将 signal 传递给异步操作：**

```typescript
async execute(toolCallId, params, signal, onUpdate, ctx) {
  // 传递给 fetch
  const response = await fetch(url, { signal });

  // 传递给自定义异步函数
  const result = await customAsyncOperation(data, { signal });

  // 监听 abort 事件
  signal.addEventListener("abort", () => {
    console.log("Operation cancelled");
    cleanup();
  });

  return { content: [...], details: {} };
}
```

### 3.2 并发控制

**限制并发数量：**

```typescript
export default function (pi: ExtensionAPI) {
  const queue: Array<() => Promise<void>> = [];
  let running = 0;
  const maxConcurrent = 3;

  async function runQueue() {
    while (queue.length > 0 && running < maxConcurrent) {
      const task = queue.shift();
      if (task) {
        running++;
        task().finally(() => {
          running--;
          runQueue();
        });
      }
    }
  }

  pi.registerTool({
    name: "concurrent_task",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      return new Promise((resolve) => {
        queue.push(async () => {
          const result = await performTask(params);
          resolve({
            content: [{ type: "text", text: "Done" }],
            details: { result },
          });
        });
        runQueue();
      });
    },
  });
}
```

### 3.3 超时处理

**实现超时机制：**

```typescript
async function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  signal?: AbortSignal
): Promise<T> {
  const timeoutPromise = new Promise<never>((_, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error("Operation timed out"));
    }, timeoutMs);

    // 如果有 signal，监听 abort 事件
    signal?.addEventListener("abort", () => {
      clearTimeout(timeout);
      reject(new Error("Operation cancelled"));
    });
  });

  return Promise.race([promise, timeoutPromise]);
}

// 使用
pi.registerTool({
  name: "timed_task",
  async execute(toolCallId, params, signal, onUpdate, ctx) {
    try {
      const result = await withTimeout(
        performTask(params),
        5000, // 5 秒超时
        signal
      );

      return {
        content: [{ type: "text", text: "Success" }],
        details: { result },
      };
    } catch (error) {
      if (error.message === "Operation timed out") {
        return {
          content: [{ type: "text", text: "Timeout" }],
          details: { timeout: true },
        };
      }
      throw error;
    }
  },
});
```

---

## 4. 资源管理模式

### 4.1 清理函数模式

**完整的资源管理：**

```typescript
export default function (pi: ExtensionAPI) {
  // 资源列表
  const resources = {
    timers: [] as NodeJS.Timeout[],
    listeners: [] as Array<{ event: string; handler: Function }>,
    connections: [] as Array<{ close: () => void }>,
  };

  // 创建定时器
  const timer = setInterval(() => {
    console.log("Heartbeat");
  }, 1000);
  resources.timers.push(timer);

  // 注册事件监听器
  const handler = async (event, ctx) => {
    console.log("Event:", event);
  };
  pi.on("tool_call", handler);
  resources.listeners.push({ event: "tool_call", handler });

  // 创建连接
  const connection = createConnection();
  resources.connections.push(connection);

  // 返回清理函数
  return () => {
    console.log("Cleaning up extension...");

    // 清理定时器
    for (const timer of resources.timers) {
      clearInterval(timer);
    }

    // 移除事件监听器
    for (const { event, handler } of resources.listeners) {
      pi.off(event as any, handler as any);
    }

    // 关闭连接
    for (const connection of resources.connections) {
      connection.close();
    }

    console.log("Cleanup complete");
  };
}
```

### 4.2 资源池模式

**复用资源：**

```typescript
export default function (pi: ExtensionAPI) {
  // 连接池
  const connectionPool = {
    connections: [] as Connection[],
    maxSize: 5,

    async acquire(): Promise<Connection> {
      if (this.connections.length > 0) {
        return this.connections.pop()!;
      }

      if (this.connections.length < this.maxSize) {
        return await createConnection();
      }

      // 等待连接可用
      return new Promise((resolve) => {
        const interval = setInterval(() => {
          if (this.connections.length > 0) {
            clearInterval(interval);
            resolve(this.connections.pop()!);
          }
        }, 100);
      });
    },

    release(connection: Connection) {
      if (this.connections.length < this.maxSize) {
        this.connections.push(connection);
      } else {
        connection.close();
      }
    },
  };

  pi.registerTool({
    name: "db_query",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      const connection = await connectionPool.acquire();

      try {
        const result = await connection.query(params.sql);
        return {
          content: [{ type: "text", text: JSON.stringify(result) }],
          details: { result },
        };
      } finally {
        connectionPool.release(connection);
      }
    },
  });

  // 清理
  return () => {
    for (const connection of connectionPool.connections) {
      connection.close();
    }
  };
}
```

---

## 5. 性能优化模式

### 5.1 缓存模式

**实现缓存：**

```typescript
export default function (pi: ExtensionAPI) {
  // LRU 缓存
  const cache = new Map<string, { value: any; timestamp: number }>();
  const maxSize = 100;
  const ttl = 60000; // 1 分钟

  function get(key: string): any | undefined {
    const entry = cache.get(key);
    if (!entry) return undefined;

    // 检查过期
    if (Date.now() - entry.timestamp > ttl) {
      cache.delete(key);
      return undefined;
    }

    return entry.value;
  }

  function set(key: string, value: any) {
    // LRU 淘汰
    if (cache.size >= maxSize) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }

    cache.set(key, { value, timestamp: Date.now() });
  }

  pi.registerTool({
    name: "cached_fetch",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      const { url } = params as { url: string };

      // 检查缓存
      const cached = get(url);
      if (cached) {
        return {
          content: [{ type: "text", text: cached }],
          details: { cached: true },
        };
      }

      // 获取数据
      const response = await fetch(url, { signal });
      const data = await response.text();

      // 缓存结果
      set(url, data);

      return {
        content: [{ type: "text", text: data }],
        details: { cached: false },
      };
    },
  });
}
```

### 5.2 防抖和节流

**防抖（Debounce）：**

```typescript
function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): T {
  let timeout: NodeJS.Timeout;

  return ((...args: any[]) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), delay);
  }) as T;
}

// 使用
export default function (pi: ExtensionAPI) {
  const debouncedUpdate = debounce((ctx: ExtensionContext) => {
    ctx.ui.setStatus("Updated");
  }, 500);

  pi.on("tool_call", async (event, ctx) => {
    debouncedUpdate(ctx);
  });
}
```

**节流（Throttle）：**

```typescript
function throttle<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): T {
  let lastCall = 0;

  return ((...args: any[]) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      fn(...args);
    }
  }) as T;
}

// 使用
export default function (pi: ExtensionAPI) {
  const throttledLog = throttle((event: any) => {
    console.log("Tool called:", event.toolName);
  }, 1000);

  pi.on("tool_call", async (event, ctx) => {
    throttledLog(event);
  });
}
```

---

## 6. 最佳实践

### 6.1 单一职责原则

```typescript
// ✅ 好：每个扩展只做一件事
// safety.ts
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 只负责安全检查
    if (isDangerous(event)) {
      return { block: true, reason: "Dangerous" };
    }
  });
}

// logging.ts
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 只负责日志记录
    console.log(`[LOG] ${event.toolName}`);
  });
}

// ❌ 不好：一个扩展做太多事
export default function (pi: ExtensionAPI) {
  // 安全检查
  pi.on("tool_call", async (event, ctx) => {
    if (isDangerous(event)) {
      return { block: true };
    }
  });

  // 日志记录
  pi.on("tool_call", async (event, ctx) => {
    console.log(event);
  });

  // 性能监控
  pi.on("tool_call", async (event, ctx) => {
    // ...
  });

  // UI 更新
  pi.on("tool_call", async (event, ctx) => {
    // ...
  });
}
```

### 6.2 类型安全

```typescript
// ✅ 好：使用类型定义
interface TodoItem {
  id: number;
  text: string;
  done: boolean;
}

interface TodoDetails {
  todos: TodoItem[];
  nextId: number;
}

export default function (pi: ExtensionAPI) {
  let todos: TodoItem[] = [];

  pi.registerTool({
    name: "todo",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      return {
        content: [...],
        details: { todos, nextId } as TodoDetails,
      };
    },
  });
}

// ❌ 不好：没有类型定义
export default function (pi: ExtensionAPI) {
  let todos = [];

  pi.registerTool({
    name: "todo",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      return {
        content: [...],
        details: { todos, nextId }, // 类型不明确
      };
    },
  });
}
```

### 6.3 错误边界

```typescript
// ✅ 好：每个操作都有错误处理
export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "my_tool",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      try {
        const result = await operation1();
        const processed = await operation2(result);
        return {
          content: [{ type: "text", text: processed }],
          details: {},
        };
      } catch (error) {
        console.error("Tool error:", error);
        return {
          content: [{ type: "text", text: `Error: ${error.message}` }],
          details: { error: error.message },
        };
      }
    },
  });
}

// ❌ 不好：没有错误处理
export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "my_tool",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      const result = await operation1(); // 可能抛出错误
      const processed = await operation2(result); // 可能抛出错误
      return {
        content: [{ type: "text", text: processed }],
        details: {},
      };
    },
  });
}
```

---

## 7. 反模式（Anti-Patterns）

### 7.1 全局状态污染

```typescript
// ❌ 反模式：使用全局变量
let globalState = {};

export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    globalState.lastTool = event.toolName; // 污染全局状态
  });
}

// ✅ 正确：使用闭包
export default function (pi: ExtensionAPI) {
  let localState = {}; // 闭包中的局部状态

  pi.on("tool_call", async (event, ctx) => {
    localState.lastTool = event.toolName;
  });
}
```

### 7.2 同步阻塞

```typescript
// ❌ 反模式：同步阻塞操作
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 同步的重计算，阻塞事件循环
    const result = expensiveSync Computation();
    console.log(result);
  });
}

// ✅ 正确：异步执行
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 异步执行
    const result = await Promise.resolve().then(() => {
      return expensiveComputation();
    });
    console.log(result);
  });
}
```

### 7.3 忽略取消信号

```typescript
// ❌ 反模式：忽略 AbortSignal
pi.registerTool({
  name: "long_task",
  async execute(toolCallId, params, signal, onUpdate, ctx) {
    for (let i = 0; i < 1000; i++) {
      await performStep(i); // 忽略 signal
    }
    return { content: [...], details: {} };
  },
});

// ✅ 正确：检查取消信号
pi.registerTool({
  name: "long_task",
  async execute(toolCallId, params, signal, onUpdate, ctx) {
    for (let i = 0; i < 1000; i++) {
      if (signal.aborted) {
        return {
          content: [{ type: "text", text: "Cancelled" }],
          details: { cancelled: true },
        };
      }
      await performStep(i);
    }
    return { content: [...], details: {} };
  },
});
```

---

## 8. 测试模式

### 8.1 单元测试

```typescript
// extension.ts
export function createExtension(pi: ExtensionAPI) {
  let state = { count: 0 };

  pi.registerTool({
    name: "counter",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      state.count++;
      return {
        content: [{ type: "text", text: `Count: ${state.count}` }],
        details: { count: state.count },
      };
    },
  });

  return {
    getState: () => state,
    setState: (newState) => { state = newState; },
  };
}

export default createExtension;

// extension.test.ts
import { createExtension } from "./extension";

test("counter increments", async () => {
  const mockPI = createMockExtensionAPI();
  const ext = createExtension(mockPI);

  // 模拟工具调用
  const tool = mockPI.getRegisteredTool("counter");
  const result = await tool.execute("1", {}, new AbortController().signal, () => {}, mockContext);

  expect(ext.getState().count).toBe(1);
  expect(result.details.count).toBe(1);
});
```

### 8.2 集成测试

```typescript
// 测试扩展加载
test("extension loads successfully", async () => {
  const manager = new ExtensionManager();
  await manager.loadExtension("./my-extension.ts");

  expect(manager.extensions.size).toBe(1);
  expect(manager.extensions.has("./my-extension.ts")).toBe(true);
});

// 测试热重载
test("extension reloads successfully", async () => {
  const manager = new ExtensionManager();
  await manager.loadExtension("./my-extension.ts");

  const firstInstance = manager.extensions.get("./my-extension.ts");

  await manager.reload();

  const secondInstance = manager.extensions.get("./my-extension.ts");

  expect(firstInstance).not.toBe(secondInstance);
});
```

---

## 9. 总结

### 核心模式

1. **状态持久化**：使用 details 字段，支持 Session 分支
2. **状态重建**：监听 Session 事件，从历史重建状态
3. **错误处理**：完整的 try-catch，区分错误类型
4. **异步模式**：正确使用 AbortSignal，支持取消
5. **资源管理**：返回清理函数，释放资源
6. **性能优化**：缓存、防抖、节流

### 最佳实践

1. **单一职责**：每个扩展只做一件事
2. **类型安全**：使用 TypeScript 类型定义
3. **错误边界**：每个操作都有错误处理
4. **资源清理**：返回清理函数
5. **测试覆盖**：编写单元测试和集成测试

### 反模式

1. **全局状态污染**：使用闭包而非全局变量
2. **同步阻塞**：使用异步操作
3. **忽略取消信号**：检查 AbortSignal
4. **外部文件存储**：使用 details 字段
5. **直接修改事件**：通过返回值控制

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: pi-mono 2025-2026 版本
