# 01_30字核心

> **学习目标**：用最精炼的语言理解 RunnablePassthrough 与 RunnableLambda 的本质

---

## 30字核心定义

**RunnablePassthrough 与 RunnableLambda 是 LangChain LCEL 中的数据转换工具：前者透传并扩展数据，后者包装自定义函数为标准 Runnable。**

---

## 拆解理解

### RunnablePassthrough（透传器）

**核心作用**：保持输入不变地传递，同时可通过 `assign()` 方法添加新字段

```
输入 → RunnablePassthrough → 输出（完全相同）
输入 → RunnablePassthrough.assign(key=func) → 输出（原数据 + 新字段）
```

**典型场景**：
- RAG 管道中同时传递原始查询和检索结果
- 保留上下文的同时添加中间处理结果
- 并行处理时保持数据完整性

### RunnableLambda（函数包装器）

**核心作用**：将任意 Python 函数（同步/异步）转换为符合 LCEL 标准的 Runnable

```
普通函数 → RunnableLambda(func) → 标准 Runnable
可链式组合 | 支持批处理 | 统一错误处理
```

**典型场景**：
- 自定义数据预处理逻辑
- 集成外部 API 调用
- 实现复杂的条件转换

---

## 核心价值

| 组件 | 核心价值 | 使用频率 |
|------|----------|----------|
| **RunnablePassthrough** | 数据保留与扩展 | ⭐⭐⭐⭐⭐ |
| **RunnableLambda** | 自定义逻辑集成 | ⭐⭐⭐⭐ |

---

## 最小记忆单元

**记住这三句话：**

1. **RunnablePassthrough = 数据透传 + assign 扩展**
   - 不改变输入，只添加新字段

2. **RunnableLambda = 函数 → Runnable**
   - 任何函数都能变成链的一部分

3. **两者配合 = 灵活的数据流控制**
   - Passthrough 保留，Lambda 转换

---

## 一句话类比

**前端类比**：
- RunnablePassthrough = `{...input, newKey: value}` 的展开运算符
- RunnableLambda = 将普通函数包装成 Promise 链的 `.then()`

**日常类比**：
- RunnablePassthrough = 传送带上的物品保持原样，同时贴上新标签
- RunnableLambda = 把任何工具（函数）变成流水线上的标准工位

---

## 为什么需要它们？

### 问题场景

**没有 RunnablePassthrough 时**：
```python
# ❌ 数据丢失问题
chain = retriever | llm  # 原始查询丢失了！
```

**有 RunnablePassthrough 时**：
```python
# ✅ 数据保留
chain = {
    "query": RunnablePassthrough(),  # 保留原始查询
    "context": retriever              # 添加检索结果
} | llm
```

**没有 RunnableLambda 时**：
```python
# ❌ 无法集成自定义逻辑
def custom_process(x):
    return x.upper()

# 无法直接用在链中
chain = prompt | custom_process | llm  # 报错！
```

**有 RunnableLambda 时**：
```python
# ✅ 自定义函数无缝集成
chain = prompt | RunnableLambda(custom_process) | llm
```

---

## 核心 API 速查

### RunnablePassthrough

```python
from langchain_core.runnables import RunnablePassthrough

# 1. 基础透传
passthrough = RunnablePassthrough()
passthrough.invoke("hello")  # 输出: "hello"

# 2. assign 扩展（最常用）
chain = RunnablePassthrough.assign(
    new_field=lambda x: x["input"].upper()
)
chain.invoke({"input": "hello"})
# 输出: {"input": "hello", "new_field": "HELLO"}
```

### RunnableLambda

```python
from langchain_core.runnables import RunnableLambda

# 1. 同步函数
def process(x):
    return x.upper()

lambda_runnable = RunnableLambda(process)
lambda_runnable.invoke("hello")  # 输出: "HELLO"

# 2. 异步函数
async def async_process(x):
    return x.upper()

async_runnable = RunnableLambda(async_process)
await async_runnable.ainvoke("hello")  # 输出: "HELLO"
```

---

## 典型组合模式

### 模式 1：RAG 数据保留

```python
# 同时保留查询和检索结果
rag_chain = (
    RunnablePassthrough.assign(context=retriever)
    | prompt
    | llm
)
```

### 模式 2：自定义预处理

```python
# 查询改写 + 检索
chain = (
    RunnableLambda(rewrite_query)  # 自定义改写
    | RunnablePassthrough.assign(context=retriever)
    | llm
)
```

### 模式 3：并行处理

```python
from langchain_core.runnables import RunnableParallel

# 并行执行多个转换
parallel = RunnableParallel(
    original=RunnablePassthrough(),
    processed=RunnableLambda(process_func),
    enriched=RunnablePassthrough.assign(extra=compute_func)
)
```

---

## 关键特性对比

| 特性 | RunnablePassthrough | RunnableLambda |
|------|---------------------|----------------|
| **主要用途** | 数据透传与扩展 | 自定义函数包装 |
| **输入输出** | 保持输入不变 | 完全自定义 |
| **典型场景** | RAG 上下文保留 | 数据预处理/后处理 |
| **学习难度** | ⭐ 简单 | ⭐⭐ 中等 |
| **使用频率** | 极高（几乎每个 RAG） | 高（自定义逻辑） |
| **错误处理** | 自动传递 | 需手动处理 |
| **异步支持** | ✅ 原生支持 | ✅ 原生支持 |

---

## 生产环境注意事项

### RunnablePassthrough

**常见陷阱**：
1. **误以为 assign 会替换输入**
   ```python
   # ❌ 错误理解
   # assign 不会替换，而是扩展
   result = RunnablePassthrough.assign(input="new")
   # 原始 input 仍然保留！
   ```

2. **字典键冲突**
   ```python
   # ⚠️ 如果 assign 的键已存在，会被覆盖
   chain = RunnablePassthrough.assign(query=lambda x: "new")
   # 原始 query 会被覆盖
   ```

### RunnableLambda

**常见陷阱**：
1. **忘记处理异常**
   ```python
   # ❌ 没有错误处理
   def risky_func(x):
       return x / 0  # 会导致整个链崩溃

   # ✅ 添加错误处理
   def safe_func(x):
       try:
           return x / 0
       except ZeroDivisionError:
           return None
   ```

2. **同步函数阻塞异步链**
   ```python
   # ⚠️ 同步函数会阻塞
   def slow_sync(x):
       time.sleep(10)  # 阻塞整个链

   # ✅ 使用异步版本
   async def fast_async(x):
       await asyncio.sleep(10)  # 不阻塞
   ```

---

## 2025-2026 最新特性

### 1. 类型推断增强（LangChain v0.3+）

```python
# 自动类型推断
chain = RunnablePassthrough.assign(
    count=lambda x: len(x["items"])
)
# 类型系统自动识别: Runnable[dict, dict]
```

### 2. 批处理优化

```python
# 批量处理性能提升 3-5 倍
results = await chain.abatch([
    {"query": "q1"},
    {"query": "q2"},
    {"query": "q3"}
])
```

### 3. 错误传播改进

```python
# 更清晰的错误堆栈
chain = RunnableLambda(risky_func).with_retry(
    stop_after_attempt=3
)
# 错误信息包含完整调用链路
```

---

## 快速决策树

```
需要在链中处理数据？
├─ 需要保留原始输入？
│  ├─ 只需透传 → RunnablePassthrough()
│  └─ 需要添加字段 → RunnablePassthrough.assign()
└─ 需要自定义转换？
   ├─ 简单转换 → RunnableLambda(func)
   └─ 复杂逻辑 → RunnableLambda + 错误处理
```

---

## 学习检查点

**你应该能回答：**

1. RunnablePassthrough 的主要作用是什么？
   - **答案**：透传输入数据，可通过 assign() 添加新字段

2. RunnableLambda 解决什么问题？
   - **答案**：将任意 Python 函数包装为标准 Runnable，集成到 LCEL 链中

3. 什么时候用 assign()？
   - **答案**：需要保留原始输入同时添加新字段时（如 RAG 中保留查询并添加上下文）

**如果以上都能回答，继续学习其他维度；否则重读本文档。**

---

## 下一步

- **深入理解**：阅读 `02_第一性原理.md` 了解底层设计思想
- **核心概念**：学习 `03_核心概念_*.md` 掌握详细机制
- **实战代码**：查看 `07_实战代码_*.md` 获取生产级示例

---

**参考资料**：
- [LangChain RunnablePassthrough 官方文档](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html) (2025)
- [Building Production-Ready AI Pipelines with LangChain Runnables](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557) (2026)
- [Master LangChain in 2025: Complete Guide](https://towardsai.net/p/machine-learning/master-langchain-in-2025-from-rag-to-tools-complete-guide) (2025)

---

**版本**：v1.0
**最后更新**：2026-02-18
**字数统计**：约 100 行核心内容
