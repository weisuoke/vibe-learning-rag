# å®æˆ˜ä»£ç  03ï¼šå‹ç¼©ç›‘æ§ä¸è°ƒè¯•

> **ç›®æ ‡**ï¼šé€šè¿‡å®é™…ä»£ç ç¤ºä¾‹å­¦ä¹ å¦‚ä½•ç›‘æ§å‹ç¼©äº‹ä»¶ã€è°ƒè¯•é—®é¢˜å’Œåˆ†æè´¨é‡

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å®Œæ•´å¯è¿è¡Œçš„ç›‘æ§å’Œè°ƒè¯•å·¥å…·ï¼Œå±•ç¤ºå¦‚ä½•ï¼š
1. è¿½è¸ªå‹ç¼©äº‹ä»¶å’Œ token èŠ‚çœ
2. è°ƒè¯•å‹ç¼©å¤±è´¥
3. åˆ†ææ‘˜è¦è´¨é‡
4. æ”¶é›†æ€§èƒ½æŒ‡æ ‡

---

## ç¤ºä¾‹ 1ï¼šå‹ç¼©äº‹ä»¶è¿½è¸ªå™¨

### å®Œæ•´è¿½è¸ªæ‰©å±•

```typescript
/**
 * .pi/extensions/compaction-tracker.ts
 * è¿½è¸ªæ‰€æœ‰å‹ç¼©äº‹ä»¶å¹¶è®°å½•è¯¦ç»†ä¿¡æ¯
 */

import { Extension } from '@mariozechner/pi-agent-core';
import * as fs from 'fs';
import * as path from 'path';

interface CompactionEvent {
  timestamp: string;
  sessionId: string;
  contextTokens: number;
  contextWindow: number;
  usagePercentage: number;
  model: string;
  estimatedCost: number;
  messageCount: number;
}

export const compactionTrackerExtension: Extension = {
  name: 'compaction-tracker',
  description: 'è¿½è¸ªæ‰€æœ‰å‹ç¼©äº‹ä»¶',

  async onLoad(context) {
    console.log('âœ… Compaction Tracker å·²åŠ è½½');

    const logFile = path.join(process.env.HOME || '', '.pi', 'compaction-events.jsonl');

    context.session.on('session_before_compact', async (event) => {
      const compactionEvent: CompactionEvent = {
        timestamp: new Date().toISOString(),
        sessionId: context.session.id,
        contextTokens: event.contextTokens,
        contextWindow: event.contextWindow,
        usagePercentage: (event.contextTokens / event.contextWindow) * 100,
        model: event.customModel || context.session.config.model,
        estimatedCost: estimateCost(event.contextTokens, event.customModel || context.session.config.model),
        messageCount: event.messages.length,
      };

      // è®°å½•åˆ°æ–‡ä»¶
      await fs.promises.appendFile(
        logFile,
        JSON.stringify(compactionEvent) + '\n'
      );

      // è¾“å‡ºåˆ°æ§åˆ¶å°
      console.log('\nğŸ“Š å‹ç¼©äº‹ä»¶è®°å½•:');
      console.log(`   æ—¶é—´: ${compactionEvent.timestamp}`);
      console.log(`   Tokens: ${compactionEvent.contextTokens.toLocaleString()}`);
      console.log(`   ä½¿ç”¨ç‡: ${compactionEvent.usagePercentage.toFixed(2)}%`);
      console.log(`   æ¨¡å‹: ${compactionEvent.model}`);
      console.log(`   ä¼°ç®—æˆæœ¬: $${compactionEvent.estimatedCost.toFixed(4)}`);
      console.log(`   æ¶ˆæ¯æ•°: ${compactionEvent.messageCount}`);
    });
  },
};

function estimateCost(tokens: number, model: string): number {
  const pricing: Record<string, { input: number; output: number }> = {
    'claude-opus-4': { input: 15, output: 75 },
    'claude-sonnet-4': { input: 3, output: 15 },
    'gemini-flash-2.0': { input: 0.075, output: 0.30 },
  };

  const modelPricing = pricing[model] || pricing['claude-opus-4'];
  const inputCost = (tokens / 1000000) * modelPricing.input;
  const outputCost = (tokens * 0.05 / 1000000) * modelPricing.output;

  return inputCost + outputCost;
}
```

### åˆ†æè¿½è¸ªæ—¥å¿—

```typescript
/**
 * analyze-compaction-logs.ts
 * åˆ†æå‹ç¼©äº‹ä»¶æ—¥å¿—
 */

import * as fs from 'fs';
import * as path from 'path';

interface CompactionEvent {
  timestamp: string;
  sessionId: string;
  contextTokens: number;
  contextWindow: number;
  usagePercentage: number;
  model: string;
  estimatedCost: number;
  messageCount: number;
}

function analyzeCompactionLogs() {
  const logFile = path.join(process.env.HOME || '', '.pi', 'compaction-events.jsonl');

  if (!fs.existsSync(logFile)) {
    console.log('æ²¡æœ‰æ‰¾åˆ°å‹ç¼©äº‹ä»¶æ—¥å¿—');
    return;
  }

  const content = fs.readFileSync(logFile, 'utf-8');
  const events: CompactionEvent[] = content
    .trim()
    .split('\n')
    .map(line => JSON.parse(line));

  console.log('='.repeat(80));
  console.log('å‹ç¼©äº‹ä»¶åˆ†ææŠ¥å‘Š');
  console.log('='.repeat(80));
  console.log();

  // æ€»ä½“ç»Ÿè®¡
  console.log('ğŸ“Š æ€»ä½“ç»Ÿè®¡:');
  console.log(`   æ€»å‹ç¼©æ¬¡æ•°: ${events.length}`);
  console.log(`   æ€»æˆæœ¬: $${events.reduce((sum, e) => sum + e.estimatedCost, 0).toFixed(4)}`);
  console.log();

  // æŒ‰æ¨¡å‹ç»Ÿè®¡
  const byModel = events.reduce((acc, e) => {
    if (!acc[e.model]) {
      acc[e.model] = { count: 0, cost: 0 };
    }
    acc[e.model].count++;
    acc[e.model].cost += e.estimatedCost;
    return acc;
  }, {} as Record<string, { count: number; cost: number }>);

  console.log('ğŸ“ˆ æŒ‰æ¨¡å‹ç»Ÿè®¡:');
  for (const [model, stats] of Object.entries(byModel)) {
    console.log(`   ${model}:`);
    console.log(`     æ¬¡æ•°: ${stats.count}`);
    console.log(`     æˆæœ¬: $${stats.cost.toFixed(4)}`);
    console.log(`     å¹³å‡: $${(stats.cost / stats.count).toFixed(4)}/æ¬¡`);
  }
  console.log();

  // ä½¿ç”¨ç‡åˆ†å¸ƒ
  const usageRanges = {
    '90-95%': 0,
    '95-98%': 0,
    '98-100%': 0,
  };

  for (const event of events) {
    if (event.usagePercentage >= 98) {
      usageRanges['98-100%']++;
    } else if (event.usagePercentage >= 95) {
      usageRanges['95-98%']++;
    } else {
      usageRanges['90-95%']++;
    }
  }

  console.log('ğŸ“Š ä½¿ç”¨ç‡åˆ†å¸ƒ:');
  for (const [range, count] of Object.entries(usageRanges)) {
    console.log(`   ${range}: ${count} æ¬¡`);
  }
  console.log();

  // æ—¶é—´è¶‹åŠ¿
  const firstEvent = events[0];
  const lastEvent = events[events.length - 1];
  const duration = new Date(lastEvent.timestamp).getTime() - new Date(firstEvent.timestamp).getTime();
  const hours = duration / (1000 * 60 * 60);

  console.log('â±ï¸  æ—¶é—´è¶‹åŠ¿:');
  console.log(`   é¦–æ¬¡å‹ç¼©: ${firstEvent.timestamp}`);
  console.log(`   æœ€åå‹ç¼©: ${lastEvent.timestamp}`);
  console.log(`   æ—¶é—´è·¨åº¦: ${hours.toFixed(2)} å°æ—¶`);
  console.log(`   å¹³å‡é¢‘ç‡: ${(events.length / hours).toFixed(2)} æ¬¡/å°æ—¶`);
  console.log();

  console.log('='.repeat(80));
}

analyzeCompactionLogs();
```

---

## ç¤ºä¾‹ 2ï¼šæ‘˜è¦è´¨é‡åˆ†æå™¨

### è´¨é‡è¯„ä¼°å·¥å…·

```typescript
/**
 * .pi/extensions/summary-quality-analyzer.ts
 * åˆ†æå‹ç¼©æ‘˜è¦çš„è´¨é‡
 */

import { Extension } from '@mariozechner/pi-agent-core';

export const summaryQualityAnalyzerExtension: Extension = {
  name: 'summary-quality-analyzer',
  description: 'åˆ†æå‹ç¼©æ‘˜è¦è´¨é‡',

  async onLoad(context) {
    console.log('âœ… Summary Quality Analyzer å·²åŠ è½½');

    context.session.on('session_after_compact', async () => {
      // è·å–æœ€æ–°çš„æ‘˜è¦
      const summary = context.session.messages.find(m => m.role === 'summary');

      if (!summary) {
        console.log('âš ï¸  æœªæ‰¾åˆ°æ‘˜è¦');
        return;
      }

      // åˆ†æè´¨é‡
      const quality = analyzeSummaryQuality(summary.content);

      console.log('\nğŸ“ æ‘˜è¦è´¨é‡åˆ†æ:');
      console.log(`   æ€»åˆ†: ${quality.score}/100`);
      console.log(`   ç­‰çº§: ${quality.grade}`);
      console.log();
      console.log('   è¯¦ç»†è¯„åˆ†:');
      console.log(`     ç»“æ„åŒ–: ${quality.structured ? 'âœ…' : 'âŒ'} (${quality.structuredScore}/25)`);
      console.log(`     å…³é”®ç‚¹: ${quality.hasKeyPoints ? 'âœ…' : 'âŒ'} (${quality.keyPointsScore}/25)`);
      console.log(`     æ–‡ä»¶è¿½è¸ª: ${quality.hasFiles ? 'âœ…' : 'âŒ'} (${quality.filesScore}/25)`);
      console.log(`     é•¿åº¦é€‚ä¸­: ${quality.lengthOk ? 'âœ…' : 'âŒ'} (${quality.lengthScore}/25)`);

      if (quality.suggestions.length > 0) {
        console.log();
        console.log('   ğŸ’¡ æ”¹è¿›å»ºè®®:');
        for (const suggestion of quality.suggestions) {
          console.log(`     - ${suggestion}`);
        }
      }
    });
  },
};

interface QualityAnalysis {
  score: number;
  grade: string;
  structured: boolean;
  structuredScore: number;
  hasKeyPoints: boolean;
  keyPointsScore: number;
  hasFiles: boolean;
  filesScore: number;
  lengthOk: boolean;
  lengthScore: number;
  suggestions: string[];
}

function analyzeSummaryQuality(summary: string): QualityAnalysis {
  const suggestions: string[] = [];
  let score = 0;

  // 1. æ£€æŸ¥ç»“æ„åŒ– (25åˆ†)
  const hasStructure = summary.includes('## Summary') || summary.includes('## Key Points');
  const structuredScore = hasStructure ? 25 : 0;
  score += structuredScore;

  if (!hasStructure) {
    suggestions.push('ä½¿ç”¨ç»“æ„åŒ–æ ¼å¼ï¼ˆ## Summary, ## Key Points, ## Filesï¼‰');
  }

  // 2. æ£€æŸ¥å…³é”®ç‚¹ (25åˆ†)
  const hasKeyPoints = summary.includes('Key Points') || summary.includes('å…³é”®ç‚¹');
  const keyPointCount = (summary.match(/^- /gm) || []).length;
  const keyPointsScore = hasKeyPoints && keyPointCount >= 3 ? 25 : keyPointCount * 5;
  score += keyPointsScore;

  if (keyPointCount < 3) {
    suggestions.push('å¢åŠ æ›´å¤šå…³é”®ç‚¹ï¼ˆå»ºè®®è‡³å°‘3ä¸ªï¼‰');
  }

  // 3. æ£€æŸ¥æ–‡ä»¶è¿½è¸ª (25åˆ†)
  const hasFiles = summary.includes('Files') || summary.includes('æ–‡ä»¶');
  const hasRead = summary.includes('Read:') || summary.includes('è¯»å–:');
  const hasModified = summary.includes('Modified:') || summary.includes('ä¿®æ”¹:');
  const filesScore = hasFiles && hasRead && hasModified ? 25 : (hasFiles ? 10 : 0);
  score += filesScore;

  if (!hasFiles) {
    suggestions.push('æ·»åŠ æ–‡ä»¶è¿½è¸ªä¿¡æ¯ï¼ˆRead å’Œ Modifiedï¼‰');
  }

  // 4. æ£€æŸ¥é•¿åº¦ (25åˆ†)
  const length = summary.length;
  const lengthOk = length >= 200 && length <= 2000;
  const lengthScore = lengthOk ? 25 : (length < 200 ? 10 : 15);
  score += lengthScore;

  if (length < 200) {
    suggestions.push('æ‘˜è¦å¤ªçŸ­ï¼Œå¢åŠ æ›´å¤šç»†èŠ‚');
  } else if (length > 2000) {
    suggestions.push('æ‘˜è¦å¤ªé•¿ï¼Œç²¾ç®€å†…å®¹');
  }

  // è®¡ç®—ç­‰çº§
  let grade: string;
  if (score >= 90) {
    grade = 'A (ä¼˜ç§€)';
  } else if (score >= 75) {
    grade = 'B (è‰¯å¥½)';
  } else if (score >= 60) {
    grade = 'C (åŠæ ¼)';
  } else {
    grade = 'D (éœ€æ”¹è¿›)';
  }

  return {
    score,
    grade,
    structured: hasStructure,
    structuredScore,
    hasKeyPoints,
    keyPointsScore,
    hasFiles,
    filesScore,
    lengthOk,
    lengthScore,
    suggestions,
  };
}
```

---

## ç¤ºä¾‹ 3ï¼šå‹ç¼©å¤±è´¥è°ƒè¯•å™¨

### è°ƒè¯•æ‰©å±•

```typescript
/**
 * .pi/extensions/compaction-debugger.ts
 * è°ƒè¯•å‹ç¼©å¤±è´¥å’Œå¼‚å¸¸
 */

import { Extension } from '@mariozechner/pi-agent-core';

export const compactionDebuggerExtension: Extension = {
  name: 'compaction-debugger',
  description: 'è°ƒè¯•å‹ç¼©å¤±è´¥',

  async onLoad(context) {
    console.log('âœ… Compaction Debugger å·²åŠ è½½');

    // ç›‘å¬å‹ç¼©å‰äº‹ä»¶
    context.session.on('session_before_compact', async (event) => {
      console.log('\nğŸ” å‹ç¼©å‰æ£€æŸ¥:');

      // æ£€æŸ¥ 1: æ¶ˆæ¯å®Œæ•´æ€§
      const integrityCheck = checkMessageIntegrity(event.messages);
      console.log(`   æ¶ˆæ¯å®Œæ•´æ€§: ${integrityCheck.ok ? 'âœ…' : 'âŒ'}`);
      if (!integrityCheck.ok) {
        console.log(`     é—®é¢˜: ${integrityCheck.error}`);
      }

      // æ£€æŸ¥ 2: åˆ‡ç‚¹æœ‰æ•ˆæ€§
      const cutPointCheck = checkCutPoint(event.messages, event.cutPoint);
      console.log(`   åˆ‡ç‚¹æœ‰æ•ˆæ€§: ${cutPointCheck.ok ? 'âœ…' : 'âŒ'}`);
      if (!cutPointCheck.ok) {
        console.log(`     é—®é¢˜: ${cutPointCheck.error}`);
      }

      // æ£€æŸ¥ 3: Token ä¼°ç®—
      const tokenCheck = checkTokenEstimation(event.contextTokens, event.contextWindow);
      console.log(`   Token ä¼°ç®—: ${tokenCheck.ok ? 'âœ…' : 'âŒ'}`);
      if (!tokenCheck.ok) {
        console.log(`     é—®é¢˜: ${tokenCheck.error}`);
      }

      // æ£€æŸ¥ 4: æ¨¡å‹å¯ç”¨æ€§
      const modelCheck = checkModelAvailability(event.customModel || context.session.config.model);
      console.log(`   æ¨¡å‹å¯ç”¨æ€§: ${modelCheck.ok ? 'âœ…' : 'âŒ'}`);
      if (!modelCheck.ok) {
        console.log(`     é—®é¢˜: ${modelCheck.error}`);
      }
    });

    // ç›‘å¬å‹ç¼©é”™è¯¯
    context.session.on('session_compact_error', async (error) => {
      console.log('\nâŒ å‹ç¼©å¤±è´¥:');
      console.log(`   é”™è¯¯: ${error.message}`);
      console.log(`   å †æ ˆ: ${error.stack}`);

      // æä¾›è°ƒè¯•å»ºè®®
      const suggestions = getDebugSuggestions(error);
      if (suggestions.length > 0) {
        console.log('\n   ğŸ’¡ è°ƒè¯•å»ºè®®:');
        for (const suggestion of suggestions) {
          console.log(`     - ${suggestion}`);
        }
      }
    });
  },
};

function checkMessageIntegrity(messages: any[]): { ok: boolean; error?: string } {
  // æ£€æŸ¥æ¶ˆæ¯æ•°ç»„ä¸ä¸ºç©º
  if (messages.length === 0) {
    return { ok: false, error: 'æ¶ˆæ¯æ•°ç»„ä¸ºç©º' };
  }

  // æ£€æŸ¥æ¶ˆæ¯æ ¼å¼
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];

    if (!message.role) {
      return { ok: false, error: `æ¶ˆæ¯ ${i} ç¼ºå°‘ role` };
    }

    if (!message.content && !message.tool_calls) {
      return { ok: false, error: `æ¶ˆæ¯ ${i} ç¼ºå°‘ content å’Œ tool_calls` };
    }
  }

  return { ok: true };
}

function checkCutPoint(messages: any[], cutPoint: number): { ok: boolean; error?: string } {
  if (cutPoint < 0 || cutPoint >= messages.length) {
    return { ok: false, error: `åˆ‡ç‚¹ ${cutPoint} è¶…å‡ºèŒƒå›´ [0, ${messages.length})` };
  }

  const cutMessage = messages[cutPoint];
  const validRoles = ['user', 'assistant', 'bashExecution', 'custom'];

  if (!validRoles.includes(cutMessage.role)) {
    return { ok: false, error: `åˆ‡ç‚¹æ¶ˆæ¯çš„ role (${cutMessage.role}) ä¸æ˜¯æœ‰æ•ˆåˆ‡ç‚¹` };
  }

  return { ok: true };
}

function checkTokenEstimation(contextTokens: number, contextWindow: number): { ok: boolean; error?: string } {
  if (contextTokens <= 0) {
    return { ok: false, error: 'contextTokens <= 0' };
  }

  if (contextTokens > contextWindow) {
    return { ok: false, error: `contextTokens (${contextTokens}) è¶…è¿‡ contextWindow (${contextWindow})` };
  }

  return { ok: true };
}

function checkModelAvailability(model: string): { ok: boolean; error?: string } {
  const supportedModels = [
    'claude-opus-4',
    'claude-sonnet-4',
    'gemini-flash-2.0',
    'gpt-4-turbo',
  ];

  if (!supportedModels.includes(model)) {
    return { ok: false, error: `æ¨¡å‹ ${model} å¯èƒ½ä¸æ”¯æŒ` };
  }

  return { ok: true };
}

function getDebugSuggestions(error: Error): string[] {
  const suggestions: string[] = [];

  if (error.message.includes('API key')) {
    suggestions.push('æ£€æŸ¥ API key æ˜¯å¦æ­£ç¡®é…ç½®');
    suggestions.push('æ£€æŸ¥ç¯å¢ƒå˜é‡ ANTHROPIC_API_KEY æˆ– GOOGLE_API_KEY');
  }

  if (error.message.includes('rate limit')) {
    suggestions.push('ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•');
    suggestions.push('è€ƒè™‘ä½¿ç”¨æ›´ä¾¿å®œçš„æ¨¡å‹é™ä½è°ƒç”¨é¢‘ç‡');
  }

  if (error.message.includes('context')) {
    suggestions.push('æ£€æŸ¥ contextTokens å’Œ contextWindow çš„å€¼');
    suggestions.push('å°è¯•å¢å¤§ reserveTokens');
  }

  if (error.message.includes('model')) {
    suggestions.push('æ£€æŸ¥æ¨¡å‹åç§°æ˜¯å¦æ­£ç¡®');
    suggestions.push('å°è¯•ä½¿ç”¨é»˜è®¤æ¨¡å‹');
  }

  return suggestions;
}
```

---

## ç¤ºä¾‹ 4ï¼šæ€§èƒ½æŒ‡æ ‡æ”¶é›†å™¨

### æ€§èƒ½ç›‘æ§æ‰©å±•

```typescript
/**
 * .pi/extensions/performance-monitor.ts
 * æ”¶é›†å‹ç¼©æ€§èƒ½æŒ‡æ ‡
 */

import { Extension } from '@mariozechner/pi-agent-core';

interface PerformanceMetrics {
  compactionDuration: number;
  tokensBefore: number;
  tokensAfter: number;
  compressionRatio: number;
  messagesBefore: number;
  messagesAfter: number;
  cost: number;
}

export const performanceMonitorExtension: Extension = {
  name: 'performance-monitor',
  description: 'æ”¶é›†å‹ç¼©æ€§èƒ½æŒ‡æ ‡',

  async onLoad(context) {
    console.log('âœ… Performance Monitor å·²åŠ è½½');

    let compactionStartTime: number;
    let tokensBefore: number;
    let messagesBefore: number;

    // å‹ç¼©å‰
    context.session.on('session_before_compact', async (event) => {
      compactionStartTime = Date.now();
      tokensBefore = event.contextTokens;
      messagesBefore = event.messages.length;
    });

    // å‹ç¼©å
    context.session.on('session_after_compact', async () => {
      const compactionDuration = Date.now() - compactionStartTime;

      // è·å–å‹ç¼©åçš„ tokens
      const usage = getLastAssistantUsage(context.session.messages);
      const tokensAfter = usage?.input_tokens || 0;

      const messagesAfter = context.session.messages.length;

      const metrics: PerformanceMetrics = {
        compactionDuration,
        tokensBefore,
        tokensAfter,
        compressionRatio: tokensBefore / tokensAfter,
        messagesBefore,
        messagesAfter,
        cost: estimateCost(tokensBefore),
      };

      console.log('\nâš¡ æ€§èƒ½æŒ‡æ ‡:');
      console.log(`   å‹ç¼©è€—æ—¶: ${metrics.compactionDuration}ms`);
      console.log(`   Tokens: ${metrics.tokensBefore.toLocaleString()} â†’ ${metrics.tokensAfter.toLocaleString()}`);
      console.log(`   å‹ç¼©æ¯”: ${metrics.compressionRatio.toFixed(2)}x`);
      console.log(`   æ¶ˆæ¯æ•°: ${metrics.messagesBefore} â†’ ${metrics.messagesAfter}`);
      console.log(`   æˆæœ¬: $${metrics.cost.toFixed(4)}`);

      // æ€§èƒ½è¯„ä¼°
      evaluatePerformance(metrics);
    });
  },
};

function getLastAssistantUsage(messages: any[]): any {
  for (let i = messages.length - 1; i >= 0; i--) {
    if (messages[i].role === 'assistant' && messages[i].usage) {
      return messages[i].usage;
    }
  }
  return undefined;
}

function estimateCost(tokens: number): number {
  return (tokens / 1000000) * 15 + (tokens * 0.05 / 1000000) * 75;
}

function evaluatePerformance(metrics: PerformanceMetrics) {
  console.log('\n   ğŸ“Š æ€§èƒ½è¯„ä¼°:');

  // å‹ç¼©æ¯”è¯„ä¼°
  if (metrics.compressionRatio > 10) {
    console.log(`     å‹ç¼©æ¯”: âœ… ä¼˜ç§€ (${metrics.compressionRatio.toFixed(2)}x)`);
  } else if (metrics.compressionRatio > 5) {
    console.log(`     å‹ç¼©æ¯”: âœ… è‰¯å¥½ (${metrics.compressionRatio.toFixed(2)}x)`);
  } else {
    console.log(`     å‹ç¼©æ¯”: âš ï¸  åä½ (${metrics.compressionRatio.toFixed(2)}x)`);
  }

  // è€—æ—¶è¯„ä¼°
  if (metrics.compactionDuration < 2000) {
    console.log(`     è€—æ—¶: âœ… å¿«é€Ÿ (${metrics.compactionDuration}ms)`);
  } else if (metrics.compactionDuration < 5000) {
    console.log(`     è€—æ—¶: âœ… æ­£å¸¸ (${metrics.compactionDuration}ms)`);
  } else {
    console.log(`     è€—æ—¶: âš ï¸  è¾ƒæ…¢ (${metrics.compactionDuration}ms)`);
  }

  // æˆæœ¬è¯„ä¼°
  if (metrics.cost < 0.01) {
    console.log(`     æˆæœ¬: âœ… ä½ ($${metrics.cost.toFixed(4)})`);
  } else if (metrics.cost < 0.05) {
    console.log(`     æˆæœ¬: âœ… ä¸­ç­‰ ($${metrics.cost.toFixed(4)})`);
  } else {
    console.log(`     æˆæœ¬: âš ï¸  è¾ƒé«˜ ($${metrics.cost.toFixed(4)})`);
  }
}
```

---

## ç¤ºä¾‹ 5ï¼šç»¼åˆè°ƒè¯•å·¥å…·

### ä¸€é”®è°ƒè¯•è„šæœ¬

```bash
#!/bin/bash
# debug-compaction.sh
# ç»¼åˆè°ƒè¯•å‹ç¼©é—®é¢˜

echo "==================================="
echo "Compaction è°ƒè¯•å·¥å…·"
echo "==================================="
echo

# 1. æ£€æŸ¥ Session æ–‡ä»¶
echo "1. æ£€æŸ¥ Session æ–‡ä»¶..."
SESSION_DIR="$HOME/.pi/sessions"
if [ -d "$SESSION_DIR" ]; then
  LATEST_SESSION=$(ls -t "$SESSION_DIR"/*.jsonl | head -1)
  echo "   æœ€æ–° Session: $LATEST_SESSION"
  echo "   æ–‡ä»¶å¤§å°: $(du -h "$LATEST_SESSION" | cut -f1)"
  echo "   æ¶ˆæ¯æ•°: $(wc -l < "$LATEST_SESSION")"
else
  echo "   âŒ Session ç›®å½•ä¸å­˜åœ¨"
fi
echo

# 2. æ£€æŸ¥å‹ç¼©æ—¥å¿—
echo "2. æ£€æŸ¥å‹ç¼©æ—¥å¿—..."
COMPACTION_LOG="$HOME/.pi/compaction-events.jsonl"
if [ -f "$COMPACTION_LOG" ]; then
  echo "   å‹ç¼©æ¬¡æ•°: $(wc -l < "$COMPACTION_LOG")"
  echo "   æœ€åå‹ç¼©: $(tail -1 "$COMPACTION_LOG" | jq -r '.timestamp')"
else
  echo "   âš ï¸  æ²¡æœ‰å‹ç¼©æ—¥å¿—"
fi
echo

# 3. æ£€æŸ¥ API keys
echo "3. æ£€æŸ¥ API keys..."
if [ -n "$ANTHROPIC_API_KEY" ]; then
  echo "   âœ… ANTHROPIC_API_KEY å·²è®¾ç½®"
else
  echo "   âŒ ANTHROPIC_API_KEY æœªè®¾ç½®"
fi

if [ -n "$GOOGLE_API_KEY" ]; then
  echo "   âœ… GOOGLE_API_KEY å·²è®¾ç½®"
else
  echo "   âš ï¸  GOOGLE_API_KEY æœªè®¾ç½®"
fi
echo

# 4. æ£€æŸ¥æ‰©å±•
echo "4. æ£€æŸ¥æ‰©å±•..."
EXTENSIONS_DIR=".pi/extensions"
if [ -d "$EXTENSIONS_DIR" ]; then
  echo "   æ‰©å±•æ•°: $(ls "$EXTENSIONS_DIR"/*.ts 2>/dev/null | wc -l)"
  ls "$EXTENSIONS_DIR"/*.ts 2>/dev/null | while read ext; do
    echo "     - $(basename "$ext")"
  done
else
  echo "   âš ï¸  æ²¡æœ‰æ‰©å±•ç›®å½•"
fi
echo

echo "==================================="
echo "è°ƒè¯•å®Œæˆ"
echo "==================================="
```

---

## æ€»ç»“

**æœ¬æ–‡æ¡£æä¾›çš„ç›‘æ§å’Œè°ƒè¯•å·¥å…·ï¼š**

1. **äº‹ä»¶è¿½è¸ªå™¨**ï¼šè®°å½•æ‰€æœ‰å‹ç¼©äº‹ä»¶
2. **è´¨é‡åˆ†æå™¨**ï¼šè¯„ä¼°æ‘˜è¦è´¨é‡
3. **å¤±è´¥è°ƒè¯•å™¨**ï¼šè¯Šæ–­å‹ç¼©é—®é¢˜
4. **æ€§èƒ½ç›‘æ§å™¨**ï¼šæ”¶é›†æ€§èƒ½æŒ‡æ ‡
5. **ç»¼åˆè°ƒè¯•è„šæœ¬**ï¼šä¸€é”®æ£€æŸ¥æ‰€æœ‰é—®é¢˜

**å…³é”®è¦ç‚¹ï¼š**
- ä½¿ç”¨äº‹ä»¶è¿½è¸ªäº†è§£å‹ç¼©è¡Œä¸º
- åˆ†ææ‘˜è¦è´¨é‡æŒç»­æ”¹è¿›
- è°ƒè¯•å·¥å…·å¿«é€Ÿå®šä½é—®é¢˜
- æ€§èƒ½æŒ‡æ ‡ä¼˜åŒ–å‹ç¼©ç­–ç•¥

---

**ä¸‹ä¸€æ­¥å­¦ä¹ ï¼š**
- **å®æˆ˜ä»£ç  04**ï¼šåˆ†æ”¯æ€»ç»“å®ç°ï¼ˆ07_å®æˆ˜ä»£ç _04_åˆ†æ”¯æ€»ç»“å®ç°.mdï¼‰
- **é¢è¯•å¿…é—®**ï¼šå¸¸è§é¢è¯•é—®é¢˜ï¼ˆ08_é¢è¯•å¿…é—®.mdï¼‰

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2026-02-20
**ç»´æŠ¤è€…ï¼š** Claude Code
