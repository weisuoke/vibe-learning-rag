# 最小可用

## 4.1 SPO三元组表示

### 核心概念

**SPO三元组**是知识图谱的基本单元：
- **S (Subject)**: 主语，表示实体
- **P (Predicate)**: 谓语，表示关系
- **O (Object)**: 宾语，表示另一个实体或属性值

### 基本表示法

```python
# 方式1：元组表示
triple = ("张三", "工作于", "阿里巴巴")

# 方式2：字典表示
triple = {
    "subject": "张三",
    "predicate": "工作于",
    "object": "阿里巴巴"
}

# 方式3：带类型的表示
triple = {
    "subject": {"id": "张三", "type": "Person"},
    "predicate": "WORKS_AT",
    "object": {"id": "阿里巴巴", "type": "Company"}
}
```

### 最小实现

```python
"""最小SPO三元组提取器"""

def extract_simple_triples(text: str) -> list[tuple]:
    """
    从文本中提取简单的SPO三元组

    示例：
    输入："张三在阿里巴巴工作。"
    输出：[("张三", "工作于", "阿里巴巴")]
    """
    triples = []

    # 简单规则：主语 + 在 + 宾语 + 工作
    if "在" in text and "工作" in text:
        parts = text.split("在")
        if len(parts) >= 2:
            subject = parts[0].strip()
            rest = parts[1].split("工作")[0].strip()
            triples.append((subject, "工作于", rest))

    return triples

# 测试
text = "张三在阿里巴巴工作。"
print(extract_simple_triples(text))
# 输出：[('张三', '工作于', '阿里巴巴')]
```

### 在RAG中的应用

```python
"""从文档中提取三元组"""

def extract_triples_from_doc(doc: str) -> list[tuple]:
    """
    从文档中提取所有三元组

    应用场景：
    - 文档知识图谱构建
    - 实体关系抽取
    - 知识库构建
    """
    triples = []

    # 分句
    sentences = doc.split("。")

    # 对每个句子提取三元组
    for sentence in sentences:
        if sentence.strip():
            triples.extend(extract_simple_triples(sentence))

    return triples

# 测试
doc = """
张三在阿里巴巴工作。
李四在腾讯工作。
阿里巴巴位于杭州。
"""

triples = extract_triples_from_doc(doc)
for triple in triples:
    print(triple)
# 输出：
# ('张三', '工作于', '阿里巴巴')
# ('李四', '工作于', '腾讯')
```

---

## 4.2 Neo4j基本操作

### 安装Neo4j

```bash
# 方式1：使用Docker（推荐）
docker run \
    --name neo4j \
    -p 7474:7474 -p 7687:7687 \
    -e NEO4J_AUTH=neo4j/password \
    neo4j:latest

# 方式2：使用Neo4j Desktop
# 下载：https://neo4j.com/download/
```

### Python连接Neo4j

```python
"""最小Neo4j连接示例"""

from neo4j import GraphDatabase

# 连接配置
URI = "bolt://localhost:7687"
AUTH = ("neo4j", "password")

# 创建驱动
driver = GraphDatabase.driver(URI, auth=AUTH)

# 测试连接
def test_connection():
    with driver.session() as session:
        result = session.run("RETURN 'Hello, Neo4j!' AS message")
        print(result.single()["message"])

test_connection()
# 输出：Hello, Neo4j!
```

### 创建节点和关系

```python
"""创建节点和关系的最小示例"""

def create_person(name: str, age: int):
    """创建Person节点"""
    with driver.session() as session:
        query = """
        CREATE (p:Person {name: $name, age: $age})
        RETURN p
        """
        result = session.run(query, name=name, age=age)
        return result.single()

def create_works_at(person_name: str, company_name: str):
    """创建WORKS_AT关系"""
    with driver.session() as session:
        query = """
        MATCH (p:Person {name: $person_name})
        MATCH (c:Company {name: $company_name})
        CREATE (p)-[:WORKS_AT]->(c)
        """
        session.run(query, person_name=person_name, company_name=company_name)

# 使用示例
create_person("张三", 30)
create_person("李四", 28)
create_works_at("张三", "阿里巴巴")
```

### 在RAG中的应用

```python
"""从三元组构建知识图谱"""

def build_graph_from_triples(triples: list[tuple]):
    """
    从SPO三元组构建知识图谱

    应用场景：
    - 文档知识图谱构建
    - 实体关系可视化
    - 图检索基础
    """
    with driver.session() as session:
        for subject, predicate, obj in triples:
            # 创建节点和关系
            query = """
            MERGE (s {name: $subject})
            MERGE (o {name: $object})
            MERGE (s)-[r:RELATION {type: $predicate}]->(o)
            """
            session.run(
                query,
                subject=subject,
                predicate=predicate,
                object=obj
            )

# 使用示例
triples = [
    ("张三", "工作于", "阿里巴巴"),
    ("阿里巴巴", "位于", "杭州"),
    ("李四", "工作于", "阿里巴巴")
]

build_graph_from_triples(triples)
print("知识图谱构建完成！")
```

---

## 4.3 简单Cypher查询

### 基本查询语法

```cypher
-- 查询所有Person节点
MATCH (p:Person)
RETURN p

-- 查询特定Person
MATCH (p:Person {name: '张三'})
RETURN p

-- 查询关系
MATCH (p:Person)-[r:WORKS_AT]->(c:Company)
RETURN p.name, c.name

-- 查询路径
MATCH path = (p:Person)-[:WORKS_AT]->(:Company)-[:LOCATED_IN]->(city:City)
RETURN path
```

### Python执行Cypher

```python
"""执行Cypher查询的最小示例"""

def query_person_company():
    """查询所有人和他们的公司"""
    with driver.session() as session:
        query = """
        MATCH (p:Person)-[:WORKS_AT]->(c:Company)
        RETURN p.name AS person, c.name AS company
        """
        result = session.run(query)

        # 打印结果
        for record in result:
            print(f"{record['person']} 在 {record['company']} 工作")

# 使用示例
query_person_company()
# 输出：
# 张三 在 阿里巴巴 工作
# 李四 在 阿里巴巴 工作
```

### 多跳查询

```python
"""多跳查询示例"""

def query_coworkers(person_name: str):
    """查询某人的同事（2跳查询）"""
    with driver.session() as session:
        query = """
        MATCH (p:Person {name: $name})
              -[:WORKS_AT]->(c:Company)
              <-[:WORKS_AT]-(coworker:Person)
        WHERE coworker.name <> $name
        RETURN DISTINCT coworker.name AS coworker
        """
        result = session.run(query, name=person_name)

        coworkers = [record["coworker"] for record in result]
        return coworkers

# 使用示例
coworkers = query_coworkers("张三")
print(f"张三的同事：{coworkers}")
# 输出：张三的同事：['李四']
```

### 在RAG中的应用

```python
"""图检索示例"""

def graph_search(query: str) -> list[str]:
    """
    基于图的检索

    应用场景：
    - 关系查询
    - 多跳推理
    - 知识问答
    """
    # 简单示例：查询某人在哪个城市工作
    if "在哪" in query and "工作" in query:
        # 提取人名（简化版）
        person_name = query.split("在哪")[0].strip()

        with driver.session() as session:
            cypher = """
            MATCH (p:Person {name: $name})
                  -[:WORKS_AT]->(c:Company)
                  -[:LOCATED_IN]->(city:City)
            RETURN city.name AS city
            """
            result = session.run(cypher, name=person_name)

            cities = [record["city"] for record in result]
            return cities

    return []

# 使用示例
query = "张三在哪个城市工作？"
cities = graph_search(query)
print(f"答案：{cities[0] if cities else '未知'}")
```

---

## 4.4 Python连接Neo4j

### 完整连接示例

```python
"""Neo4j连接管理器"""

from neo4j import GraphDatabase
from typing import Optional

class Neo4jConnection:
    """Neo4j连接管理器"""

    def __init__(self, uri: str, user: str, password: str):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        """关闭连接"""
        if self.driver:
            self.driver.close()

    def query(self, cypher: str, parameters: Optional[dict] = None):
        """执行查询"""
        with self.driver.session() as session:
            result = session.run(cypher, parameters or {})
            return [record.data() for record in result]

    def write(self, cypher: str, parameters: Optional[dict] = None):
        """执行写操作"""
        with self.driver.session() as session:
            session.run(cypher, parameters or {})

# 使用示例
conn = Neo4jConnection(
    uri="bolt://localhost:7687",
    user="neo4j",
    password="password"
)

# 查询
results = conn.query("""
    MATCH (p:Person)
    RETURN p.name AS name, p.age AS age
""")

for result in results:
    print(f"{result['name']}, {result['age']}岁")

# 关闭连接
conn.close()
```

### 上下文管理器版本

```python
"""使用上下文管理器的Neo4j连接"""

from contextlib import contextmanager

@contextmanager
def neo4j_session(uri: str, user: str, password: str):
    """Neo4j会话上下文管理器"""
    driver = GraphDatabase.driver(uri, auth=(user, password))
    try:
        with driver.session() as session:
            yield session
    finally:
        driver.close()

# 使用示例
with neo4j_session("bolt://localhost:7687", "neo4j", "password") as session:
    result = session.run("MATCH (p:Person) RETURN p.name AS name")
    for record in result:
        print(record["name"])
```

### 在RAG中的应用

```python
"""RAG系统中的图数据库集成"""

class GraphRAG:
    """简单的GraphRAG实现"""

    def __init__(self, neo4j_uri: str, neo4j_user: str, neo4j_password: str):
        self.conn = Neo4jConnection(neo4j_uri, neo4j_user, neo4j_password)

    def add_document(self, doc: str):
        """添加文档到知识图谱"""
        # 1. 提取三元组
        triples = extract_triples_from_doc(doc)

        # 2. 写入图数据库
        for subject, predicate, obj in triples:
            self.conn.write("""
                MERGE (s {name: $subject})
                MERGE (o {name: $object})
                MERGE (s)-[r:RELATION {type: $predicate}]->(o)
            """, {
                "subject": subject,
                "predicate": predicate,
                "object": obj
            })

    def search(self, query: str) -> list[str]:
        """图检索"""
        return graph_search(query)

    def close(self):
        """关闭连接"""
        self.conn.close()

# 使用示例
rag = GraphRAG(
    neo4j_uri="bolt://localhost:7687",
    neo4j_user="neo4j",
    neo4j_password="password"
)

# 添加文档
rag.add_document("张三在阿里巴巴工作。阿里巴巴位于杭州。")

# 检索
results = rag.search("张三在哪个城市工作？")
print(results)

# 关闭
rag.close()
```

---

## 4.5 基本实体提取

### 基于规则的提取

```python
"""基于规则的实体提取"""

import re

def extract_entities_rule_based(text: str) -> dict:
    """
    基于规则提取实体

    规则：
    - 人名：中文姓名模式
    - 公司：包含"公司"、"集团"等关键词
    - 地点：省市名称
    """
    entities = {
        "persons": [],
        "companies": [],
        "locations": []
    }

    # 人名模式（简化版）
    person_pattern = r'[张李王刘陈杨黄赵周吴][一-龥]{1,2}'
    entities["persons"] = re.findall(person_pattern, text)

    # 公司模式
    company_pattern = r'[一-龥]+(?:公司|集团|科技|网络)'
    entities["companies"] = re.findall(company_pattern, text)

    # 地点模式（简化版）
    location_pattern = r'(?:北京|上海|广州|深圳|杭州|成都|武汉)'
    entities["locations"] = re.findall(location_pattern, text)

    return entities

# 测试
text = "张三在阿里巴巴集团工作，公司位于杭州。"
entities = extract_entities_rule_based(text)
print(entities)
# 输出：
# {
#     'persons': ['张三'],
#     'companies': ['阿里巴巴集团'],
#     'locations': ['杭州']
# }
```

### 基于LLM的提取

```python
"""基于LLM的实体提取"""

from openai import OpenAI

client = OpenAI()

def extract_entities_llm(text: str) -> dict:
    """
    使用LLM提取实体

    优势：
    - 更准确
    - 支持复杂实体
    - 可以提取关系
    """
    prompt = f"""
从以下文本中提取实体和关系，以JSON格式返回。

文本：{text}

返回格式：
{{
    "entities": [
        {{"name": "实体名", "type": "类型"}},
        ...
    ],
    "relations": [
        {{"subject": "主语", "predicate": "关系", "object": "宾语"}},
        ...
    ]
}}
"""

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        response_format={"type": "json_object"}
    )

    import json
    return json.loads(response.choices[0].message.content)

# 测试
text = "张三在阿里巴巴集团工作，公司位于杭州。"
result = extract_entities_llm(text)
print(result)
# 输出：
# {
#     "entities": [
#         {"name": "张三", "type": "Person"},
#         {"name": "阿里巴巴集团", "type": "Company"},
#         {"name": "杭州", "type": "Location"}
#     ],
#     "relations": [
#         {"subject": "张三", "predicate": "工作于", "object": "阿里巴巴集团"},
#         {"subject": "阿里巴巴集团", "predicate": "位于", "object": "杭州"}
#     ]
# }
```

### 在RAG中的应用

```python
"""完整的实体提取 + 图谱构建流程"""

def build_knowledge_graph_from_text(text: str):
    """
    从文本构建知识图谱

    流程：
    1. 提取实体和关系
    2. 写入Neo4j
    3. 返回统计信息
    """
    # 1. 提取实体和关系
    result = extract_entities_llm(text)

    # 2. 连接Neo4j
    conn = Neo4jConnection(
        uri="bolt://localhost:7687",
        user="neo4j",
        password="password"
    )

    # 3. 创建实体节点
    for entity in result["entities"]:
        conn.write("""
            MERGE (e {name: $name})
            SET e.type = $type
        """, {
            "name": entity["name"],
            "type": entity["type"]
        })

    # 4. 创建关系
    for relation in result["relations"]:
        conn.write("""
            MATCH (s {name: $subject})
            MATCH (o {name: $object})
            MERGE (s)-[r:RELATION {type: $predicate}]->(o)
        """, {
            "subject": relation["subject"],
            "predicate": relation["predicate"],
            "object": relation["object"]
        })

    # 5. 关闭连接
    conn.close()

    # 6. 返回统计
    return {
        "entities_count": len(result["entities"]),
        "relations_count": len(result["relations"])
    }

# 使用示例
text = """
张三在阿里巴巴集团工作，担任高级工程师。
阿里巴巴集团总部位于杭州，是中国最大的电商公司之一。
李四也在阿里巴巴工作，是张三的同事。
"""

stats = build_knowledge_graph_from_text(text)
print(f"构建完成：{stats['entities_count']}个实体，{stats['relations_count']}个关系")
```

---

## 总结

### 最小可用技能清单

完成以上5个部分后，你应该能够：

1. **SPO三元组表示**
   - ✅ 理解三元组的基本结构
   - ✅ 能够手写简单的三元组提取器
   - ✅ 能够从文档中提取三元组

2. **Neo4j基本操作**
   - ✅ 能够启动Neo4j数据库
   - ✅ 能够创建节点和关系
   - ✅ 能够从三元组构建图谱

3. **简单Cypher查询**
   - ✅ 能够编写基本的MATCH查询
   - ✅ 能够执行多跳查询
   - ✅ 能够实现图检索

4. **Python连接Neo4j**
   - ✅ 能够使用neo4j-driver连接数据库
   - ✅ 能够执行查询和写操作
   - ✅ 能够管理连接生命周期

5. **基本实体提取**
   - ✅ 能够使用规则提取实体
   - ✅ 能够使用LLM提取实体和关系
   - ✅ 能够构建完整的知识图谱

### 下一步

掌握了最小可用技能后，你可以：
- 学习更复杂的Cypher查询（聚合、排序、路径算法）
- 学习SPARQL和RDF模型
- 学习2025-2026新技术（Graphiti、混合检索）
- 构建生产级GraphRAG系统

---

**引用来源**：
- [Neo4j Python Driver文档](https://neo4j.com/docs/python-manual/current/)
- [Cypher查询语言](https://neo4j.com/docs/cypher-manual/current/)
- [Neo4j GraphRAG Python](https://neo4j.com/docs/neo4j-graphrag-python)

---

**版本**：v1.0
**最后更新**：2026-02-14
**维护者**：Claude Code
