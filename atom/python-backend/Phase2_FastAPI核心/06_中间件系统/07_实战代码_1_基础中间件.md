# 实战代码 1：基础中间件

本文提供最基础的中间件示例，帮助你快速上手 FastAPI 中间件开发。

---

## 1. 最简单的中间件

### 1.1 Hello World 中间件

```python
"""
最简单的中间件示例
演示：中间件的基本结构
"""

from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def hello_middleware(request: Request, call_next):
    # 请求前处理
    print("Hello from middleware!")

    # 调用下一个中间件或路由
    response = await call_next(request)

    # 响应后处理
    print("Goodbye from middleware!")

    return response

@app.get("/")
async def root():
    print("Route handler")
    return {"message": "Hello World"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```bash
# 启动服务器
$ python basic_middleware.py

# 访问 http://localhost:8000/
# 控制台输出：
Hello from middleware!
Route handler
Goodbye from middleware!
```

**关键点：**
- 中间件在路由处理前后都会执行
- 必须调用 `await call_next(request)`
- 必须返回 `response`

---

## 2. 添加响应头

### 2.1 自定义响应头中间件

```python
"""
添加自定义响应头
演示：修改响应对象
"""

from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def add_custom_headers(request: Request, call_next):
    response = await call_next(request)

    # 添加自定义响应头
    response.headers["X-Custom-Header"] = "MyValue"
    response.headers["X-Server"] = "FastAPI"
    response.headers["X-Powered-By"] = "Python"

    return response

@app.get("/")
async def root():
    return {"message": "Check response headers"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 使用 curl 查看响应头
$ curl -I http://localhost:8000/

HTTP/1.1 200 OK
content-type: application/json
x-custom-header: MyValue
x-server: FastAPI
x-powered-by: Python
```

**应用场景：**
- 添加安全头（X-Frame-Options、X-Content-Type-Options）
- 添加性能监控头（X-Process-Time）
- 添加请求追踪头（X-Request-ID）

---

## 3. 计算请求耗时

### 3.1 性能监控中间件

```python
"""
计算请求耗时
演示：在请求前后执行不同的逻辑
"""

from fastapi import FastAPI, Request
import time

app = FastAPI()

@app.middleware("http")
async def timing_middleware(request: Request, call_next):
    # 记录开始时间
    start_time = time.time()

    # 调用下一个中间件或路由
    response = await call_next(request)

    # 计算耗时
    duration = time.time() - start_time

    # 添加耗时到响应头
    response.headers["X-Process-Time"] = f"{duration:.3f}"

    # 打印日志
    print(f"{request.method} {request.url.path} - {duration:.3f}s")

    return response

@app.get("/fast")
async def fast_endpoint():
    return {"message": "Fast response"}

@app.get("/slow")
async def slow_endpoint():
    # 模拟慢请求
    import asyncio
    await asyncio.sleep(1)
    return {"message": "Slow response"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```bash
# 访问快速端点
$ curl http://localhost:8000/fast
# 控制台输出：GET /fast - 0.001s

# 访问慢速端点
$ curl http://localhost:8000/slow
# 控制台输出：GET /slow - 1.002s
```

**应用场景：**
- 性能监控
- 慢请求告警
- API 性能分析

---

## 4. 访问请求信息

### 4.1 请求信息打印中间件

```python
"""
访问请求信息
演示：读取请求的各种属性
"""

from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def inspect_request(request: Request, call_next):
    # 请求方法
    print(f"Method: {request.method}")

    # 请求路径
    print(f"Path: {request.url.path}")

    # 完整 URL
    print(f"Full URL: {request.url}")

    # 查询参数
    print(f"Query params: {dict(request.query_params)}")

    # 请求头
    print(f"User-Agent: {request.headers.get('user-agent')}")
    print(f"Content-Type: {request.headers.get('content-type')}")

    # 客户端信息
    print(f"Client: {request.client.host}:{request.client.port}")

    response = await call_next(request)
    return response

@app.get("/users")
async def get_users(page: int = 1, limit: int = 10):
    return {"page": page, "limit": limit}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```bash
# 访问 http://localhost:8000/users?page=2&limit=20
# 控制台输出：
Method: GET
Path: /users
Full URL: http://localhost:8000/users?page=2&limit=20
Query params: {'page': '2', 'limit': '20'}
User-Agent: curl/7.64.1
Content-Type: None
Client: 127.0.0.1:54321
```

---

## 5. 使用 request.state 传递数据

### 5.1 状态传递中间件

```python
"""
使用 request.state 传递数据
演示：在中间件和路由之间共享数据
"""

from fastapi import FastAPI, Request
import uuid
import time

app = FastAPI()

@app.middleware("http")
async def add_request_info(request: Request, call_next):
    # 生成请求 ID
    request.state.request_id = str(uuid.uuid4())

    # 记录开始时间
    request.state.start_time = time.time()

    # 设置其他信息
    request.state.client_ip = request.client.host

    response = await call_next(request)

    # 添加请求 ID 到响应头
    response.headers["X-Request-ID"] = request.state.request_id

    return response

@app.get("/info")
async def get_info(request: Request):
    # 在路由中读取 request.state
    return {
        "request_id": request.state.request_id,
        "client_ip": request.state.client_ip,
        "elapsed": time.time() - request.state.start_time
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
$ curl http://localhost:8000/info

{
  "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "client_ip": "127.0.0.1",
  "elapsed": 0.001234
}
```

**应用场景：**
- 请求追踪
- 用户信息传递
- 性能监控

---

## 6. 提前返回响应

### 6.1 维护模式中间件

```python
"""
提前返回响应
演示：在中间件中拦截请求
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import os

app = FastAPI()

@app.middleware("http")
async def maintenance_mode(request: Request, call_next):
    # 检查维护模式
    if os.getenv("MAINTENANCE_MODE") == "true":
        # 提前返回，不调用 call_next
        return JSONResponse(
            {
                "error": "Service under maintenance",
                "message": "We'll be back soon!"
            },
            status_code=503
        )

    # 正常处理
    response = await call_next(request)
    return response

@app.get("/")
async def root():
    return {"message": "Service is running"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 正常模式
$ curl http://localhost:8000/
{"message":"Service is running"}

# 维护模式
$ MAINTENANCE_MODE=true python maintenance_middleware.py
$ curl http://localhost:8000/
{"error":"Service under maintenance","message":"We'll be back soon!"}
```

**应用场景：**
- 维护模式
- 路径黑名单
- IP 黑名单
- 认证失败拦截

---

## 7. 多个中间件的执行顺序

### 7.1 洋葱模型演示

```python
"""
多个中间件的执行顺序
演示：洋葱模型
"""

from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def middleware_1(request: Request, call_next):
    print("1: before")
    response = await call_next(request)
    print("1: after")
    return response

@app.middleware("http")
async def middleware_2(request: Request, call_next):
    print("2: before")
    response = await call_next(request)
    print("2: after")
    return response

@app.middleware("http")
async def middleware_3(request: Request, call_next):
    print("3: before")
    response = await call_next(request)
    print("3: after")
    return response

@app.get("/test")
async def test():
    print("Route handler")
    return {"message": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```bash
# 访问 http://localhost:8000/test
# 控制台输出：
1: before
2: before
3: before
Route handler
3: after
2: after
1: after
```

**关键点：**
- 先注册的中间件在最外层
- 后注册的中间件在最内层
- 请求从外到内，响应从内到外

---

## 8. 完整示例：基础中间件组合

### 8.1 组合多个基础中间件

```python
"""
完整示例：组合多个基础中间件
演示：实际项目中的中间件配置
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import time
import uuid

app = FastAPI()

# 1. 请求 ID 中间件
@app.middleware("http")
async def request_id_middleware(request: Request, call_next):
    request.state.request_id = str(uuid.uuid4())
    response = await call_next(request)
    response.headers["X-Request-ID"] = request.state.request_id
    return response

# 2. 性能监控中间件
@app.middleware("http")
async def timing_middleware(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time
    response.headers["X-Process-Time"] = f"{duration:.3f}"
    return response

# 3. 日志中间件
@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    request_id = request.state.request_id
    print(f"[{request_id}] → {request.method} {request.url.path}")

    response = await call_next(request)

    process_time = response.headers.get("X-Process-Time", "0")
    print(f"[{request_id}] ← {response.status_code} ({process_time}s)")

    return response

# 4. 自定义响应头中间件
@app.middleware("http")
async def custom_headers_middleware(request: Request, call_next):
    response = await call_next(request)
    response.headers["X-Server"] = "FastAPI"
    response.headers["X-Powered-By"] = "Python"
    return response

# 业务路由
@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/slow")
async def slow_endpoint():
    import asyncio
    await asyncio.sleep(0.5)
    return {"message": "Slow response"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```bash
# 访问 http://localhost:8000/
# 控制台输出：
[a1b2c3d4-e5f6-7890-abcd-ef1234567890] → GET /
[a1b2c3d4-e5f6-7890-abcd-ef1234567890] ← 200 (0.001s)

# 响应头：
X-Request-ID: a1b2c3d4-e5f6-7890-abcd-ef1234567890
X-Process-Time: 0.001
X-Server: FastAPI
X-Powered-By: Python
```

---

## 9. 中间件开发技巧

### 9.1 条件执行

```python
@app.middleware("http")
async def conditional_middleware(request: Request, call_next):
    # 只对 /api/ 路径执行
    if request.url.path.startswith("/api/"):
        print("API request")

    response = await call_next(request)
    return response
```

### 9.2 跳过某些路径

```python
@app.middleware("http")
async def skip_paths_middleware(request: Request, call_next):
    # 跳过静态文件
    if request.url.path.startswith("/static/"):
        return await call_next(request)

    # 其他路径执行中间件逻辑
    print(f"Processing: {request.url.path}")

    response = await call_next(request)
    return response
```

### 9.3 异常处理

```python
@app.middleware("http")
async def safe_middleware(request: Request, call_next):
    try:
        # 可能出错的操作
        request.state.user_id = get_user_id(request)
    except Exception as e:
        # 记录错误，但不中断请求
        print(f"Error: {e}")
        request.state.user_id = None

    response = await call_next(request)
    return response
```

---

## 总结

**基础中间件的核心要点：**

1. **基本结构**：`request → call_next() → response`
2. **请求前处理**：在 `call_next()` 之前
3. **响应后处理**：在 `call_next()` 之后
4. **状态传递**：使用 `request.state`
5. **提前返回**：不调用 `call_next()`
6. **洋葱模型**：先注册在外层，后注册在内层

**下一步学习：**
- 实战代码 2：请求日志中间件
- 实战代码 3：认证中间件
- 实战代码 4：限流中间件
- 实战代码 5：错误处理中间件
