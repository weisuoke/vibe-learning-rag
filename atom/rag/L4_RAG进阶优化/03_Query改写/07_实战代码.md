# 实战代码

一个完整可运行的 Query改写示例，展示 HyDE、Multi-Query 和智能路由的实际应用。

---

## 完整示例：智能 Query改写系统

```python
"""
Query改写实战示例
演示：HyDE、Multi-Query、智能路由的完整实现
"""

import os
import re
import json
from typing import Literal
from openai import OpenAI
import numpy as np

# ===== 初始化 =====
client = OpenAI()

# ===== 1. 基础工具函数 =====

def get_embedding(text: str) -> list[float]:
    """获取文本的 Embedding 向量"""
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    return response.data[0].embedding


def cosine_similarity(a: list, b: list) -> float:
    """计算余弦相似度"""
    a, b = np.array(a), np.array(b)
    return float(np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)))


# ===== 2. Query改写策略 =====

def hyde_rewrite(query: str) -> str:
    """
    HyDE: 生成假设文档
    适用于开放性问题
    """
    prompt = f"""请简要回答以下问题（80-120字）。
只包含最核心的信息，使用专业但易懂的语言。

问题：{query}

回答："""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.5,
        max_tokens=200
    )

    return response.choices[0].message.content.strip()


def multi_query_rewrite(query: str, num_variants: int = 3) -> list[str]:
    """
    Multi-Query: 生成多个查询变体
    适用于模糊/多义查询
    """
    prompt = f"""请将以下查询改写成 {num_variants} 个不同的版本。
每个版本应该：
1. 保持原始查询的核心意图
2. 使用不同的表达方式或同义词
3. 可能从不同角度描述同一需求

原始查询：{query}

请直接输出 {num_variants} 个改写，每行一个（不要编号）："""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.8,
        max_tokens=300
    )

    variants = response.choices[0].message.content.strip().split('\n')
    variants = [v.strip() for v in variants if v.strip()]

    # 返回原始查询 + 变体
    return [query] + variants[:num_variants]


def decompose_query(query: str) -> list[str]:
    """
    Query Decomposition: 分解复杂问题
    适用于复合型问题
    """
    prompt = f"""请将以下复杂问题分解为 2-4 个简单的子问题。
每个子问题应该是独立的、可以单独回答的。

复杂问题：{query}

请以 JSON 数组格式输出子问题："""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.3,
        max_tokens=300
    )

    content = response.choices[0].message.content
    try:
        # 尝试提取 JSON 数组
        match = re.search(r'\[.*\]', content, re.DOTALL)
        if match:
            return json.loads(match.group())
    except json.JSONDecodeError:
        pass

    # 回退：按行分割
    return [q.strip() for q in content.split('\n') if q.strip()]


# ===== 3. 智能路由 =====

def classify_query(query: str) -> Literal["exact", "open", "complex", "fuzzy"]:
    """
    分类查询类型，决定使用哪种改写策略

    返回：
    - exact: 精确查询，不需要改写
    - open: 开放性问题，使用 HyDE
    - complex: 复杂复合问题，使用 Decomposition
    - fuzzy: 模糊查询，使用 Multi-Query
    """
    # 精确查询特征
    exact_patterns = [
        r'error[:\s]',
        r'\d+\.\d+\.\d+',
        r'pip\s+install',
        r'git\s+\w+',
        r'import\s+\w+',
        r'[A-Z]{2,}_[A-Z]+',  # 常量名如 API_KEY
    ]

    for pattern in exact_patterns:
        if re.search(pattern, query, re.IGNORECASE):
            return "exact"

    # 复杂问题特征
    complex_keywords = ['比较', '对比', '区别', '优缺点', '和...的区别', 'vs', 'versus']
    for keyword in complex_keywords:
        if keyword in query.lower():
            return "complex"

    # 开放性问题特征
    open_keywords = ['如何', '怎么', '怎样', '什么是', '为什么', '原理', '最佳实践']
    for keyword in open_keywords:
        if keyword in query:
            return "open"

    # 默认：模糊查询
    return "fuzzy"


def smart_rewrite(query: str) -> dict:
    """
    智能 Query改写
    根据查询类型自动选择最佳策略
    """
    query_type = classify_query(query)

    result = {
        "original_query": query,
        "query_type": query_type,
        "strategy": None,
        "rewritten_queries": []
    }

    if query_type == "exact":
        result["strategy"] = "none"
        result["rewritten_queries"] = [query]

    elif query_type == "open":
        result["strategy"] = "hyde"
        hyde_doc = hyde_rewrite(query)
        result["rewritten_queries"] = [hyde_doc]
        result["hyde_document"] = hyde_doc

    elif query_type == "complex":
        result["strategy"] = "decomposition"
        sub_queries = decompose_query(query)
        result["rewritten_queries"] = sub_queries

    else:  # fuzzy
        result["strategy"] = "multi_query"
        result["rewritten_queries"] = multi_query_rewrite(query)

    return result


# ===== 4. 模拟向量检索 =====

class SimpleVectorStore:
    """简单的向量存储，用于演示"""

    def __init__(self, documents: list[str]):
        self.documents = documents
        self.embeddings = [get_embedding(doc) for doc in documents]

    def search(self, query: str, top_k: int = 3) -> list[dict]:
        """检索最相似的文档"""
        query_embedding = get_embedding(query)

        similarities = [
            cosine_similarity(query_embedding, doc_emb)
            for doc_emb in self.embeddings
        ]

        # 排序并返回 top_k
        results = sorted(
            zip(self.documents, similarities),
            key=lambda x: x[1],
            reverse=True
        )

        return [
            {"content": doc, "score": score}
            for doc, score in results[:top_k]
        ]


def search_with_rewrite(
    query: str,
    vector_store: SimpleVectorStore,
    top_k: int = 3
) -> dict:
    """
    带 Query改写的完整检索流程
    """
    # 1. 智能改写
    rewrite_result = smart_rewrite(query)

    # 2. 执行检索
    all_results = []
    seen_contents = set()

    for rewritten_query in rewrite_result["rewritten_queries"]:
        results = vector_store.search(rewritten_query, top_k=top_k)
        for doc in results:
            if doc["content"] not in seen_contents:
                all_results.append(doc)
                seen_contents.add(doc["content"])

    # 3. 按分数排序，取 top_k
    all_results.sort(key=lambda x: x["score"], reverse=True)

    return {
        "query": query,
        "rewrite_info": rewrite_result,
        "results": all_results[:top_k]
    }


# ===== 5. 演示 =====

def demo():
    """演示 Query改写的效果"""

    # 准备测试文档
    documents = [
        "Python asyncio 库提供了异步 IO 支持，使用 async/await 语法编写并发代码",
        "Python 性能优化可以通过 profiling 分析瓶颈，使用 cProfile 或 line_profiler",
        "Python 多线程受 GIL 限制，IO 密集型任务适合多线程，CPU 密集型适合多进程",
        "Python 3.12 引入了更快的解释器和改进的错误消息",
        "Redis 是高性能的内存数据库，支持多种数据结构，常用于缓存",
        "Memcached 是简单的分布式内存缓存系统，只支持简单的键值存储",
        "数据库索引可以显著提升查询性能，但会增加写入开销",
        "Python 装饰器是一种设计模式，用于在不修改函数代码的情况下扩展功能",
    ]

    print("=" * 60)
    print("Query改写实战演示")
    print("=" * 60)

    # 创建向量存储
    print("\n正在创建向量存储...")
    vector_store = SimpleVectorStore(documents)
    print(f"已索引 {len(documents)} 个文档")

    # 测试不同类型的查询
    test_queries = [
        # 精确查询 - 不改写
        "Python 3.12 新特性",

        # 开放性问题 - HyDE
        "Python 怎么实现异步编程",

        # 复杂问题 - Decomposition
        "比较 Redis 和 Memcached 的优缺点",

        # 模糊查询 - Multi-Query
        "代码跑得慢怎么办",
    ]

    for query in test_queries:
        print("\n" + "-" * 60)
        print(f"原始查询: {query}")

        result = search_with_rewrite(query, vector_store, top_k=2)

        print(f"查询类型: {result['rewrite_info']['query_type']}")
        print(f"改写策略: {result['rewrite_info']['strategy']}")

        if result['rewrite_info']['strategy'] == 'hyde':
            print(f"HyDE 文档: {result['rewrite_info']['hyde_document'][:100]}...")
        elif result['rewrite_info']['strategy'] == 'multi_query':
            print("改写变体:")
            for i, q in enumerate(result['rewrite_info']['rewritten_queries'], 1):
                print(f"  {i}. {q}")
        elif result['rewrite_info']['strategy'] == 'decomposition':
            print("分解子问题:")
            for i, q in enumerate(result['rewrite_info']['rewritten_queries'], 1):
                print(f"  {i}. {q}")

        print("\n检索结果:")
        for i, doc in enumerate(result['results'], 1):
            print(f"  {i}. [{doc['score']:.3f}] {doc['content'][:50]}...")

    print("\n" + "=" * 60)
    print("演示完成")
    print("=" * 60)


if __name__ == "__main__":
    demo()
```

---

## 运行输出示例

```
============================================================
Query改写实战演示
============================================================

正在创建向量存储...
已索引 8 个文档

------------------------------------------------------------
原始查询: Python 3.12 新特性
查询类型: exact
改写策略: none

检索结果:
  1. [0.847] Python 3.12 引入了更快的解释器和改进的错误消息...
  2. [0.723] Python asyncio 库提供了异步 IO 支持，使用 async/...

------------------------------------------------------------
原始查询: Python 怎么实现异步编程
查询类型: open
改写策略: hyde
HyDE 文档: Python 实现异步编程主要通过 asyncio 库。使用 async 定义协程函数，await 等待...

检索结果:
  1. [0.912] Python asyncio 库提供了异步 IO 支持，使用 async/...
  2. [0.756] Python 多线程受 GIL 限制，IO 密集型任务适合多线程...

------------------------------------------------------------
原始查询: 比较 Redis 和 Memcached 的优缺点
查询类型: complex
改写策略: decomposition
分解子问题:
  1. Redis 的主要特点和优势是什么？
  2. Memcached 的主要特点和优势是什么？
  3. Redis 和 Memcached 各自适合什么场景？

检索结果:
  1. [0.889] Redis 是高性能的内存数据库，支持多种数据结构，常用...
  2. [0.867] Memcached 是简单的分布式内存缓存系统，只支持简单的...

------------------------------------------------------------
原始查询: 代码跑得慢怎么办
查询类型: fuzzy
改写策略: multi_query
改写变体:
  1. 代码跑得慢怎么办
  2. 如何优化代码性能
  3. 程序运行速度慢的解决方法
  4. 提升代码执行效率的技巧

检索结果:
  1. [0.834] Python 性能优化可以通过 profiling 分析瓶颈，使用 c...
  2. [0.798] 数据库索引可以显著提升查询性能，但会增加写入开销...

============================================================
演示完成
============================================================
```

---

## 代码要点说明

### 1. 智能路由的实现

```python
# 通过正则和关键词匹配判断查询类型
def classify_query(query: str) -> str:
    # 精确查询：包含版本号、错误码、命令等
    # 复杂问题：包含"比较"、"对比"等关键词
    # 开放性问题：包含"如何"、"怎么"等关键词
    # 默认：模糊查询
```

### 2. HyDE 的关键参数

```python
# temperature=0.5：适中的创造性，避免太发散
# max_tokens=200：限制长度，保持简洁
# 提示词要求 80-120 字：聚焦核心信息
```

### 3. Multi-Query 的关键参数

```python
# temperature=0.8：较高的创造性，增加多样性
# 返回原始查询 + 变体：确保原始意图不丢失
```

### 4. 结果去重和融合

```python
# 使用 seen_contents 集合去重
# 按分数排序，取 top_k
# 可以扩展为 RRF 融合
```

---

## 扩展建议

1. **添加缓存**：对相同查询的改写结果进行缓存
2. **异步执行**：Multi-Query 的多个检索可以并行执行
3. **A/B 测试**：对比不同策略的效果
4. **监控指标**：记录改写延迟、检索效果等指标

---

**下一步：** [08_面试必问](./08_面试必问.md) - 如何在面试中展示 Query改写的理解
