# docker-compose编排 - 核心概念：环境配置管理

## 概述

**环境配置管理** 是容器化应用的核心问题之一。不同环境（开发/测试/生产）需要不同的配置，而配置与代码分离是最佳实践。docker-compose 提供了多种环境配置管理方案。

**本文涵盖：**
1. environment 环境变量定义
2. env_file 文件引用
3. .env 文件管理
4. profiles 多环境配置
5. secrets 敏感信息管理
6. 多环境配置策略

---

## 1. environment 环境变量定义

### 1.1 基本用法

```yaml
services:
  api:
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
      - REDIS_URL=redis://redis:6379
      - DEBUG=true
```

**说明：**
- 直接在 docker-compose.yml 中定义环境变量
- 格式：`KEY=VALUE`
- 容器内可以通过 `os.environ` 访问

**Python 代码：**
```python
import os

database_url = os.environ.get('DATABASE_URL')
redis_url = os.environ.get('REDIS_URL')
debug = os.environ.get('DEBUG', 'false').lower() == 'true'
```

### 1.2 字典格式

```yaml
services:
  api:
    environment:
      DATABASE_URL: postgresql://user:pass@db:5432/mydb
      REDIS_URL: redis://redis:6379
      DEBUG: "true"
```

**注意：** 布尔值和数字需要用引号包裹，否则会被解析为 YAML 类型。

### 1.3 引用主机环境变量

```yaml
services:
  api:
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}  # 从主机环境变量读取
      - DATABASE_URL=${DATABASE_URL:-postgresql://user:pass@db:5432/mydb}  # 默认值
```

**说明：**
- `${VAR}`：引用主机环境变量
- `${VAR:-default}`：如果变量不存在，使用默认值

**前端类比：**
```javascript
// environment = process.env
const apiKey = process.env.OPENAI_API_KEY;
const dbUrl = process.env.DATABASE_URL || 'postgresql://...';
```

---

## 2. env_file 文件引用

### 2.1 基本用法

```yaml
services:
  api:
    env_file:
      - .env
```

**.env 文件：**
```bash
DATABASE_URL=postgresql://user:pass@db:5432/mydb
REDIS_URL=redis://redis:6379
OPENAI_API_KEY=sk-xxx
DEBUG=true
```

**说明：**
- `env_file` 指定环境变量文件
- 文件中的变量会自动加载到容器

### 2.2 多个文件

```yaml
services:
  api:
    env_file:
      - .env          # 基础配置
      - .env.local    # 本地覆盖
```

**加载顺序：**
- 后面的文件会覆盖前面的文件
- `.env.local` 中的变量会覆盖 `.env` 中的同名变量

### 2.3 指定文件路径

```yaml
services:
  api:
    env_file:
      - ./config/.env.dev
      - ./config/.env.local
```

---

## 3. .env 文件管理

### 3.1 .env 文件格式

```bash
# 数据库配置
DATABASE_URL=postgresql://user:pass@db:5432/mydb
POSTGRES_USER=user
POSTGRES_PASSWORD=pass
POSTGRES_DB=mydb

# Redis 配置
REDIS_URL=redis://redis:6379

# API 密钥（敏感信息）
OPENAI_API_KEY=sk-xxx
ANTHROPIC_API_KEY=sk-ant-xxx

# 应用配置
DEBUG=true
LOG_LEVEL=info
APP_ENV=development

# 注释
# 这是注释
```

**规则：**
- 每行一个变量
- 格式：`KEY=VALUE`
- 支持注释（`#` 开头）
- 不支持多行值
- 不支持引号（值会包含引号）

### 3.2 .env 文件优先级

```
1. docker-compose.yml 中的 environment（最高优先级）
   ↓
2. env_file 指定的文件
   ↓
3. docker-compose.yml 同目录的 .env 文件
   ↓
4. 主机环境变量（最低优先级）
```

**示例：**

```yaml
# docker-compose.yml
services:
  api:
    environment:
      - DEBUG=false  # 优先级最高
    env_file:
      - .env.local   # 优先级第二
```

**.env.local：**
```bash
DEBUG=true
LOG_LEVEL=debug
```

**.env：**
```bash
DEBUG=true
LOG_LEVEL=info
APP_ENV=development
```

**最终结果：**
```bash
DEBUG=false           # 来自 environment
LOG_LEVEL=debug       # 来自 .env.local
APP_ENV=development   # 来自 .env
```

### 3.3 .env 文件最佳实践

```bash
# .env.example（模板文件，提交到 Git）
DATABASE_URL=postgresql://user:pass@localhost:5432/mydb
OPENAI_API_KEY=your_key_here
DEBUG=true

# .env（实际配置，不提交到 Git）
DATABASE_URL=postgresql://user:pass@localhost:5432/mydb
OPENAI_API_KEY=sk-xxx
DEBUG=true

# .env.local（本地覆盖，不提交到 Git）
DEBUG=false
LOG_LEVEL=debug
```

**.gitignore：**
```
.env
.env.local
.env.*.local
```

---

## 4. profiles 多环境配置

### 4.1 基本用法

```yaml
services:
  # 所有环境都启动
  api:
    profiles: ["dev", "test", "prod"]

  db:
    profiles: ["dev", "test", "prod"]

  # 只在开发环境启动
  pgadmin:
    profiles: ["dev"]
    image: dpage/pgadmin4

  # 只在生产环境启动
  nginx:
    profiles: ["prod"]
    image: nginx
```

**使用：**
```bash
# 开发环境（启动 api、db、pgadmin）
docker-compose --profile dev up

# 生产环境（启动 api、db、nginx）
docker-compose --profile prod up

# 多个 profile
docker-compose --profile dev --profile test up
```

### 4.2 默认 profile

```yaml
services:
  # 不指定 profile，总是启动
  api:
    image: my-api

  # 指定 profile，需要显式启动
  debug-tools:
    profiles: ["dev"]
    image: debug-tools
```

**说明：**
- 不指定 `profiles` 的服务总是启动
- 指定 `profiles` 的服务需要 `--profile` 参数

### 4.3 在 AI Agent 开发中的应用

```yaml
services:
  # 核心服务（所有环境）
  api:
    build: .
    profiles: ["dev", "test", "prod"]

  db:
    image: postgres:14-alpine
    profiles: ["dev", "test", "prod"]

  redis:
    image: redis:7-alpine
    profiles: ["dev", "test", "prod"]

  # 开发工具（只在开发环境）
  pgadmin:
    profiles: ["dev"]
    image: dpage/pgadmin4
    ports:
      - "5050:80"

  # 测试工具（只在测试环境）
  test-runner:
    profiles: ["test"]
    build: .
    command: pytest

  # 生产工具（只在生产环境）
  nginx:
    profiles: ["prod"]
    image: nginx
    ports:
      - "80:80"

  prometheus:
    profiles: ["prod"]
    image: prom/prometheus
```

**使用：**
```bash
# 开发环境
docker-compose --profile dev up

# 测试环境
docker-compose --profile test up

# 生产环境
docker-compose --profile prod up -d
```

---

## 5. secrets 敏感信息管理

### 5.1 Docker Swarm secrets（生产环境）

```yaml
version: '3.8'

services:
  api:
    image: my-api
    secrets:
      - db_password
      - api_key

secrets:
  db_password:
    external: true  # 外部创建的 secret

  api_key:
    file: ./secrets/api_key.txt  # 从文件读取
```

**创建 secret：**
```bash
# Docker Swarm
echo "my_password" | docker secret create db_password -

# 使用
docker stack deploy -c docker-compose.yml myapp
```

**访问 secret：**
```python
# 容器内访问（/run/secrets/<secret_name>）
with open('/run/secrets/db_password') as f:
    db_password = f.read().strip()
```

### 5.2 环境变量 + .env（开发环境）

```yaml
services:
  api:
    environment:
      - DATABASE_PASSWORD=${DATABASE_PASSWORD}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
```

**.env（不提交到 Git）：**
```bash
DATABASE_PASSWORD=my_secret_password
OPENAI_API_KEY=sk-xxx
```

### 5.3 外部密钥管理（推荐）

```yaml
services:
  api:
    environment:
      # 从外部密钥管理系统读取
      - DATABASE_PASSWORD=${DATABASE_PASSWORD}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
```

**使用外部密钥管理：**
```bash
# AWS Secrets Manager
export DATABASE_PASSWORD=$(aws secretsmanager get-secret-value --secret-id db-password --query SecretString --output text)

# HashiCorp Vault
export DATABASE_PASSWORD=$(vault kv get -field=password secret/database)

# 启动
docker-compose up
```

---

## 6. 多环境配置策略

### 6.1 策略1：多文件策略（推荐）

**文件结构：**
```
docker-compose.yml          # 基础配置
docker-compose.dev.yml      # 开发环境覆盖
docker-compose.test.yml     # 测试环境覆盖
docker-compose.prod.yml     # 生产环境覆盖
.env.example                # 环境变量模板
.env.dev                    # 开发环境变量
.env.test                   # 测试环境变量
.env.prod                   # 生产环境变量
```

**基础配置（docker-compose.yml）：**
```yaml
version: '3.8'

services:
  api:
    build: .
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}

  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
```

**开发环境覆盖（docker-compose.dev.yml）：**
```yaml
version: '3.8'

services:
  api:
    volumes:
      - .:/app  # 代码热重载
    command: uvicorn app.main:app --reload
    environment:
      - DEBUG=true

  # 添加开发工具
  pgadmin:
    image: dpage/pgadmin4
    ports:
      - "5050:80"
```

**生产环境覆盖（docker-compose.prod.yml）：**
```yaml
version: '3.8'

services:
  api:
    image: my-api:latest  # 使用构建好的镜像
    restart: always
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
    environment:
      - DEBUG=false

  # 添加生产工具
  nginx:
    image: nginx
    ports:
      - "80:80"
```

**使用：**
```bash
# 开发环境
cp .env.dev .env
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up

# 生产环境
cp .env.prod .env
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

### 6.2 策略2：环境变量策略

```yaml
# docker-compose.yml
services:
  api:
    image: my-api:${APP_VERSION:-latest}
    command: ${API_COMMAND:-uvicorn app.main:app}
    environment:
      - DEBUG=${DEBUG:-false}
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - DATABASE_URL=${DATABASE_URL}
```

**.env.dev：**
```bash
APP_VERSION=dev
API_COMMAND=uvicorn app.main:app --reload
DEBUG=true
LOG_LEVEL=debug
DATABASE_URL=postgresql://user:pass@db:5432/dev_db
```

**.env.prod：**
```bash
APP_VERSION=v1.0.0
API_COMMAND=uvicorn app.main:app --workers 4
DEBUG=false
LOG_LEVEL=warning
DATABASE_URL=postgresql://user:pass@prod-db:5432/prod_db
```

### 6.3 策略3：profiles + 多文件（最灵活）

```yaml
# docker-compose.yml
services:
  api:
    build: .
    profiles: ["dev", "test", "prod"]

  db:
    image: postgres:14-alpine
    profiles: ["dev", "test", "prod"]

  pgadmin:
    profiles: ["dev"]
    image: dpage/pgadmin4

  nginx:
    profiles: ["prod"]
    image: nginx
```

**使用：**
```bash
# 开发环境
docker-compose --profile dev \
  -f docker-compose.yml \
  -f docker-compose.dev.yml \
  up

# 生产环境
docker-compose --profile prod \
  -f docker-compose.yml \
  -f docker-compose.prod.yml \
  up -d
```

---

## 7. 在 AI Agent 开发中的完整示例

### 7.1 文件结构

```
my-ai-agent/
├── docker-compose.yml          # 基础配置
├── docker-compose.dev.yml      # 开发环境
├── docker-compose.test.yml     # 测试环境
├── docker-compose.prod.yml     # 生产环境
├── .env.example                # 环境变量模板
├── .env.dev                    # 开发环境变量
├── .env.test                   # 测试环境变量
├── .env.prod                   # 生产环境变量（不提交）
└── .gitignore
```

### 7.2 基础配置

**docker-compose.yml：**
```yaml
version: '3.8'

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "${API_PORT:-8000}:8000"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - DEBUG=${DEBUG:-false}
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - app-network

  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "${POSTGRES_USER}"]
      interval: 5s
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    networks:
      - app-network

volumes:
  postgres_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

### 7.3 开发环境配置

**docker-compose.dev.yml：**
```yaml
version: '3.8'

services:
  api:
    volumes:
      - .:/app:delegated  # 代码热重载
      - /app/.venv
    command: uvicorn app.main:app --host 0.0.0.0 --reload
    environment:
      - DEBUG=true
      - LOG_LEVEL=debug

  # 开发工具
  pgadmin:
    image: dpage/pgadmin4
    ports:
      - "5050:80"
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_EMAIL:-admin@example.com}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_PASSWORD:-admin}
    networks:
      - app-network
```

**.env.dev：**
```bash
# API 配置
API_PORT=8000
DEBUG=true
LOG_LEVEL=debug

# 数据库配置
DATABASE_URL=postgresql://user:pass@db:5432/agent_dev
POSTGRES_USER=user
POSTGRES_PASSWORD=pass
POSTGRES_DB=agent_dev

# Redis 配置
REDIS_URL=redis://redis:6379

# API 密钥
OPENAI_API_KEY=sk-xxx

# pgAdmin 配置
PGADMIN_EMAIL=admin@example.com
PGADMIN_PASSWORD=admin
```

### 7.4 测试环境配置

**docker-compose.test.yml：**
```yaml
version: '3.8'

services:
  api:
    command: pytest
    environment:
      - DEBUG=false
      - LOG_LEVEL=info

  # 测试数据库（独立）
  test-db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_USER=${TEST_POSTGRES_USER}
      - POSTGRES_PASSWORD=${TEST_POSTGRES_PASSWORD}
      - POSTGRES_DB=${TEST_POSTGRES_DB}
    networks:
      - app-network
```

**.env.test：**
```bash
# API 配置
DEBUG=false
LOG_LEVEL=info

# 测试数据库配置
DATABASE_URL=postgresql://test:test@test-db:5432/agent_test
TEST_POSTGRES_USER=test
TEST_POSTGRES_PASSWORD=test
TEST_POSTGRES_DB=agent_test

# Redis 配置
REDIS_URL=redis://redis:6379

# API 密钥（测试用）
OPENAI_API_KEY=sk-test-xxx
```

### 7.5 生产环境配置

**docker-compose.prod.yml：**
```yaml
version: '3.8'

services:
  api:
    image: my-api:${APP_VERSION}  # 使用构建好的镜像
    restart: always
    command: uvicorn app.main:app --host 0.0.0.0 --workers 4
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    environment:
      - DEBUG=false
      - LOG_LEVEL=warning

  db:
    restart: always
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

  redis:
    restart: always

  # 反向代理
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - api
    networks:
      - app-network
    restart: always

  # 监控
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
    networks:
      - app-network
    restart: always
```

**.env.prod（不提交到 Git）：**
```bash
# API 配置
APP_VERSION=v1.0.0
API_PORT=8000
DEBUG=false
LOG_LEVEL=warning

# 数据库配置（生产环境）
DATABASE_URL=postgresql://prod_user:prod_pass@db:5432/agent_prod
POSTGRES_USER=prod_user
POSTGRES_PASSWORD=prod_pass
POSTGRES_DB=agent_prod

# Redis 配置
REDIS_URL=redis://redis:6379

# API 密钥（生产环境）
OPENAI_API_KEY=sk-prod-xxx
```

### 7.6 使用方式

```bash
# 开发环境
cp .env.dev .env
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up

# 测试环境
cp .env.test .env
docker-compose -f docker-compose.yml -f docker-compose.test.yml up

# 生产环境
cp .env.prod .env
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

---

## 8. 最佳实践

### 8.1 环境变量命名

```bash
# ✅ 推荐：清晰的命名
DATABASE_URL=postgresql://...
REDIS_URL=redis://...
OPENAI_API_KEY=sk-xxx
DEBUG=true
LOG_LEVEL=info

# ❌ 不推荐：模糊的命名
DB=postgresql://...
CACHE=redis://...
KEY=sk-xxx
D=true
L=info
```

### 8.2 敏感信息管理

```bash
# ✅ 推荐：使用 .env 文件（不提交）
# .env
OPENAI_API_KEY=sk-xxx
DATABASE_PASSWORD=secret

# .gitignore
.env
.env.local
.env.*.local

# ❌ 不推荐：硬编码在 docker-compose.yml
services:
  api:
    environment:
      - OPENAI_API_KEY=sk-xxx  # 不要这样做！
```

### 8.3 默认值

```yaml
# ✅ 推荐：提供默认值
services:
  api:
    environment:
      - DEBUG=${DEBUG:-false}
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - API_PORT=${API_PORT:-8000}

# ❌ 不推荐：没有默认值
services:
  api:
    environment:
      - DEBUG=${DEBUG}  # 如果未设置会报错
```

### 8.4 环境变量文档

```bash
# .env.example（提交到 Git）
# 数据库配置
DATABASE_URL=postgresql://user:pass@localhost:5432/mydb
POSTGRES_USER=user
POSTGRES_PASSWORD=your_password_here
POSTGRES_DB=mydb

# API 密钥（从 https://platform.openai.com/api-keys 获取）
OPENAI_API_KEY=your_key_here

# 应用配置
DEBUG=true
LOG_LEVEL=info
```

---

## 9. 常见问题

### Q1: 环境变量没有生效怎么办？

**A:** 检查优先级和格式

```bash
# 1. 检查 .env 文件是否存在
ls -la .env

# 2. 检查环境变量格式（不要有空格）
# ✅ 正确
DATABASE_URL=postgresql://...

# ❌ 错误
DATABASE_URL = postgresql://...  # 有空格

# 3. 重新启动容器
docker-compose down
docker-compose up
```

### Q2: 如何在容器内查看环境变量？

**A:** 使用 docker-compose exec

```bash
# 查看所有环境变量
docker-compose exec api env

# 查看特定环境变量
docker-compose exec api env | grep DATABASE_URL
```

### Q3: 如何在不同环境使用不同的 .env 文件？

**A:** 使用符号链接或复制

```bash
# 方法1：复制
cp .env.dev .env

# 方法2：符号链接
ln -sf .env.dev .env

# 方法3：使用脚本
#!/bin/bash
ENV=${1:-dev}
cp .env.$ENV .env
docker-compose up
```

### Q4: 如何传递多行环境变量？

**A:** 使用文件或 base64 编码

```bash
# 方法1：使用文件
services:
  api:
    volumes:
      - ./private_key.pem:/app/private_key.pem:ro

# 方法2：base64 编码
PRIVATE_KEY=$(cat private_key.pem | base64)

# 在容器内解码
import base64
private_key = base64.b64decode(os.environ['PRIVATE_KEY'])
```

### Q5: 如何在 CI/CD 中管理环境变量？

**A:** 使用 CI/CD 平台的密钥管理

```bash
# GitHub Actions
- name: Deploy
  env:
    DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
    OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  run: |
    echo "DATABASE_PASSWORD=$DATABASE_PASSWORD" >> .env
    echo "OPENAI_API_KEY=$OPENAI_API_KEY" >> .env
    docker-compose up -d
```

---

## 10. 总结

**环境配置管理的核心要素：**
1. **environment**：直接定义环境变量
2. **env_file**：从文件加载环境变量
3. **.env**：环境变量文件（不提交到 Git）
4. **profiles**：多环境配置
5. **secrets**：敏感信息管理

**在 AI Agent 开发中：**
- 使用多文件策略管理多环境
- 敏感信息用 .env 文件（不提交）
- 提供 .env.example 模板
- 使用默认值提高容错性
- 文档化所有环境变量

**最佳实践：**
- ✅ 配置与代码分离
- ✅ 敏感信息不提交到 Git
- ✅ 提供默认值
- ✅ 文档化环境变量
- ❌ 不要硬编码敏感信息
- ❌ 不要提交 .env 文件

---

**版本：** v1.0
**最后更新：** 2026-02-12
