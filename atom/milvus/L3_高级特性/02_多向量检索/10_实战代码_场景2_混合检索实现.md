# 实战代码 - 场景2：混合检索实现

> 同时检索多个向量字段并融合结果

---

## 场景描述

**目标：** 实现混合检索，同时检索文本向量和图片向量，并使用 RRF 融合结果

**应用场景：**
- 用户同时输入文字和图片进行搜索
- 提升检索准确率（融合多个维度的信息）
- 多模态文档检索

---

## 完整代码

```python
"""
混合检索实现 - 完整示例
演示：使用 hybrid_search() 和手动实现两种方式
"""

import os
from pymilvus import (
    connections,
    Collection,
    AnnSearchRequest,
    RRFRanker,
)
from openai import OpenAI
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

# ===== 1. 连接到 Milvus =====
print("=== 连接到 Milvus ===")
connections.connect(
    alias="default",
    host=os.getenv("MILVUS_HOST", "localhost"),
    port=os.getenv("MILVUS_PORT", "19530")
)
print("✅ 连接成功")

# ===== 2. 加载 Collection =====
print("\n=== 加载 Collection ===")
collection_name = "doc_qa_multi_vector"
collection = Collection(collection_name)
collection.load()
print(f"✅ Collection '{collection_name}' 已加载")
print(f"   文档数量：{collection.num_entities}")

# ===== 3. 初始化 OpenAI 客户端 =====
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def get_text_embedding(text):
    """生成文本向量"""
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    return response.data[0].embedding

def get_image_embedding_mock():
    """生成图片向量（Mock）"""
    import random
    return [random.random() for _ in range(512)]

# ===== 4. 方法1：使用 hybrid_search()（Milvus 2.4+）=====
print("\n" + "="*60)
print("方法1：使用 hybrid_search()（推荐）")
print("="*60)

# 用户查询
user_query = "如何安装 Python？"
print(f"\n查询：{user_query}")

# 生成查询向量
print("生成查询向量...")
text_embedding = get_text_embedding(user_query)
image_embedding = get_image_embedding_mock()  # 实际应用中应该从用户上传的图片生成

# 定义检索请求
print("定义检索请求...")

# 请求1：检索 text_vector
text_req = AnnSearchRequest(
    data=[text_embedding],
    anns_field="text_vector",
    param={
        "metric_type": "COSINE",
        "params": {"ef": 100}  # HNSW 参数
    },
    limit=10  # 召回10个候选
)
print("  - text_vector 请求：COSINE, limit=10")

# 请求2：检索 image_vector
image_req = AnnSearchRequest(
    data=[image_embedding],
    anns_field="image_vector",
    param={
        "metric_type": "COSINE",
        "params": {"ef": 100}
    },
    limit=10  # 召回10个候选
)
print("  - image_vector 请求：COSINE, limit=10")

# 执行混合检索
print("\n执行混合检索（RRF 融合）...")
results = collection.hybrid_search(
    reqs=[text_req, image_req],
    rerank=RRFRanker(),  # 使用 RRF 融合
    limit=3,  # 最终返回 Top 3
    output_fields=["title", "content", "category"]
)

# 展示结果
print("\n混合检索结果（Top 3）：")
for i, hit in enumerate(results[0], 1):
    print(f"\n{i}. {hit.entity.get('title')}")
    print(f"   分类：{hit.entity.get('category')}")
    print(f"   内容：{hit.entity.get('content')[:80]}...")
    print(f"   文档ID：{hit.id}")

# ===== 5. 方法2：手动实现混合检索（兼容旧版本）=====
print("\n" + "="*60)
print("方法2：手动实现混合检索（兼容 Milvus < 2.4）")
print("="*60)

# 分别检索两个向量字段
print("\n步骤1：分别检索两个向量字段")

# 检索 text_vector
print("  - 检索 text_vector...")
text_results = collection.search(
    data=[text_embedding],
    anns_field="text_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=10,
    output_fields=["doc_id", "title", "content"]
)

print(f"    召回 {len(text_results[0])} 个候选")

# 检索 image_vector
print("  - 检索 image_vector...")
image_results = collection.search(
    data=[image_embedding],
    anns_field="image_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=10,
    output_fields=["doc_id", "title", "content"]
)

print(f"    召回 {len(image_results[0])} 个候选")

# 手动实现 RRF 融合
print("\n步骤2：手动实现 RRF 融合")

def rrf_fusion(results_list, k=60):
    """
    RRF 融合算法

    Args:
        results_list: 多个检索结果的列表
        k: 平滑参数（默认60）

    Returns:
        融合后的文档列表 [(doc_id, score), ...]
    """
    scores = {}

    # 遍历每个检索结果
    for results in results_list:
        # 遍历每个文档及其排名
        for rank, hit in enumerate(results[0]):
            doc_id = hit.id
            # RRF 公式：1 / (k + rank)
            rrf_score = 1.0 / (k + rank + 1)
            scores[doc_id] = scores.get(doc_id, 0) + rrf_score

    # 按分数降序排序
    sorted_docs = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    return sorted_docs

# 融合结果
fused_results = rrf_fusion([text_results, image_results], k=60)
print(f"  融合完成，共 {len(fused_results)} 个文档")

# 获取 Top 3 的完整信息
print("\n步骤3：获取 Top 3 的完整信息")
top3_ids = [doc_id for doc_id, score in fused_results[:3]]

final_docs = collection.query(
    expr=f"doc_id in {top3_ids}",
    output_fields=["doc_id", "title", "content", "category"]
)

# 按 RRF 分数排序
doc_dict = {doc["doc_id"]: doc for doc in final_docs}
sorted_final_docs = [doc_dict[doc_id] for doc_id, score in fused_results[:3]]

# 展示结果
print("\n手动融合结果（Top 3）：")
for i, doc in enumerate(sorted_final_docs, 1):
    rrf_score = fused_results[i-1][1]
    print(f"\n{i}. {doc['title']}")
    print(f"   分类：{doc['category']}")
    print(f"   内容：{doc['content'][:80]}...")
    print(f"   文档ID：{doc['doc_id']}")
    print(f"   RRF分数：{rrf_score:.4f}")

# ===== 6. 对比两种方法的结果 =====
print("\n" + "="*60)
print("对比两种方法")
print("="*60)

print("\nhybrid_search() 结果：")
for i, hit in enumerate(results[0], 1):
    print(f"  {i}. {hit.entity.get('title')} (ID: {hit.id})")

print("\n手动融合结果：")
for i, doc in enumerate(sorted_final_docs, 1):
    print(f"  {i}. {doc['title']} (ID: {doc['doc_id']})")

# ===== 7. 添加标量过滤 =====
print("\n" + "="*60)
print("添加标量过滤")
print("="*60)

print("\n场景：只检索「教程」分类的文档")

# 使用 hybrid_search + 标量过滤
filtered_results = collection.hybrid_search(
    reqs=[text_req, image_req],
    rerank=RRFRanker(),
    limit=3,
    expr='category == "教程"',  # 标量过滤
    output_fields=["title", "content", "category"]
)

print("\n过滤后的结果（Top 3）：")
for i, hit in enumerate(filtered_results[0], 1):
    print(f"\n{i}. {hit.entity.get('title')}")
    print(f"   分类：{hit.entity.get('category')}")
    print(f"   内容：{hit.entity.get('content')[:80]}...")

# ===== 8. 调整召回数量 =====
print("\n" + "="*60)
print("调整召回数量")
print("="*60)

print("\n场景1：少召回（快速，但可能不够准确）")

# 少召回：每个字段只召回5个
text_req_small = AnnSearchRequest(
    data=[text_embedding],
    anns_field="text_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=5  # 只召回5个
)

image_req_small = AnnSearchRequest(
    data=[image_embedding],
    anns_field="image_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=5  # 只召回5个
)

results_small = collection.hybrid_search(
    reqs=[text_req_small, image_req_small],
    rerank=RRFRanker(),
    limit=3,
    output_fields=["title"]
)

print("结果（少召回）：")
for i, hit in enumerate(results_small[0], 1):
    print(f"  {i}. {hit.entity.get('title')}")

print("\n场景2：多召回（慢一些，但更准确）")

# 多召回：每个字段召回20个
text_req_large = AnnSearchRequest(
    data=[text_embedding],
    anns_field="text_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=20  # 召回20个
)

image_req_large = AnnSearchRequest(
    data=[image_embedding],
    anns_field="image_vector",
    param={"metric_type": "COSINE", "params": {"ef": 100}},
    limit=20  # 召回20个
)

results_large = collection.hybrid_search(
    reqs=[text_req_large, image_req_large],
    rerank=RRFRanker(),
    limit=3,
    output_fields=["title"]
)

print("结果（多召回）：")
for i, hit in enumerate(results_large[0], 1):
    print(f"  {i}. {hit.entity.get('title')}")

# ===== 9. 性能测试 =====
print("\n" + "="*60)
print("性能测试")
print("="*60)

import time

def benchmark_hybrid_search(reqs, num_runs=10):
    """性能测试"""
    times = []
    for _ in range(num_runs):
        start = time.time()
        collection.hybrid_search(
            reqs=reqs,
            rerank=RRFRanker(),
            limit=3,
            output_fields=["title"]
        )
        end = time.time()
        times.append((end - start) * 1000)  # 转换为毫秒

    avg_time = sum(times) / len(times)
    min_time = min(times)
    max_time = max(times)

    return avg_time, min_time, max_time

print("\n测试1：少召回（limit=5）")
avg, min_t, max_t = benchmark_hybrid_search([text_req_small, image_req_small])
print(f"  平均延迟：{avg:.2f}ms")
print(f"  最小延迟：{min_t:.2f}ms")
print(f"  最大延迟：{max_t:.2f}ms")

print("\n测试2：中等召回（limit=10）")
avg, min_t, max_t = benchmark_hybrid_search([text_req, image_req])
print(f"  平均延迟：{avg:.2f}ms")
print(f"  最小延迟：{min_t:.2f}ms")
print(f"  最大延迟：{max_t:.2f}ms")

print("\n测试3：多召回（limit=20）")
avg, min_t, max_t = benchmark_hybrid_search([text_req_large, image_req_large])
print(f"  平均延迟：{avg:.2f}ms")
print(f"  最小延迟：{min_t:.2f}ms")
print(f"  最大延迟：{max_t:.2f}ms")

print("\n" + "="*60)
print("✅ 混合检索实现完成！")
print("="*60)
```

---

## 运行输出示例

```
=== 连接到 Milvus ===
✅ 连接成功

=== 加载 Collection ===
✅ Collection 'doc_qa_multi_vector' 已加载
   文档数量：3

============================================================
方法1：使用 hybrid_search()（推荐）
============================================================

查询：如何安装 Python？
生成查询向量...
定义检索请求...
  - text_vector 请求：COSINE, limit=10
  - image_vector 请求：COSINE, limit=10

执行混合检索（RRF 融合）...

混合检索结果（Top 3）：

1. Python 安装教程
   分类：教程
   内容：Python 是一种高级编程语言。安装步骤：1. 下载安装包 2. 运行安装程序 3. 配置环境变量...
   文档ID：449646258995855360

2. Java 入门指南
   分类：教程
   内容：Java 是一种面向对象的编程语言。特点：跨平台、强类型、自动内存管理...
   文档ID：449646258995855361

3. Docker 容器化部署
   分类：运维
   内容：Docker 是一个容器化平台。使用 Dockerfile 定义镜像，使用 docker-compose 编排服务...
   文档ID：449646258995855362

============================================================
方法2：手动实现混合检索（兼容 Milvus < 2.4）
============================================================

步骤1：分别检索两个向量字段
  - 检索 text_vector...
    召回 3 个候选
  - 检索 image_vector...
    召回 3 个候选

步骤2：手动实现 RRF 融合
  融合完成，共 3 个文档

步骤3：获取 Top 3 的完整信息

手动融合结果（Top 3）：

1. Python 安装教程
   分类：教程
   内容：Python 是一种高级编程语言。安装步骤：1. 下载安装包 2. 运行安装程序 3. 配置环境变量...
   文档ID：449646258995855360
   RRF分数：0.0328

2. Java 入门指南
   分类：教程
   内容：Java 是一种面向对象的编程语言。特点：跨平台、强类型、自动内存管理...
   文档ID：449646258995855361
   RRF分数：0.0311

3. Docker 容器化部署
   分类：运维
   内容：Docker 是一个容器化平台。使用 Dockerfile 定义镜像，使用 docker-compose 编排服务...
   文档ID：449646258995855362
   RRF分数：0.0295

============================================================
对比两种方法
============================================================

hybrid_search() 结果：
  1. Python 安装教程 (ID: 449646258995855360)
  2. Java 入门指南 (ID: 449646258995855361)
  3. Docker 容器化部署 (ID: 449646258995855362)

手动融合结果：
  1. Python 安装教程 (ID: 449646258995855360)
  2. Java 入门指南 (ID: 449646258995855361)
  3. Docker 容器化部署 (ID: 449646258995855362)

============================================================
添加标量过滤
============================================================

场景：只检索「教程」分类的文档

过滤后的结果（Top 3）：

1. Python 安装教程
   分类：教程
   内容：Python 是一种高级编程语言。安装步骤：1. 下载安装包 2. 运行安装程序 3. 配置环境变量...

2. Java 入门指南
   分类：教程
   内容：Java 是一种面向对象的编程语言。特点：跨平台、强类型、自动内存管理...

============================================================
调整召回数量
============================================================

场景1：少召回（快速，但可能不够准确）
结果（少召回）：
  1. Python 安装教程
  2. Java 入门指南
  3. Docker 容器化部署

场景2：多召回（慢一些，但更准确）
结果（多召回）：
  1. Python 安装教程
  2. Java 入门指南
  3. Docker 容器化部署

============================================================
性能测试
============================================================

测试1：少召回（limit=5）
  平均延迟：25.34ms
  最小延迟：22.15ms
  最大延迟：31.28ms

测试2：中等召回（limit=10）
  平均延迟：32.67ms
  最小延迟：28.92ms
  最大延迟：38.45ms

测试3：多召回（limit=20）
  平均延迟：45.89ms
  最小延迟：41.23ms
  最大延迟：52.67ms

============================================================
✅ 混合检索实现完成！
============================================================
```

---

## 代码详解

### 1. hybrid_search() 的关键参数

```python
results = collection.hybrid_search(
    reqs=[req1, req2],      # 多个检索请求
    rerank=RRFRanker(),     # 融合算法
    limit=3,                # 最终返回数量
    expr='category == "教程"',  # 标量过滤（可选）
    output_fields=["title", "content"]  # 返回字段
)
```

### 2. AnnSearchRequest 的配置

```python
req = AnnSearchRequest(
    data=[embedding],           # 查询向量（列表）
    anns_field="text_vector",   # 检索字段名
    param={
        "metric_type": "COSINE",  # 度量方式
        "params": {"ef": 100}     # 索引参数
    },
    limit=10                    # 召回数量
)
```

### 3. RRF 融合算法的实现

```python
def rrf_fusion(results_list, k=60):
    scores = {}
    for results in results_list:
        for rank, hit in enumerate(results[0]):
            doc_id = hit.id
            # RRF 公式
            rrf_score = 1.0 / (k + rank + 1)
            scores[doc_id] = scores.get(doc_id, 0) + rrf_score

    return sorted(scores.items(), key=lambda x: x[1], reverse=True)
```

### 4. 标量过滤的语法

```python
# 单个条件
expr='category == "教程"'

# 多个条件（AND）
expr='category == "教程" and price < 100'

# 多个条件（OR）
expr='category == "教程" or category == "运维"'

# IN 操作
expr='category in ["教程", "运维"]'

# 范围查询
expr='price >= 50 and price <= 200'
```

---

## 性能优化技巧

### 1. 调整召回数量

```python
# 场景1：实时搜索（低延迟）
limit=5-10

# 场景2：通用场景（平衡）
limit=10-20

# 场景3：离线分析（高准确率）
limit=20-50
```

### 2. 使用标量过滤预先缩小范围

```python
# ✅ 推荐：先过滤再检索
results = collection.hybrid_search(
    reqs=[req1, req2],
    rerank=RRFRanker(),
    limit=10,
    expr="category == '教程'"  # 先过滤
)

# ❌ 不推荐：检索后再过滤
results = collection.hybrid_search(
    reqs=[req1, req2],
    rerank=RRFRanker(),
    limit=100  # 召回很多
)
# 手动过滤
filtered = [hit for hit in results[0] if hit.entity.get("category") == "教程"]
```

### 3. 缓存查询向量

```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def get_cached_embedding(text):
    """缓存查询向量"""
    return get_text_embedding(text)

# 使用
embedding = get_cached_embedding("如何安装 Python？")
```

---

## 常见问题

### Q1：hybrid_search() 和分别 search() 有什么区别？

**答：** hybrid_search() 是原子操作，性能更好

```python
# hybrid_search()：一次调用，内部并行
results = collection.hybrid_search(reqs=[req1, req2], ...)

# 分别 search()：两次调用，需要手动融合
results1 = collection.search(...)
results2 = collection.search(...)
fused = rrf_fusion([results1, results2])
```

### Q2：如何调试混合检索？

**答：** 分别查看每个字段的检索结果

```python
# 1. 分别检索
text_results = collection.search(data=[text_embedding], anns_field="text_vector", limit=10)
image_results = collection.search(data=[image_embedding], anns_field="image_vector", limit=10)

# 2. 查看各自的 Top 10
print("text_vector Top 10:")
for hit in text_results[0]:
    print(f"  ID: {hit.id}, Score: {hit.distance}")

print("\nimage_vector Top 10:")
for hit in image_results[0]:
    print(f"  ID: {hit.id}, Score: {hit.distance}")

# 3. 手动融合并对比
manual_fusion = rrf_fusion([text_results, image_results])
print("\n手动融合 Top 5:")
for doc_id, score in manual_fusion[:5]:
    print(f"  ID: {doc_id}, RRF Score: {score}")
```

### Q3：如何选择召回数量？

**答：** 根据场景和性能要求

| 场景 | 召回数量 | 延迟 | 准确率 |
|------|---------|------|--------|
| 实时搜索 | 5-10 | ~25ms | 中 |
| 通用场景 | 10-20 | ~35ms | 高 |
| 离线分析 | 20-50 | ~50ms | 很高 |

---

## 总结

**混合检索的关键步骤：**

1. **定义检索请求**：为每个向量字段创建 `AnnSearchRequest`
2. **执行混合检索**：使用 `hybrid_search()` 或手动实现
3. **融合结果**：使用 RRF 或其他融合算法
4. **添加过滤**：使用标量过滤缩小范围
5. **性能优化**：调整召回数量、缓存向量

**两种实现方式：**
- **hybrid_search()**：Milvus 2.4+，推荐使用
- **手动实现**：兼容旧版本，更灵活

---

**继续学习：** [11_实战代码_场景3_加权融合策略.md](./11_实战代码_场景3_加权融合策略.md)
