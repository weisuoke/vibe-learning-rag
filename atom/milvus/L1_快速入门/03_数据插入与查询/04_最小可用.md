# 最小可用知识

> **20% 核心知识解决 80% 问题**：掌握这些核心概念，你就能完成大部分数据插入与查询任务。

---

## 核心知识地图

### 1. Embedding Functions（自动向量化）

**核心价值：** 无需手动调用 Embedding API，Milvus 自动完成向量化。

**最小可用配置：**

```python
from pymilvus import MilvusClient, DataType, Function, FunctionType

# 1. 创建 Schema
schema = client.create_schema()
schema.add_field("id", DataType.INT64, is_primary=True, auto_id=False)
schema.add_field("document", DataType.VARCHAR, max_length=9000)
schema.add_field("dense", DataType.FLOAT_VECTOR, dim=1536)

# 2. 配置 Embedding Function
text_embedding_function = Function(
    name="openai_embedding",
    function_type=FunctionType.TEXTEMBEDDING,
    input_field_names=["document"],
    output_field_names=["dense"],
    params={"provider": "openai", "model_name": "text-embedding-3-small"}
)
schema.add_function(text_embedding_function)
```

**记住：** 配置一次，终身受益。

---

### 2. 数据插入（Insert）

**核心价值：** 直接插入原始文本，Milvus 自动向量化。

**最小可用代码：**

```python
# 插入数据（无需手动向量化）
data = [
    {'id': 1, 'document': 'Artificial Intelligence is transforming industries.'},
    {'id': 2, 'document': 'Machine Learning enables computers to learn from data.'},
]

result = client.insert(collection_name='my_collection', data=data)
print(f"✅ 插入成功：{result['insert_count']} 条数据")
```

**记住：** 插入原始文本，Milvus 自动完成向量化和索引。

---

### 3. 数据更新（Upsert）

**核心价值：** 自动处理插入/更新逻辑，无需手动判断。

**最小可用代码：**

```python
# Upsert 数据（如果存在则更新，否则插入）
data = [
    {'id': 1, 'document': 'Updated content for AI document.'}
]

result = client.upsert(collection_name='my_collection', data=data)
print(f"✅ Upsert 成功：{result['upsert_count']} 条数据")
```

**记住：** Upsert = Update + Insert，自动处理重复数据。

---

### 4. 批量插入（Bulk Insert）

**核心价值：** 高效插入大量数据，适合初始化知识库。

**最小可用代码：**

```python
# 批量插入
batch_size = 1000
for i in range(0, len(documents), batch_size):
    batch = documents[i:i + batch_size]
    result = client.insert(collection_name='my_collection', data=batch)
    print(f"✅ 已插入：{result['insert_count']} 条数据")
```

**记住：** 批量插入 = 单条插入 × N，但效率更高。

---

### 5. 相似度检索（Search）

**核心价值：** 直接使用原始文本查询，Milvus 自动向量化并检索。

**最小可用代码：**

```python
# 相似度检索（无需手动向量化查询）
results = client.search(
    collection_name='my_collection',
    data=['What is AI?'],  # 原始文本查询
    anns_field='dense',
    limit=5,
    output_fields=['document']
)

for result in results[0]:
    print(f"Score: {result['distance']:.4f}, Content: {result['entity']['document']}")
```

**记住：** 查询原始文本，Milvus 自动完成向量化和检索。

---

### 6. 混合检索（Hybrid Search）

**核心价值：** 结合语义检索（Dense）和关键词检索（BM25），提高准确性。

**最小可用代码：**

```python
from pymilvus import AnnSearchRequest, RRFRanker

# 1. 配置 BM25 Function（在 Schema 中）
bm25_function = Function(
    name="bm25",
    function_type=FunctionType.BM25,
    input_field_names=["document"],
    output_field_names="sparse_vector"
)
schema.add_function(bm25_function)

# 2. 混合检索
query = "What is hybrid search?"

# Dense 检索请求
dense_request = AnnSearchRequest(
    [query], "dense", {"metric_type": "COSINE"}, limit=5
)

# Sparse 检索请求（BM25）
sparse_request = AnnSearchRequest(
    [query], "sparse_vector", {"metric_type": "BM25"}, limit=5
)

# 执行混合检索
results = client.hybrid_search(
    collection_name='my_collection',
    [dense_request, sparse_request],
    ranker=RRFRanker(),  # 使用 RRF 融合结果
    limit=5,
    output_fields=['document']
)
```

**记住：** 混合检索 = Dense（语义）+ Sparse（关键词）+ Reranking。

---

## 核心配置清单

### 1. milvus.yaml 配置

```yaml
credential:
  apikey_openai:
    apikey: "sk-your-openai-api-key"

function:
  textEmbedding:
    providers:
      openai:
        credential: apikey_openai
```

### 2. Schema 配置

```python
# 必需字段
schema.add_field("id", DataType.INT64, is_primary=True, auto_id=False)
schema.add_field("document", DataType.VARCHAR, max_length=9000)
schema.add_field("dense", DataType.FLOAT_VECTOR, dim=1536)

# Embedding Function
text_embedding_function = Function(
    name="openai_embedding",
    function_type=FunctionType.TEXTEMBEDDING,
    input_field_names=["document"],
    output_field_names=["dense"],
    params={"provider": "openai", "model_name": "text-embedding-3-small"}
)
schema.add_function(text_embedding_function)
```

### 3. 索引配置

```python
index_params = client.prepare_index_params()
index_params.add_index(
    field_name="dense",
    index_type="AUTOINDEX",
    metric_type="COSINE"
)
```

---

## 常见场景速查

### 场景 1：初始化知识库

```python
# 1. 创建 Collection（配置 Embedding Function）
# 2. 批量插入数据
for i in range(0, len(documents), 1000):
    batch = documents[i:i + 1000]
    client.insert(collection_name='my_collection', data=batch)
```

### 场景 2：实时添加文档

```python
# 直接插入单条或小批量数据
data = [{'id': 100, 'document': 'New document content'}]
client.insert(collection_name='my_collection', data=data)
```

### 场景 3：更新文档

```python
# 使用 Upsert 自动处理插入/更新
data = [{'id': 100, 'document': 'Updated document content'}]
client.upsert(collection_name='my_collection', data=data)
```

### 场景 4：语义检索

```python
# 直接使用原始文本查询
results = client.search(
    collection_name='my_collection',
    data=['Your query text'],
    anns_field='dense',
    limit=5
)
```

### 场景 5：混合检索（推荐）

```python
# 结合 Dense 和 Sparse 检索
results = client.hybrid_search(
    collection_name='my_collection',
    [dense_request, sparse_request],
    ranker=RRFRanker(),
    limit=5
)
```

---

## 核心原则

### 1. 简化原则

- **使用 Embedding Functions**：无需手动向量化
- **使用 Upsert**：自动处理插入/更新逻辑
- **使用 AUTOINDEX**：自动选择最优索引

### 2. 效率原则

- **批量插入**：使用 Bulk Insert 处理大量数据
- **并行处理**：使用多线程提高吞吐量
- **混合检索**：结合 Dense 和 Sparse 提高准确性

### 3. 可靠性原则

- **错误处理**：使用 try-except 捕获异常
- **重试机制**：失败时自动重试
- **日志记录**：记录关键操作

---

## 快速上手步骤

### 步骤 1：配置 Milvus（5 分钟）

1. 修改 `milvus.yaml`，添加 API Key
2. 重启 Milvus

### 步骤 2：创建 Collection（5 分钟）

1. 定义 Schema（id + document + dense）
2. 配置 Embedding Function
3. 配置索引
4. 创建 Collection

### 步骤 3：插入数据（5 分钟）

1. 准备数据（原始文本）
2. 批量插入

### 步骤 4：查询数据（5 分钟）

1. 使用原始文本查询
2. 查看结果

**总计：** 20 分钟完成从零到可用。

---

## 记住这些就够了

1. **Embedding Functions**：自动向量化，无需手动调用 API
2. **Insert**：插入新数据
3. **Upsert**：插入或更新数据
4. **Bulk Insert**：批量插入大量数据
5. **Search**：相似度检索
6. **Hybrid Search**：混合检索（推荐）

**核心公式：**

```
Milvus 2.6 = Embedding Functions + Insert/Upsert + Search/Hybrid Search
```

**一句话总结：** 配置 Embedding Functions，插入原始文本，查询原始文本，Milvus 自动完成向量化和检索。
