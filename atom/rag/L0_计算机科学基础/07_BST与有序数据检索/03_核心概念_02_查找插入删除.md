# 03_核心概念_02_查找插入删除

## 概念定义

BST的三个核心操作：**查找（Search）**、**插入（Insert）**、**删除（Delete）**，都利用BST的有序性质实现O(log n)的时间复杂度（平衡时）。

---

## 操作1：查找（Search）

### 算法原理

**核心思想：** 利用BST的二分性质，每次比较排除一半搜索空间

```
查找target：
1. 如果当前节点为空，返回未找到
2. 如果target == 当前节点值，找到
3. 如果target < 当前节点值，在左子树查找
4. 如果target > 当前节点值，在右子树查找
```

### 代码实现

**递归版本：**
```python
def search(root, target):
    """递归查找"""
    # 基础情况
    if not root or root.val == target:
        return root

    # 递归情况
    if target < root.val:
        return search(root.left, target)
    else:
        return search(root.right, target)
```

**迭代版本：**
```python
def search_iterative(root, target):
    """迭代查找"""
    current = root
    while current:
        if target == current.val:
            return current
        elif target < current.val:
            current = current.left
        else:
            current = current.right
    return None
```

### 时间复杂度分析

| 情况 | 时间复杂度 | 说明 |
|------|-----------|------|
| 最好情况 | O(1) | 根节点就是目标 |
| 平均情况 | O(log n) | 平衡树 |
| 最坏情况 | O(n) | 退化为链表 |

**空间复杂度：**
- 递归：O(h)，h是树高（递归栈）
- 迭代：O(1)

### 示例

```
查找60：
        50
       /  \
      30   70
     / \   / \
   20  40 60 80

步骤：
1. 60 > 50，往右 → 70
2. 60 < 70，往左 → 60
3. 找到！

比较次数：3次
```

---

## 操作2：插入（Insert）

### 算法原理

**核心思想：** 找到正确位置后插入，BST性质自动保持

```
插入val：
1. 如果当前节点为空，创建新节点
2. 如果val < 当前节点值，在左子树插入
3. 如果val > 当前节点值，在右子树插入
4. 如果val == 当前节点值，根据策略处理（不插入/计数/放右边）
```

### 代码实现

**递归版本：**
```python
def insert(root, val):
    """递归插入"""
    # 基础情况：找到插入位置
    if not root:
        return TreeNode(val)

    # 递归情况
    if val < root.val:
        root.left = insert(root.left, val)
    elif val > root.val:
        root.right = insert(root.right, val)
    # else: val == root.val，不插入重复值

    return root
```

**迭代版本：**
```python
def insert_iterative(root, val):
    """迭代插入"""
    new_node = TreeNode(val)

    # 空树情况
    if not root:
        return new_node

    # 找到插入位置
    current = root
    while True:
        if val < current.val:
            if not current.left:
                current.left = new_node
                break
            current = current.left
        elif val > current.val:
            if not current.right:
                current.right = new_node
                break
            current = current.right
        else:
            # 重复值，不插入
            break

    return root
```

### 时间复杂度分析

| 情况 | 时间复杂度 | 说明 |
|------|-----------|------|
| 最好情况 | O(1) | 根节点为空 |
| 平均情况 | O(log n) | 平衡树 |
| 最坏情况 | O(n) | 退化为链表 |

**空间复杂度：**
- 递归：O(h)
- 迭代：O(1)

### 示例

```
插入45：
        50
       /  \
      30   70
     / \   / \
   20  40 60 80

步骤：
1. 45 < 50，往左 → 30
2. 45 > 30，往右 → 40
3. 45 > 40，40的右子树为空
4. 插入45作为40的右子节点

结果：
        50
       /  \
      30   70
     / \   / \
   20  40 60 80
        \
        45
```

---

## 操作3：删除（Delete）

### 算法原理

**核心思想：** 根据节点的子节点数量分三种情况处理

### 情况1：叶子节点（无子节点）

**处理：** 直接删除

```python
if not node.left and not node.right:
    return None
```

**示例：**
```
删除20：
        50                50
       /  \              /  \
      30   70    →     30   70
     / \   / \          \   / \
   20  40 60 80         40 60 80
```

### 情况2：单子节点

**处理：** 用子节点替换当前节点

```python
if not node.left:
    return node.right
if not node.right:
    return node.left
```

**示例：**
```
删除30（只有右子节点40）：
        50                50
       /  \              /  \
      30   70    →     40   70
       \   / \             / \
       40 60 80           60 80
```

### 情况3：双子节点

**处理：** 用后继节点（右子树最小值）或前驱节点（左子树最大值）替换

**为什么用后继节点？**
- 后继节点是右子树的最小值
- 大于左子树所有节点
- 小于右子树其他节点
- 保持BST性质

```python
# 找到右子树的最小值（后继节点）
successor = find_min(node.right)
# 用后继节点的值替换当前节点
node.val = successor.val
# 删除后继节点
node.right = delete(node.right, successor.val)
```

**示例：**
```
删除50（有两个子节点）：
        50                60
       /  \              /  \
      30   70    →     30   70
     / \   / \        / \     \
   20  40 60 80     20  40    80

步骤：
1. 找到右子树最小值：60
2. 用60替换50
3. 删除原来的60节点
```

### 完整代码实现

```python
def delete(root, val):
    """删除节点"""
    if not root:
        return None

    # 查找要删除的节点
    if val < root.val:
        root.left = delete(root.left, val)
    elif val > root.val:
        root.right = delete(root.right, val)
    else:
        # 找到要删除的节点

        # 情况1：叶子节点或单子节点
        if not root.left:
            return root.right
        if not root.right:
            return root.left

        # 情况2：双子节点
        # 找到后继节点（右子树最小值）
        successor = find_min(root.right)
        # 用后继节点的值替换当前节点
        root.val = successor.val
        # 删除后继节点
        root.right = delete(root.right, successor.val)

    return root

def find_min(root):
    """找到最小值节点"""
    while root.left:
        root = root.left
    return root
```

### 时间复杂度分析

| 情况 | 时间复杂度 | 说明 |
|------|-----------|------|
| 最好情况 | O(1) | 删除根节点且为叶子 |
| 平均情况 | O(log n) | 平衡树 |
| 最坏情况 | O(n) | 退化为链表 |

---

## 三个操作的对比

| 操作 | 时间复杂度 | 空间复杂度 | 难度 |
|------|-----------|-----------|------|
| 查找 | O(log n) | O(1)迭代 | ⭐ |
| 插入 | O(log n) | O(1)迭代 | ⭐⭐ |
| 删除 | O(log n) | O(1)迭代 | ⭐⭐⭐ |

**难度说明：**
- 查找：最简单，只需比较和移动
- 插入：需要找到正确位置
- 删除：需要处理三种情况，尤其是双子节点

---

## 完整BST类实现

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


class BST:
    def __init__(self):
        self.root = None

    def search(self, val):
        """查找值"""
        return self._search(self.root, val)

    def _search(self, root, val):
        if not root or root.val == val:
            return root
        if val < root.val:
            return self._search(root.left, val)
        return self._search(root.right, val)

    def insert(self, val):
        """插入值"""
        self.root = self._insert(self.root, val)

    def _insert(self, root, val):
        if not root:
            return TreeNode(val)
        if val < root.val:
            root.left = self._insert(root.left, val)
        elif val > root.val:
            root.right = self._insert(root.right, val)
        return root

    def delete(self, val):
        """删除值"""
        self.root = self._delete(self.root, val)

    def _delete(self, root, val):
        if not root:
            return None
        if val < root.val:
            root.left = self._delete(root.left, val)
        elif val > root.val:
            root.right = self._delete(root.right, val)
        else:
            if not root.left:
                return root.right
            if not root.right:
                return root.left
            successor = self._find_min(root.right)
            root.val = successor.val
            root.right = self._delete(root.right, successor.val)
        return root

    def _find_min(self, root):
        while root.left:
            root = root.left
        return root

    def inorder(self):
        """中序遍历"""
        result = []
        self._inorder(self.root, result)
        return result

    def _inorder(self, root, result):
        if root:
            self._inorder(root.left, result)
            result.append(root.val)
            self._inorder(root.right, result)


# 使用示例
bst = BST()

# 插入
for val in [50, 30, 70, 20, 40, 60, 80]:
    bst.insert(val)

print("初始树:", bst.inorder())  # [20, 30, 40, 50, 60, 70, 80]

# 查找
node = bst.search(40)
print("查找40:", node.val if node else "未找到")  # 40

# 删除
bst.delete(30)
print("删除30后:", bst.inorder())  # [20, 40, 50, 60, 70, 80]

bst.delete(50)
print("删除50后:", bst.inorder())  # [20, 40, 60, 70, 80]
```

---

## 在AI Agent中的应用

### 应用1：对话历史管理

```python
class ConversationHistory:
    def __init__(self):
        self.bst = BST()

    def add_message(self, timestamp, message):
        """添加消息"""
        node = TreeNode(timestamp)
        node.message = message
        self.bst.root = self.bst._insert(self.bst.root, node)

    def search_message(self, timestamp):
        """查找特定时间的消息"""
        node = self.bst.search(timestamp)
        return node.message if node else None

    def delete_old_messages(self, before_timestamp):
        """删除指定时间之前的消息"""
        # 中序遍历找到所有旧消息
        old_timestamps = []
        def collect_old(node):
            if not node:
                return
            collect_old(node.left)
            if node.val < before_timestamp:
                old_timestamps.append(node.val)
            collect_old(node.right)

        collect_old(self.bst.root)

        # 删除旧消息
        for ts in old_timestamps:
            self.bst.delete(ts)
```

### 应用2：任务优先级队列

```python
class PriorityTaskQueue:
    def __init__(self):
        self.bst = BST()

    def add_task(self, priority, task):
        """添加任务"""
        node = TreeNode(priority)
        node.task = task
        self.bst.root = self.bst._insert(self.bst.root, node)

    def get_highest_priority_task(self):
        """获取最高优先级任务"""
        if not self.bst.root:
            return None
        # 最大值节点
        max_node = self.bst.root
        while max_node.right:
            max_node = max_node.right
        task = max_node.task
        # 删除该任务
        self.bst.delete(max_node.val)
        return task
```

---

## 常见错误

### 错误1：删除双子节点时丢失子树

```python
# ❌ 错误：直接用右子树替换
def delete_wrong(root, val):
    if root.val == val:
        return root.right  # 丢失了左子树！

# ✅ 正确：用后继节点替换
def delete_correct(root, val):
    if root.val == val:
        if not root.left or not root.right:
            return root.left or root.right
        successor = find_min(root.right)
        root.val = successor.val
        root.right = delete(root.right, successor.val)
    return root
```

### 错误2：插入时没有返回新根

```python
# ❌ 错误：没有返回
def insert_wrong(root, val):
    if not root:
        root = TreeNode(val)  # 局部变量，不会影响外部
    # ...

# ✅ 正确：返回新根
def insert_correct(root, val):
    if not root:
        return TreeNode(val)
    # ...
    return root
```

### 错误3：查找时没有处理空节点

```python
# ❌ 错误：可能访问None.val
def search_wrong(root, val):
    if root.val == val:  # root可能是None！
        return root
    # ...

# ✅ 正确：先检查空节点
def search_correct(root, val):
    if not root or root.val == val:
        return root
    # ...
```

---

## 性能优化技巧

### 技巧1：迭代代替递归

**优势：** 避免递归栈开销，空间复杂度O(1)

```python
# 递归：O(h)空间
def search_recursive(root, val):
    if not root or root.val == val:
        return root
    if val < root.val:
        return search_recursive(root.left, val)
    return search_recursive(root.right, val)

# 迭代：O(1)空间
def search_iterative(root, val):
    while root:
        if root.val == val:
            return root
        root = root.left if val < root.val else root.right
    return None
```

### 技巧2：批量操作优化

**场景：** 需要插入大量数据

```python
# ❌ 低效：逐个插入
bst = BST()
for val in data:
    bst.insert(val)  # 每次O(log n)

# ✅ 高效：先排序再构建平衡树
def build_balanced_bst(sorted_data):
    """从有序数组构建平衡BST"""
    def build(left, right):
        if left > right:
            return None
        mid = (left + right) // 2
        root = TreeNode(sorted_data[mid])
        root.left = build(left, mid - 1)
        root.right = build(mid + 1, right)
        return root

    return build(0, len(sorted_data) - 1)

# 先排序
sorted_data = sorted(data)  # O(n log n)
# 构建平衡树
bst.root = build_balanced_bst(sorted_data)  # O(n)
```

---

## 学习检查清单

- [ ] 能手写查找、插入、删除的递归和迭代版本
- [ ] 理解删除操作的三种情况
- [ ] 知道为什么删除双子节点要用后继节点
- [ ] 能分析三个操作的时间和空间复杂度
- [ ] 知道常见错误和如何避免
- [ ] 能应用到实际场景（对话历史、任务队列）

---

**记住：** 查找、插入、删除是BST的核心操作，理解它们的原理和实现是掌握BST的关键。
