# 最小可用 - 20%核心知识

## 核心理念

**20%的测试知识解决80%的实际问题**

作为初学者，你不需要掌握所有测试技巧，只需要掌握这些核心概念：

1. **pytest 基础**：如何写测试、运行测试
2. **fixture 机制**：如何准备测试数据
3. **FastAPI TestClient**：如何测试 API 端点
4. **Mock 技巧**：如何隔离外部依赖

掌握这4个核心，你就能写出80%的测试场景。

---

## 30分钟快速上手

### 第1步：安装 pytest（2分钟）

```bash
# 安装 pytest 和相关工具
uv add pytest pytest-asyncio httpx

# 验证安装
pytest --version
```

### 第2步：写第一个测试（5分钟）

**创建文件：`tests/test_basic.py`**

```python
# tests/test_basic.py

def add(a: int, b: int) -> int:
    """简单的加法函数"""
    return a + b


def test_add_positive_numbers():
    """测试：两个正数相加"""
    result = add(2, 3)
    assert result == 5


def test_add_negative_numbers():
    """测试：两个负数相加"""
    result = add(-2, -3)
    assert result == -5


def test_add_zero():
    """测试：加零"""
    result = add(5, 0)
    assert result == 5
```

**运行测试：**

```bash
pytest tests/test_basic.py -v
```

**输出：**

```
tests/test_basic.py::test_add_positive_numbers PASSED
tests/test_basic.py::test_add_negative_numbers PASSED
tests/test_basic.py::test_add_zero PASSED

======================== 3 passed in 0.02s ========================
```

**关键点**：
- 测试文件以 `test_` 开头
- 测试函数以 `test_` 开头
- 使用 `assert` 断言结果
- pytest 自动发现和运行测试

### 第3步：使用 fixture 准备数据（8分钟）

**问题**：如果多个测试需要相同的数据怎么办？

**解决方案**：使用 fixture

```python
# tests/test_user.py
import pytest


class User:
    def __init__(self, username: str, email: str):
        self.username = username
        self.email = email

    def get_display_name(self) -> str:
        return f"{self.username} <{self.email}>"


@pytest.fixture
def sample_user():
    """创建一个测试用户"""
    return User(username="alice", email="alice@example.com")


def test_user_display_name(sample_user):
    """测试：用户显示名称"""
    display_name = sample_user.get_display_name()
    assert display_name == "alice <alice@example.com>"


def test_user_username(sample_user):
    """测试：用户名"""
    assert sample_user.username == "alice"


def test_user_email(sample_user):
    """测试：邮箱"""
    assert sample_user.email == "alice@example.com"
```

**运行测试：**

```bash
pytest tests/test_user.py -v
```

**关键点**：
- `@pytest.fixture` 装饰器定义 fixture
- 测试函数通过参数名引用 fixture
- 每个测试都会获得一个新的 fixture 实例（隔离性）

### 第4步：测试 FastAPI 端点（10分钟）

**创建一个简单的 FastAPI 应用：**

```python
# app/main.py
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    price: float


@app.get("/")
def read_root():
    return {"message": "Hello World"}


@app.get("/items/{item_id}")
def read_item(item_id: int):
    return {"item_id": item_id, "name": f"Item {item_id}"}


@app.post("/items")
def create_item(item: Item):
    return {"name": item.name, "price": item.price, "created": True}
```

**测试 FastAPI 端点：**

```python
# tests/test_api.py
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)


def test_read_root():
    """测试：根路径"""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}


def test_read_item():
    """测试：获取单个商品"""
    response = client.get("/items/42")
    assert response.status_code == 200
    assert response.json() == {"item_id": 42, "name": "Item 42"}


def test_create_item():
    """测试：创建商品"""
    response = client.post("/items", json={
        "name": "iPhone",
        "price": 999.99
    })
    assert response.status_code == 200
    data = response.json()
    assert data["name"] == "iPhone"
    assert data["price"] == 999.99
    assert data["created"] is True


def test_create_item_invalid_data():
    """测试：创建商品（无效数据）"""
    response = client.post("/items", json={
        "name": "iPhone"
        # 缺少 price 字段
    })
    assert response.status_code == 422  # Validation Error
```

**运行测试：**

```bash
pytest tests/test_api.py -v
```

**关键点**：
- `TestClient` 模拟 HTTP 请求
- 不需要启动真实的服务器
- 可以测试各种 HTTP 方法（GET、POST、PUT、DELETE）
- 可以测试请求验证和错误处理

### 第5步：Mock 外部依赖（5分钟）

**问题**：如果函数调用外部 API 怎么办？

**示例：调用 OpenAI API**

```python
# app/llm.py
import openai


def get_completion(prompt: str) -> str:
    """调用 OpenAI API 获取回复"""
    response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )
    return response.choices[0].message.content
```

**测试时 Mock API 调用：**

```python
# tests/test_llm.py
from unittest.mock import Mock, patch
from app.llm import get_completion


def test_get_completion():
    """测试：获取 LLM 回复（Mock）"""
    # Mock OpenAI API 响应
    mock_response = Mock()
    mock_response.choices = [Mock()]
    mock_response.choices[0].message.content = "这是一个测试回复"

    with patch("openai.chat.completions.create") as mock_create:
        mock_create.return_value = mock_response

        # 调用函数
        result = get_completion("你好")

        # 验证结果
        assert result == "这是一个测试回复"

        # 验证 API 被正确调用
        mock_create.assert_called_once_with(
            model="gpt-4",
            messages=[{"role": "user", "content": "你好"}]
        )
```

**关键点**：
- `unittest.mock.patch` 替换真实的函数
- `Mock()` 创建模拟对象
- `assert_called_once_with()` 验证调用参数
- 测试不会真正调用 OpenAI API（快速、免费、可重复）

---

## 核心概念速查表

### 1. pytest 基础

| 概念 | 说明 | 示例 |
|------|------|------|
| 测试文件 | 以 `test_` 开头或 `_test.py` 结尾 | `test_user.py` |
| 测试函数 | 以 `test_` 开头 | `def test_add():` |
| 断言 | 使用 `assert` 验证结果 | `assert result == 5` |
| 运行测试 | `pytest` 或 `pytest <file>` | `pytest tests/` |
| 详细输出 | `pytest -v` | 显示每个测试的名称 |
| 失败时停止 | `pytest -x` | 遇到第一个失败就停止 |

### 2. fixture 机制

| 概念 | 说明 | 示例 |
|------|------|------|
| 定义 fixture | `@pytest.fixture` | `@pytest.fixture def user():` |
| 使用 fixture | 作为测试函数参数 | `def test_user(user):` |
| fixture 作用域 | `scope="function"` (默认) | 每个测试一个新实例 |
| fixture 作用域 | `scope="module"` | 整个模块共享一个实例 |
| fixture 作用域 | `scope="session"` | 整个测试会话共享 |
| fixture 清理 | `yield` 语法 | `yield user; cleanup()` |

### 3. FastAPI TestClient

| 概念 | 说明 | 示例 |
|------|------|------|
| 创建客户端 | `TestClient(app)` | `client = TestClient(app)` |
| GET 请求 | `client.get(url)` | `client.get("/items/1")` |
| POST 请求 | `client.post(url, json=data)` | `client.post("/items", json={...})` |
| 添加 Header | `headers={}` | `headers={"Authorization": "Bearer ..."}` |
| 检查状态码 | `response.status_code` | `assert response.status_code == 200` |
| 获取 JSON | `response.json()` | `data = response.json()` |

### 4. Mock 技巧

| 概念 | 说明 | 示例 |
|------|------|------|
| Mock 对象 | `Mock()` | `mock_obj = Mock()` |
| Mock 返回值 | `return_value` | `mock_func.return_value = 42` |
| Mock 函数 | `patch()` | `with patch("module.func"):` |
| 验证调用 | `assert_called_once()` | `mock_func.assert_called_once()` |
| 验证参数 | `assert_called_with()` | `mock_func.assert_called_with(1, 2)` |
| Mock 属性 | 直接赋值 | `mock_obj.name = "test"` |

---

## 常见测试场景

### 场景1：测试数据验证（Pydantic）

```python
from pydantic import BaseModel, ValidationError
import pytest


class User(BaseModel):
    username: str
    email: str
    age: int


def test_user_valid_data():
    """测试：有效数据"""
    user = User(username="alice", email="alice@example.com", age=25)
    assert user.username == "alice"


def test_user_invalid_email():
    """测试：无效邮箱"""
    with pytest.raises(ValidationError):
        User(username="alice", email="invalid", age=25)


def test_user_negative_age():
    """测试：负数年龄"""
    with pytest.raises(ValidationError):
        User(username="alice", email="alice@example.com", age=-1)
```

### 场景2：测试异步函数

```python
import pytest


async def fetch_data(url: str) -> dict:
    """模拟异步获取数据"""
    await asyncio.sleep(0.1)
    return {"url": url, "data": "test"}


@pytest.mark.asyncio
async def test_fetch_data():
    """测试：异步获取数据"""
    result = await fetch_data("https://example.com")
    assert result["url"] == "https://example.com"
    assert result["data"] == "test"
```

### 场景3：测试异常处理

```python
def divide(a: int, b: int) -> float:
    """除法函数"""
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b


def test_divide_normal():
    """测试：正常除法"""
    result = divide(10, 2)
    assert result == 5.0


def test_divide_by_zero():
    """测试：除以零"""
    with pytest.raises(ValueError, match="除数不能为零"):
        divide(10, 0)
```

### 场景4：参数化测试

```python
import pytest


@pytest.mark.parametrize("a,b,expected", [
    (2, 3, 5),
    (0, 0, 0),
    (-1, 1, 0),
    (100, 200, 300),
])
def test_add_parametrized(a, b, expected):
    """测试：参数化加法"""
    result = a + b
    assert result == expected
```

**运行结果：**

```
test_add_parametrized[2-3-5] PASSED
test_add_parametrized[0-0-0] PASSED
test_add_parametrized[-1-1-0] PASSED
test_add_parametrized[100-200-300] PASSED
```

---

## AI Agent 测试快速入门

### 测试 RAG 检索

```python
# tests/test_rag.py
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings


def test_vector_search():
    """测试：向量检索"""
    # 准备测试数据
    documents = [
        "RAG 是检索增强生成",
        "Embedding 是文本向量化",
        "LangChain 是 AI 开发框架"
    ]

    # 创建向量存储
    embeddings = OpenAIEmbeddings()
    vectorstore = Chroma.from_texts(documents, embeddings)

    # 执行检索
    results = vectorstore.similarity_search("什么是 RAG", k=1)

    # 验证结果
    assert len(results) == 1
    assert "RAG" in results[0].page_content
```

### 测试 LLM 调用（Mock）

```python
# tests/test_agent.py
from unittest.mock import Mock, patch
from langchain_openai import ChatOpenAI


def test_llm_call_mock():
    """测试：LLM 调用（Mock）"""
    # Mock LLM 响应
    mock_response = Mock()
    mock_response.content = "这是一个测试回复"

    with patch.object(ChatOpenAI, "invoke") as mock_invoke:
        mock_invoke.return_value = mock_response

        # 调用 LLM
        llm = ChatOpenAI()
        result = llm.invoke("你好")

        # 验证结果
        assert result.content == "这是一个测试回复"
```

### 测试流式输出

```python
# tests/test_streaming.py
import pytest
from langchain_openai import ChatOpenAI


@pytest.mark.asyncio
async def test_streaming_output():
    """测试：流式输出"""
    llm = ChatOpenAI(temperature=0)

    # 收集所有 chunk
    chunks = []
    async for chunk in llm.astream("说一个数字"):
        chunks.append(chunk.content)

    # 验证
    assert len(chunks) > 0
    full_response = "".join(chunks)
    assert len(full_response) > 0
```

---

## 测试组织结构

### 推荐的目录结构

```
project/
├── app/                    # 应用代码
│   ├── __init__.py
│   ├── main.py            # FastAPI 应用
│   ├── models.py          # 数据模型
│   ├── services.py        # 业务逻辑
│   └── utils.py           # 工具函数
├── tests/                 # 测试代码
│   ├── __init__.py
│   ├── conftest.py        # 共享 fixture
│   ├── test_api.py        # API 测试
│   ├── test_models.py     # 模型测试
│   ├── test_services.py   # 服务测试
│   └── test_utils.py      # 工具测试
└── pytest.ini             # pytest 配置
```

### conftest.py - 共享 fixture

```python
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from app.main import app


@pytest.fixture
def client():
    """FastAPI 测试客户端"""
    return TestClient(app)


@pytest.fixture
def sample_user():
    """测试用户"""
    return {
        "username": "test",
        "email": "test@example.com",
        "password": "password123"
    }


@pytest.fixture
def auth_token(client, sample_user):
    """认证 token"""
    response = client.post("/auth/login", json=sample_user)
    return response.json()["access_token"]
```

### pytest.ini - 配置文件

```ini
# pytest.ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --tb=short
asyncio_mode = auto
```

---

## 运行测试的常用命令

```bash
# 运行所有测试
pytest

# 运行指定文件
pytest tests/test_api.py

# 运行指定测试函数
pytest tests/test_api.py::test_read_root

# 详细输出
pytest -v

# 显示 print 输出
pytest -s

# 失败时停止
pytest -x

# 只运行失败的测试
pytest --lf

# 并行运行（需要 pytest-xdist）
pytest -n auto

# 生成覆盖率报告
pytest --cov=app --cov-report=html
```

---

## 快速调试技巧

### 1. 使用 print 调试

```python
def test_debug_with_print():
    """测试：使用 print 调试"""
    result = add(2, 3)
    print(f"Result: {result}")  # 使用 pytest -s 查看输出
    assert result == 5
```

### 2. 使用 pytest.set_trace()

```python
def test_debug_with_breakpoint():
    """测试：使用断点调试"""
    result = add(2, 3)
    pytest.set_trace()  # 进入调试器
    assert result == 5
```

### 3. 查看失败详情

```bash
# 显示完整的错误信息
pytest --tb=long

# 只显示第一行错误
pytest --tb=line

# 不显示错误堆栈
pytest --tb=no
```

---

## 最小可用检查清单

完成以下检查，确保你掌握了最小可用知识：

- [ ] 能写一个简单的测试函数
- [ ] 能使用 `assert` 断言结果
- [ ] 能运行 pytest 并查看结果
- [ ] 能定义和使用 fixture
- [ ] 能使用 TestClient 测试 FastAPI 端点
- [ ] 能使用 Mock 隔离外部依赖
- [ ] 能测试异常情况
- [ ] 能组织测试文件结构
- [ ] 能运行指定的测试
- [ ] 能查看测试覆盖率

---

## 下一步

掌握了这些最小可用知识后，你可以：

1. **深入学习**：阅读其他维度的详细内容
2. **实战练习**：为你的 AI Agent 项目编写测试
3. **扩展知识**：学习数据库测试、集成测试、性能测试

**记住**：测试不是一次性的任务，而是持续的实践。从简单开始，逐步提升。
