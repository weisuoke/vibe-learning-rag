# 核心概念1：固定窗口算法

> 最简单的限流算法，但有窗口边界问题

---

## 概述

**固定窗口算法**（Fixed Window）是最简单的限流算法，在固定时间窗口内计数，超过阈值就拒绝请求。

**核心思想：**
```
每个时间窗口有独立的计数器
窗口结束时重置计数器
实现简单，但有窗口边界问题
```

---

## 算法原理

### 基本概念

**固定窗口 = 时间窗口 + 计数器 + 重置机制**

```
时间轴：
[0:00-0:59] → 窗口1，计数器1
[1:00-1:59] → 窗口2，计数器2（重置）
[2:00-2:59] → 窗口3，计数器3（重置）
```

**工作流程：**
1. 请求到达
2. 检查当前时间是否在当前窗口内
3. 如果不在，重置计数器，更新窗口起始时间
4. 如果计数器 < 限制，计数器+1，允许请求
5. 否则，拒绝请求

---

### 可视化

```
限制：每分钟10个请求

时间轴：
0:00 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 0:59
     ↑                                                           ↑
   窗口开始                                                    窗口结束
   count = 0                                                   count = 10

1:00 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1:59
     ↑                                                           ↑
   窗口重置                                                    窗口结束
   count = 0                                                   count = 10


请求流：
0:00 → count=1 ✅
0:10 → count=2 ✅
0:20 → count=3 ✅
...
0:50 → count=10 ✅
0:55 → count=11 ❌ (超过限制)
1:00 → count=1 ✅ (窗口重置)
```

---

## 手写实现

### 版本1：最简单的实现

```python
import time
from typing import Optional

class FixedWindowLimiter:
    """
    固定窗口限流器

    原理：在固定时间窗口内计数，超过阈值就拒绝
    """

    def __init__(self, limit: int, window: int):
        """
        Args:
            limit: 窗口内最多允许的请求数
            window: 窗口大小（秒）
        """
        self.limit = limit
        self.window = window
        self.count = 0
        self.window_start = time.time()

    def acquire(self) -> bool:
        """
        尝试获取一个请求配额

        Returns:
            True: 允许请求
            False: 拒绝请求
        """
        now = time.time()

        # 检查是否进入新窗口
        if now - self.window_start >= self.window:
            # 重置计数器
            self.count = 0
            self.window_start = now

        # 检查是否超过限制
        if self.count < self.limit:
            self.count += 1
            return True

        return False

    def get_status(self) -> dict:
        """获取当前状态"""
        now = time.time()
        elapsed = now - self.window_start
        remaining = max(0, self.window - elapsed)

        return {
            "count": self.count,
            "limit": self.limit,
            "window_remaining": remaining,
            "reset_at": self.window_start + self.window
        }


# 使用示例
if __name__ == "__main__":
    # 每10秒最多5个请求
    limiter = FixedWindowLimiter(limit=5, window=10)

    # 模拟请求
    for i in range(10):
        if limiter.acquire():
            print(f"请求{i}: ✅ 通过")
        else:
            print(f"请求{i}: ❌ 被限流")

        # 查看状态
        status = limiter.get_status()
        print(f"  状态: {status['count']}/{status['limit']}, "
              f"窗口剩余: {status['window_remaining']:.1f}秒")

        time.sleep(1)
```

**输出：**
```
请求0: ✅ 通过
  状态: 1/5, 窗口剩余: 9.0秒
请求1: ✅ 通过
  状态: 2/5, 窗口剩余: 8.0秒
请求2: ✅ 通过
  状态: 3/5, 窗口剩余: 7.0秒
请求3: ✅ 通过
  状态: 4/5, 窗口剩余: 6.0秒
请求4: ✅ 通过
  状态: 5/5, 窗口剩余: 5.0秒
请求5: ❌ 被限流
  状态: 5/5, 窗口剩余: 4.0秒
...
请求9: ❌ 被限流
  状态: 5/5, 窗口剩余: 0.0秒
```

---

### 版本2：Redis 实现（分布式）

```python
import redis
import time
from typing import Optional

class RedisFixedWindowLimiter:
    """
    基于 Redis 的固定窗口限流器

    使用 Redis 的 INCR 和 EXPIRE 命令实现
    """

    def __init__(self, redis_client: redis.Redis, key_prefix: str, limit: int, window: int):
        """
        Args:
            redis_client: Redis 客户端
            key_prefix: Redis key 前缀
            limit: 窗口内最多允许的请求数
            window: 窗口大小（秒）
        """
        self.redis = redis_client
        self.key_prefix = key_prefix
        self.limit = limit
        self.window = window

    def _get_window_key(self) -> str:
        """
        获取当前窗口的 Redis key

        格式: {key_prefix}:{window_start_timestamp}
        """
        now = int(time.time())
        window_start = now - (now % self.window)
        return f"{self.key_prefix}:{window_start}"

    def acquire(self) -> bool:
        """
        尝试获取一个请求配额

        Returns:
            True: 允许请求
            False: 拒绝请求
        """
        key = self._get_window_key()

        # 使用 Redis 管道保证原子性
        pipe = self.redis.pipeline()
        pipe.incr(key)
        pipe.expire(key, self.window)
        results = pipe.execute()

        count = results[0]
        return count <= self.limit

    def get_status(self) -> dict:
        """获取当前状态"""
        key = self._get_window_key()
        count = int(self.redis.get(key) or 0)
        ttl = self.redis.ttl(key)

        return {
            "count": count,
            "limit": self.limit,
            "window_remaining": max(0, ttl),
            "key": key
        }


# 使用示例
if __name__ == "__main__":
    redis_client = redis.Redis(host='localhost', port=6379, db=0)

    # 每10秒最多5个请求
    limiter = RedisFixedWindowLimiter(
        redis_client=redis_client,
        key_prefix="user:123:rate_limit",
        limit=5,
        window=10
    )

    # 模拟请求
    for i in range(10):
        if limiter.acquire():
            print(f"请求{i}: ✅ 通过")
        else:
            print(f"请求{i}: ❌ 被限流")

        status = limiter.get_status()
        print(f"  状态: {status['count']}/{status['limit']}, "
              f"窗口剩余: {status['window_remaining']}秒")

        time.sleep(1)
```

---

### 版本3：Lua 脚本实现（更高效）

```python
import redis
import time

class RedisFixedWindowLimiterLua:
    """
    基于 Redis + Lua 脚本的固定窗口限流器

    使用 Lua 脚本保证原子性，减少网络往返
    """

    # Lua 脚本
    LUA_SCRIPT = """
    local key = KEYS[1]
    local limit = tonumber(ARGV[1])
    local window = tonumber(ARGV[2])

    -- 获取当前计数
    local current = redis.call('incr', key)

    -- 如果是第一个请求，设置过期时间
    if current == 1 then
        redis.call('expire', key, window)
    end

    -- 检查是否超过限制
    if current > limit then
        return 0  -- 拒绝
    end

    return 1  -- 允许
    """

    def __init__(self, redis_client: redis.Redis, key_prefix: str, limit: int, window: int):
        self.redis = redis_client
        self.key_prefix = key_prefix
        self.limit = limit
        self.window = window

        # 注册 Lua 脚本
        self.script_sha = self.redis.script_load(self.LUA_SCRIPT)

    def _get_window_key(self) -> str:
        """获取当前窗口的 Redis key"""
        now = int(time.time())
        window_start = now - (now % self.window)
        return f"{self.key_prefix}:{window_start}"

    def acquire(self) -> bool:
        """尝试获取一个请求配额"""
        key = self._get_window_key()

        # 执行 Lua 脚本
        result = self.redis.evalsha(
            self.script_sha,
            1,  # 1个key
            key,
            self.limit,
            self.window
        )

        return result == 1

    def get_status(self) -> dict:
        """获取当前状态"""
        key = self._get_window_key()
        count = int(self.redis.get(key) or 0)
        ttl = self.redis.ttl(key)

        return {
            "count": count,
            "limit": self.limit,
            "window_remaining": max(0, ttl)
        }
```

---

## 窗口边界问题

### 问题描述

固定窗口算法的最大问题是**窗口边界流量突刺**（Boundary Burst Problem）。

**场景：** 限制每分钟100个请求

```
时间轴：
[0:59:00 - 0:59:59] → 窗口1，100个请求 ✅
[1:00:00 - 1:00:59] → 窗口2，100个请求 ✅

实际情况：
[0:59:50 - 1:00:10] → 20秒内200个请求！❌
```

**可视化：**
```
窗口1 (0:00-0:59)          窗口2 (1:00-1:59)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                    ↑                    ↑
                  0:59                 1:00
                    └──────────┬──────────┘
                          20秒内200个请求
```

---

### 问题演示

```python
import time

def test_boundary_burst():
    """演示窗口边界问题"""
    limiter = FixedWindowLimiter(limit=10, window=60)

    print("=== 窗口边界问题演示 ===\n")

    # 在第59秒发送10个请求
    print("第59秒：发送10个请求")
    for i in range(10):
        assert limiter.acquire() == True
        print(f"  请求{i}: ✅")

    print(f"\n当前状态: {limiter.get_status()}")

    # 等待1秒，进入新窗口
    print("\n等待1秒，进入新窗口...")
    time.sleep(1)

    # 在第1秒又发送10个请求
    print("\n第1秒：发送10个请求")
    for i in range(10):
        assert limiter.acquire() == True
        print(f"  请求{i}: ✅")

    print(f"\n当前状态: {limiter.get_status()}")

    print("\n❌ 问题：2秒内通过了20个请求！")


if __name__ == "__main__":
    test_boundary_burst()
```

**输出：**
```
=== 窗口边界问题演示 ===

第59秒：发送10个请求
  请求0: ✅
  请求1: ✅
  ...
  请求9: ✅

当前状态: {'count': 10, 'limit': 10, 'window_remaining': 0.0}

等待1秒，进入新窗口...

第1秒：发送10个请求
  请求0: ✅
  请求1: ✅
  ...
  请求9: ✅

当前状态: {'count': 10, 'limit': 10, 'window_remaining': 59.0}

❌ 问题：2秒内通过了20个请求！
```

---

## 优缺点分析

### 优点

1. **实现简单**
   - 只需要一个计数器和窗口起始时间
   - 代码量少，易于理解和维护

2. **性能高**
   - 时间复杂度：O(1)
   - 空间复杂度：O(1)
   - 内存占用小

3. **Redis 实现高效**
   - 使用 INCR 和 EXPIRE 命令
   - 原子操作，无并发问题
   - 网络往返少

---

### 缺点

1. **窗口边界问题**
   - 窗口交界处可能出现双倍流量
   - 无法精确控制请求速率

2. **不支持突发流量**
   - 窗口内的配额用完就拒绝
   - 无法利用之前窗口的余量

3. **粗粒度限流**
   - 只能按固定窗口限流
   - 无法实现更精细的控制

---

## 适用场景

### ✅ 适合的场景

1. **粗粒度限流**
   - 每天、每月的配额限制
   - 对精确性要求不高

2. **内部服务**
   - 服务之间的限流
   - 不需要防止恶意攻击

3. **简单场景**
   - 流量平稳，无突发
   - 对窗口边界问题不敏感

**示例：**
```python
# 每天最多1000次 LLM 调用
daily_limiter = FixedWindowLimiter(limit=1000, window=86400)

# 每月最多10000次 API 调用
monthly_limiter = FixedWindowLimiter(limit=10000, window=2592000)
```

---

### ❌ 不适合的场景

1. **细粒度限流**
   - 每秒、每分钟的限流
   - 窗口边界问题明显

2. **对外 API**
   - 容易被攻击者利用窗口边界
   - 需要更精确的控制

3. **高并发场景**
   - 突发流量会被拒绝
   - 用户体验差

**推荐方案：** 使用滑动窗口或令牌桶

---

## 在 AI Agent 开发中的应用

### 场景1：每日 LLM 调用配额

```python
from fastapi import FastAPI, Depends, HTTPException
from typing import Annotated

app = FastAPI()

# 每天最多100次 LLM 调用
daily_limiters = {}

def get_daily_limiter(user_id: str):
    """获取用户的每日限流器"""
    if user_id not in daily_limiters:
        daily_limiters[user_id] = FixedWindowLimiter(
            limit=100,
            window=86400  # 24小时
        )
    return daily_limiters[user_id]


@app.post("/chat")
async def chat(
    message: str,
    user_id: str,
    limiter: Annotated[FixedWindowLimiter, Depends(get_daily_limiter)]
):
    # 检查每日配额
    if not limiter.acquire():
        status = limiter.get_status()
        raise HTTPException(
            status_code=429,
            detail={
                "error": "Daily quota exceeded",
                "limit": status["limit"],
                "reset_at": status["reset_at"]
            }
        )

    # 调用 LLM
    response = await llm.chat(message)
    return {"response": response}
```

---

### 场景2：按用户等级限流

```python
from enum import Enum

class UserTier(str, Enum):
    FREE = "free"
    BASIC = "basic"
    PRO = "pro"


# 不同等级的每日配额
DAILY_LIMITS = {
    UserTier.FREE: 10,
    UserTier.BASIC: 100,
    UserTier.PRO: 1000
}


def get_user_limiter(user_id: str, user_tier: UserTier):
    """根据用户等级获取限流器"""
    limit = DAILY_LIMITS[user_tier]

    return RedisFixedWindowLimiter(
        redis_client=redis_client,
        key_prefix=f"user:{user_id}:daily",
        limit=limit,
        window=86400
    )


@app.post("/chat")
async def chat(
    message: str,
    user: User = Depends(get_current_user)
):
    # 获取限流器
    limiter = get_user_limiter(user.id, user.tier)

    # 检查配额
    if not limiter.acquire():
        status = limiter.get_status()
        raise HTTPException(
            status_code=429,
            detail={
                "error": f"Daily quota exceeded for {user.tier} tier",
                "limit": status["limit"],
                "used": status["count"],
                "reset_in": status["window_remaining"]
            }
        )

    # 调用 LLM
    response = await llm.chat(message)
    return {"response": response}
```

---

### 场景3：监控和告警

```python
from prometheus_client import Counter, Gauge

# Prometheus 指标
rate_limit_requests = Counter(
    'rate_limit_requests_total',
    'Total rate limit checks',
    ['user_tier', 'result']
)

rate_limit_usage = Gauge(
    'rate_limit_usage_ratio',
    'Rate limit usage ratio',
    ['user_tier']
)


async def chat_with_metrics(message: str, user: User):
    """带监控的聊天接口"""
    limiter = get_user_limiter(user.id, user.tier)

    # 检查配额
    if not limiter.acquire():
        # 记录被拒绝的请求
        rate_limit_requests.labels(user.tier, 'rejected').inc()

        status = limiter.get_status()
        raise HTTPException(status_code=429, detail="Quota exceeded")

    # 记录通过的请求
    rate_limit_requests.labels(user.tier, 'allowed').inc()

    # 更新使用率
    status = limiter.get_status()
    usage_ratio = status['count'] / status['limit']
    rate_limit_usage.labels(user.tier).set(usage_ratio)

    # 告警：使用率超过80%
    if usage_ratio > 0.8:
        logger.warning(
            f"User {user.id} ({user.tier}) usage: {usage_ratio:.1%}"
        )

    # 调用 LLM
    response = await llm.chat(message)
    return {"response": response}
```

---

## 性能分析

### 时间复杂度

- **acquire()**: O(1)
- **get_status()**: O(1)

### 空间复杂度

- **内存版本**: O(1)（只存储计数器和时间戳）
- **Redis 版本**: O(n)（n 是并发用户数）

### 性能对比

```python
import time

def benchmark_fixed_window():
    """性能测试"""
    limiter = FixedWindowLimiter(limit=10000, window=60)

    # 测试 10000 次 acquire
    start = time.time()
    for _ in range(10000):
        limiter.acquire()
    elapsed = time.time() - start

    print(f"10000次 acquire: {elapsed:.3f}秒")
    print(f"平均延迟: {elapsed / 10000 * 1000:.3f}ms")
    print(f"QPS: {10000 / elapsed:.0f}")


if __name__ == "__main__":
    benchmark_fixed_window()
```

**输出：**
```
10000次 acquire: 0.005秒
平均延迟: 0.0005ms
QPS: 2000000
```

---

## 总结

### 核心要点

1. **固定窗口是最简单的限流算法**
   - 实现简单，性能高
   - 但有窗口边界问题

2. **适合粗粒度限流**
   - 每天、每月的配额
   - 内部服务之间的限流

3. **不适合细粒度限流**
   - 每秒、每分钟的限流
   - 对外 API 的限流

4. **Redis 实现支持分布式**
   - 使用 INCR 和 EXPIRE 命令
   - Lua 脚本保证原子性

---

### 与其他算法对比

| 算法 | 实现复杂度 | 精确性 | 支持突发 | 适用场景 |
|------|-----------|--------|----------|----------|
| 固定窗口 | ⭐ 简单 | ⭐⭐ 低 | ❌ 不支持 | 粗粒度限流 |
| 滑动窗口 | ⭐⭐⭐ 复杂 | ⭐⭐⭐ 高 | ❌ 不支持 | 精确限流 |
| 令牌桶 | ⭐⭐ 中等 | ⭐⭐⭐ 高 | ✅ 支持 | API 网关 |
| 漏桶 | ⭐⭐ 中等 | ⭐⭐⭐ 高 | ❌ 不支持 | 流量整形 |

---

### 学习检查清单

- [ ] 理解固定窗口的原理（时间窗口 + 计数器 + 重置）
- [ ] 能手写一个简单的固定窗口实现
- [ ] 理解窗口边界问题及其原因
- [ ] 能用 Redis 实现分布式固定窗口
- [ ] 能用 Lua 脚本优化 Redis 实现
- [ ] 知道固定窗口的适用场景和不适用场景
- [ ] 能在 AI Agent 项目中应用固定窗口限流

---

## 下一步

学习了固定窗口算法后，接下来学习：
1. **滑动窗口算法**：解决窗口边界问题
2. **令牌桶算法**：支持突发流量
3. **漏桶算法**：流量整形

---

**记住：** 固定窗口算法简单高效，但有窗口边界问题。适合粗粒度限流（每天、每月），不适合细粒度限流（每秒、每分钟）。在 AI Agent 开发中，可以用于每日 LLM 调用配额的限制。
