# 核心概念5：存储后端选择

> 内存 vs Redis：如何选择限流存储方案

---

## 概述

限流状态需要存储，有两种主要方案：
- **内存存储**：单机环境，性能高
- **Redis 存储**：分布式环境，支持共享状态

---

## 内存存储

### 优点

1. **性能极高**
   - 无网络延迟（< 1μs）
   - 适合高并发场景

2. **实现简单**
   - 无需额外依赖
   - 代码量少

3. **成本低**
   - 无需维护 Redis
   - 无额外成本

### 缺点

1. **不支持分布式**
   - 多个服务器实例无法共享状态
   - 限流失效

2. **状态不持久**
   - 服务重启后状态丢失
   - 无法恢复

3. **无法跨进程**
   - 单机多进程也无法共享

### 适用场景

- ✅ 单机应用
- ✅ 开发环境
- ✅ 简单场景
- ❌ 分布式环境
- ❌ 生产环境（多实例）

---

## Redis 存储

### 优点

1. **支持分布式**
   - 多个服务器共享状态
   - 限流精确

2. **状态持久化**
   - 服务重启后状态保留
   - 可恢复

3. **功能丰富**
   - 支持过期时间
   - 支持 Lua 脚本

### 缺点

1. **网络延迟**
   - 每次请求需要网络往返（~1ms）
   - 性能比内存低

2. **额外成本**
   - 需要维护 Redis 服务器
   - 需要考虑高可用

3. **实现复杂**
   - 需要处理连接、重试
   - 需要 Lua 脚本保证原子性

### 适用场景

- ✅ 分布式环境
- ✅ 生产环境（多实例）
- ✅ 需要持久化
- ❌ 单机应用（过度设计）
- ❌ 开发环境（增加复杂度）

---

## 性能对比

```python
import time
import redis

def benchmark():
    """性能对比测试"""
    # 内存限流
    memory_limiter = TokenBucket(rate=10000, capacity=10000)
    start = time.time()
    for _ in range(10000):
        memory_limiter.acquire()
    memory_time = time.time() - start

    # Redis 限流
    redis_client = redis.Redis()
    redis_limiter = RedisTokenBucket(redis_client, "test", 10000, 10000)
    start = time.time()
    for _ in range(10000):
        redis_limiter.acquire()
    redis_time = time.time() - start

    print(f"内存限流: {memory_time:.3f}秒 ({10000/memory_time:.0f} QPS)")
    print(f"Redis限流: {redis_time:.3f}秒 ({10000/redis_time:.0f} QPS)")
    print(f"性能差距: {redis_time/memory_time:.1f}x")
```

**输出：**
```
内存限流: 0.005秒 (2000000 QPS)
Redis限流: 2.5秒 (4000 QPS)
性能差距: 500x
```

---

## 混合方案

### 原理

结合内存和 Redis 的优点：
- 内存预检（快速拒绝）
- Redis 精确控制（保证一致性）

```python
class HybridLimiter:
    """混合限流器：内存 + Redis"""

    def __init__(self, redis_client, key, rate, capacity):
        # 内存限流器（放宽20%）
        self.memory_limiter = TokenBucket(rate * 1.2, capacity * 1.2)
        # Redis 限流器（精确）
        self.redis_limiter = RedisTokenBucket(redis_client, key, rate, capacity)

    async def acquire(self) -> bool:
        # 1. 内存预检（快速拒绝）
        if not self.memory_limiter.acquire():
            return False

        # 2. Redis 精确检查
        return await self.redis_limiter.acquire()
```

### 优点

- 大部分请求在内存层被拒绝（快速）
- 通过内存层的请求才访问 Redis（减少 Redis 压力）
- 保证分布式环境下的精确限流

### 性能

```
纯内存: < 1μs
纯 Redis: ~1ms
混合方案: ~0.1ms（90%请求在内存层被拒绝）
```

---

## 选择决策树

```
单机应用？
  ↓ 是 → 内存限流
  ↓ 否
分布式环境？
  ↓ 是
高并发（>10万QPS）？
  ↓ 是 → 混合方案
  ↓ 否 → Redis 限流
```

---

## 在 AI Agent 开发中的应用

### 场景1：开发环境（内存）

```python
# 开发环境：使用内存限流
if os.getenv("ENV") == "development":
    limiter = TokenBucket(rate=10, capacity=100)
else:
    limiter = RedisTokenBucket(redis_client, "user:123", 10, 100)
```

### 场景2：生产环境（Redis）

```python
# 生产环境：使用 Redis 限流
redis_client = redis.Redis(
    host=os.getenv("REDIS_HOST"),
    port=int(os.getenv("REDIS_PORT")),
    db=0
)

limiter = RedisTokenBucket(
    redis_client=redis_client,
    key=f"user:{user_id}:rate_limit",
    rate=10,
    capacity=100
)
```

### 场景3：高并发（混合）

```python
# 高并发场景：使用混合方案
limiter = HybridLimiter(
    redis_client=redis_client,
    key=f"user:{user_id}:rate_limit",
    rate=100,
    capacity=1000
)
```

---

## 总结

| 方案 | 性能 | 分布式 | 持久化 | 适用场景 |
|------|------|--------|--------|----------|
| 内存 | ⭐⭐⭐ 极高 | ❌ | ❌ | 单机、开发环境 |
| Redis | ⭐⭐ 中等 | ✅ | ✅ | 分布式、生产环境 |
| 混合 | ⭐⭐⭐ 高 | ✅ | ✅ | 高并发、生产环境 |

---

**记住：** 单机用内存，分布式用 Redis，高并发用混合方案。
