# 核心概念 03：消息传递模式

> **核心价值**: 消息传递模式决定了工具调用的执行方式，one-at-a-time 模式确保顺序执行，all 模式支持并行批处理，是优化 Agent 性能的关键机制。

---

## 概述

在 AI Agent 系统中，当 LLM 返回多个工具调用时，有两种传递模式：

1. **one-at-a-time 模式**（默认）：逐个执行工具调用，每次执行完一个工具后将结果返回给 LLM
2. **all 模式**（批量）：并行执行所有工具调用，一次性将所有结果返回给 LLM

选择合适的传递模式可以显著影响 Agent 的性能和行为。

---

## 1. one-at-a-time 模式（默认）

### 1.1 定义

**one-at-a-time 模式**：逐个执行工具调用，每次执行完一个工具后立即将结果返回给 LLM，LLM 可以根据结果决定下一步操作。

**核心特征**：
- **顺序执行**：工具按顺序逐个执行
- **实时反馈**：每个工具执行完立即返回结果
- **动态决策**：LLM 可以根据前一个工具的结果调整后续操作
- **更安全**：避免并行执行可能导致的冲突

### 1.2 执行流程

```typescript
// one-at-a-time 模式执行流程
async function executeOneAtATime(toolCalls: ToolCall[]): Promise<void> {
  for (const toolCall of toolCalls) {
    // 1. 执行单个工具
    const result = await executeTool(toolCall);

    // 2. 立即返回结果给 LLM
    const llmResponse = await callLLM({
      messages: [...previousMessages, result]
    });

    // 3. LLM 可能返回新的工具调用
    if (llmResponse.toolCalls) {
      await executeOneAtATime(llmResponse.toolCalls);
    }
  }
}
```

### 1.3 执行示例

```typescript
// 场景：LLM 返回 3 个工具调用
const toolCalls = [
  { name: 'readFile', args: { path: 'config.json' } },
  { name: 'parseJSON', args: { data: '...' } },
  { name: 'validateConfig', args: { config: '...' } }
];

// one-at-a-time 执行
// Step 1: 执行 readFile
const file = await readFile('config.json');
// → 返回给 LLM

// Step 2: LLM 根据文件内容决定下一步
// → 执行 parseJSON
const parsed = await parseJSON(file);
// → 返回给 LLM

// Step 3: LLM 根据解析结果决定下一步
// → 执行 validateConfig
const valid = await validateConfig(parsed);
// → 返回给 LLM
```

### 1.4 适用场景

✅ **推荐使用场景**：
- **依赖关系**：后续工具依赖前一个工具的结果
- **动态决策**：需要根据中间结果调整后续操作
- **安全优先**：避免并行执行可能导致的冲突
- **调试需要**：需要逐步观察每个工具的执行结果

**示例**：
```typescript
// 场景：读取文件 → 解析内容 → 根据内容决定下一步
// 后续操作依赖前一个结果，必须使用 one-at-a-time
```

### 1.5 TypeScript/Node.js 类比

**类比：async/await 顺序执行**

```typescript
// one-at-a-time 类似于 async/await 顺序执行
async function processData() {
  const data = await fetchData();      // 等待完成
  const parsed = await parseData(data); // 等待完成
  const result = await saveData(parsed); // 等待完成
  return result;
}
```

### 1.6 日常生活类比

**类比：餐厅点餐**

想象你在餐厅点餐：
- **one-at-a-time** = 先上前菜，吃完后再上主菜，最后上甜点
- 每道菜上完后，服务员会根据你的反馈决定下一道菜

---

## 2. all 模式（批量）

### 2.1 定义

**all 模式**：并行执行所有工具调用，一次性将所有结果返回给 LLM。

**核心特征**：
- **并行执行**：所有工具同时执行
- **批量返回**：所有结果一次性返回给 LLM
- **性能优化**：减少 LLM 调用次数，提升性能
- **独立工具**：适用于相互独立的工具调用

### 2.2 执行流程

```typescript
// all 模式执行流程
async function executeAll(toolCalls: ToolCall[]): Promise<void> {
  // 1. 并行执行所有工具
  const results = await Promise.all(
    toolCalls.map(toolCall => executeTool(toolCall))
  );

  // 2. 一次性返回所有结果给 LLM
  const llmResponse = await callLLM({
    messages: [...previousMessages, ...results]
  });

  // 3. 处理 LLM 响应
  if (llmResponse.toolCalls) {
    await executeAll(llmResponse.toolCalls);
  }
}
```

### 2.3 执行示例

```typescript
// 场景：LLM 返回 3 个独立的工具调用
const toolCalls = [
  { name: 'readFile', args: { path: 'file1.txt' } },
  { name: 'readFile', args: { path: 'file2.txt' } },
  { name: 'readFile', args: { path: 'file3.txt' } }
];

// all 模式执行
// 并行执行所有工具
const results = await Promise.all([
  readFile('file1.txt'),
  readFile('file2.txt'),
  readFile('file3.txt')
]);

// 一次性返回所有结果给 LLM
await callLLM({ messages: [...previousMessages, ...results] });
```

### 2.4 适用场景

✅ **推荐使用场景**：
- **独立工具**：工具之间没有依赖关系
- **性能优先**：需要减少 LLM 调用次数
- **批量操作**：需要同时执行多个相似操作
- **并行安全**：工具执行不会相互冲突

**示例**：
```typescript
// 场景：同时读取多个文件
// 文件之间没有依赖关系，可以并行执行
const files = await Promise.all([
  readFile('config.json'),
  readFile('data.json'),
  readFile('schema.json')
]);
```

### 2.5 TypeScript/Node.js 类比

**类比：Promise.all() 并行执行**

```typescript
// all 模式类似于 Promise.all() 并行执行
async function processData() {
  const [data1, data2, data3] = await Promise.all([
    fetchData1(),
    fetchData2(),
    fetchData3()
  ]);

  return { data1, data2, data3 };
}
```

### 2.6 日常生活类比

**类比：餐厅点餐**

想象你在餐厅点餐：
- **all 模式** = 所有菜一起上，一次性端上桌
- 厨房并行准备所有菜品，同时完成

---

## 3. 模式对比

### 3.1 核心区别

| 特性 | one-at-a-time | all |
|------|--------------|-----|
| **执行方式** | 顺序执行 | 并行执行 |
| **返回时机** | 每个工具执行完立即返回 | 所有工具执行完一次性返回 |
| **LLM 调用次数** | 多次（每个工具一次） | 一次（所有工具完成后） |
| **性能** | 较慢（顺序执行） | 较快（并行执行） |
| **动态决策** | 支持（可根据中间结果调整） | 不支持（无法根据中间结果调整） |
| **依赖处理** | 支持（后续工具可依赖前一个结果） | 不支持（工具必须独立） |
| **安全性** | 更安全（避免并行冲突） | 需要确保工具独立 |
| **调试** | 更容易（逐步观察） | 较难（批量执行） |

### 3.2 性能对比

```typescript
// 场景：执行 3 个工具，每个工具耗时 1 秒

// one-at-a-time 模式
// Tool 1: 1s → LLM call: 0.5s
// Tool 2: 1s → LLM call: 0.5s
// Tool 3: 1s → LLM call: 0.5s
// 总耗时: 3s + 1.5s = 4.5s

// all 模式
// Tool 1, 2, 3 并行: 1s → LLM call: 0.5s
// 总耗时: 1s + 0.5s = 1.5s

// 性能提升: 4.5s / 1.5s = 3x
```

### 3.3 决策树

```
LLM 返回多个工具调用
    ↓
工具之间有依赖关系？
    ↓
  是 → one-at-a-time（顺序执行）
    ↓
  否 → 需要根据中间结果调整？
    ↓
      是 → one-at-a-time（动态决策）
      否 → all（并行执行，性能优先）
```

---

## 4. 配置方式

### 4.1 在 pi-mono 中配置

```typescript
// packages/pi-agent-core/src/agent.ts

export interface AgentConfig {
  // 工具传递模式
  toolDeliveryMode: 'one-at-a-time' | 'all';

  // 其他配置...
}

// 创建 Agent 时指定模式
const agent = new Agent({
  toolDeliveryMode: 'all' // 使用 all 模式
});
```

### 4.2 动态切换模式

```typescript
// 根据工具类型动态选择模式
function selectDeliveryMode(toolCalls: ToolCall[]): DeliveryMode {
  // 检查是否有依赖关系
  const hasDependencies = checkDependencies(toolCalls);

  if (hasDependencies) {
    return 'one-at-a-time';
  }

  // 检查是否需要动态决策
  const needsDynamicDecision = checkDynamicDecision(toolCalls);

  if (needsDynamicDecision) {
    return 'one-at-a-time';
  }

  // 默认使用 all 模式（性能优先）
  return 'all';
}
```

### 4.3 混合模式

```typescript
// 混合模式：部分顺序执行，部分并行执行
async function executeHybrid(toolCalls: ToolCall[]): Promise<void> {
  // 1. 分析依赖关系
  const groups = analyzeDependencies(toolCalls);

  // 2. 按组执行
  for (const group of groups) {
    if (group.canParallel) {
      // 并行执行
      await Promise.all(group.tools.map(executeTool));
    } else {
      // 顺序执行
      for (const tool of group.tools) {
        await executeTool(tool);
      }
    }
  }
}
```

---

## 5. 实际应用示例

### 5.1 场景 1：文件操作（all 模式）

```typescript
// 场景：同时读取多个配置文件
// 文件之间没有依赖关系，使用 all 模式

const toolCalls = [
  { name: 'readFile', args: { path: 'config/app.json' } },
  { name: 'readFile', args: { path: 'config/db.json' } },
  { name: 'readFile', args: { path: 'config/api.json' } }
];

// 并行执行
const results = await Promise.all(
  toolCalls.map(call => executeTool(call))
);

// 性能提升：3x（3 个文件并行读取）
```

### 5.2 场景 2：数据处理（one-at-a-time 模式）

```typescript
// 场景：读取文件 → 解析 → 验证 → 保存
// 每一步依赖前一步的结果，使用 one-at-a-time 模式

const toolCalls = [
  { name: 'readFile', args: { path: 'data.json' } },
  { name: 'parseJSON', args: { data: '...' } },
  { name: 'validateData', args: { data: '...' } },
  { name: 'saveToDatabase', args: { data: '...' } }
];

// 顺序执行
for (const call of toolCalls) {
  const result = await executeTool(call);
  // 每一步的结果传递给下一步
}
```

### 5.3 场景 3：混合模式

```typescript
// 场景：读取多个文件 → 合并 → 处理
// 第一步并行，第二步顺序

// Step 1: 并行读取文件（all 模式）
const files = await Promise.all([
  readFile('file1.txt'),
  readFile('file2.txt'),
  readFile('file3.txt')
]);

// Step 2: 顺序处理（one-at-a-time 模式）
const merged = await mergeFiles(files);
const processed = await processData(merged);
const saved = await saveResult(processed);
```

---

## 6. 最佳实践

### 6.1 默认使用 one-at-a-time

```typescript
// 推荐：默认使用 one-at-a-time 模式
// 原因：更安全，避免并行冲突

const agent = new Agent({
  toolDeliveryMode: 'one-at-a-time' // 默认
});
```

### 6.2 明确标记可并行工具

```typescript
// 为工具添加元数据，标记是否可并行
interface ToolDefinition {
  name: string;
  execute: (args: any) => Promise<any>;
  canParallel: boolean; // 是否可并行执行
}

// 示例
const tools: ToolDefinition[] = [
  {
    name: 'readFile',
    execute: readFile,
    canParallel: true // 读取文件可以并行
  },
  {
    name: 'writeFile',
    execute: writeFile,
    canParallel: false // 写入文件不能并行（可能冲突）
  }
];
```

### 6.3 性能监控

```typescript
// 监控不同模式的性能
class PerformanceMonitor {
  private metrics = {
    oneAtATime: { count: 0, totalTime: 0 },
    all: { count: 0, totalTime: 0 }
  };

  async executeWithMonitoring(
    mode: DeliveryMode,
    toolCalls: ToolCall[]
  ): Promise<void> {
    const startTime = Date.now();

    if (mode === 'one-at-a-time') {
      await executeOneAtATime(toolCalls);
      this.metrics.oneAtATime.count++;
      this.metrics.oneAtATime.totalTime += Date.now() - startTime;
    } else {
      await executeAll(toolCalls);
      this.metrics.all.count++;
      this.metrics.all.totalTime += Date.now() - startTime;
    }
  }

  getMetrics() {
    return {
      oneAtATime: {
        avgTime: this.metrics.oneAtATime.totalTime / this.metrics.oneAtATime.count
      },
      all: {
        avgTime: this.metrics.all.totalTime / this.metrics.all.count
      }
    };
  }
}
```

---

## 7. 总结

### 7.1 核心要点

1. **one-at-a-time 模式**：顺序执行，支持依赖和动态决策，更安全
2. **all 模式**：并行执行，性能更好，适用于独立工具
3. **选择标准**：有依赖 → one-at-a-time，独立 → all
4. **默认推荐**：one-at-a-time（更安全）
5. **性能优化**：明确标记可并行工具，使用混合模式

### 7.2 TypeScript/Node.js 类比

- **one-at-a-time** = async/await 顺序执行
- **all** = Promise.all() 并行执行

### 7.3 日常生活类比

- **one-at-a-time** = 餐厅逐道上菜
- **all** = 餐厅所有菜一起上

### 7.4 学习检查

- [ ] 理解 one-at-a-time 和 all 模式的区别
- [ ] 知道何时使用 one-at-a-time，何时使用 all
- [ ] 理解性能差异和权衡
- [ ] 能够设计混合模式
- [ ] 能够配置和切换传递模式

### 7.5 下一步

- **03_核心概念_04_Transport机制.md**：学习 SSE、WebSocket、HTTP Streaming
- **03_核心概念_06_队列优化策略.md**：学习批处理和去重优化
- **07_实战代码_07_批处理优化.md**：手写批处理优化实现

---

**版本**: v1.0
**最后更新**: 2026-02-19
**维护者**: Claude Code
