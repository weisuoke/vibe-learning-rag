# JWT认证 - 核心概念03：认证流程设计

## 概述

完整的认证系统包括注册、登录、Token刷新、登出等流程。本章详细讲解每个流程的设计和实现。

---

## 用户注册流程

### 密码哈希原理

**为什么不能明文存储密码？**

```python
# ❌ 危险：明文存储密码
users = {
    "alice@example.com": {
        "password": "password123"  # 数据库泄露后，密码直接暴露
    }
}
```

**问题：**
- 数据库泄露后，所有密码暴露
- 内部人员可以看到用户密码
- 用户在其他网站使用相同密码会被攻击

**解决：密码哈希**

```python
# ✅ 安全：哈希存储密码
users = {
    "alice@example.com": {
        "hashed_password": "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYzS4HWBe4u"
    }
}
```

### bcrypt 哈希算法

**特点：**
- 慢速哈希（故意设计的）
- 自动加盐（Salt）
- 可调节计算成本（Work Factor）

```python
from passlib.context import CryptContext

# 创建密码上下文
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# ===== 哈希密码 =====
password = "password123"
hashed = pwd_context.hash(password)
print(f"哈希后: {hashed}")
# $2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYzS4HWBe4u

# ===== 验证密码 =====
is_valid = pwd_context.verify("password123", hashed)
print(f"密码正确: {is_valid}")  # True

is_valid = pwd_context.verify("wrong_password", hashed)
print(f"错误密码: {is_valid}")  # False
```

**bcrypt 哈希格式：**
```
$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYzS4HWBe4u
│  │  │                      │
│  │  │                      └─ 哈希值（31字符）
│  │  └─ 盐值（22字符）
│  └─ 成本因子（12 = 2^12 次迭代）
└─ 算法版本（2b = bcrypt）
```

### 注册端点实现

```python
"""
用户注册完整实现
演示：注册 → 密码哈希 → 存储到数据库
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, EmailStr, validator
from passlib.context import CryptContext
from sqlalchemy import Column, Integer, String, DateTime, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

app = FastAPI()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# ===== 数据库模型 =====
Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)


# ===== 请求模型 =====
class RegisterRequest(BaseModel):
    email: EmailStr
    username: str
    password: str

    @validator('username')
    def username_valid(cls, v):
        if len(v) < 3:
            raise ValueError('用户名至少3个字符')
        if len(v) > 20:
            raise ValueError('用户名最多20个字符')
        return v

    @validator('password')
    def password_strong(cls, v):
        if len(v) < 8:
            raise ValueError('密码至少8个字符')
        if not any(c.isupper() for c in v):
            raise ValueError('密码必须包含大写字母')
        if not any(c.islower() for c in v):
            raise ValueError('密码必须包含小写字母')
        if not any(c.isdigit() for c in v):
            raise ValueError('密码必须包含数字')
        return v


# ===== 注册端点 =====
@app.post("/register")
async def register(request: RegisterRequest, db: Session = Depends(get_db)):
    """用户注册"""
    # 1. 检查邮箱是否已存在
    existing_user = db.query(User).filter(User.email == request.email).first()
    if existing_user:
        raise HTTPException(400, "邮箱已被注册")

    # 2. 检查用户名是否已存在
    existing_user = db.query(User).filter(User.username == request.username).first()
    if existing_user:
        raise HTTPException(400, "用户名已被使用")

    # 3. 哈希密码
    hashed_password = pwd_context.hash(request.password)

    # 4. 创建用户
    user = User(
        email=request.email,
        username=request.username,
        hashed_password=hashed_password
    )
    db.add(user)
    db.commit()
    db.refresh(user)

    # 5. 返回成功（不返回密码）
    return {
        "message": "注册成功",
        "user": {
            "id": user.id,
            "email": user.email,
            "username": user.username
        }
    }
```

---

## 登录流程

### 登录流程图

```
用户输入邮箱和密码
    ↓
查询数据库，找到用户
    ↓
验证密码哈希
    ↓
生成 Access Token（15分钟）
    ↓
生成 Refresh Token（7天）
    ↓
返回双 Token
```

### 登录端点实现

```python
from jose import jwt
from datetime import timedelta

SECRET_KEY = os.getenv("SECRET_KEY")
REFRESH_SECRET_KEY = os.getenv("REFRESH_SECRET_KEY")
ALGORITHM = "HS256"


class LoginRequest(BaseModel):
    email: EmailStr
    password: str


class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


def create_access_token(user_id: int, expires_delta: timedelta = None) -> str:
    """生成 Access Token"""
    if expires_delta is None:
        expires_delta = timedelta(minutes=15)

    payload = {
        "user_id": user_id,
        "type": "access",
        "exp": datetime.utcnow() + expires_delta
    }

    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def create_refresh_token(user_id: int, expires_delta: timedelta = None) -> str:
    """生成 Refresh Token"""
    if expires_delta is None:
        expires_delta = timedelta(days=7)

    payload = {
        "user_id": user_id,
        "type": "refresh",
        "exp": datetime.utcnow() + expires_delta
    }

    return jwt.encode(payload, REFRESH_SECRET_KEY, algorithm=ALGORITHM)


@app.post("/login", response_model=TokenResponse)
async def login(request: LoginRequest, db: Session = Depends(get_db)):
    """用户登录"""
    # 1. 查找用户
    user = db.query(User).filter(User.email == request.email).first()
    if not user:
        raise HTTPException(401, "邮箱或密码错误")

    # 2. 验证密码
    if not pwd_context.verify(request.password, user.hashed_password):
        raise HTTPException(401, "邮箱或密码错误")

    # 3. 生成双 Token
    access_token = create_access_token(user.id)
    refresh_token = create_refresh_token(user.id)

    # 4. 返回 Token
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token
    )
```

**安全注意事项：**
- 用户不存在和密码错误返回相同的错误信息（防止用户枚举）
- 使用 bcrypt 验证密码（慢速哈希，防止暴力破解）
- 限制登录尝试次数（使用限流中间件）

---

## Token 刷新机制

### 为什么需要刷新？

**问题：**
- Access Token 15分钟过期，用户需要频繁登录
- 如果 Access Token 过期时间长，安全风险高

**解决：Refresh Token**
- Access Token 短期（15分钟），频繁使用
- Refresh Token 长期（7天），只用于刷新

### 刷新端点实现

```python
@app.post("/refresh", response_model=TokenResponse)
async def refresh_token(refresh_token: str, db: Session = Depends(get_db)):
    """刷新 Access Token"""
    try:
        # 1. 验证 Refresh Token
        payload = jwt.decode(
            refresh_token,
            REFRESH_SECRET_KEY,
            algorithms=[ALGORITHM]
        )

        # 2. 检查 Token 类型
        if payload.get("type") != "refresh":
            raise HTTPException(400, "无效的 Token 类型")

        user_id = payload.get("user_id")

        # 3. 检查用户是否存在
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(401, "用户不存在")

        # 4. 生成新的双 Token
        new_access_token = create_access_token(user_id)
        new_refresh_token = create_refresh_token(user_id)

        return TokenResponse(
            access_token=new_access_token,
            refresh_token=new_refresh_token
        )

    except jwt.ExpiredSignatureError:
        raise HTTPException(401, "Refresh Token 已过期，请重新登录")

    except jwt.JWTError:
        raise HTTPException(401, "无效的 Refresh Token")
```

### 前端自动刷新

```javascript
// 前端拦截器（axios）
axios.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config;

    // 如果是 401 错误且未重试过
    if (error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        // 用 Refresh Token 刷新
        const refreshToken = localStorage.getItem('refresh_token');
        const response = await axios.post('/refresh', { refresh_token: refreshToken });

        // 保存新 Token
        const { access_token, refresh_token } = response.data;
        localStorage.setItem('access_token', access_token);
        localStorage.setItem('refresh_token', refresh_token);

        // 重试原请求
        originalRequest.headers['Authorization'] = `Bearer ${access_token}`;
        return axios(originalRequest);

      } catch (refreshError) {
        // Refresh Token 也过期了，跳转到登录页
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);
```

---

## 登出处理

### Token 黑名单实现

```python
from redis import Redis

redis_client = Redis(host='localhost', port=6379, db=0)


@app.post("/logout")
async def logout(
    refresh_token: str,
    current_user: dict = Depends(get_current_user)
):
    """用户登出"""
    try:
        # 1. 解析 Refresh Token
        payload = jwt.decode(
            refresh_token,
            REFRESH_SECRET_KEY,
            algorithms=[ALGORITHM]
        )

        # 2. 计算剩余有效时间
        exp = payload.get("exp")
        ttl = exp - int(datetime.utcnow().timestamp())

        if ttl > 0:
            # 3. 加入黑名单（只需存到过期时间）
            redis_client.setex(
                f"blacklist:refresh:{refresh_token}",
                ttl,
                "1"
            )

        return {"message": "登出成功"}

    except jwt.JWTError:
        raise HTTPException(401, "无效的 Refresh Token")


# 验证时检查黑名单
async def get_current_user(authorization: str = Header()):
    """验证 Access Token"""
    if not authorization.startswith("Bearer "):
        raise HTTPException(401, "无效的认证格式")

    token = authorization.replace("Bearer ", "")

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])

        # 检查 Token 类型
        if payload.get("type") != "access":
            raise HTTPException(400, "无效的 Token 类型")

        return payload

    except jwt.ExpiredSignatureError:
        raise HTTPException(401, "Token 已过期")

    except jwt.JWTError:
        raise HTTPException(401, "无效的 Token")


# 刷新时检查黑名单
@app.post("/refresh")
async def refresh_token(refresh_token: str):
    # 1. 检查黑名单
    if redis_client.exists(f"blacklist:refresh:{refresh_token}"):
        raise HTTPException(401, "Token 已被撤销，请重新登录")

    # 2. 验证并刷新...
    pass
```

### 批量撤销（修改密码时）

```python
@app.post("/change-password")
async def change_password(
    old_password: str,
    new_password: str,
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """修改密码"""
    user_id = current_user["user_id"]

    # 1. 查找用户
    user = db.query(User).filter(User.id == user_id).first()

    # 2. 验证旧密码
    if not pwd_context.verify(old_password, user.hashed_password):
        raise HTTPException(401, "旧密码错误")

    # 3. 更新密码
    user.hashed_password = pwd_context.hash(new_password)

    # 4. 递增 Token 版本号（批量撤销所有旧 Token）
    user.token_version = (user.token_version or 0) + 1

    db.commit()

    return {"message": "密码修改成功，请重新登录"}


# 生成 Token 时包含版本号
def create_access_token(user_id: int, token_version: int) -> str:
    payload = {
        "user_id": user_id,
        "token_version": token_version,  # 包含版本号
        "type": "access",
        "exp": datetime.utcnow() + timedelta(minutes=15)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


# 验证时检查版本号
async def get_current_user(authorization: str = Header(), db: Session = Depends(get_db)):
    token = authorization.replace("Bearer ", "")
    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])

    user_id = payload["user_id"]
    token_version = payload.get("token_version", 0)

    # 查询用户当前版本号
    user = db.query(User).filter(User.id == user_id).first()

    # 版本号不匹配，Token 已失效
    if token_version < (user.token_version or 0):
        raise HTTPException(401, "Token 已失效，请重新登录")

    return payload
```

---

## Session 管理策略

### 单设备登录

```python
# 用户表添加字段
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True)
    hashed_password = Column(String)
    current_refresh_token = Column(String, nullable=True)  # 当前有效的 Refresh Token


@app.post("/login")
async def login(request: LoginRequest, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == request.email).first()

    # 验证密码...

    # 生成新 Token
    refresh_token = create_refresh_token(user.id)

    # 保存到数据库（覆盖旧 Token）
    user.current_refresh_token = refresh_token
    db.commit()

    return TokenResponse(
        access_token=create_access_token(user.id),
        refresh_token=refresh_token
    )


@app.post("/refresh")
async def refresh_token(refresh_token: str, db: Session = Depends(get_db)):
    payload = jwt.decode(refresh_token, REFRESH_SECRET_KEY, algorithms=[ALGORITHM])
    user_id = payload["user_id"]

    user = db.query(User).filter(User.id == user_id).first()

    # 检查是否是当前有效的 Refresh Token
    if user.current_refresh_token != refresh_token:
        raise HTTPException(401, "Token 已失效（其他设备登录）")

    # 生成新 Token...
```

### 多设备登录

```python
# 创建 Session 表
class UserSession(Base):
    __tablename__ = "user_sessions"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    refresh_token = Column(String, unique=True)
    device_info = Column(String)  # 设备信息
    ip_address = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_used_at = Column(DateTime, default=datetime.utcnow)


@app.post("/login")
async def login(
    request: LoginRequest,
    user_agent: str = Header(None),
    x_forwarded_for: str = Header(None),
    db: Session = Depends(get_db)
):
    user = db.query(User).filter(User.email == request.email).first()

    # 验证密码...

    # 生成 Token
    refresh_token = create_refresh_token(user.id)

    # 创建 Session 记录
    session = UserSession(
        user_id=user.id,
        refresh_token=refresh_token,
        device_info=user_agent,
        ip_address=x_forwarded_for
    )
    db.add(session)
    db.commit()

    return TokenResponse(
        access_token=create_access_token(user.id),
        refresh_token=refresh_token
    )


@app.get("/sessions")
async def list_sessions(
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """查看所有登录设备"""
    sessions = db.query(UserSession).filter(
        UserSession.user_id == current_user["user_id"]
    ).all()

    return {
        "sessions": [
            {
                "id": s.id,
                "device_info": s.device_info,
                "ip_address": s.ip_address,
                "last_used_at": s.last_used_at
            }
            for s in sessions
        ]
    }


@app.delete("/sessions/{session_id}")
async def revoke_session(
    session_id: int,
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """撤销指定设备的登录"""
    session = db.query(UserSession).filter(
        UserSession.id == session_id,
        UserSession.user_id == current_user["user_id"]
    ).first()

    if not session:
        raise HTTPException(404, "Session 不存在")

    # 将 Refresh Token 加入黑名单
    redis_client.setex(
        f"blacklist:refresh:{session.refresh_token}",
        7 * 24 * 3600,  # 7天
        "1"
    )

    # 删除 Session 记录
    db.delete(session)
    db.commit()

    return {"message": "设备已登出"}
```

---

## 在 AI Agent API 中的应用

### 完整认证系统

```python
"""
AI Agent API 完整认证系统
演示：注册 → 登录 → 调用 AI Agent → 刷新 → 登出
"""

from fastapi import FastAPI, Depends, HTTPException, Header
from sqlalchemy.orm import Session

app = FastAPI()


# ===== 1. 注册 =====
@app.post("/register")
async def register(request: RegisterRequest, db: Session = Depends(get_db)):
    # 检查邮箱...
    # 哈希密码...
    # 创建用户...
    pass


# ===== 2. 登录 =====
@app.post("/login")
async def login(request: LoginRequest, db: Session = Depends(get_db)):
    # 验证密码...
    # 生成双 Token...
    pass


# ===== 3. AI Agent 对话（需要认证）=====
@app.post("/agent/chat")
async def chat(
    message: str,
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """AI Agent 对话端点"""
    user_id = current_user["user_id"]

    # 加载对话历史
    conversation = await db.get_conversation(user_id)

    # 调用 AI Agent
    response = await agent.run(message, conversation)

    # 保存对话历史
    await db.save_message(user_id, message, response)

    return {"response": response}


# ===== 4. 刷新 Token =====
@app.post("/refresh")
async def refresh_token(refresh_token: str):
    # 检查黑名单...
    # 验证 Refresh Token...
    # 生成新 Token...
    pass


# ===== 5. 登出 =====
@app.post("/logout")
async def logout(refresh_token: str):
    # 加入黑名单...
    pass
```

---

## 总结

**认证流程的核心：**
1. **注册**：密码哈希（bcrypt）→ 存储到数据库
2. **登录**：验证密码 → 生成双 Token
3. **刷新**：验证 Refresh Token → 生成新 Token
4. **登出**：Refresh Token 加入黑名单
5. **Session 管理**：单设备 vs 多设备

**关键点：**
- 密码必须哈希存储（bcrypt）
- 双 Token 机制（Access + Refresh）
- Refresh Token 使用黑名单
- 修改密码时批量撤销旧 Token
- 支持多设备登录管理

通过完整的认证流程设计，你的 AI Agent API 就有了安全可靠的身份验证系统！
