# 双重类比

用前端开发和日常生活的概念，理解进阶 Prompt 技巧。

---

## 类比1：Few-shot = 给新员工看工作样例

### 前端类比：组件文档中的示例代码

```jsx
// 组件库文档通常会给出使用示例
// 开发者看了示例就知道怎么用

// 示例1：基础用法
<Button type="primary">提交</Button>

// 示例2：带图标
<Button type="primary" icon={<SearchOutlined />}>搜索</Button>

// 示例3：加载状态
<Button type="primary" loading>加载中</Button>

// 看了这些示例，你就知道 Button 组件怎么用了
```

**类比关系：**
- 组件文档的示例 = Few-shot 的示例
- 开发者看示例学会用法 = LLM 看示例学会输出格式
- 示例越清晰，使用越正确 = 示例越好，LLM 输出越准确

### 日常生活类比：新员工入职培训

```
场景：新员工第一天上班，不知道周报怎么写

❌ 只给规则（Zero-shot）：
"周报要包含本周工作、下周计划、遇到的问题"
→ 新员工还是不知道具体格式

✅ 给几个样例（Few-shot）：
"这是小王上周的周报，这是小李的，你参考着写"
→ 新员工一看就懂了
```

**核心洞察：** 人类通过模仿学习，LLM 也是。

---

## 类比2：Chain-of-Thought = 数学题要写解题步骤

### 前端类比：代码 Review 要求写注释说明思路

```javascript
// ❌ 直接给结果（没有 CoT）
const result = data.filter(x => x.status === 'active' && x.score > 80)
                   .sort((a, b) => b.score - a.score)
                   .slice(0, 10);

// ✅ 分步骤写，每步有注释（有 CoT）
// 步骤1：筛选活跃用户
const activeUsers = data.filter(x => x.status === 'active');

// 步骤2：筛选高分用户（>80分）
const highScoreUsers = activeUsers.filter(x => x.score > 80);

// 步骤3：按分数降序排列
const sortedUsers = highScoreUsers.sort((a, b) => b.score - a.score);

// 步骤4：取前10名
const result = sortedUsers.slice(0, 10);

// 分步写更容易发现错误，也更容易维护
```

**类比关系：**
- 代码分步骤写 = CoT 分步骤推理
- 每步有注释 = 每步有解释
- 更容易发现错误 = 推理更准确

### 日常生活类比：数学考试要写解题过程

```
题目：小明有100元，买了3本书每本15元，又买了2支笔每支8元，还剩多少钱？

❌ 直接写答案（没有 CoT）：
答：39元
（阅卷老师：怎么算的？万一算错了呢？）

✅ 写解题步骤（有 CoT）：
解：
1. 书的总价：3 × 15 = 45元
2. 笔的总价：2 × 8 = 16元
3. 总花费：45 + 16 = 61元
4. 剩余：100 - 61 = 39元
答：还剩39元

（每一步都能检查，更不容易出错）
```

**核心洞察：** 分步骤思考，每一步都可验证，最终结果更可靠。

---

## 类比3：结构化输出 = API 返回 JSON 而不是纯文本

### 前端类比：后端 API 返回格式化数据

```javascript
// ❌ 后端返回纯文本（非结构化）
const response = "用户张三，年龄25岁，余额1000元，VIP用户";
// 前端怎么解析？正则？太痛苦了...

// ✅ 后端返回 JSON（结构化）
const response = {
  name: "张三",
  age: 25,
  balance: 1000,
  isVip: true
};
// 前端直接用：response.name, response.balance
```

**类比关系：**
- 后端返回 JSON = LLM 输出 JSON
- 前端直接解析使用 = 程序直接解析使用
- 格式固定可预测 = 输出稳定可处理

### 日常生活类比：填表格 vs 写作文

```
场景：医院挂号

❌ 写作文形式（非结构化）：
"我叫张三，今年25岁，男性，身份证号是xxx，
我想挂内科的号，手机号是138xxx"
→ 工作人员要从中提取信息，容易出错

✅ 填表格形式（结构化）：
姓名：张三
年龄：25
性别：男
身份证：xxx
科室：内科
手机：138xxx
→ 信息清晰，直接录入系统
```

**核心洞察：** 结构化数据更容易被系统处理。

---

## 类比4：RAG + 进阶技巧 = 开卷考试 + 答题技巧

### 前端类比：带文档的编程 + 代码规范

```javascript
// RAG = 可以查文档
// 进阶技巧 = 遵循代码规范

// 场景：实现一个功能

// 1. 查文档（RAG 检索）
// → 找到相关 API 文档和示例

// 2. 参考示例写代码（Few-shot）
// → 按照文档示例的风格写

// 3. 分步实现（CoT）
// → 先处理数据，再渲染，最后绑定事件

// 4. 返回标准格式（结构化输出）
// → 函数返回 { success: boolean, data: any, error?: string }
```

### 日常生活类比：开卷考试的答题策略

```
开卷考试 = RAG（可以查资料）
答题技巧 = 进阶 Prompt 技巧

好的答题策略：
1. 先看题目，明确要找什么（理解 Query）
2. 翻书找到相关内容（检索 Context）
3. 参考标准答案的格式（Few-shot）
4. 分步骤组织答案（CoT）
5. 按要求的格式作答（结构化输出）

只会翻书不会答题 = 只有 RAG 没有进阶技巧
→ 找到了资料，但答案质量不高

会翻书也会答题 = RAG + 进阶技巧
→ 找到资料，还能组织出高质量答案
```

---

## 类比总结表

| 进阶技巧 | 前端类比 | 日常生活类比 |
|---------|---------|-------------|
| **Few-shot** | 组件文档的示例代码 | 给新员工看工作样例 |
| **Chain-of-Thought** | 代码分步骤写+注释 | 数学题写解题过程 |
| **结构化输出** | API 返回 JSON | 填表格而不是写作文 |
| **RAG + 进阶技巧** | 查文档 + 遵循规范 | 开卷考试 + 答题技巧 |

---

## 一句话记忆

- **Few-shot**：给 LLM 看几个"满分作业"，它就会照着写
- **CoT**：让 LLM 像学生一样"写出解题步骤"，而不是直接写答案
- **结构化输出**：让 LLM 像后端 API 一样返回 JSON，而不是随意的文本

---

**下一步：** [06_反直觉点](./06_反直觉点.md) - 避开常见误区
