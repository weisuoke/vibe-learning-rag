# 最小可用知识

掌握以下内容，就能开始使用 OutputParser 构建结构化输出应用。

---

## 4.1 核心知识：with_structured_output()（2025+ 推荐）

**这是你需要掌握的 80% 核心**

### 基本用法

```python
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field

# 1. 定义 Pydantic 模型
class Person(BaseModel):
    name: str = Field(description="人名")
    age: int = Field(description="年龄", ge=0, le=150)
    email: str = Field(description="邮箱地址")

# 2. 创建支持结构化输出的 LLM
llm = ChatOpenAI(model="gpt-4o")
structured_llm = llm.with_structured_output(Person)

# 3. 调用并获取结构化结果
result = structured_llm.invoke("Alice is 25 years old, email: alice@example.com")
print(result)  # Person(name='Alice', age=25, email='alice@example.com')
print(type(result))  # <class '__main__.Person'>
```

### 为什么这是最小可用？

- ✅ **最简单**：只需 3 步（定义模型 → 包装 LLM → 调用）
- ✅ **最现代**：利用模型原生能力（OpenAI、Anthropic 2025+ 支持）
- ✅ **最可靠**：不需要手动解析 JSON，模型直接返回结构化数据
- ✅ **最高效**：无需额外 LLM 调用修复错误

---

## 4.2 Pydantic 模型定义（必须掌握）

### 基础字段类型

```python
from pydantic import BaseModel, Field
from typing import List, Optional

class Product(BaseModel):
    # 必填字段
    name: str = Field(description="产品名称")
    price: float = Field(description="价格", gt=0)

    # 可选字段
    description: Optional[str] = Field(None, description="产品描述")

    # 列表字段
    tags: List[str] = Field(default_factory=list, description="标签列表")

    # 带约束的字段
    stock: int = Field(description="库存数量", ge=0)
```

### 字段约束（Field 参数）

| 参数 | 说明 | 示例 |
|------|------|------|
| `description` | 字段说明（LLM 会读取） | `Field(description="用户年龄")` |
| `ge` / `gt` | 大于等于 / 大于 | `Field(ge=0)` 非负数 |
| `le` / `lt` | 小于等于 / 小于 | `Field(le=150)` 年龄上限 |
| `min_length` / `max_length` | 字符串长度 | `Field(min_length=1)` 非空 |
| `default` | 默认值 | `Field(default="未知")` |
| `default_factory` | 默认值工厂 | `Field(default_factory=list)` |

---

## 4.3 错误处理（基础）

### 验证错误捕获

```python
from pydantic import ValidationError

try:
    result = structured_llm.invoke("Extract person info: Bob")
except ValidationError as e:
    print(f"验证失败: {e}")
    # 处理验证错误
```

### 常见错误类型

1. **字段缺失**：LLM 没有提取到必填字段
2. **类型错误**：LLM 返回的类型不匹配（如字符串 "25" vs 整数 25）
3. **约束违反**：值不满足 Field 约束（如年龄 -5）

---

## 4.4 实际应用场景（快速上手）

### 场景 1：从文本提取结构化信息

```python
from pydantic import BaseModel
from langchain_openai import ChatOpenAI

class Contact(BaseModel):
    name: str
    phone: str
    email: str

llm = ChatOpenAI(model="gpt-4o")
extractor = llm.with_structured_output(Contact)

text = "请联系张三，电话 13800138000，邮箱 zhangsan@example.com"
contact = extractor.invoke(f"从以下文本提取联系信息：{text}")
print(contact)
# Contact(name='张三', phone='13800138000', email='zhangsan@example.com')
```

### 场景 2：RAG 元数据提取

```python
class DocumentMetadata(BaseModel):
    title: str
    author: str
    publish_date: str
    keywords: List[str]

metadata_extractor = llm.with_structured_output(DocumentMetadata)

doc_text = "《Python 编程》作者：Guido van Rossum，2024年出版..."
metadata = metadata_extractor.invoke(f"提取文档元数据：{doc_text}")
```

### 场景 3：Agent 工具响应

```python
class WeatherResponse(BaseModel):
    city: str
    temperature: float
    condition: str
    humidity: int

weather_formatter = llm.with_structured_output(WeatherResponse)

# Agent 调用天气 API 后格式化响应
raw_response = "北京今天晴天，温度 15 度，湿度 60%"
formatted = weather_formatter.invoke(f"格式化天气信息：{raw_response}")
```

---

## 4.5 何时使用传统 OutputParser？

**只在以下情况使用 PydanticOutputParser**：

1. ❌ 模型不支持原生结构化输出（如 GPT-3.5-turbo 旧版本）
2. ❌ 需要兼容旧代码
3. ❌ 使用开源模型（如 Llama 2）

**示例**：

```python
from langchain.output_parsers import PydanticOutputParser
from langchain.prompts import PromptTemplate

parser = PydanticOutputParser(pydantic_object=Person)

# 需要手动注入格式指令
prompt = PromptTemplate(
    template="提取人物信息：{text}\n\n{format_instructions}",
    input_variables=["text"],
    partial_variables={"format_instructions": parser.get_format_instructions()}
)

chain = prompt | llm | parser
```

---

## 这些知识足以

- ✅ 构建基础的结构化输出应用
- ✅ 在 RAG 系统中提取元数据
- ✅ 在 Agent 中格式化工具响应
- ✅ 处理 80% 的常见场景
- ✅ 为后续学习高级特性打基础

---

## 下一步学习

掌握最小可用知识后，可以深入学习：
- 嵌套 Pydantic 模型（复杂结构）
- OutputFixingParser（自动修复错误）
- RetryOutputParser（重试机制）
- 批量处理和流式输出
- 成本优化策略

---

**记住**：80% 的场景只需要 `with_structured_output()` + 简单 Pydantic 模型，不要过度设计！
