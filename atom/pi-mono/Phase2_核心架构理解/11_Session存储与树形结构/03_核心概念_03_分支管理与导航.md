# 核心概念 03：分支管理与导航

> 深入理解 Pi-mono 如何实现会话分支、分支摘要和交互式导航

---

## 分支的概念

### 什么是分支？

**分支（Branch）** 是从某个历史节点开始的新对话路径。

**类比 Git 分支：**

```
main:    A --- B --- C --- D
                \
feature:         E --- F
```

**会话分支：**

```
用户: "Hello"
  └─ AI: "Hi there!"
      ├─ 用户: "How are you?"  ← 主路径
      │   └─ AI: "I'm good"
      └─ 用户: "What's your name?"  ← 分支
          └─ AI: "I'm Claude"
```

### 为什么需要分支？

**实际场景：**

1. **探索不同方向**
   - 用户想尝试不同的问题
   - 对比不同的 AI 响应

2. **回溯历史**
   - 回到之前的某个状态
   - 从那里重新开始

3. **保留多个路径**
   - 不丢失任何对话历史
   - 可以随时切换

**示例：**

```
用户: "帮我写一个排序函数"
  └─ AI: "好的，我用快速排序实现"
      ├─ 用户: "继续"  ← 主路径
      │   └─ AI: [快速排序代码]
      └─ 用户: "用归并排序"  ← 分支
          └─ AI: [归并排序代码]
```

---

## 分支创建机制

### Leaf Pointer（叶子指针）

**核心概念：** Pi-mono 使用一个"叶子指针"指向当前活跃的节点。

```typescript
class SessionManager {
  private leafId: string;  // 当前叶子节点的 ID

  constructor() {
    this.leafId = 'root';  // 初始指向根节点
  }
}
```

**叶子指针的作用：**
- 指示当前对话的位置
- 新消息总是添加到叶子节点下
- 分支时移动叶子指针

### branch(branchFromId) 方法

**功能：** 从指定节点创建分支

**实现原理：**

```typescript
class SessionManager {
  private leafId: string;

  // 创建分支
  branch(branchFromId: string): void {
    // 验证节点存在
    const entry = this.entryMap.get(branchFromId);
    if (!entry) {
      throw new Error(`Entry not found: ${branchFromId}`);
    }

    // 移动叶子指针
    this.leafId = branchFromId;

    console.log(`Branched from ${branchFromId}`);
  }

  // 添加新消息（总是添加到叶子节点下）
  addMessage(content: string, type: 'user' | 'assistant'): string {
    const id = this.generateId();
    const entry: SessionEntry = {
      type,
      id,
      parentId: this.leafId,  // 父节点是当前叶子
      timestamp: new Date().toISOString(),
      content
    };

    this.appendEntry(entry);

    // 更新叶子指针
    this.leafId = id;

    return id;
  }
}
```

**使用示例：**

```typescript
const manager = new SessionManager();

// 初始对话
const msg1 = manager.addMessage('Hello', 'user');
// leafId = msg1

const msg2 = manager.addMessage('Hi there!', 'assistant');
// leafId = msg2

const msg3 = manager.addMessage('How are you?', 'user');
// leafId = msg3

// 创建分支：回到 msg2
manager.branch(msg2);
// leafId = msg2

const msg4 = manager.addMessage('What\'s your name?', 'user');
// leafId = msg4
// msg4 的 parentId = msg2
```

**树形结构：**

```
root
└── msg1 (user: "Hello")
    └── msg2 (assistant: "Hi there!")
        ├── msg3 (user: "How are you?")
        └── msg4 (user: "What's your name?")  ← 分支
```

### 分支的本质

**关键理解：**

1. **分支不创建新文件**
   - 所有分支都在同一个 JSONL 文件中
   - 通过 id/parentId 关系表示

2. **分支只是移动指针**
   - `branch()` 方法只是改变 `leafId`
   - 不修改任何现有数据

3. **新消息自动形成分支**
   - 新消息的 `parentId` 指向当前 `leafId`
   - 如果该节点已有子节点，自动形成分支

---

## 分支摘要（Branch Summary）

### 为什么需要摘要？

**问题：** 当用户创建分支时，可能忘记之前的对话内容。

**解决方案：** 使用 LLM 生成分支摘要，帮助用户回忆上下文。

**示例：**

```
用户: "帮我写一个排序函数"
AI: "好的，我用快速排序实现"
AI: [快速排序代码]
用户: "测试一下"
AI: [测试结果]

--- 用户创建分支，回到"好的，我用快速排序实现" ---

分支摘要: "用户请求排序函数，AI 提议使用快速排序"
```

### LLM 生成摘要

**实现原理：**

```typescript
class BranchSummarizer {
  constructor(private llmClient: LLMClient) {}

  async generateSummary(
    branchPoint: SessionEntry,
    context: SessionEntry[]
  ): Promise<string> {
    // 构建 prompt
    const prompt = this.buildSummaryPrompt(branchPoint, context);

    // 调用 LLM
    const response = await this.llmClient.complete({
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 200
    });

    return response.content;
  }

  private buildSummaryPrompt(
    branchPoint: SessionEntry,
    context: SessionEntry[]
  ): string {
    const contextText = context
      .map(e => `${e.type}: ${e.content || e.type}`)
      .join('\n');

    return `
请为以下对话生成一个简短的摘要（1-2 句话）：

${contextText}

分支点: ${branchPoint.content || branchPoint.type}

摘要:
    `.trim();
  }
}
```

### 摘要的存储

**摘要作为特殊条目存储：**

```typescript
interface BranchSummaryEntry extends SessionEntryBase {
  type: 'branch_summary';
  summary: string;
  branchFromId: string;
  readFiles?: string[];      // 涉及的文件
  modifiedFiles?: string[];  // 修改的文件
}
```

**存储示例：**

```jsonl
{"type":"user","id":"msg1","parentId":"root","content":"Hello"}
{"type":"assistant","id":"msg2","parentId":"msg1","content":"Hi"}
{"type":"user","id":"msg3","parentId":"msg2","content":"How are you?"}
{"type":"branch_summary","id":"sum1","parentId":"msg2","branchFromId":"msg2","summary":"User greeted, AI responded"}
{"type":"user","id":"msg4","parentId":"msg2","content":"What's your name?"}
```

### branchWithSummary() 方法

**完整的分支创建流程：**

```typescript
class SessionManager {
  async branchWithSummary(branchFromId: string): Promise<string> {
    // 1. 获取分支点的上下文
    const context = this.getBranch(branchFromId);

    // 2. 生成摘要
    const summarizer = new BranchSummarizer(this.llmClient);
    const summary = await summarizer.generateSummary(
      this.entryMap.get(branchFromId)!,
      context
    );

    // 3. 收集文件信息
    const { readFiles, modifiedFiles } = this.collectFileInfo(context);

    // 4. 添加摘要条目
    const summaryId = this.addEntry({
      type: 'branch_summary',
      parentId: branchFromId,
      summary,
      branchFromId,
      readFiles,
      modifiedFiles
    });

    // 5. 移动叶子指针
    this.branch(branchFromId);

    return summaryId;
  }

  private collectFileInfo(context: SessionEntry[]): {
    readFiles: string[];
    modifiedFiles: string[];
  } {
    const readFiles = new Set<string>();
    const modifiedFiles = new Set<string>();

    for (const entry of context) {
      if (entry.type === 'tool_use') {
        if (entry.name === 'read_file') {
          readFiles.add(entry.input.path);
        } else if (entry.name === 'write_file' || entry.name === 'edit_file') {
          modifiedFiles.add(entry.input.path);
        }
      }
    }

    return {
      readFiles: Array.from(readFiles),
      modifiedFiles: Array.from(modifiedFiles)
    };
  }
}
```

---

## 分支导航

### 树形可视化

**将树转换为可视化字符串：**

```typescript
interface VisualTreeNode {
  id: string;
  label: string;
  children: VisualTreeNode[];
}

class TreeVisualizer {
  visualize(tree: SessionTreeNode): string {
    return this.renderNode(tree, '', true);
  }

  private renderNode(
    node: SessionTreeNode,
    prefix: string,
    isLast: boolean
  ): string {
    const connector = isLast ? '└── ' : '├── ';
    const label = this.getNodeLabel(node.entry);

    let result = prefix + connector + label + '\n';

    const childPrefix = prefix + (isLast ? '    ' : '│   ');
    const children = node.children;

    for (let i = 0; i < children.length; i++) {
      const isLastChild = i === children.length - 1;
      result += this.renderNode(children[i], childPrefix, isLastChild);
    }

    return result;
  }

  private getNodeLabel(entry: SessionEntry): string {
    if (entry.type === 'session') {
      return `[Session] ${entry.id}`;
    } else if (entry.type === 'user') {
      return `[User] ${entry.content?.substring(0, 30)}...`;
    } else if (entry.type === 'assistant') {
      return `[AI] ${entry.content?.substring(0, 30)}...`;
    } else if (entry.type === 'branch_summary') {
      return `[Summary] ${entry.summary}`;
    } else {
      return `[${entry.type}] ${entry.id}`;
    }
  }
}
```

**输出示例：**

```
└── [Session] root
    └── [User] Hello
        └── [AI] Hi there!
            ├── [User] How are you?
            │   └── [AI] I'm good
            └── [Summary] User greeted, AI responded
                └── [User] What's your name?
                    └── [AI] I'm Claude
```

### 交互式导航

**提供交互式的分支选择：**

```typescript
class InteractiveBranchNavigator {
  constructor(private manager: SessionManager) {}

  async navigate(): Promise<void> {
    while (true) {
      // 显示当前位置
      this.showCurrentPosition();

      // 显示可用选项
      const options = this.getNavigationOptions();
      this.showOptions(options);

      // 获取用户输入
      const choice = await this.getUserChoice();

      if (choice === 'quit') {
        break;
      }

      // 执行导航
      this.executeNavigation(choice);
    }
  }

  private showCurrentPosition(): void {
    const branch = this.manager.getBranch(this.manager.getLeafId());
    console.log('\n=== Current Position ===');
    for (const entry of branch) {
      console.log(`${entry.type}: ${entry.content || entry.id}`);
    }
  }

  private getNavigationOptions(): NavigationOption[] {
    const leafId = this.manager.getLeafId();
    const children = this.manager.getChildren(leafId);
    const parent = this.manager.getParent(leafId);

    const options: NavigationOption[] = [];

    // 可以前进到子节点
    for (const child of children) {
      options.push({
        type: 'forward',
        targetId: child.id,
        label: `Forward to: ${child.content || child.type}`
      });
    }

    // 可以后退到父节点
    if (parent) {
      options.push({
        type: 'backward',
        targetId: parent.id,
        label: `Back to: ${parent.content || parent.type}`
      });
    }

    // 可以创建新分支
    options.push({
      type: 'branch',
      targetId: leafId,
      label: 'Create new branch here'
    });

    return options;
  }

  private executeNavigation(choice: NavigationOption): void {
    if (choice.type === 'forward' || choice.type === 'backward') {
      this.manager.branch(choice.targetId);
    } else if (choice.type === 'branch') {
      this.manager.branchWithSummary(choice.targetId);
    }
  }
}
```

---

## 手写实现：完整的分支管理器

```typescript
import { randomBytes } from 'crypto';

interface SessionEntry {
  type: string;
  id: string;
  parentId: string | null;
  timestamp: string;
  content?: string;
  [key: string]: any;
}

interface BranchInfo {
  id: string;
  summary?: string;
  depth: number;
  messageCount: number;
}

class BranchManager {
  private entries: SessionEntry[] = [];
  private entryMap = new Map<string, SessionEntry>();
  private childrenMap = new Map<string, SessionEntry[]>();
  private leafId: string;
  private usedIds = new Set<string>();

  constructor() {
    // 创建根节点
    const rootId = this.generateId();
    const root: SessionEntry = {
      type: 'session',
      id: rootId,
      parentId: null,
      timestamp: new Date().toISOString()
    };

    this.addEntryInternal(root);
    this.leafId = rootId;
  }

  private generateId(): string {
    let id: string;
    do {
      id = randomBytes(4).toString('hex');
    } while (this.usedIds.has(id));

    this.usedIds.add(id);
    return id;
  }

  private addEntryInternal(entry: SessionEntry): void {
    this.entries.push(entry);
    this.entryMap.set(entry.id, entry);

    if (entry.parentId !== null) {
      if (!this.childrenMap.has(entry.parentId)) {
        this.childrenMap.set(entry.parentId, []);
      }
      this.childrenMap.get(entry.parentId)!.push(entry);
    }
  }

  // 添加消息
  addMessage(content: string, type: 'user' | 'assistant'): string {
    const id = this.generateId();
    const entry: SessionEntry = {
      type,
      id,
      parentId: this.leafId,
      timestamp: new Date().toISOString(),
      content
    };

    this.addEntryInternal(entry);
    this.leafId = id;

    return id;
  }

  // 创建分支
  branch(branchFromId: string): void {
    const entry = this.entryMap.get(branchFromId);
    if (!entry) {
      throw new Error(`Entry not found: ${branchFromId}`);
    }

    this.leafId = branchFromId;
    console.log(`Branched from ${branchFromId}`);
  }

  // 创建分支并添加摘要
  branchWithSummary(branchFromId: string, summary: string): string {
    const summaryId = this.generateId();
    const summaryEntry: SessionEntry = {
      type: 'branch_summary',
      id: summaryId,
      parentId: branchFromId,
      timestamp: new Date().toISOString(),
      summary,
      branchFromId
    };

    this.addEntryInternal(summaryEntry);
    this.branch(branchFromId);

    return summaryId;
  }

  // 获取当前叶子 ID
  getLeafId(): string {
    return this.leafId;
  }

  // 获取分支（从叶子到根）
  getBranch(fromId: string): SessionEntry[] {
    const branch: SessionEntry[] = [];
    let currentId: string | null = fromId;

    while (currentId !== null) {
      const entry = this.entryMap.get(currentId);
      if (!entry) break;

      branch.push(entry);
      currentId = entry.parentId;
    }

    return branch.reverse();
  }

  // 获取子节点
  getChildren(id: string): SessionEntry[] {
    return this.childrenMap.get(id) || [];
  }

  // 获取父节点
  getParent(id: string): SessionEntry | null {
    const entry = this.entryMap.get(id);
    if (!entry || entry.parentId === null) {
      return null;
    }
    return this.entryMap.get(entry.parentId) || null;
  }

  // 获取所有分支信息
  getAllBranches(): BranchInfo[] {
    const branches: BranchInfo[] = [];
    const leaves = this.getLeaves();

    for (const leaf of leaves) {
      const branch = this.getBranch(leaf.id);
      const summary = this.findBranchSummary(leaf.id);

      branches.push({
        id: leaf.id,
        summary: summary?.summary,
        depth: branch.length,
        messageCount: branch.filter(e => e.type === 'user' || e.type === 'assistant').length
      });
    }

    return branches;
  }

  private getLeaves(): SessionEntry[] {
    const leaves: SessionEntry[] = [];

    for (const entry of this.entries) {
      const children = this.childrenMap.get(entry.id);
      if (!children || children.length === 0) {
        leaves.push(entry);
      }
    }

    return leaves;
  }

  private findBranchSummary(leafId: string): SessionEntry | undefined {
    const branch = this.getBranch(leafId);
    return branch.find(e => e.type === 'branch_summary');
  }

  // 可视化树
  visualizeTree(): string {
    const root = this.entries.find(e => e.parentId === null);
    if (!root) return '';

    return this.visualizeNode(root, '', true);
  }

  private visualizeNode(entry: SessionEntry, prefix: string, isLast: boolean): string {
    const connector = isLast ? '└── ' : '├── ';
    const label = this.getNodeLabel(entry);

    let result = prefix + connector + label + '\n';

    const children = this.childrenMap.get(entry.id) || [];
    const childPrefix = prefix + (isLast ? '    ' : '│   ');

    for (let i = 0; i < children.length; i++) {
      const isLastChild = i === children.length - 1;
      result += this.visualizeNode(children[i], childPrefix, isLastChild);
    }

    return result;
  }

  private getNodeLabel(entry: SessionEntry): string {
    const marker = entry.id === this.leafId ? ' ← current' : '';

    if (entry.type === 'session') {
      return `[Session]${marker}`;
    } else if (entry.type === 'user') {
      return `[User] ${entry.content?.substring(0, 30)}...${marker}`;
    } else if (entry.type === 'assistant') {
      return `[AI] ${entry.content?.substring(0, 30)}...${marker}`;
    } else if (entry.type === 'branch_summary') {
      return `[Summary] ${entry.summary}${marker}`;
    } else {
      return `[${entry.type}]${marker}`;
    }
  }
}
```

### 使用示例

```typescript
const manager = new BranchManager();

// 初始对话
manager.addMessage('Hello', 'user');
manager.addMessage('Hi there!', 'assistant');
manager.addMessage('How are you?', 'user');
const msg3 = manager.getLeafId();
manager.addMessage('I\'m good', 'assistant');

// 可视化当前树
console.log(manager.visualizeTree());

// 创建分支
const msg2 = manager.getParent(msg3)!.id;
manager.branchWithSummary(msg2, 'User greeted, AI responded');
manager.addMessage('What\'s your name?', 'user');
manager.addMessage('I\'m Claude', 'assistant');

// 再次可视化
console.log(manager.visualizeTree());

// 获取所有分支
const branches = manager.getAllBranches();
console.log('All branches:', branches);
```

---

## 2025-2026 模式

### Git-like Branching

**Pi-mono 的分支机制借鉴了 Git：**

| Git | Pi-mono Session |
|-----|-----------------|
| `git branch` | `branch(id)` |
| `git checkout` | 移动 leafId |
| `git log` | `getBranch(id)` |
| `git merge` | 不支持（保持简单） |

**参考：**
- [GitHub - Moonsong-Labs/agent-prompttrain](https://github.com/Moonsong-Labs/agent-prompttrain) - Claude Code management with Git-like branching

### Non-linear Conversation Trees

**2025-2026 年的 AI 对话系统普遍支持非线性对话：**

**示例项目：**

1. **Branch-Your-LLM (Perception)**
   - 支持多方向对话流
   - 用户可以探索不同的对话路径
   - [GitHub - princepal9120/Perception](https://github.com/princepal9120/perception)

2. **LobeHub Branch Conversations**
   - 分支对话功能
   - 可视化对话树
   - [GitHub - lobehub/lobehub](https://github.com/lobehub/lobehub)

**共同特点：**
- 树形结构存储对话
- 支持分支创建和切换
- 提供可视化界面

### 2025-2026 最佳实践

**1. 分支摘要自动生成**

```typescript
// 使用 LLM 自动生成摘要
async function autoGenerateSummary(context: SessionEntry[]): Promise<string> {
  const prompt = buildSummaryPrompt(context);
  const response = await llm.complete(prompt);
  return response.content;
}
```

**2. 分支可视化**

```typescript
// 使用 ASCII 树或 Web UI 可视化
function visualizeBranches(tree: SessionTreeNode): string {
  return renderTree(tree);
}
```

**3. 分支导航快捷键**

```typescript
// 提供快捷键快速导航
const shortcuts = {
  'Ctrl+B': 'branch',
  'Ctrl+[': 'backward',
  'Ctrl+]': 'forward'
};
```

---

## 在 Pi-mono 中的应用

### SessionManager 的分支方法

**文件位置：** `sourcecode/pi-mono/packages/coding-agent/src/core/session-manager.ts`

**核心方法：**

```typescript
// 创建分支
branch(branchFromId: string): void {
  const entry = this.entryMap.get(branchFromId);
  if (!entry) {
    throw new Error(`Entry not found: ${branchFromId}`);
  }

  this.leafId = branchFromId;
  this.flush();
}

// 创建分支并生成摘要
async branchWithSummary(branchFromId: string): Promise<void> {
  // 1. 获取上下文
  const context = this.getBranch(branchFromId);

  // 2. 生成摘要
  const summary = await this.generateBranchSummary(context);

  // 3. 添加摘要条目
  this.appendMessage({
    type: 'branch_summary',
    parentId: branchFromId,
    summary,
    branchFromId,
    readFiles: this.collectReadFiles(context),
    modifiedFiles: this.collectModifiedFiles(context)
  });

  // 4. 移动叶子指针
  this.branch(branchFromId);
}
```

### Branch Summarization

**文件位置：** `sourcecode/pi-mono/packages/coding-agent/src/core/compaction/branch-summarization.ts`

**核心逻辑：**

```typescript
export async function generateBranchSummary(
  entries: SessionEntry[],
  llmClient: LLMClient
): Promise<string> {
  // 收集需要摘要的内容
  const messages = entries.filter(e =>
    e.type === 'user' || e.type === 'assistant'
  );

  // 构建 prompt
  const prompt = buildSummaryPrompt(messages);

  // 调用 LLM
  const response = await llmClient.complete({
    messages: [{ role: 'user', content: prompt }],
    max_tokens: 200
  });

  return response.content;
}
```

---

## 关键要点总结

1. **分支概念**：从历史节点开始的新对话路径
2. **Leaf Pointer**：指向当前活跃节点的指针
3. **branch() 方法**：移动叶子指针，不修改数据
4. **分支摘要**：使用 LLM 生成上下文摘要
5. **树形可视化**：ASCII 树或 Web UI
6. **Git-like**：借鉴 Git 的分支机制
7. **非线性对话**：2025-2026 年的主流模式

---

**下一步**：理解最小可用知识 → `04_最小可用.md`
