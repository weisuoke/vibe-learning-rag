# 化骨绵掌

> 10个2分钟知识卡片，系统掌握路由与依赖注入

---

## 卡片1：路由装饰器的本质

**一句话：** 路由装饰器是将 URL 模式映射到处理函数的声明式语法糖。

**举例：**
```python
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}

# 等价于
def get_user(user_id: int):
    return {"user_id": user_id}

app.add_api_route("/users/{user_id}", get_user, methods=["GET"])
```

**应用：** 在 AI Agent 后端中，用装饰器快速定义对话接口、文档管理接口等。

---

## 卡片2：路径参数 vs 查询参数

**一句话：** 路径参数标识资源（必需），查询参数过滤资源（可选）。

**举例：**
```python
# 路径参数：标识具体用户（必需）
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    pass

# 查询参数：过滤用户列表（可选）
@app.get("/users")
async def list_users(role: str = None, limit: int = 10):
    pass
```

**RESTful 原则：**
- `/users/123` - 获取用户123
- `/users?role=admin` - 获取管理员用户列表

**应用：** 设计 RESTful API 时，用路径参数定位资源，用查询参数筛选和分页。

---

## 卡片3：Depends() 的工作原理

**一句话：** Depends() 告诉 FastAPI 在调用路由函数前先执行依赖函数，并将结果注入。

**举例：**
```python
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users")
async def list_users(db: Session = Depends(get_db)):
    # FastAPI 自动执行：
    # 1. 调用 get_db()
    # 2. 获取 db
    # 3. 注入到 list_users
    # 4. 执行 list_users
    # 5. 执行 get_db 的 finally（关闭 db）
    return db.query(User).all()
```

**应用：** 管理数据库连接、认证、LLM 客户端等需要自动清理的资源。

---

## 卡片4：依赖链的执行顺序

**一句话：** 依赖链按照依赖关系从底层到顶层依次执行。

**举例：**
```python
def get_db():
    print("1. 创建数据库连接")
    db = SessionLocal()
    try:
        yield db
    finally:
        print("5. 关闭数据库连接")
        db.close()

def get_current_user(db: Session = Depends(get_db)):
    print("2. 查询当前用户")
    return db.query(User).first()

@app.get("/profile")
async def get_profile(user: User = Depends(get_current_user)):
    print("3. 执行路由函数")
    return user
    # 4. 路由函数返回
```

**执行顺序：**
```
1. 创建数据库连接
2. 查询当前用户
3. 执行路由函数
4. 路由函数返回
5. 关闭数据库连接
```

**应用：** 理解依赖链的执行顺序，避免资源泄漏和逻辑错误。

---

## 卡片5：依赖缓存机制

**一句话：** 同一个请求中，相同的依赖只执行一次，结果被缓存。

**举例：**
```python
def get_timestamp():
    print("生成时间戳")
    return datetime.now()

@app.get("/test")
async def test(
    ts1: datetime = Depends(get_timestamp),
    ts2: datetime = Depends(get_timestamp),
    ts3: datetime = Depends(get_timestamp)
):
    # 只打印一次 "生成时间戳"
    # ts1 == ts2 == ts3
    return {"ts1": ts1, "ts2": ts2, "ts3": ts3}
```

**为什么需要缓存？**
- 性能优化：避免重复计算
- 数据一致性：同一请求中数据一致
- 资源管理：数据库连接只创建一次

**应用：** 在依赖链中复用数据库连接、用户信息等。

---

## 卡片6：response_model 的三大作用

**一句话：** response_model 自动过滤敏感字段、验证响应数据、生成 API 文档。

**举例：**
```python
class User(BaseModel):
    id: int
    username: str
    password: str  # 敏感信息

class UserResponse(BaseModel):
    id: int
    username: str  # 不包含 password

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    user = User(id=1, username="alice", password="secret")
    return user  # FastAPI 自动过滤 password
```

**三大作用：**
1. **安全过滤** - 防止敏感信息泄露
2. **数据验证** - 确保响应数据正确
3. **文档生成** - 自动生成 OpenAPI 文档

**应用：** 所有返回用户数据的接口都应该使用 response_model。

---

## 卡片7：类作为依赖

**一句话：** 类可以作为依赖，封装相关参数和方法，提高代码复用性。

**举例：**
```python
class Pagination:
    def __init__(
        self,
        page: int = Query(1, ge=1),
        page_size: int = Query(10, ge=1, le=100)
    ):
        self.page = page
        self.page_size = page_size
        self.skip = (page - 1) * page_size
        self.limit = page_size

    def paginate(self, items: List):
        return items[self.skip : self.skip + self.limit]

@app.get("/items")
async def list_items(pagination: Pagination = Depends()):
    items = get_all_items()
    return pagination.paginate(items)
```

**优势：**
- 封装相关参数
- 可以添加方法
- 更好的代码组织

**应用：** 分页、搜索参数、过滤条件等复杂参数组合。

---

## 卡片8：生成器依赖（yield）

**一句话：** 使用 yield 的依赖函数可以在请求前后执行代码，自动管理资源生命周期。

**举例：**
```python
def get_db():
    # 请求开始：创建资源
    db = SessionLocal()
    try:
        yield db  # 注入到路由函数
    finally:
        # 请求结束：清理资源
        db.close()

@app.get("/users")
async def list_users(db: Session = Depends(get_db)):
    return db.query(User).all()
    # 函数返回后，自动执行 finally 中的 db.close()
```

**执行流程：**
```
1. 执行 yield 之前的代码（创建资源）
2. yield 返回值注入到路由函数
3. 执行路由函数
4. 路由函数返回
5. 执行 finally 中的代码（清理资源）
```

**应用：** 数据库连接、文件句柄、网络连接等需要清理的资源。

---

## 卡片9：依赖覆盖（测试）

**一句话：** 在测试中可以替换依赖，便于模拟外部服务和数据库。

**举例：**
```python
# 生产环境依赖
def get_db():
    return SessionLocal()

# 测试依赖
def get_test_db():
    return MockDatabase()

# 测试中覆盖依赖
app.dependency_overrides[get_db] = get_test_db

# 测试
client = TestClient(app)
response = client.get("/users")
# 使用 MockDatabase 而不是真实数据库

# 清理
app.dependency_overrides = {}
```

**为什么重要？**
- 隔离测试环境
- 避免依赖外部服务
- 提高测试速度

**应用：** 单元测试、集成测试中替换数据库、LLM 客户端等。

---

## 卡片10：路由组织最佳实践

**一句话：** 使用 APIRouter 按功能模块组织路由，使用依赖注入管理共享逻辑。

**举例：**
```python
# api/users.py
users_router = APIRouter(
    prefix="/users",
    tags=["用户管理"],
    dependencies=[Depends(verify_token)]  # 路由器级依赖
)

@users_router.get("/")
async def list_users(): ...

@users_router.get("/{user_id}")
async def get_user(user_id: int): ...

# main.py
app = FastAPI()
app.include_router(users_router)
app.include_router(posts_router)
app.include_router(admin_router)
```

**项目结构：**
```
app/
├── api/
│   ├── users.py      # 用户路由
│   ├── posts.py      # 文章路由
│   └── admin.py      # 管理员路由
├── core/
│   └── deps.py       # 依赖注入
└── main.py           # 主应用
```

**应用：** 大型项目中按功能模块组织路由，提高代码可维护性。

---

## 知识卡片总结

### 路由系统（卡片1-2）
- 路由装饰器的本质
- 路径参数 vs 查询参数

### 依赖注入（卡片3-5）
- Depends() 的工作原理
- 依赖链的执行顺序
- 依赖缓存机制

### 响应模型（卡片6）
- response_model 的三大作用

### 高级技巧（卡片7-9）
- 类作为依赖
- 生成器依赖（yield）
- 依赖覆盖（测试）

### 最佳实践（卡片10）
- 路由组织最佳实践

---

## 学习检查清单

完成本知识点后，你应该能够：

### 基础理解
- [ ] 理解路由装饰器的工作原理
- [ ] 区分路径参数和查询参数
- [ ] 理解 Depends() 的作用
- [ ] 理解依赖链的执行顺序
- [ ] 理解依赖缓存机制

### 实战能力
- [ ] 定义 GET/POST/PUT/DELETE 路由
- [ ] 使用路径参数和查询参数
- [ ] 使用 Depends() 注入数据库连接
- [ ] 实现 JWT 认证授权
- [ ] 使用 response_model 过滤敏感字段

### 高级技巧
- [ ] 使用类作为依赖
- [ ] 使用 yield 管理资源生命周期
- [ ] 在测试中覆盖依赖
- [ ] 使用 APIRouter 组织路由
- [ ] 设计可扩展的 API 结构

### 最佳实践
- [ ] 何时使用依赖注入
- [ ] 如何组织大型项目
- [ ] 如何处理错误
- [ ] 如何优化性能

---

## 下一步学习

完成本知识点后，建议学习：

1. **请求体验证** - Pydantic 模型的高级用法
2. **异常处理** - 统一错误处理机制
3. **中间件系统** - 请求/响应拦截器
4. **后台任务** - 异步后台任务处理
5. **流式响应** - Server-Sent Events

---

## 快速参考

### 常用装饰器

```python
@app.get("/path")           # GET 请求
@app.post("/path")          # POST 请求
@app.put("/path")           # PUT 请求
@app.delete("/path")        # DELETE 请求
```

### 常用依赖

```python
# 数据库连接
db: Session = Depends(get_db)

# 当前用户
user: User = Depends(get_current_user)

# 分页
pagination: Pagination = Depends()
```

### 常用响应模型配置

```python
response_model=UserResponse              # 定义响应模型
response_model_exclude={"password"}      # 排除字段
response_model_include={"id", "name"}    # 只包含字段
response_model_exclude_unset=True        # 排除未设置字段
response_model_exclude_none=True         # 排除 None 值
```

---

**记住：** 这10个知识卡片涵盖了路由与依赖注入的核心知识，反复阅读可以加深理解！
