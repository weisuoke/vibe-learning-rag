# 实战代码 02：数据库连接器

> **构建生产级 PostgreSQL 和 MongoDB MCP 连接器**

---

## 概述

数据库连接器是 MCP 服务器最常见的应用场景之一。本文将实现完整的 PostgreSQL 和 MongoDB 连接器，支持安全查询、连接池管理和错误处理。

```
数据库连接器核心：
├─ PostgreSQL 连接器 → pg 驱动 + 连接池
├─ MongoDB 连接器 → mongodb 驱动 + 聚合查询
├─ 安全查询 → 参数化查询 + 权限控制
└─ 生产部署 → Docker + 环境变量
```

**本质**：数据库连接器是 MCP 服务器与数据库之间的安全桥梁，通过预定义的工具让 AI 能够查询数据库而不直接执行 SQL。

[Source: Build an MCP Server for PostgreSQL](https://dev.to/sergiocolqueponce/build-an-mcp-server-for-postgresql-query-your-database-with-claude-any-ai-client-5m6)

---

## PostgreSQL 连接器实现

### 项目初始化

```bash
# 创建项目
mkdir postgres-mcp-server
cd postgres-mcp-server

# 初始化并安装依赖
npm init -y
npm install @modelcontextprotocol/sdk pg dotenv
npm install -D typescript @types/node @types/pg

# 创建目录结构
mkdir src
touch src/database.ts src/server.ts
```

### TypeScript 配置

创建 `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

### 数据库服务层

创建 `src/database.ts`:

```typescript
import { Pool, QueryResult } from 'pg';
import dotenv from 'dotenv';

dotenv.config();

// 创建连接池
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,                    // 最大连接数
  idleTimeoutMillis: 30000,   // 空闲超时
  connectionTimeoutMillis: 2000, // 连接超时
});

// 监听连接池事件
pool.on('error', (err) => {
  console.error('Unexpected error on idle client', err);
  process.exit(-1);
});

export class DatabaseService {
  /**
   * 查询用户列表
   */
  async queryUsers(limit: number = 10): Promise<any[]> {
    const result = await pool.query(
      'SELECT id, name, email, created_at FROM users ORDER BY created_at DESC LIMIT $1',
      [limit]
    );
    return result.rows;
  }

  /**
   * 根据状态查询事件
   */
  async queryIncidents(status: string): Promise<any[]> {
    const result = await pool.query(
      `SELECT id, title, status, severity, created_at
       FROM incidents
       WHERE status = $1
       ORDER BY created_at DESC`,
      [status]
    );
    return result.rows;
  }

  /**
   * 获取数据库统计信息
   */
  async getStats(): Promise<any> {
    const result = await pool.query(`
      SELECT
        COUNT(*) as total_incidents,
        SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical_count,
        SUM(CASE WHEN status = 'open' THEN 1 ELSE 0 END) as open_count,
        SUM(CASE WHEN status = 'resolved' THEN 1 ELSE 0 END) as resolved_count
      FROM incidents
    `);
    return result.rows[0];
  }

  /**
   * 执行自定义查询（仅用于只读操作）
   */
  async executeQuery(query: string, params: any[] = []): Promise<any[]> {
    // 安全检查：只允许 SELECT 查询
    const trimmedQuery = query.trim().toUpperCase();
    if (!trimmedQuery.startsWith('SELECT')) {
      throw new Error('Only SELECT queries are allowed');
    }

    const result = await pool.query(query, params);
    return result.rows;
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<boolean> {
    try {
      await pool.query('SELECT 1');
      return true;
    } catch (error) {
      console.error('Health check failed:', error);
      return false;
    }
  }

  /**
   * 关闭连接池
   */
  async close(): Promise<void> {
    await pool.end();
  }
}
```

**关键点**：

- **连接池**：使用 `Pool` 而非单个 `Client`，提高性能
- **参数化查询**：使用 `$1`, `$2` 占位符防止 SQL 注入
- **错误处理**：监听连接池错误事件
- **安全限制**：只允许 SELECT 查询

### MCP 服务器实现

创建 `src/server.ts`:

```typescript
#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { DatabaseService } from './database.js';

// 创建服务器实例
const server = new Server({
  name: 'postgres-mcp-server',
  version: '1.0.0',
}, {
  capabilities: {
    tools: {},
  },
});

// 创建数据库服务实例
const db = new DatabaseService();

// 注册工具列表
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: 'get_users',
      description: 'Retrieve recent users from the database',
      inputSchema: {
        type: 'object',
        properties: {
          limit: {
            type: 'number',
            description: 'Maximum number of users to return (default: 10)',
            default: 10,
          },
        },
        required: [],
      },
    },
    {
      name: 'get_incidents_by_status',
      description: 'Get incidents filtered by status',
      inputSchema: {
        type: 'object',
        properties: {
          status: {
            type: 'string',
            description: 'Incident status (open, in_progress, resolved, closed)',
            enum: ['open', 'in_progress', 'resolved', 'closed'],
          },
        },
        required: ['status'],
      },
    },
    {
      name: 'get_database_stats',
      description: 'Get incident statistics (total, critical, open, resolved)',
      inputSchema: {
        type: 'object',
        properties: {},
        required: [],
      },
    },
    {
      name: 'health_check',
      description: 'Check database connection health',
      inputSchema: {
        type: 'object',
        properties: {},
        required: [],
      },
    },
  ],
}));

// 注册工具执行处理器
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'get_users': {
        const limit = (args as any)?.limit || 10;
        const users = await db.queryUsers(limit);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(users, null, 2),
            },
          ],
        };
      }

      case 'get_incidents_by_status': {
        const status = (args as any)?.status;
        if (!status) {
          throw new Error('Status parameter is required');
        }
        const incidents = await db.queryIncidents(status);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(incidents, null, 2),
            },
          ],
        };
      }

      case 'get_database_stats': {
        const stats = await db.getStats();
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(stats, null, 2),
            },
          ],
        };
      }

      case 'health_check': {
        const isHealthy = await db.healthCheck();
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                status: isHealthy ? 'healthy' : 'unhealthy',
                timestamp: new Date().toISOString(),
              }, null, 2),
            },
          ],
        };
      }

      default:
        return {
          content: [
            {
              type: 'text',
              text: `Unknown tool: ${name}`,
            },
          ],
          isError: true,
        };
    }
  } catch (error) {
    console.error(`Error executing tool ${name}:`, error);
    return {
      content: [
        {
          type: 'text',
          text: `Error: ${error instanceof Error ? error.message : String(error)}`,
        },
      ],
      isError: true,
    };
  }
});

// 启动服务器
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('PostgreSQL MCP Server running on stdio');
  console.error('Available tools: get_users, get_incidents_by_status, get_database_stats, health_check');
}

// 优雅关闭
process.on('SIGINT', async () => {
  console.error('Shutting down...');
  await db.close();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.error('Shutting down...');
  await db.close();
  process.exit(0);
});

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
```

### 环境配置

创建 `.env`:

```bash
# PostgreSQL 连接字符串
DATABASE_URL=postgresql://username:password@localhost:5432/database_name

# 或者分开配置
# PGHOST=localhost
# PGPORT=5432
# PGDATABASE=mydb
# PGUSER=myuser
# PGPASSWORD=mypassword
```

创建 `.env.example`:

```bash
DATABASE_URL=postgresql://username:password@localhost:5432/database_name
```

### package.json 配置

```json
{
  "name": "postgres-mcp-server",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "start": "node dist/server.js",
    "dev": "tsc && npm start",
    "test": "node dist/server.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "pg": "^8.11.0",
    "dotenv": "^16.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/pg": "^8.10.0",
    "typescript": "^5.0.0"
  }
}
```

[Source: Build an MCP Server for PostgreSQL](https://dev.to/sergiocolqueponce/build-an-mcp-server-for-postgresql-query-your-database-with-claude-any-ai-client-5m6)

---

## MongoDB 连接器实现

### 数据库服务层

创建 `src/mongodb.ts`:

```typescript
import { MongoClient, Db, Collection } from 'mongodb';
import dotenv from 'dotenv';

dotenv.config();

export class MongoDBService {
  private client: MongoClient;
  private db: Db | null = null;

  constructor() {
    const uri = process.env.MONGODB_URI || 'mongodb://localhost:27017';
    this.client = new MongoClient(uri, {
      maxPoolSize: 10,
      minPoolSize: 2,
      maxIdleTimeMS: 30000,
    });
  }

  /**
   * 连接到数据库
   */
  async connect(dbName: string): Promise<void> {
    await this.client.connect();
    this.db = this.client.db(dbName);
    console.error(`Connected to MongoDB database: ${dbName}`);
  }

  /**
   * 查询文档
   */
  async findDocuments(
    collectionName: string,
    filter: any = {},
    limit: number = 10
  ): Promise<any[]> {
    if (!this.db) throw new Error('Database not connected');

    const collection = this.db.collection(collectionName);
    return await collection.find(filter).limit(limit).toArray();
  }

  /**
   * 聚合查询
   */
  async aggregate(
    collectionName: string,
    pipeline: any[]
  ): Promise<any[]> {
    if (!this.db) throw new Error('Database not connected');

    const collection = this.db.collection(collectionName);
    return await collection.aggregate(pipeline).toArray();
  }

  /**
   * 统计文档数量
   */
  async countDocuments(
    collectionName: string,
    filter: any = {}
  ): Promise<number> {
    if (!this.db) throw new Error('Database not connected');

    const collection = this.db.collection(collectionName);
    return await collection.countDocuments(filter);
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.client.db('admin').command({ ping: 1 });
      return true;
    } catch (error) {
      console.error('MongoDB health check failed:', error);
      return false;
    }
  }

  /**
   * 关闭连接
   */
  async close(): Promise<void> {
    await this.client.close();
  }
}
```

---

## 测试与部署

### 本地测试

```bash
# 构建项目
npm run build

# 启动服务器
npm start

# 应该看到：
# PostgreSQL MCP Server running on stdio
# Available tools: get_users, get_incidents_by_status, get_database_stats, health_check
```

### Claude Desktop 配置

编辑 `~/Library/Application Support/Claude/claude_desktop_config.json`:

```json
{
  "mcpServers": {
    "postgres": {
      "command": "node",
      "args": [
        "/absolute/path/to/postgres-mcp-server/dist/server.js"
      ],
      "env": {
        "DATABASE_URL": "postgresql://user:password@localhost:5432/mydb"
      }
    }
  }
}
```

### Docker 部署

创建 `Dockerfile`:

```dockerfile
FROM node:20-alpine

WORKDIR /app

# 复制 package 文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建 TypeScript
RUN npm run build

# 暴露端口（如果使用 HTTP 传输）
# EXPOSE 3000

# 启动服务器
CMD ["node", "dist/server.js"]
```

创建 `docker-compose.yml`:

```yaml
version: '3.8'

services:
  postgres-mcp:
    build: .
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/mydb
    depends_on:
      - postgres
    restart: unless-stopped

  postgres:
    image: postgres:16-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:
```

---

## 最佳实践

### 安全性

```typescript
// ✅ 使用参数化查询
const result = await pool.query(
  'SELECT * FROM users WHERE id = $1',
  [userId]
);

// ❌ 字符串拼接（SQL 注入风险）
const result = await pool.query(
  `SELECT * FROM users WHERE id = ${userId}`
);

// ✅ 限制查询类型
if (!query.trim().toUpperCase().startsWith('SELECT')) {
  throw new Error('Only SELECT queries allowed');
}

// ✅ 使用只读数据库用户
// CREATE USER readonly WITH PASSWORD 'password';
// GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly;
```

### 连接池管理

```typescript
// ✅ 配置合理的连接池参数
const pool = new Pool({
  max: 20,                    // 最大连接数
  min: 5,                     // 最小连接数
  idleTimeoutMillis: 30000,   // 空闲超时
  connectionTimeoutMillis: 2000, // 连接超时
});

// ✅ 监听连接池事件
pool.on('connect', () => {
  console.error('New client connected');
});

pool.on('error', (err) => {
  console.error('Unexpected error:', err);
});

// ✅ 优雅关闭
process.on('SIGTERM', async () => {
  await pool.end();
  process.exit(0);
});
```

### 错误处理

```typescript
// ✅ 完整的错误处理
try {
  const result = await db.queryUsers(limit);
  return {
    content: [{
      type: 'text',
      text: JSON.stringify(result, null, 2)
    }]
  };
} catch (error) {
  console.error('Query error:', error);
  return {
    content: [{
      type: 'text',
      text: `Database error: ${error instanceof Error ? error.message : 'Unknown error'}`
    }],
    isError: true
  };
}
```

### 性能优化

```typescript
// ✅ 使用索引
// CREATE INDEX idx_users_created_at ON users(created_at DESC);
// CREATE INDEX idx_incidents_status ON incidents(status);

// ✅ 限制返回行数
const result = await pool.query(
  'SELECT * FROM users LIMIT $1',
  [Math.min(limit, 100)] // 最多返回 100 行
);

// ✅ 使用连接池而非单个连接
// Pool 自动管理连接复用
```

[Source: Build an MCP Server for PostgreSQL](https://dev.to/sergiocolqueponce/build-an-mcp-server-for-postgresql-query-your-database-with-claude-any-ai-client-5m6)

---

## 总结

### 核心要点

1. **连接池**：使用 `pg.Pool` 管理 PostgreSQL 连接
2. **参数化查询**：使用 `$1`, `$2` 占位符防止 SQL 注入
3. **安全限制**：只允许 SELECT 查询，使用只读用户
4. **错误处理**：完整的 try-catch 和连接池错误监听
5. **生产部署**：Docker + 环境变量 + 优雅关闭

### 关键约束

- ✅ 使用连接池而非单个连接
- ✅ 参数化查询防止 SQL 注入
- ✅ 限制查询类型（只允许 SELECT）
- ✅ 配置合理的连接池参数
- ✅ 监听连接池错误事件

### 下一步

- 阅读 [07_实战代码_03_API包装器](./07_实战代码_03_API包装器.md) 学习 API 包装
- 阅读 [07_实战代码_04_高级Server特性](./07_实战代码_04_高级Server特性.md) 学习高级特性

---

**参考资源**：
- [Source: Build an MCP Server for PostgreSQL](https://dev.to/sergiocolqueponce/build-an-mcp-server-for-postgresql-query-your-database-with-claude-any-ai-client-5m6)
- [Source: MCP Official Servers](https://github.com/modelcontextprotocol/servers)
- [Source: pg Documentation](https://node-postgres.com/)
