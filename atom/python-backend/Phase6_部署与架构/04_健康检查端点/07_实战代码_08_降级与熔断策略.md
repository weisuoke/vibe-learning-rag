# å®æˆ˜ä»£ç 8ï¼šé™çº§ä¸ç†”æ–­ç­–ç•¥

> æœåŠ¡é™çº§ã€ç†”æ–­å™¨æ¨¡å¼ã€å¥åº·çŠ¶æ€è½¬æ¢çš„å®Œæ•´å®ç°

---

## æ¦‚è¿°

æœ¬æ–‡æä¾›æœåŠ¡é™çº§å’Œç†”æ–­ç­–ç•¥çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬ï¼š
- æœåŠ¡é™çº§å®ç°
- ç†”æ–­å™¨æ¨¡å¼ï¼ˆCircuit Breakerï¼‰
- å¥åº·çŠ¶æ€è½¬æ¢ï¼ˆå¥åº·â†’é™çº§â†’ä¸å¥åº·ï¼‰
- è‡ªåŠ¨æ¢å¤æœºåˆ¶
- é™çº§å“åº”ç­–ç•¥
- ç†”æ–­å™¨ä¸å¥åº·æ£€æŸ¥é›†æˆ

---

## å®Œæ•´ä»£ç 

```python
"""
é™çº§ä¸ç†”æ–­ç­–ç•¥å®ç°
æ¼”ç¤ºï¼šæœåŠ¡é™çº§ã€ç†”æ–­å™¨æ¨¡å¼ã€è‡ªåŠ¨æ¢å¤
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Optional, Callable, Any
from enum import Enum
from datetime import datetime, timedelta
import asyncio
import time

# ===== 1. çŠ¶æ€æšä¸¾ =====

class ServiceStatus(str, Enum):
    """æœåŠ¡çŠ¶æ€"""
    HEALTHY = "healthy"      # å¥åº·
    DEGRADED = "degraded"    # é™çº§
    UNHEALTHY = "unhealthy"  # ä¸å¥åº·

class CircuitState(str, Enum):
    """ç†”æ–­å™¨çŠ¶æ€"""
    CLOSED = "closed"        # å…³é—­ï¼ˆæ­£å¸¸ï¼‰
    OPEN = "open"            # æ‰“å¼€ï¼ˆç†”æ–­ï¼‰
    HALF_OPEN = "half_open"  # åŠå¼€ï¼ˆå°è¯•æ¢å¤ï¼‰

# ===== 2. ç†”æ–­å™¨å®ç° =====

class CircuitBreaker:
    """
    ç†”æ–­å™¨æ¨¡å¼å®ç°

    å½“è¿ç»­å¤±è´¥æ¬¡æ•°è¶…è¿‡é˜ˆå€¼æ—¶ï¼Œæ‰“å¼€ç†”æ–­å™¨ï¼Œå¿«é€Ÿå¤±è´¥
    """

    def __init__(
        self,
        name: str,
        failure_threshold: int = 5,
        success_threshold: int = 2,
        timeout: int = 60,
        half_open_timeout: int = 30
    ):
        """
        åˆå§‹åŒ–ç†”æ–­å™¨

        Args:
            name: ç†”æ–­å™¨åç§°
            failure_threshold: å¤±è´¥é˜ˆå€¼ï¼ˆè¿ç»­å¤±è´¥å¤šå°‘æ¬¡æ‰“å¼€ç†”æ–­å™¨ï¼‰
            success_threshold: æˆåŠŸé˜ˆå€¼ï¼ˆåŠå¼€çŠ¶æ€è¿ç»­æˆåŠŸå¤šå°‘æ¬¡å…³é—­ç†”æ–­å™¨ï¼‰
            timeout: ç†”æ–­å™¨æ‰“å¼€åå¤šä¹…è¿›å…¥åŠå¼€çŠ¶æ€ï¼ˆç§’ï¼‰
            half_open_timeout: åŠå¼€çŠ¶æ€æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
        """
        self.name = name
        self.failure_threshold = failure_threshold
        self.success_threshold = success_threshold
        self.timeout = timeout
        self.half_open_timeout = half_open_timeout

        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.last_state_change = datetime.now()
        self.state = CircuitState.CLOSED

    async def call(self, func: Callable, *args, **kwargs) -> Any:
        """
        é€šè¿‡ç†”æ–­å™¨è°ƒç”¨å‡½æ•°

        Args:
            func: è¦è°ƒç”¨çš„å‡½æ•°
            *args: å‡½æ•°å‚æ•°
            **kwargs: å‡½æ•°å…³é”®å­—å‚æ•°

        Returns:
            å‡½æ•°è¿”å›å€¼

        Raises:
            Exception: å¦‚æœç†”æ–­å™¨æ‰“å¼€æˆ–å‡½æ•°è°ƒç”¨å¤±è´¥
        """
        # æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
        await self._check_state()

        # å¦‚æœç†”æ–­å™¨æ‰“å¼€ï¼Œå¿«é€Ÿå¤±è´¥
        if self.state == CircuitState.OPEN:
            raise Exception(f"Circuit breaker '{self.name}' is open")

        try:
            # è°ƒç”¨å‡½æ•°
            result = await func(*args, **kwargs)

            # è®°å½•æˆåŠŸ
            await self._on_success()

            return result

        except Exception as e:
            # è®°å½•å¤±è´¥
            await self._on_failure()
            raise e

    async def _check_state(self):
        """æ£€æŸ¥å¹¶æ›´æ–°ç†”æ–­å™¨çŠ¶æ€"""
        now = datetime.now()

        # å¦‚æœæ˜¯æ‰“å¼€çŠ¶æ€ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›å…¥åŠå¼€çŠ¶æ€
        if self.state == CircuitState.OPEN:
            if self.last_failure_time:
                elapsed = (now - self.last_failure_time).total_seconds()
                if elapsed >= self.timeout:
                    self.state = CircuitState.HALF_OPEN
                    self.success_count = 0
                    self.last_state_change = now
                    print(f"ğŸ”„ Circuit breaker '{self.name}' entering half-open state")

        # å¦‚æœæ˜¯åŠå¼€çŠ¶æ€ï¼Œæ£€æŸ¥æ˜¯å¦è¶…æ—¶
        elif self.state == CircuitState.HALF_OPEN:
            elapsed = (now - self.last_state_change).total_seconds()
            if elapsed >= self.half_open_timeout:
                # åŠå¼€çŠ¶æ€è¶…æ—¶ï¼Œé‡æ–°æ‰“å¼€
                self.state = CircuitState.OPEN
                self.last_failure_time = now
                self.last_state_change = now
                print(f"âš ï¸  Circuit breaker '{self.name}' reopened (half-open timeout)")

    async def _on_success(self):
        """å¤„ç†æˆåŠŸè°ƒç”¨"""
        if self.state == CircuitState.HALF_OPEN:
            # åŠå¼€çŠ¶æ€ï¼Œè®°å½•æˆåŠŸæ¬¡æ•°
            self.success_count += 1
            print(f"âœ… Circuit breaker '{self.name}' success count: {self.success_count}/{self.success_threshold}")

            # å¦‚æœè¿ç»­æˆåŠŸæ¬¡æ•°è¾¾åˆ°é˜ˆå€¼ï¼Œå…³é—­ç†”æ–­å™¨
            if self.success_count >= self.success_threshold:
                self.state = CircuitState.CLOSED
                self.failure_count = 0
                self.success_count = 0
                self.last_state_change = datetime.now()
                print(f"âœ… Circuit breaker '{self.name}' closed")

        elif self.state == CircuitState.CLOSED:
            # å…³é—­çŠ¶æ€ï¼Œé‡ç½®å¤±è´¥è®¡æ•°
            self.failure_count = 0

    async def _on_failure(self):
        """å¤„ç†å¤±è´¥è°ƒç”¨"""
        self.failure_count += 1
        self.last_failure_time = datetime.now()

        if self.state == CircuitState.HALF_OPEN:
            # åŠå¼€çŠ¶æ€å¤±è´¥ï¼Œç«‹å³æ‰“å¼€ç†”æ–­å™¨
            self.state = CircuitState.OPEN
            self.last_state_change = datetime.now()
            print(f"âš ï¸  Circuit breaker '{self.name}' opened (half-open failure)")

        elif self.state == CircuitState.CLOSED:
            # å…³é—­çŠ¶æ€ï¼Œæ£€æŸ¥æ˜¯å¦è¾¾åˆ°å¤±è´¥é˜ˆå€¼
            print(f"âŒ Circuit breaker '{self.name}' failure count: {self.failure_count}/{self.failure_threshold}")

            if self.failure_count >= self.failure_threshold:
                self.state = CircuitState.OPEN
                self.last_state_change = datetime.now()
                print(f"âš ï¸  Circuit breaker '{self.name}' opened (failure threshold reached)")

    def get_state(self) -> Dict:
        """è·å–ç†”æ–­å™¨çŠ¶æ€"""
        return {
            "name": self.name,
            "state": self.state.value,
            "failure_count": self.failure_count,
            "success_count": self.success_count,
            "last_failure_time": self.last_failure_time.isoformat() if self.last_failure_time else None,
            "last_state_change": self.last_state_change.isoformat()
        }

    def reset(self):
        """é‡ç½®ç†”æ–­å™¨"""
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.last_state_change = datetime.now()
        print(f"ğŸ”„ Circuit breaker '{self.name}' reset")

# ===== 3. é™çº§ç­–ç•¥ =====

class DegradationStrategy:
    """é™çº§ç­–ç•¥åŸºç±»"""

    async def execute(self, *args, **kwargs) -> Any:
        """
        æ‰§è¡Œé™çº§ç­–ç•¥

        Returns:
            é™çº§å“åº”
        """
        raise NotImplementedError

class CachedResponseStrategy(DegradationStrategy):
    """ç¼“å­˜å“åº”é™çº§ç­–ç•¥"""

    def __init__(self, cache: Dict):
        self.cache = cache

    async def execute(self, key: str) -> Any:
        """è¿”å›ç¼“å­˜çš„å“åº”"""
        if key in self.cache:
            return {
                "data": self.cache[key],
                "degraded": True,
                "message": "Using cached response"
            }
        else:
            return {
                "data": None,
                "degraded": True,
                "message": "No cached response available"
            }

class DefaultResponseStrategy(DegradationStrategy):
    """é»˜è®¤å“åº”é™çº§ç­–ç•¥"""

    def __init__(self, default_response: Any):
        self.default_response = default_response

    async def execute(self) -> Any:
        """è¿”å›é»˜è®¤å“åº”"""
        return {
            "data": self.default_response,
            "degraded": True,
            "message": "Using default response"
        }

class FallbackServiceStrategy(DegradationStrategy):
    """å¤‡ç”¨æœåŠ¡é™çº§ç­–ç•¥"""

    def __init__(self, fallback_func: Callable):
        self.fallback_func = fallback_func

    async def execute(self, *args, **kwargs) -> Any:
        """è°ƒç”¨å¤‡ç”¨æœåŠ¡"""
        try:
            result = await self.fallback_func(*args, **kwargs)
            return {
                "data": result,
                "degraded": True,
                "message": "Using fallback service"
            }
        except Exception as e:
            return {
                "data": None,
                "degraded": True,
                "message": f"Fallback service failed: {str(e)}"
            }

# ===== 4. æœåŠ¡é™çº§ç®¡ç†å™¨ =====

class DegradationManager:
    """æœåŠ¡é™çº§ç®¡ç†å™¨"""

    def __init__(self):
        self.strategies: Dict[str, DegradationStrategy] = {}
        self.breakers: Dict[str, CircuitBreaker] = {}

    def register_strategy(self, name: str, strategy: DegradationStrategy):
        """æ³¨å†Œé™çº§ç­–ç•¥"""
        self.strategies[name] = strategy

    def register_breaker(self, name: str, breaker: CircuitBreaker):
        """æ³¨å†Œç†”æ–­å™¨"""
        self.breakers[name] = breaker

    async def call_with_degradation(
        self,
        name: str,
        func: Callable,
        strategy_name: str,
        *args,
        **kwargs
    ) -> Any:
        """
        è°ƒç”¨å‡½æ•°ï¼ˆå¸¦é™çº§ç­–ç•¥ï¼‰

        Args:
            name: æœåŠ¡åç§°
            func: è¦è°ƒç”¨çš„å‡½æ•°
            strategy_name: é™çº§ç­–ç•¥åç§°
            *args: å‡½æ•°å‚æ•°
            **kwargs: å‡½æ•°å…³é”®å­—å‚æ•°

        Returns:
            å‡½æ•°è¿”å›å€¼æˆ–é™çº§å“åº”
        """
        # è·å–ç†”æ–­å™¨
        breaker = self.breakers.get(name)
        if not breaker:
            # æ²¡æœ‰ç†”æ–­å™¨ï¼Œç›´æ¥è°ƒç”¨
            return await func(*args, **kwargs)

        try:
            # é€šè¿‡ç†”æ–­å™¨è°ƒç”¨
            return await breaker.call(func, *args, **kwargs)

        except Exception as e:
            # è°ƒç”¨å¤±è´¥ï¼Œæ‰§è¡Œé™çº§ç­–ç•¥
            print(f"âš ï¸  Service '{name}' failed, executing degradation strategy '{strategy_name}'")

            strategy = self.strategies.get(strategy_name)
            if strategy:
                return await strategy.execute(*args, **kwargs)
            else:
                raise e

# ===== 5. FastAPI åº”ç”¨ =====

app = FastAPI(title="Degradation and Circuit Breaker")

# åˆ›å»ºé™çº§ç®¡ç†å™¨
degradation_manager = DegradationManager()

# æ¨¡æ‹Ÿç¼“å­˜
response_cache = {
    "user_123": {"id": "123", "name": "John Doe", "email": "john@example.com"}
}

# æ³¨å†Œé™çº§ç­–ç•¥
degradation_manager.register_strategy(
    "cached_response",
    CachedResponseStrategy(response_cache)
)

degradation_manager.register_strategy(
    "default_response",
    DefaultResponseStrategy({"message": "Service temporarily unavailable"})
)

# æ³¨å†Œç†”æ–­å™¨
degradation_manager.register_breaker(
    "external_api",
    CircuitBreaker(
        name="external_api",
        failure_threshold=3,
        success_threshold=2,
        timeout=30,
        half_open_timeout=15
    )
)

degradation_manager.register_breaker(
    "llm_api",
    CircuitBreaker(
        name="llm_api",
        failure_threshold=5,
        success_threshold=2,
        timeout=60,
        half_open_timeout=30
    )
)

# ===== 6. æ¨¡æ‹Ÿå¤–éƒ¨æœåŠ¡ =====

# æ¨¡æ‹Ÿå¤–éƒ¨ API çŠ¶æ€
external_api_available = True

async def call_external_api(user_id: str) -> Dict:
    """æ¨¡æ‹Ÿè°ƒç”¨å¤–éƒ¨ API"""
    if not external_api_available:
        raise Exception("External API unavailable")

    await asyncio.sleep(0.1)  # æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ

    return {
        "id": user_id,
        "name": "John Doe",
        "email": "john@example.com"
    }

# ===== 7. API ç«¯ç‚¹ =====

@app.get("/user/{user_id}")
async def get_user(user_id: str):
    """
    è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆå¸¦é™çº§ç­–ç•¥ï¼‰

    å¦‚æœå¤–éƒ¨ API å¤±è´¥ï¼Œè¿”å›ç¼“å­˜çš„å“åº”
    """
    try:
        result = await degradation_manager.call_with_degradation(
            name="external_api",
            func=call_external_api,
            strategy_name="cached_response",
            user_id=user_id
        )

        return result

    except Exception as e:
        raise HTTPException(503, detail=str(e))

@app.post("/external_api/toggle")
async def toggle_external_api():
    """åˆ‡æ¢å¤–éƒ¨ API å¯ç”¨æ€§ï¼ˆç”¨äºæµ‹è¯•ï¼‰"""
    global external_api_available
    external_api_available = not external_api_available

    return {
        "external_api_available": external_api_available,
        "message": f"External API is now {'available' if external_api_available else 'unavailable'}"
    }

@app.get("/breaker/{name}/state")
async def get_breaker_state(name: str):
    """è·å–ç†”æ–­å™¨çŠ¶æ€"""
    breaker = degradation_manager.breakers.get(name)
    if not breaker:
        raise HTTPException(404, f"Circuit breaker '{name}' not found")

    return breaker.get_state()

@app.post("/breaker/{name}/reset")
async def reset_breaker(name: str):
    """é‡ç½®ç†”æ–­å™¨"""
    breaker = degradation_manager.breakers.get(name)
    if not breaker:
        raise HTTPException(404, f"Circuit breaker '{name}' not found")

    breaker.reset()

    return {
        "message": f"Circuit breaker '{name}' reset",
        "state": breaker.get_state()
    }

@app.get("/breakers")
async def list_breakers():
    """åˆ—å‡ºæ‰€æœ‰ç†”æ–­å™¨"""
    return {
        name: breaker.get_state()
        for name, breaker in degradation_manager.breakers.items()
    }

# ===== 8. å¥åº·æ£€æŸ¥é›†æˆ =====

class HealthResponse(BaseModel):
    """å¥åº·æ£€æŸ¥å“åº”"""
    status: ServiceStatus
    breakers: Dict[str, Dict]
    message: Optional[str] = None

@app.get("/health", response_model=HealthResponse)
async def health():
    """
    å¥åº·æ£€æŸ¥ï¼ˆé›†æˆç†”æ–­å™¨çŠ¶æ€ï¼‰

    æ ¹æ®ç†”æ–­å™¨çŠ¶æ€åˆ¤æ–­æœåŠ¡å¥åº·çŠ¶æ€
    """
    breakers = {
        name: breaker.get_state()
        for name, breaker in degradation_manager.breakers.items()
    }

    # åˆ¤æ–­æ•´ä½“çŠ¶æ€
    open_breakers = [
        name for name, state in breakers.items()
        if state["state"] == CircuitState.OPEN.value
    ]

    half_open_breakers = [
        name for name, state in breakers.items()
        if state["state"] == CircuitState.HALF_OPEN.value
    ]

    if open_breakers:
        # æœ‰ç†”æ–­å™¨æ‰“å¼€ï¼ŒæœåŠ¡é™çº§
        status = ServiceStatus.DEGRADED
        message = f"Circuit breakers open: {', '.join(open_breakers)}"
    elif half_open_breakers:
        # æœ‰ç†”æ–­å™¨åŠå¼€ï¼ŒæœåŠ¡é™çº§
        status = ServiceStatus.DEGRADED
        message = f"Circuit breakers recovering: {', '.join(half_open_breakers)}"
    else:
        # æ‰€æœ‰ç†”æ–­å™¨å…³é—­ï¼ŒæœåŠ¡å¥åº·
        status = ServiceStatus.HEALTHY
        message = "All circuit breakers closed"

    return HealthResponse(
        status=status,
        breakers=breakers,
        message=message
    )

# ===== 9. è¿è¡Œè¯´æ˜ =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("é™çº§ä¸ç†”æ–­ç­–ç•¥å®ç°")
    print("=" * 50)
    print()
    print("ç‰¹æ€§ï¼š")
    print("  âœ… ç†”æ–­å™¨æ¨¡å¼ï¼ˆCircuit Breakerï¼‰")
    print("  âœ… æœåŠ¡é™çº§ç­–ç•¥")
    print("  âœ… è‡ªåŠ¨æ¢å¤æœºåˆ¶")
    print("  âœ… å¥åº·çŠ¶æ€è½¬æ¢")
    print()
    print("ç«¯ç‚¹ï¼š")
    print("  GET  /user/{user_id}           - è·å–ç”¨æˆ·ï¼ˆå¸¦é™çº§ï¼‰")
    print("  POST /external_api/toggle      - åˆ‡æ¢å¤–éƒ¨ API çŠ¶æ€")
    print("  GET  /breaker/{name}/state     - è·å–ç†”æ–­å™¨çŠ¶æ€")
    print("  POST /breaker/{name}/reset     - é‡ç½®ç†”æ–­å™¨")
    print("  GET  /breakers                 - åˆ—å‡ºæ‰€æœ‰ç†”æ–­å™¨")
    print("  GET  /health                   - å¥åº·æ£€æŸ¥")
    print()
    print("æµ‹è¯•æµç¨‹ï¼š")
    print("  1. curl http://localhost:8000/user/123")
    print("     â†’ æ­£å¸¸è¿”å›ç”¨æˆ·ä¿¡æ¯")
    print()
    print("  2. curl -X POST http://localhost:8000/external_api/toggle")
    print("     â†’ å…³é—­å¤–éƒ¨ API")
    print()
    print("  3. curl http://localhost:8000/user/123")
    print("     â†’ è¿ç»­è¯·æ±‚ 3 æ¬¡ï¼Œè§¦å‘ç†”æ–­å™¨")
    print()
    print("  4. curl http://localhost:8000/breaker/external_api/state")
    print("     â†’ æŸ¥çœ‹ç†”æ–­å™¨çŠ¶æ€ï¼ˆåº”è¯¥æ˜¯ openï¼‰")
    print()
    print("  5. curl http://localhost:8000/user/123")
    print("     â†’ ç†”æ–­å™¨æ‰“å¼€ï¼Œè¿”å›ç¼“å­˜å“åº”")
    print()
    print("  6. ç­‰å¾… 30 ç§’ï¼Œç†”æ–­å™¨è¿›å…¥åŠå¼€çŠ¶æ€")
    print()
    print("  7. curl -X POST http://localhost:8000/external_api/toggle")
    print("     â†’ æ¢å¤å¤–éƒ¨ API")
    print()
    print("  8. curl http://localhost:8000/user/123")
    print("     â†’ è¿ç»­è¯·æ±‚ 2 æ¬¡ï¼Œç†”æ–­å™¨å…³é—­")
    print()
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## æµ‹è¯•ç¤ºä¾‹

### 1. æ­£å¸¸è°ƒç”¨

```bash
# è·å–ç”¨æˆ·ä¿¡æ¯
curl http://localhost:8000/user/123
```

**è¾“å‡ºï¼š**

```json
{
  "id": "123",
  "name": "John Doe",
  "email": "john@example.com"
}
```

### 2. è§¦å‘ç†”æ–­å™¨

```bash
# 1. å…³é—­å¤–éƒ¨ API
curl -X POST http://localhost:8000/external_api/toggle

# 2. è¿ç»­è¯·æ±‚ 3 æ¬¡ï¼ˆè§¦å‘ç†”æ–­å™¨ï¼‰
curl http://localhost:8000/user/123
curl http://localhost:8000/user/123
curl http://localhost:8000/user/123

# 3. æŸ¥çœ‹ç†”æ–­å™¨çŠ¶æ€
curl http://localhost:8000/breaker/external_api/state
```

**è¾“å‡ºï¼š**

```json
{
  "name": "external_api",
  "state": "open",
  "failure_count": 3,
  "success_count": 0,
  "last_failure_time": "2026-02-13T01:00:00.000Z",
  "last_state_change": "2026-02-13T01:00:00.000Z"
}
```

### 3. é™çº§å“åº”

```bash
# ç†”æ–­å™¨æ‰“å¼€åï¼Œè¿”å›ç¼“å­˜å“åº”
curl http://localhost:8000/user/123
```

**è¾“å‡ºï¼š**

```json
{
  "data": {
    "id": "123",
    "name": "John Doe",
    "email": "john@example.com"
  },
  "degraded": true,
  "message": "Using cached response"
}
```

### 4. è‡ªåŠ¨æ¢å¤

```bash
# 1. ç­‰å¾… 30 ç§’ï¼ˆç†”æ–­å™¨è¿›å…¥åŠå¼€çŠ¶æ€ï¼‰
sleep 30

# 2. æ¢å¤å¤–éƒ¨ API
curl -X POST http://localhost:8000/external_api/toggle

# 3. è¿ç»­è¯·æ±‚ 2 æ¬¡ï¼ˆç†”æ–­å™¨å…³é—­ï¼‰
curl http://localhost:8000/user/123
curl http://localhost:8000/user/123

# 4. æŸ¥çœ‹ç†”æ–­å™¨çŠ¶æ€
curl http://localhost:8000/breaker/external_api/state
```

**è¾“å‡ºï¼š**

```json
{
  "name": "external_api",
  "state": "closed",
  "failure_count": 0,
  "success_count": 0,
  "last_failure_time": null,
  "last_state_change": "2026-02-13T01:01:00.000Z"
}
```

### 5. å¥åº·æ£€æŸ¥

```bash
curl http://localhost:8000/health
```

**è¾“å‡ºï¼ˆç†”æ–­å™¨æ‰“å¼€æ—¶ï¼‰ï¼š**

```json
{
  "status": "degraded",
  "breakers": {
    "external_api": {
      "name": "external_api",
      "state": "open",
      "failure_count": 3,
      "success_count": 0
    },
    "llm_api": {
      "name": "llm_api",
      "state": "closed",
      "failure_count": 0,
      "success_count": 0
    }
  },
  "message": "Circuit breakers open: external_api"
}
```

---

## å…³é”®ç‰¹æ€§

### 1. ç†”æ–­å™¨çŠ¶æ€è½¬æ¢

```
CLOSED (å…³é—­) â†’ OPEN (æ‰“å¼€) â†’ HALF_OPEN (åŠå¼€) â†’ CLOSED
     â†‘                                              â†“
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**çŠ¶æ€è¯´æ˜ï¼š**
- **CLOSED**ï¼šæ­£å¸¸çŠ¶æ€ï¼Œè¯·æ±‚æ­£å¸¸é€šè¿‡
- **OPEN**ï¼šç†”æ–­çŠ¶æ€ï¼Œå¿«é€Ÿå¤±è´¥ï¼Œä¸è°ƒç”¨æœåŠ¡
- **HALF_OPEN**ï¼šå°è¯•æ¢å¤ï¼Œå…è®¸å°‘é‡è¯·æ±‚é€šè¿‡

### 2. é™çº§ç­–ç•¥

**ç¼“å­˜å“åº”ç­–ç•¥ï¼š**
- è¿”å›ç¼“å­˜çš„å“åº”
- é€‚ç”¨äºå¯ä»¥å®¹å¿è¿‡æœŸæ•°æ®çš„åœºæ™¯

**é»˜è®¤å“åº”ç­–ç•¥ï¼š**
- è¿”å›é¢„å®šä¹‰çš„é»˜è®¤å“åº”
- é€‚ç”¨äºæœ‰åˆç†é»˜è®¤å€¼çš„åœºæ™¯

**å¤‡ç”¨æœåŠ¡ç­–ç•¥ï¼š**
- è°ƒç”¨å¤‡ç”¨æœåŠ¡
- é€‚ç”¨äºæœ‰å¤‡ç”¨æœåŠ¡çš„åœºæ™¯

### 3. å‚æ•°é…ç½®

| å‚æ•° | è¯´æ˜ | æ¨èå€¼ |
|------|------|--------|
| failure_threshold | å¤±è´¥é˜ˆå€¼ | 3-5æ¬¡ |
| success_threshold | æˆåŠŸé˜ˆå€¼ | 2-3æ¬¡ |
| timeout | ç†”æ–­å™¨æ‰“å¼€æ—¶é—´ | 30-60ç§’ |
| half_open_timeout | åŠå¼€çŠ¶æ€æŒç»­æ—¶é—´ | 15-30ç§’ |

---

## åœ¨ AI Agent åç«¯ä¸­çš„åº”ç”¨

### LLM API ç†”æ–­å™¨

```python
# åˆ›å»º LLM API ç†”æ–­å™¨
llm_breaker = CircuitBreaker(
    name="llm_api",
    failure_threshold=5,      # LLM API å¯ä»¥å®¹å¿æ›´å¤šå¤±è´¥
    success_threshold=2,
    timeout=60,               # æ›´é•¿çš„æ¢å¤æ—¶é—´
    half_open_timeout=30
)

# æ³¨å†Œé™çº§ç­–ç•¥ï¼ˆä½¿ç”¨ç¼“å­˜å“åº”ï¼‰
degradation_manager.register_strategy(
    "llm_cached_response",
    CachedResponseStrategy(llm_response_cache)
)

# è°ƒç”¨ LLM APIï¼ˆå¸¦é™çº§ï¼‰
async def call_llm_with_degradation(prompt: str):
    return await degradation_manager.call_with_degradation(
        name="llm_api",
        func=call_llm_api,
        strategy_name="llm_cached_response",
        prompt=prompt
    )
```

### å¥åº·æ£€æŸ¥é›†æˆ

```python
@app.get("/ready")
async def ready():
    """å°±ç»ªæ£€æŸ¥ï¼ˆé›†æˆç†”æ–­å™¨ï¼‰"""
    # æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
    breakers = {
        name: breaker.get_state()
        for name, breaker in degradation_manager.breakers.items()
    }

    # åˆ¤æ–­æœåŠ¡çŠ¶æ€
    open_breakers = [
        name for name, state in breakers.items()
        if state["state"] == "open"
    ]

    if open_breakers:
        # æœ‰ç†”æ–­å™¨æ‰“å¼€ï¼ŒæœåŠ¡é™çº§
        return {
            "status": "degraded",
            "message": f"Circuit breakers open: {', '.join(open_breakers)}",
            "breakers": breakers
        }

    return {
        "status": "healthy",
        "breakers": breakers
    }
```

---

## æ€»ç»“

é™çº§ä¸ç†”æ–­ç­–ç•¥çš„å…³é”®ï¼š

1. **ç†”æ–­å™¨æ¨¡å¼**ï¼šè¿ç»­å¤±è´¥æ—¶å¿«é€Ÿå¤±è´¥ï¼Œé¿å…é›ªå´©
2. **çŠ¶æ€è½¬æ¢**ï¼šCLOSED â†’ OPEN â†’ HALF_OPEN â†’ CLOSED
3. **é™çº§ç­–ç•¥**ï¼šç¼“å­˜å“åº”ã€é»˜è®¤å“åº”ã€å¤‡ç”¨æœåŠ¡
4. **è‡ªåŠ¨æ¢å¤**ï¼šåŠå¼€çŠ¶æ€å°è¯•æ¢å¤
5. **å¥åº·æ£€æŸ¥é›†æˆ**ï¼šæ ¹æ®ç†”æ–­å™¨çŠ¶æ€åˆ¤æ–­æœåŠ¡å¥åº·
6. **å‚æ•°è°ƒä¼˜**ï¼šå¹³è¡¡å¿«é€Ÿå¤±è´¥å’Œå®¹é”™èƒ½åŠ›

åœ¨ AI Agent åç«¯ä¸­ï¼Œç†”æ–­å™¨å’Œé™çº§ç­–ç•¥å¯ä»¥ï¼š
- é˜²æ­¢ LLM API æ•…éšœå¯¼è‡´æœåŠ¡é›ªå´©
- ä½¿ç”¨ç¼“å­˜å“åº”æä¾›é™çº§æœåŠ¡
- è‡ªåŠ¨æ£€æµ‹å’Œæ¢å¤æ•…éšœæœåŠ¡
- æé«˜ç³»ç»Ÿçš„å¯ç”¨æ€§å’Œå¯é æ€§
