# å®æˆ˜ä»£ç  03ï¼šçŠ¶æ€ç®¡ç†å®ç°

> å®ç° JSONL çŠ¶æ€æŒä¹…åŒ–å’Œåˆ†æ”¯ç®¡ç†ç³»ç»Ÿ

---

## ä»£ç ç›®æ ‡

å®ç°å®Œæ•´çš„çŠ¶æ€ç®¡ç†ç³»ç»Ÿï¼ŒåŒ…å«ï¼š
- JSONL è¿½åŠ å†™å…¥
- Session åŠ è½½ä¸è§£æ
- æ ‘å½¢åˆ†æ”¯ç®¡ç†
- Context æ„å»º

**ä»£ç é•¿åº¦ï¼š** ~200 è¡Œ
**è¿è¡Œç¯å¢ƒï¼š** Node.js 18+, TypeScript

---

## å®Œæ•´ä»£ç 

```typescript
/**
 * çŠ¶æ€ç®¡ç†å®ç°
 * æ¼”ç¤ºï¼šJSONL æŒä¹…åŒ– + æ ‘å½¢åˆ†æ”¯ç®¡ç†
 */

import fs from 'fs/promises';
import path from 'path';
import { randomUUID } from 'crypto';

// ===== 1. ç±»å‹å®šä¹‰ =====

interface SessionEntry {
  id: string;
  parentId?: string;
  timestamp: number;
  type: 'user' | 'assistant' | 'tool' | 'tool_result';
  content?: string;
  toolCalls?: any[];
  toolCallId?: string;
  output?: string;
  details?: any;
}

interface Message {
  role: 'user' | 'assistant' | 'tool';
  content: string;
  toolCalls?: any[];
  toolCallId?: string;
}

// ===== 2. Session Writer ç±» =====

class SessionWriter {
  private filePath: string;
  private buffer: SessionEntry[] = [];
  private bufferSize = 10;

  constructor(sessionId: string, sessionDir: string = './.pi/sessions') {
    this.filePath = path.join(sessionDir, `${sessionId}.jsonl`);
  }

  // åˆå§‹åŒ–ï¼ˆåˆ›å»ºç›®å½•ï¼‰
  async init(): Promise<void> {
    const dir = path.dirname(this.filePath);
    await fs.mkdir(dir, { recursive: true });
    console.log(`ğŸ“ Session file: ${this.filePath}`);
  }

  // è¿½åŠ æ¡ç›®
  private append(entry: SessionEntry): void {
    this.buffer.push(entry);

    // è¾¾åˆ°ç¼“å†²åŒºå¤§å°æ—¶åˆ·æ–°
    if (this.buffer.length >= this.bufferSize) {
      this.flush();
    }
  }

  // åˆ·æ–°ç¼“å†²åŒº
  private async flush(): Promise<void> {
    if (this.buffer.length === 0) return;

    const lines = this.buffer.map(e => JSON.stringify(e) + '\n').join('');
    await fs.appendFile(this.filePath, lines);

    console.log(`ğŸ’¾ Flushed ${this.buffer.length} entries to disk`);
    this.buffer = [];
  }

  // è¿½åŠ ç”¨æˆ·æ¶ˆæ¯
  async appendUser(content: string, parentId?: string): Promise<string> {
    const entry: SessionEntry = {
      id: randomUUID(),
      parentId,
      type: 'user',
      content,
      timestamp: Date.now()
    };

    this.append(entry);
    await this.flush();  // ç«‹å³åˆ·æ–°ç”¨æˆ·æ¶ˆæ¯

    console.log(`ğŸ“ User message: ${entry.id}`);
    return entry.id;
  }

  // è¿½åŠ åŠ©æ‰‹å“åº”
  async appendAssistant(
    content: string,
    parentId: string,
    toolCalls?: any[]
  ): Promise<string> {
    const entry: SessionEntry = {
      id: randomUUID(),
      parentId,
      type: 'assistant',
      content,
      toolCalls,
      timestamp: Date.now()
    };

    this.append(entry);
    await this.flush();

    console.log(`ğŸ¤– Assistant message: ${entry.id}`);
    return entry.id;
  }

  // è¿½åŠ å·¥å…·è°ƒç”¨
  async appendTool(
    name: string,
    params: any,
    toolCallId: string,
    parentId: string
  ): Promise<string> {
    const entry: SessionEntry = {
      id: randomUUID(),
      parentId,
      type: 'tool',
      content: JSON.stringify({ name, params }),
      toolCallId,
      timestamp: Date.now()
    };

    this.append(entry);
    return entry.id;
  }

  // è¿½åŠ å·¥å…·ç»“æœ
  async appendToolResult(
    toolCallId: string,
    output: string,
    details: any,
    parentId: string
  ): Promise<string> {
    const entry: SessionEntry = {
      id: randomUUID(),
      parentId,
      type: 'tool_result',
      toolCallId,
      output,
      details,
      timestamp: Date.now()
    };

    this.append(entry);
    return entry.id;
  }

  // å…³é—­ï¼ˆåˆ·æ–°å‰©ä½™ç¼“å†²åŒºï¼‰
  async close(): Promise<void> {
    await this.flush();
    console.log(`âœ… Session saved: ${this.filePath}`);
  }
}

// ===== 3. Session Loader ç±» =====

class SessionLoader {
  private sessionPath: string;
  private entries: SessionEntry[] = [];

  constructor(sessionPath: string) {
    this.sessionPath = sessionPath;
  }

  // åŠ è½½ Session
  async load(): Promise<void> {
    console.log(`ğŸ“‚ Loading session: ${this.sessionPath}`);

    const content = await fs.readFile(this.sessionPath, 'utf-8');
    const lines = content.split('\n');

    for (const line of lines) {
      if (line.trim()) {
        try {
          const entry = JSON.parse(line);
          this.entries.push(entry);
        } catch (error) {
          console.error('Failed to parse line:', line);
        }
      }
    }

    console.log(`âœ… Loaded ${this.entries.length} entries`);
  }

  // è·å–æ‰€æœ‰æ¡ç›®
  getEntries(): SessionEntry[] {
    return this.entries;
  }

  // è·å–å…ƒæ•°æ®
  getMetadata() {
    const firstEntry = this.entries[0];
    const lastEntry = this.entries[this.entries.length - 1];

    return {
      sessionId: path.basename(this.sessionPath, '.jsonl'),
      entryCount: this.entries.length,
      startTime: firstEntry?.timestamp,
      lastTime: lastEntry?.timestamp
    };
  }
}

// ===== 4. Session Branch ç±» =====

class SessionBranch {
  private entries: Map<string, SessionEntry>;
  private children: Map<string, string[]>;

  constructor(entries: SessionEntry[]) {
    this.entries = new Map();
    this.children = new Map();

    // æ„å»ºç´¢å¼•
    for (const entry of entries) {
      this.entries.set(entry.id, entry);

      if (entry.parentId) {
        if (!this.children.has(entry.parentId)) {
          this.children.set(entry.parentId, []);
        }
        this.children.get(entry.parentId)!.push(entry.id);
      }
    }
  }

  // è·å–ä»æ ¹åˆ°æŸä¸ªæ¡ç›®çš„è·¯å¾„
  getPath(entryId: string): SessionEntry[] {
    const path: SessionEntry[] = [];
    let currentId: string | undefined = entryId;

    while (currentId) {
      const entry = this.entries.get(currentId);
      if (!entry) break;

      path.unshift(entry);
      currentId = entry.parentId;
    }

    return path;
  }

  // è·å–æ‰€æœ‰å¶å­èŠ‚ç‚¹
  getLeaves(): SessionEntry[] {
    const leaves: SessionEntry[] = [];

    for (const entry of this.entries.values()) {
      const childIds = this.children.get(entry.id) || [];
      if (childIds.length === 0) {
        leaves.push(entry);
      }
    }

    return leaves;
  }

  // è·å–åˆ†æ”¯ç‚¹ï¼ˆæœ‰å¤šä¸ªå­èŠ‚ç‚¹çš„æ¡ç›®ï¼‰
  getBranchPoints(): SessionEntry[] {
    const branchPoints: SessionEntry[] = [];

    for (const [parentId, childIds] of this.children.entries()) {
      if (childIds.length > 1) {
        const entry = this.entries.get(parentId);
        if (entry) {
          branchPoints.push(entry);
        }
      }
    }

    return branchPoints;
  }

  // æ„å»º Contextï¼ˆä»è·¯å¾„ï¼‰
  buildContext(entryId?: string): Message[] {
    // ç¡®å®šå¶å­èŠ‚ç‚¹
    const leaves = this.getLeaves();
    const leafId = entryId || leaves[0]?.id;

    if (!leafId) {
      return [];
    }

    // è·å–è·¯å¾„
    const path = this.getPath(leafId);

    // è½¬æ¢ä¸º Message
    const messages: Message[] = [];

    for (const entry of path) {
      if (entry.type === 'user') {
        messages.push({
          role: 'user',
          content: entry.content!
        });
      } else if (entry.type === 'assistant') {
        messages.push({
          role: 'assistant',
          content: entry.content!,
          toolCalls: entry.toolCalls
        });
      } else if (entry.type === 'tool_result') {
        messages.push({
          role: 'tool',
          content: entry.output!,
          toolCallId: entry.toolCallId
        });
      }
    }

    return messages;
  }
}

// ===== 5. å®Œæ•´ç¤ºä¾‹ï¼šå¸¦çŠ¶æ€ç®¡ç†çš„ Agent =====

async function agentWithStateManagement(userMessage: string): Promise<void> {
  // åˆ›å»º Session
  const sessionId = randomUUID();
  const writer = new SessionWriter(sessionId);
  await writer.init();

  console.log(`\nğŸ¤– Agent started with state management`);
  console.log(`ğŸ“ User: ${userMessage}\n`);

  // è¿½åŠ ç”¨æˆ·æ¶ˆæ¯
  let currentId = await writer.appendUser(userMessage);

  // æ¨¡æ‹Ÿ Agent å¾ªç¯
  for (let i = 0; i < 3; i++) {
    console.log(`\n=== Iteration ${i + 1} ===`);

    // æ¨¡æ‹ŸåŠ©æ‰‹å“åº”
    const assistantContent = `è¿™æ˜¯ç¬¬ ${i + 1} è½®å“åº”`;
    const assistantId = await writer.appendAssistant(
      assistantContent,
      currentId,
      i < 2 ? [{ id: `call-${i}`, name: 'test', params: {} }] : undefined
    );

    if (i < 2) {
      // æ¨¡æ‹Ÿå·¥å…·è°ƒç”¨
      const toolId = await writer.appendTool(
        'test',
        { iteration: i + 1 },
        `call-${i}`,
        assistantId
      );

      // æ¨¡æ‹Ÿå·¥å…·ç»“æœ
      const resultId = await writer.appendToolResult(
        `call-${i}`,
        `å·¥å…·æ‰§è¡Œç»“æœ ${i + 1}`,
        { iteration: i + 1 },
        toolId
      );

      currentId = resultId;
    } else {
      currentId = assistantId;
    }
  }

  // å…³é—­ Session
  await writer.close();

  console.log(`\n--- Session Analysis ---`);

  // åŠ è½½ Session
  const loader = new SessionLoader(writer['filePath']);
  await loader.load();

  // è·å–å…ƒæ•°æ®
  const metadata = loader.getMetadata();
  console.log(`\nğŸ“Š Metadata:`);
  console.log(`   Session ID: ${metadata.sessionId}`);
  console.log(`   Entry count: ${metadata.entryCount}`);
  console.log(`   Duration: ${metadata.lastTime! - metadata.startTime!}ms`);

  // æ„å»ºåˆ†æ”¯
  const branch = new SessionBranch(loader.getEntries());

  // è·å–å¶å­èŠ‚ç‚¹
  const leaves = branch.getLeaves();
  console.log(`\nğŸŒ¿ Leaves: ${leaves.length}`);
  for (const leaf of leaves) {
    console.log(`   - ${leaf.id} (${leaf.type})`);
  }

  // è·å–åˆ†æ”¯ç‚¹
  const branchPoints = branch.getBranchPoints();
  console.log(`\nğŸ”€ Branch points: ${branchPoints.length}`);

  // æ„å»º Context
  const context = branch.buildContext();
  console.log(`\nğŸ’¬ Context messages: ${context.length}`);
  for (const msg of context) {
    console.log(`   - ${msg.role}: ${msg.content?.substring(0, 50)}...`);
  }
}

// ===== 6. åˆ†æ”¯ç¤ºä¾‹ =====

async function branchExample(): Promise<void> {
  console.log(`\n=== Branch Example ===\n`);

  const sessionId = randomUUID();
  const writer = new SessionWriter(sessionId);
  await writer.init();

  // ä¸»çº¿
  const msg1 = await writer.appendUser('åˆ›å»ºæ–‡ä»¶');
  const msg2 = await writer.appendAssistant('æ–‡ä»¶å·²åˆ›å»º', msg1);
  const msg3 = await writer.appendUser('ä¿®æ”¹æ–‡ä»¶', msg2);
  const msg4 = await writer.appendAssistant('æ–‡ä»¶å·²ä¿®æ”¹', msg3);

  // åˆ†æ”¯ï¼ˆä» msg2 åˆ†å‰ï¼‰
  const msg5 = await writer.appendUser('æ”¹ç”¨ TypeScript', msg2);
  const msg6 = await writer.appendAssistant('TypeScript æ–‡ä»¶å·²åˆ›å»º', msg5);

  await writer.close();

  // åŠ è½½å¹¶åˆ†æ
  const loader = new SessionLoader(writer['filePath']);
  await loader.load();

  const branch = new SessionBranch(loader.getEntries());

  console.log(`\nğŸ“Š Branch analysis:`);
  console.log(`   Total entries: ${loader.getEntries().length}`);
  console.log(`   Leaves: ${branch.getLeaves().length}`);
  console.log(`   Branch points: ${branch.getBranchPoints().length}`);

  // è·å–ä¸¤ä¸ªåˆ†æ”¯çš„è·¯å¾„
  const leaves = branch.getLeaves();

  console.log(`\nğŸŒ¿ Branch 1 (main):`);
  const path1 = branch.getPath(leaves[0].id);
  for (const entry of path1) {
    console.log(`   ${entry.id}: ${entry.content}`);
  }

  console.log(`\nğŸŒ¿ Branch 2 (alternative):`);
  const path2 = branch.getPath(leaves[1].id);
  for (const entry of path2) {
    console.log(`   ${entry.id}: ${entry.content}`);
  }

  // æ„å»ºä¸¤ä¸ªåˆ†æ”¯çš„ Context
  const context1 = branch.buildContext(leaves[0].id);
  const context2 = branch.buildContext(leaves[1].id);

  console.log(`\nğŸ’¬ Context 1: ${context1.length} messages`);
  console.log(`ğŸ’¬ Context 2: ${context2.length} messages`);
}

// ===== 7. ä¸»å‡½æ•° =====

async function main() {
  // ç¤ºä¾‹ 1ï¼šå¸¦çŠ¶æ€ç®¡ç†çš„ Agent
  await agentWithStateManagement('æµ‹è¯•çŠ¶æ€ç®¡ç†');

  // ç¤ºä¾‹ 2ï¼šåˆ†æ”¯ç®¡ç†
  await branchExample();
}

main();
```

---

## ä»£ç è¯¦è§£

### 1. JSONL è¿½åŠ å†™å…¥

```typescript
private async flush(): Promise<void> {
  if (this.buffer.length === 0) return;

  const lines = this.buffer.map(e => JSON.stringify(e) + '\n').join('');
  await fs.appendFile(this.filePath, lines);

  this.buffer = [];
}
```

**å…³é”®ç‚¹ï¼š**
- æ‰¹é‡å†™å…¥ï¼ˆç¼“å†²åŒºï¼‰
- `appendFile`ï¼šè¿½åŠ è€Œéé‡å†™
- O(1) æ—¶é—´å¤æ‚åº¦

---

### 2. æ ‘å½¢åˆ†æ”¯ç®¡ç†

```typescript
class SessionBranch {
  private entries: Map<string, SessionEntry>;
  private children: Map<string, string[]>;  // parentId â†’ childIds

  getPath(entryId: string): SessionEntry[] {
    const path: SessionEntry[] = [];
    let currentId: string | undefined = entryId;

    while (currentId) {
      const entry = this.entries.get(currentId);
      if (!entry) break;

      path.unshift(entry);
      currentId = entry.parentId;
    }

    return path;
  }
}
```

**å…³é”®ç‚¹ï¼š**
- é€šè¿‡ `parentId` æ„å»ºæ ‘å½¢ç»“æ„
- `getPath`ï¼šä»å¶å­å›æº¯åˆ°æ ¹
- å•æ–‡ä»¶å­˜å‚¨å¤šä¸ªåˆ†æ”¯

---

### 3. Context æ„å»º

```typescript
buildContext(entryId?: string): Message[] {
  const leaves = this.getLeaves();
  const leafId = entryId || leaves[0]?.id;

  const path = this.getPath(leafId);

  const messages: Message[] = [];
  for (const entry of path) {
    if (entry.type === 'user') {
      messages.push({ role: 'user', content: entry.content! });
    }
    // ...
  }

  return messages;
}
```

**å…³é”®ç‚¹ï¼š**
- ä» Session æå–ç‰¹å®šåˆ†æ”¯
- è½¬æ¢ä¸º LLM å¯ç”¨çš„ Message æ ¼å¼
- ä»…åŒ…å«å½“å‰åˆ†æ”¯çš„æ¶ˆæ¯

---

## è¿è¡Œç¤ºä¾‹

### è¾“å‡º

```
ğŸ¤– Agent started with state management
ğŸ“ User: æµ‹è¯•çŠ¶æ€ç®¡ç†

ğŸ“ Session file: ./.pi/sessions/abc-123.jsonl

=== Iteration 1 ===
ğŸ“ User message: msg-1
ğŸ¤– Assistant message: msg-2
ğŸ’¾ Flushed 2 entries to disk

=== Iteration 2 ===
ğŸ¤– Assistant message: msg-3
ğŸ’¾ Flushed 2 entries to disk

=== Iteration 3 ===
ğŸ¤– Assistant message: msg-4
ğŸ’¾ Flushed 1 entries to disk

âœ… Session saved: ./.pi/sessions/abc-123.jsonl

--- Session Analysis ---

ğŸ“‚ Loading session: ./.pi/sessions/abc-123.jsonl
âœ… Loaded 7 entries

ğŸ“Š Metadata:
   Session ID: abc-123
   Entry count: 7
   Duration: 15ms

ğŸŒ¿ Leaves: 1
   - msg-4 (assistant)

ğŸ”€ Branch points: 0

ğŸ’¬ Context messages: 4
   - user: æµ‹è¯•çŠ¶æ€ç®¡ç†...
   - assistant: è¿™æ˜¯ç¬¬ 1 è½®å“åº”...
   - tool: å·¥å…·æ‰§è¡Œç»“æœ 1...
   - assistant: è¿™æ˜¯ç¬¬ 2 è½®å“åº”...
```

---

### JSONL æ–‡ä»¶å†…å®¹

```jsonl
{"id":"msg-1","type":"user","content":"æµ‹è¯•çŠ¶æ€ç®¡ç†","timestamp":1708300000}
{"id":"msg-2","parentId":"msg-1","type":"assistant","content":"è¿™æ˜¯ç¬¬ 1 è½®å“åº”","toolCalls":[...],"timestamp":1708300001}
{"id":"msg-3","parentId":"msg-2","type":"tool","content":"{\"name\":\"test\",\"params\":{}}","toolCallId":"call-0","timestamp":1708300002}
{"id":"msg-4","parentId":"msg-3","type":"tool_result","toolCallId":"call-0","output":"å·¥å…·æ‰§è¡Œç»“æœ 1","timestamp":1708300003}
{"id":"msg-5","parentId":"msg-4","type":"assistant","content":"è¿™æ˜¯ç¬¬ 2 è½®å“åº”","toolCalls":[...],"timestamp":1708300004}
{"id":"msg-6","parentId":"msg-5","type":"tool","content":"{\"name\":\"test\",\"params\":{}}","toolCallId":"call-1","timestamp":1708300005}
{"id":"msg-7","parentId":"msg-6","type":"tool_result","toolCallId":"call-1","output":"å·¥å…·æ‰§è¡Œç»“æœ 2","timestamp":1708300006}
```

---

## åˆ†æ”¯ç¤ºä¾‹è¾“å‡º

```
=== Branch Example ===

ğŸ“ Session file: ./.pi/sessions/xyz-456.jsonl
ğŸ’¾ Flushed 6 entries to disk
âœ… Session saved: ./.pi/sessions/xyz-456.jsonl

ğŸ“‚ Loading session: ./.pi/sessions/xyz-456.jsonl
âœ… Loaded 6 entries

ğŸ“Š Branch analysis:
   Total entries: 6
   Leaves: 2
   Branch points: 1

ğŸŒ¿ Branch 1 (main):
   msg-1: åˆ›å»ºæ–‡ä»¶
   msg-2: æ–‡ä»¶å·²åˆ›å»º
   msg-3: ä¿®æ”¹æ–‡ä»¶
   msg-4: æ–‡ä»¶å·²ä¿®æ”¹

ğŸŒ¿ Branch 2 (alternative):
   msg-1: åˆ›å»ºæ–‡ä»¶
   msg-2: æ–‡ä»¶å·²åˆ›å»º
   msg-5: æ”¹ç”¨ TypeScript
   msg-6: TypeScript æ–‡ä»¶å·²åˆ›å»º

ğŸ’¬ Context 1: 4 messages
ğŸ’¬ Context 2: 4 messages
```

---

## å…³é”®æ´å¯Ÿ

### 1. è¿½åŠ å†™å…¥ vs é‡å†™

```typescript
// âŒ JSONï¼šæ¯æ¬¡é‡å†™æ•´ä¸ªæ–‡ä»¶ O(n)
const data = JSON.parse(fs.readFileSync('session.json'));
data.messages.push(newMessage);
fs.writeFileSync('session.json', JSON.stringify(data));

// âœ… JSONLï¼šè¿½åŠ ä¸€è¡Œ O(1)
fs.appendFileSync('session.jsonl', JSON.stringify(newMessage) + '\n');
```

**æ€§èƒ½å¯¹æ¯”ï¼š**
- 100 æ¡æ¶ˆæ¯ï¼šJSON ~10msï¼ŒJSONL ~0.1ms
- 1000 æ¡æ¶ˆæ¯ï¼šJSON ~100msï¼ŒJSONL ~0.1ms

---

### 2. å•æ–‡ä»¶å¤šåˆ†æ”¯

```
JSONL æ–‡ä»¶ï¼š
msg-1 (root)
msg-2 (parentId: msg-1)
msg-3 (parentId: msg-2) â† ä¸»çº¿
msg-4 (parentId: msg-3)
msg-5 (parentId: msg-2) â† åˆ†æ”¯
msg-6 (parentId: msg-5)

æ ‘å½¢ç»“æ„ï¼š
     msg-1
       |
     msg-2
     /   \
  msg-3  msg-5
    |      |
  msg-4  msg-6
```

**ä¼˜åŠ¿ï¼š**
- å•æ–‡ä»¶å­˜å‚¨æ‰€æœ‰åˆ†æ”¯
- æ— éœ€åˆ›å»ºæ–°æ–‡ä»¶
- æ˜“äºç®¡ç†å’Œå¤‡ä»½

---

### 3. æ‰¹é‡å†™å…¥ä¼˜åŒ–

```typescript
private buffer: SessionEntry[] = [];
private bufferSize = 10;

append(entry: SessionEntry): void {
  this.buffer.push(entry);

  if (this.buffer.length >= this.bufferSize) {
    this.flush();  // è¾¾åˆ°é˜ˆå€¼æ—¶åˆ·æ–°
  }
}
```

**ä¼˜åŠ¿ï¼š**
- å‡å°‘ç£ç›˜ I/O æ¬¡æ•°
- æé«˜å†™å…¥æ€§èƒ½
- ç”¨æˆ·æ¶ˆæ¯ç«‹å³åˆ·æ–°ï¼ˆé‡è¦æ•°æ®ï¼‰

---

## æ‰©å±•ç»ƒä¹ 

### ç»ƒä¹  1ï¼šæ·»åŠ å‹ç¼©

```typescript
import zlib from 'zlib';

class CompressedSessionWriter extends SessionWriter {
  private gzipStream: zlib.Gzip;

  async init(): Promise<void> {
    await super.init();
    this.gzipStream = zlib.createGzip();
    this.gzipStream.pipe(fs.createWriteStream(this.filePath + '.gz'));
  }

  protected async flush(): Promise<void> {
    const lines = this.buffer.map(e => JSON.stringify(e) + '\n').join('');
    this.gzipStream.write(lines);
    this.buffer = [];
  }
}
```

---

### ç»ƒä¹  2ï¼šæ·»åŠ ç´¢å¼•

```typescript
class IndexedSessionLoader extends SessionLoader {
  private index: Map<string, number> = new Map();

  async load(): Promise<void> {
    await super.load();

    // æ„å»ºç´¢å¼•
    this.entries.forEach((entry, index) => {
      this.index.set(entry.id, index);
    });
  }

  getEntry(id: string): SessionEntry | undefined {
    const index = this.index.get(id);
    return index !== undefined ? this.entries[index] : undefined;
  }
}
```

---

### ç»ƒä¹  3ï¼šæ·»åŠ å¢é‡åŠ è½½

```typescript
class IncrementalSessionLoader {
  private offset: number = 0;
  private batchSize: number = 100;

  async loadNext(): Promise<SessionEntry[]> {
    const stream = fs.createReadStream(this.sessionPath, {
      start: this.offset,
      encoding: 'utf-8'
    });

    const entries: SessionEntry[] = [];
    let count = 0;

    for await (const line of readline.createInterface({ input: stream })) {
      if (line.trim()) {
        entries.push(JSON.parse(line));
        count++;

        if (count >= this.batchSize) break;
      }

      this.offset += Buffer.byteLength(line + '\n', 'utf-8');
    }

    return entries;
  }
}
```

---

## æ€»ç»“

**æœ¬ç¤ºä¾‹å±•ç¤ºäº†å®Œæ•´çš„çŠ¶æ€ç®¡ç†ç³»ç»Ÿï¼š**

1. **JSONL è¿½åŠ å†™å…¥**ï¼šO(1) æ€§èƒ½ï¼Œæ‰¹é‡åˆ·æ–°
2. **æ ‘å½¢åˆ†æ”¯ç®¡ç†**ï¼šé€šè¿‡ parentId å®ç°ï¼Œå•æ–‡ä»¶å­˜å‚¨
3. **Session åŠ è½½**ï¼šè§£æ JSONLï¼Œæ„å»ºç´¢å¼•
4. **Context æ„å»º**ï¼šä»ç‰¹å®šåˆ†æ”¯æå–æ¶ˆæ¯

**å…³é”®ä»£ç ï¼š**
```typescript
// è¿½åŠ å†™å…¥
await fs.appendFile(filePath, JSON.stringify(entry) + '\n');

// æ„å»ºåˆ†æ”¯
const path = branch.getPath(leafId);

// æ„å»º Context
const messages = path.map(entry => ({
  role: entry.type,
  content: entry.content
}));
```

**ä¸‹ä¸€æ­¥ï¼š** å­¦ä¹ å®Œæ•´ Agent ç¤ºä¾‹ï¼ˆå®æˆ˜ä»£ç  04ï¼‰ã€‚
