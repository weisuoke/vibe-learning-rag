# 最小可用

> 掌握以下内容，就能开始进行 RAG 文档加载开发

---

## 20% 核心知识

文档加载看起来复杂，但实际开发中只需要掌握以下核心知识：

```
┌─────────────────────────────────────────────────────────────┐
│                    最小可用知识                               │
│                                                             │
│  1. 使用 LangChain 的现成 Loader（不要自己造轮子）             │
│  2. 理解 Document 对象结构（page_content + metadata）         │
│  3. 掌握 PDF 和 TXT 两种最常用格式                            │
│  4. 知道如何处理加载失败                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 4.1 使用 LangChain Loader（推荐）

**核心原则：不要自己写解析器，用现成的！**

```python
# 安装依赖
# pip install langchain langchain-community pypdf python-docx beautifulsoup4

from langchain_community.document_loaders import (
    PyPDFLoader,           # PDF
    Docx2txtLoader,        # Word
    UnstructuredHTMLLoader, # HTML
    UnstructuredMarkdownLoader,  # Markdown
    TextLoader             # TXT
)

# 使用方式完全一致！
loader = PyPDFLoader("document.pdf")
documents = loader.load()

loader = TextLoader("notes.txt")
documents = loader.load()
```

### 为什么用 LangChain？

| 自己写 | 用 LangChain |
|-------|-------------|
| 需要处理各种边界情况 | 已经处理好了 |
| 需要维护多个解析库 | 统一接口 |
| 出问题自己排查 | 社区支持 |
| 重复造轮子 | 专注业务逻辑 |

---

## 4.2 理解 Document 对象

**只需要记住两个字段：**

```python
from langchain.schema import Document

# Document 对象结构
doc = Document(
    page_content="文本内容...",  # 字符串：文档的文本内容
    metadata={"source": "..."}   # 字典：元数据信息
)

# 访问内容
print(doc.page_content)  # 获取文本
print(doc.metadata)      # 获取元数据
print(doc.metadata["source"])  # 获取特定元数据
```

### 常用元数据字段

```python
metadata = {
    "source": "policy.pdf",    # 必有：来源文件路径
    "page": 1,                 # PDF 特有：页码
    "total_pages": 10,         # PDF 特有：总页数
    "file_type": "pdf",        # 可选：文件类型
    # ... 可以添加任意自定义字段
}
```

---

## 4.3 最常用的两种格式

### PDF 加载（最常用）

```python
from langchain_community.document_loaders import PyPDFLoader

def load_pdf(file_path: str):
    """加载 PDF 文件，返回按页分割的文档列表"""
    loader = PyPDFLoader(file_path)
    documents = loader.load()

    print(f"加载了 {len(documents)} 页")
    for doc in documents:
        print(f"第 {doc.metadata['page']} 页: {doc.page_content[:50]}...")

    return documents

# 使用
docs = load_pdf("company_policy.pdf")
```

### TXT 加载（最简单）

```python
from langchain_community.document_loaders import TextLoader

def load_txt(file_path: str, encoding: str = "utf-8"):
    """加载文本文件"""
    loader = TextLoader(file_path, encoding=encoding)
    documents = loader.load()

    print(f"加载了 {len(documents[0].page_content)} 个字符")

    return documents

# 使用
docs = load_txt("notes.txt")

# 中文文件可能需要指定编码
docs = load_txt("chinese_doc.txt", encoding="gbk")
```

---

## 4.4 处理加载失败

**常见错误及解决方案：**

```python
from langchain_community.document_loaders import PyPDFLoader, TextLoader

def safe_load(file_path: str):
    """安全加载文档，处理常见错误"""

    # 根据扩展名选择 Loader
    if file_path.endswith('.pdf'):
        loader = PyPDFLoader(file_path)
    elif file_path.endswith('.txt'):
        loader = TextLoader(file_path)
    else:
        print(f"不支持的格式: {file_path}")
        return []

    try:
        documents = loader.load()
        return documents

    except FileNotFoundError:
        print(f"文件不存在: {file_path}")
        return []

    except UnicodeDecodeError:
        # 尝试其他编码
        print(f"编码错误，尝试 GBK 编码...")
        loader = TextLoader(file_path, encoding='gbk')
        return loader.load()

    except Exception as e:
        print(f"加载失败: {e}")
        return []

# 使用
docs = safe_load("document.pdf")
if docs:
    print("加载成功！")
```

---

## 4.5 批量加载目录

**实际项目中最常用的模式：**

```python
import os
from pathlib import Path
from langchain_community.document_loaders import (
    PyPDFLoader, TextLoader, Docx2txtLoader
)

def load_directory(dir_path: str):
    """加载目录下所有支持的文档"""

    # 扩展名到 Loader 的映射
    loader_map = {
        '.pdf': PyPDFLoader,
        '.txt': TextLoader,
        '.docx': Docx2txtLoader,
    }

    all_documents = []

    # 遍历目录
    for file_path in Path(dir_path).rglob('*'):
        if file_path.is_file():
            ext = file_path.suffix.lower()

            if ext in loader_map:
                try:
                    loader = loader_map[ext](str(file_path))
                    docs = loader.load()
                    all_documents.extend(docs)
                    print(f"✓ 加载: {file_path.name}")
                except Exception as e:
                    print(f"✗ 失败: {file_path.name} - {e}")

    print(f"\n总共加载 {len(all_documents)} 个文档块")
    return all_documents

# 使用
docs = load_directory("./knowledge_base/")
```

---

## 这些知识足以：

- ✅ 加载企业常见的 PDF、Word、TXT 文档
- ✅ 构建基础的 RAG 知识库
- ✅ 处理常见的加载错误
- ✅ 批量处理文档目录
- ✅ 为后续的文本分块做好准备

---

## 快速参考卡

```python
# ===== 1. 安装依赖 =====
# pip install langchain langchain-community pypdf

# ===== 2. 导入 Loader =====
from langchain_community.document_loaders import (
    PyPDFLoader,    # PDF
    TextLoader,     # TXT
    Docx2txtLoader, # Word
)

# ===== 3. 加载文档 =====
loader = PyPDFLoader("file.pdf")
docs = loader.load()

# ===== 4. 访问内容 =====
for doc in docs:
    print(doc.page_content)      # 文本内容
    print(doc.metadata["source"]) # 来源文件

# ===== 5. 下一步：文本分块 =====
# 将 docs 传给 TextSplitter 进行分块
```

---

**下一步：** [05_双重类比](./05_双重类比.md) - 用前端和日常生活类比加深理解
