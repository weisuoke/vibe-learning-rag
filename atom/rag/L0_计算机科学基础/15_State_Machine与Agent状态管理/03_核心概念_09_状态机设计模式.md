# 核心概念09：状态机设计模式

> **定义**：状态机设计模式是处理复杂状态转移的高级技术，包括分层、并发、历史状态等模式

---

## 一、为什么需要设计模式？

### 1.1 简单状态机的局限

**问题1：状态爆炸**
```python
# 简单状态机：状态数指数增长
# 2个独立维度 × 3个状态 = 6个组合状态
states = {
    'idle_disconnected',
    'idle_connected',
    'processing_disconnected',
    'processing_connected',
    'completed_disconnected',
    'completed_connected'
}
# 难以维护 ❌
```

**问题2：重复逻辑**
```python
# 每个状态都要处理相同的事件
def handle_disconnect(state):
    if state == 'idle_connected':
        return 'idle_disconnected'
    elif state == 'processing_connected':
        return 'processing_disconnected'
    # 重复代码 ❌
```

**问题3：难以扩展**
```python
# 添加新维度需要修改所有状态
# 添加"authenticated"维度 → 12个组合状态
# 难以扩展 ❌
```

---

### 1.2 设计模式的解决方案

**解决方案1：分层状态机**
```python
# 分层：将状态组织成层级结构
MainState
  ├─ Idle
  ├─ Processing
  │   ├─ Retrieving
  │   ├─ Reasoning
  │   └─ Generating
  └─ Completed
```

**解决方案2：并发状态机**
```python
# 并发：独立维度并行运行
Dimension1: idle | processing | completed
Dimension2: disconnected | connected
# 只需要 3 + 2 = 5 个状态，而非 6 个组合
```

**解决方案3：历史状态**
```python
# 历史：记住上次的子状态
Processing → Paused → Resume → Processing(恢复到上次的子状态)
```

---

## 二、分层状态机（Hierarchical State Machine）

### 2.1 概念

**定义**：状态可以包含子状态，形成层级结构

**优势**：
- 减少状态数
- 共享转移逻辑
- 易于理解和维护

---

### 2.2 Python实现

```python
from typing import Dict, List, Optional
from dataclasses import dataclass

@dataclass
class HierarchicalState:
    """分层状态"""
    name: str
    parent: Optional['HierarchicalState'] = None
    children: List['HierarchicalState'] = None
    entry_action: Optional[callable] = None
    exit_action: Optional[callable] = None

    def __post_init__(self):
        if self.children is None:
            self.children = []

    def is_ancestor_of(self, state: 'HierarchicalState') -> bool:
        """检查是否是祖先状态"""
        current = state.parent
        while current:
            if current == self:
                return True
            current = current.parent
        return False

    def get_path_to_root(self) -> List['HierarchicalState']:
        """获取到根状态的路径"""
        path = [self]
        current = self.parent
        while current:
            path.append(current)
            current = current.parent
        return path


class HierarchicalStateMachine:
    """分层状态机"""

    def __init__(self, root_state: HierarchicalState):
        self.root = root_state
        self.current_state = root_state
        self.transitions: Dict[tuple, HierarchicalState] = {}

    def add_transition(
        self,
        from_state: HierarchicalState,
        event: str,
        to_state: HierarchicalState
    ):
        """添加转移"""
        self.transitions[(from_state, event)] = to_state

    def transition(self, event: str):
        """执行转移"""
        key = (self.current_state, event)

        # 尝试当前状态的转移
        if key in self.transitions:
            self._do_transition(self.transitions[key])
            return

        # 尝试父状态的转移（继承）
        current = self.current_state.parent
        while current:
            key = (current, event)
            if key in self.transitions:
                self._do_transition(self.transitions[key])
                return
            current = current.parent

        print(f"No transition for event '{event}' from state '{self.current_state.name}'")

    def _do_transition(self, to_state: HierarchicalState):
        """执行状态转移"""
        from_state = self.current_state

        # 找到最近公共祖先（LCA）
        from_path = set(from_state.get_path_to_root())
        to_path = to_state.get_path_to_root()

        lca = None
        for state in to_path:
            if state in from_path:
                lca = state
                break

        # 执行exit actions（从当前状态到LCA）
        current = from_state
        while current != lca:
            if current.exit_action:
                current.exit_action()
            current = current.parent

        # 执行entry actions（从LCA到目标状态）
        entry_path = []
        current = to_state
        while current != lca:
            entry_path.append(current)
            current = current.parent

        for state in reversed(entry_path):
            if state.entry_action:
                state.entry_action()

        self.current_state = to_state
        print(f"Transitioned to: {to_state.name}")


# 示例：RAG系统的分层状态机
def create_rag_hierarchical_sm():
    """创建RAG系统的分层状态机"""

    # 定义entry/exit actions
    def enter_processing():
        print("  → 进入Processing状态")

    def exit_processing():
        print("  ← 退出Processing状态")

    def enter_retrieving():
        print("    → 开始检索")

    def enter_reasoning():
        print("    → 开始推理")

    # 构建状态层级
    root = HierarchicalState("Root")

    idle = HierarchicalState("Idle", parent=root)

    processing = HierarchicalState(
        "Processing",
        parent=root,
        entry_action=enter_processing,
        exit_action=exit_processing
    )

    retrieving = HierarchicalState(
        "Retrieving",
        parent=processing,
        entry_action=enter_retrieving
    )

    reasoning = HierarchicalState(
        "Reasoning",
        parent=processing,
        entry_action=enter_reasoning
    )

    generating = HierarchicalState("Generating", parent=processing)

    completed = HierarchicalState("Completed", parent=root)

    # 设置子状态
    root.children = [idle, processing, completed]
    processing.children = [retrieving, reasoning, generating]

    # 创建状态机
    hsm = HierarchicalStateMachine(idle)

    # 添加转移
    hsm.add_transition(idle, "query", retrieving)
    hsm.add_transition(retrieving, "retrieved", reasoning)
    hsm.add_transition(reasoning, "reasoned", generating)
    hsm.add_transition(generating, "generated", completed)

    # 共享转移：Processing的所有子状态都可以处理"error"事件
    hsm.add_transition(processing, "error", idle)

    return hsm


# 使用示例
if __name__ == "__main__":
    hsm = create_rag_hierarchical_sm()

    print("=== 正常流程 ===")
    hsm.transition("query")      # Idle → Retrieving
    hsm.transition("retrieved")  # Retrieving → Reasoning
    hsm.transition("reasoned")   # Reasoning → Generating
    hsm.transition("generated")  # Generating → Completed

    print("\n=== 错误处理（共享转移）===")
    hsm = create_rag_hierarchical_sm()
    hsm.transition("query")      # Idle → Retrieving
    hsm.transition("error")      # Retrieving → Idle（继承自Processing）
```

---

## 三、并发状态机（Concurrent State Machine）

### 3.1 概念

**定义**：多个独立的状态机并行运行

**优势**：
- 避免状态爆炸
- 独立维度分离
- 易于理解

---

### 3.2 Python实现

```python
from typing import Dict, List
from dataclasses import dataclass

@dataclass
class Region:
    """并发区域"""
    name: str
    current_state: str
    transitions: Dict[tuple, str]

    def transition(self, event: str) -> bool:
        """执行转移"""
        key = (self.current_state, event)
        if key in self.transitions:
            old_state = self.current_state
            self.current_state = self.transitions[key]
            print(f"  {self.name}: {old_state} → {self.current_state}")
            return True
        return False


class ConcurrentStateMachine:
    """并发状态机"""

    def __init__(self):
        self.regions: List[Region] = []

    def add_region(self, region: Region):
        """添加并发区域"""
        self.regions.append(region)

    def transition(self, event: str):
        """所有区域并行处理事件"""
        print(f"Event: {event}")
        for region in self.regions:
            region.transition(event)

    def get_state(self) -> Dict[str, str]:
        """获取所有区域的当前状态"""
        return {region.name: region.current_state for region in self.regions}


# 示例：Agent系统的并发状态机
def create_agent_concurrent_sm():
    """创建Agent系统的并发状态机"""

    # 区域1：任务状态
    task_region = Region(
        name="Task",
        current_state="idle",
        transitions={
            ("idle", "start"): "processing",
            ("processing", "complete"): "completed",
            ("processing", "pause"): "paused",
            ("paused", "resume"): "processing",
        }
    )

    # 区域2：连接状态
    connection_region = Region(
        name="Connection",
        current_state="disconnected",
        transitions={
            ("disconnected", "connect"): "connected",
            ("connected", "disconnect"): "disconnected",
        }
    )

    # 区域3：认证状态
    auth_region = Region(
        name="Auth",
        current_state="unauthenticated",
        transitions={
            ("unauthenticated", "login"): "authenticated",
            ("authenticated", "logout"): "unauthenticated",
        }
    )

    # 创建并发状态机
    csm = ConcurrentStateMachine()
    csm.add_region(task_region)
    csm.add_region(connection_region)
    csm.add_region(auth_region)

    return csm


# 使用示例
if __name__ == "__main__":
    csm = create_agent_concurrent_sm()

    print("=== 初始状态 ===")
    print(csm.get_state())

    print("\n=== 并发转移 ===")
    csm.transition("start")      # Task: idle → processing
    csm.transition("connect")    # Connection: disconnected → connected
    csm.transition("login")      # Auth: unauthenticated → authenticated

    print("\n=== 当前状态 ===")
    print(csm.get_state())
    # {'Task': 'processing', 'Connection': 'connected', 'Auth': 'authenticated'}
```

---

## 四、历史状态（History State）

### 4.1 概念

**定义**：记住上次退出时的子状态，恢复时回到该子状态

**类型**：
- **浅历史（Shallow History）**：只记住直接子状态
- **深历史（Deep History）**：记住所有嵌套子状态

---

### 4.2 Python实现

```python
from typing import Dict, Optional

class HistoryStateMachine:
    """支持历史状态的状态机"""

    def __init__(self):
        self.current_state: str = "idle"
        self.history: Dict[str, str] = {}  # 记录每个复合状态的历史
        self.transitions: Dict[tuple, str] = {}

    def add_transition(self, from_state: str, event: str, to_state: str):
        """添加转移"""
        self.transitions[(from_state, event)] = to_state

    def transition(self, event: str):
        """执行转移"""
        key = (self.current_state, event)
        if key not in self.transitions:
            print(f"No transition for ({self.current_state}, {event})")
            return

        to_state = self.transitions[key]

        # 如果目标是历史状态，恢复历史
        if to_state.endswith("_history"):
            parent_state = to_state.replace("_history", "")
            if parent_state in self.history:
                to_state = self.history[parent_state]
                print(f"Restoring history: {to_state}")
            else:
                # 没有历史，使用默认子状态
                to_state = f"{parent_state}_default"
                print(f"No history, using default: {to_state}")

        # 保存历史（如果离开复合状态）
        if self.current_state.startswith("processing_"):
            self.history["processing"] = self.current_state

        old_state = self.current_state
        self.current_state = to_state
        print(f"Transition: {old_state} → {to_state}")


# 示例：RAG系统的历史状态
def create_rag_history_sm():
    """创建支持历史状态的RAG系统"""

    hsm = HistoryStateMachine()

    # 添加转移
    hsm.add_transition("idle", "start", "processing_retrieving")
    hsm.add_transition("processing_retrieving", "retrieved", "processing_reasoning")
    hsm.add_transition("processing_reasoning", "reasoned", "processing_generating")

    # 暂停：保存当前子状态
    hsm.add_transition("processing_retrieving", "pause", "paused")
    hsm.add_transition("processing_reasoning", "pause", "paused")
    hsm.add_transition("processing_generating", "pause", "paused")

    # 恢复：回到历史子状态
    hsm.add_transition("paused", "resume", "processing_history")

    return hsm


# 使用示例
if __name__ == "__main__":
    hsm = create_rag_history_sm()

    print("=== 场景1：在reasoning时暂停 ===")
    hsm.transition("start")     # idle → processing_retrieving
    hsm.transition("retrieved") # processing_retrieving → processing_reasoning
    hsm.transition("pause")     # processing_reasoning → paused（保存历史）
    hsm.transition("resume")    # paused → processing_reasoning（恢复历史）

    print("\n=== 场景2：在generating时暂停 ===")
    hsm = create_rag_history_sm()
    hsm.transition("start")     # idle → processing_retrieving
    hsm.transition("retrieved") # processing_retrieving → processing_reasoning
    hsm.transition("reasoned")  # processing_reasoning → processing_generating
    hsm.transition("pause")     # processing_generating → paused（保存历史）
    hsm.transition("resume")    # paused → processing_generating（恢复历史）
```

---

## 五、守卫条件（Guard Conditions）

### 5.1 概念

**定义**：转移前检查条件，只有条件满足才执行转移

**优势**：
- 减少状态数
- 动态决策
- 更灵活

---

### 5.2 Python实现

```python
from typing import Callable, Dict, Any

class GuardedStateMachine:
    """支持守卫条件的状态机"""

    def __init__(self):
        self.current_state: str = "idle"
        self.context: Dict[str, Any] = {}
        self.transitions: Dict[tuple, tuple] = {}  # (state, event) → (guard, next_state)

    def add_transition(
        self,
        from_state: str,
        event: str,
        to_state: str,
        guard: Callable[[Dict], bool] = lambda ctx: True
    ):
        """添加带守卫条件的转移"""
        self.transitions[(from_state, event)] = (guard, to_state)

    def transition(self, event: str, **kwargs):
        """执行转移（带守卫检查）"""
        # 更新上下文
        self.context.update(kwargs)

        key = (self.current_state, event)
        if key not in self.transitions:
            print(f"No transition for ({self.current_state}, {event})")
            return

        guard, to_state = self.transitions[key]

        # 检查守卫条件
        if not guard(self.context):
            print(f"Guard condition failed for ({self.current_state}, {event})")
            return

        old_state = self.current_state
        self.current_state = to_state
        print(f"Transition: {old_state} → {to_state}")


# 示例：RAG系统的守卫条件
def create_rag_guarded_sm():
    """创建带守卫条件的RAG系统"""

    gsm = GuardedStateMachine()

    # 添加转移
    gsm.add_transition("idle", "query", "retrieving")

    # 守卫条件：只有文档数量 > 0 才能进入reasoning
    gsm.add_transition(
        "retrieving",
        "retrieved",
        "reasoning",
        guard=lambda ctx: ctx.get("doc_count", 0) > 0
    )

    # 守卫条件：文档数量 == 0 则重试
    gsm.add_transition(
        "retrieving",
        "retrieved",
        "retry",
        guard=lambda ctx: ctx.get("doc_count", 0) == 0
    )

    # 守卫条件：只有验证通过才能完成
    gsm.add_transition(
        "generating",
        "generated",
        "completed",
        guard=lambda ctx: ctx.get("validation_passed", False)
    )

    # 守卫条件：验证失败则重试
    gsm.add_transition(
        "generating",
        "generated",
        "retry",
        guard=lambda ctx: not ctx.get("validation_passed", False)
    )

    return gsm


# 使用示例
if __name__ == "__main__":
    gsm = create_rag_guarded_sm()

    print("=== 场景1：检索成功 ===")
    gsm.transition("query")
    gsm.transition("retrieved", doc_count=5)  # 守卫通过

    print("\n=== 场景2：检索失败 ===")
    gsm = create_rag_guarded_sm()
    gsm.transition("query")
    gsm.transition("retrieved", doc_count=0)  # 守卫失败，进入retry
```

---

## 六、LangGraph中的设计模式

### 6.1 分层状态（Subgraphs）

```python
from langgraph.graph import StateGraph, END

# 创建子图
def create_processing_subgraph():
    """Processing子图"""
    subgraph = StateGraph(ProcessingState)

    subgraph.add_node("retrieving", retrieve)
    subgraph.add_node("reasoning", reason)
    subgraph.add_node("generating", generate)

    subgraph.add_edge("retrieving", "reasoning")
    subgraph.add_edge("reasoning", "generating")
    subgraph.add_edge("generating", END)

    subgraph.set_entry_point("retrieving")

    return subgraph.compile()

# 主图
main_graph = StateGraph(MainState)
main_graph.add_node("idle", idle_node)
main_graph.add_node("processing", create_processing_subgraph())  # 嵌套子图
main_graph.add_node("completed", completed_node)

main_graph.add_edge("idle", "processing")
main_graph.add_edge("processing", "completed")
```

---

### 6.2 并发执行（Parallel Edges）

```python
from langgraph.graph import StateGraph, START, END

graph = StateGraph(MultiAgentState)

# 添加并行Agent
graph.add_node("agent1", agent1)
graph.add_node("agent2", agent2)
graph.add_node("agent3", agent3)
graph.add_node("coordinator", coordinator)

# 并行执行
graph.add_edge(START, "agent1")
graph.add_edge(START, "agent2")
graph.add_edge(START, "agent3")

# 等待所有Agent完成
graph.add_edge(["agent1", "agent2", "agent3"], "coordinator")
graph.add_edge("coordinator", END)
```

---

### 6.3 条件守卫（Conditional Edges）

```python
def guard_router(state: State) -> str:
    """守卫条件路由"""
    if state["doc_count"] > 0:
        return "reasoning"
    else:
        return "retry"

graph.add_conditional_edges(
    "retrieving",
    guard_router,
    {
        "reasoning": "reasoning",
        "retry": "retrieving"
    }
)
```

---

## 七、设计模式选择指南

### 7.1 何时使用分层状态机

**适用场景**：
- 状态有明显的层级关系
- 需要共享转移逻辑
- 状态数量多

**示例**：
- RAG系统（Processing包含多个子状态）
- 工作流系统（审批流程有多个阶段）

---

### 7.2 何时使用并发状态机

**适用场景**：
- 多个独立维度
- 避免状态爆炸
- 维度之间无依赖

**示例**：
- Agent系统（任务状态 + 连接状态 + 认证状态）
- UI组件（加载状态 + 错误状态 + 数据状态）

---

### 7.3 何时使用历史状态

**适用场景**：
- 需要暂停/恢复
- 需要记住上次位置
- 中断后恢复

**示例**：
- 长运行任务（暂停后恢复到上次位置）
- 对话系统（切换话题后回到上次话题）

---

### 7.4 何时使用守卫条件

**适用场景**：
- 转移依赖运行时条件
- 减少状态数
- 动态决策

**示例**：
- RAG系统（根据文档数量决定下一步）
- 权限系统（根据用户角色决定转移）

---

## 八、最佳实践

### 8.1 组合使用模式

**推荐**：
```python
# 分层 + 守卫 + 并发
# 主图：分层结构
# 子图：守卫条件
# 并发：多Agent并行
```

---

### 8.2 保持简单

**原则**：
- 优先使用简单状态机
- 只在必要时使用高级模式
- 避免过度设计

---

### 8.3 可视化

**工具**：
- Mermaid图
- PlantUML
- Graphviz

---

## 九、总结

### 核心要点

1. **分层状态机**：状态层级结构，共享转移
2. **并发状态机**：独立维度并行，避免爆炸
3. **历史状态**：记住子状态，支持恢复
4. **守卫条件**：条件转移，动态决策
5. **LangGraph支持**：Subgraphs、Parallel、Conditional

### 模式选择

| 问题 | 推荐模式 | 原因 |
|------|---------|------|
| **状态爆炸** | 分层或并发 | 减少状态数 |
| **共享逻辑** | 分层 | 继承转移 |
| **独立维度** | 并发 | 分离关注点 |
| **暂停/恢复** | 历史状态 | 记住位置 |
| **动态决策** | 守卫条件 | 运行时判断 |

### 学习建议

1. **理解问题**：先识别状态机的复杂性
2. **选择模式**：根据问题选择合适模式
3. **实践应用**：手写实现加深理解
4. **LangGraph实现**：学习框架支持
5. **组合使用**：多种模式组合解决复杂问题

---

## 参考资料

1. **经典理论**：
   - UML State Machine Diagrams
   - Harel Statecharts
   - Design Patterns (GoF)

2. **LangGraph实现**：
   - LangGraph Subgraphs
   - LangGraph Parallel Execution
   - LangGraph Conditional Routing

3. **最佳实践**：
   - State Machine Design Patterns
   - Hierarchical State Machines in Practice

---

**版本**: v1.0
**最后更新**: 2026-02-14
**代码行数**: ~450行
