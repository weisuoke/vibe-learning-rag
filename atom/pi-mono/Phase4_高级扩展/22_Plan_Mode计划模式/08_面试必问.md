# 面试必问

> **核心理念：** 10 个高频面试题，深入理解 Plan Mode 的技术细节和设计哲学。

---

## 问题 1：为什么 pi-mono 不提供内置 Plan Mode？

### 标准答案

Pi-mono 不提供内置 Plan Mode 是基于以下设计哲学：

1. **极简主义**：核心保持简单，复杂性在扩展中
2. **可观察性优先**：文件式规划比黑盒编排更透明
3. **用户控制**：用户决定规划工作流，而非代理自动化
4. **可组合性**：扩展可以自由组合，创造无限可能

### 深入分析

**哲学层面：**
- Pi-mono 追求"原语完整"而非"功能完整"
- 提供 `write()`、`read()`、`setState()` 等原语
- 用户组合原语构建任何规划模式

**技术层面：**
- 内置 Plan Mode 会增加核心复杂度
- 不同用户需求差异大，无法一刀切
- 扩展实现更灵活，可以定制

**对比：**
- **Pi-mono**：提供原语，用户构建
- **Claude Code**：内置 Plan Mode，开箱即用
- **Oh-my-pi**：fork 添加内置 `/plan` 命令

### 面试加分点

- 引用 Mario Zechner 的博客文章
- 对比 Unix 哲学（小工具组合）
- 理解"原语 > 功能"的设计理念

---

## 问题 2：Plan Mode 的三种实现方式各有什么优劣？

### 标准答案

| 方式 | 优势 | 劣势 | 适用场景 |
|------|------|------|----------|
| **文件式** | 最简单、最可观察 | 无 UI 集成 | 快速原型 |
| **扩展式** | 最佳用户体验 | 需要创建扩展 | 频繁使用 |
| **Session 集成** | 状态持久化 | 最复杂 | 复杂项目 |

### 深入分析

**文件式规划：**
- **实现**：直接操作文件，10 行代码
- **优势**：可观察性最强，用户可以直接编辑
- **劣势**：无快捷键、无 UI、无状态管理
- **适用**：简单任务、个人项目

**扩展式规划：**
- **实现**：注册 `/plan` 和 `/execute` 命令
- **优势**：UI 集成、快捷键、状态持久化
- **劣势**：需要理解 Extension API
- **适用**：频繁使用、团队协作

**Session 集成式：**
- **实现**：使用 Session API 管理状态
- **优势**：历史追踪、分支支持、完整日志
- **劣势**：学习曲线陡峭
- **适用**：复杂项目、需要审计

### 面试加分点

- 理解每种方式的权衡（trade-offs）
- 能根据场景选择合适的方式
- 理解可以混合使用三种方式

---

## 问题 3：为什么文件优先比内存优先更好？

### 标准答案

对 AI 代理来说，文件优先比内存优先更好，因为：

1. **可观察性**：文件可以直接查看，内存不可见
2. **可编辑性**：文件可以手动修改，内存难编辑
3. **可版本控制**：文件可以用 Git 追踪，内存无法追踪
4. **可恢复性**：代理崩溃后文件仍存在，内存丢失

### 深入分析

**性能对比：**
- **内存访问**：纳秒级
- **文件访问**：毫秒级
- **差异**：对 AI 代理来说可以忽略

**可观察性对比：**
- **内存状态**：用户看不到，调试困难
- **文件状态**：用户随时查看，调试简单

**实际影响：**
```typescript
// 内存存储（不推荐）
const plan = { goal: 'auth system', tasks: [...] };
// 代理崩溃，计划丢失

// 文件存储（推荐）
await api.tools.write('.pi/plan.md', planContent);
// 代理崩溃，计划仍然存在
// 用户可以用编辑器打开查看
// 可以用 git diff 查看变化
```

### 面试加分点

- 理解"可观察性 > 性能"的权衡
- 引用 pi-mono 的设计哲学
- 理解 AI 代理与传统软件的区别

---

## 问题 4：Extension API 的核心方法有哪些？

### 标准答案

Extension API 的核心方法包括：

1. **命令注册**：`registerCommand()`
2. **工具注册**：`registerTool()`
3. **快捷键注册**：`registerShortcut()`
4. **状态管理**：`setState()` / `getState()`
5. **工具控制**：`enableTools()` / `disableTools()`
6. **事件处理**：`on()` / `emit()`
7. **Session 管理**：`createSession()` / `switchSession()`

### 深入分析

**命令注册：**
```typescript
api.registerCommand({
  name: 'plan',
  description: 'Enter plan mode',
  handler: async (args) => {
    // 命令逻辑
  }
});
```

**状态管理：**
```typescript
// 设置状态
await api.setState({ mode: 'plan' });

// 获取状态
const state = api.getState();
```

**工具控制：**
```typescript
// 禁用工具（规划模式）
api.disableTools(['write', 'edit', 'delete']);

// 启用工具（执行模式）
api.enableTools(['write', 'edit', 'delete']);
```

**事件处理：**
```typescript
// 监听事件
api.on('plan:entered', (data) => {
  console.log('Entered plan mode:', data);
});

// 触发事件
api.emit('plan:entered', { task: 'auth system' });
```

### 面试加分点

- 理解每个方法的用途和场景
- 能写出完整的扩展代码
- 理解事件驱动的优势

---

## 问题 5：Session 和普通状态管理有什么区别？

### 标准答案

| 方面 | Session | 普通状态 |
|------|---------|----------|
| **持久化** | 自动持久化到文件 | 需要手动保存 |
| **历史追踪** | CustomEntry 记录所有操作 | 无历史记录 |
| **分支支持** | 支持创建分支 Session | 不支持分支 |
| **标签系统** | Labels 多维度分类 | 单一状态字段 |
| **隔离性** | 不同 Session 状态独立 | 全局状态 |

### 深入分析

**Session 的优势：**

1. **状态持久化**：
```typescript
const session = await api.createSession({
  labels: ['planning'],
  state: { mode: 'plan' }
});
// 状态自动保存到 .pi/sessions/session-xxx.json
```

2. **历史追踪**：
```typescript
await api.addSessionEntry(sessionId, {
  type: 'system',
  content: 'Entered plan mode',
  timestamp: Date.now()
});
// 所有操作都有记录
```

3. **分支支持**：
```typescript
const branch = await api.createSession({
  parentId: originalSessionId,
  labels: ['branch', 'experiment']
});
// 可以创建分支实验不同方案
```

4. **标签系统**：
```typescript
const sessions = api.getSessions({
  labels: ['planning', 'active', 'high-priority']
});
// 多维度查询
```

### 面试加分点

- 理解 Session 的设计目的
- 能解释何时使用 Session vs. 普通状态
- 理解分支的应用场景

---

## 问题 6：如何实现 Plan Mode 的工具控制？

### 标准答案

Plan Mode 的工具控制通过 `disableTools()` 和 `enableTools()` 实现：

```typescript
// 进入规划模式时禁用写入工具
api.disableTools(['write', 'edit', 'delete', 'move', 'rename']);

// 退出规划模式时启用写入工具
api.enableTools(['write', 'edit', 'delete', 'move', 'rename']);
```

### 深入分析

**为什么需要工具控制？**

1. **防止意外修改**：规划阶段不应该修改文件
2. **明确意图**：用户明确知道当前模式
3. **可预测性**：代理行为可预测
4. **错误成本低**：规划错误成本低，执行错误成本高

**实现细节：**

```typescript
// 完整的工具控制实现
async function enterPlanMode(api: ExtensionAPI) {
  // 1. 禁用所有修改文件的工具
  api.disableTools([
    'write',    // 写文件
    'edit',     // 编辑文件
    'delete',   // 删除文件
    'move',     // 移动文件
    'rename'    // 重命名文件
  ]);

  // 2. 保留读取工具
  // read, glob, grep 等工具仍然可用

  // 3. 更新状态
  await api.setState({ mode: 'plan' });
}

async function exitPlanMode(api: ExtensionAPI) {
  // 1. 重新启用所有工具
  api.enableTools([
    'write',
    'edit',
    'delete',
    'move',
    'rename'
  ]);

  // 2. 更新状态
  await api.setState({ mode: 'execute' });
}
```

### 面试加分点

- 理解"安全性 > 便利性"的设计理念
- 能列出应该禁用的所有工具
- 理解只读模式的价值

---

## 问题 7：Plan Mode 的事件系统如何设计？

### 标准答案

Plan Mode 的事件系统基于 EventEmitter 模式：

```typescript
// 定义事件
const EVENTS = {
  PLAN_ENTERED: 'plan:entered',
  PLAN_EXITED: 'plan:exited',
  TASK_ADDED: 'plan:task:added',
  TASK_COMPLETED: 'plan:task:completed'
};

// 监听事件
api.on(EVENTS.PLAN_ENTERED, (data) => {
  console.log('Entered plan mode:', data);
});

// 触发事件
api.emit(EVENTS.PLAN_ENTERED, {
  task: 'auth system',
  planId: 'plan-001'
});
```

### 深入分析

**事件驱动的优势：**

1. **解耦**：发送者和接收者解耦
2. **可扩展**：可以添加多个监听器
3. **可组合**：不同扩展可以监听同一事件
4. **可测试**：易于测试和模拟

**事件命名规范：**
```typescript
// 使用 namespace:action 格式
'plan:entered'           // 进入规划模式
'plan:exited'            // 退出规划模式
'plan:task:added'        // 添加任务
'plan:task:completed'    // 完成任务
'plan:approved'          // 批准计划
```

**完整示例：**
```typescript
class PlanModeEventEmitter {
  constructor(private api: ExtensionAPI) {}

  // 触发事件
  emitPlanEntered(data: { task: string; planId: string }) {
    this.api.emit('plan:entered', data);
  }

  emitPlanExited(data: { planId: string; duration: number }) {
    this.api.emit('plan:exited', data);
  }

  // 监听事件
  onPlanEntered(handler: (data: any) => void) {
    this.api.on('plan:entered', handler);
  }

  onPlanExited(handler: (data: any) => void) {
    this.api.on('plan:exited', handler);
  }
}
```

### 面试加分点

- 理解事件驱动架构的优势
- 能设计完整的事件系统
- 理解事件命名规范

---

## 问题 8：如何实现 Plan Mode 的状态持久化？

### 标准答案

Plan Mode 的状态持久化通过两种方式实现：

1. **扩展状态持久化**：`setState()` 自动保存到 `.pi/state.json`
2. **Session 持久化**：Session 自动保存到 `.pi/sessions/`

### 深入分析

**扩展状态持久化：**

```typescript
// 设置状态
await api.setState({
  mode: 'plan',
  currentPlan: 'plan-001',
  planFile: '.pi/plans/plan-001.md'
});

// 状态自动保存到 .pi/state.json
{
  "mode": "plan",
  "currentPlan": "plan-001",
  "planFile": ".pi/plans/plan-001.md",
  "updatedAt": "2026-02-21T10:00:00Z"
}

// 重启后自动恢复
const state = api.getState();
console.log(state.mode); // 'plan'
```

**Session 持久化：**

```typescript
// 创建 Session
const session = await api.createSession({
  labels: ['planning'],
  state: { mode: 'plan', task: 'auth system' }
});

// Session 自动保存到 .pi/sessions/session-xxx.json
{
  "id": "session-1234567890",
  "labels": ["planning"],
  "state": {
    "mode": "plan",
    "task": "auth system"
  },
  "entries": [...],
  "createdAt": "2026-02-21T10:00:00Z"
}
```

**手动持久化：**

```typescript
// 导出 Session
async function exportSession(sessionId: string) {
  const session = api.getSession(sessionId);
  const json = JSON.stringify(session, null, 2);
  await api.tools.write(`backups/${sessionId}.json`, json);
}

// 导入 Session
async function importSession(filePath: string) {
  const json = await api.tools.read(filePath);
  const session = JSON.parse(json);
  return await api.createSession(session);
}
```

### 面试加分点

- 理解自动持久化的机制
- 能实现手动备份和恢复
- 理解状态文件的格式

---

## 问题 9：Plan Mode 的最佳实践有哪些？

### 标准答案

Plan Mode 的最佳实践包括：

1. **文件命名规范**：`plan-{timestamp}-{slug}.md`
2. **状态验证**：检查当前模式再执行操作
3. **错误处理**：捕获所有异常并返回友好消息
4. **日志记录**：记录关键事件和操作
5. **事件驱动**：使用事件解耦模块
6. **模块化设计**：每个模块职责单一
7. **定期清理**：归档旧计划和 Session

### 深入分析

**1. 文件命名规范：**
```typescript
const planId = `plan-${Date.now()}-auth-system`;
// plan-1708516800000-auth-system.md
```

**2. 状态验证：**
```typescript
async function handleExecuteCommand(api: ExtensionAPI) {
  // 验证状态
  if (!isInPlanMode(api)) {
    return '⚠️  Not in plan mode';
  }

  // 执行逻辑
  // ...
}
```

**3. 错误处理：**
```typescript
async function handlePlanCommand(api: ExtensionAPI, args: string[]) {
  try {
    // 命令逻辑
    return '✅ Success';
  } catch (error) {
    logger.error('Failed to execute /plan:', error);
    return `❌ Failed: ${error.message}`;
  }
}
```

**4. 日志记录：**
```typescript
logger.info('Entered plan mode:', planId);
logger.debug('Plan state:', state);
logger.error('Failed to create plan:', error);
```

**5. 事件驱动：**
```typescript
// 发布事件
eventEmitter.emit('plan:created', { planId });

// 订阅事件
eventEmitter.on('plan:created', (data) => {
  // 处理事件
});
```

**6. 模块化设计：**
```
core/
├── file-manager.ts      # 文件操作
├── session-manager.ts   # Session 管理
├── state-manager.ts     # 状态管理
└── event-emitter.ts     # 事件系统
```

**7. 定期清理：**
```typescript
// 归档 30 天前的 Session
const oldSessions = api.getSessions({
  labels: ['completed']
}).filter(s => {
  const age = Date.now() - new Date(s.createdAt).getTime();
  return age > 30 * 24 * 60 * 60 * 1000;
});

for (const session of oldSessions) {
  await api.addSessionLabel(session.id, 'archived');
}
```

### 面试加分点

- 能列出所有最佳实践
- 理解每个实践的原因
- 能在实际项目中应用

---

## 问题 10：如何选择 Plan Mode 的实现方式？

### 标准答案

根据以下因素选择实现方式：

| 因素 | 文件式 | 扩展式 | Session 集成 |
|------|--------|--------|-------------|
| **复杂度** | 低 | 中 | 高 |
| **学习曲线** | 平缓 | 中等 | 陡峭 |
| **功能完整性** | 基础 | 完整 | 最完整 |
| **开发时间** | 短 | 中 | 长 |
| **维护成本** | 低 | 中 | 高 |

### 深入分析

**选择决策树：**

```
是否需要频繁使用？
├─ 否 → 文件式规划
└─ 是 → 是否需要历史追踪？
    ├─ 否 → 扩展式规划
    └─ 是 → Session 集成式
```

**场景分析：**

**场景 1：快速原型**
- **需求**：快速实现基本规划功能
- **选择**：文件式规划
- **原因**：10 行代码即可实现

**场景 2：个人项目**
- **需求**：频繁使用，需要快捷键
- **选择**：扩展式规划
- **原因**：最佳用户体验

**场景 3：团队协作**
- **需求**：多人协作，需要审批流程
- **选择**：Session 集成式
- **原因**：完整的历史追踪和状态管理

**场景 4：企业级应用**
- **需求**：复杂工作流，需要审计
- **选择**：完整实现（混合三种方式）
- **原因**：生产级功能

**混合使用：**
```typescript
// 可以混合使用三种方式
// 1. 文件式：存储计划内容
await fileManager.createPlan(goal);

// 2. 扩展式：提供 UI 和命令
api.registerCommand({ name: 'plan', handler: ... });

// 3. Session 集成：管理状态和历史
const session = await sessionManager.createPlanSession(planId);
```

### 面试加分点

- 理解每种方式的适用场景
- 能根据需求做出合理选择
- 理解可以混合使用三种方式

---

## 总结

### 核心知识点

1. **设计哲学**：极简主义、可观察性、用户控制
2. **三种实现**：文件式、扩展式、Session 集成式
3. **核心 API**：命令注册、状态管理、工具控制、事件处理
4. **最佳实践**：模块化、错误处理、日志记录、定期清理

### 面试准备建议

1. **理解哲学**：深入理解 pi-mono 的设计哲学
2. **动手实践**：实现完整的 Plan Mode 扩展
3. **对比分析**：对比 pi-mono、Claude Code、Oh-my-pi
4. **阅读源码**：阅读 pi-mono 官方示例代码

---

## 参考资源

### 官方资源

- [Pi-mono GitHub](https://github.com/badlogic/pi-mono)
- [Extension API Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md)
- [Mario's Blog](https://mariozechner.at/posts/2025-11-30-pi-coding-agent)

### 研究资料

- `temp/01_grok_llm_planning_architecture.md` - LLM 规划系统架构
- `temp/02_grok_ai_agent_patterns.md` - AI 代理任务规划模式
- `temp/03_grok_pi_mono_extensions.md` - Pi-mono 扩展 API

---

## 下一步

- **09_化骨绵掌.md**：10 张知识卡片，快速复习所有核心概念
