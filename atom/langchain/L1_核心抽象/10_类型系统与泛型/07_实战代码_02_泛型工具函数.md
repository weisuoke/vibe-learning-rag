# 实战代码 2：泛型工具函数

## 场景说明

创建类型安全的泛型工具函数，展示如何使用 TypeVar 和 Generic 构建可复用的工具库。

---

## 完整代码示例

```python
"""
类型安全的泛型工具函数
演示：如何使用 TypeVar 和 Generic 创建可复用工具
"""

from typing import TypeVar, Generic, Callable, Iterable, Optional
from langchain_core.runnables import Runnable, RunnableLambda

# ===== 1. 基础泛型函数 =====

T = TypeVar('T')
U = TypeVar('U')

def map_list(items: list[T], fn: Callable[[T], U]) -> list[U]:
    """对列表中的每个元素应用函数"""
    return [fn(item) for item in items]

def filter_list(items: list[T], predicate: Callable[[T], bool]) -> list[T]:
    """过滤列表"""
    return [item for item in items if predicate(item)]

def reduce_list(items: list[T], fn: Callable[[U, T], U], initial: U) -> U:
    """归约列表"""
    result = initial
    for item in items:
        result = fn(result, item)
    return result

# ===== 2. 泛型容器 =====

class Box(Generic[T]):
    """泛型盒子"""

    def __init__(self, value: T):
        self.value = value

    def get(self) -> T:
        return self.value

    def map(self, fn: Callable[[T], U]) -> 'Box[U]':
        """映射值"""
        return Box(fn(self.value))

    def flat_map(self, fn: Callable[[T], 'Box[U]']) -> 'Box[U]':
        """扁平映射"""
        return fn(self.value)

# ===== 3. 泛型管道 =====

class Pipeline(Generic[T, U]):
    """泛型管道"""

    def __init__(self, fn: Callable[[T], U]):
        self.fn = fn

    def __call__(self, input: T) -> U:
        return self.fn(input)

    def then(self, next_fn: Callable[[U], V]) -> 'Pipeline[T, V]':
        """链接下一个函数"""
        def combined(input: T) -> V:
            intermediate = self.fn(input)
            return next_fn(intermediate)
        return Pipeline(combined)

    def to_runnable(self) -> Runnable[T, U]:
        """转换为 Runnable"""
        return RunnableLambda(self.fn)

# ===== 4. 泛型缓存 =====

class Cache(Generic[K, V]):
    """泛型缓存"""

    def __init__(self):
        self._data: dict[K, V] = {}

    def get(self, key: K) -> Optional[V]:
        return self._data.get(key)

    def set(self, key: K, value: V) -> None:
        self._data[key] = value

    def has(self, key: K) -> bool:
        return key in self._data

    def clear(self) -> None:
        self._data.clear()

# ===== 5. 泛型工厂 =====

class Factory(Generic[T]):
    """泛型工厂"""

    def __init__(self, creator: Callable[[], T]):
        self.creator = creator

    def create(self) -> T:
        return self.creator()

    def create_many(self, count: int) -> list[T]:
        return [self.create() for _ in range(count)]

# ===== 6. 泛型验证器 =====

class Validator(Generic[T]):
    """泛型验证器"""

    def __init__(self, rules: list[Callable[[T], bool]]):
        self.rules = rules

    def validate(self, value: T) -> bool:
        return all(rule(value) for rule in self.rules)

    def validate_all(self, values: list[T]) -> list[bool]:
        return [self.validate(value) for value in values]

# ===== 7. 泛型转换器 =====

class Transformer(Generic[T, U]):
    """泛型转换器"""

    def __init__(self, transform_fn: Callable[[T], U]):
        self.transform_fn = transform_fn

    def transform(self, value: T) -> U:
        return self.transform_fn(value)

    def transform_many(self, values: list[T]) -> list[U]:
        return [self.transform(value) for value in values]

    def compose(self, next_transformer: 'Transformer[U, V]') -> 'Transformer[T, V]':
        """组合转换器"""
        def combined(value: T) -> V:
            intermediate = self.transform(value)
            return next_transformer.transform(intermediate)
        return Transformer(combined)

# ===== 8. 使用示例 =====

if __name__ == "__main__":
    print("=== 泛型工具函数示例 ===\n")

    # 1. 基础泛型函数
    print("1. 基础泛型函数")
    numbers = [1, 2, 3, 4, 5]

    # map
    doubled = map_list(numbers, lambda x: x * 2)
    print(f"Doubled: {doubled}")

    # filter
    evens = filter_list(numbers, lambda x: x % 2 == 0)
    print(f"Evens: {evens}")

    # reduce
    sum_result = reduce_list(numbers, lambda acc, x: acc + x, 0)
    print(f"Sum: {sum_result}\n")

    # 2. 泛型容器
    print("2. 泛型容器")
    box: Box[int] = Box(42)
    print(f"Box value: {box.get()}")

    # map
    doubled_box: Box[int] = box.map(lambda x: x * 2)
    print(f"Doubled box: {doubled_box.get()}")

    # flat_map
    str_box: Box[str] = box.flat_map(lambda x: Box(str(x)))
    print(f"String box: {str_box.get()}\n")

    # 3. 泛型管道
    print("3. 泛型管道")
    pipeline: Pipeline[str, int] = (
        Pipeline(lambda x: x.strip())
        .then(lambda x: x.lower())
        .then(lambda x: len(x))
    )

    result = pipeline("  Hello World  ")
    print(f"Pipeline result: {result}\n")

    # 4. 泛型缓存
    print("4. 泛型缓存")
    cache: Cache[str, int] = Cache()
    cache.set("age", 30)
    cache.set("score", 95)

    print(f"Age: {cache.get('age')}")
    print(f"Score: {cache.get('score')}")
    print(f"Has 'name': {cache.has('name')}\n")

    # 5. 泛型工厂
    print("5. 泛型工厂")
    counter = 0
    def create_id() -> str:
        global counter
        counter += 1
        return f"ID-{counter}"

    factory: Factory[str] = Factory(create_id)
    ids = factory.create_many(3)
    print(f"IDs: {ids}\n")

    # 6. 泛型验证器
    print("6. 泛型验证器")
    validator: Validator[int] = Validator([
        lambda x: x > 0,
        lambda x: x < 100,
        lambda x: x % 2 == 0
    ])

    test_values = [10, 50, 101, -5, 25]
    results = validator.validate_all(test_values)
    for value, is_valid in zip(test_values, results):
        print(f"{value}: {'✅' if is_valid else '❌'}")
    print()

    # 7. 泛型转换器
    print("7. 泛型转换器")
    str_to_int: Transformer[str, int] = Transformer(len)
    int_to_str: Transformer[int, str] = Transformer(lambda x: f"Length: {x}")

    # 组合转换器
    combined: Transformer[str, str] = str_to_int.compose(int_to_str)
    result = combined.transform("hello")
    print(f"Combined result: {result}\n")

    # 8. 与 LangChain 集成
    print("8. 与 LangChain 集成")

    # 将 Pipeline 转换为 Runnable
    text_pipeline = Pipeline(lambda x: x.strip().lower())
    runnable = text_pipeline.to_runnable()

    result = runnable.invoke("  HELLO WORLD  ")
    print(f"Runnable result: {result}")

    # 组合多个 Runnable
    from langchain_core.runnables import RunnableLambda

    chain = (
        runnable
        | RunnableLambda(lambda x: x.split())
        | RunnableLambda(len)
    )

    word_count = chain.invoke("  Hello World Python  ")
    print(f"Word count: {word_count}")
```

---

## 运行输出

```
=== 泛型工具函数示例 ===

1. 基础泛型函数
Doubled: [2, 4, 6, 8, 10]
Evens: [2, 4]
Sum: 15

2. 泛型容器
Box value: 42
Doubled box: 84
String box: 42

3. 泛型管道
Pipeline result: 11

4. 泛型缓存
Age: 30
Score: 95
Has 'name': False

5. 泛型工厂
IDs: ['ID-1', 'ID-2', 'ID-3']

6. 泛型验证器
10: ✅
50: ✅
101: ❌
-5: ❌
25: ❌

7. 泛型转换器
Combined result: Length: 5

8. 与 LangChain 集成
Runnable result: hello world
Word count: 3
```

---

## 关键要点

### 1. 类型参数化

```python
T = TypeVar('T')
U = TypeVar('U')

# 函数可以接受任意类型，但保持类型安全
def map_list(items: list[T], fn: Callable[[T], U]) -> list[U]:
    return [fn(item) for item in items]

# 使用时类型自动推断
numbers: list[int] = [1, 2, 3]
strings: list[str] = map_list(numbers, str)  # list[int] -> list[str]
```

### 2. 泛型类

```python
class Box(Generic[T]):
    def __init__(self, value: T):
        self.value = value

    def get(self) -> T:
        return self.value

# 使用时指定类型
int_box: Box[int] = Box(42)
str_box: Box[str] = Box("hello")
```

### 3. 泛型组合

```python
class Pipeline(Generic[T, U]):
    def then(self, next_fn: Callable[[U], V]) -> 'Pipeline[T, V]':
        # 组合后类型自动推断
        ...

# str -> int -> str
pipeline: Pipeline[str, str] = (
    Pipeline(len)  # str -> int
    .then(str)     # int -> str
)
```

---

## 最佳实践

### 1. 明确类型变量

```python
# ✅ 推荐：使用描述性名称
Input = TypeVar('Input')
Output = TypeVar('Output')

class Processor(Generic[Input, Output]):
    ...

# ❌ 不推荐：单字母（除非很简单）
T = TypeVar('T')
U = TypeVar('U')
```

### 2. 约束类型变量

```python
from typing import TypeVar

# 约束为数字类型
Number = TypeVar('Number', int, float)

def add(a: Number, b: Number) -> Number:
    return a + b

# ✅ 可以使用 int 或 float
add(1, 2)      # int
add(1.5, 2.5)  # float

# ❌ 不能使用其他类型
# add("1", "2")  # 类型错误
```

### 3. 使用 bound 参数

```python
from typing import TypeVar

# 约束为特定基类
class Animal:
    def speak(self) -> str:
        return "..."

T = TypeVar('T', bound=Animal)

def make_speak(animal: T) -> str:
    return animal.speak()

# ✅ 可以使用 Animal 或其子类
class Dog(Animal):
    def speak(self) -> str:
        return "Woof!"

make_speak(Dog())  # ✅
```

### 4. 组合泛型

```python
# 组合多个泛型类
class Transformer(Generic[T, U]):
    ...

class Validator(Generic[T]):
    ...

class ValidatedTransformer(Generic[T, U]):
    def __init__(
        self,
        transformer: Transformer[T, U],
        validator: Validator[T]
    ):
        self.transformer = transformer
        self.validator = validator
```

---

## 高级模式

### 1. 函子（Functor）

```python
from typing import TypeVar, Generic, Callable

T = TypeVar('T')
U = TypeVar('U')

class Functor(Generic[T]):
    """函子：可映射的容器"""

    def __init__(self, value: T):
        self.value = value

    def map(self, fn: Callable[[T], U]) -> 'Functor[U]':
        return Functor(fn(self.value))

# 使用
functor = Functor(5)
result = functor.map(lambda x: x * 2).map(str)
# Functor[int] -> Functor[int] -> Functor[str]
```

### 2. 单子（Monad）

```python
class Maybe(Generic[T]):
    """Maybe 单子：处理可能为空的值"""

    def __init__(self, value: Optional[T]):
        self.value = value

    def bind(self, fn: Callable[[T], 'Maybe[U]']) -> 'Maybe[U]':
        if self.value is None:
            return Maybe(None)
        return fn(self.value)

    def map(self, fn: Callable[[T], U]) -> 'Maybe[U]':
        if self.value is None:
            return Maybe(None)
        return Maybe(fn(self.value))

# 使用
def safe_divide(a: int, b: int) -> Maybe[float]:
    if b == 0:
        return Maybe(None)
    return Maybe(a / b)

result = Maybe(10).bind(lambda x: safe_divide(x, 2))
# Maybe[int] -> Maybe[float]
```

### 3. 类型安全的构建器

```python
class Builder(Generic[T]):
    """类型安全的构建器"""

    def __init__(self):
        self._data: dict[str, Any] = {}

    def set(self, key: str, value: Any) -> 'Builder[T]':
        self._data[key] = value
        return self

    def build(self, cls: type[T]) -> T:
        return cls(**self._data)

# 使用
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int

user: User = (
    Builder()
    .set("name", "Alice")
    .set("age", 30)
    .build(User)
)
```

---

## 与 LangChain 集成

### 1. 泛型 Runnable 工厂

```python
from langchain_core.runnables import Runnable, RunnableLambda

def create_runnable(fn: Callable[[T], U]) -> Runnable[T, U]:
    """创建 Runnable"""
    return RunnableLambda(fn)

# 使用
to_upper: Runnable[str, str] = create_runnable(lambda x: x.upper())
to_length: Runnable[str, int] = create_runnable(len)

# 组合
chain = to_upper | to_length
```

### 2. 泛型管道构建器

```python
class RunnablePipelineBuilder(Generic[T, U]):
    """Runnable 管道构建器"""

    def __init__(self, runnable: Runnable[T, U]):
        self.runnable = runnable

    def then(self, next_runnable: Runnable[U, V]) -> 'RunnablePipelineBuilder[T, V]':
        combined = self.runnable | next_runnable
        return RunnablePipelineBuilder(combined)

    def build(self) -> Runnable[T, U]:
        return self.runnable

# 使用
pipeline = (
    RunnablePipelineBuilder(RunnableLambda(str.strip))
    .then(RunnableLambda(str.lower))
    .then(RunnableLambda(len))
    .build()
)
```

---

## 学习检查清单

- [ ] 理解泛型函数的定义和使用
- [ ] 掌握泛型类的创建
- [ ] 了解类型变量的约束
- [ ] 能够组合泛型类型
- [ ] 理解高级泛型模式（函子、单子）
- [ ] 能够与 LangChain 集成
- [ ] 掌握最佳实践

---

## 下一步

- **实战代码 3**：类型检查集成 - 学习集成类型检查器
- **面试必问** - 准备面试问题
- **化骨绵掌** - 巩固所有知识点

---

## 参考资源

1. [Python typing 官方文档](https://docs.python.org/3/library/typing.html)
2. [Generic Types](https://mypy.readthedocs.io/en/stable/generics.html) - mypy 文档
3. [Type Variables](https://typing.python.org/en/latest/reference/type-variables.html) - 官方指南
4. [LangChain Runnables](https://reference.langchain.com/python/langchain_core/runnables)
