# RunnableParallel并行执行 - 核心概念1：并行执行机制

> 深入理解 asyncio 和 threading 的并行执行原理

---

## 概述

本文档深入讲解 RunnableParallel 的两种并行执行机制：
1. **asyncio 事件循环**：异步并发执行
2. **threading 线程池**：多线程并行执行

**学习目标**：
- 理解事件循环的工作原理
- 理解线程池的调度机制
- 掌握两种模式的选择标准
- 能够手写简化版并行执行器

---

## 第一部分：asyncio 事件循环原理

### 1.1 什么是事件循环？

**事件循环（Event Loop）是 asyncio 的核心**，它负责调度和执行异步任务。

**类比**：事件循环就像一个餐厅服务员
- 接单（注册任务）
- 上菜（执行就绪任务）
- 等待厨房（等待 IO 完成）
- 继续服务其他客人（切换任务）

**基本原理**：
```python
# 简化的事件循环伪代码
class EventLoop:
    def __init__(self):
        self.tasks = []  # 任务队列
        self.ready = []  # 就绪队列

    def run(self):
        while self.tasks or self.ready:
            # 1. 检查 IO 是否完成
            self.check_io()

            # 2. 执行就绪任务
            while self.ready:
                task = self.ready.pop(0)
                task.step()  # 执行到下一个 await

            # 3. 如果没有就绪任务，等待 IO
            if not self.ready:
                self.wait_for_io()
```

---

### 1.2 协程的执行流程

**协程（Coroutine）是可以暂停和恢复的函数**

```python
import asyncio

async def fetch_data(url):
    print(f"开始请求 {url}")
    await asyncio.sleep(1)  # 模拟网络请求
    print(f"完成请求 {url}")
    return f"data from {url}"

# 执行流程
async def main():
    # 创建3个协程
    coro1 = fetch_data("url1")
    coro2 = fetch_data("url2")
    coro3 = fetch_data("url3")

    # 并发执行
    results = await asyncio.gather(coro1, coro2, coro3)
    return results

# 运行
asyncio.run(main())
```

**执行时间线**：
```
时间 0.0s: 开始请求 url1
时间 0.0s: 开始请求 url2
时间 0.0s: 开始请求 url3
时间 1.0s: 完成请求 url1
时间 1.0s: 完成请求 url2
时间 1.0s: 完成请求 url3
总耗时: 1.0秒（并发执行）
```

---

### 1.3 asyncio.gather 的实现原理

**asyncio.gather 是 RunnableParallel 异步模式的核心**

```python
# asyncio.gather 的简化实现
async def simple_gather(*coros):
    """简化版 asyncio.gather"""
    # 1. 将所有协程包装为 Task
    tasks = [asyncio.create_task(coro) for coro in coros]

    # 2. 等待所有 Task 完成
    results = []
    for task in tasks:
        result = await task
        results.append(result)

    return results

# 使用
results = await simple_gather(
    fetch_data("url1"),
    fetch_data("url2"),
    fetch_data("url3")
)
```

**关键机制**：
1. **Task 创建**：将协程注册到事件循环
2. **并发调度**：事件循环自动切换任务
3. **结果收集**：按顺序收集所有结果

---

### 1.4 RunnableParallel 的 ainvoke 实现

**源码分析**（简化版）：

```python
class RunnableParallel:
    def __init__(self, **steps):
        self.steps = steps

    async def ainvoke(self, input):
        """异步并行执行"""
        # 1. 创建所有任务
        tasks = {
            key: runnable.ainvoke(input)
            for key, runnable in self.steps.items()
        }

        # 2. 并发执行
        results = await asyncio.gather(*tasks.values())

        # 3. 合并结果
        return dict(zip(tasks.keys(), results))
```

**执行流程**：
```
1. 用户调用 parallel.ainvoke(input)
   ↓
2. 为每个 step 创建协程
   ↓
3. asyncio.gather 并发执行所有协程
   ↓
4. 事件循环调度：
   - 协程1 执行到 await → 暂停
   - 协程2 执行到 await → 暂停
   - 协程3 执行到 await → 暂停
   - 等待 IO 完成
   - 恢复协程1 → 继续执行
   - 恢复协程2 → 继续执行
   - 恢复协程3 → 继续执行
   ↓
5. 收集所有结果
   ↓
6. 返回字典
```

---

### 1.5 asyncio 的性能优势

**为什么 asyncio 更快？**

```python
# 性能对比
import time
import asyncio

# 同步版本
def sync_task():
    time.sleep(1)
    return "done"

start = time.time()
r1 = sync_task()
r2 = sync_task()
r3 = sync_task()
print(f"同步: {time.time() - start:.2f}秒")  # 3秒

# 异步版本
async def async_task():
    await asyncio.sleep(1)
    return "done"

start = time.time()
results = await asyncio.gather(
    async_task(),
    async_task(),
    async_task()
)
print(f"异步: {time.time() - start:.2f}秒")  # 1秒
```

**性能优势来源**：
1. **单线程**：无线程切换开销
2. **协程轻量**：每个协程 < 1KB 内存
3. **高并发**：可支持 10000+ 并发
4. **无 GIL 限制**：不受 Python GIL 影响

---

## 第二部分：threading 线程池原理

### 2.1 什么是线程池？

**线程池（ThreadPoolExecutor）是预先创建的线程集合**

**类比**：线程池就像一个出租车公司
- 预先雇佣司机（创建线程）
- 接到订单分配司机（分配任务）
- 司机完成任务回到公司（线程回到池中）
- 重复使用司机（线程复用）

**基本原理**：
```python
from concurrent.futures import ThreadPoolExecutor

# 创建线程池（5个线程）
with ThreadPoolExecutor(max_workers=5) as executor:
    # 提交任务
    future1 = executor.submit(task1)
    future2 = executor.submit(task2)
    future3 = executor.submit(task3)

    # 等待结果
    result1 = future1.result()
    result2 = future2.result()
    result3 = future3.result()
```

---

### 2.2 线程的执行流程

**线程是操作系统级别的并发单元**

```python
import threading
import time

def worker(name):
    print(f"[{name}] 开始工作")
    time.sleep(1)
    print(f"[{name}] 完成工作")
    return f"result from {name}"

# 创建线程
t1 = threading.Thread(target=worker, args=("线程1",))
t2 = threading.Thread(target=worker, args=("线程2",))
t3 = threading.Thread(target=worker, args=("线程3",))

# 启动线程
t1.start()
t2.start()
t3.start()

# 等待完成
t1.join()
t2.join()
t3.join()
```

**执行时间线**：
```
时间 0.0s: [线程1] 开始工作
时间 0.0s: [线程2] 开始工作
时间 0.0s: [线程3] 开始工作
时间 1.0s: [线程1] 完成工作
时间 1.0s: [线程2] 完成工作
时间 1.0s: [线程3] 完成工作
总耗时: 1.0秒（并行执行）
```

---

### 2.3 ThreadPoolExecutor 的实现原理

**线程池的核心机制**：

```python
# ThreadPoolExecutor 的简化实现
class SimpleThreadPool:
    def __init__(self, max_workers=5):
        self.max_workers = max_workers
        self.tasks = queue.Queue()
        self.workers = []

        # 创建工作线程
        for _ in range(max_workers):
            worker = threading.Thread(target=self._worker)
            worker.start()
            self.workers.append(worker)

    def _worker(self):
        """工作线程循环"""
        while True:
            task = self.tasks.get()  # 从队列获取任务
            if task is None:
                break
            func, args, future = task
            try:
                result = func(*args)
                future.set_result(result)
            except Exception as e:
                future.set_exception(e)

    def submit(self, func, *args):
        """提交任务"""
        future = Future()
        self.tasks.put((func, args, future))
        return future
```

**关键机制**：
1. **任务队列**：存储待执行任务
2. **工作线程**：从队列取任务执行
3. **Future 对象**：异步获取结果

---

### 2.4 RunnableParallel 的 invoke 实现

**源码分析**（简化版）：

```python
from concurrent.futures import ThreadPoolExecutor

class RunnableParallel:
    def invoke(self, input):
        """同步并行执行"""
        with ThreadPoolExecutor() as executor:
            # 1. 提交所有任务
            futures = {
                key: executor.submit(runnable.invoke, input)
                for key, runnable in self.steps.items()
            }

            # 2. 等待所有任务完成
            results = {
                key: future.result()
                for key, future in futures.items()
            }

            return results
```

**执行流程**：
```
1. 用户调用 parallel.invoke(input)
   ↓
2. 创建线程池
   ↓
3. 为每个 step 提交任务到线程池
   ↓
4. 线程池调度：
   - 线程1 执行 runnable1.invoke(input)
   - 线程2 执行 runnable2.invoke(input)
   - 线程3 执行 runnable3.invoke(input)
   - 并行执行（受 GIL 限制，但 IO 操作会释放 GIL）
   ↓
5. 等待所有 Future 完成
   ↓
6. 收集所有结果
   ↓
7. 返回字典
```

---

### 2.5 threading 的限制

**Python GIL（全局解释器锁）的影响**：

```python
# CPU-bound 任务（受 GIL 限制）
def cpu_task():
    total = 0
    for i in range(10000000):
        total += i
    return total

# 多线程执行 CPU-bound 任务
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = [executor.submit(cpu_task) for _ in range(4)]
    results = [f.result() for f in futures]
# 性能提升：几乎没有（受 GIL 限制）

# IO-bound 任务（不受 GIL 限制）
def io_task():
    time.sleep(1)  # IO 操作会释放 GIL
    return "done"

# 多线程执行 IO-bound 任务
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = [executor.submit(io_task) for _ in range(4)]
    results = [f.result() for f in futures]
# 性能提升：4倍（IO 操作释放 GIL）
```

**关键洞察**：
- **CPU-bound**：多线程无效（受 GIL 限制）
- **IO-bound**：多线程有效（IO 操作释放 GIL）
- **LLM API 调用**：IO-bound，多线程有效

---

## 第三部分：asyncio vs threading 对比

### 3.1 性能对比

| 维度 | asyncio | threading |
|------|---------|-----------|
| **并发模型** | 协程（单线程） | 线程（多线程） |
| **内存开销** | 极低（<1KB/协程） | 较高（1-8MB/线程） |
| **最大并发数** | 10000+ | <100 |
| **CPU 利用率** | 单核 | 多核（IO 时） |
| **GIL 影响** | 无 | 有（但 IO 释放 GIL） |
| **调度开销** | 低（用户态） | 高（内核态） |
| **适用场景** | IO-bound + 异步库 | IO-bound + 同步库 |

---

### 3.2 选择标准

**决策树**：
```
使用的库是异步的？
    ├─ 是（如 httpx, aiohttp）
    │   → 使用 asyncio（ainvoke）
    │   → 性能最优
    │
    └─ 否（如 requests）
        → 使用 threading（invoke）
        → 兼容性最好
```

**实际案例**：

```python
# 场景1：使用异步库（httpx）
import httpx

async def fetch_async(url):
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.text

# ✅ 使用 asyncio
parallel = RunnableParallel(
    url1=RunnableLambda(lambda _: fetch_async("https://api1.com")),
    url2=RunnableLambda(lambda _: fetch_async("https://api2.com"))
)
result = await parallel.ainvoke({})

# 场景2：使用同步库（requests）
import requests

def fetch_sync(url):
    response = requests.get(url)
    return response.text

# ✅ 使用 threading
parallel = RunnableParallel(
    url1=RunnableLambda(lambda _: fetch_sync("https://api1.com")),
    url2=RunnableLambda(lambda _: fetch_sync("https://api2.com"))
)
result = parallel.invoke({})
```

---

## 第四部分：手写简化版并行执行器

### 4.1 asyncio 版本

```python
import asyncio
from typing import Dict, Any, Callable

class AsyncParallel:
    """简化版异步并行执行器"""

    def __init__(self, **tasks: Callable):
        self.tasks = tasks

    async def ainvoke(self, input: Any) -> Dict[str, Any]:
        """异步并行执行"""
        # 1. 创建所有协程
        coros = {
            key: self._wrap_task(task, input)
            for key, task in self.tasks.items()
        }

        # 2. 并发执行
        results = await asyncio.gather(*coros.values())

        # 3. 合并结果
        return dict(zip(coros.keys(), results))

    async def _wrap_task(self, task, input):
        """包装任务为协程"""
        if asyncio.iscoroutinefunction(task):
            return await task(input)
        else:
            # 同步函数在线程池中执行
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(None, task, input)

# 使用示例
async def async_task1(x):
    await asyncio.sleep(1)
    return x + 1

async def async_task2(x):
    await asyncio.sleep(1)
    return x * 2

parallel = AsyncParallel(
    add=async_task1,
    multiply=async_task2
)

result = await parallel.ainvoke(5)
print(result)  # {"add": 6, "multiply": 10}
```

---

### 4.2 threading 版本

```python
from concurrent.futures import ThreadPoolExecutor
from typing import Dict, Any, Callable

class ThreadParallel:
    """简化版线程并行执行器"""

    def __init__(self, **tasks: Callable):
        self.tasks = tasks

    def invoke(self, input: Any) -> Dict[str, Any]:
        """同步并行执行"""
        with ThreadPoolExecutor() as executor:
            # 1. 提交所有任务
            futures = {
                key: executor.submit(task, input)
                for key, task in self.tasks.items()
            }

            # 2. 等待所有任务完成
            results = {
                key: future.result()
                for key, future in futures.items()
            }

            return results

# 使用示例
import time

def sync_task1(x):
    time.sleep(1)
    return x + 1

def sync_task2(x):
    time.sleep(1)
    return x * 2

parallel = ThreadParallel(
    add=sync_task1,
    multiply=sync_task2
)

result = parallel.invoke(5)
print(result)  # {"add": 6, "multiply": 10}
```

---

## 第五部分：2025-2026 生产环境应用

### 5.1 多模型并行调用

```python
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langchain_core.runnables import RunnableParallel

# 定义多个模型
gpt4 = ChatOpenAI(model="gpt-4o")
claude = ChatAnthropic(model="claude-3-5-sonnet-20241022")
gemini = ChatOpenAI(model="gemini-2.0-flash", base_url="...")

# 并行调用
parallel = RunnableParallel(
    gpt4=gpt4,
    claude=claude,
    gemini=gemini
)

# 执行
result = await parallel.ainvoke("解释量子计算")
# 1.5秒内获得3个模型的回答
```

---

### 5.2 RAG 多路检索

```python
from langchain_core.runnables import RunnableParallel

# 定义多个检索器
vector_retriever = ...  # 向量数据库
kg_retriever = ...      # 知识图谱
search_retriever = ...  # 搜索引擎

# 并行检索
parallel = RunnableParallel(
    vector=vector_retriever,
    kg=kg_retriever,
    search=search_retriever
)

# 执行
context = await parallel.ainvoke({"query": user_question})
# 同时从3个数据源检索，1.5秒内完成
```

---

### 5.3 内容生成管道

```python
# 同时生成标题、摘要、标签
parallel = RunnableParallel(
    title=title_generator,
    summary=summary_generator,
    tags=tag_generator,
    seo=seo_generator
)

result = await parallel.ainvoke({"content": article})
# 4个生成任务并行执行，节省75%时间
```

---

## 学习检查清单

- [ ] 理解事件循环的工作原理
- [ ] 理解协程的执行流程
- [ ] 理解 asyncio.gather 的实现
- [ ] 理解线程池的调度机制
- [ ] 理解 Python GIL 的影响
- [ ] 能够选择合适的并行模式
- [ ] 能够手写简化版并行执行器
- [ ] 理解生产环境的应用场景

---

## 参考资料

[来源: Asyncio in Python — The Essential Guide for 2025 - https://medium.com/@shweta.trrev/asyncio-in-python-the-essential-guide-for-2025-a006074ee2d1, 访问日期: 2026-02-18]

[来源: Mastering Python Async Patterns: A Complete Guide to asyncio in 2026 - https://dev.to/shehzan/mastering-python-async-patterns-a-complete-guide-to-asyncio-in-2026-10o6, 访问日期: 2026-02-18]

[来源: RunnableParallel — LangChain documentation - https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.base.RunnableParallel.html, 访问日期: 2026-02-18]

---

**版本**: v1.0
**最后更新**: 2026-02-18
**行数**: 约450行
