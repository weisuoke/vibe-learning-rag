# 一句话总结

> **记忆点**: RunnableConfig通过TypedDict定义8个字段，在链式调用中自动传播，使用merge_configs合并（简单字段覆盖，callbacks/tags连接，metadata/configurable合并），支持with_config绑定、configurable_fields动态配置、callbacks追踪、max_concurrency并发控制，实现运行时参数的统一管理和灵活调整。

---

## 核心要点速记

### 1. 配置结构（8个字段）
```
tags, metadata, callbacks, run_name,
max_concurrency, recursion_limit, configurable, run_id
```

### 2. 传递方式（3种）
```
invoke(input, config=config)  # 直接传递
chain.with_config(config)     # 绑定配置
自动传播到子链                # 链式传播
```

### 3. 合并规则（3类）
```
简单字段: 后来覆盖 (run_name, max_concurrency, recursion_limit)
列表字段: 连接 (callbacks, tags)
字典字段: 浅合并 (metadata, configurable)
```

### 4. 动态配置（2种）
```
configurable_fields()        # 动态字段
configurable_alternatives()  # 动态替代
```

### 5. 关键函数（3个）
```
merge_configs()   # 合并配置
ensure_config()   # 确保配置完整
with_config()     # 绑定配置
```

---

## 反直觉点速记

1. ❌ 配置是不可变的（每次invoke创建新上下文）
2. ❌ Callbacks是连接的，不是替换的
3. ❌ configurable字段ID必须全局唯一
4. ❌ with_config()不修改原始Runnable
5. ❌ 配置合并是浅合并，不是深合并
6. ❌ max_concurrency是局部的，不是全局的

---

## 最佳实践速记

1. ✅ 不在配置中存储秘密（使用SecretStr）
2. ✅ 使用配置工厂模式创建可重用配置
3. ✅ 验证用户提供的配置
4. ✅ 使用LangSmith callbacks追踪
5. ✅ 批处理时设置max_concurrency
6. ✅ 使用metadata记录用户和会话信息

---

## 2025-2026新特性速记

- LangChain 1.0配置优化
- LangGraph context API提案
- LangSmith Fetch CLI
- @traceable装饰器
- BackgroundCallbackHandler
- CVE-2025-68664缓解

---

## 面试必答速记

**Q: RunnableConfig有哪些字段？**
A: 8个 - tags, metadata, callbacks, run_name, max_concurrency, recursion_limit, configurable, run_id

**Q: 配置如何合并？**
A: 简单字段覆盖，callbacks/tags连接，metadata/configurable浅合并

**Q: with_config和invoke时传递config的区别？**
A: with_config创建绑定配置的新Runnable（持久化），invoke时传递是临时的

**Q: configurable_fields用途？**
A: 运行时动态调整字段值，如temperature、max_tokens

**Q: max_concurrency作用？**
A: 控制并行执行的最大并发数，优化性能和资源使用

---

## 代码模板速记

```python
# 基础配置传递
config = {"tags": ["prod"], "metadata": {"user": "alice"}}
result = chain.invoke(input, config=config)

# 配置合并
merged = merge_configs(base_config, custom_config)

# 绑定配置
chain_with_config = chain.with_config(config)

# 动态字段
llm = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="temp")
)
result = llm.invoke(input, config={"configurable": {"temp": 0.9}})

# 多模型切换
llm = ChatOpenAI(model="gpt-4").configurable_alternatives(
    ConfigurableField(id="model"),
    default_key="gpt4",
    gpt35=ChatOpenAI(model="gpt-3.5-turbo")
)

# Callbacks
config = {"callbacks": [MyCallback(), LangChainTracer()]}

# 并发控制
config = {"max_concurrency": 5}
results = chain.batch(inputs, config=config)
```

---

## 学习检查清单

- [ ] 理解RunnableConfig的8个字段
- [ ] 掌握配置传递的3种方式
- [ ] 理解merge_configs的合并规则
- [ ] 会使用configurable_fields
- [ ] 会使用configurable_alternatives
- [ ] 理解callbacks传播规则
- [ ] 会使用max_concurrency优化性能
- [ ] 理解配置不可变性
- [ ] 掌握配置验证和安全实践
- [ ] 能够编写生产就绪的配置代码

---

## 关键源码位置

```
langchain_core/runnables/config.py:51-123    # RunnableConfig定义
langchain_core/runnables/config.py:200-250   # merge_configs实现
langchain_core/runnables/config.py:150-180   # ensure_config实现
langchain_core/runnables/base.py:500-550     # with_config方法
langchain_core/runnables/configurable.py     # 可配置字段系统
langchain_core/callbacks/manager.py          # Callbacks管理
```

---

**完整学习**: 返回 [00_概览](./00_概览.md) 查看完整学习路径
