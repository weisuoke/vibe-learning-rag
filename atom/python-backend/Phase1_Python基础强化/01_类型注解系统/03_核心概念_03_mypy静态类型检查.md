# 核心概念3：mypy 静态类型检查

详细讲解 mypy 静态类型检查工具的配置和使用。

---

## 概述

mypy 是 Python 的静态类型检查器，在编写代码时发现类型错误，而不是等到运行时。

---

## 1. mypy 基础

### 1.1 安装和基本使用

```bash
# 安装 mypy
uv add --dev mypy

# 检查单个文件
mypy app.py

# 检查整个目录
mypy app/

# 检查并显示详细信息
mypy --verbose app/

# 生成 HTML 报告
mypy --html-report ./mypy-report app/
```

### 1.2 第一个例子

```python
# app.py
def greet(name: str) -> str:
    return f"Hello, {name}"

# 正确使用
result = greet("Alice")

# 错误使用
result = greet(123)  # ❌ mypy 报错
```

**运行 mypy：**

```bash
$ mypy app.py
app.py:7: error: Argument 1 to "greet" has incompatible type "int"; expected "str"
Found 1 error in 1 file (checked 1 source file)
```

### 1.3 mypy 的工作原理

```python
# mypy 读取类型注解
def add(a: int, b: int) -> int:
    return a + b

# mypy 检查类型一致性
result: str = add(1, 2)  # ❌ mypy 报错：int 不能赋值给 str

# mypy 推断类型
x = 10  # mypy 推断 x 是 int
y = x + 5  # mypy 知道 y 也是 int
z: str = y  # ❌ mypy 报错
```

---

## 2. mypy 配置

### 2.1 配置文件（pyproject.toml）

```toml
# pyproject.toml
[tool.mypy]
# Python 版本
python_version = "3.13"

# 基础配置
warn_return_any = true  # 警告返回 Any
warn_unused_configs = true  # 警告未使用的配置
warn_redundant_casts = true  # 警告多余的类型转换
warn_unused_ignores = true  # 警告无用的 type: ignore

# 严格模式（推荐新项目）
disallow_untyped_defs = true  # 禁止无类型注解的函数
disallow_any_unimported = false  # 允许导入的 Any
disallow_any_expr = false  # 允许 Any 表达式
disallow_any_decorated = false  # 允许装饰器返回 Any
disallow_any_explicit = false  # 允许显式 Any
disallow_any_generics = true  # 禁止泛型中的 Any
disallow_subclassing_any = true  # 禁止继承 Any

# 错误处理
show_error_codes = true  # 显示错误代码
show_column_numbers = true  # 显示列号
pretty = true  # 美化输出

# 导入处理
ignore_missing_imports = false  # 不忽略缺失的导入
follow_imports = "normal"  # 跟踪导入

# 缓存
cache_dir = ".mypy_cache"  # 缓存目录
```

### 2.2 按模块配置

```toml
# pyproject.toml

# 全局配置
[tool.mypy]
python_version = "3.13"
warn_return_any = true

# API 模块：严格模式
[[tool.mypy.overrides]]
module = "app.api.*"
disallow_untyped_defs = true
disallow_any_generics = true

# 工具模块：宽松模式
[[tool.mypy.overrides]]
module = "app.utils.*"
disallow_untyped_defs = false

# 第三方库：忽略错误
[[tool.mypy.overrides]]
module = "some_library.*"
ignore_missing_imports = true
```

### 2.3 严格模式

```toml
# pyproject.toml
[tool.mypy]
# 启用所有严格检查
strict = true

# 等价于以下配置：
# disallow_any_generics = true
# disallow_subclassing_any = true
# disallow_untyped_calls = true
# disallow_untyped_defs = true
# disallow_incomplete_defs = true
# check_untyped_defs = true
# disallow_untyped_decorators = true
# warn_redundant_casts = true
# warn_unused_ignores = true
# warn_return_any = true
# warn_unreachable = true
# strict_equality = true
# strict_concatenate = true
```

---

## 3. 常见错误和解决方案

### 3.1 类型不匹配

```python
# ❌ 错误
def get_age() -> int:
    return "25"  # error: Incompatible return value type

# ✅ 修复
def get_age() -> int:
    return 25

# ❌ 错误
name: str = 123  # error: Incompatible types in assignment

# ✅ 修复
name: str = "Alice"
```

### 3.2 Optional 类型未检查

```python
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    users = {1: "Alice"}
    return users.get(user_id)

# ❌ 错误
name = find_user(1)
print(name.upper())  # error: Item "None" of "Optional[str]" has no attribute "upper"

# ✅ 修复1：检查 None
name = find_user(1)
if name is not None:
    print(name.upper())

# ✅ 修复2：使用默认值
name = find_user(1) or "Unknown"
print(name.upper())

# ✅ 修复3：使用 assert
name = find_user(1)
assert name is not None
print(name.upper())
```

### 3.3 函数缺少类型注解

```python
# ❌ 错误（如果启用 disallow_untyped_defs）
def calculate(x, y):  # error: Function is missing a type annotation
    return x + y

# ✅ 修复
def calculate(x: int, y: int) -> int:
    return x + y
```

### 3.4 Any 类型警告

```python
from typing import Any

# ❌ 警告（如果启用 warn_return_any）
def process_data(data: dict) -> Any:  # note: Returning Any from function
    return data.get("value")

# ✅ 修复：明确返回类型
def process_data(data: dict[str, int]) -> int | None:
    return data.get("value")
```

### 3.5 泛型缺少类型参数

```python
from typing import List

# ❌ 错误（如果启用 disallow_any_generics）
def process_items(items: List) -> None:  # error: Missing type parameters for generic type "List"
    pass

# ✅ 修复
def process_items(items: List[str]) -> None:
    pass

# 或使用 Python 3.9+ 语法
def process_items(items: list[str]) -> None:
    pass
```

---

## 4. 忽略错误

### 4.1 单行忽略

```python
# 忽略整行
result = some_function()  # type: ignore

# 忽略特定错误
result = some_function()  # type: ignore[arg-type]

# 多个错误
result = some_function()  # type: ignore[arg-type, return-value]
```

### 4.2 忽略整个文件

```python
# mypy: ignore-errors

def untyped_function(x, y):
    return x + y
```

### 4.3 忽略导入错误

```python
# 方法1：在代码中忽略
import some_library  # type: ignore

# 方法2：在配置中忽略
# pyproject.toml
[[tool.mypy.overrides]]
module = "some_library"
ignore_missing_imports = true
```

---

## 5. 类型断言

### 5.1 cast（类型转换）

```python
from typing import cast

# 告诉 mypy 这个值是特定类型
data: dict = {"name": "Alice", "age": 25}
name = cast(str, data["name"])  # mypy 相信这是 str
print(name.upper())

# 实际应用
from typing import Any

def get_config() -> dict[str, Any]:
    return {"host": "localhost", "port": 8000}

config = get_config()
host = cast(str, config["host"])  # 断言 host 是 str
port = cast(int, config["port"])  # 断言 port 是 int
```

### 5.2 assert 类型守卫

```python
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    return "Alice" if user_id == 1 else None

# 使用 assert 告诉 mypy 这里不会是 None
user = find_user(1)
assert user is not None  # mypy 知道后面 user 不是 None
print(user.upper())
```

### 5.3 TYPE_CHECKING

```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    # 只在类型检查时导入，运行时不导入（避免循环导入）
    from app.models import User

def process_user(user: "User") -> str:
    return user.name
```

---

## 6. 实战配置

### 6.1 新项目配置（严格模式）

```toml
# pyproject.toml
[tool.mypy]
python_version = "3.13"

# 严格模式
strict = true

# 输出配置
show_error_codes = true
show_column_numbers = true
pretty = true

# 缓存
cache_dir = ".mypy_cache"

# 第三方库
[[tool.mypy.overrides]]
module = "fastapi.*"
ignore_missing_imports = false

[[tool.mypy.overrides]]
module = "pydantic.*"
ignore_missing_imports = false
```

### 6.2 旧项目配置（渐进式）

```toml
# pyproject.toml
[tool.mypy]
python_version = "3.13"

# 宽松模式（逐步收紧）
disallow_untyped_defs = false
warn_return_any = true
warn_unused_ignores = true

# 新模块严格
[[tool.mypy.overrides]]
module = "app.api.*"
disallow_untyped_defs = true

[[tool.mypy.overrides]]
module = "app.services.*"
disallow_untyped_defs = true

# 旧模块宽松
[[tool.mypy.overrides]]
module = "app.legacy.*"
disallow_untyped_defs = false
ignore_errors = true
```

### 6.3 FastAPI 项目配置

```toml
# pyproject.toml
[tool.mypy]
python_version = "3.13"
plugins = ["pydantic.mypy"]

# 严格模式
strict = true

# FastAPI 相关
[[tool.mypy.overrides]]
module = "app.api.*"
disallow_untyped_defs = true
disallow_any_generics = true

# Pydantic 插件配置
[tool.pydantic-mypy]
init_forbid_extra = true
init_typed = true
warn_required_dynamic_aliases = true
```

---

## 7. CI/CD 集成

### 7.1 GitHub Actions

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  type-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.13"

      - name: Install dependencies
        run: |
          pip install uv
          uv sync

      - name: Run mypy
        run: mypy app/

      - name: Upload mypy report
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: mypy-report
          path: mypy-report/
```

### 7.2 pre-commit hook

```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.8.0
    hooks:
      - id: mypy
        additional_dependencies:
          - types-requests
          - types-redis
        args:
          - --config-file=pyproject.toml
```

**安装和使用：**

```bash
# 安装 pre-commit
uv add --dev pre-commit

# 安装 hooks
pre-commit install

# 手动运行
pre-commit run mypy --all-files
```

### 7.3 Makefile 集成

```makefile
# Makefile
.PHONY: typecheck
typecheck:
	mypy app/

.PHONY: typecheck-report
typecheck-report:
	mypy --html-report ./mypy-report app/
	open mypy-report/index.html

.PHONY: typecheck-strict
typecheck-strict:
	mypy --strict app/
```

---

## 8. 高级技巧

### 8.1 stub 文件（.pyi）

```python
# mylib.pyi（类型存根文件）
def process_data(data: str) -> int: ...

class DataProcessor:
    def __init__(self, config: dict[str, str]) -> None: ...
    def process(self, data: str) -> int: ...
```

**使用场景：**
- 为没有类型注解的第三方库添加类型
- 为动态生成的代码添加类型
- 分离类型定义和实现

### 8.2 类型别名文件

```python
# app/types.py
from typing import TypeAlias

# 定义类型别名
UserId: TypeAlias = int
UserData: TypeAlias = dict[str, str | int]
Callback: TypeAlias = Callable[[str], None]

# 在其他文件中使用
from app.types import UserId, UserData

def get_user(user_id: UserId) -> UserData:
    return {"name": "Alice", "age": 25}
```

### 8.3 mypy 插件

```toml
# pyproject.toml
[tool.mypy]
plugins = [
    "pydantic.mypy",
    "sqlalchemy.ext.mypy.plugin"
]

# Pydantic 插件配置
[tool.pydantic-mypy]
init_forbid_extra = true
init_typed = true
warn_required_dynamic_aliases = true
```

---

## 9. 实战示例

### 示例1：FastAPI 项目完整配置

```toml
# pyproject.toml
[tool.mypy]
python_version = "3.13"
plugins = ["pydantic.mypy"]

# 严格模式
strict = true
warn_return_any = true
warn_unused_configs = true
show_error_codes = true
pretty = true

# API 模块
[[tool.mypy.overrides]]
module = "app.api.*"
disallow_untyped_defs = true

# 数据库模型
[[tool.mypy.overrides]]
module = "app.models.*"
disallow_untyped_defs = true

# 服务层
[[tool.mypy.overrides]]
module = "app.services.*"
disallow_untyped_defs = true

# 工具函数
[[tool.mypy.overrides]]
module = "app.utils.*"
disallow_untyped_defs = false

# 测试代码
[[tool.mypy.overrides]]
module = "tests.*"
disallow_untyped_defs = false
```

### 示例2：渐进式类型化

```python
# 第一步：添加基础类型注解
def process_user(user_id: int) -> dict:  # 返回类型暂时用 dict
    return {"id": user_id, "name": "Alice"}

# 第二步：使用 TypedDict
from typing import TypedDict

class UserDict(TypedDict):
    id: int
    name: str

def process_user(user_id: int) -> UserDict:
    return {"id": user_id, "name": "Alice"}

# 第三步：使用 Pydantic
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str

def process_user(user_id: int) -> User:
    return User(id=user_id, name="Alice")
```

### 示例3：错误处理

```python
# app/main.py
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    users = {1: "Alice", 2: "Bob"}
    return users.get(user_id)

def get_user_display(user_id: int) -> str:
    user = find_user(user_id)
    if user is None:
        return "Unknown User"
    return user.upper()

# 运行 mypy
# $ mypy app/main.py
# Success: no issues found in 1 source file
```

---

## 10. 常见问题

### Q1: mypy 报错但代码能运行？

**A:** mypy 是静态检查，Python 运行时不检查类型。mypy 报错说明代码可能有潜在问题。

```python
def add(a: int, b: int) -> int:
    return a + b

result = add("1", "2")  # mypy 报错，但运行时不报错（返回 "12"）
```

### Q2: 如何处理动态类型？

**A:** 使用 Any 或 cast，但尽量避免。

```python
from typing import Any, cast

# 方法1：使用 Any
def process(data: Any) -> str:
    return str(data)

# 方法2：使用 cast
def process(data: dict) -> str:
    value = cast(str, data["key"])
    return value.upper()
```

### Q3: 第三方库没有类型定义？

**A:** 安装 types-* 包或忽略导入错误。

```bash
# 安装类型定义
uv add --dev types-requests types-redis

# 或在配置中忽略
[[tool.mypy.overrides]]
module = "some_library"
ignore_missing_imports = true
```

### Q4: mypy 太慢？

**A:** 使用缓存和增量检查。

```toml
[tool.mypy]
cache_dir = ".mypy_cache"
incremental = true
```

---

## 总结

### mypy 配置速查表

| 配置项 | 作用 | 推荐值 |
|--------|------|--------|
| `python_version` | Python 版本 | `"3.13"` |
| `strict` | 严格模式 | `true`（新项目） |
| `disallow_untyped_defs` | 禁止无类型函数 | `true` |
| `warn_return_any` | 警告返回 Any | `true` |
| `show_error_codes` | 显示错误代码 | `true` |
| `ignore_missing_imports` | 忽略缺失导入 | `false` |

### 最佳实践

1. **新项目**：从严格模式开始
2. **旧项目**：渐进式添加类型注解
3. **CI/CD**：集成 mypy 检查
4. **pre-commit**：提交前自动检查
5. **按模块配置**：不同模块不同严格程度

### 常用命令

```bash
# 基础检查
mypy app/

# 严格模式
mypy --strict app/

# 生成报告
mypy --html-report ./mypy-report app/

# 显示详细信息
mypy --verbose app/

# 只检查特定文件
mypy app/main.py app/api/routes.py
```

### 下一步

学习完 mypy 后，继续学习：
- FastAPI 中的类型注解实战
- 数据模型定义最佳实践
- 类型检查工作流集成
