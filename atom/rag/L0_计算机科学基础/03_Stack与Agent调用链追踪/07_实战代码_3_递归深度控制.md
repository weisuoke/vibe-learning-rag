# 实战代码3：递归深度控制

> 防止栈溢出，实现安全的递归系统

---

## 学习目标

- 理解递归深度限制的必要性
- 实现多种深度控制策略
- 将递归转换为迭代
- 应用于 AI Agent 递归规划

---

## 1. 递归深度限制

### 1.1 基础深度限制

```python
import sys

class RecursionDepthError(Exception):
    """递归深度超限异常"""
    pass

def factorial_with_limit(n: int, depth: int = 0, max_depth: int = 100) -> int:
    """带深度限制的阶乘"""
    if depth >= max_depth:
        raise RecursionDepthError(f"递归深度超过限制 {max_depth}")

    if n <= 1:
        return 1

    return n * factorial_with_limit(n - 1, depth + 1, max_depth)

# 测试
print("=== 深度限制测试 ===")

try:
    result = factorial_with_limit(5, max_depth=10)
    print(f"factorial(5) = {result}")
except RecursionDepthError as e:
    print(f"错误: {e}")

try:
    result = factorial_with_limit(200, max_depth=10)
    print(f"factorial(200) = {result}")
except RecursionDepthError as e:
    print(f"错误: {e}")

# 查看 Python 默认递归限制
print(f"\nPython 默认递归深度限制: {sys.getrecursionlimit()}")
```

**输出：**
```
=== 深度限制测试 ===
factorial(5) = 120
错误: 递归深度超过限制 10

Python 默认递归深度限制: 1000
```

### 1.2 装饰器版本深度限制

```python
from functools import wraps
from typing import Callable, Any

def limit_recursion_depth(max_depth: int = 100):
    """递归深度限制装饰器"""
    def decorator(func: Callable) -> Callable:
        # 使用闭包存储深度计数器
        depth_counter = {'current': 0}

        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            # 检查深度
            if depth_counter['current'] >= max_depth:
                raise RecursionDepthError(
                    f"{func.__name__} 递归深度超过 {max_depth}"
                )

            # 增加深度
            depth_counter['current'] += 1

            try:
                result = func(*args, **kwargs)
                return result
            finally:
                # 减少深度
                depth_counter['current'] -= 1

        return wrapper
    return decorator

# 使用示例
@limit_recursion_depth(max_depth=50)
def fibonacci(n: int) -> int:
    """斐波那契数列"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print("\n=== 装饰器深度限制 ===")

try:
    result = fibonacci(10)
    print(f"fibonacci(10) = {result}")
except RecursionDepthError as e:
    print(f"错误: {e}")

try:
    result = fibonacci(100)
    print(f"fibonacci(100) = {result}")
except RecursionDepthError as e:
    print(f"错误: {e}")
```

---

## 2. 递归转迭代

### 2.1 简单递归转迭代

```python
# 递归版本：阶乘
def factorial_recursive(n: int) -> int:
    """递归阶乘"""
    if n <= 1:
        return 1
    return n * factorial_recursive(n - 1)

# 迭代版本：阶乘
def factorial_iterative(n: int) -> int:
    """迭代阶乘"""
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

# 性能对比
import time

def benchmark(func: Callable, n: int, iterations: int = 1000) -> float:
    """性能测试"""
    start = time.time()
    for _ in range(iterations):
        func(n)
    return time.time() - start

print("\n=== 递归 vs 迭代性能对比 ===")

n = 100
recursive_time = benchmark(factorial_recursive, n)
iterative_time = benchmark(factorial_iterative, n)

print(f"递归版本: {recursive_time:.4f}s")
print(f"迭代版本: {iterative_time:.4f}s")
print(f"性能提升: {(recursive_time / iterative_time - 1) * 100:.1f}%")
```

### 2.2 使用显式栈转换

```python
from typing import List

# 递归版本：树的前序遍历
class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder_recursive(root: TreeNode) -> List[int]:
    """递归前序遍历"""
    if not root:
        return []
    return [root.val] + preorder_recursive(root.left) + preorder_recursive(root.right)

# 迭代版本：使用显式栈
def preorder_iterative(root: TreeNode) -> List[int]:
    """迭代前序遍历（显式栈）"""
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.val)

        # 先压右子树，再压左子树（保证左子树先访问）
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result

# 测试
print("\n=== 树遍历：递归 vs 迭代 ===")

# 构建测试树
#       1
#      / \
#     2   3
#    / \
#   4   5
root = TreeNode(1,
    TreeNode(2, TreeNode(4), TreeNode(5)),
    TreeNode(3)
)

print(f"递归结果: {preorder_recursive(root)}")
print(f"迭代结果: {preorder_iterative(root)}")
```

### 2.3 复杂递归转迭代

```python
# 递归版本：快速排序
def quicksort_recursive(arr: List[int]) -> List[int]:
    """递归快速排序"""
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quicksort_recursive(left) + middle + quicksort_recursive(right)

# 迭代版本：使用显式栈
def quicksort_iterative(arr: List[int]) -> List[int]:
    """迭代快速排序（显式栈）"""
    if len(arr) <= 1:
        return arr

    # 复制数组
    result = arr.copy()

    # 栈存储待排序的区间 (start, end)
    stack = [(0, len(result) - 1)]

    while stack:
        start, end = stack.pop()

        if start >= end:
            continue

        # 分区
        pivot_index = partition(result, start, end)

        # 将左右子区间压栈
        stack.append((start, pivot_index - 1))
        stack.append((pivot_index + 1, end))

    return result

def partition(arr: List[int], start: int, end: int) -> int:
    """分区函数"""
    pivot = arr[end]
    i = start - 1

    for j in range(start, end):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + 1], arr[end] = arr[end], arr[i + 1]
    return i + 1

# 测试
print("\n=== 快速排序：递归 vs 迭代 ===")

test_arr = [3, 6, 8, 10, 1, 2, 1]
print(f"原数组: {test_arr}")
print(f"递归排序: {quicksort_recursive(test_arr)}")
print(f"迭代排序: {quicksort_iterative(test_arr)}")
```

---

## 3. 迭代深化搜索（IDDFS）

### 3.1 基础 IDDFS

```python
from typing import Optional, List, Set

class Graph:
    """图结构"""
    def __init__(self):
        self.adj_list = {}

    def add_edge(self, u, v):
        if u not in self.adj_list:
            self.adj_list[u] = []
        self.adj_list[u].append(v)

    def get_neighbors(self, node):
        return self.adj_list.get(node, [])

def dfs_limited(graph: Graph, start, goal, depth_limit: int,
                visited: Set = None) -> Optional[List]:
    """深度限制的 DFS"""
    if visited is None:
        visited = set()

    if start == goal:
        return [start]

    if depth_limit <= 0:
        return None

    visited.add(start)

    for neighbor in graph.get_neighbors(start):
        if neighbor not in visited:
            path = dfs_limited(graph, neighbor, goal, depth_limit - 1, visited)
            if path:
                return [start] + path

    return None

def iddfs(graph: Graph, start, goal, max_depth: int = 10) -> Optional[List]:
    """迭代深化深度优先搜索"""
    print(f"\n=== IDDFS 搜索从 {start} 到 {goal} ===")

    for depth_limit in range(max_depth + 1):
        print(f"尝试深度限制: {depth_limit}")
        visited = set()
        path = dfs_limited(graph, start, goal, depth_limit, visited)

        if path:
            print(f"找到路径（深度 {depth_limit}）: {path}")
            return path

    print("未找到路径")
    return None

# 测试
graph = Graph()
graph.add_edge('A', 'B')
graph.add_edge('A', 'C')
graph.add_edge('B', 'D')
graph.add_edge('B', 'E')
graph.add_edge('C', 'F')
graph.add_edge('E', 'F')

path = iddfs(graph, 'A', 'F', max_depth=5)
```

### 3.2 AI Agent 中的 IDDFS

```python
class AgentTask:
    """Agent 任务"""
    def __init__(self, name: str, subtasks: List[str] = None):
        self.name = name
        self.subtasks = subtasks or []

class AgentIDDFS:
    """Agent 迭代深化搜索"""

    def __init__(self, max_depth: int = 10):
        self.max_depth = max_depth
        self.tasks = {}

    def add_task(self, task: AgentTask):
        """添加任务"""
        self.tasks[task.name] = task

    def solve_task(self, task_name: str) -> Optional[List[str]]:
        """解决任务（使用 IDDFS）"""
        print(f"\n=== 解决任务: {task_name} ===")

        for depth_limit in range(self.max_depth + 1):
            print(f"\n尝试深度限制: {depth_limit}")

            solution = self._dfs_limited(task_name, depth_limit, set())

            if solution:
                print(f"\n找到解决方案（深度 {depth_limit}）:")
                for i, step in enumerate(solution, 1):
                    print(f"  {i}. {step}")
                return solution

        print("\n无法在深度限制内解决任务")
        return None

    def _dfs_limited(self, task_name: str, depth_limit: int,
                     visited: Set[str]) -> Optional[List[str]]:
        """深度限制的 DFS"""
        if task_name not in self.tasks:
            return None

        task = self.tasks[task_name]

        # 简单任务（无子任务）
        if not task.subtasks:
            return [task_name]

        # 达到深度限制
        if depth_limit <= 0:
            return None

        # 避免循环
        if task_name in visited:
            return None

        visited.add(task_name)

        # 递归解决子任务
        solution = [task_name]
        for subtask_name in task.subtasks:
            subsolution = self._dfs_limited(subtask_name, depth_limit - 1, visited)
            if subsolution:
                solution.extend(subsolution)
            else:
                return None  # 子任务无法解决

        return solution

# 测试
agent = AgentIDDFS(max_depth=5)

# 定义任务层级
agent.add_task(AgentTask("写文章", ["研究主题", "撰写内容"]))
agent.add_task(AgentTask("研究主题", ["查找资料", "阅读文献"]))
agent.add_task(AgentTask("查找资料"))
agent.add_task(AgentTask("阅读文献"))
agent.add_task(AgentTask("撰写内容", ["列大纲", "写正文"]))
agent.add_task(AgentTask("列大纲"))
agent.add_task(AgentTask("写正文"))

solution = agent.solve_task("写文章")
```

---

## 4. AI Agent 递归深度控制

### 4.1 Agent 递归规划器

```python
from dataclasses import dataclass
from typing import Dict, Any
import time

@dataclass
class AgentPlan:
    """Agent 计划"""
    task: str
    subtasks: List[str]
    depth: int
    estimated_time: float

class RecursiveAgentPlanner:
    """递归 Agent 规划器（带深度控制）"""

    def __init__(self, max_depth: int = 5):
        self.max_depth = max_depth
        self.execution_log = []

    def plan_task(self, task: str, depth: int = 0) -> AgentPlan:
        """规划任务"""
        indent = "  " * depth
        print(f"{indent}→ 规划任务: {task} (深度 {depth})")

        # 深度限制检查
        if depth >= self.max_depth:
            print(f"{indent}  达到最大深度 {self.max_depth}，直接执行")
            return AgentPlan(
                task=task,
                subtasks=[],
                depth=depth,
                estimated_time=0.1
            )

        # 判断任务复杂度
        if self._is_simple_task(task):
            print(f"{indent}  任务简单，直接执行")
            return AgentPlan(
                task=task,
                subtasks=[],
                depth=depth,
                estimated_time=0.1
            )

        # 分解任务
        subtasks = self._decompose_task(task)
        print(f"{indent}  分解为 {len(subtasks)} 个子任务")

        # 递归规划子任务
        subplans = []
        total_time = 0

        for subtask in subtasks:
            subplan = self.plan_task(subtask, depth + 1)
            subplans.append(subplan)
            total_time += subplan.estimated_time

        plan = AgentPlan(
            task=task,
            subtasks=subtasks,
            depth=depth,
            estimated_time=total_time
        )

        print(f"{indent}← 完成规划: {task} (预计 {total_time:.1f}s)")
        return plan

    def _is_simple_task(self, task: str) -> bool:
        """判断任务是否简单"""
        simple_keywords = ["查找", "阅读", "列出", "记录"]
        return any(keyword in task for keyword in simple_keywords) or len(task) < 10

    def _decompose_task(self, task: str) -> List[str]:
        """分解任务"""
        if "写文章" in task:
            return ["研究主题", "列大纲", "撰写内容", "校对修改"]
        elif "研究主题" in task:
            return ["查找资料", "阅读文献", "总结要点"]
        elif "撰写内容" in task:
            return ["写引言", "写正文", "写结论"]
        else:
            return [task]

    def execute_plan(self, plan: AgentPlan) -> str:
        """执行计划"""
        indent = "  " * plan.depth
        print(f"{indent}→ 执行: {plan.task}")

        start_time = time.time()

        # 执行子任务
        if plan.subtasks:
            for subtask in plan.subtasks:
                subplan = self.plan_task(subtask, plan.depth + 1)
                self.execute_plan(subplan)
        else:
            # 简单任务，直接执行
            time.sleep(0.05)  # 模拟执行

        duration = time.time() - start_time

        # 记录执行日志
        self.execution_log.append({
            'task': plan.task,
            'depth': plan.depth,
            'duration': duration
        })

        print(f"{indent}← 完成: {plan.task} ({duration:.2f}s)")
        return f"完成: {plan.task}"

    def print_summary(self):
        """打印执行摘要"""
        print("\n" + "="*60)
        print("执行摘要:")
        print("="*60)

        total_time = sum(log['duration'] for log in self.execution_log)
        max_depth = max(log['depth'] for log in self.execution_log)

        print(f"总任务数: {len(self.execution_log)}")
        print(f"总耗时: {total_time:.2f}s")
        print(f"最大深度: {max_depth}")

        print("\n任务详情:")
        for log in self.execution_log:
            indent = "  " * log['depth']
            print(f"{indent}{log['task']}: {log['duration']:.2f}s")

# 测试
print("=== 递归 Agent 规划器 ===")

planner = RecursiveAgentPlanner(max_depth=3)

# 规划任务
plan = planner.plan_task("写一篇关于 AI 的文章")

# 执行计划
print("\n" + "="*60)
print("开始执行:")
print("="*60)
result = planner.execute_plan(plan)

# 打印摘要
planner.print_summary()
```

---

## 5. 2026 年 AI Agent 深度控制实践

### 5.1 Recursive LLM 深度管理

```python
class RecursiveLLM:
    """递归语言模型（2026）"""

    def __init__(self, max_depth: int = 10):
        self.max_depth = max_depth
        self.call_history = []

    def solve(self, problem: str, depth: int = 0) -> str:
        """递归解决问题"""
        indent = "  " * depth
        print(f"{indent}→ RLM 深度 {depth}: {problem[:50]}...")

        # 记录调用
        self.call_history.append({
            'depth': depth,
            'problem': problem
        })

        # 深度限制
        if depth >= self.max_depth:
            print(f"{indent}  达到最大深度，使用迭代深化")
            return self._iterative_deepening(problem)

        # 简单问题
        if self._is_simple(problem):
            result = self._execute_simple(problem)
            print(f"{indent}← 返回: {result[:50]}...")
            return result

        # 分解问题
        subproblems = self._decompose(problem)
        print(f"{indent}  分解为 {len(subproblems)} 个子问题")

        # 递归解决
        sub_results = []
        for i, subproblem in enumerate(subproblems):
            print(f"{indent}  子问题 {i+1}/{len(subproblems)}")
            sub_result = self.solve(subproblem, depth + 1)
            sub_results.append(sub_result)

        # 整合结果
        final_result = self._combine(sub_results)
        print(f"{indent}← 完成: {problem[:50]}...")
        return final_result

    def _is_simple(self, problem: str) -> bool:
        """判断问题是否简单"""
        return len(problem) < 30

    def _execute_simple(self, problem: str) -> str:
        """执行简单问题"""
        time.sleep(0.05)
        return f"解决: {problem}"

    def _decompose(self, problem: str) -> List[str]:
        """分解问题"""
        if "分析" in problem:
            return ["收集数据", "处理数据", "得出结论"]
        return [problem]

    def _combine(self, results: List[str]) -> str:
        """整合结果"""
        return " → ".join(results)

    def _iterative_deepening(self, problem: str) -> str:
        """迭代深化搜索"""
        print(f"    使用迭代深化解决: {problem[:30]}...")
        time.sleep(0.1)
        return f"迭代解决: {problem}"

    def get_max_depth(self) -> int:
        """获取实际最大深度"""
        return max(h['depth'] for h in self.call_history) if self.call_history else 0

# 测试
print("\n=== Recursive LLM 深度管理 ===")

rlm = RecursiveLLM(max_depth=3)
result = rlm.solve("分析 2026 年 AI Agent 发展趋势")

print(f"\n最终结果: {result}")
print(f"实际最大深度: {rlm.get_max_depth()}")
print(f"总调用次数: {len(rlm.call_history)}")
```

### 5.2 LangGraph 深度控制

```python
from typing import TypedDict

class AgentState(TypedDict):
    """Agent 状态"""
    task: str
    depth: int
    max_depth: int
    result: str

class LangGraphDepthController:
    """LangGraph 深度控制器"""

    def __init__(self, max_depth: int = 5):
        self.max_depth = max_depth

    def process_node(self, state: AgentState) -> AgentState:
        """处理节点（带深度检查）"""
        current_depth = state.get('depth', 0)

        print(f"{'  ' * current_depth}→ 处理任务: {state['task']} (深度 {current_depth})")

        # 深度检查
        if current_depth >= self.max_depth:
            print(f"{'  ' * current_depth}  达到最大深度，停止递归")
            return {
                **state,
                'result': f"深度限制: {state['task']}"
            }

        # 处理任务
        time.sleep(0.05)

        return {
            **state,
            'depth': current_depth + 1,
            'result': f"完成: {state['task']}"
        }

# 测试
print("\n=== LangGraph 深度控制 ===")

controller = LangGraphDepthController(max_depth=3)

# 模拟多层任务
tasks = ["主任务", "子任务1", "子任务2", "子任务3", "子任务4"]

for i, task in enumerate(tasks):
    state = {
        'task': task,
        'depth': i,
        'max_depth': 3,
        'result': ''
    }
    result_state = controller.process_node(state)
    print(f"{'  ' * i}  结果: {result_state['result']}\n")
```

---

## 总结

**递归深度控制的核心策略：**

| 策略 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| **深度限制** | 所有递归 | 简单有效 | 可能过早终止 |
| **递归转迭代** | 性能关键 | 无栈溢出风险 | 代码复杂 |
| **IDDFS** | 搜索问题 | 找到最优解 | 重复计算 |
| **迭代深化** | 深度不确定 | 逐步探索 | 时间开销大 |

**AI Agent 应用：**
- Recursive LLM: 深度限制 + 迭代深化
- LangGraph: 状态深度检查
- Agent 规划: 递归分解 + 深度控制
- 知识图谱: IDDFS 遍历

**2026 年最佳实践：**
- 默认深度限制: 10-50 层
- 关键路径: 转换为迭代
- 复杂搜索: 使用 IDDFS
- 监控深度: 记录最大深度

**记住：** 递归深度控制是防止栈溢出的关键，选择合适的策略能保证系统稳定性！
