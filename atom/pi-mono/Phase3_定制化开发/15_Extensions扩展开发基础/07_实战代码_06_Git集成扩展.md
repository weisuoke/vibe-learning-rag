# Extensions 扩展开发基础 - 实战代码 06：Git集成扩展

> 通过 pi.exec() 和会话事件实现 Git 工作流集成

---

## 1. 场景介绍

### 1.1 为什么需要 Git 集成扩展？

在 AI Agent 开发中，Git 集成可以提供强大的版本控制功能：

**场景 1：代码快照**
```
需求：在分支前保存代码状态
问题：分支后代码状态不一致
解决：使用 git stash 创建快照
```

**场景 2：自动提交**
```
需求：会话结束时自动提交更改
问题：忘记提交导致工作丢失
解决：监听 session_end 事件，自动提交
```

**场景 3：代码回滚**
```
需求：快速回滚到之前的状态
问题：手动回滚容易出错
解决：提供 /rollback 命令，一键回滚
```

### 1.2 Git 集成的核心概念

**pi.exec() API**：
```typescript
pi.exec(
  command: string,           // 命令名称（如 "git"）
  args: string[],            // 参数数组
  options?: {
    cwd?: string,            // 工作目录
    signal?: AbortSignal,    // 取消信号
    env?: Record<string, string>,  // 环境变量
  }
): Promise<ExecResult>;

interface ExecResult {
  stdout: string;            // 标准输出
  stderr: string;            // 标准错误
  exitCode: number;          // 退出码
}
```

**Git 工作流事件**：
```typescript
"turn_start"           // Agent 开始处理（创建快照）
"turn_end"             // Agent 处理完成（可选提交）
"session_before_fork"  // 分支前（恢复快照）
"session_end"          // 会话结束（自动提交）
```

**Git 命令模式**：
```typescript
// 创建快照
git stash create

// 应用快照
git stash apply <ref>

// 提交更改
git add . && git commit -m "message"

// 查看状态
git status --porcelain
```

### 1.3 技术要点

- **pi.exec()**：执行 Git 命令
- **快照管理**：使用 git stash 创建和恢复快照
- **自动提交**：在会话结束时自动提交
- **状态检查**：检查是否有未提交的更改
- **错误处理**：处理 Git 命令失败的情况

---

## 2. 完整实现

### 2.1 基础版本：Git 快照（Checkpoint）

```typescript
/**
 * Git Checkpoint Extension - Git 快照
 *
 * 功能：
 * - 在每个 turn 开始时创建 git stash 快照
 * - 在分支时提供恢复快照的选项
 * - 自动清理快照
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  // 快照映射：entryId -> stash ref
  const checkpoints = new Map<string, string>();
  let currentEntryId: string | undefined;

  // 跟踪当前 entry ID
  pi.on("tool_result", async (_event, ctx) => {
    const leaf = ctx.sessionManager.getLeafEntry();
    if (leaf) currentEntryId = leaf.id;
  });

  // Turn 开始时创建快照
  pi.on("turn_start", async () => {
    try {
      // 创建 git stash（不会修改工作区）
      const { stdout } = await pi.exec("git", ["stash", "create"]);
      const ref = stdout.trim();

      if (ref && currentEntryId) {
        checkpoints.set(currentEntryId, ref);
        console.log(`Checkpoint created: ${ref.slice(0, 8)}`);
      }
    } catch (error) {
      console.error("Failed to create checkpoint:", error);
    }
  });

  // 分支前提供恢复选项
  pi.on("session_before_fork", async (event, ctx) => {
    const ref = checkpoints.get(event.entryId);
    if (!ref) return;

    if (!ctx.hasUI) {
      // 非交互模式：不自动恢复
      return;
    }

    // 询问用户是否恢复
    const choice = await ctx.ui.select("Restore code state?", [
      "Yes, restore code to that point",
      "No, keep current code",
    ]);

    if (choice?.startsWith("Yes")) {
      try {
        await pi.exec("git", ["stash", "apply", ref]);
        ctx.ui.notify("Code restored to checkpoint", "success");
      } catch (error: any) {
        ctx.ui.notify(`Failed to restore: ${error.message}`, "error");
      }
    }
  });

  // Agent 结束时清理快照
  pi.on("agent_end", async () => {
    checkpoints.clear();
  });
}
```

### 2.2 进阶版本：自动提交

```typescript
/**
 * Auto Commit Extension - 自动提交
 *
 * 功能：
 * - 会话结束时自动提交更改
 * - 生成智能提交消息
 * - 支持手动提交命令
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  // 检查是否有未提交的更改
  async function hasUncommittedChanges(): Promise<boolean> {
    try {
      const { stdout } = await pi.exec("git", ["status", "--porcelain"]);
      return stdout.trim().length > 0;
    } catch {
      return false;
    }
  }

  // 生成提交消息
  async function generateCommitMessage(): Promise<string> {
    try {
      // 获取修改的文件
      const { stdout } = await pi.exec("git", ["diff", "--name-only", "HEAD"]);
      const files = stdout.trim().split("\n").filter(Boolean);

      if (files.length === 0) {
        return "Update files";
      }

      // 简单的提交消息生成
      if (files.length === 1) {
        return `Update ${files[0]}`;
      } else if (files.length <= 3) {
        return `Update ${files.join(", ")}`;
      } else {
        return `Update ${files.length} files`;
      }
    } catch {
      return "Auto-commit changes";
    }
  }

  // 执行提交
  async function commitChanges(message: string): Promise<boolean> {
    try {
      // 添加所有更改
      await pi.exec("git", ["add", "."]);

      // 提交
      await pi.exec("git", ["commit", "-m", message]);

      return true;
    } catch (error) {
      console.error("Commit failed:", error);
      return false;
    }
  }

  // 会话结束时自动提交
  pi.on("session_end", async (event, ctx) => {
    const hasChanges = await hasUncommittedChanges();

    if (!hasChanges) {
      return;
    }

    if (!ctx.hasUI) {
      // 非交互模式：自动提交
      const message = await generateCommitMessage();
      const success = await commitChanges(message);
      if (success) {
        console.log("Auto-committed changes");
      }
      return;
    }

    // 交互模式：询问用户
    const choice = await ctx.ui.confirm(
      "Uncommitted Changes",
      "You have uncommitted changes. Commit them now?"
    );

    if (choice) {
      const message = await generateCommitMessage();
      const success = await commitChanges(message);

      if (success) {
        ctx.ui.notify("Changes committed", "success");
      } else {
        ctx.ui.notify("Commit failed", "error");
      }
    }
  });

  // 注册 /commit 命令
  pi.registerCommand("commit", {
    description: "Commit current changes with auto-generated message",
    handler: async (args, ctx) => {
      const hasChanges = await hasUncommittedChanges();

      if (!hasChanges) {
        ctx.ui.notify("No changes to commit", "info");
        return;
      }

      // 使用用户提供的消息或自动生成
      const message = args.trim() || (await generateCommitMessage());
      const success = await commitChanges(message);

      if (success) {
        ctx.ui.notify(`Committed: ${message}`, "success");
      } else {
        ctx.ui.notify("Commit failed", "error");
      }
    },
  });
}
```

### 2.3 高级版本：完整 Git 工作流

```typescript
/**
 * Git Workflow Extension - 完整 Git 工作流
 *
 * 功能：
 * - 快照管理（checkpoint）
 * - 自动提交（auto-commit）
 * - 状态查看（/git-status）
 * - 回滚（/rollback）
 * - 分支管理（/git-branch）
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  const checkpoints = new Map<string, string>();
  let currentEntryId: string | undefined;

  // === 快照管理 ===

  pi.on("tool_result", async (_event, ctx) => {
    const leaf = ctx.sessionManager.getLeafEntry();
    if (leaf) currentEntryId = leaf.id;
  });

  pi.on("turn_start", async () => {
    try {
      const { stdout } = await pi.exec("git", ["stash", "create"]);
      const ref = stdout.trim();
      if (ref && currentEntryId) {
        checkpoints.set(currentEntryId, ref);
      }
    } catch (error) {
      console.error("Failed to create checkpoint:", error);
    }
  });

  pi.on("session_before_fork", async (event, ctx) => {
    const ref = checkpoints.get(event.entryId);
    if (!ref || !ctx.hasUI) return;

    const choice = await ctx.ui.select("Restore code state?", [
      "Yes, restore code to that point",
      "No, keep current code",
    ]);

    if (choice?.startsWith("Yes")) {
      try {
        await pi.exec("git", ["stash", "apply", ref]);
        ctx.ui.notify("Code restored to checkpoint", "success");
      } catch (error: any) {
        ctx.ui.notify(`Failed to restore: ${error.message}`, "error");
      }
    }
  });

  // === Git 状态 ===

  pi.registerCommand("git-status", {
    description: "Show git status",
    handler: async (_args, ctx) => {
      try {
        const { stdout } = await pi.exec("git", ["status", "--short"]);

        if (stdout.trim().length === 0) {
          ctx.ui.notify("Working tree clean", "success");
        } else {
          ctx.ui.notify(`Git Status:\n${stdout}`, "info");
        }
      } catch (error: any) {
        ctx.ui.notify(`Error: ${error.message}`, "error");
      }
    },
  });

  // === 回滚 ===

  pi.registerCommand("rollback", {
    description: "Rollback uncommitted changes",
    handler: async (_args, ctx) => {
      if (!ctx.hasUI) {
        ctx.ui.notify("Rollback requires interactive mode", "error");
        return;
      }

      // 确认回滚
      const confirmed = await ctx.ui.confirm(
        "Rollback Changes",
        "This will discard all uncommitted changes. Continue?"
      );

      if (!confirmed) {
        return;
      }

      try {
        // 回滚所有更改
        await pi.exec("git", ["reset", "--hard", "HEAD"]);
        await pi.exec("git", ["clean", "-fd"]);

        ctx.ui.notify("Changes rolled back", "success");
      } catch (error: any) {
        ctx.ui.notify(`Rollback failed: ${error.message}`, "error");
      }
    },
  });

  // === 分支管理 ===

  pi.registerCommand("git-branch", {
    description: "Show current git branch",
    handler: async (_args, ctx) => {
      try {
        const { stdout } = await pi.exec("git", ["branch", "--show-current"]);
        const branch = stdout.trim();

        ctx.ui.notify(`Current branch: ${branch}`, "info");
      } catch (error: any) {
        ctx.ui.notify(`Error: ${error.message}`, "error");
      }
    },
  });

  // === 提交历史 ===

  pi.registerCommand("git-log", {
    description: "Show recent git commits",
    handler: async (args, ctx) => {
      const count = parseInt(args.trim()) || 5;

      try {
        const { stdout } = await pi.exec("git", [
          "log",
          `--max-count=${count}`,
          "--oneline",
        ]);

        ctx.ui.notify(`Recent Commits:\n${stdout}`, "info");
      } catch (error: any) {
        ctx.ui.notify(`Error: ${error.message}`, "error");
      }
    },
  });

  // === 清理 ===

  pi.on("agent_end", async () => {
    checkpoints.clear();
  });
}
```

---

## 3. 代码解析

### 3.1 pi.exec() API

```typescript
// 基本用法
const result = await pi.exec("git", ["status"]);
console.log(result.stdout);  // 标准输出
console.log(result.stderr);  // 标准错误
console.log(result.exitCode); // 退出码

// 带选项
const result = await pi.exec("git", ["log"], {
  cwd: "/path/to/repo",        // 工作目录
  signal: abortSignal,          // 取消信号
  env: { GIT_AUTHOR_NAME: "Bot" },  // 环境变量
});

// 错误处理
try {
  await pi.exec("git", ["commit", "-m", "message"]);
} catch (error: any) {
  console.error("Command failed:", error.message);
  console.error("Exit code:", error.exitCode);
  console.error("Stderr:", error.stderr);
}
```

### 3.2 Git Stash 工作流

```typescript
// 1. 创建快照（不修改工作区）
const { stdout } = await pi.exec("git", ["stash", "create"]);
const ref = stdout.trim();  // 例如: "abc123def456..."

// 2. 保存快照引用
checkpoints.set(entryId, ref);

// 3. 恢复快照
await pi.exec("git", ["stash", "apply", ref]);

// 4. 清理（可选）
// git stash create 创建的快照不会自动清理
// 但它们不会影响工作区，所以通常不需要手动清理
```

**为什么使用 git stash create 而不是 git stash？**
- `git stash`：保存并清空工作区
- `git stash create`：只创建快照，不修改工作区
- 我们需要保留工作区状态，所以使用 `create`

### 3.3 Git 状态检查

```typescript
// 检查是否有未提交的更改
async function hasUncommittedChanges(): Promise<boolean> {
  const { stdout } = await pi.exec("git", ["status", "--porcelain"]);
  return stdout.trim().length > 0;
}

// --porcelain 输出格式：
// M  file.txt        (已修改，已暂存)
// ?? new-file.txt    (未跟踪)
//  M file2.txt       (已修改，未暂存)
```

### 3.4 Git 提交工作流

```typescript
// 1. 检查状态
const hasChanges = await hasUncommittedChanges();
if (!hasChanges) return;

// 2. 添加所有更改
await pi.exec("git", ["add", "."]);

// 3. 提交
await pi.exec("git", ["commit", "-m", message]);

// 4. 推送（可选）
await pi.exec("git", ["push"]);
```

---

## 4. 变体与扩展

### 4.1 智能提交消息生成

```typescript
async function generateSmartCommitMessage(): Promise<string> {
  try {
    // 获取 diff 统计
    const { stdout: diffStat } = await pi.exec("git", [
      "diff",
      "--stat",
      "HEAD",
    ]);

    // 获取修改的文件
    const { stdout: files } = await pi.exec("git", [
      "diff",
      "--name-only",
      "HEAD",
    ]);

    const fileList = files.trim().split("\n").filter(Boolean);

    // 分析文件类型
    const hasTests = fileList.some((f) => f.includes("test"));
    const hasDocs = fileList.some((f) => f.endsWith(".md"));
    const hasCode = fileList.some((f) => /\.(ts|js|py)$/.test(f));

    // 生成消息
    let message = "";

    if (hasTests && hasCode) {
      message = "feat: Add feature with tests";
    } else if (hasTests) {
      message = "test: Update tests";
    } else if (hasDocs) {
      message = "docs: Update documentation";
    } else if (hasCode) {
      message = "feat: Update code";
    } else {
      message = "chore: Update files";
    }

    return message;
  } catch {
    return "chore: Update files";
  }
}
```

### 4.2 Git Hooks 集成

```typescript
export default function (pi: ExtensionAPI) {
  // Pre-commit hook：检查代码质量
  pi.on("tool_call", async (event, ctx) => {
    if (event.toolName !== "bash") return undefined;

    const command = event.input.command as string;

    // 检测 git commit 命令
    if (command.includes("git commit")) {
      // 运行 lint
      try {
        await pi.exec("npm", ["run", "lint"]);
      } catch (error) {
        if (!ctx.hasUI) {
          return { block: true, reason: "Lint failed" };
        }

        const choice = await ctx.ui.confirm(
          "Lint Failed",
          "Linting failed. Commit anyway?"
        );

        if (!choice) {
          return { block: true, reason: "Commit blocked by user" };
        }
      }
    }

    return undefined;
  });
}
```

### 4.3 分支自动创建

```typescript
export default function (pi: ExtensionAPI) {
  pi.on("session_start", async (_event, ctx) => {
    try {
      // 检查当前分支
      const { stdout: currentBranch } = await pi.exec("git", [
        "branch",
        "--show-current",
      ]);

      // 如果在 main/master 分支，创建新分支
      if (currentBranch.trim() === "main" || currentBranch.trim() === "master") {
        if (!ctx.hasUI) return;

        const choice = await ctx.ui.confirm(
          "Create Branch",
          "You're on the main branch. Create a new branch?"
        );

        if (choice) {
          const branchName = await ctx.ui.input(
            "Branch name",
            `feature/${Date.now()}`
          );

          if (branchName) {
            await pi.exec("git", ["checkout", "-b", branchName]);
            ctx.ui.notify(`Created branch: ${branchName}`, "success");
          }
        }
      }
    } catch (error) {
      console.error("Branch creation failed:", error);
    }
  });
}
```

### 4.4 Git 冲突检测

```typescript
export default function (pi: ExtensionAPI) {
  async function hasConflicts(): Promise<boolean> {
    try {
      const { stdout } = await pi.exec("git", ["diff", "--name-only", "--diff-filter=U"]);
      return stdout.trim().length > 0;
    } catch {
      return false;
    }
  }

  pi.on("tool_result", async (_event, ctx) => {
    const conflicts = await hasConflicts();

    if (conflicts) {
      ctx.ui.notify("⚠️ Git conflicts detected!", "warning");
    }
  });

  pi.registerCommand("git-conflicts", {
    description: "Show git conflicts",
    handler: async (_args, ctx) => {
      try {
        const { stdout } = await pi.exec("git", [
          "diff",
          "--name-only",
          "--diff-filter=U",
        ]);

        if (stdout.trim().length === 0) {
          ctx.ui.notify("No conflicts", "success");
        } else {
          ctx.ui.notify(`Conflicts:\n${stdout}`, "warning");
        }
      } catch (error: any) {
        ctx.ui.notify(`Error: ${error.message}`, "error");
      }
    },
  });
}
```

---

## 5. 错误处理

### 5.1 Git 命令失败

```typescript
async function safeExec(
  command: string,
  args: string[]
): Promise<{ success: boolean; output: string }> {
  try {
    const { stdout } = await pi.exec(command, args);
    return { success: true, output: stdout };
  } catch (error: any) {
    console.error(`Command failed: ${command} ${args.join(" ")}`, error);
    return { success: false, output: error.stderr || error.message };
  }
}

// 使用
const result = await safeExec("git", ["status"]);
if (result.success) {
  console.log(result.output);
} else {
  console.error("Git command failed:", result.output);
}
```

### 5.2 非 Git 仓库

```typescript
async function isGitRepo(): Promise<boolean> {
  try {
    await pi.exec("git", ["rev-parse", "--git-dir"]);
    return true;
  } catch {
    return false;
  }
}

export default function (pi: ExtensionAPI) {
  pi.on("session_start", async (_event, ctx) => {
    const isRepo = await isGitRepo();

    if (!isRepo) {
      ctx.ui.notify("Not a git repository", "warning");
      return;
    }

    // 继续 Git 集成逻辑...
  });
}
```

### 5.3 权限问题

```typescript
async function canCommit(): Promise<boolean> {
  try {
    // 检查是否配置了 user.name 和 user.email
    await pi.exec("git", ["config", "user.name"]);
    await pi.exec("git", ["config", "user.email"]);
    return true;
  } catch {
    return false;
  }
}

export default function (pi: ExtensionAPI) {
  pi.registerCommand("commit", {
    description: "Commit changes",
    handler: async (args, ctx) => {
      const canDo = await canCommit();

      if (!canDo) {
        ctx.ui.notify(
          "Git not configured. Please set user.name and user.email",
          "error"
        );
        return;
      }

      // 继续提交逻辑...
    },
  });
}
```

---

## 6. 最佳实践

### 6.1 快照管理

```typescript
// ✓ 好：使用 git stash create（不修改工作区）
const { stdout } = await pi.exec("git", ["stash", "create"]);

// ✗ 差：使用 git stash（会清空工作区）
await pi.exec("git", ["stash"]);
```

### 6.2 提交消息

```typescript
// ✓ 好：描述性提交消息
await pi.exec("git", ["commit", "-m", "feat: Add user authentication"]);

// ✗ 差：无意义提交消息
await pi.exec("git", ["commit", "-m", "update"]);
```

### 6.3 错误处理

```typescript
// ✓ 好：捕获并处理错误
try {
  await pi.exec("git", ["commit", "-m", message]);
  ctx.ui.notify("Committed", "success");
} catch (error: any) {
  ctx.ui.notify(`Commit failed: ${error.message}`, "error");
}

// ✗ 差：忽略错误
await pi.exec("git", ["commit", "-m", message]);
// 如果失败，用户不知道
```

### 6.4 用户确认

```typescript
// ✓ 好：破坏性操作前确认
const confirmed = await ctx.ui.confirm(
  "Rollback",
  "This will discard all changes. Continue?"
);
if (confirmed) {
  await pi.exec("git", ["reset", "--hard"]);
}

// ✗ 差：直接执行破坏性操作
await pi.exec("git", ["reset", "--hard"]);
```

---

## 7. 总结

### 7.1 核心要点

1. **pi.exec()**：执行 Git 命令
2. **git stash create**：创建快照而不修改工作区
3. **会话事件**：在 turn_start、session_before_fork 等事件中集成 Git
4. **自动提交**：在 session_end 时自动提交更改
5. **错误处理**：处理 Git 命令失败、非 Git 仓库等情况

### 7.2 扩展方向

- **智能提交消息**：根据 diff 分析生成提交消息
- **Git Hooks**：集成 pre-commit、pre-push 等 hooks
- **分支管理**：自动创建、切换、合并分支
- **冲突检测**：检测并提示 Git 冲突
- **远程同步**：自动 push/pull

### 7.3 实际应用

Git 集成扩展适用于：
- **版本控制**：自动创建快照和提交
- **代码回滚**：快速回滚到之前的状态
- **协作开发**：自动同步远程仓库
- **工作流自动化**：集成 Git 到 AI Agent 工作流
- **代码审查**：在提交前运行检查

---

**下一步：** 学习 [07_实战代码_07_Provider定制扩展.md](./07_实战代码_07_Provider定制扩展.md)，了解如何定制 LLM Provider。
