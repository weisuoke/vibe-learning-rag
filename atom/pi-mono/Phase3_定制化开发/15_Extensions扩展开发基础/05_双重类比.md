# Extensions 扩展开发基础 - 双重类比

> 通过 TypeScript/Node.js 类比和日常生活类比，深入理解 Extensions 的核心概念

---

## 类比的价值

类比是理解新概念的最快方式。本文档通过两种类比帮助你理解 Extensions：

1. **TypeScript/Node.js 类比**：利用你已有的编程知识
2. **日常生活类比**：用生活中的场景解释技术概念

---

## 类比 1：Extension 模块 = Express 中间件 + 浏览器扩展

### TypeScript/Node.js 类比：Express 中间件

**相似性：**

```typescript
// Express 中间件
app.use((req, res, next) => {
  // 1. 可以读取请求信息
  console.log(req.method, req.url);

  // 2. 可以修改请求/响应
  req.customData = "added by middleware";

  // 3. 可以阻止请求继续
  if (unauthorized) {
    return res.status(403).send("Forbidden");
  }

  // 4. 调用 next() 继续执行
  next();
});

// pi-mono Extension
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 1. 可以读取事件信息
    console.log(event.toolName, event.input);

    // 2. 可以修改事件（通过 transform）
    // 3. 可以阻止事件继续
    if (dangerous) {
      return { block: true, reason: "Blocked" };
    }

    // 4. 不返回 = 允许继续执行
  });
}
```

**核心相似点：**
- 都是在请求/事件流中插入自定义逻辑
- 都可以读取、修改、阻止流程
- 都支持多个中间件/扩展协作
- 都遵循"洋葱模型"（请求进入 → 中间件处理 → 响应返回）

**关键区别：**
- Express 中间件是同步链式调用
- Extensions 是事件驱动的异步模型

### 日常生活类比：机场安检

**Extensions 就像机场的多道安检：**

```
旅客（用户输入）
  ↓
【安检1：身份验证】← Extension 1: 权限检查
  ↓
【安检2：行李扫描】← Extension 2: 内容检查
  ↓
【安检3：危险品检测】← Extension 3: 安全防护
  ↓
登机口（Agent 执行）
```

**相似性：**
- 每道安检都可以检查旅客（读取事件）
- 每道安检都可以拦截旅客（阻止事件）
- 每道安检都可以添加标记（修改事件）
- 所有安检通过后才能登机（事件继续执行）

**实际对应：**

```typescript
// Extension 1: 身份验证
pi.on("tool_call", async (event, ctx) => {
  if (!isAuthorized(event)) {
    return { block: true, reason: "Unauthorized" };
  }
});

// Extension 2: 内容检查
pi.on("tool_call", async (event, ctx) => {
  if (containsSensitiveData(event)) {
    return { block: true, reason: "Sensitive data detected" };
  }
});

// Extension 3: 安全防护
pi.on("tool_call", async (event, ctx) => {
  if (isDangerous(event)) {
    const ok = await ctx.ui.confirm("Dangerous", "Allow?");
    if (!ok) return { block: true, reason: "User denied" };
  }
});
```

---

## 类比 2：ExtensionAPI = 插件接口

### TypeScript/Node.js 类比：VS Code Extension API

**相似性：**

```typescript
// VS Code Extension
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  // 1. 注册命令
  context.subscriptions.push(
    vscode.commands.registerCommand('extension.hello', () => {
      vscode.window.showInformationMessage('Hello!');
    })
  );

  // 2. 监听事件
  vscode.workspace.onDidSaveTextDocument((doc) => {
    console.log('File saved:', doc.fileName);
  });

  // 3. 访问 API
  const editor = vscode.window.activeTextEditor;
}

// pi-mono Extension
export default function (pi: ExtensionAPI) {
  // 1. 注册命令
  pi.registerCommand("hello", {
    description: "Say hello",
    handler: async (args, ctx) => {
      ctx.ui.notify("Hello!", "info");
    },
  });

  // 2. 监听事件
  pi.on("tool_call", async (event, ctx) => {
    console.log('Tool called:', event.toolName);
  });

  // 3. 访问 API
  const branch = ctx.sessionManager.getBranch();
}
```

**核心相似点：**
- 都提供统一的 API 接口
- 都支持命令注册
- 都支持事件监听
- 都有完整的类型定义

### 日常生活类比：智能家居控制面板

**ExtensionAPI 就像智能家居的控制面板：**

```
控制面板（ExtensionAPI）
├── 按钮区（registerCommand）
│   ├── 开灯按钮 → /light-on
│   ├── 关灯按钮 → /light-off
│   └── 调温按钮 → /set-temp
│
├── 传感器区（事件监听）
│   ├── 门铃传感器 → on("doorbell")
│   ├── 温度传感器 → on("temperature")
│   └── 烟雾传感器 → on("smoke")
│
└── 显示屏区（UI API）
    ├── 通知显示 → ctx.ui.notify()
    ├── 确认对话框 → ctx.ui.confirm()
    └── 选择菜单 → ctx.ui.select()
```

**实际对应：**

```typescript
export default function (pi: ExtensionAPI) {
  // 按钮区：注册命令
  pi.registerCommand("status", {
    description: "Show system status",
    handler: async (args, ctx) => {
      ctx.ui.notify("System OK", "success");
    },
  });

  // 传感器区：监听事件
  pi.on("tool_call", async (event, ctx) => {
    if (event.toolName === "bash") {
      // 检测到危险命令（烟雾传感器）
      if (isDangerous(event.input.command)) {
        ctx.ui.notify("⚠️ Dangerous command!", "warning");
      }
    }
  });

  // 显示屏区：UI 交互
  pi.on("session_start", async (event, ctx) => {
    const choice = await ctx.ui.select(
      "Welcome!",
      ["Start coding", "Review code", "Exit"]
    );
  });
}
```

---

## 类比 3：事件系统 = EventEmitter + 责任链模式

### TypeScript/Node.js 类比：Node.js EventEmitter

**相似性：**

```typescript
// Node.js EventEmitter
import { EventEmitter } from 'events';

const emitter = new EventEmitter();

// 多个监听器
emitter.on('data', (data) => {
  console.log('Listener 1:', data);
});

emitter.on('data', (data) => {
  console.log('Listener 2:', data);
});

// 触发事件
emitter.emit('data', { value: 42 });
// 输出:
// Listener 1: { value: 42 }
// Listener 2: { value: 42 }

// pi-mono 事件系统
export default function (pi: ExtensionAPI) {
  // 多个监听器
  pi.on("tool_call", async (event, ctx) => {
    console.log('Extension 1:', event.toolName);
  });

  pi.on("tool_call", async (event, ctx) => {
    console.log('Extension 2:', event.toolName);
  });

  // 当工具被调用时，所有监听器都会被触发
}
```

**核心相似点：**
- 都是发布-订阅模式
- 都支持多个监听器
- 都是异步执行
- 都可以传递数据

**关键增强：**
- pi-mono 的事件监听器可以阻止事件（返回 `{ block: true }`）
- pi-mono 的事件监听器可以转换事件（返回 `{ transform: ... }`）

### 日常生活类比：火灾报警系统

**事件系统就像火灾报警系统：**

```
火灾发生（事件触发）
  ↓
【烟雾探测器】→ 发出警报
  ↓
【自动喷淋系统】→ 开始喷水
  ↓
【消防中心】→ 通知消防队
  ↓
【电梯控制】→ 停止电梯
  ↓
【应急照明】→ 开启应急灯
```

**所有系统同时响应，互不干扰**

**实际对应：**

```typescript
// Extension 1: 日志记录（烟雾探测器）
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    console.log(`[LOG] ${event.toolName} called`);
  });
}

// Extension 2: 安全检查（自动喷淋）
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    if (isDangerous(event)) {
      return { block: true, reason: "Dangerous" };
    }
  });
}

// Extension 3: 性能监控（消防中心）
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    const start = Date.now();
    // 记录性能数据
  });
}

// Extension 4: UI 更新（应急照明）
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    ctx.ui.setStatus(`Executing: ${event.toolName}`);
  });
}
```

---

## 类比 4：工具注册 = REST API 路由注册

### TypeScript/Node.js 类比：Express 路由

**相似性：**

```typescript
// Express 路由
app.post('/api/users', async (req, res) => {
  // 1. 验证参数
  const { name, email } = req.body;
  if (!name || !email) {
    return res.status(400).json({ error: "Missing fields" });
  }

  // 2. 执行业务逻辑
  const user = await createUser(name, email);

  // 3. 返回结果
  res.json({ user });
});

// pi-mono 工具注册
pi.registerTool({
  name: "create_user",
  description: "Create a new user",

  // 1. 定义参数 schema
  parameters: Type.Object({
    name: Type.String(),
    email: Type.String(),
  }),

  // 2. 执行业务逻辑
  async execute(toolCallId, params, signal, onUpdate, ctx) {
    const { name, email } = params as { name: string; email: string };

    // 验证
    if (!email.includes('@')) {
      return {
        content: [{ type: "text", text: "Invalid email" }],
        details: { error: "invalid_email" },
      };
    }

    // 执行
    const user = await createUser(name, email);

    // 3. 返回结果
    return {
      content: [{ type: "text", text: `Created user: ${user.id}` }],
      details: { user },
    };
  },
});
```

**核心相似点：**
- 都是注册一个可调用的端点
- 都需要定义参数 schema
- 都有执行函数
- 都返回结构化结果

### 日常生活类比：餐厅点餐系统

**工具注册就像餐厅的菜单：**

```
菜单（工具列表）
├── 宫保鸡丁（tool: cook_kungpao）
│   ├── 参数：辣度（mild/medium/hot）
│   ├── 参数：份量（small/large）
│   └── 执行：厨师做菜 → 返回菜品
│
├── 麻婆豆腐（tool: cook_mapo）
│   ├── 参数：辣度
│   └── 执行：厨师做菜 → 返回菜品
│
└── 自定义菜（Extension 注册的工具）
    ├── 参数：食材列表
    └── 执行：特殊做法 → 返回菜品
```

**实际对应：**

```typescript
// 注册"做菜"工具
pi.registerTool({
  name: "cook_dish",
  label: "Cook Dish",
  description: "Cook a dish with specified ingredients",

  // 菜单参数
  parameters: Type.Object({
    dish: StringEnum(["kungpao", "mapo", "custom"] as const),
    spiciness: StringEnum(["mild", "medium", "hot"] as const),
    size: StringEnum(["small", "large"] as const),
    ingredients: Type.Optional(Type.Array(Type.String())),
  }),

  // 厨师执行
  async execute(toolCallId, params, signal, onUpdate, ctx) {
    const { dish, spiciness, size, ingredients } = params;

    // 检查食材
    if (dish === "custom" && !ingredients) {
      return {
        content: [{ type: "text", text: "Custom dish needs ingredients" }],
        details: { error: "missing_ingredients" },
      };
    }

    // 做菜
    const result = await cookDish(dish, spiciness, size, ingredients);

    // 上菜
    return {
      content: [{ type: "text", text: `Dish ready: ${result.name}` }],
      details: { dish: result },
    };
  },
});
```

---

## 类比 5：状态管理（details 存储）= Git 分支

### TypeScript/Node.js 类比：Git 版本控制

**相似性：**

```bash
# Git 分支
main
  ├── commit 1: "Add feature A"
  ├── commit 2: "Add feature B"
  └── commit 3: "Add feature C"
      ├── branch feature-x
      │   ├── commit 4: "Work on X"
      │   └── commit 5: "Finish X"
      └── branch feature-y
          ├── commit 4: "Work on Y"
          └── commit 5: "Finish Y"

# pi-mono Session 分支
main session
  ├── message 1: "Create todo A"
  ├── message 2: "Create todo B"
  └── message 3: "Create todo C"
      ├── fork session-x
      │   ├── message 4: "Toggle todo A"
      │   └── message 5: "Delete todo B"
      └── fork session-y
          ├── message 4: "Add todo D"
          └── message 5: "Toggle todo C"
```

**核心相似点：**
- 都支持分支（fork）
- 每个分支有独立的历史
- 分支之间互不影响
- 可以从任意点创建分支

**状态存储对应：**

```typescript
// Git: 每个 commit 包含完整的文件状态
// pi-mono: 每个 tool result 包含完整的状态

pi.registerTool({
  name: "todo",
  async execute(toolCallId, params, signal, onUpdate, ctx) {
    // 修改状态
    todos.push(newTodo);

    // 保存到 details（类似 git commit）
    return {
      content: [{ type: "text", text: "Added" }],
      details: {
        todos: [...todos],  // 完整状态快照
        nextId,
      },
    };
  },
});

// 重建状态（类似 git checkout）
pi.on("session_fork", async (_, ctx) => {
  todos = [];
  // 遍历分支历史，重建状态
  for (const entry of ctx.sessionManager.getBranch()) {
    if (entry.type === "message" && entry.message.toolName === "todo") {
      todos = entry.message.details.todos;
    }
  }
});
```

### 日常生活类比：平行宇宙

**Session 分支就像平行宇宙：**

```
主宇宙（main session）
  ├── 事件1: 买了苹果
  ├── 事件2: 吃了苹果
  └── 事件3: 去了公园
      ├── 宇宙A（fork 1）
      │   ├── 事件4: 遇到朋友
      │   └── 事件5: 一起吃饭
      │   状态: 有朋友，吃饱了
      │
      └── 宇宙B（fork 2）
          ├── 事件4: 独自散步
          └── 事件5: 回家睡觉
          状态: 独自，休息了
```

**关键点：**
- 两个宇宙从"去了公园"这个点分叉
- 宇宙A和宇宙B有不同的后续事件
- 每个宇宙的状态独立演化
- 不能用外部文件存储状态（否则两个宇宙会共享状态）

**实际对应：**

```typescript
// 主 session: todos = [A, B, C]
// 用户 fork 了 session

// Fork 1: 删除 todo B
// 状态: todos = [A, C]

// Fork 2: 添加 todo D
// 状态: todos = [A, B, C, D]

// 如果用外部文件存储 ❌
// ~/.pi/todos.json
// 问题: Fork 1 和 Fork 2 会共享同一个文件，状态会混乱

// 如果用 details 存储 ✅
// 每个 fork 有独立的历史和状态
pi.registerTool({
  name: "todo",
  async execute(toolCallId, params, signal, onUpdate, ctx) {
    return {
      content: [...],
      details: { todos: [...todos] }, // 每个 fork 独立保存
    };
  },
});
```

---

## 类比 6：热重载 = 浏览器开发者工具的热更新

### TypeScript/Node.js 类比：Webpack HMR

**相似性：**

```typescript
// Webpack HMR (Hot Module Replacement)
if (module.hot) {
  module.hot.accept('./component.js', () => {
    // 1. 保存当前状态
    const state = saveState();

    // 2. 卸载旧模块
    unmountOldComponent();

    // 3. 加载新模块
    const NewComponent = require('./component.js');

    // 4. 恢复状态
    mountNewComponent(NewComponent, state);
  });
}

// pi-mono 热重载
class ExtensionManager {
  async reload() {
    // 1. 保存当前状态
    const state = this.saveState();

    // 2. 卸载所有扩展
    for (const ext of this.extensions.values()) {
      await ext.dispose();
    }

    // 3. 清除模块缓存
    this.clearModuleCache();

    // 4. 重新加载扩展
    await this.loadAllExtensions();

    // 5. 恢复状态
    this.restoreState(state);
  }
}
```

**核心相似点：**
- 都是在不重启的情况下更新代码
- 都需要保存和恢复状态
- 都需要清除模块缓存
- 都提升了开发效率

### 日常生活类比：换轮胎不停车

**热重载就像 F1 赛车的进站换胎：**

```
赛车行驶中（pi 运行中）
  ↓
进站（/reload）
  ├── 1. 减速但不熄火（保存状态）
  ├── 2. 换轮胎（卸载旧扩展）
  ├── 3. 装新轮胎（加载新扩展）
  └── 4. 加速继续比赛（恢复状态）
  ↓
继续行驶（继续工作）
```

**如果没有热重载：**
```
赛车行驶中
  ↓
停车熄火（重启 pi）
  ├── 失去位置（丢失 session 状态）
  ├── 换轮胎（更新扩展）
  └── 重新启动（重新开始）
  ↓
从起点开始（状态丢失）
```

**实际对应：**

```bash
# 开发流程（有热重载）
pi
> Working on a task...
# 修改 extension 代码
/reload
# 扩展更新，session 状态保留
> Continue working...

# 开发流程（无热重载）
pi
> Working on a task...
# 修改 extension 代码
# 必须退出 pi
exit
pi
# session 状态丢失，需要重新开始
```

---

## 类比总结表

| pi-mono 概念 | TypeScript/Node.js 类比 | 日常生活类比 | 核心相似性 |
|-------------|------------------------|--------------|-----------|
| **Extension 模块** | Express 中间件 | 机场安检 | 在流程中插入自定义逻辑 |
| **ExtensionAPI** | VS Code Extension API | 智能家居控制面板 | 统一的接口和能力 |
| **事件系统** | EventEmitter | 火灾报警系统 | 发布-订阅，多个响应者 |
| **工具注册** | Express 路由 | 餐厅菜单 | 注册可调用的端点 |
| **状态管理（details）** | Git 分支 | 平行宇宙 | 独立的历史和状态 |
| **热重载** | Webpack HMR | F1 进站换胎 | 不停机更新代码 |

---

## 综合类比：Extensions 生态系统

### 完整类比：智能城市管理系统

```
智能城市（pi-mono）
├── 基础设施（Agent Core）
│   ├── 道路网络（消息流）
│   ├── 电力系统（工具调用）
│   └── 通信网络（事件系统）
│
├── 管理中心（ExtensionAPI）
│   ├── 控制面板（registerTool, registerCommand）
│   ├── 监控系统（事件监听）
│   └── 显示大屏（UI API）
│
└── 智能模块（Extensions）
    ├── 交通管理（safety.ts）
    │   └── 监控危险行为，拦截违规
    ├── 环境监测（logging.ts）
    │   └── 记录所有活动
    ├── 应急响应（git-checkpoint.ts）
    │   └── 自动创建备份
    └── 公共服务（custom-tools.ts）
        └── 提供额外功能
```

**工作流程：**

1. **市民请求**（用户输入）→ 进入城市系统
2. **交通管理**（safety extension）→ 检查是否安全
3. **环境监测**（logging extension）→ 记录活动
4. **执行服务**（Agent 执行工具）→ 完成任务
5. **应急响应**（git-checkpoint）→ 创建备份
6. **返回结果**（工具结果）→ 反馈给市民

**每个模块独立工作，互不干扰，共同维护城市运转**

---

## 使用类比理解复杂概念

### 问题：为什么状态要存储在 details 而不是外部文件？

**Git 类比：**
- Git 分支：每个分支有独立的 commit 历史
- 外部文件：就像所有分支共享一个文件，会导致冲突

**平行宇宙类比：**
- details 存储：每个宇宙有独立的历史
- 外部文件：所有宇宙共享一个笔记本，会混乱

### 问题：为什么需要事件系统而不是回调函数？

**火灾报警类比：**
- 事件系统：一个火警触发多个系统响应（喷淋、通知、照明）
- 回调函数：只能触发一个响应

### 问题：为什么需要热重载？

**F1 换胎类比：**
- 热重载：进站换胎，不停车，保持位置
- 重启：停车熄火，重新开始，丢失位置

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: pi-mono 2025-2026 版本
