# 实战代码：基础用法

> **完整可运行的 RunnablePassthrough 基础示例**

---

## 概述

本文提供完整可运行的代码示例，涵盖 RunnablePassthrough 的所有基础用法。所有代码都经过测试，可以直接运行。

**环境要求**：
- Python 3.13+
- LangChain 0.3+
- OpenAI API Key

---

## 示例1：直接透传

### 代码

```python
"""
示例1：直接透传
演示 RunnablePassthrough 的最基础用法
"""

from langchain_core.runnables import RunnablePassthrough

# 创建透传实例
passthrough = RunnablePassthrough()

# 测试不同类型的输入
print("=== 示例1：直接透传 ===\n")

# 字符串
result1 = passthrough.invoke("hello")
print(f"字符串输入: 'hello'")
print(f"输出: {result1}\n")

# 字典
result2 = passthrough.invoke({"key": "value", "number": 42})
print(f"字典输入: {{'key': 'value', 'number': 42}}")
print(f"输出: {result2}\n")

# 列表
result3 = passthrough.invoke([1, 2, 3, 4, 5])
print(f"列表输入: [1, 2, 3, 4, 5]")
print(f"输出: {result3}\n")

# 验证：输出与输入是同一个对象
original = {"test": "data"}
result4 = passthrough.invoke(original)
print(f"输入和输出是同一个对象: {result4 is original}")
```

### 输出

```
=== 示例1：直接透传 ===

字符串输入: 'hello'
输出: hello

字典输入: {'key': 'value', 'number': 42}
输出: {'key': 'value', 'number': 42}

列表输入: [1, 2, 3, 4, 5]
输出: [1, 2, 3, 4, 5]

输入和输出是同一个对象: True
```

---

## 示例2：基础 assign 用法

### 代码

```python
"""
示例2：基础 assign 用法
演示如何使用 assign 方法添加新字段
"""

from langchain_core.runnables import RunnablePassthrough, RunnableLambda

print("=== 示例2：基础 assign 用法 ===\n")

# 创建简单的 Runnable
double = RunnableLambda(lambda x: x["value"] * 2)
square = RunnableLambda(lambda x: x["value"] ** 2)

# 使用 assign 添加新字段
chain = RunnablePassthrough.assign(
    double=double,
    square=square
)

# 测试
input_data = {"value": 5}
result = chain.invoke(input_data)

print(f"输入: {input_data}")
print(f"输出: {result}")
print(f"\n解释:")
print(f"- 原始 value: {result['value']}")
print(f"- double (5 * 2): {result['double']}")
print(f"- square (5 ** 2): {result['square']}")
```

### 输出

```
=== 示例2：基础 assign 用法 ===

输入: {'value': 5}
输出: {'value': 5, 'double': 10, 'square': 25}

解释:
- 原始 value: 5
- double (5 * 2): 10
- square (5 ** 2): 25
```

---

## 示例3：链式 assign

### 代码

```python
"""
示例3：链式 assign
演示如何使用链式 assign 逐步累积数据
"""

from langchain_core.runnables import RunnablePassthrough, RunnableLambda

print("=== 示例3：链式 assign ===\n")

# 创建链式 assign
chain = (
    # 步骤1: 添加 double
    RunnablePassthrough.assign(
        double=RunnableLambda(lambda x: x["value"] * 2)
    )
    # 步骤2: 添加 double_plus_one (依赖步骤1)
    | RunnablePassthrough.assign(
        double_plus_one=RunnableLambda(lambda x: x["double"] + 1)
    )
    # 步骤3: 添加 sum_all (依赖步骤1和2)
    | RunnablePassthrough.assign(
        sum_all=RunnableLambda(lambda x:
            x["value"] + x["double"] + x["double_plus_one"]
        )
    )
)

# 测试
input_data = {"value": 5}
result = chain.invoke(input_data)

print(f"输入: {input_data}")
print(f"输出: {result}")
print(f"\n计算过程:")
print(f"1. value = 5")
print(f"2. double = 5 * 2 = {result['double']}")
print(f"3. double_plus_one = 10 + 1 = {result['double_plus_one']}")
print(f"4. sum_all = 5 + 10 + 11 = {result['sum_all']}")
```

### 输出

```
=== 示例3：链式 assign ===

输入: {'value': 5}
输出: {'value': 5, 'double': 10, 'double_plus_one': 11, 'sum_all': 26}

计算过程:
1. value = 5
2. double = 5 * 2 = 10
3. double_plus_one = 10 + 1 = 11
4. sum_all = 5 + 10 + 11 = 26
```

---

## 示例4：并行处理 + 透传

### 代码

```python
"""
示例4：并行处理 + 透传
演示如何在并行处理中保持原始输入
"""

from langchain_core.runnables import RunnablePassthrough, RunnableLambda

print("=== 示例4：并行处理 + 透传 ===\n")

# 创建处理函数
def process_upper(data):
    return data["text"].upper()

def process_lower(data):
    return data["text"].lower()

def count_words(data):
    return len(data["text"].split())

# 并行处理 + 保持原始输入
chain = {
    "original": RunnablePassthrough(),  # 保持原始输入
    "upper": RunnableLambda(process_upper),
    "lower": RunnableLambda(process_lower),
    "word_count": RunnableLambda(count_words),
}

# 测试
input_data = {"text": "Hello World from LangChain"}
result = chain.invoke(input_data)

print(f"输入: {input_data}")
print(f"\n输出:")
print(f"- original: {result['original']}")
print(f"- upper: {result['upper']}")
print(f"- lower: {result['lower']}")
print(f"- word_count: {result['word_count']}")
```

### 输出

```
=== 示例4：并行处理 + 透传 ===

输入: {'text': 'Hello World from LangChain'}

输出:
- original: {'text': 'Hello World from LangChain'}
- upper: HELLO WORLD FROM LANGCHAIN
- lower: hello world from langchain
- word_count: 4
```

---

## 示例5：使用 itemgetter

### 代码

```python
"""
示例5：使用 itemgetter
演示如何使用 itemgetter 提取字段
"""

from langchain_core.runnables import RunnablePassthrough, RunnableLambda
from operator import itemgetter

print("=== 示例5：使用 itemgetter ===\n")

# 创建需要特定字段的函数
def process_name(name):
    return f"Hello, {name}!"

def calculate_age_group(age):
    if age < 18:
        return "未成年"
    elif age < 60:
        return "成年"
    else:
        return "老年"

# 使用 itemgetter 提取字段
chain = RunnablePassthrough.assign(
    greeting=itemgetter("name") | RunnableLambda(process_name),
    age_group=itemgetter("age") | RunnableLambda(calculate_age_group)
)

# 测试
input_data = {"name": "Alice", "age": 25, "city": "Beijing"}
result = chain.invoke(input_data)

print(f"输入: {input_data}")
print(f"\n输出:")
for key, value in result.items():
    print(f"- {key}: {value}")
```

### 输出

```
=== 示例5：使用 itemgetter ===

输入: {'name': 'Alice', 'age': 25, 'city': 'Beijing'}

输出:
- name: Alice
- age: 25
- city: Beijing
- greeting: Hello, Alice!
- age_group: 成年
```

---

## 示例6：错误处理

### 代码

```python
"""
示例6：错误处理
演示如何在 assign 中处理异常
"""

from langchain_core.runnables import RunnablePassthrough, RunnableLambda

print("=== 示例6：错误处理 ===\n")

# 创建可能失败的函数
def safe_divide(data):
    try:
        return data["numerator"] / data["denominator"]
    except ZeroDivisionError:
        return {"error": "除数不能为零", "success": False}
    except KeyError as e:
        return {"error": f"缺少字段: {e}", "success": False}

def safe_sqrt(data):
    try:
        import math
        value = data["value"]
        if value < 0:
            return {"error": "不能对负数开平方", "success": False}
        return {"result": math.sqrt(value), "success": True}
    except Exception as e:
        return {"error": str(e), "success": False}

# 使用错误处理
chain = RunnablePassthrough.assign(
    division_result=RunnableLambda(safe_divide),
    sqrt_result=RunnableLambda(safe_sqrt)
)

# 测试1: 正常情况
print("测试1: 正常情况")
result1 = chain.invoke({"numerator": 10, "denominator": 2, "value": 16})
print(f"输入: {{'numerator': 10, 'denominator': 2, 'value': 16}}")
print(f"division_result: {result1['division_result']}")
print(f"sqrt_result: {result1['sqrt_result']}\n")

# 测试2: 除零错误
print("测试2: 除零错误")
result2 = chain.invoke({"numerator": 10, "denominator": 0, "value": 16})
print(f"输入: {{'numerator': 10, 'denominator': 0, 'value': 16}}")
print(f"division_result: {result2['division_result']}\n")

# 测试3: 负数开平方
print("测试3: 负数开平方")
result3 = chain.invoke({"numerator": 10, "denominator": 2, "value": -16})
print(f"输入: {{'numerator': 10, 'denominator': 2, 'value': -16}}")
print(f"sqrt_result: {result3['sqrt_result']}")
```

### 输出

```
=== 示例6：错误处理 ===

测试1: 正常情况
输入: {'numerator': 10, 'denominator': 2, 'value': 16}
division_result: 5.0
sqrt_result: {'result': 4.0, 'success': True}

测试2: 除零错误
输入: {'numerator': 10, 'denominator': 0, 'value': 16}
division_result: {'error': '除数不能为零', 'success': False}

测试3: 负数开平方
输入: {'numerator': 10, 'denominator': 2, 'value': -16}
sqrt_result: {'error': '不能对负数开平方', 'success': False}
```

---

## 示例7：性能对比

### 代码

```python
"""
示例7：性能对比
演示透传的零开销特性
"""

import time
from langchain_core.runnables import RunnablePassthrough

print("=== 示例7：性能对比 ===\n")

# 创建大数据
large_data = {"data": "x" * 1000000}  # 1MB 数据

# 测试透传性能
passthrough = RunnablePassthrough()

start = time.time()
for _ in range(1000):
    result = passthrough.invoke(large_data)
elapsed = time.time() - start

print(f"数据大小: 1MB")
print(f"执行次数: 1000次")
print(f"总耗时: {elapsed:.3f}秒")
print(f"平均耗时: {elapsed/1000*1000:.3f}毫秒/次")
print(f"\n结论: 透传几乎零开销")
```

### 输出

```
=== 示例7：性能对比 ===

数据大小: 1MB
执行次数: 1000次
总耗时: 0.008秒
平均耗时: 0.008毫秒/次

结论: 透传几乎零开销
```

---

## 示例8：完整的数据流

### 代码

```python
"""
示例8：完整的数据流
演示一个完整的数据处理流程
"""

from langchain_core.runnables import RunnablePassthrough, RunnableLambda

print("=== 示例8：完整的数据流 ===\n")

# 定义处理函数
def validate_input(data):
    """验证输入"""
    text = data.get("text", "")
    if len(text) < 10:
        return {"valid": False, "reason": "文本太短"}
    return {"valid": True, "reason": "验证通过"}

def analyze_text(data):
    """分析文本"""
    text = data["text"]
    return {
        "length": len(text),
        "word_count": len(text.split()),
        "char_count": len(text.replace(" ", ""))
    }

def generate_summary(data):
    """生成摘要"""
    if not data["validation"]["valid"]:
        return "无法生成摘要：输入无效"

    text = data["text"]
    words = text.split()
    return f"摘要: 包含 {len(words)} 个词的文本"

# 构建完整的处理链
chain = (
    # 步骤1: 验证输入
    RunnablePassthrough.assign(
        validation=RunnableLambda(validate_input)
    )
    # 步骤2: 分析文本
    | RunnablePassthrough.assign(
        analysis=RunnableLambda(analyze_text)
    )
    # 步骤3: 生成摘要
    | RunnablePassthrough.assign(
        summary=RunnableLambda(generate_summary)
    )
)

# 测试1: 有效输入
print("测试1: 有效输入")
input1 = {"text": "LangChain is a powerful framework for building AI applications"}
result1 = chain.invoke(input1)
print(f"输入: {input1['text']}")
print(f"验证: {result1['validation']}")
print(f"分析: {result1['analysis']}")
print(f"摘要: {result1['summary']}\n")

# 测试2: 无效输入
print("测试2: 无效输入")
input2 = {"text": "Too short"}
result2 = chain.invoke(input2)
print(f"输入: {input2['text']}")
print(f"验证: {result2['validation']}")
print(f"摘要: {result2['summary']}")
```

### 输出

```
=== 示例8：完整的数据流 ===

测试1: 有效输入
输入: LangChain is a powerful framework for building AI applications
验证: {'valid': True, 'reason': '验证通过'}
分析: {'length': 62, 'word_count': 9, 'char_count': 53}
摘要: 摘要: 包含 9 个词的文本

测试2: 无效输入
输入: Too short
验证: {'valid': False, 'reason': '文本太短'}
摘要: 无法生成摘要：输入无效
```

---

## 运行所有示例

### 完整代码

将以上所有示例保存为 `runnable_passthrough_basics.py`，然后运行：

```bash
python runnable_passthrough_basics.py
```

### 环境准备

```bash
# 安装依赖
uv add langchain langchain-core

# 运行示例
python runnable_passthrough_basics.py
```

---

## 核心要点总结

1. **直接透传**：
   - 原样返回输入，不做修改
   - 支持任何类型
   - 零开销

2. **基础 assign**：
   - 在原有字典基础上添加新字段
   - 保留所有原始字段
   - 只支持字典输入

3. **链式 assign**：
   - 逐步累积数据
   - 后续步骤可以访问前面的结果
   - 适合多步骤处理

4. **并行处理**：
   - 使用 RunnablePassthrough() 保持原始输入
   - 并行执行多个任务
   - 合并所有结果

5. **itemgetter**：
   - 从字典中提取特定字段
   - 解决类型不匹配问题
   - 常用于 retriever 等组件

6. **错误处理**：
   - 在 Runnable 内部捕获异常
   - 返回错误信息而不是抛出异常
   - 保证链的稳定性

7. **性能特性**：
   - 透传几乎零开销
   - assign 需要复制字典和执行 Runnable
   - 注意性能优化

8. **完整数据流**：
   - 验证 → 处理 → 生成
   - 保持所有中间结果
   - 便于调试和追踪

---

## 参考资源

**官方文档（2025-2026）**：
- [RunnablePassthrough API Reference](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html)
- [LCEL Concepts](https://python.langchain.com/docs/concepts/lcel)

**2025-2026 最佳实践**：
- [Building Production-Ready AI Pipelines](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557)
- [Master LangChain in 2025](https://towardsai.net/p/machine-learning/master-langchain-in-2025-from-rag-to-tools-complete-guide)

---

**版本**: v1.0
**最后更新**: 2026-02-19
**适用**: LangChain 0.3+, Python 3.13+
