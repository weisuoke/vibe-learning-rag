# 关系定义 - 概览

> SQLAlchemy 的关系定义，用 relationship() 声明表之间的关联关系

---

## 学习目标

完成本知识点后，你将能够：

- ✅ 理解关系定义的本质和价值
- ✅ 定义一对多关系（用户-对话）
- ✅ 定义多对多关系（对话-标签）
- ✅ 定义一对一关系（用户-个人资料）
- ✅ 定义自引用关系（用户关注系统）
- ✅ 选择合适的加载策略（避免 N+1 问题）
- ✅ 配置级联操作（自动删除关联数据）
- ✅ 在 FastAPI 中使用关系定义

---

## 知识点结构

### 基础维度

1. **30字核心** - 一句话理解关系定义
2. **第一性原理** - 从根本理解关系定义的本质
3. **最小可用** - 5个核心知识快速上手
4. **双重类比** - 前端开发 + 日常生活类比
5. **反直觉点** - 3个常见误区
6. **面试必问** - 3个高频面试题及出彩回答
7. **化骨绵掌** - 10个2分钟知识卡片
8. **一句话总结** - 完整总结

### 核心概念（3个关系类型深度讲解）

1. **一对多关系** - relationship 配置、back_populates、加载策略、级联操作、手写实现
2. **多对多关系** - 中间表、secondary 参数、Association Object、查询优化、手写实现
3. **一对一与自引用关系** - uselist=False、自引用关系、remote_side、手写实现

### 实战代码（3个场景）

1. **一对多场景** - 用户-对话（AI Agent 上下文）
2. **多对多场景** - 对话-标签（AI Agent 上下文）
3. **复杂关系场景** - 完整的 AI Agent 数据模型

---

## 学习路径

```
第一步：理解本质
├─ 30字核心：快速理解关系定义
├─ 第一性原理：从根本理解为什么需要关系定义
└─ 双重类比：用前端和日常生活类比理解

第二步：掌握基础
├─ 最小可用：5个核心知识快速上手
│  ├─ 一对多关系定义
│  ├─ 多对多关系定义
│  ├─ 加载策略（lazy）
│  ├─ 级联操作（cascade）
│  └─ FastAPI 集成
└─ 核心概念：深入理解3种关系类型
   ├─ 一对多关系（最常用）
   ├─ 多对多关系（需要中间表）
   └─ 一对一与自引用关系（进阶）

第三步：避免陷阱
├─ 反直觉点：3个常见误区
│  ├─ relationship 不会自动创建外键
│  ├─ 访问 relationship 会触发查询
│  └─ back_populates vs backref
└─ 面试必问：3个高频面试题

第四步：实战应用
├─ 实战代码：3个完整场景
│  ├─ 一对多场景（用户-对话）
│  ├─ 多对多场景（对话-标签）
│  └─ 复杂关系场景（完整数据模型）
└─ 化骨绵掌：10个知识卡片速查

第五步：总结回顾
└─ 一句话总结：完整总结关系定义
```

---

## 核心要点

### 1. 关系定义的本质

**relationship 是 ORM 层面的对象导航，不是数据库约束**

```python
class Conversation(Base):
    # 外键：数据库层面的约束
    user_id = Column(Integer, ForeignKey('users.id'))

    # relationship：ORM 层面的导航
    user = relationship("User", back_populates="conversations")
```

**类比：**
- 外键 = 门牌号（数据库知道地址）
- relationship = 导航软件（Python 知道怎么走）

### 2. 四种关系类型

| 关系类型 | 外键位置 | 配置要点 | 使用场景 |
|---------|---------|---------|---------|
| 一对多 | "多"的一方 | `back_populates` | 用户-对话、对话-消息 |
| 多对多 | 中间表 | `secondary` | 对话-标签、用户-角色 |
| 一对一 | 任意一方 | `uselist=False` | 用户-个人资料 |
| 自引用 | 自己 | `remote_side` | 用户关注、组织树 |

### 3. 加载策略

| 策略 | 查询时机 | 适用场景 | SQL 示例 |
|-----|---------|---------|---------|
| `lazy='select'` | 访问时查询 | 默认，简单场景 | `SELECT * WHERE user_id=1` |
| `lazy='joined'` | 立即 JOIN | 总是需要关联数据 | `LEFT JOIN conversations` |
| `lazy='selectin'` | 批量 IN 查询 | 循环访问（推荐） | `WHERE user_id IN (1,2,3)` |

### 4. 级联操作

| 级联选项 | 行为 | 适用场景 |
|---------|-----|---------|
| `"all, delete-orphan"` | 删除父对象删除子对象，子对象脱离父对象也删除 | 强依赖关系 |
| `"all"` | 删除父对象删除子对象 | 一般依赖关系 |
| `"save-update"` | 保存父对象自动保存子对象 | 默认行为 |

---

## 在 AI Agent 开发中的应用

### 典型数据模型

```
User（用户）
  ├─ 一对多 → Conversation（对话）
  │            ├─ 一对多 → Message（消息）
  │            └─ 多对多 → Tag（标签）
  └─ 多对多 → User（关注关系）
```

### 代码示例

```python
from sqlalchemy import Column, Integer, String, ForeignKey, Table
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

# 多对多中间表
conversation_tags = Table(
    'conversation_tags',
    Base.metadata,
    Column('conversation_id', ForeignKey('conversations.id')),
    Column('tag_id', ForeignKey('tags.id'))
)

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)

    # 一对多：用户的对话
    conversations = relationship(
        "Conversation",
        back_populates="user",
        lazy='selectin',
        cascade="all, delete-orphan"
    )

class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)
    title = Column(String)
    user_id = Column(Integer, ForeignKey('users.id'))

    # 多对一：对话属于哪个用户
    user = relationship("User", back_populates="conversations")

    # 一对多：对话的消息
    messages = relationship(
        "Message",
        back_populates="conversation",
        lazy='selectin',
        cascade="all, delete-orphan"
    )

    # 多对多：对话的标签
    tags = relationship("Tag", secondary=conversation_tags, back_populates="conversations")

class Message(Base):
    __tablename__ = 'messages'
    id = Column(Integer, primary_key=True)
    content = Column(String)
    conversation_id = Column(Integer, ForeignKey('conversations.id'))

    # 多对一：消息属于哪个对话
    conversation = relationship("Conversation", back_populates="messages")

class Tag(Base):
    __tablename__ = 'tags'
    id = Column(Integer, primary_key=True)
    name = Column(String)

    # 多对多：标签关联的对话
    conversations = relationship("Conversation", secondary=conversation_tags, back_populates="tags")
```

---

## 常见陷阱

### 陷阱1：忘记定义外键

```python
# ❌ 错误：只定义 relationship，没有外键
class Conversation(Base):
    user = relationship("User")  # 缺少外键！

# ✅ 正确：同时定义外键和 relationship
class Conversation(Base):
    user_id = Column(Integer, ForeignKey('users.id'))  # 外键
    user = relationship("User")  # relationship
```

### 陷阱2：N+1 查询问题

```python
# ❌ 产生 N+1 问题
users = session.query(User).all()  # 1次查询
for user in users:
    print(user.conversations)  # N次查询

# ✅ 使用 selectin 避免 N+1
class User(Base):
    conversations = relationship("Conversation", lazy='selectin')

users = session.query(User).all()  # 总共2次查询
```

### 陷阱3：使用 backref 而非 back_populates

```python
# ❌ 不推荐：使用 backref
class User(Base):
    conversations = relationship("Conversation", backref="user")

# ✅ 推荐：使用 back_populates
class User(Base):
    conversations = relationship("Conversation", back_populates="user")

class Conversation(Base):
    user = relationship("User", back_populates="conversations")
```

---

## 学习检查清单

完成本知识点后，你应该能够：

- [ ] 解释 relationship 和外键的区别
- [ ] 定义一对多关系（用户-对话）
- [ ] 定义多对多关系（对话-标签）
- [ ] 定义一对一关系（用户-个人资料）
- [ ] 定义自引用关系（用户关注）
- [ ] 选择合适的加载策略（lazy='select' vs lazy='selectin' vs lazy='joined'）
- [ ] 配置级联操作（cascade="all, delete-orphan"）
- [ ] 避免 N+1 查询问题
- [ ] 使用 back_populates 而非 backref
- [ ] 在 FastAPI 中使用关系定义

---

## 下一步学习

完成本知识点后，建议学习：

1. **数据库迁移 Alembic**（Phase3_数据库层/04）- 管理数据库 schema 变更
2. **连接池配置**（Phase3_数据库层/05）- 优化数据库连接性能
3. **向量检索 pgvector**（Phase3_数据库层/06）- AI Agent 的向量检索能力

---

## 快速参考

### 一对多关系模板

```python
class Parent(Base):
    __tablename__ = 'parents'
    id = Column(Integer, primary_key=True)
    children = relationship("Child", back_populates="parent", lazy='selectin')

class Child(Base):
    __tablename__ = 'children'
    id = Column(Integer, primary_key=True)
    parent_id = Column(Integer, ForeignKey('parents.id'))
    parent = relationship("Parent", back_populates="children")
```

### 多对多关系模板

```python
association_table = Table(
    'association',
    Base.metadata,
    Column('left_id', ForeignKey('left.id')),
    Column('right_id', ForeignKey('right.id'))
)

class Left(Base):
    __tablename__ = 'left'
    id = Column(Integer, primary_key=True)
    rights = relationship("Right", secondary=association_table, back_populates="lefts")

class Right(Base):
    __tablename__ = 'right'
    id = Column(Integer, primary_key=True)
    lefts = relationship("Left", secondary=association_table, back_populates="rights")
```

### 一对一关系模板

```python
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    profile = relationship("Profile", uselist=False, back_populates="user")

class Profile(Base):
    __tablename__ = 'profiles'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User", back_populates="profile")
```

---

**版本：** v1.0
**最后更新：** 2026-02-11
