# 面试必问

## 问题 1："Sub-Agents 和普通函数调用有什么区别？"

### 普通回答（❌ 不出彩）
"Sub-Agents 是独立的进程，函数调用是在同一个进程里。"

### 出彩回答（✅ 推荐）

> **Sub-Agents 和函数调用有三个本质区别：**
>
> 1. **执行隔离**：Sub-Agents 运行在独立的 `pi` 进程中，拥有独立的内存空间和上下文窗口。函数调用共享同一进程的内存和上下文。这意味着 Sub-Agent 崩溃不会影响主 Agent，而函数崩溃会导致整个程序终止。
>
> 2. **AI 能力**：Sub-Agents 是完整的 AI 代理，有 LLM 推理能力、工具调用能力和自主决策能力。函数调用只是执行预定义的代码逻辑，没有 AI 能力。例如，Sub-Agent 可以根据代码库结构自主选择搜索策略，而函数只能按固定逻辑执行。
>
> 3. **上下文管理**：Sub-Agents 有独立的上下文窗口（如 200K tokens），可以突破主 Agent 的上下文限制。函数调用共享主 Agent 的上下文，复杂任务会快速耗尽上下文空间。
>
> **在实际工作中的应用**：在 pi-mono 中，我们使用 Sub-Agents 实现任务分解。例如，重构认证系统时，Scout Agent 快速侦查代码（使用 Haiku 模型节省成本），Planner Agent 制定计划（使用 Sonnet 模型保证质量），Worker Agent 执行实现。每个 Agent 有独立的上下文，避免了上下文污染，同时可以根据任务复杂度选择不同的模型。

### 为什么这个回答出彩？
1. ✅ 多层次解释（隔离/能力/上下文）
2. ✅ 具体例子（崩溃影响、自主决策、上下文限制）
3. ✅ 实际应用（pi-mono 的使用场景）
4. ✅ 展示深度思考（成本优化、质量保证）

---

## 问题 2："Chain Mode 和 Parallel Mode 分别适合什么场景？"

### 普通回答（❌ 不出彩）
"Chain Mode 适合有依赖的任务，Parallel Mode 适合独立的任务。"

### 出彩回答（✅ 推荐）

> **选择 Chain 还是 Parallel 取决于三个因素：**
>
> 1. **任务依赖关系**：
>    - Chain Mode：后续任务需要前面任务的输出。例如：侦查代码 → 制定计划 → 执行实现。Planner 需要 Scout 的发现，Worker 需要 Planner 的计划。
>    - Parallel Mode：任务完全独立，无依赖关系。例如：同时分析前端、后端、数据库代码。
>
> 2. **性能权衡**：
>    - Parallel Mode 有启动开销（每个进程 ~1 秒）。对于短任务（< 5 秒），并行收益不明显。例如，3 个 2 秒的任务，Single 需要 6 秒，Parallel 需要 ~5 秒，只快 1 秒。
>    - 对于长任务（> 10 秒），并行收益显著。3 个 10 秒的任务，Single 需要 30 秒，Parallel 需要 ~12 秒，快 18 秒。
>
> 3. **错误处理策略**：
>    - Chain Mode：任何步骤失败，整个链停止。适合严格的工作流，如代码生成 → 测试 → 部署。
>    - Parallel Mode：部分失败不影响其他任务。适合信息收集，如分析多个模块，即使一个失败也能获得其他结果。
>
> **实际决策树**：
> ```
> 任务之间有依赖？
>   ├─ 是 → Chain Mode
>   └─ 否 → 任务执行时间 > 5 秒？
>       ├─ 是 → Parallel Mode
>       └─ 否 → Single Mode（逐个执行）
> ```
>
> **在实际工作中的应用**：在 pi-mono 中，我们使用 Chain Mode 实现 scout-and-plan 工作流（侦查 → 计划），使用 Parallel Mode 进行技术栈分析（前端 + 后端 + 数据库并行分析）。关键是评估任务依赖关系和执行时间，选择合适的模式。

### 为什么这个回答出彩？
1. ✅ 多维度分析（依赖/性能/错误处理）
2. ✅ 量化对比（具体时间数据）
3. ✅ 决策工具（决策树）
4. ✅ 实际应用（pi-mono 的使用场景）

---

## 问题 3："如何保证 Sub-Agents 的安全性？"

### 普通回答（❌ 不出彩）
"需要审查项目 agents，确保没有恶意代码。"

### 出彩回答（✅ 推荐）

> **Sub-Agents 的安全模型基于信任边界和最小权限原则：**
>
> 1. **信任边界**：
>    - 用户 Agents（`~/.pi/agent/agents/`）：完全信任，你自己创建的，始终加载。
>    - 项目 Agents（`.pi/agents/`）：需要审查，仓库控制的，默认需要确认。
>    - 这类似于 npm 包的 dependencies（信任）vs devDependencies（需要审查）。
>
> 2. **最小权限原则**：
>    - Scout Agent：只给只读工具（read, grep, find, ls），无法修改代码。
>    - Worker Agent：给完整工具集（write, edit, bash），但只在必要时使用。
>    - 这类似于 Unix 的文件权限系统，不同角色有不同权限。
>
> 3. **确认机制**：
>    - 使用项目 Agents 时，pi 显示确认对话框，列出 Agent 名称、来源路径、工具集。
>    - 用户可以审查 `.pi/agents/*.md` 的内容，检查系统提示和工具集。
>    - 只有用户明确同意后才执行。
>
> 4. **审查清单**：
>    - 系统提示是否合理？（检查是否有可疑指令）
>    - 工具集是否必要？（特别是 bash 工具）
>    - 是否访问敏感文件？（~/.ssh, ~/.aws, etc.）
>    - 是否发送数据到外部服务？（curl, wget 等）
>
> **在实际工作中的应用**：在 pi-mono 中，我们默认只使用用户 Agents（`agentScope: "user"`），这是最安全的。只有在完全信任的仓库中才启用项目 Agents（`agentScope: "both"`）。我们还建议通用 Agents 放在用户级别，项目特定的 Agents 放在项目级别，并在 README 中文档化项目 Agents 的用途。

### 为什么这个回答出彩？
1. ✅ 系统化思考（信任边界/权限/确认/审查）
2. ✅ 类比说明（npm 包、Unix 权限）
3. ✅ 具体清单（可操作的审查步骤）
4. ✅ 实际应用（pi-mono 的安全实践）

---

## 总结

面试中回答 Sub-Agents 相关问题的关键：

1. **多层次解释**：不只说"是什么"，还要说"为什么"和"怎么用"
2. **具体例子**：用实际场景和数据支撑观点
3. **系统化思考**：展示对架构和权衡的深入理解
4. **实际应用**：联系真实项目经验

**记住**：好的回答不是背诵定义，而是展示你对技术的深入理解和实践经验。
