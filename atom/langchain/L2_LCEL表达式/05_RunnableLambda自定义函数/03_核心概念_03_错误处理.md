# 03_æ ¸å¿ƒæ¦‚å¿µ_03_é”™è¯¯å¤„ç†

> **æœ¬æ–‡æ¡£æ·±å…¥è®²è§£ RunnableLambda çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œæ„å»ºç”Ÿäº§çº§çš„å¯é æ€§ä¿éšœã€‚**

---

## æ ¸å¿ƒé—®é¢˜

**å¦‚ä½•è®© RunnableLambda åœ¨ç”Ÿäº§ç¯å¢ƒä¸­å¯é è¿è¡Œï¼Ÿ**

è¿™æ˜¯ RunnableLambda ç”Ÿäº§åŒ–çš„å…³é”®é—®é¢˜ã€‚æœ¬æ–‡æ¡£å°†æ·±å…¥æ¢è®¨ï¼š
- é‡è¯•æœºåˆ¶çš„å®ç°
- å¼‚å¸¸æ•è·ä¸ä¼ æ’­
- é™çº§ç­–ç•¥è®¾è®¡
- é”™è¯¯å›è°ƒå’Œç›‘æ§
- ç”Ÿäº§çº§é”™è¯¯å¤„ç†æ¨¡å¼

---

## with_retry é‡è¯•æœºåˆ¶

### åŸºæœ¬ç”¨æ³•

**é—®é¢˜ï¼š** å¤–éƒ¨è°ƒç”¨å¯èƒ½å¤±è´¥ï¼Œå¦‚ä½•è‡ªåŠ¨é‡è¯•ï¼Ÿ

```python
from langchain_core.runnables import RunnableLambda
import requests

def call_api(query: str) -> dict:
    """è°ƒç”¨å¤–éƒ¨ APIï¼ˆå¯èƒ½å¤±è´¥ï¼‰"""
    response = requests.get(
        "https://api.example.com/search",
        params={"q": query},
        timeout=5
    )
    response.raise_for_status()  # å¯èƒ½æŠ›å‡ºå¼‚å¸¸
    return response.json()

# æ·»åŠ é‡è¯•æœºåˆ¶
runnable = RunnableLambda(call_api).with_retry(
    stop_after_attempt=3,  # æœ€å¤šé‡è¯• 3 æ¬¡
    wait_exponential_multiplier=1,  # æŒ‡æ•°é€€é¿
    wait_exponential_max=10  # æœ€å¤§ç­‰å¾… 10 ç§’
)

# è‡ªåŠ¨é‡è¯•
try:
    result = runnable.invoke("test query")
except Exception as e:
    print(f"Failed after 3 retries: {e}")
```

---

### with_retry çš„å‚æ•°

**å®Œæ•´å‚æ•°åˆ—è¡¨ï¼š**

```python
runnable.with_retry(
    # é‡è¯•æ¬¡æ•°æ§åˆ¶
    stop_after_attempt=3,  # æœ€å¤šå°è¯• 3 æ¬¡ï¼ˆåŒ…æ‹¬é¦–æ¬¡ï¼‰

    # ç­‰å¾…æ—¶é—´æ§åˆ¶
    wait_exponential_multiplier=1,  # æŒ‡æ•°é€€é¿çš„ä¹˜æ•°
    wait_exponential_max=10,  # æœ€å¤§ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰

    # é‡è¯•æ¡ä»¶
    retry_if_exception_type=(  # åªé‡è¯•ç‰¹å®šå¼‚å¸¸
        requests.exceptions.RequestException,
        TimeoutError
    ),

    # å›è°ƒå‡½æ•°
    before_sleep=lambda retry_state: print(f"Retry {retry_state.attempt_number}")
)
```

---

### æŒ‡æ•°é€€é¿ç­–ç•¥

**ä»€ä¹ˆæ˜¯æŒ‡æ•°é€€é¿ï¼š**

```
ç¬¬1æ¬¡å°è¯•ï¼šç«‹å³æ‰§è¡Œ
ç¬¬1æ¬¡å¤±è´¥ï¼šç­‰å¾… 1 ç§’
ç¬¬2æ¬¡å°è¯•ï¼šæ‰§è¡Œ
ç¬¬2æ¬¡å¤±è´¥ï¼šç­‰å¾… 2 ç§’
ç¬¬3æ¬¡å°è¯•ï¼šæ‰§è¡Œ
ç¬¬3æ¬¡å¤±è´¥ï¼šç­‰å¾… 4 ç§’
ç¬¬4æ¬¡å°è¯•ï¼šæ‰§è¡Œ
```

**ä¸ºä»€ä¹ˆä½¿ç”¨æŒ‡æ•°é€€é¿ï¼š**
1. **é¿å…é›ªå´©**ï¼šç»™æœåŠ¡æ¢å¤çš„æ—¶é—´
2. **å‡å°‘è´Ÿè½½**ï¼šä¸ä¼šæŒç»­é«˜é¢‘è¯·æ±‚
3. **æé«˜æˆåŠŸç‡**ï¼šä¸´æ—¶æ•…éšœæœ‰æ—¶é—´æ¢å¤

**å®ç°ç¤ºä¾‹ï¼š**

```python
from langchain_core.runnables import RunnableLambda
import time

def unstable_operation(x: int) -> int:
    """ä¸ç¨³å®šçš„æ“ä½œï¼ˆ70% å¤±è´¥ç‡ï¼‰"""
    import random
    if random.random() < 0.7:
        raise ValueError("Random failure")
    return x * 2

# é…ç½®æŒ‡æ•°é€€é¿
runnable = RunnableLambda(unstable_operation).with_retry(
    stop_after_attempt=5,
    wait_exponential_multiplier=1,
    wait_exponential_max=10
)

# æµ‹è¯•é‡è¯•
start = time.time()
try:
    result = runnable.invoke(5)
    print(f"Success: {result}")
except Exception as e:
    print(f"Failed: {e}")
finally:
    print(f"Total time: {time.time() - start:.2f}s")
```

---

### è‡ªå®šä¹‰é‡è¯•æ¡ä»¶

**åœºæ™¯ï¼š** åªé‡è¯•ç‰¹å®šç±»å‹çš„é”™è¯¯

```python
from langchain_core.runnables import RunnableLambda
import requests

def call_api(query: str) -> dict:
    """è°ƒç”¨ API"""
    response = requests.get(f"https://api.example.com/search?q={query}")

    # ä¸åŒçš„é”™è¯¯ç±»å‹
    if response.status_code == 429:
        raise requests.exceptions.TooManyRequests("Rate limit exceeded")
    elif response.status_code == 500:
        raise requests.exceptions.HTTPError("Server error")
    elif response.status_code == 404:
        raise requests.exceptions.HTTPError("Not found")

    return response.json()

# åªé‡è¯•ä¸´æ—¶é”™è¯¯ï¼ˆ429, 500ï¼‰ï¼Œä¸é‡è¯•æ°¸ä¹…é”™è¯¯ï¼ˆ404ï¼‰
runnable = RunnableLambda(call_api).with_retry(
    stop_after_attempt=3,
    retry_if_exception_type=(
        requests.exceptions.TooManyRequests,  # é‡è¯•é™æµ
        requests.exceptions.ConnectionError,  # é‡è¯•è¿æ¥é”™è¯¯
    )
)

# ä½¿ç”¨
try:
    result = runnable.invoke("test")
except requests.exceptions.HTTPError as e:
    # 404 ä¸ä¼šé‡è¯•ï¼Œç›´æ¥æŠ›å‡º
    print(f"Permanent error: {e}")
```

---

## å¼‚å¸¸æ•è·ä¸ä¼ æ’­

### å¼‚å¸¸çš„ä¼ æ’­è·¯å¾„

**åœ¨ LCEL é“¾ä¸­ï¼Œå¼‚å¸¸å¦‚ä½•ä¼ æ’­ï¼š**

```python
from langchain_core.runnables import RunnableLambda

def step1(x: int) -> int:
    print("Step 1")
    return x * 2

def step2(x: int) -> int:
    print("Step 2")
    if x > 10:
        raise ValueError("Value too large")
    return x + 1

def step3(x: int) -> int:
    print("Step 3")
    return x * 3

# ç»„åˆé“¾
chain = (
    RunnableLambda(step1)
    | RunnableLambda(step2)
    | RunnableLambda(step3)
)

# æµ‹è¯•å¼‚å¸¸ä¼ æ’­
try:
    result = chain.invoke(6)  # 6 * 2 = 12 > 10
except ValueError as e:
    print(f"Caught exception: {e}")

# è¾“å‡º:
# Step 1
# Step 2
# Caught exception: Value too large
# (Step 3 ä¸ä¼šæ‰§è¡Œ)
```

**ä¼ æ’­è·¯å¾„ï¼š**

```
invoke(6)
    â†“
step1(6) â†’ 12
    â†“
step2(12) â†’ ValueError("Value too large")
    â†“
å¼‚å¸¸å‘ä¸Šä¼ æ’­
    â†“
chain.invoke() æŠ›å‡ºå¼‚å¸¸
```

---

### æ•è·ç‰¹å®šæ­¥éª¤çš„å¼‚å¸¸

**åœºæ™¯ï¼š** åªæ•è·æŸä¸ªæ­¥éª¤çš„å¼‚å¸¸ï¼Œå…¶ä»–æ­¥éª¤æ­£å¸¸ä¼ æ’­

```python
from langchain_core.runnables import RunnableLambda

def risky_step(x: int) -> int:
    """å¯èƒ½å¤±è´¥çš„æ­¥éª¤"""
    if x < 0:
        raise ValueError("Negative value")
    return x * 2

def safe_wrapper(x: int) -> int:
    """å®‰å…¨åŒ…è£…å™¨"""
    try:
        return risky_step(x)
    except ValueError as e:
        print(f"Caught error: {e}, using default value")
        return 0  # è¿”å›é»˜è®¤å€¼

# ä½¿ç”¨å®‰å…¨åŒ…è£…å™¨
runnable = RunnableLambda(safe_wrapper)

# æµ‹è¯•
result = runnable.invoke(-5)  # 0ï¼ˆä½¿ç”¨é»˜è®¤å€¼ï¼‰
result = runnable.invoke(5)   # 10ï¼ˆæ­£å¸¸æ‰§è¡Œï¼‰
```

---

## é™çº§ç­–ç•¥è®¾è®¡

### with_fallbacks æ–¹æ³•

**é—®é¢˜ï¼š** ä¸»è¦æ–¹æ³•å¤±è´¥æ—¶ï¼Œå¦‚ä½•ä½¿ç”¨å¤‡ç”¨æ–¹æ³•ï¼Ÿ

```python
from langchain_core.runnables import RunnableLambda

def primary_method(query: str) -> str:
    """ä¸»è¦æ–¹æ³•ï¼ˆå¯èƒ½å¤±è´¥ï¼‰"""
    # è°ƒç”¨é«˜è´¨é‡ä½†ä¸ç¨³å®šçš„ API
    response = requests.get(f"https://premium-api.com/search?q={query}")
    response.raise_for_status()
    return response.json()["result"]

def fallback_method(query: str) -> str:
    """å¤‡ç”¨æ–¹æ³•ï¼ˆæ›´å¯é ï¼‰"""
    # è°ƒç”¨ä½è´¨é‡ä½†ç¨³å®šçš„ API
    response = requests.get(f"https://basic-api.com/search?q={query}")
    return response.json()["result"]

def last_resort(query: str) -> str:
    """æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆ"""
    return f"No results found for: {query}"

# é…ç½®é™çº§é“¾
runnable = RunnableLambda(primary_method).with_fallbacks([
    RunnableLambda(fallback_method),
    RunnableLambda(last_resort)
])

# ä½¿ç”¨
result = runnable.invoke("test query")
# å°è¯•é¡ºåºï¼šprimary_method â†’ fallback_method â†’ last_resort
```

---

### é™çº§ç­–ç•¥çš„æœ€ä½³å®è·µ

**æ¨¡å¼ 1ï¼šè´¨é‡é™çº§**

```python
# é«˜è´¨é‡ â†’ ä¸­è´¨é‡ â†’ ä½è´¨é‡
chain = (
    RunnableLambda(gpt4_process)  # æœ€å¥½ä½†å¯èƒ½å¤±è´¥
    .with_fallbacks([
        RunnableLambda(gpt35_process),  # ä¸­ç­‰è´¨é‡
        RunnableLambda(rule_based_process)  # æœ€å¯é ä½†è´¨é‡ä½
    ])
)
```

**æ¨¡å¼ 2ï¼šé€Ÿåº¦é™çº§**

```python
# å¿«é€Ÿ â†’ æ…¢é€Ÿ â†’ ç¼“å­˜
chain = (
    RunnableLambda(fast_api)  # å¿«ä½†å¯èƒ½é™æµ
    .with_fallbacks([
        RunnableLambda(slow_api),  # æ…¢ä½†ç¨³å®š
        RunnableLambda(cached_result)  # ä½¿ç”¨ç¼“å­˜
    ])
)
```

**æ¨¡å¼ 3ï¼šæ•°æ®æºé™çº§**

```python
# ä¸»æ•°æ®æº â†’ å¤‡ç”¨æ•°æ®æº â†’ é»˜è®¤å€¼
chain = (
    RunnableLambda(primary_db)  # ä¸»æ•°æ®åº“
    .with_fallbacks([
        RunnableLambda(replica_db),  # ä»åº“
        RunnableLambda(lambda x: {"default": True})  # é»˜è®¤å€¼
    ])
)
```

---

## config ä¸­çš„é”™è¯¯å›è°ƒ

### é…ç½®å›è°ƒå‡½æ•°

**åœºæ™¯ï¼š** ç›‘æ§å’Œè®°å½•é”™è¯¯

```python
from langchain_core.runnables import RunnableLambda
from langchain_core.callbacks import BaseCallbackHandler

class ErrorLoggingCallback(BaseCallbackHandler):
    """é”™è¯¯æ—¥å¿—å›è°ƒ"""

    def on_chain_error(self, error: Exception, **kwargs):
        """é“¾æ‰§è¡Œé”™è¯¯æ—¶è°ƒç”¨"""
        print(f"Chain error: {error}")
        # è®°å½•åˆ°æ—¥å¿—ç³»ç»Ÿ
        logger.error(f"Chain failed: {error}", exc_info=True)

    def on_tool_error(self, error: Exception, **kwargs):
        """å·¥å…·æ‰§è¡Œé”™è¯¯æ—¶è°ƒç”¨"""
        print(f"Tool error: {error}")

# ä½¿ç”¨å›è°ƒ
def risky_operation(x: int) -> int:
    if x < 0:
        raise ValueError("Negative value")
    return x * 2

runnable = RunnableLambda(risky_operation)

# é…ç½®å›è°ƒ
result = runnable.invoke(
    -5,
    config={"callbacks": [ErrorLoggingCallback()]}
)
```

---

### è‡ªå®šä¹‰é”™è¯¯å¤„ç†å›è°ƒ

**åœºæ™¯ï¼š** é”™è¯¯æ—¶å‘é€å‘Šè­¦

```python
from langchain_core.callbacks import BaseCallbackHandler
import requests

class AlertCallback(BaseCallbackHandler):
    """å‘Šè­¦å›è°ƒ"""

    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url

    def on_chain_error(self, error: Exception, **kwargs):
        """å‘é€å‘Šè­¦"""
        # å‘é€åˆ° Slack/é’‰é’‰/ä¼ä¸šå¾®ä¿¡
        requests.post(
            self.webhook_url,
            json={
                "text": f"ğŸš¨ Chain Error: {error}",
                "error_type": type(error).__name__,
                "timestamp": time.time()
            }
        )

# ä½¿ç”¨
alert_callback = AlertCallback("https://hooks.slack.com/...")
runnable = RunnableLambda(risky_operation)

result = runnable.invoke(
    -5,
    config={"callbacks": [alert_callback]}
)
```

---

## ç”Ÿäº§çº§é”™è¯¯å¤„ç†æ¨¡å¼

### æ¨¡å¼ 1ï¼šé‡è¯• + é™çº§

**æœ€å¸¸ç”¨çš„ç»„åˆï¼š**

```python
from langchain_core.runnables import RunnableLambda

def primary_api(query: str) -> dict:
    """ä¸» APIï¼ˆä¸ç¨³å®šï¼‰"""
    response = requests.get(f"https://api.example.com/search?q={query}")
    response.raise_for_status()
    return response.json()

def fallback_api(query: str) -> dict:
    """å¤‡ç”¨ APIï¼ˆç¨³å®šï¼‰"""
    response = requests.get(f"https://backup-api.com/search?q={query}")
    return response.json()

# ä¸» APIï¼šé‡è¯• 3 æ¬¡
primary = RunnableLambda(primary_api).with_retry(
    stop_after_attempt=3,
    wait_exponential_multiplier=1
)

# é™çº§é“¾ï¼šä¸» API â†’ å¤‡ç”¨ API
runnable = primary.with_fallbacks([
    RunnableLambda(fallback_api)
])

# ä½¿ç”¨
result = runnable.invoke("test query")
# æµç¨‹ï¼š
# 1. å°è¯• primary_apiï¼ˆæœ€å¤š 3 æ¬¡ï¼‰
# 2. å¦‚æœå¤±è´¥ï¼Œä½¿ç”¨ fallback_api
```

---

### æ¨¡å¼ 2ï¼šè¶…æ—¶ + é‡è¯•

**åœºæ™¯ï¼š** é˜²æ­¢é•¿æ—¶é—´é˜»å¡

```python
from langchain_core.runnables import RunnableLambda
import signal

class TimeoutError(Exception):
    pass

def timeout_handler(signum, frame):
    raise TimeoutError("Operation timed out")

def with_timeout(func, timeout_seconds=5):
    """æ·»åŠ è¶…æ—¶æ§åˆ¶"""
    def wrapper(*args, **kwargs):
        # è®¾ç½®è¶…æ—¶ä¿¡å·
        signal.signal(signal.SIGALRM, timeout_handler)
        signal.alarm(timeout_seconds)
        try:
            result = func(*args, **kwargs)
        finally:
            # å–æ¶ˆè¶…æ—¶ä¿¡å·
            signal.alarm(0)
        return result
    return wrapper

def slow_operation(x: int) -> int:
    """æ…¢æ“ä½œ"""
    time.sleep(10)  # æ¨¡æ‹Ÿæ…¢æ“ä½œ
    return x * 2

# æ·»åŠ è¶…æ—¶ + é‡è¯•
runnable = RunnableLambda(
    with_timeout(slow_operation, timeout_seconds=2)
).with_retry(
    stop_after_attempt=3,
    retry_if_exception_type=(TimeoutError,)
)

# ä½¿ç”¨
try:
    result = runnable.invoke(5)
except TimeoutError:
    print("Operation timed out after 3 retries")
```

---

### æ¨¡å¼ 3ï¼šæ–­è·¯å™¨æ¨¡å¼

**åœºæ™¯ï¼š** é˜²æ­¢çº§è”å¤±è´¥

```python
from langchain_core.runnables import RunnableLambda
import time

class CircuitBreaker:
    """æ–­è·¯å™¨"""

    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN

    def call(self, func, *args, **kwargs):
        """è°ƒç”¨å‡½æ•°ï¼ˆå¸¦æ–­è·¯å™¨ä¿æŠ¤ï¼‰"""
        # æ£€æŸ¥æ–­è·¯å™¨çŠ¶æ€
        if self.state == "OPEN":
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "HALF_OPEN"
            else:
                raise Exception("Circuit breaker is OPEN")

        try:
            result = func(*args, **kwargs)
            # æˆåŠŸï¼šé‡ç½®è®¡æ•°
            if self.state == "HALF_OPEN":
                self.state = "CLOSED"
            self.failure_count = 0
            return result
        except Exception as e:
            # å¤±è´¥ï¼šå¢åŠ è®¡æ•°
            self.failure_count += 1
            self.last_failure_time = time.time()

            if self.failure_count >= self.failure_threshold:
                self.state = "OPEN"

            raise e

# ä½¿ç”¨æ–­è·¯å™¨
breaker = CircuitBreaker(failure_threshold=5, timeout=60)

def unstable_api(query: str) -> dict:
    """ä¸ç¨³å®šçš„ API"""
    response = requests.get(f"https://api.example.com/search?q={query}")
    response.raise_for_status()
    return response.json()

def protected_api(query: str) -> dict:
    """å—ä¿æŠ¤çš„ API"""
    return breaker.call(unstable_api, query)

runnable = RunnableLambda(protected_api)

# ä½¿ç”¨
try:
    result = runnable.invoke("test")
except Exception as e:
    print(f"Error: {e}")
```

---

## ä¸ RunnableParallel çš„é”™è¯¯éš”ç¦»

### å¹¶è¡Œæ‰§è¡Œä¸­çš„é”™è¯¯å¤„ç†

**é—®é¢˜ï¼š** å¹¶è¡Œæ‰§è¡Œæ—¶ï¼Œä¸€ä¸ªå¤±è´¥æ˜¯å¦å½±å“å…¶ä»–ï¼Ÿ

```python
from langchain_core.runnables import RunnableLambda, RunnableParallel

def task1(x: int) -> int:
    """ä»»åŠ¡ 1ï¼ˆæ­£å¸¸ï¼‰"""
    return x * 2

def task2(x: int) -> int:
    """ä»»åŠ¡ 2ï¼ˆå¤±è´¥ï¼‰"""
    raise ValueError("Task 2 failed")

def task3(x: int) -> int:
    """ä»»åŠ¡ 3ï¼ˆæ­£å¸¸ï¼‰"""
    return x + 1

# å¹¶è¡Œæ‰§è¡Œ
parallel = RunnableParallel(
    result1=RunnableLambda(task1),
    result2=RunnableLambda(task2),
    result3=RunnableLambda(task3)
)

# æµ‹è¯•
try:
    result = parallel.invoke(5)
except ValueError as e:
    print(f"Error: {e}")
    # æ‰€æœ‰ä»»åŠ¡éƒ½ä¼šè¢«å–æ¶ˆ
```

**é»˜è®¤è¡Œä¸ºï¼š** ä¸€ä¸ªå¤±è´¥ï¼Œå…¨éƒ¨å¤±è´¥

---

### é”™è¯¯éš”ç¦»ç­–ç•¥

**ç­–ç•¥ 1ï¼šæ•è·å¼‚å¸¸ï¼Œè¿”å›é»˜è®¤å€¼**

```python
def safe_task(func):
    """å®‰å…¨åŒ…è£…å™¨"""
    def wrapper(x):
        try:
            return func(x)
        except Exception as e:
            return {"error": str(e)}
    return wrapper

# ä½¿ç”¨å®‰å…¨åŒ…è£…å™¨
parallel = RunnableParallel(
    result1=RunnableLambda(safe_task(task1)),
    result2=RunnableLambda(safe_task(task2)),
    result3=RunnableLambda(safe_task(task3))
)

# æµ‹è¯•
result = parallel.invoke(5)
print(result)
# {
#     "result1": 10,
#     "result2": {"error": "Task 2 failed"},
#     "result3": 6
# }
```

**ç­–ç•¥ 2ï¼šä½¿ç”¨é™çº§**

```python
def task2_fallback(x: int) -> int:
    """ä»»åŠ¡ 2 çš„å¤‡ç”¨æ–¹æ¡ˆ"""
    return 0

# ä¸ºæ¯ä¸ªä»»åŠ¡é…ç½®é™çº§
parallel = RunnableParallel(
    result1=RunnableLambda(task1),
    result2=RunnableLambda(task2).with_fallbacks([
        RunnableLambda(task2_fallback)
    ]),
    result3=RunnableLambda(task3)
)

# æµ‹è¯•
result = parallel.invoke(5)
print(result)
# {
#     "result1": 10,
#     "result2": 0,  # ä½¿ç”¨é™çº§å€¼
#     "result3": 6
# }
```

---

## å®Œæ•´çš„ç”Ÿäº§çº§ç¤ºä¾‹

### RAG åº”ç”¨çš„é”™è¯¯å¤„ç†

```python
from langchain_core.runnables import RunnableLambda, RunnableParallel
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
import logging

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 1. æ–‡æ¡£æ£€ç´¢ï¼ˆå¯èƒ½å¤±è´¥ï¼‰
def retrieve_docs(query: str) -> list[str]:
    """æ£€ç´¢æ–‡æ¡£"""
    try:
        # è°ƒç”¨å‘é‡æ•°æ®åº“
        docs = vector_store.similarity_search(query, k=5)
        return [doc.page_content for doc in docs]
    except Exception as e:
        logger.error(f"Retrieval failed: {e}")
        raise

# 2. æ–‡æ¡£é‡æ’åºï¼ˆå¯é€‰ï¼Œå¯èƒ½å¤±è´¥ï¼‰
def rerank_docs(docs: list[str]) -> list[str]:
    """é‡æ’åºæ–‡æ¡£"""
    try:
        # è°ƒç”¨é‡æ’åº API
        response = requests.post(
            "https://api.rerank.com/rerank",
            json={"docs": docs}
        )
        return response.json()["ranked_docs"]
    except Exception as e:
        logger.warning(f"Rerank failed, using original order: {e}")
        return docs  # é™çº§ï¼šä½¿ç”¨åŸå§‹é¡ºåº

# 3. ç”Ÿæˆç­”æ¡ˆï¼ˆå…³é”®æ­¥éª¤ï¼‰
def generate_answer(context: dict) -> str:
    """ç”Ÿæˆç­”æ¡ˆ"""
    docs = context["docs"]
    query = context["query"]

    prompt = ChatPromptTemplate.from_template(
        "Based on these documents:\n{docs}\n\nAnswer: {query}"
    )
    model = ChatOpenAI(model="gpt-4")

    chain = prompt | model
    result = chain.invoke({"docs": "\n".join(docs), "query": query})
    return result.content

# æ„å»ºå®Œæ•´é“¾
rag_chain = (
    # æ­¥éª¤ 1: æ£€ç´¢ï¼ˆé‡è¯• 3 æ¬¡ï¼‰
    RunnableLambda(retrieve_docs).with_retry(
        stop_after_attempt=3,
        wait_exponential_multiplier=1
    )
    # æ­¥éª¤ 2: é‡æ’åºï¼ˆæœ‰é™çº§ï¼‰
    | RunnableLambda(rerank_docs)
    # æ­¥éª¤ 3: ç»„åˆä¸Šä¸‹æ–‡
    | RunnableLambda(lambda docs: {"docs": docs, "query": query})
    # æ­¥éª¤ 4: ç”Ÿæˆç­”æ¡ˆï¼ˆé‡è¯• 2 æ¬¡ï¼‰
    | RunnableLambda(generate_answer).with_retry(
        stop_after_attempt=2
    )
)

# ä½¿ç”¨
try:
    query = "What is LangChain?"
    answer = rag_chain.invoke(query)
    print(f"Answer: {answer}")
except Exception as e:
    logger.error(f"RAG chain failed: {e}")
    # è¿”å›é»˜è®¤ç­”æ¡ˆ
    answer = "Sorry, I couldn't find an answer to your question."
```

---

## é”™è¯¯å¤„ç†æ£€æŸ¥æ¸…å•

### è®¾è®¡é˜¶æ®µ

- [ ] è¯†åˆ«å¯èƒ½å¤±è´¥çš„æ­¥éª¤
- [ ] ç¡®å®šå“ªäº›é”™è¯¯éœ€è¦é‡è¯•
- [ ] è®¾è®¡é™çº§ç­–ç•¥
- [ ] è§„åˆ’é”™è¯¯ç›‘æ§å’Œå‘Šè­¦

### å®ç°é˜¶æ®µ

- [ ] ä¸ºä¸ç¨³å®šçš„æ“ä½œæ·»åŠ é‡è¯•
- [ ] ä¸ºå…³é”®æ­¥éª¤æ·»åŠ é™çº§
- [ ] é…ç½®åˆé€‚çš„è¶…æ—¶æ—¶é—´
- [ ] æ·»åŠ é”™è¯¯æ—¥å¿—å’Œå›è°ƒ

### æµ‹è¯•é˜¶æ®µ

- [ ] æµ‹è¯•é‡è¯•æœºåˆ¶æ˜¯å¦ç”Ÿæ•ˆ
- [ ] æµ‹è¯•é™çº§ç­–ç•¥æ˜¯å¦æ­£ç¡®
- [ ] æµ‹è¯•é”™è¯¯ä¼ æ’­æ˜¯å¦ç¬¦åˆé¢„æœŸ
- [ ] æµ‹è¯•å¹¶å‘åœºæ™¯çš„é”™è¯¯éš”ç¦»

### ç›‘æ§é˜¶æ®µ

- [ ] ç›‘æ§é”™è¯¯ç‡å’Œé‡è¯•ç‡
- [ ] ç›‘æ§é™çº§ä½¿ç”¨é¢‘ç‡
- [ ] è®¾ç½®å‘Šè­¦é˜ˆå€¼
- [ ] å®šæœŸreviewé”™è¯¯æ—¥å¿—

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **é‡è¯•æœºåˆ¶**
   - ä½¿ç”¨ with_retry æ·»åŠ è‡ªåŠ¨é‡è¯•
   - é…ç½®æŒ‡æ•°é€€é¿ç­–ç•¥
   - åªé‡è¯•ä¸´æ—¶é”™è¯¯

2. **é™çº§ç­–ç•¥**
   - ä½¿ç”¨ with_fallbacks æ·»åŠ å¤‡ç”¨æ–¹æ¡ˆ
   - è®¾è®¡å¤šå±‚é™çº§ï¼ˆè´¨é‡/é€Ÿåº¦/æ•°æ®æºï¼‰
   - ç¡®ä¿æœ€åæœ‰å…œåº•æ–¹æ¡ˆ

3. **é”™è¯¯ç›‘æ§**
   - ä½¿ç”¨å›è°ƒè®°å½•é”™è¯¯
   - é…ç½®å‘Šè­¦é€šçŸ¥
   - å®šæœŸåˆ†æé”™è¯¯æ¨¡å¼

4. **é”™è¯¯éš”ç¦»**
   - å¹¶è¡Œæ‰§è¡Œæ—¶ä½¿ç”¨å®‰å…¨åŒ…è£…å™¨
   - ä¸ºæ¯ä¸ªä»»åŠ¡é…ç½®ç‹¬ç«‹çš„é™çº§
   - é¿å…çº§è”å¤±è´¥

---

## å¼•ç”¨æ¥æº

- [LangChain Error Handling Guide](https://python.langchain.com/docs/guides/development/error_handling) - å®˜æ–¹é”™è¯¯å¤„ç†æŒ‡å—
- [tenacity Documentation](https://tenacity.readthedocs.io/) - é‡è¯•åº“æ–‡æ¡£
- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html) - æ–­è·¯å™¨æ¨¡å¼
- [Building Resilient Systems](https://aws.amazon.com/builders-library/building-resilient-systems/) - AWS å¼¹æ€§ç³»ç»Ÿè®¾è®¡
- [Production-Ready AI Pipelines (2026)](https://medium.com/@techsachin/building-production-ready-ai-pipelines-with-langchain-a-comprehensive-guide-2026-edition) - ç”Ÿäº§çº§å®è·µ

---

**ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2026-02-20
**é€‚ç”¨äº**: LangChain v0.3+
**Python ç‰ˆæœ¬**: 3.13+
