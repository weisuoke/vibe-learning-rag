# 核心概念1：迭代器协议

> 理解 Python 迭代的底层机制：`__iter__` 和 `__next__`

---

## 什么是迭代器协议？

**迭代器协议**是 Python 定义的一套规则，任何实现了这套规则的对象都可以被 `for` 循环遍历。

**协议包含两个方法：**
1. `__iter__()`：返回迭代器对象本身
2. `__next__()`：返回下一个值，结束时抛出 `StopIteration`

---

## 一句话定义

**迭代器协议是 Python 对象实现"可遍历"能力的标准接口，通过 `__iter__` 和 `__next__` 两个魔法方法定义遍历行为。**

---

## 迭代器协议的完整实现

### 最简单的迭代器

```python
class SimpleIterator:
    """最简单的迭代器：计数器"""

    def __init__(self, max_count):
        self.max_count = max_count
        self.current = 0

    def __iter__(self):
        """返回迭代器对象（自己）"""
        return self

    def __next__(self):
        """返回下一个值"""
        if self.current >= self.max_count:
            raise StopIteration  # 结束信号
        self.current += 1
        return self.current

# 使用
iterator = SimpleIterator(5)
for num in iterator:
    print(num)  # 1, 2, 3, 4, 5
```

**关键点：**
- `__iter__` 返回 `self`（迭代器对象本身）
- `__next__` 返回下一个值，并更新内部状态
- 结束时抛出 `StopIteration` 异常

---

## for 循环的本质

**`for` 循环是迭代器协议的语法糖**

```python
# 这段代码：
for item in iterable:
    print(item)

# 等价于：
iterator = iter(iterable)  # 调用 __iter__()
while True:
    try:
        item = next(iterator)  # 调用 __next__()
        print(item)
    except StopIteration:
        break  # 捕获 StopIteration，结束循环
```

**演示：**

```python
# 手动实现 for 循环
class Counter:
    def __init__(self, max_count):
        self.max_count = max_count
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.max_count:
            raise StopIteration
        self.current += 1
        return self.current

# 方式1：使用 for 循环（语法糖）
print("使用 for 循环:")
for num in Counter(3):
    print(num)

# 方式2：手动调用迭代器协议（等价）
print("\n手动调用:")
counter = Counter(3)
iterator = iter(counter)  # 调用 __iter__()
while True:
    try:
        num = next(iterator)  # 调用 __next__()
        print(num)
    except StopIteration:
        break
```

---

## 可迭代对象 vs 迭代器

### 概念区分

**可迭代对象（Iterable）：**
- 实现了 `__iter__` 方法
- 可以被 `for` 循环遍历
- 可以多次遍历

**迭代器（Iterator）：**
- 实现了 `__iter__` 和 `__next__` 方法
- 可以被 `for` 循环遍历
- 只能遍历一次（一次性的）

### 代码示例

```python
# 可迭代对象：列表
my_list = [1, 2, 3]

# 列表是可迭代对象，但不是迭代器
print(hasattr(my_list, '__iter__'))  # True
print(hasattr(my_list, '__next__'))  # False

# 可以多次遍历
for item in my_list:
    print(item)
for item in my_list:
    print(item)  # 仍然有效

# 获取迭代器
iterator = iter(my_list)  # 调用 __iter__()

# 迭代器既有 __iter__ 也有 __next__
print(hasattr(iterator, '__iter__'))  # True
print(hasattr(iterator, '__next__'))  # True

# 迭代器只能遍历一次
for item in iterator:
    print(item)
for item in iterator:
    print(item)  # 什么都不输出，迭代器已耗尽
```

### 关系图

```
可迭代对象（Iterable）
    ├─ 列表 [1, 2, 3]
    ├─ 元组 (1, 2, 3)
    ├─ 字符串 "abc"
    ├─ 字典 {"a": 1}
    └─ 自定义可迭代对象
         ↓ iter()
    迭代器（Iterator）
         ├─ list_iterator
         ├─ tuple_iterator
         ├─ str_iterator
         └─ 自定义迭代器
```

---

## 自定义可迭代对象

### 分离可迭代对象和迭代器

**最佳实践：** 可迭代对象和迭代器分开实现

```python
class MyList:
    """可迭代对象：自定义列表"""

    def __init__(self, data):
        self.data = data

    def __iter__(self):
        """返回一个新的迭代器"""
        return MyListIterator(self.data)

class MyListIterator:
    """迭代器：负责遍历"""

    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        """迭代器的 __iter__ 返回自己"""
        return self

    def __next__(self):
        """返回下一个值"""
        if self.index >= len(self.data):
            raise StopIteration
        value = self.data[self.index]
        self.index += 1
        return value

# 使用
my_list = MyList([1, 2, 3])

# 可以多次遍历（每次创建新的迭代器）
for item in my_list:
    print(item)  # 1, 2, 3

for item in my_list:
    print(item)  # 1, 2, 3（仍然有效）
```

**为什么要分离？**
- 可迭代对象可以多次遍历
- 每次遍历创建新的迭代器
- 迭代器之间互不影响

### 对比：不分离的实现

```python
class BadIterator:
    """不推荐：可迭代对象和迭代器合二为一"""

    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self  # 返回自己

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        value = self.data[self.index]
        self.index += 1
        return value

# 使用
bad_iter = BadIterator([1, 2, 3])

# 第一次遍历：正常
for item in bad_iter:
    print(item)  # 1, 2, 3

# 第二次遍历：什么都没有！
for item in bad_iter:
    print(item)  # 什么都不输出（index 已经到末尾）
```

---

## 迭代器的内部状态

### 状态管理

迭代器必须记住当前位置（状态）

```python
class RangeIterator:
    """自定义 range 迭代器"""

    def __init__(self, start, stop, step=1):
        self.current = start  # 状态：当前值
        self.stop = stop
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.stop:
            raise StopIteration
        value = self.current
        self.current += self.step  # 更新状态
        return value

# 使用
for num in RangeIterator(0, 10, 2):
    print(num)  # 0, 2, 4, 6, 8
```

### 状态可视化

```python
class DebugIterator:
    """可视化迭代器状态"""

    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        print(f"__iter__ 被调用，返回迭代器")
        return self

    def __next__(self):
        print(f"__next__ 被调用，当前 index={self.index}")
        if self.index >= len(self.data):
            print("到达末尾，抛出 StopIteration")
            raise StopIteration
        value = self.data[self.index]
        self.index += 1
        print(f"返回值: {value}")
        return value

# 使用
print("开始遍历:")
for item in DebugIterator([1, 2, 3]):
    print(f"得到: {item}\n")
```

**输出：**
```
开始遍历:
__iter__ 被调用，返回迭代器
__next__ 被调用，当前 index=0
返回值: 1
得到: 1

__next__ 被调用，当前 index=1
返回值: 2
得到: 2

__next__ 被调用，当前 index=2
返回值: 3
得到: 3

__next__ 被调用，当前 index=3
到达末尾，抛出 StopIteration
```

---

## 实际应用场景

### 场景1：自定义范围迭代器

```python
class FloatRange:
    """支持浮点数的 range"""

    def __init__(self, start, stop, step=1.0):
        self.start = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        current = self.start
        while current < self.stop:
            yield current
            current += self.step

# 使用
for num in FloatRange(0, 1, 0.1):
    print(f"{num:.1f}")  # 0.0, 0.1, 0.2, ..., 0.9
```

### 场景2：文件行迭代器

```python
class FileLineIterator:
    """逐行读取文件的迭代器"""

    def __init__(self, filename):
        self.filename = filename
        self.file = None

    def __iter__(self):
        self.file = open(self.filename, 'r', encoding='utf-8')
        return self

    def __next__(self):
        line = self.file.readline()
        if not line:
            self.file.close()
            raise StopIteration
        return line.strip()

# 使用
for line in FileLineIterator('data.txt'):
    print(line)
```

### 场景3：斐波那契数列迭代器

```python
class Fibonacci:
    """斐波那契数列迭代器"""

    def __init__(self, max_count):
        self.max_count = max_count
        self.count = 0
        self.a, self.b = 0, 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.count >= self.max_count:
            raise StopIteration
        self.count += 1
        value = self.a
        self.a, self.b = self.b, self.a + self.b
        return value

# 使用
for num in Fibonacci(10):
    print(num)  # 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

### 场景4：批量数据迭代器

```python
class BatchIterator:
    """将数据分批返回的迭代器"""

    def __init__(self, data, batch_size):
        self.data = data
        self.batch_size = batch_size
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration

        batch = self.data[self.index:self.index + self.batch_size]
        self.index += self.batch_size
        return batch

# 使用：处理大数据集
data = list(range(100))
for batch in BatchIterator(data, batch_size=10):
    print(f"处理批次: {batch[:3]}... (共 {len(batch)} 项)")
```

---

## 在 AI Agent 开发中的应用

### 应用1：流式数据处理

```python
class StreamProcessor:
    """流式处理数据的迭代器"""

    def __init__(self, data_source):
        self.data_source = data_source

    def __iter__(self):
        return self

    def __next__(self):
        # 从数据源获取下一条数据
        data = self.data_source.get_next()
        if data is None:
            raise StopIteration

        # 处理数据
        processed = self.process(data)
        return processed

    def process(self, data):
        """数据处理逻辑"""
        return data.upper()

# 在 FastAPI 中使用
from fastapi import FastAPI
from fastapi.responses import StreamingResponse

app = FastAPI()

@app.get("/stream")
async def stream_data():
    """流式返回处理后的数据"""
    processor = StreamProcessor(data_source)
    return StreamingResponse(
        processor,
        media_type="text/plain"
    )
```

### 应用2：数据库结果集迭代器

```python
class DatabaseResultIterator:
    """数据库结果集迭代器（避免一次性加载全部）"""

    def __init__(self, cursor):
        self.cursor = cursor

    def __iter__(self):
        return self

    def __next__(self):
        row = self.cursor.fetchone()
        if row is None:
            raise StopIteration
        return row

# 使用
import sqlite3

conn = sqlite3.connect('database.db')
cursor = conn.execute('SELECT * FROM large_table')

# 逐行处理，不占用大量内存
for row in DatabaseResultIterator(cursor):
    process_row(row)

conn.close()
```

---

## 内置迭代器示例

### Python 内置的迭代器

```python
# 1. 列表迭代器
lst = [1, 2, 3]
lst_iter = iter(lst)
print(type(lst_iter))  # <class 'list_iterator'>
print(next(lst_iter))  # 1

# 2. 字符串迭代器
s = "abc"
s_iter = iter(s)
print(type(s_iter))  # <class 'str_iterator'>
print(next(s_iter))  # 'a'

# 3. 字典迭代器
d = {"a": 1, "b": 2}
d_iter = iter(d)
print(type(d_iter))  # <class 'dict_keyiterator'>
print(next(d_iter))  # 'a'

# 4. 文件迭代器
with open('file.txt') as f:
    print(type(f))  # <class '_io.TextIOWrapper'>
    print(next(f))  # 第一行
```

---

## 迭代器协议的优势

### 优势1：统一接口

所有可遍历对象都遵循相同的协议

```python
# 统一的遍历方式
for item in [1, 2, 3]:  # 列表
    print(item)

for char in "abc":  # 字符串
    print(char)

for key in {"a": 1}:  # 字典
    print(key)

for line in open('file.txt'):  # 文件
    print(line)
```

### 优势2：惰性求值

不需要一次性加载全部数据

```python
# 处理大文件：内存高效
for line in open('10GB_file.log'):
    if 'ERROR' in line:
        print(line)
# 内存占用：只有当前行的大小
```

### 优势3：无限序列

可以表示无限长的序列

```python
class InfiniteCounter:
    """无限计数器"""

    def __init__(self):
        self.count = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.count += 1
        return self.count

# 使用：可以无限生成
counter = InfiniteCounter()
for num in counter:
    print(num)
    if num >= 10:
        break  # 手动停止
```

---

## 常见陷阱

### 陷阱1：忘记抛出 StopIteration

```python
# ❌ 错误：没有抛出 StopIteration
class BadIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            return None  # 错误：应该抛出 StopIteration
        value = self.data[self.index]
        self.index += 1
        return value

# 使用：会无限循环！
for item in BadIterator([1, 2, 3]):
    print(item)  # 1, 2, 3, None, None, None, ...（无限循环）
```

### 陷阱2：__iter__ 不返回迭代器

```python
# ❌ 错误：__iter__ 返回了错误的对象
class BadIterable:
    def __init__(self, data):
        self.data = data

    def __iter__(self):
        return self.data  # 错误：应该返回迭代器

# 使用：会报错
for item in BadIterable([1, 2, 3]):
    print(item)  # TypeError: iter() returned non-iterator
```

### 陷阱3：迭代器状态未重置

```python
# ❌ 错误：迭代器状态未重置，无法多次遍历
class BadIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        # 错误：没有重置 index
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        value = self.data[self.index]
        self.index += 1
        return value

# 使用
bad_iter = BadIterator([1, 2, 3])
list(bad_iter)  # [1, 2, 3]
list(bad_iter)  # []（第二次为空）
```

---

## 总结

### 核心要点

1. **迭代器协议 = `__iter__` + `__next__`**
2. **`__iter__` 返回迭代器对象**
3. **`__next__` 返回下一个值，结束时抛出 `StopIteration`**
4. **`for` 循环是迭代器协议的语法糖**
5. **可迭代对象 ≠ 迭代器**
6. **迭代器是一次性的**

### 最佳实践

- ✅ 分离可迭代对象和迭代器
- ✅ `__iter__` 返回新的迭代器实例
- ✅ `__next__` 结束时抛出 `StopIteration`
- ✅ 迭代器的 `__iter__` 返回 `self`
- ❌ 不要在 `__next__` 中返回 `None` 表示结束
- ❌ 不要让可迭代对象和迭代器合二为一（除非有特殊需求）

---

**版本：** v1.0
**最后更新：** 2026-02-11
