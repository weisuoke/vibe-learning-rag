# 核心概念2：相似度搜索

## 什么是相似度搜索？

**相似度搜索是根据向量之间的距离，找到与查询向量最相似的 Top-K 个向量的过程。**

在 RAG 系统中，相似度搜索是核心功能：用户提问 → 转换为查询向量 → 找到最相似的文档向量 → 返回相关文档。

## 三种距离函数

pgvector 支持三种距离计算方法，每种适用于不同的场景。

### 1. 余弦距离（Cosine Distance）

**定义：** 1 - 余弦相似度

**数学公式：**
```
余弦相似度 = (A · B) / (||A|| × ||B||)
余弦距离 = 1 - 余弦相似度
```

**特点：**
- 只关心向量的方向，不关心长度
- 适用于已归一化的向量（如文本 Embedding）
- 值域：[0, 2]，0 表示完全相同，2 表示完全相反

**SQL 操作符：** `<=>`

```sql
-- 查询最相似的 10 个文档
SELECT
    id,
    content,
    embedding <=> '[0.1, 0.2, ...]' AS distance
FROM documents
ORDER BY distance
LIMIT 10;
```

**Python 示例：**
```python
from openai import OpenAI
import psycopg2

client = OpenAI()
conn = psycopg2.connect("postgresql://localhost/mydb")
cursor = conn.cursor()

# 1. 生成查询向量
query = "什么是向量数据库？"
query_embedding = client.embeddings.create(
    input=query,
    model="text-embedding-3-small"
).data[0].embedding

# 2. 余弦距离检索
cursor.execute(
    """
    SELECT
        id,
        content,
        embedding <=> %s AS distance,
        1 - (embedding <=> %s) AS similarity
    FROM documents
    ORDER BY distance
    LIMIT 10
    """,
    (query_embedding, query_embedding)
)

results = cursor.fetchall()
for doc_id, content, distance, similarity in results:
    print(f"ID: {doc_id}")
    print(f"内容: {content}")
    print(f"距离: {distance:.4f}")
    print(f"相似度: {similarity:.4f}")
    print("-" * 50)
```

**适用场景：**
- ✅ 文本 Embedding（OpenAI、Sentence-Transformers）
- ✅ 已归一化的向量
- ✅ 关注语义方向，不关注向量长度

### 2. 欧氏距离（Euclidean Distance / L2 Distance）

**定义：** 向量之间的直线距离

**数学公式：**
```
欧氏距离 = sqrt(Σ(A[i] - B[i])²)
```

**特点：**
- 同时关心向量的方向和长度
- 适用于未归一化的向量
- 值域：[0, +∞)，0 表示完全相同

**SQL 操作符：** `<->`

```sql
-- 使用欧氏距离检索
SELECT
    id,
    content,
    embedding <-> '[0.1, 0.2, ...]' AS distance
FROM documents
ORDER BY distance
LIMIT 10;
```

**Python 示例：**
```python
# 欧氏距离检索
cursor.execute(
    """
    SELECT
        id,
        content,
        embedding <-> %s AS distance
    FROM documents
    ORDER BY distance
    LIMIT 10
    """,
    (query_embedding,)
)

results = cursor.fetchall()
for doc_id, content, distance in results:
    print(f"ID: {doc_id}, 距离: {distance:.4f}")
```

**适用场景：**
- ✅ 图像 Embedding（未归一化）
- ✅ 音频 Embedding
- ✅ 需要考虑向量长度的场景

### 3. 内积距离（Inner Product Distance）

**定义：** 负内积（-A · B）

**数学公式：**
```
内积 = Σ(A[i] × B[i])
内积距离 = -内积
```

**特点：**
- 值越小表示越相似（因为是负内积）
- 适用于某些特殊的 Embedding 模型
- 值域：(-∞, +∞)

**SQL 操作符：** `<#>`

```sql
-- 使用内积距离检索
SELECT
    id,
    content,
    embedding <#> '[0.1, 0.2, ...]' AS distance
FROM documents
ORDER BY distance
LIMIT 10;
```

**适用场景：**
- ✅ 某些推荐系统（用户-物品向量）
- ✅ 特定的 Embedding 模型（如 BERT 的某些变体）

### 距离函数对比

| 距离函数 | 操作符 | 适用场景 | 值域 | 是否归一化 |
|---------|--------|---------|------|-----------|
| 余弦距离 | `<=>` | 文本 Embedding | [0, 2] | 是 |
| 欧氏距离 | `<->` | 图像/音频 Embedding | [0, +∞) | 否 |
| 内积距离 | `<#>` | 推荐系统 | (-∞, +∞) | 否 |

**推荐：**
- **文本检索（RAG 系统）**：使用余弦距离 `<=>`
- **图像检索**：使用欧氏距离 `<->`
- **推荐系统**：根据模型选择内积距离 `<#>` 或余弦距离 `<=>`

## Top-K 检索

### 基本用法

```python
# Top-K 检索（K=10）
cursor.execute(
    """
    SELECT
        id,
        content,
        embedding <=> %s AS distance
    FROM documents
    ORDER BY distance
    LIMIT 10  -- Top-10
    """,
    (query_embedding,)
)
```

### 动态 K 值

```python
def search_documents(query: str, top_k: int = 5):
    """动态 Top-K 检索"""
    # 生成查询向量
    query_embedding = client.embeddings.create(
        input=query,
        model="text-embedding-3-small"
    ).data[0].embedding

    # 检索
    cursor.execute(
        """
        SELECT id, content, embedding <=> %s AS distance
        FROM documents
        ORDER BY distance
        LIMIT %s
        """,
        (query_embedding, top_k)
    )

    return cursor.fetchall()

# 使用
results = search_documents("什么是向量数据库？", top_k=5)
```

### 距离阈值过滤

```python
# 只返回距离小于阈值的结果
cursor.execute(
    """
    SELECT id, content, embedding <=> %s AS distance
    FROM documents
    WHERE embedding <=> %s < 0.5  -- 距离阈值
    ORDER BY distance
    LIMIT 10
    """,
    (query_embedding, query_embedding)
)
```

## 过滤条件的组合

### 1. 预过滤（Filter-then-Search）

**适用场景：** 过滤条件选择性高（如 `user_id = 123`）

```python
# 先过滤，再向量检索
cursor.execute(
    """
    SELECT id, content, embedding <=> %s AS distance
    FROM documents
    WHERE user_id = %s  -- 预过滤
    ORDER BY distance
    LIMIT 10
    """,
    (query_embedding, 123)
)
```

**优势：**
- 减少向量检索的搜索空间
- 适合高选择性过滤（如用户 ID、文档 ID）

### 2. 后过滤（Search-then-Filter）

**适用场景：** 过滤条件选择性低（如 `created_at > '2024-01-01'`）

```python
# 先向量检索，再过滤
cursor.execute(
    """
    SELECT id, content, embedding <=> %s AS distance
    FROM documents
    WHERE created_at > %s  -- 后过滤
    ORDER BY distance
    LIMIT 10
    """,
    (query_embedding, '2024-01-01')
)
```

**优势：**
- 向量索引可以充分利用
- 适合低选择性过滤（如时间范围、分类）

### 3. 复杂过滤

```python
# 多条件过滤 + 向量检索
cursor.execute(
    """
    SELECT
        d.id,
        d.content,
        d.embedding <=> %s AS distance,
        u.username,
        c.name AS category
    FROM documents d
    JOIN users u ON d.user_id = u.id
    JOIN categories c ON d.category_id = c.id
    WHERE
        d.created_at > %s
        AND u.is_active = true
        AND c.name IN ('tech', 'ai')
    ORDER BY distance
    LIMIT 10
    """,
    (query_embedding, '2024-01-01')
)
```

### 4. 元数据过滤（JSONB）

```python
# 使用 JSONB 元数据过滤
cursor.execute(
    """
    SELECT id, content, embedding <=> %s AS distance
    FROM documents
    WHERE
        metadata->>'category' = 'tech'  -- JSONB 过滤
        AND (metadata->>'priority')::int > 5
    ORDER BY distance
    LIMIT 10
    """,
    (query_embedding,)
)
```

## 批量检索

### 1. 单查询多结果

```python
# 一次查询返回多个结果
cursor.execute(
    """
    SELECT id, content, embedding <=> %s AS distance
    FROM documents
    ORDER BY distance
    LIMIT 20  -- 返回 Top-20
    """,
    (query_embedding,)
)
```

### 2. 多查询批量处理

```python
# 批量查询（使用 LATERAL JOIN）
queries = ["查询1", "查询2", "查询3"]
query_embeddings = [
    client.embeddings.create(input=q, model="text-embedding-3-small").data[0].embedding
    for q in queries
]

# 构建批量查询
cursor.execute(
    """
    SELECT
        q.id AS query_id,
        d.id AS doc_id,
        d.content,
        d.embedding <=> q.embedding AS distance
    FROM (
        SELECT 1 AS id, %s::vector AS embedding
        UNION ALL
        SELECT 2 AS id, %s::vector AS embedding
        UNION ALL
        SELECT 3 AS id, %s::vector AS embedding
    ) q
    CROSS JOIN LATERAL (
        SELECT id, content, embedding
        FROM documents
        ORDER BY embedding <=> q.embedding
        LIMIT 10
    ) d
    ORDER BY q.id, distance
    """,
    tuple(query_embeddings)
)
```

## 在 RAG 系统中的应用

### 场景1：基础文档检索

```python
def retrieve_documents(query: str, top_k: int = 5):
    """基础文档检索"""
    # 生成查询向量
    query_embedding = client.embeddings.create(
        input=query,
        model="text-embedding-3-small"
    ).data[0].embedding

    # 检索
    cursor.execute(
        """
        SELECT id, content, embedding <=> %s AS distance
        FROM documents
        ORDER BY distance
        LIMIT %s
        """,
        (query_embedding, top_k)
    )

    return [
        {"id": row[0], "content": row[1], "distance": row[2]}
        for row in cursor.fetchall()
    ]
```

### 场景2：带权限的检索

```python
def retrieve_documents_with_permission(query: str, user_id: int, top_k: int = 5):
    """带权限控制的文档检索"""
    query_embedding = client.embeddings.create(
        input=query,
        model="text-embedding-3-small"
    ).data[0].embedding

    cursor.execute(
        """
        SELECT d.id, d.content, d.embedding <=> %s AS distance
        FROM documents d
        JOIN document_permissions dp ON d.id = dp.document_id
        WHERE dp.user_id = %s OR d.is_public = true
        ORDER BY distance
        LIMIT %s
        """,
        (query_embedding, user_id, top_k)
    )

    return cursor.fetchall()
```

### 场景3：混合检索（向量 + 全文）

```python
def hybrid_search(query: str, top_k: int = 5):
    """混合检索：向量检索 + 全文检索"""
    query_embedding = client.embeddings.create(
        input=query,
        model="text-embedding-3-small"
    ).data[0].embedding

    cursor.execute(
        """
        SELECT
            id,
            content,
            embedding <=> %s AS vector_distance,
            ts_rank(to_tsvector('english', content), to_tsquery('english', %s)) AS text_rank,
            (1 - (embedding <=> %s)) * 0.7 + ts_rank(to_tsvector('english', content), to_tsquery('english', %s)) * 0.3 AS combined_score
        FROM documents
        ORDER BY combined_score DESC
        LIMIT %s
        """,
        (query_embedding, query, query_embedding, query, top_k)
    )

    return cursor.fetchall()
```

### 场景4：对话历史检索

```python
def retrieve_conversation_history(user_id: int, query: str, top_k: int = 5):
    """检索用户的相关对话历史"""
    query_embedding = client.embeddings.create(
        input=query,
        model="text-embedding-3-small"
    ).data[0].embedding

    cursor.execute(
        """
        SELECT
            id,
            message,
            role,
            created_at,
            embedding <=> %s AS distance
        FROM conversations
        WHERE user_id = %s
        ORDER BY distance
        LIMIT %s
        """,
        (query_embedding, user_id, top_k)
    )

    return cursor.fetchall()
```

## 性能优化技巧

### 1. 使用 EXPLAIN ANALYZE 分析查询

```python
# 分析查询性能
cursor.execute(
    """
    EXPLAIN ANALYZE
    SELECT id, content, embedding <=> %s AS distance
    FROM documents
    ORDER BY distance
    LIMIT 10
    """,
    (query_embedding,)
)

plan = cursor.fetchall()
for line in plan:
    print(line[0])
```

### 2. 调整索引搜索范围

```python
# 增加搜索范围，提高召回率
cursor.execute("SET hnsw.ef_search = 100")

# 执行查询
cursor.execute(
    "SELECT * FROM documents ORDER BY embedding <=> %s LIMIT 10",
    (query_embedding,)
)
```

### 3. 使用连接池

```python
from psycopg2.pool import SimpleConnectionPool

# 创建连接池
pool = SimpleConnectionPool(
    minconn=1,
    maxconn=10,
    host="localhost",
    database="mydb",
    user="postgres",
    password="password"
)

# 使用连接
conn = pool.getconn()
cursor = conn.cursor()
# ... 执行查询 ...
pool.putconn(conn)
```

## 常见问题

### Q1: 为什么检索结果不准确？

**可能原因：**
1. 使用了错误的距离函数（如文本用了欧氏距离）
2. 索引未生效（数据量太小或查询语句不当）
3. Embedding 模型不合适

**解决方案：**
```python
# 1. 确认使用余弦距离
cursor.execute("SELECT embedding <=> %s FROM documents LIMIT 1", (query_embedding,))

# 2. 检查索引是否生效
cursor.execute("EXPLAIN SELECT * FROM documents ORDER BY embedding <=> %s LIMIT 10", (query_embedding,))

# 3. 尝试不同的 Embedding 模型
```

### Q2: 如何提高召回率？

```python
# 1. 增加 Top-K
results = search_documents(query, top_k=20)  # 从 10 增加到 20

# 2. 调整索引搜索范围
cursor.execute("SET hnsw.ef_search = 200")  # 从 100 增加到 200

# 3. 降低距离阈值
cursor.execute(
    "SELECT * FROM documents WHERE embedding <=> %s < 0.8 ORDER BY distance",
    (query_embedding,)
)
```

### Q3: 如何处理多语言检索？

```python
# 使用多语言 Embedding 模型
from sentence_transformers import SentenceTransformer

model = SentenceTransformer('paraphrase-multilingual-MiniLM-L12-v2')

# 中文查询
query_zh = "什么是向量数据库？"
embedding_zh = model.encode(query_zh)

# 英文查询
query_en = "What is a vector database?"
embedding_en = model.encode(query_en)

# 两者的 Embedding 在同一个向量空间中，可以跨语言检索
```

## 总结

**相似度搜索的核心要点：**
1. 三种距离函数：余弦（文本）、欧氏（图像）、内积（推荐）
2. Top-K 检索：只返回最相似的 K 个结果
3. 过滤条件：预过滤（高选择性）vs 后过滤（低选择性）
4. 批量检索：使用 LATERAL JOIN 提高效率

**在 RAG 系统中：**
- 基础检索：query → embedding → Top-K documents
- 权限控制：结合 JOIN 过滤用户权限
- 混合检索：向量检索 + 全文检索
- 对话历史：检索相关的历史对话
