# 树的高度与平衡 - 核心概念详解

> 深入理解树的高度计算、平衡因子、AVL树原理

---

## 概述

树的高度和平衡性直接影响树操作的性能。平衡树保证 O(log n) 的操作复杂度，而不平衡树可能退化为 O(n)。

**学习目标：**
- 理解树的高度和深度的区别
- 掌握平衡因子的计算
- 理解 AVL 树的自平衡原理
- 掌握四种旋转操作
- 能够实现平衡树的基本操作

---

## 1. 树的高度

### 1.1 定义

**高度（Height）**：从节点到叶子节点的最长路径长度（边的数量）

```python
def height(root):
    """计算树的高度"""
    if not root:
        return 0  # 空树高度为0

    # 递归计算左右子树高度
    left_height = height(root.left)
    right_height = height(root.right)

    # 返回较大的高度 + 1
    return max(left_height, right_height) + 1

# 示例：
#       1  ← 高度3
#      / \
#     2   3  ← 高度2（节点2），高度1（节点3）
#    / \
#   4   5    ← 高度1
```

### 1.2 高度的性质

**关键性质：**
1. **空树高度为0**
2. **叶子节点高度为1**
3. **树的高度 = max(左子树高度, 右子树高度) + 1**
4. **高度决定了操作的时间复杂度**

```python
# 高度与性能的关系
def analyze_height_performance(n):
    """分析不同高度对性能的影响"""
    import math

    # 平衡树：高度 = O(log n)
    balanced_height = math.ceil(math.log2(n + 1))

    # 不平衡树（最坏情况）：高度 = O(n)
    unbalanced_height = n

    print(f"节点数: {n}")
    print(f"平衡树高度: {balanced_height}")
    print(f"不平衡树高度: {unbalanced_height}")
    print(f"性能差距: {unbalanced_height / balanced_height:.2f}x")

# 测试
analyze_height_performance(1000)
# 节点数: 1000
# 平衡树高度: 10
# 不平衡树高度: 1000
# 性能差距: 100.00x
```

### 1.3 高度的应用

```python
# 应用1：判断完全二叉树
def is_complete_binary_tree(root):
    """判断是否为完全二叉树"""
    if not root:
        return True

    from collections import deque
    queue = deque([root])
    found_null = False

    while queue:
        node = queue.popleft()

        if not node:
            found_null = True
        else:
            if found_null:
                return False  # 在null之后还有节点
            queue.append(node.left)
            queue.append(node.right)

    return True

# 应用2：计算最小高度
def min_height(root):
    """计算最小高度（根到最近叶子的路径）"""
    if not root:
        return 0

    if not root.left:
        return min_height(root.right) + 1
    if not root.right:
        return min_height(root.left) + 1

    return min(min_height(root.left), min_height(root.right)) + 1

# 应用3：计算树的直径
def diameter(root):
    """计算树的直径（任意两节点间的最长路径）"""
    max_diameter = 0

    def dfs(node):
        nonlocal max_diameter
        if not node:
            return 0

        left_h = dfs(node.left)
        right_h = dfs(node.right)

        # 更新直径：左高度 + 右高度
        max_diameter = max(max_diameter, left_h + right_h)

        return max(left_h, right_h) + 1

    dfs(root)
    return max_diameter
```

---

## 2. 平衡因子

### 2.1 定义

**平衡因子（Balance Factor）**：左子树高度 - 右子树高度

```python
def balance_factor(root):
    """计算节点的平衡因子"""
    if not root:
        return 0

    left_h = height(root.left)
    right_h = height(root.right)

    return left_h - right_h

# 示例：
#       1  ← BF = 2 - 1 = 1
#      / \
#     2   3  ← BF = 2 - 0 = 2（不平衡）
#    / \
#   4   5
```

### 2.2 平衡因子的含义

| 平衡因子 | 含义 | 状态 |
|---------|------|------|
| **BF = 0** | 左右子树高度相等 | 完全平衡 |
| **BF = 1** | 左子树比右子树高1 | 平衡 |
| **BF = -1** | 右子树比左子树高1 | 平衡 |
| **BF > 1** | 左子树过高 | 不平衡（需要右旋） |
| **BF < -1** | 右子树过高 | 不平衡（需要左旋） |

### 2.3 计算所有节点的平衡因子

```python
def calculate_all_balance_factors(root):
    """计算所有节点的平衡因子"""
    result = {}

    def dfs(node):
        if not node:
            return 0

        left_h = dfs(node.left)
        right_h = dfs(node.right)

        bf = left_h - right_h
        result[node.val] = bf

        return max(left_h, right_h) + 1

    dfs(root)
    return result

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

bfs = calculate_all_balance_factors(root)
print(bfs)  # {4: 0, 5: 0, 2: 0, 3: 0, 1: 1}
```

---

## 3. 平衡树

### 3.1 定义

**平衡树**：任意节点的平衡因子 ∈ {-1, 0, 1}

```python
def is_balanced(root):
    """判断是否为平衡树"""
    def check(node):
        if not node:
            return 0, True  # (高度, 是否平衡)

        left_h, left_bal = check(node.left)
        right_h, right_bal = check(node.right)

        # 平衡条件：左右平衡 且 高度差 ≤ 1
        balanced = left_bal and right_bal and abs(left_h - right_h) <= 1
        height = max(left_h, right_h) + 1

        return height, balanced

    _, is_bal = check(root)
    return is_bal
```

### 3.2 平衡树的类型

| 类型 | 平衡条件 | 特点 | 应用 |
|------|---------|------|------|
| **AVL 树** | \|BF\| ≤ 1 | 严格平衡 | 查找密集型 |
| **红黑树** | 黑高平衡 | 近似平衡 | 插入删除密集型 |
| **B 树** | 多路平衡 | 磁盘友好 | 数据库索引 |
| **Treap** | 随机优先级 | 期望平衡 | 简单实现 |

### 3.3 平衡树的优势

```python
# 性能对比：平衡树 vs 不平衡树
import time
import random

def benchmark_tree_performance():
    """性能测试"""
    # 构建平衡树（完全二叉树）
    def build_balanced_tree(values):
        if not values:
            return None
        mid = len(values) // 2
        root = TreeNode(values[mid])
        root.left = build_balanced_tree(values[:mid])
        root.right = build_balanced_tree(values[mid+1:])
        return root

    # 构建不平衡树（链表）
    def build_unbalanced_tree(values):
        if not values:
            return None
        root = TreeNode(values[0])
        current = root
        for val in values[1:]:
            current.right = TreeNode(val)
            current = current.right
        return root

    # 查找操作
    def search(root, target):
        if not root:
            return False
        if root.val == target:
            return True
        return search(root.left, target) or search(root.right, target)

    # 测试数据
    values = list(range(1000))

    # 平衡树
    balanced_tree = build_balanced_tree(values)
    start = time.time()
    for _ in range(1000):
        search(balanced_tree, random.choice(values))
    balanced_time = time.time() - start

    # 不平衡树
    unbalanced_tree = build_unbalanced_tree(values)
    start = time.time()
    for _ in range(1000):
        search(unbalanced_tree, random.choice(values))
    unbalanced_time = time.time() - start

    print(f"平衡树: {balanced_time:.4f}s")
    print(f"不平衡树: {unbalanced_time:.4f}s")
    print(f"性能提升: {unbalanced_time / balanced_time:.2f}x")

benchmark_tree_performance()
```

---

## 4. AVL 树

### 4.1 定义

**AVL 树**：自平衡二叉搜索树，任意节点的平衡因子 ∈ {-1, 0, 1}

**核心特性：**
1. **BST 性质**：左 < 根 < 右
2. **平衡性质**：|BF| ≤ 1
3. **自平衡**：插入/删除后自动调整

### 4.2 AVL 树节点

```python
class AVLNode:
    """AVL 树节点"""
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1  # 新节点高度为1

def get_height(node):
    """获取节点高度"""
    if not node:
        return 0
    return node.height

def update_height(node):
    """更新节点高度"""
    if not node:
        return
    node.height = max(get_height(node.left), get_height(node.right)) + 1

def get_balance_factor(node):
    """获取平衡因子"""
    if not node:
        return 0
    return get_height(node.left) - get_height(node.right)
```

### 4.3 四种旋转操作

#### 4.3.1 左旋（Left Rotation）

**场景：** 右子树过高（BF < -1）

```python
def left_rotate(node):
    """左旋：右子树太高"""
    #     x                y
    #    / \              / \
    #   A   y     =>     x   C
    #      / \          / \
    #     B   C        A   B

    new_root = node.right
    node.right = new_root.left
    new_root.left = node

    # 更新高度
    update_height(node)
    update_height(new_root)

    return new_root
```

#### 4.3.2 右旋（Right Rotation）

**场景：** 左子树过高（BF > 1）

```python
def right_rotate(node):
    """右旋：左子树太高"""
    #       x            y
    #      / \          / \
    #     y   C   =>   A   x
    #    / \              / \
    #   A   B            B   C

    new_root = node.left
    node.left = new_root.right
    new_root.right = node

    # 更新高度
    update_height(node)
    update_height(new_root)

    return new_root
```

#### 4.3.3 左右旋（Left-Right Rotation）

**场景：** 左子树的右子树过高（LR 情况）

```python
def left_right_rotate(node):
    """左右旋：LR 情况"""
    #     x              x            z
    #    / \            / \          / \
    #   y   D   =>     z   D   =>   y   x
    #  / \            / \          / \ / \
    # A   z          y   C        A  B C  D
    #    / \        / \
    #   B   C      A   B

    node.left = left_rotate(node.left)
    return right_rotate(node)
```

#### 4.3.4 右左旋（Right-Left Rotation）

**场景：** 右子树的左子树过高（RL 情况）

```python
def right_left_rotate(node):
    """右左旋：RL 情况"""
    #   x                x              z
    #  / \              / \            / \
    # A   y     =>     A   z    =>    x   y
    #    / \              / \        / \ / \
    #   z   D            B   y      A  B C  D
    #  / \                  / \
    # B   C                C   D

    node.right = right_rotate(node.right)
    return left_rotate(node)
```

### 4.4 AVL 树的平衡操作

```python
def balance(node):
    """平衡节点"""
    if not node:
        return None

    # 更新高度
    update_height(node)

    # 获取平衡因子
    bf = get_balance_factor(node)

    # 左子树过高
    if bf > 1:
        if get_balance_factor(node.left) >= 0:
            # LL 情况：右旋
            return right_rotate(node)
        else:
            # LR 情况：左右旋
            return left_right_rotate(node)

    # 右子树过高
    if bf < -1:
        if get_balance_factor(node.right) <= 0:
            # RR 情况：左旋
            return left_rotate(node)
        else:
            # RL 情况：右左旋
            return right_left_rotate(node)

    return node
```

### 4.5 AVL 树的插入

```python
def avl_insert(root, val):
    """AVL 树插入"""
    # 1. 标准 BST 插入
    if not root:
        return AVLNode(val)

    if val < root.val:
        root.left = avl_insert(root.left, val)
    elif val > root.val:
        root.right = avl_insert(root.right, val)
    else:
        return root  # 重复值，不插入

    # 2. 更新高度
    update_height(root)

    # 3. 平衡节点
    return balance(root)
```

### 4.6 AVL 树的删除

```python
def avl_delete(root, val):
    """AVL 树删除"""
    # 1. 标准 BST 删除
    if not root:
        return None

    if val < root.val:
        root.left = avl_delete(root.left, val)
    elif val > root.val:
        root.right = avl_delete(root.right, val)
    else:
        # 找到要删除的节点
        if not root.left:
            return root.right
        elif not root.right:
            return root.left
        else:
            # 两个子节点：找到右子树的最小节点
            min_node = find_min(root.right)
            root.val = min_node.val
            root.right = avl_delete(root.right, min_node.val)

    # 2. 更新高度
    update_height(root)

    # 3. 平衡节点
    return balance(root)

def find_min(node):
    """找到最小节点"""
    while node.left:
        node = node.left
    return node
```

---

## 5. 完整的 AVL 树实现

```python
class AVLTree:
    """AVL 树"""
    def __init__(self):
        self.root = None

    def insert(self, val):
        """插入节点"""
        self.root = avl_insert(self.root, val)

    def delete(self, val):
        """删除节点"""
        self.root = avl_delete(self.root, val)

    def search(self, val):
        """查找节点"""
        return self._search(self.root, val)

    def _search(self, node, val):
        if not node:
            return False
        if node.val == val:
            return True
        elif val < node.val:
            return self._search(node.left, val)
        else:
            return self._search(node.right, val)

    def inorder(self):
        """中序遍历"""
        result = []
        def traverse(node):
            if not node:
                return
            traverse(node.left)
            result.append(node.val)
            traverse(node.right)
        traverse(self.root)
        return result

    def is_balanced(self):
        """判断是否平衡"""
        def check(node):
            if not node:
                return 0, True
            left_h, left_bal = check(node.left)
            right_h, right_bal = check(node.right)
            balanced = left_bal and right_bal and abs(left_h - right_h) <= 1
            height = max(left_h, right_h) + 1
            return height, balanced
        _, is_bal = check(self.root)
        return is_bal

# 使用示例
avl = AVLTree()

# 插入节点
for val in [10, 20, 30, 40, 50, 25]:
    avl.insert(val)
    print(f"插入 {val}，平衡: {avl.is_balanced()}")

# 中序遍历（有序）
print("中序遍历:", avl.inorder())  # [10, 20, 25, 30, 40, 50]

# 删除节点
avl.delete(30)
print("删除 30 后:", avl.inorder())  # [10, 20, 25, 40, 50]
print("平衡:", avl.is_balanced())  # True
```

---

## 6. 性能分析

### 6.1 时间复杂度

| 操作 | 平衡树 | 不平衡树 |
|------|--------|---------|
| **查找** | O(log n) | O(n) |
| **插入** | O(log n) | O(n) |
| **删除** | O(log n) | O(n) |
| **遍历** | O(n) | O(n) |

### 6.2 空间复杂度

| 操作 | 空间复杂度 |
|------|-----------|
| **存储** | O(n) |
| **递归栈** | O(log n) |

### 6.3 旋转次数

| 操作 | 最多旋转次数 |
|------|-------------|
| **插入** | 2 次（LR 或 RL） |
| **删除** | O(log n) 次 |

---

## 7. 应用场景

### 7.1 数据库索引

```python
# MySQL InnoDB 使用 B+ 树（多路平衡树）
# 原理类似 AVL 树，但每个节点有多个子节点

class BPlusTreeNode:
    def __init__(self, is_leaf=False):
        self.is_leaf = is_leaf
        self.keys = []
        self.children = []  # 内部节点：子节点指针
        self.values = []    # 叶子节点：数据指针
        self.next = None    # 叶子节点：链表指针
```

### 7.2 文件系统

```python
# 文件系统使用平衡树管理目录
class FileSystemNode:
    def __init__(self, name):
        self.name = name
        self.children = AVLTree()  # 使用 AVL 树存储子目录

    def add_child(self, child):
        self.children.insert(child.name)

    def find_child(self, name):
        return self.children.search(name)
```

### 7.3 AI Agent 决策树剪枝

```python
def prune_decision_tree(root, max_depth):
    """剪枝决策树，保持平衡"""
    def prune(node, depth):
        if not node or depth >= max_depth:
            return None

        # 递归剪枝子树
        node.left = prune(node.left, depth + 1)
        node.right = prune(node.right, depth + 1)

        # 如果是叶子节点且深度过大，剪掉
        if not node.left and not node.right and depth > max_depth // 2:
            return None

        return node

    return prune(root, 0)
```

---

## 学习检查清单

完成本文档学习后，你应该能够：

- [ ] 计算树的高度
- [ ] 计算节点的平衡因子
- [ ] 判断树是否平衡
- [ ] 理解四种旋转操作
- [ ] 实现 AVL 树的插入
- [ ] 实现 AVL 树的删除
- [ ] 理解平衡树的性能优势
- [ ] 应用平衡树解决实际问题

---

## 参考资源

### 教程
- [GeeksforGeeks - AVL Tree](https://www.geeksforgeeks.org/dsa/avl-tree-in-python/) (2025)
- [W3Schools - Python AVL Trees](https://www.w3schools.com/python/python_dsa_avltrees.asp)
- [DataCamp - AVL Tree Guide](https://www.datacamp.com/tutorial/avl-tree)

### 可视化工具
- [VisuAlgo - AVL Tree](https://visualgo.net/en/bst)
- [USF - AVL Tree Visualization](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html)

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+, AI Agent 开发, RAG 系统
**学习时间**: 30-40 分钟
