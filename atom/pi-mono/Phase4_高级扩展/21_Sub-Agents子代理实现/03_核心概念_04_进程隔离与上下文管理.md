# 核心概念 04：进程隔离与上下文管理

## 1. 进程隔离机制

### 1.1 基本原理

**每个 Sub-Agent 运行在独立的 `pi` 进程中，拥有独立的内存空间和上下文窗口。**

```typescript
// 主 Agent 进程
Process 1 (PID: 1000)
├─ 上下文: 150K tokens
├─ 内存: 200MB
└─ 状态: 运行中

// Sub-Agent 进程（独立）
Process 2 (PID: 1001)
├─ 上下文: 0 tokens（全新）
├─ 内存: 50MB
└─ 状态: 运行中
```

### 1.2 隔离级别

| 维度 | 主 Agent | Sub-Agent | 隔离程度 |
|------|---------|-----------|---------|
| **进程 ID** | 不同 | 不同 | 完全隔离 |
| **内存空间** | 独立 | 独立 | 完全隔离 |
| **上下文窗口** | 独立 | 独立 | 完全隔离 |
| **文件系统** | 共享 | 共享 | 无隔离 |
| **网络** | 共享 | 共享 | 无隔离 |

**关键特性**：
- ✅ 进程级隔离（不是线程）
- ✅ 独立内存空间
- ✅ 独立上下文窗口
- ⚠️ 共享文件系统（通过 cwd 参数控制）

---

## 2. 上下文管理

### 2.1 上下文窗口独立性

```typescript
// 主 Agent 上下文（200K tokens）
{
  messages: [
    { role: "user", content: "重构认证系统" },
    { role: "assistant", content: "我会使用 scout..." },
    // ... 150K tokens 的历史对话
  ]
}

// Sub-Agent 上下文（全新，0 tokens）
{
  messages: [
    { role: "system", content: "You are a scout agent..." },
    { role: "user", content: "Task: Find authentication code" }
  ]
}
```

**优势**：
- ✅ 突破上下文限制：每个 Sub-Agent 有完整窗口
- ✅ 避免污染：子任务细节不占用主 Agent 上下文
- ✅ 专注度高：只看到相关信息

### 2.2 上下文传递

**Chain Mode 中的上下文传递**：

```typescript
// Step 1: Scout 输出
"Found auth code in src/auth.ts"

// Step 2: Planner 上下文
{
  messages: [
    { role: "system", content: "You are a planner..." },
    { role: "user", content: "Task: Based on Found auth code in src/auth.ts, create plan" }
  ]
}
```

**关键点**：
- 只传递文本输出，不传递完整上下文
- 每个 Sub-Agent 仍然是独立的上下文窗口
- 通过任务描述传递必要信息

---

## 3. 进程生命周期

### 3.1 启动流程

```typescript
// 1. 构建参数
const args = [
  '--mode', 'json',
  '--model', agent.model,
  '--tools', agent.tools.join(','),
  '--no-session',
  `Task: ${task}`
];

// 2. 启动进程
const proc = spawn('pi', args, {
  cwd: cwd ?? ctx.cwd,
  stdio: ['ignore', 'pipe', 'pipe']
});

// 3. 监听输出
proc.stdout.on('data', handleOutput);
proc.stderr.on('data', handleError);

// 4. 等待完成
proc.on('close', (code) => {
  resolve(code ?? 0);
});
```

### 3.2 资源管理

**每个 Sub-Agent 进程**：
- 内存：~50-100MB
- CPU：取决于任务
- 文件描述符：stdout, stderr
- 生命周期：任务完成后自动退出

**清理机制**：
```typescript
// 进程退出后自动清理
proc.on('close', () => {
  // 内存自动释放
  // 文件描述符自动关闭
  // 临时文件清理（如果有）
});
```

---

## 4. 2025-2026 隔离技术对比

根据最新研究，AI Agent 隔离技术分为多个级别：

[Source: 2026 AI代理沙箱化：MicroVMs与gVisor隔离技术](https://northflank.com/blog/how-to-sandbox-ai-agents)

| 技术 | 隔离级别 | 性能开销 | 安全性 | 适用场景 |
|------|---------|---------|--------|---------|
| **进程隔离** | 低 | 低 | 中 | 上下文隔离 |
| **容器 (Docker)** | 中 | 中 | 中 | 应用隔离 |
| **gVisor** | 中高 | 中 | 高 | 用户态内核 |
| **MicroVM** | 高 | 高 | 很高 | Hypervisor 级 |

**Pi-mono 的选择**：
- 使用进程隔离（最简单）
- 足够实现上下文隔离
- 不需要容器/VM 的复杂性
- 性能开销最小

[Source: NVIDIA代理工作流沙箱安全指导](https://developer.nvidia.com/blog/practical-security-guidance-for-sandboxing-agentic-workflows-and-managing-execution-risk/)

---

## 5. 安全考虑

### 5.1 文件系统访问

**Sub-Agent 可以访问文件系统**：

```typescript
// Sub-Agent 可以：
- 读取文件（read 工具）
- 写入文件（write 工具）
- 执行命令（bash 工具）

// 控制方式：
1. 工具集限制（tools 参数）
2. 工作目录限制（cwd 参数）
3. 项目 agents 确认机制
```

### 5.2 网络访问

**Sub-Agent 继承主进程的网络权限**：
- 可以访问网络（如果有网络工具）
- 可以调用 LLM API
- 无额外网络隔离

### 5.3 最佳实践

```markdown
<!-- ✅ 好的做法：最小权限 -->
---
name: scout
tools: read, grep, find, ls  # 只读工具
---

<!-- ⚠️ 注意：给予写权限 -->
---
name: worker
tools: read, write, edit, bash  # 完整权限
---

<!-- ❌ 不好：项目 agent 有 bash -->
.pi/agents/custom.md
tools: bash  # 需要审查
```

---

## 6. 性能影响

### 6.1 启动开销

```typescript
// 进程启动时间
Node.js 进程启动: ~200-500ms
pi 初始化: ~300-500ms
总启动时间: ~500-1000ms
```

### 6.2 内存使用

```typescript
// 单个 Sub-Agent
基础内存: ~30MB
模型加载: ~20MB
上下文: ~10-50MB（取决于任务）
总计: ~50-100MB

// 4 个并发 Sub-Agents
总内存: ~200-400MB
```

### 6.3 优化策略

**1. 减少 Sub-Agent 数量**
```typescript
// ❌ 不好：过多 Sub-Agents
{ tasks: [task1, task2, task3, task4, task5, task6, task7, task8] }

// ✅ 好：合并任务
{ tasks: [
  { agent: "scout", task: "Find A, B, C, D" },
  { agent: "scout", task: "Find E, F, G, H" }
]}
```

**2. 选择合适的模型**
```typescript
// 简单任务：Haiku（内存占用小）
model: "claude-haiku-4-5"

// 复杂任务：Sonnet
model: "claude-sonnet-4"
```

---

## 7. 故障隔离

### 7.1 进程崩溃

**Sub-Agent 崩溃不影响主 Agent**：

```typescript
// 场景：Sub-Agent 崩溃
Sub-Agent Process: ✗ Crashed (exit code 1)
主 Agent Process: ✓ 继续运行

// 返回错误，但主 Agent 不受影响
return {
  content: [{ type: "text", text: "Sub-agent failed" }],
  isError: true
};
```

### 7.2 资源泄漏

**进程退出自动清理**：
- 内存自动释放
- 文件描述符自动关闭
- 不会有资源泄漏

---

## 8. 与其他隔离方案对比

### 8.1 线程 vs 进程

| 维度 | 线程 | 进程（Pi-mono） |
|------|------|----------------|
| **内存** | 共享 | 独立 |
| **上下文** | 共享 | 独立 |
| **崩溃影响** | 整个程序 | 仅该进程 |
| **开销** | 低 | 中 |
| **隔离性** | 弱 | 强 |

**为什么选择进程**：
- ✅ 上下文完全隔离
- ✅ 故障隔离
- ✅ 简单可靠

### 8.2 容器 vs 进程

| 维度 | 容器 | 进程（Pi-mono） |
|------|------|----------------|
| **隔离级别** | 高 | 中 |
| **启动时间** | 慢（秒级） | 快（毫秒级） |
| **资源开销** | 高 | 低 |
| **复杂度** | 高 | 低 |
| **适用场景** | 生产部署 | 开发工具 |

**为什么不用容器**：
- ⚠️ 启动慢（影响用户体验）
- ⚠️ 复杂度高（需要 Docker）
- ✅ 进程隔离已足够

---

## 9. 未来演进

### 9.1 可能的改进

**1. 资源限制**
```typescript
// 未来可能支持
{
  agent: "scout",
  task: "...",
  limits: {
    memory: "100MB",
    cpu: "50%",
    timeout: "30s"
  }
}
```

**2. 沙箱增强**
```typescript
// 未来可能使用 gVisor 或 MicroVM
{
  agent: "worker",
  task: "...",
  sandbox: "gvisor"  // 更强的隔离
}
```

**3. 进程池**
```typescript
// 复用进程，减少启动开销
class SubAgentPool {
  private pool: Process[] = [];

  async execute(agent: string, task: string) {
    const proc = this.pool.pop() || spawn('pi', ...);
    // 复用进程
  }
}
```

---

## 10. 总结

### 核心要点

1. **进程隔离**：每个 Sub-Agent 独立进程
2. **上下文独立**：完整的上下文窗口
3. **故障隔离**：崩溃不影响主 Agent
4. **简单可靠**：无需容器/VM
5. **性能可接受**：启动开销 ~1s

### 关键洞察

- **隔离 = 独立**：进程级隔离保证完全独立
- **简单 = 可靠**：避免过度工程
- **性能 = 权衡**：启动开销换取隔离性
- **未来 = 增强**：可选的沙箱增强

---

**参考资源**：
- [2026 AI代理沙箱化技术](https://northflank.com/blog/how-to-sandbox-ai-agents)
- [NVIDIA代理工作流安全指导](https://developer.nvidia.com/blog/practical-security-guidance-for-sandboxing-agentic-workflows-and-managing-execution-risk/)
- [Node.js child_process 文档](https://nodejs.org/api/child_process.html)
