# 实战代码 02：单调队列算法

> LeetCode 239 滑动窗口最大值完整实现 + AI Agent 应用

---

## 1. LeetCode 239：滑动窗口最大值

```python
from collections import deque
from typing import List

def maxSlidingWindow(nums: List[int], k: int) -> List[int]:
    """
    滑动窗口最大值 - 单调递减队列
    
    时间复杂度：O(n)
    空间复杂度：O(k)
    
    Args:
        nums: 输入数组
        k: 窗口大小
    
    Returns:
        每个窗口的最大值列表
    """
    if not nums or k == 0:
        return []
    
    dq = deque()  # 存储索引
    result = []
    
    for i, num in enumerate(nums):
        # 维护单调递减：移除所有小于当前元素的元素
        while dq and nums[dq[-1]] < num:
            dq.pop()
        
        # 添加当前元素的索引
        dq.append(i)
        
        # 移除超出窗口的元素
        if dq[0] < i - k + 1:
            dq.popleft()
        
        # 窗口形成后，队首就是最大值
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result

# 测试
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]
```

---

## 2. 滑动窗口最小值

```python
from collections import deque
from typing import List

def minSlidingWindow(nums: List[int], k: int) -> List[int]:
    """
    滑动窗口最小值 - 单调递增队列
    
    时间复杂度：O(n)
    空间复杂度：O(k)
    """
    if not nums or k == 0:
        return []
    
    dq = deque()  # 存储索引
    result = []
    
    for i, num in enumerate(nums):
        # 维护单调递增：移除所有大于当前元素的元素
        while dq and nums[dq[-1]] > num:
            dq.pop()
        
        dq.append(i)
        
        # 移除超出窗口的元素
        if dq[0] < i - k + 1:
            dq.popleft()
        
        # 窗口形成后，队首就是最小值
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result

# 测试
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(minSlidingWindow(nums, k))  # [1, -3, -3, -3, 3, 3]
```

---

## 3. 完整测试套件

```python
import pytest
from collections import deque

def test_max_sliding_window():
    """测试滑动窗口最大值"""
    # 基本测试
    assert maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7]
    
    # 边界测试
    assert maxSlidingWindow([1], 1) == [1]
    assert maxSlidingWindow([1,2,3,4,5], 1) == [1,2,3,4,5]
    assert maxSlidingWindow([1,2,3,4,5], 5) == [5]
    
    # 空数组
    assert maxSlidingWindow([], 0) == []
    
    # 递增序列
    assert maxSlidingWindow([1,2,3,4,5], 3) == [3,4,5]
    
    # 递减序列
    assert maxSlidingWindow([5,4,3,2,1], 3) == [5,4,3]
    
    # 相同元素
    assert maxSlidingWindow([1,1,1,1,1], 3) == [1,1,1]

def test_min_sliding_window():
    """测试滑动窗口最小值"""
    assert minSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [1,-3,-3,-3,3,3]
    assert minSlidingWindow([1], 1) == [1]
    assert minSlidingWindow([5,4,3,2,1], 3) == [3,2,1]

# 运行测试
if __name__ == "__main__":
    test_max_sliding_window()
    test_min_sliding_window()
    print("所有测试通过！")
```

---

## 4. AI Agent 应用：优先级任务调度

```python
from collections import deque
import time
from typing import Optional, Tuple

class PriorityTaskScheduler:
    """基于单调队列的优先级任务调度器"""
    
    def __init__(self):
        self.tasks = deque()  # 存储 (priority, timestamp, task_id, task_data)
    
    def add_task(self, priority: int, task_id: str, task_data: dict):
        """
        添加任务，维护单调递减优先级
        
        Args:
            priority: 任务优先级（数字越大优先级越高）
            task_id: 任务ID
            task_data: 任务数据
        """
        timestamp = time.time()
        
        # 移除所有优先级低于当前任务的任务
        while self.tasks and self.tasks[-1][0] < priority:
            removed = self.tasks.pop()
            print(f"移除低优先级任务: {removed[2]} (优先级: {removed[0]})")
        
        self.tasks.append((priority, timestamp, task_id, task_data))
        print(f"添加任务: {task_id} (优先级: {priority})")
    
    def get_next_task(self) -> Optional[Tuple]:
        """获取最高优先级任务"""
        if self.tasks:
            task = self.tasks.popleft()
            print(f"执行任务: {task[2]} (优先级: {task[0]})")
            return task
        return None
    
    def get_max_priority(self) -> int:
        """O(1) 获取最高优先级"""
        if self.tasks:
            return self.tasks[0][0]
        return -1
    
    def get_pending_count(self) -> int:
        """获取待处理任务数量"""
        return len(self.tasks)

# 使用示例
scheduler = PriorityTaskScheduler()

# 添加不同优先级的任务
scheduler.add_task(1, "task_1", {"type": "低优先级"})
scheduler.add_task(5, "task_2", {"type": "高优先级"})  # 移除 task_1
scheduler.add_task(3, "task_3", {"type": "中优先级"})
scheduler.add_task(4, "task_4", {"type": "中高优先级"})

print(f"\n当前最高优先级: {scheduler.get_max_priority()}")
print(f"待处理任务数: {scheduler.get_pending_count()}")

# 执行任务
print("\n开始执行任务:")
while scheduler.get_pending_count() > 0:
    scheduler.get_next_task()
```

---

## 5. 实时性能监控

```python
from collections import deque
import time
import random

class PerformanceMonitor:
    """实时性能监控 - 滑动窗口统计"""
    
    def __init__(self, window_size: int = 100):
        self.window_size = window_size
        self.latencies = deque(maxlen=window_size)
        self.max_queue = deque()  # 单调递减队列（最大值）
        self.min_queue = deque()  # 单调递增队列（最小值）
    
    def record_latency(self, latency: float):
        """记录延迟"""
        self.latencies.append(latency)
        
        # 维护最大值队列
        while self.max_queue and self.max_queue[-1] < latency:
            self.max_queue.pop()
        self.max_queue.append(latency)
        
        # 维护最小值队列
        while self.min_queue and self.min_queue[-1] > latency:
            self.min_queue.pop()
        self.min_queue.append(latency)
        
        # 移除超出窗口的元素
        if len(self.latencies) == self.window_size:
            if self.max_queue and self.max_queue[0] == self.latencies[0]:
                self.max_queue.popleft()
            if self.min_queue and self.min_queue[0] == self.latencies[0]:
                self.min_queue.popleft()
    
    def get_max_latency(self) -> float:
        """O(1) 获取最大延迟"""
        return self.max_queue[0] if self.max_queue else 0
    
    def get_min_latency(self) -> float:
        """O(1) 获取最小延迟"""
        return self.min_queue[0] if self.min_queue else 0
    
    def get_avg_latency(self) -> float:
        """获取平均延迟"""
        return sum(self.latencies) / len(self.latencies) if self.latencies else 0
    
    def get_range(self) -> float:
        """O(1) 获取极差"""
        if self.max_queue and self.min_queue:
            return self.max_queue[0] - self.min_queue[0]
        return 0
    
    def get_stats(self) -> dict:
        """获取完整统计信息"""
        return {
            "count": len(self.latencies),
            "max": self.get_max_latency(),
            "min": self.get_min_latency(),
            "avg": self.get_avg_latency(),
            "range": self.get_range()
        }

# 使用示例
monitor = PerformanceMonitor(window_size=10)

print("模拟 API 调用延迟监控:")
for i in range(20):
    latency = random.uniform(0.1, 2.0)
    monitor.record_latency(latency)
    
    if i >= 9:  # 窗口形成后开始输出统计
        stats = monitor.get_stats()
        print(f"请求 {i+1}: 延迟={latency:.3f}s, "
              f"最大={stats['max']:.3f}s, "
              f"最小={stats['min']:.3f}s, "
              f"平均={stats['avg']:.3f}s")
```

---

## 6. 流式数据处理

```python
from collections import deque
from typing import List

class StreamProcessor:
    """流式数据处理器 - 实时最值统计"""
    
    def __init__(self, window_size: int):
        self.window_size = window_size
        self.data = deque(maxlen=window_size)
        self.max_queue = deque()  # 单调递减
        self.min_queue = deque()  # 单调递增
    
    def add_data(self, value: float):
        """添加数据点"""
        self.data.append(value)
        
        # 维护最大值队列
        while self.max_queue and self.max_queue[-1] < value:
            self.max_queue.pop()
        self.max_queue.append(value)
        
        # 维护最小值队列
        while self.min_queue and self.min_queue[-1] > value:
            self.min_queue.pop()
        self.min_queue.append(value)
        
        # 移除超出窗口的元素
        if len(self.data) == self.window_size:
            if self.max_queue and self.max_queue[0] == self.data[0]:
                self.max_queue.popleft()
            if self.min_queue and self.min_queue[0] == self.data[0]:
                self.min_queue.popleft()
    
    def get_max(self) -> float:
        """O(1) 获取当前窗口最大值"""
        return self.max_queue[0] if self.max_queue else float('-inf')
    
    def get_min(self) -> float:
        """O(1) 获取当前窗口最小值"""
        return self.min_queue[0] if self.min_queue else float('inf')
    
    def get_range(self) -> float:
        """O(1) 获取当前窗口极差"""
        if self.max_queue and self.min_queue:
            return self.max_queue[0] - self.min_queue[0]
        return 0
    
    def is_anomaly(self, threshold: float = 2.0) -> bool:
        """检测异常（极差超过阈值）"""
        return self.get_range() > threshold

# 使用示例
processor = StreamProcessor(window_size=5)

print("流式数据处理示例:")
data_stream = [1.0, 1.2, 1.1, 1.3, 5.0, 1.2, 1.1, 1.4, 1.0]

for i, value in enumerate(data_stream):
    processor.add_data(value)
    
    if i >= 4:  # 窗口形成后
        print(f"数据点 {i+1}: 值={value:.1f}, "
              f"最大={processor.get_max():.1f}, "
              f"最小={processor.get_min():.1f}, "
              f"极差={processor.get_range():.1f}, "
              f"异常={'是' if processor.is_anomaly(2.0) else '否'}")
```

---

## 7. 性能基准测试

```python
import time
from collections import deque

def benchmark_monotonic_queue():
    """性能基准测试"""
    n = 100000
    k = 1000
    nums = list(range(n))
    
    # 方法1：暴力解法 O(n*k)
    print("=== 暴力解法 ===")
    start = time.time()
    result1 = []
    for i in range(len(nums) - k + 1):
        result1.append(max(nums[i:i+k]))
    brute_time = time.time() - start
    print(f"时间: {brute_time:.4f}s")
    
    # 方法2：单调队列 O(n)
    print("\n=== 单调队列 ===")
    start = time.time()
    result2 = maxSlidingWindow(nums, k)
    mono_time = time.time() - start
    print(f"时间: {mono_time:.4f}s")
    
    # 验证结果一致
    assert result1 == result2, "结果不一致！"
    
    print(f"\n性能提升: {brute_time / mono_time:.0f} 倍")
    print(f"结果长度: {len(result2)}")

benchmark_monotonic_queue()

# 输出示例：
# === 暴力解法 ===
# 时间: 5.0000s
#
# === 单调队列 ===
# 时间: 0.0050s
#
# 性能提升: 1000 倍
# 结果长度: 99001
```

---

**版本**: v1.0
**最后更新**: 2026-02-13
