# 化骨绵掌

将中间件系统拆分成 10 个 2 分钟知识卡片，每个卡片独立完整，形成递进关系。

---

## 卡片1：中间件的直觉理解

**一句话：** 中间件是请求和响应的拦截器，就像机场安检通道

**举例：**

想象你要坐飞机：
1. 进入机场（请求到达）
2. 经过安检（中间件1：检查身份）
3. 经过海关（中间件2：检查签证）
4. 到达登机口（路由处理）
5. 返回时再次经过海关（中间件2：出境检查）
6. 返回时再次经过安检（中间件1：安全检查）
7. 离开机场（响应返回）

每个乘客（请求）都要经过这些检查站（中间件），不能跳过。

**应用：** 在 AI Agent 后端中，中间件用于日志、认证、限流等横切关注点，让业务代码专注于 AI 逻辑。

---

## 卡片2：中间件的形式化定义

**一句话：** 中间件是一个接收 `request` 和 `call_next` 的异步函数，返回 `response`

**举例：**

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def my_middleware(request: Request, call_next):
    # 1. 请求前处理
    print(f"Before: {request.url.path}")

    # 2. 调用下一个中间件或路由
    response = await call_next(request)

    # 3. 响应后处理
    print(f"After: {response.status_code}")

    # 4. 返回响应
    return response
```

**关键点：**
- 必须是 `async` 函数
- 必须调用 `await call_next(request)`
- 必须返回 `response`

**应用：** 这是所有中间件的基本结构，理解了这个，就能写出任何中间件。

---

## 卡片3：洋葱模型执行流程

**一句话：** 中间件按洋葱模型执行：先注册的在外层，后注册的在内层

**举例：**

```python
@app.middleware("http")
async def middleware_1(request: Request, call_next):
    print("1: before")
    response = await call_next(request)
    print("1: after")
    return response

@app.middleware("http")
async def middleware_2(request: Request, call_next):
    print("2: before")
    response = await call_next(request)
    print("2: after")
    return response

# 执行顺序：
# 1: before → 2: before → 路由 → 2: after → 1: after
```

**可视化：**
```
请求进入：
客户端 → 中间件1 → 中间件2 → 路由 → 中间件2 → 中间件1 → 客户端
         ↓before  ↓before  ↓     ↑after   ↑after
```

**应用：** 理解洋葱模型，才能正确设计中间件的执行顺序。

---

## 卡片4：request.state 状态传递

**一句话：** 使用 `request.state` 在中间件和路由之间传递数据

**举例：**

```python
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 中间件中设置状态
    token = request.headers.get("authorization")
    if token:
        request.state.user_id = "user_123"
        request.state.is_admin = True

    response = await call_next(request)
    return response

@app.get("/users/me")
async def get_current_user(request: Request):
    # 路由中读取状态
    user_id = request.state.user_id
    is_admin = request.state.is_admin
    return {"user_id": user_id, "is_admin": is_admin}
```

**应用：** 认证中间件设置 `request.state.user`，路由直接使用，避免重复验证。

---

## 卡片5：提前返回响应

**一句话：** 在中间件中直接返回响应，不调用 `call_next()`，可以拦截请求

**举例：**

```python
from fastapi.responses import JSONResponse

@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    token = request.headers.get("authorization")

    if not token:
        # 提前返回，不继续处理
        return JSONResponse(
            {"error": "Unauthorized"},
            status_code=401
        )

    # 认证通过，继续处理
    response = await call_next(request)
    return response
```

**应用：** 认证失败、限流超限、维护模式等场景，直接返回错误响应。

---

## 卡片6：CORS 中间件配置

**一句话：** 使用 FastAPI 内置的 CORS 中间件处理跨域请求

**举例：**

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # 允许的前端域名
    allow_credentials=True,                    # 允许携带 Cookie
    allow_methods=["*"],                       # 允许所有 HTTP 方法
    allow_headers=["*"],                       # 允许所有请求头
)
```

**配置说明：**
- `allow_origins`：白名单域名，`["*"]` 表示允许所有
- `allow_credentials`：是否允许携带 Cookie
- `allow_methods`：允许的 HTTP 方法（GET、POST 等）
- `allow_headers`：允许的请求头

**应用：** 前端（React/Vue）调用后端 API 时，必须配置 CORS。

---

## 卡片7：中间件类的实现

**一句话：** 除了装饰器，还可以用类实现中间件，更灵活

**举例：**

```python
from starlette.middleware.base import BaseHTTPMiddleware

class LoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # 请求前处理
        print(f"Request: {request.method} {request.url.path}")

        # 调用下一个中间件或路由
        response = await call_next(request)

        # 响应后处理
        print(f"Response: {response.status_code}")

        return response

# 使用
app.add_middleware(LoggingMiddleware)
```

**类 vs 装饰器：**
- 装饰器：简单场景，快速实现
- 类：复杂场景，可以有初始化参数和状态

**应用：** 需要配置参数的中间件（如限流中间件的速率配置），用类更合适。

---

## 卡片8：中间件的执行顺序设计

**一句话：** 中间件的顺序很重要，要根据依赖关系合理安排

**举例：**

```python
# ✅ 正确的顺序
# 1. 日志中间件（最外层，记录完整时间）
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    start = time.time()
    response = await call_next(request)
    duration = time.time() - start
    print(f"{request.method} {request.url.path} - {duration:.3f}s")
    return response

# 2. CORS 中间件（处理跨域）
app.add_middleware(CORSMiddleware, allow_origins=["*"])

# 3. 认证中间件（验证身份）
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 验证 token...
    response = await call_next(request)
    return response

# 4. 限流中间件（防止滥用）
@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    # 检查限流...
    response = await call_next(request)
    return response
```

**顺序原则：**
- 日志在最外层（记录完整时间）
- CORS 在外层（确保跨域请求能处理）
- 认证在中层（业务逻辑前验证）
- 限流在内层（认证后再检查）

**应用：** 合理的顺序可以提高性能，避免浪费资源。

---

## 卡片9：中间件 vs 依赖注入

**一句话：** 中间件是全局拦截器，依赖注入是局部注入器

**举例：**

```python
# 中间件：应用到所有路由
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    print(f"Request: {request.url.path}")
    response = await call_next(request)
    return response

# 依赖注入：只应用到指定路由
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users")
async def get_users(db: Session = Depends(get_db)):  # 只有这个路由用到 db
    return db.query(User).all()
```

**选择原则：**
- 需要应用到所有路由 → 中间件
- 只有部分路由需要 → 依赖注入

**应用：** 日志、CORS、认证用中间件；数据库连接、分页参数用依赖注入。

---

## 卡片10：AI Agent 后端的中间件实战

**一句话：** 在 AI Agent 后端中，中间件是保护 LLM API 的第一道防线

**举例：**

```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import time

app = FastAPI()

# 1. CORS：允许前端跨域调用
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# 2. 日志：记录每个请求
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    start = time.time()
    print(f"→ {request.method} {request.url.path}")

    response = await call_next(request)

    duration = time.time() - start
    print(f"← {response.status_code} ({duration:.3f}s)")

    return response

# 3. 认证：验证 JWT
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    if request.url.path.startswith("/api/agent/"):
        token = request.headers.get("authorization")
        if not token:
            return JSONResponse({"error": "Unauthorized"}, status_code=401)
        # 验证 token...
        request.state.user_id = "user_123"

    response = await call_next(request)
    return response

# 4. 限流：防止滥用
rate_limit_store = {}

@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    client_ip = request.client.host
    now = time.time()

    if client_ip not in rate_limit_store:
        rate_limit_store[client_ip] = []

    # 清理 1 分钟前的记录
    rate_limit_store[client_ip] = [
        t for t in rate_limit_store[client_ip]
        if now - t < 60
    ]

    # 检查限流
    if len(rate_limit_store[client_ip]) >= 10:
        return JSONResponse(
            {"error": "Rate limit exceeded"},
            status_code=429
        )

    rate_limit_store[client_ip].append(now)
    response = await call_next(request)
    return response

# 业务路由
@app.post("/api/agent/chat")
async def chat(request: Request, message: str):
    user_id = request.state.user_id
    # 调用 LLM API...
    return {"response": "..."}
```

**应用场景：**
- **CORS**：允许前端调用
- **日志**：记录请求，便于调试
- **认证**：保护 API，防止未授权访问
- **限流**：防止滥用，控制 LLM API 成本

**为什么重要：**
- LLM API 调用很贵（每次几分钱到几块钱）
- 必须防止 API 被滥用
- 中间件是第一道防线

---

## 总结

**10 个知识卡片的递进关系：**

1. **直觉理解**：中间件是拦截器
2. **形式化定义**：`request → call_next() → response`
3. **洋葱模型**：先注册在外层，后注册在内层
4. **状态传递**：`request.state` 在中间件和路由之间传递数据
5. **提前返回**：不调用 `call_next()` 可以拦截请求
6. **CORS 配置**：处理跨域请求
7. **中间件类**：用类实现更灵活的中间件
8. **执行顺序**：合理安排中间件顺序
9. **vs 依赖注入**：全局 vs 局部
10. **AI Agent 实战**：保护 LLM API 的第一道防线

**学习路径：**
```
直觉理解 → 形式化定义 → 洋葱模型 → 状态传递 → 提前返回
    ↓
CORS 配置 → 中间件类 → 执行顺序 → vs 依赖注入 → AI Agent 实战
```

**记住：** 中间件是 FastAPI 中最重要的概念之一，理解了中间件，就能构建生产级的 API。
