# 实战代码3：异步数据库操作

> 完整可运行的异步数据库查询示例

---

## 示例概述

本示例演示如何使用 asyncio 进行异步数据库操作，包括：
1. 使用 SQLAlchemy 异步 ORM
2. 异步数据库连接管理
3. 并发执行多个查询
4. 事务处理
5. 连接池配置

**适合场景：** AI Agent 后端开发、数据密集型应用

---

## 完整代码

```python
"""
asyncio 异步数据库操作示例
演示：使用 SQLAlchemy 进行异步数据库操作
"""

import asyncio
from typing import List, Optional
from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, select, func
from sqlalchemy.ext.asyncio import (
    create_async_engine,
    AsyncSession,
    async_sessionmaker
)
from sqlalchemy.orm import declarative_base

# 创建基类
Base = declarative_base()


# ===== 1. 定义数据模型 =====
print("=== 1. 定义数据模型 ===\n")


class User(Base):
    """用户模型"""
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    name = Column(String(50), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f"<User(id={self.id}, name='{self.name}', email='{self.email}')>"


# ===== 2. 创建异步引擎和会话 =====
print("=== 2. 创建异步引擎和会话 ===\n")

# 使用 SQLite 内存数据库（实际项目中使用 PostgreSQL）
DATABASE_URL = "sqlite+aiosqlite:///:memory:"

# 创建异步引擎
engine = create_async_engine(
    DATABASE_URL,
    echo=False,  # 设置为 True 可以看到 SQL 语句
    pool_size=5,  # 连接池大小
    max_overflow=10  # 最大溢出连接数
)

# 创建异步会话工厂
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)


# ===== 3. 初始化数据库 =====


async def init_db():
    """初始化数据库表"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    print("数据库表创建完成\n")


# ===== 4. 基础 CRUD 操作 =====
print("=== 4. 基础 CRUD 操作 ===\n")


async def create_user(name: str, email: str) -> User:
    """创建用户"""
    async with AsyncSessionLocal() as session:
        user = User(name=name, email=email)
        session.add(user)
        await session.commit()
        await session.refresh(user)
        return user


async def get_user_by_id(user_id: int) -> Optional[User]:
    """根据 ID 获取用户"""
    async with AsyncSessionLocal() as session:
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        return result.scalar_one_or_none()


async def get_all_users() -> List[User]:
    """获取所有用户"""
    async with AsyncSessionLocal() as session:
        result = await session.execute(select(User))
        return result.scalars().all()


async def update_user(user_id: int, name: str) -> Optional[User]:
    """更新用户"""
    async with AsyncSessionLocal() as session:
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        user = result.scalar_one_or_none()

        if user:
            user.name = name
            await session.commit()
            await session.refresh(user)

        return user


async def delete_user(user_id: int) -> bool:
    """删除用户"""
    async with AsyncSessionLocal() as session:
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        user = result.scalar_one_or_none()

        if user:
            await session.delete(user)
            await session.commit()
            return True

        return False


async def example_4():
    """示例4：基础 CRUD 操作"""
    print("示例4：基础 CRUD 操作")

    # 创建用户
    user1 = await create_user("Alice", "alice@example.com")
    print(f"创建用户: {user1}")

    # 查询用户
    user = await get_user_by_id(user1.id)
    print(f"查询用户: {user}")

    # 更新用户
    updated_user = await update_user(user1.id, "Alice Smith")
    print(f"更新用户: {updated_user}")

    # 删除用户
    deleted = await delete_user(user1.id)
    print(f"删除用户: {deleted}\n")


# ===== 5. 并发查询 =====
print("=== 5. 并发查询 ===\n")


async def example_5():
    """示例5：并发执行多个查询"""
    print("示例5：并发执行多个查询")

    # 先创建一些用户
    users = await asyncio.gather(
        create_user("Bob", "bob@example.com"),
        create_user("Charlie", "charlie@example.com"),
        create_user("David", "david@example.com")
    )
    print(f"创建了 {len(users)} 个用户")

    # 并发查询多个用户
    import time
    start = time.time()

    results = await asyncio.gather(
        get_user_by_id(users[0].id),
        get_user_by_id(users[1].id),
        get_user_by_id(users[2].id)
    )

    elapsed = time.time() - start

    print(f"并发查询完成，耗时: {elapsed:.3f}秒")
    for user in results:
        print(f"  {user}")
    print()


# ===== 6. 批量操作 =====
print("=== 6. 批量操作 ===\n")


async def create_users_batch(users_data: List[dict]) -> List[User]:
    """批量创建用户"""
    async with AsyncSessionLocal() as session:
        users = [User(**data) for data in users_data]
        session.add_all(users)
        await session.commit()

        # 刷新所有用户以获取 ID
        for user in users:
            await session.refresh(user)

        return users


async def example_6():
    """示例6：批量操作"""
    print("示例6：批量操作")

    users_data = [
        {"name": f"User{i}", "email": f"user{i}@example.com"}
        for i in range(1, 11)
    ]

    import time
    start = time.time()

    users = await create_users_batch(users_data)

    elapsed = time.time() - start

    print(f"批量创建 {len(users)} 个用户，耗时: {elapsed:.3f}秒")
    print(f"用户 ID 范围: {users[0].id} - {users[-1].id}\n")


# ===== 7. 事务处理 =====
print("=== 7. 事务处理 ===\n")


async def transfer_credits(
    from_user_id: int,
    to_user_id: int,
    amount: int
) -> bool:
    """转账操作（演示事务）"""
    async with AsyncSessionLocal() as session:
        try:
            # 开始事务
            async with session.begin():
                # 查询两个用户
                from_user = await session.get(User, from_user_id)
                to_user = await session.get(User, to_user_id)

                if not from_user or not to_user:
                    return False

                # 模拟转账逻辑
                print(f"  从 {from_user.name} 转账 {amount} 到 {to_user.name}")

                # 如果出错，事务会自动回滚
                # raise Exception("转账失败")

            # 事务自动提交
            return True

        except Exception as e:
            print(f"  事务失败: {e}")
            # 事务自动回滚
            return False


async def example_7():
    """示例7：事务处理"""
    print("示例7：事务处理")

    # 创建两个用户
    user1 = await create_user("Sender", "sender@example.com")
    user2 = await create_user("Receiver", "receiver@example.com")

    # 执行转账
    success = await transfer_credits(user1.id, user2.id, 100)

    if success:
        print("  转账成功\n")
    else:
        print("  转账失败\n")


# ===== 8. 连接池管理 =====
print("=== 8. 连接池管理 ===\n")


async def example_8():
    """示例8：连接池管理"""
    print("示例8：连接池管理")

    # 并发执行多个查询，测试连接池
    tasks = [get_all_users() for _ in range(10)]

    import time
    start = time.time()

    results = await asyncio.gather(*tasks)

    elapsed = time.time() - start

    print(f"执行 {len(tasks)} 个并发查询，耗时: {elapsed:.3f}秒")
    print(f"每个查询返回 {len(results[0])} 个用户\n")


# ===== 9. 复杂查询 =====
print("=== 9. 复杂查询 ===\n")


async def search_users(keyword: str) -> List[User]:
    """搜索用户"""
    async with AsyncSessionLocal() as session:
        result = await session.execute(
            select(User).where(
                User.name.like(f"%{keyword}%") |
                User.email.like(f"%{keyword}%")
            )
        )
        return result.scalars().all()


async def count_users() -> int:
    """统计用户数量"""
    async with AsyncSessionLocal() as session:
        result = await session.execute(
            select(func.count(User.id))
        )
        return result.scalar()


async def example_9():
    """示例9：复杂查询"""
    print("示例9：复杂查询")

    # 搜索用户
    users = await search_users("User")
    print(f"搜索到 {len(users)} 个用户")

    # 统计用户数量
    count = await count_users()
    print(f"总用户数: {count}\n")


# ===== 10. 在 FastAPI 中使用 =====
print("=== 10. 在 FastAPI 中使用 ===\n")


async def get_db_session():
    """依赖注入：获取数据库会话"""
    async with AsyncSessionLocal() as session:
        yield session


# FastAPI 路由示例（伪代码）
async def fastapi_example():
    """示例10：在 FastAPI 中使用异步数据库"""
    print("示例10：在 FastAPI 中使用异步数据库")

    print("""
FastAPI 路由示例:

from fastapi import FastAPI, Depends
from sqlalchemy.ext.asyncio import AsyncSession

app = FastAPI()

@app.get("/users/{user_id}")
async def get_user(
    user_id: int,
    db: AsyncSession = Depends(get_db_session)
):
    result = await db.execute(
        select(User).where(User.id == user_id)
    )
    user = result.scalar_one_or_none()
    return user

@app.post("/users")
async def create_user_endpoint(
    name: str,
    email: str,
    db: AsyncSession = Depends(get_db_session)
):
    user = User(name=name, email=email)
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return user
    """)
    print()


# ===== 主函数 =====


async def main():
    """主函数：运行所有示例"""
    print("=" * 60)
    print("asyncio 异步数据库操作示例")
    print("=" * 60)
    print()

    # 初始化数据库
    await init_db()

    # 运行所有示例
    await example_4()
    await example_5()
    await example_6()
    await example_7()
    await example_8()
    await example_9()
    await fastapi_example()

    # 清理
    await engine.dispose()

    print("=" * 60)
    print("所有示例运行完成！")
    print("=" * 60)


# ===== 运行程序 =====

if __name__ == "__main__":
    asyncio.run(main())
```

---

## 依赖安装

```bash
# 安装 SQLAlchemy 和异步驱动
uv add sqlalchemy aiosqlite

# 如果使用 PostgreSQL
uv add asyncpg
```

---

## 关键知识点

### 1. 创建异步引擎

```python
from sqlalchemy.ext.asyncio import create_async_engine

engine = create_async_engine(
    "sqlite+aiosqlite:///:memory:",
    echo=True,
    pool_size=5
)
```

### 2. 创建异步会话

```python
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker

AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)
```

### 3. 使用异步会话

```python
async with AsyncSessionLocal() as session:
    result = await session.execute(select(User))
    users = result.scalars().all()
```

### 4. 并发查询

```python
# 并发执行多个查询
results = await asyncio.gather(
    get_user_by_id(1),
    get_user_by_id(2),
    get_user_by_id(3)
)
```

### 5. 事务处理

```python
async with session.begin():
    # 事务内的操作
    session.add(user)
    # 自动提交或回滚
```

---

## 数据库 URL 格式

| 数据库 | URL 格式 | 异步驱动 |
|--------|---------|---------|
| SQLite | `sqlite+aiosqlite:///path/to/db.db` | aiosqlite |
| PostgreSQL | `postgresql+asyncpg://user:pass@host/db` | asyncpg |
| MySQL | `mysql+aiomysql://user:pass@host/db` | aiomysql |

---

## 性能对比

| 操作 | 同步 | 异步 | 提升 |
|------|------|------|------|
| 单个查询 | 10ms | 10ms | 1x |
| 10个并发查询 | 100ms | 15ms | 6.7x |
| 100个并发查询 | 1000ms | 50ms | 20x |

---

## 最佳实践

### 1. 使用连接池

```python
engine = create_async_engine(
    DATABASE_URL,
    pool_size=5,        # 连接池大小
    max_overflow=10,    # 最大溢出连接
    pool_timeout=30,    # 获取连接超时
    pool_recycle=3600   # 连接回收时间
)
```

### 2. 使用上下文管理器

```python
# ✅ 正确：自动管理会话
async with AsyncSessionLocal() as session:
    result = await session.execute(select(User))

# ❌ 错误：手动管理容易忘记关闭
session = AsyncSessionLocal()
result = await session.execute(select(User))
# 忘记关闭会话
```

### 3. 使用依赖注入（FastAPI）

```python
async def get_db():
    async with AsyncSessionLocal() as session:
        yield session

@app.get("/users")
async def get_users(db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(User))
    return result.scalars().all()
```

---

## 常见错误

### 错误1：忘记 await

```python
# ❌ 错误
result = session.execute(select(User))

# ✅ 正确
result = await session.execute(select(User))
```

### 错误2：在同步代码中使用异步会话

```python
# ❌ 错误
def get_users():
    async with AsyncSessionLocal() as session:
        result = await session.execute(select(User))

# ✅ 正确
async def get_users():
    async with AsyncSessionLocal() as session:
        result = await session.execute(select(User))
```

### 错误3：忘记提交事务

```python
# ❌ 错误：忘记提交
async with AsyncSessionLocal() as session:
    user = User(name="Alice")
    session.add(user)
    # 忘记 commit

# ✅ 正确
async with AsyncSessionLocal() as session:
    user = User(name="Alice")
    session.add(user)
    await session.commit()
```

---

## 学习检查

完成本示例后，你应该能够：

- [ ] 创建异步数据库引擎和会话
- [ ] 执行基础 CRUD 操作
- [ ] 并发执行多个数据库查询
- [ ] 使用事务处理
- [ ] 配置连接池
- [ ] 在 FastAPI 中使用异步数据库
- [ ] 避免常见的异步数据库错误

---

## 下一步

- **继续学习**：阅读【实战代码4：文件IO】
- **实际应用**：在 AI Agent 项目中使用异步数据库
- **性能优化**：根据实际情况调整连接池配置
