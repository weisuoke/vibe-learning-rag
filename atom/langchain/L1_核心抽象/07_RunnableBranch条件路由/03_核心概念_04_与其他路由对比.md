# 核心概念4：与其他路由对比

深入理解 RunnableBranch 与其他路由方式的区别和选择标准。

---

## 4.1 路由方式概览

LangChain 提供了多种路由方式，每种都有其适用场景：

| 路由方式 | 核心特点 | 适用场景 |
|----------|----------|----------|
| **if-else** | 命令式控制流 | 简单逻辑，不需要组合 |
| **RunnableBranch** | 声明式条件路由 | 需要组合和可观测性 |
| **RouterRunnable** | 键值映射路由 | 固定的路由表 |
| **RunnableLambda** | 自定义路由逻辑 | 复杂的动态路由 |
| **Agent** | 智能决策路由 | 需要推理和规划 |

---

## 4.2 vs RouterRunnable（键值路由）

### RouterRunnable 简介

**RouterRunnable**：基于键值映射的路由，类似 switch-case。

```python
from langchain_core.runnables import RouterRunnable

# 定义路由表
routes = {
    "code": code_handler,
    "math": math_handler,
    "general": general_handler
}

# 创建 Router
router = RouterRunnable(routes)

# 使用：输入必须包含路由键
result = router.invoke({"key": "code", "data": "..."})
```

### 核心区别

#### 区别1：路由决策方式

**RunnableBranch**：基于条件函数
```python
# 动态评估条件
branch = RunnableBranch(
    (lambda x: "code" in x["text"], code_handler),
    (lambda x: "math" in x["text"], math_handler),
    general_handler
)

# 输入不需要显式指定路由键
result = branch.invoke({"text": "Write a Python function"})
```

**RouterRunnable**：基于键值查找
```python
# 静态键值映射
router = RouterRunnable({
    "code": code_handler,
    "math": math_handler,
    "general": general_handler
})

# 输入必须包含路由键
result = router.invoke({"key": "code", "data": "..."})
```

#### 区别2：灵活性

**RunnableBranch**：
- ✅ 条件可以是任意复杂的逻辑
- ✅ 可以使用 LLM 做语义判断
- ✅ 支持顺序优先级

**RouterRunnable**：
- ❌ 只能基于固定的键
- ❌ 需要预先知道路由键
- ✅ 查找速度快（O(1)）

#### 区别3：默认处理

**RunnableBranch**：
- 必须提供默认分支
- 默认分支是最后一个参数

**RouterRunnable**：
- 可以指定默认路由
- 如果没有默认路由且键不存在，会报错

### 何时使用 RouterRunnable

**适合**：
- 路由键是固定的、已知的
- 路由表是静态的
- 需要快速查找（O(1)）

**示例场景**：
```python
# API 端点路由
api_router = RouterRunnable({
    "/users": users_handler,
    "/orders": orders_handler,
    "/products": products_handler
})

# 语言路由（已知语言代码）
language_router = RouterRunnable({
    "en": english_handler,
    "zh": chinese_handler,
    "ja": japanese_handler
})
```

### 何时使用 RunnableBranch

**适合**：
- 需要动态条件判断
- 路由逻辑复杂
- 需要优先级排序

**示例场景**：
```python
# 意图识别（需要语义判断）
intent_branch = RunnableBranch(
    (lambda x: "urgent" in x.lower(), urgent_handler),
    (lambda x: "?" in x, question_handler),
    general_handler
)

# 多条件组合
complex_branch = RunnableBranch(
    (lambda x: x["score"] > 0.8 and x["is_vip"], premium_handler),
    (lambda x: x["score"] > 0.5, standard_handler),
    basic_handler
)
```

---

## 4.3 vs RunnableLambda（自定义路由）

### RunnableLambda 简介

**RunnableLambda**：将任意 Python 函数包装成 Runnable。

```python
from langchain_core.runnables import RunnableLambda

def custom_router(x):
    """自定义路由逻辑"""
    if "code" in x["text"]:
        return code_handler.invoke(x)
    elif "math" in x["text"]:
        return math_handler.invoke(x)
    else:
        return general_handler.invoke(x)

router = RunnableLambda(custom_router)
```

### 核心区别

#### 区别1：表达方式

**RunnableBranch**：声明式
```python
# 清晰展示所有分支
branch = RunnableBranch(
    (condition1, handler1),
    (condition2, handler2),
    (condition3, handler3),
    default_handler
)
```

**RunnableLambda**：命令式
```python
# 逻辑集中在函数中
def router(x):
    if condition1(x):
        return handler1.invoke(x)
    elif condition2(x):
        return handler2.invoke(x)
    elif condition3(x):
        return handler3.invoke(x)
    else:
        return default_handler.invoke(x)

router = RunnableLambda(router)
```

#### 区别2：灵活性

**RunnableBranch**：
- ❌ 只能表达简单的条件路由
- ❌ 不能包含复杂的中间计算
- ✅ 结构清晰，易于维护

**RunnableLambda**：
- ✅ 可以包含任意 Python 代码
- ✅ 可以做复杂的中间计算
- ✅ 可以动态选择 handler
- ⚠️ 可能过于灵活，难以维护

#### 区别3：可读性

**RunnableBranch**：
```python
# 一眼看出所有分支
branch = RunnableBranch(
    (is_urgent, urgent_handler),
    (is_high_priority, high_priority_handler),
    (is_normal, normal_handler),
    default_handler
)
```

**RunnableLambda**：
```python
# 需要阅读函数体才能理解
def complex_router(x):
    # 复杂的逻辑
    score = calculate_score(x)
    context = get_context(x)

    if score > 0.8 and context["urgent"]:
        return urgent_handler.invoke(x)
    elif score > 0.5:
        handler = select_best_handler(x, context)
        return handler.invoke(x)
    else:
        return default_handler.invoke(x)

router = RunnableLambda(complex_router)
```

### 何时使用 RunnableLambda

**适合**：
- 需要复杂的路由逻辑
- 需要中间计算或状态管理
- 需要动态选择 handler
- 需要与非 LangChain 代码集成

**示例场景**：
```python
# 复杂的多步路由
def multi_step_router(x):
    # 1. 预处理
    processed = preprocess(x)

    # 2. 获取上下文
    context = fetch_context(processed["user_id"])

    # 3. 计算分数
    score = calculate_confidence(processed, context)

    # 4. 动态选择 handler
    if score > 0.8 and context["is_premium"]:
        handler = premium_handlers[context["preferred_model"]]
    elif score > 0.5:
        handler = standard_handler
    else:
        handler = fallback_handler

    # 5. 执行
    return handler.invoke(processed)

router = RunnableLambda(multi_step_router)
```

### 何时使用 RunnableBranch

**适合**：
- 路由逻辑简单清晰
- 分支数量有限（< 10）
- 强调声明式风格
- 团队熟悉 LangChain

**示例场景**：
```python
# 简单的条件路由
branch = RunnableBranch(
    (lambda x: x["type"] == "A", handler_a),
    (lambda x: x["type"] == "B", handler_b),
    (lambda x: x["type"] == "C", handler_c),
    default_handler
)
```

### 2025-2026 官方推荐

**LangChain 官方态度**：
- **新项目**：优先考虑 RunnableLambda（更灵活，更符合 Python 习惯）
- **简单场景**：RunnableBranch 仍然是好选择（清晰、易维护）
- **现有项目**：不强制迁移，根据实际需求选择

**原因**：
1. RunnableLambda 减少了框架特定 API 的学习成本
2. 更容易与现有 Python 代码集成
3. 更灵活，适应性更强

---

## 4.4 vs Agent（智能路由）

### Agent 简介

**Agent**：使用 LLM 做智能决策，动态选择工具和执行路径。

```python
from langchain.agents import create_openai_functions_agent
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# 定义工具
tools = [code_tool, math_tool, search_tool]

# 创建 Agent
agent = create_openai_functions_agent(
    llm=ChatOpenAI(model="gpt-4"),
    tools=tools,
    prompt=ChatPromptTemplate.from_messages([...])
)

# Agent 会自动选择合适的工具
result = agent.invoke({"input": "Write a Python function"})
```

### 核心区别

#### 区别1：决策方式

**RunnableBranch**：基于规则
```python
# 预定义的条件规则
branch = RunnableBranch(
    (lambda x: "code" in x, code_handler),
    (lambda x: "math" in x, math_handler),
    general_handler
)
```

**Agent**：基于推理
```python
# LLM 推理决策
agent = create_openai_functions_agent(
    llm=ChatOpenAI(),
    tools=[code_tool, math_tool, general_tool],
    prompt=prompt
)
# Agent 会分析输入，推理出最合适的工具
```

#### 区别2：灵活性

**RunnableBranch**：
- ❌ 只能处理预定义的情况
- ❌ 无法处理新的、未见过的情况
- ✅ 行为可预测
- ✅ 成本低（不需要额外 LLM 调用）

**Agent**：
- ✅ 可以处理新的、未见过的情况
- ✅ 可以组合多个工具
- ✅ 可以多步推理
- ⚠️ 行为不完全可预测
- ⚠️ 成本高（需要 LLM 调用）

#### 区别3：复杂度

**RunnableBranch**：
- 简单的条件路由
- 一次决策，一次执行

**Agent**：
- 复杂的推理循环
- 可能多次决策和执行
- 支持工具调用链

### 何时使用 Agent

**适合**：
- 需要智能推理
- 需要组合多个工具
- 需要多步规划
- 输入多样化，难以预定义规则

**示例场景**：
```python
# 复杂的任务规划
# 用户："帮我分析这个 GitHub 仓库的代码质量，并生成报告"
# Agent 会：
# 1. 使用 GitHub API 工具获取代码
# 2. 使用代码分析工具分析质量
# 3. 使用报告生成工具生成报告
```

### 何时使用 RunnableBranch

**适合**：
- 路由逻辑明确
- 不需要推理
- 成本敏感
- 需要可预测的行为

**示例场景**：
```python
# 简单的意图路由
# 用户："我想退款"
# Branch 直接路由到退款处理器，不需要推理
```

### 性能和成本对比

| 维度 | RunnableBranch | Agent |
|------|----------------|-------|
| **延迟** | 低（毫秒级） | 高（秒级） |
| **成本** | 低（无额外 LLM 调用） | 高（需要 LLM 推理） |
| **可预测性** | 高 | 中 |
| **灵活性** | 低 | 高 |
| **适用场景** | 明确的路由规则 | 复杂的任务规划 |

---

## 4.5 综合对比表

### 功能对比

| 功能 | if-else | RunnableBranch | RouterRunnable | RunnableLambda | Agent |
|------|---------|----------------|----------------|----------------|-------|
| **LCEL 组合** | ❌ | ✅ | ✅ | ✅ | ✅ |
| **可观测性** | ❌ | ✅ | ✅ | ✅ | ✅ |
| **异步支持** | ⚠️ | ✅ | ✅ | ✅ | ✅ |
| **流式输出** | ❌ | ✅ | ✅ | ✅ | ✅ |
| **条件灵活性** | ✅ | ✅ | ❌ | ✅ | ✅ |
| **智能推理** | ❌ | ❌ | ❌ | ❌ | ✅ |
| **学习成本** | 低 | 中 | 中 | 低 | 高 |
| **执行成本** | 低 | 低 | 低 | 低 | 高 |

### 性能对比

| 维度 | if-else | RunnableBranch | RouterRunnable | RunnableLambda | Agent |
|------|---------|----------------|----------------|----------------|-------|
| **路由延迟** | 极低 | 低 | 极低 | 低 | 高 |
| **内存占用** | 极低 | 低 | 低 | 低 | 中 |
| **可扩展性** | 低 | 高 | 中 | 高 | 高 |

### 适用场景对比

| 场景 | 推荐方式 | 理由 |
|------|----------|------|
| **简单条件判断** | if-else | 最简单直接 |
| **需要 LCEL 组合** | RunnableBranch | 声明式，易维护 |
| **固定路由表** | RouterRunnable | O(1) 查找 |
| **复杂路由逻辑** | RunnableLambda | 最灵活 |
| **需要智能推理** | Agent | 唯一选择 |
| **成本敏感** | RunnableBranch | 无额外 LLM 调用 |
| **新项目** | RunnableLambda | 官方推荐 |
| **简单项目** | RunnableBranch | 清晰易懂 |

---

## 4.6 迁移指南

### 从 if-else 迁移到 RunnableBranch

**迁移前**：
```python
def process(input):
    if "code" in input["text"]:
        return code_handler.invoke(input)
    elif "math" in input["text"]:
        return math_handler.invoke(input)
    else:
        return general_handler.invoke(input)

# 使用
result = process(input)
```

**迁移后**：
```python
branch = RunnableBranch(
    (lambda x: "code" in x["text"], code_handler),
    (lambda x: "math" in x["text"], math_handler),
    general_handler
)

# 使用（可以与 LCEL 组合）
chain = preprocessor | branch | postprocessor
result = chain.invoke(input)
```

**优势**：
- ✅ 可以与 LCEL 组合
- ✅ 支持 LangSmith 追踪
- ✅ 支持异步和流式

### 从 RunnableBranch 迁移到 RunnableLambda

**迁移前**：
```python
branch = RunnableBranch(
    (lambda x: x["score"] > 0.8, high_handler),
    (lambda x: x["score"] > 0.5, medium_handler),
    low_handler
)
```

**迁移后**：
```python
def smart_router(x):
    score = x["score"]
    if score > 0.8:
        return high_handler.invoke(x)
    elif score > 0.5:
        return medium_handler.invoke(x)
    else:
        return low_handler.invoke(x)

router = RunnableLambda(smart_router)
```

**何时迁移**：
- 需要更复杂的路由逻辑
- 需要中间计算
- 需要动态选择 handler

### 从 RouterRunnable 迁移到 RunnableBranch

**迁移前**：
```python
router = RouterRunnable({
    "code": code_handler,
    "math": math_handler,
    "general": general_handler
})

# 需要显式提供路由键
result = router.invoke({"key": "code", "data": "..."})
```

**迁移后**：
```python
branch = RunnableBranch(
    (lambda x: x.get("key") == "code", code_handler),
    (lambda x: x.get("key") == "math", math_handler),
    general_handler
)

# 可以基于任意条件路由
result = branch.invoke({"key": "code", "data": "..."})
```

**何时迁移**：
- 需要更灵活的条件判断
- 路由键不是固定的
- 需要优先级排序

---

## 4.7 选择决策树

```
需要路由吗？
├─ 否 → 不需要路由
└─ 是 → 继续

需要智能推理吗？
├─ 是 → Agent
└─ 否 → 继续

需要与 LCEL 组合吗？
├─ 否 → if-else
└─ 是 → 继续

路由键是固定的吗？
├─ 是 → RouterRunnable
└─ 否 → 继续

路由逻辑复杂吗？
├─ 是 → RunnableLambda
└─ 否 → RunnableBranch

是新项目吗？
├─ 是 → RunnableLambda（官方推荐）
└─ 否 → RunnableBranch（简单清晰）
```

---

## 4.8 实际案例对比

### 案例1：意图识别

**场景**：根据用户输入识别意图并路由

#### 方案1：RunnableBranch（推荐）
```python
intent_branch = RunnableBranch(
    (lambda x: any(w in x.lower() for w in ["hi", "hello"]), greeting_handler),
    (lambda x: x.strip().endswith("?"), question_handler),
    (lambda x: "help" in x.lower(), help_handler),
    general_handler
)
```

**优点**：清晰、简单、高效

#### 方案2：RunnableLambda
```python
def intent_router(x):
    text = x.lower()
    if any(w in text for w in ["hi", "hello"]):
        return greeting_handler.invoke(x)
    elif x.strip().endswith("?"):
        return question_handler.invoke(x)
    elif "help" in text:
        return help_handler.invoke(x)
    else:
        return general_handler.invoke(x)

router = RunnableLambda(intent_router)
```

**优点**：更灵活，可以添加复杂逻辑

#### 方案3：Agent
```python
agent = create_openai_functions_agent(
    llm=ChatOpenAI(),
    tools=[greeting_tool, question_tool, help_tool],
    prompt=intent_prompt
)
```

**缺点**：过度设计，成本高

**推荐**：RunnableBranch（简单高效）

---

### 案例2：多条件优先级路由

**场景**：VIP 用户的紧急请求优先级最高

#### 方案1：RunnableBranch（推荐）
```python
priority_branch = RunnableBranch(
    (lambda x: x["is_vip"] and x["is_urgent"], vip_urgent_handler),
    (lambda x: x["is_urgent"], urgent_handler),
    (lambda x: x["is_vip"], vip_handler),
    normal_handler
)
```

**优点**：优先级清晰，易于维护

#### 方案2：RunnableLambda
```python
def priority_router(x):
    if x["is_vip"] and x["is_urgent"]:
        return vip_urgent_handler.invoke(x)
    elif x["is_urgent"]:
        return urgent_handler.invoke(x)
    elif x["is_vip"]:
        return vip_handler.invoke(x)
    else:
        return normal_handler.invoke(x)

router = RunnableLambda(priority_router)
```

**优点**：逻辑集中

**推荐**：RunnableBranch（声明式更清晰）

---

### 案例3：复杂的动态路由

**场景**：根据用户画像、上下文、历史记录动态选择模型

#### 方案1：RunnableLambda（推荐）
```python
def smart_model_router(x):
    # 1. 获取用户画像
    profile = get_user_profile(x["user_id"])

    # 2. 获取上下文
    context = get_conversation_context(x["session_id"])

    # 3. 计算复杂度分数
    complexity = calculate_complexity(x["text"], context)

    # 4. 动态选择模型
    if profile["is_premium"] and complexity > 0.8:
        model = "gpt-4"
    elif complexity > 0.5:
        model = "gpt-4o"
    else:
        model = "gpt-4o-mini"

    # 5. 创建 handler
    handler = ChatOpenAI(model=model)

    # 6. 执行
    return handler.invoke(x)

router = RunnableLambda(smart_model_router)
```

**优点**：最灵活，可以包含任意逻辑

#### 方案2：RunnableBranch
```python
# ❌ 不适合：条件太复杂，难以表达
branch = RunnableBranch(
    (lambda x: get_user_profile(x["user_id"])["is_premium"] and
               calculate_complexity(x["text"], get_conversation_context(x["session_id"])) > 0.8,
     gpt4_handler),
    # ... 太复杂了
)
```

**缺点**：条件太复杂，难以维护

**推荐**：RunnableLambda（复杂逻辑的唯一选择）

---

## 4.9 2025-2026 迁移建议

### 官方态度

**LangChain 官方（2025-2026）**：
- RunnableBranch 标记为 "legacy"（遗留）
- 推荐新项目使用 RunnableLambda
- 不强制迁移现有代码

### 迁移策略

#### 策略1：新项目
```python
# ✅ 推荐：使用 RunnableLambda
def router(x):
    if condition1(x):
        return handler1.invoke(x)
    elif condition2(x):
        return handler2.invoke(x)
    else:
        return default_handler.invoke(x)

router = RunnableLambda(router)
```

#### 策略2：现有项目
```python
# ✅ 保持：如果 RunnableBranch 工作良好，不需要迁移
branch = RunnableBranch(
    (condition1, handler1),
    (condition2, handler2),
    default_handler
)
```

#### 策略3：混合使用
```python
# ✅ 灵活：根据场景选择
# 简单路由：RunnableBranch
simple_branch = RunnableBranch(...)

# 复杂路由：RunnableLambda
complex_router = RunnableLambda(...)

# 组合使用
chain = preprocessor | simple_branch | complex_router | postprocessor
```

### 迁移时机

**立即迁移**：
- 需要复杂的路由逻辑
- 需要中间计算
- 需要动态选择 handler

**暂不迁移**：
- 现有代码工作良好
- 路由逻辑简单
- 团队熟悉 RunnableBranch

**永不迁移**：
- 如果 RunnableBranch 更清晰易懂
- 如果团队偏好声明式风格

---

## 4.10 小结

**选择路由方式的关键因素**：

1. **复杂度**：
   - 简单 → RunnableBranch
   - 复杂 → RunnableLambda
   - 需要推理 → Agent

2. **组合性**：
   - 需要 LCEL → RunnableBranch/RunnableLambda
   - 不需要 → if-else

3. **性能**：
   - 固定键 → RouterRunnable（O(1)）
   - 条件判断 → RunnableBranch（O(n)）

4. **成本**：
   - 成本敏感 → RunnableBranch
   - 需要智能 → Agent

5. **团队**：
   - 熟悉 LangChain → RunnableBranch
   - 熟悉 Python → RunnableLambda

6. **趋势**：
   - 新项目 → RunnableLambda（官方推荐）
   - 简单场景 → RunnableBranch（仍然好用）

**记住**：没有"最好"的路由方式，只有"最合适"的路由方式。根据实际需求选择，不要盲目追新或固守旧方式。

---

**下一步**：学习实战代码示例（实战代码1-3）。
