# 实战代码

完整可运行的混合检索示例，从零搭建一个生产可用的混合检索系统。

---

## 环境准备

```bash
# 安装依赖
pip install rank-bm25 chromadb jieba openai python-dotenv
```

```python
# .env 文件（如果使用 OpenAI Embedding）
OPENAI_API_KEY=your_api_key_here
```

---

## 完整实战代码

```python
"""
混合检索策略 实战示例
演示：BM25 + 向量检索 + RRF 融合的完整实现

运行环境：Python 3.9+
依赖：pip install rank-bm25 chromadb jieba
"""

import jieba
from rank_bm25 import BM25Okapi
import chromadb
from typing import List, Tuple, Dict
from dataclasses import dataclass


# ===== 1. 数据准备 =====
print("=" * 60)
print("1. 准备测试文档")
print("=" * 60)

# 模拟 RAG 知识库文档
documents = [
    {
        "id": "doc_001",
        "content": "Python asyncio 是 Python 3.4 引入的异步 IO 框架，用于编写并发代码。",
        "metadata": {"category": "Python", "topic": "异步编程"}
    },
    {
        "id": "doc_002",
        "content": "使用 async/await 语法可以让异步代码看起来像同步代码，提高可读性。",
        "metadata": {"category": "Python", "topic": "异步编程"}
    },
    {
        "id": "doc_003",
        "content": "Python 多线程受 GIL 限制，对于 CPU 密集型任务应该使用多进程。",
        "metadata": {"category": "Python", "topic": "并发"}
    },
    {
        "id": "doc_004",
        "content": "性能优化的第一步是找到瓶颈，可以使用 cProfile 或 line_profiler 进行分析。",
        "metadata": {"category": "Python", "topic": "性能"}
    },
    {
        "id": "doc_005",
        "content": "代码执行速度慢的常见原因包括：算法复杂度高、IO 阻塞、内存泄漏等。",
        "metadata": {"category": "Python", "topic": "性能"}
    },
    {
        "id": "doc_006",
        "content": "JavaScript 的 Promise 和 async/await 是处理异步操作的现代方式。",
        "metadata": {"category": "JavaScript", "topic": "异步编程"}
    },
    {
        "id": "doc_007",
        "content": "Python 3.12 引入了更快的解释器和改进的错误消息。",
        "metadata": {"category": "Python", "topic": "版本更新"}
    },
    {
        "id": "doc_008",
        "content": "如何让程序运行更快？首先要测量，然后针对热点进行优化。",
        "metadata": {"category": "通用", "topic": "性能"}
    },
]

print(f"加载了 {len(documents)} 个文档")
for doc in documents[:3]:
    print(f"  - {doc['id']}: {doc['content'][:30]}...")


# ===== 2. BM25 检索器 =====
print("\n" + "=" * 60)
print("2. 构建 BM25 检索器")
print("=" * 60)


class BM25Retriever:
    """BM25 关键词检索器"""

    def __init__(self, documents: List[Dict]):
        self.documents = documents
        self.doc_ids = [doc["id"] for doc in documents]
        self.doc_contents = [doc["content"] for doc in documents]

        # 中文分词
        print("  正在进行中文分词...")
        self.tokenized_docs = [list(jieba.cut(doc)) for doc in self.doc_contents]

        # 构建 BM25 索引
        print("  正在构建 BM25 索引...")
        self.bm25 = BM25Okapi(self.tokenized_docs)
        print("  BM25 索引构建完成")

    def search(self, query: str, top_k: int = 5) -> List[Tuple[str, float]]:
        """
        搜索并返回 (doc_id, score) 列表
        """
        tokenized_query = list(jieba.cut(query))
        scores = self.bm25.get_scores(tokenized_query)

        # 组合 doc_id 和分数，排序
        doc_scores = list(zip(self.doc_ids, scores))
        doc_scores.sort(key=lambda x: x[1], reverse=True)

        return doc_scores[:top_k]


bm25_retriever = BM25Retriever(documents)

# 测试 BM25
print("\n测试 BM25 检索：")
query = "Python 异步编程"
results = bm25_retriever.search(query, top_k=3)
for doc_id, score in results:
    print(f"  {doc_id}: {score:.2f}")


# ===== 3. 向量检索器 =====
print("\n" + "=" * 60)
print("3. 构建向量检索器")
print("=" * 60)


class VectorRetriever:
    """向量语义检索器（使用 ChromaDB）"""

    def __init__(self, documents: List[Dict], collection_name: str = "rag_docs"):
        self.documents = documents
        self.doc_ids = [doc["id"] for doc in documents]

        # 初始化 ChromaDB
        print("  正在初始化 ChromaDB...")
        self.client = chromadb.Client()

        # 创建集合（ChromaDB 会自动生成 Embedding）
        self.collection = self.client.create_collection(
            name=collection_name,
            metadata={"hnsw:space": "cosine"}  # 使用余弦相似度
        )

        # 添加文档
        print("  正在添加文档到向量库...")
        self.collection.add(
            ids=self.doc_ids,
            documents=[doc["content"] for doc in documents],
            metadatas=[doc["metadata"] for doc in documents]
        )
        print(f"  向量库构建完成，共 {self.collection.count()} 个文档")

    def search(self, query: str, top_k: int = 5) -> List[Tuple[str, float]]:
        """
        搜索并返回 (doc_id, distance) 列表
        注意：ChromaDB 返回的是距离，越小越相似
        """
        results = self.collection.query(
            query_texts=[query],
            n_results=top_k
        )

        doc_ids = results["ids"][0]
        distances = results["distances"][0]

        # 转换为 (doc_id, similarity) 格式
        # 余弦距离转相似度：similarity = 1 - distance
        return [(doc_id, 1 - dist) for doc_id, dist in zip(doc_ids, distances)]


vector_retriever = VectorRetriever(documents)

# 测试向量检索
print("\n测试向量检索：")
query = "如何让代码跑得更快"
results = vector_retriever.search(query, top_k=3)
for doc_id, score in results:
    print(f"  {doc_id}: {score:.3f}")


# ===== 4. RRF 融合 =====
print("\n" + "=" * 60)
print("4. 实现 RRF 融合")
print("=" * 60)


def reciprocal_rank_fusion(
    results_list: List[List[Tuple[str, float]]],
    k: int = 60
) -> List[Tuple[str, float]]:
    """
    倒数排名融合 (Reciprocal Rank Fusion)

    参数：
    - results_list: 多个检索器的结果，每个是 [(doc_id, score), ...] 列表
    - k: 平滑参数，默认 60（论文推荐值）

    返回：
    - 融合后的 [(doc_id, rrf_score), ...] 列表，按分数降序
    """
    rrf_scores: Dict[str, float] = {}

    for results in results_list:
        for rank, (doc_id, _) in enumerate(results, 1):
            if doc_id not in rrf_scores:
                rrf_scores[doc_id] = 0
            rrf_scores[doc_id] += 1 / (k + rank)

    # 按 RRF 分数排序
    sorted_results = sorted(rrf_scores.items(), key=lambda x: x[1], reverse=True)
    return sorted_results


print("RRF 融合函数已定义")


# ===== 5. 混合检索器 =====
print("\n" + "=" * 60)
print("5. 构建混合检索器")
print("=" * 60)


@dataclass
class SearchResult:
    """检索结果"""
    doc_id: str
    content: str
    score: float
    metadata: Dict


class HybridRetriever:
    """混合检索器：BM25 + 向量检索 + RRF 融合"""

    def __init__(self, documents: List[Dict]):
        self.documents = documents
        self.id_to_doc = {doc["id"]: doc for doc in documents}

        # 初始化两个检索器
        self.bm25 = BM25Retriever(documents)
        self.vector = VectorRetriever(documents)

    def search(
        self,
        query: str,
        top_k: int = 5,
        bm25_candidates: int = 10,
        vector_candidates: int = 10
    ) -> List[SearchResult]:
        """
        混合检索

        参数：
        - query: 查询文本
        - top_k: 返回结果数量
        - bm25_candidates: BM25 召回数量
        - vector_candidates: 向量召回数量
        """
        # 1. BM25 检索
        bm25_results = self.bm25.search(query, top_k=bm25_candidates)

        # 2. 向量检索
        vector_results = self.vector.search(query, top_k=vector_candidates)

        # 3. RRF 融合
        fused_results = reciprocal_rank_fusion([bm25_results, vector_results])

        # 4. 构建返回结果
        search_results = []
        for doc_id, score in fused_results[:top_k]:
            doc = self.id_to_doc[doc_id]
            search_results.append(SearchResult(
                doc_id=doc_id,
                content=doc["content"],
                score=score,
                metadata=doc["metadata"]
            ))

        return search_results

    def search_with_debug(
        self,
        query: str,
        top_k: int = 5
    ) -> Dict:
        """
        带调试信息的混合检索
        """
        bm25_results = self.bm25.search(query, top_k=10)
        vector_results = self.vector.search(query, top_k=10)
        fused_results = reciprocal_rank_fusion([bm25_results, vector_results])

        return {
            "query": query,
            "bm25_results": bm25_results[:5],
            "vector_results": vector_results[:5],
            "fused_results": fused_results[:top_k],
            "final_results": [
                self.id_to_doc[doc_id]["content"]
                for doc_id, _ in fused_results[:top_k]
            ]
        }


hybrid_retriever = HybridRetriever(documents)
print("混合检索器构建完成")


# ===== 6. 测试不同类型的查询 =====
print("\n" + "=" * 60)
print("6. 测试不同类型的查询")
print("=" * 60)

test_queries = [
    ("精确术语查询", "Python asyncio"),
    ("自然语言查询", "如何让代码跑得更快"),
    ("版本相关查询", "Python 3.12"),
    ("跨概念查询", "异步编程性能优化"),
]

for query_type, query in test_queries:
    print(f"\n【{query_type}】: \"{query}\"")
    print("-" * 50)

    debug_info = hybrid_retriever.search_with_debug(query, top_k=3)

    print("BM25 Top-3:")
    for doc_id, score in debug_info["bm25_results"][:3]:
        print(f"  {doc_id}: {score:.2f}")

    print("向量 Top-3:")
    for doc_id, score in debug_info["vector_results"][:3]:
        print(f"  {doc_id}: {score:.3f}")

    print("融合 Top-3:")
    for doc_id, score in debug_info["fused_results"][:3]:
        content = hybrid_retriever.id_to_doc[doc_id]["content"][:40]
        print(f"  {doc_id}: {score:.4f} - {content}...")


# ===== 7. 对比实验：单一检索 vs 混合检索 =====
print("\n" + "=" * 60)
print("7. 对比实验：单一检索 vs 混合检索")
print("=" * 60)


def compare_retrieval_methods(query: str, relevant_doc_ids: List[str]):
    """
    对比不同检索方法的召回效果

    参数：
    - query: 查询
    - relevant_doc_ids: 人工标注的相关文档 ID
    """
    print(f"\n查询: \"{query}\"")
    print(f"相关文档: {relevant_doc_ids}")
    print("-" * 50)

    # BM25 检索
    bm25_results = [doc_id for doc_id, _ in bm25_retriever.search(query, top_k=5)]
    bm25_recall = len(set(bm25_results) & set(relevant_doc_ids)) / len(relevant_doc_ids)

    # 向量检索
    vector_results = [doc_id for doc_id, _ in vector_retriever.search(query, top_k=5)]
    vector_recall = len(set(vector_results) & set(relevant_doc_ids)) / len(relevant_doc_ids)

    # 混合检索
    hybrid_results = [r.doc_id for r in hybrid_retriever.search(query, top_k=5)]
    hybrid_recall = len(set(hybrid_results) & set(relevant_doc_ids)) / len(relevant_doc_ids)

    print(f"BM25 召回率:   {bm25_recall:.0%} - 召回: {set(bm25_results) & set(relevant_doc_ids)}")
    print(f"向量召回率:    {vector_recall:.0%} - 召回: {set(vector_results) & set(relevant_doc_ids)}")
    print(f"混合召回率:    {hybrid_recall:.0%} - 召回: {set(hybrid_results) & set(relevant_doc_ids)}")

    return bm25_recall, vector_recall, hybrid_recall


# 测试用例
test_cases = [
    ("Python 异步编程", ["doc_001", "doc_002"]),
    ("如何提升代码性能", ["doc_004", "doc_005", "doc_008"]),
    ("Python 3.12 新特性", ["doc_007"]),
]

total_bm25, total_vector, total_hybrid = 0, 0, 0
for query, relevant_ids in test_cases:
    b, v, h = compare_retrieval_methods(query, relevant_ids)
    total_bm25 += b
    total_vector += v
    total_hybrid += h

print("\n" + "=" * 60)
print("平均召回率对比")
print("=" * 60)
n = len(test_cases)
print(f"BM25:   {total_bm25/n:.0%}")
print(f"向量:   {total_vector/n:.0%}")
print(f"混合:   {total_hybrid/n:.0%}")


# ===== 8. RAG 应用示例 =====
print("\n" + "=" * 60)
print("8. RAG 应用示例")
print("=" * 60)


def simple_rag_answer(query: str, retriever: HybridRetriever) -> str:
    """
    简单的 RAG 问答（模拟，不调用 LLM）
    """
    # 1. 检索相关文档
    results = retriever.search(query, top_k=3)

    # 2. 构建上下文
    context = "\n".join([
        f"[{i+1}] {r.content}"
        for i, r in enumerate(results)
    ])

    # 3. 构建 Prompt（实际应用中会发送给 LLM）
    prompt = f"""基于以下参考资料回答问题：

参考资料：
{context}

问题：{query}

回答："""

    print(f"查询: {query}")
    print(f"\n检索到的文档:")
    for i, r in enumerate(results):
        print(f"  [{i+1}] {r.doc_id}: {r.content[:50]}...")
    print(f"\n生成的 Prompt 长度: {len(prompt)} 字符")

    return prompt


# 测试 RAG
query = "Python 中如何进行异步编程？"
prompt = simple_rag_answer(query, hybrid_retriever)


print("\n" + "=" * 60)
print("实战代码演示完成！")
print("=" * 60)
```

---

## 运行输出示例

```
============================================================
1. 准备测试文档
============================================================
加载了 8 个文档
  - doc_001: Python asyncio 是 Python 3.4...
  - doc_002: 使用 async/await 语法可以让异步代码看...
  - doc_003: Python 多线程受 GIL 限制，对于 CPU...

============================================================
2. 构建 BM25 检索器
============================================================
  正在进行中文分词...
  正在构建 BM25 索引...
  BM25 索引构建完成

测试 BM25 检索：
  doc_001: 4.52
  doc_002: 2.31
  doc_003: 1.89

============================================================
6. 测试不同类型的查询
============================================================

【精确术语查询】: "Python asyncio"
--------------------------------------------------
BM25 Top-3:
  doc_001: 5.23
  doc_007: 1.45
  doc_003: 1.12
向量 Top-3:
  doc_001: 0.892
  doc_002: 0.834
  doc_006: 0.756
融合 Top-3:
  doc_001: 0.0323 - Python asyncio 是 Python 3.4 引入的异步...
  doc_002: 0.0161 - 使用 async/await 语法可以让异步代码看起来...
  doc_007: 0.0160 - Python 3.12 引入了更快的解释器和改进的错...

【自然语言查询】: "如何让代码跑得更快"
--------------------------------------------------
BM25 Top-3:
  doc_005: 2.34
  doc_008: 1.89
  doc_004: 1.23
向量 Top-3:
  doc_008: 0.912
  doc_004: 0.867
  doc_005: 0.845
融合 Top-3:
  doc_008: 0.0323 - 如何让程序运行更快？首先要测量，然后针对热...
  doc_005: 0.0322 - 代码执行速度慢的常见原因包括：算法复杂度高...
  doc_004: 0.0321 - 性能优化的第一步是找到瓶颈，可以使用 cPro...

============================================================
平均召回率对比
============================================================
BM25:   67%
向量:   78%
混合:   89%
```

---

## 关键代码解析

### 1. BM25 分词的重要性

```python
# 中文必须分词，否则 BM25 无法工作
tokenized_docs = [list(jieba.cut(doc)) for doc in documents]

# 英文可以简单按空格分词
# tokenized_docs = [doc.split() for doc in documents]
```

### 2. RRF 的 k 参数

```python
# k=60 是论文推荐值，适用于大多数场景
# k 越大，排名靠后的文档权重越接近
# k 越小，排名靠前的文档权重差异越大

def rrf_score(rank, k=60):
    return 1 / (k + rank)

# k=60 时：第1名=0.0164，第2名=0.0161，差异小
# k=1 时：第1名=0.5，第2名=0.33，差异大
```

### 3. 召回数量的设置

```python
# 混合检索时，每个检索器应该多召回一些
# 然后通过 RRF 融合后再截取 top_k

bm25_candidates = top_k * 2  # BM25 召回 2 倍
vector_candidates = top_k * 2  # 向量召回 2 倍
# 融合后取 top_k
```

---

**下一步：** [08_面试必问](./08_面试必问.md) - 混合检索的面试高频问题
