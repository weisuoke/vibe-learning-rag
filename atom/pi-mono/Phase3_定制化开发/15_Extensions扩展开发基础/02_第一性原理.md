# Extensions 扩展开发基础 - 第一性原理

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题，而不是通过类比或经验来推理。

在物理学中，第一性原理意味着从基本的物理定律（如牛顿定律、热力学定律）出发推导现象。在软件工程中，第一性原理意味着从最基础的计算机科学概念（如函数、数据结构、进程）出发理解系统。

**为什么需要第一性原理思维？**
- 避免被表面现象迷惑
- 理解事物的本质和边界
- 能够创新和突破现有模式
- 在遇到问题时能够从根本上解决

---

## Extensions 的第一性原理

### 1. 最基础的定义

**Extensions = 在运行时动态加载的代码模块，可以访问宿主程序的内部 API**

仅此而已！没有更基础的了。

拆解这个定义：
- **代码模块**：一段可执行的程序代码（TypeScript 函数）
- **运行时动态加载**：程序启动后可以加载，不需要重新编译宿主程序
- **访问内部 API**：可以调用宿主程序提供的接口（ExtensionAPI）

这就是 Extensions 的本质。所有其他特性（工具注册、事件监听、UI 定制）都是基于这个基础定义衍生出来的。

### 2. 为什么需要 Extensions？

**核心问题：如何在不修改源码的情况下扩展程序功能？**

#### 问题的根源

在软件开发中，我们经常遇到这样的困境：

```typescript
// pi-mono 核心代码（假设）
class CodingAgent {
  async executeTool(toolName: string, params: any) {
    if (toolName === "read") {
      return this.readFile(params);
    } else if (toolName === "write") {
      return this.writeFile(params);
    } else if (toolName === "bash") {
      return this.executeBash(params);
    }
    // 如果我想添加新工具怎么办？
    // 难道要修改这个核心代码吗？
  }
}
```

**传统解决方案的问题：**

1. **修改源码**
   - ❌ 需要理解整个代码库
   - ❌ 可能引入 bug
   - ❌ 难以维护和升级
   - ❌ 无法与上游同步

2. **Fork 项目**
   - ❌ 维护成本高
   - ❌ 无法享受上游更新
   - ❌ 社区分裂

3. **包装器模式**
   - ❌ 无法访问内部状态
   - ❌ 功能受限
   - ❌ 性能开销

**Extensions 的解决方案：**

```typescript
// pi-mono 核心代码（实际设计）
class CodingAgent {
  private extensions: Extension[] = [];
  private tools: Map<string, Tool> = new Map();

  // 提供扩展点
  registerExtension(extension: Extension) {
    this.extensions.push(extension);
    // 扩展可以注册新工具
    extension.init(this.getExtensionAPI());
  }

  async executeTool(toolName: string, params: any) {
    // 先查找扩展注册的工具
    const tool = this.tools.get(toolName);
    if (tool) {
      return tool.execute(params);
    }
    // 再执行内置工具
    return this.executeBuiltinTool(toolName, params);
  }
}
```

**Extensions 解决了什么？**
- ✅ 无需修改源码即可扩展功能
- ✅ 可以访问内部 API 和状态
- ✅ 保持与上游同步
- ✅ 社区可以共享扩展
- ✅ 用户可以定制自己的工作流

### 3. Extensions 的三层价值

#### 价值 1：开放封闭原则（Open-Closed Principle）

**定义**：软件实体应该对扩展开放，对修改封闭。

**在 Extensions 中的体现：**

```typescript
// 核心代码保持稳定（封闭）
export default function (pi: ExtensionAPI) {
  // 通过扩展添加新功能（开放）
  pi.registerTool({
    name: "custom_search",
    description: "Search using custom algorithm",
    parameters: Type.Object({
      query: Type.String(),
    }),
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      // 自定义搜索逻辑
      return { content: [...], details: {} };
    },
  });
}
```

**举例：安全防护**

不需要修改 pi-mono 的 bash 工具实现，只需添加一个扩展：

```typescript
// permission-gate.ts
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    if (event.toolName === "bash") {
      const cmd = event.input.command;
      if (cmd?.includes("rm -rf") || cmd?.includes("sudo")) {
        const ok = await ctx.ui.confirm(
          "Dangerous Command",
          `Allow: ${cmd}?`
        );
        if (!ok) {
          return { block: true, reason: "Blocked by user" };
        }
      }
    }
  });
}
```

**价值**：
- 核心代码保持简洁和稳定
- 用户可以根据需求添加功能
- 不同用户可以有不同的扩展组合

#### 价值 2：控制反转（Inversion of Control）

**定义**：框架调用用户代码，而不是用户代码调用框架。

**传统模式（用户控制）：**

```typescript
// 用户代码
import { CodingAgent } from "pi-mono";

const agent = new CodingAgent();
agent.run();

// 问题：用户无法介入 agent 的内部流程
```

**Extensions 模式（框架控制）：**

```typescript
// 框架代码
class CodingAgent {
  async executeTool(toolName: string, params: any) {
    // 1. 触发事件，让扩展有机会介入
    const result = await this.emitEvent("tool_call", {
      toolName,
      input: params,
    });

    // 2. 扩展可以阻止或修改
    if (result.block) {
      return { blocked: true, reason: result.reason };
    }

    // 3. 执行工具
    return this.executeToolInternal(toolName, params);
  }
}

// 用户扩展
export default function (pi: ExtensionAPI) {
  // 框架会在合适的时机调用这个回调
  pi.on("tool_call", async (event, ctx) => {
    // 用户代码可以介入流程
    console.log("Tool called:", event.toolName);
  });
}
```

**价值**：
- 用户可以在关键节点介入
- 框架保持对流程的控制
- 扩展之间可以协作

#### 价值 3：组合优于继承（Composition over Inheritance）

**继承模式的问题：**

```typescript
// 如果用继承来扩展
class MyCodingAgent extends CodingAgent {
  // 问题1：只能有一个父类
  // 问题2：必须理解父类的实现
  // 问题3：容易破坏父类的封装
  // 问题4：难以组合多个扩展
}
```

**Extensions 的组合模式：**

```typescript
// 可以同时加载多个扩展
pi --extension safety.ts \
   --extension git-integration.ts \
   --extension custom-tools.ts \
   --extension ui-theme.ts

// 每个扩展独立工作，互不干扰
// 扩展之间可以通过事件总线通信
```

**举例：多个扩展协作**

```typescript
// safety.ts - 安全防护
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    if (isDangerous(event)) {
      return { block: true, reason: "Safety check failed" };
    }
  });
}

// logging.ts - 日志记录
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    console.log(`[LOG] ${event.toolName}`, event.input);
  });
}

// metrics.ts - 性能监控
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    const start = Date.now();
    // 工具执行后会触发 tool_result 事件
    pi.on("tool_result", async (resultEvent, ctx) => {
      if (resultEvent.toolCallId === event.toolCallId) {
        const duration = Date.now() - start;
        console.log(`[METRICS] ${event.toolName} took ${duration}ms`);
      }
    });
  });
}
```

**价值**：
- 每个扩展职责单一
- 可以灵活组合
- 易于测试和维护
- 社区可以共享扩展

### 4. 从第一性原理推导 Extensions 的能力

让我们从最基础的定义出发，推导 Extensions 应该具备哪些能力。

#### 推理链 1：从"动态加载"到"热重载"

```
1. Extensions 是运行时动态加载的代码模块
   ↓
2. 既然可以在运行时加载，那么也应该可以在运行时卸载
   ↓
3. 卸载后重新加载 = 热重载
   ↓
4. 因此，Extensions 应该支持热重载（/reload 命令）
```

**实现：**

```typescript
// pi-mono 实现
class ExtensionManager {
  private extensions: Map<string, Extension> = new Map();

  async reload() {
    // 1. 卸载所有扩展
    for (const ext of this.extensions.values()) {
      await ext.dispose();
    }
    this.extensions.clear();

    // 2. 重新发现和加载扩展
    const extensionFiles = await this.discoverExtensions();
    for (const file of extensionFiles) {
      await this.loadExtension(file);
    }
  }
}
```

#### 推理链 2：从"访问内部 API"到"事件系统"

```
1. Extensions 可以访问宿主程序的内部 API
   ↓
2. 宿主程序的核心是事件驱动的（用户输入 → Agent 处理 → 工具调用 → 结果返回）
   ↓
3. Extensions 应该能够监听这些事件
   ↓
4. Extensions 应该能够在事件发生时执行自定义逻辑
   ↓
5. Extensions 应该能够修改或阻止事件的默认行为
   ↓
6. 因此，Extensions 需要一个强大的事件系统
```

**实现：**

```typescript
// ExtensionAPI 提供的事件系统
export default function (pi: ExtensionAPI) {
  // 监听事件
  pi.on("tool_call", async (event, ctx) => {
    // 可以阻止事件
    if (shouldBlock(event)) {
      return { block: true, reason: "..." };
    }

    // 可以修改事件
    return { transform: modifiedEvent };
  });

  // 监听多个事件
  pi.on("session_start", async (event, ctx) => { ... });
  pi.on("session_fork", async (event, ctx) => { ... });
  pi.on("agent_turn_start", async (event, ctx) => { ... });
}
```

#### 推理链 3：从"扩展功能"到"工具注册"

```
1. Extensions 的目的是扩展程序功能
   ↓
2. pi-mono 的核心功能是通过工具（tools）实现的
   ↓
3. 扩展功能 = 添加新工具
   ↓
4. 因此，Extensions 应该能够注册自定义工具
   ↓
5. 自定义工具应该与内置工具享有同等地位
   ↓
6. Agent 应该能够自动发现和使用自定义工具
```

**实现：**

```typescript
// 注册自定义工具
export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "custom_tool",
    label: "Custom Tool",
    description: "A custom tool for specific tasks",
    parameters: Type.Object({
      input: Type.String(),
    }),
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      // 自定义逻辑
      return {
        content: [{ type: "text", text: "Result" }],
        details: { /* 状态数据 */ },
      };
    },
  });
}
```

#### 推理链 4：从"用户交互"到"UI 定制"

```
1. Extensions 可能需要与用户交互（如确认危险操作）
   ↓
2. pi-mono 是一个 CLI 工具，有自己的 UI 系统（pi-tui）
   ↓
3. Extensions 应该能够使用 UI 系统与用户交互
   ↓
4. Extensions 应该能够定制 UI 的外观和行为
   ↓
5. 因此，Extensions 需要访问 UI API
```

**实现：**

```typescript
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 使用 UI API
    const ok = await ctx.ui.confirm("Title", "Message");
    const choice = await ctx.ui.select("Choose", ["A", "B", "C"]);
    ctx.ui.notify("Info", "info");

    // 定制 UI
    ctx.ui.setFooter(() => "Custom footer");
    ctx.ui.setHeader(() => "Custom header");
    ctx.ui.setWidget("above", () => "Widget above editor");
  });
}
```

#### 推理链 5：从"状态管理"到"Session 集成"

```
1. Extensions 可能需要维护状态（如 todo 列表）
   ↓
2. pi-mono 使用 Session 来管理对话历史和状态
   ↓
3. Session 支持分支（fork），每个分支有独立的历史
   ↓
4. Extensions 的状态也应该支持分支
   ↓
5. 状态应该存储在 Session 中，而不是外部文件
   ↓
6. 因此，Extensions 应该通过 tool result details 存储状态
```

**实现：**

```typescript
export default function (pi: ExtensionAPI) {
  let todos: Todo[] = [];

  // 从 Session 重建状态
  const reconstructState = (ctx: ExtensionContext) => {
    todos = [];
    for (const entry of ctx.sessionManager.getBranch()) {
      if (entry.type === "message" && entry.message.toolName === "todo") {
        const details = entry.message.details as TodoDetails;
        if (details) {
          todos = details.todos;
        }
      }
    }
  };

  // 在 Session 事件时重建状态
  pi.on("session_start", async (_, ctx) => reconstructState(ctx));
  pi.on("session_fork", async (_, ctx) => reconstructState(ctx));

  // 工具执行时保存状态到 details
  pi.registerTool({
    name: "todo",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      // 修改状态
      todos.push({ id: 1, text: "New todo", done: false });

      // 保存到 details（会被持久化到 Session）
      return {
        content: [{ type: "text", text: "Added todo" }],
        details: { todos: [...todos] }, // 关键：状态存储在这里
      };
    },
  });
}
```

#### 推理链 6：从"类型安全"到"TypeScript 优先"

```
1. Extensions 需要访问复杂的内部 API
   ↓
2. 复杂的 API 容易出错
   ↓
3. 类型系统可以在编译时捕获错误
   ↓
4. TypeScript 提供了强大的类型系统
   ↓
5. 因此，Extensions 应该使用 TypeScript
   ↓
6. ExtensionAPI 应该提供完整的类型定义
```

**实现：**

```typescript
// ExtensionAPI 的类型定义
export interface ExtensionAPI {
  registerTool(definition: ToolDefinition): void;
  registerCommand(name: string, config: CommandConfig): void;
  on<E extends EventType>(
    event: E,
    handler: EventHandler<E>
  ): void;
  // ... 更多类型安全的 API
}

// 用户编写扩展时有完整的类型提示
export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "my_tool",
    // TypeScript 会检查所有字段
    parameters: Type.Object({
      // TypeBox 提供运行时类型验证
      input: Type.String(),
    }),
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      // params 的类型是自动推导的
      // ctx 有完整的类型定义
      return {
        content: [{ type: "text", text: "..." }],
        details: {},
      };
    },
  });
}
```

### 5. 一句话总结第一性原理

**Extensions 是一种基于控制反转和事件驱动的插件系统，通过在运行时动态加载代码模块并提供类型安全的 API，实现了在不修改源码的情况下扩展和定制程序功能的能力。**

---

## 从第一性原理理解 Extensions 的设计决策

### 为什么使用 TypeScript 而不是 JavaScript？

**第一性原理分析：**

1. Extensions 需要访问复杂的 API（30+ 事件类型，40+ API 方法）
2. 复杂的 API 容易出错（拼写错误、参数类型错误、缺少必需字段）
3. 类型系统可以在编译时捕获这些错误
4. TypeScript 提供了强大的类型系统和 IDE 支持
5. 因此，TypeScript 是更好的选择

**实际效果：**

```typescript
// TypeScript - 编译时错误
pi.registerTool({
  name: "my_tool",
  // ❌ 编译错误：缺少 description 字段
  parameters: Type.Object({}),
  async execute() {
    // ❌ 编译错误：返回值类型不匹配
    return "wrong type";
  },
});

// JavaScript - 运行时错误
pi.registerTool({
  name: "my_tool",
  // ✅ 编译通过，但运行时可能出错
  async execute() {
    return "wrong type"; // 运行时才发现错误
  },
});
```

### 为什么使用事件系统而不是回调函数？

**第一性原理分析：**

1. Extensions 需要在多个时间点介入程序流程
2. 回调函数是一对一的（一个事件 → 一个回调）
3. 事件系统是一对多的（一个事件 → 多个监听器）
4. 多个 Extensions 可能需要监听同一个事件
5. 因此，事件系统是更好的选择

**对比：**

```typescript
// 回调模式 - 只能有一个处理器
class CodingAgent {
  onToolCall?: (event: ToolCallEvent) => void;

  async executeTool(toolName: string, params: any) {
    if (this.onToolCall) {
      this.onToolCall({ toolName, input: params });
    }
    // 问题：如果有多个扩展都想监听怎么办？
  }
}

// 事件模式 - 可以有多个监听器
class CodingAgent {
  private eventEmitter = new EventEmitter();

  async executeTool(toolName: string, params: any) {
    // 所有监听器都会被调用
    await this.eventEmitter.emit("tool_call", {
      toolName,
      input: params,
    });
  }
}
```

### 为什么状态存储在 tool result details 而不是外部文件？

**第一性原理分析：**

1. pi-mono 支持 Session 分支（fork）
2. 分支创建时，历史记录会被复制
3. 如果状态存储在外部文件，分支之间会共享状态
4. 这会导致状态不一致（分支 A 修改了状态，分支 B 也会看到）
5. 如果状态存储在 Session 中（tool result details），每个分支有独立的状态
6. 因此，状态应该存储在 tool result details

**对比：**

```typescript
// 外部文件 - 分支之间共享状态 ❌
export default function (pi: ExtensionAPI) {
  const todosFile = "~/.pi/todos.json";

  pi.registerTool({
    name: "todo",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      const todos = JSON.parse(fs.readFileSync(todosFile));
      todos.push(params.text);
      fs.writeFileSync(todosFile, JSON.stringify(todos));
      // 问题：如果 fork 了 session，两个分支会共享同一个文件
    },
  });
}

// tool result details - 每个分支独立状态 ✅
export default function (pi: ExtensionAPI) {
  let todos: Todo[] = [];

  // 从 Session 重建状态
  pi.on("session_fork", async (_, ctx) => {
    todos = [];
    for (const entry of ctx.sessionManager.getBranch()) {
      if (entry.type === "message" && entry.message.toolName === "todo") {
        todos = entry.message.details.todos;
      }
    }
  });

  pi.registerTool({
    name: "todo",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      todos.push(params.text);
      // 状态保存在 details，会被持久化到 Session
      return {
        content: [{ type: "text", text: "Added" }],
        details: { todos: [...todos] },
      };
    },
  });
}
```

### 为什么支持热重载而不是重启？

**第一性原理分析：**

1. 开发 Extensions 需要频繁修改代码
2. 每次修改都重启 pi 会丢失当前的 Session 状态
3. 丢失状态会打断开发流程
4. 热重载可以在不丢失状态的情况下更新代码
5. 因此，热重载是更好的选择

**实现：**

```typescript
// pi-mono 的热重载实现
class ExtensionManager {
  async reload() {
    // 1. 保存当前状态
    const currentState = this.saveState();

    // 2. 卸载所有扩展
    for (const ext of this.extensions.values()) {
      await ext.dispose();
    }

    // 3. 清除模块缓存（Node.js）
    for (const key of Object.keys(require.cache)) {
      if (key.includes("/extensions/")) {
        delete require.cache[key];
      }
    }

    // 4. 重新加载扩展
    await this.loadAllExtensions();

    // 5. 恢复状态
    this.restoreState(currentState);
  }
}
```

---

## 总结

从第一性原理出发，我们理解了：

1. **Extensions 的本质**：运行时动态加载的代码模块 + 访问内部 API
2. **为什么需要 Extensions**：在不修改源码的情况下扩展功能
3. **Extensions 的三层价值**：开放封闭原则、控制反转、组合优于继承
4. **Extensions 的能力推导**：从基础定义推导出热重载、事件系统、工具注册、UI 定制、状态管理、类型安全
5. **设计决策的合理性**：TypeScript、事件系统、details 存储、热重载

**核心洞察：**

Extensions 不是简单的"插件系统"，而是一种**架构模式**，它体现了软件工程的核心原则：
- 开放封闭原则（扩展开放，修改封闭）
- 控制反转（框架调用用户代码）
- 组合优于继承（多个扩展协作）
- 单一职责原则（每个扩展做一件事）

理解这些第一性原理，你就能够：
- 设计出高质量的 Extensions
- 理解 pi-mono 的架构决策
- 在遇到问题时从根本上解决
- 创新和突破现有模式

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: pi-mono 2025-2026 版本
