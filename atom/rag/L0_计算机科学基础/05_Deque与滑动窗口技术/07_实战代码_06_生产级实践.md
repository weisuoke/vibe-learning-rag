# 实战代码 06：生产级实践

> 线程安全 + 错误处理 + 监控 + 部署最佳实践

---

## 1. 线程安全的对话管理器

```python
import threading
from collections import deque
from typing import Dict, List, Optional

class ThreadSafeConversationManager:
    """线程安全的对话管理器"""
    
    def __init__(self, max_turns: int = 10):
        self.messages = deque(maxlen=max_turns * 2)
        self.lock = threading.RLock()  # 可重入锁
        self.stats = {
            "total_messages": 0,
            "user_messages": 0,
            "assistant_messages": 0
        }
    
    def add_message(self, role: str, content: str) -> bool:
        """线程安全地添加消息"""
        try:
            with self.lock:
                self.messages.append({"role": role, "content": content})
                self.stats["total_messages"] += 1
                if role == "user":
                    self.stats["user_messages"] += 1
                elif role == "assistant":
                    self.stats["assistant_messages"] += 1
                return True
        except Exception as e:
            print(f"添加消息失败: {e}")
            return False
    
    def get_context(self) -> List[Dict]:
        """线程安全地获取上下文"""
        with self.lock:
            return list(self.messages)
    
    def get_stats(self) -> Dict:
        """线程安全地获取统计信息"""
        with self.lock:
            return self.stats.copy()
    
    def clear(self):
        """线程安全地清空历史"""
        with self.lock:
            self.messages.clear()

# 多线程测试
manager = ThreadSafeConversationManager(max_turns=10)

def worker(thread_id: int):
    for i in range(100):
        manager.add_message("user", f"Thread {thread_id} - 问题 {i}")
        manager.add_message("assistant", f"Thread {thread_id} - 回答 {i}")

threads = [threading.Thread(target=worker, args=(i,)) for i in range(10)]
for t in threads:
    t.start()
for t in threads:
    t.join()

print(f"统计信息: {manager.get_stats()}")
```

---

## 2. 错误处理与重试机制

```python
from collections import deque
from typing import Dict, List, Optional
import time
from functools import wraps

class RobustConversationManager:
    """带错误处理的对话管理器"""
    
    def __init__(self, max_turns: int = 10, max_retries: int = 3):
        self.messages = deque(maxlen=max_turns * 2)
        self.max_retries = max_retries
        self.error_count = 0
    
    def retry_on_failure(max_retries: int = 3):
        """重试装饰器"""
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                for attempt in range(max_retries):
                    try:
                        return func(*args, **kwargs)
                    except Exception as e:
                        if attempt == max_retries - 1:
                            raise
                        time.sleep(2 ** attempt)  # 指数退避
                return None
            return wrapper
        return decorator
    
    @retry_on_failure(max_retries=3)
    def add_message(self, role: str, content: str) -> bool:
        """添加消息（带重试）"""
        if not role or not content:
            raise ValueError("role 和 content 不能为空")
        
        if role not in ["user", "assistant", "system"]:
            raise ValueError(f"无效的 role: {role}")
        
        self.messages.append({"role": role, "content": content})
        return True
    
    def get_context(self) -> Optional[List[Dict]]:
        """获取上下文（带错误处理）"""
        try:
            return list(self.messages)
        except Exception as e:
            self.error_count += 1
            print(f"获取上下文失败: {e}")
            return None

# 使用示例
manager = RobustConversationManager(max_turns=5)

try:
    manager.add_message("user", "你好")
    manager.add_message("assistant", "你好！")
    manager.add_message("invalid_role", "测试")  # 会重试 3 次后失败
except ValueError as e:
    print(f"错误: {e}")
```

---

## 3. 监控与日志

```python
from collections import deque
from typing import Dict, List
import logging
import time
import json

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

class MonitoredConversationManager:
    """带监控的对话管理器"""
    
    def __init__(self, max_turns: int = 10):
        self.messages = deque(maxlen=max_turns * 2)
        self.logger = logging.getLogger(__name__)
        self.metrics = {
            "total_messages": 0,
            "total_tokens": 0,
            "avg_message_length": 0,
            "last_update": None
        }
    
    def add_message(self, role: str, content: str):
        """添加消息（带日志）"""
        start_time = time.time()
        
        try:
            self.messages.append({"role": role, "content": content})
            
            # 更新指标
            self.metrics["total_messages"] += 1
            self.metrics["total_tokens"] += len(content.split())
            self.metrics["avg_message_length"] = (
                sum(len(msg["content"]) for msg in self.messages) / len(self.messages)
            )
            self.metrics["last_update"] = time.time()
            
            # 记录日志
            self.logger.info(
                f"添加消息 - role={role}, length={len(content)}, "
                f"time={time.time() - start_time:.3f}s"
            )
            
        except Exception as e:
            self.logger.error(f"添加消息失败: {e}", exc_info=True)
            raise
    
    def get_metrics(self) -> Dict:
        """获取监控指标"""
        return self.metrics.copy()
    
    def export_metrics(self) -> str:
        """导出指标（JSON 格式）"""
        return json.dumps(self.metrics, indent=2)

# 使用示例
manager = MonitoredConversationManager(max_turns=5)

for i in range(10):
    manager.add_message("user", f"问题 {i}")
    manager.add_message("assistant", f"回答 {i}")

print("\n监控指标:")
print(manager.export_metrics())
```

---

## 4. 内存限制与清理

```python
from collections import deque
from typing import Dict, List
import sys

class MemoryAwareManager:
    """内存感知的对话管理器"""
    
    def __init__(self, max_turns: int = 10, max_memory_mb: float = 10.0):
        self.messages = deque(maxlen=max_turns * 2)
        self.max_memory_bytes = max_memory_mb * 1024 * 1024
    
    def get_memory_usage(self) -> int:
        """获取当前内存使用（字节）"""
        return sys.getsizeof(self.messages) + sum(
            sys.getsizeof(msg) + sys.getsizeof(msg["content"])
            for msg in self.messages
        )
    
    def add_message(self, role: str, content: str):
        """添加消息（检查内存限制）"""
        # 检查内存使用
        if self.get_memory_usage() > self.max_memory_bytes:
            # 清理旧消息
            while self.messages and self.get_memory_usage() > self.max_memory_bytes * 0.8:
                self.messages.popleft()
        
        self.messages.append({"role": role, "content": content})
    
    def get_memory_stats(self) -> Dict:
        """获取内存统计"""
        usage = self.get_memory_usage()
        return {
            "usage_bytes": usage,
            "usage_mb": usage / (1024 * 1024),
            "limit_mb": self.max_memory_bytes / (1024 * 1024),
            "utilization": f"{usage / self.max_memory_bytes:.2%}"
        }

# 使用示例
manager = MemoryAwareManager(max_turns=100, max_memory_mb=1.0)

for i in range(1000):
    manager.add_message("user", f"问题 {i}" * 100)

print("内存统计:")
import json
print(json.dumps(manager.get_memory_stats(), indent=2))
```

---

## 5. 配置管理

```python
from collections import deque
from typing import Dict, List, Optional
from dataclasses import dataclass
import json

@dataclass
class ConversationConfig:
    """对话配置"""
    max_turns: int = 10
    max_tokens: int = 4096
    enable_logging: bool = True
    enable_metrics: bool = True
    thread_safe: bool = True

class ConfigurableManager:
    """可配置的对话管理器"""
    
    def __init__(self, config: Optional[ConversationConfig] = None):
        self.config = config or ConversationConfig()
        self.messages = deque(maxlen=self.config.max_turns * 2)
    
    @classmethod
    def from_json(cls, json_str: str):
        """从 JSON 创建"""
        config_dict = json.loads(json_str)
        config = ConversationConfig(**config_dict)
        return cls(config)
    
    def to_json(self) -> str:
        """导出配置"""
        return json.dumps(self.config.__dict__, indent=2)
    
    def update_config(self, **kwargs):
        """更新配置"""
        for key, value in kwargs.items():
            if hasattr(self.config, key):
                setattr(self.config, key, value)

# 使用示例
config = ConversationConfig(
    max_turns=5,
    max_tokens=2048,
    enable_logging=True
)

manager = ConfigurableManager(config)
print("配置:")
print(manager.to_json())
```

---

## 6. 完整的生产级实现

```python
from collections import deque
from typing import Dict, List, Optional
import threading
import logging
import time
import json
from dataclasses import dataclass, asdict

@dataclass
class ProductionConfig:
    """生产配置"""
    max_turns: int = 10
    max_tokens: int = 4096
    enable_logging: bool = True
    enable_metrics: bool = True
    thread_safe: bool = True
    max_retries: int = 3

class ProductionConversationManager:
    """生产级对话管理器"""
    
    def __init__(self, config: Optional[ProductionConfig] = None):
        self.config = config or ProductionConfig()
        self.messages = deque(maxlen=self.config.max_turns * 2)
        
        # 线程安全
        self.lock = threading.RLock() if self.config.thread_safe else None
        
        # 日志
        if self.config.enable_logging:
            self.logger = logging.getLogger(__name__)
            self.logger.setLevel(logging.INFO)
        else:
            self.logger = None
        
        # 指标
        if self.config.enable_metrics:
            self.metrics = {
                "total_messages": 0,
                "user_messages": 0,
                "assistant_messages": 0,
                "errors": 0,
                "start_time": time.time()
            }
        else:
            self.metrics = None
    
    def _log(self, level: str, message: str):
        """记录日志"""
        if self.logger:
            getattr(self.logger, level)(message)
    
    def _update_metrics(self, role: str):
        """更新指标"""
        if self.metrics:
            self.metrics["total_messages"] += 1
            if role == "user":
                self.metrics["user_messages"] += 1
            elif role == "assistant":
                self.metrics["assistant_messages"] += 1
    
    def add_message(self, role: str, content: str) -> bool:
        """添加消息"""
        def _add():
            # 验证输入
            if not role or not content:
                raise ValueError("role 和 content 不能为空")
            
            if role not in ["user", "assistant", "system"]:
                raise ValueError(f"无效的 role: {role}")
            
            # 添加消息
            self.messages.append({"role": role, "content": content})
            
            # 更新指标
            self._update_metrics(role)
            
            # 记录日志
            self._log("info", f"添加消息 - role={role}, length={len(content)}")
            
            return True
        
        # 线程安全
        if self.lock:
            with self.lock:
                try:
                    return _add()
                except Exception as e:
                    if self.metrics:
                        self.metrics["errors"] += 1
                    self._log("error", f"添加消息失败: {e}")
                    return False
        else:
            try:
                return _add()
            except Exception as e:
                if self.metrics:
                    self.metrics["errors"] += 1
                self._log("error", f"添加消息失败: {e}")
                return False
    
    def get_context(self) -> Optional[List[Dict]]:
        """获取上下文"""
        if self.lock:
            with self.lock:
                return list(self.messages)
        else:
            return list(self.messages)
    
    def get_metrics(self) -> Optional[Dict]:
        """获取指标"""
        if not self.metrics:
            return None
        
        if self.lock:
            with self.lock:
                metrics = self.metrics.copy()
        else:
            metrics = self.metrics.copy()
        
        # 计算运行时间
        metrics["uptime_seconds"] = time.time() - metrics["start_time"]
        
        return metrics
    
    def export_config(self) -> str:
        """导出配置"""
        return json.dumps(asdict(self.config), indent=2)
    
    def export_metrics(self) -> str:
        """导出指标"""
        metrics = self.get_metrics()
        return json.dumps(metrics, indent=2) if metrics else "{}"

# 使用示例
config = ProductionConfig(
    max_turns=5,
    max_tokens=2048,
    enable_logging=True,
    enable_metrics=True,
    thread_safe=True
)

manager = ProductionConversationManager(config)

# 添加消息
for i in range(10):
    manager.add_message("user", f"问题 {i}")
    manager.add_message("assistant", f"回答 {i}")

# 查看指标
print("指标:")
print(manager.export_metrics())

# 查看配置
print("\n配置:")
print(manager.export_config())
```

---

## 7. 部署检查清单

### 代码质量
- [ ] 所有代码都有类型注解
- [ ] 所有公共方法都有文档字符串
- [ ] 所有异常都被正确处理
- [ ] 所有资源都被正确释放

### 性能
- [ ] 使用 Deque 而非 List 进行双端操作
- [ ] 使用 maxlen 自动管理内存
- [ ] 缓存 Token 计数结果
- [ ] 避免不必要的数据复制

### 安全
- [ ] 验证所有输入
- [ ] 限制消息长度
- [ ] 限制内存使用
- [ ] 防止注入攻击

### 可观测性
- [ ] 记录关键操作日志
- [ ] 收集性能指标
- [ ] 监控内存使用
- [ ] 设置告警阈值

### 可靠性
- [ ] 实现重试机制
- [ ] 实现降级策略
- [ ] 实现熔断机制
- [ ] 实现优雅关闭

---

**版本**: v1.0
**最后更新**: 2026-02-13
