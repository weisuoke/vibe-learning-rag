# 实战代码 03: 模板加载配置

## 概述

本章节通过完整的 TypeScript 代码示例，演示如何配置和管理模板加载。包括多源加载、优先级控制、缓存管理等高级功能。

---

## 示例 1: 基础模板加载器

### 需求

实现一个基础的模板加载器，支持从文件系统加载模板。

### 实现

```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

/**
 * 模板接口
 */
interface Template {
  name: string;
  description: string;
  content: string;
  source: 'global' | 'project';
  filePath: string;
}

/**
 * 基础模板加载器
 */
class TemplateLoader {
  private globalDir: string;
  private projectDir: string;

  constructor(projectRoot?: string) {
    this.globalDir = path.join(os.homedir(), '.pi', 'agent', 'prompts');
    this.projectDir = projectRoot
      ? path.join(projectRoot, '.pi', 'prompts')
      : path.join(process.cwd(), '.pi', 'prompts');
  }

  /**
   * 加载所有模板
   */
  loadAll(): Template[] {
    const templates: Template[] = [];

    // 1. 加载项目模板
    if (fs.existsSync(this.projectDir)) {
      templates.push(...this.loadFromDirectory(this.projectDir, 'project'));
    }

    // 2. 加载全局模板
    if (fs.existsSync(this.globalDir)) {
      templates.push(...this.loadFromDirectory(this.globalDir, 'global'));
    }

    // 3. 去重（项目模板优先）
    return this.deduplicateTemplates(templates);
  }

  /**
   * 从目录加载模板
   */
  private loadFromDirectory(dir: string, source: 'global' | 'project'): Template[] {
    const templates: Template[] = [];
    const files = fs.readdirSync(dir);

    for (const file of files) {
      if (!file.endsWith('.md')) continue;

      const filePath = path.join(dir, file);
      const content = fs.readFileSync(filePath, 'utf-8');
      const { frontmatter, body } = this.parseFrontmatter(content);

      templates.push({
        name: file.replace(/\.md$/, ''),
        description: frontmatter.description || '',
        content: body,
        source,
        filePath
      });
    }

    return templates;
  }

  /**
   * 解析 YAML frontmatter
   */
  private parseFrontmatter(content: string): { frontmatter: any; body: string } {
    const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);

    if (!match) {
      return { frontmatter: {}, body: content };
    }

    const frontmatterText = match[1];
    const body = match[2];

    // 简单的 YAML 解析（仅支持基本键值对）
    const frontmatter: any = {};
    frontmatterText.split('\n').forEach(line => {
      const [key, ...valueParts] = line.split(':');
      if (key && valueParts.length > 0) {
        frontmatter[key.trim()] = valueParts.join(':').trim();
      }
    });

    return { frontmatter, body };
  }

  /**
   * 去重模板（项目模板优先）
   */
  private deduplicateTemplates(templates: Template[]): Template[] {
    const seen = new Set<string>();
    return templates.filter(t => {
      if (seen.has(t.name)) return false;
      seen.add(t.name);
      return true;
    });
  }

  /**
   * 根据名称查找模板
   */
  findByName(name: string): Template | null {
    const templates = this.loadAll();
    return templates.find(t => t.name === name) || null;
  }
}

// 使用示例
const loader = new TemplateLoader();
const templates = loader.loadAll();

console.log(`Loaded ${templates.length} templates:`);
templates.forEach(t => {
  console.log(`  [${t.source}] ${t.name}: ${t.description}`);
});

// 查找特定模板
const reviewTemplate = loader.findByName('review');
if (reviewTemplate) {
  console.log(`\nFound template: ${reviewTemplate.name}`);
  console.log(`Source: ${reviewTemplate.source}`);
  console.log(`Path: ${reviewTemplate.filePath}`);
}
```

---

## 示例 2: 带缓存的模板加载器

### 需求

实现一个带缓存的模板加载器，提高性能。

### 实现

```typescript
/**
 * 带缓存的模板加载器
 */
class CachedTemplateLoader extends TemplateLoader {
  private cache: Map<string, Template> = new Map();
  private cacheTimestamp: number = 0;
  private cacheTTL: number = 60000; // 60秒

  /**
   * 加载所有模板（带缓存）
   */
  loadAll(): Template[] {
    const now = Date.now();

    // 检查缓存是否过期
    if (this.cache.size > 0 && now - this.cacheTimestamp < this.cacheTTL) {
      return Array.from(this.cache.values());
    }

    // 重新加载
    const templates = super.loadAll();

    // 更新缓存
    this.cache.clear();
    templates.forEach(t => this.cache.set(t.name, t));
    this.cacheTimestamp = now;

    return templates;
  }

  /**
   * 根据名称查找模板（带缓存）
   */
  findByName(name: string): Template | null {
    // 先检查缓存
    if (this.cache.has(name)) {
      const now = Date.now();
      if (now - this.cacheTimestamp < this.cacheTTL) {
        return this.cache.get(name)!;
      }
    }

    // 缓存未命中或过期，重新加载
    this.loadAll();
    return this.cache.get(name) || null;
  }

  /**
   * 清除缓存
   */
  clearCache(): void {
    this.cache.clear();
    this.cacheTimestamp = 0;
  }

  /**
   * 设置缓存 TTL
   */
  setCacheTTL(ttl: number): void {
    this.cacheTTL = ttl;
  }
}

// 使用示例
const cachedLoader = new CachedTemplateLoader();

// 第一次加载（从文件系统）
console.time('First load');
const templates1 = cachedLoader.loadAll();
console.timeEnd('First load');

// 第二次加载（从缓存）
console.time('Second load');
const templates2 = cachedLoader.loadAll();
console.timeEnd('Second load');

// 清除缓存
cachedLoader.clearCache();

// 第三次加载（从文件系统）
console.time('Third load');
const templates3 = cachedLoader.loadAll();
console.timeEnd('Third load');
```

---

## 示例 3: 监听文件变化

### 需求

实现文件监听，自动重新加载模板。

### 实现

```typescript
import * as fs from 'fs';
import * as path from 'path';

/**
 * 带文件监听的模板加载器
 */
class WatchingTemplateLoader extends TemplateLoader {
  private watchers: fs.FSWatcher[] = [];
  private onChange?: () => void;

  /**
   * 开始监听
   */
  watch(onChange?: () => void): void {
    this.onChange = onChange;

    // 监听全局目录
    if (fs.existsSync(this.globalDir)) {
      const watcher = fs.watch(this.globalDir, (eventType, filename) => {
        if (filename && filename.endsWith('.md')) {
          console.log(`Global template changed: ${filename}`);
          this.onChange?.();
        }
      });
      this.watchers.push(watcher);
    }

    // 监听项目目录
    if (fs.existsSync(this.projectDir)) {
      const watcher = fs.watch(this.projectDir, (eventType, filename) => {
        if (filename && filename.endsWith('.md')) {
          console.log(`Project template changed: ${filename}`);
          this.onChange?.();
        }
      });
      this.watchers.push(watcher);
    }

    console.log('Started watching template directories');
  }

  /**
   * 停止监听
   */
  unwatch(): void {
    this.watchers.forEach(w => w.close());
    this.watchers = [];
    console.log('Stopped watching template directories');
  }
}

// 使用示例
const watchingLoader = new WatchingTemplateLoader();

// 开始监听
watchingLoader.watch(() => {
  console.log('Templates changed, reloading...');
  const templates = watchingLoader.loadAll();
  console.log(`Reloaded ${templates.length} templates`);
});

// 模拟：等待文件变化
console.log('Watching for changes... (Press Ctrl+C to exit)');

// 清理
process.on('SIGINT', () => {
  watchingLoader.unwatch();
  process.exit(0);
});
```

---

## 示例 4: 配置管理

### 需求

实现配置管理，支持自定义模板路径。

### 实现

```typescript
/**
 * 加载器配置
 */
interface LoaderConfig {
  globalDir?: string;
  projectDir?: string;
  additionalDirs?: string[];
  cacheTTL?: number;
  watch?: boolean;
}

/**
 * 可配置的模板加载器
 */
class ConfigurableTemplateLoader {
  private config: Required<LoaderConfig>;
  private cache: Map<string, Template> = new Map();
  private cacheTimestamp: number = 0;
  private watchers: fs.FSWatcher[] = [];

  constructor(config: LoaderConfig = {}) {
    this.config = {
      globalDir: config.globalDir || path.join(os.homedir(), '.pi', 'agent', 'prompts'),
      projectDir: config.projectDir || path.join(process.cwd(), '.pi', 'prompts'),
      additionalDirs: config.additionalDirs || [],
      cacheTTL: config.cacheTTL || 60000,
      watch: config.watch || false
    };

    if (this.config.watch) {
      this.startWatching();
    }
  }

  /**
   * 加载所有模板
   */
  loadAll(): Template[] {
    // 检查缓存
    const now = Date.now();
    if (this.cache.size > 0 && now - this.cacheTimestamp < this.config.cacheTTL) {
      return Array.from(this.cache.values());
    }

    const templates: Template[] = [];

    // 1. 加载项目模板
    if (fs.existsSync(this.config.projectDir)) {
      templates.push(...this.loadFromDirectory(this.config.projectDir, 'project'));
    }

    // 2. 加载全局模板
    if (fs.existsSync(this.config.globalDir)) {
      templates.push(...this.loadFromDirectory(this.config.globalDir, 'global'));
    }

    // 3. 加载额外目录
    this.config.additionalDirs.forEach(dir => {
      if (fs.existsSync(dir)) {
        templates.push(...this.loadFromDirectory(dir, 'global'));
      }
    });

    // 4. 去重
    const deduplicated = this.deduplicateTemplates(templates);

    // 5. 更新缓存
    this.cache.clear();
    deduplicated.forEach(t => this.cache.set(t.name, t));
    this.cacheTimestamp = now;

    return deduplicated;
  }

  /**
   * 开始监听
   */
  private startWatching(): void {
    const dirs = [
      this.config.globalDir,
      this.config.projectDir,
      ...this.config.additionalDirs
    ];

    dirs.forEach(dir => {
      if (fs.existsSync(dir)) {
        const watcher = fs.watch(dir, () => {
          this.cache.clear();
          this.cacheTimestamp = 0;
        });
        this.watchers.push(watcher);
      }
    });
  }

  /**
   * 停止监听
   */
  stopWatching(): void {
    this.watchers.forEach(w => w.close());
    this.watchers = [];
  }

  // ... 其他方法（loadFromDirectory, parseFrontmatter, deduplicateTemplates）
}

// 使用示例
const configurableLoader = new ConfigurableTemplateLoader({
  globalDir: path.join(os.homedir(), '.pi', 'agent', 'prompts'),
  projectDir: path.join(process.cwd(), '.pi', 'prompts'),
  additionalDirs: [
    '/usr/local/share/pi/prompts',
    path.join(os.homedir(), 'custom-prompts')
  ],
  cacheTTL: 30000, // 30秒
  watch: true
});

const templates = configurableLoader.loadAll();
console.log(`Loaded ${templates.length} templates from multiple sources`);
```

---

## 示例 5: 完整的模板管理系统

### 需求

实现一个完整的模板管理系统，包括加载、缓存、监听、搜索等功能。

### 实现

```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

/**
 * 模板管理系统
 */
class TemplateManager {
  private loader: ConfigurableTemplateLoader;
  private templates: Map<string, Template> = new Map();

  constructor(config: LoaderConfig = {}) {
    this.loader = new ConfigurableTemplateLoader(config);
    this.reload();
  }

  /**
   * 重新加载所有模板
   */
  reload(): void {
    const templates = this.loader.loadAll();
    this.templates.clear();
    templates.forEach(t => this.templates.set(t.name, t));
  }

  /**
   * 获取模板
   */
  get(name: string): Template | null {
    return this.templates.get(name) || null;
  }

  /**
   * 列出所有模板
   */
  list(): Template[] {
    return Array.from(this.templates.values());
  }

  /**
   * 搜索模板
   */
  search(query: string): Template[] {
    const lowerQuery = query.toLowerCase();
    return this.list().filter(t =>
      t.name.toLowerCase().includes(lowerQuery) ||
      t.description.toLowerCase().includes(lowerQuery)
    );
  }

  /**
   * 按标签过滤
   */
  filterByTag(tag: string): Template[] {
    return this.list().filter(t => {
      // 假设 frontmatter 中有 tags 字段
      const tags = t.description.match(/tags:\s*\[(.*?)\]/);
      if (!tags) return false;
      return tags[1].split(',').map(t => t.trim()).includes(tag);
    });
  }

  /**
   * 按来源过滤
   */
  filterBySource(source: 'global' | 'project'): Template[] {
    return this.list().filter(t => t.source === source);
  }

  /**
   * 渲染模板
   */
  render(name: string, args: string[]): string | null {
    const template = this.get(name);
    if (!template) return null;

    return this.substituteVariables(template.content, args);
  }

  /**
   * 变量替换
   */
  private substituteVariables(content: string, args: string[]): string {
    let result = content;

    // 替换 $ARGUMENTS 和 $@
    const allArgs = args.join(' ');
    result = result.replace(/\$ARGUMENTS/g, allArgs);
    result = result.replace(/\$@/g, allArgs);

    // 替换 ${@:N:L}
    result = result.replace(/\$\{@:(\d+):(\d+)\}/g, (match, start, length) => {
      const startIdx = parseInt(start) - 1;
      const endIdx = startIdx + parseInt(length);
      return args.slice(startIdx, endIdx).join(' ');
    });

    // 替换 ${@:N}
    result = result.replace(/\$\{@:(\d+)\}/g, (match, start) => {
      const startIdx = parseInt(start) - 1;
      return args.slice(startIdx).join(' ');
    });

    // 替换 $1, $2, $3, ...
    result = result.replace(/\$(\d+)/g, (match, num) => {
      const idx = parseInt(num) - 1;
      return args[idx] || '';
    });

    return result;
  }

  /**
   * 获取统计信息
   */
  getStats(): {
    total: number;
    global: number;
    project: number;
  } {
    const templates = this.list();
    return {
      total: templates.length,
      global: templates.filter(t => t.source === 'global').length,
      project: templates.filter(t => t.source === 'project').length
    };
  }
}

// 使用示例
const manager = new TemplateManager({
  cacheTTL: 30000,
  watch: true
});

// 列出所有模板
console.log('All templates:');
manager.list().forEach(t => {
  console.log(`  [${t.source}] ${t.name}: ${t.description}`);
});

// 搜索模板
console.log('\nSearch results for "review":');
manager.search('review').forEach(t => {
  console.log(`  ${t.name}: ${t.description}`);
});

// 按来源过滤
console.log('\nProject templates:');
manager.filterBySource('project').forEach(t => {
  console.log(`  ${t.name}: ${t.description}`);
});

// 渲染模板
const rendered = manager.render('greet', ['Alice']);
console.log('\nRendered template:');
console.log(rendered);

// 统计信息
const stats = manager.getStats();
console.log('\nStatistics:');
console.log(`  Total: ${stats.total}`);
console.log(`  Global: ${stats.global}`);
console.log(`  Project: ${stats.project}`);
```

---

## 示例 6: CLI 工具

### 需求

创建一个命令行工具来管理模板。

### 实现

```typescript
#!/usr/bin/env node

import * as fs from 'fs';
import * as path from 'path';

/**
 * CLI 工具
 */
class TemplateCLI {
  private manager: TemplateManager;

  constructor() {
    this.manager = new TemplateManager();
  }

  /**
   * 运行命令
   */
  run(args: string[]): void {
    const command = args[0];

    switch (command) {
      case 'list':
        this.listTemplates();
        break;
      case 'search':
        this.searchTemplates(args[1]);
        break;
      case 'show':
        this.showTemplate(args[1]);
        break;
      case 'render':
        this.renderTemplate(args[1], args.slice(2));
        break;
      case 'stats':
        this.showStats();
        break;
      case 'help':
        this.showHelp();
        break;
      default:
        console.error(`Unknown command: ${command}`);
        this.showHelp();
        process.exit(1);
    }
  }

  /**
   * 列出所有模板
   */
  private listTemplates(): void {
    const templates = this.manager.list();
    console.log(`Found ${templates.length} templates:\n`);
    templates.forEach(t => {
      console.log(`  [${t.source}] ${t.name}`);
      console.log(`      ${t.description}`);
    });
  }

  /**
   * 搜索模板
   */
  private searchTemplates(query: string): void {
    if (!query) {
      console.error('Error: search query required');
      process.exit(1);
    }

    const results = this.manager.search(query);
    console.log(`Found ${results.length} templates matching "${query}":\n`);
    results.forEach(t => {
      console.log(`  ${t.name}: ${t.description}`);
    });
  }

  /**
   * 显示模板内容
   */
  private showTemplate(name: string): void {
    if (!name) {
      console.error('Error: template name required');
      process.exit(1);
    }

    const template = this.manager.get(name);
    if (!template) {
      console.error(`Error: template "${name}" not found`);
      process.exit(1);
    }

    console.log(`Template: ${template.name}`);
    console.log(`Source: ${template.source}`);
    console.log(`Description: ${template.description}`);
    console.log(`Path: ${template.filePath}`);
    console.log('\nContent:');
    console.log(template.content);
  }

  /**
   * 渲染模板
   */
  private renderTemplate(name: string, args: string[]): void {
    if (!name) {
      console.error('Error: template name required');
      process.exit(1);
    }

    const rendered = this.manager.render(name, args);
    if (!rendered) {
      console.error(`Error: template "${name}" not found`);
      process.exit(1);
    }

    console.log(rendered);
  }

  /**
   * 显示统计信息
   */
  private showStats(): void {
    const stats = this.manager.getStats();
    console.log('Template Statistics:');
    console.log(`  Total: ${stats.total}`);
    console.log(`  Global: ${stats.global}`);
    console.log(`  Project: ${stats.project}`);
  }

  /**
   * 显示帮助信息
   */
  private showHelp(): void {
    console.log(`
Usage: template-cli <command> [options]

Commands:
  list                List all templates
  search <query>      Search templates
  show <name>         Show template content
  render <name> [...] Render template with arguments
  stats               Show statistics
  help                Show this help message

Examples:
  template-cli list
  template-cli search review
  template-cli show greet
  template-cli render greet Alice
  template-cli stats
    `);
  }
}

// 运行 CLI
if (require.main === module) {
  const cli = new TemplateCLI();
  cli.run(process.argv.slice(2));
}
```

---

## 总结

本章节演示了如何实现完整的模板加载和管理系统：

1. **基础加载器** - 从文件系统加载模板
2. **缓存机制** - 提高加载性能
3. **文件监听** - 自动重新加载
4. **配置管理** - 支持自定义路径
5. **管理系统** - 完整的模板管理
6. **CLI 工具** - 命令行管理工具

所有代码都是完整可运行的，可以直接在项目中使用。

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
