# Extensions 扩展开发基础 - 核心概念 02：事件监听与响应

> 深入理解 Extensions 的事件驱动架构和 30+ 事件类型

---

## 概述

本文档深入讲解 Extensions 的事件系统，包括：
- 事件驱动架构的原理
- 30+ 事件类型的分类和用途
- 事件处理模式（监听、阻止、转换）
- 事件监听器的最佳实践

---

## 1. 事件驱动架构

### 1.1 什么是事件驱动？

**事件驱动架构（Event-Driven Architecture, EDA）**：系统的行为由事件触发和响应。

```
传统架构（调用链）:
A → B → C → D
(A 调用 B, B 调用 C, C 调用 D)

事件驱动架构:
Event → [Listener 1, Listener 2, Listener 3, ...]
(事件触发，所有监听器响应)
```

**pi-mono 的事件驱动模型：**

```
用户输入
  ↓
触发 "input" 事件
  ↓
Extension 1: 转换输入
Extension 2: 记录日志
Extension 3: 检查权限
  ↓
Agent 处理
  ↓
触发 "tool_call" 事件
  ↓
Extension 1: 安全检查
Extension 2: 性能监控
Extension 3: 日志记录
  ↓
执行工具
  ↓
触发 "tool_result" 事件
  ↓
Extension 1: 处理结果
Extension 2: 更新 UI
  ↓
返回结果
```

### 1.2 事件系统的优势

**1. 解耦（Decoupling）**

```typescript
// 紧耦合（不好）
class Agent {
  executeTool(toolName: string) {
    // 直接调用扩展
    securityExtension.check(toolName);
    loggingExtension.log(toolName);
    metricsExtension.track(toolName);
    // 添加新扩展需要修改这里
  }
}

// 松耦合（好）
class Agent {
  executeTool(toolName: string) {
    // 触发事件
    this.emit("tool_call", { toolName });
    // 扩展自己监听事件，无需修改核心代码
  }
}
```

**2. 可扩展（Extensibility）**

```typescript
// 添加新功能只需添加监听器
pi.on("tool_call", async (event, ctx) => {
  // 新的安全检查
});

pi.on("tool_call", async (event, ctx) => {
  // 新的日志记录
});

// 核心代码无需修改
```

**3. 组合（Composition）**

```typescript
// 多个扩展协作
Extension 1: 权限检查 → 通过
Extension 2: 安全检查 → 通过
Extension 3: 配额检查 → 阻止
// 任何一个阻止，事件就不会继续
```

---

## 2. 事件类型分类

### 2.1 Session 事件

**Session 生命周期事件：**

| 事件 | 触发时机 | 用途 |
|------|---------|------|
| `session_start` | Session 启动时 | 初始化状态 |
| `session_switch` | 切换 Session 时 | 重建状态 |
| `session_fork` | Session 分支时 | 复制状态 |
| `session_tree` | 查看 Session 树时 | 显示状态 |
| `session_exit` | Session 退出时 | 清理资源、保存数据 |

**代码示例：**

```typescript
export default function (pi: ExtensionAPI) {
  let todos: Todo[] = [];

  // Session 启动时初始化
  pi.on("session_start", async (event, ctx) => {
    console.log("Session started:", event.sessionId);
    // 从历史重建状态
    reconstructState(ctx);
  });

  // Session 切换时重建状态
  pi.on("session_switch", async (event, ctx) => {
    console.log("Switched to session:", event.sessionId);
    reconstructState(ctx);
  });

  // Session 分支时复制状态
  pi.on("session_fork", async (event, ctx) => {
    console.log("Forked from:", event.parentSessionId);
    console.log("New session:", event.sessionId);
    reconstructState(ctx);

    // 可选：创建 git checkpoint
    await ctx.exec("git stash push -m 'checkpoint before fork'");
  });

  // Session 退出时清理
  pi.on("session_exit", async (event, ctx) => {
    console.log("Session exiting");
    // 保存数据、清理资源
  });
}
```

### 2.2 Agent 事件

**Agent 执行周期事件：**

| 事件 | 触发时机 | 用途 |
|------|---------|------|
| `agent_turn_start` | Agent 回合开始 | 更新 UI、记录开始时间 |
| `agent_turn_end` | Agent 回合结束 | 更新 UI、记录结束时间 |
| `agent_error` | Agent 执行错误 | 错误处理、通知用户 |

**代码示例：**

```typescript
export default function (pi: ExtensionAPI) {
  const timings = new Map<number, number>();

  // Agent 回合开始
  pi.on("agent_turn_start", async (event, ctx) => {
    console.log(`Turn ${event.turnNumber} started`);
    console.log(`Model: ${event.model}`);
    console.log(`Thinking level: ${event.thinkingLevel}`);

    // 记录开始时间
    timings.set(event.turnNumber, Date.now());

    // 更新 UI
    ctx.ui.setStatus(`Turn ${event.turnNumber} - ${event.model}`);
  });

  // Agent 回合结束
  pi.on("agent_turn_end", async (event, ctx) => {
    const start = timings.get(event.turnNumber);
    if (start) {
      const duration = Date.now() - start;
      console.log(`Turn ${event.turnNumber} took ${duration}ms`);
    }

    // 清理
    timings.delete(event.turnNumber);
  });

  // Agent 错误
  pi.on("agent_error", async (event, ctx) => {
    console.error("Agent error:", event.error);
    ctx.ui.notify(`Error: ${event.error.message}`, "error");
  });
}
```

### 2.3 工具事件

**工具调用周期事件：**

| 事件 | 触发时机 | 用途 |
|------|---------|------|
| `tool_call` | 工具调用前 | 拦截、修改、记录 |
| `tool_result` | 工具调用后 | 处理结果、更新状态 |
| `tool_error` | 工具执行错误 | 错误处理 |

**代码示例：**

```typescript
export default function (pi: ExtensionAPI) {
  // 工具调用前
  pi.on("tool_call", async (event, ctx) => {
    console.log(`Tool: ${event.toolName}`);
    console.log(`Input:`, event.input);
    console.log(`Tool call ID: ${event.toolCallId}`);

    // 安全检查
    if (event.toolName === "bash") {
      const cmd = event.input.command;
      if (cmd?.includes("rm -rf") || cmd?.includes("sudo")) {
        const ok = await ctx.ui.confirm(
          "Dangerous Command",
          `Allow: ${cmd}?`
        );
        if (!ok) {
          return { block: true, reason: "Blocked by user" };
        }
      }
    }

    // 记录日志
    console.log(`[${new Date().toISOString()}] ${event.toolName}`);
  });

  // 工具调用后
  pi.on("tool_result", async (event, ctx) => {
    console.log(`Tool result for: ${event.toolName}`);
    console.log(`Success: ${!event.error}`);

    // 处理结果
    if (event.toolName === "bash" && event.result) {
      const output = event.result.content[0];
      if (output?.type === "text") {
        console.log(`Output: ${output.text}`);
      }
    }
  });

  // 工具错误
  pi.on("tool_error", async (event, ctx) => {
    console.error(`Tool error: ${event.toolName}`);
    console.error(`Error: ${event.error}`);
    ctx.ui.notify(`Tool ${event.toolName} failed`, "error");
  });
}
```

### 2.4 用户事件

**用户交互事件：**

| 事件 | 触发时机 | 用途 |
|------|---------|------|
| `input` | 用户输入后 | 转换输入、添加上下文 |
| `user_message` | 用户消息发送前 | 修改消息内容 |

**代码示例：**

```typescript
export default function (pi: ExtensionAPI) {
  // 转换用户输入
  pi.on("input", async (event, ctx) => {
    let text = event.text;

    // 展开 !{command} 模式
    const commandPattern = /!\{([^}]+)\}/g;
    const matches = text.matchAll(commandPattern);

    for (const match of matches) {
      const command = match[1];
      const result = await ctx.exec(command);
      text = text.replace(match[0], result.stdout);
    }

    // 返回转换后的输入
    if (text !== event.text) {
      return { transform: text };
    }
  });

  // 修改用户消息
  pi.on("user_message", async (event, ctx) => {
    // 添加上下文信息
    const enhanced = `${event.content}\n\nContext: ${getContext()}`;
    return { transform: enhanced };
  });
}
```

### 2.5 模型事件

**模型选择事件：**

| 事件 | 触发时机 | 用途 |
|------|---------|------|
| `model_select` | 模型切换时 | 更新 UI、记录日志 |
| `thinking_level_change` | 思考级别变化时 | 更新 UI |

**代码示例：**

```typescript
export default function (pi: ExtensionAPI) {
  // 模型切换
  pi.on("model_select", async (event, ctx) => {
    console.log(`Model changed: ${event.model}`);
    ctx.ui.setStatus(`Model: ${event.model}`);
  });

  // 思考级别变化
  pi.on("thinking_level_change", async (event, ctx) => {
    console.log(`Thinking level: ${event.level}`);
  });
}
```

---

## 3. 事件处理模式

### 3.1 监听模式（Listen）

**仅监听，不阻止：**

```typescript
pi.on("tool_call", async (event, ctx) => {
  // 记录日志
  console.log(`Tool called: ${event.toolName}`);

  // 不返回任何值 = 允许继续
});
```

### 3.2 阻止模式（Block）

**阻止事件继续执行：**

```typescript
pi.on("tool_call", async (event, ctx) => {
  if (shouldBlock(event)) {
    // 返回 block: true 阻止事件
    return {
      block: true,
      reason: "Blocked by security policy",
    };
  }
  // 不返回 = 允许继续
});
```

**阻止的效果：**

```
Extension 1: 检查权限 → 通过（不返回）
Extension 2: 检查安全 → 阻止（返回 block: true）
Extension 3: 检查配额 → 不会执行（因为已被阻止）
工具执行 → 不会执行（因为已被阻止）
```

### 3.3 转换模式（Transform）

**修改事件内容：**

```typescript
pi.on("input", async (event, ctx) => {
  // 转换用户输入
  const sanitized = sanitizeInput(event.text);

  if (sanitized !== event.text) {
    return { transform: sanitized };
  }
});

pi.on("tool_call", async (event, ctx) => {
  if (event.toolName === "bash") {
    // 修改命令
    const safeCommand = makeSafe(event.input.command);

    return {
      transform: {
        ...event,
        input: {
          ...event.input,
          command: safeCommand,
        },
      },
    };
  }
});
```

### 3.4 异步处理

**所有事件处理器都是异步的：**

```typescript
pi.on("tool_call", async (event, ctx) => {
  // 可以执行异步操作
  const ok = await ctx.ui.confirm("Allow?", "Confirm action");

  if (!ok) {
    return { block: true, reason: "User denied" };
  }

  // 可以执行异步 API 调用
  const result = await fetch("https://api.example.com/check");
  const data = await result.json();

  if (!data.allowed) {
    return { block: true, reason: "API denied" };
  }
});
```

---

## 4. 事件监听器的执行顺序

### 4.1 注册顺序

**监听器按注册顺序执行：**

```typescript
// Extension A
pi.on("tool_call", async (event, ctx) => {
  console.log("A");
});

// Extension B
pi.on("tool_call", async (event, ctx) => {
  console.log("B");
});

// Extension C
pi.on("tool_call", async (event, ctx) => {
  console.log("C");
});

// 输出顺序: A, B, C
// (假设 A, B, C 按这个顺序加载)
```

**但是：Extension 的加载顺序不确定！**

```
实际可能的输出:
- B, A, C
- C, B, A
- A, C, B
- ...
```

### 4.2 短路机制

**任何一个监听器返回 `block: true`，后续监听器不会执行：**

```typescript
// Extension 1
pi.on("tool_call", async (event, ctx) => {
  console.log("Extension 1: checking");
  // 通过，继续
});

// Extension 2
pi.on("tool_call", async (event, ctx) => {
  console.log("Extension 2: checking");
  return { block: true, reason: "Blocked" };
  // 阻止，后续不执行
});

// Extension 3
pi.on("tool_call", async (event, ctx) => {
  console.log("Extension 3: checking");
  // 不会执行
});

// 输出:
// Extension 1: checking
// Extension 2: checking
// (Extension 3 不会执行)
```

### 4.3 独立性原则

**设计监听器时，不要依赖其他监听器的执行顺序：**

```typescript
// ❌ 不好：依赖顺序
let globalState = null;

// Extension A
pi.on("tool_call", async (event, ctx) => {
  globalState = "initialized";
});

// Extension B
pi.on("tool_call", async (event, ctx) => {
  // 假设 Extension A 已经执行
  if (globalState === "initialized") {
    // 问题：如果 B 先于 A 加载，这里会失败
  }
});

// ✅ 好：独立工作
// Extension A
pi.on("tool_call", async (event, ctx) => {
  // 独立检查
  if (needsPermission(event)) {
    return { block: true, reason: "No permission" };
  }
});

// Extension B
pi.on("tool_call", async (event, ctx) => {
  // 独立检查
  if (isDangerous(event)) {
    return { block: true, reason: "Dangerous" };
  }
});
```

---

## 5. 事件上下文（ExtensionContext）

### 5.1 UI API

```typescript
pi.on("tool_call", async (event, ctx) => {
  // 确认对话框
  const ok = await ctx.ui.confirm("Title", "Message");

  // 选择对话框
  const choice = await ctx.ui.select("Choose", ["A", "B", "C"]);

  // 输入对话框
  const input = await ctx.ui.input("Enter value", "default");

  // 通知
  ctx.ui.notify("Info message", "info");
  ctx.ui.notify("Success message", "success");
  ctx.ui.notify("Warning message", "warning");
  ctx.ui.notify("Error message", "error");

  // 设置状态栏
  ctx.ui.setStatus("Status text");

  // 设置 footer
  ctx.ui.setFooter(() => "Footer text");

  // 设置 header
  ctx.ui.setHeader(() => "Header text");

  // 设置 widget
  ctx.ui.setWidget("above", () => "Widget above editor");
  ctx.ui.setWidget("below", () => "Widget below editor");
});
```

### 5.2 Session 管理

```typescript
pi.on("session_start", async (event, ctx) => {
  // 获取当前分支的历史
  const branch = ctx.sessionManager.getBranch();

  // 遍历历史
  for (const entry of branch) {
    if (entry.type === "message") {
      console.log(`Message: ${entry.message.role}`);

      if (entry.message.role === "toolResult") {
        console.log(`Tool: ${entry.message.toolName}`);
        console.log(`Details:`, entry.message.details);
      }
    }
  }

  // 设置 Session 标签
  ctx.sessionManager.setLabel(entry.id, "Important");

  // 设置 Session 名称
  ctx.sessionManager.setSessionName("My Session");
});
```

### 5.3 执行命令

```typescript
pi.on("session_fork", async (event, ctx) => {
  // 执行 shell 命令
  const result = await ctx.exec("git stash push -m 'checkpoint'");

  console.log("Exit code:", result.exitCode);
  console.log("Stdout:", result.stdout);
  console.log("Stderr:", result.stderr);

  // 带选项的执行
  const result2 = await ctx.exec("ls -la", {
    cwd: "/path/to/dir",
    timeout: 5000,
  });
});
```

---

## 6. 高级模式

### 6.1 事件总线（Inter-Extension Communication）

**Extensions 之间通过事件总线通信：**

```typescript
// Extension A: 发布自定义事件
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 触发自定义事件
    pi.events.emit("custom:tool_validated", {
      toolName: event.toolName,
      validated: true,
    });
  });
}

// Extension B: 监听自定义事件
export default function (pi: ExtensionAPI) {
  pi.events.on("custom:tool_validated", (data) => {
    console.log("Tool validated:", data.toolName);
  });
}
```

### 6.2 条件监听

**根据条件决定是否处理事件：**

```typescript
pi.on("tool_call", async (event, ctx) => {
  // 只处理 bash 工具
  if (event.toolName !== "bash") {
    return; // 不处理，允许继续
  }

  // 只处理包含特定模式的命令
  const command = event.input.command;
  if (!command?.includes("deploy")) {
    return;
  }

  // 处理 deploy 命令
  const ok = await ctx.ui.confirm("Deploy", "Confirm deployment?");
  if (!ok) {
    return { block: true, reason: "Deployment cancelled" };
  }
});
```

### 6.3 状态累积

**在事件处理器中累积状态：**

```typescript
export default function (pi: ExtensionAPI) {
  const stats = {
    toolCalls: 0,
    bashCalls: 0,
    errors: 0,
  };

  pi.on("tool_call", async (event, ctx) => {
    stats.toolCalls++;
    if (event.toolName === "bash") {
      stats.bashCalls++;
    }
  });

  pi.on("tool_error", async (event, ctx) => {
    stats.errors++;
  });

  pi.on("session_exit", async (event, ctx) => {
    console.log("Session stats:", stats);
  });
}
```

---

## 7. 最佳实践

### 7.1 错误处理

```typescript
pi.on("tool_call", async (event, ctx) => {
  try {
    // 处理事件
    const result = await processEvent(event);

    if (!result.success) {
      return { block: true, reason: result.error };
    }
  } catch (error) {
    // 捕获错误，记录日志
    console.error("Event handler error:", error);

    // 不阻止事件（除非必要）
    // return { block: true, reason: error.message };
  }
});
```

### 7.2 性能优化

```typescript
// ❌ 不好：每次都重新计算
pi.on("tool_call", async (event, ctx) => {
  const config = await loadConfig(); // 慢
  if (config.enabled) {
    // ...
  }
});

// ✅ 好：缓存配置
export default function (pi: ExtensionAPI) {
  let config = null;

  pi.on("session_start", async (event, ctx) => {
    config = await loadConfig(); // 只加载一次
  });

  pi.on("tool_call", async (event, ctx) => {
    if (config?.enabled) {
      // 使用缓存的配置
    }
  });
}
```

### 7.3 清理资源

```typescript
export default function (pi: ExtensionAPI) {
  const timers = [];

  pi.on("session_start", async (event, ctx) => {
    // 创建定时器
    const timer = setInterval(() => {
      console.log("Heartbeat");
    }, 1000);
    timers.push(timer);
  });

  // 返回清理函数
  return () => {
    // 清理定时器
    for (const timer of timers) {
      clearInterval(timer);
    }
  };
}
```

---

## 8. 常见模式

### 8.1 安全防护模式

```typescript
export default function (pi: ExtensionAPI) {
  const dangerousPatterns = [
    /rm\s+-rf\s+\//,
    /sudo\s+rm/,
    /dd\s+if=/,
  ];

  pi.on("tool_call", async (event, ctx) => {
    if (event.toolName !== "bash") return;

    const command = event.input.command;
    for (const pattern of dangerousPatterns) {
      if (pattern.test(command)) {
        const ok = await ctx.ui.confirm(
          "⚠️ Dangerous Command",
          `Allow: ${command}?`
        );
        if (!ok) {
          return { block: true, reason: "Blocked by user" };
        }
      }
    }
  });
}
```

### 8.2 日志记录模式

```typescript
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    console.log(`[${new Date().toISOString()}] Tool: ${event.toolName}`);
    console.log(`Input:`, JSON.stringify(event.input, null, 2));
  });

  pi.on("tool_result", async (event, ctx) => {
    console.log(`[${new Date().toISOString()}] Result: ${event.toolName}`);
    console.log(`Success: ${!event.error}`);
  });
}
```

### 8.3 性能监控模式

```typescript
export default function (pi: ExtensionAPI) {
  const timings = new Map();

  pi.on("tool_call", async (event, ctx) => {
    timings.set(event.toolCallId, Date.now());
  });

  pi.on("tool_result", async (event, ctx) => {
    const start = timings.get(event.toolCallId);
    if (start) {
      const duration = Date.now() - start;
      console.log(`[PERF] ${event.toolName}: ${duration}ms`);
      timings.delete(event.toolCallId);
    }
  });
}
```

---

## 9. 总结

### 核心要点

1. **事件驱动架构**：系统行为由事件触发和响应
2. **30+ 事件类型**：覆盖 Session、Agent、工具、用户、模型等
3. **三种处理模式**：监听、阻止、转换
4. **异步执行**：所有事件处理器都是异步的
5. **独立性原则**：不依赖其他监听器的执行顺序
6. **ExtensionContext**：提供 UI、Session、命令执行等能力

### 下一步

- **核心概念 03**：工具与命令注册
- **核心概念 04**：UI 定制与交互
- **实战代码**：安全防护扩展、日志记录扩展

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: pi-mono 2025-2026 版本
