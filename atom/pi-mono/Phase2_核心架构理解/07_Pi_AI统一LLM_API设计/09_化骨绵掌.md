# 化骨绵掌

> 10个2分钟知识卡片，快速掌握 Pi AI 统一 LLM API 设计

---

## 卡片1：Adapter Pattern 的本质

**一句话：** Adapter Pattern 是将不兼容的接口转换为客户端期望的接口。

**核心公式：**
```
Client → Target Interface → Adapter → Adaptee
```

**举例：**
```typescript
// Target Interface
interface ProviderAdapter {
  complete(context: Context): Promise<Message>;
}

// Adapter
class OpenAIAdapter implements ProviderAdapter {
  complete(context: Context) {
    // 转换 context → OpenAI 格式
    // 调用 OpenAI API
    // 转换响应 → 统一格式
  }
}
```

**应用：** 在 Pi AI 中，每个 LLM Provider 都有一个 Adapter，统一为 `complete()` 和 `stream()` 接口。

---

## 卡片2：为什么需要中间格式

**一句话：** 中间格式将 N² 的转换复杂度降低到 N。

**对比：**
```
直接转换：OpenAI ↔ Anthropic ↔ Google
需要：N×(N-1) 个转换器

中间格式：OpenAI → Pi AI → Anthropic
需要：2N 个转换器（to/from）
```

**数据：**
- 3个 Provider：6个 vs 6个（相同）
- 10个 Provider：90个 vs 20个（4.5倍差距）
- 25个 Provider：600个 vs 50个（12倍差距）

**应用：** Pi AI 使用统一的内部格式，所有 Provider 都转换为这个格式。

---

## 卡片3：流式响应的三段式

**一句话：** start/delta/end 是流式响应的最小必要事件集。

**事件流：**
```
start → 告诉客户端流开始（传递元数据）
delta → 传输增量内容（逐字输出）
end → 告诉客户端流结束（传递统计）
```

**为什么不是两段式？**
- 缺少 start，客户端无法初始化 UI
- 缺少 end，客户端不知道何时停止

**应用：** 所有 Provider 的流式响应都转换为这三种事件。

---

## 卡片4：TypeBox 的优势

**一句话：** TypeBox 同时提供 TypeScript 类型和 JSON Schema。

**对比：**
```typescript
// 手写 JSON Schema（无类型推导）
const schema = {
  type: 'object',
  properties: {
    location: { type: 'string' }
  }
};

// TypeBox（自动类型推导）
const schema = Type.Object({
  location: Type.String()
});
// TypeScript 自动推导类型
type Input = Static<typeof schema>;
```

**优势：**
- 编译时类型检查
- 运行时参数验证
- 性能优化（比 JSON Schema 快 10-100 倍）

**应用：** Pi AI 使用 TypeBox 定义工具 Schema。

---

## 卡片5：Token 计费的差异

**一句话：** 不同 Provider 的输入/输出 Token 价格差异巨大。

**2026年定价对比（每1M tokens）：**
```
GPT-4o-mini:
  输入：$0.15
  输出：$0.60

Claude Opus 4:
  输入：$3.00（20倍）
  输出：$15.00（25倍）

Gemini 2.0 Flash:
  输入：$0.075（0.5倍）
  输出：$0.30（0.5倍）
```

**应用：** 根据任务复杂度选择模型，简单任务用便宜模型，复杂任务用强大模型。

---

## 卡片6：格式转换的开销

**一句话：** 格式转换 < 1ms，网络延迟 > 50ms，开销可忽略。

**性能分析：**
```
格式转换：< 1ms（纯内存操作）
网络延迟：50-200ms（国内）
LLM 推理：500-5000ms

转换开销占比：< 0.1%
```

**结论：** 不要担心抽象层的性能影响，瓶颈在网络和 LLM 推理。

**应用：** 可以放心使用统一 API，性能影响可忽略不计。

---

## 卡片7：OAuth vs API Key

**一句话：** API Key 简单直接，OAuth 更安全但复杂。

**对比：**
```
API Key:
  ✅ 简单（一个字符串）
  ✅ 易于管理
  ❌ 泄露风险高
  ❌ 无法撤销单个应用

OAuth:
  ✅ 更安全（Token 可撤销）
  ✅ 细粒度权限
  ❌ 复杂（需要授权流程）
  ❌ 需要刷新 Token
```

**应用：** OpenAI、Anthropic 使用 API Key，GitHub Models 使用 OAuth。

---

## 卡片8：跨 Provider 切换的场景

**一句话：** 对话中途切换 Provider 可以优化成本和性能。

**场景：**
```
1. 成本优化
   简单任务 → GPT-4o-mini（便宜）
   复杂任务 → Claude Opus 4（强大）

2. 容错降级
   主 Provider 故障 → 自动切换备用

3. A/B 测试
   对比不同模型的效果

4. 功能需求
   需要 vision → 切换到支持的模型
```

**应用：** Pi AI 的统一格式使切换无缝。

---

## 卡片9：工具调用的验证

**一句话：** TypeBox 自动验证工具参数，防止运行时错误。

**验证流程：**
```typescript
// 1. 定义 Schema
const tool = {
  name: 'get_weather',
  parameters: Type.Object({
    location: Type.String(),
    unit: Type.Optional(Type.Union([
      Type.Literal('celsius'),
      Type.Literal('fahrenheit')
    ]))
  })
};

// 2. LLM 返回工具调用
const toolCall = {
  name: 'get_weather',
  input: { location: 'Tokyo', unit: 'kelvin' }  // ❌ 错误
};

// 3. 自动验证
const valid = Value.Check(tool.parameters, toolCall.input);
// false（unit 不是 celsius 或 fahrenheit）
```

**应用：** 在执行工具前验证参数，避免运行时错误。

---

## 卡片10：统一 API 的核心价值

**一句话：** 统一 API 的价值是降低复杂度，而非增加功能。

**价值公式：**
```
价值 = 减少的复杂度 - 增加的抽象成本

减少的复杂度：
  - 学习成本：N → 1
  - 维护成本：N → 1
  - 切换成本：重写 → 配置

增加的抽象成本：
  - 格式转换：< 1ms
  - 学习抽象：1次
```

**结论：** 当 N > 2 时，统一 API 的价值显著。

**应用：** Pi AI 支持 25+ Provider，价值巨大。

---

## 学习路径

### 快速回顾（10分钟）
按顺序阅读 10 个卡片，快速建立知识框架。

### 深入学习（2小时）
结合核心概念和实战代码，深入理解每个知识点。

### 实践应用（1周）
在实际项目中使用 Pi AI，体验统一 API 的价值。

---

## 知识卡片索引

| 卡片 | 主题 | 关键词 |
|------|------|--------|
| 1 | Adapter Pattern | 接口转换、解耦 |
| 2 | 中间格式 | 复杂度、O(N) vs O(N²) |
| 3 | 流式响应 | start/delta/end、事件驱动 |
| 4 | TypeBox | 类型安全、JSON Schema |
| 5 | Token 计费 | 定价差异、成本优化 |
| 6 | 性能开销 | < 1ms、可忽略 |
| 7 | 认证方式 | API Key vs OAuth |
| 8 | 跨 Provider 切换 | 成本优化、容错降级 |
| 9 | 参数验证 | TypeBox、运行时检查 |
| 10 | 核心价值 | 降低复杂度、N → 1 |

---

**版本：** v1.0
**最后更新：** 2026-02-19
