# 实战代码 02：自定义工具开发

演示如何开发自定义工具，包括 API 调用、数据库查询和文件搜索工具。

---

## 示例 1：HTTP 请求工具

```typescript
import { Type, Static } from '@sinclair/typebox';
import fetch from 'node-fetch';

// Schema 定义
const HttpToolSchema = Type.Object({
  url: Type.String({
    format: 'uri',
    description: 'HTTP URL to request'
  }),
  method: Type.Optional(Type.Union([
    Type.Literal('GET'),
    Type.Literal('POST'),
    Type.Literal('PUT'),
    Type.Literal('DELETE')
  ], {
    default: 'GET',
    description: 'HTTP method'
  })),
  headers: Type.Optional(Type.Record(
    Type.String(),
    Type.String(),
    { description: 'HTTP headers' }
  )),
  body: Type.Optional(Type.String({
    description: 'Request body (JSON string)'
  })),
  timeout: Type.Optional(Type.Number({
    minimum: 1000,
    maximum: 60000,
    default: 10000,
    description: 'Timeout in milliseconds'
  }))
});

type HttpToolParams = Static<typeof HttpToolSchema>;

// 执行函数
async function executeHttp(params: HttpToolParams): Promise<string> {
  const { url, method = 'GET', headers, body, timeout = 10000 } = params;

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    const response = await fetch(url, {
      method,
      headers: headers || {},
      body: body ? JSON.stringify(JSON.parse(body)) : undefined,
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    const contentType = response.headers.get('content-type');
    const text = await response.text();

    return `Status: ${response.status} ${response.statusText}\n` +
           `Content-Type: ${contentType}\n\n` +
           text;
  } catch (error: any) {
    if (error.name === 'AbortError') {
      return `Error: Request timed out after ${timeout}ms`;
    }
    return `Error: ${error.message}`;
  }
}

// 注册
registry.register({
  name: 'http',
  description: 'Make HTTP requests',
  schema: HttpToolSchema,
  execute: executeHttp
});
```

---

## 示例 2：数据库查询工具

```typescript
import { Type, Static } from '@sinclair/typebox';
import { Pool } from 'pg';

// 创建连接池
const pool = new Pool({
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  max: 10
});

// Schema 定义
const DbQueryToolSchema = Type.Object({
  query: Type.String({
    minLength: 1,
    description: 'SQL query to execute (SELECT only)'
  }),
  params: Type.Optional(Type.Array(
    Type.Union([Type.String(), Type.Number(), Type.Boolean()]),
    { description: 'Query parameters' }
  )),
  limit: Type.Optional(Type.Number({
    minimum: 1,
    maximum: 1000,
    default: 100,
    description: 'Maximum number of rows to return'
  }))
});

type DbQueryToolParams = Static<typeof DbQueryToolSchema>;

// 执行函数
async function executeDbQuery(params: DbQueryToolParams): Promise<string> {
  const { query, params: queryParams = [], limit = 100 } = params;

  // 安全检查：只允许 SELECT 查询
  const normalizedQuery = query.trim().toLowerCase();
  if (!normalizedQuery.startsWith('select')) {
    return 'Error: Only SELECT queries are allowed';
  }

  // 禁止危险操作
  const dangerous = ['drop', 'delete', 'update', 'insert', 'truncate'];
  if (dangerous.some(d => normalizedQuery.includes(d))) {
    return 'Error: Dangerous SQL keywords detected';
  }

  try {
    // 添加 LIMIT 子句
    const limitedQuery = query.includes('LIMIT')
      ? query
      : `${query} LIMIT ${limit}`;

    const result = await pool.query(limitedQuery, queryParams);

    if (result.rows.length === 0) {
      return 'No results found';
    }

    // 格式化结果为表格
    const headers = Object.keys(result.rows[0]);
    const rows = result.rows.map(row =>
      headers.map(h => String(row[h] || ''))
    );

    return formatTable(headers, rows);
  } catch (error: any) {
    return `Error: ${error.message}`;
  }
}

// 表格格式化辅助函数
function formatTable(headers: string[], rows: string[][]): string {
  const colWidths = headers.map((h, i) =>
    Math.max(h.length, ...rows.map(r => r[i].length))
  );

  const headerRow = headers
    .map((h, i) => h.padEnd(colWidths[i]))
    .join(' | ');

  const separator = colWidths
    .map(w => '-'.repeat(w))
    .join('-+-');

  const dataRows = rows
    .map(row =>
      row.map((cell, i) => cell.padEnd(colWidths[i])).join(' | ')
    )
    .join('\n');

  return `${headerRow}\n${separator}\n${dataRows}\n\nTotal: ${rows.length} rows`;
}

// 注册
registry.register({
  name: 'db_query',
  description: 'Execute SQL SELECT queries',
  schema: DbQueryToolSchema,
  execute: executeDbQuery
});
```

---

## 示例 3：文件搜索工具

```typescript
import { Type, Static } from '@sinclair/typebox';
import { readdir, readFile } from 'fs/promises';
import { join, relative } from 'path';

// Schema 定义
const SearchToolSchema = Type.Object({
  pattern: Type.String({
    minLength: 1,
    description: 'Search pattern (regex supported)'
  }),
  path: Type.Optional(Type.String({
    description: 'Directory to search (default: current directory)'
  })),
  filePattern: Type.Optional(Type.String({
    description: 'File name pattern (e.g., *.ts, *.md)'
  })),
  caseSensitive: Type.Optional(Type.Boolean({
    default: false,
    description: 'Case sensitive search'
  })),
  maxResults: Type.Optional(Type.Number({
    minimum: 1,
    maximum: 1000,
    default: 100,
    description: 'Maximum number of results'
  })),
  contextLines: Type.Optional(Type.Number({
    minimum: 0,
    maximum: 10,
    default: 2,
    description: 'Number of context lines before/after match'
  }))
});

type SearchToolParams = Static<typeof SearchToolSchema>;

interface SearchResult {
  file: string;
  line: number;
  match: string;
  context: string[];
}

// 执行函数
async function executeSearch(
  params: SearchToolParams,
  workDir: string
): Promise<string> {
  const {
    pattern,
    path: searchPath = '.',
    filePattern = '*',
    caseSensitive = false,
    maxResults = 100,
    contextLines = 2
  } = params;

  const fullPath = join(workDir, searchPath);

  try {
    // 创建正则表达式
    const flags = caseSensitive ? 'g' : 'gi';
    const regex = new RegExp(pattern, flags);

    // 搜索文件
    const results: SearchResult[] = [];
    await searchDirectory(fullPath, regex, filePattern, contextLines, results, maxResults);

    if (results.length === 0) {
      return `No matches found for pattern: ${pattern}`;
    }

    // 格式化结果
    return formatSearchResults(results, workDir);
  } catch (error: any) {
    return `Error: ${error.message}`;
  }
}

async function searchDirectory(
  dir: string,
  regex: RegExp,
  filePattern: string,
  contextLines: number,
  results: SearchResult[],
  maxResults: number
): Promise<void> {
  if (results.length >= maxResults) return;

  const entries = await readdir(dir, { withFileTypes: true });

  for (const entry of entries) {
    if (results.length >= maxResults) break;

    const fullPath = join(dir, entry.name);

    // 跳过隐藏文件和 node_modules
    if (entry.name.startsWith('.') || entry.name === 'node_modules') {
      continue;
    }

    if (entry.isDirectory()) {
      await searchDirectory(fullPath, regex, filePattern, contextLines, results, maxResults);
    } else if (entry.isFile()) {
      // 检查文件名是否匹配
      if (!matchFilePattern(entry.name, filePattern)) {
        continue;
      }

      // 搜索文件内容
      await searchFile(fullPath, regex, contextLines, results, maxResults);
    }
  }
}

async function searchFile(
  filePath: string,
  regex: RegExp,
  contextLines: number,
  results: SearchResult[],
  maxResults: number
): Promise<void> {
  try {
    const content = await readFile(filePath, 'utf-8');
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      if (results.length >= maxResults) break;

      const line = lines[i];
      if (regex.test(line)) {
        // 提取上下文
        const start = Math.max(0, i - contextLines);
        const end = Math.min(lines.length, i + contextLines + 1);
        const context = lines.slice(start, end);

        results.push({
          file: filePath,
          line: i + 1,
          match: line.trim(),
          context
        });
      }
    }
  } catch (error) {
    // 跳过无法读取的文件
  }
}

function matchFilePattern(fileName: string, pattern: string): boolean {
  if (pattern === '*') return true;

  const regex = new RegExp(
    '^' + pattern.replace(/\*/g, '.*').replace(/\?/g, '.') + '$'
  );
  return regex.test(fileName);
}

function formatSearchResults(results: SearchResult[], workDir: string): string {
  let output = `Found ${results.length} matches:\n\n`;

  for (const result of results) {
    const relativePath = relative(workDir, result.file);
    output += `${relativePath}:${result.line}\n`;
    output += result.context.map((line, i) => {
      const lineNum = result.line - Math.floor(result.context.length / 2) + i;
      const prefix = lineNum === result.line ? '>' : ' ';
      return `${prefix} ${lineNum}: ${line}`;
    }).join('\n');
    output += '\n\n';
  }

  return output;
}

// 注册
registry.register({
  name: 'search',
  description: 'Search for text in files',
  schema: SearchToolSchema,
  execute: (params) => executeSearch(params, workDir)
});
```

---

## 示例 4：JSON 处理工具

```typescript
import { Type, Static } from '@sinclair/typebox';

// Schema 定义
const JsonToolSchema = Type.Object({
  operation: Type.Union([
    Type.Literal('parse'),
    Type.Literal('stringify'),
    Type.Literal('query'),
    Type.Literal('validate')
  ], {
    description: 'JSON operation to perform'
  }),
  input: Type.String({
    description: 'Input data (JSON string or object)'
  }),
  query: Type.Optional(Type.String({
    description: 'JSONPath query (for query operation)'
  })),
  schema: Type.Optional(Type.String({
    description: 'JSON Schema for validation (for validate operation)'
  })),
  pretty: Type.Optional(Type.Boolean({
    default: true,
    description: 'Pretty print output'
  }))
});

type JsonToolParams = Static<typeof JsonToolSchema>;

// 执行函数
async function executeJson(params: JsonToolParams): Promise<string> {
  const { operation, input, query, schema, pretty = true } = params;

  try {
    switch (operation) {
      case 'parse': {
        const parsed = JSON.parse(input);
        return pretty
          ? JSON.stringify(parsed, null, 2)
          : JSON.stringify(parsed);
      }

      case 'stringify': {
        // 假设 input 已经是对象
        const obj = typeof input === 'string' ? JSON.parse(input) : input;
        return pretty
          ? JSON.stringify(obj, null, 2)
          : JSON.stringify(obj);
      }

      case 'query': {
        if (!query) {
          return 'Error: query parameter required for query operation';
        }

        const obj = JSON.parse(input);
        const result = queryJson(obj, query);
        return pretty
          ? JSON.stringify(result, null, 2)
          : JSON.stringify(result);
      }

      case 'validate': {
        if (!schema) {
          return 'Error: schema parameter required for validate operation';
        }

        const obj = JSON.parse(input);
        const schemaObj = JSON.parse(schema);

        const ajv = new Ajv();
        const validate = ajv.compile(schemaObj);
        const valid = validate(obj);

        if (valid) {
          return '✓ JSON is valid';
        } else {
          return `✗ JSON is invalid:\n${JSON.stringify(validate.errors, null, 2)}`;
        }
      }

      default:
        return `Error: Unknown operation: ${operation}`;
    }
  } catch (error: any) {
    return `Error: ${error.message}`;
  }
}

// 简单的 JSONPath 查询实现
function queryJson(obj: any, path: string): any {
  const parts = path.split('.').filter(p => p);
  let current = obj;

  for (const part of parts) {
    if (part.includes('[')) {
      // 数组索引
      const [key, index] = part.split('[');
      const idx = parseInt(index.replace(']', ''));
      current = current[key][idx];
    } else {
      current = current[part];
    }

    if (current === undefined) {
      return null;
    }
  }

  return current;
}

// 注册
registry.register({
  name: 'json',
  description: 'JSON operations (parse, stringify, query, validate)',
  schema: JsonToolSchema,
  execute: executeJson
});
```

---

## 完整测试示例

```typescript
async function testCustomTools() {
  console.log('=== Custom Tools Demo ===\n');

  const registry = new ToolRegistry();
  const executor = new ToolExecutor(registry, process.cwd());

  // 注册所有自定义工具
  // ... (注册代码省略)

  // 测试 1: HTTP 请求
  console.log('--- Test 1: HTTP Request ---');
  const result1 = await executor.execute('http', {
    url: 'https://api.github.com/repos/anthropics/anthropic-sdk-typescript',
    method: 'GET',
    headers: {
      'User-Agent': 'Custom-Tool-Demo'
    }
  });
  console.log(result1.output.slice(0, 200) + '...\n');

  // 测试 2: 数据库查询
  console.log('--- Test 2: Database Query ---');
  const result2 = await executor.execute('db_query', {
    query: 'SELECT id, name, email FROM users WHERE active = $1',
    params: [true],
    limit: 10
  });
  console.log(result2.output + '\n');

  // 测试 3: 文件搜索
  console.log('--- Test 3: File Search ---');
  const result3 = await executor.execute('search', {
    pattern: 'TypeBox',
    filePattern: '*.ts',
    maxResults: 5,
    contextLines: 1
  });
  console.log(result3.output + '\n');

  // 测试 4: JSON 处理
  console.log('--- Test 4: JSON Operations ---');
  const result4 = await executor.execute('json', {
    operation: 'query',
    input: JSON.stringify({
      users: [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' }
      ]
    }),
    query: 'users[0].name'
  });
  console.log(result4.output + '\n');
}

testCustomTools().catch(console.error);
```

---

## 工具开发最佳实践

### 1. Schema 设计原则

- **清晰的描述**：每个参数都要有详细的 description
- **合理的约束**：使用 minLength、minimum、maximum 等约束
- **可选参数**：提供合理的默认值
- **类型安全**：使用 TypeBox 的类型推导

### 2. 错误处理

- **验证错误**：返回清晰的错误信息，不抛异常
- **运行时错误**：捕获所有异常，返回友好的错误消息
- **超时保护**：为长时间运行的操作设置超时

### 3. 安全考虑

- **输入验证**：验证所有用户输入
- **路径检查**：确保文件路径在允许的范围内
- **SQL 注入防护**：使用参数化查询
- **命令注入防护**：避免直接执行用户输入的命令

### 4. 性能优化

- **连接池**：数据库连接使用连接池
- **缓存**：缓存频繁访问的数据
- **批量操作**：支持批量处理以提高效率
- **流式处理**：对大文件使用流式读取

---

## 总结

自定义工具开发的关键点：
1. 使用 TypeBox 定义清晰的 Schema
2. 实现健壮的错误处理
3. 考虑安全性和性能
4. 提供友好的用户体验
5. 遵循工具注册和执行的标准流程
