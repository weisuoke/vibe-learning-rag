# 核心概念04：状态转移函数

> **定义**：状态转移函数δ定义了状态机如何根据当前状态和输入符号转移到下一个状态

---

## 一、形式化定义

### 1.1 DFA的转移函数

```
δ: Q × Σ → Q

输入：(当前状态, 输入符号)
输出：下一个状态（唯一确定）

示例：
δ(q0, 'a') = q1
δ(q1, 'b') = q2
```

**特点**：
- **确定性**：每个(状态, 符号)对应唯一的下一状态
- **完整性**：对所有状态和符号都有定义
- **函数性**：满足函数的定义（单值）

---

### 1.2 NFA的转移函数

```
δ: Q × (Σ ∪ {ε}) → P(Q)

输入：(当前状态, 输入符号或ε)
输出：下一状态集合（幂集）

示例：
δ(q0, 'a') = {q1, q2}  // 非确定性
δ(q1, 'ε') = {q2, q3}  // ε-转移
```

**特点**：
- **非确定性**：可能有多个下一状态
- **ε-转移**：允许不消耗输入的转移
- **幂集**：返回状态集合

---

## 二、转移函数的表示方法

### 2.1 转移表（Transition Table）

**DFA转移表**：
```
状态 | 输入'0' | 输入'1'
-----|---------|--------
q0   | q0      | q1
q1   | q1      | q0
```

**Python实现**：
```python
# 使用字典表示转移表
transition_table = {
    ('q0', '0'): 'q0',
    ('q0', '1'): 'q1',
    ('q1', '0'): 'q1',
    ('q1', '1'): 'q0',
}

def delta(state: str, symbol: str) -> str:
    """DFA转移函数"""
    return transition_table[(state, symbol)]
```

---

### 2.2 转移图（Transition Diagram）

**图形表示**：
```
    0
q0 ⟲ --1--> q1
         ⟲ 0
         1
         ↓
        q0
```

**优势**：
- 直观可视化
- 易于理解
- 便于设计

---

### 2.3 转移矩阵（Transition Matrix）

**矩阵表示**：
```
对于字母表Σ = {0, 1}，状态集Q = {q0, q1}

M_0 = [1 0]  // 输入'0'的转移矩阵
      [0 1]

M_1 = [0 1]  // 输入'1'的转移矩阵
      [1 0]
```

**应用**：
- 快速计算多步转移
- 矩阵乘法：M^n表示n步转移
- 理论分析

---

## 三、转移函数的实现

### 3.1 基于字典的实现

```python
from typing import Dict, Tuple

class TransitionFunction:
    """基于字典的转移函数实现"""

    def __init__(self):
        self.transitions: Dict[Tuple[str, str], str] = {}

    def add_transition(self, from_state: str, symbol: str, to_state: str):
        """添加转移"""
        self.transitions[(from_state, symbol)] = to_state

    def __call__(self, state: str, symbol: str) -> str:
        """调用转移函数"""
        if (state, symbol) not in self.transitions:
            raise ValueError(f"No transition defined for ({state}, {symbol})")
        return self.transitions[(state, symbol)]

    def is_complete(self, states: set, alphabet: set) -> bool:
        """检查转移函数是否完整"""
        for state in states:
            for symbol in alphabet:
                if (state, symbol) not in self.transitions:
                    return False
        return True


# 使用示例
delta = TransitionFunction()
delta.add_transition('q0', '0', 'q0')
delta.add_transition('q0', '1', 'q1')
delta.add_transition('q1', '0', 'q1')
delta.add_transition('q1', '1', 'q0')

# 调用
print(delta('q0', '1'))  # 输出：q1
print(delta.is_complete({'q0', 'q1'}, {'0', '1'}))  # 输出：True
```

---

### 3.2 基于嵌套字典的实现

```python
from typing import Dict
from collections import defaultdict

class NestedTransitionFunction:
    """基于嵌套字典的转移函数实现"""

    def __init__(self):
        # transitions[state][symbol] = next_state
        self.transitions: Dict[str, Dict[str, str]] = defaultdict(dict)

    def add_transition(self, from_state: str, symbol: str, to_state: str):
        """添加转移"""
        self.transitions[from_state][symbol] = to_state

    def __call__(self, state: str, symbol: str) -> str:
        """调用转移函数"""
        if state not in self.transitions:
            raise ValueError(f"State {state} not found")
        if symbol not in self.transitions[state]:
            raise ValueError(f"No transition for ({state}, {symbol})")
        return self.transitions[state][symbol]

    def get_transitions_from(self, state: str) -> Dict[str, str]:
        """获取从某状态出发的所有转移"""
        return self.transitions.get(state, {})


# 使用示例
delta = NestedTransitionFunction()
delta.add_transition('q0', '0', 'q0')
delta.add_transition('q0', '1', 'q1')

print(delta('q0', '1'))  # 输出：q1
print(delta.get_transitions_from('q0'))  # 输出：{'0': 'q0', '1': 'q1'}
```

---

### 3.3 基于类的面向对象实现

```python
from abc import ABC, abstractmethod
from typing import Set

class State:
    """状态类"""

    def __init__(self, name: str, is_accept: bool = False):
        self.name = name
        self.is_accept = is_accept
        self.transitions: Dict[str, 'State'] = {}

    def add_transition(self, symbol: str, to_state: 'State'):
        """添加转移"""
        self.transitions[symbol] = to_state

    def transition(self, symbol: str) -> 'State':
        """执行转移"""
        if symbol not in self.transitions:
            raise ValueError(f"No transition for symbol '{symbol}'")
        return self.transitions[symbol]

    def __repr__(self):
        return f"State({self.name}, accept={self.is_accept})"


class DFAWithStates:
    """使用State对象的DFA"""

    def __init__(self, initial_state: State):
        self.initial_state = initial_state
        self.current_state = initial_state

    def reset(self):
        """重置到初始状态"""
        self.current_state = self.initial_state

    def step(self, symbol: str):
        """执行一步转移"""
        self.current_state = self.current_state.transition(symbol)

    def accepts(self, input_string: str) -> bool:
        """判断是否接受输入"""
        self.reset()
        for symbol in input_string:
            self.step(symbol)
        return self.current_state.is_accept


# 使用示例：构建识别偶数个1的DFA
q0 = State('q0', is_accept=True)   # 偶数个1
q1 = State('q1', is_accept=False)  # 奇数个1

q0.add_transition('0', q0)
q0.add_transition('1', q1)
q1.add_transition('0', q1)
q1.add_transition('1', q0)

dfa = DFAWithStates(q0)
print(dfa.accepts("110"))   # True（2个1）
print(dfa.accepts("111"))   # False（3个1）
```

---

## 四、扩展转移函数

### 4.1 扩展到字符串

**定义**：
```
δ*: Q × Σ* → Q

δ*(q, ε) = q
δ*(q, wa) = δ(δ*(q, w), a)  // w是字符串，a是符号
```

**含义**：从状态q读取整个字符串w后到达的状态

**Python实现**：
```python
def delta_star(delta, state: str, string: str) -> str:
    """
    扩展转移函数：处理字符串

    Args:
        delta: 转移函数
        state: 初始状态
        string: 输入字符串

    Returns:
        最终状态
    """
    current_state = state
    for symbol in string:
        current_state = delta(current_state, symbol)
    return current_state


# 使用示例
delta = TransitionFunction()
delta.add_transition('q0', '0', 'q0')
delta.add_transition('q0', '1', 'q1')
delta.add_transition('q1', '0', 'q1')
delta.add_transition('q1', '1', 'q0')

final_state = delta_star(delta, 'q0', '110')
print(f"δ*(q0, '110') = {final_state}")  # 输出：q0
```

---

### 4.2 扩展到状态集合（NFA）

**定义**：
```
δ*: P(Q) × Σ* → P(Q)

δ*(S, ε) = ε-closure(S)
δ*(S, wa) = ε-closure(⋃_{q∈δ*(S,w)} δ(q, a))
```

**Python实现**：
```python
def delta_star_nfa(nfa, states: Set[str], string: str) -> Set[str]:
    """
    NFA的扩展转移函数

    Args:
        nfa: NFA对象
        states: 初始状态集合
        string: 输入字符串

    Returns:
        最终状态集合
    """
    current_states = nfa.epsilon_closure(states)

    for symbol in string:
        current_states = nfa.move(current_states, symbol)
        current_states = nfa.epsilon_closure(current_states)

    return current_states
```

---

## 五、转移函数的性质

### 5.1 完整性（Completeness）

**定义**：对所有q ∈ Q和a ∈ Σ，δ(q, a)都有定义

**检查算法**：
```python
def check_completeness(delta, states: Set[str], alphabet: Set[str]) -> bool:
    """检查转移函数的完整性"""
    missing = []
    for state in states:
        for symbol in alphabet:
            try:
                delta(state, symbol)
            except (KeyError, ValueError):
                missing.append((state, symbol))

    if missing:
        print(f"Missing transitions: {missing}")
        return False
    return True
```

---

### 5.2 确定性（Determinism）

**定义**：对每个(q, a)，δ(q, a)返回唯一状态

**检查算法**：
```python
def check_determinism(transitions: Dict) -> bool:
    """检查转移函数的确定性"""
    for (state, symbol), next_states in transitions.items():
        if isinstance(next_states, set) and len(next_states) > 1:
            print(f"Non-deterministic: δ({state}, {symbol}) = {next_states}")
            return False
    return True
```

---

### 5.3 可达性（Reachability）

**定义**：从初始状态q0可以到达的状态集合

**计算算法**：
```python
def compute_reachable_states(
    delta,
    initial_state: str,
    alphabet: Set[str]
) -> Set[str]:
    """计算可达状态集合"""
    reachable = {initial_state}
    queue = [initial_state]

    while queue:
        state = queue.pop(0)
        for symbol in alphabet:
            try:
                next_state = delta(state, symbol)
                if next_state not in reachable:
                    reachable.add(next_state)
                    queue.append(next_state)
            except (KeyError, ValueError):
                pass

    return reachable
```

---

## 六、AI Agent中的应用

### 6.1 Agent决策函数

**场景**：RAG系统的状态转移

```python
from enum import Enum
from typing import Callable

class RAGState(Enum):
    IDLE = "idle"
    RETRIEVING = "retrieving"
    REASONING = "reasoning"
    GENERATING = "generating"
    VALIDATING = "validating"
    COMPLETED = "completed"
    FAILED = "failed"

class RAGEvent(Enum):
    QUERY = "query"
    RETRIEVED = "retrieved"
    RETRIEVAL_FAILED = "retrieval_failed"
    REASONED = "reasoned"
    GENERATED = "generated"
    VALIDATED = "validated"
    VALIDATION_FAILED = "validation_failed"


class RAGTransitionFunction:
    """RAG系统的转移函数"""

    def __init__(self):
        # 定义转移规则
        self.transitions = {
            (RAGState.IDLE, RAGEvent.QUERY): RAGState.RETRIEVING,
            (RAGState.RETRIEVING, RAGEvent.RETRIEVED): RAGState.REASONING,
            (RAGState.RETRIEVING, RAGEvent.RETRIEVAL_FAILED): RAGState.FAILED,
            (RAGState.REASONING, RAGEvent.REASONED): RAGState.GENERATING,
            (RAGState.GENERATING, RAGEvent.GENERATED): RAGState.VALIDATING,
            (RAGState.VALIDATING, RAGEvent.VALIDATED): RAGState.COMPLETED,
            (RAGState.VALIDATING, RAGEvent.VALIDATION_FAILED): RAGState.RETRIEVING,
        }

    def __call__(self, state: RAGState, event: RAGEvent) -> RAGState:
        """执行状态转移"""
        key = (state, event)
        if key not in self.transitions:
            raise ValueError(f"Invalid transition: {state} --{event}--> ?")
        return self.transitions[key]

    def is_valid_transition(self, state: RAGState, event: RAGEvent) -> bool:
        """检查转移是否有效"""
        return (state, event) in self.transitions


# 使用示例
delta = RAGTransitionFunction()

# 正常流程
state = RAGState.IDLE
state = delta(state, RAGEvent.QUERY)           # IDLE → RETRIEVING
state = delta(state, RAGEvent.RETRIEVED)       # RETRIEVING → REASONING
state = delta(state, RAGEvent.REASONED)        # REASONING → GENERATING
state = delta(state, RAGEvent.GENERATED)       # GENERATING → VALIDATING
state = delta(state, RAGEvent.VALIDATED)       # VALIDATING → COMPLETED

print(f"Final state: {state}")  # COMPLETED
```

---

### 6.2 条件转移函数

**场景**：基于条件的动态转移

```python
from typing import Callable, Any

class ConditionalTransitionFunction:
    """条件转移函数"""

    def __init__(self):
        # transitions[(state, event)] = (condition, next_state)
        self.transitions = {}

    def add_transition(
        self,
        from_state: str,
        event: str,
        to_state: str,
        condition: Callable[[Any], bool] = lambda _: True
    ):
        """添加条件转移"""
        self.transitions[(from_state, event)] = (condition, to_state)

    def __call__(self, state: str, event: str, context: Any = None) -> str:
        """执行条件转移"""
        key = (state, event)
        if key not in self.transitions:
            raise ValueError(f"No transition for ({state}, {event})")

        condition, next_state = self.transitions[key]
        if condition(context):
            return next_state
        else:
            raise ValueError(f"Condition not met for ({state}, {event})")


# 使用示例：RAG系统的条件转移
delta = ConditionalTransitionFunction()

# 检索成功 → 推理（条件：文档数量 > 0）
delta.add_transition(
    'retrieving',
    'retrieved',
    'reasoning',
    condition=lambda ctx: len(ctx.get('documents', [])) > 0
)

# 检索失败 → 重试（条件：文档数量 == 0）
delta.add_transition(
    'retrieving',
    'retrieved',
    'retry',
    condition=lambda ctx: len(ctx.get('documents', [])) == 0
)

# 测试
context = {'documents': ['doc1', 'doc2']}
next_state = delta('retrieving', 'retrieved', context)
print(f"Next state: {next_state}")  # reasoning
```

---

## 七、转移函数的优化

### 7.1 转移表压缩

**问题**：大型DFA的转移表占用大量内存

**解决方案**：
1. **默认转移**：大部分转移到同一状态
2. **稀疏表示**：只存储非默认转移
3. **状态合并**：合并等价状态

```python
class CompressedTransitionFunction:
    """压缩的转移函数"""

    def __init__(self, default_state: str = 'error'):
        self.transitions = {}
        self.default_state = default_state

    def add_transition(self, from_state: str, symbol: str, to_state: str):
        """添加转移（只存储非默认转移）"""
        if to_state != self.default_state:
            self.transitions[(from_state, symbol)] = to_state

    def __call__(self, state: str, symbol: str) -> str:
        """查询转移（使用默认值）"""
        return self.transitions.get((state, symbol), self.default_state)
```

---

### 7.2 转移缓存

**问题**：频繁计算相同的转移

**解决方案**：缓存转移结果

```python
from functools import lru_cache

class CachedTransitionFunction:
    """带缓存的转移函数"""

    def __init__(self):
        self.transitions = {}

    def add_transition(self, from_state: str, symbol: str, to_state: str):
        self.transitions[(from_state, symbol)] = to_state

    @lru_cache(maxsize=1024)
    def __call__(self, state: str, symbol: str) -> str:
        """带缓存的转移查询"""
        return self.transitions[(state, symbol)]
```

---

## 八、总结

### 核心要点

1. **定义**：δ: Q × Σ → Q（DFA）或 δ: Q × (Σ ∪ {ε}) → P(Q)（NFA）
2. **表示方法**：转移表、转移图、转移矩阵
3. **实现方式**：字典、嵌套字典、面向对象
4. **扩展**：δ*处理字符串、状态集合
5. **性质**：完整性、确定性、可达性
6. **AI Agent应用**：决策函数、条件转移

### 实现建议

| 场景 | 推荐实现 | 原因 |
|------|---------|------|
| **小型DFA** | 字典 | 简单直接 |
| **大型DFA** | 嵌套字典 | 查询效率高 |
| **面向对象** | State类 | 封装性好 |
| **条件转移** | 条件函数 | 灵活性高 |
| **高频查询** | 缓存 | 性能优化 |

### 学习建议

1. **理解形式化定义**：δ的数学含义
2. **掌握多种表示**：表、图、矩阵
3. **实践多种实现**：字典、OOP、函数式
4. **学习扩展**：δ*的递归定义
5. **应用到Agent**：决策函数设计

---

## 参考资料

1. **经典理论**：
   - Wikipedia - Finite-state machine
   - GeeksforGeeks - Transition Function
   - Stanford - Automata Theory

2. **实现参考**：
   - Stack Overflow - Transition function implementation
   - Design Patterns - State Pattern

3. **AI Agent应用**：
   - LangGraph - State transitions
   - Agent decision functions

---

**版本**: v1.0
**最后更新**: 2026-02-14
**代码行数**: ~400行
