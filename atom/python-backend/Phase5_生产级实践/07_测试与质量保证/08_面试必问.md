# 面试必问 - 测试与质量保证

## 基础概念题

### Q1: 什么是单元测试、集成测试、端到端测试？它们的区别是什么？

**答案**：

**单元测试（Unit Test）**：
- 测试最小的可测试单元（函数、方法、类）
- 完全隔离，Mock 所有依赖
- 速度快（毫秒级）
- 易于定位问题

**集成测试（Integration Test）**：
- 测试多个组件协作
- 使用真实依赖（数据库、缓存等）
- 速度中等（秒级）
- 验证组件间接口

**端到端测试（E2E Test）**：
- 测试完整的用户场景
- 从开始到结束的完整流程
- 速度慢（分钟级）
- 最接近真实使用

**对比表格**：

| 维度 | 单元测试 | 集成测试 | E2E测试 |
|------|----------|----------|---------|
| 范围 | 单个函数 | 多个组件 | 完整流程 |
| 依赖 | Mock所有 | 部分真实 | 全部真实 |
| 速度 | 快 | 中 | 慢 |
| 定位 | 精确到函数 | 精确到模块 | 只知道流程失败 |
| 比例 | 60% | 30% | 10% |

**示例**：

```python
# 单元测试
def test_add():
    assert add(2, 3) == 5

# 集成测试
def test_user_repository(db_session):
    repo = UserRepository(db_session)
    user = repo.create("alice", "alice@example.com")
    assert user.id is not None

# E2E测试
def test_user_registration_flow(client):
    # 注册 → 登录 → 操作 → 登出
    response = client.post("/register", json={...})
    assert response.status_code == 201
```

---

### Q2: 什么是 TDD（测试驱动开发）？它的优缺点是什么？

**答案**：

**TDD 定义**：
先写测试，再写代码，最后重构

**TDD 三步骤**：
1. **Red**：写一个失败的测试
2. **Green**：写最少的代码让测试通过
3. **Refactor**：重构代码，保持测试通过

**优点**：
- ✅ 设计驱动：先思考接口，再实现
- ✅ 快速反馈：立即知道代码是否正确
- ✅ 重构安全：有测试保护
- ✅ 文档化：测试即文档

**缺点**：
- ❌ 初期慢：写测试需要时间
- ❌ 学习曲线：需要改变思维方式
- ❌ 过度测试：可能测试太多细节
- ❌ 维护成本：测试也需要维护

**示例**：

```python
# Step 1: Red - 写失败的测试
def test_chunk_text():
    text = "Hello world"
    chunks = chunk_text(text, chunk_size=5)
    assert len(chunks) == 2  # 失败，函数还不存在

# Step 2: Green - 写代码让测试通过
def chunk_text(text: str, chunk_size: int) -> list[str]:
    return [text[i:i+chunk_size] for i in range(0, len(text), chunk_size)]

# Step 3: Refactor - 重构
def chunk_text(text: str, chunk_size: int) -> list[str]:
    if chunk_size <= 0:
        raise ValueError("chunk_size must be positive")
    return [text[i:i+chunk_size] for i in range(0, len(text), chunk_size)]
```

---

### Q3: 什么是测试覆盖率？100%覆盖率意味着什么？

**答案**：

**测试覆盖率定义**：
测试执行的代码行数 / 总代码行数

**覆盖率类型**：
- **行覆盖率**：执行的代码行
- **分支覆盖率**：执行的分支（if/else）
- **函数覆盖率**：调用的函数
- **语句覆盖率**：执行的语句

**100%覆盖率的误区**：

❌ **不代表没有 bug**：
```python
def divide(a, b):
    return a / b

def test_divide():
    divide(10, 2)  # 100%覆盖率，但没测试除以零
```

❌ **不代表测试质量高**：
```python
def test_user_creation():
    user = User(username="test")
    # 没有断言，但覆盖率100%
```

✅ **合理的覆盖率目标**：
- 核心业务逻辑：90%+
- 工具函数：80%+
- 配置和常量：不需要测试

**示例**：

```bash
# 生成覆盖率报告
pytest --cov=app --cov-report=html

# 输出
Name                Stmts   Miss  Cover
---------------------------------------
app/utils.py           50      5    90%
app/services.py        80     10    87%
---------------------------------------
TOTAL                 130     15    88%
```

---

## pytest 相关题

### Q4: pytest 的 fixture 是什么？它有哪些作用域？

**答案**：

**Fixture 定义**：
测试的前置准备和后置清理

**作用域（Scope）**：

1. **function**（默认）：每个测试函数创建一次
2. **class**：每个测试类创建一次
3. **module**：每个测试模块创建一次
4. **session**：整个测试会话创建一次

**示例**：

```python
# function 作用域
@pytest.fixture(scope="function")
def user():
    return User(username="test")

def test_1(user):
    user.age = 25
    assert user.age == 25

def test_2(user):
    # 获得新的 user 实例
    assert not hasattr(user, 'age')

# session 作用域
@pytest.fixture(scope="session")
def db_engine():
    engine = create_engine("sqlite:///:memory:")
    yield engine
    engine.dispose()

# 依赖其他 fixture
@pytest.fixture
def db_session(db_engine):
    session = Session(bind=db_engine)
    yield session
    session.close()
```

**Fixture 的优势**：
- 复用测试数据
- 自动清理资源
- 依赖注入
- 作用域控制

---

### Q5: 如何在 pytest 中进行参数化测试？

**答案**：

**使用 @pytest.mark.parametrize**：

```python
import pytest

@pytest.mark.parametrize("a,b,expected", [
    (2, 3, 5),
    (0, 0, 0),
    (-1, 1, 0),
    (100, 200, 300),
])
def test_add(a, b, expected):
    assert add(a, b) == expected
```

**运行结果**：
```
test_add[2-3-5] PASSED
test_add[0-0-0] PASSED
test_add[-1-1-0] PASSED
test_add[100-200-300] PASSED
```

**多参数组合**：

```python
@pytest.mark.parametrize("text", ["Hello", "World"])
@pytest.mark.parametrize("chunk_size", [5, 10])
def test_chunk_text(text, chunk_size):
    result = chunk_text(text, chunk_size)
    assert isinstance(result, list)

# 生成 2 × 2 = 4 个测试用例
```

**使用 pytest.param 添加标记**：

```python
@pytest.mark.parametrize("value,expected", [
    (1, 2),
    (2, 4),
    pytest.param(1000, 2000, marks=pytest.mark.slow),
])
def test_double(value, expected):
    assert double(value) == expected
```

---

### Q6: 如何测试异常？

**答案**：

**使用 pytest.raises**：

```python
import pytest

def test_divide_by_zero():
    """测试：除以零应该抛出异常"""
    with pytest.raises(ValueError):
        divide(10, 0)

# 验证异常消息
def test_divide_by_zero_message():
    """测试：验证异常消息"""
    with pytest.raises(ValueError, match="除数不能为零"):
        divide(10, 0)

# 捕获异常对象
def test_divide_by_zero_details():
    """测试：检查异常详情"""
    with pytest.raises(ValueError) as exc_info:
        divide(10, 0)

    assert "除数" in str(exc_info.value)
    assert exc_info.type == ValueError
```

**测试不应该抛出异常**：

```python
def test_no_exception():
    """测试：不应该抛出异常"""
    try:
        result = safe_divide(10, 2)
        assert result == 5
    except Exception as e:
        pytest.fail(f"Unexpected exception: {e}")
```

---

## FastAPI 测试题

### Q7: 如何测试 FastAPI 端点？

**答案**：

**使用 TestClient**：

```python
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_read_root():
    """测试：根路径"""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}

def test_create_user():
    """测试：创建用户"""
    response = client.post("/api/users", json={
        "username": "alice",
        "email": "alice@example.com"
    })
    assert response.status_code == 201
    data = response.json()
    assert data["username"] == "alice"

def test_protected_endpoint():
    """测试：受保护端点"""
    response = client.get(
        "/api/users/me",
        headers={"Authorization": "Bearer token123"}
    )
    assert response.status_code == 200
```

**覆盖依赖注入**：

```python
from app.dependencies import get_db

def test_with_mock_db():
    """测试：使用 Mock 数据库"""
    def override_get_db():
        return MockDatabase()

    app.dependency_overrides[get_db] = override_get_db

    response = client.get("/api/users")
    assert response.status_code == 200

    app.dependency_overrides.clear()
```

---

### Q8: 如何测试异步端点？

**答案**：

**使用 httpx.AsyncClient**：

```python
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_async_endpoint():
    """测试：异步端点"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/api/async-data")
        assert response.status_code == 200
        assert response.json()["data"] is not None

@pytest.mark.asyncio
async def test_streaming_endpoint():
    """测试：流式端点"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        async with client.stream("GET", "/api/stream") as response:
            assert response.status_code == 200

            chunks = []
            async for chunk in response.aiter_text():
                chunks.append(chunk)

            assert len(chunks) > 0
```

**配置 pytest-asyncio**：

```ini
# pytest.ini
[pytest]
asyncio_mode = auto
```

---

## 数据库测试题

### Q9: 如何测试数据库操作？

**答案**：

**策略1：使用测试数据库**

```python
@pytest.fixture(scope="session")
def db_engine():
    """测试数据库引擎"""
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)
```

**策略2：事务回滚**

```python
@pytest.fixture
def db_session(db_engine):
    """数据库会话（事务回滚）"""
    connection = db_engine.connect()
    transaction = connection.begin()
    session = Session(bind=connection)

    yield session

    session.close()
    transaction.rollback()
    connection.close()
```

**测试示例**：

```python
def test_create_user(db_session):
    """测试：创建用户"""
    user = User(username="alice", email="alice@example.com")
    db_session.add(user)
    db_session.commit()

    assert user.id is not None

def test_query_user(db_session):
    """测试：查询用户"""
    user = User(username="alice", email="alice@example.com")
    db_session.add(user)
    db_session.commit()

    found = db_session.query(User).filter_by(username="alice").first()
    assert found is not None
```

---

### Q10: 如何测试数据库事务？

**答案**：

**测试事务提交**：

```python
def test_transaction_commit(db_session):
    """测试：事务提交"""
    user = User(username="alice")
    db_session.add(user)
    db_session.commit()

    # 验证已提交
    found = db_session.query(User).filter_by(username="alice").first()
    assert found is not None
```

**测试事务回滚**：

```python
def test_transaction_rollback(db_session):
    """测试：事务回滚"""
    user = User(username="alice")
    db_session.add(user)
    db_session.flush()  # 不提交

    # 手动回滚
    db_session.rollback()

    # 验证已回滚
    found = db_session.query(User).filter_by(username="alice").first()
    assert found is None
```

**测试异常回滚**：

```python
def test_exception_rollback(db_session):
    """测试：异常时回滚"""
    try:
        user1 = User(username="alice")
        db_session.add(user1)

        # 触发异常
        user2 = User(username="alice")  # 重复用户名
        db_session.add(user2)
        db_session.commit()
    except Exception:
        db_session.rollback()

    # 验证都未提交
    count = db_session.query(User).count()
    assert count == 0
```

---

## Mock 相关题

### Q11: 什么是 Mock？什么时候应该使用 Mock？

**答案**：

**Mock 定义**：
模拟对象，用于替代真实的依赖

**使用场景**：
1. **外部 API 调用**：OpenAI、第三方服务
2. **慢速操作**：文件 I/O、网络请求
3. **不确定性操作**：随机数、时间
4. **难以触发的场景**：异常、边界条件

**示例**：

```python
from unittest.mock import Mock, patch

# Mock 外部 API
def test_llm_call():
    """测试：LLM 调用"""
    mock_response = Mock()
    mock_response.content = "这是回复"

    with patch("openai.chat.completions.create") as mock_create:
        mock_create.return_value = mock_response

        result = get_llm_response("你好")

        assert result == "这是回复"
        mock_create.assert_called_once()

# Mock 时间
def test_with_fixed_time():
    """测试：固定时间"""
    from datetime import datetime

    fixed_time = datetime(2024, 1, 1, 12, 0, 0)

    with patch("datetime.datetime") as mock_datetime:
        mock_datetime.now.return_value = fixed_time

        result = get_current_time()

        assert result == fixed_time
```

**Mock 的原则**：
- ✅ Mock 外部依赖
- ✅ Mock 不可控的部分
- ❌ 不 Mock 被测试的代码
- ❌ 不 Mock 简单对象

---

### Q12: Mock 和 Stub 的区别是什么？

**答案**：

**Stub**：
- 提供预定义的返回值
- 不验证交互
- 用于提供测试数据

**Mock**：
- 提供返回值 + 验证交互
- 验证方法是否被调用
- 验证调用参数

**示例**：

```python
# Stub
class StubUserRepository:
    def get_by_id(self, user_id: int):
        return User(id=user_id, username="test")

def test_with_stub():
    repo = StubUserRepository()
    user = repo.get_by_id(1)
    assert user.username == "test"

# Mock
def test_with_mock():
    mock_repo = Mock()
    mock_repo.get_by_id.return_value = User(id=1, username="test")

    service = UserService(mock_repo)
    user = service.get_user(1)

    # 验证交互
    mock_repo.get_by_id.assert_called_once_with(1)
```

---

## AI Agent 测试题

### Q13: 如何测试 LLM 的输出？

**答案**：

**挑战**：
- LLM 输出不确定
- 每次运行结果可能不同
- 无法精确匹配

**解决方案**：

**1. 测试输出结构**：

```python
def test_llm_output_structure():
    """测试：输出结构"""
    response = llm.invoke("什么是RAG?")

    assert isinstance(response, str)
    assert len(response) > 0
    assert len(response) < 1000
```

**2. 测试关键信息**：

```python
def test_llm_output_keywords():
    """测试：包含关键词"""
    response = llm.invoke("什么是RAG?")

    keywords = ["RAG", "检索", "生成"]
    assert any(keyword in response for keyword in keywords)
```

**3. 使用确定性输出**：

```python
def test_llm_deterministic():
    """测试：确定性输出"""
    llm = ChatOpenAI(temperature=0)

    response1 = llm.invoke("1+1=?")
    response2 = llm.invoke("1+1=?")

    assert "2" in response1
    assert "2" in response2
```

**4. Mock LLM 调用**：

```python
def test_llm_mock():
    """测试：Mock LLM"""
    mock_llm = Mock()
    mock_llm.invoke.return_value = "这是测试回复"

    agent = create_agent(llm=mock_llm)
    result = agent.run("测试")

    assert result == "这是测试回复"
```

---

### Q14: 如何测试 RAG 检索？

**答案**：

**测试策略**：

**1. 测试检索功能**：

```python
def test_rag_retrieval(vector_store):
    """测试：RAG 检索"""
    query = "什么是 RAG?"
    results = vector_store.similarity_search(query, k=3)

    assert len(results) == 3
    assert "RAG" in results[0].page_content
```

**2. 测试相似度**：

```python
def test_retrieval_relevance(vector_store):
    """测试：检索相关性"""
    query = "Python 框架"
    results = vector_store.similarity_search_with_score(query, k=5)

    # 验证相似度递减
    scores = [score for _, score in results]
    assert scores == sorted(scores, reverse=True)
```

**3. 测试边界条件**：

```python
def test_retrieval_empty_query(vector_store):
    """测试：空查询"""
    results = vector_store.similarity_search("", k=3)
    assert isinstance(results, list)

def test_retrieval_large_k(vector_store):
    """测试：k 值过大"""
    results = vector_store.similarity_search("test", k=1000)
    assert len(results) <= 1000
```

---

### Q15: 如何测试流式输出？

**答案**：

**测试策略**：

**1. 收集所有 chunk**：

```python
@pytest.mark.asyncio
async def test_streaming_output():
    """测试：流式输出"""
    chunks = []
    async for chunk in agent.astream("你好"):
        chunks.append(chunk)

    assert len(chunks) > 0
    full_response = "".join(chunks)
    assert len(full_response) > 0
```

**2. 测试流的开始和结束**：

```python
@pytest.mark.asyncio
async def test_streaming_events():
    """测试：流式事件"""
    chunks = []
    async for chunk in agent.astream("测试"):
        chunks.append(chunk)

    # 验证有开始
    assert len(chunks) > 0

    # 验证有结束
    assert chunks[-1] is not None
```

**3. Mock 流式输出**：

```python
@pytest.mark.asyncio
async def test_streaming_mock():
    """测试：Mock 流式输出"""
    async def mock_stream(prompt):
        for chunk in ["Hello", " ", "World"]:
            yield chunk

    with patch.object(agent, 'astream', side_effect=mock_stream):
        chunks = [chunk async for chunk in agent.astream("test")]

        assert chunks == ["Hello", " ", "World"]
```

---

## 最佳实践题

### Q16: 测试的最佳实践有哪些？

**答案**：

**1. 测试命名**：
```python
# ✅ 好的命名
def test_user_creation_with_valid_data_should_succeed():
    pass

# ❌ 不好的命名
def test1():
    pass
```

**2. 测试独立性**：
```python
# ✅ 每个测试独立
@pytest.fixture
def clean_db():
    db = create_db()
    yield db
    db.drop_all()

# ❌ 测试间依赖
global_user = None
def test_create():
    global global_user
    global_user = User()
```

**3. 一个测试一个断言**：
```python
# ✅ 单一职责
def test_user_username():
    user = User(username="alice")
    assert user.username == "alice"

# ❌ 多个断言
def test_user():
    user = User(username="alice", email="alice@example.com")
    assert user.username == "alice"
    assert user.email == "alice@example.com"
    assert user.is_active is True
```

**4. 测试覆盖关键路径**：
- 正常情况
- 边界条件
- 异常情况

**5. 使用 fixture 复用代码**：
```python
@pytest.fixture
def sample_user():
    return User(username="test")

def test_1(sample_user):
    assert sample_user.username == "test"
```

---

### Q17: 如何组织测试代码？

**答案**：

**推荐结构**：

```
tests/
├── conftest.py              # 全局 fixture
├── unit/                    # 单元测试
│   ├── test_utils.py
│   └── test_services.py
├── integration/             # 集成测试
│   ├── test_database.py
│   └── test_repositories.py
├── api/                     # API 测试
│   ├── test_users_api.py
│   └── test_auth_api.py
├── e2e/                     # 端到端测试
│   └── test_user_flow.py
├── fixtures/                # 共享 fixture
│   ├── database.py
│   └── users.py
└── helpers/                 # 测试辅助函数
    ├── auth.py
    └── factories.py
```

**命名约定**：
- 测试文件：`test_*.py`
- 测试类：`Test*`
- 测试函数：`test_*`

**标记分类**：
```python
@pytest.mark.unit
@pytest.mark.fast
def test_calculation():
    pass

@pytest.mark.integration
@pytest.mark.slow
def test_database():
    pass
```

---

## 总结

### 核心要点

1. **测试类型**：单元、集成、E2E，各有用途
2. **pytest 基础**：fixture、参数化、异常测试
3. **FastAPI 测试**：TestClient、异步测试
4. **数据库测试**：测试数据库、事务回滚
5. **Mock 技巧**：隔离依赖、验证交互
6. **AI Agent 测试**：测试结构、Mock LLM、测试流式输出

### 面试技巧

1. **理解原理**：不只是会用，要知道为什么
2. **实战经验**：结合项目经验回答
3. **权衡取舍**：讨论优缺点和适用场景
4. **最佳实践**：展示对测试的深入理解
5. **持续学习**：关注测试领域的新发展
