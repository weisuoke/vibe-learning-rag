# 第一性原理

> **从根本问题出发，推导出自定义工具注册的必然性**

## 什么是第一性原理？

第一性原理思维是一种从最基本的真理出发，逐步推导出结论的思考方式。在理解自定义工具注册时，我们不直接记忆 API 和用法,而是从根本问题出发，理解为什么需要这样的机制。

---

## 推理链：从问题到解决方案

### 第一层：AI Agent 的根本限制

**基本事实 1：LLM 只能处理文本**

```
输入：文本（用户消息、上下文）
处理：文本生成（预测下一个 token）
输出：文本（回复消息）
```

**基本事实 2：现实世界的任务需要与外部系统交互**

```
用户需求：
- 读取文件内容
- 搜索代码
- 调用 API
- 执行命令
- 查询数据库
- 生成图片
```

**推导 1：LLM 无法直接完成这些任务**

```
LLM 的能力边界：
✓ 理解自然语言
✓ 生成文本
✓ 推理和规划
✗ 读取文件
✗ 执行代码
✗ 调用 API
```

**结论 1：需要一种机制让 LLM 能够"调用"外部能力**

---

### 第二层：如何让 LLM 调用外部能力？

**问题：LLM 如何表达"我想读取文件"？**

**方案 1：让 LLM 生成代码**
```python
# LLM 生成
with open('file.txt') as f:
    content = f.read()
```

**问题：**
- 不安全（任意代码执行）
- 不可控（无法限制权限）
- 不可靠（代码可能有错误）

**方案 2：让 LLM 生成结构化的"调用指令"**
```json
{
  "action": "read_file",
  "parameters": {
    "path": "file.txt"
  }
}
```

**优势：**
- 安全（只能调用预定义的操作）
- 可控（可以验证参数）
- 可靠（由框架执行）

**推导 2：需要一种标准化的"调用指令"格式**

**结论 2：这就是 Tool Definition 的由来**

---

### 第三层：如何定义"调用指令"？

**问题：LLM 如何知道有哪些工具可用？**

**需求分析：**

1. **工具标识**：LLM 需要知道工具的名称
2. **工具描述**：LLM 需要理解工具的用途
3. **参数定义**：LLM 需要知道如何传递参数
4. **执行逻辑**：框架需要知道如何执行工具

**推导 3：需要一个完整的工具描述接口**

```typescript
interface ToolDefinition {
  name: string;              // 工具标识
  description: string;       // 工具描述（给 LLM 看）
  parameters: Schema;        // 参数定义（给 LLM 看）
  execute: Function;         // 执行逻辑（给框架用）
}
```

**结论 3：Tool Definition 必须包含这四个要素**

---

### 第四层：如何描述参数？

**问题：LLM 如何知道参数的类型和约束？**

**场景：文件读取工具**

```typescript
// 需要告诉 LLM：
// 1. 参数名是 "path"
// 2. 类型是字符串
// 3. 必须提供（不是可选的）
// 4. 应该是文件路径
```

**方案 1：用自然语言描述**
```
"参数 path 是一个字符串，表示文件路径，必须提供"
```

**问题：**
- LLM 可能理解错误
- 无法自动验证
- 不够精确

**方案 2：用结构化 Schema**
```json
{
  "type": "object",
  "properties": {
    "path": {
      "type": "string",
      "description": "File path to read"
    }
  },
  "required": ["path"]
}
```

**优势：**
- LLM 可以准确理解
- 可以自动验证参数
- 标准化格式（JSON Schema）

**推导 4：需要使用 JSON Schema 描述参数**

**为什么选择 TypeBox？**

```typescript
// TypeBox 提供：
// 1. TypeScript 类型推导（编译时）
Type.Object({
  path: Type.String()
})
// → { path: string }

// 2. JSON Schema 生成（运行时）
// → { "type": "object", "properties": { "path": { "type": "string" } } }

// 3. 运行时验证
// → 自动验证参数是否符合 Schema
```

**结论 4：使用 TypeBox 定义参数 Schema**

---

### 第五层：如何执行工具？

**问题：框架如何执行工具的实际逻辑？**

**需求分析：**

1. **接收参数**：从 LLM 的调用指令中提取参数
2. **验证参数**：确保参数符合 Schema
3. **执行逻辑**：调用实际的操作（读文件、调 API 等）
4. **返回结果**：将结果返回给 LLM

**推导 5：需要一个执行函数**

```typescript
type ExecuteFunction = (
  params: any,                    // 已验证的参数
  context: ExtensionContext       // 执行上下文
) => Promise<AgentToolResult>;    // 返回结果
```

**为什么必须是 async？**

```
现实世界的操作大多是异步的：
- 读取文件：I/O 操作
- 调用 API：网络请求
- 查询数据库：数据库查询
- 等待用户输入：交互操作

→ 统一使用 async 函数
→ 简化框架实现
→ 支持取消操作（AbortSignal）
```

**结论 5：execute 必须是 async 函数**

---

### 第六层：如何注册工具？

**问题：框架如何知道有哪些工具可用？**

**需求分析：**

1. **工具收集**：从各个 Extension 收集工具
2. **工具存储**：统一管理所有工具
3. **工具发现**：LLM 需要知道所有可用工具
4. **工具调用**：根据 LLM 的指令调用对应工具

**推导 6：需要一个注册机制**

```typescript
// Extension 注册工具
context.registerTool(toolDefinition);

// 框架收集工具
const tools = getAllRegisteredTools();

// 发送给 LLM
const response = await llm.chat({
  messages: [...],
  tools: tools  // LLM 可以调用这些工具
});
```

**为什么在 Extension 的 activate 中注册？**

```
Extension 生命周期：
1. 加载 Extension
2. 调用 activate 函数
3. Extension 注册工具、监听事件等
4. Extension 激活完成

→ activate 是 Extension 的初始化阶段
→ 在这里注册工具，确保工具在使用前就绪
```

**结论 6：在 Extension 的 activate 中调用 registerTool**

---

### 第七层：如何处理工具调用？

**问题：LLM 决定调用工具后，发生了什么？**

**完整流程：**

```
1. 用户输入
   ↓
2. LLM 理解意图
   ↓
3. LLM 决定调用工具
   ↓
4. LLM 生成调用指令
   {
     "name": "read_file",
     "parameters": { "path": "file.txt" }
   }
   ↓
5. 框架接收调用指令
   ↓
6. 框架验证参数（TypeBox）
   ↓
7. 框架触发 tool_call 事件
   ↓
8. 框架调用 tool.execute()
   ↓
9. 工具执行实际逻辑
   ↓
10. 工具返回结果
    {
      "content": "File content: ..."
    }
    ↓
11. 框架触发 tool_result 事件
    ↓
12. 框架将结果返回给 LLM
    ↓
13. LLM 生成最终回复
    ↓
14. 用户收到回复
```

**推导 7：需要事件系统支持扩展**

```typescript
// Extension 可以监听工具调用
context.on('tool_call', (event) => {
  console.log('Tool called:', event.tool.name);
  // 可以记录日志、修改参数等
});

context.on('tool_result', (event) => {
  console.log('Tool result:', event.result);
  // 可以记录日志、修改结果等
});
```

**结论 7：事件系统提供了强大的扩展能力**

---

### 第八层：如何优化用户体验？

**问题：如何让用户知道工具正在执行？**

**需求分析：**

1. **调用提示**：显示"正在读取文件..."
2. **进度反馈**：显示"已处理 50%..."
3. **结果展示**：格式化显示结果

**推导 8：需要自定义渲染**

```typescript
// 自定义调用显示
renderCall: (params) => {
  return `Reading file: ${params.path}`;
}

// 自定义结果显示
renderResult: (result) => {
  return `File content (${result.content.length} bytes):\n${result.content}`;
}
```

**推导 9：需要流式更新**

```typescript
const execute = async (params, context) => {
  const { onUpdate } = context;
  
  // 实时更新进度
  onUpdate?.({ content: 'Starting...' });
  await step1();
  
  onUpdate?.({ content: 'Processing...' });
  await step2();
  
  onUpdate?.({ content: 'Finishing...' });
  await step3();
  
  return { content: 'Complete!' };
};
```

**结论 8：自定义渲染和流式更新提升用户体验**

---

## 完整推理链总结

```
问题 1: LLM 无法直接与外部系统交互
  ↓
解决方案 1: 让 LLM 生成结构化的"调用指令"
  ↓
问题 2: 如何定义"调用指令"的格式？
  ↓
解决方案 2: Tool Definition 接口（name, description, parameters, execute）
  ↓
问题 3: 如何描述参数？
  ↓
解决方案 3: 使用 JSON Schema（TypeBox）
  ↓
问题 4: 如何执行工具？
  ↓
解决方案 4: async execute 函数
  ↓
问题 5: 如何注册工具？
  ↓
解决方案 5: registerTool API（在 Extension 的 activate 中）
  ↓
问题 6: 如何扩展工具行为？
  ↓
解决方案 6: 事件系统（tool_call, tool_result）
  ↓
问题 7: 如何优化用户体验？
  ↓
解决方案 7: 自定义渲染 + 流式更新
  ↓
最终结果: 完整的自定义工具注册机制
```

---

## 核心设计原则

从第一性原理推导出的设计原则：

### 1. 声明式而非命令式

**原则：**
- 工具注册是"声明"工具的存在
- 不是"命令"框架做某事

**体现：**
```typescript
// 声明式：告诉框架"我有这个工具"
context.registerTool({
  name: 'read_file',
  description: 'Read file content',
  parameters: Type.Object({ path: Type.String() }),
  execute: async ({ path }) => { /* ... */ }
});

// 而不是命令式："现在执行读文件"
context.executeCommand('read_file', { path: 'file.txt' });
```

### 2. 类型安全优先

**原则：**
- 编译时类型检查（TypeScript）
- 运行时类型验证（TypeBox）
- 双重保障

**体现：**
```typescript
// TypeScript 类型推导
const params = Type.Object({
  age: Type.Number()
});
type Params = Static<typeof params>;
// Params = { age: number }

// 运行时验证
if (!validate(params, input)) {
  throw new Error('Invalid parameters');
}
```

### 3. 异步优先

**原则：**
- 所有工具都是异步的
- 统一接口，简化实现
- 支持取消和进度反馈

**体现：**
```typescript
// 统一的异步接口
const execute = async (params, context) => {
  // 支持 AbortSignal
  if (context.signal.aborted) return;
  
  // 支持 onUpdate
  context.onUpdate?.({ content: 'Progress...' });
  
  return { content: 'Result' };
};
```

### 4. 可扩展性

**原则：**
- 事件系统支持拦截和修改
- 自定义渲染支持个性化显示
- Extension 可以扩展工具行为

**体现：**
```typescript
// 监听工具调用
context.on('tool_call', (event) => {
  // 可以记录日志
  // 可以修改参数
  // 可以阻止调用（未来可能支持）
});

// 自定义渲染
renderCall: (params) => {
  // 自定义显示格式
};
```

### 5. 用户体验优先

**原则：**
- 实时反馈（onUpdate）
- 清晰显示（renderCall, renderResult）
- 友好错误信息

**体现：**
```typescript
// 实时进度
onUpdate?.({ content: 'Processing 50%...' });

// 友好错误
return { 
  content: 'Error: File not found. Please check the file path.' 
};
```

---

## 与其他方案的对比

### 方案 1：直接代码执行

```python
# LLM 生成代码
code = """
with open('file.txt') as f:
    content = f.read()
"""
exec(code)
```

**问题：**
- ❌ 不安全（任意代码执行）
- ❌ 不可控（无法限制权限）
- ❌ 不可靠（代码可能有错误）

### 方案 2：固定命令集

```typescript
// 预定义命令
const commands = {
  'read_file': (path) => fs.readFile(path),
  'write_file': (path, content) => fs.writeFile(path, content)
};

// LLM 生成命令
const command = 'read_file';
const args = ['file.txt'];
commands[command](...args);
```

**问题：**
- ❌ 不可扩展（无法添加新命令）
- ❌ 参数验证困难
- ❌ 缺少类型安全

### 方案 3：自定义工具注册（Pi-mono）

```typescript
// 可扩展的工具注册
context.registerTool({
  name: 'read_file',
  description: 'Read file content',
  parameters: Type.Object({
    path: Type.String({ description: 'File path' })
  }),
  execute: async ({ path }) => {
    const content = await fs.readFile(path, 'utf-8');
    return { content };
  }
});
```

**优势：**
- ✅ 安全（只能调用注册的工具）
- ✅ 可扩展（Extension 可以注册新工具）
- ✅ 类型安全（TypeBox + TypeScript）
- ✅ 可控（参数验证、权限控制）
- ✅ 用户体验好（自定义渲染、进度反馈）

---

## 实战推导：设计一个新工具

**需求：设计一个天气查询工具**

### 步骤 1：定义问题

```
用户需求：查询城市天气
LLM 需要：
- 知道有"天气查询"这个工具
- 知道需要提供"城市名称"参数
- 调用工具并获取结果
```

### 步骤 2：设计 Tool Definition

```typescript
{
  // 工具标识
  name: 'get_weather',
  
  // 工具描述（给 LLM 看）
  description: 'Get current weather for a city',
  
  // 参数定义（给 LLM 看）
  parameters: Type.Object({
    city: Type.String({
      description: 'City name (e.g., Beijing, Shanghai)'
    })
  }),
  
  // 执行逻辑（给框架用）
  execute: async ({ city }, context) => {
    // 实际逻辑
  }
}
```

### 步骤 3：实现 execute 函数

```typescript
execute: async ({ city }, context) => {
  try {
    // 1. 调用天气 API
    const weather = await fetchWeather(city);
    
    // 2. 返回结果
    return {
      content: `Weather in ${city}: ${weather}`,
      metadata: {
        city,
        temperature: weather.temperature,
        condition: weather.condition
      }
    };
  } catch (error) {
    // 3. 错误处理
    context.logger.error('Weather API error:', error);
    return {
      content: `Failed to get weather for ${city}: ${error.message}`
    };
  }
}
```

### 步骤 4：添加自定义渲染

```typescript
renderCall: (params) => {
  return `🌤️ Checking weather for ${params.city}...`;
},

renderResult: (result) => {
  if (result.metadata?.temperature) {
    return `🌡️ ${result.content}`;
  }
  return result.content;
}
```

### 步骤 5：注册工具

```typescript
export const weatherExtension: Extension = {
  name: 'weather-extension',
  version: '1.0.0',
  
  async activate(context) {
    context.registerTool({
      name: 'get_weather',
      description: 'Get current weather for a city',
      parameters: Type.Object({
        city: Type.String({
          description: 'City name (e.g., Beijing, Shanghai)'
        })
      }),
      execute: async ({ city }, context) => {
        // ... 实现
      },
      renderCall: (params) => {
        // ... 实现
      },
      renderResult: (result) => {
        // ... 实现
      }
    });
    
    context.logger.info('Weather tool registered');
  }
};
```

---

## 深度理解：为什么这样设计？

### 问题 1：为什么不直接让 LLM 执行代码？

**答案：安全性和可控性**

```
直接执行代码的风险：
1. 任意代码执行（安全漏洞）
2. 无法限制权限（可能删除文件、访问敏感数据）
3. 代码可能有错误（导致程序崩溃）
4. 难以审计和监控

工具注册的优势：
1. 只能调用预定义的工具（安全）
2. 可以限制工具的权限（可控）
3. 框架负责执行（可靠）
4. 可以记录所有工具调用（可审计）
```

### 问题 2：为什么使用 TypeBox 而不是 Zod？

**答案：性能和 LLM 友好**

```
TypeBox 优势：
1. 生成标准 JSON Schema（LLM 可以直接理解）
2. 性能更好（编译时优化）
3. 与 pi-mono 的类型系统集成更好
4. 更轻量（包体积更小）

Zod 优势：
1. 更流行（社区更大）
2. API 更友好（链式调用）
3. 错误信息更详细

Pi-mono 选择 TypeBox 是因为：
- LLM 集成是核心需求
- 性能很重要（工具调用频繁）
- 类型系统集成很重要
```

### 问题 3：为什么需要事件系统？

**答案：可扩展性和可观测性**

```
事件系统的作用：
1. 可观测性
   - 记录所有工具调用
   - 监控工具性能
   - 调试工具问题

2. 可扩展性
   - Extension 可以拦截工具调用
   - 可以修改参数或结果
   - 可以添加额外的逻辑（如权限检查）

3. 解耦
   - 工具实现不需要知道有哪些监听器
   - 监听器不需要修改工具代码
   - 符合开闭原则（对扩展开放，对修改关闭）
```

---

## 总结：从第一性原理到实现

**核心推理链：**

```
1. LLM 无法直接与外部系统交互
   ↓
2. 需要让 LLM 生成结构化的"调用指令"
   ↓
3. 需要标准化的工具描述接口（Tool Definition）
   ↓
4. 需要类型安全的参数定义（TypeBox Schema）
   ↓
5. 需要异步执行函数（async execute）
   ↓
6. 需要注册机制（registerTool）
   ↓
7. 需要事件系统（tool_call, tool_result）
   ↓
8. 需要自定义渲染（renderCall, renderResult）
   ↓
9. 完整的自定义工具注册机制
```

**核心设计原则：**
1. 声明式而非命令式
2. 类型安全优先
3. 异步优先
4. 可扩展性
5. 用户体验优先

**关键洞察：**
- 工具注册不是"功能"，而是"架构"
- 它解决的是 LLM 与外部世界交互的根本问题
- 它的设计体现了安全性、可控性、可扩展性的平衡

理解了第一性原理，你就能理解为什么 Pi-mono 的自定义工具注册是这样设计的，以及如何设计自己的工具！
