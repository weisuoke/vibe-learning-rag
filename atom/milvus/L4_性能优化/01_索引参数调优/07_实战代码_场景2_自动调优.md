# 实战代码 - 场景2：生产环境参数自动调优

## 场景描述

在生产环境中，数据规模和查询模式会不断变化，需要根据实时监控数据自动调整索引参数。本示例展示如何实现自动参数调优系统。

---

## 完整代码

```python
"""
索引参数自动调优系统

功能：
1. 监控搜索性能指标
2. 检测性能退化
3. 自动调整参数
4. A/B 测试验证
5. 灰度发布

依赖：
pip install pymilvus numpy
"""

from pymilvus import connections, Collection, utility
import numpy as np
import time
from typing import Dict, List, Tuple
from collections import deque
from dataclasses import dataclass
import math

# ===== 1. 性能指标数据类 =====
@dataclass
class PerformanceMetrics:
    """性能指标"""
    timestamp: float
    avg_latency_ms: float
    p95_latency_ms: float
    p99_latency_ms: float
    qps: float
    num_vectors: int

# ===== 2. 性能监控器 =====
class PerformanceMonitor:
    """性能监控器"""

    def __init__(self, window_size: int = 1000):
        self.window_size = window_size
        self.latencies = deque(maxlen=window_size)
        self.timestamps = deque(maxlen=window_size)
        self.baseline_metrics = None

    def record_search(self, latency_ms: float):
        """记录搜索延迟"""
        self.latencies.append(latency_ms)
        self.timestamps.append(time.time())

    def get_current_metrics(self) -> PerformanceMetrics:
        """获取当前性能指标"""
        if len(self.latencies) == 0:
            return None

        latencies_sorted = sorted(self.latencies)
        n = len(latencies_sorted)

        # 计算 QPS
        if len(self.timestamps) >= 2:
            time_span = self.timestamps[-1] - self.timestamps[0]
            qps = len(self.timestamps) / time_span if time_span > 0 else 0
        else:
            qps = 0

        metrics = PerformanceMetrics(
            timestamp=time.time(),
            avg_latency_ms=np.mean(latencies_sorted),
            p95_latency_ms=latencies_sorted[int(n * 0.95)],
            p99_latency_ms=latencies_sorted[int(n * 0.99)],
            qps=qps,
            num_vectors=0  # 需要从外部获取
        )

        return metrics

    def set_baseline(self, metrics: PerformanceMetrics):
        """设置性能基线"""
        self.baseline_metrics = metrics
        print(f"设置性能基线:")
        print(f"  平均延迟: {metrics.avg_latency_ms:.2f}ms")
        print(f"  P95 延迟: {metrics.p95_latency_ms:.2f}ms")
        print(f"  QPS: {metrics.qps:.2f}")

    def detect_degradation(self, current_metrics: PerformanceMetrics) -> Tuple[bool, str]:
        """
        检测性能退化

        Returns:
            (is_degraded, reason)
        """
        if self.baseline_metrics is None:
            return False, ""

        # 检查延迟增长
        latency_increase = (
            current_metrics.p95_latency_ms / self.baseline_metrics.p95_latency_ms
        )

        if latency_increase > 1.5:
            return True, f"P95 延迟增长 {latency_increase:.1f}x"

        # 检查 QPS 下降
        if self.baseline_metrics.qps > 0:
            qps_decrease = (
                self.baseline_metrics.qps - current_metrics.qps
            ) / self.baseline_metrics.qps

            if qps_decrease > 0.3:
                return True, f"QPS 下降 {qps_decrease*100:.1f}%"

        return False, ""

# ===== 3. 参数优化器 =====
class ParameterOptimizer:
    """参数优化器"""

    def __init__(self, collection: Collection):
        self.collection = collection
        self.current_params = None

    def calculate_optimal_params(
        self,
        num_vectors: int,
        index_type: str,
        target_latency_ms: float = 100
    ) -> Dict:
        """
        根据数据规模和目标延迟计算最优参数

        Args:
            num_vectors: 向量数量
            index_type: 索引类型
            target_latency_ms: 目标延迟

        Returns:
            推荐的搜索参数
        """
        if index_type.startswith("IVF"):
            # IVF 系列索引
            nlist = int(2 * math.sqrt(num_vectors))

            # 根据目标延迟调整 nprobe
            if target_latency_ms < 50:
                nprobe = max(8, nlist // 50)  # 快速模式
            elif target_latency_ms < 100:
                nprobe = max(16, nlist // 30)  # 平衡模式
            else:
                nprobe = max(32, nlist // 20)  # 精确模式

            return {
                "metric_type": "L2",
                "params": {"nprobe": nprobe}
            }

        elif index_type == "HNSW":
            # HNSW 索引
            if target_latency_ms < 50:
                ef = 64  # 快速模式
            elif target_latency_ms < 100:
                ef = 128  # 平衡模式
            else:
                ef = 256  # 精确模式

            return {
                "metric_type": "L2",
                "params": {"ef": ef}
            }

        else:
            # 默认参数
            return {
                "metric_type": "L2",
                "params": {}
            }

    def adjust_params_for_degradation(
        self,
        current_params: Dict,
        index_type: str,
        reason: str
    ) -> Dict:
        """
        根据性能退化原因调整参数

        Args:
            current_params: 当前参数
            index_type: 索引类型
            reason: 退化原因

        Returns:
            调整后的参数
        """
        new_params = current_params.copy()

        if "延迟增长" in reason:
            # 延迟过高，减小搜索范围
            if index_type.startswith("IVF"):
                current_nprobe = current_params["params"].get("nprobe", 16)
                new_nprobe = max(8, int(current_nprobe * 0.7))
                new_params["params"]["nprobe"] = new_nprobe
                print(f"  调整 nprobe: {current_nprobe} → {new_nprobe}")

            elif index_type == "HNSW":
                current_ef = current_params["params"].get("ef", 128)
                new_ef = max(64, int(current_ef * 0.7))
                new_params["params"]["ef"] = new_ef
                print(f"  调整 ef: {current_ef} → {new_ef}")

        elif "QPS 下降" in reason:
            # QPS 下降，可能是资源不足，减小搜索范围
            if index_type.startswith("IVF"):
                current_nprobe = current_params["params"].get("nprobe", 16)
                new_nprobe = max(8, int(current_nprobe * 0.8))
                new_params["params"]["nprobe"] = new_nprobe
                print(f"  调整 nprobe: {current_nprobe} → {new_nprobe}")

        return new_params

# ===== 4. A/B 测试管理器 =====
class ABTestManager:
    """A/B 测试管理器"""

    def __init__(self, collection: Collection):
        self.collection = collection
        self.config_a = None  # 当前配置
        self.config_b = None  # 新配置
        self.traffic_split = 0.0  # B 配置的流量比例
        self.metrics_a = []
        self.metrics_b = []

    def start_ab_test(
        self,
        config_a: Dict,
        config_b: Dict,
        initial_traffic: float = 0.1
    ):
        """
        开始 A/B 测试

        Args:
            config_a: 当前配置
            config_b: 新配置
            initial_traffic: 初始流量比例（B 配置）
        """
        self.config_a = config_a
        self.config_b = config_b
        self.traffic_split = initial_traffic
        self.metrics_a = []
        self.metrics_b = []

        print(f"开始 A/B 测试:")
        print(f"  配置 A: {config_a['params']}")
        print(f"  配置 B: {config_b['params']}")
        print(f"  初始流量分配: A={1-initial_traffic:.0%}, B={initial_traffic:.0%}")

    def route_request(self, request_id: str) -> str:
        """
        路由请求到 A 或 B

        Args:
            request_id: 请求 ID

        Returns:
            "A" 或 "B"
        """
        # 使用哈希决定路由
        import hashlib
        hash_val = int(hashlib.md5(request_id.encode()).hexdigest(), 16)
        use_b = (hash_val % 100) < (self.traffic_split * 100)

        return "B" if use_b else "A"

    def get_config(self, variant: str) -> Dict:
        """获取配置"""
        return self.config_b if variant == "B" else self.config_a

    def record_metrics(self, variant: str, latency_ms: float):
        """记录指标"""
        if variant == "A":
            self.metrics_a.append(latency_ms)
        else:
            self.metrics_b.append(latency_ms)

    def compare_results(self) -> Dict:
        """
        对比 A/B 测试结果

        Returns:
            对比结果
        """
        if len(self.metrics_a) < 10 or len(self.metrics_b) < 10:
            return {"status": "insufficient_data"}

        avg_a = np.mean(self.metrics_a)
        avg_b = np.mean(self.metrics_b)
        p95_a = np.percentile(self.metrics_a, 95)
        p95_b = np.percentile(self.metrics_b, 95)

        improvement = (avg_a - avg_b) / avg_a

        result = {
            "status": "completed",
            "config_a_avg_ms": avg_a,
            "config_b_avg_ms": avg_b,
            "config_a_p95_ms": p95_a,
            "config_b_p95_ms": p95_b,
            "improvement_percent": improvement * 100,
            "winner": "B" if avg_b < avg_a else "A"
        }

        print(f"\nA/B 测试结果:")
        print(f"  配置 A: 平均 {avg_a:.2f}ms, P95 {p95_a:.2f}ms")
        print(f"  配置 B: 平均 {avg_b:.2f}ms, P95 {p95_b:.2f}ms")
        print(f"  性能变化: {improvement*100:+.1f}%")
        print(f"  胜出配置: {result['winner']}")

        return result

# ===== 5. 自动调优系统 =====
class AutoTuningSystem:
    """自动调优系统"""

    def __init__(
        self,
        collection: Collection,
        target_latency_ms: float = 100,
        check_interval_s: int = 300
    ):
        self.collection = collection
        self.target_latency_ms = target_latency_ms
        self.check_interval_s = check_interval_s

        self.monitor = PerformanceMonitor()
        self.optimizer = ParameterOptimizer(collection)
        self.ab_test = ABTestManager(collection)

        self.current_params = None
        self.index_type = None
        self.last_check_time = time.time()

    def initialize(self, index_type: str, initial_params: Dict):
        """
        初始化系统

        Args:
            index_type: 索引类型
            initial_params: 初始参数
        """
        self.index_type = index_type
        self.current_params = initial_params
        self.optimizer.current_params = initial_params

        print(f"自动调优系统初始化:")
        print(f"  索引类型: {index_type}")
        print(f"  初始参数: {initial_params['params']}")
        print(f"  目标延迟: {self.target_latency_ms}ms")
        print(f"  检查间隔: {self.check_interval_s}秒")

    def search_with_monitoring(
        self,
        query_vector: List[float],
        limit: int = 10,
        request_id: str = None
    ):
        """
        带监控的搜索

        Args:
            query_vector: 查询向量
            limit: 返回结果数量
            request_id: 请求 ID（用于 A/B 测试）

        Returns:
            搜索结果
        """
        # 选择配置（如果在 A/B 测试中）
        if self.ab_test.config_a is not None and request_id:
            variant = self.ab_test.route_request(request_id)
            search_params = self.ab_test.get_config(variant)
        else:
            variant = None
            search_params = self.current_params

        # 执行搜索
        start = time.time()
        results = self.collection.search(
            data=[query_vector],
            anns_field="embedding",
            param=search_params,
            limit=limit
        )
        latency_ms = (time.time() - start) * 1000

        # 记录指标
        self.monitor.record_search(latency_ms)

        if variant:
            self.ab_test.record_metrics(variant, latency_ms)

        return results

    def check_and_optimize(self):
        """检查性能并优化参数"""
        current_time = time.time()

        # 检查是否到达检查间隔
        if current_time - self.last_check_time < self.check_interval_s:
            return

        self.last_check_time = current_time

        print(f"\n{'='*80}")
        print(f"性能检查 ({time.strftime('%Y-%m-%d %H:%M:%S')})")
        print(f"{'='*80}")

        # 获取当前指标
        current_metrics = self.monitor.get_current_metrics()

        if current_metrics is None:
            print("数据不足，跳过检查")
            return

        print(f"当前性能:")
        print(f"  平均延迟: {current_metrics.avg_latency_ms:.2f}ms")
        print(f"  P95 延迟: {current_metrics.p95_latency_ms:.2f}ms")
        print(f"  QPS: {current_metrics.qps:.2f}")

        # 设置基线（首次检查）
        if self.monitor.baseline_metrics is None:
            self.monitor.set_baseline(current_metrics)
            return

        # 检测性能退化
        is_degraded, reason = self.monitor.detect_degradation(current_metrics)

        if is_degraded:
            print(f"\n⚠️  检测到性能退化: {reason}")
            self._trigger_optimization(reason)
        else:
            print(f"\n✓ 性能正常")

    def _trigger_optimization(self, reason: str):
        """触发优化"""
        print(f"\n开始参数优化...")

        # 获取向量数量
        num_vectors = self.collection.num_entities

        # 生成新参数
        new_params = self.optimizer.adjust_params_for_degradation(
            self.current_params,
            self.index_type,
            reason
        )

        # 启动 A/B 测试
        self.ab_test.start_ab_test(
            config_a=self.current_params,
            config_b=new_params,
            initial_traffic=0.1
        )

        print(f"\n已启动 A/B 测试，将在下次检查时评估结果")

    def evaluate_ab_test(self):
        """评估 A/B 测试结果"""
        if self.ab_test.config_a is None:
            return

        result = self.ab_test.compare_results()

        if result["status"] == "insufficient_data":
            print("A/B 测试数据不足，继续收集")
            return

        # 如果 B 配置更好，切换到 B
        if result["winner"] == "B" and result["improvement_percent"] > 5:
            print(f"\n✓ 新配置性能提升 {result['improvement_percent']:.1f}%，切换到新配置")
            self.current_params = self.ab_test.config_b
            self.optimizer.current_params = self.ab_test.config_b

            # 更新基线
            current_metrics = self.monitor.get_current_metrics()
            self.monitor.set_baseline(current_metrics)

            # 结束 A/B 测试
            self.ab_test.config_a = None
            self.ab_test.config_b = None
        else:
            print(f"\n✗ 新配置未带来显著提升，保持当前配置")
            self.ab_test.config_a = None
            self.ab_test.config_b = None

# ===== 6. 使用示例 =====
def main():
    """主函数"""

    # 连接到 Milvus
    connections.connect("default", host="localhost", port="19530")

    # 获取 collection
    collection = Collection("my_collection")

    # 创建自动调优系统
    tuning_system = AutoTuningSystem(
        collection=collection,
        target_latency_ms=100,
        check_interval_s=60  # 每分钟检查一次
    )

    # 初始化
    initial_params = {
        "metric_type": "L2",
        "params": {"nprobe": 16}
    }
    tuning_system.initialize("IVF_FLAT", initial_params)

    # 模拟查询流量
    print(f"\n开始模拟查询流量...")

    for i in range(1000):
        # 生成查询向量
        query_vector = np.random.rand(768).astype(np.float32).tolist()
        request_id = f"req_{i}"

        # 执行搜索（带监控）
        results = tuning_system.search_with_monitoring(
            query_vector,
            limit=10,
            request_id=request_id
        )

        # 每 100 次查询检查一次
        if (i + 1) % 100 == 0:
            print(f"\n已处理 {i+1} 个查询")
            tuning_system.check_and_optimize()

            # 如果在 A/B 测试中，评估结果
            if tuning_system.ab_test.config_a is not None:
                tuning_system.evaluate_ab_test()

        # 模拟延迟
        time.sleep(0.01)

    print(f"\n模拟完成")

    # 断开连接
    connections.disconnect("default")

if __name__ == "__main__":
    main()
```

---

## 运行输出示例

```
连接到 Milvus: localhost:19530
自动调优系统初始化:
  索引类型: IVF_FLAT
  初始参数: {'nprobe': 16}
  目标延迟: 100ms
  检查间隔: 60秒

开始模拟查询流量...

已处理 100 个查询

================================================================================
性能检查 (2026-02-10 10:30:00)
================================================================================
当前性能:
  平均延迟: 45.23ms
  P95 延迟: 62.18ms
  QPS: 22.11
设置性能基线:
  平均延迟: 45.23ms
  P95 延迟: 62.18ms
  QPS: 22.11

已处理 200 个查询

================================================================================
性能检查 (2026-02-10 10:31:00)
================================================================================
当前性能:
  平均延迟: 98.45ms
  P95 延迟: 125.32ms
  QPS: 10.16

⚠️  检测到性能退化: P95 延迟增长 2.0x

开始参数优化...
  调整 nprobe: 16 → 11
开始 A/B 测试:
  配置 A: {'nprobe': 16}
  配置 B: {'nprobe': 11}
  初始流量分配: A=90%, B=10%

已启动 A/B 测试，将在下次检查时评估结果

已处理 300 个查询

A/B 测试结果:
  配置 A: 平均 98.45ms, P95 125.32ms
  配置 B: 平均 72.34ms, P95 95.21ms
  性能变化: +26.5%
  胜出配置: B

✓ 新配置性能提升 26.5%，切换到新配置
设置性能基线:
  平均延迟: 72.34ms
  P95 延迟: 95.21ms
  QPS: 13.82

模拟完成
```

---

## 关键要点

1. **自动监控**：持续监控搜索性能指标
2. **性能退化检测**：自动检测延迟增长和 QPS 下降
3. **智能调参**：根据退化原因自动调整参数
4. **A/B 测试**：验证新参数的效果
5. **灰度切换**：性能提升后自动切换到新配置

---

## 在 RAG 系统中的应用

```python
# RAG 系统集成自动调优
class RAGSystem:
    def __init__(self, collection):
        self.collection = collection
        self.tuning_system = AutoTuningSystem(
            collection=collection,
            target_latency_ms=200,  # RAG 系统的延迟要求
            check_interval_s=300    # 每 5 分钟检查一次
        )

        # 初始化
        self.tuning_system.initialize(
            "IVF_SQ8",
            {"metric_type": "L2", "params": {"nprobe": 32}}
        )

    def search_documents(self, query_text: str, user_id: str):
        """搜索相关文档"""
        # 1. 将查询文本转换为向量
        query_vector = self.embed(query_text)

        # 2. 使用自动调优系统搜索（带监控）
        results = self.tuning_system.search_with_monitoring(
            query_vector,
            limit=5,
            request_id=f"user_{user_id}_{time.time()}"
        )

        # 3. 定期检查和优化
        self.tuning_system.check_and_optimize()

        return results
```
