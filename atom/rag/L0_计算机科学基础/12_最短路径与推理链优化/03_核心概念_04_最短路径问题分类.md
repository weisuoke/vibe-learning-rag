# 核心概念04：最短路径问题分类

> 理解不同类型的最短路径问题，选择合适的算法

---

## 一句话定义

**最短路径问题根据源点数量、目标数量、权重类型和约束条件可分为多种类型，不同类型需要选择不同的算法来高效求解。**

---

## 问题分类维度

### 维度1：源点和目标数量

#### 1. 单源单目标（Single-Source Single-Target）

**定义：** 从一个起点到一个终点的最短路径

**算法选择：**
- **A*** - 最优选择（目标导向）
- Dijkstra - 保证最优但较慢
- 双向搜索 - 进一步加速

**应用场景：**
- 导航系统：从A地到B地
- AI Agent：从当前状态到目标状态
- 知识图谱：从问题实体到答案实体

```python
# 单源单目标示例
path, cost = a_star(graph, start="北京", goal="上海", heuristic)
```

#### 2. 单源最短路径（Single-Source Shortest Paths）

**定义：** 从一个起点到所有其他节点的最短路径

**算法选择：**
- **Dijkstra** - 非负权重
- Bellman-Ford - 可处理负权重
- SPFA - Bellman-Ford的队列优化

**应用场景：**
- 社交网络：计算一个人到所有其他人的距离
- 知识图谱：从一个实体出发的所有推理路径
- 路由表：从一个路由器到所有其他路由器

```python
# 单源最短路径示例
distances, predecessors = dijkstra(graph, start="北京")
# distances = {"北京": 0, "上海": 1200, "广州": 2100, ...}
```

#### 3. 全源最短路径（All-Pairs Shortest Paths）

**定义：** 任意两点之间的最短路径

**算法选择：**
- **Floyd-Warshall** - O(V³)，适合稠密图
- Johnson算法 - O(V²log V + VE)，适合稀疏图
- 多次Dijkstra - O(VE log V)

**应用场景：**
- 距离矩阵预计算
- 网络分析：所有节点对的距离
- 知识图谱：预计算所有实体对的距离

```python
# 全源最短路径示例
dist_matrix = floyd_warshall(graph)
# dist_matrix[i][j] = 从节点i到节点j的最短距离
```

---

### 维度2：权重类型

#### 1. 非负权重图

**特点：** 所有边权重 ≥ 0

**算法选择：**
- Dijkstra - 最优选择
- A* - 如果有启发式

**为什么重要？**
- Dijkstra的贪心策略依赖非负权重
- 负权重会破坏算法正确性

```python
# 非负权重图
graph = {
    'A': [('B', 5), ('C', 2)],  # 权重都 ≥ 0
    'B': [('D', 3)],
    'C': [('D', 8)]
}
```

#### 2. 含负权重图

**特点：** 存在权重 < 0 的边

**算法选择：**
- **Bellman-Ford** - 可处理负权重
- SPFA - Bellman-Ford的优化版本
- ❌ Dijkstra - 不能使用！

**应用场景：**
- 金融套利：负权重表示收益
- 时间旅行问题：负权重表示时间倒流
- 某些优化问题

```python
# 含负权重图
graph = {
    'A': [('B', 5), ('C', -2)],  # C的权重为负
    'B': [('D', 3)],
    'C': [('D', 8)]
}

# 使用Bellman-Ford
distances = bellman_ford(graph, start='A')
```

#### 3. 含负权环图

**特点：** 存在权重和为负的环

**问题：** 最短路径不存在（可以无限减小）

**算法选择：**
- Bellman-Ford - 可以检测负权环
- 其他算法无法处理

```python
# 负权环示例
graph = {
    'A': [('B', 1)],
    'B': [('C', -2)],
    'C': [('A', -1)]  # A->B->C->A = 1-2-1 = -2 < 0
}

# Bellman-Ford可以检测
has_negative_cycle = bellman_ford_detect_cycle(graph)
```

#### 4. 无权图

**特点：** 所有边权重相同（通常为1）

**算法选择：**
- **BFS** - 最简单高效
- Dijkstra - 可以用但过于复杂

```python
# 无权图（所有边权重为1）
graph = {
    'A': ['B', 'C'],  # 简化表示，权重默认为1
    'B': ['D'],
    'C': ['D']
}

# 使用BFS
path = bfs_shortest_path(graph, 'A', 'D')
```

---

### 维度3：约束条件

#### 1. 无约束最短路径

**定义：** 只考虑路径长度，无其他限制

**算法：** 标准Dijkstra/A*

#### 2. K最短路径

**定义：** 找到前K条最短路径

**算法：**
- Yen's算法
- Eppstein's算法

**应用场景：**
- 提供多个路线选择
- 推理链多样性
- 备选方案生成

```python
def k_shortest_paths(graph, start, goal, k):
    """找到前K条最短路径"""
    paths = []

    # 第一条最短路径
    path1 = a_star(graph, start, goal)
    paths.append(path1)

    # 后续K-1条路径
    for i in range(1, k):
        # Yen's算法：系统地偏离已有路径
        candidate_paths = []

        for j in range(len(paths[-1]) - 1):
            # 固定前j个节点，寻找新路径
            spur_node = paths[-1][j]
            root_path = paths[-1][:j+1]

            # 移除已用边，寻找新路径
            # ...

        paths.append(min(candidate_paths, key=lambda p: path_cost(p)))

    return paths
```

#### 3. 资源约束最短路径

**定义：** 路径需要满足资源限制（如时间、成本）

**算法：**
- 动态规划
- 约束满足问题（CSP）

**应用场景：**
- 带时间窗的路径规划
- 预算约束的任务规划
- Token限制的推理链

```python
def resource_constrained_shortest_path(graph, start, goal, max_resource):
    """
    资源约束最短路径

    每条边有两个属性：
    - cost: 路径代价（要最小化）
    - resource: 资源消耗（要满足约束）
    """
    # 状态：(节点, 已用资源)
    # dp[node][resource] = 到达node且用了resource的最小cost

    dp = {}
    dp[(start, 0)] = 0

    pq = [(0, start, 0)]  # (cost, node, resource_used)

    while pq:
        cost, node, resource_used = heapq.heappop(pq)

        if node == goal:
            return cost, resource_used

        for neighbor, edge_cost, edge_resource in graph[node]:
            new_resource = resource_used + edge_resource

            # 检查资源约束
            if new_resource > max_resource:
                continue

            new_cost = cost + edge_cost

            # 更新DP表
            if (neighbor, new_resource) not in dp or new_cost < dp[(neighbor, new_resource)]:
                dp[(neighbor, new_resource)] = new_cost
                heapq.heappush(pq, (new_cost, neighbor, new_resource))

    return None  # 无解
```

#### 4. 时间依赖最短路径

**定义：** 边的权重随时间变化

**算法：**
- 时间扩展网络
- 动态Dijkstra

**应用场景：**
- 交通导航（考虑拥堵）
- 动态知识图谱
- 时序推理

```python
def time_dependent_shortest_path(graph, start, goal, start_time):
    """
    时间依赖最短路径

    graph[node][neighbor] = lambda t: cost_at_time_t
    """
    # 状态：(节点, 到达时间)
    pq = [(0, start, start_time)]
    visited = {}

    while pq:
        cost, node, arrival_time = heapq.heappop(pq)

        if node == goal:
            return cost, arrival_time

        if (node, arrival_time) in visited:
            continue
        visited[(node, arrival_time)] = cost

        for neighbor in graph[node]:
            # 边的权重取决于到达时间
            edge_cost = graph[node][neighbor](arrival_time)
            new_arrival_time = arrival_time + edge_cost
            new_cost = cost + edge_cost

            heapq.heappush(pq, (new_cost, neighbor, new_arrival_time))

    return None
```

---

## 在AI Agent中的问题分类

### 场景1：知识图谱推理

**问题类型：** 单源单目标 + 非负权重 + 可能有约束

```python
class KGReasoningPathFinder:
    """知识图谱推理路径查找"""

    def find_path(self, question_entity, answer_entity, constraints=None):
        """
        根据约束选择算法

        约束类型：
        - max_hops: 最大跳数限制
        - min_confidence: 最小置信度要求
        - allowed_relations: 允许的关系类型
        """
        if constraints is None:
            # 无约束：使用A*
            return self.a_star_search(question_entity, answer_entity)

        elif 'max_hops' in constraints:
            # 跳数约束：使用资源约束最短路径
            return self.resource_constrained_search(
                question_entity,
                answer_entity,
                max_resource=constraints['max_hops']
            )

        elif 'k_paths' in constraints:
            # 需要多条路径：使用K最短路径
            return self.k_shortest_paths(
                question_entity,
                answer_entity,
                k=constraints['k_paths']
            )
```

### 场景2：多跳问答

**问题类型：** 单源单目标 + 可能需要K条路径

```python
def multi_hop_qa(kg, question, k=3):
    """
    多跳问答：找到K条最优推理路径

    返回多条路径以提高鲁棒性
    """
    question_entity = extract_entity(question)
    answer_candidates = identify_answer_candidates(question)

    all_paths = []
    for candidate in answer_candidates:
        # 找到K条路径
        paths = k_shortest_paths(kg, question_entity, candidate, k)
        all_paths.extend([(p, candidate) for p in paths])

    # 按路径质量排序
    all_paths.sort(key=lambda x: path_quality(x[0]))

    return all_paths[:k]
```

### 场景3：Agent任务规划

**问题类型：** 单源单目标 + 资源约束

```python
def agent_task_planning(initial_state, goal_state, constraints):
    """
    Agent任务规划：考虑时间和资源约束

    约束：
    - max_time: 最大执行时间
    - max_cost: 最大成本
    - available_tools: 可用工具集
    """
    # 构建状态图
    state_graph = build_state_graph(available_tools=constraints['available_tools'])

    # 使用资源约束最短路径
    plan, total_time, total_cost = resource_constrained_shortest_path(
        state_graph,
        initial_state,
        goal_state,
        max_time=constraints['max_time'],
        max_cost=constraints['max_cost']
    )

    return plan
```

---

## 算法选择决策树

```
最短路径问题
│
├─ 源点和目标数量？
│  ├─ 单源单目标 ────────────────┐
│  ├─ 单源所有目标 ───────────────┤
│  └─ 所有源所有目标 ─────────────┤
│                                  │
├─ 权重类型？                      │
│  ├─ 非负权重 ───────────────────┤
│  ├─ 含负权重（无负环）──────────┤
│  ├─ 含负权环 ───────────────────┤
│  └─ 无权图 ─────────────────────┤
│                                  │
├─ 有约束条件吗？                  │
│  ├─ 无约束 ─────────────────────┤
│  ├─ K最短路径 ──────────────────┤
│  ├─ 资源约束 ───────────────────┤
│  └─ 时间依赖 ───────────────────┤
│                                  │
└─ 算法选择 ◄────────────────────┘
   ├─ A* (单源单目标 + 非负 + 无约束 + 有启发式)
   ├─ Dijkstra (单源 + 非负 + 无约束)
   ├─ Bellman-Ford (含负权重)
   ├─ Floyd-Warshall (全源 + 小规模)
   ├─ BFS (无权图)
   ├─ Yen's算法 (K最短路径)
   └─ 动态规划 (资源约束/时间依赖)
```

---

## 算法对比表

| 问题类型 | 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---------|------|-----------|-----------|---------|
| **单源单目标** | A* | O(E log V) | O(V) | 有启发式，目标明确 |
| | Dijkstra | O(E log V) | O(V) | 无启发式，保证最优 |
| | 双向搜索 | O(E log V) | O(V) | 大规模图加速 |
| **单源最短路径** | Dijkstra | O(E log V) | O(V) | 非负权重 |
| | Bellman-Ford | O(VE) | O(V) | 可有负权重 |
| | SPFA | O(kE) | O(V) | 稀疏图优化 |
| **全源最短路径** | Floyd-Warshall | O(V³) | O(V²) | 稠密图，小规模 |
| | Johnson | O(V²log V + VE) | O(V²) | 稀疏图 |
| **K最短路径** | Yen's | O(KV(E log V)) | O(V+E) | 需要多条路径 |
| **资源约束** | DP | O(VR) | O(VR) | R=资源上限 |
| **无权图** | BFS | O(V+E) | O(V) | 最简单高效 |

---

## 实战示例：智能算法选择器

```python
class ShortestPathSolver:
    """智能最短路径求解器：根据问题特征自动选择算法"""

    def __init__(self, graph):
        self.graph = graph
        self.has_negative_weights = self._check_negative_weights()

    def _check_negative_weights(self):
        """检查图中是否有负权重"""
        for node in self.graph:
            for neighbor, weight in self.graph[node]:
                if weight < 0:
                    return True
        return False

    def solve(self, start, goal=None, constraints=None):
        """
        智能求解最短路径

        参数:
            start: 起点
            goal: 终点（None表示单源最短路径）
            constraints: 约束条件字典
        """
        # 场景1：无权图
        if self._is_unweighted():
            if goal is not None:
                return self._bfs(start, goal)
            else:
                return self._bfs_all(start)

        # 场景2：含负权重
        if self.has_negative_weights:
            if goal is not None:
                return self._bellman_ford_single_target(start, goal)
            else:
                return self._bellman_ford(start)

        # 场景3：有约束条件
        if constraints is not None:
            if 'k_paths' in constraints:
                return self._k_shortest_paths(start, goal, constraints['k_paths'])
            elif 'max_resource' in constraints:
                return self._resource_constrained(start, goal, constraints)
            elif 'time_dependent' in constraints:
                return self._time_dependent(start, goal, constraints)

        # 场景4：单源单目标 + 非负权重
        if goal is not None:
            # 如果有启发式函数，使用A*
            if hasattr(self, 'heuristic'):
                return self._a_star(start, goal)
            else:
                return self._dijkstra_single_target(start, goal)

        # 场景5：单源最短路径 + 非负权重
        return self._dijkstra(start)

    def _is_unweighted(self):
        """检查是否为无权图"""
        for node in self.graph:
            for neighbor, weight in self.graph[node]:
                if weight != 1:
                    return False
        return True

    # ... 各种算法的实现 ...


# 使用示例
graph = build_knowledge_graph()
solver = ShortestPathSolver(graph)

# 自动选择最优算法
path1 = solver.solve(start="问题实体", goal="答案实体")

# 带约束的求解
path2 = solver.solve(
    start="问题实体",
    goal="答案实体",
    constraints={'k_paths': 3, 'max_hops': 5}
)
```

---

## 常见错误

### 错误1：问题类型判断错误

```python
# ❌ 错误：有负权重却用Dijkstra
graph = {
    'A': [('B', -5)]  # 负权重！
}
path = dijkstra(graph, 'A', 'B')  # 结果错误

# ✅ 正确：使用Bellman-Ford
path = bellman_ford(graph, 'A', 'B')
```

### 错误2：算法选择不当

```python
# ❌ 错误：无权图用Dijkstra（过于复杂）
graph = {
    'A': [('B', 1), ('C', 1)],  # 所有权重都是1
    'B': [('D', 1)]
}
path = dijkstra(graph, 'A', 'D')  # 可以工作但不必要

# ✅ 正确：使用BFS（更简单高效）
path = bfs(graph, 'A', 'D')
```

### 错误3：忽略约束条件

```python
# ❌ 错误：有资源约束却用标准算法
path = dijkstra(graph, start, goal)
if path_resource(path) > max_resource:
    # 事后检查，可能无解

# ✅ 正确：使用资源约束算法
path = resource_constrained_shortest_path(graph, start, goal, max_resource)
```

---

## 延伸思考

1. **如何在AI Agent中动态选择算法？**
   - 提示：根据图的特征和约束条件

2. **K最短路径在推理链中的应用？**
   - 提示：提供多样性，提高鲁棒性

3. **资源约束如何影响路径质量？**
   - 提示：权衡最优性和可行性

4. **时间依赖最短路径在动态知识图谱中的应用？**
   - 提示：知识的时效性

5. **如何处理多目标优化（如同时最小化时间和成本）？**
   - 提示：帕累托最优，权重组合

---

## 参考资源

- **算法导论（CLRS）**：第24-25章 最短路径
- **论文**：Yen, J. Y. (1971). Finding the k shortest loopless paths
- **实践**：NetworkX库的最短路径算法

---

**记住：选择合适的算法比优化算法本身更重要。理解问题类型是高效求解的第一步。**
