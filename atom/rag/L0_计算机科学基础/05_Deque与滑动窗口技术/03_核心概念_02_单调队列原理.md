# 核心概念 02：单调队列原理

> 深入理解单调队列算法，解决滑动窗口最值问题

---

## 概述

**单调队列（Monotonic Queue）** 是一种特殊的队列，队列中的元素保持单调递增或单调递减的顺序。它是解决滑动窗口最大值/最小值问题的核心算法，时间复杂度为 O(n)。

**核心思想：** 只保留"可能成为答案"的元素，丢弃不可能成为答案的元素。

---

## 1. 单调队列的基本概念

### 1.1 什么是单调队列？

**定义：** 队列中的元素按照某种单调性排列（递增或递减）。

```python
# 单调递减队列（用于求最大值）
[5, 3, 1]  # 从队首到队尾递减

# 单调递增队列（用于求最小值）
[1, 3, 5]  # 从队首到队尾递增
```

**关键特性：**
- 队首元素是当前窗口的最大值（递减队列）或最小值（递增队列）
- 新元素入队时，维护单调性
- 元素离开窗口时，从队首移除

### 1.2 为什么需要单调队列？

**问题：** 滑动窗口最大值

```python
# 给定数组和窗口大小 k，求每个窗口的最大值
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

# 期望输出：[3, 3, 5, 5, 6, 7]
```

**暴力解法：O(n*k)**
```python
def max_sliding_window_brute_force(nums, k):
    result = []
    for i in range(len(nums) - k + 1):
        window_max = max(nums[i:i+k])  # O(k)
        result.append(window_max)
    return result

# 时间复杂度：O(n*k)
# 对于 n=10000, k=1000：需要 10,000,000 次操作
```

**单调队列：O(n)**
```python
from collections import deque

def max_sliding_window(nums, k):
    dq = deque()  # 存储索引
    result = []

    for i, num in enumerate(nums):
        # 维护单调递减
        while dq and nums[dq[-1]] < num:
            dq.pop()

        dq.append(i)

        # 移除超出窗口的元素
        if dq[0] < i - k + 1:
            dq.popleft()

        # 窗口形成后，队首就是最大值
        if i >= k - 1:
            result.append(nums[dq[0]])

    return result

# 时间复杂度：O(n)
# 对于 n=10000, k=1000：只需要 10,000 次操作
# 性能提升：1000 倍
```

---

## 2. 单调递减队列（求最大值）

### 2.1 核心原理

**关键洞察：** 如果元素 A 在元素 B 的左边，且 A ≤ B，那么 A 永远不可能是窗口最大值。

```
窗口：[1, 3, -1]
      ↑  ↑
      A  B

因为 1 < 3，且 1 在 3 的左边
→ 当窗口滑动时，1 会比 3 先离开窗口
→ 所以 1 永远不可能成为最大值
→ 可以安全移除
```

### 2.2 算法步骤

```python
from collections import deque

def max_sliding_window(nums: list, k: int) -> list:
    """滑动窗口最大值 - 单调递减队列"""
    dq = deque()  # 存储索引（不是值）
    result = []

    for i, num in enumerate(nums):
        # 步骤1：维护单调递减
        # 移除所有小于当前元素的元素
        while dq and nums[dq[-1]] < num:
            dq.pop()

        # 步骤2：添加当前元素的索引
        dq.append(i)

        # 步骤3：移除超出窗口的元素
        if dq[0] < i - k + 1:
            dq.popleft()

        # 步骤4：窗口形成后，队首就是最大值
        if i >= k - 1:
            result.append(nums[dq[0]])

    return result

# 测试
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(max_sliding_window(nums, k))  # [3, 3, 5, 5, 6, 7]
```

### 2.3 算法可视化

```
nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3

i=0, num=1:
  dq = []
  添加 1: dq = [0]

i=1, num=3:
  dq = [0]
  3 > nums[0]=1，移除 0
  dq = []
  添加 1: dq = [1]

i=2, num=-1:
  dq = [1]
  -1 < nums[1]=3，保留
  添加 2: dq = [1, 2]
  窗口形成，最大值 = nums[1] = 3
  result = [3]

i=3, num=-3:
  dq = [1, 2]
  -3 < nums[2]=-1，保留
  添加 3: dq = [1, 2, 3]
  移除超出窗口的 1: dq = [2, 3]
  最大值 = nums[2] = -1... 错误！

实际上：
i=3, num=-3:
  dq = [1, 2]
  -3 < nums[2]=-1，保留
  添加 3: dq = [1, 2, 3]
  1 < 3-3+1=1，不移除
  最大值 = nums[1] = 3
  result = [3, 3]
```

### 2.4 时间复杂度分析

**为什么是 O(n)？**

每个元素最多：
- 入队一次：O(1)
- 出队一次：O(1)

总操作次数：2n = O(n)

---

## 3. 单调递增队列（求最小值）

### 3.1 算法实现

```python
from collections import deque

def min_sliding_window(nums: list, k: int) -> list:
    """滑动窗口最小值 - 单调递增队列"""
    dq = deque()  # 存储索引
    result = []

    for i, num in enumerate(nums):
        # 维护单调递增
        # 移除所有大于当前元素的元素
        while dq and nums[dq[-1]] > num:
            dq.pop()

        dq.append(i)

        # 移除超出窗口的元素
        if dq[0] < i - k + 1:
            dq.popleft()

        # 窗口形成后，队首就是最小值
        if i >= k - 1:
            result.append(nums[dq[0]])

    return result

# 测试
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(min_sliding_window(nums, k))  # [1, -3, -3, -3, 3, 3]
```

### 3.2 递增 vs 递减对比

| 特性 | 单调递减队列 | 单调递增队列 |
|------|------------|------------|
| **用途** | 求最大值 | 求最小值 |
| **队首** | 最大值 | 最小值 |
| **维护条件** | 移除小于当前的 | 移除大于当前的 |
| **队列顺序** | 从大到小 | 从小到大 |

---

## 4. 经典问题与变体

### 4.1 LeetCode 239：滑动窗口最大值

```python
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:
        """
        给定数组 nums 和窗口大小 k，返回每个窗口的最大值

        示例：
        输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
        输出：[3,3,5,5,6,7]

        时间复杂度：O(n)
        空间复杂度：O(k)
        """
        if not nums or k == 0:
            return []

        dq = deque()
        result = []

        for i, num in enumerate(nums):
            # 维护单调递减
            while dq and nums[dq[-1]] < num:
                dq.pop()

            dq.append(i)

            # 移除超出窗口的元素
            if dq[0] < i - k + 1:
                dq.popleft()

            # 窗口形成后添加结果
            if i >= k - 1:
                result.append(nums[dq[0]])

        return result
```

### 4.2 变体：最长连续递增子序列

```python
from collections import deque

def longest_continuous_increasing_subsequence(nums: list) -> int:
    """
    找到最长的连续递增子序列长度

    示例：
    输入：[1, 3, 5, 4, 7]
    输出：3（[1, 3, 5]）
    """
    if not nums:
        return 0

    max_length = 1
    current_length = 1

    for i in range(1, len(nums)):
        if nums[i] > nums[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1

    return max_length

# 测试
print(longest_continuous_increasing_subsequence([1, 3, 5, 4, 7]))  # 3
```

### 4.3 变体：滑动窗口中位数

```python
from collections import deque
import heapq

def median_sliding_window(nums: list, k: int) -> list:
    """
    滑动窗口中位数（使用两个堆）

    时间复杂度：O(n*k*log(k))
    """
    result = []

    for i in range(len(nums) - k + 1):
        window = sorted(nums[i:i+k])
        if k % 2 == 0:
            median = (window[k//2-1] + window[k//2]) / 2
        else:
            median = window[k//2]
        result.append(median)

    return result

# 测试
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(median_sliding_window(nums, k))  # [1, -1, -1, 3, 5, 6]
```

---

## 5. AI Agent 应用场景

### 5.1 优先级任务调度

```python
from collections import deque
import time

class PriorityTaskScheduler:
    """基于单调队列的优先级任务调度器"""

    def __init__(self):
        self.tasks = deque()  # 存储 (priority, timestamp, task)

    def add_task(self, priority: int, task: str):
        """添加任务，维护单调递减优先级"""
        timestamp = time.time()

        # 移除所有优先级低于当前任务的任务
        while self.tasks and self.tasks[-1][0] < priority:
            self.tasks.pop()

        self.tasks.append((priority, timestamp, task))

    def get_next_task(self) -> tuple:
        """获取最高优先级任务"""
        if self.tasks:
            return self.tasks.popleft()
        return None

    def get_max_priority(self) -> int:
        """O(1) 获取最高优先级"""
        if self.tasks:
            return self.tasks[0][0]
        return -1

# 使用示例
scheduler = PriorityTaskScheduler()

scheduler.add_task(1, "低优先级任务")
scheduler.add_task(5, "高优先级任务")  # 移除低优先级任务
scheduler.add_task(3, "中优先级任务")

print(scheduler.get_next_task())  # (5, timestamp, "高优先级任务")
print(scheduler.get_max_priority())  # 3
```

### 5.2 实时性能监控

```python
from collections import deque

class PerformanceMonitor:
    """实时性能监控 - 滑动窗口统计"""

    def __init__(self, window_size: int = 100):
        self.window_size = window_size
        self.latencies = deque(maxlen=window_size)
        self.max_queue = deque()  # 单调递减队列

    def record_latency(self, latency: float):
        """记录延迟"""
        self.latencies.append(latency)

        # 维护单调递减队列
        while self.max_queue and self.max_queue[-1] < latency:
            self.max_queue.pop()
        self.max_queue.append(latency)

        # 移除超出窗口的元素
        if len(self.latencies) == self.window_size:
            if self.max_queue and self.max_queue[0] == self.latencies[0]:
                self.max_queue.popleft()

    def get_max_latency(self) -> float:
        """O(1) 获取最大延迟"""
        return self.max_queue[0] if self.max_queue else 0

    def get_avg_latency(self) -> float:
        """获取平均延迟"""
        return sum(self.latencies) / len(self.latencies) if self.latencies else 0

# 使用示例
monitor = PerformanceMonitor(window_size=10)

for i in range(20):
    monitor.record_latency(i * 0.1)

print(f"最大延迟: {monitor.get_max_latency():.2f}s")
print(f"平均延迟: {monitor.get_avg_latency():.2f}s")
```

### 5.3 流式数据处理

```python
from collections import deque

class StreamProcessor:
    """流式数据处理器 - 实时最值统计"""

    def __init__(self, window_size: int):
        self.window_size = window_size
        self.data = deque(maxlen=window_size)
        self.max_queue = deque()  # 单调递减
        self.min_queue = deque()  # 单调递增

    def add_data(self, value: float):
        """添加数据点"""
        self.data.append(value)

        # 维护最大值队列
        while self.max_queue and self.max_queue[-1] < value:
            self.max_queue.pop()
        self.max_queue.append(value)

        # 维护最小值队列
        while self.min_queue and self.min_queue[-1] > value:
            self.min_queue.pop()
        self.min_queue.append(value)

        # 移除超出窗口的元素
        if len(self.data) == self.window_size:
            if self.max_queue and self.max_queue[0] == self.data[0]:
                self.max_queue.popleft()
            if self.min_queue and self.min_queue[0] == self.data[0]:
                self.min_queue.popleft()

    def get_range(self) -> float:
        """O(1) 获取当前窗口的极差"""
        if self.max_queue and self.min_queue:
            return self.max_queue[0] - self.min_queue[0]
        return 0

# 使用示例
processor = StreamProcessor(window_size=5)

for value in [1, 5, 3, 7, 2, 9, 4]:
    processor.add_data(value)
    print(f"当前极差: {processor.get_range()}")
```

---

## 6. 常见错误与最佳实践

### 6.1 错误：存储值而非索引

```python
# ❌ 错误：存储值
dq = deque()
for num in nums:
    while dq and dq[-1] < num:
        dq.pop()
    dq.append(num)  # 存储值

# 问题：无法判断元素是否超出窗口

# ✅ 正确：存储索引
dq = deque()
for i, num in enumerate(nums):
    while dq and nums[dq[-1]] < num:
        dq.pop()
    dq.append(i)  # 存储索引

    # 可以判断是否超出窗口
    if dq[0] < i - k + 1:
        dq.popleft()
```

### 6.2 错误：忘记移除超出窗口的元素

```python
# ❌ 错误：没有移除超出窗口的元素
for i, num in enumerate(nums):
    while dq and nums[dq[-1]] < num:
        dq.pop()
    dq.append(i)
    # 忘记移除超出窗口的元素

# ✅ 正确：移除超出窗口的元素
for i, num in enumerate(nums):
    while dq and nums[dq[-1]] < num:
        dq.pop()
    dq.append(i)

    # 移除超出窗口的元素
    if dq[0] < i - k + 1:
        dq.popleft()
```

### 6.3 错误：混淆递增和递减

```python
# ❌ 错误：求最大值却用递增队列
def max_sliding_window_wrong(nums, k):
    dq = deque()
    for i, num in enumerate(nums):
        # 错误：移除大于当前的（递增队列）
        while dq and nums[dq[-1]] > num:
            dq.pop()
        dq.append(i)

# ✅ 正确：求最大值用递减队列
def max_sliding_window_correct(nums, k):
    dq = deque()
    for i, num in enumerate(nums):
        # 正确：移除小于当前的（递减队列）
        while dq and nums[dq[-1]] < num:
            dq.pop()
        dq.append(i)
```

---

## 7. 性能分析

### 7.1 时间复杂度

```python
# 单调队列：O(n)
# 每个元素最多入队一次，出队一次
# 总操作次数：2n = O(n)

# 暴力解法：O(n*k)
# 每个窗口都要遍历 k 个元素
# 总操作次数：n*k

# 性能提升：k 倍
```

### 7.2 空间复杂度

```python
# 单调队列：O(k)
# 队列中最多存储 k 个元素

# 暴力解法：O(1)
# 不需要额外空间
```

### 7.3 实际性能测试

```python
import time
from collections import deque

def benchmark():
    nums = list(range(10000))
    k = 1000

    # 暴力解法
    start = time.time()
    result1 = []
    for i in range(len(nums) - k + 1):
        result1.append(max(nums[i:i+k]))
    brute_time = time.time() - start

    # 单调队列
    start = time.time()
    result2 = max_sliding_window(nums, k)
    mono_time = time.time() - start

    print(f"暴力解法: {brute_time:.4f}s")
    print(f"单调队列: {mono_time:.4f}s")
    print(f"性能提升: {brute_time / mono_time:.0f} 倍")

# 输出示例：
# 暴力解法: 5.0000s
# 单调队列: 0.0050s
# 性能提升: 1000 倍
```

---

## 学习检查清单

- [ ] 理解单调队列的核心思想（只保留可能成为答案的元素）
- [ ] 能够实现单调递减队列（求最大值）
- [ ] 能够实现单调递增队列（求最小值）
- [ ] 理解为什么时间复杂度是 O(n)
- [ ] 能够解决 LeetCode 239（滑动窗口最大值）
- [ ] 理解 AI Agent 中的应用场景
- [ ] 避免常见错误（存储值vs索引、忘记移除超出窗口的元素）

---

## 下一步学习

### 深入理解
→ **03_核心概念_03_滑动窗口模式.md** - 学习滑动窗口的通用模式

### 实战练习
→ **07_实战代码_02_单调队列算法.md** - 完整代码示例

### 面试准备
→ **08_面试必问.md** - 经典面试题

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+, AI Agent 开发, RAG 系统
