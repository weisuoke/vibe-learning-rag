# 核心概念 07：多跳推理路径

## 一句话定义

**多跳推理路径是在知识图谱中通过多次跳转（遍历多条边）连接查询实体和答案实体的推理链，是 Multi-hop QA 系统的核心技术。**

---

## 核心概念

### 什么是多跳推理？

**单跳推理：** 查询 → 答案（1条边）
```
问题："Python 的创始人是谁？"
路径：Python --[created_by]--> Guido van Rossum
```

**多跳推理：** 查询 → 中间实体 → ... → 答案（多条边）
```
问题："Python 创始人的国籍是什么？"
路径：Python --[created_by]--> Guido van Rossum --[nationality]--> 荷兰
```

---

## KG2RAG 方法（BFS扩展 + DFS组织）

### 核心思想

**步骤1：BFS 扩展 m-hop 邻域**（广度覆盖）
**步骤2：DFS 组织连贯段落**（深度连接）

```python
from collections import deque
from typing import List, Set

def kg2rag_multi_hop(kg, query_entities: List[str], m_hops: int = 2, max_depth: int = 3):
    """
    KG2RAG 多跳推理

    来源：KG2RAG (NAACL 2025)
    论文：https://arxiv.org/abs/2502.06864
    """
    # 步骤1：BFS 扩展 m-hop 邻域
    expanded = bfs_expand_neighborhood(kg, query_entities, m_hops)

    # 步骤2：DFS 组织连贯段落
    organized_chunks = dfs_organize_chunks(kg, expanded, max_depth)

    return organized_chunks

def bfs_expand_neighborhood(kg, seeds: List[str], m_hops: int) -> Set[str]:
    """
    BFS 扩展 m-hop 邻域

    目标：广度覆盖所有相关实体
    """
    expanded = set(seeds)
    queue = deque([(e, 0) for e in seeds])

    while queue:
        entity, depth = queue.popleft()

        if depth >= m_hops:
            continue

        for neighbor in kg.get_neighbors(entity):
            if neighbor not in expanded:
                expanded.add(neighbor)
                queue.append((neighbor, depth + 1))

    return expanded

def dfs_organize_chunks(kg, entities: Set[str], max_depth: int) -> List[List[str]]:
    """
    DFS 组织连贯段落

    目标：构建连贯的推理链，避免碎片化
    """
    organized = []
    visited = set()

    def dfs_path(entity: str, path: List[str], depth: int):
        if depth >= max_depth or entity in visited:
            return

        visited.add(entity)
        path.append(entity)

        neighbors = kg.get_neighbors(entity)

        if not neighbors or depth == max_depth - 1:
            # 到达叶子节点，保存路径
            organized.append(path[:])
        else:
            # 继续深入（只选择一个邻居）
            for neighbor in neighbors:
                if neighbor not in visited:
                    dfs_path(neighbor, path, depth + 1)
                    break  # 只沿着一条路径深入

        path.pop()  # 回溯

    for entity in entities:
        if entity not in visited:
            dfs_path(entity, [], 0)

    return organized
```

**实际效果：**
```
查询："Einstein 的理论如何影响现代物理？"

BFS 扩展结果（无序）：
{Einstein, 相对论, 光电效应, 时空弯曲, 量子力学, GPS技术, 半导体, ...}

DFS 组织结果（连贯）：
段落1：Einstein → 相对论 → 时空弯曲 → 引力波探测
段落2：Einstein → 光电效应 → 量子力学 → 半导体技术
段落3：Einstein → 质能方程 → 核能 → 核电站

优势：每个段落是连贯的推理链，LLM 更容易理解
```

---

## SG-RAG MOT 方法（三元组排序）

### 核心思想

**问题：** 直接拼接三元组会导致 lost-in-the-middle

**解决方案：** 使用 BFS/DFS 排序三元组

```python
def sg_rag_mot_ordering(kg, query: str, triples: List[tuple]) -> List[tuple]:
    """
    SG-RAG MOT 三元组排序

    来源：SG-RAG MOT (2025)
    论文：https://www.mdpi.com/2504-4990/7/3/74
    """
    # 提取查询实体
    query_entities = kg.extract_entities(query)

    # BFS 计算每个三元组到查询实体的距离
    distances = {}
    for triple in triples:
        head, relation, tail = triple
        dist = min(
            bfs_distance(kg, query_entities, head),
            bfs_distance(kg, query_entities, tail)
        )
        distances[triple] = dist

    # 按距离排序（近的在前）
    sorted_triples = sorted(triples, key=lambda t: distances[t])

    return sorted_triples

def bfs_distance(kg, sources: List[str], target: str) -> int:
    """计算最短距离"""
    visited = {s: 0 for s in sources}
    queue = deque([(s, 0) for s in sources])

    while queue:
        entity, dist = queue.popleft()

        if entity == target:
            return dist

        for neighbor in kg.get_neighbors(entity):
            if neighbor not in visited:
                visited[neighbor] = dist + 1
                queue.append((neighbor, dist + 1))

    return float('inf')  # 不可达
```

**效果：**
```
未排序：
(A, r1, B), (X, r2, Y), (B, r3, C), (Y, r4, Z), (C, r5, D)
↓ 碎片化，LLM 难以理解

排序后：
(A, r1, B), (B, r3, C), (C, r5, D), (X, r2, Y), (Y, r4, Z)
↓ 连贯，LLM 容易理解
```

---

## 路径评分与选择

### 评分维度

```python
def score_reasoning_path(kg, path: List[str], query: str) -> float:
    """
    评估推理路径质量

    考虑因素：
    1. 路径长度（越短越好）
    2. 实体重要性（越重要越好）
    3. 关系强度（越强越好）
    4. 与查询的相关性（越相关越好）
    """
    # 1. 长度惩罚
    length_score = 1.0 / len(path)

    # 2. 实体重要性
    importance_score = sum(kg.get_entity_importance(e) for e in path) / len(path)

    # 3. 关系强度
    relation_score = 0
    for i in range(len(path) - 1):
        relation_score += kg.get_relation_strength(path[i], path[i + 1])
    relation_score /= (len(path) - 1)

    # 4. 查询相关性
    relevance_score = kg.compute_relevance(path, query)

    # 综合得分
    return (
        0.2 * length_score +
        0.3 * importance_score +
        0.3 * relation_score +
        0.2 * relevance_score
    )

def select_best_paths(kg, all_paths: List[List[str]], query: str, top_k: int = 3) -> List[List[str]]:
    """选择最佳的 K 条路径"""
    scored_paths = [(path, score_reasoning_path(kg, path, query)) for path in all_paths]
    scored_paths.sort(key=lambda x: x[1], reverse=True)
    return [path for path, _ in scored_paths[:top_k]]
```

---

## 实战示例

### 完整的多跳 QA 系统

```python
class MultiHopQASystem:
    """多跳问答系统"""
    def __init__(self, kg, llm):
        self.kg = kg
        self.llm = llm

    def answer(self, question: str) -> str:
        """
        回答多跳问题

        流程：
        1. 提取查询实体
        2. BFS 扩展邻域
        3. DFS 构建推理路径
        4. 评分选择最佳路径
        5. LLM 生成答案
        """
        # 步骤1：提取查询实体
        query_entities = self.kg.extract_entities(question)

        # 步骤2：BFS 扩展邻域
        expanded = bfs_expand_neighborhood(self.kg, query_entities, m_hops=3)

        # 步骤3：DFS 构建推理路径
        all_paths = []
        for start in query_entities:
            for end in expanded:
                paths = self.find_paths_dfs(start, end, max_depth=5)
                all_paths.extend(paths)

        # 步骤4：选择最佳路径
        best_paths = select_best_paths(self.kg, all_paths, question, top_k=3)

        # 步骤5：LLM 生成答案
        context = self.format_paths(best_paths)
        answer = self.llm.generate(f"问题：{question}\n\n推理路径：\n{context}\n\n答案：")

        return answer

    def find_paths_dfs(self, start: str, end: str, max_depth: int) -> List[List[str]]:
        """DFS 查找所有路径"""
        all_paths = []

        def dfs(node: str, target: str, depth: int, visited: set, path: List[str]):
            if depth > max_depth:
                return

            if node == target:
                all_paths.append(path[:])
                return

            visited.add(node)

            for neighbor in self.kg.get_neighbors(node):
                if neighbor not in visited:
                    path.append(neighbor)
                    dfs(neighbor, target, depth + 1, visited, path)
                    path.pop()

            visited.remove(node)

        dfs(start, end, 0, set(), [start])
        return all_paths

    def format_paths(self, paths: List[List[str]]) -> str:
        """格式化路径为文本"""
        formatted = []
        for i, path in enumerate(paths, 1):
            path_str = " → ".join(path)
            formatted.append(f"路径{i}：{path_str}")
        return "\n".join(formatted)
```

---

## 优化技术

### 1. 路径剪枝

```python
def pruned_path_search(kg, start: str, end: str, max_depth: int, min_score: float = 0.3):
    """
    带剪枝的路径搜索

    剪枝条件：
    - 路径得分低于阈值
    - 路径长度超过限制
    - 实体重要性过低
    """
    all_paths = []

    def dfs(node: str, depth: int, visited: set, path: List[str], current_score: float):
        # 剪枝1：得分过低
        if current_score < min_score:
            return

        # 剪枝2：深度超限
        if depth > max_depth:
            return

        if node == end:
            all_paths.append((path[:], current_score))
            return

        visited.add(node)

        for neighbor in kg.get_neighbors(node):
            if neighbor not in visited:
                # 剪枝3：实体重要性过低
                if kg.get_entity_importance(neighbor) < 0.2:
                    continue

                path.append(neighbor)
                new_score = current_score * kg.get_relation_strength(node, neighbor)
                dfs(neighbor, depth + 1, visited, path, new_score)
                path.pop()

        visited.remove(node)

    dfs(start, 0, set(), [start], 1.0)
    return all_paths
```

---

### 2. 缓存优化

```python
from functools import lru_cache

class CachedMultiHopQA:
    """带缓存的多跳 QA"""
    def __init__(self, kg):
        self.kg = kg

    @lru_cache(maxsize=1000)
    def find_paths_cached(self, start: str, end: str, max_depth: int) -> tuple:
        """缓存路径查找结果"""
        paths = self.find_paths_dfs(start, end, max_depth)
        return tuple(tuple(p) for p in paths)  # 转换为可哈希类型
```

---

## 常见问题

### Q1：如何处理路径爆炸？

**问题：** 大规模图中路径数量呈指数增长

**解决方案：**
1. 限制最大深度（max_depth）
2. 早停（找到 K 条路径后停止）
3. 剪枝（过滤低质量路径）
4. Beam Search（只保留 top-K 候选）

---

### Q2：如何避免 lost-in-the-middle？

**问题：** LLM 对中间部分的上下文理解较差

**解决方案：**
1. SG-RAG MOT：按距离排序三元组
2. KG2RAG：DFS 组织连贯段落
3. 路径压缩：只保留关键实体

---

### Q3：如何提高推理准确性？

**解决方案：**
1. 路径评分：选择高质量路径
2. 多路径验证：对比多条路径的答案
3. LLM 自校正：让 LLM 验证推理链的合理性

---

## 学习检查

- [ ] 理解单跳 vs 多跳推理的区别
- [ ] 掌握 KG2RAG 的 BFS+DFS 混合策略
- [ ] 了解 SG-RAG MOT 的三元组排序
- [ ] 能够实现路径评分和选择
- [ ] 理解路径剪枝和优化技术

---

## 下一步

1. `03_核心概念_08_自适应BFS_DFS选择.md` - 学习 ARK 框架
2. `07_实战代码_场景3_多跳推理系统.md` - 实践多跳 QA

---

**版本：** v1.0
**最后更新：** 2026-02-14
**参考文献：**
- KG2RAG (NAACL 2025): https://arxiv.org/abs/2502.06864
- SG-RAG MOT (2025): https://www.mdpi.com/2504-4990/7/3/74
