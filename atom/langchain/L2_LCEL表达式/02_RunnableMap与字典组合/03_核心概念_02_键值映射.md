# 核心概念2: 键值映射

> **深入理解输入分发、输出映射和键名设计**

---

## 概述

**键值映射**是 RunnableParallel 的核心机制，它定义了输入如何分发到各个分支，以及输出如何映射为字典。

**本文内容**：
- 输入分发机制
- 输出映射规则
- 键名设计原则
- 类型系统和类型推断
- 常见问题和解决方案

**学习目标**：
- 理解输入如何分发到所有分支
- 掌握输出映射的规则
- 学会设计清晰的键名
- 理解类型系统

---

## 输入分发机制

### 基本原理

```python
chain = {
    "task1": runnable1,
    "task2": runnable2,
    "task3": runnable3,
}

result = chain.invoke(input)
```

**分发过程**：

```
输入: input
  ↓
复制3份
  ├─> runnable1.invoke(input)
  ├─> runnable2.invoke(input)
  └─> runnable3.invoke(input)
```

**关键特性**：
- **相同输入**：所有分支接收相同的输入
- **输入复制**：每个分支接收输入的副本
- **独立执行**：分支之间不共享状态

---

### 输入复制 vs 输入共享

#### 输入复制（实际行为）

```python
from langchain_core.runnables import RunnableLambda

def modify_input(x):
    """尝试修改输入"""
    x["data"] = "modified"
    return x["data"]

def read_input(x):
    """读取输入"""
    return x["data"]

chain = {
    "modify": RunnableLambda(modify_input),
    "read": RunnableLambda(read_input),
}

result = chain.invoke({"data": "original"})
print(result)
# {"modify": "modified", "read": "original"}
# read 看到的是原始输入，不受 modify 影响
```

**原因**：每个分支接收输入的副本，修改不会影响其他分支。

---

#### 如果是输入共享（假设）

```python
# 假设输入是共享的（实际不是）
result = chain.invoke({"data": "original"})
# 可能的输出（取决于执行顺序）：
# {"modify": "modified", "read": "modified"}  # modify 先执行
# {"modify": "modified", "read": "original"}  # read 先执行
# 结果不确定！
```

**问题**：
- 竞态条件（race condition）
- 结果不可预测
- 难以调试

---

### 输入类型要求

#### 所有分支必须接受相同类型

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

model = ChatOpenAI(model="gpt-4")

# ✅ 正确：所有分支接受 Dict[str, str]
chain = {
    "summary": ChatPromptTemplate.from_template("总结: {text}") | model,
    "keywords": ChatPromptTemplate.from_template("关键词: {text}") | model,
}

result = chain.invoke({"text": "LangChain 很强大"})
```

---

#### 输入类型不匹配的解决方案

```python
from operator import itemgetter
from langchain_core.runnables import RunnablePassthrough

# 问题：retriever 期望字符串，但输入是字典
# ❌ 错误
chain = {
    "context": retriever,  # 期望 str
    "question": RunnablePassthrough(),  # 接受 dict
}
chain.invoke({"question": "..."})  # 报错！

# ✅ 解决方案1：使用 itemgetter 提取字段
chain = {
    "context": itemgetter("question") | retriever,  # 提取 question 字段
    "question": RunnablePassthrough(),
}

# ✅ 解决方案2：使用 lambda
chain = {
    "context": RunnableLambda(lambda x: retriever.invoke(x["question"])),
    "question": RunnablePassthrough(),
}

# ✅ 解决方案3：使用 retriever 的 pick 方法（如果支持）
chain = {
    "context": retriever.pick("question"),
    "question": RunnablePassthrough(),
}
```

---

### 输入分发的完整示例

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableLambda
from dotenv import load_dotenv

load_dotenv()

model = ChatOpenAI(model="gpt-4")

# 定义多个任务，都接受相同的输入格式
chain = {
    "summary": ChatPromptTemplate.from_template(
        "总结以下文本:\n\n{text}"
    ) | model,
    "keywords": ChatPromptTemplate.from_template(
        "提取关键词:\n\n{text}"
    ) | model,
    "length": RunnableLambda(lambda x: len(x["text"])),
    "word_count": RunnableLambda(lambda x: len(x["text"].split())),
}

# 相同输入分发到所有分支
input_data = {"text": "LangChain 是一个强大的 AI 应用开发框架"}
result = chain.invoke(input_data)

print("摘要:", result["summary"].content)
print("关键词:", result["keywords"].content)
print("长度:", result["length"])
print("词数:", result["word_count"])
```

---

## 输出映射规则

### 基本映射

```python
chain = {
    "key1": runnable1,
    "key2": runnable2,
}

result = chain.invoke(input)
# result = {
#     "key1": runnable1的输出,
#     "key2": runnable2的输出,
# }
```

**映射规则**：
- 字典的键名 → 输出字典的键名
- Runnable 的输出 → 输出字典的值

---

### 嵌套映射

```python
chain = {
    "group1": {
        "task1a": runnable1a,
        "task1b": runnable1b,
    },
    "group2": runnable2,
}

result = chain.invoke(input)
# result = {
#     "group1": {
#         "task1a": runnable1a的输出,
#         "task1b": runnable1b的输出,
#     },
#     "group2": runnable2的输出,
# }
```

**嵌套规则**：
- 嵌套字典保持结构
- 递归应用映射规则

---

### 输出类型

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableLambda

model = ChatOpenAI(model="gpt-4")

chain = {
    "ai_message": ChatPromptTemplate.from_template("{text}") | model,  # AIMessage
    "string": RunnableLambda(lambda x: x["text"]),  # str
    "number": RunnableLambda(lambda x: len(x["text"])),  # int
    "list": RunnableLambda(lambda x: x["text"].split()),  # List[str]
}

result = chain.invoke({"text": "Hello World"})
# result = {
#     "ai_message": AIMessage(...),
#     "string": "Hello World",
#     "number": 11,
#     "list": ["Hello", "World"],
# }
```

**类型规则**：
- 输出字典的值类型 = 对应 Runnable 的输出类型
- 可以是任意类型（AIMessage、str、int、list、dict 等）

---

### 输出访问

```python
result = chain.invoke(input)

# 方式1：字典访问
summary = result["summary"]
keywords = result["keywords"]

# 方式2：get 方法（带默认值）
summary = result.get("summary", "默认摘要")

# 方式3：解构（如果键名固定）
summary, keywords = result["summary"], result["keywords"]

# 方式4：遍历
for key, value in result.items():
    print(f"{key}: {value}")
```

---

## 键名设计原则

### 原则1：使用描述性名称

```python
# ✅ 好：键名清晰描述内容
chain = {
    "user_profile": get_user_profile,
    "recent_posts": get_recent_posts,
    "friend_recommendations": get_recommendations,
}

# ❌ 不好：键名不清晰
chain = {
    "data1": get_user_profile,
    "x": get_recent_posts,
    "result": get_recommendations,
}
```

**为什么重要？**
- 代码可读性
- 维护性
- 调试时更容易理解

---

### 原则2：保持命名一致性

```python
# ✅ 好：统一使用下划线命名
chain = {
    "user_profile": get_profile,
    "user_posts": get_posts,
    "user_stats": get_stats,
}

# ❌ 不好：命名风格不一致
chain = {
    "userProfile": get_profile,  # 驼峰
    "user_posts": get_posts,     # 下划线
    "UserStats": get_stats,      # 帕斯卡
}
```

**推荐风格**：
- Python：`snake_case`（下划线）
- JavaScript：`camelCase`（驼峰）
- 保持项目内一致

---

### 原则3：键名与后续步骤匹配

```python
from langchain_core.prompts import ChatPromptTemplate

# 定义 Prompt 模板
prompt = ChatPromptTemplate.from_template(
    "根据以下信息生成报告\n\n"
    "用户资料: {user_profile}\n"
    "文章列表: {recent_posts}\n"
    "统计数据: {user_stats}"
)

# ✅ 正确：键名与模板变量匹配
chain = {
    "user_profile": get_profile,
    "recent_posts": get_posts,
    "user_stats": get_stats,
} | prompt | model

# ❌ 错误：键名不匹配
chain = {
    "profile": get_profile,  # 模板期望 user_profile
    "posts": get_posts,      # 模板期望 recent_posts
    "stats": get_stats,      # 模板期望 user_stats
} | prompt | model  # 报错：KeyError
```

---

### 原则4：避免键名冲突

```python
# ❌ 错误：键名重复
chain = {
    "result": task1,
    "result": task2,  # 覆盖了第一个
}

result = chain.invoke(input)
print(result)
# {"result": task2的输出}  # task1 的结果丢失

# ✅ 正确：使用不同的键名
chain = {
    "result1": task1,
    "result2": task2,
}
```

---

### 原则5：使用有意义的前缀/后缀

```python
# ✅ 好：使用前缀分组
chain = {
    "api_user": api_get_user,
    "api_posts": api_get_posts,
    "db_stats": db_get_stats,
    "db_settings": db_get_settings,
}

# ✅ 好：使用后缀表示类型
chain = {
    "summary_text": summary_chain,
    "keywords_list": keywords_chain,
    "sentiment_score": sentiment_chain,
}
```

---

## 类型系统

### 类型签名

```python
from typing import Dict, Any
from langchain_core.runnables import Runnable

# RunnableParallel 的类型签名
class RunnableParallel(Runnable[Input, Dict[str, Output]]):
    """
    Input: 输入类型
    Dict[str, Output]: 输出类型（字典）
    """
    pass
```

---

### 类型推断

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import AIMessage

model = ChatOpenAI(model="gpt-4")

chain = {
    "summary": ChatPromptTemplate.from_template("{text}") | model,
    "keywords": ChatPromptTemplate.from_template("{text}") | model,
}

# 类型推断
# chain: RunnableParallel[Dict[str, str], Dict[str, AIMessage]]
#        输入类型: Dict[str, str]
#        输出类型: Dict[str, AIMessage]

result = chain.invoke({"text": "..."})
# result: Dict[str, AIMessage]
```

---

### 类型注解示例

```python
from typing import Dict
from langchain_core.runnables import RunnableParallel, RunnableLambda
from langchain_core.messages import AIMessage

# 定义输入类型
class InputData:
    text: str
    user_id: str

# 定义输出类型
class OutputData:
    summary: AIMessage
    keywords: AIMessage
    metadata: Dict[str, int]

# 带类型注解的链
def create_analysis_chain() -> RunnableParallel[Dict[str, str], Dict[str, Any]]:
    return {
        "summary": summary_chain,
        "keywords": keywords_chain,
        "metadata": RunnableLambda(lambda x: {"length": len(x["text"])}),
    }

chain = create_analysis_chain()
result: Dict[str, Any] = chain.invoke({"text": "..."})
```

---

## 完整示例

### 示例1: RAG 键值映射

```python
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_community.vectorstores import Chroma
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_core.documents import Document
from dotenv import load_dotenv

load_dotenv()

# 准备向量存储
docs = [
    Document(page_content="LangChain 是一个 AI 应用开发框架"),
    Document(page_content="LCEL 是 LangChain 的表达式语言"),
]

vectorstore = Chroma.from_documents(
    documents=docs,
    embedding=OpenAIEmbeddings()
)
retriever = vectorstore.as_retriever()

model = ChatOpenAI(model="gpt-4")

# 键值映射：context 和 question
rag_chain = (
    {
        "context": retriever,  # 键名: context
        "question": RunnablePassthrough(),  # 键名: question
    }
    | ChatPromptTemplate.from_template(
        "根据上下文回答问题\n\n"
        "上下文: {context}\n"  # 使用 context 键
        "问题: {question}\n"  # 使用 question 键
        "答案:"
    )
    | model
)

answer = rag_chain.invoke("LangChain 是什么？")
print(answer.content)
```

**键值映射分析**：
1. 输入：`"LangChain 是什么？"`（字符串）
2. 第一步并行：
   - `context`: retriever 接收字符串，返回文档列表
   - `question`: RunnablePassthrough 接收字符串，返回字符串
3. 输出：`{"context": [...], "question": "LangChain 是什么？"}`
4. 第二步：Prompt 模板使用 `{context}` 和 `{question}` 变量

---

### 示例2: 多层键值映射

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableLambda
from dotenv import load_dotenv

load_dotenv()

model = ChatOpenAI(model="gpt-4")

# 多层嵌套的键值映射
chain = {
    "content_analysis": {
        "summary": ChatPromptTemplate.from_template("总结: {text}") | model,
        "keywords": ChatPromptTemplate.from_template("关键词: {text}") | model,
    },
    "metadata": {
        "length": RunnableLambda(lambda x: len(x["text"])),
        "word_count": RunnableLambda(lambda x: len(x["text"].split())),
    },
    "original_text": RunnableLambda(lambda x: x["text"]),
}

result = chain.invoke({"text": "LangChain 让 AI 开发更简单"})

# 访问嵌套结果
print("=== 内容分析 ===")
print("摘要:", result["content_analysis"]["summary"].content)
print("关键词:", result["content_analysis"]["keywords"].content)

print("\n=== 元数据 ===")
print("长度:", result["metadata"]["length"])
print("词数:", result["metadata"]["word_count"])

print("\n=== 原始文本 ===")
print(result["original_text"])
```

---

### 示例3: 动态键名

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from dotenv import load_dotenv

load_dotenv()

model = ChatOpenAI(model="gpt-4")

def create_multi_perspective_chain(perspectives: list[str]):
    """根据视角列表动态创建键值映射"""
    tasks = {}
    for perspective in perspectives:
        key = f"perspective_{perspective}"
        tasks[key] = ChatPromptTemplate.from_template(
            f"从{perspective}的角度分析: {{text}}"
        ) | model
    return tasks

# 创建多视角分析链
perspectives = ["技术", "商业", "用户体验"]
chain = create_multi_perspective_chain(perspectives)

result = chain.invoke({"text": "LangChain 的优势是什么？"})

for key, value in result.items():
    print(f"{key}: {value.content}\n")
```

---

## 常见问题和解决方案

### 问题1: 键名不匹配

```python
# 问题
prompt = ChatPromptTemplate.from_template("上下文: {context}\n问题: {question}")

chain = {
    "ctx": retriever,  # 键名是 ctx
    "q": RunnablePassthrough(),  # 键名是 q
} | prompt  # 期望 context 和 question

# 报错：KeyError: 'context'

# 解决方案1：修改键名
chain = {
    "context": retriever,
    "question": RunnablePassthrough(),
} | prompt

# 解决方案2：使用 RunnableLambda 重新映射
chain = (
    {
        "ctx": retriever,
        "q": RunnablePassthrough(),
    }
    | RunnableLambda(lambda x: {"context": x["ctx"], "question": x["q"]})
    | prompt
)
```

---

### 问题2: 输入类型不匹配

```python
# 问题：retriever 期望字符串，但输入是字典
chain = {
    "context": retriever,  # 期望 str
}
chain.invoke({"question": "..."})  # 传入 dict

# 报错：TypeError

# 解决方案1：使用 itemgetter
from operator import itemgetter

chain = {
    "context": itemgetter("question") | retriever,
}

# 解决方案2：使用 lambda
chain = {
    "context": RunnableLambda(lambda x: retriever.invoke(x["question"])),
}
```

---

### 问题3: 键名冲突

```python
# 问题：键名重复
chain = {
    "result": task1,
    "result": task2,  # 覆盖
}

# 解决方案：使用不同的键名
chain = {
    "result_task1": task1,
    "result_task2": task2,
}

# 或者使用描述性名称
chain = {
    "summary": task1,
    "keywords": task2,
}
```

---

### 问题4: 嵌套访问错误

```python
# 问题：嵌套字典访问
result = {
    "group1": {
        "task1": "value1",
    }
}

# ❌ 错误：直接访问不存在的键
value = result["group1"]["task2"]  # KeyError

# ✅ 解决方案1：使用 get
value = result.get("group1", {}).get("task2", "默认值")

# ✅ 解决方案2：检查键是否存在
if "group1" in result and "task2" in result["group1"]:
    value = result["group1"]["task2"]
else:
    value = "默认值"
```

---

## 最佳实践总结

### 输入分发

1. **确保类型一致**：所有分支接受相同类型的输入
2. **使用 itemgetter**：提取字典中的特定字段
3. **不要依赖执行顺序**：分支之间不共享状态

### 输出映射

1. **使用描述性键名**：清晰表达输出内容
2. **保持命名一致**：统一命名风格
3. **键名与后续步骤匹配**：确保 Prompt 模板能找到变量

### 键名设计

1. **描述性**：`user_profile` 而不是 `data1`
2. **一致性**：统一使用 `snake_case` 或 `camelCase`
3. **匹配性**：与 Prompt 模板变量名一致
4. **无冲突**：避免键名重复
5. **有意义的前缀/后缀**：`api_user`、`summary_text`

### 类型系统

1. **使用类型注解**：提高代码可读性
2. **理解类型推断**：知道输入输出类型
3. **处理类型不匹配**：使用转换函数

---

## 下一步学习

- [核心概念3: 结果合并策略](./03_核心概念_03_结果合并策略.md) - 字典合并和错误处理
- [实战代码1: 基础并行执行](./07_实战代码_01_基础并行执行.md) - 完整可运行示例
- [实战代码2: RAG检索场景](./07_实战代码_02_RAG检索场景.md) - RAG 中的键值映射

---

## 参考资源

**官方文档**：
- [RunnableParallel API Reference](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.base.RunnableParallel.html)
- [Python Type Hints](https://docs.python.org/3/library/typing.html)

**2025-2026 最佳实践**：
- [Building Production-Ready AI Pipelines](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557)
- [LangChain Best Practices](https://www.swarnendu.de/blog/langchain-best-practices)

---

**版本**: v1.0
**最后更新**: 2026-02-19
**适用**: LangChain 0.3+, Python 3.13+
