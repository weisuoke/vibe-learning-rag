# JWT认证 - 实战代码02：用户登录注册

## 概述

本章实现完整的用户注册和登录系统，包括密码哈希、数据库存储、输入验证等。

---

## 环境准备

### 安装依赖

```bash
# 安装所需库
pip install fastapi uvicorn sqlalchemy psycopg2-binary passlib[bcrypt] python-jose[cryptography] pydantic[email]

# 或使用 uv
uv add fastapi uvicorn sqlalchemy psycopg2-binary "passlib[bcrypt]" "python-jose[cryptography]" "pydantic[email]"
```

---

## 数据库模型

### 用户模型定义

```python
"""
用户数据库模型
演示：定义 User 表结构
"""

from sqlalchemy import Column, Integer, String, DateTime, Boolean
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()


class User(Base):
    """用户模型"""
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f"<User(id={self.id}, email={self.email}, username={self.username})>"
```

### 数据库连接

```python
"""
数据库连接配置
演示：创建数据库引擎和会话
"""

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from typing import Generator
import os

# 数据库 URL
DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://user:password@localhost:5432/jwt_auth_db"
)

# 创建引擎
engine = create_engine(DATABASE_URL, echo=True)

# 创建会话工厂
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


def get_db() -> Generator[Session, None, None]:
    """获取数据库会话（依赖注入）"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# 创建所有表
def create_tables():
    """创建数据库表"""
    Base.metadata.create_all(bind=engine)


if __name__ == "__main__":
    create_tables()
    print("数据库表创建成功")
```

---

## 密码哈希

### 密码工具类

```python
"""
密码哈希工具
演示：使用 bcrypt 哈希和验证密码
"""

from passlib.context import CryptContext

# 创建密码上下文
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class PasswordManager:
    """密码管理器"""

    @staticmethod
    def hash_password(password: str) -> str:
        """
        哈希密码

        Args:
            password: 明文密码

        Returns:
            哈希后的密码
        """
        return pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """
        验证密码

        Args:
            plain_password: 明文密码
            hashed_password: 哈希后的密码

        Returns:
            密码是否正确
        """
        return pwd_context.verify(plain_password, hashed_password)


# ===== 使用示例 =====

# 1. 哈希密码
password = "MySecurePassword123!"
hashed = PasswordManager.hash_password(password)
print(f"原始密码: {password}")
print(f"哈希后: {hashed}")
# $2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYzS4HWBe4u

# 2. 验证密码
is_valid = PasswordManager.verify_password("MySecurePassword123!", hashed)
print(f"密码正确: {is_valid}")  # True

is_valid = PasswordManager.verify_password("WrongPassword", hashed)
print(f"错误密码: {is_valid}")  # False
```

---

## 输入验证

### Pydantic 模型

```python
"""
请求和响应模型
演示：使用 Pydantic 验证输入
"""

from pydantic import BaseModel, EmailStr, validator, Field
from typing import Optional
from datetime import datetime


class RegisterRequest(BaseModel):
    """注册请求"""
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=20)
    password: str = Field(..., min_length=8)

    @validator('username')
    def username_alphanumeric(cls, v):
        """用户名只能包含字母、数字和下划线"""
        if not v.replace('_', '').isalnum():
            raise ValueError('用户名只能包含字母、数字和下划线')
        return v

    @validator('password')
    def password_strength(cls, v):
        """密码强度验证"""
        if not any(c.isupper() for c in v):
            raise ValueError('密码必须包含至少一个大写字母')
        if not any(c.islower() for c in v):
            raise ValueError('密码必须包含至少一个小写字母')
        if not any(c.isdigit() for c in v):
            raise ValueError('密码必须包含至少一个数字')
        if not any(c in '!@#$%^&*()_+-=[]{}|;:,.<>?' for c in v):
            raise ValueError('密码必须包含至少一个特殊字符')
        return v


class LoginRequest(BaseModel):
    """登录请求"""
    email: EmailStr
    password: str


class UserResponse(BaseModel):
    """用户响应"""
    id: int
    email: str
    username: str
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True  # Pydantic v2


class TokenResponse(BaseModel):
    """Token 响应"""
    access_token: str
    token_type: str = "bearer"


# ===== 测试验证 =====

# 1. 有效的注册请求
try:
    request = RegisterRequest(
        email="alice@example.com",
        username="alice_123",
        password="SecurePass123!"
    )
    print(f"✓ 有效请求: {request}")
except ValueError as e:
    print(f"✗ 验证失败: {e}")

# 2. 无效的用户名
try:
    request = RegisterRequest(
        email="bob@example.com",
        username="ab",  # 太短
        password="SecurePass123!"
    )
except ValueError as e:
    print(f"✗ 用户名验证失败: {e}")

# 3. 弱密码
try:
    request = RegisterRequest(
        email="charlie@example.com",
        username="charlie",
        password="weak"  # 太弱
    )
except ValueError as e:
    print(f"✗ 密码验证失败: {e}")
```

---

## 用户注册实现

### 注册端点

```python
"""
用户注册完整实现
演示：注册 → 验证 → 哈希密码 → 存储
"""

from fastapi import FastAPI, HTTPException, Depends
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

app = FastAPI()


@app.post("/register", response_model=UserResponse)
async def register(
    request: RegisterRequest,
    db: Session = Depends(get_db)
):
    """
    用户注册端点

    Args:
        request: 注册请求（邮箱、用户名、密码）
        db: 数据库会话

    Returns:
        创建的用户信息

    Raises:
        HTTPException: 邮箱或用户名已存在
    """
    # 1. 检查邮箱是否已存在
    existing_user = db.query(User).filter(User.email == request.email).first()
    if existing_user:
        raise HTTPException(
            status_code=400,
            detail="邮箱已被注册"
        )

    # 2. 检查用户名是否已存在
    existing_user = db.query(User).filter(User.username == request.username).first()
    if existing_user:
        raise HTTPException(
            status_code=400,
            detail="用户名已被使用"
        )

    # 3. 哈希密码
    hashed_password = PasswordManager.hash_password(request.password)

    # 4. 创建用户
    user = User(
        email=request.email,
        username=request.username,
        hashed_password=hashed_password
    )

    try:
        db.add(user)
        db.commit()
        db.refresh(user)
    except IntegrityError:
        db.rollback()
        raise HTTPException(
            status_code=400,
            detail="用户创建失败，请稍后重试"
        )

    # 5. 返回用户信息（不包含密码）
    return user
```

### 测试注册

```bash
# 1. 注册新用户
curl -X POST "http://localhost:8000/register" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "alice@example.com",
    "username": "alice",
    "password": "SecurePass123!"
  }'

# 响应
# {
#   "id": 1,
#   "email": "alice@example.com",
#   "username": "alice",
#   "is_active": true,
#   "created_at": "2024-02-12T10:00:00"
# }

# 2. 尝试重复注册（应该失败）
curl -X POST "http://localhost:8000/register" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "alice@example.com",
    "username": "alice2",
    "password": "SecurePass123!"
  }'

# 响应
# {
#   "detail": "邮箱已被注册"
# }
```

---

## 用户登录实现

### JWT 工具函数

```python
"""
JWT 工具函数
演示：生成 Access Token
"""

from jose import jwt
from datetime import datetime, timedelta
import os

SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 15


def create_access_token(user_id: int, username: str) -> str:
    """
    生成 Access Token

    Args:
        user_id: 用户 ID
        username: 用户名

    Returns:
        JWT Token
    """
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    payload = {
        "user_id": user_id,
        "username": username,
        "exp": expire
    }

    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    return token
```

### 登录端点

```python
@app.post("/login", response_model=TokenResponse)
async def login(
    request: LoginRequest,
    db: Session = Depends(get_db)
):
    """
    用户登录端点

    Args:
        request: 登录请求（邮箱、密码）
        db: 数据库会话

    Returns:
        JWT Token

    Raises:
        HTTPException: 邮箱或密码错误
    """
    # 1. 查找用户
    user = db.query(User).filter(User.email == request.email).first()
    if not user:
        raise HTTPException(
            status_code=401,
            detail="邮箱或密码错误"
        )

    # 2. 验证密码
    if not PasswordManager.verify_password(request.password, user.hashed_password):
        raise HTTPException(
            status_code=401,
            detail="邮箱或密码错误"
        )

    # 3. 检查用户是否激活
    if not user.is_active:
        raise HTTPException(
            status_code=403,
            detail="账号已被禁用"
        )

    # 4. 生成 JWT
    access_token = create_access_token(
        user_id=user.id,
        username=user.username
    )

    return TokenResponse(access_token=access_token)
```

### 测试登录

```bash
# 1. 登录
curl -X POST "http://localhost:8000/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "alice@example.com",
    "password": "SecurePass123!"
  }'

# 响应
# {
#   "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
#   "token_type": "bearer"
# }

# 2. 错误的密码
curl -X POST "http://localhost:8000/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "alice@example.com",
    "password": "WrongPassword"
  }'

# 响应
# {
#   "detail": "邮箱或密码错误"
# }
```

---

## 完整示例

### 完整的注册登录系统

```python
"""
完整的用户注册登录系统
演示：注册 → 登录 → 获取 Token
"""

from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.exc import IntegrityError
from passlib.context import CryptContext
from jose import jwt, JWTError
from pydantic import BaseModel, EmailStr, validator, Field
from datetime import datetime, timedelta
from typing import Generator, Optional
import os

# ===== 配置 =====

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./test.db")
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 15

# ===== 数据库设置 =====

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()


class User(Base):
    """用户模型"""
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)


Base.metadata.create_all(bind=engine)


def get_db() -> Generator[Session, None, None]:
    """获取数据库会话"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# ===== 密码管理 =====

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class PasswordManager:
    """密码管理器"""

    @staticmethod
    def hash_password(password: str) -> str:
        return pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)


# ===== Pydantic 模型 =====

class RegisterRequest(BaseModel):
    """注册请求"""
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=20)
    password: str = Field(..., min_length=8)

    @validator('password')
    def password_strength(cls, v):
        if not any(c.isupper() for c in v):
            raise ValueError('密码必须包含大写字母')
        if not any(c.islower() for c in v):
            raise ValueError('密码必须包含小写字母')
        if not any(c.isdigit() for c in v):
            raise ValueError('密码必须包含数字')
        return v


class LoginRequest(BaseModel):
    """登录请求"""
    email: EmailStr
    password: str


class UserResponse(BaseModel):
    """用户响应"""
    id: int
    email: str
    username: str
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True


class TokenResponse(BaseModel):
    """Token 响应"""
    access_token: str
    token_type: str = "bearer"


# ===== JWT 工具 =====

def create_access_token(user_id: int, username: str) -> str:
    """生成 Access Token"""
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    payload = {
        "user_id": user_id,
        "username": username,
        "exp": expire
    }

    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def verify_token(token: str) -> dict:
    """验证 Token"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的 Token"
        )


# ===== FastAPI 应用 =====

app = FastAPI(title="JWT 认证系统")
security = HTTPBearer()


@app.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def register(request: RegisterRequest, db: Session = Depends(get_db)):
    """用户注册"""
    # 检查邮箱
    if db.query(User).filter(User.email == request.email).first():
        raise HTTPException(400, "邮箱已被注册")

    # 检查用户名
    if db.query(User).filter(User.username == request.username).first():
        raise HTTPException(400, "用户名已被使用")

    # 创建用户
    user = User(
        email=request.email,
        username=request.username,
        hashed_password=PasswordManager.hash_password(request.password)
    )

    try:
        db.add(user)
        db.commit()
        db.refresh(user)
        return user
    except IntegrityError:
        db.rollback()
        raise HTTPException(400, "用户创建失败")


@app.post("/login", response_model=TokenResponse)
async def login(request: LoginRequest, db: Session = Depends(get_db)):
    """用户登录"""
    # 查找用户
    user = db.query(User).filter(User.email == request.email).first()
    if not user:
        raise HTTPException(401, "邮箱或密码错误")

    # 验证密码
    if not PasswordManager.verify_password(request.password, user.hashed_password):
        raise HTTPException(401, "邮箱或密码错误")

    # 检查激活状态
    if not user.is_active:
        raise HTTPException(403, "账号已被禁用")

    # 生成 Token
    access_token = create_access_token(user.id, user.username)

    return TokenResponse(access_token=access_token)


@app.get("/me", response_model=UserResponse)
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
):
    """获取当前用户信息"""
    # 验证 Token
    payload = verify_token(credentials.credentials)
    user_id = payload.get("user_id")

    # 查找用户
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(404, "用户不存在")

    return user


# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 完整测试流程

```bash
# 1. 注册用户
curl -X POST "http://localhost:8000/register" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "alice@example.com",
    "username": "alice",
    "password": "SecurePass123!"
  }'

# 2. 登录获取 Token
TOKEN=$(curl -s -X POST "http://localhost:8000/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "alice@example.com",
    "password": "SecurePass123!"
  }' | jq -r '.access_token')

# 3. 使用 Token 获取用户信息
curl -X GET "http://localhost:8000/me" \
  -H "Authorization: Bearer $TOKEN"
```

---

## 在 AI Agent API 中的应用

### AI Agent 用户系统

```python
"""
AI Agent 用户系统
演示：注册 → 登录 → 调用 AI Agent
"""

@app.post("/agent/chat")
async def chat(
    message: str,
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
):
    """AI Agent 对话端点（需要登录）"""
    # 1. 验证 Token
    payload = verify_token(credentials.credentials)
    user_id = payload.get("user_id")

    # 2. 查找用户
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(404, "用户不存在")

    # 3. 调用 AI Agent（简化）
    response = f"AI 回复给 {user.username}: 你说了 '{message}'"

    return {
        "user_id": user.id,
        "username": user.username,
        "message": message,
        "response": response
    }
```

---

## 总结

**本章实现了：**
1. 用户数据库模型
2. 密码哈希（bcrypt）
3. 输入验证（Pydantic）
4. 用户注册端点
5. 用户登录端点
6. 完整的认证系统

**关键点：**
- 密码必须哈希存储
- 使用 Pydantic 验证输入
- 邮箱和用户名唯一性检查
- 登录失败返回统一错误信息
- Token 包含用户 ID 和用户名

**下一步：**
- 学习 Token 刷新机制
- 学习依赖注入保护路由
- 学习 RBAC 权限控制
