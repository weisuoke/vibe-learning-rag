# 最小可用

> **目标**：用最少的代码快速上手状态机和AI Agent

---

## 一、5分钟上手DFA

```python
# 最简单的DFA：识别偶数个1
transitions = {
    ('q0', '0'): 'q0',
    ('q0', '1'): 'q1',
    ('q1', '0'): 'q1',
    ('q1', '1'): 'q0',
}

def accepts(input_str):
    state = 'q0'
    for symbol in input_str:
        state = transitions[(state, symbol)]
    return state == 'q0'

# 测试
print(accepts("11"))   # True（2个1）
print(accepts("111"))  # False（3个1）
```

---

## 二、10分钟上手LangGraph

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict

# 1. 定义状态
class State(TypedDict):
    query: str
    answer: str

# 2. 定义节点
def process(state: State) -> State:
    return {"answer": f"处理: {state['query']}"}

# 3. 构建图
graph = StateGraph(State)
graph.add_node("process", process)
graph.set_entry_point("process")
graph.add_edge("process", END)

# 4. 运行
app = graph.compile()
result = app.invoke({"query": "test", "answer": ""})
print(result["answer"])
```

---

## 三、15分钟上手Checkpointing

```python
from langgraph.checkpoint.memory import MemorySaver

# 添加checkpointer
checkpointer = MemorySaver()
app = graph.compile(checkpointer=checkpointer)

# 运行（自动保存状态）
config = {"configurable": {"thread_id": "1"}}
result = app.invoke({"query": "test"}, config=config)

# 获取状态
state = app.get_state(config)
print(state.values)
```

---

## 四、20分钟上手多Agent

```python
from typing import Annotated
import operator

# 共享状态
class MultiAgentState(TypedDict):
    results: Annotated[list, operator.add]

# Agent节点
def agent1(state): return {"results": ["agent1"]}
def agent2(state): return {"results": ["agent2"]}

# 并行执行
graph = StateGraph(MultiAgentState)
graph.add_node("agent1", agent1)
graph.add_node("agent2", agent2)
graph.add_edge(START, "agent1")
graph.add_edge(START, "agent2")
graph.add_edge(["agent1", "agent2"], END)

app = graph.compile()
result = app.invoke({"results": []})
print(result["results"])  # ["agent1", "agent2"]
```

---

## 五、核心API速查

### DFA
```python
# 创建
dfa = DFA(states, alphabet, transitions, initial, accept)

# 使用
dfa.accepts(input_string)  # 判断接受
dfa.trace(input_string)     # 追踪执行
```

### LangGraph
```python
# 创建图
graph = StateGraph(StateType)
graph.add_node("name", function)
graph.add_edge("from", "to")
graph.add_conditional_edges("from", router, {...})

# 编译运行
app = graph.compile()
result = app.invoke(initial_state)
```

### Checkpointing
```python
# 保存状态
app = graph.compile(checkpointer=checkpointer)
result = app.invoke(state, config={"configurable": {"thread_id": "1"}})

# 获取状态
state = app.get_state(config)

# 更新状态
app.update_state(config, {"key": "value"})

# 获取历史
history = app.get_state_history(config)
```

---

## 六、常见问题

**Q: DFA和NFA有什么区别？**
A: DFA每个状态对每个输入有唯一转移，NFA可以有多个转移。

**Q: LangGraph和传统Prompt链有什么区别？**
A: LangGraph显式定义状态和转移，传统Prompt链是隐式的。

**Q: 什么时候需要Checkpointing？**
A: 长运行任务、需要故障恢复、人机协作时需要。

**Q: 如何实现多Agent并行？**
A: 使用`graph.add_edge(START, "agent1")`和`graph.add_edge(START, "agent2")`。

---

## 七、学习路径

**第1天**：理解DFA基础（5元组、转移函数）
**第2天**：手写DFA实现
**第3天**：学习LangGraph基础（StateGraph、节点、边）
**第4天**：构建简单RAG Agent
**第5天**：学习Checkpointing
**第6天**：实现多Agent系统
**第7天**：生产级优化

---

## 八、资源链接

**官方文档**：
- LangGraph: https://docs.langchain.com/oss/python/langgraph
- LangGraph Persistence: https://docs.langchain.com/oss/python/langgraph/persistence

**教程**：
- LangGraph Quickstart
- LangGraph for Beginners

**示例代码**：
- 本目录的实战代码场景1-5

---

**版本**: v1.0
**最后更新**: 2026-02-14
