# 核心概念2：授权机制（RBAC）

**授权（Authorization）是控制用户权限的过程，基于角色的访问控制（RBAC）实现最小权限原则，确保用户只能执行被允许的操作。**

---

## 什么是授权？

### 定义

**授权 = 控制"谁"可以对"什么资源"做"什么操作"**

```
认证回答：你是谁？（已验证身份）
授权回答：你能做什么？（检查权限）

示例：
用户：张三（已认证）
操作：删除 Collection
授权检查：张三是否有删除权限？
- 有权限 → 允许操作
- 无权限 → 拒绝操作
```

### 授权 vs 认证

```
认证（Authentication）：
- 问题：你是谁？
- 时机：连接时
- 结果：通过 → 获得访问权限 / 失败 → 无法连接

授权（Authorization）：
- 问题：你能做什么？
- 时机：每次操作时
- 结果：有权限 → 允许操作 / 无权限 → 拒绝操作
```

---

## RBAC（基于角色的访问控制）

### 什么是 RBAC？

**RBAC = Role-Based Access Control（基于角色的访问控制）**

**核心思想：** 通过角色简化权限管理

```
传统方式（直接授权）：
用户1 → 权限A, 权限B, 权限C
用户2 → 权限A, 权限B, 权限C
用户3 → 权限A, 权限B, 权限C
❌ 问题：每个用户都要单独配置，管理复杂

RBAC 方式（基于角色）：
角色：数据分析师 → 权限A, 权限B, 权限C
用户1 → 数据分析师
用户2 → 数据分析师
用户3 → 数据分析师
✅ 优点：只需配置一次角色，用户绑定角色即可
```

### RBAC 模型

```
┌─────────┐      ┌─────────┐      ┌─────────┐      ┌─────────┐
│  用户   │ ───> │  角色   │ ───> │  权限   │ ───> │  资源   │
│  User   │      │  Role   │      │Privilege│      │ Object  │
└─────────┘      └─────────┘      └─────────┘      └─────────┘

示例：
张三 → 数据分析师 → Search 权限 → docs Collection
李四 → 数据管理员 → Insert/Delete 权限 → 所有 Collection
王五 → 系统管理员 → 全部权限 → 所有资源
```

### RBAC 的优势

1. **简化管理**
```
场景：公司有100个数据分析师

传统方式：
- 为每个分析师单独配置权限（100次）
- 修改权限时需要更新100个用户

RBAC 方式：
- 创建"数据分析师"角色（1次）
- 100个用户绑定到角色（100次）
- 修改权限时只需更新角色（1次）
```

2. **最小权限原则**
```
原则：只给用户完成工作所需的最小权限

示例：
客服人员：
✅ 可以查询知识库（Search）
❌ 不能删除数据（Delete）
❌ 不能创建 Collection（CreateCollection）
```

3. **职责分离**
```
不同角色有不同职责：
- 只读用户：只能查询
- 数据管理员：可以增删改查
- 系统管理员：可以管理用户和系统配置
```

---

## Milvus 中的权限类型

### 权限分类

Milvus 的权限分为以下几类：

#### 1. Collection 级别权限

```python
# Collection 管理
- CreateCollection：创建 Collection
- DropCollection：删除 Collection
- DescribeCollection：查看 Collection 信息
- ShowCollections：列出所有 Collection
- RenameCollection：重命名 Collection

# Collection 操作
- Load：加载 Collection 到内存
- Release：从内存释放 Collection
- GetLoadState：查看加载状态
- GetLoadingProgress：查看加载进度
```

#### 2. 数据操作权限

```python
# 数据写入
- Insert：插入数据
- Delete：删除数据
- Upsert：插入或更新数据

# 数据查询
- Search：向量检索
- Query：标量查询
- GetStatistics：获取统计信息
```

#### 3. 索引管理权限

```python
- CreateIndex：创建索引
- DropIndex：删除索引
- DescribeIndex：查看索引信息
```

#### 4. Partition 管理权限

```python
- CreatePartition：创建分区
- DropPartition：删除分区
- ShowPartitions：列出所有分区
- HasPartition：检查分区是否存在
```

#### 5. 用户管理权限

```python
- CreateUser：创建用户
- DeleteUser：删除用户
- UpdateUser：更新用户
- SelectUser：查询用户
```

#### 6. 角色管理权限

```python
- CreateRole：创建角色
- DropRole：删除角色
- SelectRole：查询角色
- GrantPrivilege：授予权限
- RevokePrivilege：撤销权限
- GrantRole：将角色授予用户
- RevokeRole：从用户撤销角色
```

### 权限层级

```
全局权限（Global）：
- 影响整个 Milvus 实例
- 示例：CreateCollection, CreateUser

Collection 权限（Collection）：
- 影响特定 Collection
- 示例：Insert, Search, Query

Partition 权限（Partition）：
- 影响特定 Partition
- 示例：Load, Release
```

---

## 角色和权限管理

### 创建角色

```python
from pymilvus import utility

# 创建角色
utility.create_role(role_name="readonly")
utility.create_role(role_name="data_admin")
utility.create_role(role_name="system_admin")

print("✅ 角色已创建")
```

### 授予权限

```python
# 授予全局权限（所有 Collection）
utility.grant_privilege(
    role_name="readonly",
    object_type="Collection",
    privilege="Search",
    object_name="*"  # * 表示所有 Collection
)

# 授予特定 Collection 的权限
utility.grant_privilege(
    role_name="data_admin",
    object_type="Collection",
    privilege="Insert",
    object_name="docs"  # 只能操作 docs Collection
)

print("✅ 权限已授予")
```

### 撤销权限

```python
# 撤销权限
utility.revoke_privilege(
    role_name="readonly",
    object_type="Collection",
    privilege="Search",
    object_name="*"
)

print("✅ 权限已撤销")
```

### 用户绑定角色

```python
# 将用户绑定到角色
utility.add_user_to_role(
    username="analyst",
    role_name="readonly"
)

# 从角色移除用户
utility.remove_user_from_role(
    username="analyst",
    role_name="readonly"
)

print("✅ 用户角色已更新")
```

### 查询权限

```python
# 查询角色的权限
privileges = utility.list_privileges(role_name="readonly")
print(f"readonly 角色的权限：{privileges}")

# 查询用户的角色
roles = utility.list_roles(username="analyst")
print(f"analyst 用户的角色：{roles}")
```

---

## 常见角色设计

### 1. 只读用户（Readonly User）

**适用场景：** 数据分析师、客服人员、报表查询

```python
from pymilvus import utility

# 创建只读角色
utility.create_role("readonly")

# 授予查询权限
utility.grant_privilege(
    role_name="readonly",
    object_type="Collection",
    privilege="Search",
    object_name="*"
)

utility.grant_privilege(
    role_name="readonly",
    object_type="Collection",
    privilege="Query",
    object_name="*"
)

# 授予查看权限
utility.grant_privilege(
    role_name="readonly",
    object_type="Collection",
    privilege="DescribeCollection",
    object_name="*"
)

utility.grant_privilege(
    role_name="readonly",
    object_type="Collection",
    privilege="ShowCollections",
    object_name="*"
)

# 绑定用户
utility.add_user_to_role("analyst", "readonly")
```

**权限总结：**
- ✅ 可以：查询数据、查看 Collection 信息
- ❌ 不能：插入、删除、创建 Collection

### 2. 数据管理员（Data Admin）

**适用场景：** 内容管理员、数据工程师

```python
# 创建数据管理员角色
utility.create_role("data_admin")

# 授予数据操作权限
privileges = ["Insert", "Delete", "Upsert", "Search", "Query"]
for privilege in privileges:
    utility.grant_privilege(
        role_name="data_admin",
        object_type="Collection",
        privilege=privilege,
        object_name="*"
    )

# 授予索引管理权限
utility.grant_privilege(
    role_name="data_admin",
    object_type="Collection",
    privilege="CreateIndex",
    object_name="*"
)

utility.grant_privilege(
    role_name="data_admin",
    object_type="Collection",
    privilege="DropIndex",
    object_name="*"
)

# 绑定用户
utility.add_user_to_role("data_manager", "data_admin")
```

**权限总结：**
- ✅ 可以：增删改查数据、管理索引
- ❌ 不能：创建/删除 Collection、管理用户

### 3. 系统管理员（System Admin）

**适用场景：** 运维人员、DBA

```python
# 创建系统管理员角色
utility.create_role("system_admin")

# 授予所有权限
all_privileges = [
    "CreateCollection", "DropCollection", "DescribeCollection",
    "ShowCollections", "RenameCollection",
    "Load", "Release",
    "Insert", "Delete", "Upsert", "Search", "Query",
    "CreateIndex", "DropIndex",
    "CreatePartition", "DropPartition",
    "CreateUser", "DeleteUser", "UpdateUser",
    "CreateRole", "DropRole", "GrantPrivilege", "RevokePrivilege"
]

for privilege in all_privileges:
    utility.grant_privilege(
        role_name="system_admin",
        object_type="Collection",
        privilege=privilege,
        object_name="*"
    )

# 绑定用户
utility.add_user_to_role("admin", "system_admin")
```

**权限总结：**
- ✅ 可以：所有操作

### 4. 部门角色（Department Role）

**适用场景：** 多部门企业，部门数据隔离

```python
# 人力部门角色
utility.create_role("hr_staff")

utility.grant_privilege(
    role_name="hr_staff",
    object_type="Collection",
    privilege="Search",
    object_name="hr_docs"  # 只能访问人力部门的 Collection
)

utility.grant_privilege(
    role_name="hr_staff",
    object_type="Collection",
    privilege="Query",
    object_name="hr_docs"
)

# 财务部门角色
utility.create_role("finance_staff")

utility.grant_privilege(
    role_name="finance_staff",
    object_type="Collection",
    privilege="Search",
    object_name="finance_docs"  # 只能访问财务部门的 Collection
)

# 绑定用户
utility.add_user_to_role("hr_employee", "hr_staff")
utility.add_user_to_role("finance_employee", "finance_staff")
```

**权限总结：**
- ✅ 人力员工：只能访问 hr_docs
- ✅ 财务员工：只能访问 finance_docs
- ❌ 跨部门访问被禁止

---

## 权限检查流程

### 权限验证机制

```
用户执行操作时的检查流程：

1. 认证检查
   用户是否已登录？
   ↓ 是
2. 获取用户角色
   查询用户绑定的所有角色
   ↓
3. 获取角色权限
   查询每个角色的权限列表
   ↓
4. 权限匹配
   操作所需权限是否在权限列表中？
   ↓ 是
5. 资源检查
   用户是否有权访问该资源？
   ↓ 是
6. 允许操作
   执行用户请求的操作
```

### 权限检查示例

```python
from pymilvus import Collection, connections, utility

# 1. 用户登录（认证）
connections.connect(
    alias="default",
    host="localhost",
    port="19530",
    user="analyst",
    password="AnalystPass123!"
)

# 2. 尝试查询（授权检查）
try:
    collection = Collection("docs")
    results = collection.search(...)
    print("✅ 查询成功（有 Search 权限）")
except Exception as e:
    print(f"❌ 查询失败：{e}")

# 3. 尝试删除（授权检查）
try:
    collection.delete(expr="id in [1, 2, 3]")
    print("✅ 删除成功（有 Delete 权限）")
except Exception as e:
    print(f"❌ 删除失败：{e}")
    # 输出：❌ 删除失败：permission denied
```

---

## 最小权限原则

### 什么是最小权限原则？

**定义：** 只给用户完成工作所需的最小权限，不多给。

**为什么重要？**

1. **降低安全风险**
```
场景：员工账号被盗

如果员工是管理员：
❌ 攻击者可以删除所有数据
❌ 攻击者可以创建新用户
❌ 攻击者可以窃取所有数据

如果员工是只读用户：
✅ 攻击者只能查询数据
✅ 无法删除或修改数据
✅ 损失最小化
```

2. **防止误操作**
```
场景：新员工不熟悉系统

如果有删除权限：
❌ 可能误删生产数据

如果只有查询权限：
✅ 无法误删数据
✅ 可以安全学习系统
```

3. **职责分离**
```
不同角色有不同职责：
- 数据分析师：只需要查询权限
- 内容管理员：需要增删改查权限
- 系统管理员：需要全部权限
```

### 实施最小权限原则

```python
# ❌ 错误：给所有用户管理员权限
utility.add_user_to_role("analyst", "admin")
utility.add_user_to_role("intern", "admin")
utility.add_user_to_role("contractor", "admin")

# ✅ 正确：根据职责分配权限
utility.add_user_to_role("analyst", "readonly")      # 只读
utility.add_user_to_role("intern", "readonly")       # 只读
utility.add_user_to_role("contractor", "readonly")   # 只读
utility.add_user_to_role("data_manager", "data_admin")  # 数据管理
utility.add_user_to_role("ops_engineer", "system_admin")  # 系统管理
```

---

## 在 RAG 系统中的应用

### 场景1：企业知识库

```python
from pymilvus import utility, connections

class EnterpriseRAGRBAC:
    def __init__(self):
        # 管理员连接
        connections.connect(
            alias="admin",
            user="admin",
            password="AdminPass123!"
        )

    def setup_roles(self):
        """设置企业角色"""
        # 1. 客服角色（只读）
        utility.create_role("customer_service")
        utility.grant_privilege(
            role_name="customer_service",
            object_type="Collection",
            privilege="Search",
            object_name="product_docs"  # 只能查询产品文档
        )

        # 2. 内容管理员（读写）
        utility.create_role("content_admin")
        for privilege in ["Search", "Query", "Insert", "Delete", "Upsert"]:
            utility.grant_privilege(
                role_name="content_admin",
                object_type="Collection",
                privilege=privilege,
                object_name="*"  # 可以操作所有 Collection
            )

        # 3. 部门角色
        departments = ["hr", "finance", "rd"]
        for dept in departments:
            role_name = f"{dept}_staff"
            utility.create_role(role_name)
            utility.grant_privilege(
                role_name=role_name,
                object_type="Collection",
                privilege="Search",
                object_name=f"{dept}_docs"  # 只能访问本部门文档
            )

    def assign_user_role(self, username, role):
        """分配用户角色"""
        utility.add_user_to_role(username, role)
        print(f"✅ 用户 {username} 已分配角色 {role}")

# 使用
rbac = EnterpriseRAGRBAC()
rbac.setup_roles()

# 分配角色
rbac.assign_user_role("service_001", "customer_service")
rbac.assign_user_role("content_manager", "content_admin")
rbac.assign_user_role("hr_employee", "hr_staff")
```

### 场景2：多租户 SaaS 服务

```python
class MultiTenantRAGRBAC:
    def __init__(self):
        connections.connect(
            alias="admin",
            user="admin",
            password="AdminPass123!"
        )

    def create_tenant_role(self, tenant_id):
        """为租户创建专属角色"""
        role_name = f"tenant_{tenant_id}"

        # 创建角色
        utility.create_role(role_name)

        # 授予权限（只能访问自己的 Collection）
        collection_name = f"tenant_{tenant_id}_docs"

        for privilege in ["Search", "Query", "Insert", "Delete"]:
            utility.grant_privilege(
                role_name=role_name,
                object_type="Collection",
                privilege=privilege,
                object_name=collection_name
            )

        print(f"✅ 租户 {tenant_id} 的角色已创建")

    def assign_tenant_user(self, user_id, tenant_id):
        """将用户分配到租户"""
        role_name = f"tenant_{tenant_id}"
        utility.add_user_to_role(user_id, role_name)
        print(f"✅ 用户 {user_id} 已加入租户 {tenant_id}")

# 使用
rbac = MultiTenantRAGRBAC()

# 创建租户角色
rbac.create_tenant_role("tenant_a")
rbac.create_tenant_role("tenant_b")

# 分配用户
rbac.assign_tenant_user("user_001", "tenant_a")
rbac.assign_tenant_user("user_002", "tenant_b")

# 结果：
# user_001 只能访问 tenant_a_docs
# user_002 只能访问 tenant_b_docs
```

### 场景3：分级权限管理

```python
class HierarchicalRAGRBAC:
    """分级权限管理"""

    def setup_hierarchical_roles(self):
        """设置分级角色"""
        # Level 1：访客（最低权限）
        utility.create_role("guest")
        utility.grant_privilege(
            role_name="guest",
            object_type="Collection",
            privilege="Search",
            object_name="public_docs"  # 只能访问公开文档
        )

        # Level 2：员工（中等权限）
        utility.create_role("employee")
        for collection in ["public_docs", "internal_docs"]:
            utility.grant_privilege(
                role_name="employee",
                object_type="Collection",
                privilege="Search",
                object_name=collection
            )

        # Level 3：经理（高权限）
        utility.create_role("manager")
        for collection in ["public_docs", "internal_docs", "confidential_docs"]:
            for privilege in ["Search", "Query", "Insert"]:
                utility.grant_privilege(
                    role_name="manager",
                    object_type="Collection",
                    privilege=privilege,
                    object_name=collection
                )

        # Level 4：高管（最高权限）
        utility.create_role("executive")
        utility.grant_privilege(
            role_name="executive",
            object_type="Collection",
            privilege="*",  # 所有权限
            object_name="*"  # 所有 Collection
        )

# 使用
rbac = HierarchicalRAGRBAC()
rbac.setup_hierarchical_roles()

# 分配角色
utility.add_user_to_role("visitor_001", "guest")
utility.add_user_to_role("emp_001", "employee")
utility.add_user_to_role("mgr_001", "manager")
utility.add_user_to_role("ceo", "executive")
```

---

## 权限审计

### 审计用户权限

```python
def audit_user_permissions(username):
    """审计用户权限"""
    print(f"\n=== 用户 {username} 的权限审计 ===")

    # 1. 查询用户角色
    roles = utility.list_roles(username)
    print(f"角色：{roles}")

    # 2. 查询每个角色的权限
    for role in roles:
        privileges = utility.list_privileges(role)
        print(f"\n角色 {role} 的权限：")
        for priv in privileges:
            print(f"  - {priv}")

# 使用
audit_user_permissions("analyst")

# 输出示例：
# === 用户 analyst 的权限审计 ===
# 角色：['readonly']
#
# 角色 readonly 的权限：
#   - Search on Collection: *
#   - Query on Collection: *
#   - DescribeCollection on Collection: *
```

### 定期权限审查

```python
import logging
from datetime import datetime

class PermissionAuditor:
    def __init__(self):
        self.logger = logging.getLogger("permission_auditor")

    def audit_all_users(self):
        """审计所有用户"""
        users = utility.list_users()

        audit_report = {
            "timestamp": datetime.now(),
            "total_users": len(users),
            "users": []
        }

        for user in users:
            roles = utility.list_roles(user)
            audit_report["users"].append({
                "username": user,
                "roles": roles,
                "role_count": len(roles)
            })

        self.logger.info(f"权限审计报告：{audit_report}")
        return audit_report

    def find_over_privileged_users(self):
        """查找权限过大的用户"""
        users = utility.list_users()
        over_privileged = []

        for user in users:
            roles = utility.list_roles(user)
            if "admin" in roles or "system_admin" in roles:
                over_privileged.append(user)

        self.logger.warning(f"⚠️ 发现 {len(over_privileged)} 个高权限用户：{over_privileged}")
        return over_privileged

# 使用
auditor = PermissionAuditor()
auditor.audit_all_users()
auditor.find_over_privileged_users()
```

---

## 小结

**授权机制（RBAC）的核心要点：**

1. **定义**：控制用户权限，确保"你能做什么"
2. **RBAC 模型**：用户 → 角色 → 权限 → 资源
3. **权限类型**：Collection、数据操作、索引、Partition、用户、角色
4. **常见角色**：只读用户、数据管理员、系统管理员、部门角色
5. **最小权限原则**：只给必需的权限，不多给
6. **RAG 应用**：企业知识库、多租户 SaaS、分级权限
7. **权限审计**：定期审查用户权限，发现过度授权

**下一步：** 学习数据加密（TLS）的详细实现
