# 实战代码：综合应用

> AI Agent API 完整示例，整合路由、依赖注入、响应模型

---

## 完整的 AI Agent 对话 API

**目标：** 构建一个生产级的 AI Agent 对话 API

**功能：**
- JWT 认证授权
- 数据库连接管理
- 对话历史管理
- LLM 集成
- 流式响应
- 错误处理

```python
"""
AI Agent 对话 API - 完整示例
演示：整合路由、依赖注入、响应模型的完整应用
"""

from fastapi import FastAPI, Depends, HTTPException, status, Header
from fastapi.responses import StreamingResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime, Boolean, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session, relationship
from pydantic import BaseModel, Field, EmailStr
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta
from typing import List, Optional
import asyncio
import os
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

# ===== 配置 =====

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./ai_agent.db")
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# ===== 数据库设置 =====

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in DATABASE_URL else {}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ===== 数据库模型 =====

class UserDB(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    conversations = relationship("ConversationDB", back_populates="user")

class ConversationDB(Base):
    __tablename__ = "conversations"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    title = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    user = relationship("UserDB", back_populates="conversations")
    messages = relationship("MessageDB", back_populates="conversation")

class MessageDB(Base):
    __tablename__ = "messages"

    id = Column(Integer, primary_key=True, index=True)
    conversation_id = Column(Integer, ForeignKey("conversations.id"))
    role = Column(String)  # user, assistant, system
    content = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)

    conversation = relationship("ConversationDB", back_populates="messages")

# 创建表
Base.metadata.create_all(bind=engine)

# ===== Pydantic 模型 =====

# 用户相关
class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(..., min_length=8)

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

class LoginRequest(BaseModel):
    username: str
    password: str

# 对话相关
class MessageCreate(BaseModel):
    content: str = Field(..., min_length=1, max_length=2000)

class MessageResponse(BaseModel):
    id: int
    role: str
    content: str
    created_at: datetime

    class Config:
        from_attributes = True

class ChatRequest(BaseModel):
    message: str = Field(..., min_length=1, max_length=2000)
    conversation_id: Optional[int] = None
    stream: bool = False

class ChatResponse(BaseModel):
    reply: str
    conversation_id: int
    message_id: int
    created_at: datetime

class ConversationSummary(BaseModel):
    id: int
    title: str
    message_count: int
    created_at: datetime
    updated_at: datetime

class ConversationDetail(BaseModel):
    id: int
    title: str
    messages: List[MessageResponse]
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

# ===== 密码加密 =====

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

# ===== JWT 工具 =====

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# ===== 依赖注入 =====

# 依赖1：数据库连接
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 依赖2：认证
security = HTTPBearer()

def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> UserDB:
    token = credentials.credentials

    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="无效的认证凭证",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user = db.query(UserDB).filter(UserDB.username == username).first()
    if user is None:
        raise credentials_exception

    return user

# 依赖3：检查用户激活状态
def get_current_active_user(
    current_user: UserDB = Depends(get_current_user)
) -> UserDB:
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="用户未激活")
    return current_user

# 依赖4：LLM 客户端（模拟）
class LLMClient:
    """模拟 LLM 客户端"""

    async def generate(self, messages: List[dict]) -> str:
        """生成回复"""
        # 模拟 LLM 调用
        await asyncio.sleep(0.5)
        last_message = messages[-1]["content"]
        return f"这是对 '{last_message}' 的智能回复。"

    async def generate_stream(self, messages: List[dict]):
        """流式生成回复"""
        # 模拟流式输出
        response = f"这是对 '{messages[-1]['content']}' 的流式回复。"
        for word in response.split():
            yield word + " "
            await asyncio.sleep(0.1)

def get_llm_client() -> LLMClient:
    return LLMClient()

# ===== FastAPI 应用 =====

app = FastAPI(
    title="AI Agent 对话 API",
    description="完整的 AI Agent 对话系统",
    version="1.0.0"
)

# ===== 认证路由 =====

@app.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def register(user: UserCreate, db: Session = Depends(get_db)):
    """用户注册"""
    # 检查用户名是否已存在
    existing_user = db.query(UserDB).filter(UserDB.username == user.username).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="用户名已存在")

    # 检查邮箱是否已存在
    existing_email = db.query(UserDB).filter(UserDB.email == user.email).first()
    if existing_email:
        raise HTTPException(status_code=400, detail="邮箱已被注册")

    # 创建用户
    db_user = UserDB(
        username=user.username,
        email=user.email,
        hashed_password=get_password_hash(user.password)
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)

    return db_user

@app.post("/login", response_model=Token)
async def login(login_data: LoginRequest, db: Session = Depends(get_db)):
    """用户登录"""
    user = db.query(UserDB).filter(UserDB.username == login_data.username).first()
    if not user or not verify_password(login_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误"
        )

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username},
        expires_delta=access_token_expires
    )

    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/profile", response_model=UserResponse)
async def get_profile(current_user: UserDB = Depends(get_current_active_user)):
    """获取当前用户信息"""
    return current_user

# ===== 对话路由 =====

@app.post("/chat", response_model=ChatResponse)
async def chat(
    request: ChatRequest,
    current_user: UserDB = Depends(get_current_active_user),
    db: Session = Depends(get_db),
    llm: LLMClient = Depends(get_llm_client)
):
    """对话接口（非流式）"""
    # 获取或创建对话
    if request.conversation_id:
        conversation = db.query(ConversationDB).filter(
            ConversationDB.id == request.conversation_id,
            ConversationDB.user_id == current_user.id
        ).first()
        if not conversation:
            raise HTTPException(status_code=404, detail="对话不存在")
    else:
        # 创建新对话
        conversation = ConversationDB(
            user_id=current_user.id,
            title=request.message[:50]  # 使用前50个字符作为标题
        )
        db.add(conversation)
        db.commit()
        db.refresh(conversation)

    # 保存用户消息
    user_message = MessageDB(
        conversation_id=conversation.id,
        role="user",
        content=request.message
    )
    db.add(user_message)
    db.commit()

    # 获取对话历史
    messages = db.query(MessageDB).filter(
        MessageDB.conversation_id == conversation.id
    ).order_by(MessageDB.created_at).all()

    # 构建 LLM 消息列表
    llm_messages = [
        {"role": msg.role, "content": msg.content}
        for msg in messages
    ]

    # 调用 LLM
    reply = await llm.generate(llm_messages)

    # 保存 AI 回复
    assistant_message = MessageDB(
        conversation_id=conversation.id,
        role="assistant",
        content=reply
    )
    db.add(assistant_message)
    db.commit()
    db.refresh(assistant_message)

    # 更新对话时间
    conversation.updated_at = datetime.utcnow()
    db.commit()

    return ChatResponse(
        reply=reply,
        conversation_id=conversation.id,
        message_id=assistant_message.id,
        created_at=assistant_message.created_at
    )

@app.post("/chat/stream")
async def chat_stream(
    request: ChatRequest,
    current_user: UserDB = Depends(get_current_active_user),
    db: Session = Depends(get_db),
    llm: LLMClient = Depends(get_llm_client)
):
    """对话接口（流式）"""
    # 获取或创建对话
    if request.conversation_id:
        conversation = db.query(ConversationDB).filter(
            ConversationDB.id == request.conversation_id,
            ConversationDB.user_id == current_user.id
        ).first()
        if not conversation:
            raise HTTPException(status_code=404, detail="对话不存在")
    else:
        conversation = ConversationDB(
            user_id=current_user.id,
            title=request.message[:50]
        )
        db.add(conversation)
        db.commit()
        db.refresh(conversation)

    # 保存用户消息
    user_message = MessageDB(
        conversation_id=conversation.id,
        role="user",
        content=request.message
    )
    db.add(user_message)
    db.commit()

    # 获取对话历史
    messages = db.query(MessageDB).filter(
        MessageDB.conversation_id == conversation.id
    ).order_by(MessageDB.created_at).all()

    llm_messages = [
        {"role": msg.role, "content": msg.content}
        for msg in messages
    ]

    # 流式生成
    async def generate():
        full_reply = ""
        async for chunk in llm.generate_stream(llm_messages):
            full_reply += chunk
            yield f"data: {chunk}\n\n"

        # 保存完整回复
        assistant_message = MessageDB(
            conversation_id=conversation.id,
            role="assistant",
            content=full_reply
        )
        db.add(assistant_message)
        db.commit()

        yield f"data: [DONE]\n\n"

    return StreamingResponse(generate(), media_type="text/event-stream")

# ===== 对话管理路由 =====

@app.get("/conversations", response_model=List[ConversationSummary])
async def list_conversations(
    current_user: UserDB = Depends(get_current_active_user),
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 20
):
    """获取对话列表"""
    conversations = db.query(ConversationDB).filter(
        ConversationDB.user_id == current_user.id
    ).order_by(ConversationDB.updated_at.desc()).offset(skip).limit(limit).all()

    return [
        ConversationSummary(
            id=conv.id,
            title=conv.title,
            message_count=len(conv.messages),
            created_at=conv.created_at,
            updated_at=conv.updated_at
        )
        for conv in conversations
    ]

@app.get("/conversations/{conversation_id}", response_model=ConversationDetail)
async def get_conversation(
    conversation_id: int,
    current_user: UserDB = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """获取对话详情"""
    conversation = db.query(ConversationDB).filter(
        ConversationDB.id == conversation_id,
        ConversationDB.user_id == current_user.id
    ).first()

    if not conversation:
        raise HTTPException(status_code=404, detail="对话不存在")

    return conversation

@app.delete("/conversations/{conversation_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_conversation(
    conversation_id: int,
    current_user: UserDB = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """删除对话"""
    conversation = db.query(ConversationDB).filter(
        ConversationDB.id == conversation_id,
        ConversationDB.user_id == current_user.id
    ).first()

    if not conversation:
        raise HTTPException(status_code=404, detail="对话不存在")

    db.delete(conversation)
    db.commit()
    return None

# ===== 健康检查 =====

@app.get("/health")
async def health_check():
    """健康检查"""
    return {"status": "ok", "timestamp": datetime.utcnow()}

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 环境配置

**创建 .env 文件：**

```bash
# .env
DATABASE_URL=sqlite:///./ai_agent.db
SECRET_KEY=your-secret-key-change-in-production
OPENAI_API_KEY=your-openai-api-key
```

**安装依赖：**

```bash
uv add fastapi uvicorn sqlalchemy pydantic python-jose[cryptography] passlib[bcrypt] python-dotenv
```

---

## 完整测试流程

```bash
# 1. 运行服务器
python 12_实战代码_综合应用.py

# 2. 注册用户
curl -X POST http://localhost:8000/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "alice",
    "email": "alice@example.com",
    "password": "secret123"
  }'

# 3. 登录获取 token
TOKEN=$(curl -X POST http://localhost:8000/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "alice",
    "password": "secret123"
  }' | jq -r '.access_token')

# 4. 获取用户信息
curl http://localhost:8000/profile \
  -H "Authorization: Bearer $TOKEN"

# 5. 创建对话
curl -X POST http://localhost:8000/chat \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "message": "什么是 FastAPI？"
  }'

# 6. 继续对话
curl -X POST http://localhost:8000/chat \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "message": "它有什么优势？",
    "conversation_id": 1
  }'

# 7. 获取对话列表
curl http://localhost:8000/conversations \
  -H "Authorization: Bearer $TOKEN"

# 8. 获取对话详情
curl http://localhost:8000/conversations/1 \
  -H "Authorization: Bearer $TOKEN"

# 9. 流式对话
curl -X POST http://localhost:8000/chat/stream \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "message": "解释一下依赖注入",
    "conversation_id": 1
  }'

# 10. 删除对话
curl -X DELETE http://localhost:8000/conversations/1 \
  -H "Authorization: Bearer $TOKEN"

# 11. 健康检查
curl http://localhost:8000/health
```

---

## 项目结构建议

```
ai-agent-api/
├── app/
│   ├── __init__.py
│   ├── main.py                 # 主应用
│   ├── config.py               # 配置
│   ├── database.py             # 数据库设置
│   ├── models/
│   │   ├── __init__.py
│   │   ├── user.py             # 用户模型
│   │   ├── conversation.py     # 对话模型
│   │   └── message.py          # 消息模型
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── user.py             # 用户 Pydantic 模型
│   │   ├── conversation.py     # 对话 Pydantic 模型
│   │   └── message.py          # 消息 Pydantic 模型
│   ├── api/
│   │   ├── __init__.py
│   │   ├── auth.py             # 认证路由
│   │   ├── chat.py             # 对话路由
│   │   └── conversations.py    # 对话管理路由
│   ├── core/
│   │   ├── __init__.py
│   │   ├── security.py         # 安全相关（JWT、密码）
│   │   └── deps.py             # 依赖注入
│   └── services/
│       ├── __init__.py
│       └── llm.py              # LLM 服务
├── .env                        # 环境变量
├── .env.example                # 环境变量示例
├── pyproject.toml              # 项目配置
└── README.md                   # 项目文档
```

---

## 关键设计模式

### 1. 依赖注入层级

```
get_db() → 数据库连接
    ↓
get_current_user(db) → 当前用户
    ↓
get_current_active_user(user) → 激活用户
    ↓
路由函数(active_user, db, llm)
```

### 2. 数据模型分离

- **数据库模型**（UserDB）：SQLAlchemy ORM 模型
- **请求模型**（UserCreate）：接收客户端数据
- **响应模型**（UserResponse）：返回给客户端

### 3. 资源管理

```python
def get_db():
    db = SessionLocal()
    try:
        yield db  # 注入到路由
    finally:
        db.close()  # 自动关闭
```

### 4. 错误处理

```python
if not user:
    raise HTTPException(
        status_code=404,
        detail="用户不存在"
    )
```

---

## 扩展功能

### 1. 添加 Redis 缓存

```python
from redis import Redis

def get_redis():
    redis = Redis(host='localhost', port=6379, db=0)
    try:
        yield redis
    finally:
        redis.close()

@app.get("/conversations/{conversation_id}")
async def get_conversation(
    conversation_id: int,
    redis: Redis = Depends(get_redis),
    db: Session = Depends(get_db)
):
    # 先从缓存获取
    cached = redis.get(f"conversation:{conversation_id}")
    if cached:
        return json.loads(cached)

    # 从数据库获取
    conversation = db.query(ConversationDB).get(conversation_id)

    # 缓存结果
    redis.setex(
        f"conversation:{conversation_id}",
        3600,  # 1小时
        json.dumps(conversation)
    )

    return conversation
```

### 2. 添加限流

```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

@app.post("/chat")
@limiter.limit("10/minute")
async def chat(request: Request, ...):
    ...
```

### 3. 添加日志

```python
import structlog

logger = structlog.get_logger()

@app.post("/chat")
async def chat(...):
    logger.info("chat_request", user_id=current_user.id, message=request.message)
    ...
    logger.info("chat_response", conversation_id=conversation.id)
```

---

## 总结

### 核心技术栈

- **FastAPI** - Web 框架
- **SQLAlchemy** - ORM
- **Pydantic** - 数据验证
- **JWT** - 认证
- **bcrypt** - 密码加密

### 关键特性

1. **完整的认证流程** - 注册、登录、JWT
2. **数据库集成** - SQLAlchemy ORM
3. **依赖注入** - 数据库、认证、LLM
4. **响应模型** - 自动过滤敏感信息
5. **流式响应** - Server-Sent Events
6. **错误处理** - 统一错误格式

### 生产环境建议

1. **使用 PostgreSQL** 替代 SQLite
2. **添加 Redis 缓存** 提升性能
3. **添加限流** 防止滥用
4. **添加日志** 便于调试
5. **使用 Docker** 容器化部署
6. **添加监控** 如 Prometheus
7. **使用 HTTPS** 保护数据传输

---

**记住：** 这是一个完整的生产级示例，展示了如何整合 FastAPI 的所有核心特性！
