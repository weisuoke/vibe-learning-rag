# 最小可用知识

> **20% 核心知识解决 80% 使用场景**

## 学习目标

掌握以下内容，你就能开始注册自定义工具，扩展 AI Agent 的能力：

1. **Tool Definition 基本结构** - 工具的"身份证"
2. **TypeBox Schema 定义** - 参数的"类型检查器"
3. **execute 函数实现** - 工具的"执行引擎"
4. **registerTool API 调用** - 工具的"注册中心"

---

## 1. Tool Definition 基本结构

### 核心概念

Tool Definition 是工具的完整描述，包含 4 个必需字段：

```typescript
interface ToolDefinition {
  name: string;              // 工具名称（唯一标识）
  description: string;       // 工具描述（给 LLM 看的）
  parameters: TSchema;       // 参数 Schema（TypeBox 定义）
  execute: ExecuteFunction;  // 执行函数（实际逻辑）
}
```

### 最小示例

```typescript
import { Type } from '@sinclair/typebox';

const helloTool = {
  name: 'hello',
  description: 'Say hello to someone',
  parameters: Type.Object({
    name: Type.String({ description: 'Name of the person' })
  }),
  execute: async ({ name }) => {
    return { content: `Hello, ${name}!` };
  }
};
```

### 关键要点

- **name**: 必须唯一，建议使用 kebab-case（如 `get-weather`）
- **description**: 清晰描述工具用途，LLM 根据这个决定是否调用
- **parameters**: 使用 TypeBox 定义，提供类型安全和运行时验证
- **execute**: 异步函数，返回 `AgentToolResult`

---

## 2. TypeBox Schema 定义

### 为什么用 TypeBox？

TypeBox 是 pi-mono 选择的 Schema 库，提供：
- **类型安全**: TypeScript 类型推导
- **运行时验证**: 自动参数校验
- **JSON Schema**: LLM 可理解的格式

### 常用类型

```typescript
import { Type } from '@sinclair/typebox';

// 字符串
Type.String({ description: 'User name' })

// 数字
Type.Number({ description: 'Age', minimum: 0 })

// 布尔值
Type.Boolean({ description: 'Is active' })

// 枚举
Type.Union([
  Type.Literal('red'),
  Type.Literal('green'),
  Type.Literal('blue')
], { description: 'Color choice' })

// 数组
Type.Array(Type.String(), { description: 'List of tags' })

// 对象
Type.Object({
  name: Type.String(),
  age: Type.Number()
})

// 可选字段
Type.Object({
  name: Type.String(),
  email: Type.Optional(Type.String())
})
```

### 实战示例

```typescript
// 文件搜索工具的参数
const searchParams = Type.Object({
  query: Type.String({
    description: 'Search query'
  }),
  fileType: Type.Optional(Type.Union([
    Type.Literal('js'),
    Type.Literal('ts'),
    Type.Literal('json')
  ], {
    description: 'File type filter'
  })),
  maxResults: Type.Optional(Type.Number({
    description: 'Maximum results',
    default: 10,
    minimum: 1,
    maximum: 100
  }))
});
```

### 关键要点

- **description 必填**: 每个字段都要有描述，帮助 LLM 理解
- **Optional 包装**: 可选字段用 `Type.Optional()` 包装
- **default 值**: 可选字段可以设置默认值
- **约束条件**: 使用 `minimum`, `maximum`, `pattern` 等约束

---

## 3. execute 函数实现

### 函数签名

```typescript
type ExecuteFunction = (
  params: any,                    // 工具参数（已验证）
  context: ExtensionContext       // 执行上下文
) => Promise<AgentToolResult>;    // 返回结果
```

### AgentToolResult 结构

```typescript
interface AgentToolResult {
  content: string;           // 主要内容（必需）
  metadata?: {               // 元数据（可选）
    [key: string]: any;
  };
}
```

### 最小示例

```typescript
const execute = async (params: { name: string }) => {
  // 1. 执行逻辑
  const greeting = `Hello, ${params.name}!`;

  // 2. 返回结果
  return {
    content: greeting
  };
};
```

### 带错误处理的示例

```typescript
const execute = async (
  params: { filePath: string },
  context: ExtensionContext
) => {
  try {
    // 1. 执行逻辑
    const content = await fs.readFile(params.filePath, 'utf-8');

    // 2. 返回成功结果
    return {
      content: content,
      metadata: {
        fileSize: content.length,
        timestamp: new Date().toISOString()
      }
    };
  } catch (error) {
    // 3. 返回错误信息
    return {
      content: `Error reading file: ${error.message}`
    };
  }
};
```

### 使用 ExtensionContext

```typescript
const execute = async (
  params: { message: string },
  context: ExtensionContext
) => {
  // 访问 session 状态
  const history = context.session.get('messageHistory') || [];
  history.push(params.message);
  context.session.set('messageHistory', history);

  // 访问 logger
  context.logger.info(`Received message: ${params.message}`);

  return {
    content: `Message saved. Total: ${history.length}`
  };
};
```

### 关键要点

- **必须是 async**: 即使不需要异步操作，也要声明为 async
- **参数已验证**: TypeBox 已经验证过参数，可以直接使用
- **错误处理**: 用 try-catch 捕获错误，返回友好的错误信息
- **context 使用**: 通过 context 访问 session、logger 等

---

## 4. registerTool API 调用

### API 签名

```typescript
function registerTool(
  context: ExtensionContext,
  tool: ToolDefinition
): void
```

### 在 Extension 中注册

```typescript
import { Type } from '@sinclair/typebox';
import type { Extension } from '@pi-mono/coding-agent';

export const myExtension: Extension = {
  name: 'my-extension',
  version: '1.0.0',

  async activate(context) {
    // 注册工具
    context.registerTool({
      name: 'hello',
      description: 'Say hello to someone',
      parameters: Type.Object({
        name: Type.String({ description: 'Name of the person' })
      }),
      execute: async ({ name }) => {
        return { content: `Hello, ${name}!` };
      }
    });

    context.logger.info('Hello tool registered');
  }
};
```

### 注册多个工具

```typescript
export const myExtension: Extension = {
  name: 'my-extension',
  version: '1.0.0',

  async activate(context) {
    // 工具 1: Hello
    context.registerTool({
      name: 'hello',
      description: 'Say hello',
      parameters: Type.Object({
        name: Type.String()
      }),
      execute: async ({ name }) => {
        return { content: `Hello, ${name}!` };
      }
    });

    // 工具 2: Goodbye
    context.registerTool({
      name: 'goodbye',
      description: 'Say goodbye',
      parameters: Type.Object({
        name: Type.String()
      }),
      execute: async ({ name }) => {
        return { content: `Goodbye, ${name}!` };
      }
    });

    context.logger.info('2 tools registered');
  }
};
```

### 关键要点

- **在 activate 中注册**: Extension 激活时注册工具
- **使用 context.registerTool**: 不要直接操作工具列表
- **注册顺序无关**: 工具之间没有依赖关系
- **重复注册会覆盖**: 同名工具会被覆盖（不会报错）

---

## 完整最小示例

### 场景：天气查询工具

```typescript
import { Type } from '@sinclair/typebox';
import type { Extension } from '@pi-mono/coding-agent';

// 模拟天气 API
async function fetchWeather(city: string): Promise<string> {
  // 实际应用中这里会调用真实的天气 API
  const weatherData = {
    'Beijing': '晴天 25°C',
    'Shanghai': '多云 28°C',
    'Guangzhou': '雨天 30°C'
  };
  return weatherData[city] || '未知城市';
}

export const weatherExtension: Extension = {
  name: 'weather-extension',
  version: '1.0.0',

  async activate(context) {
    context.registerTool({
      // 1. 工具名称
      name: 'get-weather',

      // 2. 工具描述
      description: 'Get current weather for a city',

      // 3. 参数 Schema
      parameters: Type.Object({
        city: Type.String({
          description: 'City name (e.g., Beijing, Shanghai)'
        })
      }),

      // 4. 执行函数
      execute: async ({ city }, ctx) => {
        try {
          // 记录日志
          ctx.logger.info(`Fetching weather for ${city}`);

          // 获取天气
          const weather = await fetchWeather(city);

          // 返回结果
          return {
            content: `Weather in ${city}: ${weather}`,
            metadata: {
              city,
              timestamp: new Date().toISOString()
            }
          };
        } catch (error) {
          return {
            content: `Failed to get weather: ${error.message}`
          };
        }
      }
    });

    context.logger.info('Weather tool registered');
  }
};
```

### 使用方式

1. **安装 Extension**:
   ```bash
   # 将 Extension 放到 extensions 目录
   cp weather-extension.ts ~/.pi-mono/extensions/
   ```

2. **重新加载**:
   ```bash
   # 在 pi-mono CLI 中
   /reload
   ```

3. **调用工具**:
   ```
   用户: 北京今天天气怎么样？
   AI: [调用 get-weather 工具]
   结果: Weather in Beijing: 晴天 25°C
   ```

---

## 快速检查清单

在注册自定义工具前，确保：

- [ ] **name** 唯一且符合命名规范（kebab-case）
- [ ] **description** 清晰描述工具用途
- [ ] **parameters** 使用 TypeBox 定义，每个字段都有 description
- [ ] **execute** 是 async 函数
- [ ] **execute** 返回 `{ content: string }` 结构
- [ ] **错误处理** 用 try-catch 包裹
- [ ] **在 Extension 的 activate 中注册**
- [ ] **使用 context.registerTool** 注册

---

## 常见问题

### Q1: 工具注册后为什么不生效？

**A**: 可能原因：
1. Extension 没有加载（检查 `~/.pi-mono/extensions/` 目录）
2. 没有执行 `/reload` 重新加载
3. 工具名称冲突（被其他工具覆盖）

### Q2: 如何调试工具执行？

**A**: 使用 `context.logger`:
```typescript
execute: async (params, context) => {
  context.logger.info('Tool called with params:', params);
  // ... 执行逻辑
  context.logger.info('Tool result:', result);
  return result;
}
```

### Q3: 参数验证失败会怎样？

**A**: TypeBox 会自动验证参数，如果验证失败：
- 工具不会被调用
- LLM 会收到错误信息
- 可以在 execute 中添加额外的业务逻辑验证

### Q4: 可以注册异步工具吗？

**A**: 所有工具都必须是异步的（async 函数），这是设计要求。

---

## 下一步学习

掌握了最小可用知识后，可以深入学习：

1. **自定义渲染** - 美化工具调用和结果显示
2. **事件系统** - 监听和拦截工具调用
3. **状态管理** - 使用 session 存储状态
4. **性能优化** - 输出截断、流式更新
5. **OAuth 集成** - 集成第三方 API

---

## 总结

**最小可用 = 4 个核心要素**

1. **Tool Definition**: name + description + parameters + execute
2. **TypeBox Schema**: 类型安全的参数定义
3. **execute 函数**: async + 返回 AgentToolResult
4. **registerTool**: 在 Extension 的 activate 中注册

掌握这 4 个要素，你就能开始扩展 AI Agent 的能力了！
