# 反直觉点

> 路由与依赖注入的3个常见误区

---

## 误区1：依赖注入很复杂，不如直接用全局变量 ❌

### 为什么错？

**错误观点：**
```python
# "依赖注入太复杂了，直接用全局变量多简单"
db_connection = create_db_connection()

@app.get("/users")
async def get_users():
    users = db_connection.query(User).all()
    return users
```

**正确理解：**
```python
# 依赖注入更简单、更安全、更易测试
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users")
async def get_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users
```

**为什么依赖注入更好？**

1. **自动资源管理** - 请求结束后自动关闭连接
   ```python
   # 全局变量：需要手动管理
   db_connection = create_db_connection()
   try:
       users = db_connection.query(User).all()
   finally:
       db_connection.close()  # 容易忘记

   # 依赖注入：自动管理
   def get_db():
       db = SessionLocal()
       try:
           yield db
       finally:
           db.close()  # 自动执行
   ```

2. **易于测试** - 可以轻松替换依赖
   ```python
   # 测试时替换依赖
   def get_test_db():
       return MockDatabase()

   app.dependency_overrides[get_db] = get_test_db
   ```

3. **避免并发问题** - 每个请求独立的连接
   ```python
   # 全局变量：多个请求共享同一个连接（危险！）
   db_connection = create_db_connection()

   # 依赖注入：每个请求独立的连接（安全）
   def get_db():
       db = SessionLocal()  # 每次调用创建新连接
       yield db
   ```

### 为什么人们容易这样错？

**心理原因：**
- 全局变量看起来更"直接"，代码更少
- 不理解依赖注入的价值（资源管理、测试、并发安全）
- 从其他语言（如 PHP、JavaScript）转过来，习惯用全局变量

**日常类比：**
- ❌ 全局变量 = 全公司共用一支笔（抢着用，容易丢）
- ✅ 依赖注入 = 每个人需要时领一支笔，用完归还（有序管理）

---

## 误区2：路径参数和查询参数是一样的 ❌

### 为什么错？

**错误观点：**
```python
# "路径参数和查询参数都是传参数，没区别"
@app.get("/users/{user_id}")  # 路径参数
async def get_user(user_id: int):
    pass

@app.get("/users")  # 查询参数
async def get_user(user_id: int):  # ❌ 这样写是查询参数
    pass
```

**正确理解：**

| 特性 | 路径参数 | 查询参数 |
|------|----------|----------|
| **语法** | `/users/{user_id}` | `/users?user_id=1` |
| **必需性** | 必需（路径的一部分） | 可选（可以有默认值） |
| **语义** | 标识资源 | 过滤/配置资源 |
| **RESTful** | 资源定位 | 资源筛选 |
| **示例** | `/users/123` | `/users?role=admin&limit=10` |

**实际应用：**

```python
# 路径参数：标识具体资源（必需）
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    # GET /users/123
    return {"user_id": user_id}

# 查询参数：过滤/配置（可选）
@app.get("/users")
async def list_users(
    role: str = None,      # 可选：按角色过滤
    limit: int = 10,       # 可选：限制数量
    offset: int = 0        # 可选：分页偏移
):
    # GET /users?role=admin&limit=20&offset=0
    return {"role": role, "limit": limit, "offset": offset}

# 混合使用：路径参数 + 查询参数
@app.get("/users/{user_id}/posts")
async def get_user_posts(
    user_id: int,          # 路径参数：用户ID（必需）
    status: str = "published",  # 查询参数：文章状态（可选）
    limit: int = 10        # 查询参数：数量限制（可选）
):
    # GET /users/123/posts?status=draft&limit=5
    return {"user_id": user_id, "status": status, "limit": limit}
```

**RESTful 设计原则：**

```python
# ✅ 好的设计
GET /users/123              # 获取用户123
GET /users?role=admin       # 获取管理员用户列表
GET /users/123/posts        # 获取用户123的文章
GET /posts?author_id=123    # 获取作者123的文章

# ❌ 不好的设计
GET /users?user_id=123      # 应该用路径参数
GET /get_user_by_id/123     # 不符合 RESTful 风格
```

### 为什么人们容易这样错？

**心理原因：**
- 两者都是"传参数"，表面上看起来一样
- 不理解 RESTful API 的设计原则
- 从 Express 转过来，习惯用 `req.params` 和 `req.query`

**前端类比：**
```javascript
// Express
app.get('/users/:userId', (req, res) => {
  const userId = req.params.userId  // 路径参数
})

app.get('/users', (req, res) => {
  const role = req.query.role  // 查询参数
})

// FastAPI - 自动区分
@app.get("/users/{user_id}")
async def get_user(user_id: int):  # 路径参数
    pass

@app.get("/users")
async def list_users(role: str = None):  # 查询参数
    pass
```

**日常类比：**
- 路径参数 = 门牌号（必需，唯一标识一个房子）
- 查询参数 = 筛选条件（可选，"找所有红色的房子"）

---

## 误区3：Depends() 会在每次请求时都执行 ❌

### 为什么错？

**错误观点：**
```python
# "Depends() 每次请求都会执行，性能很差"
def get_settings():
    print("加载配置...")  # 以为每次请求都会打印
    return Settings()

@app.get("/")
async def root(settings: Settings = Depends(get_settings)):
    return {"app_name": settings.app_name}
```

**正确理解：**

FastAPI 的依赖注入有**缓存机制**：

```python
from fastapi import Depends

def get_settings():
    print("加载配置...")  # 在同一个请求中只打印一次
    return Settings()

def get_db():
    print("创建数据库连接...")
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 同一个请求中，多次使用同一个依赖，只执行一次
@app.get("/")
async def root(
    settings1: Settings = Depends(get_settings),  # 第1次：执行
    settings2: Settings = Depends(get_settings),  # 第2次：使用缓存
):
    print(settings1 is settings2)  # True - 同一个对象
    return {"app_name": settings1.app_name}
```

**依赖缓存的作用域：**

```python
# 1. 同一个请求中，依赖被缓存
@app.get("/user-profile")
async def get_user_profile(
    db1: Session = Depends(get_db),  # 第1次：创建连接
    db2: Session = Depends(get_db),  # 第2次：使用缓存（同一个连接）
):
    print(db1 is db2)  # True
    return {"message": "ok"}

# 2. 不同请求之间，依赖不缓存
# 请求1：创建新的 db 连接
# 请求2：创建新的 db 连接（不是请求1的连接）
```

**依赖链中的缓存：**

```python
def get_db():
    print("创建数据库连接")
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def get_current_user(db: Session = Depends(get_db)):
    print("查询当前用户")
    return db.query(User).first()

def get_user_permissions(
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)  # 使用缓存的 db
):
    print("查询用户权限")
    return db.query(Permission).filter_by(user_id=user.id).all()

@app.get("/profile")
async def get_profile(
    user: User = Depends(get_current_user),
    permissions: list = Depends(get_user_permissions),
    db: Session = Depends(get_db)  # 使用缓存的 db
):
    # 整个请求中，get_db() 只执行一次
    # 输出：
    # 创建数据库连接
    # 查询当前用户
    # 查询用户权限
    return {"user": user, "permissions": permissions}
```

**禁用缓存（如果需要）：**

```python
from fastapi import Depends

def get_current_time():
    return datetime.now()

# 默认：缓存（同一个请求中返回相同时间）
@app.get("/time1")
async def time1(
    time1: datetime = Depends(get_current_time),
    time2: datetime = Depends(get_current_time),
):
    print(time1 == time2)  # True - 缓存
    return {"time1": time1, "time2": time2}

# 禁用缓存：use_cache=False
@app.get("/time2")
async def time2(
    time1: datetime = Depends(get_current_time, use_cache=False),
    time2: datetime = Depends(get_current_time, use_cache=False),
):
    print(time1 == time2)  # False - 不缓存
    return {"time1": time1, "time2": time2}
```

### 为什么人们容易这样错？

**心理原因：**
- 看到 `Depends()` 就以为每次都会执行
- 不理解 FastAPI 的依赖缓存机制
- 担心性能问题，过度优化

**前端类比：**
```javascript
// React useMemo - 缓存计算结果
const expensiveValue = useMemo(() => {
  console.log("计算...")  // 只在依赖变化时执行
  return computeExpensiveValue(a, b)
}, [a, b])

// FastAPI Depends - 缓存依赖结果
def get_settings():
    print("加载配置...")  # 同一个请求中只执行一次
    return Settings()
```

**日常类比：**
- 依赖缓存 = 一次性门票（进场时检查一次，之后不再检查）
- 无缓存 = 每次都检查门票（每个景点都要检查）

---

## 误区总结

| 误区 | 错误观点 | 正确理解 |
|------|----------|----------|
| **依赖注入** | 太复杂，不如全局变量 | 更安全、易测试、自动资源管理 |
| **参数类型** | 路径参数和查询参数一样 | 路径参数标识资源（必需），查询参数过滤资源（可选） |
| **依赖缓存** | 每次请求都执行 | 同一个请求中缓存，不同请求独立 |

---

## 避免误区的建议

1. **理解依赖注入的价值**
   - 不是为了"炫技"，而是为了更好的代码组织
   - 资源管理、测试、并发安全都是实际需求

2. **遵循 RESTful 设计原则**
   - 路径参数：标识资源（`/users/123`）
   - 查询参数：过滤资源（`/users?role=admin`）

3. **信任 FastAPI 的优化**
   - 依赖缓存是默认行为，不需要手动优化
   - 只在真正需要时才禁用缓存

---

## 实战检验

**测试依赖缓存：**

```python
from fastapi import FastAPI, Depends
from datetime import datetime

app = FastAPI()

def get_timestamp():
    timestamp = datetime.now()
    print(f"生成时间戳: {timestamp}")
    return timestamp

@app.get("/test-cache")
async def test_cache(
    ts1: datetime = Depends(get_timestamp),
    ts2: datetime = Depends(get_timestamp),
    ts3: datetime = Depends(get_timestamp),
):
    return {
        "ts1": ts1,
        "ts2": ts2,
        "ts3": ts3,
        "all_same": ts1 == ts2 == ts3  # True
    }

# 运行后访问 http://localhost:8000/test-cache
# 控制台只会打印一次 "生成时间戳"
```

**运行：**
```bash
uvicorn main:app --reload
curl http://localhost:8000/test-cache
```

**输出：**
```
生成时间戳: 2026-02-11 10:30:45.123456
{
  "ts1": "2026-02-11T10:30:45.123456",
  "ts2": "2026-02-11T10:30:45.123456",
  "ts3": "2026-02-11T10:30:45.123456",
  "all_same": true
}
```

---

**记住：** 理解这些反直觉点，可以避免90%的常见错误！
