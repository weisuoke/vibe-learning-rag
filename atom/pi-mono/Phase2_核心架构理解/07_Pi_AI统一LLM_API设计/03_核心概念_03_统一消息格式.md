# 核心概念3：统一消息格式

> 理解如何通过标准化的消息格式统一不同 LLM Provider 的数据结构

---

## 概念定义

**统一消息格式**是指定义一套标准的数据结构来表示对话上下文、消息内容和工具调用，使不同 Provider 的 API 可以无缝转换和互操作。

**核心价值：**
- **格式统一**：一套数据结构适配所有 Provider
- **类型安全**：TypeScript 类型检查防止错误
- **双向转换**：Pi AI 格式 ↔ Provider 格式
- **多模态支持**：统一处理文本、图片、工具调用

---

## 第一性原理

### 问题的本质

**核心问题：** 不同 Provider 的消息格式完全不同，如何统一？

**OpenAI 格式：**
```typescript
{
  role: 'user',
  content: 'Hello'  // 简单字符串
}

// 或多模态
{
  role: 'user',
  content: [
    { type: 'text', text: 'What is this?' },
    { type: 'image_url', image_url: { url: 'https://...' } }
  ]
}
```

**Anthropic 格式：**
```typescript
{
  role: 'user',
  content: [  // 总是数组
    { type: 'text', text: 'Hello' }
  ]
}

// 多模态
{
  role: 'user',
  content: [
    { type: 'text', text: 'What is this?' },
    { type: 'image', source: { type: 'url', url: 'https://...' } }
  ]
}
```

**Google 格式：**
```typescript
{
  role: 'user',  // 或 'model'
  parts: [  // 不叫 content
    { text: 'Hello' }
  ]
}

// 多模态
{
  role: 'user',
  parts: [
    { text: 'What is this?' },
    { inlineData: { mimeType: 'image/jpeg', data: '...' } }
  ]
}
```

### 设计原则

**1. 最大公约数原则**
- 找到所有 Provider 都支持的功能
- 作为统一格式的基础

**2. 可扩展性原则**
- 支持未来新的内容类型
- 支持 Provider 特有功能

**3. 类型安全原则**
- 使用 TypeScript 类型系统
- 编译时检查错误

**4. 向后兼容原则**
- 新版本不破坏旧代码
- 渐进式增强

---

## 核心实现

### 1. 统一消息格式定义

```typescript
/**
 * 对话上下文（Context）
 * 包含完整的对话历史和配置
 */
interface Context {
  /**
   * 系统提示（可选）
   * 定义 AI 的角色和行为
   */
  systemPrompt?: string;

  /**
   * 消息列表
   * 按时间顺序排列的对话历史
   */
  messages: Message[];

  /**
   * 可用工具（可选）
   * Agent 可以调用的工具列表
   */
  tools?: Tool[];

  /**
   * 温度参数（可选）
   * 控制输出的随机性，0.0-1.0
   */
  temperature?: number;

  /**
   * 最大 Token 数（可选）
   * 限制响应的长度
   */
  maxTokens?: number;

  /**
   * Top-P 采样（可选）
   * 核采样参数，0.0-1.0
   */
  topP?: number;

  /**
   * 停止序列（可选）
   * 遇到这些序列时停止生成
   */
  stopSequences?: string[];
}

/**
 * 消息（Message）
 * 单条对话消息
 */
interface Message {
  /**
   * 角色
   * - user: 用户消息
   * - assistant: AI 助手消息
   * - system: 系统消息（某些 Provider 支持）
   */
  role: 'user' | 'assistant' | 'system';

  /**
   * 内容
   * 可以是简单字符串或内容块数组（多模态）
   */
  content: string | ContentBlock[];

  /**
   * 工具调用（可选）
   * AI 请求调用的工具
   */
  toolCalls?: ToolCall[];

  /**
   * 工具结果（可选）
   * 工具执行的结果
   */
  toolResults?: ToolResult[];

  /**
   * 元数据（可选）
   * 额外的信息，如时间戳、ID 等
   */
  metadata?: {
    id?: string;
    timestamp?: number;
    [key: string]: any;
  };
}

/**
 * 内容块（ContentBlock）
 * 支持多模态内容
 */
type ContentBlock =
  | TextBlock
  | ImageBlock
  | ToolUseBlock
  | ToolResultBlock;

/**
 * 文本块
 */
interface TextBlock {
  type: 'text';
  text: string;
}

/**
 * 图片块
 */
interface ImageBlock {
  type: 'image';
  source: ImageSource;
}

/**
 * 图片来源
 */
type ImageSource =
  | { type: 'url'; url: string }
  | { type: 'base64'; mediaType: string; data: string };

/**
 * 工具使用块
 */
interface ToolUseBlock {
  type: 'tool_use';
  id: string;
  name: string;
  input: Record<string, any>;
}

/**
 * 工具结果块
 */
interface ToolResultBlock {
  type: 'tool_result';
  toolUseId: string;
  content: string | ContentBlock[];
  isError?: boolean;
}

/**
 * 工具调用
 */
interface ToolCall {
  id: string;
  name: string;
  input: Record<string, any>;
}

/**
 * 工具结果
 */
interface ToolResult {
  toolCallId: string;
  content: string;
  isError?: boolean;
}
```

### 2. 格式转换器实现

```typescript
/**
 * 消息格式转换器
 * 在 Pi AI 格式和 Provider 格式之间转换
 */
class MessageConverter {
  /**
   * 转换为 OpenAI 格式
   */
  toOpenAI(context: Context): OpenAI.ChatCompletionCreateParams {
    return {
      model: 'gpt-4o-mini',  // 由外部指定
      messages: [
        // 系统提示（如果有）
        ...(context.systemPrompt
          ? [{ role: 'system' as const, content: context.systemPrompt }]
          : []),
        // 用户和助手消息
        ...context.messages.map(msg => this.messageToOpenAI(msg))
      ],
      temperature: context.temperature,
      max_tokens: context.maxTokens,
      top_p: context.topP,
      stop: context.stopSequences,
      tools: context.tools?.map(tool => ({
        type: 'function' as const,
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.parameters
        }
      }))
    };
  }

  /**
   * 单条消息转换为 OpenAI 格式
   */
  private messageToOpenAI(message: Message): OpenAI.ChatCompletionMessageParam {
    // 简单文本消息
    if (typeof message.content === 'string') {
      return {
        role: message.role,
        content: message.content
      };
    }

    // 多模态消息
    return {
      role: message.role,
      content: message.content.map(block => {
        if (block.type === 'text') {
          return { type: 'text', text: block.text };
        } else if (block.type === 'image') {
          if (block.source.type === 'url') {
            return {
              type: 'image_url',
              image_url: { url: block.source.url }
            };
          } else {
            return {
              type: 'image_url',
              image_url: {
                url: `data:${block.source.mediaType};base64,${block.source.data}`
              }
            };
          }
        } else if (block.type === 'tool_use') {
          // OpenAI 的工具调用在单独的字段
          return null;
        }
        return null;
      }).filter(Boolean) as any,
      tool_calls: message.toolCalls?.map(tc => ({
        id: tc.id,
        type: 'function' as const,
        function: {
          name: tc.name,
          arguments: JSON.stringify(tc.input)
        }
      }))
    };
  }

  /**
   * 从 OpenAI 格式转换
   */
  fromOpenAI(response: OpenAI.ChatCompletion): Message {
    const choice = response.choices[0];
    const message = choice.message;

    return {
      role: 'assistant',
      content: message.content || '',
      toolCalls: message.tool_calls?.map(tc => ({
        id: tc.id,
        name: tc.function.name,
        input: JSON.parse(tc.function.arguments)
      })),
      metadata: {
        id: response.id,
        model: response.model,
        finishReason: choice.finish_reason
      }
    };
  }

  /**
   * 转换为 Anthropic 格式
   */
  toAnthropic(context: Context): Anthropic.MessageCreateParams {
    return {
      model: 'claude-opus-4',  // 由外部指定
      system: context.systemPrompt,
      messages: context.messages.map(msg => this.messageToAnthropic(msg)),
      temperature: context.temperature,
      max_tokens: context.maxTokens || 4096,  // Anthropic 要求必填
      top_p: context.topP,
      stop_sequences: context.stopSequences,
      tools: context.tools?.map(tool => ({
        name: tool.name,
        description: tool.description,
        input_schema: tool.parameters
      }))
    };
  }

  /**
   * 单条消息转换为 Anthropic 格式
   */
  private messageToAnthropic(message: Message): Anthropic.MessageParam {
    // Anthropic 的 content 总是数组
    const content = typeof message.content === 'string'
      ? [{ type: 'text' as const, text: message.content }]
      : message.content.map(block => {
          if (block.type === 'text') {
            return { type: 'text' as const, text: block.text };
          } else if (block.type === 'image') {
            if (block.source.type === 'url') {
              return {
                type: 'image' as const,
                source: {
                  type: 'url' as const,
                  url: block.source.url
                }
              };
            } else {
              return {
                type: 'image' as const,
                source: {
                  type: 'base64' as const,
                  media_type: block.source.mediaType as any,
                  data: block.source.data
                }
              };
            }
          } else if (block.type === 'tool_use') {
            return {
              type: 'tool_use' as const,
              id: block.id,
              name: block.name,
              input: block.input
            };
          } else if (block.type === 'tool_result') {
            return {
              type: 'tool_result' as const,
              tool_use_id: block.toolUseId,
              content: typeof block.content === 'string'
                ? block.content
                : JSON.stringify(block.content),
              is_error: block.isError
            };
          }
          return null;
        }).filter(Boolean) as any;

    return {
      role: message.role === 'user' ? 'user' : 'assistant',
      content
    };
  }

  /**
   * 从 Anthropic 格式转换
   */
  fromAnthropic(response: Anthropic.Message): Message {
    const content: ContentBlock[] = response.content.map(block => {
      if (block.type === 'text') {
        return { type: 'text', text: block.text };
      } else if (block.type === 'tool_use') {
        return {
          type: 'tool_use',
          id: block.id,
          name: block.name,
          input: block.input
        };
      }
      return null;
    }).filter(Boolean) as ContentBlock[];

    return {
      role: 'assistant',
      content,
      metadata: {
        id: response.id,
        model: response.model,
        stopReason: response.stop_reason
      }
    };
  }

  /**
   * 转换为 Google 格式
   */
  toGoogle(context: Context): any {
    return {
      contents: context.messages.map(msg => this.messageToGoogle(msg)),
      systemInstruction: context.systemPrompt
        ? { parts: [{ text: context.systemPrompt }] }
        : undefined,
      generationConfig: {
        temperature: context.temperature,
        maxOutputTokens: context.maxTokens,
        topP: context.topP,
        stopSequences: context.stopSequences
      },
      tools: context.tools?.map(tool => ({
        functionDeclarations: [{
          name: tool.name,
          description: tool.description,
          parameters: tool.parameters
        }]
      }))
    };
  }

  /**
   * 单条消息转换为 Google 格式
   */
  private messageToGoogle(message: Message): any {
    const parts = typeof message.content === 'string'
      ? [{ text: message.content }]
      : message.content.map(block => {
          if (block.type === 'text') {
            return { text: block.text };
          } else if (block.type === 'image') {
            if (block.source.type === 'url') {
              // Google 不直接支持 URL，需要先下载
              return { text: `[Image: ${block.source.url}]` };
            } else {
              return {
                inlineData: {
                  mimeType: block.source.mediaType,
                  data: block.source.data
                }
              };
            }
          }
          return null;
        }).filter(Boolean);

    return {
      role: message.role === 'assistant' ? 'model' : 'user',
      parts
    };
  }

  /**
   * 从 Google 格式转换
   */
  fromGoogle(response: any): Message {
    const candidate = response.candidates[0];
    const content = candidate.content.parts.map((part: any) => ({
      type: 'text' as const,
      text: part.text
    }));

    return {
      role: 'assistant',
      content,
      metadata: {
        finishReason: candidate.finishReason
      }
    };
  }
}
```

### 3. 类型安全的消息构建器

```typescript
/**
 * 消息构建器
 * 提供类型安全的消息构建 API
 */
class MessageBuilder {
  private message: Message;

  constructor(role: 'user' | 'assistant' | 'system') {
    this.message = {
      role,
      content: []
    };
  }

  /**
   * 添加文本内容
   */
  addText(text: string): this {
    if (typeof this.message.content === 'string') {
      this.message.content = [{ type: 'text', text: this.message.content }];
    }
    (this.message.content as ContentBlock[]).push({
      type: 'text',
      text
    });
    return this;
  }

  /**
   * 添加图片（URL）
   */
  addImageUrl(url: string): this {
    if (typeof this.message.content === 'string') {
      this.message.content = [{ type: 'text', text: this.message.content }];
    }
    (this.message.content as ContentBlock[]).push({
      type: 'image',
      source: { type: 'url', url }
    });
    return this;
  }

  /**
   * 添加图片（Base64）
   */
  addImageBase64(mediaType: string, data: string): this {
    if (typeof this.message.content === 'string') {
      this.message.content = [{ type: 'text', text: this.message.content }];
    }
    (this.message.content as ContentBlock[]).push({
      type: 'image',
      source: { type: 'base64', mediaType, data }
    });
    return this;
  }

  /**
   * 添加工具调用
   */
  addToolCall(id: string, name: string, input: Record<string, any>): this {
    if (!this.message.toolCalls) {
      this.message.toolCalls = [];
    }
    this.message.toolCalls.push({ id, name, input });
    return this;
  }

  /**
   * 添加工具结果
   */
  addToolResult(toolCallId: string, content: string, isError = false): this {
    if (!this.message.toolResults) {
      this.message.toolResults = [];
    }
    this.message.toolResults.push({ toolCallId, content, isError });
    return this;
  }

  /**
   * 设置元数据
   */
  setMetadata(metadata: Record<string, any>): this {
    this.message.metadata = { ...this.message.metadata, ...metadata };
    return this;
  }

  /**
   * 构建消息
   */
  build(): Message {
    // 如果只有一个文本块，简化为字符串
    if (
      Array.isArray(this.message.content) &&
      this.message.content.length === 1 &&
      this.message.content[0].type === 'text'
    ) {
      this.message.content = this.message.content[0].text;
    }
    return this.message;
  }
}

// 使用示例
const message = new MessageBuilder('user')
  .addText('What is in this image?')
  .addImageUrl('https://example.com/image.jpg')
  .setMetadata({ timestamp: Date.now() })
  .build();
```

---

## 在 AI Agent 中的应用

### 场景1：多模态对话

```typescript
/**
 * 多模态对话示例
 * 支持文本 + 图片输入
 */
async function analyzeImage(
  imageUrl: string,
  question: string
): Promise<string> {
  const converter = new MessageConverter();

  // 构建多模态消息
  const context: Context = {
    systemPrompt: 'You are a helpful image analysis assistant.',
    messages: [
      {
        role: 'user',
        content: [
          { type: 'text', text: question },
          { type: 'image', source: { type: 'url', url: imageUrl } }
        ]
      }
    ],
    temperature: 0.7,
    maxTokens: 1000
  };

  // 转换为 Provider 格式（自动适配）
  const openaiRequest = converter.toOpenAI(context);

  // 调用 API
  const openai = new OpenAI();
  const response = await openai.chat.completions.create(openaiRequest);

  // 转换回统一格式
  const message = converter.fromOpenAI(response);

  return typeof message.content === 'string'
    ? message.content
    : message.content.map(block => block.type === 'text' ? block.text : '').join('');
}

// 使用
const answer = await analyzeImage(
  'https://example.com/chart.png',
  'What does this chart show?'
);
```

### 场景2：工具调用对话

```typescript
/**
 * 工具调用对话示例
 * 支持多轮工具调用
 */
async function chatWithTools(
  userMessage: string,
  tools: Tool[]
): Promise<string> {
  const converter = new MessageConverter();
  const messages: Message[] = [];

  // 1. 用户消息
  messages.push({
    role: 'user',
    content: userMessage
  });

  // 2. 调用 LLM
  const context: Context = {
    systemPrompt: 'You are a helpful assistant with access to tools.',
    messages,
    tools,
    temperature: 0.7
  };

  const anthropicRequest = converter.toAnthropic(context);
  const anthropic = new Anthropic();
  const response = await anthropic.messages.create(anthropicRequest);

  // 3. 处理响应
  const assistantMessage = converter.fromAnthropic(response);
  messages.push(assistantMessage);

  // 4. 如果有工具调用，执行工具
  if (Array.isArray(assistantMessage.content)) {
    const toolUses = assistantMessage.content.filter(
      block => block.type === 'tool_use'
    ) as ToolUseBlock[];

    if (toolUses.length > 0) {
      // 执行工具
      const toolResults: ContentBlock[] = [];
      for (const toolUse of toolUses) {
        const result = await executeToolfunction(toolUse.name, toolUse.input);
        toolResults.push({
          type: 'tool_result',
          toolUseId: toolUse.id,
          content: JSON.stringify(result)
        });
      }

      // 添加工具结果消息
      messages.push({
        role: 'user',
        content: toolResults
      });

      // 再次调用 LLM
      const finalContext: Context = {
        ...context,
        messages
      };
      const finalRequest = converter.toAnthropic(finalContext);
      const finalResponse = await anthropic.messages.create(finalRequest);
      const finalMessage = converter.fromAnthropic(finalResponse);

      return typeof finalMessage.content === 'string'
        ? finalMessage.content
        : finalMessage.content.map(block =>
            block.type === 'text' ? block.text : ''
          ).join('');
    }
  }

  return typeof assistantMessage.content === 'string'
    ? assistantMessage.content
    : assistantMessage.content.map(block =>
        block.type === 'text' ? block.text : ''
      ).join('');
}

// 工具执行函数（示例）
async function executeTool(name: string, input: any): Promise<any> {
  if (name === 'get_weather') {
    return { temperature: 22, condition: 'sunny' };
  }
  throw new Error(`Unknown tool: ${name}`);
}
```

### 场景3：跨 Provider 上下文迁移

```typescript
/**
 * 跨 Provider 迁移对话上下文
 * 从 OpenAI 切换到 Anthropic
 */
async function migrateContext(
  openaiMessages: OpenAI.ChatCompletionMessageParam[],
  newUserMessage: string
): Promise<string> {
  const converter = new MessageConverter();

  // 1. 将 OpenAI 消息转换为统一格式
  const piMessages: Message[] = openaiMessages.map(msg => ({
    role: msg.role as any,
    content: typeof msg.content === 'string'
      ? msg.content
      : msg.content?.map((block: any) => {
          if (block.type === 'text') {
            return { type: 'text', text: block.text };
          } else if (block.type === 'image_url') {
            return {
              type: 'image',
              source: { type: 'url', url: block.image_url.url }
            };
          }
          return null;
        }).filter(Boolean) || []
  }));

  // 2. 添加新消息
  piMessages.push({
    role: 'user',
    content: newUserMessage
  });

  // 3. 转换为 Anthropic 格式
  const context: Context = {
    messages: piMessages,
    temperature: 0.7
  };

  const anthropicRequest = converter.toAnthropic(context);

  // 4. 调用 Anthropic API
  const anthropic = new Anthropic();
  const response = await anthropic.messages.create(anthropicRequest);

  // 5. 转换回统一格式
  const message = converter.fromAnthropic(response);

  return typeof message.content === 'string'
    ? message.content
    : message.content.map(block =>
        block.type === 'text' ? block.text : ''
      ).join('');
}
```

---

## 设计权衡

### 优点

1. **类型安全**
   - TypeScript 类型检查
   - 编译时发现错误
   - IDE 自动补全

2. **格式统一**
   - 一套数据结构
   - 降低学习成本
   - 简化代码逻辑

3. **双向转换**
   - 无损转换
   - 保留所有信息
   - 支持跨 Provider 迁移

4. **可扩展性**
   - 易于添加新内容类型
   - 支持 Provider 特有功能

### 缺点

1. **转换开销**
   - 格式转换有轻微性能开销（< 1ms）
   - 但远小于网络延迟（> 50ms）

2. **抽象泄漏**
   - 某些 Provider 特有功能难以抽象
   - 需要通过 options 传递

3. **维护成本**
   - Provider API 变更需要更新转换器
   - 需要保持类型定义同步

---

## 学习检查清单

完成本概念学习后，你应该能够：

- [ ] 理解统一消息格式的设计原则
- [ ] 理解 Context、Message、ContentBlock 的结构
- [ ] 能够实现格式转换器（to/from）
- [ ] 能够使用 MessageBuilder 构建消息
- [ ] 理解多模态内容的表示
- [ ] 理解工具调用的消息格式
- [ ] 能够实现跨 Provider 上下文迁移
- [ ] 理解设计权衡

---

## 参考资源

### 官方文档
- [pi-ai Types](https://github.com/badlogic/pi-mono/blob/main/packages/pi-ai/src/types.ts) - 类型定义
- [OpenAI Message Format](https://platform.openai.com/docs/api-reference/chat/create) - OpenAI 格式
- [Anthropic Message Format](https://docs.anthropic.com/claude/reference/messages_post) - Anthropic 格式
- [Google AI Format](https://ai.google.dev/api/rest/v1beta/Content) - Google 格式

### 相关项目
- [Vercel AI SDK](https://sdk.vercel.ai/) - TypeScript 统一格式
- [LangChain.js](https://js.langchain.com/) - 消息格式抽象

---

**版本：** v1.0
**最后更新：** 2026-02-19
