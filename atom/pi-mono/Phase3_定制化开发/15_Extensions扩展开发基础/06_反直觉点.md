# Extensions 扩展开发基础 - 反直觉点

> 揭示 Extensions 开发中最常见的 3 个误区

---

## 为什么需要了解反直觉点？

在学习 Extensions 时,很多概念看似简单,但实际使用中容易犯错。这些错误往往源于:
- 从其他框架带来的固有思维
- 对底层机制的误解
- 表面现象与实际原理的差异

了解这些反直觉点,可以帮助你:
- 避免常见的开发陷阱
- 理解 pi-mono 的设计哲学
- 写出更健壮的扩展代码

---

## 误区 1: "状态可以存储在外部文件中" ❌

### 错误观点

```typescript
// ❌ 很多人会这样写
import fs from 'fs';

export default function (pi: ExtensionAPI) {
  const todosFile = path.join(os.homedir(), '.pi', 'todos.json');

  pi.registerTool({
    name: "todo",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      // 从文件读取状态
      const todos = JSON.parse(fs.readFileSync(todosFile, 'utf-8'));

      // 修改状态
      todos.push({ id: Date.now(), text: params.text });

      // 保存到文件
      fs.writeFileSync(todosFile, JSON.stringify(todos));

      return {
        content: [{ type: "text", text: "Added todo" }],
        details: {},
      };
    },
  });
}
```

**看起来很合理,为什么错了?**

### 为什么错?

**核心问题: Session 分支会导致状态不一致**

pi-mono 支持 Session 分支 (fork),当你 fork 一个 session 时:

```
主 Session (todos = [A, B, C])
  ↓ fork
  ├── Session 1: 删除 todo B
  │   文件内容: [A, C]
  │
  └── Session 2: 添加 todo D
      文件内容: [A, C, D]  ← 问题: Session 2 看不到 B 被删除了!
```

**实际发生的情况:**

1. 主 Session: `todos.json` = `[A, B, C]`
2. Fork 创建 Session 1
3. Session 1 删除 B: `todos.json` = `[A, C]`
4. 切换到 Session 2 (从主 Session fork 的另一个分支)
5. Session 2 读取 `todos.json` = `[A, C]` ← **错误!应该是 `[A, B, C]`**

**两个分支共享同一个文件,状态会互相污染!**

### 为什么人们容易这样错?

**心理/认知原因:**

1. **传统应用的思维惯性**
   - 大多数应用使用数据库或文件存储状态
   - 这在单线程、无分支的场景下是正确的
   - 但 pi-mono 的 Session 分支类似 Git 分支,需要不同的思维

2. **表面现象的误导**
   - 在不使用 fork 的情况下,外部文件存储"看起来"工作正常
   - 只有在 fork 后才会暴露问题
   - 很多人在测试时没有测试 fork 场景

3. **对"持久化"的误解**
   - 认为"持久化"就是"写入文件"
   - 但 pi-mono 的持久化是通过 Session JSONL 文件实现的
   - tool result 的 details 字段会被自动持久化

### 正确理解

**✅ 状态应该存储在 tool result 的 details 字段中**

```typescript
export default function (pi: ExtensionAPI) {
  // 内存状态 (从 Session 重建)
  let todos: Todo[] = [];
  let nextId = 1;

  // 从 Session 历史重建状态
  const reconstructState = (ctx: ExtensionContext) => {
    todos = [];
    nextId = 1;

    for (const entry of ctx.sessionManager.getBranch()) {
      if (entry.type === "message" &&
          entry.message.role === "toolResult" &&
          entry.message.toolName === "todo") {
        const details = entry.message.details as TodoDetails;
        if (details) {
          todos = details.todos;
          nextId = details.nextId;
        }
      }
    }
  };

  // 在 Session 事件时重建状态
  pi.on("session_start", async (_, ctx) => reconstructState(ctx));
  pi.on("session_switch", async (_, ctx) => reconstructState(ctx));
  pi.on("session_fork", async (_, ctx) => reconstructState(ctx));

  pi.registerTool({
    name: "todo",
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      todos.push({ id: nextId++, text: params.text, done: false });

      // ✅ 状态保存在 details (会被持久化到 Session)
      return {
        content: [{ type: "text", text: "Added todo" }],
        details: { todos: [...todos], nextId }, // 关键!
      };
    },
  });
}
```

**为什么这样是正确的?**

```
主 Session (details: todos = [A, B, C])
  ↓ fork (复制历史)
  ├── Session 1: 删除 B
  │   details: todos = [A, C]
  │   ↓ 重建状态时只看到 [A, C]
  │
  └── Session 2: 添加 D
      details: todos = [A, B, C, D]
      ↓ 重建状态时看到完整的 [A, B, C, D]
```

**每个分支有独立的历史和状态!**

**类比: Git 分支**
- 外部文件 = 所有分支共享一个文件 (会冲突)
- details 存储 = 每个分支有独立的 commit 历史 (不会冲突)

---

## 误区 2: "事件监听器可以修改事件对象" ❌

### 错误观点

```typescript
// ❌ 很多人会这样写
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 尝试直接修改事件对象
    if (event.toolName === "bash") {
      event.input.command = event.input.command?.replace("rm -rf", "echo");
    }
    // 期望修改会生效
  });
}
```

**看起来很直观,为什么错了?**

### 为什么错?

**核心问题: 事件对象是只读的,直接修改不会生效**

pi-mono 的事件系统设计:

1. **事件对象是不可变的 (immutable)**
   - 事件对象在触发时创建
   - 传递给所有监听器的是同一个对象
   - 直接修改会影响其他监听器,导致不可预测的行为

2. **修改需要通过返回值**
   - 返回 `{ transform: newValue }` 来修改事件
   - 返回 `{ block: true }` 来阻止事件
   - 不返回或返回 `undefined` 表示允许继续

**实际测试:**

```typescript
// 测试 1: 直接修改 (不生效)
pi.on("tool_call", async (event, ctx) => {
  console.log("Before:", event.input.command);
  event.input.command = "modified";
  console.log("After:", event.input.command);
  // 输出: Before: rm -rf /
  //      After: modified
  // 但实际执行的还是 "rm -rf /"!
});

// 测试 2: 通过返回值修改 (生效)
pi.on("tool_call", async (event, ctx) => {
  if (event.toolName === "bash") {
    return {
      transform: {
        ...event,
        input: {
          ...event.input,
          command: "echo 'blocked'",
        },
      },
    };
  }
});
```

### 为什么人们容易这样错?

**心理/认知原因:**

1. **JavaScript 对象的可变性**
   - JavaScript 中对象默认是可变的
   - `event.input.command = "new"` 在语法上是合法的
   - 没有编译错误,运行时也不报错
   - 但修改不会生效,导致困惑

2. **其他框架的习惯**
   - 很多框架允许直接修改事件对象 (如 Express 的 `req`, `res`)
   - 这种模式在 pi-mono 中不适用

3. **返回值的反直觉**
   - 通常函数返回值用于"返回结果"
   - 但这里返回值用于"控制事件流"
   - 这种设计模式不常见

### 正确理解

**✅ 通过返回值来控制事件**

```typescript
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 1. 阻止事件
    if (shouldBlock(event)) {
      return { block: true, reason: "Blocked by extension" };
    }

    // 2. 转换事件 (修改)
    if (event.toolName === "bash" && event.input.command) {
      const safeCommand = sanitizeCommand(event.input.command);
      return {
        transform: {
          ...event,
          input: {
            ...event.input,
            command: safeCommand,
          },
        },
      };
    }

    // 3. 允许继续 (不返回或返回 undefined)
    // 默认行为
  });
}
```

**为什么这样设计?**

1. **不可变性 (Immutability)**
   - 保证事件对象在所有监听器中一致
   - 避免监听器之间的副作用
   - 更容易调试和测试

2. **明确的控制流**
   - 返回值明确表达意图 (阻止/转换/允许)
   - 代码更易读和维护

3. **支持多个监听器**
   - 多个监听器可以独立决定是否阻止
   - 任何一个返回 `block: true` 就会阻止事件

**类比: 函数式编程**
```typescript
// 命令式 (可变)
const arr = [1, 2, 3];
arr.push(4); // 直接修改

// 函数式 (不可变)
const arr = [1, 2, 3];
const newArr = [...arr, 4]; // 返回新数组
```

---

## 误区 3: "Extension 加载顺序可以控制" ❌

### 错误观点

```typescript
// ❌ 很多人期望这样控制顺序
// 文件: 01-first.ts
export default function (pi: ExtensionAPI) {
  console.log("This should run first");
}

// 文件: 02-second.ts
export default function (pi: ExtensionAPI) {
  console.log("This should run second");
}

// 期望: 按文件名顺序加载
// 实际: 加载顺序不确定!
```

**看起来很合理,为什么错了?**

### 为什么错?

**核心问题: Extension 加载顺序是不确定的**

pi-mono 的 Extension 加载机制:

1. **文件系统扫描是无序的**
   - `fs.readdir()` 返回的文件顺序不保证
   - 不同操作系统可能有不同的顺序
   - 文件名前缀 (01-, 02-) 不影响加载顺序

2. **并发加载**
   - Extensions 可能并发加载 (使用 `Promise.all`)
   - 加载完成的顺序取决于文件大小、依赖等因素

3. **事件监听器的执行顺序**
   - 即使 Extension A 先加载,它的事件监听器也不一定先执行
   - 事件监听器按注册顺序执行,但注册顺序 ≠ 加载顺序

**实际测试:**

```bash
# 创建两个扩展
echo 'export default (pi) => console.log("A")' > ~/.pi/agent/extensions/01-a.ts
echo 'export default (pi) => console.log("B")' > ~/.pi/agent/extensions/02-b.ts

# 运行 pi
pi

# 可能的输出:
# B
# A
# (顺序不确定!)
```

### 为什么人们容易这样错?

**心理/认知原因:**

1. **文件名暗示顺序**
   - 文件名前缀 (01-, 02-) 暗示了顺序
   - 人类大脑自然会假设按顺序加载
   - 但计算机不会这样理解

2. **其他系统的经验**
   - 很多系统 (如 systemd, init.d) 按文件名顺序加载
   - 这种经验迁移到 pi-mono 会导致错误假设

3. **同步思维**
   - 期望 Extension 按顺序同步加载
   - 但实际是异步并发加载

### 正确理解

**✅ 不要依赖 Extension 加载顺序**

**设计原则:**

1. **每个 Extension 应该独立工作**
   ```typescript
   // ✅ 好的设计: 独立的扩展
   export default function (pi: ExtensionAPI) {
     pi.on("tool_call", async (event, ctx) => {
       // 不依赖其他扩展的状态
       if (event.toolName === "bash") {
         console.log("Bash called");
       }
     });
   }
   ```

2. **如果需要协作,使用事件总线**
   ```typescript
   // Extension A: 发布事件
   export default function (pi: ExtensionAPI) {
     pi.on("tool_call", async (event, ctx) => {
       // 触发自定义事件
       pi.events.emit("custom:tool_validated", { toolName: event.toolName });
     });
   }

   // Extension B: 监听事件
   export default function (pi: ExtensionAPI) {
     pi.events.on("custom:tool_validated", (data) => {
       console.log("Tool validated:", data.toolName);
     });
   }
   ```

3. **如果必须有顺序,使用单个 Extension**
   ```typescript
   // ✅ 如果逻辑必须有顺序,放在一个文件中
   export default function (pi: ExtensionAPI) {
     // 步骤 1
     pi.on("tool_call", async (event, ctx) => {
       console.log("Step 1");
     });

     // 步骤 2
     pi.on("tool_result", async (event, ctx) => {
       console.log("Step 2");
     });
   }
   ```

**事件监听器的执行顺序:**

```typescript
// 即使加载顺序不确定,事件监听器按注册顺序执行

// Extension A
pi.on("tool_call", async (event, ctx) => {
  console.log("A");
});

// Extension B
pi.on("tool_call", async (event, ctx) => {
  console.log("B");
});

// 如果 A 先注册,输出: A, B
// 如果 B 先注册,输出: B, A
// 但注册顺序 = 加载顺序,而加载顺序不确定!
```

**最佳实践:**

```typescript
// ✅ 设计不依赖顺序的扩展
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 每个扩展独立决策
    if (shouldBlock(event)) {
      return { block: true, reason: "Blocked" };
    }
  });
}

// ✅ 如果需要优先级,使用事件的 block 机制
export default function (pi: ExtensionAPI) {
  pi.on("tool_call", async (event, ctx) => {
    // 高优先级检查
    if (criticalCheck(event)) {
      return { block: true, reason: "Critical" };
    }
    // 如果没有阻止,其他扩展会继续检查
  });
}
```

**类比: 微服务架构**
- 每个微服务独立部署,启动顺序不确定
- 服务之间通过消息队列通信,不依赖启动顺序
- Extensions 也应该这样设计

---

## 总结: 三大反直觉点

| 误区 | 错误做法 | 正确做法 | 核心原因 |
|------|---------|---------|---------|
| **状态存储** | 使用外部文件 | 使用 tool result details | Session 分支需要独立状态 |
| **事件修改** | 直接修改事件对象 | 通过返回值控制 | 不可变性设计,避免副作用 |
| **加载顺序** | 依赖文件名顺序 | 设计独立的扩展 | 加载顺序不确定,应该独立工作 |

---

## 避免误区的思维模型

### 1. Session 分支思维

**传统应用:**
```
单一时间线: A → B → C → D
状态: 线性演化
```

**pi-mono:**
```
分支时间线:
  A → B → C
      ├→ D (分支 1)
      └→ E (分支 2)
状态: 每个分支独立
```

**启示: 状态必须支持分支**

### 2. 不可变性思维

**可变模式:**
```typescript
const obj = { value: 1 };
obj.value = 2; // 直接修改
```

**不可变模式:**
```typescript
const obj = { value: 1 };
const newObj = { ...obj, value: 2 }; // 返回新对象
```

**启示: 通过返回值而非修改来控制**

### 3. 独立性思维

**依赖顺序:**
```
Extension A → Extension B → Extension C
(B 依赖 A, C 依赖 B)
```

**独立工作:**
```
Extension A ↘
Extension B → 事件总线 → 结果
Extension C ↗
(各自独立,通过事件协作)
```

**启示: 设计独立的,可组合的扩展**

---

## 检查清单

在开发 Extension 时,问自己:

- [ ] 我的状态存储在 details 中吗? (不是外部文件)
- [ ] 我通过返回值控制事件吗? (不是直接修改)
- [ ] 我的扩展独立工作吗? (不依赖加载顺序)
- [ ] 我在 Session 事件时重建状态吗?
- [ ] 我的事件监听器是幂等的吗?
- [ ] 我测试了 Session fork 场景吗?

---

## 延伸阅读

- **核心概念 - 扩展开发模式**: 深入理解状态管理和事件处理模式
- **实战代码 - 会话管理扩展**: 学习正确的状态管理实践
- **官方文档**: https://github.com/badlogic/pi-mono/tree/main/packages/coding-agent/docs/extensions.md

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: pi-mono 2025-2026 版本
