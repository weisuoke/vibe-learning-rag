# 双重类比

> **用熟悉的概念理解陌生的技术**

## 类比策略

- **TypeScript/Node.js 类比**：面向有前端/后端开发经验的开发者
- **日常生活类比**：面向所有人，用生活场景理解技术概念

---

## 核心概念类比表

| Pi-mono 概念 | TypeScript/Node.js 类比 | 日常生活类比 |
|-------------|------------------------|--------------|
| **Tool Definition** | REST API 端点定义 | 工具箱里的工具说明书 |
| **registerTool** | Express `app.use()` 注册中间件 | 在服务台注册新服务 |
| **Schema (TypeBox)** | Zod schema / TypeScript interface | 表单验证规则 |
| **execute 函数** | 路由处理器 handler | 执行具体操作的工人 |
| **AgentToolResult** | HTTP Response 对象 | 工作完成后的报告 |
| **renderCall** | 请求日志格式化 | 显示"正在使用工具X" |
| **renderResult** | 响应格式化 | 显示"工具X返回结果" |
| **tool_call event** | Express middleware | 工具使用前的安检 |
| **ExtensionContext** | Request context | 工具执行的上下文环境 |
| **parameters** | Query params / Request body | 工具的使用说明 |
| **AbortSignal** | Request timeout / cancellation | 紧急停止按钮 |
| **onUpdate callback** | Server-Sent Events (SSE) | 实时进度通知 |

---

## 详细类比解析

### 1. Tool Definition = REST API 端点定义

#### TypeScript/Node.js 类比

```typescript
// Express API 端点定义
app.post('/api/weather', async (req, res) => {
  const { city } = req.body;  // 参数
  const weather = await getWeather(city);  // 执行逻辑
  res.json({ weather });  // 返回结果
});

// Pi-mono Tool Definition
const weatherTool = {
  name: 'get-weather',  // 端点路径
  description: 'Get weather',  // API 文档
  parameters: Type.Object({  // 请求体 schema
    city: Type.String()
  }),
  execute: async ({ city }) => {  // 处理器
    const weather = await getWeather(city);
    return { content: weather };
  }
};
```

**相似点**：
- 都定义了"如何调用"和"如何执行"
- 都需要参数验证
- 都返回结构化结果

**差异点**：
- API 端点通过 HTTP 调用，Tool 通过 LLM 调用
- API 返回 JSON，Tool 返回 `AgentToolResult`

#### 日常生活类比

**工具箱里的工具说明书**

想象你有一个工具箱，每个工具都有一张说明书：

```
工具名称：螺丝刀
用途：拧螺丝
使用方法：
  1. 选择合适的螺丝刀头（参数：螺丝类型）
  2. 对准螺丝
  3. 顺时针拧紧，逆时针松开
返回结果：螺丝拧紧/松开
```

Tool Definition 就是这张说明书：
- **name**: 工具名称（螺丝刀）
- **description**: 用途（拧螺丝）
- **parameters**: 使用方法（螺丝类型）
- **execute**: 执行步骤（拧的动作）

---

### 2. registerTool = Express app.use()

#### TypeScript/Node.js 类比

```typescript
// Express 注册中间件
const app = express();
app.use('/api', apiRouter);  // 注册路由
app.use(errorHandler);  // 注册错误处理

// Pi-mono 注册工具
export const myExtension: Extension = {
  async activate(context) {
    context.registerTool(weatherTool);  // 注册工具
    context.registerTool(searchTool);   // 注册工具
  }
};
```

**相似点**：
- 都是"注册"机制
- 注册后才能被调用
- 可以注册多个

**差异点**：
- Express 注册的是路由/中间件，Pi-mono 注册的是工具
- Express 在启动时注册，Pi-mono 在 Extension 激活时注册

#### 日常生活类比

**在服务台注册新服务**

想象一个政府服务大厅：

1. **没注册前**：
   - 用户：我想办理护照
   - 服务台：抱歉，我们没有这个服务

2. **注册后**：
   - 管理员：注册"护照办理"服务（registerTool）
   - 用户：我想办理护照
   - 服务台：好的，请到3号窗口

`registerTool` 就是向服务台注册新服务的过程。

---

### 3. Schema (TypeBox) = Zod schema / TypeScript interface

#### TypeScript/Node.js 类比

```typescript
// Zod schema
const UserSchema = z.object({
  name: z.string(),
  age: z.number().min(0),
  email: z.string().email().optional()
});

// TypeBox schema
const UserSchema = Type.Object({
  name: Type.String(),
  age: Type.Number({ minimum: 0 }),
  email: Type.Optional(Type.String({ format: 'email' }))
});

// TypeScript interface (仅类型，无运行时验证)
interface User {
  name: string;
  age: number;
  email?: string;
}
```

**相似点**：
- 都定义数据结构
- 都提供类型安全
- 都支持验证规则

**差异点**：
- TypeScript interface 仅编译时检查
- Zod/TypeBox 提供运行时验证
- TypeBox 生成 JSON Schema（LLM 可理解）

#### 日常生活类比

**表单验证规则**

想象一个注册表单：

```
姓名：[_______]  （必填，文本）
年龄：[_______]  （必填，数字，≥0）
邮箱：[_______]  （可选，邮箱格式）
```

Schema 就是这些验证规则：
- **Type.String()**: 必须是文本
- **Type.Number({ minimum: 0 })**: 必须是非负数
- **Type.Optional()**: 可以不填

如果填写不符合规则，表单会提示错误（运行时验证）。

---

### 4. execute 函数 = 路由处理器 handler

#### TypeScript/Node.js 类比

```typescript
// Express 路由处理器
app.post('/api/users', async (req, res) => {
  try {
    const user = await createUser(req.body);
    res.json({ success: true, user });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Pi-mono execute 函数
const execute = async (params, context) => {
  try {
    const user = await createUser(params);
    return { content: JSON.stringify(user) };
  } catch (error) {
    return { content: `Error: ${error.message}` };
  }
};
```

**相似点**：
- 都是异步函数
- 都接收参数
- 都返回结果
- 都需要错误处理

**差异点**：
- Express handler 接收 `req, res`，execute 接收 `params, context`
- Express 通过 `res.json()` 返回，execute 通过 `return` 返回

#### 日常生活类比

**执行具体操作的工人**

想象你雇了一个工人修理水管：

1. **接收任务**：修理厨房水管（params）
2. **执行操作**：
   - 关闭水阀
   - 更换水管
   - 测试是否漏水
3. **返回结果**：水管已修好，费用200元（AgentToolResult）

`execute` 函数就是这个工人的工作流程。

---

### 5. AgentToolResult = HTTP Response 对象

#### TypeScript/Node.js 类比

```typescript
// HTTP Response
res.json({
  data: { weather: 'Sunny' },
  metadata: { timestamp: '2026-02-21' }
});

// AgentToolResult
return {
  content: 'Weather: Sunny',
  metadata: { timestamp: '2026-02-21' }
};
```

**相似点**：
- 都包含主要内容（data / content）
- 都可以包含元数据（metadata）
- 都是结构化数据

**差异点**：
- HTTP Response 是 JSON，AgentToolResult 的 content 是字符串
- HTTP Response 有状态码，AgentToolResult 没有

#### 日常生活类比

**工作完成后的报告**

想象你请人打扫房间，完成后他给你一份报告：

```
主要内容（content）：
  - 客厅已打扫
  - 卧室已打扫
  - 厨房已打扫

附加信息（metadata）：
  - 用时：2小时
  - 使用清洁剂：3瓶
  - 发现问题：水龙头漏水
```

`AgentToolResult` 就是这份报告。

---

### 6. renderCall = 请求日志格式化

#### TypeScript/Node.js 类比

```typescript
// Express 请求日志
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.path}`);
  console.log('Body:', req.body);
  next();
});

// Pi-mono renderCall
renderCall: (params) => {
  return `Calling get-weather with city: ${params.city}`;
}
```

**相似点**：
- 都是格式化显示
- 都在执行前触发
- 都用于调试和监控

**差异点**：
- Express 日志输出到控制台，renderCall 显示在 UI
- renderCall 可以自定义 UI 组件

#### 日常生活类比

**显示"正在使用工具X"**

想象你在使用智能助手：

```
用户：北京今天天气怎么样？
助手：[正在查询天气] 🔍
      城市：北京
      数据源：中国气象局
```

`renderCall` 就是这个"正在查询天气"的提示。

---

### 7. renderResult = 响应格式化

#### TypeScript/Node.js 类比

```typescript
// Express 响应格式化
app.use((req, res, next) => {
  const originalJson = res.json;
  res.json = function(data) {
    console.log('Response:', JSON.stringify(data, null, 2));
    return originalJson.call(this, data);
  };
  next();
});

// Pi-mono renderResult
renderResult: (result) => {
  return `Weather result: ${result.content}`;
}
```

**相似点**：
- 都是格式化显示
- 都在执行后触发
- 都用于美化输出

**差异点**：
- Express 格式化 JSON，renderResult 格式化 AgentToolResult
- renderResult 可以使用 pi-tui 组件

#### 日常生活类比

**显示"工具X返回结果"**

想象你在使用智能助手：

```
助手：[查询完成] ✅
      北京今天天气：晴天 25°C
      空气质量：良
      建议：适合户外活动
```

`renderResult` 就是这个格式化的结果显示。

---

### 8. tool_call event = Express middleware

#### TypeScript/Node.js 类比

```typescript
// Express middleware
app.use((req, res, next) => {
  // 在请求处理前执行
  console.log('Before request');
  req.startTime = Date.now();
  next();
});

// Pi-mono tool_call event
context.on('tool_call', (event) => {
  // 在工具调用前执行
  console.log('Before tool call:', event.tool.name);
  event.context.session.set('lastToolCall', Date.now());
});
```

**相似点**：
- 都是拦截机制
- 都在执行前触发
- 都可以修改上下文

**差异点**：
- Express middleware 可以阻止请求，tool_call event 不能阻止调用
- tool_call event 是事件驱动，middleware 是链式调用

#### 日常生活类比

**工具使用前的安检**

想象你在机场安检：

```
1. 你准备登机（调用工具）
2. 安检员检查（tool_call event）
   - 记录：张三，13:45 通过安检
   - 检查：行李是否合规
   - 放行：可以登机
3. 你登机（工具执行）
```

`tool_call` event 就是这个安检过程。

---

### 9. ExtensionContext = Request context

#### TypeScript/Node.js 类比

```typescript
// Express Request context
app.use((req, res, next) => {
  req.user = { id: 123, name: 'Alice' };  // 添加用户信息
  req.logger = logger;  // 添加日志器
  next();
});

app.post('/api/data', (req, res) => {
  req.logger.info(`User ${req.user.name} accessed data`);
  // ...
});

// Pi-mono ExtensionContext
const execute = async (params, context) => {
  context.logger.info(`Tool called with params: ${JSON.stringify(params)}`);
  const history = context.session.get('history') || [];
  // ...
};
```

**相似点**：
- 都提供上下文信息
- 都可以访问共享资源（logger, session）
- 都在整个请求/调用周期内有效

**差异点**：
- Express context 是 `req` 对象，Pi-mono context 是 `ExtensionContext`
- ExtensionContext 提供 session、logger、registerTool 等 API

#### 日常生活类比

**工具执行的上下文环境**

想象你在厨房做饭：

```
上下文环境（ExtensionContext）：
  - 厨具：锅、铲、刀（工具）
  - 调料：盐、油、酱油（资源）
  - 菜谱：记录做过的菜（session）
  - 计时器：记录时间（logger）
```

做饭时你可以随时访问这些资源，`ExtensionContext` 就是这个厨房环境。

---

### 10. parameters = Query params / Request body

#### TypeScript/Node.js 类比

```typescript
// Express Query params
app.get('/api/search', (req, res) => {
  const { query, page, limit } = req.query;
  // ...
});

// Express Request body
app.post('/api/users', (req, res) => {
  const { name, email, age } = req.body;
  // ...
});

// Pi-mono parameters
parameters: Type.Object({
  query: Type.String(),
  page: Type.Optional(Type.Number()),
  limit: Type.Optional(Type.Number())
})
```

**相似点**：
- 都定义输入参数
- 都需要验证
- 都可以有可选参数

**差异点**：
- Express 参数来自 HTTP 请求，Pi-mono 参数来自 LLM
- Pi-mono 使用 TypeBox schema，Express 通常用 Joi/Zod

#### 日常生活类比

**工具的使用说明**

想象你买了一个电钻：

```
使用说明（parameters）：
  - 钻头类型：木工/金属/混凝土（必选）
  - 转速：500-3000 rpm（可选，默认1500）
  - 方向：正转/反转（可选，默认正转）
```

`parameters` 就是这些使用说明。

---

### 11. AbortSignal = Request timeout / cancellation

#### TypeScript/Node.js 类比

```typescript
// Fetch with AbortController
const controller = new AbortController();
setTimeout(() => controller.abort(), 5000);  // 5秒超时

fetch('https://api.example.com/data', {
  signal: controller.signal
}).catch(err => {
  if (err.name === 'AbortError') {
    console.log('Request cancelled');
  }
});

// Pi-mono execute with AbortSignal
const execute = async (params, context) => {
  const { signal } = context;

  const data = await fetch('https://api.example.com/data', {
    signal  // 传递 signal
  });

  if (signal.aborted) {
    return { content: 'Operation cancelled' };
  }

  return { content: data };
};
```

**相似点**：
- 都用于取消操作
- 都是标准的 AbortSignal API
- 都可以检查 `signal.aborted`

**差异点**：
- Fetch 的 signal 由用户创建，Pi-mono 的 signal 由框架提供
- Pi-mono 的 signal 在用户取消工具调用时触发

#### 日常生活类比

**紧急停止按钮**

想象你在使用洗衣机：

```
1. 启动洗衣（调用工具）
2. 洗衣进行中...
3. 你突然想起衣服里有钱包
4. 按下"紧急停止"按钮（AbortSignal）
5. 洗衣机立即停止
```

`AbortSignal` 就是这个紧急停止按钮。

---

### 12. onUpdate callback = Server-Sent Events (SSE)

#### TypeScript/Node.js 类比

```typescript
// Express SSE
app.get('/api/progress', (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');

  let progress = 0;
  const interval = setInterval(() => {
    progress += 10;
    res.write(`data: ${progress}%\n\n`);  // 发送进度

    if (progress >= 100) {
      clearInterval(interval);
      res.end();
    }
  }, 1000);
});

// Pi-mono onUpdate
const execute = async (params, context) => {
  const { onUpdate } = context;

  for (let i = 0; i <= 100; i += 10) {
    await sleep(1000);
    onUpdate?.({ content: `Progress: ${i}%` });  // 发送进度
  }

  return { content: 'Complete!' };
};
```

**相似点**：
- 都用于实时更新
- 都是流式传输
- 都可以多次发送数据

**差异点**：
- SSE 通过 HTTP 流，onUpdate 通过回调函数
- SSE 需要客户端监听，onUpdate 由框架处理

#### 日常生活类比

**实时进度通知**

想象你在下载大文件：

```
下载中... 10% ⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜
下载中... 30% ⬜⬜⬜⬛⬛⬛⬜⬜⬜⬜
下载中... 60% ⬜⬜⬜⬛⬛⬛⬛⬛⬛⬜
下载中... 100% ⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛
下载完成！
```

`onUpdate` 就是这个实时进度条。

---

## 综合类比：完整工具注册流程

### TypeScript/Node.js 类比

```typescript
// Express 应用
const app = express();

// 1. 定义路由（Tool Definition）
app.post('/api/weather', async (req, res) => {
  const { city } = req.body;
  const weather = await getWeather(city);
  res.json({ weather });
});

// 2. 注册中间件（registerTool）
app.use('/api', apiRouter);

// 3. 启动服务器（Extension activate）
app.listen(3000, () => {
  console.log('Server running');
});

// 4. 客户端调用（LLM 调用工具）
fetch('http://localhost:3000/api/weather', {
  method: 'POST',
  body: JSON.stringify({ city: 'Beijing' })
});
```

### Pi-mono 工具注册

```typescript
// 1. 定义工具（Tool Definition）
const weatherTool = {
  name: 'get-weather',
  description: 'Get weather',
  parameters: Type.Object({
    city: Type.String()
  }),
  execute: async ({ city }) => {
    const weather = await getWeather(city);
    return { content: weather };
  }
};

// 2. 注册工具（registerTool）
export const myExtension: Extension = {
  name: 'my-extension',
  async activate(context) {
    context.registerTool(weatherTool);
  }
};

// 3. Extension 加载（框架自动）
// 4. LLM 调用工具（自动）
```

### 日常生活类比

**开一家服务公司**

1. **定义服务**（Tool Definition）
   - 服务名称：快递配送
   - 服务描述：送货上门
   - 服务参数：地址、物品、时间
   - 服务流程：接单 → 取货 → 配送 → 签收

2. **注册服务**（registerTool）
   - 到工商局注册公司
   - 到平台注册服务（美团、饿了么）

3. **开始营业**（Extension activate）
   - 公司开始运营
   - 接受客户订单

4. **客户下单**（LLM 调用工具）
   - 客户在平台下单
   - 系统自动分配订单
   - 配送员执行配送

---

## 类比总结

| 维度 | TypeScript/Node.js | Pi-mono | 日常生活 |
|------|-------------------|---------|----------|
| **定义** | API 端点 | Tool Definition | 工具说明书 |
| **注册** | app.use() | registerTool | 服务台注册 |
| **验证** | Zod/Joi | TypeBox | 表单验证 |
| **执行** | Handler | execute | 工人干活 |
| **结果** | Response | AgentToolResult | 工作报告 |
| **调用** | HTTP 请求 | LLM 调用 | 客户下单 |
| **上下文** | req 对象 | ExtensionContext | 工作环境 |
| **取消** | AbortController | AbortSignal | 紧急停止 |
| **进度** | SSE | onUpdate | 进度条 |

---

## 记忆技巧

1. **Tool Definition = API 定义**：都是"如何调用"的说明书
2. **registerTool = 注册服务**：都是"让系统知道"的过程
3. **Schema = 表单验证**：都是"确保输入正确"的机制
4. **execute = 干活**：都是"实际执行"的逻辑
5. **AgentToolResult = 报告**：都是"告诉结果"的方式

通过这些类比，你可以快速理解 Pi-mono 的自定义工具注册机制！
