# 核心概念 02: 自定义编辑器

> **学习目标**: 深入理解 EditorComponent 接口和自定义编辑器开发
> **阅读时间**: 75 分钟
> **难度级别**: ⭐⭐⭐⭐ (进阶)

---

## 概述

**自定义编辑器**是 pi-mono 中实现灵活文本编辑的核心机制。通过 EditorComponent 接口，开发者可以实现任意复杂的编辑逻辑，从简单的单行输入到复杂的代码编辑器。

### 核心价值

**灵活性**: 满足不同场景的编辑需求
- 单行输入: 用户名、密码、搜索框
- 多行编辑: 消息输入、代码编辑
- 特殊编辑: 自动补全、语法高亮、错误提示

**可扩展性**: 通过接口实现，易于扩展
- 不需要继承复杂的基类
- 只需实现接口方法
- 可以组合不同的实现

### 本文内容

1. **EditorComponent 接口**: 完整的接口定义和设计哲学
2. **实现自定义编辑器**: 从简单到复杂的实现示例
3. **高级特性**: 语法高亮、自动补全、撤销/重做

---

## EditorComponent 接口

### 接口定义

**完整接口**:
```typescript
interface EditorComponent {
  // 渲染层: 如何展示
  render(ctx: RenderContext): Component;

  // 交互层: 如何响应
  handleKey(key: KeyEvent): boolean;
  handleMouse?(mouse: MouseEvent): boolean;

  // 状态层: 如何管理
  getValue(): string;
  setValue(value: string): void;

  // 生命周期: 如何初始化/清理
  mount?(): void;
  unmount?(): void;
}
```

**RenderContext**:
```typescript
interface RenderContext {
  width: number;   // 可用宽度
  height: number;  // 可用高度
  focused: boolean; // 是否聚焦
}
```

**KeyEvent**:
```typescript
interface KeyEvent {
  name: string;      // 按键名称: 'a', 'return', 'backspace', 'up', etc.
  sequence: string;  // 按键序列: 实际输入的字符
  ctrl: boolean;     // 是否按下 Ctrl
  meta: boolean;     // 是否按下 Meta (Cmd on macOS)
  shift: boolean;    // 是否按下 Shift
}
```

### 设计哲学: MVC 模式

**Model (状态层)**:
- `getValue()`: 获取编辑器的当前值
- `setValue(value)`: 设置编辑器的值

**View (渲染层)**:
- `render(ctx)`: 将状态转换为可视化组件

**Controller (交互层)**:
- `handleKey(key)`: 处理键盘输入
- `handleMouse(mouse)`: 处理鼠标输入

**好处**:
1. **分离关注点**: 每个部分职责清晰
2. **易于测试**: 可以独立测试每个方法
3. **易于扩展**: 只需实现接口，不需要继承

### 生命周期

**完整生命周期**:
```
mount()
  ↓
render loop:
  ├─ handleKey() / handleMouse()
  ├─ 更新状态
  ├─ render()
  └─ 重复
  ↓
unmount()
```

**mount()**: 编辑器挂载时调用
- 初始化资源
- 注册事件监听器
- 设置初始状态

**render loop**: 渲染循环
- 响应用户输入
- 更新内部状态
- 重新渲染

**unmount()**: 编辑器卸载时调用
- 清理资源
- 取消事件监听器
- 保存状态

### 方法详解

**render(ctx: RenderContext): Component**

**职责**: 将编辑器状态转换为可视化组件

**输入**: RenderContext (可用空间、聚焦状态)
**输出**: Component (可渲染的组件)

**示例**:
```typescript
render(ctx: RenderContext): Component {
  return Text({
    content: this.value,
    cursor: ctx.focused ? this.cursorPos : undefined
  });
}
```

**handleKey(key: KeyEvent): boolean**

**职责**: 处理键盘输入，更新编辑器状态

**输入**: KeyEvent (按键信息)
**输出**: boolean (是否已处理)

**返回值**:
- `true`: 已处理，停止事件传播
- `false`: 未处理，继续传播给父组件

**示例**:
```typescript
handleKey(key: KeyEvent): boolean {
  if (key.name === 'return') {
    // 提交输入
    this.onSubmit(this.value);
    return true;  // 已处理
  }

  if (key.name === 'escape') {
    // 取消输入
    return false;  // 未处理，传播给父组件
  }

  // 插入字符
  if (key.sequence && !key.ctrl && !key.meta) {
    this.value += key.sequence;
    return true;
  }

  return false;
}
```

**getValue(): string**

**职责**: 获取编辑器的当前值

**输出**: string (编辑器内容)

**示例**:
```typescript
getValue(): string {
  return this.value;
}
```

**setValue(value: string): void**

**职责**: 设置编辑器的值

**输入**: string (新值)

**示例**:
```typescript
setValue(value: string): void {
  this.value = value;
  this.cursorPos = value.length;  // 光标移到末尾
}
```

---

## 实现自定义编辑器

### 示例 1: 简单文本编辑器

**需求**: 单行文本输入，支持基本编辑

**实现**:
```typescript
class SimpleTextEditor implements EditorComponent {
  private value: string = '';
  private cursorPos: number = 0;

  render(ctx: RenderContext): Component {
    return Text({
      content: this.value,
      cursor: ctx.focused ? this.cursorPos : undefined
    });
  }

  handleKey(key: KeyEvent): boolean {
    switch (key.name) {
      case 'backspace':
        if (this.cursorPos > 0) {
          this.value = this.value.slice(0, this.cursorPos - 1) +
                       this.value.slice(this.cursorPos);
          this.cursorPos--;
        }
        return true;

      case 'delete':
        if (this.cursorPos < this.value.length) {
          this.value = this.value.slice(0, this.cursorPos) +
                       this.value.slice(this.cursorPos + 1);
        }
        return true;

      case 'left':
        if (this.cursorPos > 0) {
          this.cursorPos--;
        }
        return true;

      case 'right':
        if (this.cursorPos < this.value.length) {
          this.cursorPos++;
        }
        return true;

      case 'home':
        this.cursorPos = 0;
        return true;

      case 'end':
        this.cursorPos = this.value.length;
        return true;

      default:
        // 插入字符
        if (key.sequence && !key.ctrl && !key.meta) {
          this.value = this.value.slice(0, this.cursorPos) +
                       key.sequence +
                       this.value.slice(this.cursorPos);
          this.cursorPos += key.sequence.length;
          return true;
        }
        return false;
    }
  }

  getValue(): string {
    return this.value;
  }

  setValue(value: string): void {
    this.value = value;
    this.cursorPos = value.length;
  }
}
```

**特点**:
- 支持基本的光标移动 (左、右、Home、End)
- 支持删除 (Backspace、Delete)
- 支持字符插入

### 示例 2: 多行编辑器

**需求**: 多行文本编辑，支持滚动

**状态设计**:
```typescript
class MultiLineEditor implements EditorComponent {
  private lines: string[] = [''];  // 按行存储
  private cursorRow: number = 0;   // 光标行
  private cursorCol: number = 0;   // 光标列
  private scrollOffset: number = 0; // 滚动偏移
  private maxHeight: number = 10;   // 可视区域高度
}
```

**渲染逻辑**:
```typescript
render(ctx: RenderContext): Component {
  this.maxHeight = ctx.height;

  // 计算可视区域
  const visibleLines = this.lines.slice(
    this.scrollOffset,
    this.scrollOffset + this.maxHeight
  );

  // 渲染每一行
  return Box({
    children: visibleLines.map((line, i) => {
      const actualRow = this.scrollOffset + i;
      const showCursor = ctx.focused && actualRow === this.cursorRow;

      return Text({
        content: line,
        cursor: showCursor ? this.cursorCol : undefined
      });
    })
  });
}
```

**输入处理**:
```typescript
handleKey(key: KeyEvent): boolean {
  switch (key.name) {
    case 'return':
      // 插入新行
      const currentLine = this.lines[this.cursorRow];
      this.lines[this.cursorRow] = currentLine.slice(0, this.cursorCol);
      this.lines.splice(
        this.cursorRow + 1,
        0,
        currentLine.slice(this.cursorCol)
      );
      this.cursorRow++;
      this.cursorCol = 0;
      this.updateScroll();
      return true;

    case 'backspace':
      if (this.cursorCol > 0) {
        // 删除当前行的字符
        const line = this.lines[this.cursorRow];
        this.lines[this.cursorRow] =
          line.slice(0, this.cursorCol - 1) + line.slice(this.cursorCol);
        this.cursorCol--;
      } else if (this.cursorRow > 0) {
        // 合并到上一行
        const currentLine = this.lines[this.cursorRow];
        this.cursorRow--;
        this.cursorCol = this.lines[this.cursorRow].length;
        this.lines[this.cursorRow] += currentLine;
        this.lines.splice(this.cursorRow + 1, 1);
        this.updateScroll();
      }
      return true;

    case 'up':
      if (this.cursorRow > 0) {
        this.cursorRow--;
        this.cursorCol = Math.min(
          this.cursorCol,
          this.lines[this.cursorRow].length
        );
        this.updateScroll();
      }
      return true;

    case 'down':
      if (this.cursorRow < this.lines.length - 1) {
        this.cursorRow++;
        this.cursorCol = Math.min(
          this.cursorCol,
          this.lines[this.cursorRow].length
        );
        this.updateScroll();
      }
      return true;

    case 'left':
      if (this.cursorCol > 0) {
        this.cursorCol--;
      } else if (this.cursorRow > 0) {
        // 移到上一行末尾
        this.cursorRow--;
        this.cursorCol = this.lines[this.cursorRow].length;
        this.updateScroll();
      }
      return true;

    case 'right':
      if (this.cursorCol < this.lines[this.cursorRow].length) {
        this.cursorCol++;
      } else if (this.cursorRow < this.lines.length - 1) {
        // 移到下一行开头
        this.cursorRow++;
        this.cursorCol = 0;
        this.updateScroll();
      }
      return true;

    default:
      // 插入字符
      if (key.sequence && !key.ctrl && !key.meta) {
        const line = this.lines[this.cursorRow];
        this.lines[this.cursorRow] =
          line.slice(0, this.cursorCol) +
          key.sequence +
          line.slice(this.cursorCol);
        this.cursorCol += key.sequence.length;
        return true;
      }
      return false;
  }
}
```

**滚动管理**:
```typescript
private updateScroll(): void {
  // 确保光标在可视区域内
  if (this.cursorRow < this.scrollOffset) {
    // 光标在可视区域上方，向上滚动
    this.scrollOffset = this.cursorRow;
  } else if (this.cursorRow >= this.scrollOffset + this.maxHeight) {
    // 光标在可视区域下方，向下滚动
    this.scrollOffset = this.cursorRow - this.maxHeight + 1;
  }
}
```

**状态管理**:
```typescript
getValue(): string {
  return this.lines.join('\n');
}

setValue(value: string): void {
  this.lines = value.split('\n');
  if (this.lines.length === 0) {
    this.lines = [''];
  }
  this.cursorRow = 0;
  this.cursorCol = 0;
  this.scrollOffset = 0;
}
```

**特点**:
- 支持多行编辑
- 支持滚动 (自动跟随光标)
- 支持跨行光标移动
- 支持行合并和分割

---

## 高级特性

### 特性 1: 撤销/重做

**实现思路**: 维护历史栈

**状态设计**:
```typescript
interface EditorState {
  lines: string[];
  cursorRow: number;
  cursorCol: number;
}

class UndoableEditor extends MultiLineEditor {
  private history: EditorState[] = [];
  private historyIndex: number = -1;
  private maxHistory: number = 100;

  private saveState(): void {
    // 移除当前位置之后的历史
    this.history = this.history.slice(0, this.historyIndex + 1);

    // 保存当前状态
    this.history.push({
      lines: [...this.lines],
      cursorRow: this.cursorRow,
      cursorCol: this.cursorCol
    });

    // 限制历史大小
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    } else {
      this.historyIndex++;
    }
  }

  private restoreState(state: EditorState): void {
    this.lines = [...state.lines];
    this.cursorRow = state.cursorRow;
    this.cursorCol = state.cursorCol;
    this.updateScroll();
  }

  handleKey(key: KeyEvent): boolean {
    // Ctrl+Z: 撤销
    if (key.ctrl && key.name === 'z' && !key.shift) {
      if (this.historyIndex > 0) {
        this.historyIndex--;
        this.restoreState(this.history[this.historyIndex]);
      }
      return true;
    }

    // Ctrl+Shift+Z 或 Ctrl+Y: 重做
    if ((key.ctrl && key.name === 'z' && key.shift) ||
        (key.ctrl && key.name === 'y')) {
      if (this.historyIndex < this.history.length - 1) {
        this.historyIndex++;
        this.restoreState(this.history[this.historyIndex]);
      }
      return true;
    }

    // 其他按键: 保存状态后处理
    const handled = super.handleKey(key);
    if (handled && this.isModifyingKey(key)) {
      this.saveState();
    }
    return handled;
  }

  private isModifyingKey(key: KeyEvent): boolean {
    return key.name === 'return' ||
           key.name === 'backspace' ||
           key.name === 'delete' ||
           (key.sequence && !key.ctrl && !key.meta);
  }
}
```

### 特性 2: 自动补全

**实现思路**: 检测触发条件，显示补全菜单

**状态设计**:
```typescript
interface Completion {
  text: string;
  description?: string;
}

class AutocompleteEditor extends MultiLineEditor {
  private completions: Completion[] = [];
  private selectedCompletion: number = 0;
  private showCompletions: boolean = false;

  render(ctx: RenderContext): Component {
    const editorComponent = super.render(ctx);

    if (!this.showCompletions || this.completions.length === 0) {
      return editorComponent;
    }

    // 显示补全菜单
    const menu = Box({
      border: 'single',
      children: this.completions.map((completion, i) => {
        const selected = i === this.selectedCompletion;
        return Text({
          content: selected ? `> ${completion.text}` : `  ${completion.text}`,
          style: selected ? { bold: true } : {}
        });
      })
    });

    return Box({
      children: [editorComponent, menu]
    });
  }

  handleKey(key: KeyEvent): boolean {
    // 补全菜单打开时的特殊处理
    if (this.showCompletions) {
      switch (key.name) {
        case 'up':
          this.selectedCompletion = Math.max(0, this.selectedCompletion - 1);
          return true;

        case 'down':
          this.selectedCompletion = Math.min(
            this.completions.length - 1,
            this.selectedCompletion + 1
          );
          return true;

        case 'tab':
        case 'return':
          this.applyCompletion(this.completions[this.selectedCompletion]);
          this.showCompletions = false;
          return true;

        case 'escape':
          this.showCompletions = false;
          return true;
      }
    }

    // 正常处理
    const handled = super.handleKey(key);

    // 检测是否需要触发补全
    if (handled && this.shouldTriggerCompletion(key)) {
      this.triggerCompletion();
    }

    return handled;
  }

  private shouldTriggerCompletion(key: KeyEvent): boolean {
    // 输入字符时触发
    return key.sequence && !key.ctrl && !key.meta;
  }

  private triggerCompletion(): void {
    const currentLine = this.lines[this.cursorRow];
    const prefix = currentLine.slice(0, this.cursorCol);

    // 获取补全建议
    this.completions = this.getCompletions(prefix);
    this.selectedCompletion = 0;
    this.showCompletions = this.completions.length > 0;
  }

  private getCompletions(prefix: string): Completion[] {
    // 实现补全逻辑
    // 这里可以调用 LSP、查询数据库等
    return [];
  }

  private applyCompletion(completion: Completion): void {
    // 应用补全
    const currentLine = this.lines[this.cursorRow];
    const prefix = currentLine.slice(0, this.cursorCol);
    const suffix = currentLine.slice(this.cursorCol);

    // 找到需要替换的部分
    const words = prefix.split(/\s+/);
    const lastWord = words[words.length - 1];
    const replaceStart = this.cursorCol - lastWord.length;

    this.lines[this.cursorRow] =
      currentLine.slice(0, replaceStart) +
      completion.text +
      suffix;

    this.cursorCol = replaceStart + completion.text.length;
  }
}
```

### 特性 3: 语法高亮

**实现思路**: 在渲染时应用颜色

**实现**:
```typescript
interface Token {
  type: 'keyword' | 'string' | 'comment' | 'number' | 'identifier';
  text: string;
}

class SyntaxHighlightEditor extends MultiLineEditor {
  private language: string = 'typescript';

  render(ctx: RenderContext): Component {
    this.maxHeight = ctx.height;

    const visibleLines = this.lines.slice(
      this.scrollOffset,
      this.scrollOffset + this.maxHeight
    );

    return Box({
      children: visibleLines.map((line, i) => {
        const actualRow = this.scrollOffset + i;
        const showCursor = ctx.focused && actualRow === this.cursorRow;

        // 语法高亮
        const tokens = this.tokenize(line);
        const highlightedContent = this.highlight(tokens);

        return Text({
          content: highlightedContent,
          cursor: showCursor ? this.cursorCol : undefined
        });
      })
    });
  }

  private tokenize(line: string): Token[] {
    // 简化的词法分析
    const tokens: Token[] = [];
    const keywords = ['function', 'const', 'let', 'var', 'if', 'else', 'return'];

    // 这里应该使用真正的词法分析器
    // 简化示例:
    const words = line.split(/(\s+)/);
    for (const word of words) {
      if (keywords.includes(word)) {
        tokens.push({ type: 'keyword', text: word });
      } else if (word.match(/^["'].*["']$/)) {
        tokens.push({ type: 'string', text: word });
      } else if (word.match(/^\/\//)) {
        tokens.push({ type: 'comment', text: word });
      } else if (word.match(/^\d+$/)) {
        tokens.push({ type: 'number', text: word });
      } else {
        tokens.push({ type: 'identifier', text: word });
      }
    }

    return tokens;
  }

  private highlight(tokens: Token[]): string {
    // 应用 ANSI 颜色
    const colors = {
      keyword: '\x1b[35m',    // 紫色
      string: '\x1b[32m',     // 绿色
      comment: '\x1b[90m',    // 灰色
      number: '\x1b[33m',     // 黄色
      identifier: '\x1b[37m'  // 白色
    };
    const reset = '\x1b[0m';

    return tokens.map(token =>
      colors[token.type] + token.text + reset
    ).join('');
  }
}
```

---

## 总结

### 核心要点

**EditorComponent 接口**:
- **MVC 模式**: Model (getValue/setValue), View (render), Controller (handleKey)
- **生命周期**: mount → render loop → unmount
- **返回值**: handleKey 返回 boolean 表示是否已处理

**实现策略**:
- **简单编辑器**: 单行输入，基本光标移动
- **多行编辑器**: 按行存储，滚动管理
- **高级特性**: 撤销/重做、自动补全、语法高亮

**设计原则**:
- **分离关注点**: 渲染、交互、状态各司其职
- **接口优先**: 通过接口实现，不依赖继承
- **可组合性**: 可以组合不同的特性

### 关键洞察

1. **状态设计是关键**: 选择合适的数据结构（按行 vs 单字符串）
2. **滚动管理很重要**: 确保光标始终在可视区域内
3. **历史管理需要权衡**: 内存占用 vs 撤销深度
4. **补全需要异步**: 避免阻塞主线程

### 下一步

- **深入学习**: 阅读 **03_核心概念_03_Widget系统.md**
- **实战练习**: 阅读 **07_实战代码_02_自定义编辑器开发.md**
- **源码参考**: `sourcecode/pi-mono/packages/tui/src/components/editor.ts`

---

**版本**: v1.0
**最后更新**: 2026-02-21
**维护者**: Claude Code
