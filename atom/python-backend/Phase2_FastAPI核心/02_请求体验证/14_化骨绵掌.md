# 化骨绵掌

> 10个2分钟知识卡片，深度掌握请求体验证

---

## 卡片1：Pydantic 的核心设计哲学

**一句话：** Pydantic 将数据验证规则与数据定义统一，通过类型注解实现声明式验证。

**核心观点：**

传统验证方式：数据定义和验证逻辑分离
```python
# 传统方式
class User:
    def __init__(self, username, email, age):
        self.username = username
        self.email = email
        self.age = age

def validate_user(user):
    if not isinstance(user.username, str):
        raise TypeError()
    if len(user.username) < 3:
        raise ValueError()
    # ... 更多验证逻辑
```

Pydantic 方式：数据定义即验证规则
```python
# Pydantic 方式
from pydantic import BaseModel, Field

class User(BaseModel):
    username: str = Field(min_length=3)  # 定义即验证
    email: str
    age: int
```

**应用：** 在 AI Agent 开发中，这种设计让 API 接口定义更清晰，验证逻辑更集中，减少了样板代码。

---

## 卡片2：FastAPI 的自动验证机制

**一句话：** FastAPI 通过类型注解自动触发 Pydantic 验证，无需手动调用。

**工作流程：**

```
1. 请求到达 FastAPI
   ↓
2. FastAPI 解析请求体（JSON → dict）
   ↓
3. 检查路由函数的类型注解
   ↓
4. 发现 Pydantic BaseModel 类型
   ↓
5. 自动调用 Pydantic 验证
   ↓
6. 验证成功 → 调用路由函数
   验证失败 → 返回 422 错误
```

**代码示例：**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class User(BaseModel):
    username: str
    age: int

@app.post("/users")
async def create_user(user: User):  # 类型注解触发验证
    # 如果执行到这里，user 一定有效
    return {"username": user.username}
```

**应用：** 零配置的自动验证，开发者只需要定义数据模型，FastAPI 自动处理验证和错误响应。

---

## 卡片3：Field 的约束系统

**一句话：** Field 提供了丰富的约束选项，覆盖字符串、数字、集合等类型的常见验证需求。

**常用约束分类：**

**字符串约束：**
```python
from pydantic import BaseModel, Field

class User(BaseModel):
    username: str = Field(
        min_length=3,           # 最小长度
        max_length=20,          # 最大长度
        pattern=r'^[a-zA-Z0-9]+$'  # 正则表达式
    )
```

**数字约束：**
```python
class Product(BaseModel):
    price: float = Field(
        gt=0,        # 大于（greater than）
        le=10000     # 小于等于（less or equal）
    )
    quantity: int = Field(
        ge=1,        # 大于等于（greater or equal）
        lt=1000      # 小于（less than）
    )
```

**集合约束：**
```python
from typing import List

class Post(BaseModel):
    tags: List[str] = Field(
        min_items=1,    # 最少元素数
        max_items=10    # 最多元素数
    )
```

**应用：** 在 RAG 系统中，用 Field 约束确保 `top_k` 在 1-20 之间，`threshold` 在 0-1 之间，防止无效参数。

---

## 卡片4：类型强制转换（Type Coercion）

**一句话：** Pydantic 会尝试将输入数据转换为目标类型，而不是直接拒绝。

**转换规则：**

```python
from pydantic import BaseModel

class User(BaseModel):
    age: int
    is_active: bool

# 字符串 → 整数
user1 = User(age="25", is_active="true")
print(user1.age)        # 25 (int)
print(user1.is_active)  # True (bool)

# 浮点数 → 整数（截断）
user2 = User(age=25.9, is_active=1)
print(user2.age)        # 25 (int)
print(user2.is_active)  # True (bool)
```

**转换失败的情况：**

```python
# 无法转换的字符串 → 抛出异常
user3 = User(age="not-a-number", is_active="yes")
# ValidationError: value is not a valid integer
```

**应用：** 这让 API 更宽容，前端传递 `"25"` 而不是 `25` 也能正常工作，减少了类型错误。

---

## 卡片5：嵌套模型的递归验证

**一句话：** Pydantic 自动递归验证嵌套模型，确保整个数据结构的正确性。

**示例：**

```python
from pydantic import BaseModel, Field
from typing import List

class Address(BaseModel):
    street: str = Field(min_length=1)
    city: str = Field(min_length=1)
    country: str = Field(min_length=2, max_length=2)  # 国家代码

class User(BaseModel):
    username: str
    addresses: List[Address]  # 地址列表

# 验证过程
user = User(
    username="alice",
    addresses=[
        {"street": "123 Main St", "city": "NYC", "country": "US"},
        {"street": "456 Oak Ave", "city": "LA", "country": "US"}
    ]
)

# Pydantic 会：
# 1. 验证 User 的 username
# 2. 验证 addresses 是列表
# 3. 对每个地址元素：
#    - 验证是对象
#    - 验证 street、city、country 字段
#    - 验证每个字段的约束
```

**错误定位：**

```python
# 如果第二个地址的 country 错误
user = User(
    username="alice",
    addresses=[
        {"street": "123 Main St", "city": "NYC", "country": "US"},
        {"street": "456 Oak Ave", "city": "LA", "country": "USA"}  # 错误：3个字符
    ]
)
# 错误信息会精确定位：addresses[1].country
```

**应用：** 在 AI Agent 配置中，可以验证复杂的嵌套配置（如工具列表、每个工具的参数）。

---

## 卡片6：validator 的执行时机和顺序

**一句话：** validator 在字段类型验证和 Field 约束验证之后执行，可以访问已验证的字段值。

**执行顺序：**

```python
from pydantic import BaseModel, Field, validator

class User(BaseModel):
    username: str = Field(min_length=3)  # 步骤2：Field 约束
    email: str                            # 步骤1：类型验证
    age: int

    @validator('username')  # 步骤3：validator
    def username_alphanumeric(cls, v):
        if not v.isalnum():
            raise ValueError('must be alphanumeric')
        return v

    @validator('email')  # 步骤3：validator
    def email_must_contain_at(cls, v):
        if '@' not in v:
            raise ValueError('must contain @')
        return v
```

**完整流程：**

```
输入：{"username": "ab", "email": "invalid", "age": "25"}
   ↓
步骤1：类型验证
  - username: str ✅
  - email: str ✅
  - age: "25" → 25 (int) ✅
   ↓
步骤2：Field 约束验证
  - username: min_length=3 ❌ 失败！
  （后续步骤不执行）
```

**validator 可以访问其他字段：**

```python
class User(BaseModel):
    password: str
    confirm_password: str

    @validator('confirm_password')
    def passwords_match(cls, v, values):
        # values 包含已验证的字段
        if 'password' in values and v != values['password']:
            raise ValueError('passwords do not match')
        return v
```

**应用：** 在 RAG 配置中，验证 `bm25_weight + vector_weight = 1.0` 这种跨字段约束。

---

## 卡片7：root_validator 的两种模式

**一句话：** root_validator 有 `pre=True` 和 `pre=False` 两种模式，分别在字段验证前后执行。

**pre=False（默认）：在所有字段验证后执行**

```python
from pydantic import BaseModel, root_validator

class DateRange(BaseModel):
    start_date: str
    end_date: str

    @root_validator  # 默认 pre=False
    def check_date_range(cls, values):
        # 此时所有字段已验证完成
        start = values.get('start_date')
        end = values.get('end_date')
        if start and end and start > end:
            raise ValueError('start_date must be before end_date')
        return values
```

**pre=True：在字段验证前执行（原始数据）**

```python
class User(BaseModel):
    username: str
    email: str

    @root_validator(pre=True)
    def normalize_data(cls, values):
        # 此时 values 是原始 dict，字段可能不存在或类型错误
        if isinstance(values, dict):
            # 数据预处理
            if 'username' in values:
                values['username'] = values['username'].lower()
        return values
```

**使用场景对比：**

| 模式 | 使用场景 | 数据状态 |
|------|---------|---------|
| `pre=False` | 跨字段验证、业务规则 | 已验证，类型正确 |
| `pre=True` | 数据预处理、格式转换 | 原始数据，可能不完整 |

**应用：** 在 AI Agent 配置中，用 `pre=True` 统一处理配置格式（如将所有键转为小写），用 `pre=False` 验证配置的一致性。

---

## 卡片8：response_model 的三个作用

**一句话：** response_model 不仅生成文档，还真实地过滤和验证响应数据。

**作用1：过滤字段**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class UserIn(BaseModel):
    username: str
    email: str
    password: str

class UserOut(BaseModel):
    username: str
    email: str
    # 没有 password

@app.post("/users", response_model=UserOut)
async def create_user(user: UserIn):
    # 返回 UserIn（包含 password）
    return user

# 实际响应（password 被自动过滤）
# {"username": "alice", "email": "alice@example.com"}
```

**作用2：验证响应**

```python
@app.get("/users/{user_id}", response_model=UserOut)
async def get_user(user_id: int):
    # 如果返回的数据不符合 UserOut，FastAPI 会抛出错误
    return {"username": "alice"}  # ❌ 缺少 email，会报错
```

**作用3：生成文档**

```python
# OpenAPI 文档会显示：
# Response Schema:
# {
#   "username": "string",
#   "email": "string"
# }
```

**高级选项：**

```python
@app.get(
    "/users/{user_id}",
    response_model=UserOut,
    response_model_exclude_none=True,  # 过滤 None 值
    response_model_exclude_unset=True  # 过滤未设置的字段
)
async def get_user(user_id: int):
    return {"username": "alice", "email": "alice@example.com", "bio": None}
# 实际响应：{"username": "alice", "email": "alice@example.com"}
```

**应用：** 在 AI Agent API 中，用 response_model 保护 API 密钥、数据库连接字符串等敏感信息。

---

## 卡片9：验证错误的结构和自定义

**一句话：** Pydantic 的验证错误有标准结构，可以自定义错误消息和格式。

**标准错误结构：**

```python
from pydantic import BaseModel, Field, ValidationError

class User(BaseModel):
    username: str = Field(min_length=3)
    age: int = Field(ge=0, le=150)

try:
    user = User(username="ab", age=200)
except ValidationError as e:
    print(e.json())

# 输出：
# [
#   {
#     "loc": ["username"],              # 错误位置
#     "msg": "ensure this value has at least 3 characters",  # 错误消息
#     "type": "value_error.any_str.min_length",  # 错误类型
#     "ctx": {"limit_value": 3}         # 上下文信息
#   },
#   {
#     "loc": ["age"],
#     "msg": "ensure this value is less than or equal to 150",
#     "type": "value_error.number.not_le",
#     "ctx": {"limit_value": 150}
#   }
# ]
```

**自定义错误消息：**

```python
from pydantic import BaseModel, Field, validator

class User(BaseModel):
    username: str = Field(
        min_length=3,
        max_length=20,
        description="用户名（3-20个字符）"
    )

    @validator('username')
    def username_alphanumeric(cls, v):
        if not v.isalnum():
            raise ValueError('用户名只能包含字母和数字')  # 自定义消息
        return v
```

**FastAPI 的自动错误响应：**

```python
# 请求
POST /users
{"username": "ab", "age": 200}

# 自动响应（422）
{
  "detail": [
    {
      "loc": ["body", "username"],
      "msg": "ensure this value has at least 3 characters",
      "type": "value_error.any_str.min_length"
    },
    {
      "loc": ["body", "age"],
      "msg": "ensure this value is less than or equal to 150",
      "type": "value_error.number.not_le"
    }
  ]
}
```

**应用：** 在 AI Agent API 中，清晰的错误消息帮助前端快速定位问题，提升开发效率。

---

## 卡片10：性能优化和最佳实践

**一句话：** 合理使用 Pydantic 验证，避免过度验证和重复验证。

**最佳实践1：只在系统边界验证**

```python
# ✅ 好的做法
@app.post("/users")
async def create_user(user: UserIn):  # API 入口验证
    # 内部函数调用不需要重复验证
    user_id = await save_user_to_db(user.dict())  # 传递 dict
    await send_welcome_email(user.email)  # 传递字段值
    return {"id": user_id}

# ❌ 不好的做法
async def save_user_to_db(user: UserIn):  # 重复验证
    # user 已经在 API 入口验证过了
    ...
```

**最佳实践2：使用 Pydantic V2**

```python
# Pydantic V2 性能提升 5-50 倍
from pydantic import BaseModel, ConfigDict

class User(BaseModel):
    model_config = ConfigDict(
        # 禁用赋值时验证（如果不需要）
        validate_assignment=False,
        # 使用属性访问而不是 __getattr__（更快）
        use_attribute_docstrings=True
    )
    username: str
    email: str
```

**最佳实践3：缓存验证结果**

```python
from functools import lru_cache
from pydantic import BaseModel

class Config(BaseModel):
    api_key: str
    model: str
    temperature: float

@lru_cache(maxsize=1)
def get_config() -> Config:
    # 配置文件只验证一次
    return Config.parse_file("config.json")

# 多次调用，只验证一次
config1 = get_config()
config2 = get_config()  # 使用缓存
```

**最佳实践4：避免过度嵌套**

```python
# ❌ 过度嵌套（验证开销大）
class Level4(BaseModel):
    value: str

class Level3(BaseModel):
    items: List[Level4]

class Level2(BaseModel):
    items: List[Level3]

class Level1(BaseModel):
    items: List[Level2]

# ✅ 扁平化设计
class Item(BaseModel):
    level: int
    value: str

class Data(BaseModel):
    items: List[Item]
```

**最佳实践5：使用 model_validate 而不是 __init__**

```python
from pydantic import BaseModel

class User(BaseModel):
    username: str
    email: str

# ✅ 推荐（利用 Pydantic 内部缓存）
user = User.model_validate({"username": "alice", "email": "alice@example.com"})

# ❌ 不推荐（每次都创建新实例）
user = User(**{"username": "alice", "email": "alice@example.com"})
```

**应用：** 在高并发的 AI Agent API 中，这些优化可以显著提升性能，减少验证开销。

---

## 知识卡片总结

| 卡片 | 核心主题 | 关键要点 |
|------|---------|---------|
| 1 | 设计哲学 | 数据定义即验证规则 |
| 2 | 自动验证 | 类型注解触发验证 |
| 3 | Field 约束 | 丰富的约束选项 |
| 4 | 类型转换 | 自动强制转换 |
| 5 | 嵌套验证 | 递归验证整个结构 |
| 6 | validator | 执行时机和顺序 |
| 7 | root_validator | pre=True/False 两种模式 |
| 8 | response_model | 过滤、验证、文档 |
| 9 | 验证错误 | 标准结构和自定义 |
| 10 | 性能优化 | 最佳实践 |

---

## 学习检查清单

完成这10个知识卡片后，你应该能够：

- [ ] 理解 Pydantic 的设计哲学和核心机制
- [ ] 掌握 Field 的各种约束选项
- [ ] 理解类型强制转换的规则
- [ ] 使用嵌套模型验证复杂数据结构
- [ ] 编写 validator 和 root_validator
- [ ] 使用 response_model 保护敏感信息
- [ ] 理解验证错误的结构
- [ ] 应用性能优化最佳实践

---

## 下一步学习

- **深入 Pydantic**：学习更多高级特性（Union、Literal、Discriminated Union）
- **FastAPI 进阶**：学习依赖注入、中间件、异常处理
- **实战项目**：构建一个完整的 AI Agent API

---

**版本：** v1.0
**最后更新：** 2026-02-11
