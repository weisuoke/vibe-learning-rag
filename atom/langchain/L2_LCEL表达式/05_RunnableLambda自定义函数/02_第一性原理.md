# 02_第一性原理

> **本文档从第一性原理出发，推导 RunnableLambda 的设计必然性和核心价值。**

---

## 什么是第一性原理

**第一性原理思维**：回到事物最基本的条件，从最底层的真理开始推导，而不是通过类比或经验。

在理解 RunnableLambda 时，我们要问：
- 最基础的事实是什么？
- 为什么必须存在这样的机制？
- 如果从零开始设计，会得出什么结论？

---

## 推理链：从函数到 RunnableLambda

### 第一层：函数是一等公民

**基础事实 1：Python 中函数是一等公民**

```python
# 函数可以赋值给变量
def add(a, b):
    return a + b

func = add  # 函数是对象

# 函数可以作为参数传递
def apply(func, x, y):
    return func(x, y)

result = apply(add, 1, 2)  # 3

# 函数可以作为返回值
def make_adder(n):
    def adder(x):
        return x + n
    return adder

add_5 = make_adder(5)
add_5(3)  # 8
```

**推论 1：函数是可组合的基本单元**
- 函数可以传递、组合、嵌套
- 函数式编程的基础

---

### 第二层：需要统一的组合接口

**基础事实 2：LangChain 需要统一的组合机制**

在 LangChain 中，我们有各种组件：
- ChatModel（大模型）
- PromptTemplate（提示模板）
- OutputParser（输出解析器）
- Retriever（检索器）
- ...

**问题：如何让这些组件无缝组合？**

**方案 1：每个组件自己实现组合逻辑** ❌
```python
# 每个组件都要实现自己的组合方法
prompt.then(model).then(parser)  # PromptTemplate 的方式
model.pipe(parser)  # ChatModel 的方式
parser.compose(model)  # OutputParser 的方式
```

**缺点：**
- 不同组件的组合方式不一致
- 难以学习和记忆
- 难以扩展

**方案 2：定义统一的接口协议** ✅
```python
# 所有组件都实现 Runnable 接口
class Runnable:
    def invoke(self, input):
        """同步调用"""
        pass

    def batch(self, inputs):
        """批量调用"""
        pass

    def stream(self, input):
        """流式调用"""
        pass

    def __or__(self, other):
        """支持 | 操作符组合"""
        return RunnableSequence(self, other)
```

**优点：**
- 统一的调用方式：`invoke`、`batch`、`stream`
- 统一的组合方式：`|` 操作符
- 易于学习和扩展

**推论 2：需要 Runnable 协议作为统一接口**

---

### 第三层：自定义逻辑的困境

**基础事实 3：内置组件无法覆盖所有需求**

LangChain 提供了很多内置组件，但总有特殊需求：

```python
# 场景1: 特殊的数据预处理
def clean_text(text: str) -> str:
    # 业务特定的清洗逻辑
    text = text.strip().lower()
    text = re.sub(r'[^\w\s]', '', text)
    return text

# 场景2: 特殊的格式转换
def parse_custom_format(data: dict) -> str:
    # 业务特定的格式转换
    return f"{data['name']}: {data['value']}"

# 场景3: 外部系统集成
def call_legacy_api(query: str) -> dict:
    # 调用遗留系统的 API
    return requests.post(LEGACY_API_URL, json={"query": query}).json()
```

**问题：如何让这些自定义函数融入 LCEL 链？**

**方案 1：直接调用函数** ❌
```python
# 无法使用 | 操作符
text = clean_text(input_text)
result = model.invoke(text)
output = parse_custom_format(result)
```

**缺点：**
- 无法与 Runnable 组件组合
- 无法使用 batch、stream 等方法
- 无法获得重试、回调等特性

**方案 2：为每个函数创建自定义 Runnable 类** ❌
```python
class CleanTextRunnable(Runnable):
    def invoke(self, input):
        return clean_text(input)

    def batch(self, inputs):
        return [clean_text(x) for x in inputs]

    # ... 还要实现其他方法
```

**缺点：**
- 太繁琐，每个函数都要写一个类
- 大量样板代码
- 不够灵活

**方案 3：提供适配器自动转换** ✅
```python
# 一行代码将函数转换为 Runnable
runnable = RunnableLambda(clean_text)

# 现在可以组合了
chain = RunnableLambda(clean_text) | model | RunnableLambda(parse_custom_format)
```

**优点：**
- 简单：一行代码搞定
- 灵活：任何函数都能转换
- 统一：获得 Runnable 的所有能力

**推论 3：需要适配器将函数转换为 Runnable**

---

### 第四层：RunnableLambda 的必然性

**从第一性原理推导：**

```
前提1: Python 函数是一等公民（可传递、可组合）
前提2: LangChain 需要统一的 Runnable 接口
前提3: 自定义逻辑无法用内置组件表达

推导:
1. 函数是最灵活的逻辑表达方式
2. 但函数不符合 Runnable 接口
3. 需要一个机制将函数转换为 Runnable
4. 这个机制就是适配器模式

结论: RunnableLambda 是必然的设计选择
```

**RunnableLambda 的本质：**
- **适配器**：连接函数和 Runnable 的桥梁
- **包装器**：不改变函数，只是加一层外壳
- **转换器**：将函数的调用方式转换为 Runnable 的调用方式

---

## 三层价值分析

### 价值层 1：灵活性

**问题：如何在 LangChain 中实现任意自定义逻辑？**

**RunnableLambda 的解决方案：**
```python
# 任何 Python 代码都能加入链
def custom_logic(input):
    # 你的任意逻辑
    return process(input)

chain = prompt | model | RunnableLambda(custom_logic) | parser
```

**价值：**
- 不受框架限制
- 完全自定义的处理逻辑
- 可以集成任何第三方库或服务

**类比：**
- 就像 Express 中间件，可以插入任意逻辑
- 就像 Unix 管道，可以组合任意命令

---

### 价值层 2：统一性

**问题：如何让自定义函数获得 Runnable 的标准能力？**

**RunnableLambda 的解决方案：**
```python
runnable = RunnableLambda(func)

# 自动获得标准接口
runnable.invoke(input)           # 同步调用
runnable.batch(inputs)           # 批量调用
runnable.stream(input)           # 流式调用
await runnable.ainvoke(input)    # 异步调用

# 自动获得组合能力
chain = runnable1 | runnable2 | runnable3

# 自动获得配置能力
runnable.with_config({"tags": ["custom"]})
```

**价值：**
- 统一的调用方式
- 统一的组合方式
- 统一的配置方式

**类比：**
- 就像给函数办理"Runnable 护照"
- 就像把普通工人变成流水线工人

---

### 价值层 3：生产级特性

**问题：如何让自定义函数获得企业级可靠性？**

**RunnableLambda 的解决方案：**
```python
runnable = RunnableLambda(func)

# 自动获得重试机制
safe_runnable = runnable.with_retry(
    stop_after_attempt=3,
    wait_exponential_multiplier=1
)

# 自动获得降级策略
robust_runnable = runnable.with_fallbacks([
    RunnableLambda(fallback_func)
])

# 自动获得回调和追踪
runnable.invoke(input, config={
    "callbacks": [MyCallback()],
    "tags": ["production"]
})
```

**价值：**
- 错误重试
- 降级策略
- 可观测性（回调、追踪）
- 配置传递

**类比：**
- 就像给函数加上"保险"
- 就像给工序加上"质量检查"

---

## 从第一性原理推导应用场景

### 场景 1：数据预处理

**第一性原理：**
- 原始数据通常需要清洗和标准化
- 每个业务有特定的清洗规则
- 清洗逻辑最好用函数表达

**推导：**
```python
# 业务特定的清洗逻辑
def clean_text(text: str) -> str:
    text = text.strip().lower()
    text = re.sub(r'[^\w\s]', '', text)
    return text

# 转换为 Runnable
cleaner = RunnableLambda(clean_text)

# 组合到链中
chain = cleaner | prompt | model | parser
```

**为什么需要 RunnableLambda：**
- 清洗逻辑是业务特定的，无法用内置组件
- 需要与其他 Runnable 组件组合
- 需要批量处理能力

---

### 场景 2：格式转换

**第一性原理：**
- 不同系统之间的数据格式不同
- 需要转换器进行格式适配
- 转换逻辑最好用函数表达

**推导：**
```python
# JSON 到文本的转换
def json_to_text(data: dict) -> str:
    return f"Name: {data['name']}\nAge: {data['age']}"

# 文本到 JSON 的转换
def text_to_json(text: str) -> dict:
    lines = text.split('\n')
    return {
        "name": lines[0].split(': ')[1],
        "age": int(lines[1].split(': ')[1])
    }

# 组合转换链
chain = (
    RunnableLambda(json_to_text)
    | model
    | RunnableLambda(text_to_json)
)
```

**为什么需要 RunnableLambda：**
- 格式转换逻辑是特定的
- 需要在链的不同位置插入转换
- 需要统一的接口

---

### 场景 3：外部系统集成

**第一性原理：**
- 企业应用需要集成多个系统
- 每个系统有自己的 API 和协议
- 集成逻辑最好用函数封装

**推导：**
```python
# 调用遗留系统 API
def call_legacy_api(query: str) -> dict:
    response = requests.post(
        LEGACY_API_URL,
        json={"query": query},
        headers={"Authorization": f"Bearer {API_KEY}"}
    )
    return response.json()

# 调用数据库
def query_database(sql: str) -> list:
    conn = psycopg2.connect(DATABASE_URL)
    cursor = conn.cursor()
    cursor.execute(sql)
    return cursor.fetchall()

# 组合到 RAG 链中
chain = (
    prompt
    | model
    | RunnableLambda(call_legacy_api)  # 调用遗留系统
    | RunnableLambda(query_database)   # 查询数据库
    | parser
)
```

**为什么需要 RunnableLambda：**
- 外部系统的调用逻辑是特定的
- 需要与 LangChain 组件组合
- 需要异步和批处理能力

---

### 场景 4：条件路由

**第一性原理：**
- 不同输入需要不同的处理路径
- 路由逻辑是业务特定的
- 路由决策最好用函数表达

**推导：**
```python
# 根据语言选择模型
def route_by_language(input: dict) -> str:
    language = input["language"]
    if language == "zh":
        return "chinese_model"
    elif language == "en":
        return "english_model"
    else:
        return "default_model"

# 根据复杂度选择策略
def route_by_complexity(input: dict) -> str:
    if len(input["text"]) > 1000:
        return "complex_strategy"
    else:
        return "simple_strategy"

# 组合路由链
chain = (
    RunnableLambda(route_by_language)
    | RunnableBranch(...)  # 根据路由结果选择分支
)
```

**为什么需要 RunnableLambda：**
- 路由逻辑是业务特定的
- 需要与 RunnableBranch 等组件配合
- 需要统一的接口

---

## 设计哲学

### 哲学 1：适配器模式

**核心思想：**
- 不改变原有接口
- 提供新的接口适配
- 让不兼容的接口协同工作

**在 RunnableLambda 中的体现：**
```python
# 原函数不变
def my_func(x):
    return x * 2

# 适配器包装
runnable = RunnableLambda(my_func)

# 现在符合 Runnable 接口
runnable.invoke(5)  # 10
```

**类比：**
- 就像电源适配器，让不同电压的设备都能用
- 就像语言翻译器，让不同语言的人能交流

---

### 哲学 2：组合优于继承

**核心思想：**
- 通过组合小的、独立的组件构建复杂系统
- 而不是通过继承构建庞大的类层次

**在 RunnableLambda 中的体现：**
```python
# 不需要继承
class MyRunnable(Runnable):  # ❌ 繁琐
    def invoke(self, input):
        return my_func(input)

# 直接组合
runnable = RunnableLambda(my_func)  # ✅ 简洁

# 组合多个函数
chain = (
    RunnableLambda(func1)
    | RunnableLambda(func2)
    | RunnableLambda(func3)
)
```

**类比：**
- 就像乐高积木，通过组合构建复杂结构
- 就像 Unix 管道，通过组合命令完成复杂任务

---

### 哲学 3：声明式编程

**核心思想：**
- 描述"做什么"而不是"怎么做"
- 让框架处理执行细节

**在 RunnableLambda 中的体现：**
```python
# 声明式：描述处理流程
chain = (
    RunnableLambda(clean)
    | RunnableLambda(tokenize)
    | RunnableLambda(analyze)
)

# 框架自动处理：
# - 数据传递
# - 错误处理
# - 批量处理
# - 异步执行

result = chain.invoke(input)
```

**类比：**
- 就像 SQL，描述查询而不是如何查询
- 就像 React，描述 UI 而不是如何更新 DOM

---

## 核心权衡

### 权衡 1：灵活性 vs 可读性

**灵活性：**
- RunnableLambda 可以包装任何函数
- 可以实现任意复杂的逻辑

**可读性：**
- 过度使用会降低可读性
- 复杂逻辑建议用自定义 Runnable 类

**建议：**
```python
# ✅ 简单逻辑用 RunnableLambda
chain = RunnableLambda(lambda x: x.upper()) | model

# ❌ 复杂逻辑不要用 RunnableLambda
chain = RunnableLambda(lambda x: {
    "key1": complex_logic_1(x),
    "key2": complex_logic_2(x),
    "key3": complex_logic_3(x)
})  # 难以理解

# ✅ 复杂逻辑用自定义类
class ComplexProcessor(Runnable):
    def invoke(self, input):
        return {
            "key1": self._process_1(input),
            "key2": self._process_2(input),
            "key3": self._process_3(input)
        }
```

---

### 权衡 2：性能 vs 便利性

**便利性：**
- 默认的 sync → async 委托很方便
- 不需要写异步代码

**性能：**
- 委托有性能损耗
- 高并发场景需要优化

**建议：**
```python
# ✅ 低并发场景：使用默认委托
runnable = RunnableLambda(sync_func)

# ✅ 高并发场景：提供 afunc
async def async_func(x):
    await asyncio.sleep(0.1)
    return x * 2

runnable = RunnableLambda(sync_func, afunc=async_func)
```

---

### 权衡 3：简单性 vs 功能性

**简单性：**
- RunnableLambda 的 API 很简单
- 只需要传入一个函数

**功能性：**
- 不支持复杂的状态管理
- 不支持真正的流式输出（默认）

**建议：**
```python
# ✅ 无状态逻辑用 RunnableLambda
runnable = RunnableLambda(lambda x: x.upper())

# ❌ 有状态逻辑不要用 RunnableLambda
# 建议用 RunnableGenerator 或自定义类
```

---

## 一句话总结

**从第一性原理看 RunnableLambda：**

> **RunnableLambda 是将 Python 函数（一等公民）适配到 LangChain Runnable 协议（统一接口）的必然设计，通过适配器模式实现灵活性、统一性和生产级特性的平衡。**

---

## 深入思考

### 思考 1：为什么不直接让函数支持 | 操作符？

**问题：**
```python
# 为什么不能这样？
def func1(x):
    return x * 2

def func2(x):
    return x + 1

chain = func1 | func2  # ❌ 不支持
```

**原因：**
1. Python 函数对象不支持 `__or__` 方法
2. 修改内置类型的行为是危险的
3. 需要额外的元数据（如类型信息）

**RunnableLambda 的解决方案：**
```python
# 通过包装提供 | 操作符
chain = RunnableLambda(func1) | RunnableLambda(func2)  # ✅
```

---

### 思考 2：为什么不自动转换所有函数？

**问题：**
```python
# 为什么不能自动转换？
chain = prompt | my_func | model  # ❌ my_func 不是 Runnable
```

**原因：**
1. 无法区分哪些函数需要转换
2. 自动转换可能导致意外行为
3. 显式转换更清晰

**RunnableLambda 的解决方案：**
```python
# 显式转换
chain = prompt | RunnableLambda(my_func) | model  # ✅
```

---

### 思考 3：为什么需要 afunc 参数？

**问题：**
```python
# 为什么不能自动优化异步？
runnable = RunnableLambda(sync_func)
await runnable.ainvoke(input)  # 性能较低
```

**原因：**
1. 无法自动将同步函数转换为异步函数
2. 默认通过线程池委托，有性能损耗
3. 需要用户提供真正的异步实现

**RunnableLambda 的解决方案：**
```python
# 提供独立的异步实现
runnable = RunnableLambda(sync_func, afunc=async_func)  # ✅
await runnable.ainvoke(input)  # 性能提升 10-20x
```

---

## 引用来源

- [LangChain 官方文档 - RunnableLambda](https://python.langchain.com/docs/expression_language/primitives/lambda) - 官方设计理念
- [LangChain API Reference v0.3](https://reference.langchain.com/v0.3/python/core/runnables/) - 接口设计
- [Guide to LangChain Runnable Architecture (DZone 2026)](https://dzone.com/articles/guide-to-langchain-runnable-architecture) - 架构分析
- [Design Patterns: Adapter Pattern](https://refactoring.guru/design-patterns/adapter) - 适配器模式
- [Functional Programming Principles](https://en.wikipedia.org/wiki/Functional_programming) - 函数式编程

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: LangChain v0.3+
**Python 版本**: 3.13+
