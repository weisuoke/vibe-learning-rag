# 化骨绵掌 - 10 个两分钟知识卡片

> **学习目标**: 通过 10 个精炼的知识卡片，快速掌握 UI 组件定制的核心要点
> **阅读时间**: 20 分钟 (每卡片 2 分钟)
> **难度级别**: ⭐⭐⭐ (进阶)

---

## 使用说明

每个知识卡片设计为 2 分钟快速阅读，涵盖一个核心概念。适合：
- 快速复习核心知识点
- 面试前突击准备
- 碎片时间学习

---

## 卡片 1: 直觉理解

**核心问题**: UI 组件定制到底在解决什么问题？

**直觉理解**:
想象你在用记号笔在白板上写字。如果每次修改一个字，你都要擦掉整个白板重写，那会很慢。更聪明的做法是：只擦掉改变的字，其他保持不动。

这就是 UI 组件定制的核心：
- **差分渲染** = 只擦改变的字
- **自定义编辑器** = 定制你的记号笔（不同颜色、粗细、功能）
- **Widget 系统** = 在白板上贴便利贴（可以随意移动、叠加）

**关键洞察**:
终端渲染成本高（每个字符都需要 ANSI 转义序列），所以"只更新变化"比"全量重绘"快 20-100 倍。

**记住**: 终端 UI 优化的核心是**减少输出**，不是加快输出。

---

## 卡片 2: 形式化定义

**数学定义**:

```
终端状态 S = Cell[rows][cols]
Cell = { char: string, fg: Color, bg: Color, style: Style }

渲染函数 R: S → Output
全量渲染: R(S) = O(rows × cols)
差分渲染: R(S_prev, S_curr) = O(|diff(S_prev, S_curr)|)

性能提升 = O(rows × cols) / O(changed cells)
```

**接口定义**:

```typescript
// 编辑器接口
interface EditorComponent {
  render(ctx: RenderContext): Component;  // S → Component
  handleKey(key: KeyEvent): boolean;      // Event → State
  getValue(): string;                     // State → Value
  setValue(value: string): void;          // Value → State
}

// 组件接口
interface Component {
  render(ctx: RenderContext): string;     // Component → Output
}

// 容器接口
interface Container extends Component {
  children: Component[];                  // 组合模式
  layout(): void;                         // 布局计算
}
```

**关键性质**:
1. **幂等性**: render(S) 多次调用结果相同
2. **确定性**: 相同输入产生相同输出
3. **可组合性**: Component 可以嵌套组合

---

## 卡片 3: 差分渲染策略

**3-Tier 策略详解**:

**Tier 1: First Render (首次渲染)**
```typescript
function firstRender(state: State): void {
  terminal.clear();  // 清屏
  for (let row = 0; row < state.rows; row++) {
    for (let col = 0; col < state.cols; col++) {
      terminal.write(row, col, state.cells[row][col]);
    }
  }
}
// 复杂度: O(rows × cols)
// 场景: 应用启动、全屏刷新
```

**Tier 2: Width Change (宽度变化)**
```typescript
function widthChangeRender(state: State, newWidth: number): void {
  state.relayout(newWidth);  // 重新计算布局
  // 部分重绘（受影响的区域）
  for (const region of affectedRegions) {
    renderRegion(region);
  }
}
// 复杂度: O(rows × cols) 或 O(affected area)
// 场景: 终端窗口大小改变
```

**Tier 3: Normal Update (常规更新)**
```typescript
function normalUpdate(prevState: State, currState: State): void {
  const diff = computeDiff(prevState, currState);
  for (const update of diff) {
    terminal.write(update.row, update.col, update.cell);
  }
}
// 复杂度: O(changed cells)
// 场景: 日常交互、内容更新
```

**选择策略**:
```typescript
function render(prevState: State, currState: State): void {
  if (!prevState) {
    firstRender(currState);  // Tier 1
  } else if (prevState.width !== currState.width) {
    widthChangeRender(currState, currState.width);  // Tier 2
  } else {
    normalUpdate(prevState, currState);  // Tier 3
  }
}
```

**性能对比**:
- Tier 1: 100ms (1920 cells)
- Tier 2: 50ms (960 cells, 假设一半受影响)
- Tier 3: 5ms (20 cells)

---

## 卡片 4: EditorComponent 接口

**接口设计哲学**: MVC 模式

```typescript
interface EditorComponent {
  // View: 如何展示
  render(ctx: RenderContext): Component;

  // Controller: 如何响应
  handleKey(key: KeyEvent): boolean;
  handleMouse?(mouse: MouseEvent): boolean;

  // Model: 如何管理
  getValue(): string;
  setValue(value: string): void;

  // Lifecycle: 如何初始化/清理
  mount?(): void;
  unmount?(): void;
}
```

**最小实现**:
```typescript
class MinimalEditor implements EditorComponent {
  private value = '';
  private cursor = 0;

  render(ctx: RenderContext): Component {
    return Text({ content: this.value, cursor: this.cursor });
  }

  handleKey(key: KeyEvent): boolean {
    if (key.name === 'backspace') {
      this.value = this.value.slice(0, -1);
      this.cursor = Math.max(0, this.cursor - 1);
    } else if (key.sequence) {
      this.value += key.sequence;
      this.cursor += key.sequence.length;
    }
    return true;
  }

  getValue(): string { return this.value; }
  setValue(value: string): void { this.value = value; this.cursor = value.length; }
}
```

**关键点**:
1. **分离关注点**: 渲染、交互、状态各司其职
2. **返回值**: handleKey 返回 true 表示已处理，false 表示未处理
3. **生命周期**: mount/unmount 用于资源管理

---

## 卡片 5: Widget 定位

**三种定位方式**:

**1. Absolute (绝对定位)**
```typescript
{ type: 'absolute', x: 10, y: 5 }
// 直接指定坐标，类似 CSS position: absolute
```

**2. Relative (相对定位)**
```typescript
{ type: 'relative', x: 0, y: 1 }
// 相对父容器定位，类似 CSS position: relative
```

**3. Anchor (锚点定位)**
```typescript
{ type: 'anchor', anchor: 'bottom-right', offset: { x: -1, y: -1 } }
// 锚定到特定位置，类似 CSS 的 top/bottom/left/right
```

**边界处理**:
```typescript
function clampPosition(
  widget: { width: number; height: number },
  terminal: { width: number; height: number },
  position: { x: number; y: number }
): { x: number; y: number } {
  return {
    x: Math.max(0, Math.min(position.x, terminal.width - widget.width)),
    y: Math.max(0, Math.min(position.y, terminal.height - widget.height))
  };
}
```

**智能定位** (Tooltip 示例):
```typescript
function positionTooltip(anchor: Point, tooltip: Size, terminal: Size): Point {
  let x = anchor.x;
  let y = anchor.y + 1;  // 默认下方

  // 超出右边界，左对齐
  if (x + tooltip.width > terminal.width) {
    x = terminal.width - tooltip.width;
  }

  // 超出下边界，显示上方
  if (y + tooltip.height > terminal.height) {
    y = anchor.y - tooltip.height;
  }

  return clampPosition(tooltip, terminal, { x, y });
}
```

---

## 卡片 6: CSI 2026 同步输出

**问题**: 传统渲染会产生闪烁

```typescript
// 传统方式 - 用户可能看到中间状态
terminal.write(0, 0, 'A');  // 用户看到 'A'
terminal.write(0, 1, 'B');  // 用户看到 'AB'
terminal.write(0, 2, 'C');  // 用户看到 'ABC'
```

**解决**: CSI 2026 Synchronized Output

```typescript
// CSI 2026 - 用户只看到最终状态
terminal.write('\x1b[?2026h');  // Begin sync
terminal.write(0, 0, 'A');
terminal.write(0, 1, 'B');
terminal.write(0, 2, 'C');
terminal.write('\x1b[?2026l');  // End sync
// 用户直接看到 'ABC'，没有中间状态
```

**工作原理**:
1. `\x1b[?2026h` 告诉终端开始缓冲输出
2. 所有后续输出被缓冲，不立即显示
3. `\x1b[?2026l` 告诉终端刷新缓冲区，原子化显示

**实现**:
```typescript
function synchronizedRender(updates: Update[]): string {
  let output = '\x1b[?2026h';  // Begin
  for (const update of updates) {
    output += `\x1b[${update.row};${update.col}H`;  // Move cursor
    output += renderCell(update.cell);
  }
  output += '\x1b[?2026l';  // End
  return output;
}
```

**效果**:
- 消除闪烁
- 提升视觉体验
- 支持复杂动画

---

## 卡片 7: 性能优化

**优化策略**:

**1. Render Throttling (渲染节流)**
```typescript
class ThrottledRenderer {
  private lastRender = 0;
  private minInterval = 16;  // 60 FPS

  render(state: State): void {
    const now = Date.now();
    if (now - this.lastRender < this.minInterval) {
      return;  // 跳过此次渲染
    }
    this.lastRender = now;
    this.doRender(state);
  }
}
```

**2. Buffer Pooling (缓冲池)**
```typescript
class BufferPool {
  private pool: Buffer[] = [];

  acquire(): Buffer {
    return this.pool.pop() || new Buffer();
  }

  release(buffer: Buffer): void {
    buffer.clear();
    this.pool.push(buffer);
  }
}
```

**3. Lazy Rendering (延迟渲染)**
```typescript
class LazyComponent implements Component {
  private cached: string | null = null;
  private dirty = true;

  render(ctx: RenderContext): string {
    if (!this.dirty && this.cached) {
      return this.cached;  // 返回缓存
    }
    this.cached = this.doRender(ctx);
    this.dirty = false;
    return this.cached;
  }

  invalidate(): void {
    this.dirty = true;
  }
}
```

**4. Batch Updates (批量更新)**
```typescript
class BatchUpdater {
  private pending: Update[] = [];
  private timer: NodeJS.Timeout | null = null;

  scheduleUpdate(update: Update): void {
    this.pending.push(update);
    if (!this.timer) {
      this.timer = setTimeout(() => this.flush(), 0);
    }
  }

  private flush(): void {
    const updates = this.pending;
    this.pending = [];
    this.timer = null;
    this.applyUpdates(updates);
  }
}
```

**性能提升**:
- Throttling: 减少 40% 渲染次数
- Buffer Pool: 减少 60% 内存分配
- Lazy Rendering: 减少 50% 计算量
- Batch Updates: 减少 70% 输出次数

---

## 卡片 8: 组件架构

**组件层次**:

```
Component (基础组件)
├─ render(ctx): string
└─ getSize(): { width, height }

Container (容器组件)
├─ extends Component
├─ children: Component[]
└─ layout(): void

Focusable (可聚焦组件)
├─ extends Component
├─ focus(): void
├─ blur(): void
└─ isFocused(): boolean

OverlayContainer (浮层容器)
├─ extends Container
├─ position: OverlayPosition
└─ calculatePosition(): Point
```

**组合模式**:
```typescript
const ui = Box({
  children: [
    Text({ content: 'Title' }),
    Box({
      children: [
        Input({ value: 'input1' }),
        Input({ value: 'input2' })
      ]
    }),
    Button({ label: 'Submit' })
  ]
});
```

**关键设计**:
1. **组合优于继承**: 通过组合构建复杂 UI
2. **单一职责**: 每个组件只做一件事
3. **接口隔离**: 不同能力通过不同接口暴露

---

## 卡片 9: 实际应用

**应用 1: AI Agent 对话界面**

```typescript
class ChatUI {
  private messages: Message[] = [];
  private input: MultiLineEditor;
  private loading: LoadingSpinner;

  render(ctx: RenderContext): Component {
    return Box({
      children: [
        // 消息历史 (差分渲染)
        MessageHistory({
          messages: this.messages,
          height: ctx.height - 5
        }),

        // 分隔线
        Text({ content: '─'.repeat(ctx.width) }),

        // 输入框 (自定义编辑器)
        this.input,

        // Loading 指示器 (Widget)
        this.loading.visible ? this.loading : null
      ].filter(Boolean)
    });
  }
}
```

**应用 2: 代码编辑器**

```typescript
class CodeEditor implements EditorComponent {
  private lines: string[] = [];
  private cursor: { row: number; col: number };
  private highlighter: SyntaxHighlighter;

  render(ctx: RenderContext): Component {
    const visibleLines = this.getVisibleLines(ctx.height);

    return Box({
      children: visibleLines.map((line, i) => {
        const highlighted = this.highlighter.highlight(line);
        return Text({
          content: highlighted,
          cursor: i === this.cursor.row ? this.cursor.col : undefined
        });
      })
    });
  }
}
```

**应用 3: 数据可视化**

```typescript
class ChartWidget implements Component {
  private data: number[];
  private maxValue: number;

  render(ctx: RenderContext): string {
    const bars = this.data.map(value => {
      const height = Math.floor((value / this.maxValue) * ctx.height);
      return '█'.repeat(height);
    });

    return bars.join(' ');
  }
}
```

---

## 卡片 10: 总结与扩展

**核心总结**:

**三大技术**:
1. **差分渲染**: 性能优化的基础 (20-100x 提升)
2. **自定义编辑器**: 灵活性的保障 (任意编辑逻辑)
3. **Widget 系统**: 复用性的关键 (组件化架构)

**三个原则**:
1. **简单优先**: 不要过早优化
2. **接口分离**: 分离关注点
3. **组件组合**: 组合优于继承

**三个实践**:
1. **动手实践**: 理论 + 实践
2. **阅读源码**: 学习最佳实践
3. **持续优化**: 性能 + 体验

**扩展方向**:

**1. 高级交互**:
- 拖拽支持
- 手势识别
- 触摸屏支持

**2. 动画系统**:
- 缓动函数
- 关键帧动画
- 过渡效果

**3. 主题系统**:
- 颜色主题
- 样式定制
- 响应式设计

**4. 可访问性**:
- 屏幕阅读器支持
- 键盘导航
- 高对比度模式

**5. 测试**:
- 单元测试
- 快照测试
- 性能测试

**学习资源**:
- pi-mono 源码: `sourcecode/pi-mono/packages/tui`
- OpenTUI: https://github.com/anomalyco/opentui
- Rezi: https://github.com/RtlZeroMemory/Rezi
- ratatui: https://github.com/ratatui-org/ratatui

**下一步**:
- 实现一个完整的终端应用
- 优化性能到极致
- 贡献到开源社区

---

**记住**: UI 组件定制是一门艺术，需要在性能、灵活性和复用性之间找到平衡！

---

**版本**: v1.0
**最后更新**: 2026-02-21
**维护者**: Claude Code
