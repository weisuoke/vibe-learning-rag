# 实战代码1：一对多场景 - 用户-对话系统

> 完整的用户-对话关系实现，AI Agent 开发的核心场景

---

## 场景描述

实现一个 AI Agent 的用户-对话系统，包含：
- 用户管理
- 对话管理
- 消息管理
- 一对多关系（用户→对话→消息）
- FastAPI 集成

---

## 完整代码

### 1. 数据模型定义

```python
"""
AI Agent 用户-对话系统
演示一对多关系的完整实现
"""

from datetime import datetime
from typing import List, Optional
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, create_engine
from sqlalchemy.orm import relationship, DeclarativeBase, Session

# ===== 1. 基础配置 =====

class Base(DeclarativeBase):
    pass

# ===== 2. 数据模型 =====

class User(Base):
    """用户模型"""
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False, index=True)
    email = Column(String(100), unique=True, nullable=False, index=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # 一对多：用户的对话
    conversations = relationship(
        "Conversation",
        back_populates="user",
        lazy='selectin',  # 避免 N+1 问题
        cascade="all, delete-orphan",  # 删除用户时删除所有对话
        order_by="Conversation.created_at.desc()"  # 按创建时间倒序
    )

    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}')>"


class Conversation(Base):
    """对话模型"""
    __tablename__ = 'conversations'

    id = Column(Integer, primary_key=True)
    title = Column(String(200), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # 外键：指向用户
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False, index=True)

    # 多对一：对话属于哪个用户
    user = relationship("User", back_populates="conversations")

    # 一对多：对话的消息
    messages = relationship(
        "Message",
        back_populates="conversation",
        lazy='selectin',
        cascade="all, delete-orphan",
        order_by="Message.created_at"  # 按创建时间正序
    )

    def __repr__(self):
        return f"<Conversation(id={self.id}, title='{self.title}')>"


class Message(Base):
    """消息模型"""
    __tablename__ = 'messages'

    id = Column(Integer, primary_key=True)
    role = Column(String(20), nullable=False)  # 'user' or 'assistant'
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 外键：指向对话
    conversation_id = Column(Integer, ForeignKey('conversations.id'), nullable=False, index=True)

    # 多对一：消息属于哪个对话
    conversation = relationship("Conversation", back_populates="messages")

    def __repr__(self):
        return f"<Message(id={self.id}, role='{self.role}')>"


# ===== 3. 数据库初始化 =====

def init_db(db_url: str = "sqlite:///./ai_agent.db"):
    """初始化数据库"""
    engine = create_engine(db_url, echo=True)
    Base.metadata.create_all(engine)
    return engine


# ===== 4. CRUD 操作 =====

class UserService:
    """用户服务"""

    def __init__(self, session: Session):
        self.session = session

    def create_user(self, username: str, email: str) -> User:
        """创建用户"""
        user = User(username=username, email=email)
        self.session.add(user)
        self.session.commit()
        self.session.refresh(user)
        return user

    def get_user(self, user_id: int) -> Optional[User]:
        """获取用户"""
        return self.session.get(User, user_id)

    def get_user_by_username(self, username: str) -> Optional[User]:
        """根据用户名获取用户"""
        return self.session.query(User).filter(User.username == username).first()

    def list_users(self, skip: int = 0, limit: int = 100) -> List[User]:
        """列出所有用户"""
        return self.session.query(User).offset(skip).limit(limit).all()

    def delete_user(self, user_id: int) -> bool:
        """删除用户（级联删除所有对话和消息）"""
        user = self.get_user(user_id)
        if user:
            self.session.delete(user)
            self.session.commit()
            return True
        return False


class ConversationService:
    """对话服务"""

    def __init__(self, session: Session):
        self.session = session

    def create_conversation(self, user_id: int, title: str) -> Conversation:
        """创建对话"""
        conversation = Conversation(user_id=user_id, title=title)
        self.session.add(conversation)
        self.session.commit()
        self.session.refresh(conversation)
        return conversation

    def get_conversation(self, conversation_id: int) -> Optional[Conversation]:
        """获取对话"""
        return self.session.get(Conversation, conversation_id)

    def list_user_conversations(self, user_id: int) -> List[Conversation]:
        """列出用户的所有对话"""
        user = self.session.get(User, user_id)
        if user:
            return user.conversations
        return []

    def update_conversation_title(self, conversation_id: int, title: str) -> Optional[Conversation]:
        """更新对话标题"""
        conversation = self.get_conversation(conversation_id)
        if conversation:
            conversation.title = title
            self.session.commit()
            self.session.refresh(conversation)
        return conversation

    def delete_conversation(self, conversation_id: int) -> bool:
        """删除对话（级联删除所有消息）"""
        conversation = self.get_conversation(conversation_id)
        if conversation:
            self.session.delete(conversation)
            self.session.commit()
            return True
        return False


class MessageService:
    """消息服务"""

    def __init__(self, session: Session):
        self.session = session

    def create_message(self, conversation_id: int, role: str, content: str) -> Message:
        """创建消息"""
        message = Message(conversation_id=conversation_id, role=role, content=content)
        self.session.add(message)
        self.session.commit()
        self.session.refresh(message)
        return message

    def get_message(self, message_id: int) -> Optional[Message]:
        """获取消息"""
        return self.session.get(Message, message_id)

    def list_conversation_messages(self, conversation_id: int) -> List[Message]:
        """列出对话的所有消息"""
        conversation = self.session.get(Conversation, conversation_id)
        if conversation:
            return conversation.messages
        return []


# ===== 5. 使用示例 =====

def main():
    """主函数：演示完整的使用流程"""

    # 初始化数据库
    engine = init_db()
    session = Session(engine)

    # 创建服务
    user_service = UserService(session)
    conversation_service = ConversationService(session)
    message_service = MessageService(session)

    print("=== 1. 创建用户 ===")
    alice = user_service.create_user("alice", "alice@example.com")
    bob = user_service.create_user("bob", "bob@example.com")
    print(f"创建用户: {alice.username}, {bob.username}")

    print("\n=== 2. 创建对话 ===")
    conv1 = conversation_service.create_conversation(alice.id, "Python学习")
    conv2 = conversation_service.create_conversation(alice.id, "AI Agent开发")
    conv3 = conversation_service.create_conversation(bob.id, "FastAPI教程")
    print(f"创建对话: {conv1.title}, {conv2.title}, {conv3.title}")

    print("\n=== 3. 创建消息 ===")
    msg1 = message_service.create_message(conv1.id, "user", "什么是Python?")
    msg2 = message_service.create_message(conv1.id, "assistant", "Python是一种编程语言")
    msg3 = message_service.create_message(conv2.id, "user", "如何开发AI Agent?")
    msg4 = message_service.create_message(conv2.id, "assistant", "可以使用LangChain框架")
    print(f"创建消息: {len([msg1, msg2, msg3, msg4])} 条")

    print("\n=== 4. 查询用户的对话 ===")
    alice_conversations = conversation_service.list_user_conversations(alice.id)
    print(f"{alice.username} 的对话:")
    for conv in alice_conversations:
        print(f"  - {conv.title} ({len(conv.messages)} 条消息)")

    print("\n=== 5. 查询对话的消息 ===")
    conv1_messages = message_service.list_conversation_messages(conv1.id)
    print(f"{conv1.title} 的消息:")
    for msg in conv1_messages:
        print(f"  {msg.role}: {msg.content}")

    print("\n=== 6. 访问关系（对象导航）===")
    # 从用户访问对话
    print(f"{alice.username} 的对话: {[c.title for c in alice.conversations]}")

    # 从对话访问用户
    print(f"{conv1.title} 属于: {conv1.user.username}")

    # 从对话访问消息
    print(f"{conv1.title} 的消息数: {len(conv1.messages)}")

    # 从消息访问对话
    print(f"消息 '{msg1.content}' 属于对话: {msg1.conversation.title}")

    print("\n=== 7. 更新对话标题 ===")
    conversation_service.update_conversation_title(conv1.id, "Python进阶学习")
    print(f"更新后的标题: {conv1.title}")

    print("\n=== 8. 删除对话（级联删除消息）===")
    conversation_service.delete_conversation(conv2.id)
    print(f"删除对话: {conv2.title}")
    print(f"{alice.username} 剩余对话: {[c.title for c in alice.conversations]}")

    print("\n=== 9. 删除用户（级联删除所有对话和消息）===")
    user_service.delete_user(alice.id)
    print(f"删除用户: {alice.username}")
    print(f"剩余用户: {[u.username for u in user_service.list_users()]}")

    # 关闭会话
    session.close()


if __name__ == "__main__":
    main()
```

---

## 运行输出

```
=== 1. 创建用户 ===
创建用户: alice, bob

=== 2. 创建对话 ===
创建对话: Python学习, AI Agent开发, FastAPI教程

=== 3. 创建消息 ===
创建消息: 4 条

=== 4. 查询用户的对话 ===
alice 的对话:
  - AI Agent开发 (2 条消息)
  - Python学习 (2 条消息)

=== 5. 查询对话的消息 ===
Python学习 的消息:
  user: 什么是Python?
  assistant: Python是一种编程语言

=== 6. 访问关系（对象导航）===
alice 的对话: ['AI Agent开发', 'Python学习']
Python学习 属于: alice
Python学习 的消息数: 2
消息 '什么是Python?' 属于对话: Python学习

=== 7. 更新对话标题 ===
更新后的标题: Python进阶学习

=== 8. 删除对话（级联删除消息）===
删除对话: AI Agent开发
alice 剩余对话: ['Python进阶学习']

=== 9. 删除用户（级联删除所有对话和消息）===
删除用户: alice
剩余用户: ['bob']
```

---

## FastAPI 集成

```python
"""
FastAPI 集成示例
"""

from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy.orm import Session

app = FastAPI()

# ===== Pydantic 模型 =====

class UserCreate(BaseModel):
    username: str
    email: str

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime

    class Config:
        from_attributes = True

class ConversationCreate(BaseModel):
    title: str

class ConversationResponse(BaseModel):
    id: int
    title: str
    user_id: int
    created_at: datetime
    message_count: int

class MessageCreate(BaseModel):
    role: str
    content: str

class MessageResponse(BaseModel):
    id: int
    role: str
    content: str
    created_at: datetime

    class Config:
        from_attributes = True

# ===== 依赖注入 =====

def get_db():
    """获取数据库会话"""
    engine = init_db()
    session = Session(engine)
    try:
        yield session
    finally:
        session.close()

# ===== API 端点 =====

@app.post("/users", response_model=UserResponse)
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """创建用户"""
    service = UserService(db)
    return service.create_user(user.username, user.email)

@app.get("/users/{user_id}", response_model=UserResponse)
def get_user(user_id: int, db: Session = Depends(get_db)):
    """获取用户"""
    service = UserService(db)
    user = service.get_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

@app.get("/users/{user_id}/conversations")
def get_user_conversations(user_id: int, db: Session = Depends(get_db)):
    """获取用户的所有对话"""
    service = ConversationService(db)
    conversations = service.list_user_conversations(user_id)
    return [
        ConversationResponse(
            id=c.id,
            title=c.title,
            user_id=c.user_id,
            created_at=c.created_at,
            message_count=len(c.messages)
        )
        for c in conversations
    ]

@app.post("/users/{user_id}/conversations", response_model=ConversationResponse)
def create_conversation(
    user_id: int,
    conversation: ConversationCreate,
    db: Session = Depends(get_db)
):
    """创建对话"""
    service = ConversationService(db)
    conv = service.create_conversation(user_id, conversation.title)
    return ConversationResponse(
        id=conv.id,
        title=conv.title,
        user_id=conv.user_id,
        created_at=conv.created_at,
        message_count=0
    )

@app.get("/conversations/{conversation_id}/messages", response_model=List[MessageResponse])
def get_conversation_messages(conversation_id: int, db: Session = Depends(get_db)):
    """获取对话的所有消息"""
    service = MessageService(db)
    messages = service.list_conversation_messages(conversation_id)
    return messages

@app.post("/conversations/{conversation_id}/messages", response_model=MessageResponse)
def create_message(
    conversation_id: int,
    message: MessageCreate,
    db: Session = Depends(get_db)
):
    """创建消息"""
    service = MessageService(db)
    return service.create_message(conversation_id, message.role, message.content)

@app.delete("/users/{user_id}")
def delete_user(user_id: int, db: Session = Depends(get_db)):
    """删除用户（级联删除所有对话和消息）"""
    service = UserService(db)
    if not service.delete_user(user_id):
        raise HTTPException(status_code=404, detail="User not found")
    return {"message": "User deleted successfully"}

@app.delete("/conversations/{conversation_id}")
def delete_conversation(conversation_id: int, db: Session = Depends(get_db)):
    """删除对话（级联删除所有消息）"""
    service = ConversationService(db)
    if not service.delete_conversation(conversation_id):
        raise HTTPException(status_code=404, detail="Conversation not found")
    return {"message": "Conversation deleted successfully"}
```

---

## API 使用示例

```bash
# 1. 创建用户
curl -X POST "http://localhost:8000/users" \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "email": "alice@example.com"}'

# 2. 获取用户
curl "http://localhost:8000/users/1"

# 3. 创建对话
curl -X POST "http://localhost:8000/users/1/conversations" \
  -H "Content-Type: application/json" \
  -d '{"title": "Python学习"}'

# 4. 获取用户的对话
curl "http://localhost:8000/users/1/conversations"

# 5. 创建消息
curl -X POST "http://localhost:8000/conversations/1/messages" \
  -H "Content-Type: application/json" \
  -d '{"role": "user", "content": "什么是Python?"}'

# 6. 获取对话的消息
curl "http://localhost:8000/conversations/1/messages"

# 7. 删除对话
curl -X DELETE "http://localhost:8000/conversations/1"

# 8. 删除用户
curl -X DELETE "http://localhost:8000/users/1"
```

---

## 关键技术点

### 1. 一对多关系定义

```python
# 父表（一）
class User(Base):
    conversations = relationship(
        "Conversation",
        back_populates="user",
        lazy='selectin',  # 避免 N+1 问题
        cascade="all, delete-orphan",  # 级联删除
        order_by="Conversation.created_at.desc()"  # 默认排序
    )

# 子表（多）
class Conversation(Base):
    user_id = Column(Integer, ForeignKey('users.id'))  # 外键
    user = relationship("User", back_populates="conversations")
```

### 2. 级联删除

```python
# 删除用户时，自动删除所有对话和消息
user_service.delete_user(user_id)

# SQL 执行：
# DELETE FROM messages WHERE conversation_id IN (SELECT id FROM conversations WHERE user_id = ?)
# DELETE FROM conversations WHERE user_id = ?
# DELETE FROM users WHERE id = ?
```

### 3. 对象导航

```python
# 从用户访问对话
user.conversations  # 自动查询

# 从对话访问用户
conversation.user  # 自动查询

# 从对话访问消息
conversation.messages  # 自动查询

# 从消息访问对话
message.conversation  # 自动查询
```

### 4. 避免 N+1 问题

```python
# 使用 lazy='selectin'
class User(Base):
    conversations = relationship("Conversation", lazy='selectin')

# 查询所有用户
users = session.query(User).all()  # 1次查询

# 访问每个用户的对话
for user in users:
    print(user.conversations)  # 不再查询，数据已加载

# 总共 2 次查询（而不是 1 + N 次）
```

---

## 总结

这个示例展示了：
1. ✅ 完整的一对多关系定义（用户→对话→消息）
2. ✅ CRUD 操作的封装（Service 层）
3. ✅ 级联删除的使用
4. ✅ 对象导航的便利性
5. ✅ 避免 N+1 查询问题
6. ✅ FastAPI 集成
7. ✅ RESTful API 设计

**适用场景：**
- AI Agent 对话系统
- 博客文章-评论系统
- 电商订单-订单项系统
- 任何需要一对多关系的场景
