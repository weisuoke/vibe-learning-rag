# 双重类比

## TypeScript/Node.js 类比

### 类比 1：Skills = npm 包

**npm 包系统：**
```typescript
// 1. 发布包
npm publish my-package

// 2. 安装包
npm install my-package

// 3. 使用包
import { myFunction } from 'my-package';
myFunction();
```

**Skills 技能包系统：**
```bash
# 1. 发布技能（通过 Git）
git push origin main

# 2. 安装技能
git clone https://github.com/user/my-skill ~/.pi/agent/skills/my-skill

# 3. 使用技能
/skill:my-skill
```

**相似点：**
- 都是能力的封装单元
- 都支持发布和分发
- 都可以被导入和使用
- 都支持版本管理（Git tags vs npm versions）
- 都有命名规范（kebab-case）

**不同点：**
| 维度 | npm 包 | Skills 技能包 |
|------|--------|---------------|
| 内容 | JavaScript/TypeScript 代码 | Markdown 提示词 |
| 加载 | `import` / `require` | 文件系统扫描 |
| 调用 | 函数调用 | `/skill:name` 命令 |
| 时机 | 编译时/运行时 | Agent 运行时 |
| 注册 | npm registry | 文件系统 |

---

### 类比 2：SKILL.md = package.json + index.ts

**package.json + index.ts：**
```json
// package.json
{
  "name": "my-package",
  "description": "A useful package",
  "main": "index.ts"
}
```

```typescript
// index.ts
export function myFunction() {
  // 实现逻辑
}
```

**SKILL.md：**
```markdown
---
name: my-skill
description: A useful skill
---

You are an expert assistant. When the user asks...
[实现逻辑]
```

**相似点：**
- 都有元数据部分（package.json vs YAML frontmatter）
- 都有实现部分（index.ts vs Markdown 正文）
- 都定义了名称和描述
- 都是单一入口点

**不同点：**
| 维度 | package.json + index.ts | SKILL.md |
|------|-------------------------|----------|
| 格式 | JSON + TypeScript | YAML + Markdown |
| 分离 | 两个文件 | 一个文件 |
| 逻辑 | 代码逻辑 | 提示词逻辑 |
| 执行 | JavaScript 引擎 | LLM 解释 |

---

### 类比 3：技能加载 = 模块解析

**Node.js 模块解析：**
```typescript
// 1. 查找模块
import { Button } from '@ui/components';

// 解析路径：
// node_modules/@ui/components/package.json
// → "main": "dist/index.js"
// → node_modules/@ui/components/dist/index.js

// 2. 加载模块
// 读取文件 → 解析代码 → 执行代码 → 导出对象
```

**Skills 技能加载（来自 skills.ts:146-230）：**
```typescript
// 1. 扫描目录
loadSkillsFromDir({ dir: '~/.pi/agent/skills', source: 'global' })

// 解析路径：
// ~/.pi/agent/skills/my-skill/SKILL.md
// ./.pi/skills/my-skill/SKILL.md

// 2. 加载技能
// 读取文件 → 解析 frontmatter → 验证格式 → 注册技能
```

**相似点：**
- 都有目录扫描机制
- 都有文件解析逻辑
- 都有验证步骤
- 都有缓存机制

**不同点：**
| 维度 | Node.js 模块解析 | Skills 技能加载 |
|------|------------------|-----------------|
| 触发 | `import` 语句 | 启动时自动 |
| 缓存 | require.cache | 内存中的 skills 数组 |
| 热更新 | 需要重启或清除缓存 | 需要重启 Agent |
| 依赖 | package.json dependencies | 无显式依赖 |

---

### 类比 4：技能调用 = 函数调用

**函数调用：**
```typescript
// 定义函数
function greet(name: string): string {
  return `Hello, ${name}!`;
}

// 调用函数
const result = greet('Alice');
console.log(result); // "Hello, Alice!"
```

**技能调用（来自 agent-session.ts:883-907）：**
```bash
# 定义技能
# ~/.pi/agent/skills/greet/SKILL.md
---
name: greet
description: Greet the user
---
You are a friendly assistant. Greet the user by name.

# 调用技能
/skill:greet Alice

# 展开为：
<skill name="greet" location="~/.pi/agent/skills/greet/SKILL.md">
You are a friendly assistant. Greet the user by name.
</skill>

Alice
```

**相似点：**
- 都有名称（函数名 vs 技能名）
- 都可以传递参数
- 都有返回结果
- 都可以组合使用

**不同点：**
| 维度 | 函数调用 | 技能调用 |
|------|----------|----------|
| 参数 | 类型化参数 | 自由文本 |
| 返回 | 类型化返回值 | LLM 生成的文本 |
| 执行 | 同步/异步 | 异步（LLM 推理） |
| 组合 | 函数组合 | 技能嵌套调用 |

---

### 类比 5：技能组合 = 高阶函数

**高阶函数：**
```typescript
// 高阶函数：接受函数作为参数
function withLogging<T>(fn: () => T): T {
  console.log('Starting...');
  const result = fn();
  console.log('Done!');
  return result;
}

// 使用
withLogging(() => {
  return greet('Alice');
});
```

**技能组合：**
```markdown
<!-- scout-and-plan/SKILL.md -->
---
name: scout-and-plan
description: Explore codebase and generate implementation plan
---

You are a planning assistant. Follow these steps:

1. First, use /skill:explore to understand the codebase structure
2. Then, use /skill:plan to generate an implementation plan
3. Finally, present the plan to the user for approval

When the user provides a task description, execute these steps in order.
```

**相似点：**
- 都是组合多个能力
- 都有执行顺序
- 都可以传递中间结果
- 都实现了代码复用

**不同点：**
| 维度 | 高阶函数 | 技能组合 |
|------|----------|----------|
| 组合方式 | 函数嵌套 | 技能调用 |
| 类型安全 | 编译时检查 | 运行时验证 |
| 错误处理 | try-catch | LLM 处理 |
| 灵活性 | 固定逻辑 | 动态调整 |

---

## 日常生活类比

### 类比 1：Skills = 手机 App

**手机 App 系统：**
```
1. App Store（应用商店）
   ↓
2. 下载 App（微信、支付宝、抖音）
   ↓
3. 安装到手机
   ↓
4. 点击图标使用
```

**Skills 技能包系统：**
```
1. GitHub（技能仓库）
   ↓
2. 下载技能（code-review、tdd、debug）
   ↓
3. 放到 skills 目录
   ↓
4. 使用 /skill:name 调用
```

**相似点：**
- 每个 App/Skill 提供特定功能
- 可以从市场/仓库下载
- 安装后即可使用
- 可以随时卸载
- 可以组合使用（App 之间跳转 vs 技能之间调用）

**不同点：**
| 维度 | 手机 App | Skills 技能包 |
|------|----------|---------------|
| 安装 | 自动安装 | 手动复制文件 |
| 更新 | 自动更新 | 手动 git pull |
| 权限 | 需要授权 | 无权限控制 |
| 界面 | 图形界面 | 命令行 |

---

### 类比 2：SKILL.md = 菜谱

**菜谱：**
```
菜名：宫保鸡丁
描述：经典川菜，麻辣鲜香

材料：
- 鸡胸肉 300g
- 花生米 100g
- 干辣椒 10个

步骤：
1. 鸡肉切丁，腌制
2. 热油炒花生米
3. 炒鸡丁
4. 加调料翻炒
```

**SKILL.md：**
```markdown
---
name: code-review
description: Review code for quality and issues
---

You are an expert code reviewer.

Steps:
1. Read the code carefully
2. Check for bugs and issues
3. Suggest improvements
4. Provide constructive feedback
```

**相似点：**
- 都有名称和描述
- 都有步骤说明
- 都可以重复使用
- 都可以分享给他人
- 都可以根据情况调整

**不同点：**
| 维度 | 菜谱 | SKILL.md |
|------|------|----------|
| 执行者 | 人类厨师 | AI Agent |
| 材料 | 食材 | 代码/文本 |
| 结果 | 菜肴 | 分析/建议 |
| 灵活性 | 可以即兴发挥 | LLM 解释执行 |

---

### 类比 3：技能加载 = 图书馆借书

**图书馆借书：**
```
1. 图书馆有很多书架（全局技能目录）
2. 你的书包里也有书（项目技能目录）
3. 图书管理员扫描所有书架（启动时加载）
4. 建立书籍索引（技能注册表）
5. 你说书名，管理员帮你找书（技能调用）
```

**Skills 技能加载：**
```
1. ~/.pi/agent/skills/（全局技能目录）
2. ./.pi/skills/（项目技能目录）
3. loadSkillsFromDir() 扫描目录
4. 建立技能列表（skills 数组）
5. /skill:name 查找并调用
```

**相似点：**
- 都有多个来源（图书馆 vs 全局/项目）
- 都需要索引（书籍目录 vs 技能列表）
- 都支持快速查找（书名 vs 技能名）
- 都有优先级（书包优先 vs 项目技能优先）

---

### 类比 4：技能调用 = 请教专家

**请教专家：**
```
你：我想请教一下代码审查的问题
专家：好的，我是代码审查专家，请告诉我你的代码
你：[展示代码]
专家：[分析代码，提供建议]
```

**技能调用：**
```bash
你：/skill:code-review
Agent：[加载 code-review 技能]
Agent：我是代码审查专家，请告诉我你的代码
你：[展示代码]
Agent：[分析代码，提供建议]
```

**相似点：**
- 都是请教特定领域的专家
- 都需要提供上下文信息
- 都会得到专业建议
- 都可以追问和深入讨论

**不同点：**
| 维度 | 请教专家 | 技能调用 |
|------|----------|----------|
| 专家 | 真人 | AI Agent |
| 响应 | 可能需要预约 | 即时响应 |
| 成本 | 可能需要付费 | 免费（除 API 成本） |
| 可用性 | 工作时间 | 24/7 |

---

### 类比 5：技能组合 = 流水线作业

**流水线作业：**
```
汽车制造流水线：
1. 焊接车间（焊接车身）
   ↓
2. 喷漆车间（喷漆）
   ↓
3. 组装车间（安装零件）
   ↓
4. 质检车间（检查质量）
   ↓
5. 完成！
```

**技能组合：**
```markdown
<!-- full-development-workflow/SKILL.md -->
1. /skill:explore（探索代码库）
   ↓
2. /skill:plan（生成计划）
   ↓
3. /skill:implement（实现功能）
   ↓
4. /skill:test（运行测试）
   ↓
5. /skill:review（代码审查）
   ↓
6. 完成！
```

**相似点：**
- 都是多个步骤的组合
- 都有明确的顺序
- 每个步骤都有专门的职责
- 前一步的输出是后一步的输入
- 可以优化和改进流程

**不同点：**
| 维度 | 流水线作业 | 技能组合 |
|------|------------|----------|
| 执行 | 物理操作 | 文本处理 |
| 并行 | 可以并行 | 通常串行 |
| 质量控制 | 物理检测 | LLM 判断 |
| 灵活性 | 固定流程 | 可动态调整 |

---

## 类比总结

### TypeScript/Node.js 视角

| 概念 | TypeScript/Node.js 类比 | 核心相似点 |
|------|-------------------------|-----------|
| Skills | npm 包 | 能力封装和分发 |
| SKILL.md | package.json + index.ts | 元数据 + 实现 |
| 技能加载 | 模块解析 | 目录扫描和注册 |
| 技能调用 | 函数调用 | 名称调用和参数传递 |
| 技能组合 | 高阶函数 | 能力组合和复用 |

### 日常生活视角

| 概念 | 日常生活类比 | 核心相似点 |
|------|-------------|-----------|
| Skills | 手机 App | 功能模块和市场分发 |
| SKILL.md | 菜谱 | 步骤说明和可复用 |
| 技能加载 | 图书馆借书 | 索引和快速查找 |
| 技能调用 | 请教专家 | 专业能力和即时响应 |
| 技能组合 | 流水线作业 | 步骤组合和顺序执行 |

---

## 为什么需要双重类比？

### 1. 不同背景的学习者

**技术背景：**
- 熟悉 TypeScript/Node.js
- 理解模块系统和包管理
- 通过技术类比快速理解

**非技术背景：**
- 不熟悉编程概念
- 需要日常生活类比
- 通过具象化理解抽象概念

### 2. 不同层次的理解

**表层理解（日常生活类比）：**
- Skills 就像手机 App
- 可以下载、安装、使用
- 快速建立直觉

**深层理解（技术类比）：**
- Skills 就像 npm 包
- 理解加载机制、调用机制
- 掌握技术细节

### 3. 互补验证

**技术类比 → 日常生活类比：**
- 验证技术理解是否正确
- 能否用简单语言解释

**日常生活类比 → 技术类比：**
- 验证直觉是否准确
- 深入理解技术实现

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
