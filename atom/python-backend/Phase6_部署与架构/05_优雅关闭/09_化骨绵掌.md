# 化骨绵掌

> 10个2分钟知识卡片，快速掌握优雅关闭的核心要点

---

## 卡片1：优雅关闭的本质

**一句话：** 优雅关闭是在进程终止前，停止接收新请求、等待现有请求完成、清理资源的机制。

**举例：**
```python
# 优雅关闭 = 餐厅打烊
1. 收到 SIGTERM 信号 → 下班铃声响起
2. 停止接收新请求 → 翻牌子为"打烊中"
3. 等待现有请求完成 → 让顾客吃完
4. 清理资源 → 收拾桌椅、关灯、锁门
5. 退出进程 → 员工下班
```

**应用：** 在 AI Agent 后端中，优雅关闭确保 LLM 流式响应完成、数据库事务提交、向量数据库连接关闭。

---

## 卡片2：信号处理的三种信号

**一句话：** SIGTERM 可捕获用于优雅关闭，SIGINT 是 Ctrl+C，SIGKILL 无法捕获强制终止。

**举例：**
```python
import signal

def signal_handler(signum, frame):
    print(f"收到信号 {signum}")
    shutdown_event.set()  # 通知协程开始关闭

signal.signal(signal.SIGTERM, signal_handler)  # 优雅终止
signal.signal(signal.SIGINT, signal_handler)   # Ctrl+C
# SIGKILL 无法捕获！
```

**应用：** Docker stop 先发送 SIGTERM，等待10秒后发送 SIGKILL。Kubernetes 的 terminationGracePeriodSeconds 控制等待时间。

---

## 卡片3：请求排空的核心逻辑

**一句话：** 停止接收新请求，跟踪活跃请求数，等待所有请求完成。

**举例：**
```python
accepting_requests = True
active_requests = 0

@app.middleware("http")
async def shutdown_middleware(request, call_next):
    global active_requests

    if not accepting_requests:
        return JSONResponse(503, {"error": "Shutting down"})

    active_requests += 1
    try:
        return await call_next(request)
    finally:
        active_requests -= 1

# 关闭时
accepting_requests = False
while active_requests > 0:
    await asyncio.sleep(0.1)
```

**应用：** 在 AI Agent 后端中，长时间的 LLM 生成任务需要在循环中检查 shutdown_event，支持中断。

---

## 卡片4：资源清理的顺序

**一句话：** 先关闭外部连接（HTTP、Redis），再关闭数据库，最后卸载模型。

**举例：**
```python
async def cleanup_all_resources():
    # 1. HTTP 客户端（避免新的外部请求）
    await http_client.aclose()

    # 2. Redis（缓存层）
    await redis_client.close()

    # 3. 向量数据库
    await vector_db.close()

    # 4. 数据库（最后关闭，因为其他操作可能需要）
    await db_engine.dispose()

    # 5. 卸载模型（释放内存）
    del embedding_model
```

**应用：** 顺序很重要！数据库最后关闭，因为其他清理操作可能需要记录日志或保存状态。

---

## 卡片5：超时控制的三种策略

**一句话：** 单一超时简单但不灵活，分阶段超时灵活但总时间长，混合超时是最佳实践。

**举例：**
```python
# 混合超时：全局超时 + 分阶段超时
async def graceful_shutdown(global_timeout=60):
    start_time = time.time()

    def remaining_time():
        return max(0, global_timeout - (time.time() - start_time))

    # 阶段1：请求排空（最多30秒或剩余时间）
    await asyncio.wait_for(
        wait_for_requests(),
        timeout=min(30, remaining_time())
    )

    # 阶段2：资源清理（剩余时间）
    await asyncio.wait_for(
        cleanup_resources(),
        timeout=remaining_time()
    )
```

**应用：** Kubernetes 的 terminationGracePeriodSeconds 是全局超时，应用内部可以分阶段控制。

---

## 卡片6：asyncio.Task 的正确取消

**一句话：** 任务不会自动取消，需要显式调用 cancel()，并捕获 CancelledError。

**举例：**
```python
async def background_worker():
    try:
        while not shutdown_event.is_set():
            await do_work()
            await asyncio.sleep(1)
    except asyncio.CancelledError:
        print("任务被取消，正在清理...")
        await cleanup()
        raise  # 重新抛出异常

# 优雅关闭时
task.cancel()  # 请求取消
try:
    await task  # 等待取消完成
except asyncio.CancelledError:
    pass
```

**应用：** Agent 任务队列、后台工作线程、定时任务都需要显式取消。

---

## 卡片7：连接池的优雅关闭

**一句话：** dispose() 会等待活跃连接归还，不会强制中断查询。

**举例：**
```python
# SQLAlchemy 连接池
engine = create_async_engine(
    DATABASE_URL,
    pool_size=10,
    max_overflow=20,
)

# 优雅关闭
await engine.dispose()  # 等待所有连接归还

# 检查连接泄漏
pool = engine.pool
if pool.checkedout() > 0:
    print(f"警告：有 {pool.checkedout()} 个连接未归还")
```

**应用：** 使用上下文管理器（async with）管理 Session，确保连接正确归还。

---

## 卡片8：LLM 流式响应的优雅中断

**一句话：** 在生成循环中检查关闭信号，发送结束标记，保存已生成的内容。

**举例：**
```python
async def stream_llm_response(prompt: str):
    generated_content = []

    try:
        async for chunk in llm.astream(prompt):
            # 检查关闭信号
            if shutdown_event.is_set():
                # 保存已生成的内容
                await save_partial_response(
                    content="".join(generated_content)
                )
                # 发送结束标记
                yield {"type": "end", "reason": "shutdown"}
                break

            generated_content.append(chunk)
            yield {"type": "chunk", "content": chunk}

    except asyncio.CancelledError:
        await save_partial_response("".join(generated_content))
        raise
```

**应用：** 用户体验更好，已生成的内容不会丢失，LLM API 费用不会浪费。

---

## 卡片9：FastAPI lifespan 上下文管理器

**一句话：** lifespan 替代 startup/shutdown 事件，启动和关闭逻辑在同一个函数中。

**举例：**
```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    # 启动阶段
    app.state.db_engine = create_async_engine(DATABASE_URL)
    app.state.redis_client = Redis.from_url(REDIS_URL)

    yield  # 应用运行

    # 关闭阶段
    await app.state.redis_client.close()
    await app.state.db_engine.dispose()

app = FastAPI(lifespan=lifespan)
```

**应用：** 使用 app.state 存储资源，在路由中通过 request.app.state 访问。

---

## 卡片10：Kubernetes 环境的优雅关闭

**一句话：** 配置 terminationGracePeriodSeconds 和 preStop 钩子，与健康检查配合实现零停机部署。

**举例：**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  terminationGracePeriodSeconds: 60  # 全局超时
  containers:
  - name: app
    image: myapp:latest
    lifecycle:
      preStop:
        exec:
          # 给5秒时间让 readiness 探测失败
          command: ["/bin/sh", "-c", "sleep 5"]
    readinessProbe:
      httpGet:
        path: /ready
        port: 8000
```

**应用：** preStop 钩子让 Pod 从 Service 中移除，然后应用执行优雅关闭，实现零停机部署。

---

## 快速参考卡

### 优雅关闭检查清单

**信号处理：**
- [ ] 注册 SIGTERM 和 SIGINT 处理器
- [ ] 使用 asyncio.Event 通知协程
- [ ] 信号处理器是同步函数，只设置事件

**请求排空：**
- [ ] 实现请求排空中间件
- [ ] 跟踪活跃请求数
- [ ] 停止接收新请求
- [ ] 等待现有请求完成

**资源清理：**
- [ ] 关闭 HTTP 客户端
- [ ] 关闭 Redis 连接
- [ ] 关闭向量数据库连接
- [ ] 关闭数据库连接池
- [ ] 卸载 Embedding 模型

**异步任务：**
- [ ] 显式取消所有 asyncio.Task
- [ ] 捕获 CancelledError
- [ ] 等待任务完成

**超时控制：**
- [ ] 设置全局超时
- [ ] 为每个阶段设置超时
- [ ] 超时后继续下一阶段

**AI Agent 特定：**
- [ ] 中断 LLM 流式响应
- [ ] 发送结束标记
- [ ] 保存已生成的内容
- [ ] 清理 Agent 任务队列

### 常见错误速查

| 错误 | 正确做法 |
|------|---------|
| 使用 kill -9 | 使用 kill -SIGTERM |
| 只关闭数据库 | 关闭所有资源 |
| 不取消异步任务 | 显式取消并等待 |
| 不设置超时 | 设置全局和分阶段超时 |
| 忘记关闭 Session | 使用 async with |
| 不检查关闭信号 | 在长时间操作中检查 |

### 超时时间参考

| 场景 | 推荐超时 |
|------|---------|
| 快速请求 | 10秒 |
| 普通请求 | 30秒 |
| LLM 流式响应 | 60-90秒 |
| Agent 任务 | 60-120秒 |
| 资源清理 | 10秒 |
| Kubernetes 默认 | 30秒 |

### 信号速查

| 信号 | 编号 | 可捕获 | 用途 |
|------|------|--------|------|
| SIGTERM | 15 | ✅ | 优雅终止 |
| SIGINT | 2 | ✅ | Ctrl+C |
| SIGKILL | 9 | ❌ | 强制终止 |
| SIGHUP | 1 | ✅ | 重新加载配置 |

---

## 学习路径建议

### 初学者（第一次学习）
1. 卡片1：理解优雅关闭的本质
2. 卡片2：学习信号处理
3. 卡片3：掌握请求排空
4. 卡片9：使用 FastAPI lifespan

### 进阶学习（已有基础）
5. 卡片4：理解资源清理顺序
6. 卡片5：掌握超时控制
7. 卡片6：学习异步任务取消
8. 卡片7：理解连接池管理

### 实战应用（AI Agent 开发）
9. 卡片8：处理 LLM 流式响应
10. 卡片10：配置 Kubernetes 环境

### 复习巩固
- 使用快速参考卡检查实现
- 对照常见错误速查避免问题
- 参考超时时间表设置合理值

---

## 总结

**优雅关闭的核心：**
1. **信号处理**：捕获 SIGTERM，通知协程
2. **请求排空**：停止接收，等待完成
3. **资源清理**：按顺序关闭所有资源
4. **超时控制**：避免无限等待
5. **异步任务**：显式取消并等待

**记住：** 优雅关闭不是可选的，是生产环境的必需品。就像餐厅必须有打烊流程一样，服务也必须有优雅关闭流程。

**下一步：** 在实际项目中实现优雅关闭，测试各种场景，监控关闭过程，持续优化。
