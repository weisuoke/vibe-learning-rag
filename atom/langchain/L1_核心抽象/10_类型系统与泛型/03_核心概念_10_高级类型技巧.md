# 核心概念 10：高级类型技巧

## 一句话定义

**高级类型技巧包括协变逆变、ParamSpec、Self 类型、TypeForm 等 Python 类型系统的高级特性，让类型注解能够表达更复杂的类型关系，是构建类型安全框架和库的核心工具。**

---

## 为什么需要高级类型技巧？

### 问题：基础类型注解的局限性

基础类型注解无法表达某些复杂的类型关系：

```python
# 问题1：装饰器丢失函数签名
def decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

# 问题2：方法返回 self 的类型
class Builder:
    def set_name(self, name: str):
        self.name = name
        return self  # 返回类型是什么？

# 问题3：协变和逆变
class Animal: pass
class Dog(Animal): pass

# 容器类型的子类型关系？
```

**高级类型技巧的解决方案**：

```python
from typing import ParamSpec, TypeVar, Self

# ParamSpec：保留函数签名
P = ParamSpec('P')
T = TypeVar('T')

def decorator(func: Callable[P, T]) -> Callable[P, T]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
        return func(*args, **kwargs)
    return wrapper

# Self：方法返回自身类型
class Builder:
    def set_name(self, name: str) -> Self:
        self.name = name
        return self

# 协变逆变：精确的子类型关系
T_co = TypeVar('T_co', covariant=True)
```

---

## 1. 协变（Covariant）与逆变（Contravariant）

### 基本概念

**协变**：子类型关系保持方向
- 如果 Dog 是 Animal 的子类型
- 那么 Container[Dog] 是 Container[Animal] 的子类型

**逆变**：子类型关系反转方向
- 如果 Dog 是 Animal 的子类型
- 那么 Consumer[Animal] 是 Consumer[Dog] 的子类型

**不变**：没有子类型关系（默认）

### 协变示例

```python
from typing import TypeVar, Generic

T_co = TypeVar('T_co', covariant=True)

class ReadOnlyBox(Generic[T_co]):
    """只读容器（协变）"""
    def __init__(self, value: T_co):
        self._value = value

    def get(self) -> T_co:
        return self._value

# 协变：ReadOnlyBox[Dog] 可以赋值给 ReadOnlyBox[Animal]
class Animal:
    def speak(self) -> str:
        return "..."

class Dog(Animal):
    def speak(self) -> str:
        return "Woof!"

dog_box: ReadOnlyBox[Dog] = ReadOnlyBox(Dog())
animal_box: ReadOnlyBox[Animal] = dog_box  # ✅ 协变允许

# 安全：只能读取，Dog 是 Animal
animal: Animal = animal_box.get()
```

### 逆变示例

```python
from typing import TypeVar, Generic

T_contra = TypeVar('T_contra', contravariant=True)

class Sink(Generic[T_contra]):
    """只写容器（逆变）"""
    def put(self, item: T_contra) -> None:
        print(f"Received: {item}")

# 逆变：Sink[Animal] 可以赋值给 Sink[Dog]
animal_sink: Sink[Animal] = Sink()
dog_sink: Sink[Dog] = animal_sink  # ✅ 逆变允许

# 安全：可以接受 Dog（因为 animal_sink 可以接受任何 Animal）
dog_sink.put(Dog())
```

### 在 LangChain 中的应用

```python
from langchain_core.runnables import Runnable
from typing import TypeVar

# Runnable 的类型定义
Input = TypeVar('Input', contravariant=True)  # 输入逆变
Output = TypeVar('Output', covariant=True)    # 输出协变

class Runnable(Generic[Input, Output]):
    def invoke(self, input: Input) -> Output:
        ...

# 这样设计的好处：
# 1. 输入逆变：可以接受更宽泛的输入
# 2. 输出协变：可以返回更具体的输出
```

---

## 2. ParamSpec：保留函数签名

### 基本用法

```python
from typing import Callable, ParamSpec, TypeVar

P = ParamSpec('P')
T = TypeVar('T')

def decorator(func: Callable[P, T]) -> Callable[P, T]:
    """保留函数签名的装饰器"""
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@decorator
def add(a: int, b: int) -> int:
    return a + b

# ✅ 类型检查器知道 add 的参数类型
result: int = add(5, 3)  # ✅
result = add("hello", "world")  # ❌ 类型错误
```

### Concatenate：添加额外参数

```python
from typing import Callable, ParamSpec, TypeVar, Concatenate

P = ParamSpec('P')
T = TypeVar('T')

def add_logging(
    func: Callable[P, T]
) -> Callable[Concatenate[str, P], T]:
    """添加日志参数"""
    def wrapper(log_level: str, *args: P.args, **kwargs: P.kwargs) -> T:
        print(f"[{log_level}] Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@add_logging
def process(data: str) -> str:
    return data.upper()

# 使用：需要额外的 log_level 参数
result = process("INFO", "hello")  # "HELLO"
```

---

## 3. Self 类型（Python 3.11+）

### 基本用法

```python
from typing import Self

class Builder:
    """构建器模式"""
    def __init__(self):
        self.name = ""
        self.age = 0

    def set_name(self, name: str) -> Self:
        self.name = name
        return self

    def set_age(self, age: int) -> Self:
        self.age = age
        return self

    def build(self) -> dict:
        return {"name": self.name, "age": self.age}

# 链式调用（类型安全）
builder = Builder()
result = builder.set_name("Alice").set_age(30).build()
```

### 继承中的 Self

```python
from typing import Self

class Animal:
    def __init__(self, name: str):
        self.name = name

    def clone(self) -> Self:
        """克隆自身"""
        return type(self)(self.name)

class Dog(Animal):
    def __init__(self, name: str, breed: str = "Unknown"):
        super().__init__(name)
        self.breed = breed

    def clone(self) -> Self:
        return type(self)(self.name, self.breed)

# Self 自动推断为正确的类型
dog = Dog("Buddy", "Golden Retriever")
cloned_dog: Dog = dog.clone()  # ✅ 类型是 Dog，不是 Animal
```

---

## 4. TypeForm（PEP 747, mypy 1.19+）

### 基本概念

TypeForm 用于表示"类型的类型"，在需要传递类型本身作为参数时使用。

```python
from typing import TypeForm, TypeVar

T = TypeVar('T')

def create_instance(cls: TypeForm[T]) -> T:
    """创建类的实例"""
    return cls()

# 使用
class User:
    def __init__(self):
        self.name = "Unknown"

user: User = create_instance(User)  # ✅ 类型推断为 User
```

### 与 type[T] 的区别

```python
from typing import TypeForm, TypeVar

T = TypeVar('T')

# type[T]：具体的类对象
def create_with_type(cls: type[T]) -> T:
    return cls()

# TypeForm[T]：类型表达式（更通用）
def create_with_typeform(cls: TypeForm[T]) -> T:
    return cls()

# TypeForm 可以接受更多类型表达式
# 如 Union, Optional 等
```

---

## 5. 高级泛型模式

### 递归类型

```python
from typing import TypeVar, Generic

T = TypeVar('T')

class TreeNode(Generic[T]):
    """递归类型：树节点"""
    def __init__(self, value: T, children: list['TreeNode[T]'] | None = None):
        self.value = value
        self.children = children or []

# 使用
tree: TreeNode[int] = TreeNode(1, [
    TreeNode(2),
    TreeNode(3, [TreeNode(4)])
])
```

### 高阶类型

```python
from typing import TypeVar, Generic, Callable

T = TypeVar('T')
U = TypeVar('U')

class Functor(Generic[T]):
    """函子：可映射的容器"""
    def __init__(self, value: T):
        self.value = value

    def map(self, fn: Callable[[T], U]) -> 'Functor[U]':
        return Functor(fn(self.value))

# 使用
functor = Functor(5)
result = functor.map(lambda x: x * 2).map(str)
# result 的类型是 Functor[str]
```

---

## 6. 实战示例：类型安全的装饰器库

```python
"""
类型安全的装饰器库
演示：高级类型技巧的综合应用
"""

from typing import Callable, ParamSpec, TypeVar, Concatenate, Self
from functools import wraps
import time

P = ParamSpec('P')
T = TypeVar('T')

# ===== 1. 基础装饰器（ParamSpec）=====

def timing(func: Callable[P, T]) -> Callable[P, T]:
    """测量执行时间"""
    @wraps(func)
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f}s")
        return result
    return wrapper

@timing
def process_data(data: list[int], multiplier: int) -> list[int]:
    return [x * multiplier for x in data]

# ✅ 类型安全
result: list[int] = process_data([1, 2, 3], 2)

# ===== 2. 添加参数的装饰器（Concatenate）=====

def with_context(
    func: Callable[P, T]
) -> Callable[Concatenate[dict, P], T]:
    """添加上下文参数"""
    @wraps(func)
    def wrapper(context: dict, *args: P.args, **kwargs: P.kwargs) -> T:
        print(f"Context: {context}")
        return func(*args, **kwargs)
    return wrapper

@with_context
def greet(name: str) -> str:
    return f"Hello, {name}"

# 使用：需要额外的 context 参数
message = greet({"user_id": "123"}, "Alice")

# ===== 3. 构建器模式（Self）=====

class QueryBuilder:
    """SQL 查询构建器"""
    def __init__(self):
        self.table = ""
        self.conditions: list[str] = []
        self.limit_value = 0

    def from_table(self, table: str) -> Self:
        self.table = table
        return self

    def where(self, condition: str) -> Self:
        self.conditions.append(condition)
        return self

    def limit(self, n: int) -> Self:
        self.limit_value = n
        return self

    def build(self) -> str:
        query = f"SELECT * FROM {self.table}"
        if self.conditions:
            query += " WHERE " + " AND ".join(self.conditions)
        if self.limit_value:
            query += f" LIMIT {self.limit_value}"
        return query

# 链式调用
query = (QueryBuilder()
    .from_table("users")
    .where("age > 18")
    .where("active = true")
    .limit(10)
    .build())

print(f"\n=== 高级类型技巧示例 ===")
print(f"Query: {query}")

# ===== 4. 协变容器 =====

from typing import Generic

T_co = TypeVar('T_co', covariant=True)

class ImmutableList(Generic[T_co]):
    """不可变列表（协变）"""
    def __init__(self, items: list[T_co]):
        self._items = list(items)

    def get(self, index: int) -> T_co:
        return self._items[index]

    def __len__(self) -> int:
        return len(self._items)

# 协变：ImmutableList[Dog] 可以赋值给 ImmutableList[Animal]
class Animal:
    def speak(self) -> str:
        return "..."

class Dog(Animal):
    def speak(self) -> str:
        return "Woof!"

dog_list: ImmutableList[Dog] = ImmutableList([Dog(), Dog()])
animal_list: ImmutableList[Animal] = dog_list  # ✅ 协变允许

print(f"\nImmutableList length: {len(animal_list)}")
```

**运行输出**：
```
process_data took 0.0001s

=== 高级类型技巧示例 ===
Query: SELECT * FROM users WHERE age > 18 AND active = true LIMIT 10

ImmutableList length: 2
```

---

## 7. 2025-2026 最佳实践

### 1. 优先使用 Self（Python 3.11+）

```python
# ❌ 旧方式
from typing import TypeVar

T = TypeVar('T', bound='Builder')

class Builder:
    def set_name(self: T, name: str) -> T:
        ...

# ✅ 新方式
from typing import Self

class Builder:
    def set_name(self, name: str) -> Self:
        ...
```

### 2. 使用 ParamSpec 保留签名

```python
# ✅ 推荐
from typing import ParamSpec, TypeVar

P = ParamSpec('P')
T = TypeVar('T')

def decorator(func: Callable[P, T]) -> Callable[P, T]:
    ...
```

### 3. 明确协变逆变

```python
# ✅ 明确标记
T_co = TypeVar('T_co', covariant=True)      # 协变
T_contra = TypeVar('T_contra', contravariant=True)  # 逆变
T = TypeVar('T')  # 不变（默认）
```

### 4. 避免过度使用高级特性

```python
# ❌ 过度设计
from typing import TypeVar, Generic, Protocol, ParamSpec

T = TypeVar('T', bound='Comparable')
P = ParamSpec('P')

class Comparable(Protocol):
    def __lt__(self, other: 'Comparable') -> bool: ...

class Container(Generic[T]):
    ...

# ✅ 从简单开始
T = TypeVar('T')

class Container(Generic[T]):
    ...
```

---

## 8. 常见陷阱

### 1. 协变类型不能作为参数

```python
T_co = TypeVar('T_co', covariant=True)

# ❌ 错误
class Bad(Generic[T_co]):
    def set(self, value: T_co) -> None:  # 类型检查器报错
        ...

# ✅ 正确
class Good(Generic[T_co]):
    def get(self) -> T_co:
        ...
```

### 2. ParamSpec 只能用于 Callable

```python
P = ParamSpec('P')

# ❌ 错误
class Bad(Generic[P]):  # ParamSpec 不能用于类
    ...

# ✅ 正确
def decorator(func: Callable[P, T]) -> Callable[P, T]:
    ...
```

### 3. Self 不能用于类方法

```python
from typing import Self

class Bad:
    @classmethod
    def create(cls) -> Self:  # ❌ 错误
        return cls()

# ✅ 正确
class Good:
    @classmethod
    def create(cls) -> 'Good':
        return cls()
```

---

## 学习检查清单

- [ ] 理解协变、逆变、不变的概念
- [ ] 掌握 ParamSpec 保留函数签名
- [ ] 了解 Concatenate 添加参数
- [ ] 掌握 Self 类型的使用
- [ ] 了解 TypeForm 的作用
- [ ] 理解高级泛型模式
- [ ] 能够创建类型安全的装饰器
- [ ] 遵循 2025-2026 最佳实践

---

## 下一步学习

- **04_最小可用.md** - 学习 20% 核心知识
- **09_化骨绵掌.md** - 巩固所有知识点
- **实战代码系列** - 应用高级类型技巧

---

## 参考资源

1. [PEP 612 – Parameter Specification Variables](https://peps.python.org/pep-0612/) - ParamSpec 规范
2. [PEP 673 – Self Type](https://peps.python.org/pep-0673/) - Self 类型规范
3. [PEP 747 – TypeForm](https://peps.python.org/pep-0747/) - TypeForm 规范
4. [Python Typing in 2025: A Comprehensive Guide](https://khaled-jallouli.medium.com/python-typing-in-2025-a-comprehensive-guide-d61b4f562b99)
5. [Mypy 1.19 released](https://mypy-lang.blogspot.com/2025/11/mypy-119-released.html) - PEP 747 支持
6. [Advanced Python Type Hinting](https://dhirendrabiswal.com/advanced-python-type-hinting-generics-protocols-and-structural-subtyping-explained)
7. [Python typing 官方文档](https://docs.python.org/3/library/typing.html)
