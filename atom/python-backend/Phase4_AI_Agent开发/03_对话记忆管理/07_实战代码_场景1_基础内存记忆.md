# 实战代码 - 场景1：基础内存记忆

本文件演示最基础的对话记忆管理实现。

---

## 场景描述

实现一个简单的命令行对话机器人，使用内存记忆管理对话历史。

**功能要求：**
- 支持多轮对话
- 记住用户之前说过的话
- 可以查看对话历史
- 可以清空历史

---

## 完整代码

```python
"""
场景1：基础内存记忆
演示：使用 ConversationBufferMemory 实现简单的对话机器人
"""

import os
from dotenv import load_dotenv
from langchain.memory import ConversationBufferMemory
from langchain_openai import ChatOpenAI
from langchain.chains import ConversationChain

# 加载环境变量
load_dotenv()

# ===== 1. 初始化组件 =====
print("=== 初始化对话机器人 ===\n")

# 创建记忆
memory = ConversationBufferMemory()
print("✓ 创建 ConversationBufferMemory")

# 创建 LLM
llm = ChatOpenAI(
    temperature=0.7,
    model="gpt-3.5-turbo"
)
print("✓ 创建 ChatOpenAI")

# 创建对话链
conversation = ConversationChain(
    llm=llm,
    memory=memory,
    verbose=False  # 设置为 True 可以看到详细的 Prompt
)
print("✓ 创建 ConversationChain\n")

# ===== 2. 对话函数 =====
def chat(user_input: str) -> str:
    """发送消息并获取回复"""
    response = conversation.predict(input=user_input)
    return response

def show_history():
    """显示对话历史"""
    history = memory.load_memory_variables({})
    print("\n" + "="*50)
    print("对话历史：")
    print("="*50)
    if history["history"]:
        print(history["history"])
    else:
        print("（暂无历史记录）")
    print("="*50 + "\n")

def clear_history():
    """清空对话历史"""
    memory.clear()
    print("✓ 对话历史已清空\n")

def show_stats():
    """显示统计信息"""
    message_count = len(memory.chat_memory.messages)
    print(f"\n统计信息：")
    print(f"  - 消息总数：{message_count} 条")
    print(f"  - 对话轮数：{message_count // 2} 轮\n")

# ===== 3. 模拟对话 =====
print("=== 开始对话 ===\n")

# 第1轮对话
print("用户: 我叫张三，我是一名前端工程师")
response1 = chat("我叫张三，我是一名前端工程师")
print(f"AI: {response1}\n")

# 第2轮对话
print("用户: 我想学习 Python 后端开发")
response2 = chat("我想学习 Python 后端开发")
print(f"AI: {response2}\n")

# 第3轮对话（测试记忆）
print("用户: 我叫什么名字？")
response3 = chat("我叫什么名字？")
print(f"AI: {response3}\n")

# 第4轮对话（测试记忆）
print("用户: 我的职业是什么？")
response4 = chat("我的职业是什么？")
print(f"AI: {response4}\n")

# 显示统计信息
show_stats()

# 显示完整历史
show_history()

# ===== 4. 清空历史并重新对话 =====
print("=== 清空历史后重新对话 ===\n")

clear_history()

# 第5轮对话（AI 应该不记得之前的信息）
print("用户: 我叫什么名字？")
response5 = chat("我叫什么名字？")
print(f"AI: {response5}\n")

show_stats()

# ===== 5. 手动管理记忆 =====
print("=== 手动管理记忆 ===\n")

# 方式1：使用 save_context
memory.save_context(
    {"input": "我喜欢打篮球"},
    {"output": "打篮球是很好的运动！"}
)
print("✓ 使用 save_context 保存对话")

# 方式2：直接操作 chat_memory
memory.chat_memory.add_user_message("我今年25岁")
memory.chat_memory.add_ai_message("好的，我记住了。")
print("✓ 使用 chat_memory 直接添加消息\n")

# 显示历史
show_history()

# ===== 6. 查看内部消息对象 =====
print("=== 查看内部消息对象 ===\n")

print("消息对象列表：")
for i, msg in enumerate(memory.chat_memory.messages, 1):
    print(f"{i}. {msg.__class__.__name__}: {msg.content}")

print("\n" + "="*50)
print("示例完成！")
print("="*50)
```

---

## 运行输出示例

```
=== 初始化对话机器人 ===

✓ 创建 ConversationBufferMemory
✓ 创建 ChatOpenAI
✓ 创建 ConversationChain

=== 开始对话 ===

用户: 我叫张三，我是一名前端工程师
AI: 你好，张三！很高兴认识你。作为前端工程师，你一定对用户界面和用户体验有很深的理解。

用户: 我想学习 Python 后端开发
AI: 很好的选择！Python 后端开发是一个很有前景的方向。作为前端工程师，你已经有了很好的基础，学习后端会让你成为全栈工程师。

用户: 我叫什么名字？
AI: 你叫张三。

用户: 我的职业是什么？
AI: 你是一名前端工程师。

统计信息：
  - 消息总数：8 条
  - 对话轮数：4 轮

==================================================
对话历史：
==================================================
Human: 我叫张三，我是一名前端工程师
AI: 你好，张三！很高兴认识你。作为前端工程师，你一定对用户界面和用户体验有很深的理解。
Human: 我想学习 Python 后端开发
AI: 很好的选择！Python 后端开发是一个很有前景的方向。作为前端工程师，你已经有了很好的基础，学习后端会让你成为全栈工程师。
Human: 我叫什么名字？
AI: 你叫张三。
Human: 我的职业是什么？
AI: 你是一名前端工程师。
==================================================

=== 清空历史后重新对话 ===

✓ 对话历史已清空

用户: 我叫什么名字？
AI: 抱歉，我不知道你的名字。你可以告诉我吗？

统计信息：
  - 消息总数：2 条
  - 对话轮数：1 轮

=== 手动管理记忆 ===

✓ 使用 save_context 保存对话
✓ 使用 chat_memory 直接添加消息

==================================================
对话历史：
==================================================
Human: 我叫什么名字？
AI: 抱歉，我不知道你的名字。你可以告诉我吗？
Human: 我喜欢打篮球
AI: 打篮球是很好的运动！
Human: 我今年25岁
AI: 好的，我记住了。
==================================================

=== 查看内部消息对象 ===

消息对象列表：
1. HumanMessage: 我叫什么名字？
2. AIMessage: 抱歉，我不知道你的名字。你可以告诉我吗？
3. HumanMessage: 我喜欢打篮球
4. AIMessage: 打篮球是很好的运动！
5. HumanMessage: 我今年25岁
6. AIMessage: 好的，我记住了。

==================================================
示例完成！
==================================================
```

---

## 代码说明

### 1. 核心组件

```python
# 记忆
memory = ConversationBufferMemory()

# LLM
llm = ChatOpenAI(temperature=0.7)

# 对话链
conversation = ConversationChain(llm=llm, memory=memory)
```

**ConversationChain 会自动：**
- 从 memory 加载历史记录
- 将历史记录注入到 Prompt
- 调用 LLM 生成回复
- 将新的对话保存到 memory

### 2. 对话流程

```
用户输入
   ↓
conversation.predict(input=user_input)
   ↓
memory.load_memory_variables({})  # 加载历史
   ↓
构建 Prompt（历史 + 新输入）
   ↓
llm.invoke(prompt)  # 调用 LLM
   ↓
memory.save_context(...)  # 保存新对话
   ↓
返回回复
```

### 3. 记忆操作

**查看历史：**
```python
history = memory.load_memory_variables({})
print(history["history"])  # 字符串格式
```

**清空历史：**
```python
memory.clear()
```

**手动添加消息：**
```python
# 方式1：save_context
memory.save_context({"input": "..."}, {"output": "..."})

# 方式2：直接操作 chat_memory
memory.chat_memory.add_user_message("...")
memory.chat_memory.add_ai_message("...")
```

---

## 关键要点

1. **ConversationBufferMemory 是最简单的记忆类型**
   - 完整存储所有对话
   - 适合短对话（< 10 轮）

2. **ConversationChain 自动管理记忆**
   - 不需要手动加载和保存
   - 只需调用 `predict()` 方法

3. **记忆是基于内存的**
   - 服务重启后丢失
   - 不支持跨进程共享

4. **可以手动操作记忆**
   - 查看历史：`load_memory_variables()`
   - 清空历史：`clear()`
   - 添加消息：`save_context()` 或 `chat_memory.add_*_message()`

---

## 扩展练习

1. **添加命令行交互**
   ```python
   while True:
       user_input = input("用户: ")
       if user_input == "/quit":
           break
       elif user_input == "/history":
           show_history()
       elif user_input == "/clear":
           clear_history()
       else:
           response = chat(user_input)
           print(f"AI: {response}")
   ```

2. **添加 Token 计数**
   ```python
   import tiktoken

   def count_tokens(text: str) -> int:
       encoding = tiktoken.encoding_for_model("gpt-3.5-turbo")
       return len(encoding.encode(text))

   history = memory.load_memory_variables({})
   token_count = count_tokens(history["history"])
   print(f"当前 Token 使用：{token_count}")
   ```

3. **添加自动清理**
   ```python
   MAX_MESSAGES = 20

   def chat_with_limit(user_input: str) -> str:
       response = conversation.predict(input=user_input)

       # 检查消息数量
       if len(memory.chat_memory.messages) > MAX_MESSAGES:
           # 删除最旧的2条消息（1轮对话）
           memory.chat_memory.messages = memory.chat_memory.messages[2:]

       return response
   ```

---

## 下一步

- **场景2**：窗口记忆（控制 Token 消耗）
- **场景3**：FastAPI 集成（多用户对话 API）
- **场景4**：持久化存储（PostgreSQL/Redis）
