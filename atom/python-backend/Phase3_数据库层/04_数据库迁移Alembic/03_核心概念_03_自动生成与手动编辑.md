# 核心概念3：自动生成与手动编辑

**Alembic 的 autogenerate 功能通过对比 SQLAlchemy 模型和数据库 schema 自动生成迁移脚本，但有明确的限制，需要人工检查和手动编辑以处理复杂场景。**

---

## 3.1 autogenerate 的工作原理

### 核心流程

**autogenerate 通过4个步骤生成迁移脚本：**

```python
# 1. 读取数据库 schema
# Alembic 连接数据库，使用 SQLAlchemy 的反射机制读取当前表结构
from sqlalchemy import MetaData, create_engine

engine = create_engine(DATABASE_URL)
metadata = MetaData()
metadata.reflect(bind=engine)

# 获取所有表、列、索引、约束
tables = metadata.tables
# {'users': Table('users', ...), 'posts': Table('posts', ...)}

# 2. 读取 SQLAlchemy 模型定义
# 从 env.py 的 target_metadata 读取模型
from app.core.database import Base
target_metadata = Base.metadata

# 获取模型定义的所有表
model_tables = target_metadata.tables
# {'users': Table('users', ...), 'posts': Table('posts', ...), 'conversations': Table('conversations', ...)}

# 3. 对比差异
# 使用 Alembic 的 compare 模块对比数据库和模型
from alembic.autogenerate import compare_metadata

diff = compare_metadata(context, target_metadata)
# [
#   ('add_table', Table('conversations', ...)),
#   ('add_column', 'users', Column('avatar', String())),
#   ('remove_column', 'users', Column('old_field', String()))
# ]

# 4. 生成迁移脚本
# 根据差异生成 op.* 操作
def upgrade():
    op.create_table('conversations', ...)
    op.add_column('users', sa.Column('avatar', sa.String()))
    op.drop_column('users', 'old_field')
```

### 配置 autogenerate

**在 `alembic/env.py` 中配置 autogenerate：**

```python
# alembic/env.py
from app.core.database import Base
from app.models import User, Post, Conversation  # 导入所有模型

# 设置 target_metadata
target_metadata = Base.metadata

def run_migrations_online():
    """在线模式：连接数据库运行迁移"""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,  # 关键配置
            compare_type=True,  # 比较列类型
            compare_server_default=True,  # 比较默认值
        )

        with context.begin_transaction():
            context.run_migrations()
```

**重要配置选项：**

```python
context.configure(
    connection=connection,
    target_metadata=target_metadata,

    # 比较选项
    compare_type=True,  # 比较列类型变更
    compare_server_default=True,  # 比较默认值变更

    # 包含/排除选项
    include_schemas=True,  # 包含 schema
    include_object=filter_function,  # 自定义过滤函数

    # 渲染选项
    render_as_batch=True,  # SQLite 批量模式
)
```

---

## 3.2 autogenerate 能检测的变更

### 1. 表操作

**✅ 可以检测：**

```python
# 新增表
class NewTable(Base):
    __tablename__ = "new_table"
    id = Column(Integer, primary_key=True)

# autogenerate 生成：
def upgrade():
    op.create_table('new_table',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

# 删除表（从模型中移除）
# autogenerate 生成：
def upgrade():
    op.drop_table('old_table')
```

### 2. 列操作

**✅ 可以检测：**

```python
# 新增列
class User(Base):
    avatar = Column(String)  # 新增

# autogenerate 生成：
def upgrade():
    op.add_column('users', sa.Column('avatar', sa.String(), nullable=True))

# 删除列（从模型中移除）
# autogenerate 生成：
def upgrade():
    op.drop_column('users', 'old_field')

# 修改列类型（需要 compare_type=True）
class User(Base):
    age = Column(Integer)  # 从 String 改为 Integer

# autogenerate 生成：
def upgrade():
    op.alter_column('users', 'age',
        existing_type=sa.String(),
        type_=sa.Integer(),
        existing_nullable=True
    )

# 修改列可空性
class User(Base):
    email = Column(String, nullable=False)  # 从 nullable=True 改为 False

# autogenerate 生成：
def upgrade():
    op.alter_column('users', 'email',
        existing_type=sa.String(),
        nullable=False
    )
```

### 3. 索引操作

**✅ 可以检测：**

```python
# 新增索引
class User(Base):
    email = Column(String, index=True)  # 添加索引

# autogenerate 生成：
def upgrade():
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=False)

# 删除索引（从模型中移除 index=True）
# autogenerate 生成：
def upgrade():
    op.drop_index(op.f('ix_users_email'), table_name='users')

# 唯一索引
class User(Base):
    email = Column(String, unique=True)

# autogenerate 生成：
def upgrade():
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
```

### 4. 外键约束

**✅ 可以检测：**

```python
# 新增外键
class Post(Base):
    user_id = Column(Integer, ForeignKey("users.id"))

# autogenerate 生成：
def upgrade():
    op.create_foreign_key(None, 'posts', 'users', ['user_id'], ['id'])

# 删除外键（从模型中移除 ForeignKey）
# autogenerate 生成：
def upgrade():
    op.drop_constraint('fk_posts_user_id', 'posts', type_='foreignkey')
```

---

## 3.3 autogenerate 无法检测的变更

### 1. 重命名操作 ❌

**问题：重命名会被识别为删除+创建**

```python
# 场景：重命名字段
# 旧模型
class User(Base):
    username = Column(String)

# 新模型
class User(Base):
    name = Column(String)  # 重命名 username -> name

# autogenerate 生成（错误）：
def upgrade():
    op.drop_column('users', 'username')  # 删除旧字段
    op.add_column('users', sa.Column('name', sa.String()))  # 添加新字段
    # 问题：数据丢失！

# 正确的手动编辑：
def upgrade():
    op.alter_column('users', 'username', new_column_name='name')
```

**解决方案：手动编辑迁移脚本**

```python
# 1. 运行 autogenerate
alembic revision --autogenerate -m "rename username to name"

# 2. 手动编辑生成的迁移脚本
# versions/abc123_rename_username_to_name.py
def upgrade():
    # 修改前：
    # op.drop_column('users', 'username')
    # op.add_column('users', sa.Column('name', sa.String()))

    # 修改后：
    op.alter_column('users', 'username', new_column_name='name')

def downgrade():
    op.alter_column('users', 'name', new_column_name='username')
```

### 2. 表重命名 ❌

```python
# 场景：重命名表
# 旧模型
class OldUsers(Base):
    __tablename__ = "old_users"

# 新模型
class Users(Base):
    __tablename__ = "users"

# autogenerate 生成（错误）：
def upgrade():
    op.drop_table('old_users')
    op.create_table('users', ...)
    # 问题：数据丢失！

# 正确的手动编辑：
def upgrade():
    op.rename_table('old_users', 'users')
```

### 3. 约束变更 ❌

```python
# 场景：添加 CHECK 约束
class User(Base):
    age = Column(Integer, CheckConstraint('age > 0'))

# autogenerate 生成：
# （什么都不生成，无法检测 CHECK 约束）

# 手动创建迁移：
alembic revision -m "add age check constraint"

def upgrade():
    op.create_check_constraint(
        'ck_users_age_positive',
        'users',
        'age > 0'
    )

def downgrade():
    op.drop_constraint('ck_users_age_positive', 'users', type_='check')
```

### 4. 枚举类型变更 ❌

```python
# 场景：修改 PostgreSQL ENUM 类型
from sqlalchemy.dialects.postgresql import ENUM

# 旧模型
class User(Base):
    status = Column(ENUM('active', 'inactive', name='user_status'))

# 新模型
class User(Base):
    status = Column(ENUM('active', 'inactive', 'pending', name='user_status'))  # 添加 'pending'

# autogenerate 生成：
# （什么都不生成，无法检测 ENUM 变更）

# 手动创建迁移：
alembic revision -m "add pending status to user_status enum"

def upgrade():
    # PostgreSQL ENUM 类型的修改比较复杂
    op.execute("ALTER TYPE user_status ADD VALUE 'pending'")

def downgrade():
    # ENUM 类型无法删除值，需要重建类型
    op.execute("""
        ALTER TABLE users ALTER COLUMN status TYPE VARCHAR(20);
        DROP TYPE user_status;
        CREATE TYPE user_status AS ENUM ('active', 'inactive');
        ALTER TABLE users ALTER COLUMN status TYPE user_status USING status::user_status;
    """)
```

### 5. 数据库特定类型 ❌

```python
# 场景：PostgreSQL 特定类型
from sqlalchemy.dialects.postgresql import JSONB, ARRAY
from pgvector.sqlalchemy import Vector

class Document(Base):
    metadata = Column(JSONB)  # PostgreSQL JSONB
    tags = Column(ARRAY(String))  # PostgreSQL 数组
    embedding = Column(Vector(1536))  # pgvector 向量

# autogenerate 可能无法正确识别这些类型

# 手动创建迁移：
alembic revision -m "add special columns"

def upgrade():
    # 启用扩展
    op.execute("CREATE EXTENSION IF NOT EXISTS vector")

    # 添加列
    op.add_column('documents', sa.Column('metadata', JSONB, nullable=True))
    op.add_column('documents', sa.Column('tags', ARRAY(sa.String()), nullable=True))
    op.add_column('documents', sa.Column('embedding', Vector(1536), nullable=True))
```

### 6. 触发器、存储过程、视图 ❌

```python
# 场景：创建触发器
# autogenerate 完全无法检测

# 手动创建迁移：
alembic revision -m "add updated_at trigger"

def upgrade():
    # 创建触发器函数
    op.execute("""
        CREATE OR REPLACE FUNCTION update_updated_at_column()
        RETURNS TRIGGER AS $$
        BEGIN
            NEW.updated_at = now();
            RETURN NEW;
        END;
        $$ language 'plpgsql';
    """)

    # 创建触发器
    op.execute("""
        CREATE TRIGGER update_users_updated_at
        BEFORE UPDATE ON users
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column();
    """)

def downgrade():
    op.execute("DROP TRIGGER IF EXISTS update_users_updated_at ON users")
    op.execute("DROP FUNCTION IF EXISTS update_updated_at_column()")
```

### 7. 数据迁移 ❌

```python
# 场景：修改现有数据
# autogenerate 只能生成 schema 变更，无法生成数据迁移

# 手动创建迁移：
alembic revision -m "migrate user data"

def upgrade():
    # 1. 添加新字段
    op.add_column('users', sa.Column('full_name', sa.String(), nullable=True))

    # 2. 迁移数据
    op.execute("""
        UPDATE users
        SET full_name = first_name || ' ' || last_name
        WHERE full_name IS NULL
    """)

    # 3. 设置为非空
    op.alter_column('users', 'full_name', nullable=False)

    # 4. 删除旧字段
    op.drop_column('users', 'first_name')
    op.drop_column('users', 'last_name')
```

---

## 3.4 手动编辑迁移脚本的最佳实践

### 1. 检查 autogenerate 的输出

```bash
# 1. 生成迁移
alembic revision --autogenerate -m "add avatar"

# 2. 立即检查生成的文件
cat alembic/versions/abc123_add_avatar.py

# 3. 检查要点：
# - 是否有意外的删除操作？
# - 是否有重命名被识别为删除+创建？
# - 是否遗漏了约束、索引？
# - 是否需要数据迁移？
```

### 2. 使用 --sql 预览

```bash
# 预览迁移会生成的 SQL（不实际执行）
alembic upgrade head --sql

# 输出：
# CREATE TABLE conversations (
#     id INTEGER NOT NULL,
#     user_id INTEGER,
#     title VARCHAR,
#     PRIMARY KEY (id)
# );
# ...

# 检查 SQL 是否符合预期
```

### 3. 在开发环境测试

```bash
# 1. 备份数据库
pg_dump mydb > backup.sql

# 2. 应用迁移
alembic upgrade head

# 3. 验证数据库结构
psql mydb -c "\d users"

# 4. 如果有问题，回滚并修改
alembic downgrade -1
# 修改迁移脚本
alembic upgrade head
```

### 4. 添加注释说明

```python
# versions/abc123_complex_migration.py
def upgrade():
    # 注意：这个迁移包含数据迁移，可能需要较长时间
    # 预计在100万行数据上需要约5分钟

    # 步骤1：添加新字段
    op.add_column('users', sa.Column('full_name', sa.String(), nullable=True))

    # 步骤2：迁移数据（批量处理，避免锁表）
    op.execute("""
        UPDATE users
        SET full_name = first_name || ' ' || last_name
        WHERE full_name IS NULL
    """)

    # 步骤3：设置为非空
    op.alter_column('users', 'full_name', nullable=False)

    # 步骤4：删除旧字段
    op.drop_column('users', 'first_name')
    op.drop_column('users', 'last_name')
```

### 5. 分步迁移

```python
# 对于复杂变更，拆分成多个小迁移

# 迁移1：添加新字段
# versions/abc123_add_full_name.py
def upgrade():
    op.add_column('users', sa.Column('full_name', sa.String(), nullable=True))

# 迁移2：迁移数据
# versions/def456_migrate_full_name.py
def upgrade():
    op.execute("""
        UPDATE users
        SET full_name = first_name || ' ' || last_name
        WHERE full_name IS NULL
    """)

# 迁移3：删除旧字段
# versions/ghi789_remove_old_name_fields.py
def upgrade():
    op.drop_column('users', 'first_name')
    op.drop_column('users', 'last_name')
```

---

## 3.5 自定义 autogenerate 行为

### 排除特定表

```python
# alembic/env.py
def include_object(object, name, type_, reflected, compare_to):
    """自定义过滤函数，排除特定表"""
    # 排除临时表
    if type_ == "table" and name.startswith("temp_"):
        return False

    # 排除特定表
    if type_ == "table" and name in ["alembic_version", "spatial_ref_sys"]:
        return False

    return True

# 配置
context.configure(
    connection=connection,
    target_metadata=target_metadata,
    include_object=include_object,  # 使用自定义过滤
)
```

### 自定义类型比较

```python
# alembic/env.py
from sqlalchemy import String, Text

def compare_type(context, inspected_column, metadata_column, inspected_type, metadata_type):
    """自定义类型比较逻辑"""
    # 将 String 和 Text 视为相同类型
    if isinstance(inspected_type, String) and isinstance(metadata_type, Text):
        return False  # 不生成变更

    if isinstance(inspected_type, Text) and isinstance(metadata_type, String):
        return False

    # 默认比较
    return None

# 配置
context.configure(
    connection=connection,
    target_metadata=target_metadata,
    compare_type=compare_type,  # 使用自定义比较
)
```

### 自定义服务器默认值比较

```python
# alembic/env.py
def compare_server_default(context, inspected_column, metadata_column, inspected_default, metadata_default, rendered_metadata_default):
    """自定义默认值比较逻辑"""
    # 忽略 now() 和 CURRENT_TIMESTAMP 的差异
    if inspected_default in ["now()", "CURRENT_TIMESTAMP"] and metadata_default in ["now()", "CURRENT_TIMESTAMP"]:
        return False

    # 默认比较
    return None

# 配置
context.configure(
    connection=connection,
    target_metadata=target_metadata,
    compare_server_default=compare_server_default,
)
```

---

## 3.6 在 AI Agent 后端开发中的应用

### 场景1：添加向量存储字段（手动编辑）

```python
# 1. 定义模型
from pgvector.sqlalchemy import Vector

class Document(Base):
    __tablename__ = "documents"
    id = Column(Integer, primary_key=True)
    content = Column(Text)
    embedding = Column(Vector(1536))  # pgvector 类型

# 2. 运行 autogenerate（可能无法识别 Vector 类型）
alembic revision --autogenerate -m "add embedding to documents"

# 3. 手动编辑迁移脚本
# versions/abc123_add_embedding_to_documents.py
from pgvector.sqlalchemy import Vector

def upgrade():
    # 1. 启用 pgvector 扩展
    op.execute("CREATE EXTENSION IF NOT EXISTS vector")

    # 2. 添加向量字段
    op.add_column('documents',
        sa.Column('embedding', Vector(1536), nullable=True))

    # 3. 创建向量索引（加速相似度搜索）
    op.execute("""
        CREATE INDEX idx_documents_embedding
        ON documents
        USING ivfflat (embedding vector_cosine_ops)
        WITH (lists = 100)
    """)

def downgrade():
    op.drop_index('idx_documents_embedding', table_name='documents')
    op.drop_column('documents', 'embedding')
```

### 场景2：重构对话历史表（分步迁移）

```python
# 需求：将 conversation.messages (JSONB) 拆分成独立的 messages 表

# 迁移1：创建新表
# versions/abc123_create_messages_table.py
def upgrade():
    op.create_table('messages',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('conversation_id', sa.Integer(), sa.ForeignKey('conversations.id')),
        sa.Column('role', sa.String(), nullable=False),
        sa.Column('content', sa.Text(), nullable=False),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'))
    )

# 迁移2：迁移数据
# versions/def456_migrate_messages_data.py
def upgrade():
    # 使用 SQLAlchemy ORM 迁移数据
    from sqlalchemy.orm import Session
    from app.models import Conversation, Message

    bind = op.get_bind()
    session = Session(bind=bind)

    # 读取所有对话
    conversations = session.execute(
        sa.text("SELECT id, messages FROM conversations WHERE messages IS NOT NULL")
    ).fetchall()

    # 迁移数据
    for conv_id, messages_json in conversations:
        import json
        messages = json.loads(messages_json)

        for msg in messages:
            session.execute(
                sa.text("""
                    INSERT INTO messages (conversation_id, role, content, created_at)
                    VALUES (:conv_id, :role, :content, :created_at)
                """),
                {
                    "conv_id": conv_id,
                    "role": msg["role"],
                    "content": msg["content"],
                    "created_at": msg.get("created_at", "now()")
                }
            )

    session.commit()

# 迁移3：删除旧字段
# versions/ghi789_remove_messages_column.py
def upgrade():
    op.drop_column('conversations', 'messages')
```

### 场景3：添加全文搜索索引（手动编辑）

```python
# 需求：为对话标题添加全文搜索

# 1. 运行 autogenerate（无法检测全文搜索索引）
alembic revision -m "add fulltext search to conversations"

# 2. 手动编写迁移脚本
# versions/abc123_add_fulltext_search.py
def upgrade():
    # PostgreSQL 全文搜索索引
    op.execute("""
        CREATE INDEX idx_conversations_title_fts
        ON conversations
        USING gin(to_tsvector('english', title))
    """)

def downgrade():
    op.drop_index('idx_conversations_title_fts', table_name='conversations')
```

---

## 总结

**autogenerate 的核心要点：**

1. **工作原理**：对比数据库 schema 和 SQLAlchemy 模型，生成差异
2. **能检测**：表、列、索引、外键的增删改
3. **无法检测**：重命名、约束、枚举、特定类型、触发器、数据迁移
4. **最佳实践**：生成后必须人工检查，复杂变更手动编辑
5. **自定义行为**：通过 `include_object`、`compare_type` 等自定义

**在 AI Agent 后端开发中：**
- 用 autogenerate 处理简单的 schema 变更
- 用手动编辑处理向量存储、全文搜索等特殊功能
- 用分步迁移处理复杂的数据重构
- 始终在开发环境测试后再应用到生产环境

**记住：**
> autogenerate 是助手，不是替代品。它能处理80%的常见场景，但剩下20%的复杂场景需要人工智慧。生成后必须检查，必要时手动编辑。
