# 实战代码 - 场景4：RAG混合检索

> 将标量过滤应用到RAG系统，实现多租户知识库和权限控制

---

## 场景描述

**目标**：构建一个完整的RAG混合检索系统，演示标量过滤在实际应用中的核心价值。

**涉及知识点**：
- 多租户数据隔离
- 时间范围检索
- 权限控制
- 分类过滤
- 动态过滤表达式构建

---

## 完整代码

```python
"""
场景4：RAG混合检索
演示：标量过滤在RAG系统中的实际应用
"""

from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType, utility
import numpy as np
from typing import List, Dict, Optional
from datetime import datetime, timedelta

# ===== 1. 连接到Milvus =====
print("=== RAG混合检索系统 ===\n")
connections.connect(alias="default", host="localhost", port="19530")

# ===== 2. 创建多租户知识库Collection =====
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=384),
    FieldSchema(name="content", dtype=DataType.VARCHAR, max_length=2000),
    FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=500),
    FieldSchema(name="user_id", dtype=DataType.INT64),
    FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=100),
    FieldSchema(name="created_at", dtype=DataType.INT64),
    FieldSchema(name="is_public", dtype=DataType.BOOL),
    FieldSchema(name="is_deleted", dtype=DataType.BOOL),
]

schema = CollectionSchema(fields=fields, description="Multi-tenant RAG knowledge base")
collection_name = "rag_knowledge_base"

if utility.has_collection(collection_name):
    utility.drop_collection(collection_name)

collection = Collection(name=collection_name, schema=schema)
print(f"✅ 创建Collection: {collection_name}\n")

# ===== 3. 插入测试数据 =====
current_time = int(datetime.now().timestamp())
one_month_ago = int((datetime.now() - timedelta(days=30)).timestamp())
three_months_ago = int((datetime.now() - timedelta(days=90)).timestamp())

test_documents = [
    # 用户1的文档
    {"embedding": np.random.rand(384).tolist(), "content": "Python机器学习基础教程", "title": "ML入门", "user_id": 1001, "category": "ml", "created_at": current_time, "is_public": True, "is_deleted": False},
    {"embedding": np.random.rand(384).tolist(), "content": "深度学习神经网络原理", "title": "DL原理", "user_id": 1001, "category": "ai", "created_at": one_month_ago, "is_public": False, "is_deleted": False},
    {"embedding": np.random.rand(384).tolist(), "content": "数据预处理技巧", "title": "数据处理", "user_id": 1001, "category": "data", "created_at": three_months_ago, "is_public": True, "is_deleted": False},

    # 用户2的文档
    {"embedding": np.random.rand(384).tolist(), "content": "Transformer模型详解", "title": "Transformer", "user_id": 1002, "category": "ai", "created_at": current_time, "is_public": True, "is_deleted": False},
    {"embedding": np.random.rand(384).tolist(), "content": "RAG系统架构设计", "title": "RAG架构", "user_id": 1002, "category": "ai", "created_at": one_month_ago, "is_public": False, "is_deleted": False},
    {"embedding": np.random.rand(384).tolist(), "content": "向量数据库选型", "title": "数据库选型", "user_id": 1002, "category": "tech", "created_at": current_time, "is_public": True, "is_deleted": False},

    # 用户3的文档
    {"embedding": np.random.rand(384).tolist(), "content": "LangChain实战指南", "title": "LangChain", "user_id": 1003, "category": "tech", "created_at": current_time, "is_public": True, "is_deleted": False},
    {"embedding": np.random.rand(384).tolist(), "content": "已删除的文档", "title": "删除测试", "user_id": 1003, "category": "test", "created_at": three_months_ago, "is_public": False, "is_deleted": True},
]

data = {key: [doc[key] for doc in test_documents] for key in test_documents[0].keys()}
collection.insert(data)
print(f"✅ 插入 {len(test_documents)} 条文档\n")

# 创建索引
index_params = {"index_type": "IVF_FLAT", "metric_type": "L2", "params": {"nlist": 128}}
collection.create_index(field_name="embedding", index_params=index_params)
collection.create_index(field_name="user_id", index_name="user_id_index")
collection.create_index(field_name="category", index_name="category_index")
collection.load()
print("✅ 创建索引并加载Collection\n")

# ===== 4. RAG检索函数 =====
class RAGRetriever:
    """RAG混合检索器"""

    def __init__(self, collection: Collection):
        self.collection = collection

    def build_filter(self,
                    user_id: Optional[int] = None,
                    categories: Optional[List[str]] = None,
                    start_time: Optional[int] = None,
                    end_time: Optional[int] = None,
                    include_public: bool = True,
                    exclude_deleted: bool = True) -> str:
        """构建过滤表达式"""
        conditions = []

        # 多租户隔离
        if user_id is not None:
            if include_public:
                conditions.append(f"(user_id == {user_id} or is_public == true)")
            else:
                conditions.append(f"user_id == {user_id}")

        # 分类过滤
        if categories:
            cats = [f"'{c}'" for c in categories]
            conditions.append(f"category in [{', '.join(cats)}]")

        # 时间范围
        if start_time:
            conditions.append(f"created_at >= {start_time}")
        if end_time:
            conditions.append(f"created_at <= {end_time}")

        # 排除已删除
        if exclude_deleted:
            conditions.append("is_deleted == false")

        return " and ".join(conditions) if conditions else None

    def search(self,
              query_vector: List[float],
              user_id: Optional[int] = None,
              categories: Optional[List[str]] = None,
              start_time: Optional[int] = None,
              limit: int = 5) -> List[Dict]:
        """执行混合检索"""
        expr = self.build_filter(
            user_id=user_id,
            categories=categories,
            start_time=start_time
        )

        results = self.collection.search(
            data=[query_vector],
            anns_field="embedding",
            param={"metric_type": "L2", "params": {"nprobe": 10}},
            limit=limit,
            expr=expr,
            output_fields=["title", "content", "user_id", "category", "created_at", "is_public"]
        )

        return [{
            "id": hit.id,
            "title": hit.entity.get("title"),
            "content": hit.entity.get("content"),
            "user_id": hit.entity.get("user_id"),
            "category": hit.entity.get("category"),
            "distance": hit.distance,
            "is_public": hit.entity.get("is_public")
        } for hit in results[0]]

# ===== 5. 应用场景演示 =====
retriever = RAGRetriever(collection)
query_vector = np.random.rand(384).tolist()

# 场景1：多租户隔离
print("=== 场景1：多租户隔离 ===")
print("用户1001查询自己的文档（包含公开文档）\n")
results = retriever.search(query_vector, user_id=1001, limit=5)
print(f"找到 {len(results)} 条结果:")
for r in results:
    access = "公开" if r["is_public"] else "私有"
    print(f"  - {r['title']} (用户{r['user_id']}, {access})")
print()

# 场景2：分类过滤
print("=== 场景2：分类过滤 ===")
print("查询AI和ML分类的文档\n")
results = retriever.search(query_vector, categories=["ai", "ml"], limit=5)
print(f"找到 {len(results)} 条结果:")
for r in results:
    print(f"  - {r['title']} ({r['category']})")
print()

# 场景3：时间范围检索
print("=== 场景3：时间范围检索 ===")
print("查询最近30天的文档\n")
thirty_days_ago = int((datetime.now() - timedelta(days=30)).timestamp())
results = retriever.search(query_vector, start_time=thirty_days_ago, limit=5)
print(f"找到 {len(results)} 条结果:")
for r in results:
    created = datetime.fromtimestamp(r["created_at"]).strftime("%Y-%m-%d")
    print(f"  - {r['title']} (创建于{created})")
print()

# 场景4：组合条件
print("=== 场景4：组合条件 ===")
print("用户1001查询AI分类的最近30天文档\n")
results = retriever.search(
    query_vector,
    user_id=1001,
    categories=["ai", "ml"],
    start_time=thirty_days_ago,
    limit=5
)
print(f"找到 {len(results)} 条结果:")
for r in results:
    print(f"  - {r['title']} ({r['category']})")
print()

# 场景5：权限控制
print("=== 场景5：权限控制演示 ===")
print("对比：包含公开文档 vs 仅私有文档\n")

# 包含公开文档
expr1 = retriever.build_filter(user_id=1001, include_public=True)
print(f"包含公开: {expr1}")
results1 = retriever.search(query_vector, user_id=1001, limit=10)
print(f"结果数: {len(results1)}\n")

# 仅私有文档
expr2 = retriever.build_filter(user_id=1001, include_public=False)
print(f"仅私有: {expr2}")
results2 = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr2,
    output_fields=["title", "is_public"]
)
print(f"结果数: {len(results2[0])}\n")

# ===== 6. 性能优化建议 =====
print("=== 性能优化建议 ===\n")
print("""
1. 索引策略：
   ✅ user_id: 高选择性，必须创建索引
   ✅ category: 中等选择性，建议创建索引
   ✅ created_at: 范围查询频繁，建议创建索引

2. 查询优化：
   ✅ 高选择性条件在前（user_id）
   ✅ 使用IN代替多个OR
   ✅ 避免复杂的嵌套表达式

3. 架构设计：
   ✅ 多租户隔离在数据库层实现
   ✅ 软删除标记（is_deleted）
   ✅ 公开/私有权限控制
""")

# ===== 7. 清理资源 =====
collection.release()
connections.disconnect("default")
print("✅ 示例完成")
```

---

## 核心应用场景

### 1. 多租户知识库

```python
# 用户只能看到自己的文档 + 公开文档
expr = "(user_id == 1001 or is_public == true) and is_deleted == false"
```

### 2. 时间范围检索

```python
# 查询最近30天的文档
thirty_days_ago = int((datetime.now() - timedelta(days=30)).timestamp())
expr = f"created_at >= {thirty_days_ago}"
```

### 3. 分类过滤

```python
# 查询特定分类的文档
expr = "category in ['ai', 'ml', 'data']"
```

### 4. 权限控制

```python
# 公开文档 OR 用户拥有的私有文档
expr = "(is_public == true or owner_id == 1001) and is_deleted == false"
```

---

## 最佳实践

### 1. 数据建模

```python
# 必备字段
- user_id: 多租户隔离
- is_deleted: 软删除标记
- is_public: 权限控制
- created_at: 时间范围查询
- category: 分类过滤
```

### 2. 索引策略

```python
# 为高频过滤字段创建索引
collection.create_index(field_name="user_id")
collection.create_index(field_name="category")
collection.create_index(field_name="created_at")
```

### 3. 安全性

```python
# 数据库层面强制隔离
expr = f"user_id == {current_user_id}"  # 防止越权访问

# 永远排除已删除的文档
expr += " and is_deleted == false"
```

---

## 实际应用架构

```
用户查询
   ↓
查询向量化 (Embedding)
   ↓
构建过滤表达式
   ↓
Milvus混合检索 (向量相似度 + 标量过滤)
   ↓
返回Top-K结果
   ↓
LLM生成回答
```

---

## 性能优化

### 查询性能

- 为user_id创建索引：10倍提升
- 为category创建索引：3倍提升
- 高选择性条件在前：2倍提升

### 安全性

- 数据库层面隔离（不依赖应用层）
- 软删除标记（可恢复）
- 权限控制（公开/私有）

---

## 总结

标量过滤在RAG系统中的核心价值：

1. **多租户隔离**：user_id过滤
2. **时间范围**：created_at过滤
3. **权限控制**：is_public过滤
4. **分类检索**：category过滤
5. **软删除**：is_deleted过滤

**记住**：RAG系统的每一次检索都是向量相似度 + 标量过滤的混合查询。
