# 生成器与迭代器 - 学习概览

> 理解 Python 惰性求值的核心机制，掌握流式处理和内存高效的数据处理方式

---

## 学习目标

完成本知识点学习后，你将能够：

- [ ] 理解迭代器协议（`__iter__` 和 `__next__`）
- [ ] 手写迭代器类实现自定义迭代逻辑
- [ ] 使用 `yield` 关键字编写生成器函数
- [ ] 理解生成器的惰性求值特性
- [ ] 使用生成器表达式简化代码
- [ ] 在 AI Agent 开发中实现流式响应
- [ ] 处理大文件和大数据集而不耗尽内存
- [ ] 构建数据处理管道（pipeline）

---

## 知识点结构

本知识点包含以下10个维度：

1. **30字核心** - 一句话理解生成器与迭代器
2. **第一性原理** - 从惰性求值的本质出发
3. **核心概念** - 3个核心技术详解
   - 核心概念1：迭代器协议（`__iter__` 和 `__next__`）
   - 核心概念2：生成器函数（`yield` 关键字）
   - 核心概念3：生成器表达式（generator expressions）
4. **最小可用** - 20%核心知识解决80%问题
5. **双重类比** - 前端开发 + 日常生活类比
6. **反直觉点** - 3个常见误区
7. **实战代码** - 完整可运行示例
   - 场景1：大文件逐行处理
   - 场景2：AI 流式响应
   - 场景3：数据处理管道
   - 场景4：无限序列生成
8. **面试必问** - 高频面试题及出彩回答
9. **化骨绵掌** - 10个2分钟知识卡片
10. **一句话总结** - 精炼总结

---

## 学习路径

```
前置知识：
- 类的特殊方法（__iter__, __next__）
- 异常处理（StopIteration）
- 函数基础（理解 yield）

本知识点：
迭代器协议 → 生成器函数 → 生成器表达式 → 流式处理 → 数据管道

后续学习：
- 异步生成器（async def + yield，在 Phase1-02 异步编程中已覆盖）
- FastAPI 流式响应（Phase2-05）
- 大数据处理（实际项目应用）
```

---

## 与 AI Agent 开发的关系

生成器与迭代器在 AI Agent 后端开发中的核心应用：

| 应用场景 | 生成器/迭代器作用 | 示例 |
|---------|----------------|------|
| **AI 流式响应** | 逐 token 返回 LLM 输出 | `for chunk in stream_response():` |
| **大文件处理** | 逐行读取而非一次性加载 | `for line in read_large_file():` |
| **数据管道** | 链式处理数据流 | `pipeline = filter(validate, map(transform, data))` |
| **无限序列** | 生成无限数据流 | `for event in event_stream():` |
| **批量处理** | 分批处理大数据集 | `for batch in batch_generator(data, size=100):` |
| **内存优化** | 按需生成数据，节省内存 | `embeddings = (embed(text) for text in texts)` |
| **懒加载** | 延迟计算直到真正需要 | `results = (expensive_op(x) for x in items)` |

---

## 快速开始

```python
# 1. 迭代器：手动实现迭代协议
class Counter:
    def __init__(self, max_count):
        self.max_count = max_count
        self.count = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.count >= self.max_count:
            raise StopIteration
        self.count += 1
        return self.count

# 使用迭代器
for num in Counter(5):
    print(num)  # 1, 2, 3, 4, 5

# 2. 生成器函数：使用 yield 简化
def counter(max_count):
    count = 0
    while count < max_count:
        count += 1
        yield count

# 使用生成器
for num in counter(5):
    print(num)  # 1, 2, 3, 4, 5

# 3. 生成器表达式：最简洁的方式
squares = (x**2 for x in range(5))
for square in squares:
    print(square)  # 0, 1, 4, 9, 16
```

---

## 学习建议

1. **先理解本质**：迭代器 = 按需生成，而非一次性加载
2. **对比列表**：理解 `[x for x in range(1000000)]` vs `(x for x in range(1000000))` 的内存差异
3. **手写迭代器**：自己实现一个迭代器类，理解协议
4. **使用 yield**：掌握生成器函数的写法
5. **实战应用**：在 FastAPI 中实现流式响应

---

## 核心价值

**为什么需要生成器与迭代器？**

1. **内存高效**：按需生成数据，不占用大量内存
2. **惰性求值**：延迟计算直到真正需要
3. **流式处理**：处理无限序列或大数据流
4. **代码简洁**：用 yield 替代复杂的状态管理

**对比列表推导式：**

```python
# ❌ 列表推导式：一次性加载全部数据到内存
numbers = [x for x in range(10_000_000)]  # 占用约 400MB 内存
print(sum(numbers))

# ✅ 生成器表达式：按需生成，内存占用极小
numbers = (x for x in range(10_000_000))  # 占用约 100 字节
print(sum(numbers))  # 结果相同，但内存占用极小
```

**在 AI Agent 中的价值：**

```python
# AI 流式响应示例
async def stream_ai_response(prompt: str):
    """逐 token 返回 AI 响应，用户体验更好"""
    async for chunk in openai_client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        stream=True  # 启用流式响应
    ):
        if chunk.choices[0].delta.content:
            yield chunk.choices[0].delta.content
```

---

## 核心对比

| 特性 | 列表 | 迭代器 | 生成器 |
|------|------|--------|--------|
| **内存占用** | 一次性加载全部 | 按需生成 | 按需生成 |
| **是否可重复迭代** | ✅ 是 | ❌ 否（一次性） | ❌ 否（一次性） |
| **创建方式** | `[...]` | 实现 `__iter__` 和 `__next__` | `yield` 或 `(...)` |
| **适用场景** | 小数据集 | 自定义迭代逻辑 | 大数据集、流式处理 |
| **代码复杂度** | 简单 | 复杂（需要类） | 简单（函数即可） |

---

## 预计学习时间

- **快速浏览**：30分钟（30字核心 + 最小可用 + 实战代码）
- **深入学习**：2小时（完整10个维度）
- **实践巩固**：1小时（手写迭代器 + 生成器 + FastAPI 流式响应）

---

**版本：** v1.0
**最后更新：** 2026-02-11
**维护者：** Claude Code
