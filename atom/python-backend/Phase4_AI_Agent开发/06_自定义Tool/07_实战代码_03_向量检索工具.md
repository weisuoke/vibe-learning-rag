# 自定义Tool - 实战代码03：向量检索工具

> 完整可运行的向量检索Tool示例，用于知识库检索和语义搜索

---

## 概述

向量检索是RAG系统的核心组件。本文提供完整的向量检索Tool实现。

**技术要点：**
- pgvector向量数据库
- OpenAI Embeddings
- 语义相似度搜索
- 结果重排序

---

## 环境准备

```bash
# 安装依赖
uv add asyncpg pgvector openai langchain langchain-openai

# 配置.env
OPENAI_API_KEY=your_key
DATABASE_URL=postgresql://user:pass@localhost:5432/db
```

### 数据库设置

```sql
-- 启用pgvector扩展
CREATE EXTENSION IF NOT EXISTS vector;

-- 创建文档表
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    embedding vector(1536),  -- OpenAI embedding维度
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建向量索引
CREATE INDEX ON documents USING ivfflat (embedding vector_cosine_ops);

-- 插入测试数据
INSERT INTO documents (content, metadata) VALUES
('Python是一种高级编程语言', '{"category": "编程"}'),
('FastAPI是现代的Web框架', '{"category": "框架"}'),
('机器学习是人工智能的分支', '{"category": "AI"}');
```

---

## 完整代码

```python
"""
向量检索Tool示例
演示：使用pgvector进行语义搜索
"""

import os
import asyncpg
from typing import List, Optional
from langchain.tools import tool
from pydantic import BaseModel, Field
from openai import AsyncOpenAI
from dotenv import load_dotenv

load_dotenv()

# 全局资源
db_pool = None
openai_client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# ===== 1. 初始化 =====
async def init_db_pool():
    """初始化数据库连接池"""
    global db_pool
    if db_pool is None:
        db_pool = await asyncpg.create_pool(
            os.getenv("DATABASE_URL"),
            min_size=5,
            max_size=20
        )
    return db_pool

async def get_embedding(text: str) -> List[float]:
    """获取文本的向量表示"""
    response = await openai_client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    return response.data[0].embedding

# ===== 2. 定义参数Schema =====
class SearchInput(BaseModel):
    """向量搜索参数"""
    query: str = Field(
        description="搜索查询，如'如何使用FastAPI？'",
        min_length=1,
        max_length=500
    )
    limit: int = Field(
        default=5,
        description="返回结果数量",
        ge=1,
        le=20
    )
    similarity_threshold: float = Field(
        default=0.7,
        description="相似度阈值（0-1）",
        ge=0.0,
        le=1.0
    )

# ===== 3. 定义Tool =====
@tool(args_schema=SearchInput)
async def search_knowledge_base(
    query: str,
    limit: int = 5,
    similarity_threshold: float = 0.7
) -> str:
    """搜索知识库

    使用语义搜索在知识库中查找与查询最相关的文档。

    适用场景：
    - 用户询问"如何使用FastAPI？"
    - 用户询问"Python有什么特点？"
    - 用户询问"机器学习是什么？"

    Args:
        query: 搜索查询
        limit: 返回结果数量
        similarity_threshold: 相似度阈值

    Returns:
        相关文档列表

    注意事项：
    - 使用语义搜索，不是关键词匹配
    - 相似度越高越相关
    """
    try:
        # 1. 获取查询的向量表示
        query_embedding = await get_embedding(query)

        # 2. 向量相似度搜索
        pool = await init_db_pool()
        async with pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT
                    content,
                    metadata,
                    1 - (embedding <=> $1::vector) as similarity
                FROM documents
                WHERE 1 - (embedding <=> $1::vector) > $2
                ORDER BY embedding <=> $1::vector
                LIMIT $3
                """,
                query_embedding,
                similarity_threshold,
                limit
            )

        if not rows:
            return f"未找到与'{query}'相关的文档。建议：降低相似度阈值或尝试其他关键词。"

        # 3. 格式化结果
        results = []
        for i, row in enumerate(rows, 1):
            similarity = row['similarity']
            content = row['content']
            metadata = row['metadata']
            category = metadata.get('category', '未分类')

            results.append(f"""文档{i}（相似度：{similarity:.2%}）：
内容：{content}
类别：{category}
""")

        return f"找到{len(rows)}个相关文档：\n\n" + "\n".join(results)

    except Exception as e:
        return f"搜索失败：{str(e)}。建议：请稍后重试。"

# ===== 4. 添加文档Tool =====
@tool
async def add_document(content: str, category: str = "未分类") -> str:
    """添加文档到知识库

    将新文档添加到知识库，自动生成向量表示。

    Args:
        content: 文档内容
        category: 文档类别

    Returns:
        添加结果
    """
    try:
        # 1. 生成向量
        embedding = await get_embedding(content)

        # 2. 插入数据库
        pool = await init_db_pool()
        async with pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO documents (content, embedding, metadata)
                VALUES ($1, $2, $3)
                """,
                content,
                embedding,
                {"category": category}
            )

        return f"文档已添加到知识库：{content[:50]}..."

    except Exception as e:
        return f"添加失败：{str(e)}"

# ===== 5. 测试 =====
async def test_vector_search():
    """测试向量搜索"""
    print("=== 测试向量搜索 ===\n")

    # 测试1：搜索编程相关
    print("测试1：搜索'编程语言'")
    result = await search_knowledge_base.ainvoke({
        "query": "编程语言",
        "limit": 3
    })
    print(result)
    print()

    # 测试2：搜索AI相关
    print("测试2：搜索'人工智能'")
    result = await search_knowledge_base.ainvoke({
        "query": "人工智能",
        "limit": 3
    })
    print(result)
    print()

async def cleanup():
    """清理资源"""
    global db_pool
    if db_pool:
        await db_pool.close()

if __name__ == "__main__":
    import asyncio

    async def main():
        try:
            await test_vector_search()
        finally:
            await cleanup()

    asyncio.run(main())
```

---

## 运行输出示例

```
=== 测试向量搜索 ===

测试1：搜索'编程语言'
找到2个相关文档：

文档1（相似度：89.23%）：
内容：Python是一种高级编程语言
类别：编程

文档2（相似度：75.45%）：
内容：FastAPI是现代的Web框架
类别：框架

测试2：搜索'人工智能'
找到1个相关文档：

文档1（相似度：92.15%）：
内容：机器学习是人工智能的分支
类别：AI
```

---

## 最佳实践

### 1. 向量维度选择

```python
# OpenAI embedding模型
"text-embedding-3-small"  # 1536维，快速
"text-embedding-3-large"  # 3072维，精确
```

### 2. 相似度计算

```python
# pgvector支持的距离函数
<=>  # 余弦距离（推荐）
<->  # 欧氏距离
<#>  # 内积距离
```

### 3. 索引优化

```sql
-- IVFFlat索引（快速但近似）
CREATE INDEX ON documents USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- HNSW索引（更精确）
CREATE INDEX ON documents USING hnsw (embedding vector_cosine_ops);
```

---

## 总结

向量检索Tool的核心：
1. **Embedding生成**：使用OpenAI API
2. **向量存储**：pgvector数据库
3. **相似度搜索**：余弦距离
4. **结果排序**：按相似度降序

**记住：** 向量检索是语义搜索，不是关键词匹配！
