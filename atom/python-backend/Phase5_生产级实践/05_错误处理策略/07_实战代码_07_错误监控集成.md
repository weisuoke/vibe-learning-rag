# 实战代码7：错误监控集成

**场景：** 集成 structlog 和 Sentry 实现完整的错误监控

---

## 完整代码

```python
"""
错误监控集成
包含：structlog 结构化日志、Sentry 错误追踪、Request ID
"""

import uuid
import traceback
from datetime import datetime
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
import structlog
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration

# ===== 1. 配置 structlog =====
structlog.configure(
    processors=[
        structlog.stdlib.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.format_exc_info,
        structlog.processors.JSONRenderer()
    ],
    logger_factory=structlog.stdlib.LoggerFactory(),
)

logger = structlog.get_logger()

# ===== 2. 配置 Sentry =====
sentry_sdk.init(
    dsn="your-sentry-dsn",
    integrations=[FastApiIntegration()],
    environment="production",
    traces_sample_rate=0.1,
)

# ===== 3. Request ID 中间件 =====
class RequestIDMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
        request.state.request_id = request_id

        logger.info(
            "request_start",
            request_id=request_id,
            path=request.url.path,
            method=request.method
        )

        response = await call_next(request)
        response.headers["X-Request-ID"] = request_id

        logger.info(
            "request_end",
            request_id=request_id,
            status_code=response.status_code
        )

        return response

# ===== 4. FastAPI 应用 =====
app = FastAPI()
app.add_middleware(RequestIDMiddleware)

# ===== 5. 全局异常处理器 =====
@app.exception_handler(Exception)
async def global_error_handler(request: Request, exc: Exception):
    request_id = getattr(request.state, "request_id", str(uuid.uuid4()))

    # 收集错误上下文
    error_context = {
        "request_id": request_id,
        "timestamp": datetime.utcnow().isoformat(),
        "path": request.url.path,
        "method": request.method,
        "error_type": type(exc).__name__,
        "error_message": str(exc),
        "stack_trace": traceback.format_exc(),
    }

    # 记录 structlog 日志
    logger.error("unhandled_exception", **error_context)

    # 上报到 Sentry
    sentry_sdk.set_context("request", {
        "request_id": request_id,
        "path": request.url.path,
        "method": request.method
    })
    sentry_sdk.capture_exception(exc)

    return JSONResponse(
        status_code=500,
        content={
            "error": "服务器内部错误",
            "request_id": request_id
        }
    )

# ===== 6. API 端点 =====
@app.post("/chat")
async def chat(message: str, request: Request):
    request_id = request.state.request_id

    logger.info("chat_start", request_id=request_id, message_length=len(message))

    try:
        response = await call_llm(message)
        logger.info("chat_success", request_id=request_id)
        return {"response": response, "request_id": request_id}
    except Exception as e:
        logger.error("chat_error", request_id=request_id, error=str(e))
        raise
```

---

## 日志输出示例

```json
{
  "event": "request_start",
  "level": "info",
  "timestamp": "2026-02-12T08:00:00Z",
  "request_id": "abc-123",
  "path": "/chat",
  "method": "POST"
}

{
  "event": "chat_error",
  "level": "error",
  "timestamp": "2026-02-12T08:00:05Z",
  "request_id": "abc-123",
  "error_type": "TimeoutError",
  "error_message": "Request timeout",
  "stack_trace": "Traceback..."
}
```
