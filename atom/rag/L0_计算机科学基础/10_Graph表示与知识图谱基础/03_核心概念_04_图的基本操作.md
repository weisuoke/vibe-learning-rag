# 核心概念4：图的基本操作

> 添加、删除、查询、遍历 - 图的核心操作接口

---

## 一句话定义

**图的基本操作包括添加/删除节点边、查询邻居、遍历节点边等核心接口，是动态知识图谱更新和图算法实现的基础。**

---

## 核心操作分类

### 1. 结构修改操作

| 操作 | 说明 | 时间复杂度 |
|------|------|-----------|
| `add_node(node)` | 添加节点 | O(1) |
| `add_edge(u, v)` | 添加边 | O(1) |
| `remove_node(node)` | 删除节点 | O(V+E) |
| `remove_edge(u, v)` | 删除边 | O(degree) |

### 2. 查询操作

| 操作 | 说明 | 时间复杂度 |
|------|------|-----------|
| `has_node(node)` | 节点是否存在 | O(1) |
| `has_edge(u, v)` | 边是否存在 | O(degree) |
| `get_neighbors(node)` | 获取邻居 | O(1) |
| `degree(node)` | 获取度数 | O(1) |

### 3. 遍历操作

| 操作 | 说明 | 时间复杂度 |
|------|------|-----------|
| `nodes()` | 遍历所有节点 | O(V) |
| `edges()` | 遍历所有边 | O(E) |
| `neighbors(node)` | 遍历邻居 | O(degree) |

---

## 完整实现

```python
from collections import defaultdict
from typing import List, Set, Tuple, Optional

class Graph:
    """完整的图操作接口"""

    def __init__(self, directed=True):
        self.graph = defaultdict(list)
        self.directed = directed
        self._node_set = set()  # 显式跟踪节点

    # ===== 1. 结构修改操作 =====

    def add_node(self, node):
        """添加节点 - O(1)"""
        self._node_set.add(node)
        if node not in self.graph:
            self.graph[node] = []

    def add_edge(self, u, v, weight=None):
        """添加边 - O(1)"""
        # 确保节点存在
        self.add_node(u)
        self.add_node(v)

        # 添加边（避免重复）
        if weight is None:
            if v not in self.graph[u]:
                self.graph[u].append(v)
        else:
            if not any(n == v for n, _ in self.graph[u]):
                self.graph[u].append((v, weight))

        # 无向图添加反向边
        if not self.directed:
            if weight is None:
                if u not in self.graph[v]:
                    self.graph[v].append(u)
            else:
                if not any(n == u for n, _ in self.graph[v]):
                    self.graph[v].append((u, weight))

    def remove_node(self, node):
        """删除节点及其所有边 - O(V+E)"""
        if node not in self._node_set:
            return

        # 删除节点
        self._node_set.remove(node)
        if node in self.graph:
            del self.graph[node]

        # 删除指向该节点的边
        for neighbors in self.graph.values():
            if neighbors and isinstance(neighbors[0], tuple):
                # 带权重
                self.graph[node] = [(n, w) for n, w in neighbors if n != node]
            else:
                # 不带权重
                while node in neighbors:
                    neighbors.remove(node)

    def remove_edge(self, u, v):
        """删除边 - O(degree)"""
        if u in self.graph:
            neighbors = self.graph[u]
            if neighbors and isinstance(neighbors[0], tuple):
                self.graph[u] = [(n, w) for n, w in neighbors if n != v]
            else:
                if v in neighbors:
                    neighbors.remove(v)

        # 无向图删除反向边
        if not self.directed and v in self.graph:
            neighbors = self.graph[v]
            if neighbors and isinstance(neighbors[0], tuple):
                self.graph[v] = [(n, w) for n, w in neighbors if n != u]
            else:
                if u in neighbors:
                    neighbors.remove(u)

    # ===== 2. 查询操作 =====

    def has_node(self, node):
        """节点是否存在 - O(1)"""
        return node in self._node_set

    def has_edge(self, u, v):
        """边是否存在 - O(degree)"""
        if u not in self.graph:
            return False

        neighbors = self.graph[u]
        if not neighbors:
            return False

        if isinstance(neighbors[0], tuple):
            return any(n == v for n, _ in neighbors)
        else:
            return v in neighbors

    def get_neighbors(self, node):
        """获取邻居 - O(1)"""
        return self.graph.get(node, [])

    def degree(self, node):
        """获取度数 - O(1)"""
        return len(self.graph.get(node, []))

    def in_degree(self, node):
        """入度（有向图）- O(V*degree)"""
        if not self.directed:
            return self.degree(node)

        count = 0
        for neighbors in self.graph.values():
            if neighbors and isinstance(neighbors[0], tuple):
                count += sum(1 for n, _ in neighbors if n == node)
            else:
                count += neighbors.count(node)
        return count

    def out_degree(self, node):
        """出度（有向图）- O(1)"""
        return self.degree(node)

    # ===== 3. 遍历操作 =====

    def nodes(self):
        """遍历所有节点 - O(V)"""
        return list(self._node_set)

    def edges(self):
        """遍历所有边 - O(E)"""
        edges = []
        for u, neighbors in self.graph.items():
            if neighbors and isinstance(neighbors[0], tuple):
                for v, w in neighbors:
                    edges.append((u, v, w))
            else:
                for v in neighbors:
                    edges.append((u, v))
        return edges

    def neighbors(self, node):
        """遍历邻居（迭代器）- O(degree)"""
        for neighbor in self.graph.get(node, []):
            if isinstance(neighbor, tuple):
                yield neighbor[0]  # 只返回节点，不返回权重
            else:
                yield neighbor

    # ===== 4. 统计信息 =====

    def num_nodes(self):
        """节点数量"""
        return len(self._node_set)

    def num_edges(self):
        """边数量"""
        count = sum(len(neighbors) for neighbors in self.graph.values())
        return count if self.directed else count // 2

    def density(self):
        """图的密度"""
        V = self.num_nodes()
        E = self.num_edges()
        if V <= 1:
            return 0
        max_edges = V * (V - 1) if self.directed else V * (V - 1) // 2
        return E / max_edges if max_edges > 0 else 0

    # ===== 5. 实用方法 =====

    def clear(self):
        """清空图"""
        self.graph.clear()
        self._node_set.clear()

    def copy(self):
        """深拷贝图"""
        new_graph = Graph(directed=self.directed)
        for node in self.nodes():
            new_graph.add_node(node)
        for edge in self.edges():
            if len(edge) == 3:
                new_graph.add_edge(edge[0], edge[1], edge[2])
            else:
                new_graph.add_edge(edge[0], edge[1])
        return new_graph

    def __str__(self):
        """字符串表示"""
        return f"Graph(nodes={self.num_nodes()}, edges={self.num_edges()}, directed={self.directed})"

# 使用示例
g = Graph(directed=True)

# 添加节点和边
g.add_edge("A", "B")
g.add_edge("A", "C")
g.add_edge("B", "C")

print(g)  # Graph(nodes=3, edges=3, directed=True)
print(f"节点: {g.nodes()}")  # ['A', 'B', 'C']
print(f"边: {g.edges()}")    # [('A', 'B'), ('A', 'C'), ('B', 'C')]
print(f"密度: {g.density():.2%}")  # 50.00%

# 删除操作
g.remove_edge("A", "B")
print(f"删除A→B后: {g.edges()}")  # [('A', 'C'), ('B', 'C')]

g.remove_node("C")
print(f"删除C后: {g.edges()}")    # [('A',)]
```

---

## 在AI Agent中的应用

### 应用1：动态知识图谱更新

```python
class DynamicKnowledgeGraph:
    """动态更新的知识图谱"""

    def __init__(self):
        self.kg = Graph(directed=True)

    def add_fact(self, subject, predicate, object):
        """添加事实（三元组）"""
        # 添加实体节点
        self.kg.add_node(subject)
        self.kg.add_node(object)

        # 添加关系边
        self.kg.add_edge(subject, object, weight=predicate)

        print(f"✓ 添加: ({subject}, {predicate}, {object})")

    def remove_fact(self, subject, predicate, object):
        """删除事实"""
        self.kg.remove_edge(subject, object)
        print(f"✗ 删除: ({subject}, {predicate}, {object})")

    def update_fact(self, subject, old_predicate, new_predicate, object):
        """更新事实"""
        self.remove_fact(subject, old_predicate, object)
        self.add_fact(subject, new_predicate, object)

    def query_relations(self, subject):
        """查询实体的所有关系"""
        neighbors = self.kg.get_neighbors(subject)
        relations = []
        for neighbor, predicate in neighbors:
            relations.append((subject, predicate, neighbor))
        return relations

# 使用
kg = DynamicKnowledgeGraph()
kg.add_fact("张三", "工作于", "阿里巴巴")
kg.add_fact("张三", "居住在", "杭州")
kg.update_fact("张三", "工作于", "曾工作于", "阿里巴巴")

print(kg.query_relations("张三"))
```

### 应用2：图的批量操作

```python
def batch_add_edges(g, edges):
    """批量添加边"""
    for edge in edges:
        if len(edge) == 2:
            g.add_edge(edge[0], edge[1])
        elif len(edge) == 3:
            g.add_edge(edge[0], edge[1], edge[2])

def batch_remove_edges(g, edges):
    """批量删除边"""
    for u, v in edges:
        g.remove_edge(u, v)

# 使用
g = Graph()
edges = [
    ("A", "B"),
    ("B", "C"),
    ("C", "D")
]
batch_add_edges(g, edges)
```

### 应用3：图的合并

```python
def merge_graphs(g1, g2):
    """合并两个图"""
    merged = g1.copy()

    # 添加g2的所有节点和边
    for node in g2.nodes():
        merged.add_node(node)

    for edge in g2.edges():
        if len(edge) == 3:
            merged.add_edge(edge[0], edge[1], edge[2])
        else:
            merged.add_edge(edge[0], edge[1])

    return merged

# 使用
g1 = Graph()
g1.add_edge("A", "B")

g2 = Graph()
g2.add_edge("B", "C")

g_merged = merge_graphs(g1, g2)
print(g_merged.edges())  # [('A', 'B'), ('B', 'C')]
```

---

## 使用NetworkX

### 基本操作

```python
import networkx as nx

# 创建图
G = nx.DiGraph()

# 添加节点
G.add_node("A")
G.add_nodes_from(["B", "C", "D"])

# 添加边
G.add_edge("A", "B")
G.add_edges_from([("A", "C"), ("B", "C")])

# 添加带属性的边
G.add_edge("A", "D", weight=5, relation="knows")

# 查询
print(f"节点数: {G.number_of_nodes()}")  # 4
print(f"边数: {G.number_of_edges()}")    # 4
print(f"A的邻居: {list(G.neighbors('A'))}")  # ['B', 'C', 'D']
print(f"A→B存在: {G.has_edge('A', 'B')}")   # True

# 删除
G.remove_edge("A", "B")
G.remove_node("D")

# 遍历
for node in G.nodes():
    print(f"节点: {node}, 出度: {G.out_degree(node)}")

for u, v, data in G.edges(data=True):
    print(f"边: {u}→{v}, 属性: {data}")
```

### 高级操作

```python
# 子图
subgraph = G.subgraph(["A", "B"])

# 反转有向图
G_reversed = G.reverse()

# 转换为无向图
G_undirected = G.to_undirected()

# 图的并集
G_union = nx.compose(G1, G2)

# 图的交集
G_intersection = nx.intersection(G1, G2)
```

---

## 性能优化技巧

### 技巧1：使用集合加速查询

```python
class FastGraph:
    def __init__(self):
        self.graph = defaultdict(set)  # 使用set

    def add_edge(self, u, v):
        self.graph[u].add(v)  # O(1)

    def has_edge(self, u, v):
        return v in self.graph[u]  # O(1)平均

    def remove_edge(self, u, v):
        self.graph[u].discard(v)  # O(1)平均
```

### 技巧2：缓存度数

```python
class CachedDegreeGraph:
    def __init__(self):
        self.graph = defaultdict(list)
        self._out_degree = defaultdict(int)
        self._in_degree = defaultdict(int)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self._out_degree[u] += 1
        self._in_degree[v] += 1

    def out_degree(self, node):
        return self._out_degree[node]  # O(1)

    def in_degree(self, node):
        return self._in_degree[node]  # O(1)
```

### 技巧3：延迟删除

```python
class LazyDeleteGraph:
    def __init__(self):
        self.graph = defaultdict(list)
        self.deleted_edges = set()

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def remove_edge(self, u, v):
        # 标记删除，不立即删除
        self.deleted_edges.add((u, v))

    def get_neighbors(self, node):
        # 过滤已删除的边
        return [v for v in self.graph[node] if (node, v) not in self.deleted_edges]

    def compact(self):
        # 定期清理
        for u, v in self.deleted_edges:
            if u in self.graph and v in self.graph[u]:
                self.graph[u].remove(v)
        self.deleted_edges.clear()
```

---

## 实战练习

### 练习1：实现图的序列化

```python
def serialize_graph(g):
    """将图序列化为JSON"""
    import json
    data = {
        "directed": g.directed,
        "nodes": g.nodes(),
        "edges": g.edges()
    }
    return json.dumps(data)

def deserialize_graph(json_str):
    """从JSON反序列化图"""
    import json
    data = json.loads(json_str)
    g = Graph(directed=data["directed"])
    for node in data["nodes"]:
        g.add_node(node)
    for edge in data["edges"]:
        if len(edge) == 3:
            g.add_edge(edge[0], edge[1], edge[2])
        else:
            g.add_edge(edge[0], edge[1])
    return g
```

### 练习2：实现图的差集

```python
def graph_difference(g1, g2):
    """计算g1 - g2（g1中有但g2中没有的边）"""
    diff = g1.copy()
    for edge in g2.edges():
        if len(edge) == 3:
            diff.remove_edge(edge[0], edge[1])
        else:
            diff.remove_edge(edge[0], edge[1])
    return diff
```

---

## 总结

**图的基本操作核心要点：**

1. **结构修改**：add/remove节点和边
2. **查询操作**：has/get节点、边、邻居
3. **遍历操作**：nodes/edges/neighbors
4. **统计信息**：度数、密度、数量

**在AI Agent中的应用：**
- 动态知识图谱更新
- 批量操作和合并
- 图的序列化和持久化

**性能优化：**
- 使用set加速查询
- 缓存度数信息
- 延迟删除策略

**关键洞察：**
- 基本操作是图算法的基础
- NetworkX提供了完整的操作接口
- 实际应用中需要考虑性能优化

---

**下一步：** 学习 `03_核心概念_05_知识图谱三元组.md` - 进入知识图谱应用部分
