# 核心概念2：标量过滤机制

## 一句话定义

**标量过滤是 Milvus 中基于精确条件筛选数据的机制，通过表达式引擎支持丰富的比较、逻辑和范围操作，在混合检索中实现业务规则约束和数据隔离。**

---

## 1. 标量过滤的本质

### 1.1 什么是标量过滤？

**核心思想**：在向量检索前或后，根据精确条件筛选数据

```python
# 纯向量检索（无过滤）
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10
)
# 返回：所有语义相似的结果

# 向量检索 + 标量过滤
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="age > 18 and city == 'Beijing'"  # 标量过滤
)
# 返回：语义相似 + 满足条件的结果
```

**关键区别**：

| 维度 | 向量检索 | 标量过滤 |
|------|---------|---------|
| 匹配方式 | 模糊（语义相似） | 精确（条件匹配） |
| 数据类型 | 向量（高维数组） | 标量（数字、字符串、布尔） |
| 操作符 | 距离度量（L2/IP） | 比较运算（==, >, <, in） |
| 作用 | 语义理解 | 业务规则 |

---

### 1.2 标量字段类型

Milvus 支持的标量字段类型：

```python
from pymilvus import FieldSchema, DataType

# 1. 整数类型
age = FieldSchema(name="age", dtype=DataType.INT64)
count = FieldSchema(name="count", dtype=DataType.INT32)

# 2. 浮点类型
price = FieldSchema(name="price", dtype=DataType.DOUBLE)
score = FieldSchema(name="score", dtype=DataType.FLOAT)

# 3. 字符串类型
city = FieldSchema(name="city", dtype=DataType.VARCHAR, max_length=100)
title = FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=500)

# 4. 布尔类型
is_active = FieldSchema(name="is_active", dtype=DataType.BOOL)

# 5. JSON 类型（Milvus 2.4+）
metadata = FieldSchema(name="metadata", dtype=DataType.JSON)
```

---

## 2. 表达式语法

### 2.1 基础比较操作符

#### 相等/不等

```python
# 相等
expr = "city == 'Beijing'"
expr = "age == 25"
expr = "is_active == true"

# 不等
expr = "city != 'Shanghai'"
expr = "age != 18"
```

#### 大小比较

```python
# 大于/小于
expr = "age > 18"
expr = "price < 1000"
expr = "score >= 0.8"
expr = "count <= 100"
```

**注意**：只适用于数值类型（INT, FLOAT, DOUBLE）

---

### 2.2 逻辑操作符

#### AND（与）

```python
# 同时满足多个条件
expr = "age > 18 and age < 60"
expr = "city == 'Beijing' and is_active == true"
expr = "price >= 100 and price <= 1000 and category == 'electronics'"
```

#### OR（或）

```python
# 满足任一条件
expr = "city == 'Beijing' or city == 'Shanghai'"
expr = "age < 18 or age > 60"
```

#### NOT（非）

```python
# 取反
expr = "not (city == 'Beijing')"
expr = "not (age > 18 and age < 60)"
```

#### 组合使用

```python
# 复杂逻辑
expr = "(city == 'Beijing' or city == 'Shanghai') and age > 18"
expr = "age > 18 and (city == 'Beijing' or city == 'Shanghai') and is_active == true"
```

**优先级**：NOT > AND > OR（使用括号明确优先级）

---

### 2.3 范围操作符

#### IN（包含）

```python
# 字符串列表
expr = "city in ['Beijing', 'Shanghai', 'Shenzhen']"

# 数字列表
expr = "age in [18, 25, 30, 35]"

# 等价于多个 OR
# city in ['Beijing', 'Shanghai']
# ≈ city == 'Beijing' or city == 'Shanghai'
```

#### NOT IN（不包含）

```python
expr = "city not in ['Beijing', 'Shanghai']"
expr = "age not in [18, 19, 20]"
```

---

### 2.4 JSON 字段过滤（Milvus 2.4+）

```python
# JSON 字段结构
# metadata = {"tags": ["tech", "ai"], "rating": 4.5, "verified": true}

# 访问 JSON 字段
expr = "metadata['rating'] > 4.0"
expr = "metadata['verified'] == true"
expr = "metadata['tags'][0] == 'tech'"

# 组合条件
expr = "metadata['rating'] > 4.0 and metadata['verified'] == true"
```

---

### 2.5 字符串操作

#### LIKE（模糊匹配）

```python
# % 表示任意字符
expr = "title like 'Python%'"      # 以 Python 开头
expr = "title like '%tutorial'"    # 以 tutorial 结尾
expr = "title like '%Python%'"     # 包含 Python

# 注意：LIKE 性能较差，避免在大数据集上使用
```

---

## 3. 表达式引擎实现

### 3.1 表达式解析流程

```
用户表达式
   ↓
1. 词法分析（Tokenization）
   "age > 18 and city == 'Beijing'"
   → [age, >, 18, and, city, ==, 'Beijing']
   ↓
2. 语法分析（Parsing）
   → AST（抽象语法树）
   ↓
3. 语义分析（Validation）
   - 检查字段是否存在
   - 检查类型是否匹配
   - 检查操作符是否支持
   ↓
4. 执行计划生成
   - 选择执行策略（Filter-then-Search / Search-then-Filter）
   - 优化表达式（如合并条件）
   ↓
5. 执行过滤
   - 扫描数据
   - 应用条件
   - 返回结果
```

---

### 3.2 执行策略

#### 策略1：Filter-then-Search（先过滤后检索）

```python
# 适用场景：过滤选择性高（过滤掉大量数据）

# 示例：多租户场景
expr = "tenant_id == 'A'"  # 过滤掉99%数据

# 执行流程：
# 1. 标量过滤：100万条 → 1万条（过滤掉99%）
# 2. 向量检索：在1万条中检索 Top-10
# 3. 性能提升：100倍
```

**优势**：

- ✅ 减少向量计算量
- ✅ 提升检索速度
- ✅ 降低内存占用

**适用条件**：

- 过滤选择性 > 90%（过滤掉大量数据）
- 过滤字段有索引

---

#### 策略2：Search-then-Filter（先检索后过滤）

```python
# 适用场景：过滤选择性低（过滤掉少量数据）

# 示例：年龄过滤
expr = "age > 18"  # 只过滤掉10%数据

# 执行流程：
# 1. 向量检索：在100万条中检索 Top-100
# 2. 标量过滤：100条 → 90条（过滤掉10%）
# 3. 返回 Top-10
```

**优势**：

- ✅ 避免全表扫描
- ✅ 利用向量索引

**适用条件**：

- 过滤选择性 < 50%（过滤掉少量数据）
- 向量检索结果集较小

---

### 3.3 Milvus 自动优化

**Milvus 会自动选择最优策略**：

```python
# 用户只需提供表达式，Milvus 自动优化
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="tenant_id == 'A' and age > 18"
)

# Milvus 内部决策：
# 1. 分析表达式：tenant_id 选择性高，age 选择性低
# 2. 选择策略：先过滤 tenant_id（Filter-then-Search）
# 3. 执行：tenant_id 过滤 → 向量检索 → age 过滤
```

---

## 4. 性能优化

### 4.1 创建标量索引

**为什么需要索引？**

```python
# 无索引：全表扫描
# 时间复杂度：O(N)
# 100万条数据 → 扫描100万次

# 有索引：快速查找
# 时间复杂度：O(log N)
# 100万条数据 → 扫描20次（log₂(1000000) ≈ 20）
```

**创建索引**：

```python
from pymilvus import Collection

collection = Collection("documents")

# 为标量字段创建索引
collection.create_index(
    field_name="tenant_id",
    index_name="tenant_id_index"
)

collection.create_index(
    field_name="age",
    index_name="age_index"
)

# 加载 Collection（索引生效）
collection.load()
```

**索引类型**：

Milvus 自动为标量字段选择合适的索引类型：

- **INT/FLOAT/DOUBLE**：B-Tree 索引
- **VARCHAR**：倒排索引
- **BOOL**：位图索引

---

### 4.2 优化表达式

#### 技巧1：高选择性条件前置

```python
# ❌ 低效（低选择性条件在前）
expr = "age > 18 and tenant_id == 'A'"

# ✅ 高效（高选择性条件在前）
expr = "tenant_id == 'A' and age > 18"

# 原因：Milvus 可能短路求值（如果 tenant_id 已过滤掉大量数据）
```

#### 技巧2：使用 IN 代替多个 OR

```python
# ❌ 低效
expr = "city == 'Beijing' or city == 'Shanghai' or city == 'Shenzhen'"

# ✅ 高效
expr = "city in ['Beijing', 'Shanghai', 'Shenzhen']"
```

#### 技巧3：避免复杂的 NOT

```python
# ❌ 低效
expr = "not (city == 'Beijing' or city == 'Shanghai')"

# ✅ 高效
expr = "city not in ['Beijing', 'Shanghai']"
```

#### 技巧4：避免 LIKE（如果可能）

```python
# ❌ 低效（全表扫描）
expr = "title like '%Python%'"

# ✅ 高效（如果可以用精确匹配）
expr = "category == 'Python'"
```

---

### 4.3 分区 + 标量过滤

**组合优化**：

```python
# 场景：查询2024年Q1的销售报告

# 方案1：只用标量过滤
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="year == 2024 and quarter == 'Q1'"
)

# 方案2：分区 + 标量过滤（更快）
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    partition_names=["2024_Q1"],  # 分区过滤（粗粒度）
    expr="status == 'approved'"    # 标量过滤（细粒度）
)

# 性能对比：
# 方案1：在100万条中过滤 → 1万条 → 检索
# 方案2：在10万条（分区）中过滤 → 1万条 → 检索
# 方案2 快 10 倍
```

---

## 5. 在混合检索中的应用

### 5.1 数据隔离（多租户）

```python
# 场景：SaaS 平台，每个租户有独立数据

# 租户A查询
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="tenant_id == 'A'"  # 数据隔离
)

# 安全性：
# - 租户A只能访问自己的数据
# - 无法访问租户B、C的数据
# - 在数据库层面强制隔离
```

---

### 5.2 时间范围过滤

```python
# 场景：查询最近30天的文档

import time

# 计算时间戳
now = int(time.time())
thirty_days_ago = now - 30 * 24 * 3600

# 查询
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr=f"timestamp >= {thirty_days_ago}"
)
```

---

### 5.3 状态过滤

```python
# 场景：只查询已审核的内容

results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="status == 'approved' and is_public == true"
)
```

---

### 5.4 价格范围过滤

```python
# 场景：电商搜索，价格范围100-1000

results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="price >= 100 and price <= 1000"
)
```

---

### 5.5 复杂业务规则

```python
# 场景：推荐系统，复杂过滤规则

results = collection.search(
    data=[user_interest_vector],
    anns_field="embedding",
    limit=20,
    expr="""
        age_rating <= 'PG-13' and
        status == 'approved' and
        duration >= 60 and duration <= 180 and
        category in ['action', 'comedy', 'drama'] and
        rating >= 4.0 and
        release_year >= 2020
    """
)
```

---

## 6. 实战示例

### 6.1 基础标量过滤

```python
from pymilvus import connections, Collection

# 连接 Milvus
connections.connect("default", host="localhost", port="19530")

# 加载 Collection
collection = Collection("documents")
collection.load()

# 准备查询向量
query_vector = embed("Python 教程")

# 标量过滤：只查询2024年的文档
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"ef": 64}},
    limit=10,
    expr="year == 2024",
    output_fields=["title", "year", "category"]
)

# 输出结果
for hits in results:
    for hit in hits:
        print(f"ID: {hit.id}, Distance: {hit.distance:.4f}")
        print(f"Title: {hit.entity.get('title')}")
        print(f"Year: {hit.entity.get('year')}")
        print(f"Category: {hit.entity.get('category')}")
        print("-" * 50)
```

---

### 6.2 复杂条件组合

```python
# 多条件过滤
expr = """
    year == 2024 and
    category in ['tutorial', 'guide', 'documentation'] and
    difficulty in ['beginner', 'intermediate'] and
    rating >= 4.0 and
    is_free == true
"""

results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"ef": 64}},
    limit=10,
    expr=expr,
    output_fields=["title", "category", "difficulty", "rating"]
)
```

---

### 6.3 性能对比测试

```python
import time

# 测试1：无过滤
start = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10
)
time_no_filter = time.time() - start

# 测试2：标量过滤（高选择性）
start = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="tenant_id == 'A'"  # 过滤掉99%数据
)
time_with_filter = time.time() - start

print(f"无过滤: {time_no_filter:.4f}s")
print(f"标量过滤: {time_with_filter:.4f}s")
print(f"性能提升: {time_no_filter / time_with_filter:.2f}x")
```

---

### 6.4 JSON 字段过滤（Milvus 2.4+）

```python
# 插入带 JSON 字段的数据
data = [
    {
        "id": 1,
        "embedding": [0.1, 0.2, ...],
        "metadata": {
            "tags": ["python", "tutorial"],
            "rating": 4.5,
            "verified": True,
            "author": {"name": "Alice", "level": "expert"}
        }
    }
]

collection.insert(data)

# 查询：过滤 JSON 字段
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="metadata['rating'] > 4.0 and metadata['verified'] == true"
)
```

---

## 7. 常见错误与解决

### 错误1：字段不存在

```python
# ❌ 错误
expr = "unknown_field == 'value'"

# 错误信息：field 'unknown_field' not found

# ✅ 解决：检查 Schema
schema = collection.schema
for field in schema.fields:
    print(f"Field: {field.name}, Type: {field.dtype}")
```

---

### 错误2：类型不匹配

```python
# ❌ 错误（age 是 INT64，不能与字符串比较）
expr = "age == '18'"

# ✅ 正确
expr = "age == 18"
```

---

### 错误3：语法错误

```python
# ❌ 错误（缺少引号）
expr = "city == Beijing"

# ✅ 正确
expr = "city == 'Beijing'"
```

---

### 错误4：字段未加载

```python
# ❌ 错误（output_fields 中的字段未在 Schema 中定义）
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    output_fields=["unknown_field"]
)

# ✅ 解决：只输出 Schema 中定义的字段
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    output_fields=["title", "year"]  # Schema 中存在的字段
)
```

---

## 8. 关键要点总结

### 核心概念

1. **标量过滤 = 基于精确条件筛选数据**
2. **表达式引擎 = 支持丰富的操作符（==, >, <, in, and, or）**
3. **执行策略 = Filter-then-Search / Search-then-Filter**
4. **性能优化 = 创建索引 + 优化表达式 + 分区组合**

### 在混合检索中的作用

- 标量过滤：精确条件 + 业务规则
- 向量检索：语义理解 + 召回候选集
- 组合：精准召回 + 数据隔离 + 性能优化

### 最佳实践

1. **为高选择性字段创建索引**（如 tenant_id）
2. **高选择性条件前置**（如 tenant_id 在前，age 在后）
3. **使用 IN 代替多个 OR**
4. **避免 LIKE**（性能差）
5. **组合分区 + 标量过滤**（最优性能）

---

**下一步**：学习 [05_核心概念_3_混合检索执行策略.md](./05_核心概念_3_混合检索执行策略.md)
