# æ ¸å¿ƒæ¦‚å¿µ08ï¼šå¤šä»£ç†çŠ¶æ€åè°ƒ

> **å®šä¹‰**ï¼šå¤šä»£ç†çŠ¶æ€åè°ƒæ˜¯æŒ‡å¤šä¸ªAgentå…±äº«å’ŒåŒæ­¥çŠ¶æ€ï¼Œåä½œå®Œæˆå¤æ‚ä»»åŠ¡çš„æœºåˆ¶

---

## ä¸€ã€ä¸ºä»€ä¹ˆéœ€è¦å¤šAgentï¼Ÿ

### 1.1 å•Agentçš„å±€é™

**é—®é¢˜1ï¼šä»»åŠ¡å¤æ‚åº¦**
```python
# å•Agentå¤„ç†å¤æ‚ä»»åŠ¡
def single_agent(query):
    # éœ€è¦åŒæ—¶å¤„ç†ï¼š
    # - æœç´¢
    # - åˆ†æž
    # - å†™ä½œ
    # - éªŒè¯
    # å¤ªå¤æ‚ï¼Œéš¾ä»¥ç»´æŠ¤ âŒ
```

**é—®é¢˜2ï¼šä¸“ä¸šåŒ–éœ€æ±‚**
```python
# ä¸åŒä»»åŠ¡éœ€è¦ä¸åŒä¸“é•¿
# - æœç´¢Agentï¼šæ“…é•¿ä¿¡æ¯æ£€ç´¢
# - åˆ†æžAgentï¼šæ“…é•¿æ•°æ®åˆ†æž
# - å†™ä½œAgentï¼šæ“…é•¿å†…å®¹ç”Ÿæˆ
# å•Agentéš¾ä»¥å…¼é¡¾ âŒ
```

**é—®é¢˜3ï¼šå¹¶è¡Œå¤„ç†**
```python
# å¤šä¸ªç‹¬ç«‹ä»»åŠ¡
# - ä»»åŠ¡Aï¼šæœç´¢èµ„æ–™
# - ä»»åŠ¡Bï¼šåˆ†æžæ•°æ®
# - ä»»åŠ¡Cï¼šç”ŸæˆæŠ¥å‘Š
# å•Agentåªèƒ½ä¸²è¡Œ âŒ
```

---

### 1.2 å¤šAgentçš„ä¼˜åŠ¿

**ä¼˜åŠ¿1ï¼šä»»åŠ¡åˆ†è§£**
```python
# å¤æ‚ä»»åŠ¡åˆ†è§£ä¸ºå­ä»»åŠ¡
ç ”ç©¶ä»»åŠ¡ = æœç´¢Agent + åˆ†æžAgent + å†™ä½œAgent
```

**ä¼˜åŠ¿2ï¼šä¸“ä¸šåŒ–**
```python
# æ¯ä¸ªAgentä¸“æ³¨ä¸€ä¸ªé¢†åŸŸ
æœç´¢Agentï¼šä¸“æ³¨ä¿¡æ¯æ£€ç´¢
åˆ†æžAgentï¼šä¸“æ³¨æ•°æ®åˆ†æž
å†™ä½œAgentï¼šä¸“æ³¨å†…å®¹ç”Ÿæˆ
```

**ä¼˜åŠ¿3ï¼šå¹¶è¡Œæ‰§è¡Œ**
```python
# å¤šä¸ªAgentå¹¶è¡Œå·¥ä½œ
Agent1 || Agent2 || Agent3 â†’ åè°ƒå™¨ â†’ ç»“æžœ
```

---

## äºŒã€å¤šAgentæž¶æž„æ¨¡å¼

### 2.1 ä¸»ä»Žæ¨¡å¼ï¼ˆMaster-Workerï¼‰

**æž¶æž„**ï¼š
```
MasterAgentï¼ˆåè°ƒå™¨ï¼‰
    â†“ åˆ†é…ä»»åŠ¡
WorkerAgent1  WorkerAgent2  WorkerAgent3
    â†“ è¿”å›žç»“æžœ
MasterAgentï¼ˆæ±‡æ€»ï¼‰
```

**ç‰¹ç‚¹**ï¼š
- ä¸­å¿ƒåŒ–æŽ§åˆ¶
- Masterè´Ÿè´£ä»»åŠ¡åˆ†é…å’Œç»“æžœæ±‡æ€»
- Workerç‹¬ç«‹æ‰§è¡Œä»»åŠ¡

**Pythonå®žçŽ°**ï¼š
```python
from typing import TypedDict, List
from langgraph.graph import StateGraph, START, END

class MasterWorkerState(TypedDict):
    task: str
    subtasks: List[str]
    worker1_result: str
    worker2_result: str
    worker3_result: str
    final_result: str

def master_split(state: MasterWorkerState) -> MasterWorkerState:
    """Masterï¼šåˆ†è§£ä»»åŠ¡"""
    task = state["task"]
    print(f"ðŸ“‹ Master: åˆ†è§£ä»»åŠ¡ '{task}'")

    subtasks = [
        f"å­ä»»åŠ¡1: æœç´¢å…³äºŽ{task}çš„èµ„æ–™",
        f"å­ä»»åŠ¡2: åˆ†æž{task}çš„æ•°æ®",
        f"å­ä»»åŠ¡3: æ€»ç»“{task}çš„ç»“è®º"
    ]

    return {"subtasks": subtasks}

def worker1(state: MasterWorkerState) -> MasterWorkerState:
    """Worker1ï¼šæœç´¢"""
    subtask = state["subtasks"][0]
    print(f"ðŸ” Worker1: æ‰§è¡Œ '{subtask}'")
    result = f"Worker1å®Œæˆï¼šæ‰¾åˆ°10ç¯‡ç›¸å…³æ–‡æ¡£"
    return {"worker1_result": result}

def worker2(state: MasterWorkerState) -> MasterWorkerState:
    """Worker2ï¼šåˆ†æž"""
    subtask = state["subtasks"][1]
    print(f"ðŸ“Š Worker2: æ‰§è¡Œ '{subtask}'")
    result = f"Worker2å®Œæˆï¼šåˆ†æžäº†5ä¸ªå…³é”®æŒ‡æ ‡"
    return {"worker2_result": result}

def worker3(state: MasterWorkerState) -> MasterWorkerState:
    """Worker3ï¼šæ€»ç»“"""
    subtask = state["subtasks"][2]
    print(f"ðŸ“ Worker3: æ‰§è¡Œ '{subtask}'")
    result = f"Worker3å®Œæˆï¼šç”Ÿæˆäº†3é¡µæŠ¥å‘Š"
    return {"worker3_result": result}

def master_merge(state: MasterWorkerState) -> MasterWorkerState:
    """Masterï¼šåˆå¹¶ç»“æžœ"""
    print(f"ðŸ”— Master: åˆå¹¶ç»“æžœ")

    final = f"""
    æœ€ç»ˆæŠ¥å‘Šï¼š
    - {state['worker1_result']}
    - {state['worker2_result']}
    - {state['worker3_result']}
    """

    return {"final_result": final}

# æž„å»ºå›¾
def create_master_worker_graph():
    graph = StateGraph(MasterWorkerState)

    # æ·»åŠ èŠ‚ç‚¹
    graph.add_node("master_split", master_split)
    graph.add_node("worker1", worker1)
    graph.add_node("worker2", worker2)
    graph.add_node("worker3", worker3)
    graph.add_node("master_merge", master_merge)

    # Masteråˆ†è§£ä»»åŠ¡
    graph.add_edge(START, "master_split")

    # Workerså¹¶è¡Œæ‰§è¡Œ
    graph.add_edge("master_split", "worker1")
    graph.add_edge("master_split", "worker2")
    graph.add_edge("master_split", "worker3")

    # Masteråˆå¹¶ç»“æžœ
    graph.add_edge(["worker1", "worker2", "worker3"], "master_merge")
    graph.add_edge("master_merge", END)

    return graph

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    graph = create_master_worker_graph()
    app = graph.compile()

    result = app.invoke({"task": "AI AgentæŠ€æœ¯"})
    print("\n=== æœ€ç»ˆç»“æžœ ===")
    print(result["final_result"])
```

---

### 2.2 å¯¹ç­‰æ¨¡å¼ï¼ˆPeer-to-Peerï¼‰

**æž¶æž„**ï¼š
```
Agent1 â†” Agent2 â†” Agent3
  â†•        â†•        â†•
    SharedState
```

**ç‰¹ç‚¹**ï¼š
- åŽ»ä¸­å¿ƒåŒ–
- Agentä¹‹é—´å¹³ç­‰é€šä¿¡
- å…±äº«çŠ¶æ€

**Pythonå®žçŽ°**ï¼š
```python
from typing import TypedDict, Annotated
import operator

class P2PState(TypedDict):
    messages: Annotated[List[str], operator.add]
    agent1_data: str
    agent2_data: str
    agent3_data: str

def agent1_peer(state: P2PState) -> P2PState:
    """Agent1ï¼šæœç´¢"""
    print("ðŸ” Agent1: æœç´¢èµ„æ–™")

    # è¯»å–å…¶ä»–Agentçš„æ•°æ®
    agent2_data = state.get("agent2_data", "")
    if agent2_data:
        print(f"   Agent1çœ‹åˆ°Agent2çš„æ•°æ®: {agent2_data}")

    result = "Agent1æ‰¾åˆ°äº†10ç¯‡æ–‡æ¡£"
    return {
        "agent1_data": result,
        "messages": [f"Agent1: {result}"]
    }

def agent2_peer(state: P2PState) -> P2PState:
    """Agent2ï¼šåˆ†æž"""
    print("ðŸ“Š Agent2: åˆ†æžæ•°æ®")

    # è¯»å–å…¶ä»–Agentçš„æ•°æ®
    agent1_data = state.get("agent1_data", "")
    if agent1_data:
        print(f"   Agent2çœ‹åˆ°Agent1çš„æ•°æ®: {agent1_data}")

    result = "Agent2åˆ†æžäº†5ä¸ªæŒ‡æ ‡"
    return {
        "agent2_data": result,
        "messages": [f"Agent2: {result}"]
    }

def agent3_peer(state: P2PState) -> P2PState:
    """Agent3ï¼šæ€»ç»“"""
    print("ðŸ“ Agent3: ç”ŸæˆæŠ¥å‘Š")

    # è¯»å–å…¶ä»–Agentçš„æ•°æ®
    agent1_data = state.get("agent1_data", "")
    agent2_data = state.get("agent2_data", "")

    if agent1_data and agent2_data:
        print(f"   Agent3çœ‹åˆ°Agent1å’ŒAgent2çš„æ•°æ®")

    result = f"Agent3åŸºäºŽ{agent1_data}å’Œ{agent2_data}ç”ŸæˆæŠ¥å‘Š"
    return {
        "agent3_data": result,
        "messages": [f"Agent3: {result}"]
    }

# æž„å»ºå›¾
def create_p2p_graph():
    graph = StateGraph(P2PState)

    graph.add_node("agent1", agent1_peer)
    graph.add_node("agent2", agent2_peer)
    graph.add_node("agent3", agent3_peer)

    # é¡ºåºæ‰§è¡Œï¼ˆæ¯ä¸ªAgentéƒ½èƒ½çœ‹åˆ°å‰é¢Agentçš„ç»“æžœï¼‰
    graph.add_edge(START, "agent1")
    graph.add_edge("agent1", "agent2")
    graph.add_edge("agent2", "agent3")
    graph.add_edge("agent3", END)

    return graph
```

---

### 2.3 å±‚çº§æ¨¡å¼ï¼ˆHierarchicalï¼‰

**æž¶æž„**ï¼š
```
SupervisorAgent
    â†“
ManagerAgent1  ManagerAgent2
    â†“              â†“
Worker1 Worker2  Worker3 Worker4
```

**ç‰¹ç‚¹**ï¼š
- å¤šå±‚çº§ç»“æž„
- ä¸Šå±‚Agentç®¡ç†ä¸‹å±‚Agent
- é€‚åˆå¤§è§„æ¨¡ç³»ç»Ÿ

**Pythonå®žçŽ°**ï¼š
```python
class HierarchicalState(TypedDict):
    task: str
    supervisor_plan: str
    manager1_tasks: List[str]
    manager2_tasks: List[str]
    worker_results: List[str]
    final_result: str

def supervisor(state: HierarchicalState) -> HierarchicalState:
    """Supervisorï¼šåˆ¶å®šè®¡åˆ’"""
    task = state["task"]
    print(f"ðŸ‘” Supervisor: åˆ¶å®šè®¡åˆ’ '{task}'")

    plan = f"å°†{task}åˆ†ä¸ºå‰ç«¯å’ŒåŽç«¯ä¸¤éƒ¨åˆ†"
    return {"supervisor_plan": plan}

def manager1(state: HierarchicalState) -> HierarchicalState:
    """Manager1ï¼šå‰ç«¯ç®¡ç†"""
    print("ðŸ‘¨â€ðŸ’¼ Manager1: ç®¡ç†å‰ç«¯ä»»åŠ¡")

    tasks = ["UIè®¾è®¡", "ç»„ä»¶å¼€å‘"]
    return {"manager1_tasks": tasks}

def manager2(state: HierarchicalState) -> HierarchicalState:
    """Manager2ï¼šåŽç«¯ç®¡ç†"""
    print("ðŸ‘©â€ðŸ’¼ Manager2: ç®¡ç†åŽç«¯ä»»åŠ¡")

    tasks = ["APIå¼€å‘", "æ•°æ®åº“è®¾è®¡"]
    return {"manager2_tasks": tasks}

# ... Workerså®žçŽ°ç±»ä¼¼
```

---

## ä¸‰ã€çŠ¶æ€å…±äº«æœºåˆ¶

### 3.1 å…±äº«çŠ¶æ€ï¼ˆShared Stateï¼‰

**LangGraphçš„å…±äº«çŠ¶æ€æ¨¡åž‹**ï¼š
```python
from typing import TypedDict, Annotated
import operator

class SharedState(TypedDict):
    # ä½¿ç”¨Annotatedè‡ªåŠ¨åˆå¹¶
    messages: Annotated[List[str], operator.add]
    documents: Annotated[List[str], operator.add]

    # æ™®é€šå­—æ®µï¼ˆè¦†ç›–æ›´æ–°ï¼‰
    current_agent: str
    status: str

def agent1(state: SharedState) -> SharedState:
    """Agent1æ›´æ–°å…±äº«çŠ¶æ€"""
    return {
        "messages": ["Agent1çš„æ¶ˆæ¯"],
        "documents": ["æ–‡æ¡£1", "æ–‡æ¡£2"],
        "current_agent": "agent1"
    }

def agent2(state: SharedState) -> SharedState:
    """Agent2è¯»å–å¹¶æ›´æ–°å…±äº«çŠ¶æ€"""
    # è¯»å–Agent1çš„ç»“æžœ
    prev_messages = state["messages"]
    prev_docs = state["documents"]

    print(f"Agent2çœ‹åˆ°: {len(prev_messages)}æ¡æ¶ˆæ¯, {len(prev_docs)}ä¸ªæ–‡æ¡£")

    # æ·»åŠ è‡ªå·±çš„ç»“æžœ
    return {
        "messages": ["Agent2çš„æ¶ˆæ¯"],  # è‡ªåŠ¨åˆå¹¶
        "documents": ["æ–‡æ¡£3"],         # è‡ªåŠ¨åˆå¹¶
        "current_agent": "agent2"
    }

# æœ€ç»ˆçŠ¶æ€ï¼š
# messages = ["Agent1çš„æ¶ˆæ¯", "Agent2çš„æ¶ˆæ¯"]
# documents = ["æ–‡æ¡£1", "æ–‡æ¡£2", "æ–‡æ¡£3"]
# current_agent = "agent2"
```

---

### 3.2 æ¶ˆæ¯ä¼ é€’ï¼ˆMessage Passingï¼‰

**é€šè¿‡messageså­—æ®µä¼ é€’ä¿¡æ¯**ï¼š
```python
from langchain_core.messages import HumanMessage, AIMessage

class MessageState(TypedDict):
    messages: Annotated[List[BaseMessage], operator.add]

def agent1(state: MessageState) -> MessageState:
    """Agent1å‘é€æ¶ˆæ¯"""
    return {
        "messages": [
            AIMessage(
                content="Agent1çš„ç»“æžœ",
                name="agent1"
            )
        ]
    }

def agent2(state: MessageState) -> MessageState:
    """Agent2æŽ¥æ”¶å¹¶å“åº”"""
    # è¯»å–Agent1çš„æ¶ˆæ¯
    prev_messages = state["messages"]
    agent1_msg = [m for m in prev_messages if m.name == "agent1"]

    print(f"Agent2æ”¶åˆ°Agent1çš„æ¶ˆæ¯: {agent1_msg[-1].content}")

    # å‘é€å“åº”
    return {
        "messages": [
            AIMessage(
                content="Agent2çš„å“åº”",
                name="agent2"
            )
        ]
    }
```

---

### 3.3 äº‹ä»¶é©±åŠ¨ï¼ˆEvent-Drivenï¼‰

**é€šè¿‡äº‹ä»¶è§¦å‘Agent**ï¼š
```python
class EventState(TypedDict):
    events: Annotated[List[dict], operator.add]
    agent1_done: bool
    agent2_done: bool

def agent1(state: EventState) -> EventState:
    """Agent1å®ŒæˆåŽå‘é€äº‹ä»¶"""
    print("Agent1: æ‰§è¡Œä»»åŠ¡")

    return {
        "agent1_done": True,
        "events": [{
            "type": "agent1_completed",
            "data": "Agent1çš„ç»“æžœ"
        }]
    }

def agent2(state: EventState) -> EventState:
    """Agent2ç›‘å¬Agent1çš„äº‹ä»¶"""
    events = state["events"]
    agent1_events = [e for e in events if e["type"] == "agent1_completed"]

    if agent1_events:
        print(f"Agent2: æ”¶åˆ°Agent1å®Œæˆäº‹ä»¶")
        data = agent1_events[-1]["data"]
        print(f"   æ•°æ®: {data}")

    return {
        "agent2_done": True,
        "events": [{
            "type": "agent2_completed",
            "data": "Agent2çš„ç»“æžœ"
        }]
    }
```

---

## å››ã€å®Œæ•´å®žæˆ˜ç¤ºä¾‹

### 4.1 ç ”ç©¶åŠ©æ‰‹ç³»ç»Ÿ

**éœ€æ±‚**ï¼šæž„å»ºä¸€ä¸ªç ”ç©¶åŠ©æ‰‹ï¼ŒåŒ…å«æœç´¢ã€åˆ†æžã€å†™ä½œä¸‰ä¸ªAgent

```python
from typing import TypedDict, List, Annotated
from langgraph.graph import StateGraph, START, END
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage
import operator

# 1. å®šä¹‰å…±äº«çŠ¶æ€
class ResearchState(TypedDict):
    topic: str
    search_results: Annotated[List[str], operator.add]
    analysis: str
    report: str
    messages: Annotated[List[str], operator.add]

# 2. æœç´¢Agent
def search_agent(state: ResearchState) -> ResearchState:
    """æœç´¢Agentï¼šæŸ¥æ‰¾èµ„æ–™"""
    topic = state["topic"]
    print(f"ðŸ” æœç´¢Agent: æœç´¢ '{topic}'")

    # æ¨¡æ‹Ÿæœç´¢ï¼ˆå®žé™…åº”è°ƒç”¨æœç´¢APIï¼‰
    results = [
        f"èµ„æ–™1: {topic}çš„å®šä¹‰å’ŒåŽ†å²",
        f"èµ„æ–™2: {topic}çš„åº”ç”¨åœºæ™¯",
        f"èµ„æ–™3: {topic}çš„æœ€æ–°è¿›å±•",
        f"èµ„æ–™4: {topic}çš„æŠ€æœ¯ç»†èŠ‚",
        f"èµ„æ–™5: {topic}çš„æœªæ¥è¶‹åŠ¿"
    ]

    return {
        "search_results": results,
        "messages": [f"æœç´¢Agent: æ‰¾åˆ°{len(results)}æ¡èµ„æ–™"]
    }

# 3. åˆ†æžAgent
def analysis_agent(state: ResearchState) -> ResearchState:
    """åˆ†æžAgentï¼šåˆ†æžèµ„æ–™"""
    topic = state["topic"]
    results = state["search_results"]
    print(f"ðŸ“Š åˆ†æžAgent: åˆ†æž {len(results)} æ¡èµ„æ–™")

    # ä½¿ç”¨LLMåˆ†æž
    llm = ChatOpenAI(model="gpt-4", temperature=0)
    prompt = f"""åˆ†æžä»¥ä¸‹å…³äºŽ'{topic}'çš„èµ„æ–™ï¼Œæå–å…³é”®ä¿¡æ¯ï¼š

èµ„æ–™ï¼š
{chr(10).join(results)}

è¯·æä¾›ï¼š
1. æ ¸å¿ƒæ¦‚å¿µ
2. ä¸»è¦åº”ç”¨
3. æŠ€æœ¯è¶‹åŠ¿
"""

    response = llm.invoke([HumanMessage(content=prompt)])
    analysis = response.content

    return {
        "analysis": analysis,
        "messages": ["åˆ†æžAgent: å®Œæˆåˆ†æž"]
    }

# 4. å†™ä½œAgent
def writing_agent(state: ResearchState) -> ResearchState:
    """å†™ä½œAgentï¼šç”ŸæˆæŠ¥å‘Š"""
    topic = state["topic"]
    analysis = state["analysis"]
    print(f"ðŸ“ å†™ä½œAgent: ç”ŸæˆæŠ¥å‘Š")

    # ä½¿ç”¨LLMç”ŸæˆæŠ¥å‘Š
    llm = ChatOpenAI(model="gpt-4", temperature=0.7)
    prompt = f"""åŸºäºŽä»¥ä¸‹åˆ†æžï¼Œæ’°å†™ä¸€ä»½å…³äºŽ'{topic}'çš„ç ”ç©¶æŠ¥å‘Šï¼š

åˆ†æžç»“æžœï¼š
{analysis}

è¦æ±‚ï¼š
1. ç»“æž„æ¸…æ™°
2. å†…å®¹å®Œæ•´
3. è¯­è¨€ä¸“ä¸š
"""

    response = llm.invoke([HumanMessage(content=prompt)])
    report = response.content

    return {
        "report": report,
        "messages": ["å†™ä½œAgent: å®ŒæˆæŠ¥å‘Š"]
    }

# 5. æž„å»ºå¤šAgentå›¾
def create_research_system():
    graph = StateGraph(ResearchState)

    # æ·»åŠ AgentèŠ‚ç‚¹
    graph.add_node("search", search_agent)
    graph.add_node("analysis", analysis_agent)
    graph.add_node("writing", writing_agent)

    # å®šä¹‰æµç¨‹
    graph.add_edge(START, "search")
    graph.add_edge("search", "analysis")
    graph.add_edge("analysis", "writing")
    graph.add_edge("writing", END)

    return graph

# 6. ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    graph = create_research_system()
    app = graph.compile()

    # è¿è¡Œç ”ç©¶ä»»åŠ¡
    result = app.invoke({
        "topic": "LangGraphå¤šAgentç³»ç»Ÿ",
        "search_results": [],
        "analysis": "",
        "report": "",
        "messages": []
    })

    print("\n=== ç ”ç©¶æŠ¥å‘Š ===")
    print(result["report"])

    print("\n=== æ‰§è¡Œæ—¥å¿— ===")
    for msg in result["messages"]:
        print(f"  {msg}")
```

---

## äº”ã€åè°ƒç­–ç•¥

### 5.1 é¡ºåºåè°ƒ

**åœºæ™¯**ï¼šAgentæŒ‰é¡ºåºæ‰§è¡Œ

```python
# Agent1 â†’ Agent2 â†’ Agent3
graph.add_edge(START, "agent1")
graph.add_edge("agent1", "agent2")
graph.add_edge("agent2", "agent3")
graph.add_edge("agent3", END)
```

---

### 5.2 å¹¶è¡Œåè°ƒ

**åœºæ™¯**ï¼šå¤šä¸ªAgentå¹¶è¡Œæ‰§è¡Œ

```python
# START â†’ [Agent1, Agent2, Agent3] â†’ Coordinator â†’ END
graph.add_edge(START, "agent1")
graph.add_edge(START, "agent2")
graph.add_edge(START, "agent3")
graph.add_edge(["agent1", "agent2", "agent3"], "coordinator")
graph.add_edge("coordinator", END)
```

---

### 5.3 æ¡ä»¶åè°ƒ

**åœºæ™¯**ï¼šæ ¹æ®æ¡ä»¶é€‰æ‹©Agent

```python
def router(state: State) -> str:
    """æ ¹æ®çŠ¶æ€é€‰æ‹©ä¸‹ä¸€ä¸ªAgent"""
    if state["éœ€è¦æœç´¢"]:
        return "search_agent"
    elif state["éœ€è¦åˆ†æž"]:
        return "analysis_agent"
    else:
        return "writing_agent"

graph.add_conditional_edges(
    "coordinator",
    router,
    {
        "search_agent": "search_agent",
        "analysis_agent": "analysis_agent",
        "writing_agent": "writing_agent"
    }
)
```

---

## å…­ã€å†²çªè§£å†³

### 6.1 æœ€åŽå†™å…¥èƒœå‡ºï¼ˆLast Write Winsï¼‰

**ç­–ç•¥**ï¼šåŽæ‰§è¡Œçš„Agentè¦†ç›–å‰é¢çš„ç»“æžœ

```python
class State(TypedDict):
    value: int  # æ™®é€šå­—æ®µï¼Œè¦†ç›–æ›´æ–°

def agent1(state: State) -> State:
    return {"value": 10}

def agent2(state: State) -> State:
    return {"value": 20}  # è¦†ç›–agent1çš„å€¼

# æœ€ç»ˆvalue = 20
```

---

### 6.2 åˆå¹¶ç­–ç•¥ï¼ˆMergeï¼‰

**ç­–ç•¥**ï¼šä½¿ç”¨Annotatedè‡ªåŠ¨åˆå¹¶

```python
class State(TypedDict):
    items: Annotated[List[str], operator.add]  # è‡ªåŠ¨åˆå¹¶

def agent1(state: State) -> State:
    return {"items": ["a", "b"]}

def agent2(state: State) -> State:
    return {"items": ["c", "d"]}

# æœ€ç»ˆitems = ["a", "b", "c", "d"]
```

---

### 6.3 ä¼˜å…ˆçº§ç­–ç•¥ï¼ˆPriorityï¼‰

**ç­–ç•¥**ï¼šé«˜ä¼˜å…ˆçº§Agentçš„ç»“æžœä¼˜å…ˆ

```python
class State(TypedDict):
    result: str
    priority: int

def high_priority_agent(state: State) -> State:
    return {"result": "é«˜ä¼˜å…ˆçº§ç»“æžœ", "priority": 10}

def low_priority_agent(state: State) -> State:
    current_priority = state.get("priority", 0)
    if current_priority < 5:  # åªæœ‰ä¼˜å…ˆçº§ä½Žæ—¶æ‰æ›´æ–°
        return {"result": "ä½Žä¼˜å…ˆçº§ç»“æžœ", "priority": 5}
    return {}
```

---

## ä¸ƒã€2025-2026æœ€ä½³å®žè·µ

### 7.1 ä½¿ç”¨LangGraphçš„å…±äº«çŠ¶æ€

**æŽ¨è**ï¼š
```python
# âœ… ä½¿ç”¨LangGraphçš„å…±äº«çŠ¶æ€æ¨¡åž‹
class State(TypedDict):
    shared_data: Annotated[List[str], operator.add]

# è‡ªåŠ¨å¤„ç†çŠ¶æ€åˆå¹¶ï¼Œæ— éœ€æ‰‹åŠ¨åŒæ­¥
```

**ä¸æŽ¨è**ï¼š
```python
# âŒ æ‰‹åŠ¨å®žçŽ°æ¶ˆæ¯é˜Ÿåˆ—
import queue
message_queue = queue.Queue()

# å¤æ‚ä¸”å®¹æ˜“å‡ºé”™
```

---

### 7.2 æ˜Žç¡®AgentèŒè´£

**åŽŸåˆ™**ï¼šæ¯ä¸ªAgentåªåšä¸€ä»¶äº‹

```python
# âœ… èŒè´£æ˜Žç¡®
search_agent: åªè´Ÿè´£æœç´¢
analysis_agent: åªè´Ÿè´£åˆ†æž
writing_agent: åªè´Ÿè´£å†™ä½œ

# âŒ èŒè´£æ··ä¹±
general_agent: æœç´¢+åˆ†æž+å†™ä½œ
```

---

### 7.3 ä½¿ç”¨Checkpointing

**åœºæ™¯**ï¼šå¤šAgenté•¿è¿è¡Œä»»åŠ¡

```python
from langgraph.checkpoint.postgres import PostgresSaver

checkpointer = PostgresSaver.from_conn_string(DB_URI)
app = graph.compile(checkpointer=checkpointer)

# æ”¯æŒæ•…éšœæ¢å¤
config = {"configurable": {"thread_id": "multi_agent_task"}}
result = app.invoke(input, config=config)
```

---

## å…«ã€æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **å¤šAgentæž¶æž„**ï¼šä¸»ä»Žã€å¯¹ç­‰ã€å±‚çº§
2. **çŠ¶æ€å…±äº«**ï¼šå…±äº«çŠ¶æ€ã€æ¶ˆæ¯ä¼ é€’ã€äº‹ä»¶é©±åŠ¨
3. **åè°ƒç­–ç•¥**ï¼šé¡ºåºã€å¹¶è¡Œã€æ¡ä»¶
4. **å†²çªè§£å†³**ï¼šè¦†ç›–ã€åˆå¹¶ã€ä¼˜å…ˆçº§
5. **LangGraphä¼˜åŠ¿**ï¼šè‡ªåŠ¨çŠ¶æ€åˆå¹¶ã€å¹¶è¡Œæ‰§è¡Œ

### æž¶æž„é€‰æ‹©

| åœºæ™¯ | æŽ¨èæž¶æž„ | åŽŸå›  |
|------|---------|------|
| **ç®€å•ä»»åŠ¡åˆ†è§£** | ä¸»ä»Žæ¨¡å¼ | ä¸­å¿ƒåŒ–æŽ§åˆ¶ |
| **å¹³ç­‰åä½œ** | å¯¹ç­‰æ¨¡å¼ | åŽ»ä¸­å¿ƒåŒ– |
| **å¤§è§„æ¨¡ç³»ç»Ÿ** | å±‚çº§æ¨¡å¼ | å¤šå±‚ç®¡ç† |

### æœ€ä½³å®žè·µ

1. **ä½¿ç”¨LangGraphå…±äº«çŠ¶æ€**ï¼ˆè‡ªåŠ¨åˆå¹¶ï¼‰
2. **æ˜Žç¡®AgentèŒè´£**ï¼ˆå•ä¸€èŒè´£ï¼‰
3. **ä½¿ç”¨Checkpointing**ï¼ˆæ•…éšœæ¢å¤ï¼‰
4. **å¹¶è¡Œæ‰§è¡Œ**ï¼ˆæé«˜æ•ˆçŽ‡ï¼‰
5. **ç›‘æŽ§çŠ¶æ€**ï¼ˆå¯è§‚æµ‹æ€§ï¼‰

### å­¦ä¹ å»ºè®®

1. **ç†è§£æž¶æž„æ¨¡å¼**ï¼šä¸»ä»Žã€å¯¹ç­‰ã€å±‚çº§
2. **æŽŒæ¡çŠ¶æ€å…±äº«**ï¼šAnnotated + operator.add
3. **å®žè·µå¹¶è¡Œæ‰§è¡Œ**ï¼šå¤šAgentå¹¶è¡Œ
4. **å­¦ä¹ åè°ƒç­–ç•¥**ï¼šé¡ºåºã€å¹¶è¡Œã€æ¡ä»¶
5. **é˜…è¯»å®˜æ–¹æ¡ˆä¾‹**ï¼šLangGraphå¤šAgentç¤ºä¾‹

---

## å‚è€ƒèµ„æ–™

1. **å®˜æ–¹æ–‡æ¡£**ï¼š
   - LangGraph Multi-Agent Systems
   - LangGraph State Management (2025)
   - AWS - Build a Multi-Agent System with LangGraph

2. **æ•™ç¨‹**ï¼š
   - Sparkco.ai - Mastering LangGraph State Management in 2025
   - aankitroy.com - LangGraph State Management and Memory Guide
   - Temporal + LangGraph: Multi-Agent Coordination (2025)

3. **å®žæˆ˜æ¡ˆä¾‹**ï¼š
   - Research Assistant System
   - Customer Service Multi-Agent
   - Code Review Multi-Agent

---

**ç‰ˆæœ¬**: v1.0
**æœ€åŽæ›´æ–°**: 2026-02-14
**ä»£ç è¡Œæ•°**: ~450è¡Œ
