# 核心概念3：栈的应用场景

> 理解 Stack 在实际开发中的经典应用

---

## 概念定义

**栈的应用场景**：利用 LIFO 特性解决实际问题的典型场景

**核心思想**：任何需要"后进先出"、"嵌套处理"、"回溯恢复"的场景都可以用栈

---

## 1. 表达式求值

### 1.1 中缀表达式转后缀表达式

**问题：** 计算 `3 + 5 * 2 - 8 / 4`

**中缀表达式**：操作符在操作数中间（人类习惯）
**后缀表达式**：操作符在操作数后面（计算机友好）

```python
def infix_to_postfix(expression: str) -> str:
    """中缀转后缀（逆波兰表达式）"""
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    output = []
    operator_stack = []

    tokens = expression.replace(' ', '')

    for char in tokens:
        # 操作数：直接输出
        if char.isdigit():
            output.append(char)

        # 左括号：压栈
        elif char == '(':
            operator_stack.append(char)

        # 右括号：弹出直到左括号
        elif char == ')':
            while operator_stack and operator_stack[-1] != '(':
                output.append(operator_stack.pop())
            operator_stack.pop()  # 弹出左括号

        # 操作符：根据优先级处理
        elif char in precedence:
            while (operator_stack and
                   operator_stack[-1] != '(' and
                   precedence.get(operator_stack[-1], 0) >= precedence[char]):
                output.append(operator_stack.pop())
            operator_stack.append(char)

    # 弹出剩余操作符
    while operator_stack:
        output.append(operator_stack.pop())

    return ' '.join(output)

# 测试
expr = "3 + 5 * 2 - 8 / 4"
postfix = infix_to_postfix(expr)
print(f"中缀: {expr}")
print(f"后缀: {postfix}")  # 3 5 2 * + 8 4 / -
```

### 1.2 计算后缀表达式

```python
def evaluate_postfix(expression: str) -> float:
    """计算后缀表达式"""
    stack = []
    tokens = expression.split()

    for token in tokens:
        # 操作数：压栈
        if token.isdigit():
            stack.append(float(token))

        # 操作符：弹出两个操作数计算
        else:
            b = stack.pop()
            a = stack.pop()

            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            elif token == '/':
                stack.append(a / b)

    return stack[0]

# 测试
postfix = "3 5 2 * + 8 4 / -"
result = evaluate_postfix(postfix)
print(f"结果: {result}")  # 11.0
```

### 1.3 在 AI Agent 中的应用

```python
class PromptExpressionEvaluator:
    """Prompt 表达式求值器"""

    def evaluate(self, prompt_expr: str) -> str:
        """
        计算 Prompt 表达式
        示例: "summarize(extract(text, 'keywords'), 'brief')"
        """
        stack = []
        current_func = ""
        current_args = []

        for char in prompt_expr:
            if char == '(':
                # 函数开始
                stack.append((current_func, current_args))
                current_func = ""
                current_args = []

            elif char == ')':
                # 函数结束，执行
                result = self._execute_function(current_func, current_args)

                if stack:
                    parent_func, parent_args = stack.pop()
                    current_func = parent_func
                    current_args = parent_args + [result]
                else:
                    return result

            elif char == ',':
                # 参数分隔
                if current_func:
                    current_args.append(current_func)
                    current_func = ""

            else:
                current_func += char

        return current_func

    def _execute_function(self, func_name: str, args: list) -> str:
        """执行函数"""
        if func_name == 'extract':
            return f"提取({args[0]}的{args[1]})"
        elif func_name == 'summarize':
            return f"总结({args[0]}, 风格={args[1]})"
        return f"{func_name}({', '.join(map(str, args))})"

# 测试
evaluator = PromptExpressionEvaluator()
result = evaluator.evaluate("summarize(extract(text, keywords), brief)")
print(result)
```

---

## 2. 括号匹配

### 2.1 基本括号匹配

```python
def is_valid_parentheses(s: str) -> bool:
    """检查括号是否匹配"""
    stack = []
    pairs = {'(': ')', '[': ']', '{': '}'}

    for char in s:
        # 左括号：压栈
        if char in pairs:
            stack.append(char)

        # 右括号：检查匹配
        elif char in pairs.values():
            if not stack:
                return False

            left = stack.pop()
            if pairs[left] != char:
                return False

    # 栈应该为空
    return len(stack) == 0

# 测试
test_cases = [
    "()[]{}",      # True
    "([{}])",      # True
    "([)]",        # False
    "(((",         # False
    "())",         # False
]

for case in test_cases:
    print(f"{case}: {is_valid_parentheses(case)}")
```

### 2.2 带位置信息的括号匹配

```python
def find_matching_bracket(s: str, pos: int) -> int:
    """找到指定位置括号的匹配位置"""
    if s[pos] not in '()[]{}':
        return -1

    pairs = {'(': ')', '[': ']', '{': '}',
             ')': '(', ']': '[', '}': '{'}

    # 向右查找
    if s[pos] in '([{':
        stack = []
        for i in range(pos, len(s)):
            if s[i] in '([{':
                stack.append(s[i])
            elif s[i] in ')]}':
                if not stack:
                    return -1
                left = stack.pop()
                if pairs[left] == s[i] and len(stack) == 0:
                    return i

    # 向左查找
    else:
        stack = []
        for i in range(pos, -1, -1):
            if s[i] in ')]}':
                stack.append(s[i])
            elif s[i] in '([{':
                if not stack:
                    return -1
                right = stack.pop()
                if pairs[s[i]] == right and len(stack) == 0:
                    return i

    return -1

# 测试
code = "def func(a, b): return [a, {b: 1}]"
pos = code.index('(')
match_pos = find_matching_bracket(code, pos)
print(f"括号 '{code[pos]}' 在位置 {pos}")
print(f"匹配括号 '{code[match_pos]}' 在位置 {match_pos}")
```

### 2.3 在 AI Agent 中的应用

```python
class PromptValidator:
    """Prompt 模板验证器"""

    def validate_template(self, template: str) -> tuple[bool, str]:
        """
        验证 Prompt 模板的括号匹配
        示例: "请分析 {{user_input}} 并生成 {{output_format}} 格式的结果"
        """
        stack = []
        i = 0

        while i < len(template):
            # 检查双括号
            if i < len(template) - 1 and template[i:i+2] == '{{':
                stack.append(('{{', i))
                i += 2

            elif i < len(template) - 1 and template[i:i+2] == '}}':
                if not stack:
                    return False, f"位置 {i}: 多余的 '}}'"

                left, left_pos = stack.pop()
                if left != '{{':
                    return False, f"位置 {i}: '}}' 不匹配"
                i += 2

            else:
                i += 1

        if stack:
            _, pos = stack[0]
            return False, f"位置 {pos}: '{{{{' 未闭合"

        return True, "模板有效"

# 测试
validator = PromptValidator()

templates = [
    "请分析 {{user_input}} 并生成结果",           # 有效
    "请分析 {{user_input} 并生成结果",            # 无效
    "请分析 {{user_input}} 并生成 {{output}}",   # 有效
    "请分析 user_input}} 并生成结果",             # 无效
]

for template in templates:
    valid, msg = validator.validate_template(template)
    print(f"{template[:30]}... → {msg}")
```

---

## 3. 回溯搜索

### 3.1 深度优先搜索（DFS）

```python
def dfs_iterative(graph: dict, start: str) -> list:
    """使用栈实现 DFS"""
    visited = set()
    stack = [start]
    result = []

    while stack:
        node = stack.pop()

        if node in visited:
            continue

        visited.add(node)
        result.append(node)

        # 将邻居压栈（逆序，保证顺序一致）
        if node in graph:
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)

    return result

# 测试
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

result = dfs_iterative(graph, 'A')
print(f"DFS 遍历: {result}")  # ['A', 'B', 'D', 'E', 'F', 'C']
```

### 3.2 回溯算法：N 皇后问题

```python
def solve_n_queens(n: int) -> list:
    """N 皇后问题 - 使用栈回溯"""
    solutions = []
    stack = [([], 0)]  # (当前解, 当前行)

    while stack:
        current_solution, row = stack.pop()

        # 找到一个解
        if row == n:
            solutions.append(current_solution[:])
            continue

        # 尝试在当前行的每一列放置皇后
        for col in range(n):
            if is_safe(current_solution, row, col):
                # 压栈：尝试这个位置
                stack.append((current_solution + [col], row + 1))

    return solutions

def is_safe(solution: list, row: int, col: int) -> bool:
    """检查位置是否安全"""
    for prev_row, prev_col in enumerate(solution):
        # 同列
        if prev_col == col:
            return False
        # 对角线
        if abs(prev_row - row) == abs(prev_col - col):
            return False
    return True

def print_board(solution: list):
    """打印棋盘"""
    n = len(solution)
    for row in range(n):
        line = ['Q' if col == solution[row] else '.' for col in range(n)]
        print(' '.join(line))
    print()

# 测试
solutions = solve_n_queens(4)
print(f"4 皇后问题有 {len(solutions)} 个解\n")
print("第一个解:")
print_board(solutions[0])
```

### 3.3 在 AI Agent 中的应用

```python
class AgentDecisionTree:
    """Agent 决策树搜索"""

    def __init__(self, max_depth=5):
        self.max_depth = max_depth

    def search_best_action(self, initial_state: dict) -> list:
        """搜索最佳行动序列"""
        best_path = []
        best_score = float('-inf')

        # 使用栈进行 DFS
        stack = [(initial_state, [], 0)]  # (状态, 路径, 深度)

        while stack:
            state, path, depth = stack.pop()

            # 达到深度限制或终止状态
            if depth >= self.max_depth or self._is_terminal(state):
                score = self._evaluate(state, path)
                if score > best_score:
                    best_score = score
                    best_path = path
                continue

            # 尝试所有可能的行动
            for action in self._get_actions(state):
                new_state = self._apply_action(state, action)
                new_path = path + [action]
                stack.append((new_state, new_path, depth + 1))

        return best_path

    def _is_terminal(self, state: dict) -> bool:
        """判断是否为终止状态"""
        return state.get('goal_reached', False)

    def _evaluate(self, state: dict, path: list) -> float:
        """评估状态得分"""
        return state.get('score', 0) - len(path) * 0.1

    def _get_actions(self, state: dict) -> list:
        """获取可能的行动"""
        return ['search', 'analyze', 'summarize']

    def _apply_action(self, state: dict, action: str) -> dict:
        """应用行动"""
        new_state = state.copy()
        new_state['score'] = new_state.get('score', 0) + 1
        if action == 'summarize':
            new_state['goal_reached'] = True
        return new_state

# 测试
agent = AgentDecisionTree(max_depth=3)
initial_state = {'score': 0, 'goal_reached': False}
best_path = agent.search_best_action(initial_state)
print(f"最佳行动序列: {best_path}")
```

---

## 4. 撤销/重做（Undo/Redo）

### 4.1 基本撤销/重做系统

```python
class UndoRedoManager:
    """撤销/重做管理器"""

    def __init__(self):
        self.undo_stack = []
        self.redo_stack = []

    def execute(self, command):
        """执行命令"""
        command.execute()
        self.undo_stack.append(command)
        self.redo_stack.clear()  # 执行新命令后清空重做栈

    def undo(self):
        """撤销"""
        if not self.undo_stack:
            print("没有可撤销的操作")
            return

        command = self.undo_stack.pop()
        command.undo()
        self.redo_stack.append(command)

    def redo(self):
        """重做"""
        if not self.redo_stack:
            print("没有可重做的操作")
            return

        command = self.redo_stack.pop()
        command.execute()
        self.undo_stack.append(command)

# 命令接口
class Command:
    def execute(self):
        pass

    def undo(self):
        pass

# 具体命令：添加文本
class AddTextCommand(Command):
    def __init__(self, document, text):
        self.document = document
        self.text = text

    def execute(self):
        self.document.append(self.text)
        print(f"添加: {self.text}")

    def undo(self):
        self.document.pop()
        print(f"撤销添加: {self.text}")

# 测试
document = []
manager = UndoRedoManager()

manager.execute(AddTextCommand(document, "Hello"))
manager.execute(AddTextCommand(document, "World"))
print(f"文档: {document}")  # ['Hello', 'World']

manager.undo()
print(f"文档: {document}")  # ['Hello']

manager.redo()
print(f"文档: {document}")  # ['Hello', 'World']
```

### 4.2 在 AI Agent 中的应用

```python
class AgentStateManager:
    """Agent 状态管理器（支持撤销/重做）"""

    def __init__(self):
        self.state_stack = []
        self.redo_stack = []
        self.current_state = {}

    def save_state(self, state: dict):
        """保存当前状态"""
        self.state_stack.append(self.current_state.copy())
        self.current_state = state.copy()
        self.redo_stack.clear()
        print(f"保存状态: {state}")

    def undo(self) -> dict:
        """撤销到上一个状态"""
        if not self.state_stack:
            print("没有可撤销的状态")
            return self.current_state

        self.redo_stack.append(self.current_state.copy())
        self.current_state = self.state_stack.pop()
        print(f"撤销到: {self.current_state}")
        return self.current_state

    def redo(self) -> dict:
        """重做到下一个状态"""
        if not self.redo_stack:
            print("没有可重做的状态")
            return self.current_state

        self.state_stack.append(self.current_state.copy())
        self.current_state = self.redo_stack.pop()
        print(f"重做到: {self.current_state}")
        return self.current_state

    def get_current_state(self) -> dict:
        """获取当前状态"""
        return self.current_state.copy()

# 测试
manager = AgentStateManager()

manager.save_state({'step': 1, 'action': 'search'})
manager.save_state({'step': 2, 'action': 'analyze'})
manager.save_state({'step': 3, 'action': 'summarize'})

print("\n当前状态:", manager.get_current_state())

manager.undo()
manager.undo()

print("\n当前状态:", manager.get_current_state())

manager.redo()

print("\n当前状态:", manager.get_current_state())
```

---

## 5. 函数调用栈追踪

### 5.1 调用栈可视化

```python
import inspect
from datetime import datetime

class CallStackTracer:
    """函数调用栈追踪器"""

    def __init__(self):
        self.call_stack = []
        self.execution_log = []

    def trace_call(self, func):
        """装饰器：追踪函数调用"""
        def wrapper(*args, **kwargs):
            # 进入函数
            frame_info = {
                'function': func.__name__,
                'args': args,
                'kwargs': kwargs,
                'start_time': datetime.now(),
                'depth': len(self.call_stack)
            }
            self.call_stack.append(frame_info)

            indent = "  " * frame_info['depth']
            print(f"{indent}→ {func.__name__}({args}, {kwargs})")

            try:
                # 执行函数
                result = func(*args, **kwargs)

                # 退出函数
                frame_info['end_time'] = datetime.now()
                frame_info['result'] = result
                frame_info['duration'] = (frame_info['end_time'] - frame_info['start_time']).total_seconds()

                self.execution_log.append(frame_info)
                self.call_stack.pop()

                print(f"{indent}← {func.__name__} 返回 {result} (耗时: {frame_info['duration']:.3f}s)")

                return result

            except Exception as e:
                frame_info['error'] = str(e)
                self.call_stack.pop()
                print(f"{indent}✗ {func.__name__} 异常: {e}")
                raise

        return wrapper

    def get_call_stack(self) -> list:
        """获取当前调用栈"""
        return [f['function'] for f in self.call_stack]

    def print_summary(self):
        """打印执行摘要"""
        print("\n" + "="*50)
        print("执行摘要:")
        print("="*50)
        for log in self.execution_log:
            indent = "  " * log['depth']
            print(f"{indent}{log['function']}: {log['duration']:.3f}s")

# 使用示例
tracer = CallStackTracer()

@tracer.trace_call
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

@tracer.trace_call
def calculate_sum(n):
    total = 0
    for i in range(n):
        total += fibonacci(i)
    return total

# 测试
result = calculate_sum(5)
tracer.print_summary()
```

### 5.2 在 AI Agent 中的应用（2026）

```python
from typing import Any, Callable
import time

class LangGraphCallTracer:
    """LangGraph Agent 调用链追踪器（2026）"""

    def __init__(self):
        self.node_stack = []
        self.execution_trace = []

    def enter_node(self, node_name: str, state: dict):
        """进入节点"""
        node_info = {
            'node': node_name,
            'state': state.copy(),
            'start_time': time.time(),
            'depth': len(self.node_stack)
        }
        self.node_stack.append(node_info)

        indent = "  " * node_info['depth']
        print(f"{indent}→ 节点: {node_name}")

    def exit_node(self, result: Any = None):
        """退出节点"""
        if not self.node_stack:
            return

        node_info = self.node_stack.pop()
        node_info['end_time'] = time.time()
        node_info['duration'] = node_info['end_time'] - node_info['start_time']
        node_info['result'] = result

        self.execution_trace.append(node_info)

        indent = "  " * len(self.node_stack)
        print(f"{indent}← 节点: {node_info['node']} (耗时: {node_info['duration']:.3f}s)")

    def get_call_chain(self) -> list:
        """获取当前调用链"""
        return [node['node'] for node in self.node_stack]

    def visualize_trace(self):
        """可视化执行轨迹"""
        print("\n" + "="*60)
        print("LangGraph 执行轨迹:")
        print("="*60)

        for trace in self.execution_trace:
            indent = "  " * trace['depth']
            print(f"{indent}[{trace['node']}]")
            print(f"{indent}  耗时: {trace['duration']:.3f}s")
            print(f"{indent}  状态: {list(trace['state'].keys())}")

# 模拟 LangGraph Agent
tracer = LangGraphCallTracer()

def research_agent(query: str):
    tracer.enter_node('research_agent', {'query': query})

    # 调用子节点
    search_results = search_node(query)
    analysis = analyze_node(search_results)

    tracer.exit_node(result=analysis)
    return analysis

def search_node(query: str):
    tracer.enter_node('search_node', {'query': query})
    time.sleep(0.1)  # 模拟搜索
    results = [f"结果1 for {query}", f"结果2 for {query}"]
    tracer.exit_node(result=results)
    return results

def analyze_node(results: list):
    tracer.enter_node('analyze_node', {'results': results})
    time.sleep(0.15)  # 模拟分析
    analysis = f"分析了 {len(results)} 个结果"
    tracer.exit_node(result=analysis)
    return analysis

# 执行
result = research_agent("AI Agent 2026")
tracer.visualize_trace()
```

---

## 6. 浏览器历史记录

### 6.1 简单浏览器历史

```python
class BrowserHistory:
    """浏览器历史记录"""

    def __init__(self, homepage: str):
        self.history = [homepage]
        self.current = 0

    def visit(self, url: str):
        """访问新页面"""
        # 清除当前位置之后的历史
        self.history = self.history[:self.current + 1]
        self.history.append(url)
        self.current += 1
        print(f"访问: {url}")

    def back(self, steps: int = 1) -> str:
        """后退"""
        self.current = max(0, self.current - steps)
        print(f"后退到: {self.history[self.current]}")
        return self.history[self.current]

    def forward(self, steps: int = 1) -> str:
        """前进"""
        self.current = min(len(self.history) - 1, self.current + steps)
        print(f"前进到: {self.history[self.current]}")
        return self.history[self.current]

    def get_current(self) -> str:
        """获取当前页面"""
        return self.history[self.current]

# 测试
browser = BrowserHistory("google.com")
browser.visit("youtube.com")
browser.visit("github.com")
browser.visit("stackoverflow.com")

print(f"\n当前: {browser.get_current()}")

browser.back(2)
print(f"当前: {browser.get_current()}")

browser.forward(1)
print(f"当前: {browser.get_current()}")

browser.visit("reddit.com")  # 清除 stackoverflow.com
print(f"当前: {browser.get_current()}")
```

---

## 总结

**栈的经典应用场景：**

| 应用场景 | 核心思想 | 典型问题 |
|---------|---------|---------|
| **表达式求值** | 操作符优先级 | 中缀转后缀、计算器 |
| **括号匹配** | 嵌套结构验证 | 代码语法检查、模板验证 |
| **回溯搜索** | 深入-回退 | DFS、N皇后、迷宫 |
| **撤销/重做** | 状态历史 | 编辑器、状态管理 |
| **调用栈追踪** | 函数嵌套 | 调试、性能分析 |
| **浏览器历史** | 前进/后退 | 导航系统 |

**在 AI Agent 中的应用：**
- Prompt 表达式求值
- 模板验证
- 决策树搜索
- 状态回溯
- 调用链追踪（LangGraph）
- 导航历史

**记住：** 任何需要"后进先出"、"嵌套处理"、"回溯恢复"的场景都可以用栈！
