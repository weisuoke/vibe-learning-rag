# 核心概念2：运算符重载机制

## 概述

管道操作符 `|` 的底层实现是 Python 的运算符重载机制，通过 `__or__` 和 `__ror__` 方法实现。

**一句话定义**：LangChain 通过重载 `__or__` 方法，让 Runnable 对象支持 `|` 操作符，返回 RunnableSequence。

---

## 1. Python 运算符重载基础

### 1.1 什么是运算符重载

**运算符重载**：让自定义类支持 Python 内置运算符（如 `+`、`-`、`|`）。

```python
# 内置类型的运算符
a = 1 | 2  # 按位或运算，结果是 3
b = {1, 2} | {2, 3}  # 集合并集，结果是 {1, 2, 3}

# 自定义类的运算符重载
class MyClass:
    def __or__(self, other):
        return f"{self} | {other}"

obj1 = MyClass()
obj2 = MyClass()
result = obj1 | obj2  # 调用 obj1.__or__(obj2)
```

### 1.2 `__or__` 方法

**`__or__` 方法**：当使用 `|` 运算符时，Python 会调用左操作数的 `__or__` 方法。

```python
class Number:
    def __init__(self, value):
        self.value = value

    def __or__(self, other):
        # 自定义 | 的行为
        return Number(self.value + other.value)

    def __repr__(self):
        return f"Number({self.value})"

# 使用
a = Number(10)
b = Number(20)
c = a | b  # 调用 a.__or__(b)
print(c)  # Number(30)
```

**执行流程**：
```
a | b
  ↓
Python 查找 a.__or__
  ↓
调用 a.__or__(b)
  ↓
返回结果
```

---

## 2. LangChain 中的 `__or__` 实现

### 2.1 Runnable 基类的 `__or__` 方法

```python
from langchain_core.runnables import Runnable, RunnableSequence

class Runnable:
    """Runnable 基类（简化版）"""

    def __or__(self, other: Runnable) -> RunnableSequence:
        """
        重载 | 运算符

        Args:
            other: 右边的 Runnable

        Returns:
            RunnableSequence: 包含 self 和 other 的序列
        """
        return RunnableSequence(first=self, last=other)

    def invoke(self, input):
        """子类必须实现"""
        raise NotImplementedError
```

### 2.2 实际使用示例

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser

# 三个 Runnable 对象
prompt = ChatPromptTemplate.from_template("讲个笑话")
model = ChatOpenAI()
parser = StrOutputParser()

# 使用 | 运算符
chain = prompt | model | parser

# 等价于
chain = prompt.__or__(model).__or__(parser)

# 等价于
temp = prompt.__or__(model)  # 返回 RunnableSequence(prompt, model)
chain = temp.__or__(parser)  # 返回 RunnableSequence(RunnableSequence(prompt, model), parser)
```

### 2.3 执行流程可视化

```
prompt | model | parser
    ↓
第一步: prompt.__or__(model)
    ↓
返回: RunnableSequence(prompt, model)
    ↓
第二步: RunnableSequence(prompt, model).__or__(parser)
    ↓
返回: RunnableSequence(RunnableSequence(prompt, model), parser)
    ↓
最终: 一个嵌套的 RunnableSequence
```

**实际上 LangChain 会扁平化**：
```python
# LangChain 内部会扁平化嵌套的 RunnableSequence
RunnableSequence(
    RunnableSequence(prompt, model),
    parser
)
    ↓ 扁平化
RunnableSequence(prompt, model, parser)
```

---

## 3. `__ror__` 方法：反向运算符

### 3.1 什么是 `__ror__`

**`__ror__` 方法**：当左操作数不支持 `|` 运算符时，Python 会尝试调用右操作数的 `__ror__` 方法。

```python
class MyClass:
    def __ror__(self, other):
        return f"{other} | {self}"

obj = MyClass()
result = "left" | obj  # "left" 不支持 |，调用 obj.__ror__("left")
print(result)  # "left | <MyClass object>"
```

### 3.2 LangChain 中的 `__ror__` 实现

```python
class Runnable:
    def __or__(self, other):
        return RunnableSequence(self, other)

    def __ror__(self, other):
        """
        反向运算符：当左边不是 Runnable 时调用

        Args:
            other: 左边的对象（可能是字典、函数等）

        Returns:
            RunnableSequence: 将 other 包装成 Runnable 后组合
        """
        # 将 other 包装成 Runnable
        if isinstance(other, dict):
            other = RunnableParallel(other)
        elif callable(other):
            other = RunnableLambda(other)

        return RunnableSequence(other, self)
```

### 3.3 实际应用：字典作为起点

```python
from langchain_core.runnables import RunnablePassthrough

# 字典不是 Runnable，但可以用 |
chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
    | model
    | parser
)

# 执行流程
# 1. 字典 | prompt
#    字典没有 __or__ 方法
#    ↓
#    调用 prompt.__ror__(字典)
#    ↓
#    将字典包装成 RunnableParallel
#    ↓
#    返回 RunnableSequence(RunnableParallel(字典), prompt)
#
# 2. 继续 | model
# 3. 继续 | parser
```

---

## 4. 自定义 Runnable 类

### 4.1 最小实现

```python
from langchain_core.runnables import Runnable

class MyRunnable(Runnable):
    """自定义 Runnable"""

    def __init__(self, name):
        self.name = name

    def invoke(self, input):
        """必须实现 invoke 方法"""
        print(f"{self.name} 处理: {input}")
        return f"{input}_processed_by_{self.name}"

# 使用
step1 = MyRunnable("step1")
step2 = MyRunnable("step2")
step3 = MyRunnable("step3")

# 用 | 组合（自动继承 __or__ 方法）
chain = step1 | step2 | step3

# 调用
result = chain.invoke("input")
# 输出:
# step1 处理: input
# step2 处理: input_processed_by_step1
# step3 处理: input_processed_by_step1_processed_by_step2
# 返回: input_processed_by_step1_processed_by_step2_processed_by_step3
```

### 4.2 完整实现（包含异步、批处理、流式）

```python
from typing import Any, List, Iterator
from langchain_core.runnables import Runnable

class FullRunnable(Runnable):
    """完整的 Runnable 实现"""

    def __init__(self, name: str):
        self.name = name

    def invoke(self, input: Any) -> Any:
        """同步调用"""
        return f"{input}_by_{self.name}"

    async def ainvoke(self, input: Any) -> Any:
        """异步调用"""
        return self.invoke(input)

    def batch(self, inputs: List[Any]) -> List[Any]:
        """批量调用"""
        return [self.invoke(input) for input in inputs]

    def stream(self, input: Any) -> Iterator[Any]:
        """流式调用"""
        result = self.invoke(input)
        # 逐字符返回
        for char in result:
            yield char

# 使用
r1 = FullRunnable("r1")
r2 = FullRunnable("r2")

chain = r1 | r2

# 同步
print(chain.invoke("test"))  # test_by_r1_by_r2

# 批量
print(chain.batch(["a", "b"]))  # ['a_by_r1_by_r2', 'b_by_r1_by_r2']

# 流式
for chunk in chain.stream("test"):
    print(chunk, end="")  # t e s t _ b y _ r 1 _ b y _ r 2
```

---

## 5. 运算符优先级

### 5.1 Python 运算符优先级

```python
# | 的优先级低于函数调用，高于赋值
chain = prompt | model | parser  # ✅ 正确

# 等价于
chain = (prompt | model) | parser

# 不等价于（函数调用优先级更高）
chain = prompt | model(input) | parser  # model(input) 先执行
```

### 5.2 括号控制优先级

```python
# 括号可以改变执行顺序
chain1 = (prompt | model) | parser
chain2 = prompt | (model | parser)

# 但实际上两者等价，因为 | 是左结合的
# chain1 和 chain2 的执行顺序相同
```

---

## 6. 类型系统与运算符重载

### 6.1 泛型类型签名

```python
from typing import Generic, TypeVar

Input = TypeVar("Input")
Output = TypeVar("Output")

class Runnable(Generic[Input, Output]):
    """带类型的 Runnable"""

    def __or__(self, other: "Runnable[Output, NewOutput]") -> "Runnable[Input, NewOutput]":
        """
        类型安全的 | 运算符

        self: Input → Output
        other: Output → NewOutput
        返回: Input → NewOutput
        """
        return RunnableSequence(self, other)

    def invoke(self, input: Input) -> Output:
        raise NotImplementedError
```

### 6.2 类型检查示例

```python
# 类型匹配
prompt: Runnable[dict, ChatPromptValue]
model: Runnable[ChatPromptValue, AIMessage]
parser: Runnable[AIMessage, str]

# 组合后的类型
chain = prompt | model | parser
# chain: Runnable[dict, str]

# 类型不匹配（IDE 会警告）
chain = prompt | parser  # ❌ ChatPromptValue ≠ AIMessage
```

---

## 7. 在 AI Agent 中的应用

### 7.1 自定义预处理器

```python
from langchain_core.runnables import Runnable

class InputValidator(Runnable):
    """输入验证器"""

    def invoke(self, input: dict) -> dict:
        if "question" not in input:
            raise ValueError("缺少 question 字段")
        if len(input["question"]) < 5:
            raise ValueError("问题太短")
        return input

# 在链中使用
chain = (
    InputValidator()  # 自定义 Runnable
    | prompt
    | model
    | parser
)
```

### 7.2 自定义后处理器

```python
class OutputFormatter(Runnable):
    """输出格式化器"""

    def invoke(self, input: str) -> dict:
        return {
            "answer": input,
            "length": len(input),
            "timestamp": datetime.now().isoformat()
        }

# 在链中使用
chain = (
    prompt
    | model
    | parser
    | OutputFormatter()  # 自定义 Runnable
)

result = chain.invoke({"question": "什么是 AI？"})
# result = {
#     "answer": "AI 是人工智能...",
#     "length": 50,
#     "timestamp": "2026-02-18T12:00:00"
# }
```

### 7.3 自定义缓存层

```python
class CacheLayer(Runnable):
    """缓存层"""

    def __init__(self):
        self.cache = {}

    def invoke(self, input: str) -> str:
        if input in self.cache:
            print(f"缓存命中: {input}")
            return self.cache[input]

        # 缓存未命中，返回输入（让下一个组件处理）
        return input

    def set_cache(self, key: str, value: str):
        self.cache[key] = value

# 使用
cache = CacheLayer()

chain = (
    cache  # 先检查缓存
    | prompt
    | model
    | parser
)

# 第一次调用（缓存未命中）
result1 = chain.invoke("什么是 AI？")
cache.set_cache("什么是 AI？", result1)

# 第二次调用（缓存命中）
result2 = chain.invoke("什么是 AI？")  # 直接返回缓存
```

---

## 8. 运算符重载的限制

### 8.1 不能重载所有运算符

```python
# ✅ 可以重载
a | b   # __or__
a & b   # __and__
a + b   # __add__
a - b   # __sub__

# ❌ 不能重载
a and b  # 逻辑运算符不能重载
a or b   # 逻辑运算符不能重载
```

### 8.2 运算符的语义限制

```python
# LangChain 选择 | 而不是 +
chain = a | b  # ✅ 语义清晰：管道

# 如果用 +
chain = a + b  # ❌ 语义不清：加法？拼接？
```

---

## 9. 调试运算符重载

### 9.1 打印中间步骤

```python
class DebugRunnable(Runnable):
    """调试用 Runnable"""

    def __init__(self, name):
        self.name = name

    def __or__(self, other):
        print(f"组合: {self.name} | {other.name}")
        return super().__or__(other)

    def invoke(self, input):
        print(f"{self.name}.invoke({input})")
        return f"{input}_by_{self.name}"

# 使用
a = DebugRunnable("a")
b = DebugRunnable("b")
c = DebugRunnable("c")

chain = a | b | c
# 输出:
# 组合: a | b
# 组合: RunnableSequence | c

result = chain.invoke("test")
# 输出:
# a.invoke(test)
# b.invoke(test_by_a)
# c.invoke(test_by_a_by_b)
```

### 9.2 检查 RunnableSequence 结构

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser

prompt = ChatPromptTemplate.from_template("test")
model = ChatOpenAI()
parser = StrOutputParser()

chain = prompt | model | parser

# 检查类型
print(type(chain))  # <class 'langchain_core.runnables.base.RunnableSequence'>

# 检查步骤
print(chain.steps)  # [ChatPromptTemplate, ChatOpenAI, StrOutputParser]

# 检查第一个和最后一个
print(chain.first)  # ChatPromptTemplate
print(chain.last)   # StrOutputParser
```

---

## 10. 与其他语言的对比

### 10.1 JavaScript 中的管道

```javascript
// JavaScript 没有运算符重载，使用方法链
const chain = prompt
  .pipe(model)
  .pipe(parser);

// 或使用函数组合
const chain = compose(parser, model, prompt);
```

### 10.2 Rust 中的管道

```rust
// Rust 没有 | 运算符重载用于管道
// 使用方法链
let chain = prompt
    .and_then(model)
    .and_then(parser);
```

### 10.3 Python 的优势

```python
# Python 的运算符重载让管道语法更简洁
chain = prompt | model | parser

# 比方法链更简洁
chain = prompt.then(model).then(parser)

# 比函数组合更直观
chain = compose(parser, model, prompt)  # 从右到左，不直观
```

---

## 11. 高级技巧

### 11.1 条件组合

```python
def build_chain(use_cache: bool):
    """根据条件构建不同的链"""
    chain = prompt | model

    if use_cache:
        chain = cache | chain

    chain = chain | parser

    return chain

# 使用
chain_with_cache = build_chain(use_cache=True)
chain_without_cache = build_chain(use_cache=False)
```

### 11.2 动态组合

```python
def build_dynamic_chain(steps: List[Runnable]):
    """动态组合多个步骤"""
    chain = steps[0]
    for step in steps[1:]:
        chain = chain | step
    return chain

# 使用
steps = [prompt, model, parser, validator, formatter]
chain = build_dynamic_chain(steps)
```

### 11.3 运算符链式调用

```python
# 可以连续使用多个运算符
chain = (
    prompt
    | model
    | parser
    | (lambda x: x.upper())  # Lambda 会被包装成 RunnableLambda
    | (lambda x: x.strip())
)
```

---

## 12. 总结

### 运算符重载的核心要点

1. **`__or__` 方法**：实现 `a | b` 语法
2. **`__ror__` 方法**：支持非 Runnable 对象（如字典）作为起点
3. **返回 RunnableSequence**：组合后返回新的 Runnable
4. **类型安全**：通过泛型确保类型匹配
5. **可扩展**：自定义 Runnable 自动支持 `|` 运算符

### 在 AI Agent 中的价值

- **简洁语法**：`a | b | c` 比 `a.then(b).then(c)` 更简洁
- **Pythonic**：利用 Python 的语言特性
- **可组合**：任何 Runnable 都可以用 `|` 组合
- **类型安全**：编译时检查类型匹配

---

## 13. 学习检查

完成本节后，检查是否掌握：

- [ ] 理解 `__or__` 方法的作用
- [ ] 知道 `a | b` 等价于 `a.__or__(b)`
- [ ] 理解 `__ror__` 方法的使用场景
- [ ] 能自定义 Runnable 类并使用 `|` 组合
- [ ] 理解运算符重载的类型系统
- [ ] 能调试运算符重载的执行流程

---

[Source: Pinecone LCEL Tutorial - https://www.pinecone.io/learn/series/langchain/langchain-expression-language]
[Source: LangChain Official Docs - https://python.langchain.com/docs/concepts/]
