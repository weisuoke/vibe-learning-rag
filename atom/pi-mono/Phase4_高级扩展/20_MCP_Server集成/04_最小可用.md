# 最小可用

> **20% 核心知识解决 80% 的 MCP Server 集成问题**

---

## 核心理念

根据帕累托法则（80/20 法则），掌握 20% 的核心知识就能解决 80% 的实际问题。本文档提炼了 MCP Server 集成的最小必要知识集。

---

## 一、核心概念速记（5 分钟掌握）

### 1.1 MCP 是什么？

**一句话**：AI Agent 与外部工具通信的标准化协议（类似 USB-C 接口）

**三个核心抽象**：
```
Tools（工具）     → 可执行的操作（如查询数据库）
Resources（资源） → 可访问的数据（如文件内容）
Events（事件）    → 实时通知（如进度更新）
```

### 1.2 为什么需要 MCP？

**问题**：每个 AI 平台都有自己的工具集成方案 → 碎片化
**解决**：统一协议 → N×M 复杂度降为 N+M

### 1.3 三种使用模式

```
模式 1：使用现有 MCP Server
  └─ 配置 settings.json → 立即可用（最快）

模式 2：构建自定义 MCP Server
  └─ 实现 MCP 协议 → 提供专有工具

模式 3：创建 Pi-mono Extension
  └─ 集成 MCP Client → 连接任意 MCP Server
```

---

## 二、快速上手路径（30 分钟实战）

### 场景 1：使用现有 MCP Server（最常见）

**目标**：在 pi-mono 中使用 Filesystem MCP Server

**步骤**：

1. **安装 MCP Server**
```bash
npm install -g @modelcontextprotocol/server-filesystem
```

2. **配置 settings.json**
```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/path/to/allowed/directory"
      ]
    }
  }
}
```

3. **重启 pi-mono**
```bash
# MCP Server 会自动连接
# Agent 现在可以读写文件了
```

**关键决策点**：
- ✅ 选择合适的 MCP Server（查看社区目录）
- ✅ 配置正确的路径和权限
- ✅ 验证连接是否成功（查看日志）

**常见问题**：
- 路径权限不足 → 检查目录访问权限
- Server 启动失败 → 检查 npm 包是否正确安装
- 工具不可见 → 检查 settings.json 格式

---

### 场景 2：构建简单的 MCP Server（核心技能）

**目标**：创建一个提供计算工具的 MCP Server

**最小实现**（TypeScript）：

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

// 1. 创建 Server 实例
const server = new Server(
  {
    name: "calculator-server",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// 2. 注册工具列表处理器
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: "add",
      description: "Add two numbers",
      inputSchema: {
        type: "object",
        properties: {
          a: { type: "number" },
          b: { type: "number" },
        },
        required: ["a", "b"],
      },
    },
  ],
}));

// 3. 注册工具调用处理器
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (request.params.name === "add") {
    const { a, b } = request.params.arguments as { a: number; b: number };
    return {
      content: [
        {
          type: "text",
          text: `Result: ${a + b}`,
        },
      ],
    };
  }
  throw new Error(`Unknown tool: ${request.params.name}`);
});

// 4. 启动 Server（stdio 传输）
const transport = new StdioServerTransport();
await server.connect(transport);
```

**关键决策点**：
- ✅ 选择传输层（stdio 最简单，HTTP/SSE 更灵活）
- ✅ 定义清晰的工具 Schema（供 LLM 理解）
- ✅ 实现错误处理（避免 Server 崩溃）

**package.json 配置**：
```json
{
  "name": "calculator-mcp-server",
  "version": "1.0.0",
  "type": "module",
  "bin": {
    "calculator-server": "./dist/index.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0"
  }
}
```

---

### 场景 3：创建 Pi-mono Extension 集成 MCP（进阶）

**目标**：创建一个 Extension 连接到 MCP Server

**最小实现**：

```typescript
import { ExtensionAPI } from "@pi-mono/extension-api";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";

export async function activate(api: ExtensionAPI) {
  // 1. 创建 MCP Client
  const client = new Client(
    {
      name: "pi-mono-extension",
      version: "1.0.0",
    },
    {
      capabilities: {},
    }
  );

  // 2. 连接到 MCP Server
  const transport = new StdioClientTransport({
    command: "calculator-server",
    args: [],
  });
  await client.connect(transport);

  // 3. 获取工具列表
  const { tools } = await client.listTools();

  // 4. 注册工具到 pi-mono
  for (const tool of tools) {
    api.registerTool({
      name: tool.name,
      description: tool.description,
      parameters: tool.inputSchema,
      execute: async (args) => {
        const result = await client.callTool({
          name: tool.name,
          arguments: args,
        });
        return result.content[0].text;
      },
    });
  }
}
```

**关键决策点**：
- ✅ 选择 MCP Client 库（官方 SDK 最稳定）
- ✅ 处理工具参数映射（MCP Schema → Pi-mono Tool）
- ✅ 管理连接生命周期（启动、重连、关闭）

---

### 场景 4：调试 MCP Server（必备技能）

**工具**：MCP Inspector

**使用方法**：

```bash
# 1. 安装 Inspector
npm install -g @modelcontextprotocol/inspector

# 2. 启动 Inspector
npx @modelcontextprotocol/inspector calculator-server

# 3. 在浏览器中打开（自动打开）
# 可以可视化地测试工具调用
```

**调试技巧**：
- ✅ 使用 `console.error()` 输出日志（stdout 用于协议通信）
- ✅ 检查 JSON-RPC 消息格式（Inspector 显示完整消息）
- ✅ 验证工具 Schema（确保 LLM 能理解）

---

### 场景 5：多 Server 协作（实际应用）

**目标**：同时使用 Filesystem 和 Database MCP Server

**配置**：

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/data"]
    },
    "database": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres", "postgresql://..."]
    }
  }
}
```

**使用示例**：

```
用户：从数据库查询用户数据，然后保存到文件

Agent 执行流程：
1. 调用 database.query("SELECT * FROM users")
2. 调用 filesystem.write("/data/users.json", result)
```

**关键决策点**：
- ✅ 避免工具名称冲突（使用命名空间）
- ✅ 管理多个连接的生命周期
- ✅ 处理跨 Server 的数据传递

---

## 三、关键决策树

### 决策 1：我应该使用哪种模式？

```
是否有现成的 MCP Server 满足需求？
├─ 是 → 使用现有 Server（模式 1）
│   └─ 配置 settings.json 即可
└─ 否 → 是否需要深度定制？
    ├─ 是 → 构建自定义 MCP Server（模式 2）
    │   └─ 实现 MCP 协议
    └─ 否 → 创建 Pi-mono Extension（模式 3）
        └─ 包装现有 API 为 MCP 工具
```

### 决策 2：选择哪种传输层？

```
使用场景？
├─ 本地命令行工具 → stdio（最简单）
├─ 浏览器访问 → HTTP + SSE
├─ 远程服务 → HTTP + SSE
└─ 需要双向通信 → 考虑 WebSocket（非标准）
```

### 决策 3：如何设计工具 Schema？

```
工具复杂度？
├─ 简单（1-3 个参数）→ 扁平 Schema
│   {
│     "type": "object",
│     "properties": { "a": { "type": "number" } }
│   }
├─ 中等（4-10 个参数）→ 分组 Schema
│   {
│     "type": "object",
│     "properties": {
│       "query": { "type": "object", "properties": {...} },
│       "options": { "type": "object", "properties": {...} }
│     }
│   }
└─ 复杂（>10 个参数）→ 考虑拆分为多个工具
```

---

## 四、核心 API 速查

### MCP Server 端

```typescript
// 1. 创建 Server
const server = new Server(serverInfo, capabilities);

// 2. 注册处理器
server.setRequestHandler(ListToolsRequestSchema, handler);
server.setRequestHandler(CallToolRequestSchema, handler);
server.setRequestHandler(ListResourcesRequestSchema, handler);
server.setRequestHandler(ReadResourceRequestSchema, handler);

// 3. 发送通知
server.sendNotification({
  method: "notifications/message",
  params: { level: "info", message: "..." }
});

// 4. 连接传输层
await server.connect(transport);
```

### MCP Client 端

```typescript
// 1. 创建 Client
const client = new Client(clientInfo, capabilities);

// 2. 连接到 Server
await client.connect(transport);

// 3. 调用方法
const { tools } = await client.listTools();
const result = await client.callTool({ name, arguments });
const { resources } = await client.listResources();
const content = await client.readResource({ uri });

// 4. 监听通知
client.setNotificationHandler(schema, handler);
```

---

## 五、常见陷阱与解决方案

### 陷阱 1：忘记两步握手

**错误**：直接调用工具，跳过 initialize

**后果**：Server 拒绝请求或行为异常

**解决**：
```typescript
// 正确流程
await client.connect(transport);  // 自动完成 initialize
// 现在可以调用工具
```

### 陷阱 2：stdout 输出日志

**错误**：使用 `console.log()` 输出调试信息

**后果**：破坏 JSON-RPC 协议通信

**解决**：
```typescript
// ❌ 错误
console.log("Debug info");

// ✅ 正确
console.error("Debug info");  // 使用 stderr
```

### 陷阱 3：工具 Schema 不清晰

**错误**：描述模糊，LLM 无法理解何时使用

**后果**：工具很少被调用

**解决**：
```typescript
// ❌ 错误
{
  name: "query",
  description: "Query data"
}

// ✅ 正确
{
  name: "query_users",
  description: "Query user data from the database. Use this when you need to find user information by name, email, or ID."
}
```

### 陷阱 4：忽略错误处理

**错误**：工具执行失败时抛出异常，导致 Server 崩溃

**后果**：整个 MCP Server 不可用

**解决**：
```typescript
// ✅ 正确
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    // 执行工具逻辑
    return { content: [...] };
  } catch (error) {
    // 返回错误而不是抛出
    return {
      content: [
        {
          type: "text",
          text: `Error: ${error.message}`,
        },
      ],
      isError: true,
    };
  }
});
```

### 陷阱 5：资源 URI 不规范

**错误**：使用相对路径或不标准的 URI

**后果**：客户端无法正确解析

**解决**：
```typescript
// ❌ 错误
uri: "file.txt"
uri: "/path/to/file"

// ✅ 正确
uri: "file:///path/to/file.txt"
uri: "mem://cache/data"
uri: "db://users/table"
```

---

## 六、性能优化要点

### 1. 连接池管理

```typescript
// 数据库连接示例
const pool = new Pool({ max: 10 });

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const client = await pool.connect();
  try {
    // 执行查询
  } finally {
    client.release();  // 释放连接
  }
});
```

### 2. 缓存策略

```typescript
// 缓存工具列表（避免重复计算）
let cachedTools: Tool[] | null = null;

server.setRequestHandler(ListToolsRequestSchema, async () => {
  if (!cachedTools) {
    cachedTools = await computeTools();
  }
  return { tools: cachedTools };
});
```

### 3. 流式响应

```typescript
// 对于长时间运行的工具，使用流式响应
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  // 发送进度通知
  server.sendNotification({
    method: "notifications/progress",
    params: { progress: 0.5, message: "Processing..." }
  });

  // 返回最终结果
  return { content: [...] };
});
```

---

## 七、学习路径总结

### 第一周：基础掌握
- ✅ 理解 MCP 核心概念（Tools、Resources、Events）
- ✅ 配置并使用一个现有 MCP Server
- ✅ 使用 MCP Inspector 调试

### 第二周：实践构建
- ✅ 构建一个简单的 MCP Server（2-3 个工具）
- ✅ 实现错误处理和日志
- ✅ 发布到 npm（可选）

### 第三周：进阶集成
- ✅ 创建 Pi-mono Extension 集成 MCP
- ✅ 实现工具包装与转换
- ✅ 处理多 Server 协作

### 第四周：生产优化
- ✅ 性能优化（连接池、缓存）
- ✅ 安全加固（认证、权限）
- ✅ 监控和日志

---

## 八、快速参考卡片

### 核心命令

```bash
# 安装 MCP Server
npm install -g @modelcontextprotocol/server-<name>

# 运行 MCP Inspector
npx @modelcontextprotocol/inspector <server-command>

# 创建新 MCP Server 项目
npm init
npm install @modelcontextprotocol/sdk
```

### 核心文件

```
my-mcp-server/
├── package.json          # 配置 bin 字段
├── src/
│   └── index.ts         # Server 实现
└── tsconfig.json        # TypeScript 配置
```

### 核心配置

```json
// settings.json（Pi-mono）
{
  "mcpServers": {
    "server-name": {
      "command": "command",
      "args": ["arg1", "arg2"]
    }
  }
}
```

---

## 九、下一步行动

根据你的目标选择：

**目标 1：快速使用**
→ 阅读 [07_实战代码_09_发现与配置Servers](./07_实战代码_09_发现与配置Servers.md)

**目标 2：构建 Server**
→ 阅读 [07_实战代码_01_简单MCP_Server](./07_实战代码_01_简单MCP_Server.md)

**目标 3：创建 Extension**
→ 阅读 [07_实战代码_05_基础Extension开发](./07_实战代码_05_基础Extension开发.md)

**目标 4：深入理解**
→ 阅读 [03_核心概念_01_MCP协议基础](./03_核心概念_01_MCP协议基础.md)

---

**记住**：掌握这 20% 的核心知识，你已经可以解决 80% 的 MCP 集成问题了！
