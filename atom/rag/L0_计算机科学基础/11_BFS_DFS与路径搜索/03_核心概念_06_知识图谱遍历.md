# 核心概念 06：知识图谱遍历

## 一句话定义

**知识图谱遍历是在实体-关系图结构中使用 BFS/DFS 策略导航和检索相关信息的技术，是 RAG 系统实现语义检索和多跳推理的核心基础。**

---

## 知识图谱基础

### 核心组成

**知识图谱（Knowledge Graph）** = 实体 + 关系 + 三元组

```python
# 三元组表示
(Einstein, developed, 相对论)
(相对论, predicts, 时空弯曲)
(时空弯曲, affects, GPS技术)

# 图结构
Einstein --[developed]--> 相对论 --[predicts]--> 时空弯曲 --[affects]--> GPS技术
```

---

## 遍历策略

### 1. 实体关系导航（BFS）

```python
from collections import deque
from typing import List, Set, Tuple

class KnowledgeGraph:
    """知识图谱类"""
    def __init__(self):
        self.triples = []  # [(头实体, 关系, 尾实体)]
        self.entity_neighbors = {}  # {实体: [(关系, 邻居实体)]}

    def add_triple(self, head: str, relation: str, tail: str):
        """添加三元组"""
        self.triples.append((head, relation, tail))
        if head not in self.entity_neighbors:
            self.entity_neighbors[head] = []
        self.entity_neighbors[head].append((relation, tail))

    def get_neighbors(self, entity: str) -> List[Tuple[str, str]]:
        """获取实体的邻居"""
        return self.entity_neighbors.get(entity, [])

def bfs_kg_traversal(kg: KnowledgeGraph, start_entity: str, max_hops: int = 2) -> Set[str]:
    """
    BFS 遍历知识图谱

    应用：广度检索相关实体
    """
    visited = {start_entity}
    queue = deque([(start_entity, 0)])
    result = []

    while queue:
        entity, depth = queue.popleft()
        result.append(entity)

        if depth >= max_hops:
            continue

        for relation, neighbor in kg.get_neighbors(entity):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, depth + 1))

    return result
```

**应用场景：** KG2RAG 的邻域扩展

---

### 2. 三元组遍历（关系感知）

```python
def bfs_with_relations(kg: KnowledgeGraph, start: str, target_relations: List[str], max_hops: int = 3):
    """
    关系感知的 BFS 遍历

    只沿着特定类型的关系边探索
    """
    visited = {start}
    queue = deque([(start, 0, [])])  # (实体, 深度, 路径)
    paths = []

    while queue:
        entity, depth, path = queue.popleft()

        if depth >= max_hops:
            if path:
                paths.append(path)
            continue

        for relation, neighbor in kg.get_neighbors(entity):
            if relation in target_relations and neighbor not in visited:
                visited.add(neighbor)
                new_path = path + [(entity, relation, neighbor)]
                queue.append((neighbor, depth + 1, new_path))

    return paths
```

**示例：**
```python
# 只沿着因果关系遍历
causal_relations = ['causes', 'leads_to', 'results_in']
paths = bfs_with_relations(kg, 'Python', causal_relations, max_hops=3)

# 结果：
# [(Python, leads_to, 简洁语法), (简洁语法, causes, 快速开发)]
```

---

### 3. 多跳推理路径（DFS）

```python
def dfs_reasoning_path(kg: KnowledgeGraph, start: str, target: str, max_depth: int = 5) -> List[List[Tuple]]:
    """
    DFS 构建推理路径

    应用：Multi-hop QA
    """
    all_paths = []

    def dfs(entity: str, target: str, depth: int, visited: Set[str], path: List[Tuple]):
        if depth > max_depth:
            return

        if entity == target:
            all_paths.append(path[:])
            return

        visited.add(entity)

        for relation, neighbor in kg.get_neighbors(entity):
            if neighbor not in visited:
                path.append((entity, relation, neighbor))
                dfs(neighbor, target, depth + 1, visited, path)
                path.pop()

        visited.remove(entity)

    dfs(start, target, 0, set(), [])
    return all_paths
```

**示例：**
```python
# 查询："Einstein 的理论如何影响 GPS？"
paths = dfs_reasoning_path(kg, 'Einstein', 'GPS技术', max_depth=5)

# 结果：
# 路径1: Einstein → 相对论 → 时空弯曲 → GPS技术
# 路径2: Einstein → 质能方程 → 核能 → 卫星 → GPS技术
```

---

## 在 RAG 中的应用

### 应用1：KG2RAG 邻域扩展

```python
def kg2rag_expand(kg: KnowledgeGraph, query_entities: List[str], m_hops: int = 2) -> Set[str]:
    """
    KG2RAG 的 BFS 邻域扩展

    来源：KG2RAG (NAACL 2025)
    """
    expanded = set(query_entities)
    queue = deque([(e, 0) for e in query_entities])

    while queue:
        entity, depth = queue.popleft()

        if depth >= m_hops:
            continue

        for _, neighbor in kg.get_neighbors(entity):
            if neighbor not in expanded:
                expanded.add(neighbor)
                queue.append((neighbor, depth + 1))

    return expanded
```

**来源：** https://arxiv.org/abs/2502.06864

---

### 应用2：Cypher 查询（Neo4j）

```python
from neo4j import GraphDatabase

class Neo4jKG:
    """Neo4j 知识图谱"""
    def __init__(self, uri: str, user: str, password: str):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def bfs_query(self, start_entity: str, max_hops: int = 2):
        """
        使用 Cypher 进行 BFS 查询
        """
        query = """
        MATCH path = (start:Entity {name: $start})-[*1..%d]-(neighbor:Entity)
        RETURN DISTINCT neighbor.name AS entity, length(path) AS distance
        ORDER BY distance
        """ % max_hops

        with self.driver.session() as session:
            result = session.run(query, start=start_entity)
            return [(record["entity"], record["distance"]) for record in result]

    def dfs_path_query(self, start: str, end: str, max_depth: int = 5):
        """
        使用 Cypher 查找路径
        """
        query = """
        MATCH path = (start:Entity {name: $start})-[*1..%d]-(end:Entity {name: $end})
        RETURN path
        LIMIT 10
        """ % max_depth

        with self.driver.session() as session:
            result = session.run(query, start=start, end=end)
            return [record["path"] for record in result]
```

---

### 应用3：向量 + 图混合检索

```python
def hybrid_retrieval(kg: KnowledgeGraph, vector_db, query: str, top_k: int = 10):
    """
    混合检索：向量检索 + 图遍历

    步骤：
    1. 向量检索找到初始实体
    2. 图遍历扩展相关实体
    """
    # 步骤1：向量检索
    initial_entities = vector_db.search(query, top_k=5)

    # 步骤2：图遍历扩展
    expanded = set()
    for entity in initial_entities:
        neighbors = bfs_kg_traversal(kg, entity, max_hops=1)
        expanded.update(neighbors)

    # 步骤3：重排序
    ranked = vector_db.rerank(query, list(expanded))
    return ranked[:top_k]
```

**来源：** Deep GraphRAG (2026) - https://arxiv.org/html/2601.11144v3

---

## 优化技术

### 1. 关系类型过滤

```python
def filtered_traversal(kg: KnowledgeGraph, start: str, allowed_relations: Set[str]):
    """只遍历特定类型的关系"""
    visited = {start}
    queue = deque([start])
    result = []

    while queue:
        entity = queue.popleft()
        result.append(entity)

        for relation, neighbor in kg.get_neighbors(entity):
            if relation in allowed_relations and neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return result
```

---

### 2. 实体重要性加权

```python
def weighted_traversal(kg: KnowledgeGraph, start: str, importance_scores: dict):
    """
    基于实体重要性的遍历

    优先访问重要实体
    """
    import heapq

    visited = {start}
    heap = [(-importance_scores.get(start, 0), start)]
    result = []

    while heap:
        _, entity = heapq.heappop(heap)
        result.append(entity)

        for _, neighbor in kg.get_neighbors(entity):
            if neighbor not in visited:
                visited.add(neighbor)
                priority = -importance_scores.get(neighbor, 0)
                heapq.heappush(heap, (priority, neighbor))

    return result
```

---

### 3. 路径评分

```python
def score_path(path: List[Tuple], kg: KnowledgeGraph) -> float:
    """
    评估推理路径质量

    考虑：
    - 路径长度（越短越好）
    - 关系强度（越强越好）
    - 实体重要性（越重要越好）
    """
    if not path:
        return 0.0

    # 长度惩罚
    length_score = 1.0 / len(path)

    # 关系强度
    relation_score = sum(kg.get_relation_strength(h, r, t) for h, r, t in path) / len(path)

    # 实体重要性
    entities = [h for h, _, _ in path] + [path[-1][2]]
    importance_score = sum(kg.get_entity_importance(e) for e in entities) / len(entities)

    return 0.3 * length_score + 0.4 * relation_score + 0.3 * importance_score
```

---

## 实战示例

### 完整示例：知识图谱问答

```python
class KGQASystem:
    """知识图谱问答系统"""
    def __init__(self, kg: KnowledgeGraph):
        self.kg = kg

    def answer_question(self, question: str) -> str:
        """
        回答问题

        步骤：
        1. 提取查询实体
        2. BFS 扩展相关实体
        3. DFS 构建推理路径
        4. 生成答案
        """
        # 步骤1：提取实体
        query_entities = self.extract_entities(question)

        # 步骤2：BFS 扩展
        expanded = set()
        for entity in query_entities:
            neighbors = bfs_kg_traversal(self.kg, entity, max_hops=2)
            expanded.update(neighbors)

        # 步骤3：DFS 构建路径
        paths = []
        for start in query_entities:
            for end in expanded:
                entity_paths = dfs_reasoning_path(self.kg, start, end, max_depth=3)
                paths.extend(entity_paths)

        # 步骤4：选择最佳路径
        if paths:
            best_path = max(paths, key=lambda p: score_path(p, self.kg))
            return self.generate_answer(best_path)

        return "无法找到答案"

    def extract_entities(self, question: str) -> List[str]:
        """提取查询实体（简化版）"""
        # 实际应用中使用 NER 模型
        return ["Einstein", "GPS技术"]

    def generate_answer(self, path: List[Tuple]) -> str:
        """根据路径生成答案"""
        answer = " → ".join([f"{h} {r} {t}" for h, r, t in path])
        return f"推理路径：{answer}"
```

---

## 学习检查

- [ ] 理解知识图谱的三元组表示
- [ ] 掌握 BFS 在知识图谱中的应用（邻域扩展）
- [ ] 掌握 DFS 在知识图谱中的应用（推理路径）
- [ ] 了解 Cypher 查询语言
- [ ] 理解混合检索策略

---

## 下一步

1. `03_核心概念_07_多跳推理路径.md` - 深入多跳推理
2. `07_实战代码_场景2_知识图谱遍历.md` - 实践 Neo4j

---

**版本：** v1.0
**最后更新：** 2026-02-14
**参考文献：**
- KG2RAG (NAACL 2025): https://arxiv.org/abs/2502.06864
- Deep GraphRAG (2026): https://arxiv.org/html/2601.11144v3
