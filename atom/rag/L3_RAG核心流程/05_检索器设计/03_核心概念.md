# 核心概念

掌握三种检索器类型和三个关键参数，覆盖 95% 的 RAG 检索场景。

---

## 核心概念1：向量检索器（Vector Retriever）

**向量检索器通过计算语义相似度，找到与查询"意思相近"的文档。**

### 工作原理

```
用户查询："如何申请休假？"
    ↓
查询向量化：[0.12, 0.45, 0.78, ...]
    ↓
与所有文档向量计算余弦相似度
    ↓
返回相似度最高的 Top-K 文档
```

### 代码示例

```python
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings

# 创建向量存储
embeddings = OpenAIEmbeddings()
vectorstore = Chroma.from_documents(documents, embeddings)

# 创建向量检索器
retriever = vectorstore.as_retriever(
    search_type="similarity",  # 相似度搜索
    search_kwargs={"k": 5}     # 返回 Top-5
)

# 检索
results = retriever.invoke("如何申请休假？")
```

### 优缺点

| 优点 | 缺点 |
|------|------|
| ✅ 理解语义，"年假"能匹配"休假" | ❌ 对专有名词、代码不敏感 |
| ✅ 跨语言能力（中英文互搜） | ❌ 依赖 Embedding 模型质量 |
| ✅ 对拼写错误有容错性 | ❌ 可能忽略精确关键词 |

### 适用场景

- 自然语言问答（"怎么做..."、"什么是..."）
- 语义相似的内容推荐
- 跨语言检索

---

## 核心概念2：关键词检索器（BM25 Retriever）

**关键词检索器通过词频统计，找到包含相同关键词的文档。**

### BM25 算法简介

BM25（Best Matching 25）是经典的信息检索算法：

```
BM25 分数 = 词频(TF) × 逆文档频率(IDF) × 长度归一化

- TF：词在文档中出现的次数（越多越相关）
- IDF：词在所有文档中的稀有程度（越稀有越重要）
- 长度归一化：避免长文档占优势
```

### 直觉理解

```
查询："Python asyncio 教程"

文档A："Python asyncio 是异步编程库..."
- 包含 "Python"：+分
- 包含 "asyncio"：+分（稀有词，加分更多）
- BM25 分数：高

文档B："Python 是一门编程语言..."
- 包含 "Python"：+分
- 不包含 "asyncio"：无分
- BM25 分数：中

文档C："JavaScript 异步编程..."
- 不包含查询词
- BM25 分数：低
```

### 代码示例

```python
from langchain_community.retrievers import BM25Retriever

# 创建 BM25 检索器
bm25_retriever = BM25Retriever.from_documents(
    documents,
    k=5  # 返回 Top-5
)

# 检索
results = bm25_retriever.invoke("Python asyncio 教程")
```

### 优缺点

| 优点 | 缺点 |
|------|------|
| ✅ 精确匹配关键词 | ❌ 不理解语义，"休假"≠"年假" |
| ✅ 对专有名词、代码敏感 | ❌ 对拼写错误零容忍 |
| ✅ 不需要 Embedding，速度快 | ❌ 无法跨语言检索 |
| ✅ 可解释性强 | ❌ 同义词需要手动处理 |

### 适用场景

- 精确搜索（错误码、API 名称、产品型号）
- 代码搜索（函数名、类名）
- 专有名词检索（人名、公司名）

---

## 核心概念3：混合检索器（Hybrid Retriever）

**混合检索器结合向量检索和关键词检索的优势，实现"语义+精确"双重匹配。**

### 工作原理

```
用户查询："Python asyncio 如何处理异常？"
    ↓
┌─────────────────────────────────────────┐
│                                         │
│  向量检索器              关键词检索器     │
│  ┌─────────┐           ┌─────────┐     │
│  │ 语义匹配 │           │ 词频匹配 │     │
│  │ Top-10  │           │ Top-10  │     │
│  └────┬────┘           └────┬────┘     │
│       │                     │          │
│       └──────────┬──────────┘          │
│                  ↓                     │
│            分数融合（RRF）              │
│                  ↓                     │
│            返回 Top-K                  │
│                                         │
└─────────────────────────────────────────┘
```

### 分数融合方法

#### 方法1：倒数排名融合（RRF）

```python
def reciprocal_rank_fusion(results_list, k=60):
    """
    RRF：根据排名计算分数，排名越靠前分数越高

    公式：score = Σ 1/(k + rank)
    """
    fused_scores = {}

    for results in results_list:
        for rank, doc in enumerate(results):
            doc_id = doc.metadata.get("id", doc.page_content[:50])
            if doc_id not in fused_scores:
                fused_scores[doc_id] = {"doc": doc, "score": 0}
            # RRF 公式
            fused_scores[doc_id]["score"] += 1 / (k + rank + 1)

    # 按融合分数排序
    sorted_docs = sorted(
        fused_scores.values(),
        key=lambda x: x["score"],
        reverse=True
    )
    return [item["doc"] for item in sorted_docs]
```

#### 方法2：加权求和

```python
def weighted_fusion(vec_results, bm25_results, alpha=0.5):
    """
    加权融合：alpha * 向量分数 + (1-alpha) * BM25 分数

    alpha=0.7：偏向语义
    alpha=0.3：偏向关键词
    """
    # 归一化分数后加权求和
    ...
```

### 代码示例（LangChain）

```python
from langchain.retrievers import EnsembleRetriever
from langchain_community.retrievers import BM25Retriever
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings

# 创建向量检索器
vectorstore = Chroma.from_documents(documents, OpenAIEmbeddings())
vector_retriever = vectorstore.as_retriever(search_kwargs={"k": 10})

# 创建 BM25 检索器
bm25_retriever = BM25Retriever.from_documents(documents, k=10)

# 创建混合检索器（使用 RRF 融合）
hybrid_retriever = EnsembleRetriever(
    retrievers=[vector_retriever, bm25_retriever],
    weights=[0.5, 0.5]  # 权重相等
)

# 检索
results = hybrid_retriever.invoke("Python asyncio 异常处理")
```

### 优缺点

| 优点 | 缺点 |
|------|------|
| ✅ 兼顾语义和精确匹配 | ❌ 实现复杂度更高 |
| ✅ 覆盖更多相关文档 | ❌ 需要调优权重参数 |
| ✅ 对各种查询类型都有效 | ❌ 计算成本更高 |

### 适用场景

- **生产环境首选**：大多数 RAG 应用
- 查询类型多样的场景
- 对召回率要求高的场景

---

## 核心概念4：Top-K 参数

**Top-K 决定检索器返回多少个结果。**

### 参数影响

```
Top-K 太小（如 K=1）：
- 可能漏掉相关内容
- 答案不完整

Top-K 太大（如 K=50）：
- 引入大量无关内容
- 消耗更多 Token
- 可能干扰 LLM 判断
```

### 如何选择 Top-K？

```
┌─────────────────────────────────────────────────────────────┐
│                    Top-K 选择指南                            │
│                                                             │
│  简单问答（事实性问题）     →  K = 3-5                        │
│  复杂问答（需要多个来源）   →  K = 5-10                       │
│  总结/报告生成            →  K = 10-20                       │
│  代码生成                 →  K = 3-5（精确优先）              │
│                                                             │
│  经验法则：从 K=5 开始，根据效果调整                          │
└─────────────────────────────────────────────────────────────┘
```

### 代码示例

```python
# 设置 Top-K
retriever = vectorstore.as_retriever(
    search_kwargs={"k": 5}  # 返回 5 个结果
)

# 动态调整 Top-K
def adaptive_retrieval(query, vectorstore):
    """根据查询复杂度动态调整 K"""
    # 简单问题：K 小
    if len(query) < 20:
        k = 3
    # 复杂问题：K 大
    else:
        k = 10

    retriever = vectorstore.as_retriever(search_kwargs={"k": k})
    return retriever.invoke(query)
```

---

## 核心概念5：相似度阈值（Score Threshold）

**相似度阈值过滤掉相关性不够的结果，保证返回内容的质量。**

### 为什么需要阈值？

```
场景：用户问"公司的量子计算研究进展"

但知识库里根本没有量子计算相关内容！

没有阈值：
- 返回 Top-5，但都是不相关的内容
- LLM 可能"编造"答案

有阈值（如 0.7）：
- 所有结果相似度都 < 0.7
- 返回空结果
- LLM 回答"抱歉，没有找到相关信息"
```

### 代码示例

```python
# 方法1：使用 similarity_score_threshold
retriever = vectorstore.as_retriever(
    search_type="similarity_score_threshold",
    search_kwargs={
        "score_threshold": 0.7,  # 只返回相似度 > 0.7 的结果
        "k": 10  # 最多返回 10 个
    }
)

# 方法2：手动过滤
def retrieve_with_threshold(query, vectorstore, threshold=0.7, k=10):
    """手动实现阈值过滤"""
    # 获取带分数的结果
    results_with_scores = vectorstore.similarity_search_with_score(
        query, k=k
    )

    # 过滤低于阈值的结果
    filtered = [
        (doc, score) for doc, score in results_with_scores
        if score >= threshold
    ]

    return [doc for doc, score in filtered]
```

### 阈值选择建议

| 阈值范围 | 含义 | 适用场景 |
|----------|------|----------|
| 0.8-0.9 | 严格匹配 | 精确问答、法律/医疗 |
| 0.6-0.8 | 中等匹配 | 一般问答（推荐） |
| 0.4-0.6 | 宽松匹配 | 探索性搜索 |

---

## 核心概念6：MMR（最大边际相关性）

**MMR 在保证相关性的同时，增加结果的多样性，避免返回重复内容。**

### 问题场景

```
查询："Python 异步编程"

普通检索返回：
1. "Python asyncio 基础教程"（相似度 0.95）
2. "Python asyncio 入门指南"（相似度 0.93）← 内容重复！
3. "Python asyncio 快速上手"（相似度 0.91）← 内容重复！
4. "Python asyncio 教程"（相似度 0.90）← 内容重复！
5. "Python 多线程编程"（相似度 0.75）

问题：前4个内容高度重复，浪费了上下文空间
```

### MMR 原理

```
MMR 公式：
score = λ × 相关性(query, doc) - (1-λ) × max(相似性(doc, selected_docs))

- λ 接近 1：偏向相关性
- λ 接近 0：偏向多样性
- 推荐值：λ = 0.5
```

```
MMR 检索返回：
1. "Python asyncio 基础教程"（相似度 0.95）
2. "Python 多线程编程"（相似度 0.75）← 不同角度！
3. "Python 协程原理"（相似度 0.72）← 不同角度！
4. "asyncio vs threading 对比"（相似度 0.70）← 不同角度！
5. "Python 并发最佳实践"（相似度 0.68）← 不同角度！

结果：覆盖了异步编程的多个方面
```

### 代码示例

```python
# 使用 MMR 检索
retriever = vectorstore.as_retriever(
    search_type="mmr",  # 使用 MMR
    search_kwargs={
        "k": 5,              # 返回 5 个结果
        "fetch_k": 20,       # 先获取 20 个候选
        "lambda_mult": 0.5   # 多样性参数（0-1）
    }
)

results = retriever.invoke("Python 异步编程")
```

### 参数说明

| 参数 | 含义 | 推荐值 |
|------|------|--------|
| `k` | 最终返回数量 | 5-10 |
| `fetch_k` | 候选池大小 | k 的 2-4 倍 |
| `lambda_mult` | 多样性权重（0=最多样，1=最相关） | 0.5 |

---

## 六个概念的关系

```
┌─────────────────────────────────────────────────────────────┐
│                    检索器设计全景图                           │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  检索器类型选择                        │   │
│  │                                                       │   │
│  │   向量检索器 ←──→ 混合检索器 ←──→ 关键词检索器         │   │
│  │   (语义匹配)      (最佳实践)      (精确匹配)           │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  结果控制参数                          │   │
│  │                                                       │   │
│  │   Top-K        相似度阈值         MMR                 │   │
│  │   (数量控制)    (质量控制)        (多样性控制)         │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│                    返回 Top-K 文档                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 概念速查表

| 概念 | 核心作用 | 关键参数 | 推荐值 |
|------|----------|----------|--------|
| 向量检索器 | 语义匹配 | - | - |
| 关键词检索器 | 精确匹配 | - | - |
| 混合检索器 | 两者结合 | weights | [0.5, 0.5] |
| Top-K | 返回数量 | k | 5-10 |
| 相似度阈值 | 质量过滤 | score_threshold | 0.6-0.8 |
| MMR | 多样性 | lambda_mult | 0.5 |

---

**下一步：** [04_最小可用](./04_最小可用.md) - 掌握 20% 核心知识解决 80% 问题
