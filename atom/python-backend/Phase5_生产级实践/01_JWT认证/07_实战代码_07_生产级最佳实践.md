# JWT认证 - 实战代码07：生产级最佳实践

## 概述

本章介绍JWT认证在生产环境中的安全最佳实践、错误处理、日志记录和性能优化。

---

## 安全最佳实践

### 1. Token存储策略

```python
"""
安全的Token存储
演示：使用HttpOnly Cookie存储Token
"""

from fastapi import FastAPI, Response
from fastapi.responses import JSONResponse

app = FastAPI()


@app.post("/login")
async def login(username: str, password: str, response: Response):
    """登录：将Token存储在HttpOnly Cookie中"""
    # 验证密码...

    # 生成Token
    access_token = create_access_token(user_id=123)
    refresh_token = create_refresh_token(user_id=123)

    # ✅ 存储在HttpOnly Cookie中
    response.set_cookie(
        key="access_token",
        value=access_token,
        httponly=True,      # JavaScript无法访问
        secure=True,        # 只在HTTPS下传输
        samesite="lax",     # 防止CSRF攻击
        max_age=900,        # 15分钟
        path="/"
    )

    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        secure=True,
        samesite="lax",
        max_age=604800,     # 7天
        path="/refresh"     # 只在刷新端点可用
    )

    return {"message": "登录成功"}


# 从Cookie中读取Token
from fastapi import Cookie, HTTPException

async def get_current_user(access_token: str = Cookie(None)) -> dict:
    """从Cookie中获取Token"""
    if not access_token:
        raise HTTPException(401, "未登录")

    try:
        payload = jwt.decode(access_token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        raise HTTPException(401, "无效的Token")
```

### 2. CSRF防护

```python
"""
CSRF防护
演示：使用CSRF Token防止跨站请求伪造
"""

from fastapi import FastAPI, Depends, HTTPException, Header
from secrets import token_urlsafe

app = FastAPI()

# CSRF Token存储（生产环境使用Redis）
csrf_tokens = {}


@app.post("/login")
async def login(username: str, password: str, response: Response):
    """登录：生成CSRF Token"""
    # 验证密码...

    # 生成JWT
    access_token = create_access_token(user_id=123)

    # 生成CSRF Token
    csrf_token = token_urlsafe(32)
    csrf_tokens[access_token] = csrf_token

    # 存储JWT在HttpOnly Cookie
    response.set_cookie(
        key="access_token",
        value=access_token,
        httponly=True,
        secure=True,
        samesite="lax"
    )

    # 返回CSRF Token（前端存储在localStorage）
    return {
        "message": "登录成功",
        "csrf_token": csrf_token
    }


async def verify_csrf(
    access_token: str = Cookie(),
    x_csrf_token: str = Header()
) -> None:
    """验证CSRF Token"""
    expected_csrf = csrf_tokens.get(access_token)

    if not expected_csrf or expected_csrf != x_csrf_token:
        raise HTTPException(403, "CSRF验证失败")


@app.post("/agent/chat")
async def chat(
    message: str,
    current_user: dict = Depends(get_current_user),
    _: None = Depends(verify_csrf)  # CSRF验证
):
    """受保护的端点（需要CSRF验证）"""
    return {"response": f"AI回复: {message}"}
```

### 3. 密钥管理

```python
"""
安全的密钥管理
演示：从环境变量和密钥管理服务读取密钥
"""

import os
from typing import Optional


class SecretManager:
    """密钥管理器"""

    def __init__(self):
        self._secret_key: Optional[str] = None
        self._refresh_secret_key: Optional[str] = None

    def get_secret_key(self) -> str:
        """获取JWT密钥"""
        if not self._secret_key:
            # 1. 从环境变量读取
            self._secret_key = os.getenv("SECRET_KEY")

            # 2. 如果环境变量不存在，从密钥管理服务读取
            if not self._secret_key:
                self._secret_key = self._load_from_kms("jwt-secret-key")

            # 3. 验证密钥
            if not self._secret_key:
                raise ValueError("SECRET_KEY未设置")

            if len(self._secret_key) < 32:
                raise ValueError("SECRET_KEY长度至少32字符")

        return self._secret_key

    def get_refresh_secret_key(self) -> str:
        """获取Refresh Token密钥"""
        if not self._refresh_secret_key:
            self._refresh_secret_key = os.getenv("REFRESH_SECRET_KEY")

            if not self._refresh_secret_key:
                self._refresh_secret_key = self._load_from_kms("jwt-refresh-secret-key")

            if not self._refresh_secret_key:
                raise ValueError("REFRESH_SECRET_KEY未设置")

        return self._refresh_secret_key

    def _load_from_kms(self, key_name: str) -> Optional[str]:
        """从密钥管理服务加载密钥"""
        # 示例：从AWS KMS加载
        try:
            import boto3

            client = boto3.client('secretsmanager')
            response = client.get_secret_value(SecretId=key_name)

            return response['SecretString']

        except Exception as e:
            print(f"从KMS加载密钥失败: {e}")
            return None


# 使用示例
secret_manager = SecretManager()
SECRET_KEY = secret_manager.get_secret_key()
REFRESH_SECRET_KEY = secret_manager.get_refresh_secret_key()
```

### 4. 密钥轮换

```python
"""
密钥轮换
演示：支持多个密钥，逐步淘汰旧密钥
"""

from typing import List, Tuple
from datetime import datetime


class KeyRotationManager:
    """密钥轮换管理器"""

    def __init__(self):
        # 密钥列表：[(key_id, key, created_at), ...]
        self.keys: List[Tuple[str, str, datetime]] = []

    def add_key(self, key_id: str, key: str):
        """添加新密钥"""
        self.keys.append((key_id, key, datetime.utcnow()))
        print(f"添加新密钥: {key_id}")

    def get_current_key(self) -> Tuple[str, str]:
        """获取当前密钥（最新的）"""
        if not self.keys:
            raise ValueError("没有可用的密钥")

        key_id, key, _ = self.keys[-1]
        return key_id, key

    def sign(self, payload: dict) -> str:
        """使用当前密钥签名"""
        key_id, key = self.get_current_key()

        # 在Payload中包含key_id
        payload['kid'] = key_id

        # 生成JWT
        token = jwt.encode(payload, key, algorithm="HS256")

        return token

    def verify(self, token: str) -> dict:
        """使用任何有效密钥验证"""
        # 先解码Header获取key_id（不验证签名）
        unverified_payload = jwt.decode(
            token,
            options={"verify_signature": False}
        )

        key_id = unverified_payload.get('kid')

        # 查找对应的密钥
        for kid, key, _ in self.keys:
            if kid == key_id:
                # 使用对应密钥验证
                try:
                    payload = jwt.decode(token, key, algorithms=["HS256"])
                    return payload
                except JWTError:
                    raise HTTPException(401, "签名验证失败")

        raise HTTPException(401, f"未知的密钥ID: {key_id}")

    def remove_old_keys(self, keep_count: int = 2):
        """删除旧密钥（保留最新的N个）"""
        if len(self.keys) > keep_count:
            removed = self.keys[:-keep_count]
            self.keys = self.keys[-keep_count:]

            for key_id, _, _ in removed:
                print(f"删除旧密钥: {key_id}")


# 使用示例
key_manager = KeyRotationManager()

# 1. 初始密钥
key_manager.add_key("key-2024-01", "old-secret-key")

# 2. 生成Token（使用旧密钥）
token_old = key_manager.sign({"user_id": 123})

# 3. 轮换密钥
key_manager.add_key("key-2024-02", "new-secret-key")

# 4. 新Token使用新密钥
token_new = key_manager.sign({"user_id": 456})

# 5. 旧Token仍然可以验证
payload_old = key_manager.verify(token_old)
print(f"旧Token验证成功: {payload_old}")

# 6. 新Token也可以验证
payload_new = key_manager.verify(token_new)
print(f"新Token验证成功: {payload_new}")

# 7. 等待所有旧Token过期后，删除旧密钥
# key_manager.remove_old_keys(keep_count=1)
```

---

## 错误处理

### 统一错误响应

```python
"""
统一错误处理
演示：标准化的错误响应格式
"""

from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from jose import JWTError, ExpiredSignatureError
from pydantic import BaseModel


class ErrorResponse(BaseModel):
    """错误响应模型"""
    error: str
    message: str
    details: Optional[dict] = None


app = FastAPI()


# JWT错误处理
@app.exception_handler(ExpiredSignatureError)
async def expired_token_handler(request: Request, exc: ExpiredSignatureError):
    """Token过期错误"""
    return JSONResponse(
        status_code=status.HTTP_401_UNAUTHORIZED,
        content={
            "error": "token_expired",
            "message": "Token已过期，请刷新或重新登录",
            "details": {"expired_at": "..."}
        },
        headers={"WWW-Authenticate": "Bearer"}
    )


@app.exception_handler(JWTError)
async def jwt_error_handler(request: Request, exc: JWTError):
    """JWT错误"""
    return JSONResponse(
        status_code=status.HTTP_401_UNAUTHORIZED,
        content={
            "error": "invalid_token",
            "message": "无效的Token",
            "details": {"reason": str(exc)}
        },
        headers={"WWW-Authenticate": "Bearer"}
    )


# 验证错误处理
@app.exception_handler(RequestValidationError)
async def validation_error_handler(request: Request, exc: RequestValidationError):
    """请求验证错误"""
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": "validation_error",
            "message": "请求参数验证失败",
            "details": {"errors": exc.errors()}
        }
    )


# 通用错误处理
@app.exception_handler(Exception)
async def general_error_handler(request: Request, exc: Exception):
    """通用错误处理"""
    # 记录错误日志
    logger.error(f"未处理的错误: {exc}", exc_info=True)

    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": "internal_server_error",
            "message": "服务器内部错误",
            "details": None  # 生产环境不暴露详细错误
        }
    )
```

---

## 日志记录

### 结构化日志

```python
"""
结构化日志
演示：记录认证相关的安全事件
"""

import structlog
from datetime import datetime


# 配置structlog
structlog.configure(
    processors=[
        structlog.stdlib.add_log_level,
        structlog.stdlib.add_logger_name,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)

logger = structlog.get_logger()


class AuthLogger:
    """认证日志记录器"""

    @staticmethod
    def log_login_success(user_id: int, username: str, ip: str):
        """记录登录成功"""
        logger.info(
            "login_success",
            user_id=user_id,
            username=username,
            ip_address=ip,
            timestamp=datetime.utcnow().isoformat()
        )

    @staticmethod
    def log_login_failure(email: str, ip: str, reason: str):
        """记录登录失败"""
        logger.warning(
            "login_failure",
            email=email,
            ip_address=ip,
            reason=reason,
            timestamp=datetime.utcnow().isoformat()
        )

    @staticmethod
    def log_token_refresh(user_id: int, ip: str):
        """记录Token刷新"""
        logger.info(
            "token_refresh",
            user_id=user_id,
            ip_address=ip,
            timestamp=datetime.utcnow().isoformat()
        )

    @staticmethod
    def log_token_expired(user_id: int, ip: str):
        """记录Token过期"""
        logger.info(
            "token_expired",
            user_id=user_id,
            ip_address=ip,
            timestamp=datetime.utcnow().isoformat()
        )

    @staticmethod
    def log_invalid_token(ip: str, token_prefix: str):
        """记录无效Token"""
        logger.warning(
            "invalid_token",
            ip_address=ip,
            token_prefix=token_prefix,
            timestamp=datetime.utcnow().isoformat()
        )

    @staticmethod
    def log_logout(user_id: int, ip: str):
        """记录登出"""
        logger.info(
            "logout",
            user_id=user_id,
            ip_address=ip,
            timestamp=datetime.utcnow().isoformat()
        )


# 在端点中使用
@app.post("/login")
async def login(
    request: LoginRequest,
    client_ip: str = Depends(get_client_ip)
):
    """登录端点（带日志）"""
    user = db.query(User).filter(User.email == request.email).first()

    if not user:
        AuthLogger.log_login_failure(request.email, client_ip, "user_not_found")
        raise HTTPException(401, "邮箱或密码错误")

    if not verify_password(request.password, user.hashed_password):
        AuthLogger.log_login_failure(request.email, client_ip, "wrong_password")
        raise HTTPException(401, "邮箱或密码错误")

    # 生成Token
    access_token = create_access_token(user.id)

    # 记录成功
    AuthLogger.log_login_success(user.id, user.username, client_ip)

    return {"access_token": access_token}
```

---

## 限流保护

### 防止暴力破解

```python
"""
限流保护
演示：防止登录端点被暴力破解
"""

from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

# 创建限流器
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)


@app.post("/login")
@limiter.limit("5/minute")  # 每分钟最多5次登录尝试
async def login(
    request: Request,
    login_request: LoginRequest
):
    """登录端点（带限流）"""
    # 登录逻辑...
    pass


@app.post("/register")
@limiter.limit("3/hour")  # 每小时最多3次注册
async def register(request: Request, register_request: RegisterRequest):
    """注册端点（带限流）"""
    # 注册逻辑...
    pass


# 基于用户的限流
from fastapi import Depends

@app.post("/agent/chat")
@limiter.limit("100/hour")  # 每小时最多100次对话
async def chat(
    request: Request,
    message: str,
    current_user: User = Depends(get_current_user)
):
    """AI Agent对话（带限流）"""
    # 对话逻辑...
    pass
```

---

## 性能优化

### 1. Token缓存

```python
"""
Token缓存
演示：缓存已验证的Token，减少重复验证
"""

from functools import lru_cache
from redis import Redis

redis_client = Redis(host='localhost', port=6379, db=0, decode_responses=True)


class TokenCache:
    """Token缓存"""

    @staticmethod
    def get_cached_payload(token: str) -> Optional[dict]:
        """从缓存获取Payload"""
        cached = redis_client.get(f"token:{token}")

        if cached:
            return json.loads(cached)

        return None

    @staticmethod
    def cache_payload(token: str, payload: dict, ttl: int = 300):
        """缓存Payload（5分钟）"""
        redis_client.setex(
            f"token:{token}",
            ttl,
            json.dumps(payload)
        )

    @staticmethod
    def invalidate(token: str):
        """使缓存失效"""
        redis_client.delete(f"token:{token}")


async def get_current_user_cached(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """获取当前用户（带缓存）"""
    token = credentials.credentials

    # 1. 尝试从缓存获取
    cached_payload = TokenCache.get_cached_payload(token)
    if cached_payload:
        return cached_payload

    # 2. 缓存未命中，验证Token
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])

        # 3. 缓存Payload
        TokenCache.cache_payload(token, payload)

        return payload

    except JWTError:
        raise HTTPException(401, "无效的Token")
```

### 2. 数据库查询优化

```python
"""
数据库查询优化
演示：减少不必要的数据库查询
"""

# ❌ 不好：每次请求都查询数据库
async def get_current_user_slow(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """慢速版本：每次都查数据库"""
    payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
    user_id = payload["user_id"]

    # 每次请求都查询数据库
    user = db.query(User).filter(User.id == user_id).first()

    return user


# ✅ 好：只在必要时查询数据库
async def get_current_user_fast(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """快速版本：只返回Payload"""
    payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])

    # 不查询数据库，直接返回Payload
    return payload


# 只在需要完整用户信息时才查询
async def get_full_user(
    current_user: dict = Depends(get_current_user_fast),
    db: Session = Depends(get_db)
) -> User:
    """获取完整用户信息（按需查询）"""
    user_id = current_user["user_id"]
    user = db.query(User).filter(User.id == user_id).first()

    if not user:
        raise HTTPException(404, "用户不存在")

    return user


# 使用示例
@app.get("/profile")
async def get_profile(current_user: dict = Depends(get_current_user_fast)):
    """只需要user_id，不查数据库"""
    return {"user_id": current_user["user_id"]}


@app.get("/profile/full")
async def get_full_profile(user: User = Depends(get_full_user)):
    """需要完整信息，查询数据库"""
    return {
        "id": user.id,
        "email": user.email,
        "username": user.username,
        "created_at": user.created_at
    }
```

---

## 监控和告警

### 监控指标

```python
"""
监控指标
演示：收集认证相关的指标
"""

from prometheus_client import Counter, Histogram, Gauge

# 定义指标
login_attempts = Counter(
    'auth_login_attempts_total',
    'Total login attempts',
    ['status']  # success, failure
)

login_duration = Histogram(
    'auth_login_duration_seconds',
    'Login duration in seconds'
)

active_tokens = Gauge(
    'auth_active_tokens',
    'Number of active tokens'
)

token_refresh_total = Counter(
    'auth_token_refresh_total',
    'Total token refreshes'
)


@app.post("/login")
async def login(request: LoginRequest):
    """登录端点（带监控）"""
    with login_duration.time():
        try:
            # 登录逻辑...
            user = authenticate(request.email, request.password)

            # 生成Token
            token = create_access_token(user.id)

            # 记录成功
            login_attempts.labels(status='success').inc()
            active_tokens.inc()

            return {"access_token": token}

        except HTTPException:
            # 记录失败
            login_attempts.labels(status='failure').inc()
            raise


@app.post("/refresh")
async def refresh_token(request: RefreshRequest):
    """刷新端点（带监控）"""
    # 刷新逻辑...

    # 记录刷新
    token_refresh_total.inc()

    return {"access_token": new_token}
```

---

## 完整的生产级配置

### 配置类

```python
"""
生产级配置
演示：完整的配置管理
"""

from pydantic import BaseSettings, validator
from typing import Optional


class Settings(BaseSettings):
    """应用配置"""

    # JWT配置
    SECRET_KEY: str
    REFRESH_SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7

    # 数据库配置
    DATABASE_URL: str

    # Redis配置
    REDIS_URL: str = "redis://localhost:6379/0"

    # 安全配置
    COOKIE_SECURE: bool = True
    COOKIE_SAMESITE: str = "lax"
    CORS_ORIGINS: list = ["https://app.example.com"]

    # 限流配置
    RATE_LIMIT_LOGIN: str = "5/minute"
    RATE_LIMIT_REGISTER: str = "3/hour"
    RATE_LIMIT_API: str = "100/hour"

    # 日志配置
    LOG_LEVEL: str = "INFO"
    LOG_FORMAT: str = "json"

    @validator('SECRET_KEY', 'REFRESH_SECRET_KEY')
    def validate_secret_key(cls, v):
        """验证密钥长度"""
        if len(v) < 32:
            raise ValueError('密钥长度至少32字符')
        return v

    class Config:
        env_file = ".env"
        case_sensitive = True


# 加载配置
settings = Settings()
```

---

## 总结

**本章介绍了：**
1. 安全最佳实践（HttpOnly Cookie、CSRF防护、密钥管理、密钥轮换）
2. 错误处理（统一错误响应）
3. 日志记录（结构化日志）
4. 限流保护（防止暴力破解）
5. 性能优化（Token缓存、数据库查询优化）
6. 监控和告警（Prometheus指标）
7. 生产级配置

**关键点：**
- Token存储在HttpOnly Cookie
- 使用CSRF Token防护
- 密钥从环境变量或KMS读取
- 支持密钥轮换
- 结构化日志记录安全事件
- 限流防止暴力破解
- Token缓存提升性能
- 监控关键指标

**下一步：**
- 学习完整AI Agent API实现
