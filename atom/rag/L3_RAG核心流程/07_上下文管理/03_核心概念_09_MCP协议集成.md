# 核心概念9：MCP协议集成

> **2026年上下文管理的标准化接口**

---

## 什么是MCP？

**Model Context Protocol (MCP)** 是Anthropic在2024年底推出的开放标准，用于标准化AI应用与外部数据源、工具的集成方式。

**官方定义**：
> MCP是一个开放协议，使AI应用能够安全、可控地访问外部数据和工具。

---

## MCP核心架构

### 三大组件

```
MCP Server
├── Resources（资源）
│   ├── 文档
│   ├── 数据库
│   └── API
├── Tools（工具）
│   ├── 搜索
│   ├── 计算
│   └── 操作
└── Prompts（提示）
    ├── 模板
    ├── 示例
    └── 指令
```

### 工作流程

```
AI Application (Client)
  ↓ MCP Protocol
MCP Server
  ↓ 数据访问
External Data Sources
```

---

## MCP vs RAG对比

### 核心区别

| 维度 | 传统RAG | MCP + RAG |
|------|---------|-----------|
| **数据访问** | 临时方案 | 标准化协议 |
| **工具集成** | 自定义 | 统一接口 |
| **安全控制** | 应用层 | 协议层 |
| **可扩展性** | 低 | 高 |
| **互操作性** | 差 | 好 |

### 协同关系

```
MCP不是替代RAG，而是增强RAG：

传统RAG：
Query → Vector Store → LLM → Answer

MCP + RAG：
Query → MCP Server → [Vector Store + Tools + Resources] → LLM → Answer
```

---

## MCP资源管理

### 资源定义

```python
from mcp import Resource

# 定义文档资源
doc_resource = Resource(
    uri="docs://company/policies",
    name="Company Policies",
    description="Internal company policies and guidelines",
    mimeType="text/plain"
)

# 定义数据库资源
db_resource = Resource(
    uri="db://users/profile",
    name="User Profile",
    description="Current user profile information",
    mimeType="application/json"
)
```

### 资源服务器

```python
from mcp import MCPServer

class DocumentMCPServer:
    """文档MCP服务器"""
    def __init__(self):
        self.server = MCPServer(name="document-server")
        self.register_resources()

    def register_resources(self):
        """注册资源"""
        # 注册公司文档
        self.server.add_resource(
            Resource(
                uri="docs://company/handbook",
                name="Employee Handbook",
                description="Company employee handbook",
                mimeType="text/plain"
            ),
            fetch_func=self.fetch_handbook
        )

        # 注册技术文档
        self.server.add_resource(
            Resource(
                uri="docs://tech/api",
                name="API Documentation",
                description="Internal API documentation",
                mimeType="text/markdown"
            ),
            fetch_func=self.fetch_api_docs
        )

    def fetch_handbook(self) -> str:
        """获取员工手册"""
        # 实际实现中从数据库或文件系统读取
        return load_document("handbook.pdf")

    def fetch_api_docs(self) -> str:
        """获取API文档"""
        return load_document("api_docs.md")

    def start(self, port: int = 8080):
        """启动服务器"""
        self.server.run(port=port)
```

---

## MCP工具集成

### 工具定义

```python
from mcp import Tool

# 定义搜索工具
search_tool = Tool(
    name="search_documents",
    description="Search internal documents by query",
    inputSchema={
        "type": "object",
        "properties": {
            "query": {
                "type": "string",
                "description": "Search query"
            },
            "limit": {
                "type": "integer",
                "description": "Maximum number of results",
                "default": 10
            }
        },
        "required": ["query"]
    }
)
```

### 工具服务器

```python
class ToolMCPServer:
    """工具MCP服务器"""
    def __init__(self):
        self.server = MCPServer(name="tool-server")
        self.register_tools()

    def register_tools(self):
        """注册工具"""
        # 搜索工具
        self.server.add_tool(
            Tool(
                name="search_documents",
                description="Search internal documents",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "query": {"type": "string"},
                        "limit": {"type": "integer", "default": 10}
                    },
                    "required": ["query"]
                }
            ),
            execute_func=self.search_documents
        )

        # 计算工具
        self.server.add_tool(
            Tool(
                name="calculate",
                description="Perform mathematical calculations",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "expression": {"type": "string"}
                    },
                    "required": ["expression"]
                }
            ),
            execute_func=self.calculate
        )

    def search_documents(self, query: str, limit: int = 10) -> list[dict]:
        """搜索文档"""
        # 实际实现中调用向量存储
        results = vector_store.similarity_search(query, k=limit)
        return [
            {
                "content": doc.page_content,
                "metadata": doc.metadata,
                "score": doc.score
            }
            for doc in results
        ]

    def calculate(self, expression: str) -> dict:
        """计算"""
        try:
            result = eval(expression)  # 生产环境需要安全评估
            return {"result": result, "error": None}
        except Exception as e:
            return {"result": None, "error": str(e)}
```

---

## MCP客户端集成

### 基础客户端

```python
from mcp import MCPClient

class RAGWithMCP:
    """集成MCP的RAG系统"""
    def __init__(self):
        # 连接MCP服务器
        self.mcp_client = MCPClient()
        self.mcp_client.connect("http://localhost:8080")

        # 传统RAG组件
        self.vector_store = ChromaDB()
        self.llm = OpenAI()

    def query(self, question: str) -> str:
        """查询流程"""
        # 1. 列出可用资源
        resources = self.mcp_client.list_resources()

        # 2. 获取相关资源
        relevant_resources = self._select_relevant_resources(
            question,
            resources
        )

        # 3. 获取资源内容
        resource_contents = []
        for resource in relevant_resources:
            content = self.mcp_client.read_resource(resource["uri"])
            resource_contents.append(content)

        # 4. 传统向量检索
        vector_results = self.vector_store.similarity_search(question, k=5)

        # 5. 合并上下文
        context = self._merge_context(resource_contents, vector_results)

        # 6. 生成答案
        prompt = f"""基于以下上下文回答问题。

上下文：
{context}

问题：{question}

答案："""

        answer = self.llm.generate(prompt)
        return answer

    def _select_relevant_resources(
        self,
        question: str,
        resources: list[dict]
    ) -> list[dict]:
        """选择相关资源"""
        # 简化实现：基于描述匹配
        relevant = []
        for resource in resources:
            if any(keyword in question.lower()
                   for keyword in resource["description"].lower().split()):
                relevant.append(resource)
        return relevant

    def _merge_context(
        self,
        resource_contents: list[str],
        vector_results: list
    ) -> str:
        """合并上下文"""
        parts = []

        # MCP资源
        if resource_contents:
            parts.append("=== MCP资源 ===")
            parts.extend(resource_contents)

        # 向量检索结果
        if vector_results:
            parts.append("\n=== 向量检索结果 ===")
            parts.extend([doc.page_content for doc in vector_results])

        return "\n\n".join(parts)
```

### 工具调用

```python
class RAGWithMCPTools:
    """集成MCP工具的RAG系统"""
    def __init__(self):
        self.mcp_client = MCPClient()
        self.mcp_client.connect("http://localhost:8080")
        self.llm = OpenAI()

    def query_with_tools(self, question: str) -> str:
        """带工具调用的查询"""
        # 1. 列出可用工具
        tools = self.mcp_client.list_tools()

        # 2. 让LLM决定使用哪些工具
        tool_selection_prompt = f"""问题：{question}

可用工具：
{self._format_tools(tools)}

请选择需要使用的工具及参数（JSON格式）："""

        tool_calls = self.llm.generate(tool_selection_prompt)
        tool_calls = json.loads(tool_calls)

        # 3. 执行工具
        tool_results = []
        for call in tool_calls:
            result = self.mcp_client.call_tool(
                call["name"],
                call["arguments"]
            )
            tool_results.append({
                "tool": call["name"],
                "result": result
            })

        # 4. 基于工具结果生成答案
        final_prompt = f"""问题：{question}

工具执行结果：
{json.dumps(tool_results, indent=2, ensure_ascii=False)}

请基于工具结果回答问题："""

        answer = self.llm.generate(final_prompt)
        return answer

    def _format_tools(self, tools: list[dict]) -> str:
        """格式化工具列表"""
        formatted = []
        for tool in tools:
            formatted.append(f"- {tool['name']}: {tool['description']}")
        return "\n".join(formatted)
```

---

## MCP安全控制

### 权限管理

```python
from mcp import Permission, PermissionManager

class SecureMCPServer:
    """安全的MCP服务器"""
    def __init__(self):
        self.server = MCPServer(name="secure-server")
        self.permission_manager = PermissionManager()
        self.setup_permissions()

    def setup_permissions(self):
        """设置权限"""
        # 定义权限
        read_docs = Permission(
            name="read_documents",
            description="Read company documents",
            scope=["docs://company/*"]
        )

        write_docs = Permission(
            name="write_documents",
            description="Write company documents",
            scope=["docs://company/*"]
        )

        # 分配权限给角色
        self.permission_manager.assign_permission(
            role="employee",
            permission=read_docs
        )

        self.permission_manager.assign_permission(
            role="admin",
            permission=read_docs
        )

        self.permission_manager.assign_permission(
            role="admin",
            permission=write_docs
        )

    def check_permission(self, user_role: str, resource_uri: str, action: str) -> bool:
        """检查权限"""
        return self.permission_manager.check(
            role=user_role,
            resource=resource_uri,
            action=action
        )
```

### 审计日志

```python
class AuditedMCPServer:
    """带审计的MCP服务器"""
    def __init__(self):
        self.server = MCPServer(name="audited-server")
        self.audit_log = []

    def log_access(
        self,
        user: str,
        resource: str,
        action: str,
        result: str
    ):
        """记录访问日志"""
        self.audit_log.append({
            "timestamp": datetime.now().isoformat(),
            "user": user,
            "resource": resource,
            "action": action,
            "result": result
        })

    def get_audit_log(
        self,
        start_time: datetime = None,
        end_time: datetime = None
    ) -> list[dict]:
        """获取审计日志"""
        logs = self.audit_log

        if start_time:
            logs = [log for log in logs
                    if datetime.fromisoformat(log["timestamp"]) >= start_time]

        if end_time:
            logs = [log for log in logs
                    if datetime.fromisoformat(log["timestamp"]) <= end_time]

        return logs
```

---

## 2026年最佳实践

### 实践1：多MCP服务器架构

```python
class MultiMCPRAG:
    """多MCP服务器RAG系统"""
    def __init__(self):
        self.mcp_clients = {
            "documents": MCPClient("http://docs-server:8080"),
            "database": MCPClient("http://db-server:8081"),
            "tools": MCPClient("http://tools-server:8082")
        }

    def query(self, question: str) -> str:
        """跨多个MCP服务器查询"""
        # 1. 从文档服务器获取资源
        doc_resources = self.mcp_clients["documents"].list_resources()
        doc_contents = [
            self.mcp_clients["documents"].read_resource(r["uri"])
            for r in doc_resources[:3]
        ]

        # 2. 从数据库服务器获取数据
        db_data = self.mcp_clients["database"].call_tool(
            "query_database",
            {"query": f"SELECT * FROM knowledge WHERE topic LIKE '%{question}%'"}
        )

        # 3. 使用工具服务器的搜索工具
        search_results = self.mcp_clients["tools"].call_tool(
            "search_documents",
            {"query": question, "limit": 5}
        )

        # 4. 合并所有结果
        context = self._merge_all_sources(
            doc_contents,
            db_data,
            search_results
        )

        # 5. 生成答案
        return self.llm.generate(f"Context: {context}\n\nQuestion: {question}")
```

### 实践2：MCP缓存

```python
class CachedMCPClient:
    """带缓存的MCP客户端"""
    def __init__(self, server_url: str):
        self.client = MCPClient(server_url)
        self.cache = {}

    def read_resource(self, uri: str, use_cache: bool = True) -> str:
        """读取资源（带缓存）"""
        if use_cache and uri in self.cache:
            return self.cache[uri]

        content = self.client.read_resource(uri)
        self.cache[uri] = content
        return content

    def invalidate_cache(self, uri: str = None):
        """清除缓存"""
        if uri:
            self.cache.pop(uri, None)
        else:
            self.cache.clear()
```

---

## MCP生态系统

### 官方MCP服务器

| 服务器 | 功能 | 维护者 |
|--------|------|--------|
| **filesystem** | 文件系统访问 | Anthropic |
| **github** | GitHub集成 | Anthropic |
| **postgres** | PostgreSQL访问 | Anthropic |
| **google-drive** | Google Drive | 社区 |
| **slack** | Slack集成 | 社区 |

### 社区MCP服务器

```python
# 使用社区MCP服务器
from mcp_community import GitHubMCPServer, SlackMCPServer

# GitHub服务器
github_server = GitHubMCPServer(token="your_token")
github_server.start()

# Slack服务器
slack_server = SlackMCPServer(token="your_token")
slack_server.start()
```

---

## 监控与调试

### MCP监控

```python
class MCPMonitor:
    """MCP监控"""
    def __init__(self):
        self.metrics = {
            "resource_reads": 0,
            "tool_calls": 0,
            "errors": 0,
            "latency": []
        }

    def log_resource_read(self, uri: str, latency: float):
        """记录资源读取"""
        self.metrics["resource_reads"] += 1
        self.metrics["latency"].append(latency)

    def log_tool_call(self, tool_name: str, latency: float):
        """记录工具调用"""
        self.metrics["tool_calls"] += 1
        self.metrics["latency"].append(latency)

    def log_error(self, error: str):
        """记录错误"""
        self.metrics["errors"] += 1

    def report(self) -> dict:
        """生成报告"""
        return {
            "total_resource_reads": self.metrics["resource_reads"],
            "total_tool_calls": self.metrics["tool_calls"],
            "total_errors": self.metrics["errors"],
            "avg_latency": sum(self.metrics["latency"]) / len(self.metrics["latency"])
                          if self.metrics["latency"] else 0
        }
```

---

## 常见问题

### Q1: MCP会替代RAG吗？

**A**: 不会！
- MCP是标准化接口，不是技术替代
- MCP + RAG = 更强大的系统
- MCP解决集成问题，RAG解决检索问题

### Q2: 如何选择MCP服务器？

**A**: 根据需求：
- **文档访问**：filesystem, google-drive
- **代码仓库**：github, gitlab
- **数据库**：postgres, mysql
- **通信**：slack, email

### Q3: MCP的性能开销？

**A**: 很小：
- 协议开销：<10ms
- 网络延迟：取决于部署
- 建议：本地部署MCP服务器

### Q4: MCP的安全性？

**A**: 协议层安全：
- 权限管理
- 审计日志
- 加密传输
- 访问控制

---

## 总结

### 核心要点

1. **定义**：标准化的上下文管理协议
2. **组件**：Resources、Tools、Prompts
3. **优势**：标准化、安全、可扩展
4. **集成**：MCP + RAG协同增强

### 记忆口诀

**"资源工具提示，标准安全协同"**

### 下一步

理解了MCP协议后，接下来学习：
- **生产级优化**：监控、调优、部署
- **实战代码**：完整场景实现

---

**记住**：MCP是2026年上下文管理的标准化方向！
