# docker-compose编排 - 核心概念：数据持久化

## 概述

**数据持久化** 是容器化应用的关键问题。容器本身是临时的，删除后数据会丢失。docker-compose 提供了三种数据持久化方案：命名卷（volumes）、绑定挂载（bind mounts）、tmpfs 挂载。

**本文涵盖：**
1. 三种数据持久化方案的原理和区别
2. 命名卷的定义和使用
3. 绑定挂载的场景和最佳实践
4. 数据库数据持久化
5. 开发环境代码热重载
6. 数据备份和迁移

---

## 1. 三种数据持久化方案

### 1.1 对比总览

| 特性 | 命名卷（Volumes） | 绑定挂载（Bind Mounts） | tmpfs 挂载 |
|------|------------------|----------------------|-----------|
| **管理方式** | Docker 管理 | 用户管理 | 内存管理 |
| **存储位置** | Docker 目录 | 主机任意路径 | 内存 |
| **跨平台** | ✅ 完全兼容 | ⚠️ 路径可能不同 | ✅ 完全兼容 |
| **性能** | ✅ 优化过 | ⚠️ 取决于文件系统 | ✅ 最快 |
| **持久化** | ✅ 永久 | ✅ 永久 | ❌ 临时 |
| **备份** | ✅ 简单 | ⚠️ 需要手动 | ❌ 不支持 |
| **权限问题** | ✅ 无 | ⚠️ 可能有 | ✅ 无 |
| **适用场景** | 数据库数据、生产环境 | 开发代码、配置文件 | 临时文件、缓存 |

### 1.2 可视化对比

```
主机文件系统
├── /var/lib/docker/volumes/
│   └── postgres_data/          ← 命名卷（Docker 管理）
│       └── _data/
│           └── [数据库文件]
│
├── /Users/wuxiao/my-project/   ← 绑定挂载（用户管理）
│   ├── app/
│   └── docker-compose.yml
│
└── 内存（RAM）                  ← tmpfs（临时）
    └── /tmp/
        └── [临时文件]
```

---

## 2. 命名卷（Volumes）

### 2.1 基本用法

```yaml
version: '3.8'

services:
  db:
    image: postgres:14-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 命名卷

volumes:
  postgres_data:  # 定义命名卷
```

**说明：**
- `postgres_data`：卷名称（可以自定义）
- `/var/lib/postgresql/data`：容器内的挂载路径
- `volumes:` 根节点：定义所有命名卷

### 2.2 卷的生命周期

```bash
# 启动服务（自动创建卷）
docker-compose up

# 查看卷
docker volume ls

# 查看卷详情
docker volume inspect <project>_postgres_data

# 停止服务（卷不会删除）
docker-compose down

# 停止服务并删除卷
docker-compose down -v
```

**重要：** `docker-compose down -v` 会删除所有数据！

### 2.3 卷的配置选项

```yaml
volumes:
  postgres_data:
    driver: local  # 驱动（默认 local）
    driver_opts:
      type: none
      o: bind
      device: /path/to/data  # 自定义存储位置

  # 外部卷（已存在的卷）
  existing_data:
    external: true
```

### 2.4 在 AI Agent 开发中的应用

```yaml
services:
  # PostgreSQL：数据持久化
  db:
    image: postgres:14-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Redis：缓存持久化
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

  # 向量数据库：向量数据持久化
  milvus:
    image: milvusdb/milvus:latest
    volumes:
      - milvus_data:/var/lib/milvus

volumes:
  postgres_data:
  redis_data:
  milvus_data:
```

**前端类比：**
```javascript
// 命名卷 = localStorage（浏览器管理）
localStorage.setItem('user_data', JSON.stringify(data));

// 数据永久保存，即使关闭浏览器
```

---

## 3. 绑定挂载（Bind Mounts）

### 3.1 基本用法

```yaml
services:
  api:
    volumes:
      - .:/app  # 绑定挂载（主机路径:容器路径）
```

**说明：**
- `.`：主机当前目录
- `/app`：容器内的挂载路径
- 主机目录的内容会完全映射到容器内

### 3.2 相对路径 vs 绝对路径

```yaml
services:
  api:
    volumes:
      # 相对路径（推荐）
      - .:/app
      - ./config:/app/config

      # 绝对路径
      - /Users/wuxiao/my-project:/app
```

**推荐：** 使用相对路径，跨平台兼容性更好。

### 3.3 只读挂载

```yaml
services:
  api:
    volumes:
      - ./config:/app/config:ro  # 只读（read-only）
```

**适用场景：**
- 配置文件（防止容器修改）
- 静态资源（防止误删除）

### 3.4 排除特定目录

```yaml
services:
  api:
    volumes:
      - .:/app                    # 挂载整个目录
      - /app/node_modules         # 排除 node_modules
      - /app/.venv                # 排除虚拟环境
```

**说明：**
- 先挂载整个目录
- 再排除特定子目录（使用匿名卷）

### 3.5 在 AI Agent 开发中的应用

```yaml
services:
  # API：代码热重载
  api:
    volumes:
      - .:/app                    # 挂载代码
      - /app/.venv                # 排除虚拟环境
      - /app/__pycache__          # 排除缓存
    command: uvicorn app.main:app --reload  # 启用热重载

  # 配置文件：只读挂载
  nginx:
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
```

**前端类比：**
```javascript
// 绑定挂载 = 直接读写文件
import fs from 'fs';
fs.writeFileSync('./data.json', JSON.stringify(data));

// 修改立即生效
```

---

## 4. tmpfs 挂载

### 4.1 基本用法

```yaml
services:
  api:
    tmpfs:
      - /tmp                      # 临时文件
      - /app/cache                # 缓存数据
```

**特点：**
- 存储在内存中
- 速度极快
- 容器停止后数据丢失

### 4.2 配置选项

```yaml
services:
  api:
    tmpfs:
      - /tmp:size=100M,mode=1777  # 限制大小和权限
```

### 4.3 适用场景

```yaml
services:
  # API：临时文件
  api:
    tmpfs:
      - /tmp                      # 临时文件
      - /app/temp                 # 临时处理文件

  # 数据处理：中间结果
  worker:
    tmpfs:
      - /app/processing           # 处理中的数据
```

**前端类比：**
```javascript
// tmpfs = sessionStorage（会话存储）
sessionStorage.setItem('temp_data', data);

// 关闭标签页后数据丢失
```

---

## 5. 数据库数据持久化

### 5.1 PostgreSQL 持久化

```yaml
services:
  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 数据目录
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro  # 初始化脚本

volumes:
  postgres_data:
```

**说明：**
- `/var/lib/postgresql/data`：PostgreSQL 数据目录
- `/docker-entrypoint-initdb.d/`：初始化脚本目录（只在首次启动时执行）

### 5.2 Redis 持久化

```yaml
services:
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes  # 启用 AOF 持久化
    volumes:
      - redis_data:/data  # 数据目录

volumes:
  redis_data:
```

**说明：**
- `--appendonly yes`：启用 AOF（Append Only File）持久化
- `/data`：Redis 数据目录

### 5.3 MongoDB 持久化

```yaml
services:
  mongo:
    image: mongo:6
    volumes:
      - mongo_data:/data/db  # 数据目录

volumes:
  mongo_data:
```

### 5.4 向量数据库持久化

```yaml
services:
  # Milvus
  milvus:
    image: milvusdb/milvus:latest
    volumes:
      - milvus_data:/var/lib/milvus

  # ChromaDB
  chroma:
    image: chromadb/chroma:latest
    volumes:
      - chroma_data:/chroma/chroma

volumes:
  milvus_data:
  chroma_data:
```

---

## 6. 开发环境代码热重载

### 6.1 Python/FastAPI 热重载

```yaml
services:
  api:
    build: .
    volumes:
      - .:/app                    # 挂载代码
      - /app/.venv                # 排除虚拟环境
    command: uvicorn app.main:app --host 0.0.0.0 --reload
```

**Dockerfile：**
```dockerfile
FROM python:3.13-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install -r requirements.txt

# 不复制代码（通过 volume 挂载）
# COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0"]
```

**说明：**
- `--reload`：启用热重载
- 修改代码后自动重启服务

### 6.2 Node.js/Express 热重载

```yaml
services:
  api:
    build: .
    volumes:
      - .:/app
      - /app/node_modules         # 排除 node_modules
    command: npm run dev
```

**package.json：**
```json
{
  "scripts": {
    "dev": "nodemon server.js"
  }
}
```

### 6.3 前端开发热重载

```yaml
services:
  frontend:
    build: .
    volumes:
      - .:/app
      - /app/node_modules
    ports:
      - "3000:3000"
    command: npm run dev
```

---

## 7. 数据备份和迁移

### 7.1 备份命名卷

```bash
# 方法1：使用 docker run 备份
docker run --rm \
  -v <project>_postgres_data:/data \
  -v $(pwd):/backup \
  alpine tar czf /backup/postgres_backup.tar.gz -C /data .

# 方法2：使用 docker-compose exec 备份
docker-compose exec db pg_dump -U user mydb > backup.sql
```

### 7.2 恢复命名卷

```bash
# 方法1：从 tar 文件恢复
docker run --rm \
  -v <project>_postgres_data:/data \
  -v $(pwd):/backup \
  alpine tar xzf /backup/postgres_backup.tar.gz -C /data

# 方法2：从 SQL 文件恢复
docker-compose exec -T db psql -U user mydb < backup.sql
```

### 7.3 迁移到新环境

```bash
# 1. 导出数据
docker-compose exec db pg_dump -U user mydb > backup.sql

# 2. 复制到新环境
scp backup.sql user@new-server:/path/to/project/

# 3. 在新环境导入
docker-compose up -d db
docker-compose exec -T db psql -U user mydb < backup.sql
```

### 7.4 自动备份脚本

```yaml
services:
  # 备份服务
  backup:
    image: postgres:14-alpine
    volumes:
      - postgres_data:/data:ro    # 只读访问数据
      - ./backups:/backups        # 备份目录
    command: >
      sh -c "
      while true; do
        pg_dump -h db -U user mydb > /backups/backup_$$(date +%Y%m%d_%H%M%S).sql
        sleep 86400
      done
      "
    depends_on:
      - db

volumes:
  postgres_data:
```

---

## 8. 性能优化

### 8.1 Mac/Windows 性能问题

**问题：** 绑定挂载在 Mac/Windows 上性能较差

**原因：** Docker Desktop 使用虚拟机，文件系统需要跨虚拟机同步

**解决方案：**

#### 方案1：使用命名卷（推荐）

```yaml
services:
  api:
    volumes:
      - app_code:/app             # 使用命名卷
    command: uvicorn app.main:app --reload

volumes:
  app_code:
```

#### 方案2：使用 delegated 模式

```yaml
services:
  api:
    volumes:
      - .:/app:delegated          # 延迟同步
```

**模式说明：**
- `consistent`：完全同步（默认，最慢）
- `cached`：主机优先（读多写少）
- `delegated`：容器优先（写多读少，推荐）

#### 方案3：排除大量小文件

```yaml
services:
  api:
    volumes:
      - .:/app
      - /app/node_modules         # 排除 node_modules
      - /app/.venv                # 排除虚拟环境
      - /app/__pycache__          # 排除缓存
```

### 8.2 数据库性能优化

```yaml
services:
  db:
    image: postgres:14-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data
    # 性能优化配置
    command:
      - postgres
      - -c
      - shared_buffers=256MB
      - -c
      - max_connections=200
    shm_size: 256mb               # 共享内存大小

volumes:
  postgres_data:
```

---

## 9. 常见问题

### Q1: 为什么删除容器后数据还在？

**A:** 使用了命名卷，数据存储在 Docker 管理的目录中。

```bash
# 查看卷
docker volume ls

# 删除卷
docker volume rm <volume_name>

# 或者使用 docker-compose down -v
docker-compose down -v
```

### Q2: 如何查看命名卷的实际位置？

**A:** 使用 docker volume inspect

```bash
docker volume inspect <project>_postgres_data

# 输出示例
[
    {
        "Mountpoint": "/var/lib/docker/volumes/<project>_postgres_data/_data"
    }
]
```

### Q3: 绑定挂载的权限问题怎么解决？

**A:** 使用 user 参数指定容器内用户

```yaml
services:
  api:
    user: "${UID}:${GID}"         # 使用主机用户 ID
    volumes:
      - .:/app
```

**.env 文件：**
```bash
UID=1000
GID=1000
```

### Q4: 如何在容器间共享数据？

**A:** 使用同一个命名卷

```yaml
services:
  api:
    volumes:
      - shared_data:/data

  worker:
    volumes:
      - shared_data:/data

volumes:
  shared_data:
```

### Q5: 如何清理未使用的卷？

**A:** 使用 docker volume prune

```bash
# 清理所有未使用的卷
docker volume prune

# 强制清理（不提示确认）
docker volume prune -f
```

---

## 10. 在 AI Agent 开发中的完整示例

```yaml
version: '3.8'

services:
  # FastAPI 应用
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/agent_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      db:
        condition: service_healthy
    volumes:
      # 代码热重载（绑定挂载）
      - .:/app:delegated
      - /app/.venv
      - /app/__pycache__
      # 临时文件（tmpfs）
    tmpfs:
      - /tmp
      - /app/temp
    command: uvicorn app.main:app --host 0.0.0.0 --reload

  # PostgreSQL 数据库
  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=agent_db
    volumes:
      # 数据持久化（命名卷）
      - postgres_data:/var/lib/postgresql/data
      # 初始化脚本（绑定挂载，只读）
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s

  # Redis 缓存
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      # 数据持久化（命名卷）
      - redis_data:/data

  # 向量数据库
  chroma:
    image: chromadb/chroma:latest
    volumes:
      # 向量数据持久化（命名卷）
      - chroma_data:/chroma/chroma

  # 数据库备份
  backup:
    image: postgres:14-alpine
    volumes:
      - postgres_data:/data:ro
      - ./backups:/backups
    command: >
      sh -c "
      while true; do
        pg_dump -h db -U user agent_db > /backups/backup_$$(date +%Y%m%d_%H%M%S).sql
        find /backups -name 'backup_*.sql' -mtime +7 -delete
        sleep 86400
      done
      "
    depends_on:
      - db
    profiles: ["prod"]            # 只在生产环境启动

volumes:
  postgres_data:                  # PostgreSQL 数据
  redis_data:                     # Redis 数据
  chroma_data:                    # ChromaDB 数据
```

**说明：**
1. **代码热重载**：使用绑定挂载 + delegated 模式
2. **数据持久化**：使用命名卷
3. **临时文件**：使用 tmpfs
4. **配置文件**：使用绑定挂载 + 只读
5. **自动备份**：定期备份数据库

---

## 11. 最佳实践总结

### 11.1 选择决策树

```
需要持久化？
├── 是 → 需要频繁修改？
│   ├── 是 → 绑定挂载（开发代码）
│   └── 否 → 命名卷（数据库数据）
└── 否 → tmpfs（临时文件）
```

### 11.2 推荐配置

| 数据类型 | 推荐方案 | 原因 |
|---------|---------|------|
| **数据库数据** | 命名卷 | 跨平台、性能好、易备份 |
| **开发代码** | 绑定挂载 | 热重载、方便编辑 |
| **配置文件** | 绑定挂载（只读） | 方便修改、防止误改 |
| **临时文件** | tmpfs | 速度快、自动清理 |
| **日志文件** | 绑定挂载 | 方便查看和分析 |
| **缓存数据** | 命名卷或 tmpfs | 根据是否需要持久化 |

### 11.3 注意事项

1. ✅ **数据库用命名卷**，不要用绑定挂载
2. ✅ **开发代码用绑定挂载**，启用热重载
3. ✅ **排除大量小文件**（node_modules、.venv）
4. ✅ **配置文件用只读挂载**，防止误改
5. ✅ **定期备份重要数据**
6. ❌ **不要用 `docker-compose down -v`** 删除生产数据
7. ❌ **不要在生产环境用绑定挂载** 存储数据库数据

---

**版本：** v1.0
**最后更新：** 2026-02-12
