# 核心概念 02：图数据库基础

## 什么是图数据库？

**图数据库**（Graph Database）是一种专门用于存储和查询图结构数据的数据库系统。

**核心特点**：
- 数据模型：节点（Nodes）+ 边（Edges）+ 属性（Properties）
- 关系是一等公民：关系和实体同等重要
- 原生图存储：数据以图结构存储，而非表结构
- 图遍历优化：针对图遍历操作进行优化

**与关系数据库的对比**：

| 特性 | 关系数据库 | 图数据库 |
|------|-----------|---------|
| 数据模型 | 表（行+列） | 图（节点+边） |
| 关系表示 | 外键+JOIN | 边（一等公民） |
| 多跳查询 | 多次JOIN（慢） | 图遍历（快） |
| 适用场景 | 聚合统计 | 关系查询 |
| 查询语言 | SQL | Cypher/SPARQL |

---

## 两大图模型

### 1. 属性图模型（Property Graph）

**定义**：
```
属性图 = 节点 + 边 + 属性
- 节点：表示实体，可以有标签和属性
- 边：表示关系，有方向，可以有类型和属性
- 属性：键值对，附加在节点或边上
```

**示例**：
```
节点：
(张三:Person {age: 30, city: "杭州"})
(阿里巴巴:Company {founded: 1999, industry: "电商"})

边：
(张三)-[:WORKS_AT {since: "2020-01-01", position: "工程师"}]->(阿里巴巴)
```

**特点**：
- 节点和边都可以有属性
- 边有方向和类型
- 灵活的数据模型
- 适合应用开发

**代表数据库**：
- Neo4j（最流行）
- TigerGraph
- ArangoDB
- JanusGraph

### 2. RDF模型（Resource Description Framework）

**定义**：
```
RDF图 = 三元组集合
- 三元组：(主语, 谓语, 宾语)
- 所有关系都是边
- 节点和边没有属性（属性也是三元组）
```

**示例**：
```
三元组：
(张三, rdf:type, Person)
(张三, foaf:age, 30)
(张三, org:worksFor, 阿里巴巴)
(阿里巴巴, rdf:type, Company)
```

**特点**：
- 严格的三元组模型
- 支持语义推理
- 标准化（W3C标准）
- 适合开放数据和学术研究

**代表数据库**：
- Apache Jena
- Virtuoso
- Stardog
- GraphDB

**属性图 vs RDF对比**：

| 特性 | 属性图 | RDF |
|------|--------|-----|
| 数据模型 | 节点+边+属性 | 三元组 |
| 属性表示 | 直接附加 | 额外三元组 |
| 查询语言 | Cypher | SPARQL |
| 推理能力 | 弱 | 强 |
| 应用场景 | 应用开发 | 语义网、学术 |
| 学习曲线 | 低 | 高 |

---

## 图数据库的核心概念

### 1. 节点（Nodes）

**定义**：图中的实体，表示对象或概念。

**组成**：
```python
节点 = {
    "id": "唯一标识",
    "labels": ["标签1", "标签2"],  # 节点类型
    "properties": {  # 属性
        "key1": "value1",
        "key2": "value2"
    }
}
```

**示例**：
```cypher
// Neo4j中创建节点
CREATE (p:Person:Employee {
    name: "张三",
    age: 30,
    email: "zhangsan@example.com"
})
```

**Python表示**：
```python
from dataclasses import dataclass
from typing import List, Dict, Any

@dataclass
class Node:
    """图节点"""
    id: str
    labels: List[str]
    properties: Dict[str, Any]

# 创建节点
person = Node(
    id="person_001",
    labels=["Person", "Employee"],
    properties={
        "name": "张三",
        "age": 30,
        "email": "zhangsan@example.com"
    }
)
```

### 2. 边（Edges/Relationships）

**定义**：连接两个节点的关系，有方向和类型。

**组成**：
```python
边 = {
    "id": "唯一标识",
    "type": "关系类型",
    "start_node": "起始节点ID",
    "end_node": "结束节点ID",
    "properties": {  # 属性
        "key1": "value1",
        "key2": "value2"
    }
}
```

**示例**：
```cypher
// Neo4j中创建关系
MATCH (p:Person {name: "张三"})
MATCH (c:Company {name: "阿里巴巴"})
CREATE (p)-[:WORKS_AT {
    since: "2020-01-01",
    position: "高级工程师",
    department: "技术部"
}]->(c)
```

**Python表示**：
```python
@dataclass
class Edge:
    """图边"""
    id: str
    type: str
    start_node: str
    end_node: str
    properties: Dict[str, Any]

# 创建边
works_at = Edge(
    id="edge_001",
    type="WORKS_AT",
    start_node="person_001",
    end_node="company_001",
    properties={
        "since": "2020-01-01",
        "position": "高级工程师"
    }
)
```

### 3. 路径（Paths）

**定义**：节点和边的序列，表示从一个节点到另一个节点的路径。

**表示**：
```
路径 = 节点1 -[边1]-> 节点2 -[边2]-> 节点3 -[边3]-> ...
```

**示例**：
```cypher
// 查询路径
MATCH path = (p:Person {name: "张三"})
             -[:WORKS_AT]->(c:Company)
             -[:LOCATED_IN]->(city:City)
RETURN path
```

**Python表示**：
```python
@dataclass
class Path:
    """图路径"""
    nodes: List[Node]
    edges: List[Edge]

    def length(self) -> int:
        """路径长度（边的数量）"""
        return len(self.edges)

    def __str__(self) -> str:
        """可视化路径"""
        result = []
        for i, node in enumerate(self.nodes):
            result.append(node.properties.get("name", node.id))
            if i < len(self.edges):
                result.append(f"-[{self.edges[i].type}]->")
        return " ".join(result)

# 创建路径
path = Path(
    nodes=[person, company, city],
    edges=[works_at, located_in]
)
print(path)
# 输出：张三 -[WORKS_AT]-> 阿里巴巴 -[LOCATED_IN]-> 杭州
```

### 4. 标签（Labels）

**定义**：节点的类型标识，用于分类和过滤。

**特点**：
- 一个节点可以有多个标签
- 标签用于索引和查询优化
- 标签表示节点的类别

**示例**：
```cypher
// 多标签节点
CREATE (p:Person:Employee:Manager {name: "张三"})

// 按标签查询
MATCH (p:Person)
WHERE p.age > 30
RETURN p

// 按多标签查询
MATCH (m:Person:Manager)
RETURN m
```

### 5. 属性（Properties）

**定义**：附加在节点或边上的键值对数据。

**支持的数据类型**：
```python
# Neo4j支持的属性类型
properties = {
    "string": "文本",
    "integer": 123,
    "float": 3.14,
    "boolean": True,
    "date": "2026-02-14",
    "datetime": "2026-02-14T12:00:00",
    "list": [1, 2, 3],
    "map": {"key": "value"}  # 部分数据库支持
}
```

---

## 图数据库的存储原理

### 1. 原生图存储 vs 非原生图存储

**原生图存储**（Native Graph Storage）：
```
特点：
- 数据以图结构存储在磁盘上
- 节点直接存储指向相邻节点的指针
- 图遍历不需要索引查找

优势：
- 遍历速度快（O(1)访问相邻节点）
- 适合大规模图遍历

代表：Neo4j, TigerGraph
```

**非原生图存储**（Non-Native Graph Storage）：
```
特点：
- 数据存储在关系数据库或键值存储中
- 图结构通过索引维护
- 遍历需要索引查找

劣势：
- 遍历速度慢（需要索引查找）
- 不适合深度遍历

代表：JanusGraph（基于Cassandra/HBase）
```

### 2. Neo4j的存储结构

**节点存储**：
```
节点文件（neostore.nodestore.db）：
- 固定大小记录（15字节）
- 包含：节点ID、第一个属性指针、第一个关系指针、标签指针

[节点ID][属性指针][关系指针][标签指针]
```

**关系存储**：
```
关系文件（neostore.relationshipstore.db）：
- 固定大小记录（34字节）
- 包含：关系ID、起始节点、结束节点、关系类型、属性指针、前后关系指针

[关系ID][起始节点][结束节点][类型][属性][前关系][后关系]
```

**属性存储**：
```
属性文件（neostore.propertystore.db）：
- 动态大小记录
- 键值对存储

[属性ID][键][值][下一个属性]
```

**索引**：
```
- 标签索引：快速查找特定标签的节点
- 属性索引：快速查找特定属性值的节点
- 全文索引：支持全文搜索
```

---

## 图数据库的查询优化

### 1. 索引策略

**创建索引**：
```cypher
// 单属性索引
CREATE INDEX person_name FOR (p:Person) ON (p.name)

// 复合索引
CREATE INDEX person_name_age FOR (p:Person) ON (p.name, p.age)

// 全文索引
CREATE FULLTEXT INDEX person_fulltext FOR (p:Person) ON EACH [p.name, p.bio]
```

**使用索引**：
```cypher
// 使用索引（快）
MATCH (p:Person {name: "张三"})
RETURN p

// 不使用索引（慢）
MATCH (p:Person)
WHERE p.name = "张三"
RETURN p
```

### 2. 查询计划分析

**EXPLAIN和PROFILE**：
```cypher
// 查看查询计划（不执行）
EXPLAIN
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
WHERE p.age > 30
RETURN p, c

// 查看查询计划和性能（执行）
PROFILE
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
WHERE p.age > 30
RETURN p, c
```

**优化建议**：
```cypher
// ❌ 慢：先扫描所有Person，再过滤
MATCH (p:Person)
WHERE p.name = "张三"
RETURN p

// ✅ 快：使用索引直接查找
MATCH (p:Person {name: "张三"})
RETURN p

// ❌ 慢：笛卡尔积
MATCH (p:Person), (c:Company)
WHERE p.company_id = c.id
RETURN p, c

// ✅ 快：使用关系
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
RETURN p, c
```

### 3. 批量操作优化

**批量导入**：
```cypher
// ❌ 慢：逐条插入
CREATE (p:Person {name: "张三"})
CREATE (p:Person {name: "李四"})
// ...

// ✅ 快：批量导入
UNWIND [
    {name: "张三", age: 30},
    {name: "李四", age: 28}
] AS person
CREATE (p:Person)
SET p = person
```

**使用APOC插件**：
```cypher
// 批量导入CSV
CALL apoc.load.csv('people.csv') YIELD map AS row
CREATE (p:Person)
SET p = row
```

---

## 主流图数据库对比

### 1. Neo4j

**特点**：
- 最流行的图数据库
- 原生图存储
- Cypher查询语言
- 强大的可视化工具

**优势**：
- 性能优秀
- 生态完善
- 文档丰富
- 社区活跃

**劣势**：
- 企业版收费
- 单机扩展性有限

**适用场景**：
- 企业知识图谱
- 推荐系统
- 欺诈检测
- 社交网络

### 2. TigerGraph

**特点**：
- 分布式图数据库
- 原生并行图计算
- GSQL查询语言

**优势**：
- 水平扩展能力强
- 大规模图处理
- 实时分析

**劣势**：
- 学习曲线陡峭
- 社区较小

**适用场景**：
- 大规模图分析
- 实时推荐
- 金融风控

### 3. ArangoDB

**特点**：
- 多模型数据库（文档+图+键值）
- AQL查询语言
- 分布式架构

**优势**：
- 灵活的数据模型
- 支持多种查询方式
- 易于扩展

**劣势**：
- 图性能不如专用图数据库

**适用场景**：
- 混合数据模型应用
- 需要灵活性的场景

### 4. JanusGraph

**特点**：
- 开源分布式图数据库
- 基于Cassandra/HBase存储
- Gremlin查询语言

**优势**：
- 完全开源
- 水平扩展
- 支持多种存储后端

**劣势**：
- 非原生图存储
- 性能不如Neo4j

**适用场景**：
- 大规模分布式图
- 需要开源方案

---

## Python操作图数据库

### 1. Neo4j Python Driver

```python
"""Neo4j Python Driver基础"""

from neo4j import GraphDatabase
from typing import List, Dict, Any

class Neo4jDatabase:
    """Neo4j数据库操作类"""

    def __init__(self, uri: str, user: str, password: str):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        """关闭连接"""
        self.driver.close()

    def create_node(self, label: str, properties: Dict[str, Any]) -> int:
        """创建节点"""
        with self.driver.session() as session:
            result = session.run(
                f"CREATE (n:{label} $props) RETURN id(n) AS node_id",
                props=properties
            )
            return result.single()["node_id"]

    def create_relationship(
        self,
        start_id: int,
        end_id: int,
        rel_type: str,
        properties: Dict[str, Any] = None
    ):
        """创建关系"""
        with self.driver.session() as session:
            query = """
            MATCH (a), (b)
            WHERE id(a) = $start_id AND id(b) = $end_id
            CREATE (a)-[r:%s $props]->(b)
            RETURN r
            """ % rel_type

            session.run(
                query,
                start_id=start_id,
                end_id=end_id,
                props=properties or {}
            )

    def find_nodes(self, label: str, properties: Dict[str, Any] = None) -> List[Dict]:
        """查找节点"""
        with self.driver.session() as session:
            if properties:
                # 构建WHERE子句
                where_clauses = [f"n.{k} = ${k}" for k in properties.keys()]
                where_str = " AND ".join(where_clauses)
                query = f"MATCH (n:{label}) WHERE {where_str} RETURN n"
                result = session.run(query, **properties)
            else:
                query = f"MATCH (n:{label}) RETURN n"
                result = session.run(query)

            return [dict(record["n"]) for record in result]

    def find_path(
        self,
        start_label: str,
        start_props: Dict[str, Any],
        end_label: str,
        end_props: Dict[str, Any],
        max_depth: int = 5
    ) -> List[List[Dict]]:
        """查找路径"""
        with self.driver.session() as session:
            query = f"""
            MATCH path = (start:{start_label} $start_props)
                        -[*1..{max_depth}]-
                        (end:{end_label} $end_props)
            RETURN path
            LIMIT 10
            """

            result = session.run(
                query,
                start_props=start_props,
                end_props=end_props
            )

            paths = []
            for record in result:
                path = record["path"]
                path_data = {
                    "nodes": [dict(node) for node in path.nodes],
                    "relationships": [
                        {
                            "type": rel.type,
                            "properties": dict(rel)
                        }
                        for rel in path.relationships
                    ]
                }
                paths.append(path_data)

            return paths

# 使用示例
db = Neo4jDatabase(
    uri="bolt://localhost:7687",
    user="neo4j",
    password="password"
)

# 创建节点
person_id = db.create_node("Person", {"name": "张三", "age": 30})
company_id = db.create_node("Company", {"name": "阿里巴巴"})

# 创建关系
db.create_relationship(
    person_id,
    company_id,
    "WORKS_AT",
    {"since": "2020-01-01"}
)

# 查找节点
persons = db.find_nodes("Person", {"name": "张三"})
print(persons)

# 查找路径
paths = db.find_path(
    "Person", {"name": "张三"},
    "City", {"name": "杭州"},
    max_depth=3
)
print(paths)

db.close()
```

---

## 在RAG中的应用

### 1. 知识图谱存储

```python
"""使用图数据库存储知识图谱"""

class KnowledgeGraphStore:
    """知识图谱存储"""

    def __init__(self, neo4j_db: Neo4jDatabase):
        self.db = neo4j_db

    def add_triple(self, subject: str, predicate: str, obj: str):
        """添加三元组"""
        # 创建或获取主语节点
        subject_id = self._get_or_create_entity(subject)

        # 创建或获取宾语节点
        object_id = self._get_or_create_entity(obj)

        # 创建关系
        self.db.create_relationship(
            subject_id,
            object_id,
            predicate
        )

    def _get_or_create_entity(self, name: str) -> int:
        """获取或创建实体节点"""
        # 查找现有节点
        nodes = self.db.find_nodes("Entity", {"name": name})

        if nodes:
            # 返回现有节点ID
            return nodes[0]["id"]
        else:
            # 创建新节点
            return self.db.create_node("Entity", {"name": name})

    def query_relations(self, entity: str) -> List[Dict]:
        """查询实体的所有关系"""
        with self.db.driver.session() as session:
            result = session.run("""
                MATCH (e:Entity {name: $name})-[r]->(target)
                RETURN type(r) AS relation, target.name AS target
            """, name=entity)

            return [
                {"relation": record["relation"], "target": record["target"]}
                for record in result
            ]

# 使用
kg_store = KnowledgeGraphStore(db)

# 添加知识
kg_store.add_triple("张三", "WORKS_AT", "阿里巴巴")
kg_store.add_triple("阿里巴巴", "LOCATED_IN", "杭州")

# 查询
relations = kg_store.query_relations("张三")
print(relations)
# 输出：[{'relation': 'WORKS_AT', 'target': '阿里巴巴'}]
```

### 2. 图检索

```python
"""基于图的检索"""

def graph_retrieval(query: str, kg_store: KnowledgeGraphStore) -> List[str]:
    """
    图检索

    流程：
    1. 提取查询中的实体
    2. 在图中查找相关路径
    3. 返回路径上的所有信息
    """
    # 1. 提取实体（简化版）
    entities = extract_entities(query)

    # 2. 查找路径
    results = []
    for entity in entities:
        relations = kg_store.query_relations(entity)
        results.extend(relations)

    # 3. 格式化结果
    context = []
    for rel in results:
        context.append(f"{entity} {rel['relation']} {rel['target']}")

    return context

# 使用
query = "张三在哪工作？"
context = graph_retrieval(query, kg_store)
print(context)
# 输出：['张三 WORKS_AT 阿里巴巴']
```

---

## 总结

### 图数据库的核心价值

1. **关系是一等公民**：
   - 关系和实体同等重要
   - 原生支持图遍历
   - 多跳查询性能优秀

2. **灵活的数据模型**：
   - 节点和边都可以有属性
   - 支持多标签
   - 易于扩展

3. **强大的查询能力**：
   - 图遍历
   - 路径查询
   - 模式匹配

### 选择建议

**选择Neo4j如果**：
- 需要企业级支持
- 重视性能和稳定性
- 需要丰富的工具和生态

**选择TigerGraph如果**：
- 需要大规模分布式
- 需要实时分析
- 有预算和技术团队

**选择开源方案如果**：
- 预算有限
- 需要完全控制
- 有定制需求

---

**引用来源**：
- [Neo4j官方文档](https://neo4j.com/docs/)
- [图数据库对比](https://db-engines.com/en/ranking/graph+dbms)
- [Neo4j存储原理](https://neo4j.com/docs/operations-manual/current/performance/)
- [图数据库最佳实践](https://neo4j.com/developer/guide-data-modeling/)

---

**版本**：v1.0
**最后更新**：2026-02-14
**维护者**：Claude Code
