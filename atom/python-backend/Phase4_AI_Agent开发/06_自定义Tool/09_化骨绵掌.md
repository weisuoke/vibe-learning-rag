# 自定义Tool - 化骨绵掌

> 10个2分钟知识卡片，快速掌握自定义Tool的核心知识

---

## 卡片1：Tool的本质

**一句话：** Tool是让LLM能够调用的函数，通过描述让LLM理解何时调用，通过参数Schema验证输入，通过字符串返回结果。

**举例：**
```python
from langchain.tools import tool

@tool
def get_weather(city: str) -> str:
    """获取指定城市的天气信息

    Args:
        city: 城市名称，如'北京'
    """
    return f"{city}的天气：晴天，25°C"
```

**关键要素：**
- `@tool`装饰器：声明这是一个Tool
- 函数名：`get_weather` → Tool名称
- 文档字符串：LLM用来理解功能
- 参数：`city: str` → 输入
- 返回值：必须是字符串

**应用：** 在AI Agent中，Tool是LLM突破文本生成限制的唯一方式，让LLM能够查询数据、调用API、执行操作。

---

## 卡片2：4种Tool定义方式

**一句话：** LangChain提供4种Tool定义方式，@tool装饰器最简单（推荐80%场景），StructuredTool适合复杂参数，BaseTool适合高级定制。

**对比：**

| 方式 | 适用场景 | 复杂度 | 示例 |
|-----|---------|-------|------|
| @tool装饰器 | 大多数场景 | ⭐ | `@tool def func()` |
| Tool类 | 简单快速定义 | ⭐⭐ | `Tool(name=..., func=...)` |
| StructuredTool | 复杂参数验证 | ⭐⭐⭐ | `StructuredTool.from_function()` |
| BaseTool继承 | 高级定制 | ⭐⭐⭐⭐ | `class MyTool(BaseTool)` |

**举例：**
```python
# 方式1：@tool装饰器（推荐）
@tool
def get_time() -> str:
    """获取当前时间"""
    return datetime.now().strftime("%H:%M:%S")

# 方式2：Tool类
get_time_tool = Tool(
    name="get_time",
    func=lambda: datetime.now().strftime("%H:%M:%S"),
    description="获取当前时间"
)

# 方式3：StructuredTool
from langchain.tools import StructuredTool
from pydantic import BaseModel

class TimeInput(BaseModel):
    timezone: str

get_time_tool = StructuredTool.from_function(
    func=get_time_with_timezone,
    name="get_time",
    description="获取指定时区的时间",
    args_schema=TimeInput
)

# 方式4：BaseTool继承
from langchain.tools import BaseTool

class GetTimeTool(BaseTool):
    name = "get_time"
    description = "获取当前时间"

    def _run(self, timezone: str = "UTC") -> str:
        return get_time_with_timezone(timezone)
```

**应用：** 90%的场景用@tool装饰器就够了，只有需要复杂参数验证或高级定制时才用其他方式。

---

## 卡片3：参数验证的重要性

**一句话：** 使用Pydantic Schema验证Tool参数，可以在执行前拦截无效输入，避免浪费API调用和数据库查询。

**为什么重要？**
- 防止无效参数（空字符串、负数、格式错误）
- 节省成本（避免无效的API调用）
- 提升体验（提前发现错误）

**举例：**
```python
from pydantic import BaseModel, Field

# ❌ 没有验证
@tool
def search_products(keyword: str, limit: int) -> str:
    """搜索产品"""
    # keyword可能是空字符串
    # limit可能是负数或超大值
    results = db.search(keyword, limit)
    return str(results)

# ✅ 有验证
class SearchInput(BaseModel):
    keyword: str = Field(
        description="搜索关键词",
        min_length=1,      # 不能为空
        max_length=100     # 不能太长
    )
    limit: int = Field(
        default=10,
        description="返回数量",
        ge=1,              # 大于等于1
        le=50              # 小于等于50
    )

@tool(args_schema=SearchInput)
def search_products(keyword: str, limit: int = 10) -> str:
    """搜索产品"""
    # 参数已经验证过，可以放心使用
    results = db.search(keyword, limit)
    return str(results)
```

**效果：**
- 拦截80%的无效调用
- 节省API成本
- 提升Agent准确率

**应用：** 所有生产环境的Tool都应该有参数验证，开发环境可以简化。

---

## 卡片4：Tool描述的最佳实践

**一句话：** Tool描述是LLM选择Tool的唯一依据，必须包含功能说明、适用场景、参数说明、返回值说明。

**描述模板：**
```python
@tool
def tool_name(param: str) -> str:
    """[一句话功能描述]

    [详细功能说明，包括：]
    - [返回什么信息1]
    - [返回什么信息2]

    适用场景：
    - [场景1：用户询问"..."]
    - [场景2：用户询问"..."]

    Args:
        param: [参数说明，包括格式、范围、示例]

    Returns:
        [返回值说明]

    注意事项：
    - [注意事项1]
    """
    pass
```

**对比：**

| 维度 | 差的描述 | 好的描述 |
|-----|---------|---------|
| 长度 | 1行 | 10-20行 |
| 功能说明 | "获取数据" | "获取订单的状态、商品、金额、地址" |
| 适用场景 | 无 | "用户询问'我的订单XXX怎么样了？'" |
| 参数说明 | 无 | "订单ID，格式为ORD-XXXXXX" |
| LLM准确率 | 60% | 95% |

**应用：** 描述质量直接决定Tool是否被正确调用，投入时间写好描述比优化代码更重要。

---

## 卡片5：错误处理策略

**一句话：** Tool应该返回错误信息而非抛出异常，让LLM能理解错误并尝试其他方案。

**为什么不抛出异常？**
- 异常会中断Agent执行
- LLM看不到异常信息（被框架捕获）
- 用户只会看到"系统错误"

**错误处理模板：**
```python
@tool
def query_order(order_id: str) -> str:
    """查询订单"""
    try:
        # 1. 参数验证错误
        if not order_id:
            return "错误：订单号不能为空。"

        # 2. 业务逻辑错误
        order = db.get_order(order_id)
        if not order:
            return f"错误：订单{order_id}不存在。建议：请检查订单号是否正确。"

        # 3. 成功返回
        return format_order(order)

    except DatabaseError as e:
        # 4. 数据库错误
        return f"数据库错误：{str(e)}。建议：请稍后重试。"

    except NetworkError as e:
        # 5. 网络错误
        return f"网络错误：{str(e)}。建议：请检查网络连接。"

    except Exception as e:
        # 6. 未知错误
        return f"系统错误：{str(e)}。建议：请联系客服。"
```

**错误信息格式：**
```
错误：[错误类型]
原因：[错误原因]
建议：[解决方案]
```

**应用：** 友好的错误信息让LLM能够生成有帮助的回复，而不是简单的"系统错误"。

---

## 卡片6：异步Tool的优势

**一句话：** 异步Tool可以并发执行，当Agent需要调用多个Tool时，响应时间可以减少50%以上。

**同步 vs 异步：**

```python
# ❌ 同步Tool（串行执行）
@tool
def fetch_weather(city: str) -> str:
    """获取天气（同步）"""
    response = httpx.get(f"/weather?city={city}")
    return response.text

# 用户问："北京和上海的天气"
# 执行：fetch_weather("北京") → 3秒
#      fetch_weather("上海") → 3秒
# 总耗时：6秒

# ✅ 异步Tool（并发执行）
@tool
async def fetch_weather(city: str) -> str:
    """获取天气（异步）"""
    async with httpx.AsyncClient() as client:
        response = await client.get(f"/weather?city={city}")
        return response.text

# 用户问："北京和上海的天气"
# 执行：并发调用
#      fetch_weather("北京") ← 3秒
#      fetch_weather("上海") ← 3秒
# 总耗时：3秒（快一倍！）
```

**何时使用异步？**
- Tool涉及I/O操作（API调用、数据库查询、文件读写）
- Agent可能需要调用多个Tool
- 响应时间要求高

**注意事项：**
- 异步Tool需要在异步环境中运行
- FastAPI天然支持异步
- 使用`agent_executor.ainvoke()`而非`invoke()`

**应用：** 生产环境的Tool应该尽量设计为异步，提升并发性能。

---

## 卡片7：资源管理与连接池

**一句话：** 使用连接池复用数据库连接和HTTP客户端，避免每次Tool调用都建立新连接，性能提升3-5倍。

**不复用 vs 复用：**

```python
# ❌ 每次都创建新连接（慢）
@tool
async def fetch_data(url: str) -> str:
    """获取数据（不复用连接）"""
    async with httpx.AsyncClient() as client:  # 每次新建
        response = await client.get(url)
        return response.text
    # 每次都要TCP握手，慢！

# ✅ 复用连接（快）
# 在模块级别创建客户端
http_client = httpx.AsyncClient(
    limits=httpx.Limits(max_connections=10)
)

@tool
async def fetch_data(url: str) -> str:
    """获取数据（复用连接）"""
    response = await http_client.get(url)  # 复用连接
    return response.text
    # 复用TCP连接，快！
```

**数据库连接池：**
```python
# 创建连接池
db_pool = await asyncpg.create_pool(
    host='localhost',
    database='mydb',
    min_size=5,
    max_size=20
)

@tool
async def query_database(query: str) -> str:
    """查询数据库"""
    async with db_pool.acquire() as conn:
        result = await conn.fetch(query)
        return str(result)
```

**性能对比：**
- 不复用：100次调用 = 100次TCP握手 = 10秒
- 复用：100次调用 = 1次TCP握手 = 2秒（快5倍）

**应用：** 所有涉及网络或数据库的Tool都应该使用连接池。

---

## 卡片8：Tool数量控制

**一句话：** Tool数量要适中（5-10个最佳），太多会导致LLM选择困难，应该根据场景动态选择Tool。

**为什么Tool不是越多越好？**
- LLM需要分析所有Tool的描述
- Tool描述占用大量token
- 选择困难，容易选错
- 成本增加

**动态选择Tool：**
```python
# 定义Tool分组
CUSTOMER_SERVICE_TOOLS = [
    query_order,
    query_user,
    send_email
]

DATA_ANALYSIS_TOOLS = [
    query_database,
    generate_chart,
    export_csv
]

CONTENT_CREATION_TOOLS = [
    search_knowledge_base,
    generate_text,
    check_grammar
]

# 根据场景选择
def create_agent_for_scenario(scenario: str):
    if scenario == "customer_service":
        tools = CUSTOMER_SERVICE_TOOLS
    elif scenario == "data_analysis":
        tools = DATA_ANALYSIS_TOOLS
    elif scenario == "content_creation":
        tools = CONTENT_CREATION_TOOLS
    else:
        tools = []

    return create_agent(tools=tools)
```

**经验法则：**
- **5-10个Tool**：最佳范围，LLM选择准确
- **10-20个Tool**：可接受，但要确保描述清晰
- **20+个Tool**：需要分组或动态加载

**应用：** 不要一次性给Agent提供所有Tool，根据用户意图动态选择相关的Tool。

---

## 卡片9：Tool的单元测试

**一句话：** Tool应该像普通函数一样编写单元测试，确保功能正确、错误处理完善。

**测试模板：**
```python
import pytest
from your_tools import query_order

def test_query_order_success():
    """测试成功查询订单"""
    result = query_order("ORD-123456")
    assert "订单号：ORD-123456" in result
    assert "状态：" in result

def test_query_order_not_found():
    """测试订单不存在"""
    result = query_order("ORD-999999")
    assert "错误：订单ORD-999999不存在" in result
    assert "建议：" in result

def test_query_order_invalid_format():
    """测试订单号格式错误"""
    # 如果有参数验证，应该在调用前就拦截
    with pytest.raises(ValidationError):
        query_order("invalid-id")

@pytest.mark.asyncio
async def test_query_order_database_error(mocker):
    """测试数据库错误"""
    # Mock数据库抛出异常
    mocker.patch('db.get_order', side_effect=DatabaseError("连接超时"))

    result = await query_order("ORD-123456")
    assert "数据库错误" in result
    assert "请稍后重试" in result
```

**测试覆盖：**
- ✅ 正常情况：参数正确，返回预期结果
- ✅ 边界情况：空值、极值、特殊字符
- ✅ 错误情况：数据不存在、网络错误、数据库错误
- ✅ 异常情况：超时、权限不足、资源耗尽

**应用：** 生产环境的Tool必须有完善的单元测试，确保可靠性。

---

## 卡片10：Tool与Agent的集成

**一句话：** Tool定义好后，需要集成到Agent执行器中，配置合理的参数（max_iterations、timeout）确保Agent稳定运行。

**完整集成示例：**
```python
from langchain_openai import ChatOpenAI
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain.prompts import ChatPromptTemplate

# 1. 定义Tools
tools = [
    get_weather,
    query_order,
    send_email
]

# 2. 创建LLM
llm = ChatOpenAI(
    model="gpt-4",
    temperature=0  # 降低随机性，提高稳定性
)

# 3. 创建Prompt
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个智能助手，可以使用工具来回答用户问题。"),
    ("human", "{input}"),
    ("placeholder", "{agent_scratchpad}"),
])

# 4. 创建Agent
agent = create_tool_calling_agent(llm, tools, prompt)

# 5. 创建执行器
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,              # 显示执行过程
    max_iterations=5,          # 最大迭代次数
    max_execution_time=30,     # 最大执行时间（秒）
    handle_parsing_errors=True # 处理解析错误
)

# 6. 使用Agent
result = await agent_executor.ainvoke({
    "input": "北京今天天气怎么样？"
})
print(result["output"])
```

**在FastAPI中集成：**
```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class QueryRequest(BaseModel):
    question: str

@app.post("/ask")
async def ask_agent(request: QueryRequest):
    """Agent问答端点"""
    try:
        result = await agent_executor.ainvoke({
            "input": request.question
        })
        return {"answer": result["output"]}
    except Exception as e:
        return {"error": str(e)}
```

**关键配置：**
- `max_iterations`：防止无限循环
- `max_execution_time`：防止超时
- `handle_parsing_errors`：处理LLM输出格式错误
- `verbose`：开发环境开启，生产环境关闭

**应用：** Agent执行器是Tool和LLM之间的桥梁，合理配置参数确保稳定性。

---

## 知识卡片总结

### 10个卡片的知识体系

```
基础层（卡片1-2）
├── Tool的本质
└── 4种Tool定义方式

核心层（卡片3-5）
├── 参数验证的重要性
├── Tool描述的最佳实践
└── 错误处理策略

性能层（卡片6-8）
├── 异步Tool的优势
├── 资源管理与连接池
└── Tool数量控制

实践层（卡片9-10）
├── Tool的单元测试
└── Tool与Agent的集成
```

### 快速查找指南

**我想了解：**
- Tool是什么？ → 卡片1
- 如何定义Tool？ → 卡片2
- 如何验证参数？ → 卡片3
- 如何写描述？ → 卡片4
- 如何处理错误？ → 卡片5
- 如何提升性能？ → 卡片6、7
- Tool数量多少合适？ → 卡片8
- 如何测试Tool？ → 卡片9
- 如何集成到Agent？ → 卡片10

### 学习路径建议

**快速入门（15分钟）：**
卡片1 → 卡片2 → 卡片4

**深入理解（30分钟）：**
卡片1 → 卡片2 → 卡片3 → 卡片4 → 卡片5

**生产实践（60分钟）：**
全部10个卡片

---

## 实践检查清单

完成10个卡片学习后，检查你是否掌握：

### 基础能力
- [ ] 理解Tool的本质（LLM的"手脚"）
- [ ] 掌握@tool装饰器的使用
- [ ] 知道何时用其他Tool定义方式

### 核心能力
- [ ] 使用Pydantic定义参数Schema
- [ ] 编写清晰的Tool描述（功能、场景、参数）
- [ ] 返回错误信息而非抛出异常

### 性能优化
- [ ] 创建异步Tool
- [ ] 使用连接池管理资源
- [ ] 根据场景动态选择Tool

### 生产实践
- [ ] 编写Tool的单元测试
- [ ] 集成Tool到Agent执行器
- [ ] 配置合理的执行参数

---

## 下一步学习

完成化骨绵掌后，建议：

1. **阅读核心概念**（4个文件）
   - Tool定义方式的详细对比
   - 参数验证与Schema的深入讲解
   - Tool描述与LLM理解的机制
   - 异步Tool与资源管理的最佳实践

2. **实践实战代码**（8个场景）
   - API调用工具
   - 数据库查询工具
   - 向量检索工具
   - 文件操作工具
   - 计算处理工具
   - 多Tool组合
   - FastAPI集成
   - 生产实践

3. **查漏补缺**
   - 反直觉点：避免常见误区
   - 面试必问：准备面试问题

---

**记住：** 这10个卡片是自定义Tool的核心知识，掌握它们就能应对80%的实际场景！
