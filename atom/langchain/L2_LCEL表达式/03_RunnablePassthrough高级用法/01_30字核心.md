# 30字核心

> **一句话掌握 RunnablePassthrough 的本质**

---

## 核心定义

**RunnablePassthrough 是 LCEL 的数据透传原语，通过 assign 方法实现上下文保持与数据增强的完美结合。**

---

## 为什么是这30字？

### 1. **RunnablePassthrough** - 官方名称
- 这是 LangChain 官方的类名
- "Passthrough" 意为"透传"、"穿透"
- 2025-2026 文档中最核心的上下文管理工具

### 2. **LCEL 的数据透传原语** - 定位
- LCEL 有三大核心原语：
  - `RunnableSequence` - 串行执行（`|` 操作符）
  - `RunnableParallel` - 并行执行（字典语法）
  - `RunnablePassthrough` - 数据透传（上下文保持）
- 它是构建复杂 AI 链的基础工具

### 3. **assign 方法** - 核心能力
- 这是 RunnablePassthrough 最强大的功能
- 在不丢失原始输入的情况下添加新字段
- RAG 管道中最常用的模式

### 4. **上下文保持** - 第一用途
- 保持原始问题、用户信息等上下文
- 避免数据在链式传递中丢失
- 让后续步骤能访问所有历史信息

### 5. **数据增强** - 第二用途
- 在原有数据基础上添加新信息
- 逐步构建完整的数据字典
- 支持多步骤的数据累积

---

## 一个最小示例

```python
from langchain_core.runnables import RunnablePassthrough
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

model = ChatOpenAI(model="gpt-4")

# 使用 assign 方法添加新字段
chain = RunnablePassthrough.assign(
    summary=ChatPromptTemplate.from_template("总结: {text}") | model
)

# 原始输入
input_data = {"text": "LangChain 是一个强大的 AI 框架", "user": "Alice"}

# 执行后保留所有原始字段 + 新增 summary 字段
result = chain.invoke(input_data)
print(result)
# {
#     "text": "LangChain 是一个强大的 AI 框架",  # 保留
#     "user": "Alice",                          # 保留
#     "summary": AIMessage(content="...")       # 新增
# }
```

**关键点**：
- 原始字段 `text` 和 `user` 完全保留
- 新增字段 `summary` 通过 assign 添加
- 不会覆盖已有字段
- 适合逐步构建复杂数据结构

---

## 与其他概念的对比

| 概念 | 作用 | 输入 | 输出 | 使用场景 |
|------|------|------|------|----------|
| **RunnablePassthrough** | 透传 | 任意 | 原样输出 | 保持上下文 |
| **RunnablePassthrough.assign()** | 增强 | 字典 | 扩展字典 | 添加新字段 |
| **RunnableParallel** | 并行 | 任意 | 字典 | 独立任务 |
| **RunnableLambda** | 转换 | 任意 | 任意 | 自定义逻辑 |

---

## 为什么需要数据透传？

### 场景1: RAG 上下文保持

```python
from langchain_core.runnables import RunnablePassthrough

# 问题：检索后原始问题丢失了
bad_chain = retriever | prompt | model  # ❌ 问题在哪？

# 解决：使用 RunnablePassthrough 保持问题
good_chain = {
    "context": retriever,
    "question": RunnablePassthrough(),  # ✅ 保持原始问题
} | prompt | model
```

**为什么需要？**
- `retriever` 接收问题，返回文档列表
- 但 prompt 需要同时访问问题和文档
- 必须保持原始问题才能正确生成 prompt

---

### 场景2: 多步骤数据累积

```python
# 逐步构建完整的数据字典
chain = (
    # 步骤1: 添加检索结果
    RunnablePassthrough.assign(
        context=retriever
    )
    # 步骤2: 添加答案
    | RunnablePassthrough.assign(
        answer=prompt | model
    )
    # 步骤3: 添加评分
    | RunnablePassthrough.assign(
        score=evaluation_chain
    )
)

# 最终输出包含所有步骤的结果
result = chain.invoke({"question": "LangChain 是什么？"})
# {
#     "question": "...",  # 原始输入
#     "context": [...],   # 步骤1添加
#     "answer": "...",    # 步骤2添加
#     "score": 0.95       # 步骤3添加
# }
```

**为什么需要？**
- 每一步都需要访问之前的所有数据
- 不能丢失任何中间结果
- 便于调试和追踪

---

### 场景3: 并行处理 + 上下文保持

```python
# 同时执行多个任务，同时保持原始输入
chain = {
    "original": RunnablePassthrough(),  # 保持原始输入
    "summary": summary_chain,           # 生成摘要
    "keywords": keyword_chain,          # 提取关键词
    "sentiment": sentiment_chain,       # 分析情感
}

result = chain.invoke({"text": "..."})
# {
#     "original": {"text": "..."},  # 原始输入
#     "summary": "...",             # 摘要
#     "keywords": [...],            # 关键词
#     "sentiment": "positive"       # 情感
# }
```

**为什么需要？**
- 并行任务执行后，原始输入可能需要在后续步骤使用
- 保持原始输入便于对比和验证
- 提供完整的数据上下文

---

## 两种核心用法

### 用法1: 直接透传（identity 函数）

```python
from langchain_core.runnables import RunnablePassthrough

# 最简单的用法：原样返回输入
passthrough = RunnablePassthrough()

result = passthrough.invoke("hello")
print(result)  # "hello"

result = passthrough.invoke({"key": "value"})
print(result)  # {"key": "value"}
```

**使用场景**：
- 在并行链中保持原始输入
- 作为占位符传递数据
- 调试时查看中间数据

---

### 用法2: assign 方法（数据增强）

```python
from langchain_core.runnables import RunnablePassthrough

# 在原有字典基础上添加新字段
chain = RunnablePassthrough.assign(
    new_field=some_runnable
)

result = chain.invoke({"existing": "value"})
# {
#     "existing": "value",  # 保留
#     "new_field": ...      # 新增
# }
```

**使用场景**：
- RAG 管道中添加检索结果
- 多步骤链中累积数据
- 保持上下文的同时添加新信息

---

## 核心设计原理

### 1. Identity 函数的本质

```python
# RunnablePassthrough 的核心就是 identity 函数
def identity(x):
    return x

# 在 LCEL 中的作用
chain = {
    "data": RunnablePassthrough(),  # 等价于 identity
    "processed": some_runnable,
}
```

**为什么需要 identity？**
- 在并行链中，所有分支必须是 Runnable
- 直接传递数据也需要包装成 Runnable
- RunnablePassthrough 就是这个包装器

---

### 2. assign 的实现原理

```python
# assign 的伪代码实现
class RunnablePassthrough:
    @classmethod
    def assign(cls, **kwargs):
        def _assign(input_dict):
            # 1. 复制原始输入
            output = input_dict.copy()

            # 2. 执行所有 runnable 并添加结果
            for key, runnable in kwargs.items():
                output[key] = runnable.invoke(input_dict)

            # 3. 返回扩展后的字典
            return output

        return RunnableLambda(_assign)
```

**关键点**：
- 先复制原始输入（不修改原始数据）
- 每个 runnable 都接收完整的原始输入
- 新字段添加到复制的字典中
- 返回扩展后的新字典

---

## 2025-2026 最佳实践

### 实践1: 使用 assign 而非手动合并

```python
# ❌ 不推荐：手动合并字典
chain = (
    retriever
    | RunnableLambda(lambda docs: {"context": docs, "question": original_question})
    | prompt
    | model
)

# ✅ 推荐：使用 assign
chain = (
    RunnablePassthrough.assign(context=retriever)
    | prompt
    | model
)
```

**原因**：
- assign 更简洁、更易读
- 自动处理字典合并逻辑
- 避免手动管理变量作用域

---

### 实践2: 链式 assign 构建复杂数据

```python
# ✅ 推荐：链式 assign
chain = (
    RunnablePassthrough.assign(context=retriever)
    | RunnablePassthrough.assign(answer=prompt | model)
    | RunnablePassthrough.assign(score=evaluation_chain)
)
```

**优势**：
- 每一步都清晰可见
- 便于调试和修改
- 数据流向一目了然

---

### 实践3: 与 itemgetter 结合使用

```python
from operator import itemgetter

# 当 runnable 需要特定字段时
chain = RunnablePassthrough.assign(
    context=itemgetter("question") | retriever  # 提取 question 字段
)

result = chain.invoke({"question": "...", "user": "Alice"})
# {
#     "question": "...",
#     "user": "Alice",
#     "context": [...]  # retriever 只接收 question
# }
```

**使用场景**：
- runnable 期望字符串但输入是字典
- 需要从字典中提取特定字段
- 避免类型不匹配错误

---

## 性能特性

### 1. 零开销透传

```python
# RunnablePassthrough 本身几乎没有性能开销
passthrough = RunnablePassthrough()

# 只是简单的数据传递，不涉及计算
result = passthrough.invoke(large_data)  # O(1) 时间复杂度
```

---

### 2. assign 的性能考虑

```python
# assign 中的 runnable 会实际执行
chain = RunnablePassthrough.assign(
    field1=expensive_operation1,  # 会执行
    field2=expensive_operation2,  # 会执行
)

# 所有 runnable 串行执行（不是并行）
# 总时间 = field1 时间 + field2 时间
```

**优化建议**：
- 如果多个字段可以并行计算，使用 RunnableParallel
- assign 适合需要依赖前面结果的场景

---

## 常见误区

### 误区1: "RunnablePassthrough 只是占位符"

```python
# ❌ 错误理解：只是占位符，没有实际作用
chain = {"data": RunnablePassthrough()}

# ✅ 正确理解：是一个完整的 Runnable，有明确的语义
# 它的作用是保持数据流的完整性
```

---

### 误区2: "assign 会覆盖已有字段"

```python
# ❌ 错误理解：assign 会覆盖
chain = RunnablePassthrough.assign(text="new value")
result = chain.invoke({"text": "old value"})
# 实际上会报错或产生意外行为

# ✅ 正确理解：assign 不应该覆盖已有字段
# 应该使用不同的键名
chain = RunnablePassthrough.assign(processed_text="new value")
```

---

### 误区3: "RunnablePassthrough 只能用于字典"

```python
# ✅ 直接透传可以用于任何类型
passthrough = RunnablePassthrough()
passthrough.invoke("string")  # ✅
passthrough.invoke(123)       # ✅
passthrough.invoke([1, 2, 3]) # ✅

# ❌ assign 只能用于字典
chain = RunnablePassthrough.assign(new_field=runnable)
chain.invoke("string")  # ❌ 报错：期望字典
```

---

## 核心要点总结

1. **数据透传原语** - LCEL 的三大核心之一
2. **assign 方法** - 最强大的功能，用于数据增强
3. **上下文保持** - RAG 管道中的核心模式
4. **零开销** - 直接透传几乎没有性能损失
5. **链式组合** - 支持多次 assign 逐步构建数据
6. **类型要求** - assign 要求输入必须是字典

---

## 与 RAG 的关系

RunnablePassthrough 在 RAG 管道中扮演关键角色：

```python
# 典型的 RAG 链结构
rag_chain = (
    # 步骤1: 保持问题 + 检索上下文
    RunnablePassthrough.assign(context=retriever)

    # 步骤2: 生成答案（需要访问 question 和 context）
    | RunnablePassthrough.assign(
        answer=prompt | model
    )

    # 步骤3: 评估答案质量（需要访问所有历史数据）
    | RunnablePassthrough.assign(
        quality_score=evaluation_chain
    )
)
```

**为什么 RAG 离不开 RunnablePassthrough？**
- 每一步都需要访问原始问题
- 需要保留所有中间结果用于调试
- 支持多步骤的复杂处理流程

---

## 下一步学习

- **第一性原理** → 理解为什么需要数据透传
- **核心概念** → 深入 assign 方法、数据透传与增强、上下文保持
- **实战代码** → RAG 上下文注入、复杂链构建、生产环境最佳实践
- **最小可用** → 20%核心知识快速上手

---

## 参考资源

**官方文档（2025-2026）**：
- [RunnablePassthrough API Reference](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html) - LangChain 0.3+ 官方文档
- [LCEL Primitives](https://reference.langchain.com/python/langchain_core/runnables) - LCEL 核心原语文档

**2025-2026 最佳实践**：
- [LangChain Expression Language Explained](https://www.pinecone.io/learn/series/langchain/langchain-expression-language) - Pinecone 详细教程
- [Master LangChain in 2025: From RAG to Tools](https://towardsai.net/p/machine-learning/master-langchain-in-2025-from-rag-to-tools-complete-guide) - 2025 完整指南
- [Understanding LangChain Runnables](https://mirascope.com/blog/langchain-runnables) - 全面的 Runnable 指南

**实战教程（2025-2026）**：
- [Runnables in LangChain](https://medium.com/@adarishanmukh15501/runnables-in-langchain-0c5630335685) - 2025 Medium 教程
- [A Practical Walkthrough of LangChain Runnables](https://medium.com/algomart/a-practical-walkthrough-of-langchain-runnables-f3555510a4c6) - 2025 实用指南
- [Implementing Runnables in RAG: Parallel, Lambda & Passthrough](https://www.youtube.com/watch?v=EjXtuSO0aQE) - 2026 视频教程

**源码参考**：
- [RunnablePassthrough Source Code](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/runnables/passthrough.py) - GitHub 源码

---

**版本**: v1.0
**最后更新**: 2026-02-19
**适用**: LangChain 0.3+, Python 3.13+
