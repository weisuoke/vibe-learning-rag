# docker-compose编排 - 实战代码：基础开发环境

## 概述

本文提供一个最简单的 FastAPI + PostgreSQL 开发环境示例，适合快速上手和学习 docker-compose 的基本用法。

**目标：**
- 一键启动 FastAPI + PostgreSQL 开发环境
- 代码热重载
- 数据持久化
- 完整可运行

---

## 1. 项目结构

```
basic-dev-env/
├── docker-compose.yml      # docker-compose 配置
├── Dockerfile              # API 镜像构建
├── requirements.txt        # Python 依赖
├── .env                    # 环境变量
├── .gitignore             # Git 忽略文件
└── app/
    ├── __init__.py
    └── main.py            # FastAPI 应用
```

---

## 2. 文件内容

### 2.1 docker-compose.yml

```yaml
version: '3.8'

services:
  # FastAPI 应用
  api:
    build: .
    container_name: basic-api
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - .:/app  # 代码热重载
    command: uvicorn app.main:app --host 0.0.0.0 --reload

  # PostgreSQL 数据库
  db:
    image: postgres:14-alpine
    container_name: basic-db
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
      timeout: 3s
      retries: 5

volumes:
  postgres_data:
```

**配置说明：**
- `api` 服务：FastAPI 应用，端口 8000
- `db` 服务：PostgreSQL 数据库
- `depends_on` + `condition: service_healthy`：确保数据库就绪后再启动 API
- `volumes: - .:/app`：代码热重载
- `command: --reload`：启用 FastAPI 热重载

### 2.2 Dockerfile

```dockerfile
FROM python:3.13-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制代码（开发环境通过 volume 挂载，这里只是为了镜像完整性）
COPY . .

# 暴露端口
EXPOSE 8000

# 启动命令（会被 docker-compose.yml 中的 command 覆盖）
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0"]
```

### 2.3 requirements.txt

```txt
fastapi==0.109.0
uvicorn[standard]==0.27.0
psycopg2-binary==2.9.9
sqlalchemy==2.0.25
python-dotenv==1.0.0
```

### 2.4 app/main.py

```python
"""
基础 FastAPI 应用
演示：数据库连接、基础 CRUD 操作
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import psycopg2
from psycopg2.extras import RealDictCursor
import os

app = FastAPI(title="Basic Dev Environment")

# 数据库连接配置
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://user:pass@localhost:5432/mydb")


# ===== 数据库连接 =====
def get_db_connection():
    """获取数据库连接"""
    conn = psycopg2.connect(DATABASE_URL, cursor_factory=RealDictCursor)
    return conn


# ===== 数据模型 =====
class Item(BaseModel):
    name: str
    description: str = None


class ItemResponse(BaseModel):
    id: int
    name: str
    description: str = None


# ===== 初始化数据库 =====
@app.on_event("startup")
async def startup():
    """启动时创建表"""
    conn = get_db_connection()
    cursor = conn.cursor()

    # 创建 items 表
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS items (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            description TEXT
        )
    """)

    conn.commit()
    cursor.close()
    conn.close()

    print("✅ Database initialized")


# ===== API 端点 =====
@app.get("/")
async def root():
    """根端点"""
    return {
        "message": "Welcome to Basic Dev Environment",
        "docs": "/docs"
    }


@app.get("/health")
async def health():
    """健康检查"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT 1")
        cursor.close()
        conn.close()
        return {"status": "healthy", "database": "connected"}
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Database error: {str(e)}")


@app.post("/items", response_model=ItemResponse)
async def create_item(item: Item):
    """创建 item"""
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute(
        "INSERT INTO items (name, description) VALUES (%s, %s) RETURNING *",
        (item.name, item.description)
    )

    new_item = cursor.fetchone()
    conn.commit()
    cursor.close()
    conn.close()

    return new_item


@app.get("/items", response_model=list[ItemResponse])
async def list_items():
    """获取所有 items"""
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute("SELECT * FROM items ORDER BY id")
    items = cursor.fetchall()

    cursor.close()
    conn.close()

    return items


@app.get("/items/{item_id}", response_model=ItemResponse)
async def get_item(item_id: int):
    """获取单个 item"""
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute("SELECT * FROM items WHERE id = %s", (item_id,))
    item = cursor.fetchone()

    cursor.close()
    conn.close()

    if not item:
        raise HTTPException(status_code=404, detail="Item not found")

    return item


@app.put("/items/{item_id}", response_model=ItemResponse)
async def update_item(item_id: int, item: Item):
    """更新 item"""
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute(
        "UPDATE items SET name = %s, description = %s WHERE id = %s RETURNING *",
        (item.name, item.description, item_id)
    )

    updated_item = cursor.fetchone()
    conn.commit()
    cursor.close()
    conn.close()

    if not updated_item:
        raise HTTPException(status_code=404, detail="Item not found")

    return updated_item


@app.delete("/items/{item_id}")
async def delete_item(item_id: int):
    """删除 item"""
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute("DELETE FROM items WHERE id = %s RETURNING id", (item_id,))
    deleted = cursor.fetchone()

    conn.commit()
    cursor.close()
    conn.close()

    if not deleted:
        raise HTTPException(status_code=404, detail="Item not found")

    return {"message": "Item deleted"}
```

### 2.5 .env

```bash
# 数据库配置
DATABASE_URL=postgresql://user:pass@db:5432/mydb
POSTGRES_USER=user
POSTGRES_PASSWORD=pass
POSTGRES_DB=mydb
```

### 2.6 .gitignore

```
# Python
__pycache__/
*.py[cod]
*$py.class
.venv/
venv/
ENV/

# 环境变量
.env
.env.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# Docker
.dockerignore
```

### 2.7 app/__init__.py

```python
"""
App package
"""
```

---

## 3. 使用步骤

### 3.1 启动环境

```bash
# 1. 克隆或创建项目
mkdir basic-dev-env && cd basic-dev-env

# 2. 创建所有文件（按照上面的内容）

# 3. 启动服务
docker-compose up

# 或者后台运行
docker-compose up -d
```

**预期输出：**
```
Creating network "basic-dev-env_default" with the default driver
Creating volume "basic-dev-env_postgres_data" with default driver
Creating basic-db ... done
Creating basic-api ... done
Attaching to basic-db, basic-api
basic-db    | PostgreSQL init process complete; ready for start up.
basic-api   | INFO:     Uvicorn running on http://0.0.0.0:8000
basic-api   | ✅ Database initialized
```

### 3.2 测试 API

```bash
# 1. 健康检查
curl http://localhost:8000/health

# 输出
{
  "status": "healthy",
  "database": "connected"
}

# 2. 创建 item
curl -X POST http://localhost:8000/items \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Item", "description": "This is a test"}'

# 输出
{
  "id": 1,
  "name": "Test Item",
  "description": "This is a test"
}

# 3. 获取所有 items
curl http://localhost:8000/items

# 输出
[
  {
    "id": 1,
    "name": "Test Item",
    "description": "This is a test"
  }
]

# 4. 获取单个 item
curl http://localhost:8000/items/1

# 5. 更新 item
curl -X PUT http://localhost:8000/items/1 \
  -H "Content-Type: application/json" \
  -d '{"name": "Updated Item", "description": "Updated description"}'

# 6. 删除 item
curl -X DELETE http://localhost:8000/items/1
```

### 3.3 访问 API 文档

打开浏览器访问：
- Swagger UI: http://localhost:8000/docs
- ReDoc: http://localhost:8000/redoc

### 3.4 测试代码热重载

```bash
# 1. 修改 app/main.py
# 在 root() 函数中添加一行：
@app.get("/")
async def root():
    return {
        "message": "Welcome to Basic Dev Environment",
        "version": "1.0.0",  # 新增
        "docs": "/docs"
    }

# 2. 保存文件

# 3. 查看日志（自动重启）
docker-compose logs -f api

# 输出
basic-api | INFO:     Uvicorn running on http://0.0.0.0:8000
basic-api | INFO:     Application startup complete.
basic-api | WARNING:  StatReload detected changes in 'app/main.py'. Reloading...

# 4. 测试修改
curl http://localhost:8000/

# 输出（包含新增的 version 字段）
{
  "message": "Welcome to Basic Dev Environment",
  "version": "1.0.0",
  "docs": "/docs"
}
```

### 3.5 查看日志

```bash
# 查看所有服务日志
docker-compose logs

# 查看 API 日志
docker-compose logs api

# 实时查看日志
docker-compose logs -f

# 查看最近 100 行日志
docker-compose logs --tail=100
```

### 3.6 进入容器

```bash
# 进入 API 容器
docker-compose exec api bash

# 进入数据库容器
docker-compose exec db psql -U user -d mydb

# 在数据库中查询
mydb=# SELECT * FROM items;
mydb=# \dt  # 查看所有表
mydb=# \q   # 退出
```

### 3.7 停止环境

```bash
# 停止服务
docker-compose down

# 停止并删除数据卷（数据会丢失！）
docker-compose down -v
```

---

## 4. 常见操作

### 4.1 重建镜像

```bash
# 修改 Dockerfile 或 requirements.txt 后
docker-compose build

# 重建并启动
docker-compose up --build
```

### 4.2 查看运行状态

```bash
docker-compose ps

# 输出
NAME         STATUS         PORTS
basic-api    Up 2 minutes   0.0.0.0:8000->8000/tcp
basic-db     Up 2 minutes   5432/tcp
```

### 4.3 重启服务

```bash
# 重启所有服务
docker-compose restart

# 重启单个服务
docker-compose restart api
```

### 4.4 查看资源使用

```bash
docker stats

# 输出
CONTAINER    CPU %    MEM USAGE / LIMIT    MEM %
basic-api    0.5%     50MB / 1GB           5%
basic-db     0.2%     30MB / 1GB           3%
```

---

## 5. 故障排查

### 5.1 API 无法连接数据库

**问题：**
```
psycopg2.OperationalError: could not connect to server
```

**原因：** 数据库还未就绪

**解决：**
```yaml
# 确保使用了健康检查
services:
  api:
    depends_on:
      db:
        condition: service_healthy  # 等待健康检查通过

  db:
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
```

### 5.2 代码修改后未生效

**问题：** 修改代码后，API 没有自动重启

**原因：** 未启用热重载或 volume 未正确挂载

**解决：**
```yaml
services:
  api:
    volumes:
      - .:/app  # 确保挂载了代码目录
    command: uvicorn app.main:app --host 0.0.0.0 --reload  # 确保有 --reload
```

### 5.3 端口被占用

**问题：**
```
Error: Bind for 0.0.0.0:8000 failed: port is already allocated
```

**解决：**
```bash
# 方法1：停止占用端口的进程
lsof -ti:8000 | xargs kill -9

# 方法2：修改端口
# docker-compose.yml
ports:
  - "8001:8000"  # 使用不同的主机端口
```

### 5.4 数据丢失

**问题：** 重启后数据丢失

**原因：** 使用了 `docker-compose down -v`

**解决：**
```bash
# 停止服务但保留数据卷
docker-compose down

# 不要使用 -v 参数
# docker-compose down -v  # ❌ 会删除数据卷
```

---

## 6. 扩展练习

### 6.1 添加 Redis 缓存

```yaml
services:
  redis:
    image: redis:7-alpine
    container_name: basic-redis
    ports:
      - "6379:6379"
```

### 6.2 添加 pgAdmin

```yaml
services:
  pgadmin:
    image: dpage/pgadmin4
    container_name: basic-pgadmin
    ports:
      - "5050:80"
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@example.com
      - PGADMIN_DEFAULT_PASSWORD=admin
```

访问：http://localhost:5050

### 6.3 添加环境变量文件

```yaml
services:
  api:
    env_file:
      - .env
```

---

## 7. 学习要点

### 7.1 核心概念

1. **服务定义**：`services` 定义多个容器
2. **依赖管理**：`depends_on` + `healthcheck` 确保启动顺序
3. **数据持久化**：`volumes` 保存数据库数据
4. **代码热重载**：`volumes` 挂载代码 + `--reload` 参数
5. **网络通信**：服务间通过服务名访问（`db:5432`）

### 7.2 最佳实践

1. ✅ 使用健康检查确保服务就绪
2. ✅ 使用命名卷持久化数据库数据
3. ✅ 使用绑定挂载实现代码热重载
4. ✅ 使用环境变量配置
5. ✅ 不要提交 `.env` 文件到 Git

### 7.3 常见错误

1. ❌ 忘记添加健康检查
2. ❌ 使用 `docker-compose down -v` 删除数据
3. ❌ 端口冲突
4. ❌ 环境变量配置错误
5. ❌ 代码挂载路径错误

---

## 8. 下一步

学完本示例后，可以继续学习：

1. **完整开发环境**：添加 Redis、pgAdmin 等工具
2. **多环境配置**：开发/测试/生产环境分离
3. **生产级配置**：资源限制、日志管理、监控

---

## 9. 完整代码仓库

所有代码可以在以下位置找到：
```
examples/docker-compose/01-basic-dev-env/
```

---

## 10. 总结

**本示例演示了：**
1. ✅ FastAPI + PostgreSQL 基础开发环境
2. ✅ 代码热重载
3. ✅ 数据持久化
4. ✅ 健康检查和依赖管理
5. ✅ 基础 CRUD 操作

**核心配置：**
- `depends_on` + `condition: service_healthy`：确保数据库就绪
- `volumes: - .:/app`：代码热重载
- `volumes: - postgres_data:/var/lib/postgresql/data`：数据持久化
- `command: --reload`：启用热重载

**适用场景：**
- 快速上手 docker-compose
- 本地开发环境
- 学习和实验

---

**版本：** v1.0
**最后更新：** 2026-02-12
**预计学习时间：** 30-60 分钟
