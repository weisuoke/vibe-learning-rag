# 第一性原理

> 回到最基础的真理，从源头思考路由与依赖注入

---

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题，而不是通过类比或经验。

在软件工程中，第一性原理帮助我们理解：
- 为什么需要这个概念？
- 它解决了什么根本问题？
- 从最基础的需求如何推导出这个设计？

---

## 路由与依赖注入的第一性原理

### 1. 最基础的定义

**路由 = 将 HTTP 请求映射到处理函数**

```
HTTP 请求（URL + 方法） → 路由系统 → 处理函数 → HTTP 响应
```

仅此而已！没有更基础的了。

**依赖注入 = 将函数需要的资源从外部传入，而不是在函数内部创建**

```
函数需要资源 → 依赖注入系统 → 自动提供资源 → 函数执行
```

仅此而已！没有更基础的了。

---

### 2. 为什么需要路由与依赖注入？

#### 核心问题1：如何处理不同的 HTTP 请求？

**最原始的方式：**
```python
# 没有路由系统，手动判断
def handle_request(method: str, path: str, body: dict):
    if method == "GET" and path == "/users":
        return get_users()
    elif method == "GET" and path.startswith("/users/"):
        user_id = path.split("/")[-1]
        return get_user(user_id)
    elif method == "POST" and path == "/users":
        return create_user(body)
    elif method == "PUT" and path.startswith("/users/"):
        user_id = path.split("/")[-1]
        return update_user(user_id, body)
    else:
        return {"error": "Not found"}, 404
```

**问题：**
- ❌ 代码冗长，难以维护
- ❌ 路径解析容易出错
- ❌ 添加新路由需要修改主函数
- ❌ 无法复用路径解析逻辑

**路由系统的解决方案：**
```python
# 用装饰器声明路由
@app.get("/users")
def get_users():
    return users

@app.get("/users/{user_id}")
def get_user(user_id: int):
    return users[user_id]

@app.post("/users")
def create_user(user: User):
    return user
```

**优势：**
- ✅ 声明式，清晰直观
- ✅ 自动解析路径参数
- ✅ 添加新路由不影响其他代码
- ✅ 框架处理路径匹配

---

#### 核心问题2：如何管理函数的依赖资源？

**最原始的方式：**
```python
# 方式1：全局变量（危险）
db_connection = create_db_connection()

def get_users():
    users = db_connection.query(User).all()
    return users

# 问题：
# - 多个请求共享同一个连接（并发问题）
# - 无法在测试时替换
# - 资源泄漏（忘记关闭连接）
```

```python
# 方式2：手动传递（繁琐）
def get_users(db_connection):
    users = db_connection.query(User).all()
    return users

def get_user_posts(user_id, db_connection):
    user = db_connection.query(User).get(user_id)
    posts = db_connection.query(Post).filter_by(user_id=user_id).all()
    return posts

# 问题：
# - 每个函数都要手动传递 db_connection
# - 调用链很长时，中间函数也要传递
# - 添加新依赖需要修改所有函数签名
```

**依赖注入的解决方案：**
```python
# 定义依赖
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 使用依赖
@app.get("/users")
def get_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users

@app.get("/users/{user_id}/posts")
def get_user_posts(user_id: int, db: Session = Depends(get_db)):
    posts = db.query(Post).filter_by(user_id=user_id).all()
    return posts
```

**优势：**
- ✅ 自动管理资源生命周期
- ✅ 每个请求独立的资源
- ✅ 易于测试（可以替换依赖）
- ✅ 添加新依赖不影响调用方

---

### 3. 路由与依赖注入的三层价值

#### 价值1：声明式编程（Declarative Programming）

**命令式 vs 声明式：**

```python
# 命令式：告诉计算机"怎么做"
def handle_request(method, path, body):
    if method == "GET":
        if path == "/users":
            return get_users()
        elif path.startswith("/users/"):
            user_id = extract_user_id(path)
            return get_user(user_id)
    elif method == "POST":
        if path == "/users":
            return create_user(body)
    # ... 更多判断

# 声明式：告诉计算机"要什么"
@app.get("/users")
def get_users():
    return users

@app.get("/users/{user_id}")
def get_user(user_id: int):
    return users[user_id]

@app.post("/users")
def create_user(user: User):
    return user
```

**为什么声明式更好？**
- 代码更接近业务逻辑（"这是一个获取用户的接口"）
- 框架处理底层细节（路径匹配、参数解析）
- 更容易理解和维护

---

#### 价值2：关注点分离（Separation of Concerns）

**混合关注点：**
```python
def get_user_profile(user_id: int):
    # 关注点1：数据库连接管理
    db = create_db_connection()
    try:
        # 关注点2：认证授权
        token = get_token_from_header()
        if not validate_token(token):
            raise AuthError()

        # 关注点3：业务逻辑
        user = db.query(User).get(user_id)
        if not user:
            raise NotFoundError()

        # 关注点4：权限检查
        if not has_permission(token, user_id):
            raise PermissionError()

        return user
    finally:
        # 关注点1：资源清理
        db.close()
```

**分离关注点：**
```python
# 关注点1：数据库连接管理
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 关注点2：认证授权
def get_current_user(token: str = Header(...)):
    if not validate_token(token):
        raise HTTPException(status_code=401)
    return decode_token(token)

# 关注点3：权限检查
def check_permission(user: User = Depends(get_current_user)):
    if not user.has_permission():
        raise HTTPException(status_code=403)
    return user

# 关注点4：业务逻辑（纯粹）
@app.get("/users/{user_id}")
def get_user_profile(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_permission)
):
    user = db.query(User).get(user_id)
    if not user:
        raise HTTPException(status_code=404)
    return user
```

**为什么分离更好？**
- 每个函数只做一件事
- 依赖可以复用（多个路由共享认证逻辑）
- 易于测试（可以单独测试每个关注点）

---

#### 价值3：控制反转（Inversion of Control）

**传统控制流：**
```python
# 函数控制依赖的创建和销毁
def get_users():
    db = create_db_connection()  # 函数创建依赖
    try:
        users = db.query(User).all()
        return users
    finally:
        db.close()  # 函数销毁依赖
```

**控制反转：**
```python
# 框架控制依赖的创建和销毁
def get_db():
    db = SessionLocal()
    try:
        yield db  # 框架注入依赖
    finally:
        db.close()  # 框架销毁依赖

@app.get("/users")
def get_users(db: Session = Depends(get_db)):
    # 函数只关注业务逻辑
    users = db.query(User).all()
    return users
```

**为什么控制反转更好？**
- 函数不需要知道依赖如何创建
- 框架统一管理资源生命周期
- 易于替换依赖实现（测试、不同环境）

---

### 4. 从第一性原理推导 AI Agent API 设计

**推理链：**

```
1. AI Agent 需要处理用户的对话请求
   ↓
2. 对话请求是 HTTP POST 请求，需要路由系统
   ↓
3. 处理对话需要：数据库连接、LLM 客户端、用户认证
   ↓
4. 这些依赖应该由框架管理，而不是在业务逻辑中创建
   ↓
5. 使用依赖注入，将依赖从外部注入
   ↓
6. 业务逻辑只关注对话处理，不关注资源管理
   ↓
7. 得到清晰、可维护的 AI Agent API
```

**实际代码：**

```python
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session
from openai import OpenAI
from pydantic import BaseModel

app = FastAPI()

# 依赖1：数据库连接
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 依赖2：LLM 客户端
def get_llm_client():
    return OpenAI(api_key=settings.OPENAI_API_KEY)

# 依赖3：当前用户
def get_current_user(
    token: str = Header(...),
    db: Session = Depends(get_db)
):
    user = authenticate_user(db, token)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid token")
    return user

# 请求模型
class ChatRequest(BaseModel):
    message: str
    conversation_id: str | None = None

# 响应模型
class ChatResponse(BaseModel):
    reply: str
    conversation_id: str

# 路由：对话接口（业务逻辑纯粹）
@app.post("/chat", response_model=ChatResponse)
async def chat(
    request: ChatRequest,
    db: Session = Depends(get_db),
    llm: OpenAI = Depends(get_llm_client),
    user: User = Depends(get_current_user)
):
    # 1. 加载对话历史
    conversation = load_conversation(db, request.conversation_id, user.id)

    # 2. 调用 LLM
    messages = conversation.messages + [{"role": "user", "content": request.message}]
    response = llm.chat.completions.create(
        model="gpt-4",
        messages=messages
    )
    reply = response.choices[0].message.content

    # 3. 保存对话
    save_message(db, conversation.id, "user", request.message)
    save_message(db, conversation.id, "assistant", reply)

    return ChatResponse(reply=reply, conversation_id=conversation.id)
```

**从第一性原理看这个设计：**

1. **路由系统**：`@app.post("/chat")` 声明这是一个 POST 接口
2. **请求验证**：`ChatRequest` 自动验证请求体
3. **依赖注入**：`Depends()` 自动注入数据库、LLM、用户
4. **响应模型**：`response_model=ChatResponse` 定义响应格式
5. **业务逻辑**：函数只关注对话处理，不关注资源管理

---

### 5. 一句话总结第一性原理

**路由与依赖注入是将 HTTP 请求映射到处理函数、将函数需要的资源从外部注入的机制，通过声明式编程、关注点分离、控制反转，实现了清晰、可维护的 API 设计。**

---

## 从第一性原理理解常见模式

### 模式1：数据库连接管理

**问题：** 如何确保每个请求有独立的数据库连接，且请求结束后自动关闭？

**第一性原理推导：**
```
1. 数据库连接是有限资源，需要管理生命周期
   ↓
2. 每个请求应该有独立的连接（避免并发问题）
   ↓
3. 请求结束后应该自动关闭连接（避免资源泄漏）
   ↓
4. 使用生成器（yield）+ 依赖注入
   ↓
5. 框架在请求开始时创建连接，请求结束时关闭连接
```

**实现：**
```python
def get_db():
    db = SessionLocal()  # 请求开始：创建连接
    try:
        yield db  # 注入到路由函数
    finally:
        db.close()  # 请求结束：关闭连接

@app.get("/users")
def get_users(db: Session = Depends(get_db)):
    return db.query(User).all()
```

---

### 模式2：认证授权

**问题：** 如何保护 API 端点，只允许认证用户访问？

**第一性原理推导：**
```
1. 某些接口需要认证才能访问
   ↓
2. 认证逻辑应该复用（多个接口共享）
   ↓
3. 认证失败应该返回 401 错误
   ↓
4. 使用依赖注入，将认证逻辑提取为依赖
   ↓
5. 需要认证的接口声明依赖，框架自动执行认证
```

**实现：**
```python
def get_current_user(token: str = Header(...)):
    user = verify_token(token)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid token")
    return user

# 公开接口：不需要认证
@app.get("/public")
def public_endpoint():
    return {"message": "Public"}

# 受保护接口：需要认证
@app.get("/profile")
def get_profile(user: User = Depends(get_current_user)):
    return {"username": user.username}
```

---

### 模式3：依赖链

**问题：** 如何处理依赖的依赖？（例如：获取用户需要数据库连接）

**第一性原理推导：**
```
1. 获取当前用户需要查询数据库
   ↓
2. 查询数据库需要数据库连接
   ↓
3. 数据库连接也是依赖
   ↓
4. 依赖可以依赖其他依赖（依赖链）
   ↓
5. 框架自动解析依赖链，按顺序注入
```

**实现：**
```python
# 依赖1：数据库连接
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 依赖2：当前用户（依赖于 get_db）
def get_current_user(
    token: str = Header(...),
    db: Session = Depends(get_db)  # 依赖链
):
    user = db.query(User).filter_by(token=token).first()
    if not user:
        raise HTTPException(status_code=401)
    return user

# 路由：使用依赖链
@app.get("/profile")
def get_profile(user: User = Depends(get_current_user)):
    # 框架自动执行：
    # 1. 调用 get_db() 创建数据库连接
    # 2. 调用 get_current_user(db) 获取用户
    # 3. 注入 user 到路由函数
    return {"username": user.username}
```

---

## 与其他框架的对比

### Express (Node.js)

```javascript
// Express：中间件模式
app.get('/profile', authMiddleware, (req, res) => {
  // req.user 由中间件设置
  res.json({ username: req.user.username })
})

// 问题：
// - 中间件修改 req 对象（隐式依赖）
// - 类型不安全（TypeScript 也无法推断 req.user）
// - 难以测试（需要模拟整个 req 对象）
```

```python
# FastAPI：依赖注入
@app.get("/profile")
def get_profile(user: User = Depends(get_current_user)):
    return {"username": user.username}

# 优势：
# - 显式依赖（函数签名清晰）
# - 类型安全（user 是 User 类型）
# - 易于测试（可以直接传入 mock user）
```

---

### Spring (Java)

```java
// Spring：注解 + 依赖注入
@RestController
public class UserController {
    @Autowired
    private UserService userService;  // 字段注入

    @GetMapping("/users")
    public List<User> getUsers() {
        return userService.findAll();
    }
}

// 问题：
// - 字段注入（隐式依赖）
// - 需要配置类和 XML
// - 重量级框架
```

```python
# FastAPI：函数参数注入
@app.get("/users")
def get_users(db: Session = Depends(get_db)):
    return db.query(User).all()

# 优势：
# - 函数参数注入（显式依赖）
# - 无需配置类
# - 轻量级
```

---

## 总结：第一性原理的启示

1. **路由系统的本质**：将 HTTP 请求映射到处理函数
   - 声明式编程：用装饰器声明路由
   - 自动解析：框架处理路径匹配和参数解析

2. **依赖注入的本质**：将函数需要的资源从外部传入
   - 关注点分离：业务逻辑与资源管理分离
   - 控制反转：框架管理资源生命周期

3. **组合的力量**：路由 + 依赖注入 = 清晰的 API 设计
   - 每个函数只做一件事
   - 依赖可以复用
   - 易于测试和维护

---

**记住：** 理解第一性原理，不仅知道"怎么用"，更知道"为什么这样设计"！
