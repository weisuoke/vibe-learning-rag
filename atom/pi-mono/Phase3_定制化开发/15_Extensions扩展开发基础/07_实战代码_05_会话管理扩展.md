# Extensions 扩展开发基础 - 实战代码 05：会话管理扩展

> 通过会话事件和状态持久化实现会话管理功能

---

## 1. 场景介绍

### 1.1 为什么需要会话管理扩展？

在 AI Agent 开发中，会话管理是核心功能之一：

**场景 1：会话命名**
```
需求：给会话设置友好的名称
问题：默认显示第一条消息，不够清晰
解决：使用 setSessionName 设置自定义名称
```

**场景 2：状态持久化**
```
需求：在会话中保存 Todo 列表
问题：刷新后数据丢失
解决：通过 tool result details 持久化状态
```

**场景 3：会话分支管理**
```
需求：在分支时恢复代码状态
问题：分支后代码状态不一致
解决：监听 session_before_fork 事件，恢复状态
```

### 1.2 会话管理的核心概念

**会话事件（Session Events）**：
```typescript
// 会话生命周期事件
"session_start"        // 会话开始
"session_switch"       // 切换会话
"session_fork"         // 分支会话
"session_before_fork"  // 分支前（可以阻止或准备）
"session_tree"         // 查看会话树
"session_end"          // 会话结束
```

**会话 API**：
```typescript
// 设置会话名称
pi.setSessionName(name: string): void;

// 获取会话名称
pi.getSessionName(): string | undefined;

// 设置会话标签（书签）
ctx.session.setLabel(label: string): void;

// 获取会话管理器
ctx.sessionManager: SessionManager;
```

**状态持久化模式**：
```typescript
// 通过 tool result details 保存状态
return {
  content: [{ type: "text", text: "Result" }],
  details: {
    // 这些数据会保存到 session 中
    todos: [...todos],
    nextId: nextId,
  },
};

// 从 session 重建状态
for (const entry of ctx.sessionManager.getBranch()) {
  if (entry.type === "message" && entry.message.role === "toolResult") {
    const details = entry.message.details;
    // 恢复状态
  }
}
```

### 1.3 技术要点

- **会话事件监听**：监听会话生命周期事件
- **状态持久化**：通过 details 字段保存状态
- **状态重建**：从 session 历史重建状态
- **会话命名**：使用 setSessionName 设置友好名称
- **分支管理**：在分支时恢复或重置状态

---

## 2. 完整实现

### 2.1 基础版本：会话命名

```typescript
/**
 * Session Naming Extension - 会话命名
 *
 * 功能：
 * - /session-name [name]: 设置或显示会话名称
 * - 自动在会话选择器中显示友好名称
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  pi.registerCommand("session-name", {
    description: "Set or show session name (usage: /session-name [new name])",
    handler: async (args, ctx) => {
      const name = args.trim();

      if (name) {
        // 设置会话名称
        pi.setSessionName(name);
        ctx.ui.notify(`Session named: ${name}`, "success");
      } else {
        // 显示当前会话名称
        const current = pi.getSessionName();
        ctx.ui.notify(
          current ? `Session: ${current}` : "No session name set",
          "info"
        );
      }
    },
  });

  // 自动命名：根据第一条用户消息
  pi.on("user_message", async (event, ctx) => {
    const currentName = pi.getSessionName();

    // 如果还没有名称，使用第一条消息的前 50 个字符
    if (!currentName && event.text) {
      const autoName = event.text.slice(0, 50);
      pi.setSessionName(autoName);
    }
  });
}
```

### 2.2 进阶版本：状态持久化（Todo 列表）

```typescript
/**
 * Todo State Management Extension - Todo 状态持久化
 *
 * 功能：
 * - 通过 tool result details 持久化 Todo 状态
 * - 会话切换/分支时自动重建状态
 * - 支持 list、add、toggle、clear 操作
 */

import { StringEnum } from "@mariozechner/pi-ai";
import type { ExtensionAPI, ExtensionContext } from "@mariozechner/pi-coding-agent";
import { Type } from "@sinclair/typebox";

interface Todo {
  id: number;
  text: string;
  done: boolean;
}

interface TodoDetails {
  action: "list" | "add" | "toggle" | "clear";
  todos: Todo[];
  nextId: number;
  error?: string;
}

const TodoParams = Type.Object({
  action: StringEnum(["list", "add", "toggle", "clear"] as const),
  text: Type.Optional(Type.String({ description: "Todo text (for add)" })),
  id: Type.Optional(Type.Number({ description: "Todo ID (for toggle)" })),
});

export default function (pi: ExtensionAPI) {
  // 内存中的状态（从 session 重建）
  let todos: Todo[] = [];
  let nextId = 1;

  /**
   * 从 session 重建状态
   * 扫描 tool results 并按顺序应用
   */
  const reconstructState = (ctx: ExtensionContext) => {
    todos = [];
    nextId = 1;

    // 遍历当前分支的所有条目
    for (const entry of ctx.sessionManager.getBranch()) {
      if (entry.type !== "message") continue;
      const msg = entry.message;
      if (msg.role !== "toolResult" || msg.toolName !== "todo") continue;

      // 从 details 恢复状态
      const details = msg.details as TodoDetails | undefined;
      if (details) {
        todos = details.todos;
        nextId = details.nextId;
      }
    }
  };

  // 会话事件：重建状态
  pi.on("session_start", async (_event, ctx) => reconstructState(ctx));
  pi.on("session_switch", async (_event, ctx) => reconstructState(ctx));
  pi.on("session_fork", async (_event, ctx) => reconstructState(ctx));
  pi.on("session_tree", async (_event, ctx) => reconstructState(ctx));

  // 注册 todo 工具
  pi.registerTool({
    name: "todo",
    label: "Todo",
    description: "Manage a todo list. Actions: list, add (text), toggle (id), clear",
    parameters: TodoParams,

    async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
      switch (params.action) {
        case "list":
          return {
            content: [
              {
                type: "text",
                text: todos.length
                  ? todos.map((t) => `[${t.done ? "x" : " "}] #${t.id}: ${t.text}`).join("\n")
                  : "No todos",
              },
            ],
            details: { action: "list", todos: [...todos], nextId } as TodoDetails,
          };

        case "add": {
          if (!params.text) {
            return {
              content: [{ type: "text", text: "Error: text required for add" }],
              details: {
                action: "add",
                todos: [...todos],
                nextId,
                error: "text required",
              } as TodoDetails,
            };
          }
          const newTodo: Todo = { id: nextId++, text: params.text, done: false };
          todos.push(newTodo);
          return {
            content: [{ type: "text", text: `Added todo #${newTodo.id}: ${newTodo.text}` }],
            details: { action: "add", todos: [...todos], nextId } as TodoDetails,
          };
        }

        case "toggle": {
          if (params.id === undefined) {
            return {
              content: [{ type: "text", text: "Error: id required for toggle" }],
              details: {
                action: "toggle",
                todos: [...todos],
                nextId,
                error: "id required",
              } as TodoDetails,
            };
          }
          const todo = todos.find((t) => t.id === params.id);
          if (!todo) {
            return {
              content: [{ type: "text", text: `Todo #${params.id} not found` }],
              details: {
                action: "toggle",
                todos: [...todos],
                nextId,
                error: `#${params.id} not found`,
              } as TodoDetails,
            };
          }
          todo.done = !todo.done;
          return {
            content: [
              { type: "text", text: `Todo #${todo.id} ${todo.done ? "completed" : "uncompleted"}` }
            ],
            details: { action: "toggle", todos: [...todos], nextId } as TodoDetails,
          };
        }

        case "clear": {
          const count = todos.length;
          todos = [];
          nextId = 1;
          return {
            content: [{ type: "text", text: `Cleared ${count} todos` }],
            details: { action: "clear", todos: [], nextId: 1 } as TodoDetails,
          };
        }

        default:
          return {
            content: [{ type: "text", text: `Unknown action: ${params.action}` }],
            details: {
              action: "list",
              todos: [...todos],
              nextId,
              error: `unknown action: ${params.action}`,
            } as TodoDetails,
          };
      }
    },
  });

  // 注册 /todos 命令
  pi.registerCommand("todos", {
    description: "Show all todos on the current branch",
    handler: async (_args, ctx) => {
      if (todos.length === 0) {
        ctx.ui.notify("No todos yet", "info");
        return;
      }

      const lines = todos.map((t) => {
        const check = t.done ? "✓" : "○";
        return `${check} #${t.id}: ${t.text}`;
      });

      ctx.ui.notify(`Todos:\n${lines.join("\n")}`, "info");
    },
  });
}
```

### 2.3 高级版本：会话书签与标签

```typescript
/**
 * Session Bookmarks Extension - 会话书签
 *
 * 功能：
 * - 为重要的会话点设置书签
 * - 列出所有书签
 * - 跳转到书签位置
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  // 注册 /bookmark 命令
  pi.registerCommand("bookmark", {
    description: "Set a bookmark at the current position (usage: /bookmark [label])",
    handler: async (args, ctx) => {
      const label = args.trim() || `Bookmark ${Date.now()}`;

      // 设置书签（使用 session label）
      ctx.session.setLabel(label);

      ctx.ui.notify(`Bookmark set: ${label}`, "success");
    },
  });

  // 注册 /bookmarks 命令
  pi.registerCommand("bookmarks", {
    description: "List all bookmarks in the current session",
    handler: async (_args, ctx) => {
      // 获取所有带标签的条目
      const bookmarks: Array<{ id: string; label: string }> = [];

      for (const entry of ctx.sessionManager.getBranch()) {
        if (entry.label) {
          bookmarks.push({
            id: entry.id,
            label: entry.label,
          });
        }
      }

      if (bookmarks.length === 0) {
        ctx.ui.notify("No bookmarks found", "info");
        return;
      }

      // 显示书签列表
      const lines = bookmarks.map((b, i) => `${i + 1}. ${b.label} (${b.id.slice(0, 8)})`);
      ctx.ui.notify(`Bookmarks:\n${lines.join("\n")}`, "info");
    },
  });

  // 自动书签：在重要事件时设置
  pi.on("tool_result", async (event, ctx) => {
    // 如果工具执行失败，自动设置书签
    if (event.result.details?.error) {
      const label = `Error: ${event.toolName} failed`;
      ctx.session.setLabel(label);
    }
  });
}
```

---

## 3. 代码解析

### 3.1 会话事件监听

```typescript
// 会话开始（新会话或重新加载）
pi.on("session_start", async (event, ctx) => {
  console.log("Session started:", ctx.session.id);
});

// 切换到其他会话
pi.on("session_switch", async (event, ctx) => {
  console.log("Switched to session:", ctx.session.id);
});

// 分支会话（创建新分支）
pi.on("session_fork", async (event, ctx) => {
  console.log("Forked from entry:", event.entryId);
});

// 分支前（可以阻止或准备）
pi.on("session_before_fork", async (event, ctx) => {
  console.log("About to fork from:", event.entryId);
  // 可以返回 { block: true } 阻止分支
});

// 查看会话树
pi.on("session_tree", async (event, ctx) => {
  console.log("Viewing session tree");
});

// 会话结束
pi.on("session_end", async (event, ctx) => {
  console.log("Session ended:", ctx.session.id);
});
```

### 3.2 状态持久化机制

```typescript
// 1. 保存状态到 tool result details
pi.registerTool({
  name: "my-tool",
  // ...
  async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
    // 执行逻辑...

    return {
      content: [{ type: "text", text: "Result" }],
      details: {
        // 这些数据会保存到 session 中
        state: myState,
        timestamp: Date.now(),
      },
    };
  },
});

// 2. 从 session 重建状态
const reconstructState = (ctx: ExtensionContext) => {
  myState = initialState;

  for (const entry of ctx.sessionManager.getBranch()) {
    if (entry.type !== "message") continue;
    const msg = entry.message;
    if (msg.role !== "toolResult" || msg.toolName !== "my-tool") continue;

    const details = msg.details;
    if (details) {
      myState = details.state;
    }
  }
};

// 3. 在会话事件中重建状态
pi.on("session_start", async (_event, ctx) => reconstructState(ctx));
pi.on("session_switch", async (_event, ctx) => reconstructState(ctx));
pi.on("session_fork", async (_event, ctx) => reconstructState(ctx));
```

**为什么使用 details 而不是外部文件？**
- **分支安全**：分支时状态自动正确
- **历史完整**：状态变化记录在 session 中
- **无需清理**：不会留下临时文件
- **可回溯**：可以查看任意时间点的状态

### 3.3 SessionManager API

```typescript
interface SessionManager {
  // 获取当前分支的所有条目
  getBranch(): SessionEntry[];

  // 获取叶子节点（最新条目）
  getLeafEntry(): SessionEntry | undefined;

  // 获取特定条目
  getEntry(id: string): SessionEntry | undefined;

  // 获取父条目
  getParent(entry: SessionEntry): SessionEntry | undefined;

  // 获取子条目
  getChildren(entry: SessionEntry): SessionEntry[];
}

interface SessionEntry {
  id: string;                    // 条目 ID
  type: "message" | "fork";      // 条目类型
  message?: Message;             // 消息内容
  label?: string;                // 标签（书签）
  timestamp: number;             // 时间戳
}
```

### 3.4 会话命名 API

```typescript
// 设置会话名称
pi.setSessionName("My Project Session");

// 获取会话名称
const name = pi.getSessionName();
console.log(name); // "My Project Session"

// 清除会话名称
pi.setSessionName("");

// 会话名称会显示在会话选择器中
// 如果没有设置名称，显示第一条消息
```

---

## 4. 变体与扩展

### 4.1 会话元数据管理

```typescript
export default function (pi: ExtensionAPI) {
  // 在 session metadata 中保存自定义数据
  pi.on("session_start", async (_event, ctx) => {
    // 初始化元数据
    if (!ctx.session.metadata) {
      ctx.session.metadata = {};
    }

    ctx.session.metadata.startTime = Date.now();
    ctx.session.metadata.toolCallCount = 0;
  });

  // 更新元数据
  pi.on("tool_call", async (_event, ctx) => {
    if (ctx.session.metadata) {
      ctx.session.metadata.toolCallCount =
        (ctx.session.metadata.toolCallCount || 0) + 1;
    }
    return undefined;
  });

  // 显示元数据
  pi.registerCommand("session-info", {
    description: "Show session metadata",
    handler: async (_args, ctx) => {
      const meta = ctx.session.metadata || {};
      const lines = Object.entries(meta).map(([key, value]) => `${key}: ${value}`);
      ctx.ui.notify(`Session Info:\n${lines.join("\n")}`, "info");
    },
  });
}
```

### 4.2 会话自动保存

```typescript
export default function (pi: ExtensionAPI) {
  let lastSaveTime = 0;
  const SAVE_INTERVAL = 5 * 60 * 1000; // 5 分钟

  // 定期自动保存
  pi.on("tool_result", async (_event, ctx) => {
    const now = Date.now();

    if (now - lastSaveTime > SAVE_INTERVAL) {
      // 设置书签作为自动保存点
      const timestamp = new Date().toLocaleString();
      ctx.session.setLabel(`Auto-save: ${timestamp}`);
      lastSaveTime = now;

      ctx.ui.notify("Session auto-saved", "info");
    }
  });
}
```

### 4.3 会话统计

```typescript
export default function (pi: ExtensionAPI) {
  interface SessionStats {
    messageCount: number;
    toolCallCount: number;
    errorCount: number;
    startTime: number;
  }

  let stats: SessionStats = {
    messageCount: 0,
    toolCallCount: 0,
    errorCount: 0,
    startTime: Date.now(),
  };

  // 重置统计
  const resetStats = () => {
    stats = {
      messageCount: 0,
      toolCallCount: 0,
      errorCount: 0,
      startTime: Date.now(),
    };
  };

  // 会话开始
  pi.on("session_start", async (_event, _ctx) => {
    resetStats();
  });

  // 会话切换
  pi.on("session_switch", async (_event, _ctx) => {
    resetStats();
  });

  // 统计消息
  pi.on("user_message", async (_event, _ctx) => {
    stats.messageCount++;
  });

  // 统计工具调用
  pi.on("tool_call", async (_event, _ctx) => {
    stats.toolCallCount++;
    return undefined;
  });

  // 统计错误
  pi.on("tool_result", async (event, _ctx) => {
    if (event.result.details?.error) {
      stats.errorCount++;
    }
  });

  // 显示统计
  pi.registerCommand("session-stats", {
    description: "Show session statistics",
    handler: async (_args, ctx) => {
      const uptime = Math.floor((Date.now() - stats.startTime) / 1000);
      const minutes = Math.floor(uptime / 60);
      const seconds = uptime % 60;

      const lines = [
        `Messages: ${stats.messageCount}`,
        `Tool Calls: ${stats.toolCallCount}`,
        `Errors: ${stats.errorCount}`,
        `Uptime: ${minutes}m ${seconds}s`,
      ];

      ctx.ui.notify(`Session Statistics:\n${lines.join("\n")}`, "info");
    },
  });
}
```

---

## 5. 错误处理

### 5.1 状态重建失败

```typescript
const reconstructState = (ctx: ExtensionContext) => {
  try {
    todos = [];
    nextId = 1;

    for (const entry of ctx.sessionManager.getBranch()) {
      if (entry.type !== "message") continue;
      const msg = entry.message;
      if (msg.role !== "toolResult" || msg.toolName !== "todo") continue;

      const details = msg.details as TodoDetails | undefined;
      if (details) {
        // 验证数据完整性
        if (Array.isArray(details.todos) && typeof details.nextId === "number") {
          todos = details.todos;
          nextId = details.nextId;
        } else {
          console.warn("Invalid todo details:", details);
        }
      }
    }
  } catch (error) {
    console.error("Failed to reconstruct state:", error);
    // 使用默认状态
    todos = [];
    nextId = 1;
  }
};
```

### 5.2 会话命名冲突

```typescript
pi.registerCommand("session-name", {
  description: "Set or show session name",
  handler: async (args, ctx) => {
    const name = args.trim();

    if (name) {
      try {
        pi.setSessionName(name);
        ctx.ui.notify(`Session named: ${name}`, "success");
      } catch (error: any) {
        console.error("Failed to set session name:", error);
        ctx.ui.notify(`Error: ${error.message}`, "error");
      }
    } else {
      const current = pi.getSessionName();
      ctx.ui.notify(
        current ? `Session: ${current}` : "No session name set",
        "info"
      );
    }
  },
});
```

### 5.3 分支事件处理失败

```typescript
pi.on("session_before_fork", async (event, ctx) => {
  try {
    // 准备分支（如保存状态）
    const prepared = await prepareForFork(event.entryId);

    if (!prepared) {
      // 阻止分支
      return { block: true, reason: "Failed to prepare for fork" };
    }

    // 允许分支
    return undefined;
  } catch (error) {
    console.error("Fork preparation failed:", error);
    // 出错时阻止分支
    return { block: true, reason: "Fork preparation error" };
  }
});
```

---

## 6. 最佳实践

### 6.1 状态持久化

```typescript
// ✓ 好：使用 details 持久化状态
return {
  content: [{ type: "text", text: "Result" }],
  details: { state: myState },
};

// ✗ 差：使用外部文件
fs.writeFileSync("/tmp/state.json", JSON.stringify(myState));
```

### 6.2 状态重建

```typescript
// ✓ 好：在所有会话事件中重建状态
pi.on("session_start", async (_event, ctx) => reconstructState(ctx));
pi.on("session_switch", async (_event, ctx) => reconstructState(ctx));
pi.on("session_fork", async (_event, ctx) => reconstructState(ctx));

// ✗ 差：只在 session_start 中重建
pi.on("session_start", async (_event, ctx) => reconstructState(ctx));
// 切换会话后状态会错误
```

### 6.3 会话命名

```typescript
// ✓ 好：使用描述性名称
pi.setSessionName("Implement user authentication");

// ✗ 差：使用无意义名称
pi.setSessionName("Session 1");
```

### 6.4 书签使用

```typescript
// ✓ 好：在重要位置设置书签
ctx.session.setLabel("Before refactoring");
ctx.session.setLabel("After bug fix");

// ✗ 差：过度使用书签
ctx.session.setLabel("Step 1");
ctx.session.setLabel("Step 2");
ctx.session.setLabel("Step 3");
// 太多书签会降低可用性
```

---

## 7. 总结

### 7.1 核心要点

1. **会话事件**：监听 session_start、session_switch、session_fork 等事件
2. **状态持久化**：通过 tool result details 保存状态
3. **状态重建**：从 sessionManager.getBranch() 重建状态
4. **会话命名**：使用 setSessionName 设置友好名称
5. **会话书签**：使用 session.setLabel 标记重要位置

### 7.2 扩展方向

- **会话元数据**：在 session.metadata 中保存自定义数据
- **自动保存**：定期设置书签作为保存点
- **会话统计**：统计消息、工具调用、错误等
- **状态导出**：导出会话状态到文件
- **状态导入**：从文件导入会话状态

### 7.3 实际应用

会话管理扩展适用于：
- **长期项目**：为项目会话设置友好名称
- **状态管理**：持久化应用状态（Todo、配置等）
- **版本控制**：在重要位置设置书签
- **调试辅助**：记录错误位置，方便回溯
- **协作开发**：共享会话状态和书签

---

**下一步：** 学习 [07_实战代码_06_Git集成扩展.md](./07_实战代码_06_Git集成扩展.md)，了解如何集成 Git 功能。
