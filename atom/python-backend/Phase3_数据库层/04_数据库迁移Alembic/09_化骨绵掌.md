# 化骨绵掌

**10个2分钟知识卡片，帮助你深入理解 Alembic 的核心概念和实战技巧。**

---

### 卡片1：Alembic 的本质

**一句话：** Alembic 是数据库 schema 变更的版本控制系统，就像 Git 管理代码变更一样。

**举例：**
```python
# Git 管理代码
git commit -m "add user avatar feature"
git log  # 查看历史
git checkout abc123  # 切换版本

# Alembic 管理数据库
alembic revision -m "add avatar column"
alembic history  # 查看历史
alembic upgrade abc123  # 切换版本
```

**应用：** 在 AI Agent 后端开发中，Alembic 确保开发、测试、生产环境的数据库结构完全一致，避免"在我机器上能跑"的问题。

---

### 卡片2：alembic_version 表的作用

**一句话：** `alembic_version` 表只有一行一列，存储当前数据库版本号，是 Alembic 判断"数据库在哪个版本"的唯一依据。

**举例：**
```sql
-- alembic_version 表结构
CREATE TABLE alembic_version (
    version_num VARCHAR(32) PRIMARY KEY
);

-- 查看当前版本
SELECT * FROM alembic_version;
-- version_num
-- ------------
-- abc123def456

-- Alembic 通过这个表知道：
-- 1. 当前数据库在 abc123def456 版本
-- 2. 需要执行哪些迁移才能到达目标版本
```

**应用：** 每次运行 `alembic upgrade`，Alembic 先读取这个表，计算需要执行的迁移路径，执行完后更新这个表。

---

### 卡片3：版本链的线性结构

**一句话：** Alembic 的版本链是单向链表，每个迁移通过 `down_revision` 指向父迁移，形成有序的版本历史。

**举例：**
```python
# 迁移1
revision = 'abc123'
down_revision = None  # 第一个迁移

# 迁移2
revision = 'def456'
down_revision = 'abc123'  # 指向迁移1

# 迁移3
revision = 'ghi789'
down_revision = 'def456'  # 指向迁移2

# 形成链：None -> abc123 -> def456 -> ghi789
```

**应用：** 版本链确保迁移按正确顺序执行，不会跳过中间版本，保证数据库状态的一致性。

---

### 卡片4：upgrade 和 downgrade 的对称性

**一句话：** 每个迁移都有 `upgrade`（正向）和 `downgrade`（反向）两个函数，理论上可以在任意版本间来回切换。

**举例：**
```python
def upgrade():
    """正向：添加字段"""
    op.add_column('users', sa.Column('avatar', sa.String()))

def downgrade():
    """反向：删除字段"""
    op.drop_column('users', 'avatar')

# 前进
alembic upgrade +1  # 执行 upgrade()

# 后退
alembic downgrade -1  # 执行 downgrade()
```

**应用：** 但要注意：涉及数据删除的 downgrade 不安全（数据已丢失），生产环境应避免回滚，而是通过新迁移修复问题。

---

### 卡片5：autogenerate 的工作原理

**一句话：** autogenerate 通过对比数据库 schema 和 SQLAlchemy 模型，自动生成迁移脚本，但只能检测基本变更。

**举例：**
```python
# 1. 读取数据库 schema
metadata.reflect(bind=engine)
# 当前数据库：users 表有 id, email 字段

# 2. 读取 SQLAlchemy 模型
target_metadata = Base.metadata
# 模型定义：users 表有 id, email, avatar 字段

# 3. 对比差异
diff = compare_metadata(context, target_metadata)
# 差异：新增 avatar 字段

# 4. 生成迁移脚本
def upgrade():
    op.add_column('users', sa.Column('avatar', sa.String()))
```

**应用：** autogenerate 能检测表、列、索引的增删改，但无法检测重命名、约束变更、数据迁移，需要手动编辑。

---

### 卡片6：autogenerate 的限制

**一句话：** autogenerate 无法检测重命名操作，会将其识别为删除+创建，导致数据丢失。

**举例：**
```python
# 场景：重命名字段 username -> display_name

# autogenerate 生成（错误）：
def upgrade():
    op.drop_column('users', 'username')  # 删除旧字段
    op.add_column('users', sa.Column('display_name', sa.String()))  # 添加新字段
    # 问题：数据丢失！

# 手动修改（正确）：
def upgrade():
    op.alter_column('users', 'username', new_column_name='display_name')
    # 数据保留！
```

**应用：** 生成迁移脚本后，必须人工检查，对于重命名操作，手动修改为 `alter_column` 或 `rename_table`。

---

### 卡片7：迁移脚本的不可变性

**一句话：** 一旦迁移脚本被应用到生产环境，就应该视为不可变，不能修改，只能创建新迁移。

**举例：**
```python
# 错误做法：修改已应用的迁移
# versions/abc123_add_avatar.py（已应用到生产）
def upgrade():
    op.add_column('users', sa.Column('avatar', sa.String()))
    # 后来发现需要加索引，直接修改这个文件：
    op.create_index('ix_users_avatar', 'users', ['avatar'])  # ❌

# 问题：
# - 生产环境已应用旧版本（没有索引）
# - 新环境应用新版本（有索引）
# - 数据库结构不一致！

# 正确做法：创建新迁移
# versions/def456_add_avatar_index.py（新迁移）
def upgrade():
    op.create_index('ix_users_avatar', 'users', ['avatar'])
```

**应用：** 迁移脚本一旦推送到远程仓库或应用到生产环境，就不能修改，只能通过新迁移修复问题。

---

### 卡片8：数据迁移的策略

**一句话：** 数据迁移需要手动编写，通常分3步：添加新字段 → 迁移数据 → 删除旧字段。

**举例：**
```python
# 场景：合并 first_name 和 last_name 为 full_name

# 步骤1：添加新字段（可空）
def upgrade():
    op.add_column('users', sa.Column('full_name', sa.String(), nullable=True))

# 步骤2：迁移数据
def upgrade():
    op.execute("""
        UPDATE users
        SET full_name = first_name || ' ' || last_name
        WHERE full_name IS NULL
    """)

# 步骤3：删除旧字段
def upgrade():
    op.drop_column('users', 'first_name')
    op.drop_column('users', 'last_name')
```

**应用：** 分步迁移的好处是每步都可以独立回滚，如果中间出错，可以只回滚部分操作。

---

### 卡片9：零停机迁移策略

**一句话：** 零停机迁移通过"双写"策略实现：先添加新字段（可空）→ 部署新代码（双写）→ 迁移数据 → 删除旧字段。

**举例：**
```python
# 步骤1：添加新字段（可空，不影响现有代码）
def upgrade():
    op.add_column('users', sa.Column('avatar_url', sa.String(), nullable=True))

# 步骤2：部署新代码（双写）
def create_user(email, avatar_url=None):
    user = User(email=email, avatar_url=avatar_url)  # 新代码写入新字段
    db.add(user)
    db.commit()

# 步骤3：迁移现有数据（后台运行）
def upgrade():
    op.execute("UPDATE users SET avatar_url = '/default.png' WHERE avatar_url IS NULL")

# 步骤4：删除旧字段（可选）
def upgrade():
    op.alter_column('users', 'avatar_url', nullable=False)
```

**应用：** 这种策略确保服务不中断，每一步都是向后兼容的，可以随时回滚。

---

### 卡片10：生产环境迁移的黄金法则

**一句话：** 生产环境迁移前必须：备份数据库 → 在测试环境验证 → 预览 SQL → 低峰期执行 → 监控验证。

**举例：**
```bash
# 1. 备份数据库
pg_dump mydb > backup_20260211.sql

# 2. 在测试环境验证
alembic upgrade head  # 测试环境

# 3. 预览 SQL
alembic upgrade head --sql > migration.sql
cat migration.sql  # 检查 SQL

# 4. 低峰期执行
# 凌晨2点执行迁移
alembic upgrade head

# 5. 监控验证
alembic current  # 验证版本
psql -c "SELECT COUNT(*) FROM users"  # 验证数据
curl http://api/health  # 验证服务
```

**应用：** 这5步是生产环境迁移的最小安全保障，缺一不可。如果迁移失败，立即从备份恢复。

---

## 知识卡片总结

| 卡片 | 核心概念 | 关键要点 |
|------|---------|---------|
| 1 | Alembic 本质 | 数据库的 Git |
| 2 | alembic_version 表 | 单行单列，存储当前版本 |
| 3 | 版本链结构 | 单向链表，有序执行 |
| 4 | upgrade/downgrade | 双向可逆，但数据删除不可逆 |
| 5 | autogenerate 原理 | 对比 schema 和模型，生成差异 |
| 6 | autogenerate 限制 | 无法检测重命名，需手动编辑 |
| 7 | 迁移不可变性 | 已应用的迁移不能修改 |
| 8 | 数据迁移策略 | 分3步：添加 → 迁移 → 删除 |
| 9 | 零停机迁移 | 双写策略，向后兼容 |
| 10 | 生产环境黄金法则 | 备份 → 验证 → 预览 → 执行 → 监控 |

---

## 学习路径建议

**初学者（第1-4张卡片）：**
- 理解 Alembic 的本质和核心机制
- 掌握版本链和 upgrade/downgrade 的概念
- 能够使用 autogenerate 生成基本迁移

**进阶学习者（第5-7张卡片）：**
- 理解 autogenerate 的工作原理和限制
- 学会手动编辑迁移脚本
- 掌握迁移脚本的不可变性原则

**高级开发者（第8-10张卡片）：**
- 掌握数据迁移和零停机迁移策略
- 能够在生产环境安全地执行迁移
- 建立完整的迁移流程和回滚机制

---

## 常见问题速查

**Q1: 为什么 autogenerate 没有检测到我的变更？**
A: 检查 `alembic/env.py` 中是否导入了所有模型，确保 `target_metadata = Base.metadata` 正确配置。

**Q2: 如何处理多人协作时的迁移冲突？**
A: 使用 `alembic merge` 命令合并分支，或手动调整 `down_revision` 形成线性链。

**Q3: 生产环境迁移失败怎么办？**
A: 立即从备份恢复，不要尝试回滚（可能导致数据丢失），分析失败原因后创建新迁移修复。

**Q4: 如何在大表上添加索引而不锁表？**
A: 使用 PostgreSQL 的 `CONCURRENTLY` 选项：
```python
op.execute("CREATE INDEX CONCURRENTLY idx_name ON table (column)")
```

**Q5: 如何测试迁移脚本？**
A: 在开发环境执行 `alembic upgrade head`，验证数据库结构，然后 `alembic downgrade -1` 测试回滚。

---

## 记住这些原则

1. **Alembic = 数据库的 Git**：版本化管理数据库变更
2. **autogenerate 是助手，不是替代品**：生成后必须检查
3. **迁移脚本不可变**：已应用的不能修改
4. **数据迁移分步走**：添加 → 迁移 → 删除
5. **生产环境要谨慎**：备份 → 验证 → 执行 → 监控
6. **回滚不总是安全**：数据删除不可逆
7. **零停机靠双写**：向后兼容，逐步迁移
8. **团队协作要规范**：频繁同步，避免冲突
9. **版本链要线性**：避免多 head，及时合并
10. **监控很重要**：健康检查，版本追踪

**一句话总结：**
> Alembic 是数据库变更的版本控制系统，通过版本化的迁移脚本确保多环境一致性，核心是 alembic_version 表 + 线性版本链 + upgrade/downgrade 双向迁移。
