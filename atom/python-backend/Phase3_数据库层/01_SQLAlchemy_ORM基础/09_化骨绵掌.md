# 化骨绵掌

10个2分钟知识卡片，系统掌握 SQLAlchemy ORM。

---

## 卡片1：ORM 的本质

**一句话：** ORM 是对象和关系数据库之间的翻译器，让你用 Python 对象操作数据库。

**举例：**
```python
# 不用 ORM：手写 SQL
cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", ("Alice", "alice@example.com"))

# 用 ORM：面向对象
user = User(name="Alice", email="alice@example.com")
session.add(user)
session.commit()
```

**应用：** 在 AI Agent 开发中，用 ORM 管理用户、对话、消息等数据，避免手写 SQL。

---

## 卡片2：声明式模型

**一句话：** 用 Python 类定义数据库表，类属性对应表的列。

**举例：**
```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = "users"  # 表名
    id = Column(Integer, primary_key=True)  # 主键
    name = Column(String(50))  # 字符串列
    email = Column(String(100), unique=True)  # 唯一列
```

**应用：** 定义 AI Agent 的数据模型（User、Conversation、Message）。

---

## 卡片3：Session 的生命周期

**一句话：** Session 是请求级别的，每个请求创建一个 Session，请求结束时关闭。

**举例：**
```python
# FastAPI 依赖注入
def get_db():
    db = SessionLocal()
    try:
        yield db  # 使用 Session
    finally:
        db.close()  # 自动关闭

@app.get("/users")
def get_users(db: Session = Depends(get_db)):
    return db.query(User).all()
```

**应用：** 在 FastAPI 中正确管理数据库连接，避免连接泄漏。

---

## 卡片4：CRUD 操作

**一句话：** 用 Session 执行增删改查操作，最后 commit 提交。

**举例：**
```python
# Create
user = User(name="Alice")
session.add(user)
session.commit()

# Read
user = session.query(User).filter(User.name == "Alice").first()

# Update
user.name = "Alice Smith"
session.commit()

# Delete
session.delete(user)
session.commit()
```

**应用：** 实现 AI Agent 的用户管理、对话管理等功能。

---

## 卡片5：查询构造器

**一句话：** 用链式调用构建查询，类似 JavaScript 的 Array 方法。

**举例：**
```python
# 链式调用
users = session.query(User)\
    .filter(User.age > 18)\
    .filter(User.is_active == True)\
    .order_by(User.name)\
    .limit(10)\
    .all()

# 等价 SQL
# SELECT * FROM users
# WHERE age > 18 AND is_active = true
# ORDER BY name
# LIMIT 10
```

**应用：** 查询 AI Agent 的对话历史、消息记录等。

---

## 卡片6：关系映射

**一句话：** 用 relationship 定义表之间的关系，ORM 自动处理 JOIN。

**举例：**
```python
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    conversations = relationship("Conversation", back_populates="user")

class Conversation(Base):
    __tablename__ = "conversations"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    user = relationship("User", back_populates="conversations")

# 使用：自动 JOIN
user = session.query(User).first()
for conv in user.conversations:  # ORM 自动处理 JOIN
    print(conv.title)
```

**应用：** 管理 AI Agent 的用户-对话-消息多层关系。

---

## 卡片7：懒加载 vs 预加载

**一句话：** 懒加载按需查询，预加载一次性加载，避免 N+1 问题。

**举例：**
```python
# 懒加载（默认）：N+1 问题
users = session.query(User).all()  # 1 次查询
for user in users:
    print(user.conversations)  # 每个 user 触发 1 次查询

# 预加载：只需 1 次查询
from sqlalchemy.orm import joinedload

users = session.query(User)\
    .options(joinedload(User.conversations))\
    .all()  # 1 次查询（JOIN）
for user in users:
    print(user.conversations)  # 不触发查询
```

**应用：** 优化 AI Agent 的查询性能，避免 N+1 问题。

---

## 卡片8：事务管理

**一句话：** 事务保证多个操作要么全成功，要么全失败。

**举例：**
```python
try:
    # 创建对话和第一条消息（原子操作）
    conversation = Conversation(title="新对话")
    session.add(conversation)
    session.flush()  # 获取 conversation.id

    message = Message(
        conversation_id=conversation.id,
        content="你好"
    )
    session.add(message)
    session.commit()  # 要么全成功，要么全失败
except:
    session.rollback()  # 回滚所有更改
```

**应用：** 保证 AI Agent 的数据一致性（创建对话和消息是原子操作）。

---

## 卡片9：连接池配置

**一句话：** 连接池复用数据库连接，提升性能，但不要配置过大。

**举例：**
```python
from sqlalchemy import create_engine

engine = create_engine(
    DATABASE_URL,
    pool_size=10,          # 核心连接数
    max_overflow=20,       # 最大溢出连接数
    pool_timeout=30,       # 获取连接超时（秒）
    pool_recycle=3600,     # 连接回收时间（秒）
    pool_pre_ping=True     # 使用前检查连接是否有效
)
```

**应用：** 优化 AI Agent 的数据库性能，支持高并发请求。

---

## 卡片10：与 FastAPI 集成

**一句话：** 用依赖注入管理 Session，每个请求自动创建和关闭 Session。

**举例：**
```python
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session

app = FastAPI()

# 依赖函数
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 在路由中使用
@app.post("/conversations")
def create_conversation(
    title: str,
    db: Session = Depends(get_db)  # 自动注入 Session
):
    conversation = Conversation(title=title)
    db.add(conversation)
    db.commit()
    db.refresh(conversation)
    return conversation
```

**应用：** 构建 AI Agent 的 RESTful API，类型安全的数据操作。

---

## 知识卡片总结

| 卡片 | 核心概念 | 关键技术 | 应用场景 |
|------|----------|----------|----------|
| 1 | ORM 本质 | 对象-关系映射 | 理解 ORM 的价值 |
| 2 | 声明式模型 | Base, Column | 定义数据模型 |
| 3 | Session 生命周期 | 请求级别 | 管理数据库连接 |
| 4 | CRUD 操作 | add/query/commit | 基本数据操作 |
| 5 | 查询构造器 | filter/order_by | 构建复杂查询 |
| 6 | 关系映射 | relationship | 处理表关联 |
| 7 | 懒加载 vs 预加载 | joinedload | 性能优化 |
| 8 | 事务管理 | commit/rollback | 数据一致性 |
| 9 | 连接池配置 | pool_size | 高并发支持 |
| 10 | FastAPI 集成 | Depends | 构建 API |

---

## 学习路径

```
1. ORM 本质 → 2. 声明式模型 → 3. Session 生命周期
                    ↓
4. CRUD 操作 → 5. 查询构造器 → 6. 关系映射
                    ↓
7. 懒加载 vs 预加载 → 8. 事务管理 → 9. 连接池配置
                    ↓
10. FastAPI 集成（综合应用）
```

---

## 快速参考

### 常用操作速查

```python
# 创建
user = User(name="Alice")
session.add(user)
session.commit()

# 查询
user = session.query(User).filter(User.id == 1).first()
users = session.query(User).all()

# 更新
user.name = "Bob"
session.commit()

# 删除
session.delete(user)
session.commit()

# 预加载
users = session.query(User).options(joinedload(User.conversations)).all()

# 事务
try:
    session.add(obj)
    session.commit()
except:
    session.rollback()
```

### 常见错误速查

| 错误 | 原因 | 解决方案 |
|------|------|----------|
| DetachedInstanceError | Session 关闭后访问对象 | 在 Session 内访问或使用 refresh |
| N+1 查询 | 懒加载导致 | 使用 joinedload 预加载 |
| 连接泄漏 | 忘记关闭 Session | 使用上下文管理器或依赖注入 |
| 数据不一致 | 忘记 commit | 显式调用 commit |
| 笛卡尔积 | joinedload 一对多 | 使用 subqueryload 或 selectinload |

---

**记住：** 这 10 个卡片覆盖了 SQLAlchemy ORM 的核心知识，掌握它们就能开始实际开发。
