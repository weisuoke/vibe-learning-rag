# 实战代码3：TLS加密配置

**完整的 TLS/SSL 加密配置示例，从证书生成到生产环境部署。**

---

## 场景说明

**目标：** 为 Milvus 配置 TLS 加密传输：
- 生成 SSL 证书
- 配置服务端 TLS
- 实现客户端安全连接
- 性能优化
- 证书管理和监控

**适用场景：**
- 生产环境部署
- 金融/医疗等合规行业
- 公网暴露的服务

---

## 完整代码

```python
"""
Milvus TLS 加密配置
演示：从证书生成到安全连接的完整流程
"""

import os
import ssl
import socket
import subprocess
from typing import Dict, Optional
from datetime import datetime, timedelta
from pymilvus import connections, utility, Collection
from dotenv import load_dotenv
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# ===== 1. 证书生成器 =====

class CertificateGenerator:
    """SSL 证书生成器"""

    def __init__(self, cert_dir: str = "./certs"):
        self.cert_dir = cert_dir
        self.logger = logging.getLogger("CertificateGenerator")

        # 创建证书目录
        os.makedirs(cert_dir, exist_ok=True)

    def generate_self_signed_cert(self, domain: str = "localhost"):
        """生成自签名证书（开发/测试环境）"""
        self.logger.info("=== 生成自签名证书 ===")

        # 文件路径
        ca_key = os.path.join(self.cert_dir, "ca.key")
        ca_crt = os.path.join(self.cert_dir, "ca.crt")
        server_key = os.path.join(self.cert_dir, "server.key")
        server_csr = os.path.join(self.cert_dir, "server.csr")
        server_crt = os.path.join(self.cert_dir, "server.crt")
        server_pem = os.path.join(self.cert_dir, "server.pem")

        try:
            # 1. 生成 CA 私钥
            self.logger.info("1. 生成 CA 私钥")
            subprocess.run([
                "openssl", "genrsa",
                "-out", ca_key,
                "4096"
            ], check=True, capture_output=True)

            # 2. 生成 CA 证书
            self.logger.info("2. 生成 CA 证书")
            subprocess.run([
                "openssl", "req", "-new", "-x509",
                "-days", "365",
                "-key", ca_key,
                "-out", ca_crt,
                "-subj", "/C=CN/ST=Beijing/L=Beijing/O=MyCompany/CN=Milvus CA"
            ], check=True, capture_output=True)

            # 3. 生成服务器私钥
            self.logger.info("3. 生成服务器私钥")
            subprocess.run([
                "openssl", "genrsa",
                "-out", server_key,
                "4096"
            ], check=True, capture_output=True)

            # 4. 生成服务器证书签名请求（CSR）
            self.logger.info("4. 生成服务器 CSR")
            subprocess.run([
                "openssl", "req", "-new",
                "-key", server_key,
                "-out", server_csr,
                "-subj", f"/C=CN/ST=Beijing/L=Beijing/O=MyCompany/CN={domain}"
            ], check=True, capture_output=True)

            # 5. 使用 CA 签发服务器证书
            self.logger.info("5. 签发服务器证书")
            subprocess.run([
                "openssl", "x509", "-req",
                "-days", "365",
                "-in", server_csr,
                "-CA", ca_crt,
                "-CAkey", ca_key,
                "-CAcreateserial",
                "-out", server_crt
            ], check=True, capture_output=True)

            # 6. 生成 PEM 格式（Milvus 需要）
            self.logger.info("6. 生成 PEM 格式")
            with open(server_pem, 'w') as pem_file:
                with open(server_crt, 'r') as crt_file:
                    pem_file.write(crt_file.read())
                with open(server_key, 'r') as key_file:
                    pem_file.write(key_file.read())

            self.logger.info("✅ 证书生成完成")
            self.logger.info(f"证书目录：{self.cert_dir}")
            self.logger.info(f"  - CA 证书：{ca_crt}")
            self.logger.info(f"  - 服务器证书：{server_crt}")
            self.logger.info(f"  - 服务器私钥：{server_key}")
            self.logger.info(f"  - PEM 文件：{server_pem}")

            return {
                "ca_crt": ca_crt,
                "server_crt": server_crt,
                "server_key": server_key,
                "server_pem": server_pem
            }

        except subprocess.CalledProcessError as e:
            self.logger.error(f"❌ 证书生成失败：{e}")
            self.logger.error(f"错误输出：{e.stderr.decode()}")
            return None

    def generate_letsencrypt_cert(self, domain: str, email: str):
        """使用 Let's Encrypt 生成证书（生产环境）"""
        self.logger.info("=== 使用 Let's Encrypt 生成证书 ===")

        try:
            # 使用 certbot 获取证书
            subprocess.run([
                "certbot", "certonly",
                "--standalone",
                "-d", domain,
                "--email", email,
                "--agree-tos",
                "--non-interactive"
            ], check=True)

            cert_path = f"/etc/letsencrypt/live/{domain}"
            self.logger.info(f"✅ Let's Encrypt 证书已生成")
            self.logger.info(f"证书路径：{cert_path}")

            return {
                "fullchain": f"{cert_path}/fullchain.pem",
                "privkey": f"{cert_path}/privkey.pem"
            }

        except subprocess.CalledProcessError as e:
            self.logger.error(f"❌ Let's Encrypt 证书生成失败：{e}")
            return None


# ===== 2. TLS 配置管理器 =====

class TLSConfigManager:
    """TLS 配置管理器"""

    def __init__(self, cert_dir: str = "./certs"):
        self.cert_dir = cert_dir
        self.logger = logging.getLogger("TLSConfigManager")

    def generate_milvus_config(self, server_pem: str, server_key: str,
                               ca_pem: str = None) -> str:
        """生成 Milvus TLS 配置"""
        config = f"""
# Milvus TLS 配置
proxy:
  tls:
    enabled: true
    serverPemPath: {server_pem}
    serverKeyPath: {server_key}
"""
        if ca_pem:
            config += f"    caPemPath: {ca_pem}\n"

        config += """
    # TLS 版本（推荐 1.3）
    minVersion: "1.3"

    # 加密套件（使用硬件加速）
    cipherSuites:
      - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
      - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
"""

        config_file = os.path.join(self.cert_dir, "milvus_tls.yaml")
        with open(config_file, 'w') as f:
            f.write(config)

        self.logger.info(f"✅ Milvus TLS 配置已生成：{config_file}")
        return config_file


# ===== 3. TLS 连接管理器 =====

class TLSConnectionManager:
    """TLS 连接管理器"""

    def __init__(self):
        self.logger = logging.getLogger("TLSConnectionManager")
        load_dotenv()

    def connect_with_tls(self, host: str, port: str, user: str, password: str,
                        server_pem_path: str, server_name: str = None) -> bool:
        """使用 TLS 连接 Milvus"""
        try:
            self.logger.info("=== 建立 TLS 连接 ===")

            connections.connect(
                alias="secure",
                host=host,
                port=port,
                user=user,
                password=password,
                secure=True,  # 启用 TLS
                server_pem_path=server_pem_path,
                server_name=server_name or host
            )

            self.logger.info("✅ TLS 连接成功")
            return True

        except Exception as e:
            self.logger.error(f"❌ TLS 连接失败：{e}")
            return False

    def connect_with_mtls(self, host: str, port: str,
                         server_pem_path: str,
                         client_pem_path: str,
                         client_key_path: str,
                         ca_pem_path: str) -> bool:
        """使用双向 TLS（mTLS）连接"""
        try:
            self.logger.info("=== 建立 mTLS 连接 ===")

            connections.connect(
                alias="mtls",
                host=host,
                port=port,
                secure=True,
                server_pem_path=server_pem_path,
                client_pem_path=client_pem_path,
                client_key_path=client_key_path,
                ca_pem_path=ca_pem_path
            )

            self.logger.info("✅ mTLS 连接成功")
            return True

        except Exception as e:
            self.logger.error(f"❌ mTLS 连接失败：{e}")
            return False

    def test_connection(self):
        """测试连接"""
        try:
            collections = utility.list_collections()
            self.logger.info(f"✅ 连接测试成功，Collections: {collections}")
            return True
        except Exception as e:
            self.logger.error(f"❌ 连接测试失败：{e}")
            return False


# ===== 4. 证书监控器 =====

class CertificateMonitor:
    """证书监控器"""

    def __init__(self):
        self.logger = logging.getLogger("CertificateMonitor")

    def check_certificate_expiry(self, host: str, port: int = 19530) -> Dict:
        """检查证书有效期"""
        try:
            self.logger.info(f"=== 检查证书有效期：{host}:{port} ===")

            # 创建 SSL 上下文
            context = ssl.create_default_context()

            # 连接并获取证书
            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()

                    # 解析证书信息
                    subject = dict(x[0] for x in cert['subject'])
                    issuer = dict(x[0] for x in cert['issuer'])
                    not_after = cert['notAfter']

                    # 计算过期时间
                    expiry_date = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
                    days_left = (expiry_date - datetime.now()).days

                    result = {
                        "host": host,
                        "subject": subject.get('commonName'),
                        "issuer": issuer.get('commonName'),
                        "expiry_date": expiry_date,
                        "days_left": days_left,
                        "status": "valid" if days_left > 0 else "expired"
                    }

                    self.logger.info(f"证书主题：{result['subject']}")
                    self.logger.info(f"签发者：{result['issuer']}")
                    self.logger.info(f"过期时间：{result['expiry_date']}")
                    self.logger.info(f"剩余天数：{result['days_left']}")

                    if days_left < 30:
                        self.logger.warning("⚠️ 证书即将过期，请及时更新！")
                    elif days_left < 0:
                        self.logger.error("❌ 证书已过期！")
                    else:
                        self.logger.info("✅ 证书有效")

                    return result

        except Exception as e:
            self.logger.error(f"❌ 检查证书失败：{e}")
            return None

    def setup_expiry_alert(self, host: str, port: int, alert_days: int = 30):
        """设置证书过期告警"""
        result = self.check_certificate_expiry(host, port)

        if result and result['days_left'] < alert_days:
            self.logger.warning(
                f"⚠️ 告警：证书将在 {result['days_left']} 天后过期！"
            )
            # 这里可以集成告警系统（邮件、Slack、钉钉等）
            return True

        return False


# ===== 5. 性能测试器 =====

class TLSPerformanceTester:
    """TLS 性能测试器"""

    def __init__(self):
        self.logger = logging.getLogger("TLSPerformanceTester")

    def benchmark_connection(self, with_tls: bool, iterations: int = 10):
        """基准测试：连接性能"""
        import time

        self.logger.info(f"\n=== 连接性能测试（{'TLS' if with_tls else '无TLS'}）===")

        total_time = 0
        success_count = 0

        for i in range(iterations):
            start_time = time.time()

            try:
                if with_tls:
                    connections.connect(
                        alias=f"test_{i}",
                        host="localhost",
                        port="19530",
                        user="root",
                        password=os.getenv("MILVUS_PASSWORD"),
                        secure=True,
                        server_pem_path="./certs/server.pem"
                    )
                else:
                    connections.connect(
                        alias=f"test_{i}",
                        host="localhost",
                        port="19530",
                        user="root",
                        password=os.getenv("MILVUS_PASSWORD")
                    )

                elapsed = time.time() - start_time
                total_time += elapsed
                success_count += 1

                connections.disconnect(f"test_{i}")

            except Exception as e:
                self.logger.error(f"连接失败：{e}")

        avg_time = total_time / success_count if success_count > 0 else 0

        self.logger.info(f"成功连接：{success_count}/{iterations}")
        self.logger.info(f"平均连接时间：{avg_time * 1000:.2f} ms")

        return avg_time


# ===== 6. 生产环境 RAG 系统 =====

class SecureProductionRAG:
    """生产环境安全 RAG 系统"""

    def __init__(self, cert_dir: str = "./certs"):
        self.cert_dir = cert_dir
        self.logger = logging.getLogger("SecureProductionRAG")
        load_dotenv()

        # 建立 TLS 连接
        self._connect()

    def _connect(self):
        """建立安全连接"""
        connections.connect(
            alias="production",
            host=os.getenv("MILVUS_HOST", "localhost"),
            port=os.getenv("MILVUS_PORT", "19530"),
            user=os.getenv("MILVUS_USER"),
            password=os.getenv("MILVUS_PASSWORD"),
            secure=True,
            server_pem_path=os.path.join(self.cert_dir, "server.pem")
        )
        self.logger.info("✅ 生产环境安全连接已建立")

    def search(self, collection_name: str, query_vector: list, limit: int = 10):
        """安全搜索（所有数据都加密传输）"""
        try:
            collection = Collection(collection_name)
            results = collection.search(
                data=[query_vector],
                anns_field="embedding",
                param={"metric_type": "L2", "params": {"nprobe": 10}},
                limit=limit
            )

            self.logger.info(f"✅ 搜索完成（加密传输）")
            return results

        except Exception as e:
            self.logger.error(f"❌ 搜索失败：{e}")
            return None


# ===== 7. 主程序 =====

def main():
    """主程序"""
    print("=" * 60)
    print("Milvus TLS 加密配置示例")
    print("=" * 60)

    # 步骤1：生成证书
    print("\n【步骤1：生成证书】")
    cert_gen = CertificateGenerator()
    certs = cert_gen.generate_self_signed_cert(domain="localhost")

    if not certs:
        print("❌ 证书生成失败")
        return

    # 步骤2：生成 Milvus 配置
    print("\n【步骤2：生成 Milvus 配置】")
    config_mgr = TLSConfigManager()
    config_file = config_mgr.generate_milvus_config(
        server_pem=certs["server_pem"],
        server_key=certs["server_key"],
        ca_pem=certs["ca_crt"]
    )

    print(f"\n⚠️ 请将以下配置添加到 milvus.yaml 并重启 Milvus：")
    print(f"配置文件：{config_file}")

    # 步骤3：测试 TLS 连接（需要先重启 Milvus）
    print("\n【步骤3：测试 TLS 连接】")
    print("⚠️ 请先重启 Milvus 使 TLS 配置生效")
    print("然后运行：python this_script.py --test-connection")

    # 步骤4：证书监控
    print("\n【步骤4：证书监控】")
    monitor = CertificateMonitor()
    # monitor.check_certificate_expiry("localhost", 19530)

    # 步骤5：性能测试
    print("\n【步骤5：性能测试】")
    print("⚠️ 运行性能测试：python this_script.py --benchmark")

    print("\n" + "=" * 60)
    print("TLS 配置完成")
    print("=" * 60)


def test_connection():
    """测试 TLS 连接"""
    print("=== 测试 TLS 连接 ===")

    conn_mgr = TLSConnectionManager()
    success = conn_mgr.connect_with_tls(
        host="localhost",
        port="19530",
        user="root",
        password=os.getenv("MILVUS_PASSWORD"),
        server_pem_path="./certs/server.pem"
    )

    if success:
        conn_mgr.test_connection()


def benchmark():
    """性能基准测试"""
    tester = TLSPerformanceTester()

    # 测试无 TLS
    tester.benchmark_connection(with_tls=False, iterations=10)

    # 测试有 TLS
    tester.benchmark_connection(with_tls=True, iterations=10)


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        if sys.argv[1] == "--test-connection":
            test_connection()
        elif sys.argv[1] == "--benchmark":
            benchmark()
        else:
            print("用法：")
            print("  python script.py                 # 生成证书和配置")
            print("  python script.py --test-connection  # 测试 TLS 连接")
            print("  python script.py --benchmark        # 性能测试")
    else:
        main()
```

---

## 运行输出示例

```
============================================================
Milvus TLS 加密配置示例
============================================================

【步骤1：生成证书】
=== 生成自签名证书 ===
2025-02-10 12:00:00 - CertificateGenerator - INFO - 1. 生成 CA 私钥
2025-02-10 12:00:01 - CertificateGenerator - INFO - 2. 生成 CA 证书
2025-02-10 12:00:02 - CertificateGenerator - INFO - 3. 生成服务器私钥
2025-02-10 12:00:03 - CertificateGenerator - INFO - 4. 生成服务器 CSR
2025-02-10 12:00:04 - CertificateGenerator - INFO - 5. 签发服务器证书
2025-02-10 12:00:05 - CertificateGenerator - INFO - 6. 生成 PEM 格式
2025-02-10 12:00:05 - CertificateGenerator - INFO - ✅ 证书生成完成
2025-02-10 12:00:05 - CertificateGenerator - INFO - 证书目录：./certs
2025-02-10 12:00:05 - CertificateGenerator - INFO -   - CA 证书：./certs/ca.crt
2025-02-10 12:00:05 - CertificateGenerator - INFO -   - 服务器证书：./certs/server.crt
2025-02-10 12:00:05 - CertificateGenerator - INFO -   - 服务器私钥：./certs/server.key
2025-02-10 12:00:05 - CertificateGenerator - INFO -   - PEM 文件：./certs/server.pem

【步骤2：生成 Milvus 配置】
2025-02-10 12:00:05 - TLSConfigManager - INFO - ✅ Milvus TLS 配置已生成：./certs/milvus_tls.yaml

⚠️ 请将以下配置添加到 milvus.yaml 并重启 Milvus：
配置文件：./certs/milvus_tls.yaml

【步骤3：测试 TLS 连接】
⚠️ 请先重启 Milvus 使 TLS 配置生效
然后运行：python this_script.py --test-connection

【步骤4：证书监控】

【步骤5：性能测试】
⚠️ 运行性能测试：python this_script.py --benchmark

============================================================
TLS 配置完成
============================================================
```

---

## 使用说明

### 1. 生成证书

```bash
# 运行脚本生成证书
python tls_config.py

# 证书文件将生成在 ./certs/ 目录
```

### 2. 配置 Milvus

```bash
# 将生成的配置合并到 milvus.yaml
cat ./certs/milvus_tls.yaml >> /path/to/milvus.yaml

# 重启 Milvus
docker restart milvus-standalone
```

### 3. 测试连接

```bash
# 测试 TLS 连接
python tls_config.py --test-connection
```

### 4. 性能测试

```bash
# 运行性能基准测试
python tls_config.py --benchmark
```

---

## 环境配置

### .env 文件

```bash
# Milvus 连接配置
MILVUS_HOST=localhost
MILVUS_PORT=19530
MILVUS_USER=root
MILVUS_PASSWORD=SecurePassword123!
```

### 依赖安装

```bash
# 安装依赖
pip install pymilvus python-dotenv

# 安装 OpenSSL（如果没有）
# macOS
brew install openssl

# Ubuntu
sudo apt-get install openssl
```

---

## 关键特性

### 1. 自动证书生成

```python
# 一键生成所有需要的证书
cert_gen = CertificateGenerator()
certs = cert_gen.generate_self_signed_cert()
```

### 2. 证书监控

```python
# 检查证书有效期
monitor = CertificateMonitor()
monitor.check_certificate_expiry("localhost", 19530)
```

### 3. 性能测试

```python
# 对比 TLS 和非 TLS 的性能
tester = TLSPerformanceTester()
tester.benchmark_connection(with_tls=True)
```

### 4. 生产环境集成

```python
# 生产环境 RAG 系统
rag = SecureProductionRAG()
results = rag.search("docs", query_vector)
```

---

## 生产环境建议

### 1. 使用正式 CA 证书

```python
# 生产环境使用 Let's Encrypt
cert_gen.generate_letsencrypt_cert(
    domain="milvus.example.com",
    email="admin@example.com"
)
```

### 2. 证书自动更新

```bash
# 设置 cron 任务自动更新证书
0 0 * * * certbot renew --quiet --post-hook "docker restart milvus"
```

### 3. 监控告警

```python
# 设置证书过期告警（提前 30 天）
monitor.setup_expiry_alert("milvus.example.com", 19530, alert_days=30)
```

---

## 小结

**本示例展示了：**

1. ✅ 自动生成 SSL 证书
2. ✅ Milvus TLS 配置
3. ✅ 安全连接管理
4. ✅ 证书监控和告警
5. ✅ 性能测试和优化
6. ✅ 生产环境集成

**下一步：** 学习多租户权限隔离的实战代码
