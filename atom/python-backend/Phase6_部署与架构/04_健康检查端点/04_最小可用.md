# 最小可用知识

> 掌握以下内容，就能开始实现健康检查端点

---

## 4.1 两个核心端点：/health 和 /ready

**概念：**
- **/health（Liveness）**：检查进程是否存活
- **/ready（Readiness）**：检查服务是否准备好接收流量

**代码示例：**

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/health")
async def health():
    """存活检查：只要进程运行就返回 200"""
    return {"status": "healthy"}

@app.get("/ready")
async def ready():
    """就绪检查：检查依赖服务是否可用"""
    # 检查数据库连接
    try:
        # 假设有一个全局的数据库连接
        await db.execute("SELECT 1")
    except Exception:
        raise HTTPException(status_code=503, detail="Database unavailable")

    return {"status": "ready"}
```

**在 AI Agent 后端中的应用：**
- Kubernetes 使用 /health 决定是否重启 Pod
- 负载均衡器使用 /ready 决定是否发送流量

---

## 4.2 检查依赖服务的基本模式

**概念：**
就绪检查需要验证关键依赖服务是否可用

**代码示例：**

```python
async def check_database() -> bool:
    """检查数据库连接"""
    try:
        await db.execute("SELECT 1")
        return True
    except Exception:
        return False

async def check_redis() -> bool:
    """检查 Redis 连接"""
    try:
        await redis.ping()
        return True
    except Exception:
        return False

@app.get("/ready")
async def ready():
    """检查所有依赖服务"""
    checks = {
        "database": await check_database(),
        "redis": await check_redis(),
    }

    # 如果任何依赖失败，返回 503
    if not all(checks.values()):
        raise HTTPException(
            status_code=503,
            detail={"status": "not_ready", "checks": checks}
        )

    return {"status": "ready", "checks": checks}
```

**在 AI Agent 后端中的应用：**
- 检查 PostgreSQL（存储对话历史）
- 检查 Redis（缓存 Embedding）
- 检查 LLM API（OpenAI/Anthropic）

---

## 4.3 健康检查缓存（避免频繁检查）

**概念：**
健康检查会被频繁调用（每 5-10 秒），需要缓存结果避免影响性能

**代码示例：**

```python
import time
from typing import Dict, Any

# 缓存健康检查结果
health_cache: Dict[str, Any] = {
    "last_check": 0,
    "status": "unknown",
    "checks": {}
}

CACHE_TTL = 30  # 缓存 30 秒

async def get_health_status() -> Dict[str, Any]:
    """获取健康状态（带缓存）"""
    now = time.time()

    # 如果缓存未过期，直接返回
    if now - health_cache["last_check"] < CACHE_TTL:
        return health_cache

    # 执行实际检查
    checks = {
        "database": await check_database(),
        "redis": await check_redis(),
    }

    # 更新缓存
    health_cache.update({
        "last_check": now,
        "status": "ready" if all(checks.values()) else "not_ready",
        "checks": checks
    })

    return health_cache

@app.get("/ready")
async def ready():
    """就绪检查（带缓存）"""
    status = await get_health_status()

    if status["status"] != "ready":
        raise HTTPException(status_code=503, detail=status)

    return status
```

**为什么需要缓存？**
- 避免每次健康检查都查询数据库（影响性能）
- 避免短暂抖动导致误报
- 提高健康检查响应速度

---

## 4.4 Kubernetes 健康探测配置

**概念：**
Kubernetes 通过配置健康探测来自动管理 Pod 生命周期

**配置示例：**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ai-agent-api
spec:
  template:
    spec:
      containers:
      - name: api
        image: ai-agent-api:latest
        ports:
        - containerPort: 8000

        # 存活探测：失败则重启 Pod
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 10  # 启动后 10 秒开始检查
          periodSeconds: 10         # 每 10 秒检查一次
          timeoutSeconds: 5         # 超时时间 5 秒
          failureThreshold: 3       # 连续失败 3 次才重启

        # 就绪探测：失败则停止发流量
        readinessProbe:
          httpGet:
            path: /ready
            port: 8000
          initialDelaySeconds: 5   # 启动后 5 秒开始检查
          periodSeconds: 5         # 每 5 秒检查一次
          timeoutSeconds: 3        # 超时时间 3 秒
          failureThreshold: 2      # 连续失败 2 次停止流量
```

**关键参数：**
- **initialDelaySeconds**：容器启动后多久开始检查（给应用启动时间）
- **periodSeconds**：检查间隔
- **timeoutSeconds**：单次检查超时时间
- **failureThreshold**：连续失败多少次才触发动作

---

## 4.5 响应格式标准化

**概念：**
健康检查应该返回标准化的 JSON 格式，便于监控和调试

**推荐格式：**

```python
from datetime import datetime
from pydantic import BaseModel
from typing import Dict

class HealthResponse(BaseModel):
    status: str  # "healthy" | "degraded" | "unhealthy"
    timestamp: str
    version: str
    uptime: float
    checks: Dict[str, bool]

@app.get("/ready", response_model=HealthResponse)
async def ready():
    """标准化的健康检查响应"""
    checks = {
        "database": await check_database(),
        "redis": await check_redis(),
        "llm_api": await check_llm_api(),
    }

    # 判断整体状态
    if all(checks.values()):
        status = "healthy"
    elif any(checks.values()):
        status = "degraded"  # 部分服务可用
    else:
        status = "unhealthy"

    return HealthResponse(
        status=status,
        timestamp=datetime.utcnow().isoformat(),
        version="1.0.0",
        uptime=time.time() - app.state.start_time,
        checks=checks
    )
```

**标准化的好处：**
- 便于监控系统解析
- 便于调试（知道哪个依赖失败）
- 便于趋势分析

---

## 这些知识足以

掌握以上 5 个核心知识点，你就能：

✅ **实现基础的健康检查端点**
- /health 端点（存活检查）
- /ready 端点（就绪检查）

✅ **检查关键依赖服务**
- 数据库连接检查
- Redis 连接检查
- 外部 API 可用性检查

✅ **优化性能**
- 使用缓存避免频繁检查
- 设置合理的超时时间

✅ **集成 Kubernetes**
- 配置 livenessProbe
- 配置 readinessProbe
- 设置合理的探测参数

✅ **标准化响应格式**
- 返回结构化的健康状态
- 包含详细的检查结果
- 便于监控和调试

---

## 快速上手示例

完整的最小可用健康检查系统：

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from datetime import datetime
import time
from typing import Dict, Any

app = FastAPI()

# 应用启动时间
@app.on_event("startup")
async def startup():
    app.state.start_time = time.time()

# 健康检查缓存
health_cache: Dict[str, Any] = {
    "last_check": 0,
    "checks": {}
}

# 依赖检查函数
async def check_database() -> bool:
    try:
        # 实际项目中替换为真实的数据库检查
        await db.execute("SELECT 1")
        return True
    except Exception:
        return False

async def check_redis() -> bool:
    try:
        # 实际项目中替换为真实的 Redis 检查
        await redis.ping()
        return True
    except Exception:
        return False

# 存活检查（简单快速）
@app.get("/health")
async def health():
    """只要进程运行就返回 200"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat()
    }

# 就绪检查（检查依赖服务，带缓存）
@app.get("/ready")
async def ready():
    """检查依赖服务是否可用"""
    now = time.time()

    # 缓存 30 秒
    if now - health_cache["last_check"] < 30:
        checks = health_cache["checks"]
    else:
        # 执行实际检查
        checks = {
            "database": await check_database(),
            "redis": await check_redis(),
        }
        health_cache.update({
            "last_check": now,
            "checks": checks
        })

    # 判断状态
    if not all(checks.values()):
        raise HTTPException(
            status_code=503,
            detail={
                "status": "not_ready",
                "checks": checks,
                "timestamp": datetime.utcnow().isoformat()
            }
        )

    return {
        "status": "ready",
        "checks": checks,
        "uptime": time.time() - app.state.start_time,
        "timestamp": datetime.utcnow().isoformat()
    }
```

**运行测试：**

```bash
# 启动服务
uvicorn main:app --reload

# 测试健康检查
curl http://localhost:8000/health
# 输出: {"status":"healthy","timestamp":"2026-02-13T01:00:00.000Z"}

curl http://localhost:8000/ready
# 输出: {"status":"ready","checks":{"database":true,"redis":true},...}
```

---

## 下一步学习

掌握最小可用知识后，可以继续学习：

1. **核心概念** - 深入理解 Liveness/Readiness/Startup 探测原理
2. **实战代码** - 学习更复杂的健康检查场景（AI Agent 特定检查、降级策略等）
3. **监控集成** - 将健康检查指标暴露给 Prometheus
4. **生产优化** - 实现熔断器、降级策略、告警规则

---

## 常见问题

**Q: /health 和 /ready 有什么区别？**

A:
- /health 检查进程是否存活（简单快速）
- /ready 检查服务是否准备好接收流量（检查依赖服务）
- Kubernetes 用 /health 决定是否重启，用 /ready 决定是否发流量

**Q: 为什么需要缓存健康检查结果？**

A:
- 健康检查会被频繁调用（每 5-10 秒）
- 每次都查询数据库会影响性能
- 缓存可以避免短暂抖动导致误报

**Q: 健康检查失败应该返回什么状态码？**

A:
- /health 失败：返回 500（进程有问题）
- /ready 失败：返回 503（服务暂时不可用）

**Q: 健康检查应该检查哪些依赖？**

A:
- 必须检查：数据库、缓存（如果是关键依赖）
- 可选检查：外部 API（如果不是关键依赖）
- 不要检查：非关键的第三方服务（避免误报）
