# 实战代码5：多维度限流

> 实现按用户、IP、端点的多维度限流

---

## 多维度限流器

```python
"""多维度限流器"""
import redis
from fastapi import FastAPI, Depends, HTTPException, Request
from enum import Enum

app = FastAPI()
redis_client = redis.Redis()

class UserTier(str, Enum):
    FREE = "free"
    PRO = "pro"

class MultiDimensionLimiter:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    async def check_limit(self, user_id: str, ip: str, endpoint: str, user_tier: str):
        # 1. 全局限流
        global_limiter = RedisTokenBucket(
            self.redis, "global", rate=1000, capacity=1000
        )
        if not global_limiter.acquire():
            raise HTTPException(status_code=503, detail="Service overloaded")

        # 2. IP 限流
        ip_limiter = RedisTokenBucket(
            self.redis, f"ip:{ip}", rate=10, capacity=10
        )
        if not ip_limiter.acquire():
            raise HTTPException(status_code=429, detail="Too many requests from this IP")

        # 3. 用户限流
        limits = {
            "free": {"rate": 1, "capacity": 10},
            "pro": {"rate": 100, "capacity": 1000}
        }
        user_limit = limits[user_tier]
        user_limiter = RedisTokenBucket(
            self.redis, f"user:{user_id}", **user_limit
        )
        if not user_limiter.acquire():
            raise HTTPException(status_code=429, detail=f"Rate limit exceeded for {user_tier}")

        # 4. 端点限流
        endpoint_limits = {
            "/chat": {"rate": 100, "capacity": 100},
            "/embedding": {"rate": 1000, "capacity": 1000}
        }
        endpoint_limit = endpoint_limits.get(endpoint, {"rate": 100, "capacity": 100})
        endpoint_limiter = RedisTokenBucket(
            self.redis, f"endpoint:{endpoint}", **endpoint_limit
        )
        if not endpoint_limiter.acquire():
            raise HTTPException(status_code=429, detail=f"Rate limit exceeded for {endpoint}")

limiter = MultiDimensionLimiter(redis_client)

async def rate_limit_dependency(request: Request):
    user_id = request.headers.get("X-User-ID", "anonymous")
    user_tier = request.headers.get("X-User-Tier", "free")
    ip = request.client.host
    endpoint = request.url.path

    await limiter.check_limit(user_id, ip, endpoint, user_tier)

@app.post("/chat")
async def chat(message: str, _: None = Depends(rate_limit_dependency)):
    return {"response": f"Echo: {message}"}

@app.post("/embedding")
async def embedding(text: str, _: None = Depends(rate_limit_dependency)):
    return {"embedding": [0.1, 0.2, 0.3]}
```

---

## 按 Token 数限流

```python
"""按 Token 数限流"""

def estimate_tokens(text: str) -> int:
    return int(len(text) * 1.3)

@app.post("/chat")
async def chat(message: str, request: Request):
    user_id = request.headers.get("X-User-ID", "anonymous")
    estimated_tokens = estimate_tokens(message)

    limiter = RedisTokenBucket(
        redis_client, f"user:{user_id}:tokens",
        rate=1000, capacity=10000
    )

    if not limiter.acquire(tokens=estimated_tokens):
        raise HTTPException(
            status_code=429,
            detail=f"Insufficient tokens. Required: {estimated_tokens}"
        )

    return {"response": f"Echo: {message}"}
```

---

**记住：** 多维度限流提供全面保护，需要按优先级检查（全局 → IP → 用户 → 端点）。
