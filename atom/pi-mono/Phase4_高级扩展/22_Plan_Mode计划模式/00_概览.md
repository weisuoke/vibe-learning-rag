# Plan Mode 计划模式 - 概览

> **核心理念：** Plan Mode 不是 pi-mono 的内置功能，而是一种通过扩展实现的规划模式，体现极简哲学。

---

## 文档导航

### 📚 学习路径

本知识点包含 **16 个文档**，按以下顺序学习效果最佳：

#### 第一阶段：理解核心概念（必读）

1. **[01_30字核心.md](./01_30字核心.md)** ⭐⭐⭐
   - 30 字理解 Plan Mode 的本质
   - 为什么不是内置功能
   - 三种实现方式概览

2. **[02_第一性原理.md](./02_第一性原理.md)** ⭐⭐⭐
   - Pi-mono 的极简哲学
   - 为什么 Plan Mode 不是内置功能
   - Observability vs. Black-box orchestration

3. **[10_一句话总结.md](./10_一句话总结.md)** ⭐⭐
   - 一句话总结 Plan Mode 的本质
   - 与其他工具的对比

#### 第二阶段：掌握核心概念（深入理解）

4. **[03_核心概念_01_Plan表示与文件存储.md](./03_核心概念_01_Plan表示与文件存储.md)** ⭐⭐⭐
   - Plan 的数据结构
   - 文件存储模式
   - JSON vs. Markdown

5. **[03_核心概念_02_Extension_API集成.md](./03_核心概念_02_Extension_API集成.md)** ⭐⭐⭐
   - Extension API 详解
   - registerCommand() 和 registerTool()
   - 事件处理机制

6. **[03_核心概念_03_Session状态管理.md](./03_核心概念_03_Session状态管理.md)** ⭐⭐⭐
   - Session 管理机制
   - CustomEntry 和 labels
   - 状态持久化

#### 第三阶段：实战应用（动手实践）

7. **[04_最小可用.md](./04_最小可用.md)** ⭐⭐
   - 20% 核心知识
   - 快速上手指南

8. **[05_双重类比.md](./05_双重类比.md)** ⭐⭐
   - TypeScript/Node.js 类比
   - 日常生活类比

9. **[06_反直觉点.md](./06_反直觉点.md)** ⭐⭐
   - 常见误区
   - 反直觉的设计决策

#### 第四阶段：代码实战（完整示例）

10. **[07_实战代码_01_文件式计划.md](./07_实战代码_01_文件式计划.md)** ⭐⭐⭐
    - 最简单的实现方式
    - 文件式规划完整代码
    - 100-200 行可运行代码

11. **[07_实战代码_02_Extension命令实现.md](./07_实战代码_02_Extension命令实现.md)** ⭐⭐⭐
    - /plan 和 /execute 命令
    - Extension 开发完整流程
    - 100-200 行可运行代码

12. **[07_实战代码_03_Session集成执行.md](./07_实战代码_03_Session集成执行.md)** ⭐⭐⭐
    - Session 状态管理
    - CustomEntry 实战
    - 100-200 行可运行代码

13. **[07_实战代码_04_完整Plan_Mode扩展.md](./07_实战代码_04_完整Plan_Mode扩展.md)** ⭐⭐⭐
    - 生产级完整实现
    - 混合三种方式
    - 300-400 行可运行代码

#### 第五阶段：进阶提升（面试与深化）

14. **[08_面试必问.md](./08_面试必问.md)** ⭐⭐
    - 10 个高频面试题
    - 深度技术问答

15. **[09_化骨绵掌.md](./09_化骨绵掌.md)** ⭐⭐
    - 10 张知识卡片
    - 每张 2 分钟速记

---

## 快速导航

### 按学习目标选择

| 学习目标 | 推荐文档 | 预计时间 |
|---------|---------|---------|
| **快速了解** | 01, 10 | 10 分钟 |
| **理解原理** | 01, 02, 10 | 30 分钟 |
| **掌握实现** | 01-06 | 2 小时 |
| **动手实践** | 01-06, 07_01-04 | 4 小时 |
| **面试准备** | 01-06, 08, 09 | 3 小时 |
| **完整学习** | 全部 16 个文档 | 6-8 小时 |

### 按实现方式选择

| 实现方式 | 核心文档 | 代码示例 |
|---------|---------|---------|
| **文件式规划** | 03_核心概念_01 | 07_实战代码_01 |
| **扩展命令** | 03_核心概念_02 | 07_实战代码_02 |
| **Session 集成** | 03_核心概念_03 | 07_实战代码_03 |
| **完整实现** | 03_核心概念_01-03 | 07_实战代码_04 |

### 按角色选择

| 角色 | 推荐学习路径 |
|------|-------------|
| **初学者** | 01 → 02 → 04 → 05 → 07_01 |
| **开发者** | 01 → 02 → 03_01-03 → 07_01-04 |
| **架构师** | 01 → 02 → 03_01-03 → 06 → 08 |
| **面试者** | 01 → 02 → 03_01-03 → 08 → 09 |

---

## 核心知识点

### 1. Plan Mode 的本质

- **不是内置功能**：Pi-mono 不提供内置 Plan Mode
- **是一种模式**：通过扩展实现的工作流模式
- **三种实现方式**：文件式、扩展式、Session 集成式

### 2. 为什么不是内置功能？

- **极简哲学**：核心保持简单，复杂性在扩展中
- **可观察性**：文件优先，状态可见
- **用户控制**：用户决定规划工作流
- **可组合性**：与其他扩展组合使用

### 3. 三种实现方式

#### 方式 1：文件式规划
- **原理**：将计划写入文件
- **优势**：最大可观察性
- **适用**：简单任务、快速原型

#### 方式 2：扩展命令
- **原理**：注册 /plan 和 /execute 命令
- **优势**：最佳用户体验
- **适用**：频繁使用、团队协作

#### 方式 3：Session 集成
- **原理**：使用 Session 管理状态
- **优势**：状态持久化
- **适用**：复杂任务、长期项目

### 4. 核心 API

```typescript
// Extension API
api.registerCommand(config: CommandConfig): void
api.registerTool(config: ToolConfig): void
api.setState(state: Record<string, any>): Promise<void>
api.getState(): Record<string, any>
api.disableTools(tools: string[]): void
api.enableTools(tools: string[]): void

// Session API
api.createSession(config: SessionConfig): Promise<Session>
api.switchSession(sessionId: string): Promise<void>
api.getSession(sessionId: string): Session
```

---

## 学习建议

### 初学者（0-3 个月经验）

1. **先理解概念**：阅读 01, 02, 10
2. **看类比理解**：阅读 05
3. **动手实践**：跟着 07_01 写代码
4. **避免误区**：阅读 06

### 有经验开发者（3-12 个月）

1. **快速过概念**：阅读 01, 02
2. **深入核心**：阅读 03_01-03
3. **实战练习**：完成 07_01-04 所有代码
4. **面试准备**：阅读 08, 09

### 高级开发者（12+ 个月）

1. **直接看原理**：阅读 02
2. **关注反直觉**：阅读 06
3. **研究完整实现**：阅读 07_04
4. **准备面试**：阅读 08

---

## 常见问题

### Q1: Pi-mono 有 Plan Mode 吗？

**A:** 没有内置 Plan Mode，但提供原语让你构建任何规划工作流。

### Q2: 我应该用哪种实现方式？

**A:**
- **简单任务**：文件式规划
- **频繁使用**：扩展命令
- **复杂项目**：Session 集成
- **生产环境**：完整实现（混合三种方式）

### Q3: 与 Claude Code 的 Plan Mode 有什么区别？

**A:**
- **Claude Code**：内置功能，黑盒编排
- **Pi-mono**：扩展实现，用户控制

### Q4: 与 Oh-my-pi 的 /plan 命令有什么区别？

**A:**
- **Oh-my-pi**：内置 /plan 命令，功能丰富
- **Pi-mono**：扩展实现，极简灵活

### Q5: 我需要学习所有三种实现方式吗？

**A:**
- **初学者**：先学文件式（最简单）
- **开发者**：学扩展式（最常用）
- **架构师**：学完整实现（最强大）

---

## 相关资源

### 官方文档

- [Pi-mono GitHub](https://github.com/badlogic/pi-mono)
- [Extension API 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md)
- [Plan Mode 示例](https://github.com/badlogic/pi-mono/tree/main/packages/coding-agent/examples/extensions/plan-mode)

### 社区资源

- [Oh-my-pi](https://github.com/can1357/oh-my-pi) - 内置 /plan 命令的 fork
- [@juanibiapina/pi-plan](https://www.npmjs.com/package/@juanibiapina/pi-plan) - 社区 Plan Mode 扩展

### 博客文章

- [What I learned building pi coding agent](https://mariozechner.at/posts/2025-11-30-pi-coding-agent) - Mario Zechner
- [Pi: The Minimal Agent](https://lucumr.pocoo.org/2026/1/31/pi) - Armin Ronacher

### 研究资料

本文档基于 2025-2026 年最新研究，详见 `temp/` 目录：
- `01_grok_llm_planning_architecture.md` - LLM 规划系统架构
- `02_grok_ai_agent_patterns.md` - AI 代理任务规划模式
- `03_grok_pi_mono_extensions.md` - Pi-mono 扩展 API
- `04_grok_pi_mono_examples.md` - Pi-mono 扩展示例
- `05_grok_ai_coding_workflow.md` - AI 编码工作流
- `06_grok_oh_my_pi.md` - Oh-my-pi 实现

---

## 版本信息

- **版本**: v1.0
- **最后更新**: 2026-02-21
- **维护者**: Claude Code
- **基于**: Pi-mono 2026 版本

---

**开始学习：** 建议从 [01_30字核心.md](./01_30字核心.md) 开始！
