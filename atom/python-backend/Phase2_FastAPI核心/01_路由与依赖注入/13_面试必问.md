# 面试必问

> 路由与依赖注入的高频面试问题和出彩回答

---

## 问题1："FastAPI 的依赖注入和 Express 的中间件有什么区别？"

### 普通回答（❌ 不出彩）

"FastAPI 用 Depends()，Express 用 app.use()，都是用来处理请求的。"

### 出彩回答（✅ 推荐）

> **FastAPI 的依赖注入和 Express 中间件有三个核心区别：**
>
> **1. 显式 vs 隐式**
> - Express 中间件通过修改 `req` 对象传递数据（隐式）
> - FastAPI 通过函数参数注入（显式），类型安全
>
> ```javascript
> // Express - 隐式
> app.use((req, res, next) => {
>   req.user = getUser(); // 修改 req 对象
>   next();
> });
> app.get('/profile', (req, res) => {
>   res.json(req.user); // 从 req 读取
> });
> ```
>
> ```python
> # FastAPI - 显式
> def get_user():
>     return User(...)
>
> @app.get("/profile")
> async def profile(user: User = Depends(get_user)):
>     return user  # 直接使用参数
> ```
>
> **2. 资源管理**
> - Express 需要手动管理资源生命周期（try/finally）
> - FastAPI 使用生成器（yield）自动管理
>
> ```python
> def get_db():
>     db = SessionLocal()
>     try:
>         yield db  # 注入
>     finally:
>         db.close()  # 自动清理
> ```
>
> **3. 依赖缓存**
> - Express 中间件每次都执行
> - FastAPI 同一请求中依赖被缓存
>
> **在 AI Agent 后端开发中的应用：**
> - 数据库连接：FastAPI 的 yield 确保连接自动关闭
> - 认证授权：依赖链（token → user → permissions）更清晰
> - LLM 客户端：依赖注入便于测试和替换

### 为什么这个回答出彩？

1. ✅ 从三个维度对比（显式性、资源管理、缓存）
2. ✅ 提供代码示例说明差异
3. ✅ 联系实际应用场景（AI Agent 后端）
4. ✅ 展示对两个框架的深入理解

---

## 问题2："FastAPI 的依赖注入是如何实现的？"

### 普通回答（❌ 不出彩）

"FastAPI 用 Depends() 来注入依赖，框架会自动调用依赖函数。"

### 出彩回答（✅ 推荐）

> **FastAPI 的依赖注入基于 Python 的类型注解和函数签名检查：**
>
> **1. 解析阶段（应用启动时）**
> - FastAPI 检查路由函数的签名
> - 识别 `Depends()` 参数
> - 构建依赖图（依赖的依赖）
> - 确定执行顺序
>
> **2. 执行阶段（请求到达时）**
> - 按依赖图顺序执行依赖函数
> - 缓存依赖结果（同一请求）
> - 注入到路由函数参数
> - 请求结束后清理资源（yield 的 finally）
>
> **3. 核心机制**
>
> ```python
> # 简化的实现原理
> def resolve_dependencies(func):
>     # 1. 解析函数签名
>     sig = inspect.signature(func)
>
>     # 2. 找出所有 Depends() 参数
>     dependencies = {}
>     for param_name, param in sig.parameters.items():
>         if isinstance(param.default, Depends):
>             dependencies[param_name] = param.default.dependency
>
>     # 3. 执行依赖函数
>     async def wrapper(*args, **kwargs):
>         resolved = {}
>         for name, dep_func in dependencies.items():
>             # 递归解析依赖的依赖
>             resolved[name] = await resolve_dependencies(dep_func)()
>
>         # 4. 注入到路由函数
>         return await func(*args, **kwargs, **resolved)
>
>     return wrapper
> ```
>
> **4. 与其他框架的对比**
> - Spring：编译时注解 + 反射
> - Angular：装饰器 + 依赖注入器
> - FastAPI：运行时类型检查 + 函数签名

### 为什么这个回答出彩？

1. ✅ 分解实现原理（解析阶段 + 执行阶段）
2. ✅ 提供简化的实现代码
3. ✅ 对比其他框架的实现方式
4. ✅ 展示对底层机制的理解

---

## 问题3："什么时候应该使用依赖注入？"

### 普通回答（❌ 不出彩）

"需要复用代码的时候就用依赖注入。"

### 出彩回答（✅ 推荐）

> **依赖注入适用于以下场景：**
>
> **1. 资源管理（最常见）**
> - 数据库连接、文件句柄、网络连接
> - 需要确保资源正确关闭
>
> ```python
> def get_db():
>     db = SessionLocal()
>     try:
>         yield db
>     finally:
>         db.close()  # 保证关闭
> ```
>
> **2. 认证授权（安全相关）**
> - 验证 token、检查权限
> - 多个路由共享认证逻辑
>
> ```python
> def get_current_user(token: str = Header(...)):
>     user = verify_token(token)
>     if not user:
>         raise HTTPException(status_code=401)
>     return user
> ```
>
> **3. 配置和客户端（外部依赖）**
> - LLM 客户端、Redis 客户端
> - 便于测试时替换
>
> ```python
> def get_llm_client():
>     return OpenAI(api_key=settings.OPENAI_API_KEY)
>
> # 测试时替换
> app.dependency_overrides[get_llm_client] = lambda: MockLLM()
> ```
>
> **4. 参数验证和转换（复杂逻辑）**
> - 多个参数组合验证
> - 封装为类更清晰
>
> ```python
> class Pagination:
>     def __init__(self, page: int = 1, page_size: int = 10):
>         self.skip = (page - 1) * page_size
>         self.limit = page_size
> ```
>
> **不应该使用的场景：**
> - ❌ 简单的参数传递（直接用函数参数）
> - ❌ 一次性的逻辑（不需要复用）
> - ❌ 纯计算函数（无副作用）

### 为什么这个回答出彩？

1. ✅ 列举具体场景和原因
2. ✅ 提供代码示例
3. ✅ 说明不应该使用的场景（避免过度设计）
4. ✅ 展示对设计原则的理解

---

## 问题4："FastAPI 的 response_model 有什么作用？"

### 普通回答（❌ 不出彩）

"response_model 用来定义响应格式，可以过滤字段。"

### 出彩回答（✅ 推荐）

> **response_model 有三个核心作用：**
>
> **1. 安全过滤（最重要）**
> - 自动过滤敏感字段（password、api_key）
> - 防止数据泄露
>
> ```python
> class User(BaseModel):
>     id: int
>     username: str
>     password: str  # 敏感信息
>
> class UserResponse(BaseModel):
>     id: int
>     username: str  # 不包含 password
>
> @app.get("/users/{user_id}", response_model=UserResponse)
> async def get_user(user_id: int):
>     user = db.query(User).get(user_id)
>     return user  # FastAPI 自动过滤 password
> ```
>
> **2. 数据验证**
> - 确保响应数据符合定义
> - 运行时类型检查
>
> ```python
> @app.get("/items/{item_id}", response_model=Item)
> async def get_item(item_id: int):
>     return {"id": item_id, "price": "invalid"}  # ❌ 类型错误
> ```
>
> **3. 自动文档生成**
> - OpenAPI 文档自动包含响应示例
> - 前端可以根据文档生成类型定义
>
> **与手动过滤的对比：**
>
> ```python
> # ❌ 手动过滤（容易遗漏）
> @app.get("/users/{user_id}")
> async def get_user(user_id: int):
>     user = db.query(User).get(user_id)
>     return {
>         "id": user.id,
>         "username": user.username
>         # 忘记删除 password 会泄露
>     }
>
> # ✅ response_model（自动过滤）
> @app.get("/users/{user_id}", response_model=UserResponse)
> async def get_user(user_id: int):
>     return db.query(User).get(user_id)
> ```
>
> **在生产环境中的重要性：**
> - 2019年某社交平台因未过滤敏感字段泄露用户数据
> - response_model 是安全的第一道防线

### 为什么这个回答出彩？

1. ✅ 从三个维度说明作用（安全、验证、文档）
2. ✅ 对比手动过滤的风险
3. ✅ 联系生产环境的重要性
4. ✅ 展示对安全的重视

---

## 问题5："如何设计一个可扩展的 API 路由结构？"

### 普通回答（❌ 不出彩）

"用 APIRouter 把路由分到不同文件里。"

### 出彩回答（✅ 推荐）

> **可扩展的 API 路由结构应该遵循以下原则：**
>
> **1. 按功能模块划分（不是按 HTTP 方法）**
>
> ```
> app/
> ├── api/
> │   ├── auth.py          # 认证相关
> │   ├── users.py         # 用户管理
> │   ├── conversations.py # 对话管理
> │   └── chat.py          # 对话接口
> ```
>
> **2. 使用 APIRouter 组织路由**
>
> ```python
> # api/users.py
> router = APIRouter(
>     prefix="/users",
>     tags=["用户管理"],
>     dependencies=[Depends(verify_token)]  # 路由级依赖
> )
>
> @router.get("/")
> async def list_users(): ...
>
> @router.get("/{user_id}")
> async def get_user(user_id: int): ...
> ```
>
> **3. 分层依赖注入**
>
> ```python
> # 应用级依赖（所有路由）
> app = FastAPI(dependencies=[Depends(log_request)])
>
> # 路由器级依赖（特定模块）
> admin_router = APIRouter(
>     prefix="/admin",
>     dependencies=[Depends(verify_admin)]
> )
>
> # 路由级依赖（单个接口）
> @router.get("/sensitive", dependencies=[Depends(verify_2fa)])
> async def sensitive_data(): ...
> ```
>
> **4. 版本控制**
>
> ```python
> # 方式1：路径前缀
> v1_router = APIRouter(prefix="/v1")
> v2_router = APIRouter(prefix="/v2")
>
> # 方式2：子应用
> app.mount("/v1", v1_app)
> app.mount("/v2", v2_app)
> ```
>
> **5. 响应模型分离**
>
> ```python
> # schemas/user.py
> class UserCreate(BaseModel): ...    # 创建请求
> class UserUpdate(BaseModel): ...    # 更新请求
> class UserResponse(BaseModel): ...  # 标准响应
> class UserDetail(BaseModel): ...    # 详细响应
> ```
>
> **实际项目结构：**
>
> ```
> app/
> ├── main.py              # 主应用
> ├── api/
> │   ├── v1/
> │   │   ├── auth.py
> │   │   ├── users.py
> │   │   └── chat.py
> │   └── v2/
> │       └── chat.py      # 新版本接口
> ├── core/
> │   ├── deps.py          # 依赖注入
> │   └── security.py      # 安全相关
> ├── models/              # 数据库模型
> ├── schemas/             # Pydantic 模型
> └── services/            # 业务逻辑
> ```

### 为什么这个回答出彩？

1. ✅ 提供具体的设计原则
2. ✅ 展示完整的项目结构
3. ✅ 考虑版本控制和扩展性
4. ✅ 展示对架构设计的理解

---

## 问题6："依赖注入的缓存机制是如何工作的？"

### 普通回答（❌ 不出彩）

"同一个请求中，依赖只执行一次。"

### 出彩回答（✅ 推荐）

> **FastAPI 的依赖缓存机制：**
>
> **1. 缓存作用域**
> - 缓存范围：单个请求
> - 不同请求：独立执行
>
> ```python
> def get_timestamp():
>     print("执行")
>     return datetime.now()
>
> @app.get("/test")
> async def test(
>     ts1: datetime = Depends(get_timestamp),
>     ts2: datetime = Depends(get_timestamp)
> ):
>     # 只打印一次 "执行"
>     return {"ts1": ts1, "ts2": ts2, "same": ts1 == ts2}
> ```
>
> **2. 缓存键**
> - 基于依赖函数的标识（id）
> - 不是基于参数值
>
> ```python
> def get_user(user_id: int):
>     return db.query(User).get(user_id)
>
> @app.get("/test")
> async def test(
>     user1: User = Depends(lambda: get_user(1)),
>     user2: User = Depends(lambda: get_user(2))
> ):
>     # 两个 lambda 是不同的函数对象
>     # 会执行两次 get_user
> ```
>
> **3. 依赖链中的缓存**
>
> ```python
> def get_db():
>     print("创建连接")
>     db = SessionLocal()
>     try:
>         yield db
>     finally:
>         print("关闭连接")
>         db.close()
>
> def get_user(db: Session = Depends(get_db)):
>     print("查询用户")
>     return db.query(User).first()
>
> @app.get("/test")
> async def test(
>     user: User = Depends(get_user),
>     db: Session = Depends(get_db)  # 使用缓存的 db
> ):
>     # 输出：
>     # 创建连接
>     # 查询用户
>     # 关闭连接
>     return user
> ```
>
> **4. 禁用缓存**
>
> ```python
> @app.get("/test")
> async def test(
>     ts1: datetime = Depends(get_timestamp, use_cache=False),
>     ts2: datetime = Depends(get_timestamp, use_cache=False)
> ):
>     # 执行两次，ts1 != ts2
>     return {"ts1": ts1, "ts2": ts2}
> ```
>
> **5. 为什么需要缓存？**
> - 性能优化：避免重复计算
> - 一致性：同一请求中数据一致
> - 资源管理：数据库连接只创建一次

### 为什么这个回答出彩？

1. ✅ 详细解释缓存机制
2. ✅ 提供代码示例说明
3. ✅ 说明缓存的原因和价值
4. ✅ 展示对性能优化的理解

---

## 快速回答技巧

### 1. STAR 法则

- **S**ituation：场景
- **T**ask：任务
- **A**ction：行动
- **R**esult：结果

### 2. 对比法

- 与其他框架对比（Express、Spring）
- 与手动实现对比
- 优缺点对比

### 3. 分层法

- 原理层：底层实现
- 应用层：实际使用
- 架构层：设计模式

### 4. 举例法

- 代码示例
- 实际项目经验
- 常见问题和解决方案

---

## 面试准备清单

### 核心概念

- [ ] 理解路由装饰器的工作原理
- [ ] 理解依赖注入的实现机制
- [ ] 理解 response_model 的作用
- [ ] 理解依赖缓存机制

### 实战经验

- [ ] 能写出完整的 CRUD API
- [ ] 能实现 JWT 认证授权
- [ ] 能设计可扩展的路由结构
- [ ] 能处理复杂的依赖链

### 对比理解

- [ ] FastAPI vs Express
- [ ] FastAPI vs Django
- [ ] FastAPI vs Flask
- [ ] 依赖注入 vs 中间件

### 最佳实践

- [ ] 何时使用依赖注入
- [ ] 如何组织大型项目
- [ ] 如何处理错误
- [ ] 如何优化性能

---

**记住：** 面试不仅考察知识，更考察理解深度和实战经验！
