# 01_30字核心

> **本文档提供 RunnableLambda 的最精炼定义，帮助你在 30 秒内建立核心认知。**

---

## 核心定义

**RunnableLambda 是将 Python 函数转换为 Runnable 的适配器，实现自定义逻辑与 LCEL 链的无缝集成。**

---

## 拆解理解

让我们逐词理解这个定义：

### 1. "Python 函数"
- 指任何 Python callable 对象
- 包括普通函数、lambda 表达式、类方法等
- 你已经熟悉的编程工具

### 2. "转换为 Runnable"
- Runnable 是 LangChain 的统一接口协议
- 提供 invoke、batch、stream 等标准方法
- 让函数获得"LangChain 公民身份"

### 3. "适配器"
- 设计模式中的适配器模式
- 不改变原函数，只是包装一层
- 就像给函数穿上"Runnable 外套"

### 4. "自定义逻辑"
- 你的业务逻辑、数据处理、特殊算法
- 不受 LangChain 内置组件限制
- 完全由你控制的代码

### 5. "LCEL 链"
- LangChain Expression Language 表达式链
- 通过 | 操作符组合的处理管道
- 统一的组合和执行框架

### 6. "无缝集成"
- 不需要额外的胶水代码
- 自动获得重试、回调、配置等特性
- 与其他 Runnable 组件平等协作

---

## 一句话类比

**前端类比:**
> RunnableLambda 就像 Express 的中间件包装器，把普通函数变成符合框架规范的中间件。

**日常生活类比:**
> RunnableLambda 就像给工人办理工作证，让他能进入工厂流水线工作。

---

## 最小示例

```python
from langchain_core.runnables import RunnableLambda

# 普通函数
def uppercase(text: str) -> str:
    return text.upper()

# 转换为 Runnable
runnable = RunnableLambda(uppercase)

# 现在可以用 Runnable 的方式调用
result = runnable.invoke("hello")  # "HELLO"

# 可以组合到链中
chain = runnable | RunnableLambda(lambda x: x + "!")
chain.invoke("hello")  # "HELLO!"
```

---

## 核心价值（3 点）

### 1. 灵活性
- 任何 Python 代码都能加入 LangChain 链
- 不受框架内置组件限制
- 完全自定义的处理逻辑

### 2. 统一性
- 获得 Runnable 的标准接口
- invoke、batch、stream 等方法
- 与其他组件无缝协作

### 3. 生产级
- 自动获得重试、回调、配置等特性
- 支持异步优化（通过 afunc）
- 企业级的可靠性保障

---

## 典型应用场景

| 场景 | 说明 | 示例 |
|------|------|------|
| **数据预处理** | 清洗、标准化、格式转换 | 文本去空格、JSON 解析 |
| **业务逻辑** | 特定领域的计算和判断 | 价格计算、权限检查 |
| **外部集成** | 调用第三方 API 或服务 | 数据库查询、API 调用 |
| **条件路由** | 根据输入动态选择路径 | 根据语言选择模型 |
| **结果后处理** | 格式化、过滤、排序 | RAG 检索结果重排序 |

---

## 与直接调用函数的区别

| 维度 | 直接调用函数 | RunnableLambda |
|------|-------------|----------------|
| **调用方式** | `result = func(input)` | `result = runnable.invoke(input)` |
| **组合能力** | 需要手动嵌套 | 通过 \| 操作符链式组合 |
| **批处理** | 需要手动循环 | 内置 `.batch()` 方法 |
| **异步支持** | 需要自己实现 | 内置 `.ainvoke()` 方法 |
| **错误重试** | 需要自己实现 | `.with_retry()` 一行搞定 |
| **配置传递** | 需要手动管理 | 自动传递 config |
| **可观测性** | 需要自己实现 | 自动支持回调和追踪 |

---

## 何时使用 RunnableLambda

### ✅ 适合使用的场景

1. **需要在 LCEL 链中插入自定义逻辑**
   - 内置组件无法满足需求
   - 需要特定的业务处理

2. **需要 Runnable 的标准接口**
   - 批处理、异步、重试等特性
   - 与其他 Runnable 组合

3. **简单的数据转换和处理**
   - 一两行代码的简单逻辑
   - 不需要复杂的状态管理

### ❌ 不适合使用的场景

1. **复杂的业务逻辑**
   - 建议自定义 Runnable 类
   - 更好的可读性和可维护性

2. **需要复杂状态管理**
   - RunnableLambda 是无状态的
   - 考虑使用 RunnableGenerator 或自定义类

3. **性能敏感的场景**
   - 如果不提供 afunc，异步性能较差
   - 需要仔细优化异步执行

---

## 核心要点速记

1. **本质**: 函数到 Runnable 的适配器
2. **目的**: 让自定义逻辑融入 LCEL 链
3. **价值**: 灵活性 + 统一性 + 生产级特性
4. **用法**: `RunnableLambda(func)` 然后用 | 组合
5. **优化**: 提供 `afunc` 参数实现真正的异步
6. **陷阱**: 过度使用会降低可读性

---

## 下一步学习

- **深入理解**: 阅读 `02_第一性原理.md` 了解设计哲学
- **核心概念**: 阅读 `03_核心概念_*.md` 掌握技术细节
- **实战应用**: 阅读 `07_实战代码_*.md` 学习实际场景
- **避坑指南**: 阅读 `06_反直觉点.md` 了解常见误区

---

## 引用来源

- [LangChain 官方文档 - RunnableLambda](https://python.langchain.com/docs/expression_language/primitives/lambda) - 官方定义和基础用法
- [LangChain API Reference v0.3](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.base.RunnableLambda.html) - 完整 API 文档
- [Building Production-Ready AI Pipelines with LangChain (2026)](https://medium.com/@techsachin/building-production-ready-ai-pipelines-with-langchain-a-comprehensive-guide-2026-edition) - 生产级应用指南

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: LangChain v0.3+
**Python 版本**: 3.13+
