# 类型系统与泛型 - 最小可用

## 20% 核心知识解决 80% 问题

掌握以下内容，就能开始在 LangChain 项目中使用类型系统：

---

## 4.1 基础类型注解

**核心知识**：给函数参数和返回值添加类型注解

```python
# 基础语法
def greet(name: str) -> str:
    return f"Hello, {name}"

# 常用类型
def process(
    text: str,
    count: int,
    enabled: bool,
    items: list[str],
    config: dict[str, Any]
) -> str:
    return text * count
```

**在 LangChain 中**：
```python
from langchain_core.runnables import RunnableLambda

def to_upper(text: str) -> str:
    return text.upper()

runnable = RunnableLambda(to_upper)
# 类型自动推断为 Runnable[str, str]
```

**这足以**：
- 让 IDE 提供自动补全
- 让类型检查器发现基本错误
- 让代码意图更清晰

---

## 4.2 TypeVar 和 Generic 基础

**核心知识**：创建泛型函数和类

```python
from typing import TypeVar, Generic

# 定义类型变量
T = TypeVar('T')

# 泛型函数
def first(items: list[T]) -> T:
    return items[0]

# 泛型类
class Box(Generic[T]):
    def __init__(self, value: T):
        self.value = value

    def get(self) -> T:
        return self.value

# 使用
numbers = [1, 2, 3]
result: int = first(numbers)  # 类型推断为 int

int_box: Box[int] = Box(42)
value: int = int_box.get()
```

**在 LangChain 中**：
```python
from langchain_core.runnables import Runnable

# Runnable 就是泛型类
# Runnable[Input, Output]
chain: Runnable[str, int] = ...
```

**这足以**：
- 创建类型安全的容器
- 理解 LangChain 的类型系统
- 编写可复用的泛型代码

---

## 4.3 Runnable[Input, Output] 类型

**核心知识**：理解 LangChain 的核心类型

```python
from langchain_core.runnables import Runnable, RunnableLambda

# 每个 Runnable 都有输入输出类型
def format_prompt(topic: str) -> dict:
    return {"topic": topic}

def count_words(text: str) -> int:
    return len(text.split())

# 创建 Runnable（类型自动推断）
formatter: Runnable[str, dict] = RunnableLambda(format_prompt)
counter: Runnable[str, int] = RunnableLambda(count_words)

# 组合（类型检查器验证兼容性）
# ✅ 正确：str -> dict
chain1 = formatter | ...

# ❌ 错误：dict -> int（counter 期望 str）
# chain2 = formatter | counter  # 类型错误
```

**关键规则**：
- `Runnable[A, B] | Runnable[B, C] = Runnable[A, C]`
- 前一个的输出类型必须匹配后一个的输入类型

**这足以**：
- 构建类型安全的 LCEL 管道
- 在编译时发现组合错误
- 理解 LangChain 的设计哲学

---

## 4.4 类型检查器基础

**核心知识**：使用 mypy 或 pyright 检查类型

```bash
# 安装
uv add --dev mypy pyright

# 检查代码
mypy src/
pyright src/

# 基础配置
# mypy.ini
[mypy]
python_version = 3.13
warn_return_any = True
disallow_untyped_defs = True

# pyrightconfig.json
{
  "pythonVersion": "3.13",
  "typeCheckingMode": "strict"
}
```

**常见错误和修复**：

```python
# 错误1：参数类型不匹配
def add(a: int, b: int) -> int:
    return a + b

add("hello", "world")  # ❌ 类型错误
# 修复：传入正确类型
add(5, 3)  # ✅

# 错误2：返回类型不匹配
def get_name() -> str:
    return 42  # ❌ 类型错误
# 修复：返回正确类型
def get_name() -> str:
    return "Alice"  # ✅

# 错误3：可选类型未检查
def greet(name: str | None) -> str:
    return f"Hello, {name.upper()}"  # ❌ name 可能是 None
# 修复：检查 None
def greet(name: str | None) -> str:
    if name is None:
        return "Hello, stranger"
    return f"Hello, {name.upper()}"  # ✅
```

**这足以**：
- 在编译时发现大部分类型错误
- 提高代码质量
- 减少运行时错误

---

## 4.5 Optional 和 Union 类型

**核心知识**：处理可选值和多种类型

```python
from typing import Optional

# Optional[T] = T | None
def find_user(user_id: int) -> Optional[str]:
    if user_id > 0:
        return f"User {user_id}"
    return None

# 使用时检查 None
user = find_user(1)
if user is not None:
    print(user.upper())  # ✅ 类型安全

# Union：多种类型之一
def process(value: int | str) -> str:
    if isinstance(value, int):
        return str(value * 2)
    else:
        return value.upper()
```

**在 LangChain 中**：
```python
from langchain_core.messages import BaseMessage

# ChatModel 可以接受多种输入
def process_input(
    input: str | list[BaseMessage]
) -> list[BaseMessage]:
    if isinstance(input, str):
        return [HumanMessage(content=input)]
    return input
```

**这足以**：
- 处理可能为空的值
- 处理多种类型的输入
- 避免 None 相关的错误

---

## 快速参考卡

### 类型注解速查

```python
# 基础类型
x: int = 42
name: str = "Alice"
flag: bool = True

# 容器类型
numbers: list[int] = [1, 2, 3]
data: dict[str, int] = {"age": 30}
point: tuple[int, int] = (10, 20)

# 可选类型
name: str | None = None
name: Optional[str] = None  # 旧语法

# 函数类型
def add(a: int, b: int) -> int:
    return a + b

# 泛型类型
from typing import TypeVar, Generic

T = TypeVar('T')

class Box(Generic[T]):
    def __init__(self, value: T):
        self.value = value
```

### LangChain 类型速查

```python
from langchain_core.runnables import Runnable, RunnableLambda
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_openai import ChatOpenAI

# 基础组件类型
prompt: Runnable[dict, PromptValue]
model: Runnable[PromptValue, AIMessage]
parser: Runnable[AIMessage, str]

# 组合
chain: Runnable[dict, str] = prompt | model | parser

# 自定义 Runnable
def to_upper(text: str) -> str:
    return text.upper()

runnable: Runnable[str, str] = RunnableLambda(to_upper)
```

### 类型检查速查

```bash
# 检查代码
mypy src/
pyright src/

# 忽略错误
result = some_function()  # type: ignore

# 配置文件
# mypy.ini
[mypy]
python_version = 3.13
strict = True

# pyrightconfig.json
{
  "pythonVersion": "3.13",
  "typeCheckingMode": "strict"
}
```

---

## 实战练习

### 练习1：类型安全的数据处理

```python
from langchain_core.runnables import RunnableLambda

# 定义类型明确的函数
def clean_text(text: str) -> str:
    return text.strip().lower()

def extract_words(text: str) -> list[str]:
    return text.split()

def count_items(items: list[str]) -> int:
    return len(items)

# 构建管道
cleaner = RunnableLambda(clean_text)
extractor = RunnableLambda(extract_words)
counter = RunnableLambda(count_items)

# 组合
pipeline = cleaner | extractor | counter
# 类型：Runnable[str, int]

# 使用
result: int = pipeline.invoke("  Hello World  ")
print(result)  # 2
```

### 练习2：类型安全的配置

```python
from typing import TypedDict, Literal

# 定义配置类型
Environment = Literal["dev", "staging", "prod"]

class Config(TypedDict):
    environment: Environment
    debug: bool
    api_key: str

# 使用
config: Config = {
    "environment": "dev",
    "debug": True,
    "api_key": "secret"
}

# ❌ 类型错误
# bad_config: Config = {
#     "environment": "development",  # 不是有效的 Environment
#     "debug": True,
#     "api_key": "secret"
# }
```

### 练习3：类型检查集成

```bash
# 1. 安装类型检查器
uv add --dev mypy pyright

# 2. 创建配置文件
cat > mypy.ini << EOF
[mypy]
python_version = 3.13
warn_return_any = True
disallow_untyped_defs = True
EOF

# 3. 运行检查
mypy src/
pyright src/

# 4. 修复错误
# 根据错误提示修改代码
```

---

## 常见问题

### Q1: 什么时候需要类型注解？

**A**:
- ✅ 函数签名（参数和返回值）
- ✅ 公共 API
- ✅ 空容器（`list[int] = []`）
- ❌ 局部变量（类型可推断）
- ❌ 显而易见的类型（`x = 42`）

### Q2: 类型注解会影响性能吗？

**A**: 不会。类型注解是纯静态的，运行时零开销。

### Q3: mypy 和 pyright 选哪个？

**A**:
- **mypy**: Python 官方推荐，社区广泛使用
- **pyright**: 更快（3-5倍），错误提示更好
- **推荐**: 两个都用，互补

### Q4: 如何处理第三方库没有类型注解？

**A**:
```bash
# 方案1：安装 type stubs
uv add --dev types-requests

# 方案2：忽略该库
# mypy.ini
[mypy-some_library.*]
ignore_missing_imports = True
```

### Q5: 如何在 LangChain 中使用类型？

**A**:
```python
from langchain_core.runnables import Runnable

# 显式类型注解
chain: Runnable[str, str] = prompt | model | parser

# 类型检查器会验证组合的正确性
```

---

## 下一步学习

掌握了这 20% 的核心知识后，你可以：

1. **深入学习**：阅读核心概念系列，了解更多细节
2. **实战应用**：查看实战代码系列，学习实际应用
3. **巩固知识**：阅读化骨绵掌，快速复习所有知识点

**推荐学习路径**：
1. 核心概念 1：类型注解基础
2. 核心概念 2：TypeVar 与泛型
3. 核心概念 4：Runnable 泛型设计
4. 核心概念 9：mypy 与 pyright
5. 实战代码系列

---

## 学习检查清单

- [ ] 能够给函数添加类型注解
- [ ] 理解 TypeVar 和 Generic 的基本用法
- [ ] 理解 Runnable[Input, Output] 的含义
- [ ] 能够使用 mypy 或 pyright 检查代码
- [ ] 能够处理 Optional 和 Union 类型
- [ ] 能够构建类型安全的 LangChain 管道
- [ ] 能够修复常见的类型错误

---

## 总结

**20% 核心知识**：
1. 基础类型注解
2. TypeVar 和 Generic
3. Runnable[Input, Output]
4. 类型检查器
5. Optional 和 Union

**解决 80% 问题**：
- ✅ 编写类型安全的代码
- ✅ 构建 LangChain 管道
- ✅ 在编译时发现错误
- ✅ 提高代码质量
- ✅ 改善开发体验

**记住**：类型系统是工具，不是目的。从简单开始，逐步深入。
