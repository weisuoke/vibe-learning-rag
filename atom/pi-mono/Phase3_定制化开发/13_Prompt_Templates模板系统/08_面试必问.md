# 面试必问

## 为什么会被问到 Prompt Templates？

在 AI Agent 开发面试中，Prompt Templates 是一个重要话题，因为：

1. **实践经验的体现** - 展示你是否真正使用过 AI Agent 工具
2. **工程思维的考察** - 考察你对提示词工程化的理解
3. **架构设计的能力** - 考察你对模板系统设计的理解
4. **最佳实践的掌握** - 考察你是否了解行业标准

---

## 基础问题（初级）

### Q1: 什么是 Prompt Templates？为什么需要它？

**标准答案：**

Prompt Templates 是一种将提示词模板化、参数化的机制，用于解决提示词的复用性、维护性和协作性问题。

**核心要点：**
1. **复用性** - 避免重复编写相似的提示词
2. **维护性** - 集中管理，易于更新
3. **协作性** - 团队共享最佳实践
4. **版本控制** - 追踪历史和回滚

**加分回答：**
- 提到 2025-2026 年的行业趋势（Markdown + Git 管理）
- 提到实际应用场景（代码审查、问题分析等）
- 提到与其他模板系统的对比

**参考资料：**
- [Awesome AI System Prompts](https://github.com/dontriskit/awesome-ai-system-prompts) - 2025 年顶级 AI 工具系统提示精选集

---

### Q2: Pi-mono 的 Prompt Templates 使用什么语法？

**标准答案：**

Pi-mono 使用 **Bash 风格的变量替换语法**，而不是常见的 `{{variable}}` 语法。

**核心语法：**
- `$1`, `$2`, ... - 位置参数
- `$@` / `$ARGUMENTS` - 所有参数
- `${@:N}` - 从第 N 个参数开始
- `${@:N:L}` - 从第 N 个参数开始，取 L 个

**示例：**
```markdown
---
description: Review PR
---
Review this PR: $1
All PRs: $@
From 2nd PR: ${@:2}
```

**加分回答：**
- 解释为什么选择 Bash 风格（CLI 工具友好、开发者熟悉）
- 对比其他模板语法（Handlebars、Jinja2）
- 提到位置参数的优势

---

### Q3: Prompt Templates 存储在哪里？

**标准答案：**

Pi-mono 支持多源加载，有明确的优先级顺序：

1. **项目模板**：`./.pi/prompts/` （优先级最高）
2. **全局模板**：`~/.pi/agent/prompts/` （优先级中等）
3. **显式路径**：通过 CLI 或配置指定（优先级最低）

**加分回答：**
- 解释为什么项目模板优先级高（项目特定性）
- 提到文件系统加载的优势（零配置、版本控制友好）
- 提到命名约定（使用前缀组织模板）

---

### Q4: 如何创建和使用一个简单的模板？

**标准答案：**

**创建模板：**
```bash
cat > ~/.pi/agent/prompts/greet.md << 'EOF'
---
description: Greet user
---
Hello, $1!
EOF
```

**使用模板：**
```bash
pi
/greet World
```

**输出：**
```
Hello, World!
```

**加分回答：**
- 提到 YAML frontmatter 是可选的
- 提到模板名称区分大小写
- 提到模板不需要注册

---

### Q5: YAML Frontmatter 的作用是什么？

**标准答案：**

YAML Frontmatter 用于存储模板的元数据，是可选的。

**常用字段：**
- `description` - 模板描述
- `author` - 作者信息
- `version` - 版本号
- `tags` - 标签分类

**示例：**
```markdown
---
description: Review GitHub PRs
author: team@example.com
version: 1.0.0
tags: [code-review, pr, github]
---
Template content here...
```

**加分回答：**
- 提到 frontmatter 是可选的
- 提到何时应该使用 frontmatter
- 提到与 Jekyll、Hugo 的相似性

---

## 进阶问题（中级）

### Q6: 项目模板和全局模板有什么区别？何时使用哪个？

**标准答案：**

**区别：**
- **项目模板**（`./.pi/prompts/`）：项目特定，优先级高
- **全局模板**（`~/.pi/agent/prompts/`）：跨项目通用，优先级低

**使用场景：**

**项目模板：**
- 项目特定的提示词（如项目的测试约定）
- 团队协作的标准模板
- 需要版本控制的模板

**全局模板：**
- 通用的提示词（如代码审查、问题分析）
- 个人常用的模板
- 跨项目复用的模板

**加分回答：**
- 提到优先级顺序（项目 > 全局）
- 提到如何避免命名冲突
- 提到团队协作的最佳实践

**参考资料：**
- [Reddit: 生产环境演化提示模板管理](https://www.reddit.com/r/PromptEngineering/comments/1nwynw5/how_do_you_manage_dozens_of_evolving_prompts_in/)

---

### Q7: 如何使用参数切片？

**标准答案：**

参数切片允许你获取部分参数，类似于数组切片。

**语法：**
- `${@:N}` - 从第 N 个参数开始的所有参数
- `${@:N:L}` - 从第 N 个参数开始，取 L 个参数

**示例：**
```markdown
---
description: Compare files
---
Base file: $1
Files to compare: ${@:2}
```

**调用：**
```bash
/compare base.ts file1.ts file2.ts file3.ts
```

**输出：**
```
Base file: base.ts
Files to compare: file1.ts file2.ts file3.ts
```

**加分回答：**
- 提到与 TypeScript 数组切片的类比
- 提到实际应用场景（比较多个文件）
- 提到与 Bash 脚本的相似性

---

### Q8: 模板内容会如何处理？

**标准答案：**

模板内容会**直接发送给 LLM**，不会有额外的处理步骤。

**重要影响：**
1. **模板质量直接影响 LLM 输出** - 需要编写高质量的提示词
2. **需要包含完整的上下文** - 不能假设 Pi 会自动添加信息
3. **透明性** - 你看到的就是 LLM 看到的

**示例：**
```markdown
# ❌ 糟糕的模板（缺少上下文）
Review $1

# ✅ 好的模板（包含完整上下文）
You are an expert code reviewer.

Review the following PR: $1

Focus on:
- Code quality and readability
- Potential bugs or issues
- Best practices

Provide specific, actionable feedback.
```

**加分回答：**
- 提到 Anthropic 的 context engineering 最佳实践
- 提到如何编写高质量的提示词
- 提到常见错误（假设会自动添加上下文）

**参考资料：**
- [Anthropic: Effective context engineering for AI agents](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents)

---

### Q9: 如何组织大量的模板？

**标准答案：**

由于 Pi-mono 不支持子目录，推荐使用**命名约定**组织模板。

**命名约定：**
```
<category>-<action>-<target>.md

示例：
code-review-pr.md
code-refactor-legacy.md
docs-generate-api.md
docs-update-readme.md
team-analyze-bug.md
team-design-feature.md
```

**加分回答：**
- 提到为什么不支持子目录（简单性、性能）
- 提到如何使用 Git 管理模板
- 提到团队协作的最佳实践

**参考资料：**
- [Reddit: 大型代理提示存储与模板变量](https://www.reddit.com/r/PromptEngineering/comments/1n3ybtu/how_are_you_storing_and_managing_larger_prompts/)

---

### Q10: 模板修改后需要重启 Pi 吗？

**标准答案：**

**是的，需要重启 Pi。**

Pi-mono 会缓存模板，修改模板后不会自动重载。

**解决方案：**
```bash
# 方法 1: 退出并重启
exit
pi

# 方法 2: 使用 Ctrl+C 退出
# (在 pi 中按 Ctrl+C)
pi

# 方法 3: 开发模式（使用脚本）
cat > test-template.sh << 'EOF'
#!/bin/bash
pi -c "/test $@"
EOF
chmod +x test-template.sh
./test-template.sh arg1 arg2
```

**加分回答：**
- 解释为什么需要缓存（性能、一致性）
- 提到开发工作流的最佳实践
- 提到未来可能的改进（热重载）

---

## 高级问题（高级）

### Q11: Pi-mono 的 Prompt Templates 与其他模板系统有什么区别？

**标准答案：**

**核心区别：**

| 特性 | Pi-mono | Handlebars | LangChain |
|------|---------|------------|-----------|
| **语法** | Bash 风格 (`$1`) | `{{variable}}` | `{variable}` |
| **格式** | Markdown + YAML | 任意文本 | Python 字符串 |
| **加载** | 文件系统 | 编程加载 | 代码定义 |
| **调用** | 命令行 `/name` | 编程调用 | 编程调用 |
| **版本控制** | 原生支持（Git） | 需要额外管理 | 代码版本控制 |

**设计哲学：**
- **极简主义** - 零依赖、零配置、零学习成本
- **CLI 友好** - 命令行风格，适合交互式使用
- **开发者友好** - 使用熟悉的格式和语法

**加分回答：**
- 提到第一性原理（从根本问题出发）
- 提到为什么选择这些设计（约束即自由）
- 提到 2025-2026 年的行业验证

---

### Q12: 如何实现模板的版本控制和团队协作？

**标准答案：**

**版本控制：**
```bash
# 1. 初始化 Git 仓库
cd ~/.pi/agent/prompts
git init
git add .
git commit -m "Initial commit"

# 2. 推送到远程仓库
git remote add origin https://github.com/team/pi-templates.git
git push -u origin main

# 3. 团队成员克隆
git clone https://github.com/team/pi-templates.git ~/.pi/agent/prompts
```

**团队协作：**
1. **统一标准** - 使用项目模板统一团队标准
2. **代码审查** - 通过 PR 审查模板变更
3. **文档化** - 在 frontmatter 中添加元数据
4. **测试** - 编写测试脚本验证模板

**加分回答：**
- 提到 Git 工作流（feature branch、PR、merge）
- 提到模板测试的最佳实践
- 提到文档化的重要性

**参考资料：**
- [GitHub: Awesome AI System Prompts](https://github.com/dontriskit/awesome-ai-system-prompts) - 使用 Git 管理系统提示

---

### Q13: 如何设计一个高质量的模板？

**标准答案：**

**设计原则：**

1. **明确角色**
```markdown
You are an expert code reviewer with 10+ years of experience.
```

2. **提供上下文**
```markdown
You are reviewing a TypeScript codebase that uses:
- React for UI
- Jest for testing
- ESLint for linting
```

3. **清晰指令**
```markdown
Review the following PR: $1

Focus on:
1. Code quality and readability
2. Potential bugs or issues
3. Performance considerations
4. Best practices
```

4. **结构化输出**
```markdown
Provide your review in the following format:

## Summary
[Brief summary of changes]

## Issues
[List of issues found]

## Suggestions
[Specific, actionable suggestions]
```

**加分回答：**
- 提到 Anthropic 的 prompt engineering 指南
- 提到如何测试和优化模板
- 提到常见错误和如何避免

**参考资料：**
- [Anthropic: Effective context engineering for AI agents](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents)
- [The Ultimate Guide to AI Prompt Engineering [2025]](https://www.v7labs.com/blog/prompt-engineering-guide)

---

### Q14: Pi-mono 的模板系统有哪些限制？如何解决？

**标准答案：**

**主要限制：**

1. **不支持条件逻辑**
   - 限制：不能使用 if/else、for 循环
   - 解决：创建多个专门的模板

2. **不支持子目录**
   - 限制：所有模板必须在根目录
   - 解决：使用命名约定（前缀）

3. **不支持热重载**
   - 限制：修改模板需要重启 Pi
   - 解决：使用脚本快速测试

4. **不支持模板组合**
   - 限制：不能在模板中引用其他模板
   - 解决：手动复制粘贴或使用外部工具

**加分回答：**
- 解释为什么有这些限制（极简主义）
- 提到这些限制的优势（简单性、可维护性）
- 提到如何在限制内实现复杂功能

---

### Q15: 如何测试和调试模板？

**标准答案：**

**测试方法：**

1. **单元测试**
```bash
# 创建测试脚本
cat > test-templates.sh << 'EOF'
#!/bin/bash

# 测试 greet 模板
echo "Testing greet template..."
result=$(pi -c "/greet World")
if [[ $result == *"Hello, World"* ]]; then
  echo "✅ greet test passed"
else
  echo "❌ greet test failed"
  exit 1
fi

echo "All tests passed!"
EOF

chmod +x test-templates.sh
./test-templates.sh
```

2. **集成测试**
```bash
# 测试完整工作流
pi -c "/pr https://github.com/user/repo/pull/123" > output.txt
# 检查输出是否包含期望的内容
grep "Summary" output.txt
grep "Issues" output.txt
grep "Suggestions" output.txt
```

3. **调试技巧**
```bash
# 查看模板内容
cat ~/.pi/agent/prompts/template.md

# 检查 YAML frontmatter
head -n 5 ~/.pi/agent/prompts/template.md

# 测试变量替换
pi -c "/template test-arg"
```

**加分回答：**
- 提到 CI/CD 集成
- 提到模板质量评估
- 提到常见错误和调试方法

---

## 场景问题（实战）

### Q16: 如何为团队创建一套标准的代码审查模板？

**标准答案：**

**步骤：**

1. **定义审查标准**
```markdown
---
description: Team code review checklist
author: team@example.com
version: 1.0.0
---
# Code Review Checklist

**PR URL:** $1

## Code Quality
- [ ] Follows team style guide
- [ ] No code smells
- [ ] Proper error handling

## Testing
- [ ] Unit tests included
- [ ] Edge cases covered

## Documentation
- [ ] Code comments where needed
- [ ] README updated

## Security
- [ ] No vulnerabilities
- [ ] Input validation
```

2. **版本控制**
```bash
cd ./.pi/prompts
git add team-review.md
git commit -m "Add team code review template"
git push
```

3. **团队培训**
- 文档化使用方法
- 演示实际使用
- 收集反馈并改进

**加分回答：**
- 提到如何收集团队需求
- 提到如何持续改进模板
- 提到如何衡量模板效果

---

### Q17: 如何处理多语言项目的模板？

**标准答案：**

**方案 1: 创建语言特定的模板**
```bash
# TypeScript 项目
cat > ./.pi/prompts/test-ts.md << 'EOF'
---
description: Generate TypeScript tests
---
Generate Jest tests for: $1

Use TypeScript and follow our conventions:
- Test file: *.test.ts
- Coverage: 80%+
EOF

# Python 项目
cat > ./.pi/prompts/test-py.md << 'EOF'
---
description: Generate Python tests
---
Generate pytest tests for: $1

Use Python and follow our conventions:
- Test file: test_*.py
- Coverage: 90%+
EOF
```

**方案 2: 使用参数指定语言**
```markdown
---
description: Generate tests for any language
---
Generate tests for $1 in $2 language.

Follow best practices for $2:
- Use standard testing framework
- Include edge cases
- Aim for high coverage
```

**调用：**
```bash
/test src/utils.ts TypeScript
/test src/utils.py Python
```

**加分回答：**
- 提到如何组织多语言模板
- 提到如何避免重复
- 提到如何维护一致性

---

### Q18: 如何实现模板的 A/B 测试？

**标准答案：**

**方案：**

1. **创建两个版本的模板**
```bash
# 版本 A: 简洁风格
cat > ~/.pi/agent/prompts/review-a.md << 'EOF'
---
description: Code review (concise)
---
Review $1. Focus on critical issues only.
EOF

# 版本 B: 详细风格
cat > ~/.pi/agent/prompts/review-b.md << 'EOF'
---
description: Code review (detailed)
---
Review $1 thoroughly.

Analyze:
1. Code quality
2. Potential bugs
3. Performance
4. Best practices

Provide detailed feedback.
EOF
```

2. **收集数据**
```bash
# 使用版本 A
pi -c "/review-a $PR_URL" > result-a.txt

# 使用版本 B
pi -c "/review-b $PR_URL" > result-b.txt

# 比较结果
diff result-a.txt result-b.txt
```

3. **评估效果**
- 输出质量
- 响应时间
- Token 使用量
- 用户满意度

**加分回答：**
- 提到如何设计实验
- 提到如何收集和分析数据
- 提到如何做出决策

---

## 系统设计问题

### Q19: 如果让你设计一个 Prompt Templates 系统，你会如何设计？

**标准答案：**

**核心考虑：**

1. **格式选择**
   - Markdown + YAML frontmatter（人类可读 + 机器可解析）
   - 支持富文本格式（代码块、列表等）

2. **变量语法**
   - Bash 风格（CLI 工具友好）
   - 支持位置参数和参数切片

3. **存储方式**
   - 文件系统（零配置、版本控制友好）
   - 多源加载（全局 + 项目）

4. **调用方式**
   - 命令行风格（简洁、交互式友好）
   - `/template-name args` 格式

5. **扩展性**
   - 支持自定义函数（可选）
   - 支持模板组合（可选）
   - 支持条件逻辑（可选）

**权衡：**
- **简单性 vs. 功能性** - 优先简单性
- **性能 vs. 灵活性** - 优先性能
- **学习成本 vs. 强大功能** - 优先低学习成本

**加分回答：**
- 提到第一性原理思维
- 提到极简主义哲学
- 提到实际验证和迭代

---

### Q20: Pi-mono 的模板系统体现了哪些设计原则？

**标准答案：**

**核心设计原则：**

1. **极简主义**
   - 零依赖、零配置、零学习成本
   - 只提供最核心的功能
   - 避免不必要的复杂性

2. **约定优于配置**
   - 文件名即模板名
   - 文件位置决定优先级
   - 不需要注册机制

3. **工具适应人**
   - 使用开发者熟悉的格式（Markdown、YAML、Bash）
   - 使用开发者熟悉的工具（文本编辑器、Git）
   - 使用开发者熟悉的工作流（文件系统、命令行）

4. **透明性**
   - 你看到的就是 LLM 看到的
   - 没有隐藏的处理步骤
   - 易于理解和调试

5. **可扩展性**
   - 支持全局和项目级别
   - 支持版本控制
   - 支持团队协作

**加分回答：**
- 提到 Unix 哲学（一切皆文件、简单可组合）
- 提到极简主义的力量（约束即自由）
- 提到 2025-2026 年的行业验证

**参考资料：**
- [Reddit: LLM真实系统提示Markdown结构化](https://www.reddit.com/r/PromptEngineering/comments/1pseks9/for_people_building_real_systems_with_llms_how_do/)

---

## 面试技巧

### 如何准备 Prompt Templates 相关面试？

1. **实践经验**
   - 实际使用 Pi-mono 创建和使用模板
   - 为个人项目创建模板库
   - 参与开源项目的模板贡献

2. **理论知识**
   - 理解第一性原理
   - 理解设计权衡
   - 理解行业最佳实践

3. **案例准备**
   - 准备 2-3 个实际案例
   - 说明问题、解决方案、效果
   - 展示思考过程

4. **对比分析**
   - 了解其他模板系统（Handlebars、Jinja2、LangChain）
   - 理解各自的优缺点
   - 能够做出合理的选择

### 回答技巧

1. **结构化回答**
   - 先说结论
   - 再说理由
   - 最后举例

2. **展示思考**
   - 说明权衡
   - 说明选择
   - 说明验证

3. **联系实际**
   - 举实际例子
   - 说明应用场景
   - 展示效果

4. **保持谦虚**
   - 承认不足
   - 说明改进方向
   - 展示学习能力

---

## 总结

**面试中最重要的 5 个点：**

1. **理解本质** - Prompt Templates 是提示词工程化的工具
2. **掌握语法** - Bash 风格变量替换
3. **理解设计** - 极简主义、约定优于配置
4. **实践经验** - 实际使用和创建模板
5. **持续学习** - 关注行业最佳实践

**记住：** 面试不仅考察知识，更考察思维方式和解决问题的能力。

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
