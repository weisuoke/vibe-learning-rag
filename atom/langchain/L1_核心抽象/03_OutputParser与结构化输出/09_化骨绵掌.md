# 化骨绵掌

10 个 2 分钟知识卡片，系统掌握 OutputParser 与结构化输出。

---

## 卡片 1：直觉理解 - 什么是结构化输出？

**一句话：** LLM 输出是字符串，应用需要对象，OutputParser 是类型转换器。

**举例：**

```python
# LLM 输出（字符串）
llm_output = '{"name": "Alice", "age": 25}'

# 应用需要（对象）
person = Person(name="Alice", age=25)
database.save(person)  # 数据库需要对象，不是字符串
```

**应用：** RAG 系统提取文档元数据、Agent 格式化工具响应

---

## 卡片 2：形式化定义 - OutputParser 协议

**一句话：** OutputParser 是基于 Runnable 的协议，定义了 parse()、get_format_instructions() 等标准接口。

**核心方法：**

```python
class BaseOutputParser(Runnable[str, T]):
    def parse(self, text: str) -> T:
        """字符串 → 对象"""
        pass

    def get_format_instructions(self) -> str:
        """生成格式指令（注入到 Prompt）"""
        pass

    def get_output_schema(self) -> dict:
        """返回 JSON Schema（2025+ 新增）"""
        pass
```

**应用：** 所有解析器都遵循这个协议，可以互换使用

---

## 卡片 3：现代方法 - with_structured_output()（2025+ 推荐）

**一句话：** 利用模型原生工具调用能力，直接返回结构化对象，无需格式指令。

**代码：**

```python
from langchain_openai import ChatOpenAI
from pydantic import BaseModel

class Person(BaseModel):
    name: str
    age: int

llm = ChatOpenAI(model="gpt-4o")
structured_llm = llm.with_structured_output(Person)
result = structured_llm.invoke("Alice is 25")  # 直接返回 Person 对象
```

**应用：** 2025-2026 年最佳实践，适用于 GPT-4o、Claude 3.5+、Gemini 2.5

---

## 卡片 4：传统方法 - PydanticOutputParser

**一句话：** 在 Prompt 中注入格式指令，引导 LLM 返回符合 Pydantic 模型的 JSON。

**代码：**

```python
from langchain.output_parsers import PydanticOutputParser

parser = PydanticOutputParser(pydantic_object=Person)
format_instructions = parser.get_format_instructions()  # 生成格式指令

prompt = PromptTemplate(
    template="提取：{text}\n\n{format_instructions}",
    partial_variables={"format_instructions": format_instructions}
)
chain = prompt | llm | parser
```

**应用：** 兼容不支持原生结构化输出的模型（GPT-3.5-turbo 旧版、开源模型）

---

## 卡片 5：简单解析 - JsonOutputParser

**一句话：** 只做基本 JSON 解析，无 Pydantic 验证，返回 dict。

**代码：**

```python
from langchain.output_parsers import JsonOutputParser

parser = JsonOutputParser()  # 无需 Pydantic 模型
result = parser.parse('{"name": "Alice", "age": 25}')
print(type(result))  # <class 'dict'>
```

**应用：** 快速原型开发、简单场景、不需要类型检查

---

## 卡片 6：错误修复 - OutputFixingParser

**一句话：** 解析失败时，调用 LLM 修复错误的输出，增加 1 次 LLM 调用。

**代码：**

```python
from langchain.output_parsers import OutputFixingParser

fixing_parser = OutputFixingParser.from_llm(
    parser=base_parser,
    llm=llm
)

# 自动修复错误输出
bad_output = '{"name": "Alice", "age": "twenty-five"}'  # age 应该是数字
result = fixing_parser.parse(bad_output)  # 自动调用 LLM 修复
```

**应用：** 高价值任务、复杂结构、可接受额外成本

---

## 卡片 7：重试机制 - RetryOutputParser

**一句话：** 解析失败时，使用原始 Prompt 重新调用 LLM 生成输出。

**代码：**

```python
from langchain.output_parsers import RetryWithErrorOutputParser

retry_parser = RetryWithErrorOutputParser.from_llm(
    parser=base_parser,
    llm=llm,
    max_retries=3
)

# 需要提供原始 Prompt
result = retry_parser.parse_with_prompt(bad_output, prompt_value)
```

**应用：** 临时性错误（网络波动、API 限流）、高可靠性要求

---

## 卡片 8：对比区分 - 何时使用哪种 Parser？

**决策树：**

```
需要结构化输出？
└─ 是 → 模型支持原生工具调用？
    ├─ 是 → with_structured_output() ✅（2025+ 推荐）
    └─ 否 → 需要错误修复？
        ├─ 是 → 任务价值高？
        │   ├─ 是 → OutputFixingParser（可接受成本）
        │   └─ 否 → 优化 Prompt
        └─ 否 → PydanticOutputParser（标准方案）
```

**成本对比：**
- with_structured_output()：1x 成本
- PydanticOutputParser：1x 成本 + 格式指令 token
- OutputFixingParser：1.5x 成本（平均）
- RetryOutputParser：2x 成本（平均）

---

## 卡片 9：实际应用 - RAG 与 Agent 集成

**RAG 元数据提取：**

```python
class DocumentMetadata(BaseModel):
    title: str
    author: str
    keywords: List[str]
    category: str

extractor = llm.with_structured_output(DocumentMetadata)
metadata = extractor.invoke(f"提取元数据：{document_text}")

# 存入向量数据库（带结构化元数据）
vector_store.add_documents(
    documents=[document_text],
    metadatas=[metadata.dict()]
)

# 基于元数据检索
results = vector_store.similarity_search(
    query="Python",
    filter={"category": "技术"}  # 结构化过滤
)
```

**Agent 工具响应：**

```python
class WeatherResponse(BaseModel):
    city: str
    temperature: float
    condition: str

formatter = llm.with_structured_output(WeatherResponse)
formatted = formatter.invoke(f"格式化：{raw_weather_data}")

# Agent 基于结构化数据做决策
if formatted.temperature < 10:
    agent.decide("建议穿厚外套")
```

---

## 卡片 10：总结延伸 - 2025-2026 趋势与未来

**技术演进：**

```
2024 前：手动 JSON 解析 + 字符串处理
   ↓
2024-2025：PydanticOutputParser 成为标准
   ↓
2025-2026：with_structured_output() 成为最佳实践
   ↓
未来：更多模型支持原生结构化输出
```

**2025-2026 关键特性：**
- **LangChain 1.0**：with_structured_output() 成为核心 API
- **OpenAI**：`response_format` 参数支持 JSON Schema
- **Anthropic**：Claude 3.5+ 改进的 Tool Use 精度
- **Google**：Gemini 2.5 新增原生支持

**最佳实践：**
1. **优先使用 with_structured_output()**（如果模型支持）
2. **监控修复率**（> 20% 应优化 Prompt）
3. **成本意识**（修复和重试增加 50-100% 成本）
4. **类型安全**（使用 Pydantic V2 进行验证）
5. **错误处理**（始终用 try-except 捕获 ValidationError）

**未来趋势：**
- 更多模型支持原生结构化输出
- 更复杂的嵌套结构支持
- 更好的错误提示和调试工具
- 与 TypeScript 等类型系统的深度集成

**延伸学习：**
- Pydantic V2 高级特性（验证器、序列化）
- LangChain LCEL 表达式（链式组合）
- LangGraph 状态管理（复杂工作流）
- 生产环境监控和优化

---

## 学习检查清单

完成以下检查，确保掌握 OutputParser：

- [ ] 理解 LLM 输出字符串与应用需求对象的矛盾
- [ ] 掌握 with_structured_output() 的基础用法
- [ ] 了解 PydanticOutputParser 的工作原理
- [ ] 知道何时使用 OutputFixingParser 和 RetryOutputParser
- [ ] 能够定义 Pydantic 模型（字段约束、嵌套、验证器）
- [ ] 掌握错误处理策略（try-except、降级、监控）
- [ ] 理解成本差异（修复和重试的额外成本）
- [ ] 能够在 RAG 系统中提取结构化元数据
- [ ] 能够在 Agent 中格式化工具响应
- [ ] 了解 2025-2026 年的技术演进和最佳实践

---

**记住**：OutputParser 是 AI 应用从 Demo 到生产的关键基础设施，掌握它是构建可靠 AI 系统的必经之路！
