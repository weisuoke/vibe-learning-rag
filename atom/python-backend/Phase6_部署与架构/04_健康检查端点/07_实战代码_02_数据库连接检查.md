# å®æˆ˜ä»£ç 2ï¼šæ•°æ®åº“è¿æ¥æ£€æŸ¥

> SQLAlchemy è¿æ¥æ± å¥åº·æ£€æŸ¥çš„å®Œæ•´å®ç°

---

## æ¦‚è¿°

æœ¬æ–‡æä¾›æ•°æ®åº“è¿æ¥å¥åº·æ£€æŸ¥çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬ï¼š
- ç®€å•è¿æ¥æ£€æŸ¥
- è¿æ¥æ± çŠ¶æ€æ£€æŸ¥
- æ€§èƒ½æ£€æŸ¥
- è¶…æ—¶ä¸é‡è¯•æœºåˆ¶
- å®Œæ•´çš„æ•°æ®åº“å¥åº·æ£€æŸ¥å™¨

---

## å®Œæ•´ä»£ç 

```python
"""
æ•°æ®åº“è¿æ¥å¥åº·æ£€æŸ¥å®ç°
æ¼”ç¤ºï¼šSQLAlchemy è¿æ¥æ± å¥åº·æ£€æŸ¥
"""

from fastapi import FastAPI, HTTPException
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.pool import Pool
from sqlalchemy import text
from pydantic import BaseModel
from typing import Dict, Optional
import asyncio
import time

# ===== 1. æ•°æ®åº“é…ç½® =====

# æ•°æ®åº“è¿æ¥ URL
DATABASE_URL = "postgresql+asyncpg://user:password@localhost:5432/dbname"

# åˆ›å»ºå¼‚æ­¥å¼•æ“
engine = create_async_engine(
    DATABASE_URL,
    pool_size=10,              # è¿æ¥æ± å¤§å°
    max_overflow=20,           # æœ€å¤§æº¢å‡ºè¿æ¥æ•°
    pool_timeout=30,           # è·å–è¿æ¥è¶…æ—¶æ—¶é—´
    pool_recycle=3600,         # è¿æ¥å›æ”¶æ—¶é—´ï¼ˆ1å°æ—¶ï¼‰
    echo=False                 # ä¸æ‰“å° SQL
)

# åˆ›å»ºä¼šè¯å·¥å‚
async_session = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# ===== 2. FastAPI åº”ç”¨ =====

app = FastAPI(title="Database Health Check")

# ===== 3. å“åº”æ¨¡å‹ =====

class DatabaseHealthResponse(BaseModel):
    """æ•°æ®åº“å¥åº·æ£€æŸ¥å“åº”"""
    healthy: bool
    duration_ms: int
    pool_status: Optional[Dict] = None
    error: Optional[str] = None

# ===== 4. ç®€å•è¿æ¥æ£€æŸ¥ =====

async def check_database_simple() -> bool:
    """
    ç®€å•çš„æ•°æ®åº“è¿æ¥æ£€æŸ¥

    åªæ£€æŸ¥èƒ½å¦è¿æ¥æ•°æ®åº“
    """
    try:
        async with async_session() as session:
            # æ‰§è¡Œç®€å•æŸ¥è¯¢
            await asyncio.wait_for(
                session.execute(text("SELECT 1")),
                timeout=3.0
            )
        return True
    except Exception as e:
        print(f"âŒ Database check failed: {e}")
        return False

@app.get("/health/db/simple")
async def health_db_simple():
    """ç®€å•çš„æ•°æ®åº“å¥åº·æ£€æŸ¥"""
    start_time = time.time()

    healthy = await check_database_simple()
    duration_ms = int((time.time() - start_time) * 1000)

    if not healthy:
        raise HTTPException(503, "Database unavailable")

    return {
        "healthy": healthy,
        "duration_ms": duration_ms
    }

# ===== 5. è¿æ¥æ± çŠ¶æ€æ£€æŸ¥ =====

def get_pool_status(pool: Pool) -> Dict:
    """
    è·å–è¿æ¥æ± çŠ¶æ€

    è¿”å›è¿æ¥æ± çš„è¯¦ç»†ä¿¡æ¯
    """
    return {
        "size": pool.size(),              # è¿æ¥æ± å¤§å°
        "checked_in": pool.checkedin(),   # å¯ç”¨è¿æ¥æ•°
        "checked_out": pool.checkedout(), # ä½¿ç”¨ä¸­çš„è¿æ¥æ•°
        "overflow": pool.overflow(),      # æº¢å‡ºè¿æ¥æ•°
        "total": pool.size() + pool.overflow()  # æ€»è¿æ¥æ•°
    }

async def check_database_with_pool() -> DatabaseHealthResponse:
    """
    æ•°æ®åº“å¥åº·æ£€æŸ¥ï¼ˆåŒ…å«è¿æ¥æ± çŠ¶æ€ï¼‰

    æ£€æŸ¥æ•°æ®åº“è¿æ¥å¹¶è¿”å›è¿æ¥æ± çŠ¶æ€
    """
    start_time = time.time()

    try:
        # 1. æ‰§è¡Œç®€å•æŸ¥è¯¢
        async with async_session() as session:
            await asyncio.wait_for(
                session.execute(text("SELECT 1")),
                timeout=3.0
            )

        # 2. è·å–è¿æ¥æ± çŠ¶æ€
        pool: Pool = engine.pool
        pool_status = get_pool_status(pool)

        # 3. æ£€æŸ¥è¿æ¥æ± æ˜¯å¦æ¥è¿‘å®¹é‡
        usage_percent = pool_status["checked_out"] / pool_status["size"]
        if usage_percent > 0.9:
            print(f"âš ï¸  Warning: Connection pool usage is {usage_percent:.1%}")

        duration_ms = int((time.time() - start_time) * 1000)

        return DatabaseHealthResponse(
            healthy=True,
            duration_ms=duration_ms,
            pool_status=pool_status
        )

    except asyncio.TimeoutError:
        duration_ms = int((time.time() - start_time) * 1000)
        return DatabaseHealthResponse(
            healthy=False,
            duration_ms=duration_ms,
            error="Database query timeout"
        )
    except Exception as e:
        duration_ms = int((time.time() - start_time) * 1000)
        return DatabaseHealthResponse(
            healthy=False,
            duration_ms=duration_ms,
            error=str(e)
        )

@app.get("/health/db/pool", response_model=DatabaseHealthResponse)
async def health_db_pool():
    """æ•°æ®åº“å¥åº·æ£€æŸ¥ï¼ˆåŒ…å«è¿æ¥æ± çŠ¶æ€ï¼‰"""
    result = await check_database_with_pool()

    if not result.healthy:
        raise HTTPException(503, detail=result.dict())

    return result

# ===== 6. æ€§èƒ½æ£€æŸ¥ =====

async def check_database_performance() -> DatabaseHealthResponse:
    """
    æ•°æ®åº“æ€§èƒ½æ£€æŸ¥

    æ£€æŸ¥æ•°æ®åº“å“åº”æ—¶é—´æ˜¯å¦æ­£å¸¸
    """
    start_time = time.time()

    try:
        async with async_session() as session:
            await asyncio.wait_for(
                session.execute(text("SELECT 1")),
                timeout=3.0
            )

        duration_ms = int((time.time() - start_time) * 1000)

        # åˆ¤æ–­æ€§èƒ½
        if duration_ms > 1000:
            # æŸ¥è¯¢è¶…è¿‡ 1 ç§’ï¼Œæ€§èƒ½ä¸‹é™
            print(f"âš ï¸  Warning: Database query slow ({duration_ms}ms)")
            return DatabaseHealthResponse(
                healthy=True,
                duration_ms=duration_ms,
                error=f"Slow query: {duration_ms}ms"
            )

        return DatabaseHealthResponse(
            healthy=True,
            duration_ms=duration_ms
        )

    except Exception as e:
        duration_ms = int((time.time() - start_time) * 1000)
        return DatabaseHealthResponse(
            healthy=False,
            duration_ms=duration_ms,
            error=str(e)
        )

@app.get("/health/db/performance", response_model=DatabaseHealthResponse)
async def health_db_performance():
    """æ•°æ®åº“æ€§èƒ½æ£€æŸ¥"""
    result = await check_database_performance()

    if not result.healthy:
        raise HTTPException(503, detail=result.dict())

    return result

# ===== 7. å¸¦é‡è¯•çš„å¥åº·æ£€æŸ¥ =====

async def check_database_with_retry(
    max_retries: int = 2,
    retry_delay: float = 0.5
) -> DatabaseHealthResponse:
    """
    å¸¦é‡è¯•çš„æ•°æ®åº“å¥åº·æ£€æŸ¥

    å¦‚æœç¬¬ä¸€æ¬¡å¤±è´¥ï¼Œä¼šé‡è¯•æŒ‡å®šæ¬¡æ•°
    """
    for attempt in range(max_retries + 1):
        start_time = time.time()

        try:
            async with async_session() as session:
                await asyncio.wait_for(
                    session.execute(text("SELECT 1")),
                    timeout=3.0
                )

            duration_ms = int((time.time() - start_time) * 1000)

            return DatabaseHealthResponse(
                healthy=True,
                duration_ms=duration_ms
            )

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)

            if attempt < max_retries:
                # é‡è¯•å‰ç­‰å¾…
                print(f"âš ï¸  Database check failed (attempt {attempt + 1}/{max_retries + 1}), retrying...")
                await asyncio.sleep(retry_delay)
            else:
                # æœ€åä¸€æ¬¡é‡è¯•å¤±è´¥
                print(f"âŒ Database check failed after {max_retries + 1} attempts")
                return DatabaseHealthResponse(
                    healthy=False,
                    duration_ms=duration_ms,
                    error=str(e)
                )

@app.get("/health/db/retry", response_model=DatabaseHealthResponse)
async def health_db_retry():
    """å¸¦é‡è¯•çš„æ•°æ®åº“å¥åº·æ£€æŸ¥"""
    result = await check_database_with_retry(max_retries=2, retry_delay=0.5)

    if not result.healthy:
        raise HTTPException(503, detail=result.dict())

    return result

# ===== 8. å®Œæ•´çš„æ•°æ®åº“å¥åº·æ£€æŸ¥å™¨ =====

class DatabaseHealthChecker:
    """å®Œæ•´çš„æ•°æ®åº“å¥åº·æ£€æŸ¥å™¨"""

    def __init__(self, engine):
        self.engine = engine
        self.cache = {
            "last_check": 0,
            "result": None
        }
        self.cache_ttl = 30  # ç¼“å­˜ 30 ç§’

    async def check(self, use_cache: bool = True) -> DatabaseHealthResponse:
        """
        æ‰§è¡Œæ•°æ®åº“å¥åº·æ£€æŸ¥

        Args:
            use_cache: æ˜¯å¦ä½¿ç”¨ç¼“å­˜

        Returns:
            DatabaseHealthResponse: å¥åº·æ£€æŸ¥ç»“æœ
        """
        # æ£€æŸ¥ç¼“å­˜
        if use_cache and self.cache["result"]:
            now = time.time()
            if now - self.cache["last_check"] < self.cache_ttl:
                print("âœ… Using cached database health status")
                return self.cache["result"]

        print("ğŸ” Performing database health check...")
        start_time = time.time()

        try:
            # 1. æ‰§è¡Œç®€å•æŸ¥è¯¢
            async with async_session() as session:
                await asyncio.wait_for(
                    session.execute(text("SELECT 1")),
                    timeout=3.0
                )

            # 2. è·å–è¿æ¥æ± çŠ¶æ€
            pool: Pool = self.engine.pool
            pool_status = get_pool_status(pool)

            # 3. åˆ¤æ–­å¥åº·çŠ¶æ€
            duration_ms = int((time.time() - start_time) * 1000)
            warnings = []

            # æ£€æŸ¥æ€§èƒ½
            if duration_ms > 1000:
                warnings.append(f"Slow query: {duration_ms}ms")

            # æ£€æŸ¥è¿æ¥æ± 
            usage_percent = pool_status["checked_out"] / pool_status["size"]
            if usage_percent > 0.9:
                warnings.append(f"Pool usage high: {usage_percent:.1%}")

            result = DatabaseHealthResponse(
                healthy=True,
                duration_ms=duration_ms,
                pool_status=pool_status,
                error="; ".join(warnings) if warnings else None
            )

            # æ›´æ–°ç¼“å­˜
            self.cache = {
                "last_check": time.time(),
                "result": result
            }

            return result

        except asyncio.TimeoutError:
            duration_ms = int((time.time() - start_time) * 1000)
            result = DatabaseHealthResponse(
                healthy=False,
                duration_ms=duration_ms,
                error="Database query timeout"
            )

            # ä¸ç¼“å­˜å¤±è´¥ç»“æœ
            return result

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            result = DatabaseHealthResponse(
                healthy=False,
                duration_ms=duration_ms,
                error=str(e)
            )

            # ä¸ç¼“å­˜å¤±è´¥ç»“æœ
            return result

# åˆ›å»ºå…¨å±€å¥åº·æ£€æŸ¥å™¨
db_health_checker = DatabaseHealthChecker(engine)

@app.get("/health/db/complete", response_model=DatabaseHealthResponse)
async def health_db_complete():
    """å®Œæ•´çš„æ•°æ®åº“å¥åº·æ£€æŸ¥ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
    result = await db_health_checker.check(use_cache=True)

    if not result.healthy:
        raise HTTPException(503, detail=result.dict())

    return result

# ===== 9. å¯åŠ¨å’Œå…³é—­äº‹ä»¶ =====

@app.on_event("startup")
async def startup():
    """åº”ç”¨å¯åŠ¨"""
    print("ğŸš€ Starting application...")
    print(f"ğŸ“Š Database: {DATABASE_URL}")

    # æµ‹è¯•æ•°æ®åº“è¿æ¥
    try:
        result = await db_health_checker.check(use_cache=False)
        if result.healthy:
            print("âœ… Database connection successful")
        else:
            print(f"âŒ Database connection failed: {result.error}")
    except Exception as e:
        print(f"âŒ Database connection failed: {e}")

@app.on_event("shutdown")
async def shutdown():
    """åº”ç”¨å…³é—­"""
    print("ğŸ‘‹ Shutting down application...")

    # å…³é—­æ•°æ®åº“è¿æ¥
    await engine.dispose()
    print("âœ… Database connections closed")

# ===== 10. è¿è¡Œè¯´æ˜ =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("æ•°æ®åº“è¿æ¥å¥åº·æ£€æŸ¥å®ç°")
    print("=" * 50)
    print()
    print("ç«¯ç‚¹ï¼š")
    print("  /health/db/simple      - ç®€å•è¿æ¥æ£€æŸ¥")
    print("  /health/db/pool        - è¿æ¥æ± çŠ¶æ€æ£€æŸ¥")
    print("  /health/db/performance - æ€§èƒ½æ£€æŸ¥")
    print("  /health/db/retry       - å¸¦é‡è¯•çš„æ£€æŸ¥")
    print("  /health/db/complete    - å®Œæ•´æ£€æŸ¥ï¼ˆå¸¦ç¼“å­˜ï¼‰")
    print()
    print("æµ‹è¯•å‘½ä»¤ï¼š")
    print("  curl http://localhost:8000/health/db/simple")
    print("  curl http://localhost:8000/health/db/pool")
    print("  curl http://localhost:8000/health/db/complete")
    print()
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## ç¯å¢ƒé…ç½®

### 1. å®‰è£…ä¾èµ–

```bash
# ä½¿ç”¨ uv å®‰è£…ä¾èµ–
uv add fastapi uvicorn[standard] sqlalchemy[asyncio] asyncpg psycopg2-binary
```

### 2. é…ç½®æ•°æ®åº“

**åˆ›å»º .env æ–‡ä»¶ï¼š**

```bash
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/dbname
```

**æˆ–è€…ä½¿ç”¨ Docker å¯åŠ¨ PostgreSQLï¼š**

```bash
docker run -d \
  --name postgres \
  -e POSTGRES_USER=user \
  -e POSTGRES_PASSWORD=password \
  -e POSTGRES_DB=dbname \
  -p 5432:5432 \
  postgres:14
```

---

## è¿è¡Œç¤ºä¾‹

### 1. å¯åŠ¨æœåŠ¡

```bash
python main.py
```

### 2. æµ‹è¯•ç«¯ç‚¹

**ç®€å•è¿æ¥æ£€æŸ¥ï¼š**

```bash
curl http://localhost:8000/health/db/simple
```

**è¾“å‡ºï¼š**

```json
{
  "healthy": true,
  "duration_ms": 45
}
```

**è¿æ¥æ± çŠ¶æ€æ£€æŸ¥ï¼š**

```bash
curl http://localhost:8000/health/db/pool
```

**è¾“å‡ºï¼š**

```json
{
  "healthy": true,
  "duration_ms": 48,
  "pool_status": {
    "size": 10,
    "checked_in": 9,
    "checked_out": 1,
    "overflow": 0,
    "total": 10
  }
}
```

**æ€§èƒ½æ£€æŸ¥ï¼š**

```bash
curl http://localhost:8000/health/db/performance
```

**è¾“å‡ºï¼š**

```json
{
  "healthy": true,
  "duration_ms": 52
}
```

**å®Œæ•´æ£€æŸ¥ï¼ˆå¸¦ç¼“å­˜ï¼‰ï¼š**

```bash
# ç¬¬ä¸€æ¬¡è¯·æ±‚ï¼ˆæ‰§è¡Œå®é™…æ£€æŸ¥ï¼‰
curl http://localhost:8000/health/db/complete

# ç«‹å³å†æ¬¡è¯·æ±‚ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
curl http://localhost:8000/health/db/complete
```

---

## æ‰©å±•ç¤ºä¾‹ï¼šç›‘æ§è¿æ¥æ± ä½¿ç”¨ç‡

```python
"""
ç›‘æ§è¿æ¥æ± ä½¿ç”¨ç‡
å½“ä½¿ç”¨ç‡è¶…è¿‡é˜ˆå€¼æ—¶å‘Šè­¦
"""

from prometheus_client import Gauge

# å®šä¹‰ Prometheus æŒ‡æ ‡
db_pool_size = Gauge('db_pool_size', 'Database connection pool size')
db_pool_checked_out = Gauge('db_pool_checked_out', 'Database connections in use')
db_pool_usage_percent = Gauge('db_pool_usage_percent', 'Database pool usage percentage')

async def monitor_pool_usage():
    """ç›‘æ§è¿æ¥æ± ä½¿ç”¨ç‡"""
    pool: Pool = engine.pool
    pool_status = get_pool_status(pool)

    # æ›´æ–°æŒ‡æ ‡
    db_pool_size.set(pool_status["size"])
    db_pool_checked_out.set(pool_status["checked_out"])

    usage_percent = pool_status["checked_out"] / pool_status["size"]
    db_pool_usage_percent.set(usage_percent)

    # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
    if usage_percent > 0.9:
        print(f"âš ï¸  ALERT: Connection pool usage is {usage_percent:.1%}")
        # å‘é€å‘Šè­¦ï¼ˆå¦‚ Slackã€PagerDutyï¼‰

    return {
        "pool_status": pool_status,
        "usage_percent": usage_percent
    }

@app.get("/metrics/db/pool")
async def metrics_db_pool():
    """è¿æ¥æ± ä½¿ç”¨ç‡ç›‘æ§"""
    return await monitor_pool_usage()
```

---

## æ‰©å±•ç¤ºä¾‹ï¼šæ•°æ®åº“æŸ¥è¯¢æ€§èƒ½æµ‹è¯•

```python
"""
æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½æµ‹è¯•
æµ‹è¯•ä¸åŒç±»å‹çš„æŸ¥è¯¢æ€§èƒ½
"""

async def test_query_performance():
    """æµ‹è¯•æŸ¥è¯¢æ€§èƒ½"""
    results = {}

    async with async_session() as session:
        # 1. ç®€å•æŸ¥è¯¢
        start = time.time()
        await session.execute(text("SELECT 1"))
        results["simple_query_ms"] = int((time.time() - start) * 1000)

        # 2. è¡¨æŸ¥è¯¢ï¼ˆå¦‚æœæœ‰è¡¨ï¼‰
        start = time.time()
        try:
            await session.execute(text("SELECT COUNT(*) FROM users"))
            results["count_query_ms"] = int((time.time() - start) * 1000)
        except:
            results["count_query_ms"] = None

        # 3. å¤æ‚æŸ¥è¯¢ï¼ˆå¦‚æœæœ‰è¡¨ï¼‰
        start = time.time()
        try:
            await session.execute(text("""
                SELECT u.id, u.email, COUNT(c.id) as conversation_count
                FROM users u
                LEFT JOIN conversations c ON u.id = c.user_id
                GROUP BY u.id, u.email
                LIMIT 10
            """))
            results["complex_query_ms"] = int((time.time() - start) * 1000)
        except:
            results["complex_query_ms"] = None

    return results

@app.get("/health/db/performance/detailed")
async def health_db_performance_detailed():
    """è¯¦ç»†çš„æ•°æ®åº“æ€§èƒ½æµ‹è¯•"""
    return await test_query_performance()
```

---

## å…³é”®è¦ç‚¹

### 1. è¿æ¥æ± çŠ¶æ€

**å…³é”®æŒ‡æ ‡ï¼š**
- `size`ï¼šè¿æ¥æ± å¤§å°
- `checked_out`ï¼šä½¿ç”¨ä¸­çš„è¿æ¥æ•°
- `checked_in`ï¼šå¯ç”¨è¿æ¥æ•°
- `overflow`ï¼šæº¢å‡ºè¿æ¥æ•°

**å¥åº·åˆ¤æ–­ï¼š**
- ä½¿ç”¨ç‡ < 80%ï¼šå¥åº·
- ä½¿ç”¨ç‡ 80-90%ï¼šè­¦å‘Š
- ä½¿ç”¨ç‡ > 90%ï¼šå±é™©

### 2. è¶…æ—¶è®¾ç½®

```python
# æŸ¥è¯¢è¶…æ—¶
await asyncio.wait_for(
    session.execute(text("SELECT 1")),
    timeout=3.0  # 3 ç§’è¶…æ—¶
)
```

### 3. é‡è¯•æœºåˆ¶

```python
for attempt in range(max_retries + 1):
    try:
        # æ‰§è¡Œæ£€æŸ¥
        result = await check_database()
        return result
    except Exception:
        if attempt < max_retries:
            await asyncio.sleep(retry_delay)
        else:
            raise
```

### 4. ç¼“å­˜ç­–ç•¥

```python
# ç¼“å­˜ 30 ç§’
if time.time() - cache["last_check"] < 30:
    return cache["result"]
```

### 5. æ€§èƒ½é˜ˆå€¼

- **æ­£å¸¸**ï¼š< 100ms
- **è­¦å‘Š**ï¼š100-1000ms
- **æ…¢æŸ¥è¯¢**ï¼š> 1000ms

---

## åœ¨ AI Agent åç«¯ä¸­çš„åº”ç”¨

### æ•°æ®åº“å¥åº·æ£€æŸ¥çš„é‡è¦æ€§

**AI Agent åç«¯ä¾èµ–æ•°æ®åº“å­˜å‚¨ï¼š**
- ç”¨æˆ·æ•°æ®
- å¯¹è¯å†å²
- Agent çŠ¶æ€
- Embedding å‘é‡

**æ•°æ®åº“æ•…éšœçš„å½±å“ï¼š**
- æ— æ³•ä¿å­˜å¯¹è¯å†å²
- æ— æ³•æ£€ç´¢å†å²å¯¹è¯
- æ— æ³•è¿›è¡Œè¯­ä¹‰æ£€ç´¢
- æœåŠ¡å®Œå…¨ä¸å¯ç”¨

### æ¨èé…ç½®

```python
# ç”Ÿäº§ç¯å¢ƒé…ç½®
engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,              # è¿æ¥æ± å¤§å°
    max_overflow=40,           # æœ€å¤§æº¢å‡ºè¿æ¥æ•°
    pool_timeout=30,           # è·å–è¿æ¥è¶…æ—¶
    pool_recycle=3600,         # è¿æ¥å›æ”¶æ—¶é—´
    pool_pre_ping=True,        # è¿æ¥å‰ ping
    echo=False
)
```

---

## æ€»ç»“

æ•°æ®åº“è¿æ¥å¥åº·æ£€æŸ¥çš„å…³é”®ï¼š

1. **ç®€å•å¿«é€Ÿ**ï¼šä½¿ç”¨ `SELECT 1` æ£€æŸ¥è¿æ¥
2. **ç›‘æ§è¿æ¥æ± **ï¼šæ£€æŸ¥è¿æ¥æ± ä½¿ç”¨ç‡
3. **æ€§èƒ½æ£€æŸ¥**ï¼šç›‘æ§æŸ¥è¯¢å“åº”æ—¶é—´
4. **è¶…æ—¶æœºåˆ¶**ï¼šè®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
5. **é‡è¯•ç­–ç•¥**ï¼šçŸ­æš‚æŠ–åŠ¨æ—¶é‡è¯•
6. **ç¼“å­˜ç»“æœ**ï¼šé¿å…é¢‘ç¹æ£€æŸ¥å½±å“æ€§èƒ½

åœ¨ AI Agent åç«¯ä¸­ï¼Œæ•°æ®åº“æ˜¯æœ€å…³é”®çš„ä¾èµ–ï¼Œå¿…é¡»ç¡®ä¿å…¶å¥åº·çŠ¶æ€ã€‚
