# 核心概念 2：冲突解决

## 什么是冲突？

**当两个不同的键映射到同一个索引时，就发生了冲突。**

```python
# 冲突示例
def simple_hash(key: str, size: int) -> int:
    return sum(ord(c) for c in key) % size

# 这些键会冲突
print(simple_hash("abc", 10))  # 4
print(simple_hash("bca", 10))  # 4  <- 冲突！
print(simple_hash("cab", 10))  # 4  <- 冲突！
```

### 为什么冲突不可避免？

**鸽笼原理（Pigeonhole Principle）：**
- 键空间：无限（所有可能的字符串）
- 数组大小：有限（比如 1000 个位置）
- 结论：必然有多个键映射到同一位置

---

## 解决方案 1：链表法（Chaining）

### 核心思想

**每个数组位置存储一个链表，冲突的键都放在同一个链表中。**

```
索引    链表
0       []
1       [("apple", 1) → ("ant", 2)]  <- 冲突的键在同一链表
2       []
3       [("banana", 3)]
4       []
```

### Python 实现

```python
class HashTableChaining:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]  # 每个位置是列表
        self.count = 0

    def _hash(self, key: str) -> int:
        h = 0
        for char in key:
            h = (h * 31 + ord(char)) % self.size
        return h

    def put(self, key: str, value):
        """插入或更新 - O(1) 平均"""
        index = self._hash(key)
        bucket = self.table[index]

        # 检查键是否已存在
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # 更新
                return

        # 新键，追加到链表
        bucket.append((key, value))
        self.count += 1

    def get(self, key: str):
        """查找 - O(1) 平均"""
        index = self._hash(key)
        bucket = self.table[index]

        for k, v in bucket:
            if k == key:
                return v
        return None

    def delete(self, key: str) -> bool:
        """删除 - O(1) 平均"""
        index = self._hash(key)
        bucket = self.table[index]

        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket.pop(i)
                self.count -= 1
                return True
        return False

# 使用示例
ht = HashTableChaining(size=5)
ht.put("apple", 1)
ht.put("banana", 2)
ht.put("cherry", 3)

print(ht.get("apple"))   # 1
print(ht.get("banana"))  # 2
ht.delete("apple")
print(ht.get("apple"))   # None
```

### 性能分析

**时间复杂度：**
- 平均：O(1 + α)，其中 α = n/m（负载因子）
- 最坏：O(n)（所有键在同一链表）

**空间复杂度：**
- O(n + m)，需要额外的链表节点

### 优缺点

**优点：**
- ✅ 实现简单
- ✅ 删除容易
- ✅ 负载因子可以 > 1
- ✅ 不需要重新哈希

**缺点：**
- ❌ 需要额外指针空间
- ❌ 缓存不友好（链表跳转）
- ❌ 内存碎片

---

## 解决方案 2：开放寻址（Open Addressing）

### 核心思想

**所有元素都存储在数组中，冲突时探测下一个空位。**

```
索引    键      值
0       -       -
1       apple   1
2       ant     2   <- apple 冲突后探测到这里
3       banana  3
4       -       -
```

### 线性探测（Linear Probing）

**冲突时，依次检查下一个位置。**

```python
class HashTableLinearProbing:
    def __init__(self, size=10):
        self.size = size
        self.keys = [None] * size
        self.values = [None] * size
        self.count = 0

    def _hash(self, key: str) -> int:
        h = 0
        for char in key:
            h = (h * 31 + ord(char)) % self.size
        return h

    def put(self, key: str, value):
        """插入或更新"""
        if self.count >= self.size:
            raise Exception("Hash table is full")

        index = self._hash(key)

        # 线性探测：找空位或相同键
        while self.keys[index] is not None:
            if self.keys[index] == key:
                self.values[index] = value  # 更新
                return
            index = (index + 1) % self.size  # 下一个位置

        # 找到空位
        self.keys[index] = key
        self.values[index] = value
        self.count += 1

    def get(self, key: str):
        """查找"""
        index = self._hash(key)

        # 线性探测：查找键
        while self.keys[index] is not None:
            if self.keys[index] == key:
                return self.values[index]
            index = (index + 1) % self.size

        return None

    def delete(self, key: str) -> bool:
        """删除（需要标记）"""
        index = self._hash(key)

        while self.keys[index] is not None:
            if self.keys[index] == key:
                # 标记为已删除（使用特殊值）
                self.keys[index] = "<DELETED>"
                self.values[index] = None
                self.count -= 1
                return True
            index = (index + 1) % self.size

        return False

# 使用示例
ht = HashTableLinearProbing(size=10)
ht.put("apple", 1)
ht.put("banana", 2)
ht.put("cherry", 3)

print(ht.get("apple"))   # 1
print(ht.get("banana"))  # 2
```

### 二次探测（Quadratic Probing）

**冲突时，按二次方步长探测。**

```python
def quadratic_probe(self, key: str, i: int) -> int:
    """
    探测序列：h(k), h(k)+1², h(k)+2², h(k)+3², ...
    """
    base = self._hash(key)
    return (base + i * i) % self.size
```

### 双重哈希（Double Hashing）

**使用第二个哈希函数计算步长。**

```python
def double_hash_probe(self, key: str, i: int) -> int:
    """
    探测序列：h1(k), h1(k)+h2(k), h1(k)+2*h2(k), ...
    """
    h1 = self._hash(key)
    h2 = self._hash2(key)
    return (h1 + i * h2) % self.size

def _hash2(self, key: str) -> int:
    """第二个哈希函数"""
    h = 0
    for char in key:
        h = (h * 37 + ord(char))
    return 1 + (h % (self.size - 1))  # 确保不为 0
```

### 性能分析

**时间复杂度：**
- 平均：O(1/(1-α))，其中 α < 1
- 最坏：O(n)

**空间复杂度：**
- O(m)，只需数组

### 优缺点

**优点：**
- ✅ 缓存友好（连续内存）
- ✅ 不需要额外指针
- ✅ 内存紧凑

**缺点：**
- ❌ 删除复杂（需要标记）
- ❌ 负载因子必须 < 1
- ❌ 聚集问题（Clustering）

---

## 解决方案 3：Cuckoo Hashing（2026 优化）

### 核心思想

**使用两个哈希函数和两个表，冲突时"踢走"旧元素。**

```python
class CuckooHashTable:
    def __init__(self, size=10):
        self.size = size
        self.table1 = [None] * size
        self.table2 = [None] * size
        self.max_kicks = 500  # 最大踢出次数

    def _hash1(self, key: str) -> int:
        h = 0
        for char in key:
            h = (h * 31 + ord(char)) % self.size
        return h

    def _hash2(self, key: str) -> int:
        h = 0
        for char in key:
            h = (h * 37 + ord(char)) % self.size
        return h

    def put(self, key: str, value):
        """插入：可能需要踢出旧元素"""
        current_key, current_value = key, value

        for _ in range(self.max_kicks):
            # 尝试表1
            index1 = self._hash1(current_key)
            if self.table1[index1] is None:
                self.table1[index1] = (current_key, current_value)
                return

            # 踢出表1的元素
            old_item = self.table1[index1]
            self.table1[index1] = (current_key, current_value)
            current_key, current_value = old_item

            # 尝试表2
            index2 = self._hash2(current_key)
            if self.table2[index2] is None:
                self.table2[index2] = (current_key, current_value)
                return

            # 踢出表2的元素
            old_item = self.table2[index2]
            self.table2[index2] = (current_key, current_value)
            current_key, current_value = old_item

        # 踢出次数过多，需要重建
        raise Exception("Cuckoo hashing failed, need rehash")

    def get(self, key: str):
        """查找：最多两次查找"""
        index1 = self._hash1(key)
        if self.table1[index1] and self.table1[index1][0] == key:
            return self.table1[index1][1]

        index2 = self._hash2(key)
        if self.table2[index2] and self.table2[index2][0] == key:
            return self.table2[index2][1]

        return None

# 使用示例
ht = CuckooHashTable(size=10)
ht.put("apple", 1)
ht.put("banana", 2)
ht.put("cherry", 3)

print(ht.get("apple"))   # 1
print(ht.get("banana"))  # 2
```

### 2026 优化：SIMD 加速

**使用 SIMD 指令并行查找。**

```python
# 概念示例（实际需要 C/C++ 实现）
def simd_cuckoo_lookup(key: str, table1, table2):
    """
    使用 SIMD 同时检查两个表
    比传统方法快 2-3 倍
    """
    h1 = hash1(key)
    h2 = hash2(key)

    # SIMD 并行加载和比较
    # result = simd_compare([table1[h1], table2[h2]], key)
    pass
```

---

## 解决方案 4：Robin Hood Hashing（2025 研究）

### 核心思想

**"劫富济贫"：让距离原位置远的元素优先占位。**

```python
class RobinHoodHashTable:
    def __init__(self, size=10):
        self.size = size
        self.keys = [None] * size
        self.values = [None] * size
        self.distances = [0] * size  # 距离原位置的距离

    def _hash(self, key: str) -> int:
        h = 0
        for char in key:
            h = (h * 31 + ord(char)) % self.size
        return h

    def put(self, key: str, value):
        """插入：Robin Hood 策略"""
        index = self._hash(key)
        distance = 0

        current_key, current_value = key, value

        while True:
            # 空位，直接插入
            if self.keys[index] is None:
                self.keys[index] = current_key
                self.values[index] = current_value
                self.distances[index] = distance
                return

            # 相同键，更新
            if self.keys[index] == current_key:
                self.values[index] = current_value
                return

            # Robin Hood：如果当前元素距离更近，交换
            if distance > self.distances[index]:
                # 交换
                self.keys[index], current_key = current_key, self.keys[index]
                self.values[index], current_value = current_value, self.values[index]
                self.distances[index], distance = distance, self.distances[index]

            # 继续探测
            index = (index + 1) % self.size
            distance += 1

# 使用示例
ht = RobinHoodHashTable(size=10)
ht.put("apple", 1)
ht.put("banana", 2)
```

### 优势

- 减少最大探测距离
- 更均匀的性能
- 适合高负载因子

---

## 2026 AI Agent 应用

### 应用 1：LMCache KV Cache 冲突处理

```python
class KVCacheManager:
    """LMCache 风格的 KV Cache 管理"""
    def __init__(self, cache_size=1000):
        self.cache_size = cache_size
        self.cache = {}  # 使用 Python dict（链表法）
        self.access_count = {}

    def store_kv(self, context_hash: int, kv_data):
        """存储 KV Cache"""
        if context_hash in self.cache:
            # 冲突检测：验证实际内容
            if self.cache[context_hash]["content"] == kv_data["content"]:
                # 真正的重复，更新访问计数
                self.access_count[context_hash] += 1
                return
            else:
                # 哈希冲突，需要处理
                self._handle_collision(context_hash, kv_data)
        else:
            self.cache[context_hash] = kv_data
            self.access_count[context_hash] = 1

    def _handle_collision(self, hash_val: int, kv_data):
        """处理哈希冲突"""
        # 使用链表法：在同一哈希值下存储多个条目
        if not isinstance(self.cache[hash_val], list):
            self.cache[hash_val] = [self.cache[hash_val]]
        self.cache[hash_val].append(kv_data)
```

### 应用 2：分布式哈希表（DHT）冲突

```python
class KademliaDHT:
    """Kademlia DHT for Agent Discovery (2026)"""
    def __init__(self, node_id: int, k=20):
        self.node_id = node_id
        self.k = k  # 每个桶的大小
        self.routing_table = {}  # bucket_id → list of nodes

    def _xor_distance(self, id1: int, id2: int) -> int:
        """XOR 距离度量"""
        return id1 ^ id2

    def _bucket_index(self, target_id: int) -> int:
        """计算桶索引"""
        distance = self._xor_distance(self.node_id, target_id)
        if distance == 0:
            return 0
        return distance.bit_length() - 1

    def add_node(self, node_id: int, node_info: dict):
        """添加节点：处理桶冲突"""
        bucket_idx = self._bucket_index(node_id)

        if bucket_idx not in self.routing_table:
            self.routing_table[bucket_idx] = []

        bucket = self.routing_table[bucket_idx]

        # 桶满了，使用 LRU 策略
        if len(bucket) >= self.k:
            # 移除最旧的节点
            bucket.pop(0)

        bucket.append((node_id, node_info))
```

---

## 对比总结

| 策略 | 时间复杂度 | 空间效率 | 缓存友好 | 删除难度 | 适用场景 |
|------|-----------|---------|---------|---------|---------|
| **链表法** | O(1+α) | 低 | 差 | 简单 | 通用，Python dict |
| **线性探测** | O(1/(1-α)) | 高 | 好 | 复杂 | 小表，缓存敏感 |
| **二次探测** | O(1/(1-α)) | 高 | 中 | 复杂 | 减少聚集 |
| **Cuckoo** | O(1) 最坏 | 高 | 好 | 简单 | 实时系统 |
| **Robin Hood** | O(1) 均匀 | 高 | 好 | 中等 | 高负载因子 |

---

## 核心要点

1. **冲突不可避免**：鸽笼原理保证冲突必然发生
2. **链表法最通用**：Python dict 使用变种链表法
3. **开放寻址更快**：缓存友好，但删除复杂
4. **2026 优化**：Cuckoo + SIMD，Robin Hood 均匀性

**记住：选择冲突解决策略取决于具体场景，没有银弹。**
