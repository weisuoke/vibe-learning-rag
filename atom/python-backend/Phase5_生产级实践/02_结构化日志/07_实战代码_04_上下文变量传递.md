# 实战代码04：上下文变量传递

## 学习目标

深入理解contextvars的工作原理，掌握在复杂场景中传递和管理上下文变量。

---

## 第一步：contextvars基础

### 示例1：创建和使用上下文变量

```python
# examples/logging/28_contextvars_basics.py
from contextvars import ContextVar
import asyncio

# 定义上下文变量
request_id_var: ContextVar[str] = ContextVar("request_id", default="unknown")
user_id_var: ContextVar[str] = ContextVar("user_id")

async def process_request(request_id: str, user_id: str):
    # 设置上下文变量
    request_id_var.set(request_id)
    user_id_var.set(user_id)

    print(f"Request {request_id} started")

    # 调用子函数
    await process_data()
    await save_result()

async def process_data():
    # 自动获取上下文变量
    request_id = request_id_var.get()
    user_id = user_id_var.get()

    print(f"Processing data for request {request_id}, user {user_id}")

async def save_result():
    request_id = request_id_var.get()
    user_id = user_id_var.get()

    print(f"Saving result for request {request_id}, user {user_id}")

# 测试并发
async def main():
    await asyncio.gather(
        process_request("req_1", "user_A"),
        process_request("req_2", "user_B"),
        process_request("req_3", "user_C")
    )

asyncio.run(main())
```

**输出：**
```
Request req_1 started
Request req_2 started
Request req_3 started
Processing data for request req_1, user user_A
Processing data for request req_2, user user_B
Processing data for request req_3, user user_C
Saving result for request req_1, user user_A
Saving result for request req_2, user user_B
Saving result for request req_3, user user_C
```

**关键点：** 每个异步任务的上下文是独立的

---

## 第二步：上下文变量的作用域

### 示例2：理解上下文的继承

```python
# examples/logging/29_context_inheritance.py
from contextvars import ContextVar
import asyncio

counter_var: ContextVar[int] = ContextVar("counter", default=0)

async def parent_task():
    # 父任务设置值
    counter_var.set(100)
    print(f"Parent: {counter_var.get()}")

    # 创建子任务
    await child_task()

    # 父任务的值不受子任务影响
    print(f"Parent after child: {counter_var.get()}")

async def child_task():
    # 子任务继承父任务的值
    print(f"Child inherited: {counter_var.get()}")

    # 子任务修改值
    counter_var.set(200)
    print(f"Child modified: {counter_var.get()}")

asyncio.run(parent_task())
```

**输出：**
```
Parent: 100
Child inherited: 100
Child modified: 200
Parent after child: 100
```

**关键点：** 子任务继承父任务的上下文，但修改不会影响父任务

---

## 第三步：在FastAPI中传递多个上下文

### 示例3：传递用户、会话、租户信息

```python
# examples/logging/30_multiple_context.py
import uuid
from fastapi import FastAPI, Request, Header
from typing import Optional
import structlog

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_context(request: Request, call_next):
    # 收集所有上下文信息
    context = {
        "request_id": str(uuid.uuid4()),
        "method": request.method,
        "path": request.url.path,
        "client_ip": request.client.host,
    }

    # 从请求头中提取可选信息
    user_id = request.headers.get("X-User-ID")
    session_id = request.headers.get("X-Session-ID")
    tenant_id = request.headers.get("X-Tenant-ID")

    if user_id:
        context["user_id"] = user_id
    if session_id:
        context["session_id"] = session_id
    if tenant_id:
        context["tenant_id"] = tenant_id

    # 绑定所有上下文
    structlog.contextvars.bind_contextvars(**context)

    logger.info("request_start")

    response = await call_next(request)

    logger.info("request_end", status_code=response.status_code)

    structlog.contextvars.clear_contextvars()

    return response

@app.get("/")
async def root():
    logger.info("processing_root")
    return {"message": "Hello"}

@app.get("/users/me")
async def get_current_user():
    logger.info("get_current_user")
    return {"user_id": "user_123"}
```

**测试：**
```bash
curl -H "X-User-ID: user_123" \
     -H "X-Session-ID: session_456" \
     -H "X-Tenant-ID: tenant_789" \
     http://localhost:8000/users/me
```

---

## 第四步：动态添加上下文

### 示例4：在处理过程中添加上下文

```python
# examples/logging/31_dynamic_context.py
import uuid
from fastapi import FastAPI, Request
import structlog
import asyncio

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.dev.ConsoleRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_request_id(request: Request, call_next):
    request_id = str(uuid.uuid4())
    structlog.contextvars.bind_contextvars(request_id=request_id)

    logger.info("request_start", path=request.url.path)

    response = await call_next(request)

    logger.info("request_end", status_code=response.status_code)

    structlog.contextvars.clear_contextvars()

    return response

async def call_llm(prompt: str, model: str):
    """LLM调用：动态添加操作上下文"""
    # 临时添加操作相关的上下文
    structlog.contextvars.bind_contextvars(
        operation="llm_call",
        model=model
    )

    logger.info("llm_call_start", prompt_length=len(prompt))

    # 模拟LLM调用
    await asyncio.sleep(0.5)

    logger.info("llm_call_end", tokens=150)

    # 清理操作上下文（保留请求上下文）
    structlog.contextvars.unbind_contextvars("operation", "model")

    return "LLM response"

@app.post("/chat")
async def chat(message: str):
    logger.info("chat_start", message_length=len(message))

    # 调用LLM
    response = await call_llm(message, "gpt-4")

    logger.info("chat_end")

    return {"response": response}
```

**输出：**
```
2024-01-15 10:30:45 [info     ] request_start          request_id=req_abc path=/chat
2024-01-15 10:30:45 [info     ] chat_start             request_id=req_abc message_length=20
2024-01-15 10:30:45 [info     ] llm_call_start         request_id=req_abc operation=llm_call model=gpt-4 prompt_length=20
2024-01-15 10:30:46 [info     ] llm_call_end           request_id=req_abc operation=llm_call model=gpt-4 tokens=150
2024-01-15 10:30:46 [info     ] chat_end               request_id=req_abc
2024-01-15 10:30:46 [info     ] request_end            request_id=req_abc status_code=200
```

---

## 第五步：后台任务的上下文传递

### 示例5：完整的后台任务上下文管理

```python
# examples/logging/32_background_task_full.py
import uuid
from fastapi import FastAPI, Request, BackgroundTasks
import structlog
import time

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.dev.ConsoleRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_request_id(request: Request, call_next):
    request_id = str(uuid.uuid4())
    structlog.contextvars.bind_contextvars(request_id=request_id)

    logger.info("request_start", path=request.url.path)

    response = await call_next(request)

    logger.info("request_end", status_code=response.status_code)

    # 注意：不要在这里清理上下文，因为后台任务可能还在运行
    # structlog.contextvars.clear_contextvars()

    return response

def send_email(to: str, subject: str, context: dict):
    """后台任务：发送邮件"""
    # 恢复上下文
    structlog.contextvars.bind_contextvars(**context)

    logger.info("sending_email", to=to, subject=subject)

    # 模拟发送邮件
    time.sleep(1)

    logger.info("email_sent", to=to)

    # 清理上下文
    structlog.contextvars.clear_contextvars()

def save_to_database(data: dict, context: dict):
    """后台任务：保存到数据库"""
    structlog.contextvars.bind_contextvars(**context)

    logger.info("saving_to_database", data_size=len(str(data)))

    time.sleep(0.5)

    logger.info("saved_to_database")

    structlog.contextvars.clear_contextvars()

@app.post("/users")
async def create_user(user: dict, background_tasks: BackgroundTasks):
    logger.info("create_user_start", user=user)

    # 获取当前上下文
    context = structlog.contextvars.get_contextvars()

    # 添加多个后台任务
    background_tasks.add_task(save_to_database, user, context)
    background_tasks.add_task(send_email, user.get("email"), "Welcome", context)

    logger.info("create_user_end")

    # 在返回响应前清理上下文
    structlog.contextvars.clear_contextvars()

    return {"id": "user_123", **user}
```

---

## 第六步：嵌套上下文管理

### 示例6：使用上下文管理器

```python
# examples/logging/33_context_manager.py
from contextlib import contextmanager
import structlog
import uuid

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.dev.ConsoleRenderer()
    ]
)

logger = structlog.get_logger()

@contextmanager
def operation_context(operation: str, **kwargs):
    """操作上下文管理器"""
    # 绑定操作上下文
    structlog.contextvars.bind_contextvars(operation=operation, **kwargs)

    logger.info(f"{operation}_start")

    try:
        yield
    finally:
        logger.info(f"{operation}_end")
        # 清理操作上下文
        keys_to_unbind = ["operation"] + list(kwargs.keys())
        structlog.contextvars.unbind_contextvars(*keys_to_unbind)

def process_data():
    """处理数据"""
    # 绑定请求上下文
    structlog.contextvars.bind_contextvars(request_id=str(uuid.uuid4()))

    logger.info("process_start")

    # 使用上下文管理器添加操作上下文
    with operation_context("rag_search", query="Python"):
        logger.info("searching")
        # RAG检索逻辑

    with operation_context("llm_call", model="gpt-4"):
        logger.info("calling_llm")
        # LLM调用逻辑

    logger.info("process_end")

    # 清理请求上下文
    structlog.contextvars.clear_contextvars()

# 测试
process_data()
```

**输出：**
```
2024-01-15 10:30:45 [info     ] process_start          request_id=req_abc
2024-01-15 10:30:45 [info     ] rag_search_start       request_id=req_abc operation=rag_search query=Python
2024-01-15 10:30:45 [info     ] searching              request_id=req_abc operation=rag_search query=Python
2024-01-15 10:30:45 [info     ] rag_search_end         request_id=req_abc operation=rag_search query=Python
2024-01-15 10:30:45 [info     ] llm_call_start         request_id=req_abc operation=llm_call model=gpt-4
2024-01-15 10:30:45 [info     ] calling_llm            request_id=req_abc operation=llm_call model=gpt-4
2024-01-15 10:30:45 [info     ] llm_call_end           request_id=req_abc operation=llm_call model=gpt-4
2024-01-15 10:30:45 [info     ] process_end            request_id=req_abc
```

---

## 第七步：跨服务传递上下文

### 示例7：通过HTTP头传递上下文

```python
# examples/logging/34_cross_service_context.py
import uuid
from fastapi import FastAPI, Request
import structlog
import httpx

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.dev.ConsoleRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_context(request: Request, call_next):
    # 从请求头中获取或生成上下文
    request_id = request.headers.get("X-Request-ID") or str(uuid.uuid4())
    trace_id = request.headers.get("X-Trace-ID") or str(uuid.uuid4())

    structlog.contextvars.bind_contextvars(
        request_id=request_id,
        trace_id=trace_id
    )

    logger.info("request_start", path=request.url.path)

    response = await call_next(request)

    logger.info("request_end", status_code=response.status_code)

    # 在响应头中返回上下文
    response.headers["X-Request-ID"] = request_id
    response.headers["X-Trace-ID"] = trace_id

    structlog.contextvars.clear_contextvars()

    return response

async def call_downstream_service(data: dict):
    """调用下游服务"""
    # 获取当前上下文
    context = structlog.contextvars.get_contextvars()

    # 构建请求头，传递上下文
    headers = {
        "X-Request-ID": context.get("request_id"),
        "X-Trace-ID": context.get("trace_id"),
        "Content-Type": "application/json"
    }

    logger.info("calling_downstream", service="user-service")

    async with httpx.AsyncClient() as client:
        response = await client.post(
            "http://user-service/api/users",
            json=data,
            headers=headers
        )

    logger.info("downstream_response", status_code=response.status_code)

    return response.json()

@app.post("/api/create-user")
async def create_user(user: dict):
    logger.info("create_user_start")

    # 调用下游服务
    result = await call_downstream_service(user)

    logger.info("create_user_end")

    return result
```

---

## 第八步：上下文的持久化和恢复

### 示例8：保存和恢复上下文

```python
# examples/logging/35_context_persistence.py
import uuid
import json
from fastapi import FastAPI, Request
import structlog
import redis

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.dev.ConsoleRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

# Redis客户端（用于存储上下文）
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

@app.middleware("http")
async def add_context(request: Request, call_next):
    request_id = str(uuid.uuid4())

    context = {
        "request_id": request_id,
        "method": request.method,
        "path": request.url.path,
        "user_id": request.headers.get("X-User-ID")
    }

    # 保存上下文到Redis（用于异步任务）
    redis_client.setex(
        f"context:{request_id}",
        3600,  # 1小时过期
        json.dumps(context)
    )

    structlog.contextvars.bind_contextvars(**context)

    logger.info("request_start")

    response = await call_next(request)

    logger.info("request_end", status_code=response.status_code)

    response.headers["X-Request-ID"] = request_id

    structlog.contextvars.clear_contextvars()

    return response

def async_task(request_id: str):
    """异步任务：从Redis恢复上下文"""
    # 从Redis恢复上下文
    context_json = redis_client.get(f"context:{request_id}")

    if context_json:
        context = json.loads(context_json)
        structlog.contextvars.bind_contextvars(**context)

        logger.info("async_task_start")

        # 执行任务
        import time
        time.sleep(1)

        logger.info("async_task_end")

        structlog.contextvars.clear_contextvars()
    else:
        logger.error("context_not_found", request_id=request_id)

@app.post("/api/trigger-async")
async def trigger_async(data: dict):
    logger.info("trigger_async")

    # 获取请求ID
    request_id = structlog.contextvars.get_contextvars().get("request_id")

    # 触发异步任务（例如通过Celery）
    # celery_app.send_task("async_task", args=[request_id])

    return {"request_id": request_id, "status": "queued"}
```

---

## 第九步：完整的上下文管理工具类

### 示例9：可复用的上下文管理器

```python
# utils/context.py
"""
上下文管理工具

使用方法：
    from utils.context import ContextManager

    # 绑定上下文
    ContextManager.bind(request_id="req_123", user_id="user_456")

    # 获取上下文
    context = ContextManager.get_all()

    # 清理上下文
    ContextManager.clear()
```

import structlog
from typing import Dict, Any, Optional
from contextlib import contextmanager

logger = structlog.get_logger()

class ContextManager:
    """上下文管理器"""

    @staticmethod
    def bind(**kwargs):
        """绑定上下文变量"""
        structlog.contextvars.bind_contextvars(**kwargs)

    @staticmethod
    def unbind(*keys: str):
        """解绑特定的上下文变量"""
        structlog.contextvars.unbind_contextvars(*keys)

    @staticmethod
    def clear():
        """清理所有上下文变量"""
        structlog.contextvars.clear_contextvars()

    @staticmethod
    def get_all() -> Dict[str, Any]:
        """获取所有上下文变量"""
        return structlog.contextvars.get_contextvars()

    @staticmethod
    def get(key: str, default: Any = None) -> Any:
        """获取特定的上下文变量"""
        return structlog.contextvars.get_contextvars().get(key, default)

    @staticmethod
    @contextmanager
    def temporary(**kwargs):
        """临时上下文管理器"""
        # 保存当前上下文
        original_context = ContextManager.get_all()

        # 绑定新上下文
        ContextManager.bind(**kwargs)

        try:
            yield
        finally:
            # 恢复原始上下文
            ContextManager.clear()
            if original_context:
                ContextManager.bind(**original_context)

    @staticmethod
    @contextmanager
    def operation(operation: str, **kwargs):
        """操作上下文管理器"""
        ContextManager.bind(operation=operation, **kwargs)

        logger.info(f"{operation}_start")

        try:
            yield
        finally:
            logger.info(f"{operation}_end")
            keys_to_unbind = ["operation"] + list(kwargs.keys())
            ContextManager.unbind(*keys_to_unbind)


# 使用示例
if __name__ == "__main__":
    import structlog

    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,
            structlog.processors.add_log_level,
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.dev.ConsoleRenderer()
        ]
    )

    logger = structlog.get_logger()

    # 绑定请求上下文
    ContextManager.bind(request_id="req_123", user_id="user_456")

    logger.info("request_start")

    # 使用临时上下文
    with ContextManager.temporary(temp_var="temp_value"):
        logger.info("inside_temporary")

    logger.info("after_temporary")

    # 使用操作上下文
    with ContextManager.operation("llm_call", model="gpt-4"):
        logger.info("calling_llm")

    logger.info("after_operation")

    # 清理上下文
    ContextManager.clear()
```

---

## 总结

### 核心要点

1. **contextvars基础**
   - 异步安全的上下文管理
   - 子任务继承父任务的上下文
   - 修改不会影响父任务

2. **上下文传递**
   - 请求级别上下文（request_id, user_id）
   - 操作级别上下文（operation, model）
   - 后台任务需要手动传递

3. **上下文管理器**
   - 使用contextmanager简化管理
   - 自动清理上下文
   - 支持嵌套上下文

4. **跨服务传递**
   - 通过HTTP头传递
   - 保持trace_id一致
   - 支持分布式追踪

### 最佳实践

1. 使用ContextManager工具类统一管理
2. 操作结束后及时清理上下文
3. 后台任务手动传递和恢复上下文
4. 跨服务调用传递trace_id
5. 使用上下文管理器简化代码

### 下一步

- 【实战代码05】：日志过滤与路由
- 【实战代码06】：手写结构化日志
