# 核心概念05: 堆排序

## 核心目标

**深入理解堆排序算法的原理、实现、优化,以及与其他排序算法的对比。**

---

## 1. 堆排序原理

### 1.1 基本思想

**核心思想:** 利用heap的性质,反复提取最大值(或最小值),得到有序序列。

**步骤:**
1. 将无序数组建成max-heap (O(n))
2. 将堆顶(最大值)与末尾元素交换
3. 堆大小减1,对新的堆顶执行heapify-down
4. 重复步骤2-3,直到堆大小为1

**可视化:**

```
初始数组: [4, 10, 3, 5, 1]

Step 1: 建max-heap
       10
      /  \
     5    3
    / \
   4   1
数组: [10, 5, 3, 4, 1]

Step 2: 交换10和1
       1
      / \
     5   3
    /
   4
数组: [1, 5, 3, 4, | 10]

Step 3: heapify-down
       5
      / \
     4   3
    /
   1
数组: [5, 4, 3, 1, | 10]

Step 4: 交换5和1
       1
      / \
     4   3
数组: [1, 4, 3, | 5, 10]

Step 5: heapify-down
       4
      / \
     1   3
数组: [4, 1, 3, | 5, 10]

Step 6: 交换4和3
       3
      /
     1
数组: [3, 1, | 4, 5, 10]

Step 7: heapify-down
       3
      /
     1
数组: [3, 1, | 4, 5, 10]

Step 8: 交换3和1
数组: [1, | 3, 4, 5, 10]

完成!
```

### 1.2 算法特性

**时间复杂度:**
- 最好: O(n log n)
- 平均: O(n log n)
- 最坏: O(n log n)

**空间复杂度:** O(1) (原地排序)

**稳定性:** 不稳定

**适用场景:**
- 需要O(n log n)保证
- 空间受限(O(1)空间)
- 不需要稳定性

---

## 2. 完整实现

### 2.1 基础版本

```python
def heap_sort(arr):
    """
    堆排序

    时间复杂度: O(n log n)
    空间复杂度: O(1)
    稳定性: 不稳定
    """
    n = len(arr)

    # Step 1: 建max-heap O(n)
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, i, n)

    # Step 2: 反复提取最大值 O(n log n)
    for i in range(n - 1, 0, -1):
        # 交换堆顶和末尾
        arr[0], arr[i] = arr[i], arr[0]

        # heapify-down恢复heap性质
        heapify_down(arr, 0, i)

    return arr

def heapify_down(arr, i, n):
    """
    向下调整(max-heap)

    Args:
        arr: 数组
        i: 调整起始位置
        n: heap大小
    """
    while 2 * i + 1 < n:
        left = 2 * i + 1
        right = 2 * i + 2
        largest = i

        if arr[left] > arr[largest]:
            largest = left

        if right < n and arr[right] > arr[largest]:
            largest = right

        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            i = largest
        else:
            break

# 测试
arr = [4, 10, 3, 5, 1, 2, 8, 9, 7, 6]
print(f"原数组: {arr}")
heap_sort(arr)
print(f"排序后: {arr}")

# 输出:
# 原数组: [4, 10, 3, 5, 1, 2, 8, 9, 7, 6]
# 排序后: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

### 2.2 优化版本

```python
def heap_sort_optimized(arr):
    """
    优化版堆排序

    优化点:
    1. 减少交换次数(用赋值代替)
    2. 提前终止heapify
    """
    n = len(arr)

    # 建max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_down_optimized(arr, i, n)

    # 反复提取最大值
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_down_optimized(arr, 0, i)

    return arr

def heapify_down_optimized(arr, i, n):
    """优化版heapify-down"""
    value = arr[i]

    while 2 * i + 1 < n:
        left = 2 * i + 1
        right = 2 * i + 2

        # 找出较大的子节点
        if right < n and arr[right] > arr[left]:
            child = right
        else:
            child = left

        if arr[child] > value:
            arr[i] = arr[child]
            i = child
        else:
            break

    arr[i] = value
```

### 2.3 使用heapq实现

```python
import heapq

def heap_sort_heapq(arr):
    """
    使用heapq实现堆排序

    注意:heapq是min-heap,需要取负值
    """
    # 方法1: 使用nlargest
    return heapq.nlargest(len(arr), arr)[::-1]

    # 方法2: 手动建堆
    heapq.heapify(arr)
    return [heapq.heappop(arr) for _ in range(len(arr))]
```

---

## 3. 复杂度分析

### 3.1 时间复杂度证明

**建堆阶段: O(n)**

```
已在"核心概念02:堆化操作"中证明
自底向上heapify的总工作量是O(n)
```

**排序阶段: O(n log n)**

```
反复提取最大值:
- 执行n-1次
- 每次heapify-down: O(log n)
- 总复杂度: O(n log n)
```

**总复杂度: O(n) + O(n log n) = O(n log n)**

### 3.2 为什么是O(n log n)?

**与快排对比:**

```
快排:
- 最好: O(n log n) - 每次平分
- 平均: O(n log n)
- 最坏: O(n²) - 已排序数组

堆排序:
- 最好: O(n log n)
- 平均: O(n log n)
- 最坏: O(n log n) ✅ 保证

关键区别:堆排序保证O(n log n),快排不保证
```

### 3.3 空间复杂度

```python
# 堆排序是原地排序
def heap_sort(arr):
    # 只使用常数额外空间
    # 不需要额外数组
    # 空间复杂度: O(1)
    pass

# 对比:归并排序需要O(n)额外空间
def merge_sort(arr):
    # 需要临时数组存储合并结果
    # 空间复杂度: O(n)
    pass
```

---

## 4. 与其他排序算法对比

### 4.1 完整对比表

| 算法 | 最好 | 平均 | 最坏 | 空间 | 稳定 | 适用场景 |
|------|------|------|------|------|------|----------|
| 快排 | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ | 通用最优 |
| 归并 | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ | 需要稳定性 |
| **堆排序** | **O(n log n)** | **O(n log n)** | **O(n log n)** | **O(1)** | **❌** | **空间受限** |
| 插入 | O(n) | O(n²) | O(n²) | O(1) | ✅ | 小数据/近有序 |
| 选择 | O(n²) | O(n²) | O(n²) | O(1) | ❌ | 不推荐 |
| 冒泡 | O(n) | O(n²) | O(n²) | O(1) | ✅ | 不推荐 |

### 4.2 堆排序 vs 快排

```python
import time
import random

def benchmark_sort(n):
    """性能对比"""
    arr1 = [random.randint(1, 1000) for _ in range(n)]
    arr2 = arr1.copy()

    # 快排
    start = time.time()
    arr1.sort()
    time_quick = time.time() - start

    # 堆排序
    start = time.time()
    heap_sort(arr2)
    time_heap = time.time() - start

    print(f"n={n}: 快排={time_quick:.4f}s, 堆排序={time_heap:.4f}s")

# 测试
for n in [10000, 100000, 1000000]:
    benchmark_sort(n)

# 输出示例:
# n=10000: 快排=0.0012s, 堆排序=0.0034s
# n=100000: 快排=0.0145s, 堆排序=0.0421s
# n=1000000: 快排=0.1678s, 堆排序=0.5234s

# 结论:快排通常快2-3倍,因为:
# 1. 缓存友好性更好
# 2. 常数因子更小
# 3. 分支预测更准确
```

**何时选择堆排序?**

```
1. 需要O(n log n)保证(快排最坏O(n²))
2. 空间极度受限(堆排序O(1),归并O(n))
3. 不需要稳定性
4. 实时系统(需要可预测的性能)
```

### 4.3 堆排序 vs 归并排序

```
归并排序优势:
- 稳定排序
- 缓存友好(顺序访问)
- 适合链表排序

堆排序优势:
- 空间O(1)
- 原地排序
- 适合数组排序

选择指南:
- 需要稳定性 → 归并
- 空间受限 → 堆排序
- 链表排序 → 归并
- 数组排序 → 快排(通常) or 堆排序(保证)
```

---

## 5. 堆排序的优化

### 5.1 优化1: 减少交换次数

```python
def heap_sort_less_swap(arr):
    """
    减少交换次数

    标准版:每次heapify需要多次交换
    优化版:用赋值代替交换
    """
    n = len(arr)

    # 建堆
    for i in range(n // 2 - 1, -1, -1):
        heapify_down_optimized(arr, i, n)

    # 排序
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_down_optimized(arr, 0, i)

    return arr
```

### 5.2 优化2: 提前终止

```python
def heap_sort_early_stop(arr):
    """
    提前终止优化

    如果heapify过程中发现已满足heap性质,提前终止
    """
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, i, n)

    for i in range(n - 1, 0, -1):
        if arr[0] <= arr[i]:  # 已有序,提前终止
            break

        arr[0], arr[i] = arr[i], arr[0]
        heapify_down(arr, 0, i)

    return arr
```

### 5.3 优化3: 混合排序

```python
def hybrid_sort(arr, threshold=10):
    """
    混合排序:堆排序 + 插入排序

    小数组用插入排序(O(n²)但常数小)
    大数组用堆排序(O(n log n))
    """
    if len(arr) <= threshold:
        # 小数组:插入排序
        return insertion_sort(arr)
    else:
        # 大数组:堆排序
        return heap_sort(arr)

def insertion_sort(arr):
    """插入排序"""
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
```

---

## 6. 堆排序的应用

### 6.1 Top-K问题

```python
def top_k_heap_sort(arr, k):
    """
    使用堆排序解决Top-K问题

    方法:部分堆排序,只提取前K个最大值
    """
    n = len(arr)

    # 建max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, i, n)

    # 只提取前K个最大值
    result = []
    for i in range(n - 1, n - k - 1, -1):
        result.append(arr[0])
        arr[0], arr[i] = arr[i], arr[0]
        heapify_down(arr, 0, i)

    return result

# 测试
arr = [3, 1, 4, 1, 5, 9, 2, 6]
print(top_k_heap_sort(arr, 3))  # [9, 6, 5]
```

### 6.2 外部排序

```python
def external_sort(input_file, output_file, memory_limit):
    """
    外部排序:处理超大文件

    策略:
    1. 将文件分块,每块用堆排序
    2. 使用min-heap合并有序块
    """
    # Step 1: 分块排序
    chunks = []
    with open(input_file, 'r') as f:
        chunk = []
        for line in f:
            chunk.append(int(line.strip()))

            if len(chunk) >= memory_limit:
                heap_sort(chunk)
                chunk_file = f"chunk_{len(chunks)}.tmp"
                with open(chunk_file, 'w') as cf:
                    for num in chunk:
                        cf.write(f"{num}\n")
                chunks.append(chunk_file)
                chunk = []

        if chunk:
            heap_sort(chunk)
            chunk_file = f"chunk_{len(chunks)}.tmp"
            with open(chunk_file, 'w') as cf:
                for num in chunk:
                    cf.write(f"{num}\n")
            chunks.append(chunk_file)

    # Step 2: 多路归并
    import heapq
    heap = []
    files = [open(chunk, 'r') for chunk in chunks]

    # 初始化heap
    for i, f in enumerate(files):
        line = f.readline()
        if line:
            heapq.heappush(heap, (int(line.strip()), i))

    # 归并
    with open(output_file, 'w') as out:
        while heap:
            num, file_idx = heapq.heappop(heap)
            out.write(f"{num}\n")

            # 读取下一个元素
            line = files[file_idx].readline()
            if line:
                heapq.heappush(heap, (int(line.strip()), file_idx))

    # 清理
    for f in files:
        f.close()
    for chunk in chunks:
        os.remove(chunk)
```

### 6.3 RAG文档排序

```python
import heapq

def rag_document_ranking(query_emb, doc_embs):
    """
    RAG文档排序

    使用堆排序对检索结果排序
    """
    # 计算相似度
    scores = []
    for doc_id, doc_emb in doc_embs:
        score = cosine_similarity(query_emb, doc_emb)
        scores.append((score, doc_id))

    # 堆排序(降序)
    heap_sort_descending(scores)

    return scores

def heap_sort_descending(arr):
    """降序堆排序"""
    n = len(arr)

    # 建min-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_down_min(arr, i, n)

    # 反复提取最小值(放到末尾)
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_down_min(arr, 0, i)

    return arr

def heapify_down_min(arr, i, n):
    """Min-heap的heapify-down"""
    while 2 * i + 1 < n:
        left = 2 * i + 1
        right = 2 * i + 2
        smallest = i

        if arr[left] < arr[smallest]:
            smallest = left

        if right < n and arr[right] < arr[smallest]:
            smallest = right

        if smallest != i:
            arr[i], arr[smallest] = arr[smallest], arr[i]
            i = smallest
        else:
            break
```

---

## 7. 堆排序的局限性

### 7.1 不稳定性

```python
# 堆排序不稳定
arr = [(5, 'a'), (3, 'b'), (5, 'c'), (1, 'd')]

# 排序后,(5, 'a')和(5, 'c')的相对顺序可能改变
heap_sort(arr)
# 可能结果: [(1, 'd'), (3, 'b'), (5, 'c'), (5, 'a')]
#                                    ^^^^^^  ^^^^^^
#                                    顺序颠倒!
```

**解决方案:**

```python
# 方法1: 添加索引保证稳定性
arr = [(5, 'a', 0), (3, 'b', 1), (5, 'c', 2), (1, 'd', 3)]

def stable_heap_sort(arr):
    """稳定的堆排序"""
    # 按(值, 索引)排序
    arr_with_idx = [(val, idx, item) for idx, (val, item) in enumerate(arr)]
    heap_sort(arr_with_idx)
    return [(val, item) for val, idx, item in arr_with_idx]

# 方法2: 使用稳定排序算法(归并排序)
arr.sort()  # Python的sort是稳定的(Timsort)
```

### 7.2 缓存不友好

```python
# 堆排序的访问模式
def heapify_down(arr, i, n):
    while 2 * i + 1 < n:
        left = 2 * i + 1   # 跳跃访问
        right = 2 * i + 2  # 跳跃访问
        # ...

# 快排的访问模式
def quicksort(arr, left, right):
    # 顺序扫描,缓存友好
    for i in range(left, right):
        # ...
```

**性能影响:**

```
堆排序:
- 随机访问模式
- 缓存命中率低
- 实际性能比理论慢

快排:
- 顺序访问模式
- 缓存命中率高
- 实际性能接近理论
```

### 7.3 常数因子大

```python
# 堆排序的操作
def heap_sort(arr):
    # 建堆: n次heapify-down
    # 排序: n次heapify-down
    # 每次heapify: 多次比较和交换

# 快排的操作
def quicksort(arr):
    # 分区: 一次扫描
    # 递归: 两次递归调用
    # 每次分区: 一次比较和可能的交换

# 常数因子:
# 堆排序 ≈ 2n log n
# 快排 ≈ 1.4n log n
```

---

## 8. 实战技巧

### 8.1 何时使用堆排序?

**使用场景:**
1. 需要O(n log n)保证(实时系统)
2. 空间极度受限(嵌入式系统)
3. 不需要稳定性
4. 数据量中等(10K-1M)

**不使用场景:**
1. 需要稳定性 → 归并排序
2. 追求最快速度 → 快排
3. 小数据量(<100) → 插入排序
4. 大数据量(>10M) → 外部排序

### 8.2 调试技巧

```python
def heap_sort_debug(arr):
    """带调试信息的堆排序"""
    n = len(arr)

    print("=== 建堆阶段 ===")
    for i in range(n // 2 - 1, -1, -1):
        print(f"heapify({i}): {arr}")
        heapify_down(arr, i, n)

    print(f"\n建堆完成: {arr}")
    print("\n=== 排序阶段 ===")

    for i in range(n - 1, 0, -1):
        print(f"交换 arr[0]={arr[0]} 和 arr[{i}]={arr[i]}")
        arr[0], arr[i] = arr[i], arr[0]
        print(f"交换后: {arr}")

        heapify_down(arr, 0, i)
        print(f"heapify后: {arr}\n")

    return arr

# 测试
arr = [4, 10, 3, 5, 1]
heap_sort_debug(arr)
```

### 8.3 性能优化清单

```python
# ✅ 优化1: 减少交换次数
def heapify_down_optimized(arr, i, n):
    value = arr[i]
    while 2 * i + 1 < n:
        # 用赋值代替交换
        pass

# ✅ 优化2: 提前终止
def heap_sort_early_stop(arr):
    # 检测已有序
    pass

# ✅ 优化3: 混合排序
def hybrid_sort(arr, threshold=10):
    # 小数组用插入排序
    pass

# ✅ 优化4: 批量建堆
def heap_sort_batch(arr):
    # 使用heapify而非逐个插入
    pass
```

---

## 9. 常见误区

### 误区1: "堆排序比快排快"

```python
# ❌ 错误理解
# 堆排序和快排都是O(n log n),所以一样快

# ✅ 正确理解
# 虽然渐进复杂度相同,但:
# - 快排常数因子更小
# - 快排缓存友好
# - 快排平均情况更快
# 实际测试:快排通常快2-3倍
```

### 误区2: "堆排序是稳定的"

```python
# ❌ 错误理解
# 堆排序不会改变相等元素的相对顺序

# ✅ 正确理解
# 堆排序是不稳定的
# 建堆和heapify过程会打乱相等元素的顺序
```

### 误区3: "堆排序适合所有场景"

```python
# ❌ 错误理解
# 堆排序有O(n log n)保证,应该总是使用

# ✅ 正确理解
# 不同场景选择不同算法:
# - 小数据: 插入排序
# - 需要稳定性: 归并排序
# - 追求速度: 快排
# - 空间受限: 堆排序
```

---

## 10. 一句话总结

**堆排序通过建max-heap(O(n))后反复提取最大值(O(n log n))实现排序,保证O(n log n)时间和O(1)空间,但不稳定且缓存不友好,适用于需要性能保证且空间受限的场景,实际应用中常作为快排的备选方案。**
