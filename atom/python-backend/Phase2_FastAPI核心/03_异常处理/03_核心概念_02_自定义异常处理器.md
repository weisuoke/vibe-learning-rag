# 核心概念2：自定义异常处理器

> 使用 @app.exception_handler() 装饰器捕获特定异常，实现精细化错误处理

---

## 一句话定义

**自定义异常处理器是通过 `@app.exception_handler(ExceptionType)` 装饰器注册的函数，用于捕获特定类型的异常并返回自定义响应，类似 Express 的错误中间件。**

---

## 为什么需要自定义异常处理器？

### 问题：HTTPException 不够灵活

```python
# ❌ 问题1：每个路由都要写相同的错误处理逻辑
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    try:
        user = db.get_user(user_id)
        if not user:
            raise HTTPException(status_code=404, detail="用户不存在")
        return user
    except SQLAlchemyError as e:
        logger.error(f"数据库错误: {e}")
        raise HTTPException(status_code=500, detail="数据库操作失败")

@app.get("/posts/{post_id}")
async def get_post(post_id: int):
    try:
        post = db.get_post(post_id)
        if not post:
            raise HTTPException(status_code=404, detail="文章不存在")
        return post
    except SQLAlchemyError as e:
        logger.error(f"数据库错误: {e}")  # 重复的错误处理逻辑
        raise HTTPException(status_code=500, detail="数据库操作失败")
```

**问题：**
- 每个路由都要写 try/except
- 错误处理逻辑重复
- 难以统一修改错误响应格式

---

### 解决方案：自定义异常处理器

```python
# ✅ 解决方案：统一处理数据库异常
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from sqlalchemy.exc import SQLAlchemyError

app = FastAPI()

# 注册异常处理器
@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
    """统一处理所有数据库异常"""
    logger.error(f"数据库错误: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "数据库操作失败，请稍后重试"}
    )

# 路由代码变得简洁
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = db.get_user(user_id)  # 不需要 try/except
    if not user:
        raise HTTPException(status_code=404, detail="用户不存在")
    return user

@app.get("/posts/{post_id}")
async def get_post(post_id: int):
    post = db.get_post(post_id)  # 不需要 try/except
    if not post:
        raise HTTPException(status_code=404, detail="文章不存在")
    return post
```

**优势：**
- 路由代码只关注业务逻辑
- 错误处理逻辑集中在一个地方
- 易于维护和修改

---

## 自定义异常处理器的基本用法

### 1. 注册异常处理器

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    """处理 ValueError 异常"""
    return JSONResponse(
        status_code=400,
        content={"error": f"参数错误: {str(exc)}"}
    )
```

**关键点：**
- 使用 `@app.exception_handler(ExceptionType)` 装饰器
- 函数接收两个参数：`request` 和 `exc`
- 返回 `JSONResponse` 或其他响应对象

---

### 2. 处理多种异常

```python
# 方式1：为每种异常注册单独的处理器
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    return JSONResponse(status_code=400, content={"error": str(exc)})

@app.exception_handler(KeyError)
async def key_error_handler(request: Request, exc: KeyError):
    return JSONResponse(status_code=400, content={"error": f"缺少键: {str(exc)}"})

# 方式2：一个处理器处理多种异常（使用父类）
@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """捕获所有未处理的异常"""
    logger.error(f"未处理的异常: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "服务器内部错误"}
    )
```

---

### 3. 访问请求信息

```python
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    """处理器可以访问请求信息"""
    return JSONResponse(
        status_code=400,
        content={
            "error": str(exc),
            "path": request.url.path,  # 请求路径
            "method": request.method,  # 请求方法
            "client": request.client.host  # 客户端 IP
        }
    )
```

---

## 实战示例

### 示例1：处理自定义业务异常

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

# 1. 定义自定义异常类
class UserNotFoundError(Exception):
    """用户不存在异常"""
    def __init__(self, user_id: int):
        self.user_id = user_id
        super().__init__(f"用户 {user_id} 不存在")

class InsufficientBalanceError(Exception):
    """余额不足异常"""
    def __init__(self, balance: float, required: float):
        self.balance = balance
        self.required = required
        super().__init__(f"余额不足，当前余额: {balance}，需要: {required}")

# 2. 注册异常处理器
@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    return JSONResponse(
        status_code=404,
        content={
            "error": "用户不存在",
            "code": "USER_NOT_FOUND",
            "user_id": exc.user_id
        }
    )

@app.exception_handler(InsufficientBalanceError)
async def insufficient_balance_handler(request: Request, exc: InsufficientBalanceError):
    return JSONResponse(
        status_code=400,
        content={
            "error": "余额不足",
            "code": "INSUFFICIENT_BALANCE",
            "balance": exc.balance,
            "required": exc.required
        }
    )

# 3. 在路由中使用
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = db.get_user(user_id)
    if not user:
        raise UserNotFoundError(user_id)  # 抛出自定义异常
    return user

@app.post("/transfer")
async def transfer(from_user: int, to_user: int, amount: float):
    user = db.get_user(from_user)
    if user.balance < amount:
        raise InsufficientBalanceError(user.balance, amount)  # 抛出自定义异常
    # 执行转账逻辑
    return {"message": "转账成功"}
```

**测试：**
```bash
# 用户不存在
curl http://localhost:8000/users/999
# 响应: {"error": "用户不存在", "code": "USER_NOT_FOUND", "user_id": 999}
# 状态码: 404

# 余额不足
curl -X POST http://localhost:8000/transfer \
  -H "Content-Type: application/json" \
  -d '{"from_user": 1, "to_user": 2, "amount": 1000}'
# 响应: {"error": "余额不足", "code": "INSUFFICIENT_BALANCE", "balance": 100, "required": 1000}
# 状态码: 400
```

---

### 示例2：处理数据库异常

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from sqlalchemy.exc import SQLAlchemyError, IntegrityError

app = FastAPI()

@app.exception_handler(IntegrityError)
async def integrity_error_handler(request: Request, exc: IntegrityError):
    """处理数据库完整性约束错误（如唯一键冲突）"""
    logger.error(f"数据库完整性错误: {exc}")

    # 解析错误信息
    error_msg = str(exc.orig)
    if "UNIQUE constraint failed" in error_msg:
        return JSONResponse(
            status_code=409,
            content={"error": "数据已存在，请勿重复提交"}
        )
    elif "FOREIGN KEY constraint failed" in error_msg:
        return JSONResponse(
            status_code=400,
            content={"error": "关联数据不存在"}
        )
    else:
        return JSONResponse(
            status_code=400,
            content={"error": "数据验证失败"}
        )

@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_error_handler(request: Request, exc: SQLAlchemyError):
    """处理其他数据库错误"""
    logger.error(f"数据库错误: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "数据库操作失败，请稍后重试"}
    )
```

---

### 示例3：处理第三方 API 异常（OpenAI）

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from openai import OpenAIError, RateLimitError, APITimeoutError

app = FastAPI()

@app.exception_handler(RateLimitError)
async def rate_limit_handler(request: Request, exc: RateLimitError):
    """处理 OpenAI 限流错误"""
    logger.warning(f"OpenAI 限流: {exc}")
    return JSONResponse(
        status_code=429,
        content={
            "error": "请求过于频繁，请稍后重试",
            "code": "RATE_LIMIT_EXCEEDED"
        },
        headers={"Retry-After": "60"}  # 建议 60 秒后重试
    )

@app.exception_handler(APITimeoutError)
async def timeout_handler(request: Request, exc: APITimeoutError):
    """处理 OpenAI 超时错误"""
    logger.error(f"OpenAI 超时: {exc}")
    return JSONResponse(
        status_code=504,
        content={
            "error": "AI 服务响应超时，请稍后重试",
            "code": "API_TIMEOUT"
        }
    )

@app.exception_handler(OpenAIError)
async def openai_error_handler(request: Request, exc: OpenAIError):
    """处理其他 OpenAI 错误"""
    logger.error(f"OpenAI 错误: {exc}")
    return JSONResponse(
        status_code=503,
        content={
            "error": "AI 服务暂时不可用",
            "code": "AI_SERVICE_UNAVAILABLE"
        }
    )

# 使用示例
@app.post("/chat")
async def chat(message: str):
    # 不需要 try/except，异常会被自动捕获
    response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": message}]
    )
    return {"reply": response.choices[0].message.content}
```

---

### 示例4：统一错误响应格式

```python
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from datetime import datetime
import traceback

app = FastAPI()

def create_error_response(
    status_code: int,
    error: str,
    code: str = None,
    details: dict = None,
    request: Request = None
):
    """创建统一的错误响应格式"""
    response = {
        "success": False,
        "error": error,
        "timestamp": datetime.utcnow().isoformat()
    }

    if code:
        response["code"] = code

    if details:
        response["details"] = details

    if request:
        response["path"] = request.url.path
        response["method"] = request.method

    return JSONResponse(status_code=status_code, content=response)

# 处理 HTTPException
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return create_error_response(
        status_code=exc.status_code,
        error=exc.detail,
        request=request
    )

# 处理自定义异常
@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    return create_error_response(
        status_code=404,
        error="用户不存在",
        code="USER_NOT_FOUND",
        details={"user_id": exc.user_id},
        request=request
    )

# 处理所有未捕获的异常
@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    logger.error(f"未处理的异常: {exc}\n{traceback.format_exc()}")
    return create_error_response(
        status_code=500,
        error="服务器内部错误",
        code="INTERNAL_SERVER_ERROR",
        request=request
    )
```

**统一的错误响应格式：**
```json
{
  "success": false,
  "error": "用户不存在",
  "code": "USER_NOT_FOUND",
  "details": {
    "user_id": 999
  },
  "path": "/users/999",
  "method": "GET",
  "timestamp": "2026-02-11T09:30:00.000Z"
}
```

---

## 与 Express 的对比

### Express 错误中间件

```javascript
// Express: 错误中间件
app.use((err, req, res, next) => {
  // 处理特定错误
  if (err instanceof UserNotFoundError) {
    return res.status(404).json({
      error: 'User not found',
      userId: err.userId
    });
  }

  // 处理数据库错误
  if (err.name === 'SequelizeUniqueConstraintError') {
    return res.status(409).json({
      error: 'Data already exists'
    });
  }

  // 默认错误处理
  res.status(500).json({
    error: 'Internal server error'
  });
});
```

### FastAPI 异常处理器

```python
# FastAPI: 异常处理器
@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    return JSONResponse(
        status_code=404,
        content={"error": "User not found", "userId": exc.user_id}
    )

@app.exception_handler(IntegrityError)
async def integrity_error_handler(request: Request, exc: IntegrityError):
    return JSONResponse(
        status_code=409,
        content={"error": "Data already exists"}
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content={"error": "Internal server error"}
    )
```

**对比：**

| 特性 | Express | FastAPI |
|------|---------|---------|
| 注册方式 | `app.use((err, req, res, next) => {})` | `@app.exception_handler(ExceptionType)` |
| 错误类型判断 | `instanceof` 或 `err.name` | 装饰器参数指定 |
| 多个处理器 | 一个中间件处理所有错误 | 每种异常一个处理器 |
| 优先级 | 按注册顺序 | 按异常继承关系（子类优先） |
| 类型安全 | 无 | 有（TypeScript 类型提示） |

---

## 异常处理器的优先级

### 规则：子类异常优先于父类异常

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

# 父类异常处理器
@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content={"error": "通用错误", "type": "Exception"}
    )

# 子类异常处理器
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    return JSONResponse(
        status_code=400,
        content={"error": "参数错误", "type": "ValueError"}
    )

@app.get("/test")
async def test():
    raise ValueError("测试错误")  # 会被 value_error_handler 捕获，而不是 general_exception_handler
```

**优先级顺序：**
```
ValueError → Exception
   ↓            ↓
子类优先    父类兜底
```

---

## 在 AI Agent 开发中的应用

### 场景1：RAG 检索失败

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

class VectorSearchError(Exception):
    """向量检索异常"""
    pass

@app.exception_handler(VectorSearchError)
async def vector_search_error_handler(request: Request, exc: VectorSearchError):
    logger.error(f"向量检索失败: {exc}")
    return JSONResponse(
        status_code=503,
        content={
            "error": "文档检索服务暂时不可用",
            "code": "VECTOR_SEARCH_ERROR"
        }
    )

@app.post("/search")
async def search_documents(query: str):
    # 向量检索可能失败（数据库连接、超时等）
    results = vector_db.search(query)  # 如果失败会抛出 VectorSearchError
    return {"results": results}
```

---

### 场景2：LLM 生成失败

```python
class LLMGenerationError(Exception):
    """LLM 生成异常"""
    def __init__(self, model: str, error: str):
        self.model = model
        self.error = error
        super().__init__(f"LLM 生成失败: {error}")

@app.exception_handler(LLMGenerationError)
async def llm_generation_error_handler(request: Request, exc: LLMGenerationError):
    logger.error(f"LLM 生成失败: {exc}")
    return JSONResponse(
        status_code=503,
        content={
            "error": "AI 生成服务暂时不可用",
            "code": "LLM_GENERATION_ERROR",
            "model": exc.model
        }
    )
```

---

## 最佳实践

### 1. 为业务异常创建自定义异常类

```python
# ✅ 好：清晰的异常类
class UserNotFoundError(Exception):
    pass

class InsufficientBalanceError(Exception):
    pass

# ❌ 差：都用 ValueError
raise ValueError("用户不存在")  # 无法区分不同的业务错误
raise ValueError("余额不足")
```

---

### 2. 异常类携带上下文信息

```python
# ✅ 好：异常携带详细信息
class UserNotFoundError(Exception):
    def __init__(self, user_id: int):
        self.user_id = user_id
        super().__init__(f"用户 {user_id} 不存在")

# ❌ 差：只有错误消息
class UserNotFoundError(Exception):
    pass
```

---

### 3. 记录详细日志

```python
# ✅ 好：记录详细日志
@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_error_handler(request: Request, exc: SQLAlchemyError):
    logger.error(
        f"数据库错误: {exc}",
        extra={
            "path": request.url.path,
            "method": request.method,
            "client_ip": request.client.host
        }
    )
    return JSONResponse(status_code=500, content={"error": "数据库操作失败"})

# ❌ 差：不记录日志
@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_error_handler(request: Request, exc: SQLAlchemyError):
    return JSONResponse(status_code=500, content={"error": "数据库操作失败"})
```

---

### 4. 避免泄露敏感信息

```python
# ✅ 好：不泄露内部错误
@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    logger.error(f"未处理的异常: {exc}\n{traceback.format_exc()}")  # 详细日志
    return JSONResponse(
        status_code=500,
        content={"error": "服务器内部错误"}  # 用户只看到通用错误
    )

# ❌ 差：泄露内部错误
@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content={"error": str(exc)}  # 可能暴露敏感信息
    )
```

---

## 常见问题

### Q1: 异常处理器的执行顺序是什么？

**A:** 按照异常的继承关系，子类优先于父类。

```python
# ValueError 是 Exception 的子类
@app.exception_handler(Exception)  # 父类
async def general_handler(request, exc):
    return JSONResponse(status_code=500, content={"error": "通用错误"})

@app.exception_handler(ValueError)  # 子类
async def value_error_handler(request, exc):
    return JSONResponse(status_code=400, content={"error": "参数错误"})

# raise ValueError() 会被 value_error_handler 捕获
# raise KeyError() 会被 general_handler 捕获
```

---

### Q2: 可以在异常处理器中再次抛出异常吗？

**A:** 可以，但要小心避免无限循环。

```python
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    if "critical" in str(exc):
        # 重新抛出，让更通用的处理器处理
        raise exc
    return JSONResponse(status_code=400, content={"error": str(exc)})
```

---

### Q3: 异常处理器可以是同步函数吗？

**A:** 可以，但推荐使用异步函数。

```python
# 同步函数（可以，但不推荐）
@app.exception_handler(ValueError)
def value_error_handler(request: Request, exc: ValueError):
    return JSONResponse(status_code=400, content={"error": str(exc)})

# 异步函数（推荐）
@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    return JSONResponse(status_code=400, content={"error": str(exc)})
```

---

## 小结

**自定义异常处理器的核心价值：**

1. **集中管理**：所有错误处理逻辑集中在一个地方
2. **代码简洁**：路由代码不需要 try/except
3. **类型安全**：每种异常有专门的处理器
4. **易于维护**：修改错误响应格式只需改一处
5. **生产可靠**：统一记录日志、发送告警

**下一步：** 学习如何使用全局异常中间件实现更高级的错误处理架构。

---

**相关文档：**
- [FastAPI 官方文档 - 自定义异常处理器](https://fastapi.tiangolo.com/tutorial/handling-errors/#install-custom-exception-handlers)
