# 反直觉点

> 装饰器的3个常见误区，避免踩坑

---

## 误区1：装饰器会修改原函数 ❌

### 为什么错？

**装饰器不会修改原函数，而是创建一个新函数来替换原函数的引用。**

```python
def my_decorator(func):
    print(f"原函数 ID: {id(func)}")
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    print(f"包装函数 ID: {id(wrapper)}")
    return wrapper

@my_decorator
def my_function():
    pass

print(f"装饰后的函数 ID: {id(my_function)}")

# 输出：
# 原函数 ID: 140234567890123
# 包装函数 ID: 140234567890456  # 不同的 ID！
# 装饰后的函数 ID: 140234567890456  # 和 wrapper 相同
```

**原函数还在，只是引用被替换了：**

```python
def my_decorator(func):
    original_func = func  # 保存原函数引用
    def wrapper(*args, **kwargs):
        print("Before")
        result = original_func(*args, **kwargs)  # 原函数还在这里
        print("After")
        return result
    wrapper.original = original_func  # 可以访问原函数
    return wrapper

@my_decorator
def greet(name):
    return f"Hello, {name}!"

# 调用装饰后的函数
print(greet("Alice"))
# 输出：
# Before
# Hello, Alice!
# After

# 可以访问原函数
print(greet.original("Bob"))
# 输出：Hello, Bob!（没有 Before/After）
```

### 为什么人们容易这样错？

**心理原因：** `@decorator` 语法看起来像是"修改"函数，但实际上是"替换"引用。

**类比：** 就像给礼物包装，礼物本身没变，只是外面多了一层包装纸。

```python
# 装饰器的本质
@my_decorator
def func():
    pass

# 等价于：
def func():
    pass
func = my_decorator(func)  # 替换引用，不是修改原函数
```

### 正确理解

**装饰器做了什么：**
1. 接收原函数
2. 创建新函数（wrapper）
3. 返回新函数
4. 原函数的名字现在指向新函数

**实际影响：**

```python
from functools import wraps

def bad_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@bad_decorator
def my_function():
    """这是我的函数"""
    pass

# 问题：元信息丢失
print(my_function.__name__)  # wrapper（不是 my_function！）
print(my_function.__doc__)   # None（文档丢失！）

# 解决方案：使用 @wraps
def good_decorator(func):
    @wraps(func)  # 复制原函数的元信息到 wrapper
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@good_decorator
def my_function():
    """这是我的函数"""
    pass

print(my_function.__name__)  # my_function（正确！）
print(my_function.__doc__)   # 这是我的函数（保留了！）
```

---

## 误区2：装饰器在函数调用时执行 ❌

### 为什么错？

**装饰器在函数定义时执行（模块导入时），不是在函数调用时执行。**

```python
def my_decorator(func):
    print(f"[定义时] 装饰器执行，装饰 {func.__name__}")
    def wrapper(*args, **kwargs):
        print(f"[调用时] wrapper 执行")
        return func(*args, **kwargs)
    return wrapper

print("=" * 50)
print("开始定义函数")

@my_decorator
def greet():
    print("Hello!")

print("函数定义完成")
print("=" * 50)
print("开始调用函数")

greet()

print("函数调用完成")

# 输出：
# ==================================================
# 开始定义函数
# [定义时] 装饰器执行，装饰 greet  # 注意：这是在定义时！
# 函数定义完成
# ==================================================
# 开始调用函数
# [调用时] wrapper 执行
# Hello!
# 函数调用完成
```

**这就是为什么 FastAPI 能在启动时就知道所有路由：**

```python
from fastapi import FastAPI

app = FastAPI()

print("=" * 50)
print("开始定义路由")

@app.get("/users")
def get_users():
    return [{"id": 1, "name": "Alice"}]

print("路由定义完成")
print(f"已注册的路由: {list(app.routes)}")
print("=" * 50)

# 输出：
# ==================================================
# 开始定义路由
# 路由定义完成
# 已注册的路由: [Route(path='/users', ...)]  # 路由已经注册了！
# ==================================================

# 注意：我们还没有调用 get_users()，但路由已经注册了
```

### 为什么人们容易这样错？

**心理原因：** 装饰器的效果（如日志、计时）是在函数调用时看到的，所以误以为装饰器也是在调用时执行。

**混淆点：**
- **装饰器函数**在定义时执行（只执行一次）
- **wrapper 函数**在调用时执行（每次调用都执行）

### 正确理解

**两个执行时机：**

```python
def decorator(func):
    # 这里的代码在定义时执行（模块导入时）
    print("装饰器执行：只执行一次")

    def wrapper(*args, **kwargs):
        # 这里的代码在调用时执行（每次调用都执行）
        print("wrapper 执行：每次调用都执行")
        return func(*args, **kwargs)

    return wrapper

@decorator
def my_function():
    print("函数执行")

# 定义时输出：装饰器执行：只执行一次

my_function()
# 输出：
# wrapper 执行：每次调用都执行
# 函数执行

my_function()
# 输出：
# wrapper 执行：每次调用都执行
# 函数执行

# 注意：装饰器只执行了一次（定义时）
# wrapper 执行了两次（每次调用）
```

**实际应用：**

```python
# 利用定义时执行的特性，在装饰器中做初始化
def with_cache(func):
    # 在定义时创建缓存字典（只创建一次）
    cache = {}
    print(f"为 {func.__name__} 创建缓存")

    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]

    return wrapper

@with_cache
def expensive_function(n):
    print(f"计算 {n}")
    return n * n

# 定义时输出：为 expensive_function 创建缓存

expensive_function(5)  # 计算 5
expensive_function(5)  # 缓存命中，不计算
expensive_function(10) # 计算 10
```

**陷阱：定义时的副作用**

```python
# ❌ 错误：在装饰器中做耗时操作
def bad_decorator(func):
    import time
    time.sleep(5)  # 模块导入时会阻塞 5 秒！
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@bad_decorator  # 这里会阻塞 5 秒
def my_function():
    pass

# 问题：模块导入时就会阻塞，不是调用时
```

```python
# ✅ 正确：耗时操作放在 wrapper 中
def good_decorator(func):
    def wrapper(*args, **kwargs):
        import time
        time.sleep(5)  # 调用时才阻塞
        return func(*args, **kwargs)
    return wrapper

@good_decorator
def my_function():
    pass

# 模块导入时不阻塞，只有调用时才阻塞
```

---

## 误区3：多个装饰器的执行顺序是从上到下 ❌

### 为什么错？

**多个装饰器的执行顺序：**
- **定义时**：从下到上
- **调用时**：从上到下

```python
def decorator_a(func):
    print("A: 装饰器执行（定义时）")
    def wrapper(*args, **kwargs):
        print("A: 调用前")
        result = func(*args, **kwargs)
        print("A: 调用后")
        return result
    return wrapper

def decorator_b(func):
    print("B: 装饰器执行（定义时）")
    def wrapper(*args, **kwargs):
        print("B: 调用前")
        result = func(*args, **kwargs)
        print("B: 调用后")
        return result
    return wrapper

def decorator_c(func):
    print("C: 装饰器执行（定义时）")
    def wrapper(*args, **kwargs):
        print("C: 调用前")
        result = func(*args, **kwargs)
        print("C: 调用后")
        return result
    return wrapper

@decorator_a
@decorator_b
@decorator_c
def my_function():
    print("函数执行")

# 定义时输出（从下到上）：
# C: 装饰器执行（定义时）
# B: 装饰器执行（定义时）
# A: 装饰器执行（定义时）

print("=" * 50)
my_function()

# 调用时输出（从上到下）：
# A: 调用前
# B: 调用前
# C: 调用前
# 函数执行
# C: 调用后
# B: 调用后
# A: 调用后
```

**等价于：**

```python
@decorator_a
@decorator_b
@decorator_c
def my_function():
    pass

# 等价于：
my_function = decorator_a(decorator_b(decorator_c(my_function)))

# 执行顺序：
# 1. decorator_c(my_function) 返回 wrapper_c
# 2. decorator_b(wrapper_c) 返回 wrapper_b
# 3. decorator_a(wrapper_b) 返回 wrapper_a
# 4. my_function 现在指向 wrapper_a

# 调用 my_function() 时：
# wrapper_a() → wrapper_b() → wrapper_c() → 原函数 → wrapper_c → wrapper_b → wrapper_a
```

### 为什么人们容易这样错？

**心理原因：** 代码是从上到下阅读的，所以直觉认为执行顺序也是从上到下。

**混淆点：**
- 定义时的执行顺序（从下到上）
- 调用时的执行顺序（从上到下）

### 正确理解

**洋葱模型（Onion Model）：**

```
装饰器 A（最外层）
  ↓
装饰器 B（中间层）
  ↓
装饰器 C（最内层）
  ↓
原函数（核心）
  ↓
装饰器 C（最内层）
  ↓
装饰器 B（中间层）
  ↓
装饰器 A（最外层）
```

**实际应用：顺序很重要**

```python
from functools import wraps

def require_auth(func):
    """权限检查装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        user = kwargs.get('user')
        if not user or not user.get('authenticated'):
            raise PermissionError("未认证")
        return func(*args, **kwargs)
    return wrapper

def log(func):
    """日志装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"调用 {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

# ✅ 正确顺序：先检查权限，再记录日志
@log
@require_auth
def delete_user(user_id, user=None):
    return f"删除用户 {user_id}"

try:
    delete_user(123, user={'authenticated': False})
except PermissionError as e:
    print(f"错误: {e}")
# 输出：
# 调用 delete_user
# 错误: 未认证

# 注意：日志记录了调用，即使权限检查失败
```

```python
# ❌ 错误顺序：先记录日志，再检查权限
@require_auth
@log
def delete_user(user_id, user=None):
    return f"删除用户 {user_id}"

try:
    delete_user(123, user={'authenticated': False})
except PermissionError as e:
    print(f"错误: {e}")
# 输出：
# 错误: 未认证

# 注意：日志没有记录，因为权限检查在日志之前失败了
```

**FastAPI 中的顺序：**

```python
from fastapi import FastAPI, Depends

app = FastAPI()

def timing(func):
    """计时装饰器"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        import time
        start = time.time()
        result = await func(*args, **kwargs)
        print(f"耗时: {time.time() - start:.4f}秒")
        return result
    return wrapper

def require_auth(func):
    """权限检查装饰器"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        # 检查权限
        return await func(*args, **kwargs)
    return wrapper

# 顺序：路由 → 计时 → 权限 → 处理函数
@app.get("/users")
@timing
@require_auth
async def get_users():
    return [{"id": 1, "name": "Alice"}]

# 执行顺序：
# 1. 路由匹配
# 2. 计时开始
# 3. 权限检查
# 4. 处理函数
# 5. 权限检查完成
# 6. 计时结束
# 7. 返回响应
```

**记忆技巧：**

```python
# 定义时：从下到上（像盖房子，从地基到屋顶）
@roof        # 最后盖屋顶
@walls       # 然后砌墙
@foundation  # 先打地基
def house():
    pass

# 调用时：从上到下（像进房子，从屋顶到地基）
# 屋顶 → 墙 → 地基 → 房子核心 → 地基 → 墙 → 屋顶
```

---

## 额外误区：装饰器只能装饰函数 ❌

### 为什么错？

**装饰器可以装饰任何可调用对象，包括类、方法、生成器等。**

```python
# 装饰类
def singleton(cls):
    """单例装饰器"""
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class Database:
    def __init__(self):
        print("创建数据库连接")

db1 = Database()  # 创建数据库连接
db2 = Database()  # 不创建，返回已有实例
print(db1 is db2)  # True
```

```python
# 装饰方法
class MyClass:
    @staticmethod
    def static_method():
        return "静态方法"

    @classmethod
    def class_method(cls):
        return "类方法"

    @property
    def my_property(self):
        return "属性"

obj = MyClass()
print(obj.static_method())  # 静态方法
print(obj.class_method())   # 类方法
print(obj.my_property)      # 属性（不需要括号）
```

---

## 总结

**3个核心误区：**

1. **装饰器会修改原函数** ❌
   - 正确：装饰器创建新函数，替换引用
   - 原函数还在，只是名字指向了新函数

2. **装饰器在函数调用时执行** ❌
   - 正确：装饰器在定义时执行（模块导入时）
   - wrapper 在调用时执行

3. **多个装饰器从上到下执行** ❌
   - 正确：定义时从下到上，调用时从上到下
   - 洋葱模型：从外到内，再从内到外

**避免踩坑的建议：**

1. **使用 `@wraps(func)`** 保留原函数元信息
2. **不要在装饰器中做耗时操作**（定义时执行）
3. **注意多装饰器的顺序**（权限检查应该在最内层）
4. **理解装饰器的本质**（高阶函数 + 语法糖）

**快速检查清单：**

- [ ] 是否使用了 `@wraps(func)`？
- [ ] 装饰器中是否有耗时操作？（应该放在 wrapper 中）
- [ ] 多装饰器的顺序是否正确？（权限 → 日志 → 缓存）
- [ ] 是否理解了定义时 vs 调用时的区别？
- [ ] 是否理解了装饰器不修改原函数？

---

## 调试技巧

**查看装饰器的执行顺序：**

```python
def trace(name):
    """追踪装饰器执行顺序"""
    def decorator(func):
        print(f"[定义时] {name} 装饰 {func.__name__}")
        def wrapper(*args, **kwargs):
            print(f"[调用前] {name}")
            result = func(*args, **kwargs)
            print(f"[调用后] {name}")
            return result
        return wrapper
    return decorator

@trace("A")
@trace("B")
@trace("C")
def my_function():
    print("  [函数执行]")

print("=" * 50)
my_function()

# 输出：
# [定义时] C 装饰 my_function
# [定义时] B 装饰 wrapper
# [定义时] A 装饰 wrapper
# ==================================================
# [调用前] A
# [调用前] B
# [调用前] C
#   [函数执行]
# [调用后] C
# [调用后] B
# [调用后] A
```

**查看装饰后的函数：**

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def my_function():
    """原函数"""
    pass

print(f"函数名: {my_function.__name__}")  # wrapper（没有使用 @wraps）
print(f"函数类型: {type(my_function)}")   # <class 'function'>
print(f"是否是原函数: {my_function.__name__ == 'my_function'}")  # False
```

---

**记住：** 装饰器的本质是高阶函数，理解了执行时机和顺序，就能避免大部分误区。
