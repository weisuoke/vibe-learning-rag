# 实战代码1：基础PDF加载

> 使用pypdf和pdfplumber进行PDF文本提取的完整示例

---

## 场景描述

演示如何使用不同的PDF解析器加载PDF文档，并对比它们的效果。

**适用场景：**
- 快速原型开发
- 简单PDF文档处理
- 性能对比测试

---

## 依赖库

```bash
# 安装依赖
uv add pypdf pdfplumber langchain langchain-openai python-dotenv
```

---

## 完整代码

```python
"""
基础PDF加载示例
演示：使用pypdf和pdfplumber加载PDF文档

依赖库：
- pypdf: 轻量级PDF解析器
- pdfplumber: 高级PDF解析器
- langchain: 文档处理框架
- python-dotenv: 环境变量管理

参考来源：
- pypdf Documentation (2025): https://pypdf.readthedocs.io/
- pdfplumber Documentation (2025): https://github.com/jsvine/pdfplumber
- LangChain Document Loaders (2025): https://python.langchain.com/docs/modules/data_connection/document_loaders/
"""

import os
from typing import List
from dotenv import load_dotenv
from langchain.schema import Document

# 加载环境变量
load_dotenv()

# ===== 1. 使用pypdf加载PDF（快速） =====
print("=== 1. 使用pypdf加载PDF ===")

from pypdf import PdfReader

def load_pdf_with_pypdf(file_path: str) -> List[Document]:
    """
    使用pypdf加载PDF文档
    优点：速度快，内存占用小
    缺点：表格提取能力弱
    """
    reader = PdfReader(file_path)
    documents = []

    print(f"PDF总页数: {len(reader.pages)}")

    for page_num, page in enumerate(reader.pages):
        # 提取文本
        text = page.extract_text()

        # 创建Document对象
        doc = Document(
            page_content=text,
            metadata={
                "source": file_path,
                "page": page_num,
                "total_pages": len(reader.pages),
                "parser": "pypdf"
            }
        )
        documents.append(doc)

        # 显示前3页的内容预览
        if page_num < 3:
            print(f"\n第 {page_num + 1} 页内容预览:")
            print(text[:200] + "...")

    return documents

# 测试pypdf
# docs_pypdf = load_pdf_with_pypdf("sample.pdf")
# print(f"\npypdf加载完成，共 {len(docs_pypdf)} 页")

# ===== 2. 使用pdfplumber加载PDF（高质量） =====
print("\n=== 2. 使用pdfplumber加载PDF ===")

import pdfplumber

def load_pdf_with_pdfplumber(file_path: str) -> List[Document]:
    """
    使用pdfplumber加载PDF文档
    优点：表格提取能力强，保留布局信息
    缺点：速度较慢，内存占用较大
    """
    documents = []

    with pdfplumber.open(file_path) as pdf:
        print(f"PDF总页数: {len(pdf.pages)}")

        for page_num, page in enumerate(pdf.pages):
            # 提取文本
            text = page.extract_text()

            # 提取表格
            tables = page.extract_tables()

            # 创建Document对象
            doc = Document(
                page_content=text,
                metadata={
                    "source": file_path,
                    "page": page_num,
                    "total_pages": len(pdf.pages),
                    "parser": "pdfplumber",
                    "has_tables": len(tables) > 0,
                    "table_count": len(tables),
                    "page_width": page.width,
                    "page_height": page.height
                }
            )
            documents.append(doc)

            # 显示前3页的内容预览
            if page_num < 3:
                print(f"\n第 {page_num + 1} 页内容预览:")
                print(text[:200] + "...")
                if tables:
                    print(f"  包含 {len(tables)} 个表格")

    return documents

# 测试pdfplumber
# docs_pdfplumber = load_pdf_with_pdfplumber("sample.pdf")
# print(f"\npdfplumber加载完成，共 {len(docs_pdfplumber)} 页")

# ===== 3. 使用LangChain的PyPDFLoader =====
print("\n=== 3. 使用LangChain的PyPDFLoader ===")

from langchain.document_loaders import PyPDFLoader

def load_pdf_with_langchain(file_path: str) -> List[Document]:
    """
    使用LangChain的PyPDFLoader加载PDF
    优点：与LangChain生态集成，API统一
    """
    loader = PyPDFLoader(file_path)
    documents = loader.load()

    print(f"加载了 {len(documents)} 个文档")

    # 显示前3个文档的元数据
    for i, doc in enumerate(documents[:3]):
        print(f"\n文档 {i + 1} 元数据:")
        print(f"  来源: {doc.metadata['source']}")
        print(f"  页码: {doc.metadata['page']}")
        print(f"  内容预览: {doc.page_content[:100]}...")

    return documents

# 测试LangChain PyPDFLoader
# docs_langchain = load_pdf_with_langchain("sample.pdf")

# ===== 4. 提取PDF元数据 =====
print("\n=== 4. 提取PDF元数据 ===")

def extract_pdf_metadata(file_path: str) -> dict:
    """提取PDF文档的元数据"""
    reader = PdfReader(file_path)
    metadata = reader.metadata

    if metadata:
        meta_dict = {
            "title": metadata.get("/Title", ""),
            "author": metadata.get("/Author", ""),
            "subject": metadata.get("/Subject", ""),
            "creator": metadata.get("/Creator", ""),
            "producer": metadata.get("/Producer", ""),
            "creation_date": metadata.get("/CreationDate", ""),
            "modification_date": metadata.get("/ModDate", ""),
            "page_count": len(reader.pages)
        }

        print("PDF元数据:")
        for key, value in meta_dict.items():
            if value:
                print(f"  {key}: {value}")

        return meta_dict
    else:
        print("未找到PDF元数据")
        return {}

# 测试元数据提取
# metadata = extract_pdf_metadata("sample.pdf")

# ===== 5. 性能对比 =====
print("\n=== 5. 性能对比 ===")

import time

def benchmark_pdf_loaders(file_path: str):
    """对比不同PDF加载器的性能"""
    results = {}

    # 测试pypdf
    print("测试pypdf...")
    start_time = time.time()
    docs_pypdf = load_pdf_with_pypdf(file_path)
    pypdf_time = time.time() - start_time
    results["pypdf"] = {
        "time": pypdf_time,
        "pages": len(docs_pypdf),
        "total_chars": sum(len(doc.page_content) for doc in docs_pypdf)
    }

    # 测试pdfplumber
    print("\n测试pdfplumber...")
    start_time = time.time()
    docs_pdfplumber = load_pdf_with_pdfplumber(file_path)
    pdfplumber_time = time.time() - start_time
    results["pdfplumber"] = {
        "time": pdfplumber_time,
        "pages": len(docs_pdfplumber),
        "total_chars": sum(len(doc.page_content) for doc in docs_pdfplumber)
    }

    # 显示对比结果
    print("\n=== 性能对比结果 ===")
    print(f"{'解析器':<15} {'耗时(秒)':<12} {'页数':<8} {'总字符数':<12} {'速度(页/秒)':<12}")
    print("-" * 70)

    for parser, data in results.items():
        speed = data['pages'] / data['time'] if data['time'] > 0 else 0
        print(f"{parser:<15} {data['time']:<12.2f} {data['pages']:<8} {data['total_chars']:<12} {speed:<12.2f}")

    return results

# 测试性能对比
# benchmark_results = benchmark_pdf_loaders("sample.pdf")

# ===== 6. RAG应用场景：构建PDF知识库 =====
print("\n=== 6. RAG应用场景：构建PDF知识库 ===")

from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.vectorstores import Chroma
from langchain.embeddings import OpenAIEmbeddings

def build_pdf_knowledge_base(pdf_files: List[str], output_dir: str = "./pdf_kb"):
    """
    从PDF文件构建RAG知识库

    Args:
        pdf_files: PDF文件路径列表
        output_dir: 向量库输出目录
    """
    print(f"开始构建PDF知识库，共 {len(pdf_files)} 个文件")

    # 1. 加载所有PDF文档
    all_documents = []
    for pdf_file in pdf_files:
        print(f"\n加载: {pdf_file}")
        try:
            # 使用pdfplumber获得更好的质量
            docs = load_pdf_with_pdfplumber(pdf_file)
            all_documents.extend(docs)
            print(f"  ✅ 成功加载 {len(docs)} 页")
        except Exception as e:
            print(f"  ❌ 加载失败: {e}")

    print(f"\n总共加载 {len(all_documents)} 个文档")

    # 2. 文本分块
    print("\n分块处理...")
    splitter = RecursiveCharacterTextSplitter(
        chunk_size=1000,
        chunk_overlap=200
    )
    chunks = splitter.split_documents(all_documents)
    print(f"分块后得到 {len(chunks)} 个文本块")

    # 3. 向量化并存储
    print("\n向量化并存储...")
    try:
        embeddings = OpenAIEmbeddings()
        vectorstore = Chroma.from_documents(
            chunks,
            embeddings,
            persist_directory=output_dir
        )
        print(f"✅ 知识库构建成功，保存到: {output_dir}")

        # 4. 测试检索
        print("\n测试检索...")
        query = "文档的主要内容是什么？"
        results = vectorstore.similarity_search(query, k=3)

        print(f"查询: {query}")
        print(f"找到 {len(results)} 个相关文档:")
        for i, doc in enumerate(results, 1):
            print(f"\n结果 {i}:")
            print(f"  来源: {doc.metadata['source']}")
            print(f"  页码: {doc.metadata['page']}")
            print(f"  内容: {doc.page_content[:150]}...")

        return vectorstore

    except Exception as e:
        print(f"❌ 向量化失败: {e}")
        return None

# 测试构建知识库
# pdf_files = ["doc1.pdf", "doc2.pdf", "doc3.pdf"]
# vectorstore = build_pdf_knowledge_base(pdf_files)

# ===== 7. 实用工具函数 =====
print("\n=== 7. 实用工具函数 ===")

def get_pdf_info(file_path: str):
    """获取PDF文件的基本信息"""
    reader = PdfReader(file_path)

    info = {
        "file_name": os.path.basename(file_path),
        "file_size": os.path.getsize(file_path),
        "page_count": len(reader.pages),
        "metadata": {}
    }

    # 提取元数据
    if reader.metadata:
        info["metadata"] = {
            "title": reader.metadata.get("/Title", ""),
            "author": reader.metadata.get("/Author", ""),
            "subject": reader.metadata.get("/Subject", "")
        }

    print(f"PDF文件信息:")
    print(f"  文件名: {info['file_name']}")
    print(f"  文件大小: {info['file_size'] / 1024:.2f} KB")
    print(f"  页数: {info['page_count']}")
    if info["metadata"].get("title"):
        print(f"  标题: {info['metadata']['title']}")
    if info["metadata"].get("author"):
        print(f"  作者: {info['metadata']['author']}")

    return info

# 测试获取PDF信息
# pdf_info = get_pdf_info("sample.pdf")

print("\n=== 示例代码执行完成 ===")
print("\n使用说明:")
print("1. 准备PDF文件（如 sample.pdf）")
print("2. 取消注释相应的测试代码")
print("3. 运行脚本查看效果")
print("\n推荐:")
print("- 简单PDF → 使用pypdf（快速）")
print("- 复杂PDF/表格 → 使用pdfplumber（高质量）")
print("- RAG集成 → 使用LangChain PyPDFLoader（统一接口）")
```

---

## 运行输出示例

```
=== 1. 使用pypdf加载PDF ===
PDF总页数: 10

第 1 页内容预览:
RAG技术指南
第一章 概述
RAG（Retrieval-Augmented Generation）是一种结合检索和生成的AI技术...

第 2 页内容预览:
1.1 RAG的核心概念
RAG系统包含三个主要组件：
1. 文档加载器...

pypdf加载完成，共 10 页

=== 2. 使用pdfplumber加载PDF ===
PDF总页数: 10

第 1 页内容预览:
RAG技术指南
第一章 概述...
  包含 0 个表格

pdfplumber加载完成，共 10 页

=== 5. 性能对比结果 ===
解析器          耗时(秒)      页数     总字符数      速度(页/秒)
----------------------------------------------------------------------
pypdf           0.15         10       15000        66.67
pdfplumber      0.45         10       15200        22.22
```

---

## 关键要点

### 1. 解析器选择

| 场景 | 推荐解析器 | 原因 |
|------|-----------|------|
| 简单文本PDF | pypdf | 速度快，足够用 |
| 包含表格 | pdfplumber | 表格提取能力强 |
| RAG集成 | LangChain PyPDFLoader | 统一接口 |
| 批量处理 | pypdf | 性能最优 |

### 2. 元数据的重要性

```python
# 完整的元数据有助于RAG检索
metadata = {
    "source": "report.pdf",
    "page": 5,
    "title": "技术报告",
    "author": "张三",
    "created_date": "2025-01-15"
}

# 检索时可以按元数据过滤
results = vectorstore.similarity_search(
    query,
    filter={"author": "张三"}
)
```

### 3. 性能优化建议

- **小文件（<10页）**：直接使用pypdf
- **大文件（>100页）**：考虑流式加载或分批处理
- **批量处理**：使用多进程并行加载

---

## 常见问题

### Q1: PDF提取的文本有乱码怎么办？

```python
# 尝试不同的解析器
docs_pypdf = load_pdf_with_pypdf("file.pdf")
docs_pdfplumber = load_pdf_with_pdfplumber("file.pdf")

# 对比提取质量
if len(docs_pdfplumber[0].page_content) > len(docs_pypdf[0].page_content):
    print("pdfplumber提取质量更好")
```

### Q2: 如何处理扫描版PDF？

扫描版PDF需要OCR，pypdf和pdfplumber都无法直接处理。需要使用：
- Tesseract OCR
- AWS Textract
- Google Document AI

### Q3: 如何提取PDF中的图片？

```python
from pypdf import PdfReader

reader = PdfReader("file.pdf")
page = reader.pages[0]

# pypdf不直接支持图片提取
# 需要使用PyMuPDF (fitz)
```

---

## 扩展阅读

- [pypdf Documentation](https://pypdf.readthedocs.io/) (2025)
- [pdfplumber Documentation](https://github.com/jsvine/pdfplumber) (2025)
- [LangChain PDF Loaders](https://python.langchain.com/docs/modules/data_connection/document_loaders/pdf) (2025)

---

**版本：** v1.0
**最后更新：** 2026-02-15
**下一步：** 阅读 [07_实战代码_02_Office文档批量处理.md](./07_实战代码_02_Office文档批量处理.md)
