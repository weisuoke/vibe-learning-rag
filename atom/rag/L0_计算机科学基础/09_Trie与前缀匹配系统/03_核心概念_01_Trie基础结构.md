# Trie 基础结构

## 核心概念

**Trie 节点 = children（子节点映射）+ is_end（结束标志）+ value（可选值）**

Trie 的基础结构非常简单，但设计精妙。理解节点结构是掌握 Trie 的关键。

---

## 1. Trie 节点设计

### 1.1 节点的三个核心属性

```python
class TrieNode:
    def __init__(self):
        self.children = {}      # 子节点映射：字符 -> 子节点
        self.is_end = False     # 是否是单词结尾
        self.value = None       # 可选：存储关联值
```

**属性说明：**

1. **children（字典）**
   - 键：字符（如 'a', 'b', 'c'）
   - 值：子节点（TrieNode 对象）
   - 作用：建立字符到子节点的映射

2. **is_end（布尔值）**
   - True：表示从根到当前节点的路径构成一个完整单词
   - False：表示只是某个单词的前缀
   - 作用：区分完整单词和前缀

3. **value（可选）**
   - 存储与单词关联的值（如频率、权重、元数据）
   - 在某些应用中很有用（如自动补全的排序）

---

### 1.2 为什么用字典存储 children？

**方案对比：**

| 方案 | 空间复杂度 | 查询复杂度 | 适用场景 |
|------|-----------|-----------|---------|
| 字典 `{char: node}` | O(实际子节点数) | O(1) | 字符集大、稀疏 |
| 数组 `[node] * 26` | O(字符集大小) | O(1) | 字符集小、密集 |
| 链表 `[(char, node)]` | O(实际子节点数) | O(n) | 很少使用 |

**Python 中推荐使用字典：**
- 字符集可能很大（Unicode 字符）
- 大多数节点的子节点数量远小于字符集大小
- 字典的 O(1) 查询性能足够好

**在 AI Agent 中的应用：**
- 存储中文关键词时，字符集非常大（数万个汉字）
- 使用字典可以节省大量空间

---

### 1.3 可视化 Trie 结构

**示例：存储 ["cat", "car", "dog"]**

```
        root
       /    \
      c      d
      |      |
      a      o
     / \     |
    t   r    g
   (E) (E)  (E)
```

**节点详情：**

```python
root = TrieNode()
root.children = {'c': node_c, 'd': node_d}
root.is_end = False

node_c = TrieNode()
node_c.children = {'a': node_ca}
node_c.is_end = False

node_ca = TrieNode()
node_ca.children = {'t': node_cat, 'r': node_car}
node_ca.is_end = False

node_cat = TrieNode()
node_cat.children = {}
node_cat.is_end = True  # "cat" 结束

node_car = TrieNode()
node_car.children = {}
node_car.is_end = True  # "car" 结束
```

**关键观察：**
- "ca" 是 "cat" 和 "car" 的共享前缀
- 共享前缀只存储一次（节点 c 和 ca）
- 通过 `is_end` 标记区分完整单词和前缀

---

## 2. 插入操作

### 2.1 插入算法

**核心思想：逐字符遍历，不存在则创建**

```python
def insert(self, word: str, value=None):
    """
    插入单词到 Trie
    时间复杂度：O(m)，m 是单词长度
    """
    node = self.root

    # 逐字符遍历
    for char in word:
        # 如果字符不存在，创建新节点
        if char not in node.children:
            node.children[char] = TrieNode()
        # 移动到子节点
        node = node.children[char]

    # 标记单词结束
    node.is_end = True
    node.value = value
```

**步骤详解：**

1. **从根节点开始**
   ```python
   node = self.root
   ```

2. **逐字符处理**
   - 检查当前字符是否在 children 中
   - 不存在：创建新节点
   - 存在：直接使用

3. **移动到下一个节点**
   ```python
   node = node.children[char]
   ```

4. **标记结束**
   ```python
   node.is_end = True
   ```

---

### 2.2 插入示例

**插入 "cat"：**

```
初始状态：
root (empty)

插入 'c'：
root
 |
 c

插入 'a'：
root
 |
 c
 |
 a

插入 't'：
root
 |
 c
 |
 a
 |
 t (is_end=True)
```

**再插入 "car"：**

```
root
 |
 c
 |
 a
/ \
t   r
(E) (E)
```

**关键点：**
- "ca" 前缀被复用
- 只创建了新节点 'r'
- 空间效率高

---

### 2.3 在 RAG 中的应用

**场景：构建关键词索引**

```python
# 构建文档关键词 Trie
trie = Trie()

# 插入关键词及其文档 ID
trie.insert("机器学习", value={"doc_ids": [1, 3, 5]})
trie.insert("机器人", value={"doc_ids": [2, 4]})
trie.insert("深度学习", value={"doc_ids": [1, 6]})

# 用户查询："机器"
# Trie 可以快速找到所有以"机器"开头的关键词
# 返回：["机器学习", "机器人"]
# 对应文档：[1, 2, 3, 4, 5]
```

**优势：**
- O(m) 插入，m 是关键词长度
- 支持前缀查询（用户输入部分关键词）
- 自动去重（相同关键词只存储一次）

---

## 3. 查找操作

### 3.1 精确查找

**核心思想：逐字符遍历，检查 is_end**

```python
def search(self, word: str) -> bool:
    """
    查找单词是否存在
    时间复杂度：O(m)，m 是单词长度
    """
    node = self.root

    # 逐字符遍历
    for char in word:
        # 字符不存在，返回 False
        if char not in node.children:
            return False
        # 移动到子节点
        node = node.children[char]

    # 检查是否是完整单词
    return node.is_end
```

**关键点：**
- 必须检查 `is_end`
- 否则会把前缀当作完整单词

**示例：**

```python
trie = Trie()
trie.insert("cat")
trie.insert("car")

print(trie.search("cat"))  # True
print(trie.search("ca"))   # False（只是前缀）
print(trie.search("dog"))  # False（不存在）
```

---

### 3.2 前缀查找

**核心思想：找到前缀节点，不检查 is_end**

```python
def starts_with(self, prefix: str) -> bool:
    """
    查找是否存在以 prefix 开头的单词
    时间复杂度：O(m)，m 是前缀长度
    """
    node = self.root

    # 逐字符遍历
    for char in prefix:
        if char not in node.children:
            return False
        node = node.children[char]

    # 只要能到达前缀末尾，就返回 True
    return True
```

**与精确查找的区别：**
- 精确查找：必须检查 `is_end`
- 前缀查找：不检查 `is_end`

**示例：**

```python
trie = Trie()
trie.insert("cat")
trie.insert("car")

print(trie.starts_with("ca"))   # True
print(trie.starts_with("cat"))  # True
print(trie.starts_with("do"))   # False
```

---

### 3.3 获取前缀对应的所有单词

**核心思想：DFS 遍历子树**

```python
def get_words_with_prefix(self, prefix: str) -> list:
    """
    获取所有以 prefix 开头的单词
    时间复杂度：O(m + k)，m 是前缀长度，k 是结果数量
    """
    node = self.root

    # 1. 找到前缀节点
    for char in prefix:
        if char not in node.children:
            return []
        node = node.children[char]

    # 2. DFS 收集所有单词
    results = []
    self._dfs(node, prefix, results)
    return results

def _dfs(self, node, path, results):
    """DFS 遍历子树"""
    # 如果是单词结尾，加入结果
    if node.is_end:
        results.append(path)

    # 递归遍历所有子节点
    for char, child in node.children.items():
        self._dfs(child, path + char, results)
```

**示例：**

```python
trie = Trie()
trie.insert("cat")
trie.insert("car")
trie.insert("card")
trie.insert("dog")

print(trie.get_words_with_prefix("ca"))
# 输出：["cat", "car", "card"]
```

**在 AI Agent 中的应用：**

```python
# 用户输入："查询天"
# Agent 路由系统使用 Trie 匹配意图

intent_trie = Trie()
intent_trie.insert("查询天气", value="weather_agent")
intent_trie.insert("查询天气预报", value="weather_agent")
intent_trie.insert("查询时间", value="time_agent")

# 前缀匹配
matches = intent_trie.get_words_with_prefix("查询天")
# 返回：["查询天气", "查询天气预报"]
# 路由到：weather_agent
```

---

## 4. 删除操作

### 4.1 删除的复杂性

**为什么删除比插入复杂？**

1. **共享前缀问题**
   - 删除 "cat" 时，不能删除 "ca" 节点（"car" 还在用）
   - 需要检查节点是否被其他单词使用

2. **递归回溯**
   - 从叶子节点向上删除
   - 只删除不再需要的节点

---

### 4.2 删除算法

```python
def delete(self, word: str) -> bool:
    """
    删除单词
    时间复杂度：O(m)，m 是单词长度
    """
    def _delete(node, word, index):
        # 递归终止条件
        if index == len(word):
            # 检查是否是完整单词
            if not node.is_end:
                return False  # 单词不存在

            # 取消结束标记
            node.is_end = False

            # 如果没有子节点，可以删除
            return len(node.children) == 0

        char = word[index]
        if char not in node.children:
            return False  # 单词不存在

        child = node.children[char]
        should_delete = _delete(child, word, index + 1)

        # 如果子节点应该被删除
        if should_delete:
            del node.children[char]
            # 当前节点也可以删除的条件：
            # 1. 不是其他单词的结尾
            # 2. 没有其他子节点
            return not node.is_end and len(node.children) == 0

        return False

    return _delete(self.root, word, 0)
```

**算法步骤：**

1. **递归到单词末尾**
2. **取消 is_end 标记**
3. **回溯时检查是否可以删除节点**
   - 条件 1：节点不是其他单词的结尾
   - 条件 2：节点没有其他子节点
4. **删除不再需要的节点**

---

### 4.3 删除示例

**初始状态：["cat", "car", "card"]**

```
root
 |
 c
 |
 a
 |
 r (is_end=True, "car")
/ \
t   d (is_end=True, "card")
(E)
```

**删除 "card"：**

```
步骤 1：取消 'd' 的 is_end 标记
步骤 2：检查 'd' 是否可以删除
        - 不是其他单词结尾 ✓
        - 没有子节点 ✓
        - 删除 'd'
步骤 3：检查 'r' 是否可以删除
        - 是 "car" 的结尾 ✗
        - 保留 'r'

结果：
root
 |
 c
 |
 a
 |
 r (is_end=True, "car")
 |
 t (is_end=True, "cat")
```

**删除 "car"：**

```
步骤 1：取消 'r' 的 is_end 标记
步骤 2：检查 'r' 是否可以删除
        - 不是其他单词结尾 ✓
        - 有子节点 't' ✗
        - 保留 'r'

结果：
root
 |
 c
 |
 a
 |
 r (is_end=False)
 |
 t (is_end=True, "cat")
```

---

## 5. 时间复杂度分析

### 5.1 操作复杂度

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 插入 | O(m) | O(m) | m 是单词长度 |
| 查找 | O(m) | O(1) | 精确查找 |
| 前缀查找 | O(m) | O(1) | 只找前缀 |
| 前缀补全 | O(m + k) | O(k) | k 是结果数量 |
| 删除 | O(m) | O(m) | 递归栈空间 |

**关键特性：**
- **与数据量无关**：无论 Trie 中有多少单词，查询时间只与单词长度有关
- **前缀查询高效**：O(m + k)，远优于遍历所有单词的 O(n × m)

---

### 5.2 与其他数据结构对比

**场景：在 n 个单词中查找长度为 m 的单词**

| 数据结构 | 精确查找 | 前缀查找 | 空间复杂度 |
|---------|---------|---------|-----------|
| 数组 | O(n × m) | O(n × m) | O(n × m) |
| Hash Table | O(m) | O(n × m) | O(n × m) |
| Trie | O(m) | O(m + k) | O(ALPHABET_SIZE × n × m) |
| 压缩 Trie | O(m) | O(m + k) | O(n × m) |

**选择建议：**
- 只需精确查找 → Hash Table
- 需要前缀查询 → Trie
- 空间受限 → 压缩 Trie / Radix Tree

---

### 5.3 最坏情况分析

**空间最坏情况：**

```python
# 没有共享前缀的单词
words = ["a", "b", "c", "d", "e"]

# 每个单词都需要独立的路径
# 空间复杂度：O(n × m)
```

**时间最坏情况：**

```python
# 查找不存在的长单词
trie.search("abcdefghijklmnopqrstuvwxyz")

# 需要遍历整个单词
# 时间复杂度：O(m)
```

**优化策略：**
- 使用压缩 Trie 减少空间
- 使用 Bloom Filter 快速判断不存在

---

## 6. 完整实现

```python
class TrieNode:
    """Trie 节点"""
    def __init__(self):
        self.children = {}      # 子节点映射
        self.is_end = False     # 是否是单词结尾
        self.value = None       # 关联值

class Trie:
    """Trie 数据结构"""

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str, value=None):
        """插入单词"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
        node.value = value

    def search(self, word: str) -> bool:
        """精确查找"""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

    def starts_with(self, prefix: str) -> bool:
        """前缀查找"""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

    def get_words_with_prefix(self, prefix: str) -> list:
        """获取所有以 prefix 开头的单词"""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]

        results = []
        self._dfs(node, prefix, results)
        return results

    def _dfs(self, node, path, results):
        """DFS 遍历"""
        if node.is_end:
            results.append(path)
        for char, child in node.children.items():
            self._dfs(child, path + char, results)

    def delete(self, word: str) -> bool:
        """删除单词"""
        def _delete(node, word, index):
            if index == len(word):
                if not node.is_end:
                    return False
                node.is_end = False
                return len(node.children) == 0

            char = word[index]
            if char not in node.children:
                return False

            child = node.children[char]
            should_delete = _delete(child, word, index + 1)

            if should_delete:
                del node.children[char]
                return not node.is_end and len(node.children) == 0

            return False

        return _delete(self.root, word, 0)


# ===== 测试代码 =====
if __name__ == "__main__":
    trie = Trie()

    # 插入
    print("=== 插入测试 ===")
    trie.insert("cat")
    trie.insert("car")
    trie.insert("card")
    trie.insert("dog")
    print("插入完成：cat, car, card, dog")

    # 精确查找
    print("\n=== 精确查找测试 ===")
    print(f"search('cat'): {trie.search('cat')}")    # True
    print(f"search('ca'): {trie.search('ca')}")      # False
    print(f"search('dog'): {trie.search('dog')}")    # True

    # 前缀查找
    print("\n=== 前缀查找测试 ===")
    print(f"starts_with('ca'): {trie.starts_with('ca')}")    # True
    print(f"starts_with('do'): {trie.starts_with('do')}")    # True
    print(f"starts_with('x'): {trie.starts_with('x')}")      # False

    # 前缀补全
    print("\n=== 前缀补全测试 ===")
    print(f"get_words_with_prefix('ca'): {trie.get_words_with_prefix('ca')}")
    # 输出：['cat', 'car', 'card']

    # 删除
    print("\n=== 删除测试 ===")
    trie.delete("card")
    print(f"删除 'card' 后，search('card'): {trie.search('card')}")  # False
    print(f"删除 'card' 后，search('car'): {trie.search('car')}")    # True
```

**预期输出：**

```
=== 插入测试 ===
插入完成：cat, car, card, dog

=== 精确查找测试 ===
search('cat'): True
search('ca'): False
search('dog'): True

=== 前缀查找测试 ===
starts_with('ca'): True
starts_with('do'): True
starts_with('x'): False

=== 前缀补全测试 ===
get_words_with_prefix('ca'): ['cat', 'car', 'card']

=== 删除测试 ===
删除 'card' 后，search('card'): False
删除 'card' 后，search('car'): True
```

---

## 7. 在 RAG 中的应用

### 7.1 关键词索引

```python
# 构建文档关键词 Trie
keyword_trie = Trie()

# 插入关键词及其文档 ID
keyword_trie.insert("机器学习", value=[1, 3, 5])
keyword_trie.insert("机器人", value=[2, 4])
keyword_trie.insert("深度学习", value=[1, 6])

# 用户查询："机器"
matches = keyword_trie.get_words_with_prefix("机器")
# 返回：["机器学习", "机器人"]

# 合并文档 ID
doc_ids = set()
for keyword in matches:
    node = keyword_trie._get_node(keyword)
    doc_ids.update(node.value)
# 返回：{1, 2, 3, 4, 5}
```

### 7.2 实体识别

```python
# 构建实体词典 Trie
entity_trie = Trie()
entity_trie.insert("北京大学", value="ORG")
entity_trie.insert("北京", value="LOC")
entity_trie.insert("清华大学", value="ORG")

# 文本："我在北京大学读书"
# 最长匹配
text = "我在北京大学读书"
i = 0
entities = []

while i < len(text):
    # 尝试最长匹配
    max_len = 0
    max_entity = None

    for j in range(i + 1, len(text) + 1):
        substring = text[i:j]
        if entity_trie.search(substring):
            max_len = j - i
            max_entity = substring

    if max_entity:
        entities.append((max_entity, entity_trie._get_node(max_entity).value))
        i += max_len
    else:
        i += 1

print(entities)
# 输出：[("北京大学", "ORG")]
```

---

**版本**: v1.0
**最后更新**: 2026-02-14
**下一步**: 学习前缀查询与自动补全（`02_前缀查询与自动补全.md`）
