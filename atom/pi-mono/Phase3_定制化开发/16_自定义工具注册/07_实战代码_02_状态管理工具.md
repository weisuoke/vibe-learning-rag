# 实战代码 02：状态管理工具

> **基于 pi-mono todo.ts 示例 + 2025-2026 会话持久化最佳实践**

---

## 场景描述

实现一个 Todo 管理工具，展示如何在 AI Agent 中进行状态管理和会话持久化。核心特性：

- **会话持久化**：状态存储在 tool result details 中，支持分支和历史回溯
- **CRUD 操作**：添加、列表、切换、清空 todo
- **状态重建**：从会话历史自动重建状态
- **自定义命令**：提供 `/todos` 命令查看当前状态

**2025-2026 行业趋势：**
- **数据库持久化**：Letta 框架支持 PostgreSQL/SQLite 持久化（来源：[Letta Framework](https://brightdata.com/blog/ai/best-ai-agent-frameworks)）
- **Redis 状态管理**：大规模 AI Agent 使用 Redis 处理并发会话（来源：[AI Agent Frameworks 2026](https://theaijournal.co/2026/02/best-ai-agent-frameworks-2026/)）
- **SQLite 检查点**：Mastra 框架使用 SQLite 保存状态检查点（来源：[Persistence Guide](https://thenewstack.io/how-to-add-persistence-and-long-term-memory-to-ai-agents/)）
- **混合存储策略**：向量数据库 + 关系数据库混合存储（来源：[Persistent Memory Strategies](https://sparkco.ai/blog/persistent-memory-strategies-for-advanced-ai-agents)）

---

## 完整代码实现

```typescript
/**
 * Todo 状态管理工具 - 基于 pi-mono todo.ts
 *
 * 核心特性：
 * 1. 状态存储在 tool result details（非外部文件）
 * 2. 支持会话分支和历史回溯
 * 3. 自动从会话历史重建状态
 * 4. 提供 LLM 工具和用户命令
 *
 * 2025-2026 最佳实践：
 * - 会话级状态管理（非全局状态）
 * - 事件驱动状态重建
 * - 支持并发会话
 * - 类型安全的状态结构
 *
 * 参考：
 * - pi-mono: packages/coding-agent/examples/extensions/todo.ts
 * - Letta 持久化：https://brightdata.com/blog/ai/best-ai-agent-frameworks
 * - Redis 状态管理：https://theaijournal.co/2026/02/best-ai-agent-frameworks-2026/
 */

import { StringEnum } from "@mariozechner/pi-ai";
import type { ExtensionAPI, ExtensionContext, Theme } from "@mariozechner/pi-coding-agent";
import { matchesKey, Text, truncateToWidth } from "@mariozechner/pi-tui";
import { Type } from "@sinclair/typebox";

// ============================================================================
// 类型定义
// ============================================================================

interface Todo {
  id: number;
  text: string;
  done: boolean;
}

interface TodoDetails {
  action: "list" | "add" | "toggle" | "clear";
  todos: Todo[];
  nextId: number;
  error?: string;
}

// ============================================================================
// Schema 定义
// ============================================================================

const TodoParams = Type.Object({
  action: StringEnum(["list", "add", "toggle", "clear"] as const),
  text: Type.Optional(Type.String({ description: "Todo text (for add)" })),
  id: Type.Optional(Type.Number({ description: "Todo ID (for toggle)" })),
});

// ============================================================================
// UI 组件 - /todos 命令
// ============================================================================

class TodoListComponent {
  private todos: Todo[];
  private theme: Theme;
  private onClose: () => void;
  private cachedWidth?: number;
  private cachedLines?: string[];

  constructor(todos: Todo[], theme: Theme, onClose: () => void) {
    this.todos = todos;
    this.theme = theme;
    this.onClose = onClose;
  }

  handleInput(data: string): void {
    if (matchesKey(data, "escape") || matchesKey(data, "ctrl+c")) {
      this.onClose();
    }
  }

  render(width: number): string[] {
    if (this.cachedLines && this.cachedWidth === width) {
      return this.cachedLines;
    }

    const lines: string[] = [];
    const th = this.theme;

    lines.push("");
    const title = th.fg("accent", " Todos ");
    const headerLine =
      th.fg("borderMuted", "─".repeat(3)) + title +
      th.fg("borderMuted", "─".repeat(Math.max(0, width - 10)));
    lines.push(truncateToWidth(headerLine, width));
    lines.push("");

    if (this.todos.length === 0) {
      lines.push(truncateToWidth(`  ${th.fg("dim", "No todos yet. Ask the agent to add some!")}`, width));
    } else {
      const done = this.todos.filter((t) => t.done).length;
      const total = this.todos.length;
      lines.push(truncateToWidth(`  ${th.fg("muted", `${done}/${total} completed`)}`, width));
      lines.push("");

      for (const todo of this.todos) {
        const check = todo.done ? th.fg("success", "✓") : th.fg("dim", "○");
        const id = th.fg("accent", `#${todo.id}`);
        const text = todo.done ? th.fg("dim", todo.text) : th.fg("text", todo.text);
        lines.push(truncateToWidth(`  ${check} ${id} ${text}`, width));
      }
    }

    lines.push("");
    lines.push(truncateToWidth(`  ${th.fg("dim", "Press Escape to close")}`, width));
    lines.push("");

    this.cachedWidth = width;
    this.cachedLines = lines;
    return lines;
  }

  invalidate(): void {
    this.cachedWidth = undefined;
    this.cachedLines = undefined;
  }
}

// ============================================================================
// 工具注册
// ============================================================================

export default function (pi: ExtensionAPI) {
  // 内存状态（从会话重建）
  let todos: Todo[] = [];
  let nextId = 1;

  /**
   * 状态重建 - 从会话历史恢复状态
   *
   * 2025-2026 最佳实践：
   * - 扫描会话分支的所有 tool result
   * - 按时间顺序应用状态变更
   * - 支持分支和回溯
   *
   * 为什么不用外部文件？
   * - 外部文件不支持分支（会话分支时状态错误）
   * - tool result details 自动跟随会话历史
   * - 更符合 pi-mono 的设计哲学
   */
  const reconstructState = (ctx: ExtensionContext) => {
    todos = [];
    nextId = 1;

    // 遍历当前分支的所有消息
    for (const entry of ctx.sessionManager.getBranch()) {
      if (entry.type !== "message") continue;
      const msg = entry.message;
      if (msg.role !== "toolResult" || msg.toolName !== "todo") continue;

      const details = msg.details as TodoDetails | undefined;
      if (details) {
        todos = details.todos;
        nextId = details.nextId;
      }
    }
  };

  // 监听会话事件，自动重建状态
  pi.on("session_start", async (_event, ctx) => reconstructState(ctx));
  pi.on("session_switch", async (_event, ctx) => reconstructState(ctx));
  pi.on("session_fork", async (_event, ctx) => reconstructState(ctx));
  pi.on("session_tree", async (_event, ctx) => reconstructState(ctx));

  // ========================================================================
  // 注册 todo 工具（供 LLM 调用）
  // ========================================================================
  pi.registerTool({
    name: "todo",
    label: "Todo",
    description: "Manage a todo list. Actions: list, add (text), toggle (id), clear",
    parameters: TodoParams,

    async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
      switch (params.action) {
        case "list":
          return {
            content: [{
              type: "text",
              text: todos.length
                ? todos.map((t) => `[${t.done ? "x" : " "}] #${t.id}: ${t.text}`).join("\n")
                : "No todos",
            }],
            details: { action: "list", todos: [...todos], nextId } as TodoDetails,
          };

        case "add": {
          if (!params.text) {
            return {
              content: [{ type: "text", text: "Error: text required for add" }],
              details: { action: "add", todos: [...todos], nextId, error: "text required" } as TodoDetails,
            };
          }
          const newTodo: Todo = { id: nextId++, text: params.text, done: false };
          todos.push(newTodo);
          return {
            content: [{ type: "text", text: `Added todo #${newTodo.id}: ${newTodo.text}` }],
            details: { action: "add", todos: [...todos], nextId } as TodoDetails,
          };
        }

        case "toggle": {
          if (params.id === undefined) {
            return {
              content: [{ type: "text", text: "Error: id required for toggle" }],
              details: { action: "toggle", todos: [...todos], nextId, error: "id required" } as TodoDetails,
            };
          }
          const todo = todos.find((t) => t.id === params.id);
          if (!todo) {
            return {
              content: [{ type: "text", text: `Todo #${params.id} not found` }],
              details: {
                action: "toggle",
                todos: [...todos],
                nextId,
                error: `#${params.id} not found`,
              } as TodoDetails,
            };
          }
          todo.done = !todo.done;
          return {
            content: [{ type: "text", text: `Todo #${todo.id} ${todo.done ? "completed" : "uncompleted"}` }],
            details: { action: "toggle", todos: [...todos], nextId } as TodoDetails,
          };
        }

        case "clear": {
          const count = todos.length;
          todos = [];
          nextId = 1;
          return {
            content: [{ type: "text", text: `Cleared ${count} todos` }],
            details: { action: "clear", todos: [], nextId: 1 } as TodoDetails,
          };
        }

        default:
          return {
            content: [{ type: "text", text: `Unknown action: ${params.action}` }],
            details: {
              action: "list",
              todos: [...todos],
              nextId,
              error: `unknown action: ${params.action}`,
            } as TodoDetails,
          };
      }
    },

    renderCall(args, theme) {
      let text = theme.fg("toolTitle", theme.bold("todo ")) + theme.fg("muted", args.action);
      if (args.text) text += ` ${theme.fg("dim", `"${args.text}"`)}`;
      if (args.id !== undefined) text += ` ${theme.fg("accent", `#${args.id}`)}`;
      return new Text(text, 0, 0);
    },

    renderResult(result, { expanded }, theme) {
      const details = result.details as TodoDetails | undefined;
      if (!details) {
        const text = result.content[0];
        return new Text(text?.type === "text" ? text.text : "", 0, 0);
      }

      if (details.error) {
        return new Text(theme.fg("error", `Error: ${details.error}`), 0, 0);
      }

      const todoList = details.todos;

      switch (details.action) {
        case "list": {
          if (todoList.length === 0) {
            return new Text(theme.fg("dim", "No todos"), 0, 0);
          }
          let listText = theme.fg("muted", `${todoList.length} todo(s):`);
          const display = expanded ? todoList : todoList.slice(0, 5);
          for (const t of display) {
            const check = t.done ? theme.fg("success", "✓") : theme.fg("dim", "○");
            const itemText = t.done ? theme.fg("dim", t.text) : theme.fg("muted", t.text);
            listText += `\n${check} ${theme.fg("accent", `#${t.id}`)} ${itemText}`;
          }
          if (!expanded && todoList.length > 5) {
            listText += `\n${theme.fg("dim", `... ${todoList.length - 5} more`)}`;
          }
          return new Text(listText, 0, 0);
        }

        case "add": {
          const added = todoList[todoList.length - 1];
          return new Text(
            theme.fg("success", "✓ Added ") +
            theme.fg("accent", `#${added.id}`) +
            " " +
            theme.fg("muted", added.text),
            0,
            0,
          );
        }

        case "toggle": {
          const text = result.content[0];
          const msg = text?.type === "text" ? text.text : "";
          return new Text(theme.fg("success", "✓ ") + theme.fg("muted", msg), 0, 0);
        }

        case "clear":
          return new Text(theme.fg("success", "✓ ") + theme.fg("muted", "Cleared all todos"), 0, 0);
      }
    },
  });

  // ========================================================================
  // 注册 /todos 命令（供用户调用）
  // ========================================================================
  pi.registerCommand("todos", {
    description: "Show all todos on the current branch",
    handler: async (_args, ctx) => {
      if (!ctx.hasUI) {
        ctx.ui.notify("/todos requires interactive mode", "error");
        return;
      }

      await ctx.ui.custom<void>((_tui, theme, _kb, done) => {
        return new TodoListComponent(todos, theme, () => done());
      });
    },
  });
}
```

---

## 预期输出

### 场景 1：添加 Todo

**LLM 调用：**
```json
{ "tool": "todo", "params": { "action": "add", "text": "Implement user authentication" } }
```

**返回结果：**
```json
{
  "content": [{ "type": "text", "text": "Added todo #1: Implement user authentication" }],
  "details": {
    "action": "add",
    "todos": [{ "id": 1, "text": "Implement user authentication", "done": false }],
    "nextId": 2
  }
}
```

### 场景 2：列出 Todo

**LLM 调用：**
```json
{ "tool": "todo", "params": { "action": "list" } }
```

**返回结果：**
```
[ ] #1: Implement user authentication
[ ] #2: Write unit tests
[x] #3: Update documentation
```

### 场景 3：切换状态

**LLM 调用：**
```json
{ "tool": "todo", "params": { "action": "toggle", "id": 1 } }
```

**返回结果：**
```json
{
  "content": [{ "type": "text", "text": "Todo #1 completed" }],
  "details": {
    "action": "toggle",
    "todos": [{ "id": 1, "text": "Implement user authentication", "done": true }],
    "nextId": 2
  }
}
```

---

## 2025-2026 最佳实践

### 1. 会话级状态管理

**为什么不用全局状态？**
- 全局状态不支持会话分支
- 多用户并发时会冲突
- 无法回溯历史状态

**pi-mono 方案：**
```typescript
// 状态存储在 tool result details
return {
  content: [{ type: "text", text: "..." }],
  details: { todos: [...todos], nextId } // 状态快照
};
```

**2025-2026 行业方案：**
- **Letta**：PostgreSQL/SQLite 持久化（来源：[Letta Framework](https://brightdata.com/blog/ai/best-ai-agent-frameworks)）
- **Redis**：大规模并发会话管理（来源：[AI Agent Frameworks 2026](https://theaijournal.co/2026/02/best-ai-agent-frameworks-2026/)）
- **SQLite 检查点**：Mastra 框架方案（来源：[Persistence Guide](https://thenewstack.io/how-to-add-persistence-and-long-term-memory-to-ai-agents/)）

### 2. 事件驱动状态重建

**监听会话事件：**
```typescript
pi.on("session_start", async (_event, ctx) => reconstructState(ctx));
pi.on("session_switch", async (_event, ctx) => reconstructState(ctx));
pi.on("session_fork", async (_event, ctx) => reconstructState(ctx));
```

**重建逻辑：**
```typescript
const reconstructState = (ctx: ExtensionContext) => {
  todos = [];
  nextId = 1;

  // 扫描当前分支的所有 tool result
  for (const entry of ctx.sessionManager.getBranch()) {
    if (entry.type === "message" && entry.message.role === "toolResult") {
      const details = entry.message.details as TodoDetails;
      if (details) {
        todos = details.todos;
        nextId = details.nextId;
      }
    }
  }
};
```

### 3. 支持分支和回溯

**场景：**
1. 用户添加 3 个 todo
2. 用户回到历史某个点，创建新分支
3. 新分支的状态应该是回溯点的状态

**pi-mono 自动支持：**
- `ctx.sessionManager.getBranch()` 返回当前分支的消息
- 状态重建时只处理当前分支的 tool result
- 分支切换时自动触发 `session_switch` 事件

### 4. 类型安全

**TypeScript 类型定义：**
```typescript
interface Todo {
  id: number;
  text: string;
  done: boolean;
}

interface TodoDetails {
  action: "list" | "add" | "toggle" | "clear";
  todos: Todo[];
  nextId: number;
  error?: string;
}
```

**类型断言：**
```typescript
const details = msg.details as TodoDetails | undefined;
```

---

## 扩展应用场景

### 1. 项目配置管理

```typescript
interface ProjectConfig {
  framework: string;
  typescript: boolean;
  testing: string;
}

// 存储在 tool result details
return {
  content: [{ type: "text", text: "Config updated" }],
  details: { config: projectConfig }
};
```

### 2. 对话上下文管理

```typescript
interface ConversationContext {
  topic: string;
  entities: string[];
  sentiment: "positive" | "negative" | "neutral";
}

// 每次对话更新上下文
return {
  content: [{ type: "text", text: "..." }],
  details: { context: conversationContext }
};
```

### 3. 工作流状态机

```typescript
interface WorkflowState {
  currentStep: number;
  completedSteps: number[];
  data: Record<string, any>;
}

// 状态机转换
return {
  content: [{ type: "text", text: "Step completed" }],
  details: { workflow: workflowState }
};
```

---

## 参考资料

### Pi-mono 源码
- **todo.ts**：`sourcecode/pi-mono/packages/coding-agent/examples/extensions/todo.ts`
- **Session Manager**：`sourcecode/pi-mono/packages/coding-agent/src/core/session/`

### 2025-2026 行业标准
- **Letta 持久化**：https://brightdata.com/blog/ai/best-ai-agent-frameworks
- **Redis 状态管理**：https://theaijournal.co/2026/02/best-ai-agent-frameworks-2026/
- **SQLite 检查点**：https://thenewstack.io/how-to-add-persistence-and-long-term-memory-to-ai-agents/
- **混合存储策略**：https://sparkco.ai/blog/persistent-memory-strategies-for-advanced-ai-agents

### 相关文档
- **03_核心概念_03_Execute执行函数.md**：execute 函数详解
- **03_核心概念_06_工具包装与事件.md**：事件系统详解

---

**版本：** v1.0
**最后更新：** 2026-02-21
**作者：** Claude Code
**基于：** pi-mono todo.ts + 2025-2026 持久化标准
