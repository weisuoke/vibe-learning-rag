# 核心概念 03：滑动窗口模式

> 掌握固定窗口和可变窗口的通用模式

---

## 概述

滑动窗口是一种高效处理连续子序列问题的算法技巧，通过维护一个窗口并动态调整边界，将 O(n²) 的暴力解法优化为 O(n)。

**核心思想：** 增量更新窗口状态，避免重复计算。

**两种模式：**
1. **固定大小窗口**：窗口大小固定，向右滑动
2. **可变大小窗口**：窗口大小动态变化，根据条件调整

---

## 1. 固定大小滑动窗口

### 1.1 基本模式

```python
from collections import deque

def fixed_window_template(arr: list, k: int) -> list:
    """固定大小滑动窗口模板"""
    window = deque(maxlen=k)
    result = []

    for item in arr:
        # 添加新元素
        window.append(item)

        # 窗口形成后处理
        if len(window) == k:
            # 处理窗口（计算和、最大值等）
            result.append(process(window))

    return result
```

### 1.2 经典问题：滑动窗口求和

```python
from collections import deque

def sliding_window_sum(arr: list, k: int) -> list:
    """计算每个大小为 k 的窗口的和"""
    if not arr or k <= 0 or k > len(arr):
        return []

    # 方法1：使用 deque
    window = deque()
    window_sum = 0
    result = []

    for num in arr:
        window.append(num)
        window_sum += num

        if len(window) == k:
            result.append(window_sum)
            removed = window.popleft()
            window_sum -= removed

    return result

# 测试
arr = [1, 2, 3, 4, 5, 6]
k = 3
print(sliding_window_sum(arr, k))  # [6, 9, 12, 15]
```

### 1.3 优化：不使用 deque

```python
def sliding_window_sum_optimized(arr: list, k: int) -> list:
    """优化版本：不使用 deque，只维护窗口和"""
    if not arr or k <= 0 or k > len(arr):
        return []

    # 初始窗口
    window_sum = sum(arr[:k])
    result = [window_sum]

    # 滑动窗口
    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]
        result.append(window_sum)

    return result

# 测试
arr = [1, 2, 3, 4, 5, 6]
k = 3
print(sliding_window_sum_optimized(arr, k))  # [6, 9, 12, 15]
```

### 1.4 AI Agent 应用：Token 窗口

```python
from collections import deque

class TokenWindow:
    """固定大小 Token 窗口"""

    def __init__(self, max_tokens: int = 4096):
        self.max_tokens = max_tokens
        self.tokens = deque(maxlen=max_tokens)

    def add_tokens(self, new_tokens: list):
        """添加新 tokens"""
        for token in new_tokens:
            self.tokens.append(token)

    def get_tokens(self) -> list:
        """获取当前窗口内的 tokens"""
        return list(self.tokens)

    def get_token_count(self) -> int:
        """获取当前 token 数量"""
        return len(self.tokens)

# 使用示例
window = TokenWindow(max_tokens=100)
window.add_tokens([1, 2, 3, 4, 5])
print(f"Token 数量: {window.get_token_count()}")
```

---

## 2. 可变大小滑动窗口

### 2.1 基本模式

```python
def variable_window_template(arr: list) -> int:
    """可变大小滑动窗口模板"""
    left = 0
    result = 0

    for right in range(len(arr)):
        # 扩展窗口：添加 arr[right]

        # 收缩窗口：当不满足条件时
        while not condition:
            # 移除 arr[left]
            left += 1

        # 更新结果
        result = max(result, right - left + 1)

    return result
```

### 2.2 经典问题：最长无重复子串

```python
def longest_substring_without_repeating(s: str) -> int:
    """最长无重复字符子串"""
    seen = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        # 扩展窗口
        while s[right] in seen:
            # 收缩窗口
            seen.remove(s[left])
            left += 1

        seen.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length

# 测试
print(longest_substring_without_repeating("abcabcbb"))  # 3 ("abc")
print(longest_substring_without_repeating("bbbbb"))     # 1 ("b")
print(longest_substring_without_repeating("pwwkew"))    # 3 ("wke")
```

### 2.3 经典问题：最小覆盖子串

```python
from collections import Counter

def min_window(s: str, t: str) -> str:
    """最小覆盖子串"""
    if not s or not t:
        return ""

    need = Counter(t)
    window = {}
    left = 0
    valid = 0
    start, length = 0, float('inf')

    for right in range(len(s)):
        c = s[right]

        # 扩展窗口
        if c in need:
            window[c] = window.get(c, 0) + 1
            if window[c] == need[c]:
                valid += 1

        # 收缩窗口
        while valid == len(need):
            # 更新结果
            if right - left + 1 < length:
                start = left
                length = right - left + 1

            d = s[left]
            left += 1
            if d in need:
                if window[d] == need[d]:
                    valid -= 1
                window[d] -= 1

    return "" if length == float('inf') else s[start:start + length]

# 测试
print(min_window("ADOBECODEBANC", "ABC"))  # "BANC"
```

### 2.4 AI Agent 应用：语义分块

```python
class SemanticChunker:
    """基于语义的可变大小分块器"""

    def __init__(self, max_chunk_size: int = 1000, overlap: int = 200):
        self.max_chunk_size = max_chunk_size
        self.overlap = overlap

    def chunk_text(self, text: str) -> list:
        """将文本分块"""
        chunks = []
        left = 0

        while left < len(text):
            # 扩展窗口到最大大小
            right = min(left + self.max_chunk_size, len(text))

            # 如果不是最后一块，尝试在句子边界处分割
            if right < len(text):
                # 查找最近的句子边界
                for i in range(right, left, -1):
                    if text[i] in '.!?\n':
                        right = i + 1
                        break

            chunks.append(text[left:right])

            # 移动窗口，保留重叠
            left = right - self.overlap if right < len(text) else right

        return chunks

# 使用示例
chunker = SemanticChunker(max_chunk_size=100, overlap=20)
text = "This is a long document. It has multiple sentences. We need to chunk it properly."
chunks = chunker.chunk_text(text)
print(f"分块数量: {len(chunks)}")
```

---

## 3. 双指针技巧

### 3.1 同向双指针

```python
def two_pointers_same_direction(arr: list) -> int:
    """同向双指针模板"""
    left = 0

    for right in range(len(arr)):
        # 处理 arr[right]

        # 移动 left 指针
        while condition:
            # 处理 arr[left]
            left += 1

        # 更新结果

    return result
```

### 3.2 相向双指针

```python
def two_pointers_opposite_direction(arr: list) -> int:
    """相向双指针模板"""
    left = 0
    right = len(arr) - 1

    while left < right:
        # 处理 arr[left] 和 arr[right]

        if condition:
            left += 1
        else:
            right -= 1

    return result
```

### 3.3 经典问题：两数之和（有序数组）

```python
def two_sum_sorted(arr: list, target: int) -> list:
    """有序数组的两数之和"""
    left = 0
    right = len(arr) - 1

    while left < right:
        current_sum = arr[left] + arr[right]

        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1
        else:
            right -= 1

    return []

# 测试
arr = [2, 7, 11, 15]
target = 9
print(two_sum_sorted(arr, target))  # [0, 1]
```

---

## 4. 滑动窗口 vs 双指针

### 4.1 何时使用滑动窗口？

**特征：**
- 问题涉及连续子序列
- 需要维护窗口内的状态（和、最大值等）
- 窗口大小固定或根据条件动态变化

**示例：**
- 滑动窗口最大值
- 滑动窗口求和
- 最长无重复子串

### 4.2 何时使用双指针？

**特征：**
- 问题涉及两个位置的关系
- 不需要维护窗口内的所有元素
- 可以通过移动指针快速排除不可能的情况

**示例：**
- 两数之和（有序数组）
- 三数之和
- 容器盛水问题

### 4.3 决策树

```
需要处理连续子序列？
├─ 是
│  ├─ 固定大小 + 需要访问窗口内所有元素？
│  │  └─ 使用 Deque（固定窗口）
│  ├─ 固定大小 + 只需要窗口边界或聚合值？
│  │  └─ 使用双指针（优化版固定窗口）
│  └─ 可变大小？
│     └─ 使用双指针（可变窗口）
│
└─ 否
   └─ 需要两个位置的关系？
      └─ 使用双指针
```

---

## 5. 常见模式总结

### 5.1 固定窗口模式

```python
# 模式1：使用 deque
from collections import deque

window = deque(maxlen=k)
for item in arr:
    window.append(item)
    if len(window) == k:
        process(window)

# 模式2：使用双指针
window_sum = sum(arr[:k])
for i in range(k, len(arr)):
    window_sum += arr[i] - arr[i - k]
    process(window_sum)
```

### 5.2 可变窗口模式

```python
# 模式1：最长满足条件的窗口
left = 0
max_length = 0
for right in range(len(arr)):
    # 扩展窗口
    while not condition:
        # 收缩窗口
        left += 1
    max_length = max(max_length, right - left + 1)

# 模式2：最短满足条件的窗口
left = 0
min_length = float('inf')
for right in range(len(arr)):
    # 扩展窗口
    while condition:
        # 更新结果
        min_length = min(min_length, right - left + 1)
        # 收缩窗口
        left += 1
```

### 5.3 双指针模式

```python
# 模式1：同向双指针
left = 0
for right in range(len(arr)):
    while condition:
        left += 1

# 模式2：相向双指针
left = 0
right = len(arr) - 1
while left < right:
    if condition:
        left += 1
    else:
        right -= 1
```

---

## 6. AI Agent 应用场景

### 6.1 对话历史滑动窗口

```python
from collections import deque

class ConversationWindow:
    """对话历史滑动窗口"""

    def __init__(self, max_turns: int = 10):
        self.messages = deque(maxlen=max_turns * 2)

    def add_message(self, role: str, content: str):
        self.messages.append({"role": role, "content": content})

    def get_context(self) -> list:
        return list(self.messages)

# 使用示例
window = ConversationWindow(max_turns=3)
for i in range(5):
    window.add_message("user", f"问题 {i}")
    window.add_message("assistant", f"回答 {i}")

print(f"消息数: {len(window.get_context())}")  # 6
```

**2025-2026 实际应用：**

**LangGraph (2025-2026):**
```python
from collections import deque

class SlidingWindowMemory:
    def __init__(self, window_size: int = 5):
        self.messages = deque(maxlen=window_size)

    def add_message(self, message: dict):
        self.messages.append(message)

    def get_context(self) -> list:
        return list(self.messages)
```

**来源**: [LangGraph Message History with Sliding Windows](https://aiproduct.engineer/tutorials/langgraph-tutorial-message-history-management-with-sliding-windows-unit-12-exercise-3)

### 6.2 文档分块滑动窗口

```python
class DocumentChunker:
    """文档分块器 - 滑动窗口模式"""

    def __init__(self, chunk_size: int = 1000, overlap: int = 200):
        self.chunk_size = chunk_size
        self.overlap = overlap

    def chunk_document(self, text: str) -> list:
        """将文档分块，保持重叠"""
        chunks = []
        start = 0

        while start < len(text):
            end = min(start + self.chunk_size, len(text))
            chunks.append(text[start:end])
            start += self.chunk_size - self.overlap

        return chunks

# 使用示例
chunker = DocumentChunker(chunk_size=100, overlap=20)
text = "A" * 250
chunks = chunker.chunk_document(text)
print(f"分块数量: {len(chunks)}")
```

**2025-2026 实际应用：**

**LangChain (2025-2026):**
```python
from langchain.text_splitter import RecursiveCharacterTextSplitter

splitter = RecursiveCharacterTextSplitter(
    chunk_size=1000,
    chunk_overlap=200,
)

chunks = splitter.split_text(long_document)
```

### 6.3 实时指标监控

```python
from collections import deque
import time

class MetricsMonitor:
    """实时指标监控 - 滑动窗口统计"""

    def __init__(self, window_seconds: int = 60):
        self.window_seconds = window_seconds
        self.metrics = deque()

    def record_metric(self, value: float):
        """记录指标"""
        now = time.time()
        self.metrics.append((now, value))

        # 移除窗口外的指标
        while self.metrics and self.metrics[0][0] < now - self.window_seconds:
            self.metrics.popleft()

    def get_average(self) -> float:
        """获取平均值"""
        if not self.metrics:
            return 0
        return sum(v for _, v in self.metrics) / len(self.metrics)

    def get_max(self) -> float:
        """获取最大值"""
        if not self.metrics:
            return 0
        return max(v for _, v in self.metrics)

# 使用示例
monitor = MetricsMonitor(window_seconds=10)
for i in range(20):
    monitor.record_metric(i * 0.5)
    time.sleep(0.5)

print(f"平均值: {monitor.get_average():.2f}")
print(f"最大值: {monitor.get_max():.2f}")
```

---

## 7. 性能优化技巧

### 7.1 避免不必要的数据结构

```python
# ❌ 低效：使用 deque 但不需要访问窗口内元素
from collections import deque

window = deque()
for num in arr:
    window.append(num)
    if len(window) == k:
        result.append(sum(window))
        window.popleft()

# ✅ 高效：只维护窗口和
window_sum = sum(arr[:k])
result = [window_sum]
for i in range(k, len(arr)):
    window_sum += arr[i] - arr[i - k]
    result.append(window_sum)
```

### 7.2 使用 maxlen 自动管理

```python
# ❌ 低效：手动管理窗口大小
window = deque()
for item in arr:
    window.append(item)
    if len(window) > k:
        window.popleft()

# ✅ 高效：使用 maxlen
window = deque(maxlen=k)
for item in arr:
    window.append(item)
```

### 7.3 提前终止

```python
# 优化：找到满足条件的最短窗口后提前终止
def shortest_window(arr, target):
    left = 0
    min_length = float('inf')
    current_sum = 0

    for right in range(len(arr)):
        current_sum += arr[right]

        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= arr[left]
            left += 1

            # 提前终止：找到长度为 1 的窗口
            if min_length == 1:
                return 1

    return min_length if min_length != float('inf') else 0
```

---

## 学习检查清单

- [ ] 理解固定窗口和可变窗口的区别
- [ ] 掌握固定窗口的两种实现方式（deque vs 双指针）
- [ ] 掌握可变窗口的双指针技巧
- [ ] 能够解决最长无重复子串问题
- [ ] 能够解决最小覆盖子串问题
- [ ] 理解滑动窗口在 AI Agent 中的应用
- [ ] 知道何时使用滑动窗口 vs 双指针

---

## 下一步学习

### 深入算法
→ **03_核心概念_04_LRU缓存实现.md** - 学习 LRU 缓存

### AI Agent 应用
→ **03_核心概念_05_AI_Agent短期记忆.md** - AI Agent 记忆管理

### 实战代码
→ **07_实战代码_02_单调队列算法.md** - 完整代码示例

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+, AI Agent 开发, RAG 系统
