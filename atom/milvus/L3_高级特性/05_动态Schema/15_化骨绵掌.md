# 化骨绵掌 - 动态Schema

> 10个知识卡片，快速掌握动态Schema的核心要点

---

## 卡片1：一句话核心

**动态Schema = 固定字段（性能） + 动态字段（灵活性）**

```python
# 固定字段：必须预先定义，支持索引，查询快
fixed_fields = ["id", "embedding", "text"]

# 动态字段：运行时添加，无索引，查询慢
dynamic_fields = ["author", "category", "priority", ...]
```

**记忆口诀**：固定是骨架，动态是血肉

---

## 卡片2：启用动态Schema

**关键参数**：`enable_dynamic_field=True`

```python
from pymilvus import CollectionSchema, FieldSchema, DataType

schema = CollectionSchema(
    fields=[
        FieldSchema(name="id", dtype=DataType.INT64, is_primary=True),
        FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768)
    ],
    enable_dynamic_field=True  # 唯一开关
)
```

**记忆口诀**：一个参数开启灵活之门

---

## 卡片3：插入动态字段

**自动识别**：无需预先定义，自动识别并存储

```python
# 每条数据可以有不同的动态字段
data = [
    {"embedding": [0.1]*768, "author": "Alice", "category": "tech"},
    {"embedding": [0.2]*768, "priority": 5, "tags": ["AI"]},
    {"embedding": [0.3]*768, "author": "Bob", "is_public": True}
]
collection.insert(data)
```

**记忆口诀**：想加什么字段就加什么字段

---

## 卡片4：查询动态字段

**返回所有字段**：`output_fields=["*"]`

```python
# 查询所有字段（包括动态字段）
results = collection.query(
    expr="id > 0",
    output_fields=["*"]  # * 表示所有字段
)

# 或指定特定动态字段
results = collection.query(
    expr="id > 0",
    output_fields=["text", "author", "category"]
)
```

**记忆口诀**：星号返回全部，指定返回部分

---

## 卡片5：动态字段过滤

**支持标量过滤**：但性能较低（无索引）

```python
# 按动态字段过滤
results = collection.query(
    expr='author == "Alice"',  # 动态字段过滤
    output_fields=["*"]
)

# 组合过滤
results = collection.query(
    expr='category == "tech" and priority > 3',
    output_fields=["*"]
)
```

**记忆口诀**：能过滤但很慢，高频字段要固定

---

## 卡片6：动态字段的限制

**三大限制**：

1. **不支持索引**：无法为动态字段创建索引
2. **类型必须一致**：同一字段的类型不能变化
3. **查询性能低**：全表扫描，比固定字段慢10-100倍

```python
# ❌ 不支持索引
collection.create_index(field_name="author", ...)  # 报错

# ❌ 类型不一致
data = [
    {"embedding": [0.1]*768, "priority": 5},      # INT64
    {"embedding": [0.2]*768, "priority": "high"}  # VARCHAR，类型不一致
]

# ❌ 查询性能低
results = collection.query(expr='author == "Alice"')  # 全表扫描
```

**记忆口诀**：无索引、类型定、性能低

---

## 卡片7：固定字段 vs 动态字段

**决策矩阵**：

| 维度 | 固定字段 | 动态字段 |
|------|---------|---------|
| 性能 | 快（有索引） | 慢（无索引） |
| 灵活性 | 低（需预定义） | 高（运行时添加） |
| 类型安全 | 强 | 弱 |
| 查询能力 | 强（复杂查询） | 弱（基本过滤） |
| 存储效率 | 高（列式） | 低（行式） |

**记忆口诀**：高频用固定，低频用动态

---

## 卡片8：混合Schema策略

**最佳实践**：核心字段固定，扩展字段动态

```python
schema = CollectionSchema(
    fields=[
        # 固定字段：核心字段 + 高频查询字段
        FieldSchema(name="id", dtype=DataType.INT64, is_primary=True),
        FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
        FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=1000),
        FieldSchema(name="author", dtype=DataType.VARCHAR, max_length=100),  # 高频
    ],
    enable_dynamic_field=True  # 动态字段：低频查询 + 扩展字段
)
```

**记忆口诀**：核心固定，扩展动态

---

## 卡片9：渐进式Schema演化

**三阶段策略**：

```python
# 阶段1：快速原型（全部动态）
schema_v1 = {
    "id": INT64,
    "embedding": VECTOR,
    "enable_dynamic_field": True
}

# 阶段2：优化高频字段（迁移到固定）
schema_v2 = {
    "id": INT64,
    "embedding": VECTOR,
    "author": VARCHAR,  # 高频字段迁移
    "enable_dynamic_field": True
}

# 阶段3：固定Schema（生产环境）
schema_v3 = {
    "id": INT64,
    "embedding": VECTOR,
    "author": VARCHAR,
    "category": VARCHAR,
    "enable_dynamic_field": False
}
```

**记忆口诀**：原型动态，优化混合，生产固定

---

## 卡片10：RAG系统中的应用

**典型场景**：文档元数据扩展

```python
# 初期：基本字段
doc_v1 = {
    "text": "Document content",
    "embedding": [0.1]*768
}

# 中期：添加元数据（动态字段）
doc_v2 = {
    "text": "Document content",
    "embedding": [0.1]*768,
    "author": "Alice",        # 动态
    "category": "tech",       # 动态
    "created_at": "2024-01-01"  # 动态
}

# 后期：继续扩展（无需重建）
doc_v3 = {
    "text": "Document content",
    "embedding": [0.1]*768,
    "author": "Alice",
    "category": "tech",
    "created_at": "2024-01-01",
    "tags": ["AI", "ML"],     # 新增
    "rating": 4.5,            # 新增
    "views": 1000             # 新增
}
```

**记忆口诀**：元数据扩展，无需重建

---

## 快速决策树

```
需要添加新字段？
    ↓
是否高频查询？
    ↓ 是
    使用固定字段（需重建Collection）
    ↓ 否
    使用动态字段（无需重建）
        ↓
        是否需要索引？
            ↓ 是
            迁移到固定字段
            ↓ 否
            保持动态字段
```

---

## 常见错误速查

| 错误 | 原因 | 解决方案 |
|------|------|---------|
| 动态字段创建索引失败 | 动态字段不支持索引 | 迁移到固定字段 |
| 类型不一致错误 | 同一字段类型变化 | 保持类型一致 |
| 查询性能慢 | 动态字段无索引 | 高频字段迁移到固定 |
| 字段未返回 | 未指定output_fields | 使用output_fields=["*"] |

---

## 性能优化速查

| 优化策略 | 性能提升 | 适用场景 |
|---------|---------|---------|
| 高频字段迁移到固定 | 10-100x | 查询频繁的字段 |
| 分层查询（先固定后动态） | 5-50x | 混合查询 |
| 缓存动态字段查询结果 | 10-1000x | 重复查询 |
| 关闭动态Schema | 20-50x | 生产环境 |

---

## 记忆口诀总结

```
动态Schema像装修，
固定字段是承重墙。
灵活添加新属性，
无需重建旧房梁。

高频字段用固定，
低频字段用动态。
快速原型先灵活，
生产环境再优化。

无索引、类型定、性能低，
三大限制要记牢。
混合使用最明智，
发挥各自之所长。
```

---

## 一分钟速记

**核心概念**：
- 启用：`enable_dynamic_field=True`
- 插入：自动识别，无需预定义
- 查询：`output_fields=["*"]`
- 过滤：支持但慢

**三大限制**：
- 不支持索引
- 类型必须一致
- 查询性能低

**最佳实践**：
- 高频字段：固定Schema
- 低频字段：动态Schema
- 混合使用：发挥各自优势
- 渐进式演化：原型→优化→生产

**典型应用**：
- RAG元数据扩展
- 多租户灵活字段
- 快速原型迭代
- 多模态数据存储

---

**记住**：动态Schema是工具，不是银弹。根据实际需求选择合适的Schema策略。
