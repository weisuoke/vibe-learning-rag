# 核心概念

> 双阶段架构、核心组件、数据流 —— RAG 系统的三大支柱

---

## 概述

RAG 系统的核心就是三个概念：

| 概念 | 一句话解释 | 解决什么问题 |
|-----|----------|-------------|
| **双阶段架构** | 离线索引 + 在线查询 | 理解 RAG 系统的整体结构 |
| **核心组件** | 6大组件各司其职 | 知道每个环节做什么、出问题找谁 |
| **数据流转换** | 文档 → 向量 → 答案 | 理解数据如何在系统中流动 |

---

## 核心概念1：双阶段架构

### 一句话定义

**RAG 系统分为两个独立阶段：离线索引（Indexing）和在线查询（Querying）。**

### 为什么要分两个阶段？

```
如果不分阶段（每次查询都处理原始文档）:

用户提问 → 加载所有文档 → 分块 → 生成向量 → 检索 → 生成答案
           ↑_______________ 每次都要重复，太慢了！_______________↑

分阶段后:

【离线索引】（提前做好，只做一次）
文档 → 分块 → 生成向量 → 存入向量库 ✓

【在线查询】（用户提问时，毫秒级响应）
用户提问 → 生成问题向量 → 检索 → 生成答案 ✓
```

### 双阶段详解

#### 阶段1：离线索引（Indexing Pipeline）

```
┌─────────────────────────────────────────────────────────────┐
│                    离线索引阶段                               │
│                                                             │
│  原始文档        文本块         向量            向量数据库      │
│  ┌─────┐       ┌─────┐       ┌─────┐         ┌─────┐       │
│  │ PDF │       │chunk│       │ vec │         │     │       │
│  │ Word│  ──→  │chunk│  ──→  │ vec │   ──→   │ DB  │       │
│  │ HTML│       │chunk│       │ vec │         │     │       │
│  └─────┘       └─────┘       └─────┘         └─────┘       │
│     ↓            ↓             ↓                ↓          │
│   Loader      Chunker      Embedder        VectorStore     │
└─────────────────────────────────────────────────────────────┘

特点：
- 提前执行，不影响用户体验
- 只需执行一次（除非文档更新）
- 可以批量处理，不怕慢
```

#### 阶段2：在线查询（Query Pipeline）

```
┌─────────────────────────────────────────────────────────────┐
│                    在线查询阶段                               │
│                                                             │
│  用户问题      问题向量      相关文档块       最终答案         │
│  ┌─────┐      ┌─────┐      ┌─────┐        ┌─────┐         │
│  │  ?  │  ──→ │ vec │  ──→ │docs │   ──→  │ ans │         │
│  └─────┘      └─────┘      └─────┘        └─────┘         │
│     ↓            ↓            ↓              ↓            │
│   Query      Embedder     Retriever      Generator        │
└─────────────────────────────────────────────────────────────┘

特点：
- 实时执行，需要快速响应
- 每次用户提问都执行
- 毫秒级延迟要求
```

### 前端类比

```javascript
// 离线索引 ≈ 构建时（Build Time）
// webpack 打包、生成静态资源、预渲染页面
npm run build  // 提前做好，部署时执行一次

// 在线查询 ≈ 运行时（Runtime）
// 用户访问时的 API 请求、动态渲染
fetch('/api/data')  // 用户每次访问都执行
```

---

## 核心概念2：六大核心组件

### 一句话定义

**RAG 系统由 6 个核心组件组成，每个组件负责数据处理流程中的一个环节。**

### 组件全景图

```
┌─────────────────────────────────────────────────────────────────┐
│                         RAG 系统架构                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────── 离线索引阶段 ────────────────────┐        │
│  │                                                      │        │
│  │  ①Loader    ②Chunker    ③Embedder   ④VectorStore   │        │
│  │  ┌─────┐    ┌─────┐     ┌─────┐     ┌─────┐        │        │
│  │  │加载 │ →  │分块 │  →  │向量化│  →  │存储 │        │        │
│  │  └─────┘    └─────┘     └─────┘     └─────┘        │        │
│  │                                                      │        │
│  └──────────────────────────────────────────────────────┘        │
│                              ↓                                   │
│                         向量数据库                                │
│                              ↓                                   │
│  ┌──────────────────── 在线查询阶段 ────────────────────┐        │
│  │                                                      │        │
│  │     用户问题  →  ⑤Retriever  →  ⑥Generator  →  答案  │        │
│  │                  ┌─────┐       ┌─────┐              │        │
│  │                  │检索 │   →   │生成 │              │        │
│  │                  └─────┘       └─────┘              │        │
│  │                                                      │        │
│  └──────────────────────────────────────────────────────┘        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 六大组件详解

#### ① Loader（文档加载器）

```python
# 职责：将各种格式的文档加载为纯文本
# 输入：PDF、Word、HTML、Markdown、TXT...
# 输出：纯文本内容

# 示例
from langchain_community.document_loaders import PyPDFLoader

loader = PyPDFLoader("company_policy.pdf")
documents = loader.load()
# documents[0].page_content = "第一章 退款政策..."
```

**常见问题**：PDF 解析乱码、表格丢失、图片无法识别

#### ② Chunker（文本分块器）

```python
# 职责：将长文本切分成适合检索的小块
# 输入：长文本
# 输出：文本块列表

# 示例
from langchain.text_splitter import RecursiveCharacterTextSplitter

splitter = RecursiveCharacterTextSplitter(
    chunk_size=500,      # 每块最大500字符
    chunk_overlap=50     # 块之间重叠50字符
)
chunks = splitter.split_documents(documents)
# chunks = ["第一章 退款政策...", "1.1 退款条件...", ...]
```

**常见问题**：块太大检索不精准、块太小丢失上下文

#### ③ Embedder（向量化器）

```python
# 职责：将文本转换为向量表示
# 输入：文本
# 输出：向量（如 1536 维的浮点数数组）

# 示例
from openai import OpenAI

client = OpenAI()
response = client.embeddings.create(
    model="text-embedding-3-small",
    input="退款政策"
)
vector = response.data[0].embedding
# vector = [0.023, -0.041, 0.018, ...]  # 1536维
```

**常见问题**：模型选择、维度与性能权衡

#### ④ VectorStore（向量存储）

```python
# 职责：存储向量并支持相似度检索
# 输入：向量 + 元数据
# 输出：支持快速检索的索引

# 示例
import chromadb

client = chromadb.Client()
collection = client.create_collection("company_docs")
collection.add(
    documents=["退款政策内容..."],
    embeddings=[[0.023, -0.041, ...]],
    ids=["doc1"]
)
```

**常见问题**：索引策略、扩展性、持久化

#### ⑤ Retriever（检索器）

```python
# 职责：根据用户问题检索最相关的文档块
# 输入：用户问题
# 输出：Top-K 相关文档块

# 示例
results = collection.query(
    query_texts=["如何申请退款？"],
    n_results=3  # 返回最相关的3个文档块
)
# results = ["1.1 退款条件...", "1.2 退款流程...", ...]
```

**常见问题**：召回率、精确率、检索策略

#### ⑥ Generator（生成器）

```python
# 职责：基于检索到的上下文生成答案
# 输入：用户问题 + 检索到的上下文
# 输出：最终答案

# 示例
prompt = f"""
基于以下信息回答问题：

{retrieved_context}

问题：{user_question}
"""

response = client.chat.completions.create(
    model="gpt-4",
    messages=[{"role": "user", "content": prompt}]
)
answer = response.choices[0].message.content
```

**常见问题**：Prompt 设计、上下文长度、答案质量

### 组件职责速查表

| 组件 | 输入 | 输出 | 关键指标 |
|-----|------|------|---------|
| Loader | 原始文档 | 纯文本 | 格式支持度、解析准确率 |
| Chunker | 长文本 | 文本块 | 块大小、重叠策略 |
| Embedder | 文本 | 向量 | 向量维度、语义质量 |
| VectorStore | 向量 | 索引 | 检索速度、存储容量 |
| Retriever | 问题 | 相关文档 | 召回率、精确率 |
| Generator | 上下文+问题 | 答案 | 答案质量、响应速度 |

---

## 核心概念3：数据流与转换

### 一句话定义

**RAG 中的数据经历 5 次关键转换：文档 → 文本 → 块 → 向量 → 答案。**

### 数据流全景

```
┌─────────────────────────────────────────────────────────────────┐
│                        数据流转换全景                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  原始文档          纯文本           文本块           向量         │
│  ┌─────┐         ┌─────┐         ┌─────┐        ┌─────┐       │
│  │.pdf │   ──→   │ txt │   ──→   │chunk│  ──→   │[0.1,│       │
│  │.docx│  解析    │     │  分块    │chunk│ 向量化  │0.2] │       │
│  │.html│         │     │         │chunk│        │     │       │
│  └─────┘         └─────┘         └─────┘        └─────┘       │
│                                                     │          │
│                                                     ↓          │
│                                               ┌─────────┐      │
│                                               │向量数据库│      │
│                                               └─────────┘      │
│                                                     │          │
│  用户问题          问题向量         相关块           答案         │
│  ┌─────┐         ┌─────┐        ┌─────┐        ┌─────┐       │
│  │  ?  │   ──→   │[0.1,│  ──→   │chunk│  ──→   │ ans │       │
│  │     │  向量化  │0.2] │ 相似检索 │chunk│  生成   │     │       │
│  └─────┘         └─────┘        └─────┘        └─────┘       │
│                                                                │
└─────────────────────────────────────────────────────────────────┘
```

### 每次转换的关键点

| 转换 | 输入 → 输出 | 关键决策 | 影响 |
|-----|------------|---------|------|
| 解析 | 文档 → 文本 | 解析器选择 | 信息完整性 |
| 分块 | 文本 → 块 | 块大小、重叠 | 检索粒度 |
| 向量化 | 块 → 向量 | Embedding 模型 | 语义质量 |
| 检索 | 向量 → 相关块 | Top-K、阈值 | 召回质量 |
| 生成 | 块 → 答案 | Prompt 设计 | 答案质量 |

### 数据转换示例

```python
# 完整的数据流示例

# 1. 原始文档
raw_doc = "company_policy.pdf"

# 2. 解析为文本
text = "第一章 退款政策\n1.1 退款条件\n客户可在购买后7天内申请退款..."

# 3. 分块
chunks = [
    "第一章 退款政策",
    "1.1 退款条件 客户可在购买后7天内申请退款...",
    "1.2 退款流程 请联系客服提交退款申请..."
]

# 4. 向量化
vectors = [
    [0.023, -0.041, 0.018, ...],  # chunk1 的向量
    [0.015, -0.032, 0.025, ...],  # chunk2 的向量
    [0.019, -0.028, 0.021, ...]   # chunk3 的向量
]

# 5. 用户问题
question = "如何申请退款？"
question_vector = [0.017, -0.035, 0.022, ...]

# 6. 检索（找最相似的向量）
relevant_chunks = ["1.2 退款流程 请联系客服提交退款申请..."]

# 7. 生成答案
answer = "根据公司政策，您可以联系客服提交退款申请..."
```

---

## 三个概念的协作

```
用户问题: "如何申请退款？"

Step 1: 【双阶段架构】判断走哪个阶段
  → 这是用户查询，走在线查询阶段

Step 2: 【数据流转换】问题 → 向量
  → "如何申请退款？" → [0.017, -0.035, ...]

Step 3: 【核心组件】Retriever 检索
  → 从向量库中找到最相似的文档块

Step 4: 【核心组件】Generator 生成
  → 将检索结果 + 问题组装成 Prompt，调用 LLM

Step 5: 【数据流转换】上下文 → 答案
  → 输出最终答案给用户
```

---

## 总结对比

| 概念 | 作用 | 前端类比 | 关键产出 |
|-----|------|---------|---------|
| 双阶段架构 | 分离索引和查询 | Build Time vs Runtime | 系统架构图 |
| 核心组件 | 明确各环节职责 | 前端组件化 | 组件选型方案 |
| 数据流转换 | 理解数据如何流动 | 数据流（Redux） | 数据处理流程 |

---

## 检查清单

学完本节，你应该能回答：

- [ ] RAG 为什么要分离线索引和在线查询两个阶段？
- [ ] RAG 的 6 个核心组件分别是什么？各自的职责是什么？
- [ ] 数据在 RAG 系统中经历了哪些转换？
- [ ] 如果检索结果不好，应该从哪个组件开始排查？

---

**下一步：** [04_最小可用](./04_最小可用.md) - 掌握20%核心知识
