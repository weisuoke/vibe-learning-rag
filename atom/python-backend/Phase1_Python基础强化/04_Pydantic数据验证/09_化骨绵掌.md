# 化骨绵掌

10个2分钟知识卡片，快速掌握 Pydantic 核心知识。

---

## 卡片1：Pydantic 的本质

**一句话：** Pydantic 让 Python 类型注解在运行时生效，自动验证和转换数据。

**举例：**
```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int

# 自动验证和转换
user = User(name="Alice", age="25")  # "25" → 25
print(user.age)  # 25 (int)
```

**应用：** FastAPI 用 Pydantic 自动验证 API 请求，无需手动写验证代码。

---

## 卡片2：BaseModel 基础

**一句话：** 所有 Pydantic 模型都继承自 BaseModel，提供自动验证功能。

**举例：**
```python
from pydantic import BaseModel

class Product(BaseModel):
    name: str
    price: float
    in_stock: bool = True  # 默认值

# 创建实例
product = Product(name="Book", price=19.99)
print(product.in_stock)  # True
```

**应用：** 定义 API 请求/响应模型，自动验证数据格式。

---

## 卡片3：Field 验证规则

**一句话：** Field 用于添加验证约束（长度、范围、格式等）。

**举例：**
```python
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str = Field(..., min_length=1, max_length=50)
    age: int = Field(..., ge=0, le=150)
    email: str = Field(..., pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")

# 自动验证所有约束
user = User(name="Alice", age=25, email="alice@example.com")
```

**应用：** 声明式定义验证规则，比手动 if-else 简洁 10 倍。

---

## 卡片4：自动类型转换

**一句话：** Pydantic 会尝试将输入数据转换为目标类型。

**举例：**
```python
from pydantic import BaseModel

class Data(BaseModel):
    count: int
    active: bool
    price: float

# 自动转换
data = Data(count="10", active="true", price="99.99")
print(data.count)   # 10 (int)
print(data.active)  # True (bool)
print(data.price)   # 99.99 (float)
```

**应用：** Web API 接收的数据都是字符串，Pydantic 自动转换为正确类型。

---

## 卡片5：可选字段

**一句话：** 使用 Optional 或默认值定义可选字段。

**举例：**
```python
from pydantic import BaseModel
from typing import Optional

class User(BaseModel):
    name: str
    email: Optional[str] = None  # 可选
    age: int = 0  # 默认值

# 可选字段可以不传
user1 = User(name="Alice")
user2 = User(name="Bob", email="bob@example.com", age=30)
```

**应用：** API 请求中的可选参数，如分页、过滤条件等。

---

## 卡片6：嵌套模型

**一句话：** 模型可以嵌套其他模型，自动验证所有层级。

**举例：**
```python
from pydantic import BaseModel
from typing import List

class Address(BaseModel):
    city: str
    country: str

class User(BaseModel):
    name: str
    address: Address  # 嵌套模型

user = User(
    name="Alice",
    address={"city": "New York", "country": "USA"}
)
print(user.address.city)  # New York
```

**应用：** 复杂的 JSON 数据结构，如 LLM 请求/响应。

---

## 卡片7：自定义验证器

**一句话：** 使用 @field_validator 实现复杂的验证逻辑。

**举例：**
```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    password: str

    @field_validator('password')
    @classmethod
    def password_strong(cls, v):
        if len(v) < 8:
            raise ValueError('password must be at least 8 characters')
        if not any(c.isdigit() for c in v):
            raise ValueError('password must contain a digit')
        return v

# 自动调用验证器
user = User(password="password123")
```

**应用：** 密码强度、邮箱格式、业务规则等复杂验证。

---

## 卡片8：模型验证器

**一句话：** 使用 @model_validator 验证多个字段之间的关系。

**举例：**
```python
from pydantic import BaseModel, model_validator

class Event(BaseModel):
    start_date: str
    end_date: str

    @model_validator(mode='after')
    def check_dates(self):
        if self.end_date < self.start_date:
            raise ValueError('end_date must be after start_date')
        return self

# 跨字段验证
event = Event(start_date="2026-03-01", end_date="2026-03-03")
```

**应用：** 密码确认、日期范围、依赖字段等跨字段验证。

---

## 卡片9：FastAPI 集成

**一句话：** FastAPI 自动使用 Pydantic 验证请求和响应。

**举例：**
```python
from fastapi import FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class CreateUserRequest(BaseModel):
    name: str = Field(..., min_length=1)
    age: int = Field(..., ge=0)

@app.post("/users")
async def create_user(request: CreateUserRequest):
    # FastAPI 自动验证 request
    # 验证失败自动返回 422 错误
    return {"message": f"User {request.name} created"}
```

**应用：** 构建类型安全的 RESTful API，自动生成文档。

---

## 卡片10：序列化和反序列化

**一句话：** Pydantic 自动处理 JSON 序列化和反序列化。

**举例：**
```python
from pydantic import BaseModel
from datetime import datetime

class User(BaseModel):
    name: str
    created_at: datetime

user = User(name="Alice", created_at=datetime.now())

# 序列化为字典
user_dict = user.model_dump()

# 序列化为 JSON
json_str = user.model_dump_json()
# {"name":"Alice","created_at":"2026-02-11T06:20:29.095Z"}

# 从 JSON 反序列化
user2 = User.model_validate_json(json_str)
```

**应用：** API 响应序列化、数据持久化、消息队列等。

---

## 快速参考卡片

### 常用模式速查

**1. 基础模型定义**
```python
class User(BaseModel):
    name: str
    age: int
    email: Optional[str] = None
```

**2. Field 验证**
```python
name: str = Field(..., min_length=1, max_length=50)
age: int = Field(..., ge=0, le=150)
```

**3. 自定义验证器**
```python
@field_validator('field_name')
@classmethod
def validate_field(cls, v):
    if not valid(v):
        raise ValueError('error message')
    return v
```

**4. 模型验证器**
```python
@model_validator(mode='after')
def validate_model(self):
    if not valid(self):
        raise ValueError('error message')
    return self
```

**5. FastAPI 端点**
```python
@app.post("/endpoint", response_model=Response)
async def endpoint(request: Request):
    return response
```

**6. 序列化**
```python
# 转字典
data = model.model_dump()

# 转 JSON
json_str = model.model_dump_json()

# 从字典创建
model = Model(**data)

# 从 JSON 创建
model = Model.model_validate_json(json_str)
```

---

## 学习路径卡片

### 初学者路径（1小时）

**第1步（5分钟）：** 理解 Pydantic 的本质
- 卡片1：Pydantic 的本质
- 卡片2：BaseModel 基础

**第2步（15分钟）：** 掌握基础用法
- 卡片3：Field 验证规则
- 卡片4：自动类型转换
- 卡片5：可选字段

**第3步（20分钟）：** 学习高级特性
- 卡片6：嵌套模型
- 卡片7：自定义验证器
- 卡片8：模型验证器

**第4步（20分钟）：** 实战应用
- 卡片9：FastAPI 集成
- 卡片10：序列化和反序列化

---

### 进阶路径（3小时）

**阶段1：基础巩固**
- 完成初学者路径
- 阅读完整的核心概念文档
- 动手实践每个示例

**阶段2：深入理解**
- 学习 Field 的所有验证规则
- 掌握自定义验证器的各种模式
- 理解 mode='before' 和 mode='after'

**阶段3：实战项目**
- 构建完整的 FastAPI 应用
- 集成 LLM API
- 实现复杂的数据验证逻辑

---

## 常见问题卡片

### Q1: Pydantic 和类型注解有什么区别？

**简答：** 类型注解是静态提示（mypy 检查），Pydantic 是运行时验证。

**详细：**
- 类型注解：编译时检查，不影响运行时
- Pydantic：运行时验证和转换，确保数据正确
- 最佳实践：两者结合使用

---

### Q2: 验证失败会返回什么？

**简答：** 抛出 ValidationError 异常，不是返回 None。

**详细：**
```python
try:
    user = User(age="invalid")
except ValidationError as e:
    print(e.errors())  # 详细错误信息
```

---

### Q3: Pydantic 会自动转换类型吗？

**简答：** 会，这是 Pydantic 的核心功能之一。

**详细：**
```python
user = User(age="25")  # "25" → 25
print(type(user.age))  # <class 'int'>
```

---

### Q4: 如何让模型不可变？

**简答：** 使用 ConfigDict(frozen=True)。

**详细：**
```python
class Config(BaseModel):
    model_config = ConfigDict(frozen=True)
    api_key: str

config = Config(api_key="sk-xxx")
# config.api_key = "new"  # 报错
```

---

### Q5: 如何排除某些字段？

**简答：** 使用 model_dump(exclude={...})。

**详细：**
```python
user = User(name="Alice", password="secret")
data = user.model_dump(exclude={'password'})
# {'name': 'Alice'}
```

---

## 实战技巧卡片

### 技巧1：使用 EmailStr 验证邮箱

```python
from pydantic import BaseModel, EmailStr

class User(BaseModel):
    email: EmailStr  # 自动验证邮箱格式

# 需要安装：uv add pydantic[email]
```

---

### 技巧2：使用 Literal 限定可选值

```python
from pydantic import BaseModel
from typing import Literal

class Config(BaseModel):
    model: Literal["gpt-4", "claude-3", "gpt-3.5-turbo"]

# model 只能是这三个值之一
```

---

### 技巧3：使用 default_factory 避免可变默认值

```python
from pydantic import BaseModel, Field
from typing import List

class User(BaseModel):
    tags: List[str] = Field(default_factory=list)

# 每个实例都有独立的列表
```

---

### 技巧4：使用 alias 统一前后端字段名

```python
from pydantic import BaseModel, Field, ConfigDict

class User(BaseModel):
    model_config = ConfigDict(populate_by_name=True)
    user_name: str = Field(..., alias="userName")

# 可以用 userName 或 user_name 创建
```

---

### 技巧5：使用 exclude_unset 实现部分更新

```python
class UpdateUserRequest(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None

request = UpdateUserRequest(name="Alice")
# 只更新提供的字段
update_data = request.model_dump(exclude_unset=True)
# {'name': 'Alice'}（不包含 age）
```

---

## 错误处理卡片

### 错误1：忘记用 try-except 捕获 ValidationError

**错误代码：**
```python
user = User(age="invalid")  # 直接崩溃
```

**正确代码：**
```python
try:
    user = User(age="invalid")
except ValidationError as e:
    print(e.errors())
```

---

### 错误2：使用可变默认值

**错误代码：**
```python
class User(BaseModel):
    tags: List[str] = []  # 危险！
```

**正确代码：**
```python
class User(BaseModel):
    tags: List[str] = Field(default_factory=list)
```

---

### 错误3：在验证器中不返回值

**错误代码：**
```python
@field_validator('name')
@classmethod
def validate_name(cls, v):
    if not v:
        raise ValueError('name required')
    # 忘记返回 v
```

**正确代码：**
```python
@field_validator('name')
@classmethod
def validate_name(cls, v):
    if not v:
        raise ValueError('name required')
    return v  # 必须返回
```

---

### 错误4：混淆 Field(...) 和 Field(default=...)

**错误代码：**
```python
name: str = Field(None)  # None 是默认值，不是必填
```

**正确代码：**
```python
name: str = Field(...)  # 必填
# 或
name: Optional[str] = Field(None)  # 可选
```

---

### 错误5：忘记 @classmethod 装饰器

**错误代码：**
```python
@field_validator('name')
def validate_name(cls, v):  # 缺少 @classmethod
    return v
```

**正确代码：**
```python
@field_validator('name')
@classmethod
def validate_name(cls, v):
    return v
```

---

## 性能优化卡片

### 优化1：使用 model_validate 而不是 **dict

```python
# 慢
user = User(**data)

# 快
user = User.model_validate(data)
```

---

### 优化2：使用 model_dump_json 而不是 json.dumps

```python
import json

# 慢
json_str = json.dumps(user.model_dump())

# 快（使用 Rust 实现）
json_str = user.model_dump_json()
```

---

### 优化3：避免重复验证

```python
# 如果数据已经验证过，使用 model_construct 跳过验证
user = User.model_construct(name="Alice", age=25)
```

---

## 总结卡片

### Pydantic 的核心价值

1. **运行时类型安全**：让类型注解在运行时生效
2. **自动数据转换**：字符串自动转换为正确类型
3. **声明式验证**：在类型定义处声明验证规则
4. **FastAPI 集成**：无缝集成，自动生成文档
5. **序列化支持**：自动处理 JSON 序列化

### 学习建议

1. **先掌握基础**：BaseModel、Field、类型注解
2. **再学高级**：自定义验证器、模型验证器
3. **多做实践**：构建真实的 API 项目
4. **阅读文档**：Pydantic 和 FastAPI 官方文档
5. **参考示例**：学习开源项目的用法

### 下一步

- 学习 FastAPI 的依赖注入
- 学习 SQLAlchemy ORM 集成
- 学习 Pydantic Settings（配置管理）
- 学习 Pydantic v2 的新特性

---

**版本：** v1.0
**最后更新：** 2026-02-11
