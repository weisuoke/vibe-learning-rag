# å®æˆ˜ä»£ç  07ï¼šæ‰¹å¤„ç†ä¼˜åŒ–

> **ç›®æ ‡**: å®ç°æ‰¹å¤„ç†ä¼˜åŒ–ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œç‹¬ç«‹å·¥å…·ï¼Œæ˜¾è‘—æå‡æ€§èƒ½ã€‚

---

## å®Œæ•´ä»£ç å®ç°

```typescript
/**
 * æ‰¹å¤„ç†ä¼˜åŒ–å®æˆ˜ç¤ºä¾‹
 * æ¼”ç¤ºï¼šå¦‚ä½•åˆ†æä¾èµ–å…³ç³»å¹¶å¹¶è¡Œæ‰§è¡Œç‹¬ç«‹å·¥å…·
 */

// ===== 1. ç±»å‹å®šä¹‰ =====

/**
 * å·¥å…·è°ƒç”¨æ¥å£
 */
export interface ToolCall {
  id: string;
  name: string;
  args: Record<string, any>;
  dependencies?: string[]; // ä¾èµ–çš„å·¥å…· ID
}

/**
 * å·¥å…·ç»“æœæ¥å£
 */
export interface ToolResult {
  toolCallId: string;
  result: any;
  error?: string;
  executionTime: number;
}

/**
 * å·¥å…·ç»„æ¥å£
 */
export interface ToolGroup {
  tools: ToolCall[];
  canParallel: boolean;
  dependencies: string[];
}

// ===== 2. ä¾èµ–åˆ†æå™¨ =====

/**
 * ä¾èµ–åˆ†æå™¨
 * åˆ†æå·¥å…·è°ƒç”¨ä¹‹é—´çš„ä¾èµ–å…³ç³»
 */
export class DependencyAnalyzer {
  /**
   * åˆ†æä¾èµ–å…³ç³»
   */
  analyze(toolCalls: ToolCall[]): ToolGroup[] {
    const groups: ToolGroup[] = [];
    const processed = new Set<string>();

    // æ„å»ºä¾èµ–å›¾
    const dependencyGraph = this.buildDependencyGraph(toolCalls);

    // æ‹“æ‰‘æ’åº
    const sortedLevels = this.topologicalSort(toolCalls, dependencyGraph);

    // æŒ‰å±‚çº§åˆ†ç»„
    for (const level of sortedLevels) {
      const tools = level.filter(id => !processed.has(id))
        .map(id => toolCalls.find(t => t.id === id)!);

      if (tools.length > 0) {
        groups.push({
          tools,
          canParallel: tools.length > 1,
          dependencies: this.getGroupDependencies(tools, dependencyGraph)
        });

        tools.forEach(t => processed.add(t.id));
      }
    }

    return groups;
  }

  /**
   * æ„å»ºä¾èµ–å›¾
   */
  private buildDependencyGraph(
    toolCalls: ToolCall[]
  ): Map<string, Set<string>> {
    const graph = new Map<string, Set<string>>();

    for (const tool of toolCalls) {
      if (!graph.has(tool.id)) {
        graph.set(tool.id, new Set());
      }

      // åˆ†æå‚æ•°ä¸­çš„ä¾èµ–
      const deps = this.extractDependencies(tool, toolCalls);
      deps.forEach(dep => graph.get(tool.id)!.add(dep));

      // æ˜¾å¼ä¾èµ–
      if (tool.dependencies) {
        tool.dependencies.forEach(dep => graph.get(tool.id)!.add(dep));
      }
    }

    return graph;
  }

  /**
   * æå–ä¾èµ–
   */
  private extractDependencies(
    tool: ToolCall,
    allTools: ToolCall[]
  ): string[] {
    const deps: string[] = [];
    const argsStr = JSON.stringify(tool.args);

    // æ£€æŸ¥å‚æ•°ä¸­æ˜¯å¦å¼•ç”¨äº†å…¶ä»–å·¥å…·çš„è¾“å‡º
    for (const otherTool of allTools) {
      if (otherTool.id !== tool.id && argsStr.includes(`$${otherTool.id}`)) {
        deps.push(otherTool.id);
      }
    }

    return deps;
  }

  /**
   * æ‹“æ‰‘æ’åº
   */
  private topologicalSort(
    toolCalls: ToolCall[],
    graph: Map<string, Set<string>>
  ): string[][] {
    const levels: string[][] = [];
    const inDegree = new Map<string, number>();
    const remaining = new Set(toolCalls.map(t => t.id));

    // è®¡ç®—å…¥åº¦
    for (const tool of toolCalls) {
      inDegree.set(tool.id, graph.get(tool.id)!.size);
    }

    // æŒ‰å±‚çº§åˆ†ç»„
    while (remaining.size > 0) {
      const currentLevel: string[] = [];

      // æ‰¾å‡ºå…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹
      for (const id of remaining) {
        if (inDegree.get(id) === 0) {
          currentLevel.push(id);
        }
      }

      if (currentLevel.length === 0) {
        throw new Error('Circular dependency detected');
      }

      levels.push(currentLevel);

      // ç§»é™¤å½“å‰å±‚çº§çš„èŠ‚ç‚¹
      for (const id of currentLevel) {
        remaining.delete(id);

        // æ›´æ–°ä¾èµ–æ­¤èŠ‚ç‚¹çš„å…¶ä»–èŠ‚ç‚¹çš„å…¥åº¦
        for (const [otherId, deps] of graph) {
          if (deps.has(id)) {
            inDegree.set(otherId, inDegree.get(otherId)! - 1);
          }
        }
      }
    }

    return levels;
  }

  /**
   * è·å–ç»„çš„ä¾èµ–
   */
  private getGroupDependencies(
    tools: ToolCall[],
    graph: Map<string, Set<string>>
  ): string[] {
    const deps = new Set<string>();
    const toolIds = new Set(tools.map(t => t.id));

    for (const tool of tools) {
      for (const dep of graph.get(tool.id)!) {
        if (!toolIds.has(dep)) {
          deps.add(dep);
        }
      }
    }

    return Array.from(deps);
  }
}

// ===== 3. æ‰¹å¤„ç†æ‰§è¡Œå™¨ =====

/**
 * æ‰¹å¤„ç†æ‰§è¡Œå™¨
 */
export class BatchExecutor {
  private analyzer: DependencyAnalyzer;
  private results: Map<string, ToolResult> = new Map();

  constructor() {
    this.analyzer = new DependencyAnalyzer();
  }

  /**
   * æ‰¹é‡æ‰§è¡Œå·¥å…·è°ƒç”¨
   */
  async execute(toolCalls: ToolCall[]): Promise<ToolResult[]> {
    console.log(`\n=== Batch Execution: ${toolCalls.length} tools ===\n`);

    // 1. åˆ†æä¾èµ–å…³ç³»
    const groups = this.analyzer.analyze(toolCalls);
    console.log(`Analyzed into ${groups.length} groups\n`);

    // 2. æŒ‰ç»„æ‰§è¡Œ
    const startTime = Date.now();

    for (let i = 0; i < groups.length; i++) {
      const group = groups[i];
      console.log(`Group ${i + 1}/${groups.length}:`);
      console.log(`- Tools: ${group.tools.map(t => t.name).join(', ')}`);
      console.log(`- Can parallel: ${group.canParallel}`);

      if (group.canParallel) {
        // å¹¶è¡Œæ‰§è¡Œ
        await this.executeParallel(group.tools);
      } else {
        // é¡ºåºæ‰§è¡Œ
        await this.executeSequential(group.tools);
      }

      console.log('');
    }

    const totalTime = Date.now() - startTime;
    console.log(`Total execution time: ${totalTime}ms\n`);

    return Array.from(this.results.values());
  }

  /**
   * å¹¶è¡Œæ‰§è¡Œ
   */
  private async executeParallel(tools: ToolCall[]): Promise<void> {
    const startTime = Date.now();

    const results = await Promise.all(
      tools.map(tool => this.executeTool(tool))
    );

    const executionTime = Date.now() - startTime;
    console.log(`  Parallel execution: ${executionTime}ms`);

    results.forEach(result => this.results.set(result.toolCallId, result));
  }

  /**
   * é¡ºåºæ‰§è¡Œ
   */
  private async executeSequential(tools: ToolCall[]): Promise<void> {
    const startTime = Date.now();

    for (const tool of tools) {
      const result = await this.executeTool(tool);
      this.results.set(result.toolCallId, result);
    }

    const executionTime = Date.now() - startTime;
    console.log(`  Sequential execution: ${executionTime}ms`);
  }

  /**
   * æ‰§è¡Œå•ä¸ªå·¥å…·
   */
  private async executeTool(tool: ToolCall): Promise<ToolResult> {
    const startTime = Date.now();

    console.log(`    Executing: ${tool.name}(${JSON.stringify(tool.args)})`);

    // æ¨¡æ‹Ÿå·¥å…·æ‰§è¡Œ
    await new Promise(resolve => setTimeout(resolve, 500));

    const result: ToolResult = {
      toolCallId: tool.id,
      result: `Result of ${tool.name}`,
      executionTime: Date.now() - startTime
    };

    return result;
  }

  /**
   * è·å–å·¥å…·ç»“æœ
   */
  getResult(toolCallId: string): ToolResult | undefined {
    return this.results.get(toolCallId);
  }

  /**
   * æ¸…ç©ºç»“æœ
   */
  clear(): void {
    this.results.clear();
  }
}

// ===== 4. ä½¿ç”¨ç¤ºä¾‹ =====

/**
 * ç¤ºä¾‹ 1ï¼šç‹¬ç«‹å·¥å…·å¹¶è¡Œæ‰§è¡Œ
 */
async function example1_IndependentToolsParallel() {
  console.log('=== ç¤ºä¾‹ 1ï¼šç‹¬ç«‹å·¥å…·å¹¶è¡Œæ‰§è¡Œ ===');

  const executor = new BatchExecutor();

  const toolCalls: ToolCall[] = [
    { id: 'tool-1', name: 'readFile', args: { path: 'file1.txt' } },
    { id: 'tool-2', name: 'readFile', args: { path: 'file2.txt' } },
    { id: 'tool-3', name: 'readFile', args: { path: 'file3.txt' } }
  ];

  await executor.execute(toolCalls);

  console.log('Expected: All 3 tools execute in parallel (~500ms total)');
}

/**
 * ç¤ºä¾‹ 2ï¼šæœ‰ä¾èµ–å…³ç³»çš„å·¥å…·
 */
async function example2_DependentTools() {
  console.log('=== ç¤ºä¾‹ 2ï¼šæœ‰ä¾èµ–å…³ç³»çš„å·¥å…· ===');

  const executor = new BatchExecutor();

  const toolCalls: ToolCall[] = [
    { id: 'tool-1', name: 'readFile', args: { path: 'data.json' } },
    { id: 'tool-2', name: 'parseJSON', args: { data: '$tool-1' } },
    { id: 'tool-3', name: 'validateData', args: { data: '$tool-2' } }
  ];

  await executor.execute(toolCalls);

  console.log('Expected: 3 groups, sequential execution (~1500ms total)');
}

/**
 * ç¤ºä¾‹ 3ï¼šæ··åˆæ¨¡å¼
 */
async function example3_MixedMode() {
  console.log('=== ç¤ºä¾‹ 3ï¼šæ··åˆæ¨¡å¼ ===');

  const executor = new BatchExecutor();

  const toolCalls: ToolCall[] = [
    // ç¬¬ä¸€ç»„ï¼šå¹¶è¡Œè¯»å–æ–‡ä»¶
    { id: 'tool-1', name: 'readFile', args: { path: 'file1.txt' } },
    { id: 'tool-2', name: 'readFile', args: { path: 'file2.txt' } },
    { id: 'tool-3', name: 'readFile', args: { path: 'file3.txt' } },

    // ç¬¬äºŒç»„ï¼šåˆå¹¶æ–‡ä»¶ï¼ˆä¾èµ–ç¬¬ä¸€ç»„ï¼‰
    { id: 'tool-4', name: 'mergeFiles', args: { files: ['$tool-1', '$tool-2', '$tool-3'] } },

    // ç¬¬ä¸‰ç»„ï¼šå¤„ç†åˆå¹¶ç»“æœ
    { id: 'tool-5', name: 'processData', args: { data: '$tool-4' } }
  ];

  await executor.execute(toolCalls);

  console.log('Expected: 3 groups, mixed execution (~1500ms total)');
}

/**
 * ç¤ºä¾‹ 4ï¼šæ€§èƒ½å¯¹æ¯”
 */
async function example4_PerformanceComparison() {
  console.log('=== ç¤ºä¾‹ 4ï¼šæ€§èƒ½å¯¹æ¯” ===');

  const toolCalls: ToolCall[] = [
    { id: 'tool-1', name: 'readFile', args: { path: 'file1.txt' } },
    { id: 'tool-2', name: 'readFile', args: { path: 'file2.txt' } },
    { id: 'tool-3', name: 'readFile', args: { path: 'file3.txt' } },
    { id: 'tool-4', name: 'readFile', args: { path: 'file4.txt' } },
    { id: 'tool-5', name: 'readFile', args: { path: 'file5.txt' } }
  ];

  // é¡ºåºæ‰§è¡Œ
  console.log('\nMethod 1: Sequential execution');
  const start1 = Date.now();
  for (const tool of toolCalls) {
    await new Promise(resolve => setTimeout(resolve, 500));
  }
  const time1 = Date.now() - start1;
  console.log(`Time: ${time1}ms\n`);

  // æ‰¹å¤„ç†ï¼ˆå¹¶è¡Œæ‰§è¡Œï¼‰
  console.log('Method 2: Batch execution (parallel)');
  const executor = new BatchExecutor();
  await executor.execute(toolCalls);

  console.log(`Speedup: ${(time1 / 500).toFixed(2)}x`);
}

/**
 * ç¤ºä¾‹ 5ï¼šæ˜¾å¼ä¾èµ–
 */
async function example5_ExplicitDependencies() {
  console.log('=== ç¤ºä¾‹ 5ï¼šæ˜¾å¼ä¾èµ– ===');

  const executor = new BatchExecutor();

  const toolCalls: ToolCall[] = [
    { id: 'tool-1', name: 'fetchData', args: { url: 'api/data' } },
    { id: 'tool-2', name: 'fetchMetadata', args: { url: 'api/metadata' } },
    {
      id: 'tool-3',
      name: 'combineData',
      args: { data: 'combined' },
      dependencies: ['tool-1', 'tool-2'] // æ˜¾å¼å£°æ˜ä¾èµ–
    }
  ];

  await executor.execute(toolCalls);

  console.log('Expected: 2 groups (tool-1 & tool-2 parallel, then tool-3)');
}

// ===== 5. è¿è¡Œæ‰€æœ‰ç¤ºä¾‹ =====

async function runAllExamples() {
  await example1_IndependentToolsParallel();
  await new Promise(resolve => setTimeout(resolve, 1000));

  await example2_DependentTools();
  await new Promise(resolve => setTimeout(resolve, 1000));

  await example3_MixedMode();
  await new Promise(resolve => setTimeout(resolve, 1000));

  await example4_PerformanceComparison();
  await new Promise(resolve => setTimeout(resolve, 1000));

  await example5_ExplicitDependencies();
}

// è¿è¡Œç¤ºä¾‹
runAllExamples().catch(console.error);
```

---

## æ ¸å¿ƒè¦ç‚¹

1. **ä¾èµ–åˆ†æ**ï¼šåˆ†æå·¥å…·è°ƒç”¨ä¹‹é—´çš„ä¾èµ–å…³ç³»
2. **æ‹“æ‰‘æ’åº**ï¼šæŒ‰ä¾èµ–å…³ç³»å¯¹å·¥å…·è¿›è¡Œåˆ†å±‚
3. **å¹¶è¡Œæ‰§è¡Œ**ï¼šåŒä¸€å±‚çº§çš„ç‹¬ç«‹å·¥å…·å¹¶è¡Œæ‰§è¡Œ
4. **æ€§èƒ½æå‡**ï¼šç‹¬ç«‹å·¥å…·å¹¶è¡Œæ‰§è¡Œå¯æå‡ 2-5x æ€§èƒ½

---

## ä¾èµ–åˆ†æç®—æ³•

### 1. æ„å»ºä¾èµ–å›¾

```typescript
// ä¾èµ–å›¾ç¤ºä¾‹
{
  'tool-1': [],              // æ— ä¾èµ–
  'tool-2': [],              // æ— ä¾èµ–
  'tool-3': ['tool-1'],      // ä¾èµ– tool-1
  'tool-4': ['tool-2'],      // ä¾èµ– tool-2
  'tool-5': ['tool-3', 'tool-4'] // ä¾èµ– tool-3 å’Œ tool-4
}
```

### 2. æ‹“æ‰‘æ’åº

```typescript
// åˆ†å±‚ç»“æœ
[
  ['tool-1', 'tool-2'],      // ç¬¬ 1 å±‚ï¼šæ— ä¾èµ–ï¼Œå¯å¹¶è¡Œ
  ['tool-3', 'tool-4'],      // ç¬¬ 2 å±‚ï¼šä¾èµ–ç¬¬ 1 å±‚ï¼Œå¯å¹¶è¡Œ
  ['tool-5']                 // ç¬¬ 3 å±‚ï¼šä¾èµ–ç¬¬ 2 å±‚
]
```

### 3. æ‰§è¡Œç­–ç•¥

```typescript
// ç¬¬ 1 å±‚ï¼šå¹¶è¡Œæ‰§è¡Œ tool-1 å’Œ tool-2 (500ms)
await Promise.all([executeTool('tool-1'), executeTool('tool-2')]);

// ç¬¬ 2 å±‚ï¼šå¹¶è¡Œæ‰§è¡Œ tool-3 å’Œ tool-4 (500ms)
await Promise.all([executeTool('tool-3'), executeTool('tool-4')]);

// ç¬¬ 3 å±‚ï¼šæ‰§è¡Œ tool-5 (500ms)
await executeTool('tool-5');

// æ€»æ—¶é—´ï¼š1500msï¼ˆvs é¡ºåºæ‰§è¡Œçš„ 2500msï¼‰
```

---

## æ€§èƒ½æå‡åˆ†æ

### åœºæ™¯ 1ï¼š5 ä¸ªç‹¬ç«‹å·¥å…·

```
é¡ºåºæ‰§è¡Œï¼š5 Ã— 500ms = 2500ms
å¹¶è¡Œæ‰§è¡Œï¼š1 Ã— 500ms = 500ms
æ€§èƒ½æå‡ï¼š5x
```

### åœºæ™¯ 2ï¼š3 å±‚ä¾èµ–

```
é¡ºåºæ‰§è¡Œï¼š5 Ã— 500ms = 2500ms
æ‰¹å¤„ç†ï¼š3 Ã— 500ms = 1500ms
æ€§èƒ½æå‡ï¼š1.67x
```

### åœºæ™¯ 3ï¼šæ··åˆæ¨¡å¼

```
é¡ºåºæ‰§è¡Œï¼š10 Ã— 500ms = 5000ms
æ‰¹å¤„ç†ï¼š4 Ã— 500ms = 2000ms
æ€§èƒ½æå‡ï¼š2.5x
```

---

## ä¾èµ–æ£€æµ‹æ–¹å¼

### 1. å‚æ•°å¼•ç”¨æ£€æµ‹

```typescript
// æ£€æŸ¥å‚æ•°ä¸­æ˜¯å¦å¼•ç”¨äº†å…¶ä»–å·¥å…·çš„è¾“å‡º
const args = { data: '$tool-1' }; // ä¾èµ– tool-1
```

### 2. æ˜¾å¼ä¾èµ–å£°æ˜

```typescript
const tool = {
  id: 'tool-3',
  name: 'merge',
  args: {},
  dependencies: ['tool-1', 'tool-2'] // æ˜¾å¼å£°æ˜
};
```

### 3. è¯­ä¹‰åˆ†æ

```typescript
// åˆ†æå·¥å…·åç§°å’Œå‚æ•°çš„è¯­ä¹‰å…³ç³»
// ä¾‹å¦‚ï¼šwriteFile ä¾èµ– readFile
```

---

## æ‰©å±•ç»ƒä¹ 

1. **æ·»åŠ è¶…æ—¶æœºåˆ¶**ï¼šå•ä¸ªå·¥å…·æ‰§è¡Œè¶…æ—¶è‡ªåŠ¨å–æ¶ˆ
2. **æ·»åŠ é‡è¯•æœºåˆ¶**ï¼šå¤±è´¥çš„å·¥å…·è‡ªåŠ¨é‡è¯•
3. **æ·»åŠ èµ„æºé™åˆ¶**ï¼šé™åˆ¶å¹¶è¡Œæ‰§è¡Œçš„å·¥å…·æ•°é‡
4. **æ·»åŠ ä¼˜å…ˆçº§**ï¼šé«˜ä¼˜å…ˆçº§å·¥å…·ä¼˜å…ˆæ‰§è¡Œ

---

## æ€»ç»“

æ‰¹å¤„ç†ä¼˜åŒ–é€šè¿‡ä¾èµ–åˆ†æå’Œå¹¶è¡Œæ‰§è¡Œï¼Œæ˜¾è‘—æå‡äº† AI Agent çš„æ€§èƒ½ï¼š

- **ç‹¬ç«‹å·¥å…·**ï¼šæ€§èƒ½æå‡ 2-5x
- **æ··åˆæ¨¡å¼**ï¼šæ€§èƒ½æå‡ 1.5-3x
- **å®ç°å¤æ‚åº¦**ï¼šä¸­ç­‰ï¼ˆéœ€è¦ä¾èµ–åˆ†æå’Œæ‹“æ‰‘æ’åºï¼‰
- **é€‚ç”¨åœºæ™¯**ï¼šå¤šä¸ªå·¥å…·è°ƒç”¨ã€æ–‡ä»¶æ“ä½œã€API è°ƒç”¨

---

**ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2026-02-19
**ç»´æŠ¤è€…**: Claude Code

---

## ğŸ‰ æ­å–œï¼æ‰€æœ‰ 21 ä¸ªæ–‡ä»¶å·²ç”Ÿæˆå®Œæ¯•ï¼

ä½ å·²ç»å®Œæˆäº†"æ¶ˆæ¯é˜Ÿåˆ—ä¸æµå¼å“åº”"çŸ¥è¯†ç‚¹çš„å®Œæ•´å­¦ä¹ æ–‡æ¡£ï¼ŒåŒ…æ‹¬ï¼š

- **é˜¶æ®µ 1**ï¼šç®€å•ç»´åº¦ï¼ˆ3 ä¸ªæ–‡ä»¶ï¼‰âœ…
- **é˜¶æ®µ 2**ï¼šæ ¸å¿ƒæ¦‚å¿µï¼ˆ6 ä¸ªæ–‡ä»¶ï¼‰âœ…
- **é˜¶æ®µ 3**ï¼šå¤æ‚ç»´åº¦ï¼ˆ6 ä¸ªæ–‡ä»¶ï¼‰âœ…
- **é˜¶æ®µ 4**ï¼šå®æˆ˜ä»£ç ï¼ˆ7 ä¸ªæ–‡ä»¶ï¼‰âœ…

**æ€»è®¡**ï¼š21 ä¸ªæ–‡ä»¶ï¼Œçº¦ 8000-9000 è¡Œï¼Œæ¶µç›–äº†ä»åŸºç¡€æ¦‚å¿µåˆ°é«˜çº§å®æˆ˜çš„å®Œæ•´çŸ¥è¯†ä½“ç³»ã€‚
