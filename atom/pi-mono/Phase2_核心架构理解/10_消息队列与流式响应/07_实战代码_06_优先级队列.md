# 实战代码 06：优先级队列

> **目标**: 实现基于堆（Heap）的优先级队列，支持高效的入队和出队操作。

---

## 完整代码实现

```typescript
/**
 * 优先级队列实战示例
 * 演示：使用堆数据结构实现高效的优先级队列
 */

// ===== 1. 优先级队列实现 =====

/**
 * 优先级队列（最小堆实现）
 * 数字越小优先级越高
 */
export class PriorityQueue<T extends { priority: number }> {
  private heap: T[] = [];

  /**
   * 入队 - O(log n)
   */
  enqueue(item: T): void {
    this.heap.push(item);
    this.bubbleUp(this.heap.length - 1);
  }

  /**
   * 出队 - O(log n)
   */
  dequeue(): T | null {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop()!;

    const top = this.heap[0];
    this.heap[0] = this.heap.pop()!;
    this.bubbleDown(0);

    return top;
  }

  /**
   * 查看队首 - O(1)
   */
  peek(): T | null {
    return this.heap.length > 0 ? this.heap[0] : null;
  }

  /**
   * 上浮操作
   */
  private bubbleUp(index: number): void {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);

      if (this.heap[index].priority >= this.heap[parentIndex].priority) {
        break;
      }

      [this.heap[index], this.heap[parentIndex]] =
        [this.heap[parentIndex], this.heap[index]];

      index = parentIndex;
    }
  }

  /**
   * 下沉操作
   */
  private bubbleDown(index: number): void {
    while (true) {
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;
      let smallest = index;

      if (
        leftChild < this.heap.length &&
        this.heap[leftChild].priority < this.heap[smallest].priority
      ) {
        smallest = leftChild;
      }

      if (
        rightChild < this.heap.length &&
        this.heap[rightChild].priority < this.heap[smallest].priority
      ) {
        smallest = rightChild;
      }

      if (smallest === index) break;

      [this.heap[index], this.heap[smallest]] =
        [this.heap[smallest], this.heap[index]];

      index = smallest;
    }
  }

  /**
   * 获取队列大小 - O(1)
   */
  size(): number {
    return this.heap.length;
  }

  /**
   * 检查队列是否为空 - O(1)
   */
  isEmpty(): boolean {
    return this.heap.length === 0;
  }

  /**
   * 清空队列 - O(1)
   */
  clear(): void {
    this.heap = [];
  }

  /**
   * 获取所有元素（不保证顺序）
   */
  toArray(): T[] {
    return [...this.heap];
  }

  /**
   * 获取所有元素（按优先级排序）
   */
  toSortedArray(): T[] {
    const sorted: T[] = [];
    const tempQueue = new PriorityQueue<T>();

    // 复制到临时队列
    for (const item of this.heap) {
      tempQueue.enqueue(item);
    }

    // 依次出队
    while (!tempQueue.isEmpty()) {
      sorted.push(tempQueue.dequeue()!);
    }

    return sorted;
  }
}

// ===== 2. 消息优先级队列 =====

/**
 * 消息接口
 */
interface Message {
  id: string;
  type: string;
  priority: number;
  content: string;
}

/**
 * 消息优先级队列
 */
export class MessagePriorityQueue extends PriorityQueue<Message> {
  /**
   * 按类型入队（自动分配优先级）
   */
  enqueueByType(message: Omit<Message, 'priority'>): void {
    const priority = this.getPriorityByType(message.type);
    this.enqueue({ ...message, priority });
  }

  /**
   * 根据类型获取优先级
   */
  private getPriorityByType(type: string): number {
    const priorityMap: Record<string, number> = {
      'steering': 0,    // 最高优先级
      'user': 1,        // 高优先级
      'tool-result': 2, // 普通优先级
      'assistant': 3    // 低优先级
    };

    return priorityMap[type] ?? 2;
  }

  /**
   * 获取指定优先级的消息数量
   */
  countByPriority(priority: number): number {
    return this.toArray().filter(m => m.priority === priority).length;
  }

  /**
   * 获取指定类型的消息数量
   */
  countByType(type: string): number {
    return this.toArray().filter(m => m.type === type).length;
  }
}

// ===== 3. 使用示例 =====

/**
 * 示例 1：基础优先级队列
 */
function example1_BasicPriorityQueue() {
  console.log('=== 示例 1：基础优先级队列 ===\n');

  const queue = new PriorityQueue<{ id: number; priority: number }>();

  // 添加元素（乱序）
  queue.enqueue({ id: 1, priority: 5 });
  queue.enqueue({ id: 2, priority: 1 });
  queue.enqueue({ id: 3, priority: 3 });
  queue.enqueue({ id: 4, priority: 2 });
  queue.enqueue({ id: 5, priority: 4 });

  console.log('Queue size:', queue.size());

  // 按优先级出队
  console.log('Dequeue order:');
  while (!queue.isEmpty()) {
    const item = queue.dequeue();
    console.log(`- ID: ${item!.id}, Priority: ${item!.priority}`);
  }

  console.log('\n');
}

/**
 * 示例 2：消息优先级队列
 */
function example2_MessagePriorityQueue() {
  console.log('=== 示例 2：消息优先级队列 ===\n');

  const queue = new MessagePriorityQueue();

  // 添加不同类型的消息
  queue.enqueueByType({
    id: 'msg-001',
    type: 'user',
    content: 'User message'
  });

  queue.enqueueByType({
    id: 'msg-002',
    type: 'tool-result',
    content: 'Tool result'
  });

  queue.enqueueByType({
    id: 'msg-003',
    type: 'steering',
    content: 'Steering message'
  });

  queue.enqueueByType({
    id: 'msg-004',
    type: 'assistant',
    content: 'Assistant message'
  });

  // 统计
  console.log('Queue statistics:');
  console.log(`- Total: ${queue.size()}`);
  console.log(`- Steering: ${queue.countByType('steering')}`);
  console.log(`- User: ${queue.countByType('user')}`);
  console.log(`- Tool result: ${queue.countByType('tool-result')}`);
  console.log(`- Assistant: ${queue.countByType('assistant')}`);

  // 按优先级出队
  console.log('\nDequeue order:');
  while (!queue.isEmpty()) {
    const msg = queue.dequeue();
    console.log(`- [${msg!.type}] ${msg!.content} (priority: ${msg!.priority})`);
  }

  console.log('\n');
}

/**
 * 示例 3：性能对比
 */
function example3_PerformanceComparison() {
  console.log('=== 示例 3：性能对比 ===\n');

  const n = 10000;

  // 方法 1：简单数组排序
  console.log('Method 1: Array sort');
  const array: Message[] = [];
  const start1 = Date.now();

  for (let i = 0; i < n; i++) {
    array.push({
      id: `msg-${i}`,
      type: 'user',
      priority: Math.floor(Math.random() * 4),
      content: `Message ${i}`
    });
    array.sort((a, b) => a.priority - b.priority); // O(n log n) 每次
  }

  const time1 = Date.now() - start1;
  console.log(`Time: ${time1}ms`);

  // 方法 2：优先级队列（堆）
  console.log('\nMethod 2: Priority Queue (Heap)');
  const queue = new MessagePriorityQueue();
  const start2 = Date.now();

  for (let i = 0; i < n; i++) {
    queue.enqueueByType({
      id: `msg-${i}`,
      type: 'user',
      content: `Message ${i}`
    }); // O(log n) 每次
  }

  const time2 = Date.now() - start2;
  console.log(`Time: ${time2}ms`);

  console.log(`\nSpeedup: ${(time1 / time2).toFixed(2)}x`);
  console.log('\n');
}

/**
 * 示例 4：动态优先级调整
 */
function example4_DynamicPriorityAdjustment() {
  console.log('=== 示例 4：动态优先级调整 ===\n');

  const queue = new PriorityQueue<{ id: string; priority: number; content: string }>();

  // 添加初始消息
  queue.enqueue({ id: 'msg-1', priority: 2, content: 'Normal message' });
  queue.enqueue({ id: 'msg-2', priority: 2, content: 'Normal message' });
  queue.enqueue({ id: 'msg-3', priority: 2, content: 'Normal message' });

  console.log('Initial queue:');
  console.log(queue.toSortedArray().map(m => `${m.id} (${m.priority})`).join(', '));

  // 添加高优先级消息
  queue.enqueue({ id: 'msg-urgent', priority: 0, content: 'Urgent message' });

  console.log('\nAfter adding urgent message:');
  console.log(queue.toSortedArray().map(m => `${m.id} (${m.priority})`).join(', '));

  // 出队
  console.log('\nDequeue order:');
  while (!queue.isEmpty()) {
    const msg = queue.dequeue();
    console.log(`- ${msg!.id}: ${msg!.content}`);
  }

  console.log('\n');
}

// ===== 4. 运行所有示例 =====

function runAllExamples() {
  example1_BasicPriorityQueue();
  example2_MessagePriorityQueue();
  example3_PerformanceComparison();
  example4_DynamicPriorityAdjustment();
}

// 运行示例
runAllExamples();
```

---

## 核心要点

1. **堆数据结构**：使用最小堆实现，确保 O(log n) 的入队和出队性能
2. **上浮操作**：新元素添加到末尾后，向上调整到正确位置
3. **下沉操作**：删除堆顶后，将末尾元素移到堆顶，向下调整到正确位置
4. **性能优势**：比简单数组排序快 10-100 倍

---

## 时间复杂度分析

| 操作 | 简单数组排序 | 优先级队列（堆） |
|------|------------|----------------|
| 入队 | O(n log n) | O(log n) |
| 出队 | O(1) | O(log n) |
| 查看队首 | O(1) | O(1) |
| 空间复杂度 | O(n) | O(n) |

**性能提升**：
- 入队：n log n / log n = n 倍
- 对于 10000 个元素：约 1000 倍性能提升

---

## 堆的可视化

```
最小堆示例（数字越小优先级越高）：

        1
       / \
      2   3
     / \ / \
    4  5 6  7

数组表示：[1, 2, 3, 4, 5, 6, 7]

父节点索引：Math.floor((i - 1) / 2)
左子节点索引：2 * i + 1
右子节点索引：2 * i + 2
```

---

## 扩展练习

1. **添加更新优先级**：支持动态更新元素的优先级
2. **添加删除指定元素**：支持删除队列中的任意元素
3. **实现最大堆**：数字越大优先级越高
4. **添加堆排序**：使用堆实现排序算法

---

**版本**: v1.0
**最后更新**: 2026-02-19
**维护者**: Claude Code
