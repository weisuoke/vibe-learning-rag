# Binary Tree 基础定义 - 核心概念详解

> 深入理解二叉树的基础概念：节点、边、根、叶子、子树、深度、高度

---

## 概述

本文档详细讲解二叉树的7个基础概念，这些概念是理解所有树算法的基础。

**学习目标：**
- 理解二叉树的形式化定义
- 掌握节点、边、根、叶子等基本术语
- 理解深度和高度的区别
- 能够计算树的各种属性

---

## 1. 节点（Node）

### 1.1 定义

**节点**是二叉树的基本单元，包含数据和指向子节点的指针。

```python
class TreeNode:
    """二叉树节点"""
    def __init__(self, val):
        self.val = val          # 节点值（数据）
        self.left = None        # 左子节点指针
        self.right = None       # 右子节点指针
```

### 1.2 节点的组成

**三个核心部分：**
1. **数据域（val）**：存储节点的值
2. **左指针（left）**：指向左子节点
3. **右指针（right）**：指向右子节点

### 1.3 节点的类型

```python
# 1. 根节点（Root Node）
root = TreeNode(1)

# 2. 内部节点（Internal Node）：有子节点的节点
root.left = TreeNode(2)  # 节点2是内部节点

# 3. 叶子节点（Leaf Node）：没有子节点的节点
root.left.left = TreeNode(4)  # 节点4是叶子节点
root.left.right = TreeNode(5)  # 节点5是叶子节点

# 树结构：
#       1  ← 根节点
#      /
#     2    ← 内部节点
#    / \
#   4   5  ← 叶子节点
```

### 1.4 节点的属性

```python
def node_properties(node):
    """计算节点的各种属性"""
    if not node:
        return None

    properties = {
        'value': node.val,
        'is_leaf': not node.left and not node.right,
        'is_internal': node.left or node.right,
        'has_left_child': node.left is not None,
        'has_right_child': node.right is not None,
        'degree': sum([node.left is not None, node.right is not None])
    }

    return properties

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)

print(node_properties(root))
# {'value': 1, 'is_leaf': False, 'is_internal': True,
#  'has_left_child': True, 'has_right_child': True, 'degree': 2}

print(node_properties(root.left))
# {'value': 2, 'is_leaf': True, 'is_internal': False,
#  'has_left_child': False, 'has_right_child': False, 'degree': 0}
```

---

## 2. 边（Edge）

### 2.1 定义

**边**是连接两个节点的链接，表示父子关系。

```python
# 边的表示
#       1
#      / \    ← 两条边：(1,2) 和 (1,3)
#     2   3

root = TreeNode(1)
root.left = TreeNode(2)   # 创建边 (1, 2)
root.right = TreeNode(3)  # 创建边 (1, 3)
```

### 2.2 边的性质

**关键性质：**
1. **n个节点的树有 n-1 条边**
2. **边是有向的**：从父节点指向子节点
3. **边是唯一的**：任意两个节点之间最多有一条边

```python
def count_edges(root):
    """计算树的边数"""
    if not root:
        return 0

    edges = 0
    if root.left:
        edges += 1  # 左边
        edges += count_edges(root.left)
    if root.right:
        edges += 1  # 右边
        edges += count_edges(root.right)

    return edges

# 验证：n个节点有 n-1 条边
def count_nodes(root):
    if not root:
        return 0
    return 1 + count_nodes(root.left) + count_nodes(root.right)

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)

nodes = count_nodes(root)  # 4
edges = count_edges(root)  # 3
print(f"节点数: {nodes}, 边数: {edges}")  # 节点数: 4, 边数: 3
assert edges == nodes - 1  # ✅
```

### 2.3 路径（Path）

**路径**是从一个节点到另一个节点的边的序列。

```python
def find_path(root, target):
    """找到从根到目标节点的路径"""
    if not root:
        return None

    if root.val == target:
        return [root.val]

    # 在左子树中查找
    left_path = find_path(root.left, target)
    if left_path:
        return [root.val] + left_path

    # 在右子树中查找
    right_path = find_path(root.right, target)
    if right_path:
        return [root.val] + right_path

    return None

# 示例：
#       1
#      / \
#     2   3
#    /
#   4

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)

print(find_path(root, 4))  # [1, 2, 4]
print(find_path(root, 3))  # [1, 3]
```

---

## 3. 根节点（Root）

### 3.1 定义

**根节点**是树的顶层节点，没有父节点。

```python
# 根节点的特性
root = TreeNode(1)  # 根节点

# 1. 没有父节点
# 2. 是所有其他节点的祖先
# 3. 树的入口点
```

### 3.2 根节点的重要性

```python
def tree_operations_from_root(root):
    """从根节点开始的所有操作"""

    # 1. 遍历整棵树
    def traverse(node):
        if not node:
            return
        print(node.val)
        traverse(node.left)
        traverse(node.right)

    # 2. 计算树的高度
    def height(node):
        if not node:
            return 0
        return max(height(node.left), height(node.right)) + 1

    # 3. 查找节点
    def search(node, target):
        if not node:
            return None
        if node.val == target:
            return node
        return search(node.left, target) or search(node.right, target)

    return {
        'traverse': lambda: traverse(root),
        'height': lambda: height(root),
        'search': lambda target: search(root, target)
    }
```

### 3.3 空树

**空树**是没有根节点的树。

```python
# 空树的表示
empty_tree = None

# 空树的判断
def is_empty(root):
    return root is None

print(is_empty(None))  # True
print(is_empty(TreeNode(1)))  # False
```

---

## 4. 叶子节点（Leaf）

### 4.1 定义

**叶子节点**是没有子节点的节点。

```python
def is_leaf(node):
    """判断是否为叶子节点"""
    if not node:
        return False
    return node.left is None and node.right is None

# 示例：
#       1
#      / \
#     2   3  ← 叶子节点
#    /
#   4        ← 叶子节点

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)

print(is_leaf(root))        # False（有子节点）
print(is_leaf(root.left))   # False（有子节点）
print(is_leaf(root.right))  # True（叶子节点）
print(is_leaf(root.left.left))  # True（叶子节点）
```

### 4.2 统计叶子节点

```python
def count_leaves(root):
    """统计叶子节点数量"""
    if not root:
        return 0

    # 如果是叶子节点，返回1
    if not root.left and not root.right:
        return 1

    # 递归统计左右子树的叶子节点
    return count_leaves(root.left) + count_leaves(root.right)

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(count_leaves(root))  # 3（节点3、4、5）
```

### 4.3 收集所有叶子节点

```python
def collect_leaves(root):
    """收集所有叶子节点的值"""
    if not root:
        return []

    # 如果是叶子节点，返回其值
    if not root.left and not root.right:
        return [root.val]

    # 递归收集左右子树的叶子节点
    return collect_leaves(root.left) + collect_leaves(root.right)

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(collect_leaves(root))  # [4, 5, 3]
```

---

## 5. 子树（Subtree）

### 5.1 定义

**子树**是树的一部分，由某个节点及其所有后代组成。

```python
# 子树的概念
#       1
#      / \
#     2   3
#    / \
#   4   5

# 节点2的子树：
#     2
#    / \
#   4   5

# 节点3的子树：
#     3

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

# root.left 是一棵子树
left_subtree = root.left
```

### 5.2 子树的性质

```python
def subtree_properties(root):
    """计算子树的属性"""
    if not root:
        return {
            'nodes': 0,
            'height': 0,
            'leaves': 0
        }

    left_props = subtree_properties(root.left)
    right_props = subtree_properties(root.right)

    return {
        'nodes': 1 + left_props['nodes'] + right_props['nodes'],
        'height': 1 + max(left_props['height'], right_props['height']),
        'leaves': (1 if not root.left and not root.right else 0) +
                  left_props['leaves'] + right_props['leaves']
    }

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("整棵树:", subtree_properties(root))
# {'nodes': 5, 'height': 3, 'leaves': 3}

print("左子树:", subtree_properties(root.left))
# {'nodes': 3, 'height': 2, 'leaves': 2}

print("右子树:", subtree_properties(root.right))
# {'nodes': 1, 'height': 1, 'leaves': 1}
```

### 5.3 判断子树

```python
def is_subtree(s, t):
    """判断t是否为s的子树"""
    if not s:
        return False
    if is_same_tree(s, t):
        return True
    return is_subtree(s.left, t) or is_subtree(s.right, t)

def is_same_tree(p, q):
    """判断两棵树是否相同"""
    if not p and not q:
        return True
    if not p or not q:
        return False
    return (p.val == q.val and
            is_same_tree(p.left, q.left) and
            is_same_tree(p.right, q.right))

# 示例
s = TreeNode(3)
s.left = TreeNode(4)
s.right = TreeNode(5)
s.left.left = TreeNode(1)
s.left.right = TreeNode(2)

t = TreeNode(4)
t.left = TreeNode(1)
t.right = TreeNode(2)

print(is_subtree(s, t))  # True
```

---

## 6. 深度（Depth）

### 6.1 定义

**深度**是从根节点到该节点的路径长度（边的数量）。

```python
def depth(root, target, current_depth=0):
    """计算目标节点的深度"""
    if not root:
        return -1  # 未找到

    if root.val == target:
        return current_depth

    # 在左子树中查找
    left_depth = depth(root.left, target, current_depth + 1)
    if left_depth != -1:
        return left_depth

    # 在右子树中查找
    return depth(root.right, target, current_depth + 1)

# 示例：
#       1  ← 深度0
#      / \
#     2   3  ← 深度1
#    / \
#   4   5    ← 深度2

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(depth(root, 1))  # 0（根节点）
print(depth(root, 2))  # 1
print(depth(root, 3))  # 1
print(depth(root, 4))  # 2
print(depth(root, 5))  # 2
```

### 6.2 深度的性质

**关键性质：**
1. **根节点的深度为0**
2. **深度 = 父节点深度 + 1**
3. **深度是自顶向下的概念**

```python
def max_depth_value(root):
    """找到深度最大的节点值"""
    max_d = -1
    max_val = None

    def dfs(node, d):
        nonlocal max_d, max_val
        if not node:
            return

        if d > max_d:
            max_d = d
            max_val = node.val

        dfs(node.left, d + 1)
        dfs(node.right, d + 1)

    dfs(root, 0)
    return max_val, max_d

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)

val, d = max_depth_value(root)
print(f"最深节点: {val}, 深度: {d}")  # 最深节点: 4, 深度: 2
```

---

## 7. 高度（Height）

### 7.1 定义

**高度**是从该节点到叶子节点的最长路径长度（边的数量）。

```python
def height(root):
    """计算树的高度"""
    if not root:
        return 0  # 空树高度为0

    # 递归计算左右子树高度
    left_height = height(root.left)
    right_height = height(root.right)

    # 返回较大的高度 + 1
    return max(left_height, right_height) + 1

# 示例：
#       1  ← 高度3
#      / \
#     2   3  ← 高度2（节点2），高度1（节点3）
#    / \
#   4   5    ← 高度1

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(height(root))        # 3
print(height(root.left))   # 2
print(height(root.right))  # 1
print(height(root.left.left))  # 1
```

### 7.2 深度 vs 高度

**关键区别：**

| 概念 | 方向 | 起点 | 终点 | 根节点 | 叶子节点 |
|------|------|------|------|--------|---------|
| **深度** | 自顶向下 | 根节点 | 当前节点 | 深度=0 | 深度=最大 |
| **高度** | 自底向上 | 当前节点 | 叶子节点 | 高度=最大 | 高度=1 |

```python
def depth_and_height(root, target):
    """同时计算深度和高度"""
    # 计算深度
    def find_depth(node, val, d=0):
        if not node:
            return -1
        if node.val == val:
            return d
        left = find_depth(node.left, val, d + 1)
        if left != -1:
            return left
        return find_depth(node.right, val, d + 1)

    # 计算高度
    def find_height(node, val):
        if not node:
            return -1
        if node.val == val:
            return height(node)
        left = find_height(node.left, val)
        if left != -1:
            return left
        return find_height(node.right, val)

    d = find_depth(root, target)
    h = find_height(root, target)

    return {'depth': d, 'height': h}

# 示例：
#       1  ← 深度0, 高度3
#      / \
#     2   3  ← 深度1, 高度2（节点2）
#    / \
#   4   5    ← 深度2, 高度1

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(depth_and_height(root, 1))  # {'depth': 0, 'height': 3}
print(depth_and_height(root, 2))  # {'depth': 1, 'height': 2}
print(depth_and_height(root, 4))  # {'depth': 2, 'height': 1}
```

### 7.3 高度的应用

```python
# 应用1：判断平衡树
def is_balanced(root):
    """判断是否为平衡树"""
    def check(node):
        if not node:
            return 0, True

        left_h, left_bal = check(node.left)
        right_h, right_bal = check(node.right)

        # 平衡条件：|左高度 - 右高度| ≤ 1
        balanced = left_bal and right_bal and abs(left_h - right_h) <= 1
        height = max(left_h, right_h) + 1

        return height, balanced

    _, is_bal = check(root)
    return is_bal

# 应用2：计算树的直径
def diameter(root):
    """计算树的直径（任意两节点间的最长路径）"""
    max_diameter = 0

    def dfs(node):
        nonlocal max_diameter
        if not node:
            return 0

        left_h = dfs(node.left)
        right_h = dfs(node.right)

        # 更新直径：左高度 + 右高度
        max_diameter = max(max_diameter, left_h + right_h)

        return max(left_h, right_h) + 1

    dfs(root)
    return max_diameter

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(is_balanced(root))  # True
print(diameter(root))     # 3（路径：4-2-1-3 或 5-2-1-3）
```

---

## 综合示例

### 示例1：完整的树属性计算

```python
class TreeAnalyzer:
    """树分析器：计算所有属性"""

    def __init__(self, root):
        self.root = root

    def analyze(self):
        """分析树的所有属性"""
        return {
            'nodes': self.count_nodes(),
            'edges': self.count_edges(),
            'leaves': self.count_leaves(),
            'height': self.height(),
            'max_depth': self.max_depth(),
            'is_balanced': self.is_balanced(),
            'diameter': self.diameter()
        }

    def count_nodes(self):
        def count(node):
            if not node:
                return 0
            return 1 + count(node.left) + count(node.right)
        return count(self.root)

    def count_edges(self):
        return self.count_nodes() - 1 if self.root else 0

    def count_leaves(self):
        def count(node):
            if not node:
                return 0
            if not node.left and not node.right:
                return 1
            return count(node.left) + count(node.right)
        return count(self.root)

    def height(self):
        def h(node):
            if not node:
                return 0
            return max(h(node.left), h(node.right)) + 1
        return h(self.root)

    def max_depth(self):
        return self.height() - 1 if self.root else 0

    def is_balanced(self):
        def check(node):
            if not node:
                return 0, True
            left_h, left_bal = check(node.left)
            right_h, right_bal = check(node.right)
            balanced = left_bal and right_bal and abs(left_h - right_h) <= 1
            height = max(left_h, right_h) + 1
            return height, balanced
        _, is_bal = check(self.root)
        return is_bal

    def diameter(self):
        max_d = 0
        def dfs(node):
            nonlocal max_d
            if not node:
                return 0
            left_h = dfs(node.left)
            right_h = dfs(node.right)
            max_d = max(max_d, left_h + right_h)
            return max(left_h, right_h) + 1
        dfs(self.root)
        return max_d

# 使用示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

analyzer = TreeAnalyzer(root)
print(analyzer.analyze())
# {
#   'nodes': 5,
#   'edges': 4,
#   'leaves': 3,
#   'height': 3,
#   'max_depth': 2,
#   'is_balanced': True,
#   'diameter': 3
# }
```

### 示例2：可视化树结构

```python
def print_tree(root, level=0, prefix="Root: "):
    """打印树的结构"""
    if root:
        print(" " * (level * 4) + prefix + str(root.val))
        if root.left or root.right:
            if root.left:
                print_tree(root.left, level + 1, "L--- ")
            else:
                print(" " * ((level + 1) * 4) + "L--- None")

            if root.right:
                print_tree(root.right, level + 1, "R--- ")
            else:
                print(" " * ((level + 1) * 4) + "R--- None")

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print_tree(root)
# 输出：
# Root: 1
#     L--- 2
#         L--- 4
#         R--- 5
#     R--- 3
```

---

## 学习检查清单

完成本文档学习后，你应该能够：

- [ ] 定义并实现 TreeNode 类
- [ ] 区分根节点、内部节点、叶子节点
- [ ] 理解边和路径的概念
- [ ] 计算树的节点数和边数
- [ ] 理解子树的概念
- [ ] 计算节点的深度
- [ ] 计算节点的高度
- [ ] 区分深度和高度
- [ ] 判断树是否平衡
- [ ] 计算树的直径

---

## 参考资源

### 官方文档
- [Python Data Structures](https://docs.python.org/3/tutorial/datastructures.html)

### 教程
- [GeeksforGeeks - Binary Tree](https://www.geeksforgeeks.org/binary-tree-data-structure/)
- [W3Schools - Python Binary Trees](https://www.w3schools.com/python/python_dsa_binarytrees.asp)

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+, AI Agent 开发, RAG 系统
**学习时间**: 30-40 分钟
