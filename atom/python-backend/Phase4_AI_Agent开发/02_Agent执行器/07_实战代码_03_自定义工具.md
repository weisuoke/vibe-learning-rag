# Agentæ‰§è¡Œå™¨ - å®æˆ˜ä»£ç 3ï¼šè‡ªå®šä¹‰å·¥å…·

> åˆ›å»ºè‡ªå®šä¹‰å·¥å…·ï¼Œæ‰©å±• Agent èƒ½åŠ›

---

## å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬æ–‡æ¡£ï¼Œä½ å°†å­¦ä¼šï¼š
- åˆ›å»ºè‡ªå®šä¹‰å·¥å…·ï¼ˆæ•°æ®åº“æŸ¥è¯¢ã€APIè°ƒç”¨ï¼‰
- å®ç°å·¥å…·å‚æ•°éªŒè¯
- å¤„ç†å·¥å…·æ‰§è¡Œé”™è¯¯
- å®ç°å¼‚æ­¥å·¥å…·
- å·¥å…·è®¾è®¡çš„æœ€ä½³å®è·µ

---

## ç¤ºä¾‹1ï¼šæ•°æ®åº“æŸ¥è¯¢å·¥å…·

### å®Œæ•´ä»£ç 

```python
"""
æ•°æ®åº“æŸ¥è¯¢å·¥å…·
æ¼”ç¤ºå¦‚ä½•åˆ›å»ºè®¿é—®æ•°æ®åº“çš„å·¥å…·
"""

from langchain.tools import tool
from langchain.agents import AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate
import asyncpg
from typing import Optional

# ===== 1. æ•°æ®åº“è¿æ¥æ± ï¼ˆå…¨å±€å˜é‡ï¼‰=====
db_pool: Optional[asyncpg.Pool] = None

async def init_db():
    """åˆå§‹åŒ–æ•°æ®åº“è¿æ¥æ± """
    global db_pool
    db_pool = await asyncpg.create_pool(
        host="localhost",
        port=5432,
        user="postgres",
        password="password",
        database="mydb",
        min_size=5,
        max_size=20,
    )
    print("æ•°æ®åº“è¿æ¥æ± å·²åˆå§‹åŒ–")

async def close_db():
    """å…³é—­æ•°æ®åº“è¿æ¥æ± """
    global db_pool
    if db_pool:
        await db_pool.close()
        print("æ•°æ®åº“è¿æ¥æ± å·²å…³é—­")

# ===== 2. å®šä¹‰æ•°æ®åº“æŸ¥è¯¢å·¥å…· =====

@tool
async def query_order(order_id: str) -> str:
    """
    æŸ¥è¯¢è®¢å•ä¿¡æ¯

    è¾“å…¥ï¼šè®¢å•IDï¼ˆ5ä½æ•°å­—ï¼Œå¦‚ '12345'ï¼‰
    è¾“å‡ºï¼šè®¢å•çŠ¶æ€ã€é‡‘é¢ã€æ”¶è´§åœ°å€ç­‰ä¿¡æ¯

    é€‚ç”¨åœºæ™¯ï¼š
    - ç”¨æˆ·è¯¢é—®è®¢å•çŠ¶æ€
    - ç”¨æˆ·è¯¢é—®è®¢å•è¯¦æƒ…
    """
    try:
        # éªŒè¯å‚æ•°
        if not order_id.isdigit() or len(order_id) != 5:
            return "é”™è¯¯ï¼šè®¢å•IDå¿…é¡»æ˜¯5ä½æ•°å­—"

        # æŸ¥è¯¢æ•°æ®åº“
        async with db_pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT id, status, amount, address, created_at
                FROM orders
                WHERE id = $1
                """,
                order_id
            )

            if not row:
                return f"è®¢å• {order_id} ä¸å­˜åœ¨"

            # æ ¼å¼åŒ–ç»“æœ
            return f"""
è®¢å•IDï¼š{row['id']}
çŠ¶æ€ï¼š{row['status']}
é‡‘é¢ï¼š{row['amount']}å…ƒ
æ”¶è´§åœ°å€ï¼š{row['address']}
ä¸‹å•æ—¶é—´ï¼š{row['created_at']}
"""
    except Exception as e:
        return f"æŸ¥è¯¢å¤±è´¥ï¼š{str(e)}"

@tool
async def query_user(user_id: str) -> str:
    """
    æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯

    è¾“å…¥ï¼šç”¨æˆ·ID
    è¾“å‡ºï¼šç”¨æˆ·åã€é‚®ç®±ã€æ³¨å†Œæ—¶é—´ç­‰ä¿¡æ¯
    """
    try:
        async with db_pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT id, username, email, created_at
                FROM users
                WHERE id = $1
                """,
                user_id
            )

            if not row:
                return f"ç”¨æˆ· {user_id} ä¸å­˜åœ¨"

            return f"""
ç”¨æˆ·IDï¼š{row['id']}
ç”¨æˆ·åï¼š{row['username']}
é‚®ç®±ï¼š{row['email']}
æ³¨å†Œæ—¶é—´ï¼š{row['created_at']}
"""
    except Exception as e:
        return f"æŸ¥è¯¢å¤±è´¥ï¼š{str(e)}"

@tool
async def query_sales_summary(month: str) -> str:
    """
    æŸ¥è¯¢é”€å”®æ±‡æ€»æ•°æ®

    è¾“å…¥ï¼šæœˆä»½ï¼ˆæ ¼å¼ï¼š'YYYY-MM' æˆ– 'last_month'ï¼‰
    è¾“å‡ºï¼šæ¯ä¸ªäº§å“çš„æ€»é”€å”®é¢

    é€‚ç”¨åœºæ™¯ï¼š
    - ç”¨æˆ·è¯¢é—®"å“ªä¸ªäº§å“é”€å”®é¢æœ€é«˜"
    - ç”¨æˆ·è¯¢é—®"ä¸Šä¸ªæœˆé”€å”®æƒ…å†µ"
    """
    try:
        # å¤„ç† 'last_month'
        if month == 'last_month':
            month_condition = "DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')"
        else:
            month_condition = f"'{month}-01'::date"

        async with db_pool.acquire() as conn:
            rows = await conn.fetch(
                f"""
                SELECT product_name, SUM(amount) as total_sales
                FROM sales
                WHERE DATE_TRUNC('month', sale_date) = {month_condition}
                GROUP BY product_name
                ORDER BY total_sales DESC
                """
            )

            if not rows:
                return f"æ²¡æœ‰æ‰¾åˆ° {month} çš„é”€å”®æ•°æ®"

            # æ ¼å¼åŒ–ç»“æœ
            result = f"{month} é”€å”®æ±‡æ€»ï¼š\n"
            for row in rows:
                result += f"- {row['product_name']}: {row['total_sales']}å…ƒ\n"

            return result
    except Exception as e:
        return f"æŸ¥è¯¢å¤±è´¥ï¼š{str(e)}"

# ===== 3. åˆ›å»º Agent =====
async def create_db_agent():
    """åˆ›å»ºæ•°æ®åº“æŸ¥è¯¢ Agent"""

    # åˆå§‹åŒ–æ•°æ®åº“
    await init_db()

    # åˆ›å»º LLM
    llm = ChatOpenAI(model="gpt-4", temperature=0)

    # å®šä¹‰å·¥å…·
    tools = [query_order, query_user, query_sales_summary]

    # å®šä¹‰ Prompt
    prompt = PromptTemplate.from_template("""
ä½ æ˜¯ä¸€ä¸ªæ•°æ®åº“æŸ¥è¯¢åŠ©æ‰‹ã€‚

ä½ æœ‰ä»¥ä¸‹å·¥å…·å¯ç”¨ï¼š
{tools}

ä½¿ç”¨ä»¥ä¸‹æ ¼å¼å›ç­”ï¼š

Question: {input}
Thought: {agent_scratchpad}
""")

    # åˆ›å»º Agent
    agent = create_react_agent(llm, tools, prompt)

    # åˆ›å»º AgentExecutor
    executor = AgentExecutor(
        agent=agent,
        tools=tools,
        verbose=True,
        max_iterations=10,
    )

    return executor

# ===== 4. æµ‹è¯• =====
async def main():
    executor = await create_db_agent()

    questions = [
        "è®¢å•12345çš„è¯¦æƒ…æ˜¯ä»€ä¹ˆï¼Ÿ",
        "ç”¨æˆ·user001çš„ä¿¡æ¯",
        "ä¸Šä¸ªæœˆé”€å”®é¢æœ€é«˜çš„äº§å“æ˜¯ä»€ä¹ˆï¼Ÿ",
    ]

    for question in questions:
        print(f"\n{'='*60}")
        print(f"é—®é¢˜ï¼š{question}")
        print('='*60)

        result = await executor.ainvoke({"input": question})
        print(f"\nç­”æ¡ˆï¼š{result['output']}")

    # å…³é—­æ•°æ®åº“
    await close_db()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

---

## ç¤ºä¾‹2ï¼šAPI è°ƒç”¨å·¥å…·

### å®Œæ•´ä»£ç 

```python
"""
API è°ƒç”¨å·¥å…·
æ¼”ç¤ºå¦‚ä½•åˆ›å»ºè°ƒç”¨å¤–éƒ¨ API çš„å·¥å…·
"""

from langchain.tools import tool
import httpx
from typing import Optional
import json

# ===== 1. å®šä¹‰ API è°ƒç”¨å·¥å…· =====

@tool
async def query_weather(city: str) -> str:
    """
    æŸ¥è¯¢å¤©æ°”ä¿¡æ¯

    è¾“å…¥ï¼šåŸå¸‚åç§°ï¼ˆå¦‚ 'åŒ—äº¬'ã€'ä¸Šæµ·'ï¼‰
    è¾“å‡ºï¼šå½“å‰å¤©æ°”ã€æ¸©åº¦ã€æ¹¿åº¦ç­‰ä¿¡æ¯

    é€‚ç”¨åœºæ™¯ï¼š
    - ç”¨æˆ·è¯¢é—®å¤©æ°”
    - ç”¨æˆ·è¯¢é—®æ¸©åº¦
    """
    try:
        async with httpx.AsyncClient() as client:
            # è°ƒç”¨å¤©æ°” API
            response = await client.get(
                "https://api.weather.com/v1/current",
                params={
                    "city": city,
                    "key": "YOUR_API_KEY",
                    "lang": "zh",
                },
                timeout=10.0,
            )

            # æ£€æŸ¥å“åº”çŠ¶æ€
            if response.status_code != 200:
                return f"API è°ƒç”¨å¤±è´¥ï¼šHTTP {response.status_code}"

            # è§£æå“åº”
            data = response.json()

            # æ ¼å¼åŒ–ç»“æœ
            return f"""
åŸå¸‚ï¼š{city}
å¤©æ°”ï¼š{data['weather']}
æ¸©åº¦ï¼š{data['temperature']}Â°C
æ¹¿åº¦ï¼š{data['humidity']}%
é£é€Ÿï¼š{data['wind_speed']}m/s
"""
    except httpx.TimeoutException:
        return f"æŸ¥è¯¢è¶…æ—¶ï¼šAPI å“åº”æ—¶é—´è¿‡é•¿"
    except httpx.RequestError as e:
        return f"ç½‘ç»œé”™è¯¯ï¼š{str(e)}"
    except json.JSONDecodeError:
        return "è§£æé”™è¯¯ï¼šAPI è¿”å›çš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®"
    except Exception as e:
        return f"æŸ¥è¯¢å¤±è´¥ï¼š{str(e)}"

@tool
async def translate_text(text: str, target_lang: str = "en") -> str:
    """
    ç¿»è¯‘æ–‡æœ¬

    è¾“å…¥ï¼š
    - text: è¦ç¿»è¯‘çš„æ–‡æœ¬
    - target_lang: ç›®æ ‡è¯­è¨€ï¼ˆ'en', 'zh', 'ja' ç­‰ï¼‰

    è¾“å‡ºï¼šç¿»è¯‘åçš„æ–‡æœ¬
    """
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "https://api.translate.com/v1/translate",
                json={
                    "text": text,
                    "target_lang": target_lang,
                    "api_key": "YOUR_API_KEY",
                },
                timeout=10.0,
            )

            if response.status_code != 200:
                return f"ç¿»è¯‘å¤±è´¥ï¼šHTTP {response.status_code}"

            data = response.json()
            return f"ç¿»è¯‘ç»“æœï¼š{data['translated_text']}"

    except Exception as e:
        return f"ç¿»è¯‘å¤±è´¥ï¼š{str(e)}"

@tool
async def search_news(keyword: str, limit: int = 5) -> str:
    """
    æœç´¢æ–°é—»

    è¾“å…¥ï¼š
    - keyword: æœç´¢å…³é”®è¯
    - limit: è¿”å›ç»“æœæ•°é‡ï¼ˆé»˜è®¤5æ¡ï¼‰

    è¾“å‡ºï¼šæ–°é—»æ ‡é¢˜å’Œæ‘˜è¦åˆ—è¡¨
    """
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://api.news.com/v1/search",
                params={
                    "q": keyword,
                    "limit": limit,
                    "api_key": "YOUR_API_KEY",
                },
                timeout=10.0,
            )

            if response.status_code != 200:
                return f"æœç´¢å¤±è´¥ï¼šHTTP {response.status_code}"

            data = response.json()
            articles = data.get('articles', [])

            if not articles:
                return f"æ²¡æœ‰æ‰¾åˆ°å…³äº '{keyword}' çš„æ–°é—»"

            # æ ¼å¼åŒ–ç»“æœ
            result = f"å…³äº '{keyword}' çš„æ–°é—»ï¼š\n\n"
            for i, article in enumerate(articles, 1):
                result += f"{i}. {article['title']}\n"
                result += f"   {article['summary']}\n"
                result += f"   æ¥æºï¼š{article['source']} | {article['published_at']}\n\n"

            return result

    except Exception as e:
        return f"æœç´¢å¤±è´¥ï¼š{str(e)}"
```

---

## ç¤ºä¾‹3ï¼šæ–‡ä»¶æ“ä½œå·¥å…·

### å®Œæ•´ä»£ç 

```python
"""
æ–‡ä»¶æ“ä½œå·¥å…·
æ¼”ç¤ºå¦‚ä½•åˆ›å»ºæ–‡ä»¶æ“ä½œå·¥å…·
"""

from langchain.tools import tool
import os
from pathlib import Path
from typing import List

# ===== 1. å®šä¹‰æ–‡ä»¶æ“ä½œå·¥å…· =====

@tool
def list_files(directory: str = ".") -> str:
    """
    åˆ—å‡ºç›®å½•ä¸­çš„æ–‡ä»¶

    è¾“å…¥ï¼šç›®å½•è·¯å¾„ï¼ˆé»˜è®¤å½“å‰ç›®å½•ï¼‰
    è¾“å‡ºï¼šæ–‡ä»¶åˆ—è¡¨

    é€‚ç”¨åœºæ™¯ï¼š
    - ç”¨æˆ·è¯¢é—®"æœ‰å“ªäº›æ–‡ä»¶"
    - ç”¨æˆ·è¯¢é—®"ç›®å½•ç»“æ„"
    """
    try:
        # éªŒè¯ç›®å½•
        path = Path(directory)
        if not path.exists():
            return f"ç›®å½• {directory} ä¸å­˜åœ¨"

        if not path.is_dir():
            return f"{directory} ä¸æ˜¯ä¸€ä¸ªç›®å½•"

        # åˆ—å‡ºæ–‡ä»¶
        files = []
        for item in path.iterdir():
            if item.is_file():
                size = item.stat().st_size
                files.append(f"ğŸ“„ {item.name} ({size} bytes)")
            elif item.is_dir():
                files.append(f"ğŸ“ {item.name}/")

        if not files:
            return f"ç›®å½• {directory} æ˜¯ç©ºçš„"

        return f"ç›®å½• {directory} ä¸­çš„æ–‡ä»¶ï¼š\n" + "\n".join(files)

    except PermissionError:
        return f"æƒé™é”™è¯¯ï¼šæ— æ³•è®¿é—®ç›®å½• {directory}"
    except Exception as e:
        return f"åˆ—å‡ºæ–‡ä»¶å¤±è´¥ï¼š{str(e)}"

@tool
def read_file(file_path: str, max_lines: int = 100) -> str:
    """
    è¯»å–æ–‡ä»¶å†…å®¹

    è¾“å…¥ï¼š
    - file_path: æ–‡ä»¶è·¯å¾„
    - max_lines: æœ€å¤§è¯»å–è¡Œæ•°ï¼ˆé»˜è®¤100è¡Œï¼‰

    è¾“å‡ºï¼šæ–‡ä»¶å†…å®¹

    é€‚ç”¨åœºæ™¯ï¼š
    - ç”¨æˆ·è¯¢é—®"æ–‡ä»¶å†…å®¹æ˜¯ä»€ä¹ˆ"
    - ç”¨æˆ·è¯¢é—®"è¯»å–æ–‡ä»¶"
    """
    try:
        # éªŒè¯æ–‡ä»¶
        path = Path(file_path)
        if not path.exists():
            return f"æ–‡ä»¶ {file_path} ä¸å­˜åœ¨"

        if not path.is_file():
            return f"{file_path} ä¸æ˜¯ä¸€ä¸ªæ–‡ä»¶"

        # è¯»å–æ–‡ä»¶
        with open(path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        # é™åˆ¶è¡Œæ•°
        if len(lines) > max_lines:
            content = ''.join(lines[:max_lines])
            content += f"\n\n... (æ–‡ä»¶è¿˜æœ‰ {len(lines) - max_lines} è¡Œï¼Œå·²çœç•¥)"
        else:
            content = ''.join(lines)

        return f"æ–‡ä»¶ {file_path} çš„å†…å®¹ï¼š\n\n{content}"

    except UnicodeDecodeError:
        return f"è§£ç é”™è¯¯ï¼šæ–‡ä»¶ {file_path} ä¸æ˜¯æ–‡æœ¬æ–‡ä»¶"
    except PermissionError:
        return f"æƒé™é”™è¯¯ï¼šæ— æ³•è¯»å–æ–‡ä»¶ {file_path}"
    except Exception as e:
        return f"è¯»å–æ–‡ä»¶å¤±è´¥ï¼š{str(e)}"

@tool
def search_in_files(keyword: str, directory: str = ".", file_extension: str = ".py") -> str:
    """
    åœ¨æ–‡ä»¶ä¸­æœç´¢å…³é”®è¯

    è¾“å…¥ï¼š
    - keyword: æœç´¢å…³é”®è¯
    - directory: æœç´¢ç›®å½•ï¼ˆé»˜è®¤å½“å‰ç›®å½•ï¼‰
    - file_extension: æ–‡ä»¶æ‰©å±•åï¼ˆé»˜è®¤ .pyï¼‰

    è¾“å‡ºï¼šåŒ…å«å…³é”®è¯çš„æ–‡ä»¶åˆ—è¡¨

    é€‚ç”¨åœºæ™¯ï¼š
    - ç”¨æˆ·è¯¢é—®"å“ªäº›æ–‡ä»¶åŒ…å«æŸä¸ªå…³é”®è¯"
    - ç”¨æˆ·è¯¢é—®"æœç´¢ä»£ç "
    """
    try:
        path = Path(directory)
        if not path.exists() or not path.is_dir():
            return f"ç›®å½• {directory} ä¸å­˜åœ¨æˆ–ä¸æ˜¯ç›®å½•"

        # æœç´¢æ–‡ä»¶
        results = []
        for file_path in path.rglob(f"*{file_extension}"):
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    if keyword in content:
                        # ç»Ÿè®¡å‡ºç°æ¬¡æ•°
                        count = content.count(keyword)
                        results.append(f"{file_path}: {count} æ¬¡")
            except:
                continue

        if not results:
            return f"æ²¡æœ‰æ‰¾åˆ°åŒ…å« '{keyword}' çš„ {file_extension} æ–‡ä»¶"

        return f"åŒ…å« '{keyword}' çš„æ–‡ä»¶ï¼š\n" + "\n".join(results)

    except Exception as e:
        return f"æœç´¢å¤±è´¥ï¼š{str(e)}"
```

---

## ç¤ºä¾‹4ï¼šå¤æ‚å‚æ•°å·¥å…·

### ä½¿ç”¨ StructuredTool

```python
"""
å¤æ‚å‚æ•°å·¥å…·
æ¼”ç¤ºå¦‚ä½•åˆ›å»ºå¸¦æœ‰å¤šä¸ªå‚æ•°å’ŒéªŒè¯çš„å·¥å…·
"""

from langchain.tools import StructuredTool
from pydantic import BaseModel, Field, validator
from typing import Optional, List

# ===== 1. å®šä¹‰å‚æ•°æ¨¡å‹ =====

class QueryOrderInput(BaseModel):
    """æŸ¥è¯¢è®¢å•çš„å‚æ•°æ¨¡å‹"""
    order_id: str = Field(description="è®¢å•IDï¼ˆ5ä½æ•°å­—ï¼‰")
    include_items: bool = Field(default=False, description="æ˜¯å¦åŒ…å«è®¢å•å•†å“åˆ—è¡¨")
    include_logistics: bool = Field(default=False, description="æ˜¯å¦åŒ…å«ç‰©æµä¿¡æ¯")

    @validator('order_id')
    def validate_order_id(cls, v):
        if not v.isdigit():
            raise ValueError("è®¢å•IDå¿…é¡»æ˜¯æ•°å­—")
        if len(v) != 5:
            raise ValueError("è®¢å•IDå¿…é¡»æ˜¯5ä½æ•°å­—")
        return v

class SearchProductInput(BaseModel):
    """æœç´¢äº§å“çš„å‚æ•°æ¨¡å‹"""
    keyword: str = Field(description="æœç´¢å…³é”®è¯")
    category: Optional[str] = Field(default=None, description="äº§å“ç±»åˆ«")
    min_price: Optional[float] = Field(default=None, description="æœ€ä½ä»·æ ¼")
    max_price: Optional[float] = Field(default=None, description="æœ€é«˜ä»·æ ¼")
    limit: int = Field(default=10, description="è¿”å›ç»“æœæ•°é‡")

    @validator('min_price', 'max_price')
    def validate_price(cls, v):
        if v is not None and v < 0:
            raise ValueError("ä»·æ ¼ä¸èƒ½ä¸ºè´Ÿæ•°")
        return v

    @validator('limit')
    def validate_limit(cls, v):
        if v < 1 or v > 100:
            raise ValueError("è¿”å›ç»“æœæ•°é‡å¿…é¡»åœ¨1-100ä¹‹é—´")
        return v

# ===== 2. å®šä¹‰å·¥å…·å‡½æ•° =====

def query_order_impl(
    order_id: str,
    include_items: bool = False,
    include_logistics: bool = False
) -> str:
    """æŸ¥è¯¢è®¢å•ä¿¡æ¯çš„å®ç°"""
    # æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    result = f"è®¢å• {order_id}ï¼š\n"
    result += "çŠ¶æ€ï¼šå·²å‘è´§\n"
    result += "é‡‘é¢ï¼š299å…ƒ\n"

    if include_items:
        result += "\nå•†å“åˆ—è¡¨ï¼š\n"
        result += "- äº§å“A x 1\n"
        result += "- äº§å“B x 2\n"

    if include_logistics:
        result += "\nç‰©æµä¿¡æ¯ï¼š\n"
        result += "å¿«é€’å…¬å¸ï¼šé¡ºä¸°\n"
        result += "è¿å•å·ï¼šSF1234567890\n"

    return result

def search_product_impl(
    keyword: str,
    category: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    limit: int = 10
) -> str:
    """æœç´¢äº§å“çš„å®ç°"""
    # æ¨¡æ‹Ÿæœç´¢
    result = f"æœç´¢ '{keyword}' çš„ç»“æœï¼š\n\n"

    # åº”ç”¨è¿‡æ»¤æ¡ä»¶
    filters = []
    if category:
        filters.append(f"ç±»åˆ«ï¼š{category}")
    if min_price:
        filters.append(f"æœ€ä½ä»·æ ¼ï¼š{min_price}å…ƒ")
    if max_price:
        filters.append(f"æœ€é«˜ä»·æ ¼ï¼š{max_price}å…ƒ")

    if filters:
        result += "è¿‡æ»¤æ¡ä»¶ï¼š" + ", ".join(filters) + "\n\n"

    # æ¨¡æ‹Ÿç»“æœ
    for i in range(min(limit, 3)):
        result += f"{i+1}. äº§å“{i+1}\n"
        result += f"   ä»·æ ¼ï¼š{100 + i*50}å…ƒ\n"
        result += f"   ç±»åˆ«ï¼š{category or 'ç”µå­äº§å“'}\n\n"

    return result

# ===== 3. åˆ›å»º StructuredTool =====

query_order_tool = StructuredTool(
    name="query_order",
    description="æŸ¥è¯¢è®¢å•ä¿¡æ¯ï¼Œå¯ä»¥é€‰æ‹©æ˜¯å¦åŒ…å«å•†å“åˆ—è¡¨å’Œç‰©æµä¿¡æ¯",
    func=query_order_impl,
    args_schema=QueryOrderInput,
)

search_product_tool = StructuredTool(
    name="search_product",
    description="æœç´¢äº§å“ï¼Œæ”¯æŒæŒ‰ç±»åˆ«ã€ä»·æ ¼èŒƒå›´è¿‡æ»¤",
    func=search_product_impl,
    args_schema=SearchProductInput,
)

# ===== 4. ä½¿ç”¨å·¥å…· =====
if __name__ == "__main__":
    # æµ‹è¯•å·¥å…·
    print("æµ‹è¯•1ï¼šæŸ¥è¯¢è®¢å•")
    result = query_order_tool.run({
        "order_id": "12345",
        "include_items": True,
        "include_logistics": True,
    })
    print(result)

    print("\næµ‹è¯•2ï¼šæœç´¢äº§å“")
    result = search_product_tool.run({
        "keyword": "æ‰‹æœº",
        "category": "ç”µå­äº§å“",
        "min_price": 1000,
        "max_price": 5000,
        "limit": 5,
    })
    print(result)
```

---

## å·¥å…·è®¾è®¡çš„æœ€ä½³å®è·µ

### 1. æ¸…æ™°çš„å·¥å…·æè¿°

```python
@tool
def good_tool(param: str) -> str:
    """
    [ä¸€å¥è¯åŠŸèƒ½æè¿°]

    åŠŸèƒ½ï¼š[è¯¦ç»†åŠŸèƒ½è¯´æ˜]

    è¾“å…¥ï¼š
    - param: [å‚æ•°è¯´æ˜]

    è¾“å‡ºï¼š
    - [è¾“å‡ºè¯´æ˜]

    é€‚ç”¨åœºæ™¯ï¼š
    - [åœºæ™¯1]
    - [åœºæ™¯2]

    ç¤ºä¾‹ï¼š
    è¾“å…¥ï¼š[ç¤ºä¾‹è¾“å…¥]
    è¾“å‡ºï¼š[ç¤ºä¾‹è¾“å‡º]
    """
    # å®ç°...
```

---

### 2. å‚æ•°éªŒè¯

```python
@tool
def query_order(order_id: str) -> str:
    """æŸ¥è¯¢è®¢å•ä¿¡æ¯"""
    # éªŒè¯å‚æ•°
    if not order_id.isdigit():
        return "é”™è¯¯ï¼šè®¢å•IDå¿…é¡»æ˜¯æ•°å­—"

    if len(order_id) != 5:
        return "é”™è¯¯ï¼šè®¢å•IDå¿…é¡»æ˜¯5ä½æ•°å­—"

    # æ‰§è¡ŒæŸ¥è¯¢
    # ...
```

---

### 3. é”™è¯¯å¤„ç†

```python
@tool
async def query_api(url: str) -> str:
    """è°ƒç”¨ API"""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, timeout=10.0)
            return response.text
    except httpx.TimeoutException:
        return "é”™è¯¯ï¼šAPI å“åº”è¶…æ—¶"
    except httpx.RequestError as e:
        return f"é”™è¯¯ï¼šç½‘ç»œè¯·æ±‚å¤±è´¥ - {str(e)}"
    except Exception as e:
        return f"é”™è¯¯ï¼š{str(e)}"
```

---

### 4. å¼‚æ­¥å·¥å…·

```python
# æ¨èï¼šä½¿ç”¨å¼‚æ­¥å·¥å…·
@tool
async def query_db(query: str) -> str:
    """å¼‚æ­¥æŸ¥è¯¢æ•°æ®åº“"""
    async with db_pool.acquire() as conn:
        result = await conn.fetch(query)
        return str(result)

# ä½¿ç”¨
result = await query_db.arun("SELECT * FROM users")
```

---

### 5. èµ„æºç®¡ç†

```python
# ä½¿ç”¨è¿æ¥æ± 
db_pool = None

async def init_db():
    global db_pool
    db_pool = await asyncpg.create_pool(...)

async def close_db():
    global db_pool
    if db_pool:
        await db_pool.close()

# åœ¨å·¥å…·ä¸­ä½¿ç”¨è¿æ¥æ± 
@tool
async def query_db(query: str) -> str:
    async with db_pool.acquire() as conn:
        result = await conn.fetch(query)
        return str(result)
```

---

## å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] åˆ›å»ºæ•°æ®åº“æŸ¥è¯¢å·¥å…·
- [ ] åˆ›å»º API è°ƒç”¨å·¥å…·
- [ ] åˆ›å»ºæ–‡ä»¶æ“ä½œå·¥å…·
- [ ] ä½¿ç”¨ StructuredTool å¤„ç†å¤æ‚å‚æ•°
- [ ] å®ç°å‚æ•°éªŒè¯
- [ ] å¤„ç†å·¥å…·æ‰§è¡Œé”™è¯¯
- [ ] å®ç°å¼‚æ­¥å·¥å…·
- [ ] ç®¡ç†èµ„æºï¼ˆæ•°æ®åº“è¿æ¥æ± ç­‰ï¼‰
- [ ] åº”ç”¨å·¥å…·è®¾è®¡çš„æœ€ä½³å®è·µ

---

## ä¸‹ä¸€æ­¥å­¦ä¹ 

- **æ‰§è¡Œæ§åˆ¶**ï¼š`07_å®æˆ˜ä»£ç _04_æ‰§è¡Œæ§åˆ¶.md`
- **FastAPIé›†æˆ**ï¼š`07_å®æˆ˜ä»£ç _05_FastAPIé›†æˆ.md`
- **ç”Ÿäº§å®è·µ**ï¼š`07_å®æˆ˜ä»£ç _06_ç”Ÿäº§å®è·µ.md`

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2026-02-12
**ç»´æŠ¤è€…ï¼š** Claude Code
