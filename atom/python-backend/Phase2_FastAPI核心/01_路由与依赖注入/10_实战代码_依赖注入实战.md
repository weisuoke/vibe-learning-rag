# 实战代码：依赖注入实战

> 完整可运行的依赖注入示例，从数据库连接到认证授权

---

## 场景1：数据库连接管理

**目标：** 使用依赖注入管理数据库连接

```python
"""
数据库连接管理示例
演示：使用依赖注入管理 SQLAlchemy 数据库连接
"""

from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from pydantic import BaseModel
from typing import List

# ===== 数据库配置 =====

DATABASE_URL = "sqlite:///./test.db"  # 使用 SQLite 作为示例

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}  # SQLite 需要
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ===== 数据库模型 =====

class UserDB(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    full_name = Column(String)

# 创建表
Base.metadata.create_all(bind=engine)

# ===== Pydantic 模型 =====

class UserCreate(BaseModel):
    username: str
    email: str
    full_name: str

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    full_name: str

    class Config:
        from_attributes = True

# ===== 依赖注入：数据库连接 =====

def get_db():
    """
    数据库连接依赖
    - 请求开始时创建连接
    - 请求结束时自动关闭连接
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ===== FastAPI 应用 =====

app = FastAPI()

# ===== 路由 =====

@app.post("/users", response_model=UserResponse, status_code=201)
async def create_user(
    user: UserCreate,
    db: Session = Depends(get_db)  # 注入数据库连接
):
    """创建用户"""
    # 检查用户名是否已存在
    existing_user = db.query(UserDB).filter(UserDB.username == user.username).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="用户名已存在")

    # 创建用户
    db_user = UserDB(
        username=user.username,
        email=user.email,
        full_name=user.full_name
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)

    return db_user

@app.get("/users", response_model=List[UserResponse])
async def list_users(
    skip: int = 0,
    limit: int = 10,
    db: Session = Depends(get_db)  # 注入数据库连接
):
    """获取用户列表"""
    users = db.query(UserDB).offset(skip).limit(limit).all()
    return users

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    db: Session = Depends(get_db)  # 注入数据库连接
):
    """获取用户详情"""
    user = db.query(UserDB).filter(UserDB.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="用户不存在")
    return user

@app.delete("/users/{user_id}", status_code=204)
async def delete_user(
    user_id: int,
    db: Session = Depends(get_db)  # 注入数据库连接
):
    """删除用户"""
    user = db.query(UserDB).filter(UserDB.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="用户不存在")

    db.delete(user)
    db.commit()
    return None

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 安装依赖
uv add fastapi uvicorn sqlalchemy

# 运行服务器
python 10_实战代码_依赖注入实战.py

# 测试
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "email": "alice@example.com", "full_name": "Alice Smith"}'

curl http://localhost:8000/users
curl http://localhost:8000/users/1
curl -X DELETE http://localhost:8000/users/1
```

---

## 场景2：JWT 认证授权

**目标：** 使用依赖注入实现 JWT 认证

```python
"""
JWT 认证授权示例
演示：使用依赖注入实现认证和授权
"""

from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta
from typing import Optional

# ===== 配置 =====

SECRET_KEY = "your-secret-key-here"  # 生产环境应该使用环境变量
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# ===== 密码加密 =====

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

# ===== 模拟数据库 =====

fake_users_db = {
    "alice": {
        "username": "alice",
        "email": "alice@example.com",
        "hashed_password": get_password_hash("secret123"),
        "is_active": True,
        "is_admin": False
    },
    "admin": {
        "username": "admin",
        "email": "admin@example.com",
        "hashed_password": get_password_hash("admin123"),
        "is_active": True,
        "is_admin": True
    }
}

# ===== Pydantic 模型 =====

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class User(BaseModel):
    username: str
    email: str
    is_active: bool
    is_admin: bool

class UserInDB(User):
    hashed_password: str

class LoginRequest(BaseModel):
    username: str
    password: str

# ===== JWT 工具函数 =====

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# ===== 依赖注入：认证 =====

security = HTTPBearer()

def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> User:
    """
    依赖1：从 token 获取当前用户
    """
    token = credentials.credentials

    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="无效的认证凭证",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user_dict = fake_users_db.get(username)
    if user_dict is None:
        raise credentials_exception

    return User(**user_dict)

def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """
    依赖2：检查用户是否激活（依赖于 get_current_user）
    """
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="用户未激活")
    return current_user

def get_current_admin_user(
    current_user: User = Depends(get_current_active_user)
) -> User:
    """
    依赖3：检查用户是否是管理员（依赖于 get_current_active_user）
    """
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="需要管理员权限"
        )
    return current_user

# ===== FastAPI 应用 =====

app = FastAPI()

# ===== 路由 =====

@app.post("/login", response_model=Token)
async def login(login_data: LoginRequest):
    """登录接口"""
    user_dict = fake_users_db.get(login_data.username)
    if not user_dict:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误"
        )

    user = UserInDB(**user_dict)
    if not verify_password(login_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误"
        )

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username},
        expires_delta=access_token_expires
    )

    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/profile", response_model=User)
async def get_profile(
    current_user: User = Depends(get_current_active_user)
):
    """获取当前用户信息（需要认证）"""
    return current_user

@app.get("/admin/users")
async def list_all_users(
    current_user: User = Depends(get_current_admin_user)
):
    """获取所有用户（需要管理员权限）"""
    return {
        "users": [
            {k: v for k, v in user.items() if k != "hashed_password"}
            for user in fake_users_db.values()
        ]
    }

@app.get("/public")
async def public_endpoint():
    """公开接口（不需要认证）"""
    return {"message": "这是公开接口"}

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 安装依赖
uv add fastapi uvicorn python-jose[cryptography] passlib[bcrypt]

# 运行服务器
python jwt_auth.py

# 1. 登录获取 token
TOKEN=$(curl -X POST http://localhost:8000/login \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "secret123"}' \
  | jq -r '.access_token')

# 2. 访问受保护的接口
curl http://localhost:8000/profile \
  -H "Authorization: Bearer $TOKEN"

# 3. 尝试访问管理员接口（会失败，因为 alice 不是管理员）
curl http://localhost:8000/admin/users \
  -H "Authorization: Bearer $TOKEN"

# 4. 用管理员账号登录
ADMIN_TOKEN=$(curl -X POST http://localhost:8000/login \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "password": "admin123"}' \
  | jq -r '.access_token')

# 5. 访问管理员接口（成功）
curl http://localhost:8000/admin/users \
  -H "Authorization: Bearer $ADMIN_TOKEN"
```

---

## 场景3：依赖链和缓存

**目标：** 演示依赖链和依赖缓存机制

```python
"""
依赖链和缓存示例
演示：依赖的依赖、依赖缓存
"""

from fastapi import FastAPI, Depends
from datetime import datetime
import time

app = FastAPI()

# ===== 依赖函数 =====

def get_timestamp():
    """依赖1：获取时间戳"""
    timestamp = datetime.now()
    print(f"[get_timestamp] 生成时间戳: {timestamp}")
    return timestamp

def get_request_id():
    """依赖2：获取请求ID"""
    request_id = int(time.time() * 1000)
    print(f"[get_request_id] 生成请求ID: {request_id}")
    return request_id

def get_request_context(
    timestamp: datetime = Depends(get_timestamp),
    request_id: int = Depends(get_request_id)
):
    """依赖3：获取请求上下文（依赖于 get_timestamp 和 get_request_id）"""
    print(f"[get_request_context] 创建请求上下文")
    return {
        "timestamp": timestamp,
        "request_id": request_id
    }

def log_request(
    context: dict = Depends(get_request_context),
    timestamp: datetime = Depends(get_timestamp)  # 使用缓存的 timestamp
):
    """依赖4：记录请求日志（依赖于 get_request_context 和 get_timestamp）"""
    print(f"[log_request] 记录请求: {context['request_id']}")
    return f"Logged at {timestamp}"

# ===== 路由 =====

@app.get("/test-cache")
async def test_cache(
    context: dict = Depends(get_request_context),
    log: str = Depends(log_request),
    timestamp1: datetime = Depends(get_timestamp),  # 使用缓存
    timestamp2: datetime = Depends(get_timestamp),  # 使用缓存
    timestamp3: datetime = Depends(get_timestamp)   # 使用缓存
):
    """
    测试依赖缓存
    - get_timestamp() 只执行一次
    - get_request_id() 只执行一次
    - get_request_context() 只执行一次
    - log_request() 只执行一次
    """
    return {
        "context": context,
        "log": log,
        "timestamp1": timestamp1,
        "timestamp2": timestamp2,
        "timestamp3": timestamp3,
        "all_same": timestamp1 == timestamp2 == timestamp3
    }

@app.get("/test-no-cache")
async def test_no_cache(
    timestamp1: datetime = Depends(get_timestamp, use_cache=False),
    timestamp2: datetime = Depends(get_timestamp, use_cache=False),
    timestamp3: datetime = Depends(get_timestamp, use_cache=False)
):
    """
    测试禁用缓存
    - get_timestamp() 执行三次
    - 每次返回不同的时间戳
    """
    return {
        "timestamp1": timestamp1,
        "timestamp2": timestamp2,
        "timestamp3": timestamp3,
        "all_same": timestamp1 == timestamp2 == timestamp3
    }

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 运行服务器
python dependency_cache.py

# 测试缓存（控制台只会打印一次 "生成时间戳"）
curl http://localhost:8000/test-cache

# 测试禁用缓存（控制台会打印三次 "生成时间戳"）
curl http://localhost:8000/test-no-cache
```

---

## 场景4：类作为依赖

**目标：** 使用类封装依赖逻辑

```python
"""
类作为依赖示例
演示：使用类封装复杂的依赖逻辑
"""

from fastapi import FastAPI, Depends, Query, HTTPException
from pydantic import BaseModel
from typing import Optional, List

app = FastAPI()

# ===== 分页类 =====

class Pagination:
    """分页依赖类"""

    def __init__(
        self,
        page: int = Query(1, ge=1, description="页码"),
        page_size: int = Query(10, ge=1, le=100, description="每页数量")
    ):
        self.page = page
        self.page_size = page_size
        self.skip = (page - 1) * page_size
        self.limit = page_size

    def paginate(self, items: List):
        """对列表进行分页"""
        return items[self.skip : self.skip + self.limit]

    def get_metadata(self, total: int):
        """获取分页元数据"""
        return {
            "page": self.page,
            "page_size": self.page_size,
            "total": total,
            "total_pages": (total + self.page_size - 1) // self.page_size
        }

# ===== 搜索参数类 =====

class SearchParams:
    """搜索参数依赖类"""

    def __init__(
        self,
        q: Optional[str] = Query(None, min_length=3, description="搜索关键词"),
        category: Optional[str] = Query(None, description="分类"),
        min_price: Optional[float] = Query(None, ge=0, description="最低价格"),
        max_price: Optional[float] = Query(None, ge=0, description="最高价格"),
        sort_by: str = Query("created_at", regex="^(created_at|price|name)$"),
        sort_order: str = Query("desc", regex="^(asc|desc)$")
    ):
        self.q = q
        self.category = category
        self.min_price = min_price
        self.max_price = max_price
        self.sort_by = sort_by
        self.sort_order = sort_order

    def filter(self, items: List[dict]) -> List[dict]:
        """过滤列表"""
        filtered = items

        if self.q:
            filtered = [
                item for item in filtered
                if self.q.lower() in item["name"].lower()
            ]

        if self.category:
            filtered = [
                item for item in filtered
                if item.get("category") == self.category
            ]

        if self.min_price is not None:
            filtered = [
                item for item in filtered
                if item["price"] >= self.min_price
            ]

        if self.max_price is not None:
            filtered = [
                item for item in filtered
                if item["price"] <= self.max_price
            ]

        return filtered

    def sort(self, items: List[dict]) -> List[dict]:
        """排序列表"""
        reverse = self.sort_order == "desc"
        return sorted(items, key=lambda x: x[self.sort_by], reverse=reverse)

# ===== 模拟数据 =====

fake_items = [
    {"id": 1, "name": "Laptop", "price": 999.99, "category": "electronics", "created_at": "2026-01-01"},
    {"id": 2, "name": "Mouse", "price": 29.99, "category": "electronics", "created_at": "2026-01-02"},
    {"id": 3, "name": "Keyboard", "price": 79.99, "category": "electronics", "created_at": "2026-01-03"},
    {"id": 4, "name": "Book", "price": 19.99, "category": "books", "created_at": "2026-01-04"},
    {"id": 5, "name": "Pen", "price": 2.99, "category": "stationery", "created_at": "2026-01-05"},
]

# ===== 路由 =====

@app.get("/items")
async def list_items(
    search: SearchParams = Depends(),
    pagination: Pagination = Depends()
):
    """
    获取商品列表
    - 支持搜索、过滤、排序、分页
    """
    # 过滤
    filtered_items = search.filter(fake_items)

    # 排序
    sorted_items = search.sort(filtered_items)

    # 分页
    paginated_items = pagination.paginate(sorted_items)

    return {
        "items": paginated_items,
        "pagination": pagination.get_metadata(len(sorted_items))
    }

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 基础查询
curl "http://localhost:8000/items"

# 搜索
curl "http://localhost:8000/items?q=laptop"

# 过滤
curl "http://localhost:8000/items?category=electronics&min_price=50&max_price=500"

# 排序
curl "http://localhost:8000/items?sort_by=price&sort_order=asc"

# 分页
curl "http://localhost:8000/items?page=1&page_size=2"

# 组合使用
curl "http://localhost:8000/items?q=laptop&category=electronics&sort_by=price&page=1&page_size=10"
```

---

## 场景5：依赖覆盖（测试）

**目标：** 在测试中替换依赖

```python
"""
依赖覆盖示例
演示：在测试中替换依赖
"""

from fastapi import FastAPI, Depends, HTTPException
from fastapi.testclient import TestClient
from pydantic import BaseModel

app = FastAPI()

# ===== 模拟数据库 =====

class FakeDB:
    def __init__(self):
        self.users = {
            1: {"id": 1, "username": "alice", "email": "alice@example.com"}
        }

    def get_user(self, user_id: int):
        return self.users.get(user_id)

# ===== 依赖 =====

def get_db():
    """生产环境的数据库连接"""
    return FakeDB()

def get_current_user_id():
    """生产环境的用户ID获取（从 token）"""
    # 实际应该从 JWT token 中解析
    return 1

# ===== 路由 =====

@app.get("/profile")
async def get_profile(
    user_id: int = Depends(get_current_user_id),
    db: FakeDB = Depends(get_db)
):
    user = db.get_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

# ===== 测试 =====

def test_get_profile():
    """测试获取用户信息"""

    # 测试数据库
    class TestDB:
        def get_user(self, user_id: int):
            return {"id": user_id, "username": "test_user", "email": "test@example.com"}

    # 测试用户ID
    def get_test_user_id():
        return 999

    # 覆盖依赖
    app.dependency_overrides[get_db] = lambda: TestDB()
    app.dependency_overrides[get_current_user_id] = get_test_user_id

    # 测试
    client = TestClient(app)
    response = client.get("/profile")

    assert response.status_code == 200
    assert response.json()["username"] == "test_user"
    assert response.json()["id"] == 999

    # 清理
    app.dependency_overrides = {}

    print("✅ 测试通过")

if __name__ == "__main__":
    # 运行测试
    test_get_profile()

    # 运行服务器
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 总结

### 学到的技能

1. **数据库连接** - 使用 yield 管理资源生命周期
2. **JWT 认证** - 多层依赖链实现认证授权
3. **依赖缓存** - 理解依赖缓存机制
4. **类依赖** - 封装复杂的依赖逻辑
5. **依赖覆盖** - 在测试中替换依赖

### 关键要点

- 依赖注入让代码更模块化、可测试
- 使用 yield 自动管理资源生命周期
- 依赖可以依赖其他依赖（依赖链）
- 同一个请求中依赖被缓存
- 类可以作为依赖，封装复杂逻辑

---

**记住：** 依赖注入是 FastAPI 的核心特性，掌握它可以写出清晰、可维护的代码！
