# 实战代码 - 场景4：SSE流式进度更新

> 完整可运行的SSE实时进度推送示例，比WebSocket更简单

---

## 场景描述

**需求**：使用SSE（Server-Sent Events）实时推送任务进度，自动重连

**技术栈**：FastAPI + SSE + Celery + PostgreSQL

**SSE优势**：
- ✅ 自动重连（浏览器原生支持）
- ✅ 实现简单（50行代码）
- ✅ 单向推送（满足进度推送需求）

---

## 完整代码实现

### 1. SSE进度推送端点

```python
# app/main.py
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
from app.models.task import Task
from app.core.database import SessionLocal
import asyncio
import json

app = FastAPI()

@app.get("/tasks/{task_id}/stream")
async def stream_task_progress(task_id: str):
    """SSE推送任务进度"""
    async def generate():
        db = SessionLocal()

        try:
            while True:
                # 查询任务状态
                task = db.query(Task).filter(Task.task_id == task_id).first()

                if not task:
                    yield f"data: {json.dumps({'error': 'Task not found'})}\n\n"
                    break

                # 推送进度
                data = {
                    "task_id": task_id,
                    "status": task.status.value,
                    "progress": task.progress,
                    "message": task.metadata.get('message') if task.metadata else None
                }
                yield f"data: {json.dumps(data)}\n\n"

                # 任务完成，停止推送
                if task.status in ["completed", "failed", "canceled"]:
                    # 发送完成事件
                    yield f"event: complete\n"
                    yield f"data: {json.dumps({'result': task.result})}\n\n"
                    break

                # 每秒查询一次
                await asyncio.sleep(1)

        finally:
            db.close()

    return StreamingResponse(
        generate(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # 禁用Nginx缓冲
            "Connection": "keep-alive"
        }
    )
```

---

### 2. 带心跳的SSE端点

```python
import time

@app.get("/tasks/{task_id}/stream-with-heartbeat")
async def stream_with_heartbeat(task_id: str):
    """带心跳的SSE端点"""
    async def generate():
        db = SessionLocal()
        last_heartbeat = time.time()

        try:
            while True:
                # 查询任务状态
                task = db.query(Task).filter(Task.task_id == task_id).first()

                if task:
                    # 推送进度
                    data = {
                        "task_id": task_id,
                        "status": task.status.value,
                        "progress": task.progress
                    }
                    yield f"data: {json.dumps(data)}\n\n"

                    # 任务完成
                    if task.status in ["completed", "failed"]:
                        break

                # 发送心跳（每30秒）
                if time.time() - last_heartbeat > 30:
                    yield f": heartbeat\n\n"  # 注释行，客户端不处理
                    last_heartbeat = time.time()

                await asyncio.sleep(1)

        finally:
            db.close()

    return StreamingResponse(generate(), media_type="text/event-stream")
```

---

### 3. 带ID的SSE（支持断线重连）

```python
@app.get("/tasks/{task_id}/stream-with-id")
async def stream_with_id(task_id: str, last_event_id: int = 0):
    """支持断线重连的SSE端点"""
    async def generate():
        db = SessionLocal()

        try:
            # 从上次断开的位置继续
            event_id = last_event_id

            while True:
                task = db.query(Task).filter(Task.task_id == task_id).first()

                if not task:
                    break

                # 发送带ID的消息
                event_id += 1
                yield f"id: {event_id}\n"
                yield f"data: {json.dumps({'progress': task.progress})}\n\n"

                if task.status in ["completed", "failed"]:
                    break

                await asyncio.sleep(1)

        finally:
            db.close()

    return StreamingResponse(generate(), media_type="text/event-stream")
```

---

### 4. 前端SSE客户端

```javascript
// 基础SSE连接
const taskId = 'task-123';
const eventSource = new EventSource(`/tasks/${taskId}/stream`);

// 接收消息
eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log('进度:', data.progress);

    // 更新进度条
    document.getElementById('progress').value = data.progress;
    document.getElementById('status').textContent = data.status;

    if (data.message) {
        document.getElementById('message').textContent = data.message;
    }
};

// 监听完成事件
eventSource.addEventListener('complete', (event) => {
    const data = JSON.parse(event.data);
    console.log('任务完成:', data.result);
    eventSource.close();
});

// 错误处理（浏览器自动重连）
eventSource.onerror = (error) => {
    console.error('SSE错误:', error);
    // 浏览器会自动重连
};

// 关闭连接
// eventSource.close();
```

---

### 5. 前端进度条组件

```html
<!DOCTYPE html>
<html>
<head>
    <title>任务进度</title>
    <style>
        .progress-container {
            width: 100%;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background-color: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }
        .status {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="progress-container">
        <h2>任务进度</h2>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
        <div class="status">
            <p>状态: <span id="status">pending</span></p>
            <p>进度: <span id="progress-text">0</span>%</p>
            <p>消息: <span id="message">-</span></p>
        </div>
    </div>

    <script>
        const taskId = new URLSearchParams(window.location.search).get('task_id');
        const eventSource = new EventSource(`/tasks/${taskId}/stream`);

        eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);

            // 更新进度条
            document.getElementById('progress-fill').style.width = data.progress + '%';
            document.getElementById('progress-text').textContent = data.progress.toFixed(1);
            document.getElementById('status').textContent = data.status;

            if (data.message) {
                document.getElementById('message').textContent = data.message;
            }
        };

        eventSource.addEventListener('complete', (event) => {
            const data = JSON.parse(event.data);
            alert('任务完成！');
            eventSource.close();
        });

        eventSource.onerror = (error) => {
            console.error('SSE错误:', error);
        };
    </script>
</body>
</html>
```

---

### 6. 异步任务模式（不用Celery）

```python
# app/main.py
import asyncio
from typing import Dict

# 全局任务字典
tasks: Dict[str, dict] = {}

async def long_running_task(task_id: str):
    """长时间运行的任务"""
    tasks[task_id] = {"status": "running", "progress": 0}

    try:
        for i in range(10):
            # 模拟处理
            await asyncio.sleep(1)

            # 更新进度
            tasks[task_id]["progress"] = (i + 1) * 10

        # 任务完成
        tasks[task_id]["status"] = "completed"
        tasks[task_id]["result"] = {"data": "processed"}

    except Exception as e:
        tasks[task_id]["status"] = "failed"
        tasks[task_id]["error"] = str(e)

@app.post("/submit")
async def submit_task():
    """提交任务"""
    import uuid
    task_id = str(uuid.uuid4())

    # 初始化任务状态
    tasks[task_id] = {"status": "pending", "progress": 0}

    # 创建后台任务
    asyncio.create_task(long_running_task(task_id))

    return {"task_id": task_id}

@app.get("/tasks/{task_id}/stream")
async def stream_progress(task_id: str):
    """SSE推送进度（从内存读取）"""
    async def generate():
        while True:
            if task_id not in tasks:
                yield f"data: {json.dumps({'error': 'Task not found'})}\n\n"
                break

            task = tasks[task_id]
            yield f"data: {json.dumps(task)}\n\n"

            if task["status"] in ["completed", "failed"]:
                break

            await asyncio.sleep(1)

    return StreamingResponse(generate(), media_type="text/event-stream")
```

---

## 运行步骤

```bash
# 1. 启动FastAPI
uvicorn app.main:app --reload

# 2. 提交任务
curl -X POST "http://localhost:8000/submit"
# 响应: {"task_id": "abc-123"}

# 3. 连接SSE（浏览器）
# 打开浏览器访问：
http://localhost:8000/tasks/abc-123/stream

# 或使用curl测试
curl -N "http://localhost:8000/tasks/abc-123/stream"
```

---

## 预期输出

### SSE消息流

```
data: {"task_id": "abc-123", "status": "running", "progress": 0}

data: {"task_id": "abc-123", "status": "running", "progress": 10}

data: {"task_id": "abc-123", "status": "running", "progress": 20}

...

data: {"task_id": "abc-123", "status": "completed", "progress": 100}

event: complete
data: {"result": {"data": "processed"}}
```

---

## 关键知识点

### 1. SSE消息格式

```python
# 基础消息
yield f"data: {json.dumps(data)}\n\n"

# 自定义事件
yield f"event: complete\n"
yield f"data: {json.dumps(data)}\n\n"

# 带ID的消息
yield f"id: {event_id}\n"
yield f"data: {json.dumps(data)}\n\n"

# 心跳（注释行）
yield f": heartbeat\n\n"
```

### 2. StreamingResponse配置

```python
return StreamingResponse(
    generate(),
    media_type="text/event-stream",  # 必需
    headers={
        "Cache-Control": "no-cache",  # 禁止缓存
        "X-Accel-Buffering": "no"     # 禁用Nginx缓冲
    }
)
```

### 3. 前端自动重连

```javascript
// 浏览器自动处理重连
eventSource.onerror = (error) => {
    console.error('SSE错误:', error);
    // 浏览器会自动重连，无需手动处理
};
```

---

## SSE vs WebSocket对比

| 特性 | SSE | WebSocket |
|------|-----|-----------|
| **实现复杂度** | 50行代码 | 200行代码 |
| **自动重连** | ✅ 浏览器自动 | ❌ 需要手动实现 |
| **通信方向** | 单向（服务器→客户端） | 双向 |
| **适用场景** | 进度推送、通知 | 聊天、实时协作 |

---

## 常见问题

### Q1: SSE连接一直pending

**问题**：浏览器显示连接pending，没有收到消息

**原因**：Nginx缓冲导致

**解决**：
```python
headers={
    "X-Accel-Buffering": "no"  # 禁用Nginx缓冲
}
```

### Q2: SSE连接频繁断开

**问题**：连接每隔一段时间就断开

**原因**：没有发送心跳，连接超时

**解决**：
```python
# 每30秒发送心跳
if time.time() - last_heartbeat > 30:
    yield f": heartbeat\n\n"
```

### Q3: 浏览器连接数限制

**问题**：同一域名只能建立6个SSE连接

**解决**：
- 使用不同的子域名
- 关闭不需要的连接
- 使用HTTP/2（连接数限制更高）

---

## 扩展练习

### 练习1：添加任务取消

```python
@app.post("/tasks/{task_id}/cancel")
async def cancel_task(task_id: str):
    """取消任务"""
    if task_id in tasks:
        tasks[task_id]["status"] = "canceled"
    return {"status": "canceled"}

# SSE端点检测取消状态
async def generate():
    while True:
        task = tasks[task_id]

        if task["status"] == "canceled":
            yield f"data: {json.dumps({'status': 'canceled'})}\n\n"
            break

        # ...
```

### 练习2：添加多任务监控

```python
@app.get("/tasks/stream-all")
async def stream_all_tasks():
    """监控所有任务"""
    async def generate():
        while True:
            # 推送所有任务状态
            data = {
                "tasks": [
                    {"task_id": tid, **task}
                    for tid, task in tasks.items()
                ]
            }
            yield f"data: {json.dumps(data)}\n\n"
            await asyncio.sleep(1)

    return StreamingResponse(generate(), media_type="text/event-stream")
```

---

## 总结

本示例演示了：
- ✅ SSE基础实现
- ✅ 心跳机制
- ✅ 断线重连
- ✅ 异步任务模式
- ✅ 前端进度条

**SSE优势**：
- 实现简单（50行代码）
- 自动重连（浏览器原生支持）
- 满足单向推送需求

**下一步**：学习生产级长任务系统（场景5）
