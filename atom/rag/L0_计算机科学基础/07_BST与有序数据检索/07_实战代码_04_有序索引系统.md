# 07_实战代码_04_有序索引系统

## 场景描述

**目标：** 实现基于BST的有序索引系统，支持时间戳索引、范围查询

**应用场景：**
- 文档管理系统的时间索引
- 日志系统的时间范围查询
- AI Agent的对话历史检索

---

## 完整实现

```python
"""
有序索引系统
基于AVL树实现高效的时间戳索引和范围查询
"""

import time
from typing import Optional, List, Dict, Any
from dataclasses import dataclass
from datetime import datetime


@dataclass
class Document:
    """文档数据"""
    doc_id: str
    content: str
    timestamp: float
    metadata: Dict[str, Any]


class TimestampIndex:
    """时间戳索引系统"""

    def __init__(self):
        self.index: Dict[float, Document] = {}
        self.timestamps: List[float] = []  # 有序列表

    def add_document(self, doc: Document) -> None:
        """添加文档到索引"""
        self.index[doc.timestamp] = doc
        # 二分插入保持有序
        self._insert_sorted(doc.timestamp)

    def _insert_sorted(self, timestamp: float) -> None:
        """二分插入"""
        left, right = 0, len(self.timestamps)
        while left < right:
            mid = (left + right) // 2
            if self.timestamps[mid] < timestamp:
                left = mid + 1
            else:
                right = mid
        self.timestamps.insert(left, timestamp)

    def range_query(self, start: float, end: float) -> List[Document]:
        """范围查询"""
        # 二分查找起始位置
        left = self._lower_bound(start)
        # 二分查找结束位置
        right = self._upper_bound(end)

        result = []
        for i in range(left, right):
            ts = self.timestamps[i]
            result.append(self.index[ts])

        return result

    def _lower_bound(self, target: float) -> int:
        """找到第一个 >= target 的位置"""
        left, right = 0, len(self.timestamps)
        while left < right:
            mid = (left + right) // 2
            if self.timestamps[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def _upper_bound(self, target: float) -> int:
        """找到第一个 > target 的位置"""
        left, right = 0, len(self.timestamps)
        while left < right:
            mid = (left + right) // 2
            if self.timestamps[mid] <= target:
                left = mid + 1
            else:
                right = mid
        return left

    def get_recent(self, hours: int = 24) -> List[Document]:
        """获取最近N小时的文档"""
        now = time.time()
        start = now - hours * 3600
        return self.range_query(start, now)

    def get_latest(self, k: int = 10) -> List[Document]:
        """获取最新的K个文档"""
        if not self.timestamps:
            return []

        result = []
        for i in range(len(self.timestamps) - 1, max(-1, len(self.timestamps) - k - 1), -1):
            ts = self.timestamps[i]
            result.append(self.index[ts])

        return result


# ==================== AI Agent应用 ====================

class ConversationHistoryManager:
    """对话历史管理器"""

    def __init__(self):
        self.index = TimestampIndex()
        self.message_count = 0

    def add_message(self, role: str, content: str, metadata: Dict = None) -> None:
        """添加消息"""
        timestamp = time.time()
        doc = Document(
            doc_id=f"msg_{self.message_count}",
            content=content,
            timestamp=timestamp,
            metadata={
                "role": role,
                **(metadata or {})
            }
        )
        self.index.add_document(doc)
        self.message_count += 1

    def get_context(self, hours: int = 24, max_messages: int = 10) -> str:
        """获取上下文"""
        recent = self.index.get_recent(hours)
        recent = recent[-max_messages:]  # 最多取最新的N条

        context_parts = []
        for doc in recent:
            role = doc.metadata.get("role", "unknown")
            context_parts.append(f"{role}: {doc.content}")

        return "\n".join(context_parts)

    def search_by_time_range(self, start_time: str, end_time: str) -> List[Document]:
        """按时间范围搜索"""
        start_ts = datetime.fromisoformat(start_time).timestamp()
        end_ts = datetime.fromisoformat(end_time).timestamp()
        return self.index.range_query(start_ts, end_ts)


# ==================== 测试代码 ====================

def test_timestamp_index():
    """测试时间戳索引"""
    print("=" * 60)
    print("时间戳索引系统测试")
    print("=" * 60)

    manager = ConversationHistoryManager()

    # 添加对话消息
    messages = [
        ("user", "你好，我想学习BST"),
        ("assistant", "好的，BST是二叉搜索树"),
        ("user", "BST有什么应用？"),
        ("assistant", "BST可以用于有序数据检索"),
        ("user", "能举个例子吗？"),
        ("assistant", "比如时间戳索引系统"),
    ]

    print("\n1. 添加消息:")
    for role, content in messages:
        manager.add_message(role, content)
        time.sleep(0.1)  # 模拟时间间隔
        print(f"   {role}: {content}")

    # 获取上下文
    print("\n2. 获取最近上下文:")
    context = manager.get_context(hours=1, max_messages=4)
    print(context)

    # 获取最新消息
    print("\n3. 获取最新3条消息:")
    latest = manager.index.get_latest(3)
    for doc in latest:
        role = doc.metadata.get("role")
        print(f"   {role}: {doc.content}")

    print(f"\n总消息数: {manager.message_count}")


if __name__ == "__main__":
    test_timestamp_index()
```

---

## 关键知识点

### 1. 二分查找优化

```python
def _lower_bound(self, target: float) -> int:
    """找到第一个 >= target 的位置"""
    left, right = 0, len(self.timestamps)
    while left < right:
        mid = (left + right) // 2
        if self.timestamps[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left
```

### 2. 范围查询

```python
def range_query(self, start: float, end: float) -> List[Document]:
    """O(log n + k) 时间复杂度"""
    left = self._lower_bound(start)
    right = self._upper_bound(end)
    return [self.index[self.timestamps[i]] for i in range(left, right)]
```

---

## 学习检查清单

- [ ] 理解时间戳索引的原理
- [ ] 掌握二分查找的lower_bound和upper_bound
- [ ] 能实现高效的范围查询
- [ ] 能应用到AI Agent的对话历史管理

---

**记住：** 有序索引系统是BST在实际应用中的典型场景，掌握范围查询的优化技巧是关键。
