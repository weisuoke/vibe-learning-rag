# 核心概念 3：字段类型详解

## 字段类型概览

Milvus 支持两大类字段类型：

1. **标量字段（Scalar Fields）**：存储元数据
2. **向量字段（Vector Fields）**：存储向量数据

## 一、标量字段类型

### 1.1 整数类型

```python
from pymilvus import FieldSchema, DataType

# INT8: -128 到 127
int8_field = FieldSchema(
    name="age",
    dtype=DataType.INT8,
    description="用户年龄"
)

# INT16: -32,768 到 32,767
int16_field = FieldSchema(
    name="year",
    dtype=DataType.INT16,
    description="年份"
)

# INT32: -2^31 到 2^31-1
int32_field = FieldSchema(
    name="count",
    dtype=DataType.INT32,
    description="计数"
)

# INT64: -2^63 到 2^63-1（最常用）
int64_field = FieldSchema(
    name="id",
    dtype=DataType.INT64,
    is_primary=True,
    description="主键ID"
)
```

**选择建议：**
- 主键：使用 `INT64`
- 小范围数值（如年龄、评分）：使用 `INT8` 或 `INT16`
- 一般计数：使用 `INT32`
- 大数值或时间戳：使用 `INT64`

### 1.2 浮点数类型

```python
# FLOAT: 32位浮点数
float_field = FieldSchema(
    name="score",
    dtype=DataType.FLOAT,
    description="相似度分数"
)

# DOUBLE: 64位浮点数（更高精度）
double_field = FieldSchema(
    name="price",
    dtype=DataType.DOUBLE,
    description="商品价格"
)
```

**选择建议：**
- 一般浮点数（如分数、比例）：使用 `FLOAT`
- 需要高精度（如金融数据）：使用 `DOUBLE`

### 1.3 字符串类型

```python
# VARCHAR: 可变长度字符串
varchar_field = FieldSchema(
    name="title",
    dtype=DataType.VARCHAR,
    max_length=200,  # 必须指定最大长度
    description="文档标题"
)

# 主键也可以是 VARCHAR
varchar_pk_field = FieldSchema(
    name="doc_id",
    dtype=DataType.VARCHAR,
    max_length=50,
    is_primary=True,
    description="文档ID"
)
```

**重要注意事项：**
- `max_length` 是字符数，不是字节数
- 中文字符也算1个字符
- 超过 `max_length` 的数据会被截断或报错

**示例：**
```python
# 正确：标题最多200个字符
title_field = FieldSchema(
    name="title",
    dtype=DataType.VARCHAR,
    max_length=200
)

# 错误：忘记指定 max_length
# title_field = FieldSchema(
#     name="title",
#     dtype=DataType.VARCHAR
# )  # 会报错！
```

### 1.4 布尔类型

```python
# BOOL: True 或 False
bool_field = FieldSchema(
    name="is_published",
    dtype=DataType.BOOL,
    description="是否已发布"
)
```

**使用场景：**
- 状态标记（已发布/未发布）
- 开关标志（启用/禁用）
- 二元分类（是/否）

### 1.5 JSON 类型（Milvus 2.2+）

```python
# JSON: 存储复杂的结构化数据
json_field = FieldSchema(
    name="metadata",
    dtype=DataType.JSON,
    description="文档元数据"
)
```

**使用场景：**
```python
# 插入 JSON 数据
data = [{
    "id": 1,
    "embedding": [0.1, 0.2, ...],
    "metadata": {
        "author": "张三",
        "tags": ["Python", "AI", "RAG"],
        "stats": {
            "views": 1000,
            "likes": 50
        }
    }
}]

collection.insert(data)

# 查询 JSON 字段
# 支持 JSON 路径表达式
results = collection.query(
    expr='metadata["author"] == "张三"',
    output_fields=["id", "metadata"]
)
```

**JSON 字段的优势：**
- 灵活存储复杂数据结构
- 支持嵌套对象和数组
- 可以通过 JSON 路径查询

**JSON 字段的限制：**
- 不能作为主键
- 查询性能低于标量字段
- 不支持索引（Milvus 2.3）

## 二、向量字段类型

### 2.1 浮点向量（FLOAT_VECTOR）

```python
# FLOAT_VECTOR: 最常用的向量类型
vector_field = FieldSchema(
    name="embedding",
    dtype=DataType.FLOAT_VECTOR,
    dim=768,  # 向量维度（必须指定）
    description="文档向量"
)
```

**特点：**
- 每个维度是32位浮点数
- 精度高，适合大多数场景
- 存储空间：`dim * 4` 字节

**常见维度：**
```python
# OpenAI text-embedding-3-small: 1536维
openai_field = FieldSchema(
    name="openai_embedding",
    dtype=DataType.FLOAT_VECTOR,
    dim=1536
)

# sentence-transformers/all-MiniLM-L6-v2: 384维
minilm_field = FieldSchema(
    name="minilm_embedding",
    dtype=DataType.FLOAT_VECTOR,
    dim=384
)

# sentence-transformers/all-mpnet-base-v2: 768维
mpnet_field = FieldSchema(
    name="mpnet_embedding",
    dtype=DataType.FLOAT_VECTOR,
    dim=768
)
```

### 2.2 二进制向量（BINARY_VECTOR）

```python
# BINARY_VECTOR: 二进制向量（每个维度是0或1）
binary_field = FieldSchema(
    name="binary_embedding",
    dtype=DataType.BINARY_VECTOR,
    dim=512,  # 维度必须是8的倍数
    description="二进制向量"
)
```

**特点：**
- 每个维度是1位（0或1）
- 存储空间小：`dim / 8` 字节
- 检索速度快
- 精度低于浮点向量

**使用场景：**
- 图像哈希（如 pHash, dHash）
- 文本指纹
- 快速去重
- 对精度要求不高的场景

**示例：**
```python
import numpy as np

# 生成二进制向量（512维）
binary_vector = np.random.randint(0, 2, 512).astype(np.uint8)

# 转换为字节数组（Milvus 要求）
binary_bytes = np.packbits(binary_vector).tolist()

# 插入数据
data = [{
    "id": 1,
    "binary_embedding": binary_bytes
}]
```

### 2.3 多向量字段

一个 Collection 可以包含多个向量字段：

```python
from pymilvus import CollectionSchema, FieldSchema, DataType

# 定义多个向量字段
schema = CollectionSchema(
    fields=[
        FieldSchema(name="id", dtype=DataType.INT64, is_primary=True),
        FieldSchema(name="text_vector", dtype=DataType.FLOAT_VECTOR, dim=768),
        FieldSchema(name="image_vector", dtype=DataType.FLOAT_VECTOR, dim=512),
        FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=200)
    ],
    description="多模态 Collection"
)
```

**使用场景：**
- 多模态检索（文本 + 图片）
- 多语言检索（中文向量 + 英文向量）
- 多粒度检索（标题向量 + 内容向量）

**检索时指定向量字段：**
```python
# 使用 text_vector 检索
results = collection.search(
    data=[query_text_vector],
    anns_field="text_vector",  # 指定向量字段
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10
)

# 使用 image_vector 检索
results = collection.search(
    data=[query_image_vector],
    anns_field="image_vector",  # 指定向量字段
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10
)
```

## 三、字段约束和属性

### 3.1 主键约束（Primary Key）

```python
# 主键字段的要求
pk_field = FieldSchema(
    name="id",
    dtype=DataType.INT64,  # 只能是 INT64 或 VARCHAR
    is_primary=True,       # 标记为主键
    auto_id=False          # 是否自动生成ID
)
```

**主键规则：**
- 每个 Collection 必须有且只有一个主键
- 主键类型只能是 `INT64` 或 `VARCHAR`
- 主键值必须唯一
- 主键不能为空

**自动生成 ID：**
```python
# auto_id=True: Milvus 自动生成ID
pk_field = FieldSchema(
    name="id",
    dtype=DataType.INT64,
    is_primary=True,
    auto_id=True  # 插入时不需要提供ID
)

# 插入数据时不需要提供 id
data = [{
    "embedding": [0.1, 0.2, ...],
    "title": "文档标题"
}]
collection.insert(data)

# auto_id=False: 手动指定ID
pk_field = FieldSchema(
    name="id",
    dtype=DataType.INT64,
    is_primary=True,
    auto_id=False  # 插入时必须提供ID
)

# 插入数据时必须提供 id
data = [{
    "id": 1,
    "embedding": [0.1, 0.2, ...],
    "title": "文档标题"
}]
collection.insert(data)
```

### 3.2 字段描述（Description）

```python
# 为字段添加描述（可选，但推荐）
field = FieldSchema(
    name="title",
    dtype=DataType.VARCHAR,
    max_length=200,
    description="文档标题，最多200个字符"  # 描述信息
)
```

**最佳实践：**
- 为每个字段添加清晰的描述
- 说明字段的用途和约束
- 便于团队协作和维护

### 3.3 字段命名规范

```python
# ✅ 推荐：使用小写字母和下划线
"document_id", "content_vector", "created_at", "is_published"

# ❌ 避免：使用特殊字符、空格、中文
"document-id", "content vector", "文档ID"

# ✅ 推荐：有意义的名称
"user_age", "product_price", "embedding_768d"

# ❌ 避免：无意义的名称
"field1", "data", "temp"
```

## 四、字段类型选择指南

### 4.1 根据数据类型选择

| 数据类型 | 推荐字段类型 | 示例 |
|---------|-------------|------|
| 唯一标识符 | INT64 或 VARCHAR | 用户ID、文档ID |
| 整数 | INT8/INT16/INT32/INT64 | 年龄、计数、年份 |
| 小数 | FLOAT 或 DOUBLE | 分数、价格、比例 |
| 文本 | VARCHAR | 标题、描述、标签 |
| 布尔值 | BOOL | 是否发布、是否启用 |
| 复杂结构 | JSON | 元数据、配置信息 |
| 向量 | FLOAT_VECTOR | Embedding |
| 二进制向量 | BINARY_VECTOR | 图像哈希 |

### 4.2 根据使用场景选择

**场景1：文档检索系统**
```python
schema = CollectionSchema(
    fields=[
        FieldSchema(name="doc_id", dtype=DataType.INT64, is_primary=True),
        FieldSchema(name="content_vector", dtype=DataType.FLOAT_VECTOR, dim=768),
        FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=200),
        FieldSchema(name="content", dtype=DataType.VARCHAR, max_length=5000),
        FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=50),
        FieldSchema(name="created_at", dtype=DataType.INT64),
        FieldSchema(name="is_published", dtype=DataType.BOOL)
    ]
)
```

**场景2：图像检索系统**
```python
schema = CollectionSchema(
    fields=[
        FieldSchema(name="image_id", dtype=DataType.VARCHAR, max_length=50, is_primary=True),
        FieldSchema(name="image_vector", dtype=DataType.FLOAT_VECTOR, dim=512),
        FieldSchema(name="image_url", dtype=DataType.VARCHAR, max_length=500),
        FieldSchema(name="width", dtype=DataType.INT32),
        FieldSchema(name="height", dtype=DataType.INT32),
        FieldSchema(name="tags", dtype=DataType.JSON)
    ]
)
```

**场景3：用户画像系统**
```python
schema = CollectionSchema(
    fields=[
        FieldSchema(name="user_id", dtype=DataType.VARCHAR, max_length=50, is_primary=True),
        FieldSchema(name="profile_vector", dtype=DataType.FLOAT_VECTOR, dim=256),
        FieldSchema(name="age", dtype=DataType.INT8),
        FieldSchema(name="gender", dtype=DataType.VARCHAR, max_length=10),
        FieldSchema(name="interests", dtype=DataType.JSON),
        FieldSchema(name="last_active", dtype=DataType.INT64)
    ]
)
```

## 五、字段类型的性能考虑

### 5.1 存储空间

| 字段类型 | 存储空间 | 示例 |
|---------|---------|------|
| INT8 | 1 字节 | age: 25 |
| INT16 | 2 字节 | year: 2024 |
| INT32 | 4 字节 | count: 1000000 |
| INT64 | 8 字节 | id: 1234567890 |
| FLOAT | 4 字节 | score: 0.95 |
| DOUBLE | 8 字节 | price: 99.99 |
| BOOL | 1 字节 | is_active: true |
| VARCHAR | 可变 | title: "Hello" (5字节+) |
| FLOAT_VECTOR(768) | 3072 字节 | 768 * 4 |
| BINARY_VECTOR(512) | 64 字节 | 512 / 8 |

**优化建议：**
- 使用合适大小的整数类型（不要都用 INT64）
- VARCHAR 的 `max_length` 不要设置过大
- 考虑使用 BINARY_VECTOR 代替 FLOAT_VECTOR（如果精度要求不高）

### 5.2 查询性能

**标量字段查询性能（从快到慢）：**
1. INT 类型（最快）
2. BOOL 类型
3. FLOAT/DOUBLE 类型
4. VARCHAR 类型
5. JSON 类型（最慢）

**向量检索性能：**
- BINARY_VECTOR 检索速度 > FLOAT_VECTOR
- 向量维度越低，检索越快
- 需要在精度和速度之间权衡

## 六、常见错误和解决方案

### 错误1：VARCHAR 未指定 max_length

```python
# ❌ 错误
field = FieldSchema(
    name="title",
    dtype=DataType.VARCHAR
)  # 报错：missing required parameter 'max_length'

# ✅ 正确
field = FieldSchema(
    name="title",
    dtype=DataType.VARCHAR,
    max_length=200
)
```

### 错误2：向量维度不匹配

```python
# Schema 定义：768维
vector_field = FieldSchema(
    name="embedding",
    dtype=DataType.FLOAT_VECTOR,
    dim=768
)

# ❌ 错误：插入1536维向量
data = [{
    "id": 1,
    "embedding": [0.1] * 1536  # 维度不匹配！
}]

# ✅ 正确：插入768维向量
data = [{
    "id": 1,
    "embedding": [0.1] * 768
}]
```

### 错误3：主键类型错误

```python
# ❌ 错误：主键不能是 FLOAT
pk_field = FieldSchema(
    name="id",
    dtype=DataType.FLOAT,  # 错误！
    is_primary=True
)

# ✅ 正确：主键只能是 INT64 或 VARCHAR
pk_field = FieldSchema(
    name="id",
    dtype=DataType.INT64,
    is_primary=True
)
```

### 错误4：BINARY_VECTOR 维度不是8的倍数

```python
# ❌ 错误
binary_field = FieldSchema(
    name="binary_vector",
    dtype=DataType.BINARY_VECTOR,
    dim=500  # 不是8的倍数！
)

# ✅ 正确
binary_field = FieldSchema(
    name="binary_vector",
    dtype=DataType.BINARY_VECTOR,
    dim=512  # 8的倍数
)
```

## 总结

**字段类型选择的核心原则：**

1. **标量字段**：根据数据范围选择合适的类型
2. **向量字段**：根据 Embedding 模型选择维度
3. **主键字段**：优先使用 INT64，需要字符串ID时用 VARCHAR
4. **存储优化**：选择最小满足需求的类型
5. **查询优化**：避免过度使用 JSON 和 VARCHAR

**下一步：** 了解如何使用这些字段类型创建完整的 Collection（最小可用知识）
