# 化骨绵掌

## 卡片1：环境变量的本质

**一句话：** 环境变量是操作系统提供的键值对存储，让应用在不修改代码的情况下适应不同运行环境。

**举例：**
```python
import os
DATABASE_URL = os.getenv("DATABASE_URL")
# 开发环境：localhost:5432
# 生产环境：prod-db.example.com:5432
```

**应用：** 在 AI Agent 后端中，用环境变量管理数据库连接、API 密钥、调试开关等配置，实现开发/测试/生产环境的无缝切换。

---

## 卡片2：python-dotenv 的作用

**一句话：** python-dotenv 将 .env 文件中的配置加载到系统环境变量，简化本地开发的配置管理。

**举例：**
```python
from dotenv import load_dotenv
load_dotenv()  # 加载 .env 文件

# 现在可以用 os.getenv() 读取配置
```

**应用：** 开发时用 .env 文件管理配置，避免每次启动都要手动设置环境变量。生产环境直接用系统环境变量，不需要 .env 文件。

---

## 卡片3：Pydantic Settings 的优势

**一句话：** Pydantic Settings 提供类型安全的配置管理，自动验证、转换类型，并在启动时发现配置错误。

**举例：**
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str  # 必需字段
    port: int = 8000   # 自动转换为整数

settings = Settings()  # 缺少配置立即报错
```

**应用：** 在 FastAPI 应用中，用 Pydantic Settings 管理所有配置，确保类型正确、必需字段存在，避免运行时才发现配置问题。

---

## 卡片4：12-Factor App 配置原则

**一句话：** 12-Factor App 要求配置与代码严格分离，存储在环境变量中，不同环境使用相同代码。

**举例：**
```python
# ✅ 正确：配置在环境变量中
DATABASE_URL = os.getenv("DATABASE_URL")

# ❌ 错误：配置硬编码在代码中
DATABASE_URL = "postgresql://localhost:5432/mydb"
```

**应用：** 遵循 12-Factor App 原则，让同一个 Docker 镜像可以在开发、测试、生产环境中使用，只需改变环境变量。

---

## 卡片5：配置优先级规则

**一句话：** 配置按优先级加载：系统环境变量 > .env 文件 > 默认值，外部配置覆盖内部配置。

**举例：**
```python
# 默认值
debug: bool = False

# .env 文件
DEBUG=True

# 系统环境变量
export DEBUG=False

# 最终结果：False（系统环境变量优先）
```

**应用：** 开发时用 .env 文件，部署时用系统环境变量覆盖，实现灵活的配置管理。

---

## 卡片6：多环境文件模式

**一句话：** 使用多个 .env 文件（.env.dev、.env.test、.env.prod）分别存储不同环境的配置。

**举例：**
```python
env = os.getenv("ENV", "dev")
load_dotenv(f".env.{env}")

# ENV=dev → 加载 .env.dev
# ENV=prod → 加载 .env.prod
```

**应用：** 团队共享 .env.dev 和 .env.test，个人用 .env.local 覆盖，生产环境用 .env.prod（不提交到 git）。

---

## 卡片7：Docker 环境变量注入

**一句话：** Docker 容器通过 -e 参数或 docker-compose 的 environment 注入环境变量，让同一镜像适应不同环境。

**举例：**
```yaml
services:
  api:
    environment:
      - DATABASE_URL=postgresql://db:5432/mydb
      - DEBUG=False
```

**应用：** 构建一次镜像，通过环境变量在不同环境中部署，避免为每个环境构建不同镜像。

---

## 卡片8：敏感信息保护

**一句话：** 敏感信息（API 密钥、密码）不应硬编码或提交到 git，应通过环境变量注入并在日志中隐藏。

**举例：**
```python
from pydantic import SecretStr

class Settings(BaseSettings):
    api_key: SecretStr  # 自动隐藏

print(settings.api_key)  # SecretStr('**********')
```

**应用：** 使用 SecretStr 保护敏感信息，配置 .gitignore 排除 .env 文件，生产环境用云平台密钥管理服务。

---

## 卡片9：配置验证机制

**一句话：** 在应用启动时验证配置的完整性和正确性，快速失败而不是运行时才报错。

**举例：**
```python
@field_validator("port")
@classmethod
def validate_port(cls, v: int) -> int:
    if v < 1024 or v > 65535:
        raise ValueError("端口号必须在 1024-65535 之间")
    return v
```

**应用：** 使用 Pydantic 的验证器检查配置格式、范围、环境特定规则，确保应用在正确的配置下启动。

---

## 卡片10：环境变量管理的最佳实践

**一句话：** 配置分层加载、类型验证、敏感信息保护、环境隔离、文档化是环境变量管理的核心实践。

**举例：**
```python
# 1. 多层加载
load_dotenv(".env")
load_dotenv(f".env.{env}", override=True)
load_dotenv(".env.local", override=True)

# 2. 类型验证
class Settings(BaseSettings):
    database_url: str  # 自动验证

# 3. 敏感信息保护
api_key: SecretStr

# 4. 环境隔离
if env == "prod" and debug:
    raise ValueError("生产环境不能启用调试")
```

**应用：** 在生产级 AI Agent 项目中，综合运用这些实践，构建安全、可靠、易维护的配置系统。
