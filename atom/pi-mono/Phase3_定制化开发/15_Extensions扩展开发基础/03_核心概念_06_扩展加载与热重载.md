# Extensions 扩展开发基础 - 核心概念 06：扩展加载与热重载

> 深入理解 Extensions 的发现机制、加载流程和热重载实现

---

## 概述

本文档深入讲解 Extensions 的加载和热重载机制，包括：
- Extension 发现机制（全局、项目本地、显式加载）
- jiti 动态加载和虚拟模块
- 热重载实现（/reload 命令）
- 错误处理和冲突检测

---

## 1. Extension 发现机制

### 1.1 三种发现方式

**pi-mono 支持三种 Extension 发现方式：**

```
1. 全局扩展（Global Extensions）
   ~/.pi/agent/extensions/
   ├── extension1.ts
   ├── extension2.ts
   └── extension3.ts

2. 项目扩展（Project Extensions）
   .pi/extensions/
   ├── project-extension1.ts
   └── project-extension2.ts

3. 显式加载（Explicit Loading）
   pi --extension ./my-extension.ts
   pi --extension /path/to/extension.ts
```

### 1.2 加载优先级

**加载顺序：**

```
1. 全局扩展（~/.pi/agent/extensions/）
   ↓
2. 项目扩展（.pi/extensions/）
   ↓
3. 显式加载（--extension 参数）
```

**注意：加载顺序不保证 Extension 的执行顺序！**

### 1.3 发现算法

**Extension 发现的实现：**

```typescript
class ExtensionManager {
  async discoverExtensions(): Promise<string[]> {
    const extensions: string[] = [];

    // 1. 全局扩展
    const globalDir = path.join(os.homedir(), ".pi", "agent", "extensions");
    if (fs.existsSync(globalDir)) {
      const files = fs.readdirSync(globalDir);
      for (const file of files) {
        if (file.endsWith(".ts") || file.endsWith(".js")) {
          extensions.push(path.join(globalDir, file));
        }
      }
    }

    // 2. 项目扩展
    const projectDir = path.join(process.cwd(), ".pi", "extensions");
    if (fs.existsSync(projectDir)) {
      const files = fs.readdirSync(projectDir);
      for (const file of files) {
        if (file.endsWith(".ts") || file.endsWith(".js")) {
          extensions.push(path.join(projectDir, file));
        }
      }
    }

    // 3. 显式加载（从命令行参数）
    for (const explicitPath of this.explicitExtensions) {
      extensions.push(path.resolve(explicitPath));
    }

    return extensions;
  }
}
```

---

## 2. jiti 动态加载

### 2.1 什么是 jiti？

**jiti 是一个 TypeScript 运行时加载器：**

- 动态编译 TypeScript 到 JavaScript
- 支持 ESM 和 CommonJS
- 无需预编译
- 支持模块缓存

**为什么使用 jiti？**

```typescript
// 传统方式：需要预编译
// 1. tsc extension.ts → extension.js
// 2. node extension.js

// jiti 方式：直接运行
// jiti.import("extension.ts") → 自动编译并执行
```

### 2.2 jiti 加载流程

```
Extension 文件（.ts）
  ↓
jiti.import(filePath)
  ↓
1. 检查模块缓存
   ├→ 已缓存 → 返回缓存的模块
   └→ 未缓存 → 继续
  ↓
2. 读取文件内容
  ↓
3. 使用 esbuild 编译 TypeScript
  ↓
4. 解析 import 语句
  ↓
5. 递归加载依赖
  ↓
6. 执行模块代码
  ↓
7. 缓存模块
  ↓
8. 返回 exports
```

### 2.3 jiti 配置

**pi-mono 的 jiti 配置：**

```typescript
import { createJiti } from "jiti";

const jiti = createJiti(__filename, {
  // 启用 ESM 支持
  interopDefault: true,

  // 启用模块缓存
  cache: true,

  // 启用源码映射
  sourceMaps: true,

  // 转换选项
  transform: {
    // 使用 esbuild 编译
    loader: "ts",
  },
});
```

---

## 3. Extension 加载流程

### 3.1 完整加载流程

```
启动 pi
  ↓
1. 初始化 ExtensionManager
  ↓
2. 发现 Extensions
   - 扫描全局目录
   - 扫描项目目录
   - 添加显式加载的扩展
  ↓
3. 加载每个 Extension
   ├→ 使用 jiti 加载模块
   ├→ 验证默认导出
   ├→ 调用工厂函数
   ├→ 注册功能（工具、命令、事件）
   └→ 保存扩展实例
  ↓
4. 检测冲突
   - 工具名称冲突
   - 命令名称冲突
  ↓
5. 完成加载
  ↓
Agent 运行
```

### 3.2 加载实现

**ExtensionManager 的加载实现：**

```typescript
class ExtensionManager {
  private extensions: Map<string, LoadedExtension> = new Map();
  private jiti: Jiti;

  async loadAllExtensions() {
    // 1. 发现扩展
    const extensionPaths = await this.discoverExtensions();

    // 2. 加载每个扩展
    for (const filePath of extensionPaths) {
      try {
        await this.loadExtension(filePath);
      } catch (error) {
        console.error(`Failed to load extension: ${filePath}`);
        console.error(error);
      }
    }

    // 3. 检测冲突
    this.detectConflicts();
  }

  async loadExtension(filePath: string) {
    // 1. 使用 jiti 加载模块
    const module = await this.jiti.import(filePath);

    // 2. 验证默认导出
    const factory = module.default;
    if (typeof factory !== "function") {
      throw new Error(`Extension ${filePath} must export a default function`);
    }

    // 3. 调用工厂函数
    const dispose = factory(this.extensionAPI);

    // 4. 保存扩展实例
    this.extensions.set(filePath, {
      filePath,
      factory,
      dispose,
      loadedAt: Date.now(),
    });

    console.log(`Loaded extension: ${path.basename(filePath)}`);
  }
}
```

### 3.3 虚拟模块

**pi-mono 提供的虚拟模块：**

```typescript
// 虚拟模块：不需要安装，jiti 自动解析

// @mariozechner/pi-coding-agent
import type {
  ExtensionAPI,
  ExtensionContext,
  ToolDefinition,
} from "@mariozechner/pi-coding-agent";

// @mariozechner/pi-ai
import { StringEnum } from "@mariozechner/pi-ai";
import { Type } from "@sinclair/typebox";

// @mariozechner/pi-tui
import { Text, Box, matchesKey } from "@mariozechner/pi-tui";
```

**虚拟模块的实现：**

```typescript
// jiti 配置中添加虚拟模块解析
const jiti = createJiti(__filename, {
  alias: {
    "@mariozechner/pi-coding-agent": path.join(__dirname, "types.ts"),
    "@mariozechner/pi-ai": path.join(__dirname, "../pi-ai/index.ts"),
    "@mariozechner/pi-tui": path.join(__dirname, "../pi-tui/index.ts"),
  },
});
```

---

## 4. 热重载机制

### 4.1 什么是热重载？

**热重载（Hot Reload）**：在不重启程序的情况下，重新加载代码。

**为什么需要热重载？**

```
传统开发流程：
1. 修改代码
2. 退出 pi
3. 重新启动 pi
4. 丢失 Session 状态
5. 重新开始工作

热重载流程：
1. 修改代码
2. 运行 /reload
3. 扩展更新
4. Session 状态保留
5. 继续工作
```

### 4.2 /reload 命令

**使用 /reload 命令：**

```bash
# 在 pi 会话中
/reload

# 输出：
# Unloading 3 extensions...
# Clearing module cache...
# Loading extensions...
# Loaded: extension1.ts
# Loaded: extension2.ts
# Loaded: extension3.ts
# ✓ Reload complete
```

### 4.3 热重载实现

**完整的热重载实现：**

```typescript
class ExtensionManager {
  async reload() {
    console.log("Reloading extensions...");

    // 1. 卸载所有扩展
    console.log(`Unloading ${this.extensions.size} extensions...`);
    for (const ext of this.extensions.values()) {
      if (ext.dispose) {
        try {
          await ext.dispose();
        } catch (error) {
          console.error("Error disposing extension:", error);
        }
      }
    }
    this.extensions.clear();

    // 2. 清除模块缓存
    console.log("Clearing module cache...");
    this.clearModuleCache();

    // 3. 重新加载扩展
    console.log("Loading extensions...");
    await this.loadAllExtensions();

    console.log("✓ Reload complete");
  }

  clearModuleCache() {
    // 清除 Node.js 模块缓存
    for (const key of Object.keys(require.cache)) {
      // 只清除扩展相关的模块
      if (
        key.includes("/extensions/") ||
        key.includes("/.pi/extensions/")
      ) {
        delete require.cache[key];
      }
    }

    // 清除 jiti 缓存
    this.jiti = createJiti(__filename, { cache: false });
  }
}
```

### 4.4 清理函数

**Extension 可以返回清理函数：**

```typescript
export default function (pi: ExtensionAPI) {
  // 初始化
  const timers = [];
  const listeners = [];

  // 创建定时器
  const timer = setInterval(() => {
    console.log("Heartbeat");
  }, 1000);
  timers.push(timer);

  // 注册事件监听器
  const handler = async (event, ctx) => {
    console.log("Event:", event);
  };
  pi.on("tool_call", handler);
  listeners.push({ event: "tool_call", handler });

  // 返回清理函数
  return () => {
    console.log("Cleaning up extension...");

    // 清理定时器
    for (const timer of timers) {
      clearInterval(timer);
    }

    // 移除事件监听器
    for (const { event, handler } of listeners) {
      pi.off(event, handler);
    }
  };
}
```

---

## 5. 错误处理

### 5.1 加载错误

**处理 Extension 加载错误：**

```typescript
async loadExtension(filePath: string) {
  try {
    // 加载模块
    const module = await this.jiti.import(filePath);

    // 验证导出
    if (!module.default) {
      throw new Error("Extension must export a default function");
    }

    if (typeof module.default !== "function") {
      throw new Error("Default export must be a function");
    }

    // 调用工厂函数
    const dispose = module.default(this.extensionAPI);

    // 验证返回值
    if (dispose !== undefined && typeof dispose !== "function") {
      throw new Error("Extension must return undefined or a cleanup function");
    }

    // 保存扩展
    this.extensions.set(filePath, {
      filePath,
      factory: module.default,
      dispose,
      loadedAt: Date.now(),
    });

    console.log(`✓ Loaded: ${path.basename(filePath)}`);
  } catch (error) {
    console.error(`✗ Failed to load: ${path.basename(filePath)}`);
    console.error(`  Error: ${error.message}`);

    // 记录详细错误
    if (error.stack) {
      console.error(`  Stack: ${error.stack}`);
    }

    // 不抛出错误，继续加载其他扩展
  }
}
```

### 5.2 运行时错误

**处理 Extension 运行时错误：**

```typescript
class ExtensionAPI {
  on<E extends EventType>(event: E, handler: EventHandler<E>) {
    // 包装处理器，捕获错误
    const wrappedHandler = async (eventData, ctx) => {
      try {
        return await handler(eventData, ctx);
      } catch (error) {
        console.error(`Error in event handler for ${event}:`, error);
        // 不阻止其他处理器执行
      }
    };

    this.eventEmitter.on(event, wrappedHandler);
  }

  registerTool(definition: ToolDefinition) {
    // 包装执行函数，捕获错误
    const originalExecute = definition.execute;
    definition.execute = async (toolCallId, params, signal, onUpdate, ctx) => {
      try {
        return await originalExecute(toolCallId, params, signal, onUpdate, ctx);
      } catch (error) {
        console.error(`Error executing tool ${definition.name}:`, error);
        return {
          content: [{ type: "text", text: `Error: ${error.message}` }],
          details: { error: error.message },
        };
      }
    };

    this.tools.set(definition.name, definition);
  }
}
```

---

## 6. 冲突检测

### 6.1 工具名称冲突

**检测工具名称冲突：**

```typescript
class ExtensionManager {
  detectConflicts() {
    const toolNames = new Map<string, string[]>();

    // 收集所有工具名称
    for (const [filePath, ext] of this.extensions) {
      for (const toolName of ext.registeredTools) {
        if (!toolNames.has(toolName)) {
          toolNames.set(toolName, []);
        }
        toolNames.get(toolName).push(filePath);
      }
    }

    // 检测冲突
    for (const [toolName, filePaths] of toolNames) {
      if (filePaths.length > 1) {
        console.warn(`⚠️  Tool name conflict: ${toolName}`);
        console.warn(`   Registered by:`);
        for (const filePath of filePaths) {
          console.warn(`   - ${path.basename(filePath)}`);
        }
        console.warn(`   Last registration wins.`);
      }
    }
  }
}
```

### 6.2 命令名称冲突

**检测命令名称冲突：**

```typescript
detectConflicts() {
  const commandNames = new Map<string, string[]>();

  // 收集所有命令名称
  for (const [filePath, ext] of this.extensions) {
    for (const commandName of ext.registeredCommands) {
      if (!commandNames.has(commandName)) {
        commandNames.set(commandName, []);
      }
      commandNames.get(commandName).push(filePath);
    }
  }

  // 检测冲突
  for (const [commandName, filePaths] of commandNames) {
    if (filePaths.length > 1) {
      console.warn(`⚠️  Command name conflict: /${commandName}`);
      console.warn(`   Registered by:`);
      for (const filePath of filePaths) {
        console.warn(`   - ${path.basename(filePath)}`);
      }
      console.warn(`   Last registration wins.`);
    }
  }
}
```

### 6.3 解决冲突

**冲突解决策略：**

```
1. 最后注册优先（Last Registration Wins）
   - 后加载的扩展覆盖先加载的扩展
   - 显式加载 > 项目扩展 > 全局扩展

2. 命名空间（Namespacing）
   - 使用前缀避免冲突
   - 例如：my-extension:tool_name

3. 禁用扩展（Disable Extension）
   - 在配置中禁用冲突的扩展
```

**示例：使用命名空间**

```typescript
// extension1.ts
pi.registerTool({
  name: "ext1:deploy",  // 使用前缀
  description: "Deploy from extension 1",
  // ...
});

// extension2.ts
pi.registerTool({
  name: "ext2:deploy",  // 使用前缀
  description: "Deploy from extension 2",
  // ...
});
```

---

## 7. 调试和监控

### 7.1 加载日志

**详细的加载日志：**

```typescript
async loadExtension(filePath: string) {
  const startTime = Date.now();

  console.log(`Loading: ${path.basename(filePath)}`);

  try {
    // 加载模块
    const module = await this.jiti.import(filePath);
    console.log(`  ✓ Module loaded (${Date.now() - startTime}ms)`);

    // 调用工厂函数
    const dispose = module.default(this.extensionAPI);
    console.log(`  ✓ Factory called (${Date.now() - startTime}ms)`);

    // 记录注册的功能
    console.log(`  ✓ Registered:`);
    console.log(`    - Tools: ${ext.registeredTools.length}`);
    console.log(`    - Commands: ${ext.registeredCommands.length}`);
    console.log(`    - Event listeners: ${ext.registeredListeners.length}`);

    console.log(`✓ Loaded: ${path.basename(filePath)} (${Date.now() - startTime}ms)`);
  } catch (error) {
    console.error(`✗ Failed: ${path.basename(filePath)} (${Date.now() - startTime}ms)`);
    console.error(`  Error: ${error.message}`);
  }
}
```

### 7.2 扩展信息命令

**添加 /extensions 命令查看已加载的扩展：**

```typescript
pi.registerCommand("extensions", {
  description: "List loaded extensions",
  handler: async (args, ctx) => {
    const extensions = Array.from(this.extensions.values());

    if (extensions.length === 0) {
      ctx.ui.notify("No extensions loaded", "info");
      return;
    }

    const info = [
      `Loaded Extensions (${extensions.length}):`,
      "─".repeat(60),
    ];

    for (const ext of extensions) {
      const name = path.basename(ext.filePath);
      const age = Math.round((Date.now() - ext.loadedAt) / 1000);
      info.push(`${name} (loaded ${age}s ago)`);
      info.push(`  Tools: ${ext.registeredTools.join(", ") || "none"}`);
      info.push(`  Commands: ${ext.registeredCommands.join(", ") || "none"}`);
      info.push("");
    }

    ctx.ui.notify(info.join("\n"), "info");
  },
});
```

---

## 8. 性能优化

### 8.1 延迟加载

**延迟加载不常用的扩展：**

```typescript
class ExtensionManager {
  private lazyExtensions: Map<string, () => Promise<void>> = new Map();

  async loadExtensionLazy(filePath: string) {
    // 注册延迟加载函数
    this.lazyExtensions.set(filePath, async () => {
      await this.loadExtension(filePath);
    });
  }

  async loadLazyExtension(filePath: string) {
    const loader = this.lazyExtensions.get(filePath);
    if (loader) {
      await loader();
      this.lazyExtensions.delete(filePath);
    }
  }
}
```

### 8.2 并行加载

**并行加载多个扩展：**

```typescript
async loadAllExtensions() {
  const extensionPaths = await this.discoverExtensions();

  // 并行加载所有扩展
  await Promise.all(
    extensionPaths.map(filePath => this.loadExtension(filePath))
  );

  // 检测冲突
  this.detectConflicts();
}
```

### 8.3 缓存优化

**优化模块缓存：**

```typescript
// 开发模式：禁用缓存，支持热重载
const devJiti = createJiti(__filename, {
  cache: false,
  sourceMaps: true,
});

// 生产模式：启用缓存，提升性能
const prodJiti = createJiti(__filename, {
  cache: true,
  sourceMaps: false,
});
```

---

## 9. 最佳实践

### 9.1 Extension 组织

```
推荐的目录结构：

~/.pi/agent/extensions/
├── core/                    # 核心扩展（总是加载）
│   ├── logging.ts
│   └── safety.ts
├── optional/                # 可选扩展（按需加载）
│   ├── git-integration.ts
│   └── custom-tools.ts
└── experimental/            # 实验性扩展
    └── new-feature.ts

.pi/extensions/              # 项目特定扩展
├── project-tools.ts
└── team-workflows.ts
```

### 9.2 错误处理

```typescript
// ✅ 好：捕获并记录错误
export default function (pi: ExtensionAPI) {
  try {
    pi.registerTool({ ... });
  } catch (error) {
    console.error("Failed to register tool:", error);
  }

  pi.on("tool_call", async (event, ctx) => {
    try {
      // 处理事件
    } catch (error) {
      console.error("Event handler error:", error);
    }
  });
}

// ❌ 不好：让错误传播
export default function (pi: ExtensionAPI) {
  pi.registerTool({ ... }); // 可能抛出错误
  pi.on("tool_call", async (event, ctx) => {
    // 可能抛出错误
  });
}
```

### 9.3 清理资源

```typescript
// ✅ 好：返回清理函数
export default function (pi: ExtensionAPI) {
  const resources = [];

  // 创建资源
  const timer = setInterval(() => { ... }, 1000);
  resources.push(timer);

  // 返回清理函数
  return () => {
    for (const resource of resources) {
      clearInterval(resource);
    }
  };
}

// ❌ 不好：不清理资源
export default function (pi: ExtensionAPI) {
  setInterval(() => { ... }, 1000);
  // 热重载时定时器会泄漏
}
```

---

## 10. 总结

### 核心要点

1. **发现机制**：全局、项目本地、显式加载三种方式
2. **jiti 加载**：动态编译 TypeScript，支持虚拟模块
3. **热重载**：/reload 命令，无需重启
4. **错误处理**：捕获加载和运行时错误
5. **冲突检测**：检测工具和命令名称冲突
6. **清理函数**：返回清理函数，支持热重载
7. **性能优化**：并行加载、缓存优化

### 下一步

- **核心概念 07**：扩展开发模式
- **实战代码**：完整扩展实战

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: pi-mono 2025-2026 版本
