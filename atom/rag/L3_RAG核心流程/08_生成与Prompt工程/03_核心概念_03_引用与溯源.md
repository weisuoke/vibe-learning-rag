# 核心概念3：引用与溯源

> Citation-aware RAG with Spatial Metadata - 2025-2026生产级可追溯性标准

---

## 概述

引用与溯源是RAG系统可信度的关键，让用户能够验证答案来源，追溯到原始文档的精确位置。2025-2026年的标准已从简单的文档ID标注进化到带空间元数据的精确定位。

**核心价值：**
1. **可验证性** - 用户可以检查答案的准确性
2. **可信度** - 提供来源增强用户信任
3. **可审计性** - 生产环境必需的追溯能力
4. **法律合规** - 某些领域的监管要求

---

## 1. 引用系统的演进

### 1.1 三代引用技术

```python
# ===== 第一代：文档ID标注（2023） =====
answer_v1 = "Python是一种解释型语言 [doc1]"
# 问题：只知道来自哪个文档，无法定位具体位置

# ===== 第二代：文档+页码（2024） =====
answer_v2 = "Python是一种解释型语言 [doc1, p.15]"
# 问题：页码粗糙，无法精确定位段落或句子

# ===== 第三代：空间元数据（2025-2026） =====
answer_v3 = "Python是一种解释型语言 <c>1.2</c>"
citations = {
    "1.2": {
        "doc_id": "doc1",
        "page": 15,
        "bbox": [100, 200, 400, 250],  # 精确位置
        "text": "Python is an interpreted language...",
        "confidence": 0.92
    }
}
# 优势：精确到像素级，可视化高亮，支持验证
```

### 1.2 2025-2026标准：Citation-aware RAG

**来源：** Tensorlake "Citation-Aware RAG: How to add Fine Grained Citations" (2025年9月)
https://www.tensorlake.ai/blog/rag-citations

**核心技术：**
1. **Inline Citation Anchors** - 内联引用锚点 `<c>X.Y</c>`
2. **Spatial Metadata** - 空间元数据（bounding box坐标）
3. **Confidence Scores** - 引用置信度
4. **Visual Highlighting** - 可视化高亮支持

---

## 2. 基础引用实现

### 2.1 简单文档ID引用

```python
from openai import OpenAI
import os

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def generate_with_simple_citations(query: str, docs: list) -> dict:
    """
    生成带简单引用的答案
    """
    # 构建带编号的上下文
    context = "\n\n".join([
        f"[文档{i+1}] {doc['content']}"
        for i, doc in enumerate(docs)
    ])

    prompt = f"""
参考资料：
{context}

问题：{query}

要求：
1. 基于参考资料回答
2. 为每个关键信息添加引用标记，格式：[文档X]
3. 如果信息不足，明确说明

回答：
"""

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "你是一个严谨的知识助手"},
            {"role": "user", "content": prompt}
        ],
        temperature=0.1
    )

    answer = response.choices[0].message.content

    # 提取引用
    import re
    citations = re.findall(r'\[文档(\d+)\]', answer)

    return {
        "answer": answer,
        "citations": [
            {"id": int(c), "doc": docs[int(c)-1]}
            for c in set(citations)
        ]
    }

# 使用示例
docs = [
    {"content": "Python是一种解释型语言", "source": "python_intro.pdf"},
    {"content": "Python支持面向对象编程", "source": "python_oop.pdf"}
]

result = generate_with_simple_citations("Python有什么特点？", docs)

print("答案：", result["answer"])
print("\n引用来源：")
for cite in result["citations"]:
    print(f"  文档{cite['id']}: {cite['doc']['source']}")
```

### 2.2 带页码的引用

```python
def generate_with_page_citations(query: str, docs: list) -> dict:
    """
    生成带页码引用的答案
    """
    # 构建带页码的上下文
    context = "\n\n".join([
        f"[文档{i+1}, 第{doc.get('page', 'N/A')}页]\n{doc['content']}"
        for i, doc in enumerate(docs)
    ])

    prompt = f"""
参考资料：
{context}

问题：{query}

要求：
1. 基于参考资料回答
2. 为关键信息添加引用，格式：[文档X, p.Y]
3. 如果信息不足，明确说明

回答：
"""

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "你是一个严谨的知识助手"},
            {"role": "user", "content": prompt}
        ],
        temperature=0.1
    )

    answer = response.choices[0].message.content

    # 提取引用（文档+页码）
    import re
    citations = re.findall(r'\[文档(\d+),\s*p\.(\d+)\]', answer)

    return {
        "answer": answer,
        "citations": [
            {
                "doc_id": int(doc_id),
                "page": int(page),
                "source": docs[int(doc_id)-1].get('source', 'Unknown')
            }
            for doc_id, page in set(citations)
        ]
    }

# 使用示例
docs = [
    {"content": "Python是一种解释型语言", "source": "python_intro.pdf", "page": 15},
    {"content": "Python支持面向对象编程", "source": "python_oop.pdf", "page": 23}
]

result = generate_with_page_citations("Python有什么特点？", docs)

print("答案：", result["answer"])
print("\n引用来源：")
for cite in result["citations"]:
    print(f"  文档{cite['doc_id']}, 第{cite['page']}页: {cite['source']}")
```

---

## 3. Citation-aware RAG（2025-2026标准）

### 3.1 空间元数据结构

```python
from typing import Dict, List, Tuple
from dataclasses import dataclass

@dataclass
class SpatialMetadata:
    """
    空间元数据：精确定位文档中的位置
    """
    doc_id: str
    page: int
    bbox: Tuple[float, float, float, float]  # (x1, y1, x2, y2)
    text: str
    confidence: float

@dataclass
class Citation:
    """
    引用对象
    """
    id: str  # 引用ID，如 "1.2"
    metadata: SpatialMetadata
    context: str  # 周围上下文

class CitationManager:
    """
    引用管理器
    """

    def __init__(self):
        self.citations: Dict[str, Citation] = {}
        self.next_id = 1

    def add_citation(
        self,
        doc_id: str,
        page: int,
        bbox: Tuple[float, float, float, float],
        text: str,
        context: str = "",
        confidence: float = 1.0
    ) -> str:
        """
        添加引用，返回引用ID
        """
        citation_id = f"{self.next_id}.{len(self.citations) + 1}"

        metadata = SpatialMetadata(
            doc_id=doc_id,
            page=page,
            bbox=bbox,
            text=text,
            confidence=confidence
        )

        citation = Citation(
            id=citation_id,
            metadata=metadata,
            context=context
        )

        self.citations[citation_id] = citation
        return citation_id

    def get_citation(self, citation_id: str) -> Citation:
        """
        获取引用详情
        """
        return self.citations.get(citation_id)

    def format_citation(self, citation_id: str) -> str:
        """
        格式化引用信息
        """
        citation = self.get_citation(citation_id)
        if not citation:
            return "引用未找到"

        meta = citation.metadata
        return f"""
引用 {citation.id}:
- 文档: {meta.doc_id}
- 页码: {meta.page}
- 位置: {meta.bbox}
- 原文: {meta.text}
- 置信度: {meta.confidence:.2f}
"""

# 使用示例
manager = CitationManager()

# 添加引用
cite_id1 = manager.add_citation(
    doc_id="python_intro.pdf",
    page=15,
    bbox=(100, 200, 400, 250),
    text="Python is an interpreted language",
    confidence=0.95
)

cite_id2 = manager.add_citation(
    doc_id="python_oop.pdf",
    page=23,
    bbox=(150, 300, 450, 350),
    text="Python supports object-oriented programming",
    confidence=0.92
)

print(manager.format_citation(cite_id1))
print(manager.format_citation(cite_id2))
```

### 3.2 生成带空间引用的答案

```python
def generate_with_spatial_citations(
    query: str,
    docs: List[Dict],
    citation_manager: CitationManager
) -> dict:
    """
    生成带空间元数据引用的答案
    """
    # 为每个文档创建引用
    context_with_citations = []

    for i, doc in enumerate(docs):
        # 添加引用到管理器
        cite_id = citation_manager.add_citation(
            doc_id=doc.get('doc_id', f'doc{i+1}'),
            page=doc.get('page', 1),
            bbox=doc.get('bbox', (0, 0, 0, 0)),
            text=doc['content'],
            confidence=doc.get('score', 1.0)
        )

        # 构建带引用ID的上下文
        context_with_citations.append(
            f"[引用{cite_id}] {doc['content']}"
        )

    context = "\n\n".join(context_with_citations)

    prompt = f"""
参考资料：
{context}

问题：{query}

要求：
1. 基于参考资料回答
2. 为关键信息添加引用标记，格式：<c>X.Y</c>
3. 使用提供的引用ID
4. 如果信息不足，明确说明

回答：
"""

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "你是一个严谨的知识助手"},
            {"role": "user", "content": prompt}
        ],
        temperature=0.1
    )

    answer = response.choices[0].message.content

    # 提取引用ID
    import re
    citation_ids = re.findall(r'<c>([\d.]+)</c>', answer)

    # 获取引用详情
    citations = [
        citation_manager.get_citation(cid)
        for cid in set(citation_ids)
        if citation_manager.get_citation(cid)
    ]

    return {
        "answer": answer,
        "citations": citations,
        "citation_count": len(citations)
    }

# 使用示例
manager = CitationManager()

docs = [
    {
        "content": "Python是一种解释型语言",
        "doc_id": "python_intro.pdf",
        "page": 15,
        "bbox": (100, 200, 400, 250),
        "score": 0.95
    },
    {
        "content": "Python支持面向对象编程",
        "doc_id": "python_oop.pdf",
        "page": 23,
        "bbox": (150, 300, 450, 350),
        "score": 0.92
    }
]

result = generate_with_spatial_citations("Python有什么特点？", docs, manager)

print("答案：", result["answer"])
print(f"\n引用数量：{result['citation_count']}")
print("\n引用详情：")
for citation in result["citations"]:
    print(manager.format_citation(citation.id))
```

---

## 4. 引用验证与质量控制

### 4.1 引用准确性验证

```python
def verify_citation_accuracy(
    answer: str,
    citations: List[Citation]
) -> dict:
    """
    验证引用的准确性
    """
    results = {
        "total_citations": len(citations),
        "verified": 0,
        "unverified": 0,
        "issues": []
    }

    for citation in citations:
        # 检查引用文本是否在答案中
        if citation.metadata.text.lower() in answer.lower():
            results["verified"] += 1
        else:
            results["unverified"] += 1
            results["issues"].append({
                "citation_id": citation.id,
                "issue": "引用文本未在答案中出现",
                "text": citation.metadata.text
            })

        # 检查置信度
        if citation.metadata.confidence < 0.7:
            results["issues"].append({
                "citation_id": citation.id,
                "issue": "置信度过低",
                "confidence": citation.metadata.confidence
            })

    results["accuracy"] = results["verified"] / results["total_citations"] if results["total_citations"] > 0 else 0

    return results

# 使用示例
answer = "Python是一种解释型语言<c>1.1</c>，支持面向对象编程<c>1.2</c>。"
citations = result["citations"]

verification = verify_citation_accuracy(answer, citations)

print("验证结果：")
print(f"  总引用数：{verification['total_citations']}")
print(f"  已验证：{verification['verified']}")
print(f"  未验证：{verification['unverified']}")
print(f"  准确率：{verification['accuracy']:.2%}")

if verification["issues"]:
    print("\n问题：")
    for issue in verification["issues"]:
        print(f"  - {issue}")
```

### 4.2 引用覆盖率检查

```python
def check_citation_coverage(answer: str, context: str) -> dict:
    """
    检查答案中的关键信息是否都有引用
    """
    # 使用LLM识别答案中的关键事实
    check_prompt = f"""
分析以下答案，识别所有关键事实陈述。

答案：
{answer}

请列出所有关键事实（每行一个）：
"""

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "你是一个事实分析专家"},
            {"role": "user", "content": check_prompt}
        ],
        temperature=0
    )

    facts = response.choices[0].message.content.strip().split('\n')

    # 检查每个事实是否有引用
    import re
    citation_pattern = r'<c>[\d.]+</c>'

    results = {
        "total_facts": len(facts),
        "cited_facts": 0,
        "uncited_facts": []
    }

    for fact in facts:
        if re.search(citation_pattern, fact):
            results["cited_facts"] += 1
        else:
            results["uncited_facts"].append(fact)

    results["coverage"] = results["cited_facts"] / results["total_facts"] if results["total_facts"] > 0 else 0

    return results

# 使用示例
coverage = check_citation_coverage(answer, context)

print("引用覆盖率：")
print(f"  总事实数：{coverage['total_facts']}")
print(f"  已引用：{coverage['cited_facts']}")
print(f"  覆盖率：{coverage['coverage']:.2%}")

if coverage["uncited_facts"]:
    print("\n未引用的事实：")
    for fact in coverage["uncited_facts"]:
        print(f"  - {fact}")
```

---

## 5. 可视化与用户交互

### 5.1 引用高亮显示

```python
def format_answer_with_highlights(
    answer: str,
    citations: List[Citation]
) -> str:
    """
    格式化答案，添加引用高亮
    """
    # 替换引用标记为可点击链接（Markdown格式）
    import re

    def replace_citation(match):
        cite_id = match.group(1)
        citation = next((c for c in citations if c.id == cite_id), None)

        if citation:
            meta = citation.metadata
            tooltip = f"{meta.doc_id}, p.{meta.page}"
            return f"[{match.group(0)}]({tooltip})"
        return match.group(0)

    highlighted = re.sub(
        r'<c>([\d.]+)</c>',
        replace_citation,
        answer
    )

    return highlighted

# 使用示例
highlighted_answer = format_answer_with_highlights(answer, citations)
print("高亮答案：")
print(highlighted_answer)
```

### 5.2 引用详情展示

```python
def generate_citation_sidebar(citations: List[Citation]) -> str:
    """
    生成引用侧边栏（Markdown格式）
    """
    sidebar = "## 引用来源\n\n"

    for citation in citations:
        meta = citation.metadata
        sidebar += f"""
### 引用 {citation.id}

**文档：** {meta.doc_id}
**页码：** {meta.page}
**置信度：** {meta.confidence:.2%}
**原文：**
> {meta.text}

**位置：** `{meta.bbox}`

---
"""

    return sidebar

# 使用示例
sidebar = generate_citation_sidebar(citations)
print(sidebar)
```

---

## 6. 生产环境最佳实践

### 6.1 引用存储与检索

```python
import json
from pathlib import Path

class CitationStore:
    """
    引用持久化存储
    """

    def __init__(self, storage_path: str = "./citations"):
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(exist_ok=True)

    def save_citations(
        self,
        session_id: str,
        answer: str,
        citations: List[Citation]
    ):
        """
        保存引用数据
        """
        data = {
            "session_id": session_id,
            "answer": answer,
            "citations": [
                {
                    "id": c.id,
                    "doc_id": c.metadata.doc_id,
                    "page": c.metadata.page,
                    "bbox": c.metadata.bbox,
                    "text": c.metadata.text,
                    "confidence": c.metadata.confidence,
                    "context": c.context
                }
                for c in citations
            ]
        }

        file_path = self.storage_path / f"{session_id}.json"
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    def load_citations(self, session_id: str) -> dict:
        """
        加载引用数据
        """
        file_path = self.storage_path / f"{session_id}.json"

        if not file_path.exists():
            return None

        with open(file_path, 'r', encoding='utf-8') as f:
            return json.load(f)

# 使用示例
store = CitationStore()

# 保存
store.save_citations(
    session_id="session_123",
    answer=answer,
    citations=citations
)

# 加载
loaded = store.load_citations("session_123")
print("加载的引用数据：")
print(json.dumps(loaded, ensure_ascii=False, indent=2))
```

### 6.2 引用审计日志

```python
import logging
from datetime import datetime

class CitationAuditLogger:
    """
    引用审计日志
    """

    def __init__(self, log_file: str = "citation_audit.log"):
        self.logger = logging.getLogger("citation_audit")
        self.logger.setLevel(logging.INFO)

        handler = logging.FileHandler(log_file)
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def log_citation_generation(
        self,
        session_id: str,
        query: str,
        answer: str,
        citation_count: int,
        coverage: float
    ):
        """
        记录引用生成
        """
        self.logger.info(
            f"Session: {session_id} | "
            f"Query: {query} | "
            f"Citations: {citation_count} | "
            f"Coverage: {coverage:.2%}"
        )

    def log_citation_verification(
        self,
        session_id: str,
        accuracy: float,
        issues: List[dict]
    ):
        """
        记录引用验证
        """
        self.logger.info(
            f"Session: {session_id} | "
            f"Accuracy: {accuracy:.2%} | "
            f"Issues: {len(issues)}"
        )

        if issues:
            for issue in issues:
                self.logger.warning(
                    f"Session: {session_id} | "
                    f"Issue: {issue}"
                )

# 使用示例
audit_logger = CitationAuditLogger()

audit_logger.log_citation_generation(
    session_id="session_123",
    query="Python有什么特点？",
    answer=answer,
    citation_count=len(citations),
    coverage=0.95
)

audit_logger.log_citation_verification(
    session_id="session_123",
    accuracy=verification["accuracy"],
    issues=verification["issues"]
)
```

---

## 7. 常见问题

### Q1: 如何处理引用冲突？

**答：** 当多个文档提供矛盾信息时：

```python
def handle_citation_conflicts(citations: List[Citation]) -> str:
    """
    处理引用冲突
    """
    # 按置信度排序
    sorted_citations = sorted(
        citations,
        key=lambda c: c.metadata.confidence,
        reverse=True
    )

    # 使用最高置信度的引用
    primary = sorted_citations[0]

    # 标注存在冲突
    conflict_note = ""
    if len(sorted_citations) > 1:
        conflict_note = f"\n\n注：存在其他来源的不同说法，详见引用 {', '.join([c.id for c in sorted_citations[1:]])}"

    return f"<c>{primary.id}</c>{conflict_note}"
```

### Q2: 如何优化引用性能？

**答：** 使用引用缓存：

```python
from functools import lru_cache

class CachedCitationManager(CitationManager):
    """
    带缓存的引用管理器
    """

    @lru_cache(maxsize=1000)
    def get_citation_cached(self, citation_id: str) -> Citation:
        """
        缓存引用查询
        """
        return self.get_citation(citation_id)
```

### Q3: 如何处理长文档的引用？

**答：** 使用分段引用：

```python
def create_segmented_citations(
    doc_content: str,
    segment_size: int = 500
) -> List[Citation]:
    """
    为长文档创建分段引用
    """
    segments = [
        doc_content[i:i+segment_size]
        for i in range(0, len(doc_content), segment_size)
    ]

    citations = []
    for i, segment in enumerate(segments):
        citation = Citation(
            id=f"seg_{i+1}",
            metadata=SpatialMetadata(
                doc_id="long_doc.pdf",
                page=i // 2 + 1,  # 假设每页2个段落
                bbox=(0, i*100, 600, (i+1)*100),
                text=segment,
                confidence=1.0
            ),
            context=""
        )
        citations.append(citation)

    return citations
```

---

## 总结

### 核心原则

1. **精确性优先**：使用空间元数据实现精确定位
2. **可验证性**：所有引用都应可验证
3. **用户友好**：提供可视化和交互式引用
4. **审计能力**：记录所有引用生成和验证过程

### 2025-2026标准

```python
# 生产级引用系统配置
CITATION_STANDARDS_2026 = {
    "format": "spatial_metadata",  # 空间元数据
    "anchor_style": "<c>X.Y</c>",  # 内联锚点
    "min_confidence": 0.7,         # 最低置信度
    "coverage_target": 0.9,        # 目标覆盖率
    "verification": True,          # 启用验证
    "audit_logging": True          # 启用审计
}
```

---

**版本：** v1.0 (2025-2026最新标准)
**最后更新：** 2026-02-16
**参考来源：**
- Tensorlake "Citation-Aware RAG" (2025-09)
- https://www.tensorlake.ai/blog/rag-citations
