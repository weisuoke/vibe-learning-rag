# 核心概念 11：工具包装与转换

> **深入理解 MCP 工具到 pi 工具的转换模式、参数映射和结果格式化**

---

## 概述

工具包装与转换是将 MCP Server 的工具转换为 pi-mono 可用工具的关键技术，涉及参数映射、结果格式化和错误处理。

```
工具包装与转换核心：
├─ 参数映射 → MCP Schema 到 TypeBox Schema
├─ 工具注册 → 通过 ExtensionAPI 注册
├─ 结果格式化 → 转换为 pi 工具结果格式
└─ 错误转换 → MCP 错误到 pi 错误
```

**本质**：工具包装与转换是 MCP 与 pi-mono 之间的适配层，通过标准化的转换模式，让 MCP 工具能够无缝集成到 pi-mono 的工具系统中。

[Source: pi-mono Extensions Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md)

---

## 参数映射策略

### MCP Schema 到 TypeBox Schema

**MCP 工具定义**：

```json
{
  "name": "get_weather",
  "description": "Get weather for a location",
  "inputSchema": {
    "type": "object",
    "properties": {
      "location": {
        "type": "string",
        "description": "City name"
      },
      "units": {
        "type": "string",
        "enum": ["celsius", "fahrenheit"],
        "default": "celsius"
      }
    },
    "required": ["location"]
  }
}
```

**转换为 TypeBox Schema**：

```typescript
import { Type } from "@sinclair/typebox";
import { StringEnum } from "@mariozechner/pi-ai";

const weatherSchema = Type.Object({
  location: Type.String({
    description: "City name"
  }),
  units: Type.Optional(
    StringEnum(["celsius", "fahrenheit"] as const, {
      default: "celsius"
    })
  )
});
```

### 类型映射表

| MCP 类型 | TypeBox 类型 | 示例 |
|----------|--------------|------|
| `string` | `Type.String()` | `Type.String({ minLength: 1 })` |
| `number` | `Type.Number()` | `Type.Number({ minimum: 0 })` |
| `integer` | `Type.Integer()` | `Type.Integer({ minimum: 1 })` |
| `boolean` | `Type.Boolean()` | `Type.Boolean()` |
| `array` | `Type.Array()` | `Type.Array(Type.String())` |
| `object` | `Type.Object()` | `Type.Object({ key: Type.String() })` |
| `enum` | `StringEnum()` | `StringEnum(["a", "b"] as const)` |

### 复杂类型转换

**嵌套对象**：

```typescript
// MCP Schema
{
  "type": "object",
  "properties": {
    "user": {
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "age": { "type": "integer" }
      },
      "required": ["name"]
    }
  }
}

// TypeBox Schema
Type.Object({
  user: Type.Object({
    name: Type.String(),
    age: Type.Optional(Type.Integer())
  })
})
```

**数组类型**：

```typescript
// MCP Schema
{
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "id": { "type": "string" },
      "value": { "type": "number" }
    }
  }
}

// TypeBox Schema
Type.Array(
  Type.Object({
    id: Type.String(),
    value: Type.Number()
  })
)
```

[Source: pi-mono Extensions Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md)

---

## 工具注册实现

### 基本包装模式

```typescript
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { Type } from "@sinclair/typebox";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

export default function (pi: ExtensionAPI) {
  // MCP 客户端
  const mcpClient = new Client({
    name: "mcp-wrapper",
    version: "1.0.0"
  });

  // 连接到 MCP 服务器
  pi.on("session_start", async (_event, ctx) => {
    await connectToMCPServer(mcpClient);

    // 获取 MCP 工具列表
    const toolsResult = await mcpClient.listTools();

    // 为每个 MCP 工具注册 pi 工具
    for (const mcpTool of toolsResult.tools) {
      registerMCPTool(pi, mcpClient, mcpTool);
    }
  });
}
```

### 动态工具注册

```typescript
function registerMCPTool(
  pi: ExtensionAPI,
  mcpClient: Client,
  mcpTool: any
) {
  // 转换 MCP Schema 到 TypeBox Schema
  const schema = convertMCPSchemaToTypeBox(mcpTool.inputSchema);

  // 注册 pi 工具
  pi.registerTool({
    name: mcpTool.name,
    label: mcpTool.title || mcpTool.name,
    description: mcpTool.description,
    parameters: schema,

    async execute(toolCallId, params, signal, onUpdate, ctx) {
      try {
        // 调用 MCP 工具
        const result = await mcpClient.callTool({
          name: mcpTool.name,
          arguments: params
        });

        // 转换结果格式
        return {
          content: result.content.map(item => ({
            type: item.type,
            text: item.type === "text" ? item.text : undefined,
            data: item.type === "image" ? item.data : undefined,
            mimeType: item.mimeType
          })),
          details: { mcpResult: result }
        };
      } catch (error) {
        // 错误处理
        return {
          content: [{
            type: "text",
            text: `MCP tool error: ${error.message}`
          }],
          isError: true
        };
      }
    }
  });
}
```

### Schema 转换实现

```typescript
function convertMCPSchemaToTypeBox(mcpSchema: any): any {
  if (mcpSchema.type === "object") {
    const properties: Record<string, any> = {};

    for (const [key, value] of Object.entries(mcpSchema.properties || {})) {
      const prop = value as any;
      let typeboxType = convertType(prop);

      // 处理可选字段
      if (!mcpSchema.required?.includes(key)) {
        typeboxType = Type.Optional(typeboxType);
      }

      properties[key] = typeboxType;
    }

    return Type.Object(properties);
  }

  return convertType(mcpSchema);
}

function convertType(prop: any): any {
  switch (prop.type) {
    case "string":
      if (prop.enum) {
        return StringEnum(prop.enum as string[]);
      }
      return Type.String({
        description: prop.description,
        minLength: prop.minLength,
        maxLength: prop.maxLength
      });

    case "number":
      return Type.Number({
        description: prop.description,
        minimum: prop.minimum,
        maximum: prop.maximum
      });

    case "integer":
      return Type.Integer({
        description: prop.description,
        minimum: prop.minimum,
        maximum: prop.maximum
      });

    case "boolean":
      return Type.Boolean({
        description: prop.description
      });

    case "array":
      return Type.Array(
        convertType(prop.items),
        {
          description: prop.description,
          minItems: prop.minItems,
          maxItems: prop.maxItems
        }
      );

    case "object":
      return convertMCPSchemaToTypeBox(prop);

    default:
      return Type.Any();
  }
}
```

[Source: pi-mono Extensions Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md)

---

## 结果格式化

### MCP 结果到 pi 结果

**MCP 工具结果格式**：

```json
{
  "content": [
    {
      "type": "text",
      "text": "Weather in London: 15°C, Cloudy"
    }
  ],
  "isError": false
}
```

**pi 工具结果格式**：

```typescript
{
  content: [
    {
      type: "text",
      text: "Weather in London: 15°C, Cloudy"
    }
  ],
  details: {
    temperature: 15,
    conditions: "Cloudy",
    location: "London"
  }
}
```

### 结果转换实现

```typescript
function convertMCPResultToPiResult(mcpResult: any): any {
  return {
    content: mcpResult.content.map((item: any) => {
      if (item.type === "text") {
        return {
          type: "text",
          text: item.text
        };
      } else if (item.type === "image") {
        return {
          type: "image",
          data: item.data,
          mimeType: item.mimeType
        };
      } else if (item.type === "resource") {
        return {
          type: "text",
          text: `Resource: ${item.resource.uri}`
        };
      }
      return item;
    }),
    details: extractDetails(mcpResult),
    isError: mcpResult.isError || false
  };
}

function extractDetails(mcpResult: any): any {
  // 尝试从文本内容中提取结构化数据
  const textContent = mcpResult.content
    .filter((item: any) => item.type === "text")
    .map((item: any) => item.text)
    .join("\n");

  try {
    // 尝试解析 JSON
    return JSON.parse(textContent);
  } catch {
    // 如果不是 JSON，返回原始文本
    return { raw: textContent };
  }
}
```

### 图片内容处理

```typescript
async function handleImageContent(mcpResult: any): Promise<any> {
  const images = mcpResult.content.filter(
    (item: any) => item.type === "image"
  );

  if (images.length === 0) {
    return mcpResult;
  }

  // 转换图片为 pi 格式
  return {
    content: mcpResult.content.map((item: any) => {
      if (item.type === "image") {
        return {
          type: "image",
          data: item.data,
          mimeType: item.mimeType || "image/png"
        };
      }
      return item;
    }),
    details: {
      imageCount: images.length,
      mimeTypes: images.map((img: any) => img.mimeType)
    }
  };
}
```

---

## 错误转换

### MCP 错误到 pi 错误

**MCP 错误格式**：

```json
{
  "content": [
    {
      "type": "text",
      "text": "Tool execution failed: Invalid location"
    }
  ],
  "isError": true
}
```

**pi 错误格式**：

```typescript
{
  content: [
    {
      type: "text",
      text: "MCP tool error: Invalid location"
    }
  ],
  isError: true,
  details: {
    errorType: "ValidationError",
    originalError: "Invalid location"
  }
}
```

### 错误处理实现

```typescript
async function executeMCPTool(
  mcpClient: Client,
  toolName: string,
  params: any
): Promise<any> {
  try {
    const result = await mcpClient.callTool({
      name: toolName,
      arguments: params
    });

    // 检查 MCP 工具是否返回错误
    if (result.isError) {
      return {
        content: [{
          type: "text",
          text: `MCP tool error: ${extractErrorMessage(result)}`
        }],
        isError: true,
        details: {
          errorType: "MCPToolError",
          originalError: result.content
        }
      };
    }

    return convertMCPResultToPiResult(result);
  } catch (error) {
    // 处理连接错误或协议错误
    return {
      content: [{
        type: "text",
        text: `MCP connection error: ${error.message}`
      }],
      isError: true,
      details: {
        errorType: "MCPConnectionError",
        originalError: error.message
      }
    };
  }
}

function extractErrorMessage(mcpResult: any): string {
  const textContent = mcpResult.content
    .filter((item: any) => item.type === "text")
    .map((item: any) => item.text)
    .join("\n");

  return textContent || "Unknown error";
}
```

---

## 最佳实践

### 1. 令牌效率

**问题**：MCP 工具定义冗长，消耗大量上下文

**解决方案**：使用代理工具模式

```typescript
// 代理工具：单个工具代理所有 MCP 工具
pi.registerTool({
  name: "mcp",
  label: "MCP Proxy",
  description: "Call MCP server tools",
  parameters: Type.Object({
    tool: Type.String({ description: "Tool name" }),
    args: Type.String({ description: "JSON arguments" })
  }),

  async execute(toolCallId, params, signal, onUpdate, ctx) {
    const toolArgs = JSON.parse(params.args);
    const result = await mcpClient.callTool({
      name: params.tool,
      arguments: toolArgs
    });

    return convertMCPResultToPiResult(result);
  }
});
```

### 2. 工具发现

**搜索工具**：

```typescript
pi.registerTool({
  name: "mcp_search",
  label: "Search MCP Tools",
  description: "Search available MCP tools",
  parameters: Type.Object({
    query: Type.String({ description: "Search query" })
  }),

  async execute(toolCallId, params, signal, onUpdate, ctx) {
    const toolsResult = await mcpClient.listTools();
    const matching = toolsResult.tools.filter(tool =>
      tool.name.includes(params.query) ||
      tool.description.includes(params.query)
    );

    return {
      content: [{
        type: "text",
        text: matching.map(tool =>
          `${tool.name}\n  ${tool.description}`
        ).join("\n\n")
      }],
      details: { tools: matching }
    };
  }
});
```

### 3. 状态管理

**连接池管理**：

```typescript
class MCPConnectionPool {
  private connections = new Map<string, Client>();

  async getConnection(serverName: string): Promise<Client> {
    if (!this.connections.has(serverName)) {
      const client = await this.createConnection(serverName);
      this.connections.set(serverName, client);
    }
    return this.connections.get(serverName)!;
  }

  async createConnection(serverName: string): Promise<Client> {
    const client = new Client({
      name: `mcp-${serverName}`,
      version: "1.0.0"
    });

    // 连接逻辑
    await connectToServer(client, serverName);

    return client;
  }

  async cleanup() {
    for (const [name, client] of this.connections) {
      await client.close();
    }
    this.connections.clear();
  }
}
```

[Source: pi-mcp-adapter GitHub](https://github.com/nicobailon/pi-mcp-adapter)

---

## 总结

### 核心要点

1. **参数映射**：MCP Schema 到 TypeBox Schema 的转换
2. **工具注册**：通过 ExtensionAPI 动态注册工具
3. **结果格式化**：转换 MCP 结果为 pi 工具结果格式
4. **错误转换**：统一错误处理和格式化
5. **令牌效率**：使用代理工具模式减少上下文消耗

### 关键约束

- ✅ 正确映射 MCP Schema 到 TypeBox Schema
- ✅ 处理可选字段和默认值
- ✅ 转换结果格式（content + details）
- ✅ 统一错误处理
- ✅ 管理 MCP 连接生命周期

### 下一步

- 阅读 [03_核心概念_12_配置与部署](./03_核心概念_12_配置与部署.md) 了解配置与部署
- 阅读 [07_实战代码_07_工具包装与转换](./07_实战代码_07_工具包装与转换.md) 查看完整实现

---

**参考资源**：
- [Source: pi-mono Extensions Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md)
- [Source: pi-mcp-adapter GitHub](https://github.com/nicobailon/pi-mcp-adapter)
