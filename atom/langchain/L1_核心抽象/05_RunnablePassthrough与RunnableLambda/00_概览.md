# 00_概览

> **导航中心**：快速了解本知识点的学习路径、核心内容和使用指南

---

## 知识点概述

### 主题

**RunnablePassthrough 与 RunnableLambda**

### 定位

LangChain LCEL 中的数据转换工具，用于实现灵活的数据流控制

### 重要性

⭐⭐⭐⭐⭐ **核心必学**

**原因**：
- RAG 管道中保留原始数据的标准方式
- 自定义逻辑集成到 LCEL 链的唯一途径
- 几乎所有生产级 LangChain 应用都会用到
- 理解数据流控制的基础

### 学习时长

- **快速入门**：2-3 小时（理解基础概念 + 运行示例）
- **深入掌握**：1-2 天（理解机制 + 实战练习）
- **生产应用**：3-5 天（完整 RAG 项目 + 优化）

---

## 核心内容

### 一句话总结

**RunnablePassthrough 透传并扩展数据（保留原输入 + assign 添加字段），RunnableLambda 包装任意函数为标准 Runnable（自定义逻辑 + 链式集成），两者是 LCEL 中实现灵活数据流控制的核心工具。**

### 三个核心概念

1. **RunnablePassthrough 透传机制**
   - 输入原样输出（identity function）
   - assign() 方法添加新字段
   - 保留原始数据的同时扩展信息

2. **RunnableLambda 自定义函数**
   - 包装任意 Python 函数
   - 支持同步和异步
   - 统一的 Runnable 接口

3. **数据转换与组合**
   - Passthrough + Lambda 配合
   - 与其他 Runnable 组合
   - 构建复杂数据流管道

### 关键价值

**解决的核心问题**：
1. **数据丢失**：链式处理中如何保留原始输入？
2. **自定义逻辑**：如何将任意函数集成到 LCEL 链中？
3. **灵活控制**：如何实现复杂的数据转换和路由？

**典型应用场景**：
- RAG 管道中保留查询并添加检索上下文
- 查询改写和预处理
- 数据增强和后处理
- 条件路由和动态分支

---

## 文档结构

### 学习维度（10 个）

本知识点按照原子化知识模板组织，包含以下 10 个维度：

| 维度 | 文件 | 内容 | 学习优先级 |
|------|------|------|-----------|
| **1. 30字核心** | `01_30字核心.md` | 最精炼的定义和核心 API | ⭐⭐⭐⭐⭐ 必读 |
| **2. 第一性原理** | `02_第一性原理.md` | 底层设计思想和原理 | ⭐⭐⭐⭐ 深入理解 |
| **3. 核心概念** | `03_核心概念_*.md` | 三个核心概念详解 | ⭐⭐⭐⭐⭐ 必读 |
| **4. 最小可用** | `04_最小可用.md` | 20%核心知识速成 | ⭐⭐⭐⭐⭐ 快速入门 |
| **5. 双重类比** | `05_双重类比.md` | 前端+日常生活类比 | ⭐⭐⭐⭐ 理解辅助 |
| **6. 反直觉点** | `06_反直觉点.md` | 常见误区和陷阱 | ⭐⭐⭐⭐⭐ 避坑必读 |
| **7. 实战代码** | `07_实战代码_*.md` | 三个实战场景代码 | ⭐⭐⭐⭐⭐ 动手实践 |
| **8. 面试必问** | `08_面试必问.md` | 高频面试题 | ⭐⭐⭐ 面试准备 |
| **9. 化骨绵掌** | `09_化骨绵掌.md` | 10个知识卡片 | ⭐⭐⭐ 快速复习 |
| **10. 一句话总结** | `10_一句话总结.md` | 总结+检查清单 | ⭐⭐⭐⭐⭐ 学习验证 |

### 核心概念详解（3 个文件）

| 文件 | 核心内容 | 重点 |
|------|----------|------|
| `03_核心概念_01_RunnablePassthrough透传机制.md` | 透传机制、assign() API、数据保留模式 | ⭐⭐⭐⭐⭐ |
| `03_核心概念_02_RunnableLambda自定义函数.md` | 函数包装、同步/异步、错误处理 | ⭐⭐⭐⭐⭐ |
| `03_核心概念_03_数据转换与组合.md` | 转换模式、组合策略、性能优化 | ⭐⭐⭐⭐ |

### 实战代码示例（3 个文件）

| 文件 | 场景 | 难度 |
|------|------|------|
| `07_实战代码_01_基础透传与assign.md` | 基础用法、assign 扩展、调试 | ⭐⭐ 入门 |
| `07_实战代码_02_Lambda自定义处理.md` | 自定义函数、异步、错误重试 | ⭐⭐⭐ 进阶 |
| `07_实战代码_03_RAG数据增强.md` | 完整 RAG 管道、数据增强 | ⭐⭐⭐⭐ 实战 |

---

## 学习路径

### 路径 1：快速入门（2-3 小时）

**目标**：理解基础概念，能运行简单示例

**步骤**：
1. 阅读 `01_30字核心.md`（15 分钟）
   - 理解 RunnablePassthrough 和 RunnableLambda 的定义
   - 记住核心 API

2. 阅读 `04_最小可用.md`（30 分钟）
   - 掌握 20% 核心知识
   - 理解典型使用场景

3. 运行 `07_实战代码_01_基础透传与assign.md`（1 小时）
   - 运行所有代码示例
   - 修改参数观察输出
   - 理解 assign() 的行为

4. 阅读 `06_反直觉点.md`（30 分钟）
   - 了解常见误区
   - 避免典型陷阱

5. 完成 `10_一句话总结.md` 中的基础检查清单（30 分钟）

**验收标准**：
- [ ] 能解释 RunnablePassthrough 和 RunnableLambda 的作用
- [ ] 能写出基础的 assign() 代码
- [ ] 能运行简单的 RAG 示例

### 路径 2：深入掌握（1-2 天）

**目标**：理解底层机制，能实现复杂场景

**步骤**：
1. 完成路径 1 的所有内容

2. 阅读 `02_第一性原理.md`（1 小时）
   - 理解设计思想
   - 掌握底层原理

3. 深入学习三个核心概念（3 小时）
   - `03_核心概念_01_RunnablePassthrough透传机制.md`
   - `03_核心概念_02_RunnableLambda自定义函数.md`
   - `03_核心概念_03_数据转换与组合.md`

4. 实战练习（4 小时）
   - `07_实战代码_02_Lambda自定义处理.md`
   - `07_实战代码_03_RAG数据增强.md`
   - 修改代码实现自己的需求

5. 阅读 `05_双重类比.md`（30 分钟）
   - 加深理解
   - 建立直觉

6. 完成 `10_一句话总结.md` 中的进阶检查清单（1 小时）

**验收标准**：
- [ ] 能解释透传机制的底层原理
- [ ] 能实现异步处理和错误重试
- [ ] 能构建完整的 RAG 数据增强管道

### 路径 3：生产应用（3-5 天）

**目标**：能在生产环境中应用，优化性能

**步骤**：
1. 完成路径 2 的所有内容

2. 构建完整项目（2 天）
   - 实现完整的 RAG 应用
   - 集成外部 API
   - 添加错误处理和重试

3. 性能优化（1 天）
   - 批处理优化
   - 异步处理优化
   - 内存和延迟优化

4. 学习最佳实践（1 天）
   - 阅读生产环境案例
   - 学习可观测性和监控
   - 理解安全最佳实践

5. 面试准备（可选，1 天）
   - 阅读 `08_面试必问.md`
   - 练习回答面试题
   - 总结项目经验

**验收标准**：
- [ ] 能独立构建生产级 RAG 应用
- [ ] 能优化性能和处理边界情况
- [ ] 能解释设计决策和权衡

### 路径 4：专家进阶（持续学习）

**目标**：深入源码，贡献社区

**步骤**：
1. 阅读 LangChain 源码
   - `langchain_core/runnables/passthrough.py`
   - `langchain_core/runnables/base.py`
   - 理解 Runnable 接口设计

2. 研究高级特性
   - 类型系统和推断
   - 批处理和流式输出
   - 错误传播机制

3. 社区贡献
   - 分享最佳实践
   - 提交 bug 修复
   - 参与讨论和 PR review

---

## 前置知识

### 必须掌握

- **L1_核心抽象/01_Runnable接口与LCEL基础**
  - 理解 Runnable 接口
  - 掌握 LCEL 基础语法
  - 了解 invoke/ainvoke 方法

- **L1_核心抽象/04_链式组合（管道操作符）**
  - 理解管道操作符 `|`
  - 掌握链式组合模式
  - 了解数据流动方式

### 建议掌握

- **Python 基础**
  - 字典操作
  - Lambda 表达式
  - 异步编程（async/await）

- **L1_核心抽象/02_ChatModel与PromptTemplate**
  - 理解 LLM 调用
  - 掌握 Prompt 模板

---

## 后续学习

### 直接相关

- **L1_核心抽象/06_RunnableParallel与RunnableBranch**
  - 并行处理和条件路由
  - 与 Passthrough/Lambda 的组合

- **L2_检索增强/01_Retriever接口**
  - 检索器的使用
  - 与 RunnablePassthrough.assign() 的集成

### 应用场景

- **L3_RAG核心流程**
  - 完整 RAG 管道构建
  - 数据增强和上下文管理

- **L4_RAG进阶优化**
  - 查询改写和重排序
  - 复杂数据转换

---

## 快速参考

### 核心 API

```python
from langchain_core.runnables import RunnablePassthrough, RunnableLambda

# RunnablePassthrough
passthrough = RunnablePassthrough()
chain = RunnablePassthrough.assign(key=func)

# RunnableLambda
lambda_runnable = RunnableLambda(func)
safe_lambda = lambda_runnable.with_retry(stop_after_attempt=3)
```

### 典型模式

```python
# RAG 数据保留
rag_chain = (
    RunnablePassthrough.assign(context=retriever)
    | prompt
    | llm
)

# 查询改写 + 检索
chain = (
    RunnableLambda(rewrite_query)
    | RunnablePassthrough.assign(context=retriever)
    | llm
)
```

### 常见陷阱

1. **误以为 assign 会替换输入**（实际是扩展）
2. **Lambda 中忘记错误处理**（会导致链崩溃）
3. **同步函数阻塞异步链**（应使用异步函数）

---

## 学习资源

### 官方文档（2025-2026）

- [RunnablePassthrough 官方文档](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html)
- [RunnableLambda 官方文档](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.base.RunnableLambda.html)
- [LangChain LCEL 指南](https://python.langchain.com/docs/concepts/lcel/)

### 推荐文章（2025-2026）

- [Building Production-Ready AI Pipelines with LangChain Runnables](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557) (2026)
- [Master LangChain in 2025: Complete Guide](https://towardsai.net/p/machine-learning/master-langchain-in-2025-from-rag-to-tools-complete-guide) (2025)
- [LangChain Expression Language Explained](https://www.pinecone.io/learn/series/langchain/langchain-expression-language) (2025)

### 视频教程

- [LangChain LCEL | Implementing Runnables in RAG](https://www.youtube.com/watch?v=EjXtuSO0aQE) - 实战演示

### 源码阅读

- [passthrough.py](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/runnables/passthrough.py) - RunnablePassthrough 实现
- [base.py](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/runnables/base.py) - RunnableLambda 实现

---

## 常见问题

### Q1: RunnablePassthrough 和 RunnableLambda 的区别？

**A**:
- **RunnablePassthrough**：透传输入，保持不变，可通过 assign() 添加字段
- **RunnableLambda**：包装自定义函数，实现任意转换逻辑
- **使用场景**：Passthrough 用于数据保留，Lambda 用于数据转换

### Q2: 什么时候用 assign()？

**A**: 需要保留原始输入同时添加新字段时，典型场景：
- RAG 中保留查询并添加检索上下文
- 并行处理时保持数据完整性
- 需要在链中传递中间结果

### Q3: assign() 会替换原输入吗？

**A**: 不会！assign() 是扩展，不是替换：
```python
input_data = {"query": "hello", "user": "alice"}
result = RunnablePassthrough.assign(context="retrieved").invoke(input_data)
# 输出: {"query": "hello", "user": "alice", "context": "retrieved"}
```

### Q4: 如何在 Lambda 中处理错误？

**A**: 两种方式：
1. **函数内部处理**：
   ```python
   def safe_func(x):
       try:
           return risky_operation(x)
       except Exception as e:
           return fallback_value
   ```

2. **使用 with_retry**：
   ```python
   safe_lambda = RunnableLambda(func).with_retry(
       stop_after_attempt=3
   )
   ```

### Q5: 同步函数会阻塞异步链吗？

**A**: 会！应该使用异步函数：
```python
# ❌ 同步函数阻塞
def slow_sync(x):
    time.sleep(5)  # 阻塞

# ✅ 异步函数不阻塞
async def fast_async(x):
    await asyncio.sleep(5)  # 不阻塞
```

### Q6: 如何调试 RunnablePassthrough 和 RunnableLambda？

**A**: 使用 LangSmith 或添加日志：
```python
# 添加日志
chain = (
    RunnableLambda(lambda x: print(f"Input: {x}") or x)
    | RunnablePassthrough.assign(context=retriever)
    | RunnableLambda(lambda x: print(f"After assign: {x}") or x)
    | llm
)
```

---

## 2025-2026 最新特性

### 1. 类型推断增强（LangChain v0.3+）

```python
# 自动类型推断
chain = RunnablePassthrough.assign(
    count=lambda x: len(x["items"])
)
# 类型系统自动识别: Runnable[dict, dict]
```

### 2. 批处理性能优化

```python
# 批量处理性能提升 3-5 倍
results = await chain.abatch([
    {"query": "q1"},
    {"query": "q2"},
    {"query": "q3"}
])
```

### 3. 错误传播改进

```python
# 更清晰的错误堆栈
chain = RunnableLambda(risky_func).with_retry(
    stop_after_attempt=3
)
# 错误信息包含完整调用链路
```

### 4. 安全性增强

- **CVE-2025-68664**：修复了序列化安全问题
- 建议升级到 LangChain v0.3.15+

---

## 学习建议

### 初学者

1. **不要跳过基础**
   - 先理解 Runnable 接口
   - 再学习 Passthrough 和 Lambda

2. **动手实践**
   - 运行所有代码示例
   - 修改参数观察输出
   - 尝试实现自己的需求

3. **避免过度设计**
   - 从简单场景开始
   - 逐步增加复杂度
   - 不要一开始就追求完美

### 进阶学习者

1. **深入源码**
   - 阅读 LangChain 源码
   - 理解底层实现
   - 学习设计模式

2. **性能优化**
   - 使用异步处理
   - 批处理优化
   - 减少不必要的数据复制

3. **生产实践**
   - 添加完善的错误处理
   - 实现可观测性
   - 优化性能和成本

---

## 文档导航

### 快速开始

- **新手入门** → `01_30字核心.md` → `04_最小可用.md` → `07_实战代码_01_基础透传与assign.md`
- **深入理解** → `02_第一性原理.md` → `03_核心概念_*.md` 系列
- **实战应用** → `07_实战代码_*.md` 系列 → 完整项目

### 按需查阅

- **快速查 API** → `01_30字核心.md`
- **理解原理** → `02_第一性原理.md`
- **避免踩坑** → `06_反直觉点.md`
- **面试准备** → `08_面试必问.md`
- **快速复习** → `09_化骨绵掌.md`

### 学习验证

- **检查理解** → `10_一句话总结.md` 中的检查清单
- **实战验证** → 完成实战检查点任务

---

## 更新日志

### v1.0 (2026-02-18)

- 初始版本
- 基于 LangChain v0.3 最新特性
- 包含 2025-2026 最新实践
- 完整的 10 维度文档结构

---

**开始学习**：建议从 `01_30字核心.md` 或 `04_最小可用.md` 开始！

---

**版本**：v1.0
**最后更新**：2026-02-18
**维护者**：Claude Code
