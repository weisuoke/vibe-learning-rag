# 实战代码：基础后台任务示例

> 完整可运行的 BackgroundTasks 基础示例，涵盖常见使用场景

---

## 示例1：发送邮件通知

### 场景描述
用户注册后，立即返回响应，在后台发送欢迎邮件。

### 完整代码

```python
"""
示例1：发送邮件通知
演示：用户注册后台发送欢迎邮件
"""

from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel, EmailStr
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import logging

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# ===== 1. 定义请求模型 =====
class UserRegister(BaseModel):
    email: EmailStr
    username: str

# ===== 2. 后台任务：发送邮件 =====
def send_welcome_email(email: str, username: str):
    """发送欢迎邮件"""
    try:
        logger.info(f"开始发送欢迎邮件到: {email}")

        # 邮件配置（实际使用时从环境变量读取）
        smtp_server = "smtp.gmail.com"
        smtp_port = 587
        sender_email = "your-email@gmail.com"
        sender_password = "your-password"

        # 创建邮件
        message = MIMEMultipart()
        message["From"] = sender_email
        message["To"] = email
        message["Subject"] = "欢迎注册！"

        body = f"""
        你好 {username}，

        欢迎注册我们的服务！

        祝好，
        团队
        """
        message.attach(MIMEText(body, "plain"))

        # 发送邮件
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(sender_email, sender_password)
            server.send_message(message)

        logger.info(f"欢迎邮件发送成功: {email}")

    except Exception as e:
        logger.error(f"邮件发送失败: {email}, 错误: {e}")

# ===== 3. API 端点 =====
@app.post("/register")
async def register(
    user: UserRegister,
    background_tasks: BackgroundTasks
):
    """用户注册"""
    # 1. 保存用户到数据库（模拟）
    logger.info(f"保存用户: {user.username}")

    # 2. 添加后台任务：发送欢迎邮件
    background_tasks.add_task(
        send_welcome_email,
        user.email,
        user.username
    )

    # 3. 立即返回响应
    return {
        "message": "注册成功",
        "username": user.username,
        "email": user.email
    }

# ===== 4. 测试端点 =====
@app.get("/")
async def root():
    return {"message": "后台任务示例 - 邮件发送"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 运行方式

```bash
# 1. 安装依赖
uv add fastapi uvicorn[standard] pydantic[email]

# 2. 运行服务
python examples/background_tasks/01_email.py

# 3. 测试 API
curl -X POST "http://localhost:8000/register" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "username": "testuser"
  }'
```

### 预期输出

```
INFO:     开始发送欢迎邮件到: user@example.com
INFO:     欢迎邮件发送成功: user@example.com
```

---

## 示例2：日志记录

### 场景描述
用户执行操作后，立即返回响应，在后台记录详细日志。

### 完整代码

```python
"""
示例2：日志记录
演示：用户操作后台记录日志
"""

from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
from datetime import datetime
import json
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# ===== 1. 定义请求模型 =====
class UserAction(BaseModel):
    user_id: int
    action: str
    details: dict = {}

# ===== 2. 后台任务：记录日志 =====
def write_action_log(user_id: int, action: str, details: dict):
    """记录用户操作日志到文件"""
    try:
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "user_id": user_id,
            "action": action,
            "details": details
        }

        # 写入日志文件
        with open("user_actions.log", "a") as f:
            f.write(json.dumps(log_entry) + "\n")

        logger.info(f"日志记录成功: user_id={user_id}, action={action}")

    except Exception as e:
        logger.error(f"日志记录失败: {e}")

# ===== 3. API 端点 =====
@app.post("/action")
async def record_action(
    action: UserAction,
    background_tasks: BackgroundTasks
):
    """记录用户操作"""
    # 添加后台任务：记录日志
    background_tasks.add_task(
        write_action_log,
        action.user_id,
        action.action,
        action.details
    )

    # 立即返回响应
    return {
        "message": "操作成功",
        "action": action.action
    }

# ===== 4. 查询日志端点 =====
@app.get("/logs")
async def get_logs(limit: int = 10):
    """获取最近的日志"""
    try:
        with open("user_actions.log", "r") as f:
            lines = f.readlines()
            recent_logs = [json.loads(line) for line in lines[-limit:]]
            return {"logs": recent_logs}
    except FileNotFoundError:
        return {"logs": []}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 运行方式

```bash
# 1. 运行服务
python examples/background_tasks/02_logging.py

# 2. 记录操作
curl -X POST "http://localhost:8000/action" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "action": "login",
    "details": {"ip": "192.168.1.1"}
  }'

# 3. 查询日志
curl "http://localhost:8000/logs?limit=5"
```

### 预期输出

```json
{
  "logs": [
    {
      "timestamp": "2026-02-11T10:30:00.123456",
      "user_id": 1,
      "action": "login",
      "details": {"ip": "192.168.1.1"}
    }
  ]
}
```

---

## 示例3：文件处理

### 场景描述
用户上传文件后，立即返回响应，在后台处理文件（压缩、转换等）。

### 完整代码

```python
"""
示例3：文件处理
演示：文件上传后台处理
"""

from fastapi import FastAPI, BackgroundTasks, UploadFile, File
from pathlib import Path
import shutil
import zipfile
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# 创建上传目录
UPLOAD_DIR = Path("uploads")
PROCESSED_DIR = Path("processed")
UPLOAD_DIR.mkdir(exist_ok=True)
PROCESSED_DIR.mkdir(exist_ok=True)

# ===== 1. 后台任务：压缩文件 =====
def compress_file(file_path: Path, output_path: Path):
    """压缩文件"""
    try:
        logger.info(f"开始压缩文件: {file_path}")

        # 创建 ZIP 文件
        with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            zipf.write(file_path, file_path.name)

        logger.info(f"文件压缩完成: {output_path}")

        # 删除原文件
        file_path.unlink()
        logger.info(f"原文件已删除: {file_path}")

    except Exception as e:
        logger.error(f"文件压缩失败: {e}")

# ===== 2. API 端点 =====
@app.post("/upload")
async def upload_file(
    file: UploadFile = File(...),
    background_tasks: BackgroundTasks = None
):
    """上传文件"""
    # 1. 保存文件
    file_path = UPLOAD_DIR / file.filename
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)

    logger.info(f"文件保存成功: {file_path}")

    # 2. 添加后台任务：压缩文件
    output_path = PROCESSED_DIR / f"{file.filename}.zip"
    background_tasks.add_task(compress_file, file_path, output_path)

    # 3. 立即返回响应
    return {
        "message": "文件上传成功，正在后台处理",
        "filename": file.filename,
        "size": file.size
    }

# ===== 3. 查询处理结果 =====
@app.get("/processed")
async def list_processed_files():
    """列出已处理的文件"""
    files = [f.name for f in PROCESSED_DIR.glob("*.zip")]
    return {"files": files}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 运行方式

```bash
# 1. 运行服务
python examples/background_tasks/03_file_processing.py

# 2. 上传文件
curl -X POST "http://localhost:8000/upload" \
  -F "file=@test.txt"

# 3. 查询处理结果
curl "http://localhost:8000/processed"
```

---

## 示例4：多个后台任务

### 场景描述
一个请求触发多个后台任务，按顺序执行。

### 完整代码

```python
"""
示例4：多个后台任务
演示：一个请求触发多个后台任务
"""

from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
import time
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# ===== 1. 定义请求模型 =====
class Order(BaseModel):
    order_id: int
    user_email: str
    amount: float

# ===== 2. 后台任务函数 =====
def send_order_confirmation(order_id: int, email: str):
    """发送订单确认邮件"""
    logger.info(f"任务1: 发送订单确认邮件 - 订单 {order_id}")
    time.sleep(1)  # 模拟发送邮件
    logger.info(f"任务1完成: 订单 {order_id}")

def update_inventory(order_id: int):
    """更新库存"""
    logger.info(f"任务2: 更新库存 - 订单 {order_id}")
    time.sleep(1)  # 模拟更新库存
    logger.info(f"任务2完成: 订单 {order_id}")

def notify_warehouse(order_id: int):
    """通知仓库发货"""
    logger.info(f"任务3: 通知仓库 - 订单 {order_id}")
    time.sleep(1)  # 模拟通知仓库
    logger.info(f"任务3完成: 订单 {order_id}")

def update_analytics(order_id: int, amount: float):
    """更新分析数据"""
    logger.info(f"任务4: 更新分析数据 - 订单 {order_id}, 金额 {amount}")
    time.sleep(1)  # 模拟更新分析
    logger.info(f"任务4完成: 订单 {order_id}")

# ===== 3. API 端点 =====
@app.post("/order")
async def create_order(
    order: Order,
    background_tasks: BackgroundTasks
):
    """创建订单"""
    logger.info(f"创建订单: {order.order_id}")

    # 添加多个后台任务（按顺序执行）
    background_tasks.add_task(
        send_order_confirmation,
        order.order_id,
        order.user_email
    )
    background_tasks.add_task(
        update_inventory,
        order.order_id
    )
    background_tasks.add_task(
        notify_warehouse,
        order.order_id
    )
    background_tasks.add_task(
        update_analytics,
        order.order_id,
        order.amount
    )

    # 立即返回响应
    return {
        "message": "订单创建成功",
        "order_id": order.order_id,
        "status": "processing"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 运行方式

```bash
# 1. 运行服务
python examples/background_tasks/04_multiple_tasks.py

# 2. 创建订单
curl -X POST "http://localhost:8000/order" \
  -H "Content-Type: application/json" \
  -d '{
    "order_id": 12345,
    "user_email": "user@example.com",
    "amount": 99.99
  }'
```

### 预期输出

```
INFO:     创建订单: 12345
INFO:     任务1: 发送订单确认邮件 - 订单 12345
INFO:     任务1完成: 订单 12345
INFO:     任务2: 更新库存 - 订单 12345
INFO:     任务2完成: 订单 12345
INFO:     任务3: 通知仓库 - 订单 12345
INFO:     任务3完成: 订单 12345
INFO:     任务4: 更新分析数据 - 订单 12345, 金额 99.99
INFO:     任务4完成: 订单 12345
```

---

## 示例5：异步后台任务

### 场景描述
使用异步函数作为后台任务，适合 I/O 密集型操作。

### 完整代码

```python
"""
示例5：异步后台任务
演示：使用异步函数处理后台任务
"""

from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
import asyncio
import httpx
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# ===== 1. 定义请求模型 =====
class WebhookData(BaseModel):
    event: str
    data: dict

# ===== 2. 异步后台任务 =====
async def send_webhook(url: str, event: str, data: dict):
    """发送 Webhook 通知"""
    try:
        logger.info(f"开始发送 Webhook: {url}")

        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                url,
                json={
                    "event": event,
                    "data": data
                }
            )

            logger.info(
                f"Webhook 发送成功: {url}, "
                f"状态码: {response.status_code}"
            )

    except httpx.TimeoutException:
        logger.error(f"Webhook 超时: {url}")
    except Exception as e:
        logger.error(f"Webhook 发送失败: {url}, 错误: {e}")

async def process_data_async(data: dict):
    """异步处理数据"""
    logger.info("开始异步处理数据")

    # 模拟异步操作
    await asyncio.sleep(2)

    logger.info("数据处理完成")

# ===== 3. API 端点 =====
@app.post("/webhook")
async def trigger_webhook(
    webhook_data: WebhookData,
    background_tasks: BackgroundTasks
):
    """触发 Webhook"""
    # 添加异步后台任务
    background_tasks.add_task(
        send_webhook,
        "https://webhook.site/your-unique-url",
        webhook_data.event,
        webhook_data.data
    )

    background_tasks.add_task(
        process_data_async,
        webhook_data.data
    )

    return {
        "message": "Webhook 已触发",
        "event": webhook_data.event
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 运行方式

```bash
# 1. 安装依赖
uv add httpx

# 2. 运行服务
python examples/background_tasks/05_async_tasks.py

# 3. 触发 Webhook
curl -X POST "http://localhost:8000/webhook" \
  -H "Content-Type: application/json" \
  -d '{
    "event": "user.created",
    "data": {"user_id": 123, "email": "user@example.com"}
  }'
```

---

## 总结

### 关键要点

1. **基础用法**：通过 `BackgroundTasks` 依赖注入获取实例
2. **添加任务**：使用 `add_task(func, *args, **kwargs)` 添加任务
3. **同步/异步**：支持同步和异步函数
4. **多个任务**：可以添加多个任务，按顺序执行
5. **错误处理**：添加 try-except 和日志记录

### 适用场景

- ✅ 发送邮件/通知（5秒）
- ✅ 记录日志（1秒）
- ✅ 文件处理（10秒）
- ✅ 更新缓存（2秒）
- ✅ 发送 Webhook（3秒）

### 下一步

学习更复杂的场景：
- → **任务队列集成**：使用 Celery 处理长时间任务
- → **生产级后台任务**：错误处理、监控、重试
- → **综合应用**：AI Agent 中的实际应用

---

**版本：** v1.0
**最后更新：** 2026-02-11
