# å®æˆ˜ä»£ç 4ï¼šå¥åº·ç›‘æ§ä¸è‡ªåŠ¨æ¢å¤

æœ¬ç¤ºä¾‹æ¼”ç¤ºå¦‚ä½•å®ç° Milvus é›†ç¾¤çš„å¥åº·ç›‘æ§ç³»ç»Ÿå’Œè‡ªåŠ¨æ¢å¤æœºåˆ¶ï¼ŒåŒ…æ‹¬æŒ‡æ ‡æ”¶é›†ã€å‘Šè­¦ã€è‡ªåŠ¨é‡å¯å’Œè‡ªæ„ˆèƒ½åŠ›ã€‚

---

## åœºæ™¯è¯´æ˜

**ç›®æ ‡ï¼š** æ„å»ºä¸€ä¸ªå®Œæ•´çš„å¥åº·ç›‘æ§å’Œè‡ªåŠ¨æ¢å¤ç³»ç»Ÿ

**åŠŸèƒ½ï¼š**
1. å®æ—¶ç›‘æ§é›†ç¾¤å¥åº·çŠ¶æ€
2. æ”¶é›†æ€§èƒ½æŒ‡æ ‡ï¼ˆQPSã€å»¶è¿Ÿã€èµ„æºä½¿ç”¨ï¼‰
3. å¼‚å¸¸æ£€æµ‹å’Œå‘Šè­¦
4. è‡ªåŠ¨é‡å¯ä¸å¥åº·çš„ç»„ä»¶
5. è‡ªåŠ¨æ‰©ç¼©å®¹

---

## å®Œæ•´å®ç°ä»£ç 

### 1. å¥åº·ç›‘æ§ç³»ç»Ÿ

```python
"""
Milvus é›†ç¾¤å¥åº·ç›‘æ§ç³»ç»Ÿ
"""
from pymilvus import connections, utility
import requests
import time
import logging
from typing import Dict, List
from dataclasses import dataclass
import subprocess

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class HealthStatus:
    """å¥åº·çŠ¶æ€"""
    component: str
    is_healthy: bool
    latency_ms: float
    error_message: str = ""

class HealthMonitor:
    """å¥åº·ç›‘æ§å™¨"""

    def __init__(self, config: Dict):
        self.milvus_host = config['milvus_host']
        self.milvus_port = config['milvus_port']
        self.metrics_port = config.get('metrics_port', 9091)
        self.namespace = config.get('namespace', 'milvus-ha')
        self.check_interval = config.get('check_interval', 30)

    def check_milvus_health(self) -> HealthStatus:
        """æ£€æŸ¥ Milvus æœåŠ¡å¥åº·"""
        try:
            start = time.time()
            connections.connect(
                alias="health_check",
                host=self.milvus_host,
                port=self.milvus_port
            )

            # æ‰§è¡Œç®€å•æŸ¥è¯¢æµ‹è¯•
            collections = utility.list_collections(using="health_check")
            latency = (time.time() - start) * 1000

            connections.disconnect("health_check")

            return HealthStatus(
                component="milvus",
                is_healthy=True,
                latency_ms=latency
            )
        except Exception as e:
            return HealthStatus(
                component="milvus",
                is_healthy=False,
                latency_ms=0,
                error_message=str(e)
            )

    def check_component_health(self, component: str) -> HealthStatus:
        """æ£€æŸ¥ç»„ä»¶å¥åº·ï¼ˆé€šè¿‡ metrics ç«¯ç‚¹ï¼‰"""
        try:
            # è·å–ç»„ä»¶çš„ Pod
            cmd = [
                "kubectl", "get", "pods",
                "-l", f"app=milvus-{component}",
                "-n", self.namespace,
                "-o", "jsonpath={.items[0].status.podIP}"
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            pod_ip = result.stdout.strip()

            if not pod_ip:
                return HealthStatus(
                    component=component,
                    is_healthy=False,
                    latency_ms=0,
                    error_message="No pod found"
                )

            # æ£€æŸ¥ healthz ç«¯ç‚¹
            start = time.time()
            response = requests.get(
                f"http://{pod_ip}:{self.metrics_port}/healthz",
                timeout=5
            )
            latency = (time.time() - start) * 1000

            return HealthStatus(
                component=component,
                is_healthy=response.status_code == 200,
                latency_ms=latency
            )
        except Exception as e:
            return HealthStatus(
                component=component,
                is_healthy=False,
                latency_ms=0,
                error_message=str(e)
            )

    def get_pod_metrics(self, component: str) -> Dict:
        """è·å– Pod èµ„æºä½¿ç”¨æŒ‡æ ‡"""
        try:
            cmd = [
                "kubectl", "top", "pods",
                "-l", f"app=milvus-{component}",
                "-n", self.namespace,
                "--no-headers"
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)

            metrics = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split()
                    metrics.append({
                        'pod': parts[0],
                        'cpu': parts[1],
                        'memory': parts[2]
                    })

            return metrics
        except Exception as e:
            logger.error(f"è·å– {component} æŒ‡æ ‡å¤±è´¥: {e}")
            return []

    def monitor_loop(self):
        """ç›‘æ§å¾ªç¯"""
        logger.info("=== å¼€å§‹å¥åº·ç›‘æ§ ===")

        components = ['proxy', 'rootcoord', 'querynode', 'datanode']

        while True:
            logger.info(f"\n{'='*60}")
            logger.info(f"å¥åº·æ£€æŸ¥ - {time.strftime('%Y-%m-%d %H:%M:%S')}")
            logger.info(f"{'='*60}")

            # æ£€æŸ¥ Milvus æœåŠ¡
            milvus_status = self.check_milvus_health()
            self._log_status(milvus_status)

            # æ£€æŸ¥å„ç»„ä»¶
            for component in components:
                status = self.check_component_health(component)
                self._log_status(status)

                # å¦‚æœä¸å¥åº·ï¼Œå°è¯•è‡ªåŠ¨æ¢å¤
                if not status.is_healthy:
                    self._auto_recover(component)

                # è·å–èµ„æºä½¿ç”¨æƒ…å†µ
                metrics = self.get_pod_metrics(component)
                for metric in metrics:
                    logger.info(f"  {metric['pod']}: CPU={metric['cpu']}, Memory={metric['memory']}")

            time.sleep(self.check_interval)

    def _log_status(self, status: HealthStatus):
        """è®°å½•çŠ¶æ€"""
        if status.is_healthy:
            logger.info(f"âœ… {status.component}: å¥åº· (å»¶è¿Ÿ: {status.latency_ms:.2f}ms)")
        else:
            logger.error(f"âŒ {status.component}: ä¸å¥åº· - {status.error_message}")

    def _auto_recover(self, component: str):
        """è‡ªåŠ¨æ¢å¤"""
        logger.warning(f"âš ï¸  å°è¯•è‡ªåŠ¨æ¢å¤: {component}")

        # é‡å¯ Pod
        cmd = [
            "kubectl", "rollout", "restart",
            f"deployment/milvus-{component}",
            "-n", self.namespace
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode == 0:
            logger.info(f"âœ… {component} é‡å¯æˆåŠŸ")
        else:
            logger.error(f"âŒ {component} é‡å¯å¤±è´¥: {result.stderr}")
```

---

### 2. æ€§èƒ½æŒ‡æ ‡æ”¶é›†å™¨

```python
"""
æ€§èƒ½æŒ‡æ ‡æ”¶é›†å™¨
"""
from prometheus_client import start_http_server, Gauge, Counter, Histogram
import time

class MetricsCollector:
    """æŒ‡æ ‡æ”¶é›†å™¨"""

    def __init__(self, port: int = 8000):
        self.port = port

        # å®šä¹‰æŒ‡æ ‡
        self.query_latency = Histogram(
            'milvus_query_latency_seconds',
            'Query latency in seconds',
            ['collection']
        )

        self.query_total = Counter(
            'milvus_query_total',
            'Total number of queries',
            ['collection', 'status']
        )

        self.collection_size = Gauge(
            'milvus_collection_size',
            'Number of entities in collection',
            ['collection']
        )

        self.component_health = Gauge(
            'milvus_component_health',
            'Component health status (1=healthy, 0=unhealthy)',
            ['component']
        )

    def start(self):
        """å¯åŠ¨ Prometheus HTTP æœåŠ¡å™¨"""
        start_http_server(self.port)
        logger.info(f"Metrics server started on port {self.port}")

    def record_query(self, collection: str, latency: float, success: bool):
        """è®°å½•æŸ¥è¯¢"""
        self.query_latency.labels(collection=collection).observe(latency)
        status = 'success' if success else 'failure'
        self.query_total.labels(collection=collection, status=status).inc()

    def update_collection_size(self, collection: str, size: int):
        """æ›´æ–° Collection å¤§å°"""
        self.collection_size.labels(collection=collection).set(size)

    def update_component_health(self, component: str, is_healthy: bool):
        """æ›´æ–°ç»„ä»¶å¥åº·çŠ¶æ€"""
        self.component_health.labels(component=component).set(1 if is_healthy else 0)
```

---

### 3. å‘Šè­¦ç³»ç»Ÿ

```python
"""
å‘Šè­¦ç³»ç»Ÿ
"""
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class AlertManager:
    """å‘Šè­¦ç®¡ç†å™¨"""

    def __init__(self, config: Dict):
        self.smtp_host = config.get('smtp_host')
        self.smtp_port = config.get('smtp_port', 587)
        self.smtp_user = config.get('smtp_user')
        self.smtp_password = config.get('smtp_password')
        self.alert_emails = config.get('alert_emails', [])
        self.alert_threshold = config.get('alert_threshold', 3)
        self.alert_history = {}

    def send_alert(self, title: str, message: str, severity: str = "warning"):
        """å‘é€å‘Šè­¦"""
        # æ£€æŸ¥æ˜¯å¦éœ€è¦å‘é€ï¼ˆé¿å…å‘Šè­¦é£æš´ï¼‰
        if not self._should_send_alert(title):
            return

        logger.warning(f"ğŸ“§ å‘é€å‘Šè­¦: {title}")

        # å‘é€é‚®ä»¶
        self._send_email(title, message, severity)

        # å‘é€åˆ° Slackï¼ˆå¯é€‰ï¼‰
        # self._send_slack(title, message, severity)

        # è®°å½•å‘Šè­¦å†å²
        self.alert_history[title] = time.time()

    def _should_send_alert(self, title: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥å‘é€å‘Šè­¦ï¼ˆé˜²æ­¢å‘Šè­¦é£æš´ï¼‰"""
        if title not in self.alert_history:
            return True

        # 5 åˆ†é’Ÿå†…ä¸é‡å¤å‘é€ç›¸åŒå‘Šè­¦
        last_alert_time = self.alert_history[title]
        return time.time() - last_alert_time > 300

    def _send_email(self, title: str, message: str, severity: str):
        """å‘é€é‚®ä»¶å‘Šè­¦"""
        try:
            msg = MIMEMultipart()
            msg['From'] = self.smtp_user
            msg['To'] = ', '.join(self.alert_emails)
            msg['Subject'] = f"[{severity.upper()}] Milvus Alert: {title}"

            body = f"""
Milvus é›†ç¾¤å‘Šè­¦

ä¸¥é‡ç¨‹åº¦: {severity}
æ ‡é¢˜: {title}
æ—¶é—´: {time.strftime('%Y-%m-%d %H:%M:%S')}

è¯¦æƒ…:
{message}

---
æ­¤é‚®ä»¶ç”± Milvus ç›‘æ§ç³»ç»Ÿè‡ªåŠ¨å‘é€
"""
            msg.attach(MIMEText(body, 'plain'))

            server = smtplib.SMTP(self.smtp_host, self.smtp_port)
            server.starttls()
            server.login(self.smtp_user, self.smtp_password)
            server.send_message(msg)
            server.quit()

            logger.info(f"âœ… å‘Šè­¦é‚®ä»¶å‘é€æˆåŠŸ")
        except Exception as e:
            logger.error(f"âŒ å‘Šè­¦é‚®ä»¶å‘é€å¤±è´¥: {e}")
```

---

### 4. è‡ªåŠ¨æ‰©ç¼©å®¹

```python
"""
è‡ªåŠ¨æ‰©ç¼©å®¹
"""
class AutoScaler:
    """è‡ªåŠ¨æ‰©ç¼©å®¹å™¨"""

    def __init__(self, config: Dict):
        self.namespace = config.get('namespace', 'milvus-ha')
        self.min_replicas = config.get('min_replicas', 2)
        self.max_replicas = config.get('max_replicas', 10)
        self.cpu_threshold = config.get('cpu_threshold', 70)  # CPU ä½¿ç”¨ç‡é˜ˆå€¼
        self.memory_threshold = config.get('memory_threshold', 80)  # å†…å­˜ä½¿ç”¨ç‡é˜ˆå€¼

    def check_and_scale(self, component: str):
        """æ£€æŸ¥å¹¶æ‰©ç¼©å®¹"""
        # è·å–å½“å‰å‰¯æœ¬æ•°
        current_replicas = self._get_current_replicas(component)

        # è·å–èµ„æºä½¿ç”¨æƒ…å†µ
        metrics = self._get_resource_usage(component)

        if not metrics:
            return

        avg_cpu = sum(m['cpu_percent'] for m in metrics) / len(metrics)
        avg_memory = sum(m['memory_percent'] for m in metrics) / len(metrics)

        logger.info(f"{component}: å‰¯æœ¬æ•°={current_replicas}, CPU={avg_cpu:.1f}%, Memory={avg_memory:.1f}%")

        # æ‰©å®¹æ¡ä»¶
        if (avg_cpu > self.cpu_threshold or avg_memory > self.memory_threshold) and current_replicas < self.max_replicas:
            new_replicas = min(current_replicas + 1, self.max_replicas)
            logger.warning(f"â¬†ï¸  æ‰©å®¹ {component}: {current_replicas} -> {new_replicas}")
            self._scale(component, new_replicas)

        # ç¼©å®¹æ¡ä»¶
        elif avg_cpu < self.cpu_threshold * 0.5 and avg_memory < self.memory_threshold * 0.5 and current_replicas > self.min_replicas:
            new_replicas = max(current_replicas - 1, self.min_replicas)
            logger.info(f"â¬‡ï¸  ç¼©å®¹ {component}: {current_replicas} -> {new_replicas}")
            self._scale(component, new_replicas)

    def _get_current_replicas(self, component: str) -> int:
        """è·å–å½“å‰å‰¯æœ¬æ•°"""
        cmd = [
            "kubectl", "get", "deployment",
            f"milvus-{component}",
            "-n", self.namespace,
            "-o", "jsonpath={.spec.replicas}"
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        return int(result.stdout.strip() or 0)

    def _get_resource_usage(self, component: str) -> List[Dict]:
        """è·å–èµ„æºä½¿ç”¨æƒ…å†µ"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä» Prometheus è·å–
        return []

    def _scale(self, component: str, replicas: int):
        """æ‰§è¡Œæ‰©ç¼©å®¹"""
        cmd = [
            "kubectl", "scale", "deployment",
            f"milvus-{component}",
            f"--replicas={replicas}",
            "-n", self.namespace
        ]
        subprocess.run(cmd)
```

---

### 5. é›†æˆç›‘æ§ç³»ç»Ÿ

```python
"""
é›†æˆç›‘æ§ç³»ç»Ÿ
"""
def main():
    # é…ç½®
    config = {
        'milvus_host': 'milvus-proxy.milvus-ha.svc.cluster.local',
        'milvus_port': '19530',
        'namespace': 'milvus-ha',
        'check_interval': 30,
        'smtp_host': 'smtp.gmail.com',
        'smtp_user': 'alerts@example.com',
        'smtp_password': 'password',
        'alert_emails': ['admin@example.com']
    }

    # åˆå§‹åŒ–ç»„ä»¶
    health_monitor = HealthMonitor(config)
    metrics_collector = MetricsCollector(port=8000)
    alert_manager = AlertManager(config)
    auto_scaler = AutoScaler(config)

    # å¯åŠ¨ Prometheus æŒ‡æ ‡æœåŠ¡å™¨
    metrics_collector.start()

    # å¯åŠ¨ç›‘æ§å¾ªç¯
    logger.info("=== ç›‘æ§ç³»ç»Ÿå¯åŠ¨ ===")

    try:
        while True:
            # å¥åº·æ£€æŸ¥
            components = ['proxy', 'rootcoord', 'querynode']

            for component in components:
                status = health_monitor.check_component_health(component)

                # æ›´æ–°æŒ‡æ ‡
                metrics_collector.update_component_health(
                    component,
                    status.is_healthy
                )

                # å‘é€å‘Šè­¦
                if not status.is_healthy:
                    alert_manager.send_alert(
                        title=f"{component} ä¸å¥åº·",
                        message=f"ç»„ä»¶ {component} å¥åº·æ£€æŸ¥å¤±è´¥: {status.error_message}",
                        severity="critical"
                    )

                    # è‡ªåŠ¨æ¢å¤
                    health_monitor._auto_recover(component)

                # è‡ªåŠ¨æ‰©ç¼©å®¹
                auto_scaler.check_and_scale(component)

            time.sleep(config['check_interval'])

    except KeyboardInterrupt:
        logger.info("\nç›‘æ§ç³»ç»Ÿåœæ­¢")

if __name__ == "__main__":
    main()
```

---

## Kubernetes é…ç½®

### HPA (Horizontal Pod Autoscaler)

```yaml
# hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: milvus-querynode-hpa
  namespace: milvus-ha
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: milvus-querynode
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
```

---

## éƒ¨ç½²å’Œä½¿ç”¨

```bash
# 1. éƒ¨ç½² HPA
kubectl apply -f hpa.yaml

# 2. å¯åŠ¨ç›‘æ§ç³»ç»Ÿ
python monitoring_system.py

# 3. æŸ¥çœ‹æŒ‡æ ‡
curl http://localhost:8000/metrics

# 4. æŸ¥çœ‹ HPA çŠ¶æ€
kubectl get hpa -n milvus-ha
```

---

## å…³é”®è¦ç‚¹

1. **å¤šå±‚ç›‘æ§**ï¼šå¥åº·æ£€æŸ¥ + æ€§èƒ½æŒ‡æ ‡ + èµ„æºä½¿ç”¨
2. **è‡ªåŠ¨æ¢å¤**ï¼šæ£€æµ‹åˆ°æ•…éšœè‡ªåŠ¨é‡å¯
3. **å‘Šè­¦æœºåˆ¶**ï¼šåŠæ—¶é€šçŸ¥è¿ç»´å›¢é˜Ÿ
4. **è‡ªåŠ¨æ‰©ç¼©å®¹**ï¼šæ ¹æ®è´Ÿè½½è‡ªåŠ¨è°ƒæ•´å‰¯æœ¬æ•°
5. **é˜²æ­¢å‘Šè­¦é£æš´**ï¼š5 åˆ†é’Ÿå†…ä¸é‡å¤å‘é€ç›¸åŒå‘Šè­¦
