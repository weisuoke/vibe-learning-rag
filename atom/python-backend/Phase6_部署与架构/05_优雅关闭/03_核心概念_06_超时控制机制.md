# 核心概念：超时控制机制

> 深入理解如何设计分阶段超时策略，避免无限等待

---

## 什么是超时控制？

**超时控制（Timeout Control）** 是优雅关闭的安全阀，确保服务在规定时间内完成关闭，避免无限等待。

**核心问题：** 如果某些请求或任务卡住，服务可能永远无法退出。

**解决方案：** 设置最大等待时间，超时后强制终止。

**类比：**
- **前端视角**：类似于 `Promise.race([task, timeout])`，给任务设置最大执行时间
- **日常视角**：类似于商场闭店时间，到点了必须关门，不能无限等待顾客

---

## 为什么需要超时控制？

### 问题场景：没有超时控制

```python
# 没有超时控制的"伪优雅关闭"
async def graceful_shutdown():
    # 等待所有请求完成
    while active_requests > 0:
        await asyncio.sleep(0.1)
    # 如果有请求卡住，这里会无限等待！

# 问题：
# 1. 某个请求卡在数据库查询（死锁）
# 2. 某个请求卡在外部 API 调用（网络超时）
# 3. 某个请求卡在 LLM 流式响应（连接断开）
# 4. 服务永远无法退出
```

**实际后果：**
```
运维视角：
- 服务无法重启（卡在关闭流程）
- 需要手动 kill -9（失去优雅关闭的意义）
- 影响滚动更新（新版本无法部署）

用户视角：
- 服务长时间不可用
- 请求超时但服务未响应
- 影响业务连续性
```

---

## 超时控制的层次

### 1. 单一超时

**最简单的超时控制：**

```python
async def graceful_shutdown_with_timeout(timeout: int = 30):
    """带超时的优雅关闭"""
    try:
        # 等待所有清理完成，最多30秒
        await asyncio.wait_for(
            cleanup_all_resources(),
            timeout=timeout
        )
        print("优雅关闭完成")
        sys.exit(0)

    except asyncio.TimeoutError:
        print(f"优雅关闭超时（{timeout}秒），强制退出")
        sys.exit(1)
```

**优点：**
- 实现简单
- 保证最终会退出

**缺点：**
- 无法区分不同阶段
- 无法针对性优化
- 超时后无法知道卡在哪里

### 2. 分阶段超时

**更精细的超时控制：**

```python
async def graceful_shutdown_staged():
    """分阶段优雅关闭"""

    # 阶段1：请求排空（30秒）
    print("阶段1：请求排空...")
    try:
        await asyncio.wait_for(
            wait_for_requests(),
            timeout=30
        )
        print("✓ 请求排空完成")
    except asyncio.TimeoutError:
        print("✗ 请求排空超时，取消剩余请求")
        # 取消所有活跃请求
        for task in active_tasks:
            task.cancel()

    # 阶段2：后台任务清理（10秒）
    print("阶段2：后台任务清理...")
    try:
        await asyncio.wait_for(
            cleanup_background_tasks(),
            timeout=10
        )
        print("✓ 后台任务清理完成")
    except asyncio.TimeoutError:
        print("✗ 后台任务清理超时")

    # 阶段3：资源清理（10秒）
    print("阶段3：资源清理...")
    try:
        await asyncio.wait_for(
            cleanup_resources(),
            timeout=10
        )
        print("✓ 资源清理完成")
    except asyncio.TimeoutError:
        print("✗ 资源清理超时")

    # 总超时：30 + 10 + 10 = 50秒
    sys.exit(0)
```

**优点：**
- 可以针对不同阶段设置不同超时
- 超时后可以继续下一阶段
- 可以记录哪个阶段超时

**缺点：**
- 实现复杂
- 总超时时间是各阶段之和

### 3. 全局超时 + 分阶段超时

**最佳实践：**

```python
async def graceful_shutdown_hybrid(global_timeout: int = 60):
    """混合超时策略"""

    start_time = asyncio.get_event_loop().time()

    def remaining_time():
        """计算剩余时间"""
        elapsed = asyncio.get_event_loop().time() - start_time
        return max(0, global_timeout - elapsed)

    # 阶段1：请求排空（最多30秒或剩余时间）
    stage_timeout = min(30, remaining_time())
    print(f"阶段1：请求排空（超时 {stage_timeout}秒）...")
    try:
        await asyncio.wait_for(
            wait_for_requests(),
            timeout=stage_timeout
        )
        print("✓ 请求排空完成")
    except asyncio.TimeoutError:
        print("✗ 请求排空超时")

    # 检查全局超时
    if remaining_time() <= 0:
        print("全局超时，强制退出")
        sys.exit(1)

    # 阶段2：后台任务清理（最多10秒或剩余时间）
    stage_timeout = min(10, remaining_time())
    print(f"阶段2：后台任务清理（超时 {stage_timeout}秒）...")
    try:
        await asyncio.wait_for(
            cleanup_background_tasks(),
            timeout=stage_timeout
        )
        print("✓ 后台任务清理完成")
    except asyncio.TimeoutError:
        print("✗ 后台任务清理超时")

    # 检查全局超时
    if remaining_time() <= 0:
        print("全局超时，强制退出")
        sys.exit(1)

    # 阶段3：资源清理（剩余时间）
    stage_timeout = remaining_time()
    print(f"阶段3：资源清理（超时 {stage_timeout}秒）...")
    try:
        await asyncio.wait_for(
            cleanup_resources(),
            timeout=stage_timeout
        )
        print("✓ 资源清理完成")
    except asyncio.TimeoutError:
        print("✗ 资源清理超时")

    sys.exit(0)
```

**优点：**
- 保证总时间不超过全局超时
- 可以针对不同阶段设置期望时间
- 灵活且可控

---

## 超时时间的设置

### 1. 根据请求类型设置

```python
# 不同类型请求的超时时间
TIMEOUT_CONFIG = {
    "fast_requests": 10,      # 快请求：10秒
    "normal_requests": 30,    # 普通请求：30秒
    "slow_requests": 60,      # 慢请求：60秒
    "streaming": 90,          # 流式响应：90秒
}

async def wait_for_requests_dynamic():
    """根据请求类型动态设置超时"""

    # 计算超时时间
    if streaming_requests > 0:
        timeout = TIMEOUT_CONFIG["streaming"]
    elif slow_requests > 0:
        timeout = TIMEOUT_CONFIG["slow_requests"]
    elif normal_requests > 0:
        timeout = TIMEOUT_CONFIG["normal_requests"]
    else:
        timeout = TIMEOUT_CONFIG["fast_requests"]

    print(f"动态超时时间: {timeout}秒")

    try:
        await asyncio.wait_for(
            wait_for_all_requests(),
            timeout=timeout
        )
    except asyncio.TimeoutError:
        print(f"请求排空超时（{timeout}秒）")
```

### 2. 根据环境设置

```python
# 不同环境的超时配置
ENVIRONMENT_TIMEOUTS = {
    "development": {
        "request_draining": 10,
        "background_tasks": 5,
        "resource_cleanup": 5,
        "global": 30,
    },
    "staging": {
        "request_draining": 30,
        "background_tasks": 10,
        "resource_cleanup": 10,
        "global": 60,
    },
    "production": {
        "request_draining": 60,
        "background_tasks": 20,
        "resource_cleanup": 20,
        "global": 120,
    },
}

# 获取当前环境的超时配置
env = os.getenv("ENVIRONMENT", "development")
timeouts = ENVIRONMENT_TIMEOUTS[env]
```

### 3. Kubernetes 环境

```yaml
# Kubernetes Pod 配置
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  terminationGracePeriodSeconds: 60  # 全局超时：60秒
  containers:
  - name: app
    image: myapp:latest
    lifecycle:
      preStop:
        exec:
          command: ["/bin/sh", "-c", "sleep 5"]  # 给5秒时间停止接收新请求
```

**Kubernetes 超时流程：**
```
1. kubectl delete pod myapp
   ↓
2. Pod 状态变为 Terminating
   ↓
3. 执行 preStop 钩子（5秒）
   ↓
4. 向容器发送 SIGTERM
   ↓
5. 等待 terminationGracePeriodSeconds（60秒）
   ↓
6. 如果容器还在运行，发送 SIGKILL
```

---

## 超时后的处理策略

### 策略1：强制退出

```python
async def graceful_shutdown_force_exit():
    """超时后强制退出"""
    try:
        await asyncio.wait_for(
            cleanup_all_resources(),
            timeout=30
        )
        sys.exit(0)  # 正常退出

    except asyncio.TimeoutError:
        print("超时，强制退出")
        os._exit(1)  # 强制退出，不执行清理
```

**适用场景：**
- 紧急情况
- 无法接受更长等待时间
- 数据一致性要求不高

### 策略2：优雅降级

```python
async def graceful_shutdown_degraded():
    """超时后优雅降级"""
    try:
        await asyncio.wait_for(
            cleanup_all_resources(),
            timeout=30
        )
        sys.exit(0)

    except asyncio.TimeoutError:
        print("超时，尝试保存状态...")

        # 保存关键状态
        try:
            await asyncio.wait_for(
                save_critical_state(),
                timeout=5
            )
        except asyncio.TimeoutError:
            print("保存状态超时")

        # 强制退出
        os._exit(1)
```

**适用场景：**
- 需要保存关键状态
- 可以接受短暂的额外等待
- 数据一致性要求高

### 策略3：分级处理

```python
async def graceful_shutdown_tiered():
    """分级处理超时"""

    # 第一次尝试：正常超时（30秒）
    try:
        await asyncio.wait_for(
            cleanup_all_resources(),
            timeout=30
        )
        sys.exit(0)

    except asyncio.TimeoutError:
        print("第一次超时，尝试快速清理...")

        # 第二次尝试：快速清理（10秒）
        try:
            await asyncio.wait_for(
                quick_cleanup(),
                timeout=10
            )
            sys.exit(0)

        except asyncio.TimeoutError:
            print("第二次超时，强制退出")
            os._exit(1)
```

---

## 超时监控和告警

### 1. 记录超时事件

```python
async def graceful_shutdown_with_logging():
    """记录超时事件"""
    start_time = time.time()

    try:
        await asyncio.wait_for(
            cleanup_all_resources(),
            timeout=30
        )

        # 记录成功
        elapsed = time.time() - start_time
        logger.info(f"优雅关闭完成，耗时 {elapsed:.2f}秒")

    except asyncio.TimeoutError:
        # 记录超时
        elapsed = time.time() - start_time
        logger.warning(
            f"优雅关闭超时，耗时 {elapsed:.2f}秒",
            extra={
                "timeout": 30,
                "active_requests": active_requests,
                "background_tasks": len(background_tasks),
            }
        )

        # 发送告警
        await send_alert("Graceful shutdown timeout")

        os._exit(1)
```

### 2. 监控超时频率

```python
# Prometheus 指标
from prometheus_client import Counter, Histogram

shutdown_duration = Histogram(
    "graceful_shutdown_duration_seconds",
    "Graceful shutdown duration"
)

shutdown_timeout_counter = Counter(
    "graceful_shutdown_timeout_total",
    "Total number of graceful shutdown timeouts"
)

async def graceful_shutdown_with_metrics():
    """记录超时指标"""
    with shutdown_duration.time():
        try:
            await asyncio.wait_for(
                cleanup_all_resources(),
                timeout=30
            )
        except asyncio.TimeoutError:
            shutdown_timeout_counter.inc()
            raise
```

### 3. 分析超时原因

```python
async def graceful_shutdown_with_analysis():
    """分析超时原因"""
    timeout_info = {
        "stage": None,
        "active_requests": active_requests,
        "background_tasks": len(background_tasks),
        "db_connections": db_pool.checkedout(),
    }

    try:
        # 阶段1：请求排空
        timeout_info["stage"] = "request_draining"
        await asyncio.wait_for(wait_for_requests(), timeout=30)

        # 阶段2：后台任务
        timeout_info["stage"] = "background_tasks"
        await asyncio.wait_for(cleanup_background_tasks(), timeout=10)

        # 阶段3：资源清理
        timeout_info["stage"] = "resource_cleanup"
        await asyncio.wait_for(cleanup_resources(), timeout=10)

    except asyncio.TimeoutError:
        # 记录超时阶段和状态
        logger.error(
            f"优雅关闭超时在阶段: {timeout_info['stage']}",
            extra=timeout_info
        )
```

---

## AI Agent 后端的超时控制

### 1. LLM 流式响应超时

```python
async def wait_for_streaming_responses(timeout: int = 90):
    """等待流式响应完成"""
    print(f"等待 {len(streaming_tasks)} 个流式响应完成...")

    try:
        await asyncio.wait_for(
            asyncio.gather(*streaming_tasks, return_exceptions=True),
            timeout=timeout
        )
        print("所有流式响应已完成")

    except asyncio.TimeoutError:
        print(f"流式响应超时（{timeout}秒），强制中断")

        # 发送结束标记
        for task in streaming_tasks:
            if not task.done():
                # 设置关闭标志，让流式响应自然结束
                shutdown_event.set()

        # 再等待5秒
        try:
            await asyncio.wait_for(
                asyncio.gather(*streaming_tasks, return_exceptions=True),
                timeout=5
            )
        except asyncio.TimeoutError:
            # 强制取消
            for task in streaming_tasks:
                if not task.done():
                    task.cancel()
```

### 2. Agent 任务超时

```python
async def wait_for_agent_tasks(timeout: int = 120):
    """等待 Agent 任务完成"""
    print(f"等待 {len(agent_tasks)} 个 Agent 任务完成...")

    # Agent 任务可能需要较长时间
    try:
        await asyncio.wait_for(
            asyncio.gather(*agent_tasks, return_exceptions=True),
            timeout=timeout
        )
        print("所有 Agent 任务已完成")

    except asyncio.TimeoutError:
        print(f"Agent 任务超时（{timeout}秒）")

        # 保存未完成任务的状态
        for task_id, task in agent_tasks.items():
            if not task.done():
                await save_agent_task_state(task_id)

        # 取消任务
        for task in agent_tasks.values():
            if not task.done():
                task.cancel()
```

### 3. 向量数据库查询超时

```python
async def cleanup_vector_db_with_timeout(timeout: int = 10):
    """清理向量数据库连接"""
    print("关闭向量数据库连接...")

    try:
        # 等待所有查询完成
        await asyncio.wait_for(
            vector_db.wait_for_queries(),
            timeout=timeout
        )

        # 关闭连接
        await vector_db.close()

        print("向量数据库连接已关闭")

    except asyncio.TimeoutError:
        print(f"向量数据库查询超时（{timeout}秒），强制关闭")

        # 强制关闭连接
        await vector_db.force_close()
```

---

## 完整示例：生产级超时控制

```python
"""
生产级超时控制实现
演示：完整的超时控制系统
"""

import asyncio
import time
from typing import Optional
from dataclasses import dataclass

@dataclass
class TimeoutConfig:
    """超时配置"""
    request_draining: int = 30
    background_tasks: int = 10
    resource_cleanup: int = 10
    global_timeout: int = 60

class GracefulShutdownManager:
    """优雅关闭管理器"""

    def __init__(self, config: TimeoutConfig):
        self.config = config
        self.start_time: Optional[float] = None
        self.timeout_info = {
            "stage": None,
            "timeout_count": 0,
            "stages_completed": [],
            "stages_timeout": [],
        }

    def remaining_time(self) -> float:
        """计算剩余时间"""
        if self.start_time is None:
            return self.config.global_timeout

        elapsed = time.time() - self.start_time
        return max(0, self.config.global_timeout - elapsed)

    async def execute_stage(
        self,
        stage_name: str,
        stage_func,
        stage_timeout: int
    ) -> bool:
        """执行一个阶段"""
        self.timeout_info["stage"] = stage_name

        # 计算实际超时时间（不超过剩余时间）
        actual_timeout = min(stage_timeout, self.remaining_time())

        if actual_timeout <= 0:
            print(f"⚠️  全局超时，跳过阶段: {stage_name}")
            self.timeout_info["stages_timeout"].append(stage_name)
            return False

        print(f"\n{'='*50}")
        print(f"阶段: {stage_name}")
        print(f"超时: {actual_timeout}秒")
        print(f"剩余全局时间: {self.remaining_time():.1f}秒")
        print(f"{'='*50}")

        try:
            await asyncio.wait_for(
                stage_func(),
                timeout=actual_timeout
            )

            print(f"✓ {stage_name} 完成")
            self.timeout_info["stages_completed"].append(stage_name)
            return True

        except asyncio.TimeoutError:
            print(f"✗ {stage_name} 超时")
            self.timeout_info["timeout_count"] += 1
            self.timeout_info["stages_timeout"].append(stage_name)
            return False

    async def shutdown(self):
        """执行优雅关闭"""
        self.start_time = time.time()

        print("\n" + "="*60)
        print("开始优雅关闭")
        print(f"全局超时: {self.config.global_timeout}秒")
        print("="*60)

        # 阶段1：请求排空
        await self.execute_stage(
            "请求排空",
            wait_for_requests,
            self.config.request_draining
        )

        # 阶段2：后台任务清理
        await self.execute_stage(
            "后台任务清理",
            cleanup_background_tasks,
            self.config.background_tasks
        )

        # 阶段3：资源清理
        await self.execute_stage(
            "资源清理",
            cleanup_resources,
            self.config.resource_cleanup
        )

        # 打印总结
        self._print_summary()

        # 根据结果决定退出码
        if self.timeout_info["timeout_count"] == 0:
            print("\n✓ 优雅关闭成功")
            sys.exit(0)
        else:
            print(f"\n⚠️  优雅关闭部分超时（{self.timeout_info['timeout_count']}个阶段）")
            sys.exit(1)

    def _print_summary(self):
        """打印总结"""
        elapsed = time.time() - self.start_time

        print("\n" + "="*60)
        print("优雅关闭总结")
        print("="*60)
        print(f"总耗时: {elapsed:.2f}秒")
        print(f"全局超时: {self.config.global_timeout}秒")
        print(f"超时阶段数: {self.timeout_info['timeout_count']}")
        print(f"\n完成的阶段:")
        for stage in self.timeout_info["stages_completed"]:
            print(f"  ✓ {stage}")
        print(f"\n超时的阶段:")
        for stage in self.timeout_info["stages_timeout"]:
            print(f"  ✗ {stage}")
        print("="*60)

# ===== 使用示例 =====

# 创建配置
config = TimeoutConfig(
    request_draining=30,
    background_tasks=10,
    resource_cleanup=10,
    global_timeout=60,
)

# 创建管理器
shutdown_manager = GracefulShutdownManager(config)

# 执行优雅关闭
await shutdown_manager.shutdown()
```

---

## 总结

### 核心要点

1. **超时控制的必要性**：
   - 避免无限等待
   - 保证服务最终会退出
   - 平衡可靠性和可用性

2. **超时策略**：
   - 单一超时：简单但不灵活
   - 分阶段超时：灵活但总时间长
   - 混合超时：最佳实践

3. **超时时间设置**：
   - 根据请求类型动态调整
   - 根据环境配置不同值
   - Kubernetes 环境需要配合 terminationGracePeriodSeconds

4. **超时后处理**：
   - 强制退出：紧急情况
   - 优雅降级：保存关键状态
   - 分级处理：多次尝试

5. **监控和告警**：
   - 记录超时事件
   - 监控超时频率
   - 分析超时原因

### 检查清单

- [ ] 设置了全局超时时间
- [ ] 为每个阶段设置了超时
- [ ] 实现了超时后的处理策略
- [ ] 记录了超时事件
- [ ] 监控了超时频率
- [ ] 分析了超时原因
- [ ] 配置了 Kubernetes terminationGracePeriodSeconds

---

**下一步**：学习 **03_核心概念_07_进程管理与信号传递.md**，了解 Uvicorn/Gunicorn 的信号处理机制。
