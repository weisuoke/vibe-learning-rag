# 实战代码 - 场景1：文件资源管理

## 概述

演示如何使用上下文管理器管理文件资源，包括读写文件、批量处理、临时文件等场景。

---

## 场景1.1：基本文件读写

```python
"""
基本文件读写示例
演示：使用 with 语句自动管理文件资源
"""

# ===== 1. 读取文件 =====
print("=== 读取文件 ===")

# 读取整个文件
with open("data.txt", "r", encoding="utf-8") as f:
    content = f.read()
    print(f"文件内容：{content[:100]}...")  # 只显示前100个字符

# 逐行读取
with open("data.txt", "r", encoding="utf-8") as f:
    for line_num, line in enumerate(f, 1):
        print(f"第{line_num}行: {line.strip()}")

# ===== 2. 写入文件 =====
print("\n=== 写入文件 ===")

# 覆盖写入
with open("output.txt", "w", encoding="utf-8") as f:
    f.write("第一行\n")
    f.write("第二行\n")
    f.write("第三行\n")
print("文件写入完成")

# 追加写入
with open("output.txt", "a", encoding="utf-8") as f:
    f.write("追加的第四行\n")
print("追加写入完成")

# ===== 3. 同时读写多个文件 =====
print("\n=== 同时读写多个文件 ===")

# 文件转换：读取输入文件，转换后写入输出文件
with open("input.txt", "r", encoding="utf-8") as infile, \
     open("output_upper.txt", "w", encoding="utf-8") as outfile:
    for line in infile:
        # 转换为大写
        outfile.write(line.upper())
print("文件转换完成")
```

**运行输出示例：**
```
=== 读取文件 ===
文件内容：这是一个示例文件...
第1行: 这是第一行
第2行: 这是第二行

=== 写入文件 ===
文件写入完成
追加写入完成

=== 同时读写多个文件 ===
文件转换完成
```

---

## 场景1.2：自定义文件管理器

```python
"""
自定义文件管理器
演示：实现带日志和错误处理的文件管理器
"""

import os
from datetime import datetime

class LoggedFileManager:
    """带日志的文件管理器"""

    def __init__(self, filename, mode="r", encoding="utf-8"):
        self.filename = filename
        self.mode = mode
        self.encoding = encoding
        self.file = None
        self.start_time = None

    def __enter__(self):
        """打开文件并记录日志"""
        self.start_time = datetime.now()
        print(f"[{self.start_time}] 打开文件: {self.filename} (模式: {self.mode})")

        try:
            self.file = open(self.filename, self.mode, encoding=self.encoding)
            print(f"文件大小: {os.path.getsize(self.filename)} 字节")
            return self.file
        except FileNotFoundError:
            print(f"错误: 文件不存在 - {self.filename}")
            raise
        except PermissionError:
            print(f"错误: 没有权限访问 - {self.filename}")
            raise

    def __exit__(self, exc_type, exc_val, exc_tb):
        """关闭文件并记录日志"""
        if self.file:
            self.file.close()

        end_time = datetime.now()
        elapsed = (end_time - self.start_time).total_seconds()

        if exc_type is None:
            print(f"[{end_time}] 文件操作成功完成")
        else:
            print(f"[{end_time}] 文件操作失败: {exc_type.__name__}: {exc_val}")

        print(f"耗时: {elapsed:.3f}秒")
        return False  # 不抑制异常

# ===== 使用自定义文件管理器 =====
print("=== 使用自定义文件管理器 ===\n")

# 成功案例
with LoggedFileManager("test.txt", "w") as f:
    f.write("Hello, World!\n")
    f.write("This is a test.\n")

print()

# 读取文件
with LoggedFileManager("test.txt", "r") as f:
    content = f.read()
    print(f"读取内容: {content}")

print()

# 错误案例：文件不存在
try:
    with LoggedFileManager("nonexistent.txt", "r") as f:
        content = f.read()
except FileNotFoundError:
    print("已捕获 FileNotFoundError")
```

**运行输出示例：**
```
=== 使用自定义文件管理器 ===

[2026-02-11 14:30:00.123456] 打开文件: test.txt (模式: w)
文件大小: 0 字节
[2026-02-11 14:30:00.234567] 文件操作成功完成
耗时: 0.111秒

[2026-02-11 14:30:00.345678] 打开文件: test.txt (模式: r)
文件大小: 28 字节
读取内容: Hello, World!
This is a test.

[2026-02-11 14:30:00.456789] 文件操作成功完成
耗时: 0.111秒

[2026-02-11 14:30:00.567890] 打开文件: nonexistent.txt (模式: r)
错误: 文件不存在 - nonexistent.txt
已捕获 FileNotFoundError
```

---

## 场景1.3：批量文件处理

```python
"""
批量文件处理
演示：使用 ExitStack 同时处理多个文件
"""

from contextlib import ExitStack
import os

def merge_files(input_files, output_file):
    """合并多个文件到一个文件"""
    print(f"=== 合并 {len(input_files)} 个文件 ===")

    with ExitStack() as stack:
        # 打开所有输入文件
        infiles = []
        for filename in input_files:
            print(f"打开输入文件: {filename}")
            f = stack.enter_context(open(filename, "r", encoding="utf-8"))
            infiles.append(f)

        # 打开输出文件
        print(f"打开输出文件: {output_file}")
        outfile = stack.enter_context(open(output_file, "w", encoding="utf-8"))

        # 合并内容
        for i, infile in enumerate(infiles, 1):
            outfile.write(f"\n{'='*50}\n")
            outfile.write(f"文件 {i}: {input_files[i-1]}\n")
            outfile.write(f"{'='*50}\n\n")
            outfile.write(infile.read())

    print(f"合并完成: {output_file}")

# ===== 创建测试文件 =====
print("=== 创建测试文件 ===")
test_files = ["file1.txt", "file2.txt", "file3.txt"]

for i, filename in enumerate(test_files, 1):
    with open(filename, "w", encoding="utf-8") as f:
        f.write(f"这是文件 {i} 的内容\n")
        f.write(f"第二行内容\n")
        f.write(f"第三行内容\n")
    print(f"创建: {filename}")

print()

# ===== 合并文件 =====
merge_files(test_files, "merged.txt")

print()

# ===== 验证结果 =====
print("=== 验证合并结果 ===")
with open("merged.txt", "r", encoding="utf-8") as f:
    content = f.read()
    print(content[:200] + "...")

# ===== 清理测试文件 =====
print("\n=== 清理测试文件 ===")
for filename in test_files + ["merged.txt"]:
    os.remove(filename)
    print(f"删除: {filename}")
```

**运行输出示例：**
```
=== 创建测试文件 ===
创建: file1.txt
创建: file2.txt
创建: file3.txt

=== 合并 3 个文件 ===
打开输入文件: file1.txt
打开输入文件: file2.txt
打开输入文件: file3.txt
打开输出文件: merged.txt
合并完成: merged.txt

=== 验证合并结果 ===
==================================================
文件 1: file1.txt
==================================================

这是文件 1 的内容
第二行内容
第三行内容

==================================================
文件 2: file2.txt
==================================================
...

=== 清理测试文件 ===
删除: file1.txt
删除: file2.txt
删除: file3.txt
删除: merged.txt
```

---

## 场景1.4：临时文件管理

```python
"""
临时文件管理
演示：使用上下文管理器自动清理临时文件
"""

import tempfile
import os
from contextlib import contextmanager

@contextmanager
def temp_file(suffix="", prefix="tmp", dir=None):
    """创建临时文件，退出时自动删除"""
    # 创建临时文件
    fd, path = tempfile.mkstemp(suffix=suffix, prefix=prefix, dir=dir)
    print(f"创建临时文件: {path}")

    try:
        # 关闭文件描述符，返回文件路径
        os.close(fd)
        yield path
    finally:
        # 删除临时文件
        if os.path.exists(path):
            os.remove(path)
            print(f"删除临时文件: {path}")

@contextmanager
def temp_directory():
    """创建临时目录，退出时自动删除"""
    # 创建临时目录
    path = tempfile.mkdtemp()
    print(f"创建临时目录: {path}")

    try:
        yield path
    finally:
        # 删除临时目录及其内容
        import shutil
        if os.path.exists(path):
            shutil.rmtree(path)
            print(f"删除临时目录: {path}")

# ===== 使用临时文件 =====
print("=== 使用临时文件 ===\n")

with temp_file(suffix=".txt", prefix="test_") as tmpfile:
    # 写入临时文件
    with open(tmpfile, "w") as f:
        f.write("临时数据\n")
        f.write("这些数据会被自动清理\n")

    # 读取临时文件
    with open(tmpfile, "r") as f:
        content = f.read()
        print(f"临时文件内容:\n{content}")

print()

# ===== 使用临时目录 =====
print("=== 使用临时目录 ===\n")

with temp_directory() as tmpdir:
    # 在临时目录中创建文件
    file1 = os.path.join(tmpdir, "file1.txt")
    file2 = os.path.join(tmpdir, "file2.txt")

    with open(file1, "w") as f:
        f.write("文件1内容\n")
    print(f"创建: {file1}")

    with open(file2, "w") as f:
        f.write("文件2内容\n")
    print(f"创建: {file2}")

    # 列出临时目录内容
    files = os.listdir(tmpdir)
    print(f"临时目录内容: {files}")

print("\n所有临时资源已自动清理")
```

**运行输出示例：**
```
=== 使用临时文件 ===

创建临时文件: /tmp/test_abc123.txt
临时文件内容:
临时数据
这些数据会被自动清理

删除临时文件: /tmp/test_abc123.txt

=== 使用临时目录 ===

创建临时目录: /tmp/tmpxyz789
创建: /tmp/tmpxyz789/file1.txt
创建: /tmp/tmpxyz789/file2.txt
临时目录内容: ['file1.txt', 'file2.txt']
删除临时目录: /tmp/tmpxyz789

所有临时资源已自动清理
```

---

## 场景1.5：文件锁管理

```python
"""
文件锁管理
演示：使用上下文管理器管理文件锁，防止并发写入冲突
"""

import fcntl
import time
from contextlib import contextmanager

@contextmanager
def file_lock(filename, mode="a"):
    """文件锁上下文管理器"""
    print(f"尝试获取文件锁: {filename}")

    # 打开文件
    f = open(filename, mode)

    try:
        # 获取排他锁（阻塞）
        fcntl.flock(f.fileno(), fcntl.LOCK_EX)
        print(f"✓ 获取文件锁成功: {filename}")

        yield f

    finally:
        # 释放锁
        fcntl.flock(f.fileno(), fcntl.LOCK_UN)
        f.close()
        print(f"✓ 释放文件锁: {filename}")

# ===== 使用文件锁 =====
print("=== 使用文件锁 ===\n")

# 创建测试文件
test_file = "locked_file.txt"
with open(test_file, "w") as f:
    f.write("初始内容\n")

# 模拟并发写入（实际上是串行，因为有锁）
def write_with_lock(content, delay=0.1):
    """带锁的写入操作"""
    with file_lock(test_file) as f:
        # 模拟耗时操作
        time.sleep(delay)
        f.write(f"{content}\n")
        print(f"写入: {content}")

# 执行多次写入
write_with_lock("第一次写入", 0.1)
print()
write_with_lock("第二次写入", 0.1)
print()
write_with_lock("第三次写入", 0.1)

print()

# 验证结果
print("=== 验证文件内容 ===")
with open(test_file, "r") as f:
    content = f.read()
    print(content)

# 清理
import os
os.remove(test_file)
print(f"清理: {test_file}")
```

**运行输出示例：**
```
=== 使用文件锁 ===

尝试获取文件锁: locked_file.txt
✓ 获取文件锁成功: locked_file.txt
写入: 第一次写入
✓ 释放文件锁: locked_file.txt

尝试获取文件锁: locked_file.txt
✓ 获取文件锁成功: locked_file.txt
写入: 第二次写入
✓ 释放文件锁: locked_file.txt

尝试获取文件锁: locked_file.txt
✓ 获取文件锁成功: locked_file.txt
写入: 第三次写入
✓ 释放文件锁: locked_file.txt

=== 验证文件内容 ===
初始内容
第一次写入
第二次写入
第三次写入

清理: locked_file.txt
```

---

## 在 AI Agent 后端中的应用

### 应用1：日志文件管理

```python
"""
AI Agent 日志文件管理
演示：在 FastAPI 中使用上下文管理器管理日志文件
"""

from contextlib import contextmanager
from datetime import datetime
import json

@contextmanager
def agent_log_file(agent_id, action):
    """AI Agent 日志文件上下文管理器"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = f"logs/agent_{agent_id}_{action}_{timestamp}.json"

    print(f"开始记录 Agent 日志: {log_file}")

    logs = {
        "agent_id": agent_id,
        "action": action,
        "start_time": datetime.now().isoformat(),
        "events": []
    }

    try:
        yield logs["events"]  # 提供事件列表给调用者

        # 记录成功
        logs["status"] = "success"
        logs["end_time"] = datetime.now().isoformat()

    except Exception as e:
        # 记录失败
        logs["status"] = "failed"
        logs["error"] = str(e)
        logs["end_time"] = datetime.now().isoformat()
        raise

    finally:
        # 写入日志文件
        with open(log_file, "w") as f:
            json.dump(logs, f, indent=2)
        print(f"日志已保存: {log_file}")

# 使用示例
with agent_log_file("agent_001", "process_query") as events:
    events.append({"step": 1, "action": "接收查询"})
    events.append({"step": 2, "action": "检索文档"})
    events.append({"step": 3, "action": "生成回答"})
```

### 应用2：配置文件管理

```python
"""
配置文件管理
演示：临时修改 AI Agent 配置
"""

@contextmanager
def temp_agent_config(**overrides):
    """临时修改 Agent 配置"""
    from app.config import config

    # 保存原配置
    old_values = {}
    for key, value in overrides.items():
        old_values[key] = getattr(config, key, None)
        setattr(config, key, value)
        print(f"配置修改: {key} = {value}")

    try:
        yield config
    finally:
        # 恢复原配置
        for key, old_value in old_values.items():
            setattr(config, key, old_value)
            print(f"配置恢复: {key} = {old_value}")

# 使用示例
with temp_agent_config(temperature=0.1, max_tokens=100):
    # 在这个范围内使用低温度和短输出
    response = agent.generate(prompt)
# 配置自动恢复
```

---

## 总结

### 文件管理最佳实践

1. ✅ **总是使用 with 语句**：自动关闭文件，防止资源泄漏
2. ✅ **指定编码**：明确指定 `encoding="utf-8"`
3. ✅ **使用 ExitStack**：处理动态数量的文件
4. ✅ **临时文件自动清理**：使用 `@contextmanager` 包装
5. ✅ **文件锁防止冲突**：并发写入时使用文件锁

### 常见错误

1. ❌ 忘记关闭文件：导致资源泄漏
2. ❌ 在 with 块外使用文件对象：文件已关闭
3. ❌ 不处理文件不存在异常：程序崩溃
4. ❌ 并发写入不加锁：数据损坏

---

**版本：** v1.0
**最后更新：** 2026-02-11
