# 实战代码 - 场景1: 基础分区操作

完整演示 Milvus Partition 的基础操作，包括创建、插入、查询、加载、释放、删除等核心功能。

---

## 场景描述

**目标**: 构建一个简单的文档管理系统，使用分区按月组织数据

**需求**:
- 按月创建分区
- 插入文档到指定月份分区
- 从指定月份分区检索文档
- 管理分区的加载和释放
- 查看分区统计信息

---

## 完整代码

```python
"""
Milvus Partition 基础操作示例
演示：创建分区、插入数据、查询、加载/释放、统计信息
"""

from pymilvus import (
    connections,
    Collection,
    FieldSchema,
    CollectionSchema,
    DataType,
    utility
)
import numpy as np
from datetime import datetime
import time

# ===== 1. 连接到 Milvus =====
print("=== 1. 连接到 Milvus ===")
connections.connect(
    alias="default",
    host="localhost",
    port="19530"
)
print("✓ 连接成功")

# ===== 2. 创建 Collection =====
print("\n=== 2. 创建 Collection ===")

collection_name = "document_collection"

# 删除已存在的 Collection（如果存在）
if utility.has_collection(collection_name):
    utility.drop_collection(collection_name)
    print(f"✓ 删除旧的 Collection: {collection_name}")

# 定义 Schema
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=128),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=500),
    FieldSchema(name="created_at", dtype=DataType.INT64)
]

schema = CollectionSchema(
    fields,
    description="文档管理系统 - 按月分区"
)

# 创建 Collection
collection = Collection(collection_name, schema)
print(f"✓ 创建 Collection: {collection_name}")

# ===== 3. 创建分区 =====
print("\n=== 3. 创建分区 ===")

# 创建3个月的分区
partition_names = ["partition_2024_01", "partition_2024_02", "partition_2024_03"]

for partition_name in partition_names:
    partition = collection.create_partition(
        partition_name,
        description=f"{partition_name.split('_')[1]}年{partition_name.split('_')[2]}月的文档"
    )
    print(f"✓ 创建分区: {partition_name}")

# 列出所有分区
print("\n所有分区:")
for partition in collection.partitions:
    print(f"  - {partition.name}: {partition.description}")

# ===== 4. 插入数据到分区 =====
print("\n=== 4. 插入数据到分区 ===")

def insert_documents_to_partition(partition_name, count=100):
    """插入文档到指定分区"""
    partition = collection.partition(partition_name)

    # 生成随机向量和文本
    vectors = np.random.rand(count, 128).tolist()
    texts = [f"Document {i} in {partition_name}" for i in range(count)]
    timestamps = [int(datetime.now().timestamp())] * count

    # 插入数据
    data = [vectors, texts, timestamps]
    result = partition.insert(data)

    print(f"✓ 插入 {count} 条文档到 {partition_name}")
    print(f"  ID 范围: {result.primary_keys[0]} - {result.primary_keys[-1]}")

    return result.primary_keys

# 向每个分区插入数据
for partition_name in partition_names:
    insert_documents_to_partition(partition_name, count=100)

# 刷新到磁盘
collection.flush()
print("\n✓ 数据已刷新到磁盘")

# ===== 5. 创建索引 =====
print("\n=== 5. 创建索引 ===")

index_params = {
    "index_type": "HNSW",
    "metric_type": "COSINE",
    "params": {"M": 16, "efConstruction": 256}
}

collection.create_index(
    field_name="embedding",
    index_params=index_params
)
print("✓ 创建 HNSW 索引")

# ===== 6. 加载分区 =====
print("\n=== 6. 加载分区到内存 ===")

# 只加载前2个分区
partitions_to_load = ["partition_2024_01", "partition_2024_02"]

for partition_name in partitions_to_load:
    partition = collection.partition(partition_name)
    partition.load()
    print(f"✓ 加载分区: {partition_name}")

# 检查加载状态
print("\n分区加载状态:")
for partition in collection.partitions:
    status = "已加载" if partition.is_loaded else "未加载"
    print(f"  - {partition.name}: {status}")

# ===== 7. 从分区检索 =====
print("\n=== 7. 从分区检索 ===")

# 准备查询向量
query_vector = np.random.rand(1, 128).tolist()

search_params = {
    "metric_type": "COSINE",
    "params": {"ef": 64}
}

# 测试1：从单个分区检索
print("\n测试1: 从单个分区检索")
start = time.time()
results = collection.search(
    data=query_vector,
    anns_field="embedding",
    param=search_params,
    limit=5,
    partition_names=["partition_2024_01"],
    output_fields=["text"]
)
time_single = (time.time() - start) * 1000

print(f"✓ 检索完成，耗时: {time_single:.2f}ms")
print("检索结果:")
for i, hit in enumerate(results[0]):
    print(f"  {i+1}. ID: {hit.id}, 距离: {hit.distance:.4f}, 文本: {hit.entity.get('text')}")

# 测试2：从多个分区检索
print("\n测试2: 从多个分区检索")
start = time.time()
results = collection.search(
    data=query_vector,
    anns_field="embedding",
    param=search_params,
    limit=5,
    partition_names=["partition_2024_01", "partition_2024_02"],
    output_fields=["text"]
)
time_multi = (time.time() - start) * 1000

print(f"✓ 检索完成，耗时: {time_multi:.2f}ms")
print(f"检索了 2 个分区，返回 {len(results[0])} 条结果")

# ===== 8. Query 操作（标量查询）=====
print("\n=== 8. Query 操作 ===")

# 查询指定分区的前10条数据
results = collection.query(
    expr="id >= 0",
    output_fields=["id", "text"],
    partition_names=["partition_2024_01"],
    limit=10
)

print(f"✓ 查询到 {len(results)} 条数据")
print("查询结果（前5条）:")
for i, result in enumerate(results[:5]):
    print(f"  {i+1}. ID: {result['id']}, 文本: {result['text']}")

# ===== 9. 分区统计信息 =====
print("\n=== 9. 分区统计信息 ===")

print("\n分区详细信息:")
print(f"{'分区名':<25} {'数据量':<10} {'加载状态':<10}")
print("-" * 50)

for partition in collection.partitions:
    num_entities = partition.num_entities
    is_loaded = "已加载" if partition.is_loaded else "未加载"
    print(f"{partition.name:<25} {num_entities:<10} {is_loaded:<10}")

# Collection 总数据量
total_entities = collection.num_entities
print(f"\nCollection 总数据量: {total_entities}")

# ===== 10. 释放分区 =====
print("\n=== 10. 释放分区 ===")

# 释放第一个分区
partition = collection.partition("partition_2024_01")
partition.release()
print(f"✓ 释放分区: partition_2024_01")

# 检查释放后的状态
print("\n释放后的加载状态:")
for partition in collection.partitions:
    status = "已加载" if partition.is_loaded else "未加载"
    print(f"  - {partition.name}: {status}")

# ===== 11. 删除分区数据 =====
print("\n=== 11. 删除分区数据 ===")

# 查询要删除的数据
results = collection.query(
    expr="id >= 0",
    output_fields=["id"],
    partition_names=["partition_2024_03"],
    limit=10
)

if results:
    # 删除前10条数据
    ids_to_delete = [r["id"] for r in results]
    collection.delete(
        expr=f"id in {ids_to_delete}",
        partition_name="partition_2024_03"
    )
    collection.flush()
    print(f"✓ 从 partition_2024_03 删除了 {len(ids_to_delete)} 条数据")

    # 验证删除
    partition = collection.partition("partition_2024_03")
    print(f"删除后 partition_2024_03 的数据量: {partition.num_entities}")

# ===== 12. 删除分区 =====
print("\n=== 12. 删除分区 ===")

# 删除第三个分区
collection.drop_partition("partition_2024_03")
print("✓ 删除分区: partition_2024_03")

# 列出剩余分区
print("\n剩余分区:")
for partition in collection.partitions:
    print(f"  - {partition.name}")

# ===== 13. 清理资源 =====
print("\n=== 13. 清理资源 ===")

# 释放所有分区
for partition in collection.partitions:
    if partition.is_loaded:
        partition.release()
        print(f"✓ 释放分区: {partition.name}")

# 断开连接
connections.disconnect("default")
print("✓ 断开连接")

print("\n=== 基础分区操作演示完成 ===")
```

---

## 运行输出示例

```
=== 1. 连接到 Milvus ===
✓ 连接成功

=== 2. 创建 Collection ===
✓ 删除旧的 Collection: document_collection
✓ 创建 Collection: document_collection

=== 3. 创建分区 ===
✓ 创建分区: partition_2024_01
✓ 创建分区: partition_2024_02
✓ 创建分区: partition_2024_03

所有分区:
  - _default:
  - partition_2024_01: 2024年01月的文档
  - partition_2024_02: 2024年02月的文档
  - partition_2024_03: 2024年03月的文档

=== 4. 插入数据到分区 ===
✓ 插入 100 条文档到 partition_2024_01
  ID 范围: 442844556789123456 - 442844556789123555
✓ 插入 100 条文档到 partition_2024_02
  ID 范围: 442844556789123556 - 442844556789123655
✓ 插入 100 条文档到 partition_2024_03
  ID 范围: 442844556789123656 - 442844556789123755

✓ 数据已刷新到磁盘

=== 5. 创建索引 ===
✓ 创建 HNSW 索引

=== 6. 加载分区到内存 ===
✓ 加载分区: partition_2024_01
✓ 加载分区: partition_2024_02

分区加载状态:
  - _default: 未加载
  - partition_2024_01: 已加载
  - partition_2024_02: 已加载
  - partition_2024_03: 未加载

=== 7. 从分区检索 ===

测试1: 从单个分区检索
✓ 检索完成，耗时: 15.23ms
检索结果:
  1. ID: 442844556789123478, 距离: 0.8234, 文本: Document 22 in partition_2024_01
  2. ID: 442844556789123501, 距离: 0.8156, 文本: Document 45 in partition_2024_01
  3. ID: 442844556789123489, 距离: 0.8089, 文本: Document 33 in partition_2024_01
  4. ID: 442844556789123512, 距离: 0.7998, 文本: Document 56 in partition_2024_01
  5. ID: 442844556789123467, 距离: 0.7945, 文本: Document 11 in partition_2024_01

测试2: 从多个分区检索
✓ 检索完成，耗时: 22.45ms
检索了 2 个分区，返回 5 条结果

=== 8. Query 操作 ===
✓ 查询到 10 条数据
查询结果（前5条）:
  1. ID: 442844556789123456, 文本: Document 0 in partition_2024_01
  2. ID: 442844556789123457, 文本: Document 1 in partition_2024_01
  3. ID: 442844556789123458, 文本: Document 2 in partition_2024_01
  4. ID: 442844556789123459, 文本: Document 3 in partition_2024_01
  5. ID: 442844556789123460, 文本: Document 4 in partition_2024_01

=== 9. 分区统计信息 ===

分区详细信息:
分区名                      数据量        加载状态
--------------------------------------------------
_default                  0          未加载
partition_2024_01         100        已加载
partition_2024_02         100        已加载
partition_2024_03         100        未加载

Collection 总数据量: 300

=== 10. 释放分区 ===
✓ 释放分区: partition_2024_01

释放后的加载状态:
  - _default: 未加载
  - partition_2024_01: 未加载
  - partition_2024_02: 已加载
  - partition_2024_03: 未加载

=== 11. 删除分区数据 ===
✓ 从 partition_2024_03 删除了 10 条数据
删除后 partition_2024_03 的数据量: 90

=== 12. 删除分区 ===
✓ 删除分区: partition_2024_03

剩余分区:
  - _default
  - partition_2024_01
  - partition_2024_02

=== 13. 清理资源 ===
✓ 释放分区: partition_2024_02
✓ 断开连接

=== 基础分区操作演示完成 ===
```

---

## 关键知识点

### 1. 分区创建

```python
# 创建分区时可以添加描述
partition = collection.create_partition(
    "partition_2024_01",
    description="2024年1月的文档"
)
```

**要点**:
- 分区名必须唯一
- 描述是可选的，但建议添加
- 每个 Collection 默认有 `_default` 分区

---

### 2. 数据插入

```python
# 插入到指定分区
partition = collection.partition("partition_2024_01")
partition.insert(data)
```

**要点**:
- 必须明确指定分区
- 数据格式必须与 Schema 一致
- 插入后需要 `flush()` 持久化

---

### 3. 分区检索

```python
# 指定分区检索
results = collection.search(
    query_vector,
    partition_names=["partition_2024_01"]  # 明确指定分区
)
```

**要点**:
- 始终明确指定 `partition_names`
- 可以指定多个分区
- 不指定会检索所有分区（包括 `_default`）

---

### 4. 加载和释放

```python
# 加载分区
partition.load()

# 释放分区
partition.release()
```

**要点**:
- 分区必须加载才能检索
- 加载会占用内存
- 释放可以节省内存

---

### 5. 分区统计

```python
# 获取分区数据量
num_entities = partition.num_entities

# 检查加载状态
is_loaded = partition.is_loaded
```

**要点**:
- `num_entities` 返回分区的数据量
- `is_loaded` 返回加载状态

---

## 常见问题

### Q1: 为什么插入后查询不到数据？

**A**: 需要经过 flush → 索引 → load 三个步骤

```python
# 正确流程
partition.insert(data)
collection.flush()           # 1. 刷新到磁盘
collection.create_index()    # 2. 创建索引
partition.load()             # 3. 加载到内存
# 现在可以检索了
```

---

### Q2: 如何检查分区是否存在？

**A**: 使用 `has_partition()` 方法

```python
if collection.has_partition("partition_2024_01"):
    print("分区存在")
else:
    print("分区不存在")
```

---

### Q3: 删除分区会删除数据吗？

**A**: 是的，删除分区会永久删除分区内的所有数据

```python
# 删除分区（谨慎操作！）
collection.drop_partition("partition_2024_03")
# 分区内的所有数据都会被删除
```

---

### Q4: 如何清空分区但保留分区？

**A**: 使用 `delete()` 删除所有数据

```python
# 查询所有 ID
results = collection.query(
    expr="id >= 0",
    output_fields=["id"],
    partition_names=["partition_2024_01"]
)

# 删除所有数据
ids = [r["id"] for r in results]
collection.delete(
    expr=f"id in {ids}",
    partition_name="partition_2024_01"
)
```

---

## 扩展练习

### 练习1: 动态分区创建

修改代码，实现根据当前日期自动创建月度分区。

### 练习2: 批量插入优化

实现批量插入功能，每批次插入 1000 条数据，测试性能提升。

### 练习3: 分区管理工具

创建一个 `PartitionManager` 类，封装分区的创建、加载、释放、统计等功能。

### 练习4: 性能对比

对比有分区和无分区的检索性能差异。

---

## 总结

本示例演示了 Milvus Partition 的所有基础操作：

1. ✅ 创建分区
2. ✅ 插入数据到分区
3. ✅ 从分区检索
4. ✅ 加载和释放分区
5. ✅ 查看分区统计
6. ✅ 删除分区数据
7. ✅ 删除分区

掌握这些基础操作后，可以继续学习更高级的分区策略和优化技巧。
