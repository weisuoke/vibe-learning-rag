# 化骨绵掌

> 10 个 2 分钟知识卡片，快速掌握 Pi 交互模式的核心要点

---

## 卡片 1：交互界面三区域布局

**一句话：** Pi 的交互界面分为状态栏、对话区、编辑器三个区域，各司其职。

**举例：**
```
┌─────────────────────────────────────────┐
│ claude-opus-4 | my-session | 1.2K tokens│ ← 状态栏
├─────────────────────────────────────────┤
│ User: 请帮我修复 bug                     │
│ AI: 让我先读取文件...                    │ ← 对话区
│ [Tool: read] src/auth.ts                │
│ AI: 我发现了问题...                      │
├─────────────────────────────────────────┤
│ > 在这里输入消息...                      │ ← 编辑器
└─────────────────────────────────────────┘
```

**TypeScript 表达：**
```typescript
interface PiInterface {
  statusBar: { model: string; session: string; tokens: number };
  conversationArea: Message[];
  editor: { input: string; cursor: number };
}
```

**应用：** 状态栏监控成本，对话区查看历史，编辑器输入消息。

---

## 卡片 2：15 个命令分 4 类

**一句话：** Pi 的 15 个命令分为认证、模型、会话、系统四类。

**举例：**
```typescript
const commands = {
  // 认证命令（2 个）
  auth: ['/login', '/logout'],

  // 模型命令（2 个）
  model: ['/model', '/scoped-models'],

  // 会话命令（6 个）
  session: ['/new', '/resume', '/name', '/session', '/tree', '/fork', '/compact'],

  // 系统命令（5 个）
  system: ['/settings', '/copy', '/export', '/share', '/reload', '/hotkeys', '/changelog', '/quit']
};
```

**记忆技巧：**
- 认证：登录/登出
- 模型：切换/配置
- 会话：创建/管理/分支
- 系统：设置/导出/重载

**应用：** 根据任务类型选择对应类别的命令。

---

## 卡片 3：@文件引用的三种用法

**一句话：** @文件引用支持精确路径、模糊搜索、多文件引用。

**举例：**
```bash
# 1. 精确路径
@src/auth.ts

# 2. 模糊搜索
@auth
# 列出所有包含 "auth" 的文件

# 3. 多文件引用
@src/auth.ts @src/api.ts @src/types.ts
# 同时引用多个文件
```

**TypeScript 实现：**
```typescript
function resolveFileReference(ref: string): string[] {
  if (fs.existsSync(ref)) {
    // 精确路径
    return [ref];
  } else {
    // 模糊搜索
    return glob(`**/*${ref}*`);
  }
}
```

**应用：** 代码审查时引用多个相关文件，让 AI 全面分析。

---

## 卡片 4：!命令执行的两种模式

**一句话：** !command 发送输出给 AI，!!command 只执行不发送。

**举例：**
```bash
# 场景 1：需要 AI 分析输出
!npm test
请分析测试失败的原因

# 场景 2：只需要执行（如构建）
!!npm run build

# 场景 3：查看状态并请求建议
!git status
请帮我决定哪些文件应该提交
```

**对比：**
```typescript
// !command
const output = exec('npm test');
sendToAI(output);  // 发送给 AI

// !!command
exec('npm run build');
// 不发送给 AI
```

**应用：** 测试失败用 !，构建打包用 !!。

---

## 卡片 5：Session 的单文件树形结构

**一句话：** 所有分支存储在同一个 JSONL 文件中，通过 parent 字段构建树。

**举例：**
```typescript
// session.jsonl（单个文件）
{"id":"1","content":"Hello","parent":null}
{"id":"2","content":"Hi","parent":"1"}
{"id":"3","content":"Question A","parent":"2"}  // 主线
{"id":"4","content":"Question B","parent":"2"}  // 分支

// 树形结构
//     1
//     ↓
//     2
//    ↙ ↘
//   3   4
```

**Git 类比：**
```bash
# Git：多个文件
.git/refs/heads/main
.git/refs/heads/feature

# Pi：单个文件
~/.pi/sessions/project.jsonl
```

**应用：** 使用 /fork 创建分支尝试不同方案，所有历史都在一个文件中。

---

## 卡片 6：Compaction 不删除历史

**一句话：** Compaction 只添加摘要标记，原始消息完整保留在 JSONL 中。

**举例：**
```typescript
// Compaction 前
{"id":"1","content":"Message 1"}
{"id":"2","content":"Message 2"}
// ... 100 条消息

// Compaction 后
{"id":"1","content":"Message 1"}  // 保留
{"id":"2","content":"Message 2"}  // 保留
// ... 100 条消息  // 全部保留
{"type":"compaction","summary":"前 100 条消息的摘要..."}  // 新增
{"id":"101","content":"New message"}
```

**效果：**
```typescript
const effect = {
  jsonl: '完整保留所有消息',
  llmContext: '使用摘要 + 最近消息',
  tokenReduction: '从 150K 降到 50K'
};
```

**应用：** 长会话定期 /compact 降低成本，历史完整保留可审计。

---

## 卡片 7：工具调用的异步流程

**一句话：** 用户消息 → LLM 决策 → 工具执行 → 结果返回 → LLM 生成回复。

**举例：**
```typescript
// 完整流程
async function toolCallFlow() {
  // 1. 用户消息
  const userMsg = "请读取 @auth.ts 并修复 bug";

  // 2. LLM 决策
  const llmResponse = await llm.chat(userMsg);
  // llmResponse.toolCalls = [{ name: 'read', args: { path: 'src/auth.ts' } }]

  // 3. 工具执行
  const result = await tools.read({ path: 'src/auth.ts' });

  // 4. 结果返回给 LLM
  const finalResponse = await llm.chat([userMsg, llmResponse, result]);

  // 5. LLM 生成回复
  return finalResponse;
}
```

**可视化：**
```
User → LLM → Tool → LLM → User
       ↓      ↓      ↓
     决策   执行   回复
```

**应用：** 理解工具调用流程，优化提示词让 LLM 正确调用工具。

---

## 卡片 8：模型切换的三种方式

**一句话：** 命令切换、快捷键切换、Scoped models 循环切换。

**举例：**
```bash
# 方式 1：命令切换
/model claude-opus-4

# 方式 2：快捷键切换
Ctrl+L  # 打开模型选择器

# 方式 3：Scoped models 循环切换
/scoped-models claude-opus-4 claude-sonnet-4 claude-haiku-4
Ctrl+P  # 向前循环
Shift+Ctrl+P  # 向后循环
```

**TypeScript 实现：**
```typescript
class ModelSwitcher {
  private scopedModels: string[] = [];
  private currentIndex: number = 0;

  cycleFoward() {
    this.currentIndex = (this.currentIndex + 1) % this.scopedModels.length;
    return this.scopedModels[this.currentIndex];
  }

  cycleBackward() {
    this.currentIndex = (this.currentIndex - 1 + this.scopedModels.length) % this.scopedModels.length;
    return this.scopedModels[this.currentIndex];
  }
}
```

**应用：** 配置常用模型到 Scoped models，快速切换无需记住模型名。

---

## 卡片 9：Extensions 的热重载机制

**一句话：** 修改 Extension 后使用 /reload 热重载，无需重启 pi。

**举例：**
```typescript
// 1. 创建 Extension
// .pi/extensions/my-tool.ts
export default class MyTool extends Extension {
  async onLoad() {
    this.registerTool('greet', async (args) => {
      return `Hello, ${args.name}!`;
    });
  }
}

// 2. 在 pi 中重载
> /reload
Extensions reloaded: my-tool

// 3. 修改 Extension
// 改为中文问候
return `你好, ${args.name}！`;

// 4. 再次重载（无需重启）
> /reload
Extensions reloaded: my-tool
```

**热重载实现：**
```typescript
async reload() {
  // 1. 卸载所有 Extensions
  for (const ext of this.extensions.values()) {
    await ext.onUnload();
  }

  // 2. 清除 require 缓存
  delete require.cache[require.resolve(file)];

  // 3. 重新加载
  const ExtClass = require(file).default;
  const ext = new ExtClass();
  await ext.onLoad();
}
```

**应用：** 快速迭代 Extension 开发，保持会话上下文。

---

## 卡片 10：Pi 的极简哲学

**一句话：** 核心只做必要功能，其他通过 Extensions 扩展。

**举例：**
```typescript
// Pi 核心（~5000 行代码）
const piCore = {
  llmAbstraction: 'pi-ai',      // 统一 LLM API
  agentRuntime: 'pi-agent-core', // 工具调用 + 状态管理
  storage: 'JSONL',              // 追加式存储
  ui: 'pi-tui',                  // 终端 UI
};

// 扩展功能（通过 Extensions）
const extensions = {
  official: ['pi-interactive-shell', 'pi-messenger'],
  community: ['pIRS', 'math-rendering', 'vercel-gateway'],
  custom: 'any extension you want'
};
```

**对比：**
```typescript
// Claude Code：功能完整
features = ['内置功能 1', '内置功能 2', ..., '内置功能 N'];

// Pi：极简核心 + 扩展
core = ['核心功能 1', '核心功能 2', '核心功能 3'];
extensions = ['扩展 1', '扩展 2', ..., '扩展 N'];
```

**Unix 哲学：**
- 做好一件事
- 可组合性
- 文本流

**应用：** 需要新功能时，先找 Extension，没有就自己写一个。

---

## 快速参考总结表

| 卡片 | 核心概念 | 关键词 | 应用场景 |
|------|---------|--------|---------|
| 1 | 界面布局 | 状态栏、对话区、编辑器 | 理解界面结构 |
| 2 | 命令分类 | 认证、模型、会话、系统 | 快速找到需要的命令 |
| 3 | @文件引用 | 精确、模糊、多文件 | 代码审查、上下文注入 |
| 4 | !命令执行 | !发送、!!不发送 | 测试分析、构建打包 |
| 5 | Session 结构 | 单文件、树形、parent | 分支管理、历史追溯 |
| 6 | Compaction | 添加摘要、保留原始 | 成本控制、审计合规 |
| 7 | 工具调用 | 异步流程、5 步骤 | 理解工具调用机制 |
| 8 | 模型切换 | 命令、快捷键、循环 | 快速切换模型 |
| 9 | 热重载 | /reload、无需重启 | Extension 开发 |
| 10 | 极简哲学 | 核心 + 扩展 | 理解设计理念 |

---

## 学习路径建议

### 第 1 天：基础操作（卡片 1-4）
- 理解界面布局
- 掌握命令分类
- 学会 @文件引用
- 学会 !命令执行

**练习：**
```bash
# 1. 启动 pi 并观察界面
pi

# 2. 尝试命令
/help
/model
/new

# 3. 引用文件
@src/index.ts
请审查这个文件

# 4. 执行命令
!npm test
请分析测试结果
```

---

### 第 2 天：会话管理（卡片 5-6）
- 理解 Session 结构
- 学会使用 /fork
- 理解 Compaction

**练习：**
```bash
# 1. 创建 Session
/new
/name my-project

# 2. 进行对话
请帮我设计一个用户认证系统

# 3. 创建分支
/tree
[选择历史节点]
/fork
/name experiment

# 4. 查看文件
ls ~/.pi/sessions/
cat ~/.pi/sessions/my-project.jsonl
```

---

### 第 3 天：高级功能（卡片 7-10）
- 理解工具调用流程
- 掌握模型切换
- 学习 Extension 开发
- 理解极简哲学

**练习：**
```bash
# 1. 配置 Scoped models
/scoped-models claude-opus-4 claude-sonnet-4 claude-haiku-4

# 2. 循环切换
Ctrl+P  # 切换到下一个模型

# 3. 创建简单 Extension
mkdir -p .pi/extensions
cat > .pi/extensions/hello.ts << 'EOF'
import { Extension } from '@mariozechner/pi-agent-core';
export default class Hello extends Extension {
  async onLoad() {
    this.registerTool('hello', async () => 'Hello, World!');
  }
}
EOF

# 4. 重载 Extension
/reload
```

---

## 记忆技巧

### 技巧 1：命令分类记忆

```
认证（Auth）：/login /logout
模型（Model）：/model /scoped-models
会话（Session）：/new /tree /fork /compact
系统（System）：/settings /reload /export
```

---

### 技巧 2：快捷键记忆

```
Ctrl+L：L = LLM = 切换模型
Ctrl+C：C = Clear = 清空编辑器
Ctrl+O：O = Output = 折叠输出
Ctrl+P：P = Previous/Next = 循环模型
```

---

### 技巧 3：符号记忆

```
@：引用文件（@ = at = 在某个文件）
!：执行命令（! = 感叹号 = 执行）
!!：只执行不发送（!! = 双重感叹号 = 静默执行）
/：命令前缀（/ = 斜杠 = 命令）
```

---

### 技巧 4：类比记忆

```
Session = Git 分支
JSONL = 日记本
Compaction = 整理笔记
Extension = npm 包
Tool = REST API
```

---

## 常见错误与纠正

### 错误 1：认为 /fork 会创建新文件

**错误理解：**
```bash
/fork  # 创建新的 Session 文件
```

**正确理解：**
```bash
/fork  # 在同一个 JSONL 文件中创建新分支
```

---

### 错误 2：认为 Compaction 会删除历史

**错误理解：**
```bash
/compact  # 删除旧消息
```

**正确理解：**
```bash
/compact  # 添加摘要标记，保留所有原始消息
```

---

### 错误 3：修改 Extension 后重启 pi

**错误做法：**
```bash
# 修改 Extension
/quit
pi
```

**正确做法：**
```bash
# 修改 Extension
/reload  # 热重载，无需重启
```

---

## 进阶学习建议

### 1. 深入源码

```bash
# 克隆仓库
git clone https://github.com/badlogic/pi-mono.git
cd pi-mono

# 阅读核心代码
cat packages/pi-ai/src/index.ts
cat packages/pi-agent-core/src/agent.ts
cat packages/coding-agent/src/main.ts
```

---

### 2. 实践项目

```typescript
// 项目 1：自定义工具
// 创建一个代码质量分析工具

// 项目 2：多 Agent 协作
// 使用 pi-messenger 实现多 Agent 协作

// 项目 3：生产环境集成
// 将 Pi 集成到 Slack Bot
```

---

### 3. 社区参与

```bash
# GitHub Issues
https://github.com/badlogic/pi-mono/issues

# Discord 社区
https://discord.gg/pi-mono

# X/Twitter
https://x.com/search?q=pi-mono
```

---

## 总结

**10 个卡片覆盖了 Pi 交互模式的核心要点：**

1. ✅ 界面布局（3 区域）
2. ✅ 命令分类（4 类 15 个）
3. ✅ @文件引用（3 种用法）
4. ✅ !命令执行（2 种模式）
5. ✅ Session 结构（单文件树形）
6. ✅ Compaction（不删除历史）
7. ✅ 工具调用（5 步异步流程）
8. ✅ 模型切换（3 种方式）
9. ✅ 热重载（/reload）
10. ✅ 极简哲学（核心 + 扩展）

**掌握这 10 个卡片，你就能高效使用 Pi 进行日常 AI 编码协作！**

---

**来源：**
- [Pi Coding Agent README](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/README.md) - 2026-02
- [Commands 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/README.md#commands) - 2026-02
- [Keybindings 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/keybindings.md) - 2026-02
- [Sessions 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/sessions.md) - 2026-02
- [Extensions 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md) - 2026-02
