# 化骨绵掌

> 10个2分钟知识卡片，快速掌握 Docker 部署 Milvus 的核心知识

---

## 卡片1：容器化的本质

**一句话：** 容器是进程级别的隔离，不是虚拟机

**核心概念：**
- 容器共享宿主机内核，只隔离进程、文件系统、网络
- 启动速度快（秒级），资源占用小
- 性能损失 <2%，几乎可以忽略

**代码示例：**
```bash
# 查看容器进程
docker-compose exec milvus ps aux

# 在宿主机上也能看到这些进程
ps aux | grep milvus
```

**应用：** 在 RAG 开发中，使用 Docker 部署 Milvus 不会影响向量检索性能，可以放心使用。

---

## 卡片2：Docker Compose 的声明式配置

**一句话：** 描述"想要什么"，而非"如何做"

**核心概念：**
```yaml
# 声明式：描述最终状态
services:
  milvus:
    image: milvusdb/milvus:v2.4.0
    ports:
      - "19530:19530"

# 命令式：描述操作步骤
# docker pull milvusdb/milvus:v2.4.0
# docker run -p 19530:19530 ...
```

**优势：**
- 配置即文档，易于理解
- 可重复执行，幂等性
- 易于版本控制

**应用：** 将 docker-compose.yml 提交到 Git，团队成员可以一键启动相同的环境。

---

## 卡片3：Named Volumes vs Bind Mounts

**一句话：** 生产用 Named Volumes，开发用 Bind Mounts

**对比：**

| 特性 | Named Volumes | Bind Mounts |
|------|--------------|-------------|
| 管理 | Docker 管理 | 手动管理 |
| 路径 | Docker 决定 | 用户指定 |
| 跨平台 | ✅ 兼容 | ❌ 路径不同 |
| 性能 | ✅ 优化 | ⚠️ 依赖文件系统 |
| 适用 | 生产环境 | 开发环境 |

**代码示例：**
```yaml
# Named Volume（推荐生产）
volumes:
  - milvus_data:/var/lib/milvus

# Bind Mount（推荐开发）
volumes:
  - ./data:/var/lib/milvus
```

**应用：** 开发时使用 Bind Mount 方便查看数据，生产时使用 Named Volume 保证性能和可移植性。

---

## 卡片4：健康检查的重要性

**一句话：** 容器启动 ≠ 服务就绪

**问题：**
```yaml
# 错误配置：只检查依赖启动
depends_on:
  - etcd

# Milvus 可能在 etcd 未就绪时启动，导致失败
```

**正确配置：**
```yaml
etcd:
  healthcheck:
    test: ["CMD", "etcdctl", "endpoint", "health"]
    interval: 30s

milvus:
  depends_on:
    etcd:
      condition: service_healthy  # 等待健康检查通过
```

**应用：** 在 RAG 系统的 CI/CD 流程中，使用健康检查确保测试在 Milvus 完全就绪后才开始。

---

## 卡片5：容器网络的服务发现

**一句话：** 容器间通过服务名通信，无需 IP

**原理：**
```
Milvus 容器内部：
1. 解析 "etcd" → Docker DNS
2. Docker DNS 返回 etcd 容器的 IP
3. Milvus 连接到 etcd
```

**代码示例：**
```yaml
services:
  milvus:
    environment:
      ETCD_ENDPOINTS: etcd:2379  # 使用服务名
      MINIO_ADDRESS: minio:9000
```

**验证：**
```bash
# 进入 Milvus 容器
docker-compose exec milvus bash

# 测试连接
ping etcd
curl http://minio:9000
```

**应用：** 在 RAG 系统中，多个服务（API、Milvus、Redis）可以通过服务名互相访问，无需硬编码 IP。

---

## 卡片6：单机 vs 分布式的选择

**一句话：** 根据数据规模和 QPS 选择部署模式

**决策树：**
```
数据量 < 100万 && QPS < 1000
    ↓
单机模式（3个容器）
    - 部署简单
    - 资源占用小（2-4GB）
    - 适合开发和小规模生产

数据量 > 1000万 || QPS > 1000
    ↓
分布式模式（10+个容器）
    - 可水平扩展
    - 高可用
    - 适合大规模生产
```

**迁移路径：**
```
开发 → 测试 → 小规模生产（单机）→ 大规模生产（分布式）
```

**应用：** RAG 系统初期使用单机模式快速验证，业务增长后迁移到分布式模式。

---

## 卡片7：资源限制的必要性

**一句话：** 防止单个容器占用过多资源

**问题场景：**
```
Milvus 容器占用 30GB 内存
    ↓
宿主机内存不足
    ↓
其他服务被 OOM Killer 杀死
```

**解决方案：**
```yaml
services:
  milvus:
    deploy:
      resources:
        limits:
          cpus: '4'      # 最多 4 核
          memory: 8G     # 最多 8GB
        reservations:
          cpus: '2'      # 保证 2 核
          memory: 4G     # 保证 4GB
```

**监控：**
```bash
# 查看资源使用
docker stats milvus
```

**应用：** 在共享服务器上运行多个 RAG 项目时，使用资源限制防止互相影响。

---

## 卡片8：日志管理策略

**一句话：** 配置日志轮转，防止磁盘被占满

**问题：**
```
Milvus 日志不断增长
    ↓
几个月后日志文件 100GB+
    ↓
磁盘空间不足
```

**解决方案：**
```yaml
services:
  milvus:
    logging:
      driver: "json-file"
      options:
        max-size: "100m"    # 单个日志文件最大 100MB
        max-file: "3"       # 保留最近 3 个文件
```

**查看日志：**
```bash
# 查看最近 100 行
docker-compose logs --tail=100 milvus

# 实时查看
docker-compose logs -f milvus

# 查看特定时间段
docker-compose logs --since 2024-01-01 milvus
```

**应用：** 在生产环境中，配置日志轮转并定期归档到远程存储（如 S3）。

---

## 卡片9：备份的三个层次

**一句话：** 备份元数据、向量数据和配置文件

**三层备份：**
```
1. etcd（元数据）
   - Collection schema
   - 索引信息
   - 分区信息

2. MinIO（向量数据）
   - 原始向量
   - 索引文件
   - 日志文件

3. 配置文件
   - docker-compose.yml
   - milvus.yaml
   - .env
```

**备份脚本：**
```bash
# 备份所有 volumes
for volume in etcd_data minio_data milvus_data; do
  docker run --rm \
    -v $volume:/data \
    -v $(pwd)/backup:/backup \
    ubuntu tar czf /backup/$volume.tar.gz /data
done
```

**验证：**
```bash
# 定期测试恢复流程
# 1. 在测试环境恢复备份
# 2. 验证数据完整性
# 3. 记录恢复时间
```

**应用：** RAG 系统每天凌晨自动备份，保留最近 7 天的备份，每周备份到远程存储。

---

## 卡片10：从单机到分布式的迁移

**一句话：** 导出数据 → 重建 Collection → 导入数据

**迁移步骤：**
```python
# 1. 从单机 Milvus 导出数据
connections.connect("source", host="old-server", port="19530")
collection = Collection("rag_documents")
data = collection.query(expr="", output_fields=["*"])

# 2. 保存到文件
import json
with open("export.json", "w") as f:
    json.dump(data, f)

# 3. 在分布式 Milvus 中重建 Collection
connections.connect("target", host="new-server", port="19530")
# 创建相同的 schema

# 4. 导入数据
new_collection = Collection("rag_documents")
new_collection.insert(data)
new_collection.flush()

# 5. 重建索引
new_collection.create_index(...)
new_collection.load()
```

**注意事项：**
- 停机迁移：停止写入，确保数据一致性
- 增量迁移：先迁移历史数据，再同步增量
- 验证数据：迁移后验证数据完整性

**应用：** RAG 系统从单机迁移到分布式时，选择业务低峰期（凌晨）进行迁移，预计停机时间 2-4 小时。

---

## 知识卡片总结

### 核心要点

1. **容器化本质**：进程隔离，不是虚拟机
2. **声明式配置**：描述最终状态，易于管理
3. **数据持久化**：Named Volumes 独立于容器
4. **健康检查**：确保服务真正就绪
5. **服务发现**：通过服务名通信
6. **部署模式**：根据规模选择单机或分布式
7. **资源限制**：防止资源滥用
8. **日志管理**：配置轮转，防止磁盘占满
9. **备份策略**：三层备份，定期测试恢复
10. **迁移方案**：导出导入，验证数据

### 学习路径

```
基础概念（卡片1-2）
    ↓
数据管理（卡片3、9）
    ↓
服务配置（卡片4-5、7-8）
    ↓
架构选择（卡片6、10）
```

### 实践建议

**开发环境：**
- 使用单机模式
- Bind Mount 方便调试
- 不配置资源限制

**生产环境：**
- 根据规模选择模式
- Named Volumes 持久化
- 配置资源限制和日志轮转
- 定期备份和监控

### 常见问题速查

**Q1: 容器删除后数据会丢失吗？**
A: 不会，数据在 Volume 中，独立于容器生命周期。

**Q2: Docker 部署会影响性能吗？**
A: 性能损失 <2%，几乎可以忽略。

**Q3: 单机模式是一个容器吗？**
A: 不是，至少 3 个容器（Milvus + etcd + MinIO）。

**Q4: 如何扩展 Worker 节点？**
A: 使用 `docker-compose up -d --scale querynode=4`

**Q5: 如何备份数据？**
A: 备份 etcd、MinIO、Milvus 三个 volumes。

**Q6: 如何监控 Milvus？**
A: 使用 Prometheus 采集 9091 端口的 metrics。

**Q7: 如何从单机迁移到分布式？**
A: 导出数据 → 重建 Collection → 导入数据。

**Q8: 端口被占用怎么办？**
A: 修改 docker-compose.yml 中的端口映射。

**Q9: 如何查看日志？**
A: `docker-compose logs -f milvus`

**Q10: 如何进入容器调试？**
A: `docker-compose exec milvus bash`

---

## 快速参考卡

### 常用命令

```bash
# 启动服务
docker-compose up -d

# 停止服务
docker-compose stop

# 查看状态
docker-compose ps

# 查看日志
docker-compose logs -f milvus

# 重启服务
docker-compose restart milvus

# 扩展节点
docker-compose up -d --scale querynode=4

# 进入容器
docker-compose exec milvus bash

# 备份数据
docker run --rm -v milvus_data:/data -v $(pwd):/backup ubuntu tar czf /backup/milvus.tar.gz /data

# 查看资源
docker stats milvus
```

### 配置模板

```yaml
# 最小配置
version: '3.8'
services:
  etcd:
    image: quay.io/coreos/etcd:v3.5.5
    volumes:
      - etcd_data:/etcd
  minio:
    image: minio/minio:RELEASE.2023-03-20T20-16-18Z
    volumes:
      - minio_data:/minio_data
  milvus:
    image: milvusdb/milvus:v2.4.0
    command: ["milvus", "run", "standalone"]
    ports:
      - "19530:19530"
    volumes:
      - milvus_data:/var/lib/milvus
    depends_on:
      - etcd
      - minio
volumes:
  etcd_data:
  minio_data:
  milvus_data:
```

### Python 连接

```python
from pymilvus import connections, Collection

# 连接
connections.connect(host="localhost", port="19530")

# 获取 Collection
collection = Collection("my_collection")

# 检索
results = collection.search(
    data=[embedding],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10
)
```

---

## 学习检查清单

完成化骨绵掌学习后，你应该能够：

- [ ] 理解容器和虚拟机的区别
- [ ] 编写 docker-compose.yml 配置文件
- [ ] 配置 Named Volumes 和 Bind Mounts
- [ ] 配置健康检查和依赖关系
- [ ] 理解容器网络和服务发现
- [ ] 选择合适的部署模式（单机 vs 分布式）
- [ ] 配置资源限制和日志管理
- [ ] 实施备份和恢复策略
- [ ] 监控 Milvus 的运行状态
- [ ] 从单机迁移到分布式

如果以上都能做到，恭喜你已经掌握了 Docker 部署 Milvus 的核心知识！🎉

---

## 下一步学习

完成 Docker 部署后，建议学习：

1. **L5_生产实践/02_监控与健康检查**
   - Prometheus 配置
   - Grafana 可视化
   - 告警规则

2. **L5_生产实践/03_备份与恢复**
   - 自动化备份脚本
   - 灾难恢复流程
   - 数据迁移策略

3. **L5_生产实践/04_Kubernetes部署**
   - Helm Charts
   - Operator
   - 自动扩缩容

4. **L5_生产实践/05_安全与权限管理**
   - 访问控制
   - 数据加密
   - 网络安全

5. **L5_生产实践/06_高可用集群**
   - 多副本配置
   - 故障转移
   - 负载均衡
