# 核心概念 03：工具注册系统

> 深入理解 Agent Core 如何注册、管理和验证工具

---

## 概念定义

**工具注册系统**是指 Agent Core 管理可用工具的机制，包括工具定义、Schema 验证、名称映射和执行函数注册。

**一句话：** 工具注册系统就是 Agent 的"工具箱管理系统"，定义了有哪些工具、如何使用、如何验证。

---

## 工具注册的核心组件

### 1. 工具定义结构

**Tool 接口：**

```typescript
interface Tool {
  // 工具名称（唯一标识）
  name: string;

  // 工具描述（给 LLM 看的）
  description: string;

  // 参数 Schema（TypeBox 定义）
  schema: TObject;

  // 执行函数
  execute: (params: any) => Promise<ToolResult>;
}

interface ToolResult {
  // 返回给 LLM 的内容（简洁）
  output: string;

  // 返回给 UI 的详细信息（丰富）
  details?: any;
}
```

---

### 2. TypeBox Schema 定义

**Pi-mono 使用 TypeBox（不是 Zod）：**

```typescript
import { Type, Static } from '@sinclair/typebox';

// 定义 Read 工具的 Schema
const ReadSchema = Type.Object({
  path: Type.String({
    description: 'File path to read'
  }),
  lines: Type.Optional(Type.Object({
    start: Type.Number({ description: 'Start line number' }),
    end: Type.Number({ description: 'End line number' })
  }))
});

// 类型推导
type ReadParams = Static<typeof ReadSchema>;
// 等价于：
// type ReadParams = {
//   path: string;
//   lines?: { start: number; end: number };
// }
```

**为什么用 TypeBox 而不是 Zod？**

```typescript
// TypeBox：运行时验证更快
import { Type } from '@sinclair/typebox';
const schema = Type.Object({ path: Type.String() });
// 优点：轻量、快速、JSON Schema 标准

// Zod：类型推导更强
import { z } from 'zod';
const schema = z.object({ path: z.string() });
// 优点：开发体验好、类型推导强大
```

**Pi-mono 选择 TypeBox 的原因：**
- 更轻量（包体积小）
- 运行时验证更快
- 直接生成 JSON Schema（LLM API 需要）
- 符合极简哲学

---

### 3. AJV 验证器

**使用 AJV 进行参数验证：**

```typescript
import Ajv from 'ajv';

// 创建 AJV 实例
const ajv = new Ajv({
  allErrors: true,      // 返回所有错误
  coerceTypes: false,   // 不自动类型转换
  useDefaults: true     // 使用默认值
});

// 编译 Schema
const validate = ajv.compile(ReadSchema);

// 验证参数
const params = { path: 'hello.ts' };
if (validate(params)) {
  console.log('Valid!');
} else {
  console.log('Errors:', validate.errors);
}
```

**验证错误示例：**

```typescript
// 错误的参数
const params = { file: 'hello.ts' };  // 应该是 path，不是 file

validate(params);
console.log(validate.errors);
// [
//   {
//     instancePath: '',
//     schemaPath: '#/required',
//     keyword: 'required',
//     params: { missingProperty: 'path' },
//     message: "must have required property 'path'"
//   },
//   {
//     instancePath: '',
//     schemaPath: '#/additionalProperties',
//     keyword: 'additionalProperties',
//     params: { additionalProperty: 'file' },
//     message: 'must NOT have additional properties'
//   }
// ]
```

---

## Pi-mono 的 4 个核心工具

### 1. Read 工具

**完整定义：**

```typescript
const readTool: Tool = {
  name: 'read',
  description: 'Read file contents. Optionally specify line range.',

  schema: Type.Object({
    path: Type.String({
      description: 'File path to read (relative or absolute)'
    }),
    lines: Type.Optional(Type.Object({
      start: Type.Number({ description: 'Start line (1-indexed)' }),
      end: Type.Number({ description: 'End line (inclusive)' })
    }))
  }),

  execute: async (params) => {
    try {
      // 读取文件
      let content = await fs.readFile(params.path, 'utf-8');

      // 如果指定了行范围
      if (params.lines) {
        const lines = content.split('\n');
        const { start, end } = params.lines;
        content = lines.slice(start - 1, end).join('\n');
      }

      return {
        output: `File content:\n${content}`,
        details: {
          path: params.path,
          size: content.length,
          lines: content.split('\n').length,
          encoding: 'utf-8'
        }
      };
    } catch (error) {
      return {
        output: `Error: ${error.message}`,
        details: { error: error.stack }
      };
    }
  }
};
```

---

### 2. Write 工具

**完整定义：**

```typescript
const writeTool: Tool = {
  name: 'write',
  description: 'Write or overwrite file with content.',

  schema: Type.Object({
    path: Type.String({
      description: 'File path to write'
    }),
    content: Type.String({
      description: 'Content to write to file'
    })
  }),

  execute: async (params) => {
    try {
      // 确保目录存在
      const dir = path.dirname(params.path);
      await fs.mkdir(dir, { recursive: true });

      // 写入文件
      await fs.writeFile(params.path, params.content, 'utf-8');

      return {
        output: `File written: ${params.path}`,
        details: {
          path: params.path,
          bytes: Buffer.byteLength(params.content, 'utf-8'),
          lines: params.content.split('\n').length
        }
      };
    } catch (error) {
      return {
        output: `Error: ${error.message}`,
        details: { error: error.stack }
      };
    }
  }
};
```

---

### 3. Edit 工具

**完整定义：**

```typescript
const editTool: Tool = {
  name: 'edit',
  description: 'Edit file by replacing old text with new text.',

  schema: Type.Object({
    path: Type.String({
      description: 'File path to edit'
    }),
    oldText: Type.String({
      description: 'Text to search for (must match exactly)'
    }),
    newText: Type.String({
      description: 'Text to replace with'
    })
  }),

  execute: async (params) => {
    try {
      // 读取文件
      let content = await fs.readFile(params.path, 'utf-8');

      // 检查是否存在 oldText
      if (!content.includes(params.oldText)) {
        return {
          output: `Error: Text not found in file: "${params.oldText}"`,
          details: { found: false }
        };
      }

      // 替换
      const newContent = content.replace(params.oldText, params.newText);

      // 写回文件
      await fs.writeFile(params.path, newContent, 'utf-8');

      return {
        output: `File edited: ${params.path}`,
        details: {
          path: params.path,
          oldLength: content.length,
          newLength: newContent.length,
          replaced: true
        }
      };
    } catch (error) {
      return {
        output: `Error: ${error.message}`,
        details: { error: error.stack }
      };
    }
  }
};
```

---

### 4. Bash 工具

**完整定义：**

```typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

const bashTool: Tool = {
  name: 'bash',
  description: 'Execute bash command. Use for git, npm, testing, etc.',

  schema: Type.Object({
    command: Type.String({
      description: 'Bash command to execute'
    })
  }),

  execute: async (params) => {
    try {
      const { stdout, stderr } = await execAsync(params.command, {
        timeout: 30000,  // 30 秒超时
        maxBuffer: 10 * 1024 * 1024  // 10MB 输出限制
      });

      return {
        output: stdout || stderr || 'Command executed successfully',
        details: {
          command: params.command,
          stdout,
          stderr,
          exitCode: 0
        }
      };
    } catch (error) {
      return {
        output: `Error: ${error.message}\n${error.stderr || ''}`,
        details: {
          command: params.command,
          error: error.message,
          exitCode: error.code || 1
        }
      };
    }
  }
};
```

---

## 工具注册表实现

### ToolRegistry 类

```typescript
class ToolRegistry {
  private tools = new Map<string, Tool>();
  private validators = new Map<string, ValidateFunction>();
  private ajv = new Ajv({ allErrors: true });

  // 注册工具
  register(tool: Tool): void {
    // 1. 存储工具定义
    this.tools.set(tool.name, tool);

    // 2. 编译 Schema 验证器
    const validator = this.ajv.compile(tool.schema);
    this.validators.set(tool.name, validator);

    console.log(`Tool registered: ${tool.name}`);
  }

  // 获取工具
  get(name: string): Tool | undefined {
    return this.tools.get(name);
  }

  // 获取验证器
  getValidator(name: string): ValidateFunction | undefined {
    return this.validators.get(name);
  }

  // 获取所有工具定义（给 LLM）
  getToolDefinitions(): ToolDefinition[] {
    return Array.from(this.tools.values()).map(tool => ({
      name: tool.name,
      description: tool.description,
      parameters: tool.schema
    }));
  }

  // 验证工具调用
  validate(name: string, params: any): ValidationResult {
    const validator = this.validators.get(name);
    if (!validator) {
      return {
        valid: false,
        errors: [`Tool not found: ${name}`]
      };
    }

    if (validator(params)) {
      return { valid: true };
    } else {
      return {
        valid: false,
        errors: validator.errors?.map(e => e.message) || []
      };
    }
  }

  // 执行工具
  async execute(name: string, params: any): Promise<ToolResult> {
    // 1. 验证参数
    const validation = this.validate(name, params);
    if (!validation.valid) {
      return {
        output: `Error: Invalid parameters\n${validation.errors.join('\n')}`,
        details: { validationErrors: validation.errors }
      };
    }

    // 2. 获取工具
    const tool = this.tools.get(name);
    if (!tool) {
      return {
        output: `Error: Tool not found: ${name}`,
        details: { error: 'Tool not found' }
      };
    }

    // 3. 执行工具
    try {
      return await tool.execute(params);
    } catch (error) {
      return {
        output: `Error: ${error.message}`,
        details: { error: error.stack }
      };
    }
  }
}
```

---

### 使用示例

```typescript
// 创建工具注册表
const registry = new ToolRegistry();

// 注册 4 个核心工具
registry.register(readTool);
registry.register(writeTool);
registry.register(editTool);
registry.register(bashTool);

// 获取工具定义（给 LLM）
const toolDefinitions = registry.getToolDefinitions();
console.log(toolDefinitions);
// [
//   { name: 'read', description: '...', parameters: {...} },
//   { name: 'write', description: '...', parameters: {...} },
//   { name: 'edit', description: '...', parameters: {...} },
//   { name: 'bash', description: '...', parameters: {...} }
// ]

// 验证工具调用
const validation = registry.validate('read', { path: 'hello.ts' });
console.log(validation);  // { valid: true }

// 执行工具
const result = await registry.execute('read', { path: 'hello.ts' });
console.log(result.output);  // File content: ...
```

---

## 自定义工具注册

### 添加自定义工具

```typescript
// 定义自定义工具：查询数据库
const queryDbTool: Tool = {
  name: 'query_db',
  description: 'Query database with SQL',

  schema: Type.Object({
    sql: Type.String({ description: 'SQL query to execute' }),
    database: Type.Optional(Type.String({ description: 'Database name' }))
  }),

  execute: async (params) => {
    try {
      const db = await connectDatabase(params.database || 'default');
      const rows = await db.query(params.sql);

      return {
        output: `Query returned ${rows.length} rows`,
        details: {
          sql: params.sql,
          rows,
          count: rows.length
        }
      };
    } catch (error) {
      return {
        output: `Error: ${error.message}`,
        details: { error: error.stack }
      };
    }
  }
};

// 注册自定义工具
registry.register(queryDbTool);

// 现在 Agent 可以使用 5 个工具了
// read, write, edit, bash, query_db
```

---

### 动态注册工具

```typescript
// 运行时动态注册工具
class Agent {
  private registry: ToolRegistry;

  constructor() {
    this.registry = new ToolRegistry();
    // 注册核心工具
    this.registerCoreTools();
  }

  // 注册核心工具
  private registerCoreTools() {
    this.registry.register(readTool);
    this.registry.register(writeTool);
    this.registry.register(editTool);
    this.registry.register(bashTool);
  }

  // 公开方法：注册自定义工具
  registerTool(tool: Tool) {
    this.registry.register(tool);
  }

  // 公开方法：注销工具
  unregisterTool(name: string) {
    this.registry.tools.delete(name);
    this.registry.validators.delete(name);
  }
}

// 使用
const agent = new Agent();

// 添加自定义工具
agent.registerTool(queryDbTool);
agent.registerTool(plotChartTool);

// 移除工具
agent.unregisterTool('query_db');
```

---

## 工具定义的最佳实践

### 1. 清晰的描述

```typescript
// ✅ 好的描述
description: 'Read file contents. Optionally specify line range.'

// ❌ 差的描述
description: 'Read file'
```

---

### 2. 详细的参数说明

```typescript
// ✅ 好的参数定义
schema: Type.Object({
  path: Type.String({
    description: 'File path to read (relative or absolute)'
  }),
  lines: Type.Optional(Type.Object({
    start: Type.Number({ description: 'Start line (1-indexed)' }),
    end: Type.Number({ description: 'End line (inclusive)' })
  }))
})

// ❌ 差的参数定义
schema: Type.Object({
  path: Type.String(),  // 没有描述
  lines: Type.Optional(Type.Object({
    start: Type.Number(),
    end: Type.Number()
  }))
})
```

---

### 3. 合理的默认值

```typescript
// ✅ 使用默认值
schema: Type.Object({
  database: Type.String({ default: 'default' }),
  timeout: Type.Number({ default: 30000 })
})

// 执行时自动填充默认值
const params = { sql: 'SELECT * FROM users' };
// 自动变成：{ sql: '...', database: 'default', timeout: 30000 }
```

---

### 4. 输出结构一致

```typescript
// ✅ 一致的输出结构
return {
  output: '给 LLM 的简洁信息',
  details: {
    // 给 UI 的详细信息
  }
};

// ❌ 不一致的输出
return '直接返回字符串';  // 缺少 details
```

---

## 工具注册的性能优化

### 1. Schema 预编译

```typescript
// ✅ 初始化时编译
const validator = ajv.compile(schema);  // 编译一次
this.validators.set(name, validator);

// 运行时直接使用
if (validator(params)) {  // 快速验证
  // ...
}

// ❌ 每次都编译
const validator = ajv.compile(schema);  // 每次都编译，慢
if (validator(params)) {
  // ...
}
```

---

### 2. 工具定义缓存

```typescript
class ToolRegistry {
  private toolDefinitionsCache: ToolDefinition[] | null = null;

  getToolDefinitions(): ToolDefinition[] {
    // 缓存工具定义
    if (!this.toolDefinitionsCache) {
      this.toolDefinitionsCache = Array.from(this.tools.values()).map(tool => ({
        name: tool.name,
        description: tool.description,
        parameters: tool.schema
      }));
    }
    return this.toolDefinitionsCache;
  }

  register(tool: Tool): void {
    this.tools.set(tool.name, tool);
    // 清除缓存
    this.toolDefinitionsCache = null;
  }
}
```

---

### 3. 懒加载工具

```typescript
class ToolRegistry {
  private lazyTools = new Map<string, () => Tool>();

  // 注册懒加载工具
  registerLazy(name: string, loader: () => Tool): void {
    this.lazyTools.set(name, loader);
  }

  // 获取工具（懒加载）
  get(name: string): Tool | undefined {
    // 先检查已加载的工具
    if (this.tools.has(name)) {
      return this.tools.get(name);
    }

    // 懒加载
    const loader = this.lazyTools.get(name);
    if (loader) {
      const tool = loader();
      this.register(tool);
      return tool;
    }

    return undefined;
  }
}

// 使用
registry.registerLazy('heavy_tool', () => {
  // 只在需要时加载
  return require('./heavy-tool').default;
});
```

---

## 实际应用场景

### 场景 1：Coding Agent（仅 4 个工具）

```typescript
const codingAgent = new Agent();
// 默认已注册 read, write, edit, bash
// 无需额外工具
```

---

### 场景 2：数据分析 Agent（+2 个工具）

```typescript
const dataAgent = new Agent();
// 核心工具：read, write, edit, bash
// 自定义工具：
dataAgent.registerTool(queryDbTool);
dataAgent.registerTool(plotChartTool);
// 总共 6 个工具
```

---

### 场景 3：Slack Bot Agent（+2 个工具）

```typescript
const slackAgent = new Agent();
// 核心工具：read, write, edit, bash
// 自定义工具：
slackAgent.registerTool(sendMessageTool);
slackAgent.registerTool(readChannelTool);
// 总共 6 个工具
```

---

## 总结

**工具注册系统的核心要点：**

1. **Tool 结构**：name + description + schema + execute
2. **TypeBox Schema**：轻量、快速、JSON Schema 标准
3. **AJV 验证**：预编译、快速验证、详细错误
4. **4 个核心工具**：read + write + edit + bash
5. **动态注册**：运行时添加/移除工具
6. **输出结构**：output（LLM）+ details（UI）

**关键洞察：**
- 工具注册系统是 Agent 的"工具箱"
- TypeBox + AJV 提供快速验证
- 4 个核心工具 + 按需扩展 = 极简哲学
- 清晰的描述和参数说明帮助 LLM 正确使用工具

**下一步：** 理解工具注册后，学习工具执行流程（核心概念 04）。
