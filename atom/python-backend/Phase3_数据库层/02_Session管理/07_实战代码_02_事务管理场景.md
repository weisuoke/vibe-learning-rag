# 【实战代码2】事务管理场景

> 手动事务、嵌套事务、异常回滚的完整示例

---

## 场景1：手动事务管理

### 完整代码

```python
# database.py
from sqlalchemy import create_engine, Column, Integer, String, Float
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "postgresql://user:password@localhost:5432/mydb"
engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()


class Account(Base):
    """银行账户模型"""
    __tablename__ = "accounts"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    balance = Column(Float, default=0.0)

    def __repr__(self):
        return f"<Account(id={self.id}, name={self.name}, balance={self.balance})>"


Base.metadata.create_all(bind=engine)


def transfer_money(from_account_id: int, to_account_id: int, amount: float):
    """转账操作（手动事务管理）"""
    session = SessionLocal()
    try:
        # 查询账户
        from_account = session.query(Account).filter_by(id=from_account_id).first()
        to_account = session.query(Account).filter_by(id=to_account_id).first()

        if not from_account or not to_account:
            raise ValueError("Account not found")

        # 检查余额
        if from_account.balance < amount:
            raise ValueError("Insufficient balance")

        # 扣款
        from_account.balance -= amount
        print(f"Deducted {amount} from {from_account.name}")

        # 存款
        to_account.balance += amount
        print(f"Added {amount} to {to_account.name}")

        # 提交事务
        session.commit()
        print("Transaction committed successfully")

        return True

    except Exception as e:
        # 回滚事务
        session.rollback()
        print(f"Transaction rolled back: {e}")
        return False

    finally:
        # 关闭 Session
        session.close()


def transfer_money_with_context(from_account_id: int, to_account_id: int, amount: float):
    """转账操作（使用上下文管理器）"""
    with SessionLocal() as session:
        try:
            from_account = session.query(Account).filter_by(id=from_account_id).first()
            to_account = session.query(Account).filter_by(id=to_account_id).first()

            if not from_account or not to_account:
                raise ValueError("Account not found")

            if from_account.balance < amount:
                raise ValueError("Insufficient balance")

            from_account.balance -= amount
            to_account.balance += amount

            session.commit()
            print("Transaction committed successfully")
            return True

        except Exception as e:
            session.rollback()
            print(f"Transaction rolled back: {e}")
            return False


# 测试
if __name__ == "__main__":
    # 创建测试账户
    with SessionLocal() as session:
        alice = Account(name="Alice", balance=1000.0)
        bob = Account(name="Bob", balance=500.0)
        session.add_all([alice, bob])
        session.commit()

    # 成功转账
    print("\n=== 成功转账 ===")
    transfer_money(1, 2, 100.0)

    # 余额不足
    print("\n=== 余额不足 ===")
    transfer_money(2, 1, 1000.0)

    # 查看最终余额
    with SessionLocal() as session:
        accounts = session.query(Account).all()
        for account in accounts:
            print(account)
```

### 运行结果

```
=== 成功转账 ===
Deducted 100.0 from Alice
Added 100.0 to Bob
Transaction committed successfully

=== 余额不足 ===
Transaction rolled back: Insufficient balance

<Account(id=1, name=Alice, balance=900.0)>
<Account(id=2, name=Bob, balance=600.0)>
```

---

## 场景2：嵌套事务（Savepoint）

### 完整代码

```python
# database.py
from sqlalchemy import create_engine, Column, Integer, String, Float, ForeignKey
from sqlalchemy.orm import sessionmaker, declarative_base, relationship

DATABASE_URL = "postgresql://user:password@localhost:5432/mydb"
engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()


class User(Base):
    """用户模型"""
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    balance = Column(Float, default=0.0)

    orders = relationship("Order", back_populates="user")

    def __repr__(self):
        return f"<User(id={self.id}, name={self.name}, balance={self.balance})>"


class Order(Base):
    """订单模型"""
    __tablename__ = "orders"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    amount = Column(Float, nullable=False)
    status = Column(String, default="pending")

    user = relationship("User", back_populates="orders")

    def __repr__(self):
        return f"<Order(id={self.id}, user_id={self.user_id}, amount={self.amount}, status={self.status})>"


Base.metadata.create_all(bind=engine)


def create_order_with_savepoint(user_id: int, amount: float):
    """创建订单（使用 Savepoint）"""
    with SessionLocal() as session:
        # 外层事务：创建用户
        user = session.query(User).filter_by(id=user_id).first()
        if not user:
            user = User(name=f"User{user_id}", balance=1000.0)
            session.add(user)
            session.flush()
            print(f"Created user: {user}")

        # 嵌套事务：创建订单
        try:
            with session.begin_nested():
                # 检查余额
                if user.balance < amount:
                    raise ValueError("Insufficient balance")

                # 扣款
                user.balance -= amount

                # 创建订单
                order = Order(user_id=user.id, amount=amount, status="completed")
                session.add(order)
                session.flush()

                print(f"Created order: {order}")
                print(f"Updated user balance: {user.balance}")

        except ValueError as e:
            # 嵌套事务回滚（只回滚订单）
            print(f"Order creation failed: {e}")
            print(f"User balance unchanged: {user.balance}")

        # 外层事务提交（用户仍然被保存）
        session.commit()
        print("Transaction committed")


def batch_create_orders_with_savepoint(orders_data: list[dict]):
    """批量创建订单（部分失败）"""
    with SessionLocal() as session:
        success_count = 0
        fail_count = 0

        for data in orders_data:
            try:
                with session.begin_nested():
                    user = session.query(User).filter_by(id=data["user_id"]).first()
                    if not user:
                        raise ValueError(f"User {data['user_id']} not found")

                    if user.balance < data["amount"]:
                        raise ValueError("Insufficient balance")

                    user.balance -= data["amount"]
                    order = Order(**data, status="completed")
                    session.add(order)
                    session.flush()

                    success_count += 1
                    print(f"✓ Order created: {order}")

            except Exception as e:
                fail_count += 1
                print(f"✗ Order failed: {e}")

        # 提交成功的订单
        session.commit()
        print(f"\nTotal: {len(orders_data)}, Success: {success_count}, Failed: {fail_count}")


# 测试
if __name__ == "__main__":
    # 测试1：成功创建订单
    print("\n=== 测试1：成功创建订单 ===")
    create_order_with_savepoint(1, 100.0)

    # 测试2：余额不足
    print("\n=== 测试2：余额不足 ===")
    create_order_with_savepoint(1, 2000.0)

    # 测试3：批量创建订单
    print("\n=== 测试3：批量创建订单 ===")
    orders_data = [
        {"user_id": 1, "amount": 50.0},
        {"user_id": 1, "amount": 5000.0},  # 余额不足
        {"user_id": 1, "amount": 30.0},
        {"user_id": 999, "amount": 10.0},  # 用户不存在
    ]
    batch_create_orders_with_savepoint(orders_data)
```

### 运行结果

```
=== 测试1：成功创建订单 ===
Created user: <User(id=1, name=User1, balance=1000.0)>
Created order: <Order(id=1, user_id=1, amount=100.0, status=completed)>
Updated user balance: 900.0
Transaction committed

=== 测试2：余额不足 ===
Order creation failed: Insufficient balance
User balance unchanged: 900.0
Transaction committed

=== 测试3：批量创建订单 ===
✓ Order created: <Order(id=2, user_id=1, amount=50.0, status=completed)>
✗ Order failed: Insufficient balance
✓ Order created: <Order(id=3, user_id=1, amount=30.0, status=completed)>
✗ Order failed: User 999 not found

Total: 4, Success: 2, Failed: 2
```

---

## 场景3：事务隔离级别

### 完整代码

```python
# database.py
from sqlalchemy import create_engine, Column, Integer, String, Float
from sqlalchemy.orm import sessionmaker, declarative_base
import threading
import time

DATABASE_URL = "postgresql://user:password@localhost:5432/mydb"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()


class Product(Base):
    """商品模型"""
    __tablename__ = "products"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    stock = Column(Integer, default=0)

    def __repr__(self):
        return f"<Product(id={self.id}, name={self.name}, stock={self.stock})>"


Base.metadata.create_all(bind=engine)


def demonstrate_read_committed():
    """演示 Read Committed 隔离级别"""
    print("\n=== Read Committed 隔离级别 ===")

    # 创建测试数据
    with SessionLocal() as session:
        product = Product(name="iPhone", stock=10)
        session.add(product)
        session.commit()

    def transaction1():
        with SessionLocal() as session:
            # 设置隔离级别
            session.connection(execution_options={"isolation_level": "READ COMMITTED"})

            # 第一次读取
            product = session.query(Product).filter_by(id=1).first()
            print(f"T1: First read - stock={product.stock}")

            # 等待事务2修改数据
            time.sleep(2)

            # 第二次读取（会看到事务2的修改）
            session.expire_all()
            product = session.query(Product).filter_by(id=1).first()
            print(f"T1: Second read - stock={product.stock}")

    def transaction2():
        time.sleep(1)
        with SessionLocal() as session:
            product = session.query(Product).filter_by(id=1).first()
            product.stock = 20
            session.commit()
            print(f"T2: Updated stock to 20")

    # 并发执行
    t1 = threading.Thread(target=transaction1)
    t2 = threading.Thread(target=transaction2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()


def demonstrate_repeatable_read():
    """演示 Repeatable Read 隔离级别"""
    print("\n=== Repeatable Read 隔离级别 ===")

    # 重置数据
    with SessionLocal() as session:
        product = session.query(Product).filter_by(id=1).first()
        product.stock = 10
        session.commit()

    def transaction1():
        with SessionLocal() as session:
            # 设置隔离级别
            session.connection(execution_options={"isolation_level": "REPEATABLE READ"})

            # 第一次读取
            product = session.query(Product).filter_by(id=1).first()
            print(f"T1: First read - stock={product.stock}")

            # 等待事务2修改数据
            time.sleep(2)

            # 第二次读取（不会看到事务2的修改）
            session.expire_all()
            product = session.query(Product).filter_by(id=1).first()
            print(f"T1: Second read - stock={product.stock}")

    def transaction2():
        time.sleep(1)
        with SessionLocal() as session:
            product = session.query(Product).filter_by(id=1).first()
            product.stock = 30
            session.commit()
            print(f"T2: Updated stock to 30")

    # 并发执行
    t1 = threading.Thread(target=transaction1)
    t2 = threading.Thread(target=transaction2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()


def demonstrate_serializable():
    """演示 Serializable 隔离级别"""
    print("\n=== Serializable 隔离级别 ===")

    # 重置数据
    with SessionLocal() as session:
        product = session.query(Product).filter_by(id=1).first()
        product.stock = 10
        session.commit()

    def transaction1():
        try:
            with SessionLocal() as session:
                session.connection(execution_options={"isolation_level": "SERIALIZABLE"})

                product = session.query(Product).filter_by(id=1).first()
                print(f"T1: Read stock={product.stock}")

                time.sleep(2)

                product.stock += 5
                session.commit()
                print(f"T1: Updated stock to {product.stock}")
        except Exception as e:
            print(f"T1: Failed - {e}")

    def transaction2():
        time.sleep(1)
        try:
            with SessionLocal() as session:
                session.connection(execution_options={"isolation_level": "SERIALIZABLE"})

                product = session.query(Product).filter_by(id=1).first()
                print(f"T2: Read stock={product.stock}")

                product.stock += 10
                session.commit()
                print(f"T2: Updated stock to {product.stock}")
        except Exception as e:
            print(f"T2: Failed - {e}")

    # 并发执行
    t1 = threading.Thread(target=transaction1)
    t2 = threading.Thread(target=transaction2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()


# 测试
if __name__ == "__main__":
    demonstrate_read_committed()
    time.sleep(1)
    demonstrate_repeatable_read()
    time.sleep(1)
    demonstrate_serializable()
```

### 运行结果

```
=== Read Committed 隔离级别 ===
T1: First read - stock=10
T2: Updated stock to 20
T1: Second read - stock=20

=== Repeatable Read 隔离级别 ===
T1: First read - stock=10
T2: Updated stock to 30
T1: Second read - stock=10

=== Serializable 隔离级别 ===
T1: Read stock=10
T2: Read stock=10
T2: Updated stock to 20
T1: Failed - could not serialize access due to concurrent update
```

---

## 场景4：乐观锁与悲观锁

### 完整代码

```python
# database.py
from sqlalchemy import create_engine, Column, Integer, String, Float
from sqlalchemy.orm import sessionmaker, declarative_base
import threading

DATABASE_URL = "postgresql://user:password@localhost:5432/mydb"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()


class Inventory(Base):
    """库存模型（乐观锁）"""
    __tablename__ = "inventory"

    id = Column(Integer, primary_key=True, index=True)
    product_name = Column(String, nullable=False)
    quantity = Column(Integer, default=0)
    version = Column(Integer, default=0)  # 版本号

    def __repr__(self):
        return f"<Inventory(id={self.id}, product={self.product_name}, quantity={self.quantity}, version={self.version})>"


Base.metadata.create_all(bind=engine)


def optimistic_lock_update(inventory_id: int, quantity_change: int):
    """使用乐观锁更新库存"""
    max_retries = 3
    for attempt in range(max_retries):
        with SessionLocal() as session:
            try:
                # 读取库存
                inventory = session.query(Inventory).filter_by(id=inventory_id).first()
                if not inventory:
                    raise ValueError("Inventory not found")

                original_version = inventory.version
                new_quantity = inventory.quantity + quantity_change

                if new_quantity < 0:
                    raise ValueError("Insufficient inventory")

                # 更新库存（检查版本号）
                result = session.query(Inventory).filter(
                    Inventory.id == inventory_id,
                    Inventory.version == original_version
                ).update({
                    "quantity": new_quantity,
                    "version": original_version + 1
                })

                if result == 0:
                    # 版本号不匹配，重试
                    print(f"Optimistic lock failed (attempt {attempt + 1}), retrying...")
                    continue

                session.commit()
                print(f"✓ Updated inventory: quantity={new_quantity}, version={original_version + 1}")
                return True

            except ValueError as e:
                print(f"✗ Update failed: {e}")
                return False

    print(f"✗ Max retries exceeded")
    return False


def pessimistic_lock_update(inventory_id: int, quantity_change: int):
    """使用悲观锁更新库存"""
    with SessionLocal() as session:
        try:
            # 读取库存并锁定
            inventory = session.query(Inventory).with_for_update().filter_by(id=inventory_id).first()
            if not inventory:
                raise ValueError("Inventory not found")

            new_quantity = inventory.quantity + quantity_change

            if new_quantity < 0:
                raise ValueError("Insufficient inventory")

            # 更新库存
            inventory.quantity = new_quantity
            session.commit()

            print(f"✓ Updated inventory: quantity={new_quantity}")
            return True

        except ValueError as e:
            print(f"✗ Update failed: {e}")
            return False


def test_optimistic_lock():
    """测试乐观锁"""
    print("\n=== 测试乐观锁 ===")

    # 创建测试数据
    with SessionLocal() as session:
        inventory = Inventory(product_name="iPhone", quantity=100, version=0)
        session.add(inventory)
        session.commit()

    # 并发更新
    def update1():
        optimistic_lock_update(1, -10)

    def update2():
        optimistic_lock_update(1, -20)

    t1 = threading.Thread(target=update1)
    t2 = threading.Thread(target=update2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()

    # 查看最终结果
    with SessionLocal() as session:
        inventory = session.query(Inventory).filter_by(id=1).first()
        print(f"Final inventory: {inventory}")


def test_pessimistic_lock():
    """测试悲观锁"""
    print("\n=== 测试悲观锁 ===")

    # 重置数据
    with SessionLocal() as session:
        inventory = session.query(Inventory).filter_by(id=1).first()
        inventory.quantity = 100
        session.commit()

    # 并发更新
    def update1():
        pessimistic_lock_update(1, -10)

    def update2():
        pessimistic_lock_update(1, -20)

    t1 = threading.Thread(target=update1)
    t2 = threading.Thread(target=update2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()

    # 查看最终结果
    with SessionLocal() as session:
        inventory = session.query(Inventory).filter_by(id=1).first()
        print(f"Final inventory: {inventory}")


# 测试
if __name__ == "__main__":
    test_optimistic_lock()
    test_pessimistic_lock()
```

### 运行结果

```
=== 测试乐观锁 ===
Optimistic lock failed (attempt 1), retrying...
✓ Updated inventory: quantity=90, version=1
✓ Updated inventory: quantity=70, version=2
Final inventory: <Inventory(id=1, product=iPhone, quantity=70, version=2)>

=== 测试悲观锁 ===
✓ Updated inventory: quantity=90
✓ Updated inventory: quantity=70
Final inventory: <Inventory(id=1, product=iPhone, quantity=70, version=2)>
```

---

## 总结

**事务管理的核心要点：**

1. **手动事务**：try-except-finally 模式
2. **嵌套事务**：使用 begin_nested 创建 Savepoint
3. **隔离级别**：Read Committed、Repeatable Read、Serializable
4. **乐观锁**：使用版本号检测冲突
5. **悲观锁**：使用 SELECT FOR UPDATE 锁定数据

**最佳实践：**
- 保持事务简短
- 使用上下文管理器
- 处理并发冲突
- 选择合适的隔离级别
- 根据场景选择锁机制

---

**记住：** 事务是数据一致性的保证，合理使用事务可以避免数据不一致和并发问题。
