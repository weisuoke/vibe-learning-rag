# 实战代码 01：基础工具系统

完整实现一个基于 TypeBox 的工具系统，包含 4 个核心工具（read、write、edit、bash）和工具注册表。

---

## 完整代码

```typescript
/**
 * 基础工具系统实现
 * 演示：TypeBox Schema + AJV 验证 + 工具注册 + 执行流程
 */

import { Type, Static, TSchema } from '@sinclair/typebox';
import Ajv, { ValidateFunction } from 'ajv';
import { readFile, writeFile, appendFile } from 'fs/promises';
import { resolve, dirname } from 'path';
import { spawn } from 'child_process';
import { mkdir } from 'fs/promises';

// ===== 1. 类型定义 =====

interface Tool<T extends TSchema = TSchema> {
  name: string;
  description: string;
  schema: T;
  validator?: ValidateFunction;
  execute: (params: Static<T>) => Promise<string | ToolResult>;
}

interface ToolResult {
  output: string;
  error?: boolean;
  metadata?: Record<string, unknown>;
}

// ===== 2. 工具注册表 =====

class ToolRegistry {
  private tools = new Map<string, Tool>();
  private ajv = new Ajv({ allErrors: true });

  register<T extends TSchema>(tool: Tool<T>): void {
    // 预编译验证器
    tool.validator = this.ajv.compile(tool.schema);
    this.tools.set(tool.name, tool);
    console.log(`✓ Registered tool: ${tool.name}`);
  }

  get(name: string): Tool | undefined {
    return this.tools.get(name);
  }

  list(): string[] {
    return Array.from(this.tools.keys());
  }

  validate(name: string, params: unknown): boolean {
    const tool = this.tools.get(name);
    if (!tool || !tool.validator) {
      return false;
    }
    return tool.validator(params);
  }

  getValidationErrors(name: string): unknown[] | null {
    const tool = this.tools.get(name);
    return tool?.validator?.errors || null;
  }

  getSchemas() {
    return Array.from(this.tools.values()).map(tool => ({
      name: tool.name,
      description: tool.description,
      input_schema: tool.schema
    }));
  }
}

// ===== 3. Read 工具 =====

const ReadToolSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    description: '要读取的文件路径（相对于工作目录）'
  }),
  lines: Type.Optional(Type.Object({
    start: Type.Number({
      minimum: 1,
      description: '起始行号（从 1 开始）'
    }),
    end: Type.Number({
      minimum: 1,
      description: '结束行号（包含）'
    })
  }, {
    description: '可选：只读取指定行范围'
  }))
}, {
  $id: 'ReadTool',
  description: '读取文件内容'
});

type ReadToolParams = Static<typeof ReadToolSchema>;

async function executeRead(
  params: ReadToolParams,
  workDir: string
): Promise<string> {
  // 安全检查：路径必须在工作目录内
  const fullPath = resolve(workDir, params.path);
  if (!fullPath.startsWith(workDir)) {
    return `Error: Path must be within working directory`;
  }

  try {
    const content = await readFile(fullPath, 'utf-8');

    // 如果指定了行范围
    if (params.lines) {
      const lines = content.split('\n');
      const { start, end } = params.lines;

      if (start > lines.length) {
        return `Error: Start line ${start} exceeds file length ${lines.length}`;
      }

      return lines.slice(start - 1, end).join('\n');
    }

    return content;
  } catch (error: any) {
    return `Error: ${error.message}`;
  }
}

// ===== 4. Write 工具 =====

const WriteToolSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    description: '要写入的文件路径'
  }),
  content: Type.String({
    description: '文件内容'
  }),
  createDirs: Type.Optional(Type.Boolean({
    description: '是否自动创建父目录（默认 false）'
  }))
}, {
  $id: 'WriteTool',
  description: '写入文件内容（覆盖现有文件）'
});

type WriteToolParams = Static<typeof WriteToolSchema>;

async function executeWrite(
  params: WriteToolParams,
  workDir: string
): Promise<string> {
  const fullPath = resolve(workDir, params.path);

  if (!fullPath.startsWith(workDir)) {
    return `Error: Path must be within working directory`;
  }

  try {
    // 创建父目录
    if (params.createDirs) {
      await mkdir(dirname(fullPath), { recursive: true });
    }

    await writeFile(fullPath, params.content, 'utf-8');
    return `✓ Wrote ${params.content.length} bytes to ${params.path}`;
  } catch (error: any) {
    return `Error: ${error.message}`;
  }
}

// ===== 5. Edit 工具 =====

const EditToolSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    description: '要编辑的文件路径'
  }),
  oldText: Type.String({
    minLength: 1,
    description: '要替换的文本（必须完全匹配）'
  }),
  newText: Type.String({
    description: '新文本（可以为空字符串表示删除）'
  })
}, {
  $id: 'EditTool',
  description: '编辑文件内容（精确替换）'
});

type EditToolParams = Static<typeof EditToolSchema>;

async function executeEdit(
  params: EditToolParams,
  workDir: string
): Promise<string> {
  const fullPath = resolve(workDir, params.path);

  if (!fullPath.startsWith(workDir)) {
    return `Error: Path must be within working directory`;
  }

  try {
    const content = await readFile(fullPath, 'utf-8');

    // 检查 oldText 是否存在
    if (!content.includes(params.oldText)) {
      return `Error: Text not found in file`;
    }

    // 检查 oldText 是否唯一
    const occurrences = content.split(params.oldText).length - 1;
    if (occurrences > 1) {
      return `Error: Text appears ${occurrences} times, must be unique`;
    }

    // 替换
    const newContent = content.replace(params.oldText, params.newText);
    await writeFile(fullPath, newContent, 'utf-8');

    return `✓ Replaced text in ${params.path}`;
  } catch (error: any) {
    return `Error: ${error.message}`;
  }
}

// ===== 6. Bash 工具 =====

const BashToolSchema = Type.Object({
  command: Type.String({
    minLength: 1,
    description: '要执行的 shell 命令'
  }),
  timeout: Type.Optional(Type.Number({
    minimum: 1000,
    maximum: 600000,
    description: '超时时间（毫秒，默认 120000）'
  }))
}, {
  $id: 'BashTool',
  description: '执行 shell 命令'
});

type BashToolParams = Static<typeof BashToolSchema>;

async function executeBash(
  params: BashToolParams,
  workDir: string
): Promise<string> {
  const { command, timeout = 120000 } = params;

  // 安全检查：禁止危险命令
  const dangerous = ['rm -rf /', 'dd if=', ':(){ :|:& };:'];
  if (dangerous.some(d => command.includes(d))) {
    return `Error: Dangerous command detected`;
  }

  return new Promise((resolve) => {
    const proc = spawn('sh', ['-c', command], {
      cwd: workDir,
      timeout: timeout
    });

    let stdout = '';
    let stderr = '';

    proc.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    proc.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    proc.on('close', (code) => {
      if (code === 0) {
        resolve(stdout || '✓ Command completed successfully');
      } else {
        resolve(`Error: Command failed with code ${code}\n${stderr}`);
      }
    });

    proc.on('error', (error) => {
      resolve(`Error: ${error.message}`);
    });
  });
}

// ===== 7. 工具执行器 =====

class ToolExecutor {
  constructor(
    private registry: ToolRegistry,
    private workDir: string
  ) {}

  async execute(name: string, params: unknown): Promise<ToolResult> {
    console.log(`\n=== Executing tool: ${name} ===`);

    // 1. 查找工具
    const tool = this.registry.get(name);
    if (!tool) {
      return {
        output: `Error: Tool '${name}' not found. Available tools: ${this.registry.list().join(', ')}`,
        error: true
      };
    }

    // 2. 验证参数
    if (!this.registry.validate(name, params)) {
      const errors = this.registry.getValidationErrors(name);
      const errorMessage = errors
        ?.map((e: any) => `- ${e.instancePath || '/'}: ${e.message}`)
        .join('\n');

      return {
        output: `Validation failed:\n${errorMessage}`,
        error: true
      };
    }

    // 3. 执行工具
    try {
      const result = await tool.execute(params as any);
      return typeof result === 'string'
        ? { output: result, error: false }
        : result;
    } catch (error: any) {
      return {
        output: `Error: ${error.message}`,
        error: true
      };
    }
  }

  async executeMultiple(
    calls: Array<{ name: string; params: unknown }>
  ): Promise<ToolResult[]> {
    console.log(`\n=== Executing ${calls.length} tools in parallel ===`);

    const results = await Promise.all(
      calls.map(call => this.execute(call.name, call.params))
    );

    console.log(`✓ All ${calls.length} tools executed`);
    return results;
  }
}

// ===== 8. 测试演示 =====

async function demo() {
  console.log('=== Basic Tool System Demo ===\n');

  // 创建工作目录
  const workDir = process.cwd();
  console.log(`Working directory: ${workDir}\n`);

  // 创建注册表
  const registry = new ToolRegistry();

  // 注册工具
  registry.register({
    name: 'read',
    description: 'Read file content',
    schema: ReadToolSchema,
    execute: (params) => executeRead(params, workDir)
  });

  registry.register({
    name: 'write',
    description: 'Write file content',
    schema: WriteToolSchema,
    execute: (params) => executeWrite(params, workDir)
  });

  registry.register({
    name: 'edit',
    description: 'Edit file content',
    schema: EditToolSchema,
    execute: (params) => executeEdit(params, workDir)
  });

  registry.register({
    name: 'bash',
    description: 'Execute shell command',
    schema: BashToolSchema,
    execute: (params) => executeBash(params, workDir)
  });

  console.log();

  // 创建执行器
  const executor = new ToolExecutor(registry, workDir);

  // ===== 测试 1：写入文件 =====
  console.log('--- Test 1: Write file ---');
  const result1 = await executor.execute('write', {
    path: './test-file.txt',
    content: 'Hello, World!\nThis is a test file.\nLine 3.'
  });
  console.log('Result:', result1.output);

  // ===== 测试 2：读取文件 =====
  console.log('\n--- Test 2: Read file ---');
  const result2 = await executor.execute('read', {
    path: './test-file.txt'
  });
  console.log('Result:', result2.output);

  // ===== 测试 3：读取指定行 =====
  console.log('\n--- Test 3: Read specific lines ---');
  const result3 = await executor.execute('read', {
    path: './test-file.txt',
    lines: { start: 1, end: 2 }
  });
  console.log('Result:', result3.output);

  // ===== 测试 4：编辑文件 =====
  console.log('\n--- Test 4: Edit file ---');
  const result4 = await executor.execute('edit', {
    path: './test-file.txt',
    oldText: 'World',
    newText: 'TypeScript'
  });
  console.log('Result:', result4.output);

  // ===== 测试 5：验证编辑结果 =====
  console.log('\n--- Test 5: Verify edit ---');
  const result5 = await executor.execute('read', {
    path: './test-file.txt'
  });
  console.log('Result:', result5.output);

  // ===== 测试 6：执行命令 =====
  console.log('\n--- Test 6: Execute bash command ---');
  const result6 = await executor.execute('bash', {
    command: 'echo "Hello from bash"'
  });
  console.log('Result:', result6.output);

  // ===== 测试 7：验证失败 =====
  console.log('\n--- Test 7: Validation failure ---');
  const result7 = await executor.execute('read', {
    path: 123  // 错误类型
  });
  console.log('Result:', result7.output);

  // ===== 测试 8：工具不存在 =====
  console.log('\n--- Test 8: Tool not found ---');
  const result8 = await executor.execute('unknown', {});
  console.log('Result:', result8.output);

  // ===== 测试 9：并行执行 =====
  console.log('\n--- Test 9: Parallel execution ---');
  const results = await executor.executeMultiple([
    { name: 'bash', params: { command: 'echo "Task 1"' } },
    { name: 'bash', params: { command: 'echo "Task 2"' } },
    { name: 'bash', params: { command: 'echo "Task 3"' } }
  ]);
  results.forEach((r, i) => {
    console.log(`Task ${i + 1}:`, r.output);
  });

  // ===== 测试 10：获取工具列表 =====
  console.log('\n--- Test 10: List tools ---');
  console.log('Available tools:', registry.list());
  console.log('\nTool schemas for LLM:');
  console.log(JSON.stringify(registry.getSchemas(), null, 2));

  // 清理
  console.log('\n--- Cleanup ---');
  await executor.execute('bash', {
    command: 'rm -f ./test-file.txt'
  });
  console.log('✓ Test file removed');
}

// 运行演示
demo().catch(console.error);
```

---

## 运行输出

```
=== Basic Tool System Demo ===

Working directory: /Users/user/project

✓ Registered tool: read
✓ Registered tool: write
✓ Registered tool: edit
✓ Registered tool: bash

--- Test 1: Write file ---

=== Executing tool: write ===
Result: ✓ Wrote 49 bytes to ./test-file.txt

--- Test 2: Read file ---

=== Executing tool: read ===
Result: Hello, World!
This is a test file.
Line 3.

--- Test 3: Read specific lines ---

=== Executing tool: read ===
Result: Hello, World!
This is a test file.

--- Test 4: Edit file ---

=== Executing tool: edit ===
Result: ✓ Replaced text in ./test-file.txt

--- Test 5: Verify edit ---

=== Executing tool: read ===
Result: Hello, TypeScript!
This is a test file.
Line 3.

--- Test 6: Execute bash command ---

=== Executing tool: bash ===
Result: Hello from bash

--- Test 7: Validation failure ---

=== Executing tool: read ===
Result: Validation failed:
- /path: must be string

--- Test 8: Tool not found ---

=== Executing tool: unknown ===
Result: Error: Tool 'unknown' not found. Available tools: read, write, edit, bash

--- Test 9: Parallel execution ---

=== Executing 3 tools in parallel ===

=== Executing tool: bash ===

=== Executing tool: bash ===

=== Executing tool: bash ===
✓ All 3 tools executed
Task 1: Task 1

Task 2: Task 2

Task 3: Task 3


--- Test 10: List tools ---
Available tools: [ 'read', 'write', 'edit', 'bash' ]

Tool schemas for LLM:
[
  {
    "name": "read",
    "description": "Read file content",
    "input_schema": {
      "$id": "ReadTool",
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "minLength": 1,
          "description": "要读取的文件路径（相对于工作目录）"
        },
        "lines": {
          "type": "object",
          "description": "可选：只读取指定行范围",
          "properties": {
            "start": {
              "type": "number",
              "minimum": 1,
              "description": "起始行号（从 1 开始）"
            },
            "end": {
              "type": "number",
              "minimum": 1,
              "description": "结束行号（包含）"
            }
          },
          "required": ["start", "end"]
        }
      },
      "required": ["path"]
    }
  },
  ...
]

--- Cleanup ---

=== Executing tool: bash ===
✓ Test file removed
```

---

## 关键特性

### 1. TypeBox Schema 定义
- 使用 TypeBox 定义参数类型
- 自动生成 JSON Schema（给 LLM）
- 自动推导 TypeScript 类型（给代码）

### 2. AJV 预编译验证
- 注册时预编译验证器
- 执行时直接使用（性能提升 50 倍）
- 详细的验证错误信息

### 3. 安全检查
- 路径必须在工作目录内
- 禁止危险的 shell 命令
- 超时保护

### 4. 并行执行
- 支持多个工具同时执行
- 使用 Promise.all 提升性能

### 5. 错误处理
- 验证失败返回详细错误
- 执行失败返回错误信息
- 不抛出异常（支持自纠正）

---

## 扩展建议

### 添加新工具

```typescript
// 定义 Schema
const HttpToolSchema = Type.Object({
  url: Type.String({ format: 'uri' }),
  method: Type.Optional(Type.Union([
    Type.Literal('GET'),
    Type.Literal('POST')
  ]))
});

// 实现执行函数
async function executeHttp(params: Static<typeof HttpToolSchema>) {
  const response = await fetch(params.url, {
    method: params.method || 'GET'
  });
  return await response.text();
}

// 注册工具
registry.register({
  name: 'http',
  description: 'Make HTTP requests',
  schema: HttpToolSchema,
  execute: executeHttp
});
```

### 添加工具统计

```typescript
class ToolRegistry {
  private stats = new Map<string, { calls: number; errors: number }>();

  async execute(name: string, params: unknown) {
    const stats = this.stats.get(name) || { calls: 0, errors: 0 };
    stats.calls++;

    try {
      const result = await tool.execute(params);
      this.stats.set(name, stats);
      return result;
    } catch (error) {
      stats.errors++;
      this.stats.set(name, stats);
      throw error;
    }
  }

  getStats() {
    return Object.fromEntries(this.stats);
  }
}
```

---

## 总结

这个基础工具系统展示了：
- TypeBox + AJV 的完整工作流程
- 4 个核心工具的实现
- 工具注册和动态调用
- 验证、执行、错误处理
- 并行执行优化

可以直接运行并扩展为完整的 Agent 系统。
