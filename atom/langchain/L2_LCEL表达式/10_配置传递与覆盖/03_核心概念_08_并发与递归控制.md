# 核心概念08：并发与递归控制

> **本节目标**: 掌握max_concurrency和recursion_limit，优化性能和防止无限循环

---

## 一、并发控制概述

### 1.1 max_concurrency字段

max_concurrency控制并行执行的最大并发数，防止资源耗尽。

```python
# 限制并发数
config = {"max_concurrency": 5}
results = chain.batch(inputs, config=config)
# 最多同时执行5个请求
```

### 1.2 为什么需要并发控制？

**没有并发控制**：
```python
# 批处理100个输入
inputs = [{"query": f"query-{i}"} for i in range(100)]
results = chain.batch(inputs)
# 可能同时发起100个请求，耗尽资源
```

**有并发控制**：
```python
# 限制并发数
config = {"max_concurrency": 5}
results = chain.batch(inputs, config=config)
# 最多同时执行5个请求，其他排队等待
```

---

## 二、max_concurrency详解

### 2.1 工作原理

```python
# 简化的实现
import asyncio

class ConcurrencyLimiter:
    def __init__(self, max_concurrency: int):
        self.semaphore = asyncio.Semaphore(max_concurrency)

    async def run(self, coro):
        async with self.semaphore:
            return await coro

# 使用
limiter = ConcurrencyLimiter(max_concurrency=5)
tasks = [limiter.run(process(input)) for input in inputs]
results = await asyncio.gather(*tasks)
```

### 2.2 基本用法

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# 创建链
prompt = ChatPromptTemplate.from_template("Tell me about {topic}")
llm = ChatOpenAI()
chain = prompt | llm

# 批处理with并发控制
inputs = [{"topic": f"topic-{i}"} for i in range(100)]
config = {"max_concurrency": 5}
results = chain.batch(inputs, config=config)
```

### 2.3 不同场景的并发设置

```python
# 开发环境：宽松
dev_config = {"max_concurrency": 10}

# 生产环境：保守
prod_config = {"max_concurrency": 3}

# 高流量场景：严格
high_traffic_config = {"max_concurrency": 2}

# 根据环境选择
import os
env = os.getenv("ENV", "development")
if env == "production":
    config = prod_config
else:
    config = dev_config
```

---

## 三、并发控制策略

### 3.1 API限流

```python
# 避免超过API速率限制
# OpenAI: 3500 RPM (requests per minute)
# 假设每个请求1秒，60秒内最多60个请求
# 设置max_concurrency=10，确保不超过限制

config = {"max_concurrency": 10}
results = chain.batch(inputs, config=config)
```

### 3.2 资源管理

```python
# 根据系统资源调整
import psutil

def get_optimal_concurrency():
    """根据系统资源计算最优并发数"""
    cpu_count = psutil.cpu_count()
    memory_percent = psutil.virtual_memory().percent

    if memory_percent > 80:
        return 2  # 内存紧张，降低并发
    elif cpu_count >= 8:
        return 10  # CPU充足，提高并发
    else:
        return 5  # 默认

config = {"max_concurrency": get_optimal_concurrency()}
```

### 3.3 成本优化

```python
# 根据成本预算调整并发
def get_cost_aware_concurrency(budget: str):
    """根据成本预算返回并发数"""
    if budget == "high":
        return 10  # 快速完成，成本高
    elif budget == "medium":
        return 5   # 平衡
    else:
        return 2   # 节省成本，速度慢

config = {"max_concurrency": get_cost_aware_concurrency("medium")}
```

---

## 四、递归控制概述

### 4.1 recursion_limit字段

recursion_limit限制递归调用的最大深度，防止无限循环。

```python
# 限制递归深度
config = {"recursion_limit": 10}
result = agent.invoke(input, config=config)
# 最多递归10层
```

### 4.2 为什么需要递归控制？

**没有递归控制**：
```python
# Agent可能无限循环
result = agent.invoke(input)
# 如果Agent陷入循环，会一直执行直到崩溃
```

**有递归控制**：
```python
# 限制递归深度
config = {"recursion_limit": 10}
result = agent.invoke(input, config=config)
# 超过10层会抛出RecursionError
```

---

## 五、recursion_limit详解

### 5.1 默认值

```python
# 默认recursion_limit=25
result = agent.invoke(input)
# 等价于
result = agent.invoke(input, config={"recursion_limit": 25})
```

### 5.2 工作原理

```python
# 简化的实现
class RecursionTracker:
    def __init__(self, limit: int):
        self.limit = limit
        self.depth = 0

    def enter(self):
        self.depth += 1
        if self.depth > self.limit:
            raise RecursionError(f"超过递归限制: {self.limit}")

    def exit(self):
        self.depth -= 1

# 使用
tracker = RecursionTracker(limit=10)
def recursive_call():
    tracker.enter()
    try:
        # 执行
        if need_recurse:
            recursive_call()
    finally:
        tracker.exit()
```

### 5.3 错误处理

```python
from langchain_core.runnables import RecursionError

try:
    result = agent.invoke(input, config={"recursion_limit": 5})
except RecursionError as e:
    print(f"超过递归限制: {e}")
    # 处理错误，例如返回部分结果
```

---

## 六、Agent循环保护

### 6.1 Agent循环问题

```python
# Agent可能陷入循环
# 例如：查询 -> 工具调用 -> 查询 -> 工具调用 -> ...

# 使用recursion_limit保护
config = {"recursion_limit": 10}
result = agent.invoke("复杂问题", config=config)
```

### 6.2 调试Agent循环

```python
from langchain_core.callbacks import BaseCallbackHandler

class RecursionDebugCallback(BaseCallbackHandler):
    """调试递归深度"""

    def __init__(self):
        self.depth = 0

    def on_chain_start(self, serialized, inputs, **kwargs):
        self.depth += 1
        print(f"递归深度: {self.depth}")

    def on_chain_end(self, outputs, **kwargs):
        self.depth -= 1

# 使用
config = {
    "recursion_limit": 10,
    "callbacks": [RecursionDebugCallback()]
}
result = agent.invoke(input, config=config)
```

### 6.3 优化Agent避免循环

```python
# 策略1：限制工具调用次数
max_tool_calls = 5
tool_calls = 0

def tool_wrapper(tool):
    def wrapped(*args, **kwargs):
        nonlocal tool_calls
        tool_calls += 1
        if tool_calls > max_tool_calls:
            raise Exception("超过工具调用限制")
        return tool(*args, **kwargs)
    return wrapped

# 策略2：检测重复查询
seen_queries = set()

def check_duplicate(query):
    if query in seen_queries:
        raise Exception("检测到重复查询")
    seen_queries.add(query)
```

---

## 七、性能优化

### 7.1 批处理优化

```python
# 优化前：无并发控制
start = time.time()
results = chain.batch(inputs)  # 可能很慢或崩溃
end = time.time()
print(f"耗时: {end - start:.2f}秒")

# 优化后：with并发控制
start = time.time()
config = {"max_concurrency": 5}
results = chain.batch(inputs, config=config)
end = time.time()
print(f"耗时: {end - start:.2f}秒")  # 更快且稳定
```

### 7.2 动态调整并发

```python
import time

class AdaptiveConcurrency:
    """自适应并发控制"""

    def __init__(self, initial=5, min_conc=2, max_conc=20):
        self.concurrency = initial
        self.min_conc = min_conc
        self.max_conc = max_conc
        self.success_count = 0
        self.error_count = 0

    def on_success(self):
        self.success_count += 1
        if self.success_count > 10:
            # 增加并发
            self.concurrency = min(self.concurrency + 1, self.max_conc)
            self.success_count = 0

    def on_error(self):
        self.error_count += 1
        if self.error_count > 3:
            # 降低并发
            self.concurrency = max(self.concurrency - 1, self.min_conc)
            self.error_count = 0

    def get_config(self):
        return {"max_concurrency": self.concurrency}

# 使用
adaptive = AdaptiveConcurrency()
for batch in batches:
    try:
        results = chain.batch(batch, config=adaptive.get_config())
        adaptive.on_success()
    except Exception as e:
        adaptive.on_error()
```

---

## 八、实际应用场景

### 8.1 大规模批处理

```python
# 处理10000个输入
inputs = [{"query": f"query-{i}"} for i in range(10000)]

# 分批处理with并发控制
batch_size = 100
config = {"max_concurrency": 5}

all_results = []
for i in range(0, len(inputs), batch_size):
    batch = inputs[i:i+batch_size]
    results = chain.batch(batch, config=config)
    all_results.extend(results)
    print(f"完成 {i+len(batch)}/{len(inputs)}")
```

### 8.2 Agent任务

```python
# Agent任务with递归保护
config = {
    "recursion_limit": 15,  # 允许15步推理
    "max_concurrency": 3    # 限制工具调用并发
}

result = agent.invoke("复杂任务", config=config)
```

### 8.3 生产环境配置

```python
def get_production_config():
    """生产环境配置"""
    return {
        "max_concurrency": 3,      # 保守的并发
        "recursion_limit": 10,     # 严格的递归限制
        "tags": ["production"],
        "metadata": {"environment": "production"}
    }

# 使用
config = get_production_config()
result = chain.invoke(input, config=config)
```

---

## 九、监控与调优

### 9.1 并发监控

```python
class ConcurrencyMonitor(BaseCallbackHandler):
    """监控并发执行"""

    def __init__(self):
        self.active_count = 0
        self.max_active = 0

    def on_chain_start(self, serialized, inputs, **kwargs):
        self.active_count += 1
        self.max_active = max(self.max_active, self.active_count)
        print(f"当前并发: {self.active_count}, 最大: {self.max_active}")

    def on_chain_end(self, outputs, **kwargs):
        self.active_count -= 1

# 使用
monitor = ConcurrencyMonitor()
config = {
    "max_concurrency": 5,
    "callbacks": [monitor]
}
```

### 9.2 性能基准测试

```python
import time

def benchmark_concurrency(chain, inputs, concurrency_levels):
    """测试不同并发级别的性能"""
    results = {}

    for conc in concurrency_levels:
        config = {"max_concurrency": conc}
        start = time.time()
        chain.batch(inputs, config=config)
        duration = time.time() - start
        results[conc] = duration
        print(f"并发={conc}: {duration:.2f}秒")

    return results

# 使用
concurrency_levels = [1, 3, 5, 10, 20]
results = benchmark_concurrency(chain, inputs, concurrency_levels)
```

---

## 十、常见陷阱

### 10.1 并发过高

```python
# ❌ 并发过高可能导致问题
config = {"max_concurrency": 100}  # 太高
results = chain.batch(inputs, config=config)
# 可能超过API限制、耗尽内存

# ✓ 合理的并发
config = {"max_concurrency": 5}
```

### 10.2 递归限制过低

```python
# ❌ 递归限制过低可能导致任务失败
config = {"recursion_limit": 3}  # 太低
result = agent.invoke("复杂任务", config=config)
# 可能在完成前就超过限制

# ✓ 合理的递归限制
config = {"recursion_limit": 15}
```

### 10.3 忘记配置传播

```python
# ❌ 子链不会自动继承并发限制
sub_chain = llm | parser
main_chain = prompt | sub_chain

# 需要显式传递配置
config = {"max_concurrency": 5}
result = main_chain.invoke(input, config=config)
```

---

## 十一、最佳实践

### 11.1 环境特定配置

```python
def get_env_config(env: str):
    """根据环境返回配置"""
    if env == "production":
        return {
            "max_concurrency": 3,
            "recursion_limit": 10
        }
    elif env == "staging":
        return {
            "max_concurrency": 5,
            "recursion_limit": 15
        }
    else:  # development
        return {
            "max_concurrency": 10,
            "recursion_limit": 25
        }
```

### 11.2 监控和告警

```python
class LimitMonitor(BaseCallbackHandler):
    """监控限制触发"""

    def on_chain_error(self, error, **kwargs):
        if isinstance(error, RecursionError):
            logger.error("触发递归限制")
            metrics.increment("recursion_limit_hit")
```

### 11.3 渐进式调优

```python
# 从保守开始
config = {"max_concurrency": 3}

# 监控性能
# 如果稳定，逐步增加
config = {"max_concurrency": 5}

# 继续监控和调整
```

---

## 十二、下一步

- 配置最佳实践: [核心概念09 - 配置最佳实践](./03_核心概念_09_配置最佳实践.md)
- 实战练习: [实战代码06 - 并发控制实战](./07_实战代码_06_并发控制实战.md)
- 完整应用: [实战代码08 - 完整RAG应用配置](./07_实战代码_08_完整RAG应用配置.md)
