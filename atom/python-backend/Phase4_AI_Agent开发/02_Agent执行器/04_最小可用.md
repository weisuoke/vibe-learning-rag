# Agent执行器 - 最小可用知识

> 掌握20%的核心知识，解决80%的问题

---

## 核心理念

**最小可用知识（Minimum Viable Knowledge）**：只学习最核心、最常用的知识，快速上手并开始实践。

**目标**：用最短的时间掌握 Agent执行器 的核心用法，能够创建基础的 Agent 并解决实际问题。

---

## 必须掌握的5个核心知识点

### 4.1 理解 ReAct 循环的核心流程

**一句话**：Agent 通过"思考 → 行动 → 观察"的循环来完成任务。

**核心概念**：

```
用户问题
   ↓
┌─────────────────────────────────┐
│  ReAct 循环                      │
│                                 │
│  1. Thought（思考）              │
│     LLM: "我应该查询订单信息"    │
│                                 │
│  2. Action（行动）               │
│     调用: query_order("12345")  │
│                                 │
│  3. Observation（观察）          │
│     结果: "订单已发货"           │
│                                 │
│  4. 判断是否完成                 │
│     - 是 → 返回答案              │
│     - 否 → 回到步骤1             │
└─────────────────────────────────┘
   ↓
最终答案
```

**最简代码示例**：

```python
from langchain.agents import AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain.tools import tool
from langchain.prompts import PromptTemplate

# 1. 定义工具
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    return f"订单 {order_id} 已发货，预计明天到达"

# 2. 创建 LLM
llm = ChatOpenAI(model="gpt-4", temperature=0)

# 3. 定义 Prompt
prompt = PromptTemplate.from_template("""
Answer the following questions as best you can. You have access to the following tools:

{tools}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Begin!

Question: {input}
Thought: {agent_scratchpad}
""")

# 4. 创建 Agent
tools = [query_order]
agent = create_react_agent(llm, tools, prompt)

# 5. 创建 Agent执行器
executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

# 6. 运行 Agent
result = executor.invoke({"input": "订单12345什么时候到？"})
print(result["output"])
```

**输出示例**：

```
> Entering new AgentExecutor chain...
Thought: 我需要查询订单信息
Action: query_order
Action Input: 12345
Observation: 订单 12345 已发货，预计明天到达
Thought: 我现在知道最终答案了
Final Answer: 您的订单12345已发货，预计明天到达

> Finished chain.
您的订单12345已发货，预计明天到达
```

**关键要点**：
- **Thought**：LLM 思考下一步做什么
- **Action**：选择并调用工具
- **Observation**：观察工具执行结果
- **循环**：重复直到得出 Final Answer

---

### 4.2 使用 @tool 装饰器定义工具

**一句话**：用 `@tool` 装饰器把普通函数变成 Agent 可以调用的工具。

**核心语法**：

```python
from langchain.tools import tool

@tool
def tool_name(param: str) -> str:
    """工具描述（非常重要！LLM 根据这个描述选择工具）"""
    # 工具的实际逻辑
    return "结果"
```

**完整示例**：

```python
from langchain.tools import tool

# 示例1：查询订单
@tool
def query_order(order_id: str) -> str:
    """查询订单信息，输入订单ID，返回订单状态和预计到达时间"""
    # 实际应该查询数据库
    return f"订单 {order_id} 已发货，预计明天到达"

# 示例2：查询库存
@tool
def query_inventory(product_id: str) -> str:
    """查询产品库存，输入产品ID，返回当前库存数量"""
    # 实际应该查询数据库
    return f"产品 {product_id} 当前库存：100件"

# 示例3：计算器
@tool
def calculator(expression: str) -> str:
    """计算数学表达式，输入表达式（如 '2+3*4'），返回计算结果"""
    try:
        result = eval(expression)
        return f"计算结果：{result}"
    except Exception as e:
        return f"计算错误：{str(e)}"

# 使用工具
tools = [query_order, query_inventory, calculator]
```

**关键要点**：
- **函数名**：工具的唯一标识（如 `query_order`）
- **参数类型注解**：必须有类型注解（如 `order_id: str`）
- **返回类型注解**：必须有返回类型注解（如 `-> str`）
- **文档字符串**：**最重要！** LLM 根据这个描述选择工具

**工具描述的最佳实践**：

```python
@tool
def good_tool(param: str) -> str:
    """
    清晰的工具描述：
    - 功能：做什么
    - 输入：需要什么参数
    - 输出：返回什么结果
    """
    return "结果"

@tool
def bad_tool(param: str) -> str:
    """查询"""  # ❌ 描述太简单，LLM 不知道这个工具是干什么的
    return "结果"
```

---

### 4.3 创建和配置 AgentExecutor

**一句话**：AgentExecutor 是运行 Agent 的执行引擎，负责管理循环和工具调用。

**核心参数**：

```python
from langchain.agents import AgentExecutor

executor = AgentExecutor(
    agent=agent,              # Agent 实例
    tools=tools,              # 工具列表
    verbose=True,             # 是否打印执行过程（调试时很有用）
    max_iterations=10,        # 最大迭代次数（防止无限循环）
    early_stopping_method="generate",  # 早停策略
    handle_parsing_errors=True,        # 是否处理解析错误
)
```

**参数详解**：

| 参数 | 说明 | 默认值 | 推荐值 |
|------|------|--------|--------|
| `agent` | Agent 实例 | 必需 | - |
| `tools` | 工具列表 | 必需 | - |
| `verbose` | 打印执行过程 | `False` | 开发时用 `True`，生产时用 `False` |
| `max_iterations` | 最大迭代次数 | `15` | 简单任务 `5-10`，复杂任务 `10-20` |
| `early_stopping_method` | 早停策略 | `"force"` | `"generate"` 更友好 |
| `handle_parsing_errors` | 处理解析错误 | `False` | `True` 更稳定 |

**完整示例**：

```python
from langchain.agents import AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain.tools import tool
from langchain.prompts import PromptTemplate

# 1. 定义工具
@tool
def search(query: str) -> str:
    """搜索信息"""
    return f"搜索结果：{query}"

# 2. 创建 Agent
llm = ChatOpenAI(model="gpt-4", temperature=0)
tools = [search]
prompt = PromptTemplate.from_template("...")  # 省略 Prompt
agent = create_react_agent(llm, tools, prompt)

# 3. 创建 AgentExecutor（配置参数）
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,                    # 开发时打印执行过程
    max_iterations=10,               # 最多执行10次
    early_stopping_method="generate", # 友好的早停策略
    handle_parsing_errors=True,      # 处理解析错误
)

# 4. 运行 Agent
result = executor.invoke({"input": "Python 是什么？"})
print(result["output"])
```

**关键要点**：
- **verbose=True**：开发时必须开启，可以看到 Agent 的思考过程
- **max_iterations**：防止无限循环，根据任务复杂度设置
- **early_stopping_method**：`"generate"` 比 `"force"` 更友好
- **handle_parsing_errors**：建议开启，提高稳定性

---

### 4.4 运行 Agent 并获取结果

**一句话**：使用 `executor.invoke()` 运行 Agent，传入问题，获取答案。

**基础用法**：

```python
# 同步调用
result = executor.invoke({"input": "用户问题"})
print(result["output"])  # 最终答案

# 异步调用（推荐用于 FastAPI）
result = await executor.ainvoke({"input": "用户问题"})
print(result["output"])
```

**返回结果结构**：

```python
result = executor.invoke({"input": "订单12345什么时候到？"})

# result 是一个字典
{
    "input": "订单12345什么时候到？",           # 输入的问题
    "output": "您的订单12345已发货，预计明天到达",  # 最终答案
    "intermediate_steps": [                      # 中间步骤（可选）
        (AgentAction(...), "观察结果1"),
        (AgentAction(...), "观察结果2"),
    ]
}
```

**获取中间步骤**：

```python
# 如果需要查看 Agent 的执行过程
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    return_intermediate_steps=True,  # 返回中间步骤
)

result = executor.invoke({"input": "问题"})

# 查看中间步骤
for action, observation in result["intermediate_steps"]:
    print(f"Action: {action.tool} - {action.tool_input}")
    print(f"Observation: {observation}")
```

**错误处理**：

```python
try:
    result = executor.invoke({"input": "问题"})
    print(result["output"])
except Exception as e:
    print(f"Agent 执行失败：{str(e)}")
```

**关键要点**：
- **输入格式**：`{"input": "问题"}`
- **输出格式**：`result["output"]` 是最终答案
- **中间步骤**：设置 `return_intermediate_steps=True` 可以查看执行过程
- **错误处理**：用 try-except 捕获异常

---

### 4.5 集成到 FastAPI

**一句话**：把 Agent 封装成 FastAPI 端点，让前端可以调用。

**最简示例**：

```python
from fastapi import FastAPI
from pydantic import BaseModel
from langchain.agents import AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain.tools import tool
from langchain.prompts import PromptTemplate

app = FastAPI()

# 定义工具
@tool
def search(query: str) -> str:
    """搜索信息"""
    return f"搜索结果：{query}"

# 创建 Agent（全局变量，避免每次请求都创建）
llm = ChatOpenAI(model="gpt-4", temperature=0)
tools = [search]
prompt = PromptTemplate.from_template("...")  # 省略 Prompt
agent = create_react_agent(llm, tools, prompt)
executor = AgentExecutor(agent=agent, tools=tools, verbose=False)

# 定义请求体
class Question(BaseModel):
    question: str

# 定义响应体
class Answer(BaseModel):
    answer: str

# API 端点
@app.post("/agent", response_model=Answer)
async def run_agent(question: Question):
    # 运行 Agent
    result = await executor.ainvoke({"input": question.question})
    return Answer(answer=result["output"])
```

**测试 API**：

```bash
# 启动服务
uvicorn main:app --reload

# 测试请求
curl -X POST "http://localhost:8000/agent" \
  -H "Content-Type: application/json" \
  -d '{"question": "Python 是什么？"}'

# 响应
{
  "answer": "Python 是一种高级编程语言..."
}
```

**关键要点**：
- **全局 Agent**：在应用启动时创建 Agent，避免每次请求都创建
- **异步调用**：使用 `await executor.ainvoke()` 而不是 `executor.invoke()`
- **错误处理**：添加 try-except 处理 Agent 执行失败的情况
- **verbose=False**：生产环境关闭日志输出

---

## 这些知识足以做什么？

掌握以上5个核心知识点后，你可以：

### ✅ 能做的事情

1. **创建基础的 Agent**
   - 定义工具
   - 创建 Agent 和 AgentExecutor
   - 运行 Agent 并获取结果

2. **定义自定义工具**
   - 使用 `@tool` 装饰器
   - 编写清晰的工具描述
   - 实现工具的实际逻辑

3. **集成到 FastAPI**
   - 创建 API 端点
   - 处理请求和响应
   - 异步调用 Agent

4. **调试 Agent**
   - 使用 `verbose=True` 查看执行过程
   - 查看中间步骤
   - 处理常见错误

5. **控制执行流程**
   - 设置最大迭代次数
   - 配置早停策略
   - 处理解析错误

### ❌ 暂时不能做的事情（需要进阶学习）

1. **复杂的工具链**：需要学习工具之间的依赖关系
2. **流式输出**：需要学习 `astream_events()` 方法
3. **对话记忆**：需要学习 Memory 组件
4. **自定义 Prompt**：需要深入学习 Prompt Engineering
5. **生产优化**：需要学习缓存、监控、日志等

---

## 快速上手实践

### 实践1：创建一个简单的计算器 Agent（10分钟）

```python
from langchain.agents import AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain.tools import tool
from langchain.prompts import PromptTemplate

# 1. 定义工具
@tool
def calculator(expression: str) -> str:
    """计算数学表达式，输入表达式（如 '2+3*4'），返回计算结果"""
    try:
        result = eval(expression)
        return f"计算结果：{result}"
    except Exception as e:
        return f"计算错误：{str(e)}"

# 2. 创建 Agent
llm = ChatOpenAI(model="gpt-4", temperature=0)
tools = [calculator]

prompt = PromptTemplate.from_template("""
Answer the following questions as best you can. You have access to the following tools:

{tools}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Begin!

Question: {input}
Thought: {agent_scratchpad}
""")

agent = create_react_agent(llm, tools, prompt)
executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

# 3. 测试
result = executor.invoke({"input": "计算 (25 + 15) * 2"})
print(result["output"])
```

---

### 实践2：创建一个智能客服 Agent（20分钟）

```python
from langchain.agents import AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain.tools import tool
from langchain.prompts import PromptTemplate

# 1. 定义工具
@tool
def query_order(order_id: str) -> str:
    """查询订单信息，输入订单ID，返回订单状态"""
    # 模拟数据库查询
    orders = {
        "12345": "已发货，预计明天到达",
        "67890": "已签收",
    }
    return orders.get(order_id, "订单不存在")

@tool
def query_inventory(product_id: str) -> str:
    """查询产品库存，输入产品ID，返回库存数量"""
    # 模拟数据库查询
    inventory = {
        "A001": "100件",
        "A002": "50件",
    }
    return inventory.get(product_id, "产品不存在")

# 2. 创建 Agent
llm = ChatOpenAI(model="gpt-4", temperature=0)
tools = [query_order, query_inventory]

prompt = PromptTemplate.from_template("""
你是一个智能客服助手，可以帮助用户查询订单和库存信息。

你有以下工具可用：
{tools}

使用以下格式回答：

Question: 用户的问题
Thought: 你应该思考下一步做什么
Action: 要执行的操作，应该是 [{tool_names}] 之一
Action Input: 操作的输入
Observation: 操作的结果
... (这个 Thought/Action/Action Input/Observation 可以重复 N 次)
Thought: 我现在知道最终答案了
Final Answer: 对原始问题的最终答案

开始！

Question: {input}
Thought: {agent_scratchpad}
""")

agent = create_react_agent(llm, tools, prompt)
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,
    max_iterations=5,
)

# 3. 测试
questions = [
    "订单12345什么时候到？",
    "产品A001还有多少库存？",
    "我想查询订单67890的状态",
]

for q in questions:
    print(f"\n{'='*50}")
    print(f"用户问题：{q}")
    print('='*50)
    result = executor.invoke({"input": q})
    print(f"\nAgent 回答：{result['output']}")
```

---

### 实践3：集成到 FastAPI（30分钟）

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from langchain.agents import AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain.tools import tool
from langchain.prompts import PromptTemplate

app = FastAPI(title="智能客服 API")

# 定义工具
@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    orders = {
        "12345": "已发货，预计明天到达",
        "67890": "已签收",
    }
    return orders.get(order_id, "订单不存在")

@tool
def query_inventory(product_id: str) -> str:
    """查询产品库存"""
    inventory = {
        "A001": "100件",
        "A002": "50件",
    }
    return inventory.get(product_id, "产品不存在")

# 创建 Agent（全局变量）
llm = ChatOpenAI(model="gpt-4", temperature=0)
tools = [query_order, query_inventory]
prompt = PromptTemplate.from_template("""
你是一个智能客服助手。

你有以下工具可用：
{tools}

使用以下格式回答：

Question: {input}
Thought: {agent_scratchpad}
""")

agent = create_react_agent(llm, tools, prompt)
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=False,  # 生产环境关闭日志
    max_iterations=5,
)

# 定义请求和响应模型
class Question(BaseModel):
    question: str

class Answer(BaseModel):
    answer: str
    success: bool

# API 端点
@app.post("/agent", response_model=Answer)
async def run_agent(question: Question):
    try:
        result = await executor.ainvoke({"input": question.question})
        return Answer(answer=result["output"], success=True)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# 健康检查
@app.get("/health")
async def health():
    return {"status": "ok"}
```

**测试**：

```bash
# 启动服务
uvicorn main:app --reload

# 测试请求
curl -X POST "http://localhost:8000/agent" \
  -H "Content-Type: application/json" \
  -d '{"question": "订单12345什么时候到？"}'
```

---

## 常见问题速查

### Q1: Agent 一直循环不停止怎么办？

**A**: 设置 `max_iterations` 参数限制最大迭代次数。

```python
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=10,  # 最多执行10次
)
```

---

### Q2: Agent 选择了错误的工具怎么办？

**A**: 优化工具的描述（description），让 LLM 更容易理解。

```python
@tool
def good_tool(param: str) -> str:
    """
    清晰的描述：
    - 功能：查询订单信息
    - 输入：订单ID（如 '12345'）
    - 输出：订单状态和预计到达时间
    """
    return "结果"
```

---

### Q3: 如何查看 Agent 的执行过程？

**A**: 设置 `verbose=True`。

```python
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,  # 打印执行过程
)
```

---

### Q4: Agent 执行失败怎么办？

**A**: 添加错误处理。

```python
try:
    result = executor.invoke({"input": "问题"})
    print(result["output"])
except Exception as e:
    print(f"Agent 执行失败：{str(e)}")
```

---

### Q5: 如何在 FastAPI 中使用 Agent？

**A**: 使用异步调用 `await executor.ainvoke()`。

```python
@app.post("/agent")
async def run_agent(question: Question):
    result = await executor.ainvoke({"input": question.question})
    return {"answer": result["output"]}
```

---

## 下一步学习

掌握最小可用知识后，建议继续学习：

1. **核心概念**：深入理解 ReAct 模式、工具调用机制、执行循环控制
   - 文档：`03_核心概念_01_ReAct模式.md`
   - 文档：`03_核心概念_02_工具调用机制.md`
   - 文档：`03_核心概念_03_执行循环控制.md`

2. **实战代码**：通过完整示例掌握高级用法
   - 文档：`07_实战代码_02_ReAct实现.md`（手写 ReAct 循环）
   - 文档：`07_实战代码_03_自定义工具.md`（创建复杂工具）
   - 文档：`07_实战代码_05_FastAPI集成.md`（流式输出）

3. **生产实践**：学习生产环境的优化和最佳实践
   - 文档：`07_实战代码_06_生产实践.md`

---

## 学习检查清单

完成最小可用知识学习后，你应该能够：

- [ ] 理解 ReAct 循环的核心流程（Thought → Action → Observation）
- [ ] 使用 `@tool` 装饰器定义工具
- [ ] 创建和配置 AgentExecutor
- [ ] 运行 Agent 并获取结果
- [ ] 将 Agent 集成到 FastAPI
- [ ] 调试 Agent（使用 verbose=True）
- [ ] 处理常见错误
- [ ] 完成3个实践项目

---

**版本：** v1.0
**最后更新：** 2026-02-12
**维护者：** Claude Code
