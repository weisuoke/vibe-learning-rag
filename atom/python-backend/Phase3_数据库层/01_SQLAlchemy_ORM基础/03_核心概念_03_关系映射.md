# 核心概念3：关系映射

深入理解 SQLAlchemy 的关系映射（relationship）。

---

## 1. 什么是关系映射？

**关系映射（Relationship）** 是 ORM 中定义表之间关联关系的机制，让你可以通过对象属性访问关联数据。

**核心思想：**
- 用 `relationship()` 定义表之间的关系
- 用 `ForeignKey` 建立外键约束
- ORM 自动处理 JOIN 查询

```python
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    # 定义关系：一个用户有多个对话
    conversations = relationship("Conversation", back_populates="user")

class Conversation(Base):
    __tablename__ = "conversations"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))  # 外键
    # 定义关系：一个对话属于一个用户
    user = relationship("User", back_populates="conversations")

# 使用：自动 JOIN
user = session.query(User).first()
for conv in user.conversations:  # ORM 自动处理 JOIN
    print(conv.title)
```

**类比前端：** 就像 React 组件的父子关系，自动传递 props

---

## 2. 一对多关系（One-to-Many）

### 2.1 定义一对多关系

```python
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    name = Column(String(50))
    # 一对多：一个用户有多个对话
    conversations = relationship("Conversation", back_populates="user")

class Conversation(Base):
    __tablename__ = "conversations"
    id = Column(Integer, primary_key=True)
    title = Column(String(200))
    user_id = Column(Integer, ForeignKey("users.id"))  # 外键
    # 多对一：一个对话属于一个用户
    user = relationship("User", back_populates="conversations")
```

### 2.2 使用一对多关系

```python
# 创建用户和对话
user = User(name="Alice")
conversation1 = Conversation(title="对话1", user=user)
conversation2 = Conversation(title="对话2", user=user)

session.add_all([user, conversation1, conversation2])
session.commit()

# 访问关系
user = session.query(User).first()
print(user.conversations)  # [<Conversation>, <Conversation>]

conversation = session.query(Conversation).first()
print(conversation.user)  # <User>
```

### 2.3 在 AI Agent 开发中的应用

```python
# 用户 → 对话（一对多）
class User(Base):
    __tablename__ = "users"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(100), unique=True)
    conversations = relationship("Conversation", back_populates="user")

class Conversation(Base):
    __tablename__ = "conversations"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))
    title = Column(String(200))
    user = relationship("User", back_populates="conversations")

# 使用
user = session.query(User).filter(User.email == "user@example.com").first()
for conv in user.conversations:
    print(conv.title)
```

---

## 3. 多对一关系（Many-to-One）

多对一关系是一对多关系的反向，定义方式相同。

```python
# 对话 → 用户（多对一）
conversation = session.query(Conversation).first()
print(conversation.user.name)  # 访问关联的用户
```

---

## 4. 一对一关系（One-to-One）

### 4.1 定义一对一关系

```python
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    name = Column(String(50))
    # 一对一：uselist=False
    profile = relationship("UserProfile", back_populates="user", uselist=False)

class UserProfile(Base):
    __tablename__ = "user_profiles"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"), unique=True)  # 唯一外键
    bio = Column(Text)
    user = relationship("User", back_populates="profile")
```

### 4.2 使用一对一关系

```python
# 创建用户和资料
user = User(name="Alice")
profile = UserProfile(bio="Python developer", user=user)

session.add_all([user, profile])
session.commit()

# 访问关系
user = session.query(User).first()
print(user.profile.bio)  # "Python developer"
```

---

## 5. 多对多关系（Many-to-Many）

### 5.1 定义多对多关系（关联表）

```python
# 关联表
from sqlalchemy import Table

student_course = Table(
    'student_course',
    Base.metadata,
    Column('student_id', Integer, ForeignKey('students.id')),
    Column('course_id', Integer, ForeignKey('courses.id'))
)

class Student(Base):
    __tablename__ = "students"
    id = Column(Integer, primary_key=True)
    name = Column(String(50))
    # 多对多
    courses = relationship("Course", secondary=student_course, back_populates="students")

class Course(Base):
    __tablename__ = "courses"
    id = Column(Integer, primary_key=True)
    title = Column(String(100))
    # 多对多
    students = relationship("Student", secondary=student_course, back_populates="courses")
```

### 5.2 使用多对多关系

```python
# 创建学生和课程
student1 = Student(name="Alice")
student2 = Student(name="Bob")
course1 = Course(title="Python")
course2 = Course(title="SQL")

# 建立关系
student1.courses.append(course1)
student1.courses.append(course2)
student2.courses.append(course1)

session.add_all([student1, student2, course1, course2])
session.commit()

# 访问关系
student = session.query(Student).first()
for course in student.courses:
    print(course.title)  # Python, SQL

course = session.query(Course).first()
for student in course.students:
    print(student.name)  # Alice, Bob
```

### 5.3 在 AI Agent 开发中的应用

```python
# 对话 ← → 标签（多对多）
conversation_tag = Table(
    'conversation_tag',
    Base.metadata,
    Column('conversation_id', UUID(as_uuid=True), ForeignKey('conversations.id')),
    Column('tag_id', UUID(as_uuid=True), ForeignKey('tags.id'))
)

class Conversation(Base):
    __tablename__ = "conversations"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    title = Column(String(200))
    tags = relationship("Tag", secondary=conversation_tag, back_populates="conversations")

class Tag(Base):
    __tablename__ = "tags"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(50), unique=True)
    conversations = relationship("Conversation", secondary=conversation_tag, back_populates="tags")
```

---

## 6. 加载策略

### 6.1 懒加载（Lazy Loading）

**默认行为**：访问关联属性时才查询数据库。

```python
class User(Base):
    conversations = relationship("Conversation", lazy="select")  # 默认

# 使用
user = session.query(User).first()  # 1 次查询
print(user.conversations)  # 触发第 2 次查询
```

**问题：N+1 查询**

```python
users = session.query(User).all()  # 1 次查询
for user in users:
    print(user.conversations)  # 每个 user 触发 1 次查询
# 总共：1 + N 次查询
```

### 6.2 预加载（Eager Loading）

**joinedload**：使用 JOIN 一次性加载

```python
from sqlalchemy.orm import joinedload

users = session.query(User)\
    .options(joinedload(User.conversations))\
    .all()  # 1 次查询（LEFT OUTER JOIN）

for user in users:
    print(user.conversations)  # 不触发查询
```

**subqueryload**：使用子查询加载

```python
from sqlalchemy.orm import subqueryload

users = session.query(User)\
    .options(subqueryload(User.conversations))\
    .all()  # 2 次查询

for user in users:
    print(user.conversations)  # 不触发查询
```

**selectinload**：使用 IN 查询加载（推荐）

```python
from sqlalchemy.orm import selectinload

users = session.query(User)\
    .options(selectinload(User.conversations))\
    .all()  # 2 次查询

for user in users:
    print(user.conversations)  # 不触发查询
```

### 6.3 加载策略对比

| 策略 | SQL 查询次数 | 笛卡尔积 | 适用场景 |
|------|-------------|---------|----------|
| lazy="select" | 1 + N | 无 | 不总是需要关联数据 |
| joinedload | 1 | 可能 | 关联数据少 |
| subqueryload | 2 | 无 | 一对多，关联数据多 |
| selectinload | 2 | 无 | 推荐（1.4+） |

### 6.4 在 AI Agent 开发中的应用

```python
# 查询用户及其对话和消息（多层关系）
from sqlalchemy.orm import selectinload

users = session.query(User)\
    .options(
        selectinload(User.conversations)
        .selectinload(Conversation.messages)
    )\
    .all()

# 不触发额外查询
for user in users:
    for conv in user.conversations:
        for msg in conv.messages:
            print(msg.content)
```

---

## 7. 级联操作

### 7.1 级联删除

```python
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    # cascade="all, delete-orphan"：删除用户时删除所有对话
    conversations = relationship(
        "Conversation",
        back_populates="user",
        cascade="all, delete-orphan"
    )

# 删除用户时，自动删除所有对话
user = session.query(User).first()
session.delete(user)  # 自动删除所有 conversations
session.commit()
```

### 7.2 级联选项

| 选项 | 说明 |
|------|------|
| `save-update` | 添加父对象时，自动添加子对象 |
| `delete` | 删除父对象时，自动删除子对象 |
| `delete-orphan` | 子对象脱离父对象时，自动删除 |
| `merge` | 合并父对象时，自动合并子对象 |
| `all` | 包含 save-update, merge, refresh-expire, expunge, delete |

### 7.3 在 AI Agent 开发中的应用

```python
class User(Base):
    __tablename__ = "users"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    conversations = relationship(
        "Conversation",
        back_populates="user",
        cascade="all, delete-orphan"  # 删除用户时删除所有对话
    )

class Conversation(Base):
    __tablename__ = "conversations"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))
    user = relationship("User", back_populates="conversations")
    messages = relationship(
        "Message",
        back_populates="conversation",
        cascade="all, delete-orphan"  # 删除对话时删除所有消息
    )

class Message(Base):
    __tablename__ = "messages"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    conversation_id = Column(UUID(as_uuid=True), ForeignKey("conversations.id"))
    conversation = relationship("Conversation", back_populates="messages")
```

---

## 8. 完整示例：AI Agent 关系映射

```python
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Table
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship, declarative_base
from datetime import datetime
import uuid

Base = declarative_base()

# 多对多关联表
conversation_tag = Table(
    'conversation_tag',
    Base.metadata,
    Column('conversation_id', UUID(as_uuid=True), ForeignKey('conversations.id')),
    Column('tag_id', UUID(as_uuid=True), ForeignKey('tags.id'))
)

class User(Base):
    """用户模型"""
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(100), unique=True, nullable=False)

    # 一对多：用户 → 对话
    conversations = relationship(
        "Conversation",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="selectin"  # 默认预加载
    )

class Conversation(Base):
    """对话模型"""
    __tablename__ = "conversations"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    title = Column(String(200), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 多对一：对话 → 用户
    user = relationship("User", back_populates="conversations")

    # 一对多：对话 → 消息
    messages = relationship(
        "Message",
        back_populates="conversation",
        cascade="all, delete-orphan",
        order_by="Message.created_at"  # 按时间排序
    )

    # 多对多：对话 ← → 标签
    tags = relationship(
        "Tag",
        secondary=conversation_tag,
        back_populates="conversations"
    )

class Message(Base):
    """消息模型"""
    __tablename__ = "messages"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    conversation_id = Column(UUID(as_uuid=True), ForeignKey("conversations.id"), nullable=False)
    role = Column(String(20), nullable=False)
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 多对一：消息 → 对话
    conversation = relationship("Conversation", back_populates="messages")

class Tag(Base):
    """标签模型"""
    __tablename__ = "tags"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(50), unique=True, nullable=False)

    # 多对多：标签 ← → 对话
    conversations = relationship(
        "Conversation",
        secondary=conversation_tag,
        back_populates="tags"
    )

# 使用示例
from sqlalchemy.orm import Session, selectinload

# 查询用户及其对话和消息
user = session.query(User)\
    .options(
        selectinload(User.conversations)
        .selectinload(Conversation.messages)
    )\
    .filter(User.email == "user@example.com")\
    .first()

# 不触发额外查询
for conv in user.conversations:
    print(f"对话: {conv.title}")
    for msg in conv.messages:
        print(f"  {msg.role}: {msg.content}")
```

---

## 9. 最佳实践

### 9.1 使用 back_populates

```python
# ✅ 推荐：使用 back_populates
class User(Base):
    conversations = relationship("Conversation", back_populates="user")

class Conversation(Base):
    user = relationship("User", back_populates="conversations")

# ❌ 不推荐：使用 backref（隐式定义）
class User(Base):
    conversations = relationship("Conversation", backref="user")
```

### 9.2 使用预加载避免 N+1

```python
# ✅ 推荐：使用 selectinload
from sqlalchemy.orm import selectinload

users = session.query(User)\
    .options(selectinload(User.conversations))\
    .all()

# ❌ 不推荐：懒加载导致 N+1
users = session.query(User).all()
for user in users:
    print(user.conversations)  # N+1 问题
```

### 9.3 使用级联操作

```python
# ✅ 推荐：使用级联删除
conversations = relationship(
    "Conversation",
    cascade="all, delete-orphan"
)

# ❌ 不推荐：手动删除子对象
user = session.query(User).first()
for conv in user.conversations:
    session.delete(conv)
session.delete(user)
```

### 9.4 使用 order_by

```python
# ✅ 推荐：在 relationship 中指定排序
messages = relationship(
    "Message",
    order_by="Message.created_at"
)

# ❌ 不推荐：每次查询都排序
messages = session.query(Message)\
    .filter(Message.conversation_id == conv_id)\
    .order_by(Message.created_at)\
    .all()
```

---

## 总结

**关系映射的核心要点：**

1. **一对多**：最常用的关系，用 ForeignKey + relationship
2. **多对一**：一对多的反向
3. **一对一**：使用 uselist=False + unique ForeignKey
4. **多对多**：使用关联表（secondary）
5. **加载策略**：使用 selectinload 避免 N+1 问题
6. **级联操作**：使用 cascade 自动管理子对象
7. **最佳实践**：back_populates、预加载、级联、排序

**在 AI Agent 开发中的应用：**
- 用户 → 对话（一对多）
- 对话 → 消息（一对多）
- 对话 ← → 标签（多对多）
- 使用 selectinload 预加载，避免 N+1
- 使用级联删除，自动清理子对象

---

**记住：** 关系映射让你用对象属性访问关联数据，ORM 自动处理 JOIN 查询。
