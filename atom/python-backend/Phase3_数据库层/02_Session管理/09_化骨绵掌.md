# 【化骨绵掌】Session管理

> Session 管理的进阶技巧和最佳实践

---

## 技巧1：使用 scoped_session 实现线程安全

### 问题

**Session 不是线程安全的，如何在多线程环境中使用？**

### 解决方案

**使用 scoped_session 为每个线程创建独立的 Session。**

```python
from sqlalchemy.orm import scoped_session, sessionmaker

# 创建 scoped_session
SessionLocal = scoped_session(sessionmaker(bind=engine))

# 每个线程自动获得独立的 Session
def worker():
    session = SessionLocal()  # 线程本地 Session
    users = session.query(User).all()
    SessionLocal.remove()  # 清理线程本地 Session
```

**工作原理：**

```python
# scoped_session 使用线程本地存储
import threading

# 线程1
def thread1():
    session = SessionLocal()  # 线程1的 Session
    print(id(session))

# 线程2
def thread2():
    session = SessionLocal()  # 线程2的 Session
    print(id(session))  # 不同的 Session ID

t1 = threading.Thread(target=thread1)
t2 = threading.Thread(target=thread2)
t1.start()
t2.start()
```

**注意事项：**
- FastAPI 是异步框架，不需要 scoped_session
- scoped_session 适用于传统的多线程 Web 框架（如 Flask）

---

## 技巧2：使用 Session 事件监听器

### 问题

**如何在 Session 操作前后执行自定义逻辑？**

### 解决方案

**使用 SQLAlchemy 的事件系统监听 Session 事件。**

```python
from sqlalchemy import event

# 监听 Session 创建
@event.listens_for(Session, "after_begin")
def receive_after_begin(session, transaction, connection):
    print(f"Transaction started: {transaction}")

# 监听 commit 前
@event.listens_for(Session, "before_commit")
def receive_before_commit(session):
    print(f"About to commit: {len(session.new)} new, {len(session.dirty)} dirty")

# 监听 commit 后
@event.listens_for(Session, "after_commit")
def receive_after_commit(session):
    print("Transaction committed")

# 监听 rollback
@event.listens_for(Session, "after_rollback")
def receive_after_rollback(session):
    print("Transaction rolled back")
```

**实际应用：审计日志**

```python
from datetime import datetime

@event.listens_for(Session, "before_commit")
def audit_changes(session):
    for obj in session.new:
        # 记录新增对象
        AuditLog.create(
            action="INSERT",
            table=obj.__tablename__,
            object_id=obj.id,
            timestamp=datetime.utcnow(),
        )

    for obj in session.dirty:
        # 记录修改对象
        AuditLog.create(
            action="UPDATE",
            table=obj.__tablename__,
            object_id=obj.id,
            changes=get_changes(obj),
            timestamp=datetime.utcnow(),
        )

    for obj in session.deleted:
        # 记录删除对象
        AuditLog.create(
            action="DELETE",
            table=obj.__tablename__,
            object_id=obj.id,
            timestamp=datetime.utcnow(),
        )
```

---

## 技巧3：使用 Session.bulk_insert_mappings 批量插入

### 问题

**如何高效地批量插入大量数据？**

### 解决方案

**使用 bulk_insert_mappings 跳过 ORM 开销。**

```python
# 方法1：普通插入（慢）
users = [User(name=f"User{i}") for i in range(10000)]
session.add_all(users)
session.commit()
# 10000次 INSERT，每次都要创建对象

# 方法2：bulk_insert_mappings（快）
user_dicts = [{"name": f"User{i}"} for i in range(10000)]
session.bulk_insert_mappings(User, user_dicts)
session.commit()
# 批量 INSERT，跳过 ORM 开销
```

**性能对比：**

```python
import time

# 测试普通插入
start = time.time()
users = [User(name=f"User{i}") for i in range(10000)]
session.add_all(users)
session.commit()
print(f"Normal insert: {time.time() - start:.2f}s")

# 测试批量插入
start = time.time()
user_dicts = [{"name": f"User{i}"} for i in range(10000)]
session.bulk_insert_mappings(User, user_dicts)
session.commit()
print(f"Bulk insert: {time.time() - start:.2f}s")

# 结果：bulk_insert_mappings 快 5-10 倍
```

**注意事项：**
- bulk_insert_mappings 不会触发 ORM 事件
- 不会自动填充默认值（需要手动指定）
- 不会返回插入对象的 ID

---

## 技巧4：使用 Session.merge 处理分离对象

### 问题

**Session 关闭后，如何重新使用对象？**

### 解决方案

**使用 merge 将分离对象重新加入 Session。**

```python
# Session 1：查询对象
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()
    # Session 关闭，user 变成 Detached

# Session 2：重新使用对象
with SessionLocal() as session:
    # 方法1：重新查询（推荐）
    user = session.query(User).filter_by(id=1).first()

    # 方法2：使用 merge
    user = session.merge(user)  # 将分离对象重新加入 Session
    user.name = "Alice Updated"
    session.commit()
```

**merge 的工作原理：**

```python
# merge 会检查对象是否已存在
user = User(id=1, name="Alice")

with SessionLocal() as session:
    merged_user = session.merge(user)
    # 如果 id=1 的用户已存在，更新它
    # 如果不存在，插入新用户
    session.commit()
```

**应用场景：**
- 跨 Session 传递对象
- 处理 Web 表单提交的对象
- 缓存对象的更新

---

## 技巧5：使用 Session.expunge 移除对象

### 问题

**如何将对象从 Session 中移除，但不删除数据库记录？**

### 解决方案

**使用 expunge 将对象从 Session 中移除。**

```python
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()

    # 移除对象
    session.expunge(user)

    # 修改对象不会影响数据库
    user.name = "Alice Updated"
    session.commit()  # 不会更新数据库

    # user 变成 Detached 状态
    print(inspect(user).detached)  # True
```

**应用场景：**

```python
# 场景1：缓存对象
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()
    session.expunge(user)  # 移除对象
    cache.set(f"user:{user.id}", user)  # 缓存对象

# 场景2：跨 Session 传递对象
def get_user(user_id):
    with SessionLocal() as session:
        user = session.query(User).filter_by(id=user_id).first()
        session.expunge(user)  # 移除对象
        return user  # 可以在 Session 外使用

# 场景3：避免意外修改
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()
    session.expunge(user)  # 移除对象

    # 传递给不可信的代码
    untrusted_function(user)

    # 不会影响数据库
    session.commit()
```

---

## 技巧6：使用 Session.refresh 刷新对象

### 问题

**如何获取对象的最新数据？**

### 解决方案

**使用 refresh 重新从数据库加载对象。**

```python
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()
    print(user.name)  # "Alice"

    # 其他地方修改了数据库
    # UPDATE users SET name='Bob' WHERE id=1

    # 刷新对象
    session.refresh(user)
    print(user.name)  # "Bob"（最新数据）
```

**应用场景：**

```python
# 场景1：获取数据库生成的值
with SessionLocal() as session:
    user = User(name="Alice")
    session.add(user)
    session.commit()

    # 刷新对象，获取数据库生成的 ID 和时间戳
    session.refresh(user)
    print(user.id)  # 数据库生成的 ID
    print(user.created_at)  # 数据库生成的时间戳

# 场景2：处理并发修改
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()

    # 其他请求修改了用户
    # ...

    # 刷新对象，获取最新数据
    session.refresh(user)
    user.name = "Alice Updated"
    session.commit()
```

---

## 技巧7：使用 Session.execute 执行原生 SQL

### 问题

**如何在 Session 中执行原生 SQL？**

### 解决方案

**使用 execute 执行原生 SQL，同时保持事务一致性。**

```python
from sqlalchemy import text

with SessionLocal() as session:
    # 执行原生 SQL
    result = session.execute(
        text("SELECT * FROM users WHERE name = :name"),
        {"name": "Alice"}
    )
    users = result.fetchall()

    # 混合使用 ORM 和原生 SQL
    session.execute(text("UPDATE users SET name = 'Bob' WHERE id = 1"))
    user = session.query(User).filter_by(id=1).first()
    print(user.name)  # "Bob"

    session.commit()
```

**应用场景：**

```python
# 场景1：复杂查询
with SessionLocal() as session:
    result = session.execute(text("""
        SELECT u.name, COUNT(o.id) as order_count
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
        GROUP BY u.name
        HAVING COUNT(o.id) > 10
    """))
    users = result.fetchall()

# 场景2：批量更新
with SessionLocal() as session:
    session.execute(text("""
        UPDATE users
        SET status = 'inactive'
        WHERE last_login < NOW() - INTERVAL '1 year'
    """))
    session.commit()

# 场景3：数据库特定功能
with SessionLocal() as session:
    # PostgreSQL 的 COPY 命令
    session.execute(text("""
        COPY users (name, email)
        FROM '/tmp/users.csv'
        WITH (FORMAT csv, HEADER true)
    """))
    session.commit()
```

---

## 技巧8：使用 Session.get 快速查询主键

### 问题

**如何高效地通过主键查询对象？**

### 解决方案

**使用 get 方法，利用身份映射缓存。**

```python
with SessionLocal() as session:
    # 方法1：普通查询
    user = session.query(User).filter_by(id=1).first()

    # 方法2：get（推荐）
    user = session.get(User, 1)  # 更快，利用缓存
```

**性能优势：**

```python
with SessionLocal() as session:
    # 第一次查询：从数据库加载
    user1 = session.get(User, 1)

    # 第二次查询：从身份映射缓存返回
    user2 = session.get(User, 1)  # 不执行 SQL

    print(user1 is user2)  # True（同一个对象）
```

**应用场景：**

```python
# 场景1：批量查询主键
with SessionLocal() as session:
    user_ids = [1, 2, 3, 4, 5]
    users = [session.get(User, uid) for uid in user_ids]

# 场景2：关联对象查询
with SessionLocal() as session:
    order = session.get(Order, 1)
    user = session.get(User, order.user_id)  # 利用缓存
```

---

## 技巧9：使用 Session.no_autoflush 优化性能

### 问题

**如何避免查询前的自动 flush？**

### 解决方案

**使用 no_autoflush 上下文管理器。**

```python
with SessionLocal() as session:
    # 添加大量对象
    for i in range(10000):
        session.add(User(name=f"User{i}"))

    # 查询时不自动 flush
    with session.no_autoflush:
        count = session.query(User).count()
        # 不会执行 10000 次 INSERT

    # 最后一次性 flush
    session.commit()
```

**性能对比：**

```python
import time

# 方法1：自动 flush（慢）
start = time.time()
with SessionLocal() as session:
    for i in range(1000):
        session.add(User(name=f"User{i}"))
        # 每次查询都会 flush
        count = session.query(User).count()
    session.commit()
print(f"Auto flush: {time.time() - start:.2f}s")

# 方法2：禁用 autoflush（快）
start = time.time()
with SessionLocal() as session:
    with session.no_autoflush:
        for i in range(1000):
            session.add(User(name=f"User{i}"))
            count = session.query(User).count()
    session.commit()
print(f"No autoflush: {time.time() - start:.2f}s")
```

---

## 技巧10：使用 Session.identity_map 调试对象状态

### 问题

**如何查看 Session 中的所有对象？**

### 解决方案

**使用 identity_map 查看身份映射。**

```python
with SessionLocal() as session:
    user1 = session.query(User).filter_by(id=1).first()
    user2 = session.query(User).filter_by(id=2).first()

    # 查看身份映射
    print(session.identity_map)
    # {(User, (1,)): <User id=1>, (User, (2,)): <User id=2>}

    # 查看所有对象
    for key, obj in session.identity_map.items():
        print(f"{key}: {obj}")
```

**应用场景：**

```python
# 场景1：调试内存泄漏
with SessionLocal() as session:
    # 查询大量数据
    users = session.query(User).all()

    # 检查身份映射大小
    print(f"Identity map size: {len(session.identity_map)}")

    # 如果太大，考虑使用 expunge_all
    if len(session.identity_map) > 10000:
        session.expunge_all()

# 场景2：检查对象是否在 Session 中
with SessionLocal() as session:
    user = User(id=1, name="Alice")

    # 检查对象是否在 Session 中
    key = (User, (1,))
    if key in session.identity_map:
        print("User is in session")
```

---

## 技巧11：使用 Session.begin_nested 实现嵌套事务

### 问题

**如何在事务中创建保存点？**

### 解决方案

**使用 begin_nested 创建嵌套事务（SAVEPOINT）。**

```python
with SessionLocal() as session:
    # 外层事务
    user1 = User(name="Alice")
    session.add(user1)

    # 嵌套事务（SAVEPOINT）
    with session.begin_nested():
        user2 = User(name="Bob")
        session.add(user2)

        # 嵌套事务回滚
        session.rollback()  # 只回滚 Bob

    # 外层事务提交
    session.commit()  # Alice 被保存，Bob 被回滚
```

**应用场景：**

```python
# 场景1：部分回滚
with SessionLocal() as session:
    # 创建用户
    user = User(name="Alice")
    session.add(user)
    session.flush()

    # 尝试创建订单
    try:
        with session.begin_nested():
            order = Order(user_id=user.id, amount=100)
            session.add(order)

            # 验证失败
            if order.amount > user.balance:
                raise ValueError("Insufficient balance")

            session.commit()
    except ValueError:
        # 回滚订单，但保留用户
        session.rollback()

    # 提交用户
    session.commit()

# 场景2：批量操作的部分失败
with SessionLocal() as session:
    for data in batch_data:
        try:
            with session.begin_nested():
                user = User(**data)
                session.add(user)
                session.commit()
        except Exception as e:
            # 跳过失败的记录
            session.rollback()
            print(f"Failed to insert {data}: {e}")

    # 提交成功的记录
    session.commit()
```

---

## 技巧12：使用 Session.connection 获取底层连接

### 问题

**如何获取 Session 使用的数据库连接？**

### 解决方案

**使用 connection 方法获取底层连接。**

```python
with SessionLocal() as session:
    # 获取底层连接
    conn = session.connection()

    # 使用连接执行原生 SQL
    result = conn.execute(text("SELECT version()"))
    print(result.fetchone())

    # 使用连接的特定功能
    cursor = conn.connection.cursor()
    cursor.execute("SELECT * FROM users")
    rows = cursor.fetchall()
```

**应用场景：**

```python
# 场景1：使用数据库特定功能
with SessionLocal() as session:
    conn = session.connection()

    # PostgreSQL 的 COPY 命令
    with conn.connection.cursor() as cursor:
        with open('/tmp/users.csv', 'r') as f:
            cursor.copy_expert(
                "COPY users (name, email) FROM STDIN WITH CSV HEADER",
                f
            )

    session.commit()

# 场景2：设置连接参数
with SessionLocal() as session:
    conn = session.connection()

    # 设置事务隔离级别
    conn.execute(text("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE"))

    # 执行操作
    user = session.query(User).filter_by(id=1).first()
    user.name = "Alice"
    session.commit()
```

---

## 总结

**Session 管理的进阶技巧：**

1. **scoped_session**：线程安全的 Session
2. **事件监听器**：在 Session 操作前后执行自定义逻辑
3. **bulk_insert_mappings**：高效批量插入
4. **merge**：处理分离对象
5. **expunge**：移除对象但不删除记录
6. **refresh**：刷新对象获取最新数据
7. **execute**：执行原生 SQL
8. **get**：快速查询主键，利用缓存
9. **no_autoflush**：优化性能
10. **identity_map**：调试对象状态
11. **begin_nested**：嵌套事务和保存点
12. **connection**：获取底层连接

**最佳实践：**
- 使用依赖注入管理 Session 生命周期
- 使用上下文管理器确保 Session 关闭
- 使用事件监听器实现审计日志
- 使用 bulk 操作提升性能
- 使用 merge 处理跨 Session 对象
- 使用 no_autoflush 优化批量操作

---

**记住：** Session 是强大的工具，掌握这些技巧可以写出更高效、更可靠的代码。
