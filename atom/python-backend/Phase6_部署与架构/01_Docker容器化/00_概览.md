# Docker容器化 - 学习概览

## 为什么 AI Agent API 需要容器化？

在开发 AI Agent 后端时，你可能遇到过这些问题：

**问题1：环境不一致**
```bash
# 开发环境
$ python --version
Python 3.13.1

# 生产环境
$ python --version
Python 3.11.0

# 结果：代码在开发环境正常，生产环境报错
```

**问题2：依赖管理混乱**
```bash
# 本地安装了很多全局包
$ pip list | wc -l
247

# 哪些是项目真正需要的？
# 如何确保生产环境安装了所有依赖？
```

**问题3：部署复杂**
```bash
# 每次部署都要手动执行一堆命令
$ ssh server
$ cd /app
$ git pull
$ source .venv/bin/activate
$ pip install -r requirements.txt
$ systemctl restart app
# 容易出错，难以回滚
```

**Docker 容器化解决了这些问题：**
- ✅ **环境一致性**：开发、测试、生产环境完全相同
- ✅ **依赖隔离**：每个应用有独立的依赖环境
- ✅ **快速部署**：一条命令启动应用
- ✅ **易于回滚**：镜像版本化，随时回退
- ✅ **资源隔离**：限制 CPU、内存使用
- ✅ **可移植性**：在任何支持 Docker 的平台运行

---

## Docker 在 AI Agent 开发中的作用

### 1. 开发阶段

**统一开发环境：**
```dockerfile
FROM python:3.13-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["uvicorn", "app.main:app", "--reload"]
```

团队成员只需：
```bash
docker build -t my-agent-api .
docker run -p 8000:8000 my-agent-api
```

### 2. 测试阶段

**隔离测试环境：**
```yaml
# docker-compose.test.yml
services:
  api:
    build: .
    environment:
      - DATABASE_URL=postgresql://test:test@db:5432/test
  db:
    image: postgres:14-alpine
```

### 3. 生产阶段

**生产级部署：**
```dockerfile
# 多阶段构建，优化镜像体积
FROM python:3.13-slim AS builder
RUN pip install uv
COPY pyproject.toml uv.lock ./
RUN uv sync --frozen

FROM python:3.13-slim
COPY --from=builder /app/.venv /app/.venv
# 非 root 用户运行
USER appuser
# 健康检查
HEALTHCHECK CMD curl -f http://localhost:8000/health
```

---

## 学习路线图

### 阶段1：基础入门（核心概念1-3）

**目标：** 能编写基础 Dockerfile 并运行容器

**学习内容：**
1. **Dockerfile 语法与最佳实践**
   - FROM、RUN、COPY、CMD 等指令
   - 层缓存机制
   - .dockerignore 文件

2. **多阶段构建与镜像优化**
   - Builder + Runtime 模式
   - 镜像体积优化
   - 基础镜像选择

3. **容器网络与数据持久化**
   - 端口映射
   - Volume 数据卷
   - 容器间通信

**实战项目：** 基础 FastAPI Dockerfile

### 阶段2：进阶优化（核心概念4-5）

**目标：** 编写生产级 Dockerfile

**学习内容：**
4. **安全最佳实践**
   - 非 root 用户
   - Secrets 管理
   - 镜像扫描

5. **健康检查与资源限制**
   - HEALTHCHECK 指令
   - CPU/内存限制
   - 优雅关闭

**实战项目：** 生产级 Dockerfile

### 阶段3：实战应用（实战代码）

**目标：** 容器化完整 AI Agent API

**实战场景：**
1. 基础 FastAPI Dockerfile
2. 多阶段构建优化
3. 生产级 Dockerfile
4. 完整 AI Agent API 容器化（API + PostgreSQL + Redis）

---

## 快速开始

### 前置要求

```bash
# 1. 安装 Docker
# macOS
brew install docker

# 验证安装
docker --version
# Docker version 24.0.0

# 2. 启动 Docker Desktop
open -a Docker
```

### 5分钟上手

**步骤1：创建项目**
```bash
mkdir my-agent-api && cd my-agent-api
```

**步骤2：创建 FastAPI 应用**
```python
# app/main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello from Docker!"}

@app.get("/health")
async def health():
    return {"status": "healthy"}
```

**步骤3：创建依赖文件**
```txt
# requirements.txt
fastapi==0.109.0
uvicorn[standard]==0.27.0
```

**步骤4：创建 Dockerfile**
```dockerfile
FROM python:3.13-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**步骤5：构建和运行**
```bash
# 构建镜像
docker build -t my-agent-api .

# 运行容器
docker run -p 8000:8000 my-agent-api

# 测试
curl http://localhost:8000
# {"message":"Hello from Docker!"}
```

**恭喜！** 你已经成功容器化了第一个 FastAPI 应用。

---

## 核心概念速览

### 1. Docker 镜像（Image）

**类比：** 前端的 npm package / 日常的菜谱

镜像是应用的**只读模板**，包含：
- 操作系统基础
- 应用代码
- 依赖库
- 配置文件

```bash
# 查看本地镜像
docker images

# 拉取镜像
docker pull python:3.13-slim

# 构建镜像
docker build -t my-app:v1.0 .
```

### 2. Docker 容器（Container）

**类比：** 前端的沙箱环境 / 日常的集装箱

容器是镜像的**运行实例**，特点：
- 隔离的进程空间
- 独立的文件系统
- 可以启动、停止、删除

```bash
# 运行容器
docker run -d -p 8000:8000 my-app:v1.0

# 查看运行中的容器
docker ps

# 停止容器
docker stop <container-id>
```

### 3. Dockerfile

**类比：** 前端的 webpack.config.js / 日常的装修图纸

Dockerfile 是构建镜像的**指令脚本**：
```dockerfile
# 基础镜像
FROM python:3.13-slim

# 工作目录
WORKDIR /app

# 复制文件
COPY requirements.txt .

# 安装依赖
RUN pip install -r requirements.txt

# 复制应用代码
COPY . .

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0"]
```

### 4. 多阶段构建

**类比：** Webpack 打包优化 / 日常的流水线生产

分离构建和运行环境，减小镜像体积：
```dockerfile
# 构建阶段
FROM python:3.13-slim AS builder
RUN pip install uv
COPY pyproject.toml uv.lock ./
RUN uv sync --frozen

# 运行阶段
FROM python:3.13-slim
COPY --from=builder /app/.venv /app/.venv
COPY . .
CMD ["uvicorn", "app.main:app"]
```

**效果：** 镜像体积从 1GB 优化到 200MB

### 5. docker-compose

**类比：** package.json scripts / 日常的乐高积木

编排多个容器：
```yaml
version: '3.8'
services:
  api:
    build: .
    ports:
      - "8000:8000"
    depends_on:
      - db
  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_PASSWORD=secret
```

一条命令启动所有服务：
```bash
docker-compose up -d
```

---

## 常见问题

### Q1: Docker 和虚拟机有什么区别？

**虚拟机：**
- 完整的操作系统
- 启动慢（分钟级）
- 资源占用大（GB级）

**Docker 容器：**
- 共享宿主机内核
- 启动快（秒级）
- 资源占用小（MB级）

**类比：** 虚拟机像租整套房子，Docker 像租单间。

### Q2: 容器内的数据会丢失吗？

**默认情况：** 会丢失

容器删除后，内部数据会丢失。

**解决方案：** 使用 Volume 持久化数据

```bash
# 创建 Volume
docker volume create postgres_data

# 挂载 Volume
docker run -v postgres_data:/var/lib/postgresql/data postgres:14
```

### Q3: 如何调试容器内的应用？

**方法1：查看日志**
```bash
docker logs <container-id>
docker logs -f <container-id>  # 实时查看
```

**方法2：进入容器**
```bash
docker exec -it <container-id> bash
```

**方法3：端口映射**
```bash
# 映射调试端口
docker run -p 8000:8000 -p 5678:5678 my-app
```

### Q4: 镜像体积太大怎么办？

**优化策略：**
1. 使用 alpine 基础镜像
2. 多阶段构建
3. 合并 RUN 指令
4. 清理缓存文件
5. 使用 .dockerignore

**示例：**
```dockerfile
# 优化前：1.2GB
FROM python:3.13
COPY . .
RUN pip install -r requirements.txt

# 优化后：200MB
FROM python:3.13-slim AS builder
RUN pip install uv
COPY pyproject.toml uv.lock ./
RUN uv sync --frozen --no-dev

FROM python:3.13-slim
COPY --from=builder /app/.venv /app/.venv
COPY app/ app/
```

### Q5: 如何管理环境变量？

**方法1：命令行传递**
```bash
docker run -e DATABASE_URL=postgresql://... my-app
```

**方法2：.env 文件**
```bash
docker run --env-file .env my-app
```

**方法3：docker-compose**
```yaml
services:
  api:
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
```

**安全提示：** 不要在 Dockerfile 中硬编码敏感信息！

---

## 学习检查清单

完成本知识点学习后，你应该能够：

**基础能力：**
- [ ] 理解 Docker 镜像和容器的区别
- [ ] 编写基础 Dockerfile
- [ ] 构建和运行 Docker 镜像
- [ ] 使用端口映射访问容器服务
- [ ] 使用 Volume 持久化数据

**进阶能力：**
- [ ] 使用多阶段构建优化镜像体积
- [ ] 配置健康检查
- [ ] 使用非 root 用户运行容器
- [ ] 编写 docker-compose.yml 编排多容器
- [ ] 调试容器内的应用

**生产能力：**
- [ ] 编写生产级 Dockerfile
- [ ] 配置资源限制
- [ ] 实现优雅关闭
- [ ] 扫描镜像安全漏洞
- [ ] 容器化完整 AI Agent API

---

## 下一步学习

完成本知识点后，建议学习：

1. **docker-compose 编排**（Phase6_部署与架构/02）
   - 多容器应用编排
   - 服务依赖管理
   - 网络配置

2. **环境变量管理**（Phase6_部署与架构/03）
   - 配置管理策略
   - Secrets 管理
   - 多环境配置

3. **健康检查端点**（Phase6_部署与架构/04）
   - 健康检查设计
   - 就绪探针
   - 存活探针

4. **优雅关闭**（Phase6_部署与架构/05）
   - 信号处理
   - 连接清理
   - 数据一致性

---

## 参考资源

**官方文档：**
- [Docker 官方文档](https://docs.docker.com/)
- [Dockerfile 最佳实践](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
- [Docker Compose 文档](https://docs.docker.com/compose/)

**推荐阅读：**
- [FastAPI in Containers - Docker](https://fastapi.tiangolo.com/deployment/docker/)
- [Python Docker 最佳实践](https://pythonspeed.com/docker/)

**工具：**
- [dive](https://github.com/wagoodman/dive) - 镜像层分析工具
- [hadolint](https://github.com/hadolint/hadolint) - Dockerfile 语法检查
- [trivy](https://github.com/aquasecurity/trivy) - 镜像安全扫描

---

**版本：** v1.0
**最后更新：** 2026-02-12
**适用于：** Python 3.13+ / FastAPI / AI Agent 后端开发
