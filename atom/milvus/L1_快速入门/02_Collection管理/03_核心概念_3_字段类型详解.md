# Collection管理 - 核心概念3：字段类型详解

> 全面掌握 Milvus 2.6 的向量字段和标量字段类型，选择最适合的类型优化性能和成本

---

## 字段类型概览

Milvus 2.6 支持两大类字段类型：
1. **向量字段**：存储向量数据，用于相似度检索
2. **标量字段**：存储元数据，用于过滤和展示

**Milvus 2.6 新增类型：**
- FLOAT16_VECTOR / BFLOAT16_VECTOR（低精度向量）
- ARRAY（数组类型）
- 增强 JSON（支持 JSON Path Index）

---

## 向量字段类型

### 1. FLOAT_VECTOR（标准精度）

**定义：** 32位浮点数向量，标准精度

```python
from pymilvus import FieldSchema, DataType

vector_field = FieldSchema(
    name="vector",
    dtype=DataType.FLOAT_VECTOR,
    dim=768  # 向量维度
)
```

**特性：**
- 精度：100%（无损）
- 存储：4 字节/维度
- 768维向量：3072 字节
- 适用场景：高精度要求（金融、医疗）

### 2. FLOAT16_VECTOR（半精度）

**定义：** 16位半精度浮点数向量

```python
vector_field_f16 = FieldSchema(
    name="vector",
    dtype=DataType.FLOAT16_VECTOR,
    dim=768
)
```

**特性：**
- 精度：99%+（轻微损失）
- 存储：2 字节/维度（节省 50%）
- 768维向量：1536 字节
- 适用场景：一般应用（文档检索、推荐系统）

**性能对比：**
```python
# 场景：100M 向量，768 维

# FLOAT_VECTOR
# 存储：100M * 768 * 4 = 307 GB
# 成本：$$$

# FLOAT16_VECTOR
# 存储：100M * 768 * 2 = 154 GB（节省 50%）
# 成本：$$（推荐）
# 召回率影响：<1%
```

### 3. BFLOAT16_VECTOR（脑浮点）

**定义：** 16位脑浮点数向量

```python
vector_field_bf16 = FieldSchema(
    name="vector",
    dtype=DataType.BFLOAT16_VECTOR,
    dim=768
)
```

**特性：**
- 精度：98%+（可接受损失）
- 存储：2 字节/维度（节省 50%）
- 训练兼容格式
- 适用场景：超大规模（>100M 向量）

### 4. BINARY_VECTOR（二进制向量）

**定义：** 二进制向量（0/1）

```python
binary_field = FieldSchema(
    name="binary_vector",
    dtype=DataType.BINARY_VECTOR,
    dim=128  # 必须是 8 的倍数
)
```

**特性：**
- 存储：1 bit/维度
- 极致压缩
- 适用场景：图像哈希、指纹识别

### 向量类型选择指南

| 类型 | 字节/维 | 768维存储 | 精度 | 适用场景 |
|------|---------|----------|------|---------|
| FLOAT_VECTOR | 4 | 3072 字节 | 100% | 高精度（金融、医疗） |
| FLOAT16_VECTOR | 2 | 1536 字节 | 99%+ | 一般应用（推荐） |
| BFLOAT16_VECTOR | 2 | 1536 字节 | 98%+ | 超大规模 |
| BINARY_VECTOR | 0.125 | 96 字节 | N/A | 图像哈希 |

---

## 标量字段类型

### 1. 整数类型

```python
# INT8（-128 到 127）
FieldSchema(name="age", dtype=DataType.INT8)

# INT16（-32768 到 32767）
FieldSchema(name="year", dtype=DataType.INT16)

# INT32
FieldSchema(name="count", dtype=DataType.INT32)

# INT64（推荐用于主键和时间戳）
FieldSchema(name="timestamp", dtype=DataType.INT64)
```

**使用建议：**
- 主键：INT64
- 时间戳：INT64
- 计数器：INT32
- 小范围值：INT8/INT16

### 2. 浮点类型

```python
# FLOAT（32位）
FieldSchema(name="score", dtype=DataType.FLOAT)

# DOUBLE（64位）
FieldSchema(name="price", dtype=DataType.DOUBLE)
```

**使用场景：**
- 评分、权重：FLOAT
- 高精度计算：DOUBLE

### 3. 字符串类型

```python
# VARCHAR（可变长度字符串）
FieldSchema(
    name="text",
    dtype=DataType.VARCHAR,
    max_length=512  # 必须指定最大长度
)
```

**长度选择：**
- 短文本（标签、分类）：64-128
- 中等文本（摘要）：256-512
- 长文本（文档内容）：1024-2048

### 4. 布尔类型

```python
# BOOL
FieldSchema(name="is_public", dtype=DataType.BOOL)
```

### 5. JSON 类型（Milvus 2.6 增强）

```python
# JSON（灵活元数据）
FieldSchema(name="metadata", dtype=DataType.JSON)

# 插入数据
data = {
    "metadata": {
        "author": "张三",
        "tags": ["AI", "ML"],
        "created_at": "2026-02-21",
        "version": 1
    }
}

# JSON Path Index（Milvus 2.6）
collection.create_index(
    field_name="metadata",
    index_params={
        "index_type": "JSON_PATH_INDEX",
        "params": {
            "json_path": "$.category",
            "json_cast_type": "VARCHAR"
        }
    }
)
```

**JSON 优势：**
- 灵活存储复杂元数据
- 支持嵌套结构
- 支持 JSON Path Index（高效查询）

### 6. ARRAY 类型（Milvus 2.6 新增）

```python
# ARRAY（数组）
FieldSchema(
    name="tags",
    dtype=DataType.ARRAY,
    element_type=DataType.VARCHAR,
    max_capacity=100  # 最大元素数
)

# 插入数据
data = {
    "tags": ["AI", "ML", "DL", "NLP"]
}
```

**ARRAY 特性：**
- 元素类型必须一致
- 必须指定最大容量
- 适用场景：标签列表、分类列表

---

## 字段类型选择最佳实践

### 1. 向量类型选择决策树

```
需要高精度？（金融、医疗）
├─ 是 → FLOAT_VECTOR (32-bit)
└─ 否 → 数据量大？（>10M 向量）
    ├─ 是 → BFLOAT16_VECTOR (16-bit, 节省 50%)
    └─ 否 → FLOAT16_VECTOR (16-bit, 节省 50%)
```

### 2. 主键类型选择

```python
# ✅ 推荐：INT64 + auto_id
FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True)

# ✅ 可选：VARCHAR（已有唯一标识）
FieldSchema(name="doc_id", dtype=DataType.VARCHAR, max_length=64, is_primary=True)
```

### 3. 元数据存储策略

**使用 JSON 存储灵活元数据：**
```python
# ✅ 推荐：JSON 字段
FieldSchema(name="metadata", dtype=DataType.JSON)

# ❌ 不推荐：为每个元数据创建单独字段
FieldSchema(name="author", dtype=DataType.VARCHAR, max_length=64)
FieldSchema(name="tag1", dtype=DataType.VARCHAR, max_length=32)
FieldSchema(name="tag2", dtype=DataType.VARCHAR, max_length=32)
```

### 4. 标签存储策略

**使用 ARRAY 存储多值字段：**
```python
# ✅ 推荐：ARRAY 字段
FieldSchema(
    name="tags",
    dtype=DataType.ARRAY,
    element_type=DataType.VARCHAR,
    max_capacity=50
)

# ❌ 不推荐：多个单独字段
FieldSchema(name="tag1", dtype=DataType.VARCHAR, max_length=32)
FieldSchema(name="tag2", dtype=DataType.VARCHAR, max_length=32)
```

---

## RAG 应用的字段类型选择

### 场景1：基础文档问答

```python
fields = [
    # 主键
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    
    # 文档内容
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=512),
    
    # 向量（使用 FLOAT16 节省成本）
    FieldSchema(name="vector", dtype=DataType.FLOAT16_VECTOR, dim=768),
    
    # 元数据
    FieldSchema(name="source", dtype=DataType.VARCHAR, max_length=128),
    FieldSchema(name="timestamp", dtype=DataType.INT64)
]
```

### 场景2：多模态检索

```python
fields = [
    # 主键
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    
    # 文本向量（FLOAT16）
    FieldSchema(name="text_vector", dtype=DataType.FLOAT16_VECTOR, dim=768),
    
    # 图像向量（FLOAT16）
    FieldSchema(name="image_vector", dtype=DataType.FLOAT16_VECTOR, dim=512),
    
    # 元数据（JSON）
    FieldSchema(name="metadata", dtype=DataType.JSON)
]
```

### 场景3：企业知识库

```python
fields = [
    # 主键
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    
    # 文档内容
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=2048),
    
    # 向量（FLOAT16）
    FieldSchema(name="vector", dtype=DataType.FLOAT16_VECTOR, dim=1536),
    
    # 分类
    FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=64),
    
    # 标签（ARRAY）
    FieldSchema(name="tags", dtype=DataType.ARRAY, element_type=DataType.VARCHAR, max_capacity=50),
    
    # 元数据（JSON）
    FieldSchema(name="metadata", dtype=DataType.JSON)
]
```

---

## 性能与成本优化

### 1. 向量类型对成本的影响

**案例：100M 向量，768 维**

| 向量类型 | 存储大小 | 成本 | 精度损失 | 推荐场景 |
|---------|---------|------|---------|---------|
| FLOAT_VECTOR | 307 GB | $$$ | 0% | 高精度要求 |
| FLOAT16_VECTOR | 154 GB | $$ | <1% | 一般应用（推荐） |
| BFLOAT16_VECTOR | 154 GB | $$ | 1-2% | 超大规模 |

**成本节省计算：**
```python
# FLOAT_VECTOR
storage_float32 = 100_000_000 * 768 * 4  # 307 GB
cost_float32 = storage_float32 * 0.001  # 假设 $0.001/GB/月

# FLOAT16_VECTOR
storage_float16 = 100_000_000 * 768 * 2  # 154 GB
cost_float16 = storage_float16 * 0.001

savings = cost_float32 - cost_float16  # 节省 50%
print(f"每月节省: ${savings:.2f}")
```

### 2. 字段数量对性能的影响

**建议：**
- 字段数量：<20 个
- 向量字段：1-4 个
- 标量字段：根据需要，但避免过多

**优化策略：**
- 使用 JSON 字段合并多个元数据
- 使用 ARRAY 字段合并多值数据
- 避免创建不必要的字段

---

## 常见错误与解决方案

### 错误1：VARCHAR 未指定 max_length

```python
# ❌ 错误
FieldSchema(name="text", dtype=DataType.VARCHAR)

# ✅ 正确
FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=512)
```

### 错误2：ARRAY 未指定 element_type

```python
# ❌ 错误
FieldSchema(name="tags", dtype=DataType.ARRAY)

# ✅ 正确
FieldSchema(
    name="tags",
    dtype=DataType.ARRAY,
    element_type=DataType.VARCHAR,
    max_capacity=100
)
```

### 错误3：向量维度为 0

```python
# ❌ 错误
FieldSchema(name="vector", dtype=DataType.FLOAT_VECTOR, dim=0)

# ✅ 正确
FieldSchema(name="vector", dtype=DataType.FLOAT_VECTOR, dim=768)
```

### 错误4：BINARY_VECTOR 维度不是 8 的倍数

```python
# ❌ 错误
FieldSchema(name="binary_vector", dtype=DataType.BINARY_VECTOR, dim=100)

# ✅ 正确
FieldSchema(name="binary_vector", dtype=DataType.BINARY_VECTOR, dim=128)
```

---

## 学习检查

完成本节学习后，你应该能够：

- [ ] 理解四种向量类型的特性和适用场景
- [ ] 选择合适的向量类型优化成本
- [ ] 使用 JSON 字段存储灵活元数据
- [ ] 使用 ARRAY 字段存储多值数据
- [ ] 为 RAG 应用选择合适的字段类型
- [ ] 避免常见的字段定义错误
- [ ] 理解字段类型对性能和成本的影响

---

## 下一步

- **实战代码**：[07_实战代码_场景1_基础Collection创建](./07_实战代码_场景1_基础Collection创建.md)
- **实战代码**：[07_实战代码_场景2_高级Schema设计](./07_实战代码_场景2_高级Schema设计.md)
- **返回导航**：[00_概览](./00_概览.md)
