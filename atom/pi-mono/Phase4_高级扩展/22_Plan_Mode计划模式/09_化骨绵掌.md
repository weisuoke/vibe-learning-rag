# 化骨绵掌

> **核心理念：** 10 张知识卡片，每张 2 分钟速记，快速复习 Plan Mode 的所有核心概念。

---

## 卡片 1：Plan Mode 本质（2 分钟）

### 核心要点

**Plan Mode 是什么？**
- 不是内置功能，是一种模式
- 通过扩展实现
- 三种实现方式：文件式、扩展式、Session 集成式

**为什么不是内置功能？**
- 极简哲学：核心保持简单
- 可观察性：文件优先
- 用户控制：用户决定工作流
- 可组合性：扩展自由组合

**关键公式：**
```
Plan Mode = 文件存储 + Extension API + Session 管理
```

### 速记口诀

> "不是功能是模式，扩展实现三方式，文件扩展加 Session，极简可观用户控"

### 快速检查

- [ ] 理解 Plan Mode 不是内置功能
- [ ] 知道三种实现方式
- [ ] 理解极简哲学的核心

---

## 卡片 2：三种实现方式对比（2 分钟）

### 核心要点

| 方式 | 复杂度 | 优势 | 适用场景 |
|------|--------|------|----------|
| **文件式** | 低 | 最简单、最可观察 | 快速原型 |
| **扩展式** | 中 | 最佳用户体验 | 频繁使用 |
| **Session 集成** | 高 | 状态持久化 | 复杂项目 |

**选择决策树：**
```
需要频繁使用？
├─ 否 → 文件式
└─ 是 → 需要历史追踪？
    ├─ 否 → 扩展式
    └─ 是 → Session 集成
```

### 速记口诀

> "简单文件快原型，扩展命令频使用，Session 集成复杂项，根据需求选方式"

### 快速检查

- [ ] 能说出三种方式的优劣
- [ ] 能根据场景选择方式
- [ ] 理解可以混合使用

---

## 卡片 3：文件式规划（2 分钟）

### 核心要点

**最简实现（10 行代码）：**
```typescript
async function createPlan(api: ExtensionAPI, goal: string) {
  const planFile = '.pi/plan.md';
  const content = `# Plan: ${goal}\n\n## Tasks\n\n- [ ] Task 1\n`;
  await api.tools.write(planFile, content);
  return planFile;
}
```

**优势：**
- ✅ 最简单：只需 10 行代码
- ✅ 最可观察：文件可直接查看
- ✅ 最灵活：可手动编辑

**劣势：**
- ❌ 无 UI 集成
- ❌ 无快捷键
- ❌ 无状态管理

### 速记口诀

> "十行代码创计划，文件存储最直观，手动编辑很灵活，适合原型和简单"

### 快速检查

- [ ] 能写出 10 行代码实现
- [ ] 理解文件优先的价值
- [ ] 知道适用场景

---

## 卡片 4：扩展式规划（2 分钟）

### 核心要点

**核心代码（30 行）：**
```typescript
api.registerCommand({
  name: 'plan',
  handler: async (args) => {
    await api.setState({ mode: 'plan' });
    api.disableTools(['write', 'edit']);
    return 'Entered plan mode';
  }
});

api.registerCommand({
  name: 'execute',
  handler: async () => {
    await api.setState({ mode: 'execute' });
    api.enableTools(['write', 'edit']);
    return 'Exited plan mode';
  }
});
```

**核心 API：**
- `registerCommand()` - 注册命令
- `setState()` / `getState()` - 状态管理
- `disableTools()` / `enableTools()` - 工具控制
- `registerShortcut()` - 快捷键

### 速记口诀

> "命令注册加状态，工具控制快捷键，UI 集成体验好，频繁使用最合适"

### 快速检查

- [ ] 能写出基本扩展代码
- [ ] 理解核心 API 用途
- [ ] 知道如何注册命令

---

## 卡片 5：Session 集成式（2 分钟）

### 核心要点

**核心代码（40 行）：**
```typescript
// 创建 Session
const session = await api.createSession({
  labels: ['planning', 'active'],
  state: { mode: 'plan', task },
  readOnly: true
});

// 添加日志
await api.addSessionEntry(session.id, {
  type: 'system',
  content: 'Entered plan mode',
  timestamp: Date.now()
});

// 切换 Session
await api.switchSession(session.id);
```

**核心概念：**
- **Session**：状态容器，自动持久化
- **CustomEntry**：日志记录，历史追踪
- **Labels**：多维度分类，灵活查询
- **分支**：实验不同方案

### 速记口诀

> "Session 容器管状态，CustomEntry 记日志，Labels 标签多维度，分支实验不同案"

### 快速检查

- [ ] 理解 Session 的作用
- [ ] 知道如何添加日志
- [ ] 理解分支的价值

---

## 卡片 6：核心 API 速查（2 分钟）

### 核心要点

**命令注册：**
```typescript
api.registerCommand({ name: 'plan', handler: async (args) => {} });
```

**状态管理：**
```typescript
await api.setState({ mode: 'plan' });
const state = api.getState();
```

**工具控制：**
```typescript
api.disableTools(['write', 'edit']);
api.enableTools(['write', 'edit']);
```

**事件处理：**
```typescript
api.on('plan:entered', (data) => {});
api.emit('plan:entered', { task });
```

**Session 管理：**
```typescript
const session = await api.createSession({ labels: ['planning'] });
await api.switchSession(session.id);
```

### 速记口诀

> "命令状态工具控，事件 Session 全掌握，五大 API 记心中，扩展开发不用愁"

### 快速检查

- [ ] 能默写 5 个核心 API
- [ ] 理解每个 API 的用途
- [ ] 知道何时使用哪个 API

---

## 卡片 7：设计哲学（2 分钟）

### 核心要点

**四大哲学：**

1. **极简主义（Minimalism）**
   - 核心保持简单
   - 复杂性在扩展中

2. **可观察性（Observability）**
   - 文件优先
   - 状态可见

3. **用户控制（User Control）**
   - 用户决定工作流
   - 而非代理自动化

4. **可组合性（Composability）**
   - 原语自由组合
   - 创造无限可能

**核心权衡：**
- 可观察性 > 性能
- 安全性 > 便利性
- 用户控制 > 自动化
- 简单 + 可组合 > 复杂

### 速记口诀

> "极简可观用户控，可组合性是核心，权衡取舍要记牢，哲学指导实践行"

### 快速检查

- [ ] 能说出四大哲学
- [ ] 理解核心权衡
- [ ] 能用哲学指导实践

---

## 卡片 8：反直觉点（2 分钟）

### 核心要点

**10 个反直觉点：**

1. 没有内置 Plan Mode 反而更好
2. 文件优先比内存优先更好
3. 禁用工具比启用工具更安全
4. 简单扩展比复杂功能更强大
5. 用户控制比代理自动化更重要
6. Markdown 比 JSON 更适合规划
7. Session 分支比单一 Session 更灵活
8. 事件驱动比直接调用更解耦
9. Labels 比状态字段更灵活
10. 扩展热重载比重启更高效

**核心洞察：**
- 原语 > 功能
- 可观察性 > 性能
- 安全性 > 便利性
- 解耦 > 简单

### 速记口诀

> "十个反直觉，颠覆传统观，理解背后理，设计更高明"

### 快速检查

- [ ] 能说出 5 个反直觉点
- [ ] 理解为什么反直觉
- [ ] 能解释背后的原因

---

## 卡片 9：最佳实践（2 分钟）

### 核心要点

**7 个最佳实践：**

1. **文件命名规范**
   ```typescript
   const planId = `plan-${Date.now()}-${slug}`;
   ```

2. **状态验证**
   ```typescript
   if (!isInPlanMode(api)) return '⚠️  Not in plan mode';
   ```

3. **错误处理**
   ```typescript
   try { /* ... */ } catch (error) { return `❌ Failed: ${error.message}`; }
   ```

4. **日志记录**
   ```typescript
   logger.info('Operation started');
   logger.error('Operation failed', error);
   ```

5. **事件驱动**
   ```typescript
   eventEmitter.emit('plan:created', { planId });
   ```

6. **模块化设计**
   ```
   core/ - 核心模块
   commands/ - 命令实现
   utils/ - 工具函数
   ```

7. **定期清理**
   ```typescript
   // 归档 30 天前的 Session
   ```

### 速记口诀

> "命名验证错误处，日志事件模块化，定期清理不能忘，七个实践保质量"

### 快速检查

- [ ] 能说出 7 个最佳实践
- [ ] 理解每个实践的原因
- [ ] 能在项目中应用

---

## 卡片 10：完整工作流（2 分钟）

### 核心要点

**完整 Plan Mode 工作流：**

```
1. 进入规划模式
   > /plan Implement auth system
   ├─ 创建计划文件
   ├─ 创建 Session
   ├─ 更新状态
   ├─ 禁用写入工具
   └─ 触发事件

2. 规划阶段
   ├─ 只读探索代码库
   ├─ 分析需求
   ├─ 设计架构
   ├─ 创建任务列表
   └─ 编辑计划文件

3. 批准计划
   ├─ 审查计划
   ├─ 更新标签
   └─ 记录日志

4. 退出规划模式
   > /execute
   ├─ 创建执行 Session
   ├─ 更新状态
   ├─ 启用写入工具
   └─ 触发事件

5. 执行阶段
   ├─ 按计划执行
   ├─ 修改代码
   ├─ 运行测试
   └─ 提交变更
```

### 速记口诀

> "进入规划禁写入，只读探索做分析，批准计划再执行，启用工具改代码"

### 快速检查

- [ ] 能说出完整工作流
- [ ] 理解每个阶段的作用
- [ ] 能在实际项目中应用

---

## 总结：20 分钟速记清单

### 必记知识点

**基础概念（4 分钟）：**
- [ ] Plan Mode 是模式，不是功能
- [ ] 三种实现方式：文件式、扩展式、Session 集成式
- [ ] 极简哲学：核心简单，扩展丰富

**核心 API（4 分钟）：**
- [ ] registerCommand() - 命令注册
- [ ] setState() / getState() - 状态管理
- [ ] disableTools() / enableTools() - 工具控制
- [ ] on() / emit() - 事件处理
- [ ] createSession() / switchSession() - Session 管理

**设计哲学（4 分钟）：**
- [ ] 极简主义：核心保持简单
- [ ] 可观察性：文件优先
- [ ] 用户控制：用户决定工作流
- [ ] 可组合性：原语自由组合

**反直觉点（4 分钟）：**
- [ ] 没有内置 Plan Mode 反而更好
- [ ] 文件优先比内存优先更好
- [ ] 用户控制比代理自动化更重要

**最佳实践（4 分钟）：**
- [ ] 文件命名规范
- [ ] 状态验证
- [ ] 错误处理
- [ ] 日志记录
- [ ] 事件驱动
- [ ] 模块化设计
- [ ] 定期清理

---

## 快速复习策略

### 第一遍（20 分钟）

按顺序阅读所有 10 张卡片，每张 2 分钟。

### 第二遍（10 分钟）

只看"速记口诀"和"快速检查"，测试记忆。

### 第三遍（5 分钟）

只看"核心要点"，快速回顾。

### 考前 5 分钟

只看"总结：20 分钟速记清单"，最后检查。

---

## 记忆技巧

### 技巧 1：口诀记忆

每张卡片都有速记口诀，朗读 3 遍即可记住。

### 技巧 2：对比记忆

三种实现方式对比记忆，更容易记住差异。

### 技巧 3：实践记忆

动手写一遍代码，记忆更深刻。

### 技巧 4：联想记忆

将 Plan Mode 类比到日常生活，更容易理解。

---

## 常见错误

### 错误 1：认为 Plan Mode 是内置功能

**正确理解：** Plan Mode 是一种模式，通过扩展实现。

### 错误 2：只用一种实现方式

**正确理解：** 可以混合使用三种方式，发挥各自优势。

### 错误 3：忽略可观察性

**正确理解：** 文件优先是核心哲学，不要为了性能牺牲可观察性。

### 错误 4：过度自动化

**正确理解：** 用户控制比代理自动化更重要。

### 错误 5：忽略错误处理

**正确理解：** 所有操作都要有错误处理和日志记录。

---

## 面试准备

### 必答题（5 个）

1. 为什么 pi-mono 不提供内置 Plan Mode？
2. Plan Mode 的三种实现方式各有什么优劣？
3. Extension API 的核心方法有哪些？
4. Session 和普通状态管理有什么区别？
5. Plan Mode 的最佳实践有哪些？

### 加分题（5 个）

1. 如何实现 Plan Mode 的工具控制？
2. Plan Mode 的事件系统如何设计？
3. 如何实现 Plan Mode 的状态持久化？
4. 为什么文件优先比内存优先更好？
5. 如何选择 Plan Mode 的实现方式？

---

## 实战检查清单

### 文件式规划

- [ ] 能写出 10 行代码实现
- [ ] 理解文件存储的优势
- [ ] 知道如何用 Git 追踪变化

### 扩展式规划

- [ ] 能创建完整扩展
- [ ] 能注册 /plan 和 /execute 命令
- [ ] 能添加快捷键
- [ ] 能实现状态管理

### Session 集成式

- [ ] 能创建 Session
- [ ] 能添加 CustomEntry 日志
- [ ] 能使用 Labels 管理状态
- [ ] 能创建分支实验

### 完整实现

- [ ] 能结合三种方式
- [ ] 能实现模块化设计
- [ ] 能添加错误处理和日志
- [ ] 能实现事件系统

---

## 参考资源

### 官方资源

- [Pi-mono GitHub](https://github.com/badlogic/pi-mono)
- [Extension API Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md)
- [Mario's Blog](https://mariozechner.at/posts/2025-11-30-pi-coding-agent)

### 本文档其他章节

- **01_30字核心.md**：快速理解核心概念
- **02_第一性原理.md**：深入理解设计哲学
- **03_核心概念_*.md**：学习技术细节
- **07_实战代码_*.md**：查看完整代码示例
- **08_面试必问.md**：准备面试

### 研究资料

- `temp/01_grok_llm_planning_architecture.md` - LLM 规划系统架构
- `temp/02_grok_ai_agent_patterns.md` - AI 代理任务规划模式
- `temp/03_grok_pi_mono_extensions.md` - Pi-mono 扩展 API
- `temp/04_grok_pi_mono_examples.md` - Pi-mono 扩展示例
- `temp/05_grok_ai_coding_workflow.md` - AI 编码工作流
- `temp/06_grok_oh_my_pi.md` - Oh-my-pi 实现

---

## 最后提醒

### 学习建议

1. **先理解哲学**：理解为什么这样设计
2. **再学习 API**：掌握核心 API 用法
3. **然后实践**：动手写代码
4. **最后总结**：用自己的话总结

### 复习建议

1. **第一天**：完整学习所有内容
2. **第三天**：复习 10 张卡片
3. **第七天**：复习速记口诀
4. **考前**：复习快速检查清单

### 实践建议

1. **从简单开始**：先实现文件式规划
2. **逐步深入**：再实现扩展式规划
3. **最后挑战**：实现 Session 集成式
4. **综合应用**：实现完整 Plan Mode

---

**记住：** Plan Mode 不是功能，是模式。理解哲学，掌握原语，灵活组合，创造无限可能！

---

**版本：** v1.0
**最后更新：** 2026-02-21
**维护者：** Claude Code
