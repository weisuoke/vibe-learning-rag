# 核心概念 05：系统命令

> 深入理解 Pi 的 5 个系统命令：/settings、/copy、/export、/reload、/hotkeys

---

## 概念定义

**Pi 的系统命令提供配置管理（/settings）、内容操作（/copy、/export）、扩展管理（/reload）和快捷键查看（/hotkeys）功能，支持运行时配置和热重载。**

---

## 命令 1：/settings - 打开设置界面

### 语法

```bash
/settings
```

### 功能

打开交互式设置界面，配置 Pi 的行为。

### 可配置项

```typescript
// Pi 设置结构
interface PiSettings {
  // 默认模型
  defaultModel: string;

  // Scoped models（快速切换）
  scopedModels: string[];

  // 编辑器设置
  editor: {
    multilineKey: 'shift+enter' | 'ctrl+enter';
    tabCompletion: boolean;
    autoIndent: boolean;
    wordWrap: boolean;
  };

  // 快捷键绑定
  keybindings: {
    modelSelector: string;      // 默认 Ctrl+L
    cycleModelForward: string;   // 默认 Ctrl+P
    cycleModelBackward: string;  // 默认 Shift+Ctrl+P
    toggleOutput: string;        // 默认 Ctrl+O
    clearEditor: string;         // 默认 Ctrl+C
  };

  // 显示设置
  display: {
    theme: 'light' | 'dark' | 'auto';
    fontSize: number;
    lineNumbers: boolean;
    syntaxHighlighting: boolean;
  };

  // 会话设置
  session: {
    autoSave: boolean;
    autoCompact: boolean;
    compactThreshold: number;  // Token 数量阈值
  };

  // 工具设置
  tools: {
    maxFileSize: number;        // 文件大小限制
    maxOutputSize: number;      // 命令输出限制
    commandTimeout: number;     // 命令超时时间
  };
}
```

### 实现原理

```typescript
// 设置管理器
class SettingsManager {
  private settings: PiSettings;
  private settingsFile: string;

  constructor() {
    this.settingsFile = path.join(os.homedir(), '.pi', 'settings.json');
    this.settings = this.loadSettings();
  }

  async openSettingsUI(): Promise<void> {
    // 1. 显示当前设置
    console.log('Current Settings:');
    console.log(JSON.stringify(this.settings, null, 2));

    // 2. 交互式编辑
    const answers = await inquirer.prompt([
      {
        type: 'input',
        name: 'defaultModel',
        message: 'Default model:',
        default: this.settings.defaultModel
      },
      {
        type: 'input',
        name: 'scopedModels',
        message: 'Scoped models (comma-separated):',
        default: this.settings.scopedModels.join(', ')
      },
      {
        type: 'list',
        name: 'multilineKey',
        message: 'Multiline input key:',
        choices: ['shift+enter', 'ctrl+enter'],
        default: this.settings.editor.multilineKey
      },
      {
        type: 'confirm',
        name: 'tabCompletion',
        message: 'Enable tab completion:',
        default: this.settings.editor.tabCompletion
      },
      {
        type: 'list',
        name: 'theme',
        message: 'Theme:',
        choices: ['light', 'dark', 'auto'],
        default: this.settings.display.theme
      },
      {
        type: 'confirm',
        name: 'autoSave',
        message: 'Auto-save sessions:',
        default: this.settings.session.autoSave
      },
      {
        type: 'confirm',
        name: 'autoCompact',
        message: 'Auto-compact sessions:',
        default: this.settings.session.autoCompact
      },
      {
        type: 'number',
        name: 'compactThreshold',
        message: 'Compact threshold (tokens):',
        default: this.settings.session.compactThreshold
      }
    ]);

    // 3. 更新设置
    this.updateSettings(answers);

    // 4. 保存到文件
    await this.saveSettings();

    // 5. 应用设置
    await this.applySettings();

    console.log('Settings updated successfully!');
  }

  private loadSettings(): PiSettings {
    if (fs.existsSync(this.settingsFile)) {
      return JSON.parse(fs.readFileSync(this.settingsFile, 'utf-8'));
    }

    // 返回默认设置
    return this.getDefaultSettings();
  }

  private async saveSettings(): Promise<void> {
    await fs.writeFile(
      this.settingsFile,
      JSON.stringify(this.settings, null, 2)
    );
  }

  private async applySettings(): Promise<void> {
    // 应用编辑器设置
    editor.setMultilineKey(this.settings.editor.multilineKey);
    editor.setTabCompletion(this.settings.editor.tabCompletion);

    // 应用显示设置
    display.setTheme(this.settings.display.theme);
    display.setFontSize(this.settings.display.fontSize);

    // 应用快捷键
    keybindings.update(this.settings.keybindings);
  }
}
```

### 配置文件位置

```bash
# 全局设置
~/.pi/settings.json

# 项目设置（优先级更高）
.pi/settings.json
```

### 配置示例

```json
{
  "defaultModel": "claude-opus-4",
  "scopedModels": [
    "claude-opus-4",
    "claude-sonnet-4",
    "claude-haiku-4"
  ],
  "editor": {
    "multilineKey": "shift+enter",
    "tabCompletion": true,
    "autoIndent": true,
    "wordWrap": true
  },
  "keybindings": {
    "modelSelector": "ctrl+l",
    "cycleModelForward": "ctrl+p",
    "cycleModelBackward": "shift+ctrl+p",
    "toggleOutput": "ctrl+o",
    "clearEditor": "ctrl+c"
  },
  "display": {
    "theme": "dark",
    "fontSize": 14,
    "lineNumbers": true,
    "syntaxHighlighting": true
  },
  "session": {
    "autoSave": true,
    "autoCompact": true,
    "compactThreshold": 100000
  },
  "tools": {
    "maxFileSize": 102400,
    "maxOutputSize": 10240,
    "commandTimeout": 30000
  }
}
```

---

## 命令 2：/copy - 复制最后一条消息

### 语法

```bash
/copy
```

### 功能

将最后一条 AI 响应复制到剪贴板。

### 实现原理

```typescript
// 复制命令
class CopyCommand {
  async execute(): Promise<void> {
    // 1. 获取最后一条 AI 响应
    const lastMessage = this.getLastAssistantMessage();

    if (!lastMessage) {
      throw new Error('No assistant message to copy');
    }

    // 2. 提取内容
    let content = lastMessage.content;

    // 3. 如果包含代码块，提取代码
    const codeBlocks = this.extractCodeBlocks(content);

    if (codeBlocks.length > 0) {
      // 如果只有一个代码块，直接复制代码
      if (codeBlocks.length === 1) {
        content = codeBlocks[0].code;
      } else {
        // 多个代码块，让用户选择
        content = await this.selectCodeBlock(codeBlocks);
      }
    }

    // 4. 复制到剪贴板
    await clipboard.write(content);

    console.log('Copied to clipboard!');
  }

  private getLastAssistantMessage(): Message | null {
    const messages = session.messages;

    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].role === 'assistant') {
        return messages[i];
      }
    }

    return null;
  }

  private extractCodeBlocks(content: string): CodeBlock[] {
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    const blocks: CodeBlock[] = [];
    let match;

    while ((match = codeBlockRegex.exec(content)) !== null) {
      blocks.push({
        language: match[1] || 'text',
        code: match[2].trim()
      });
    }

    return blocks;
  }

  private async selectCodeBlock(blocks: CodeBlock[]): Promise<string> {
    const choices = blocks.map((block, i) => ({
      name: `${block.language} (${block.code.split('\n').length} lines)`,
      value: block.code
    }));

    choices.push({
      name: 'Full message',
      value: 'full'
    });

    const answer = await inquirer.prompt([{
      type: 'list',
      name: 'block',
      message: 'Select content to copy:',
      choices: choices
    }]);

    return answer.block === 'full' ? content : answer.block;
  }
}
```

### 使用场景

```bash
# 场景 1：复制代码
> 请写一个 TypeScript 函数计算斐波那契数列
AI: [生成代码]
> /copy
Copied to clipboard!
# 粘贴到编辑器

# 场景 2：复制解释
> 请解释 async/await 的工作原理
AI: [详细解释]
> /copy
Copied to clipboard!
# 粘贴到文档

# 场景 3：多个代码块
> 请给出前端和后端的实现
AI: [前端代码] [后端代码]
> /copy
Select content to copy:
> TypeScript (50 lines)
  Python (30 lines)
  Full message
```

---

## 命令 3：/export - 导出会话

### 语法

```bash
/export [filename]
```

### 功能

将当前会话导出为 HTML 文件。

### 实现原理

```typescript
// 导出命令
class ExportCommand {
  async execute(filename?: string): Promise<void> {
    // 1. 确定文件名
    if (!filename) {
      filename = `${session.name}-${Date.now()}.html`;
    }

    // 2. 生成 HTML
    const html = this.generateHTML(session);

    // 3. 写入文件
    await fs.writeFile(filename, html);

    console.log(`Exported to: ${filename}`);
  }

  private generateHTML(session: Session): string {
    return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${session.name}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .header {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .message {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 10px;
    }
    .user {
      border-left: 4px solid #0066cc;
    }
    .assistant {
      border-left: 4px solid #00cc66;
    }
    .role {
      font-weight: bold;
      margin-bottom: 10px;
    }
    .content {
      white-space: pre-wrap;
    }
    code {
      background: #f0f0f0;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Monaco', 'Courier New', monospace;
    }
    pre {
      background: #f0f0f0;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
    }
    .tool-call {
      background: #fff3cd;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>${session.name}</h1>
    <p>Model: ${session.model}</p>
    <p>Created: ${new Date(session.createdAt).toLocaleString()}</p>
    <p>Messages: ${session.messages.length}</p>
  </div>

  ${session.messages.map(msg => this.renderMessage(msg)).join('\n')}
</body>
</html>
    `;
  }

  private renderMessage(message: Message): string {
    const roleClass = message.role === 'user' ? 'user' : 'assistant';
    const roleLabel = message.role === 'user' ? 'You' : 'AI';

    let content = this.escapeHTML(message.content);
    content = this.renderMarkdown(content);

    let toolCallsHTML = '';
    if (message.toolCalls) {
      toolCallsHTML = message.toolCalls.map(tc => `
        <div class="tool-call">
          <strong>[Tool: ${tc.name}]</strong>
          <pre>${this.escapeHTML(JSON.stringify(tc.args, null, 2))}</pre>
          <strong>Result:</strong>
          <pre>${this.escapeHTML(tc.result)}</pre>
        </div>
      `).join('');
    }

    return `
      <div class="message ${roleClass}">
        <div class="role">${roleLabel}</div>
        <div class="content">${content}</div>
        ${toolCallsHTML}
      </div>
    `;
  }

  private renderMarkdown(content: string): string {
    // 简单的 Markdown 渲染
    // 代码块
    content = content.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
      return `<pre><code class="language-${lang || 'text'}">${this.escapeHTML(code)}</code></pre>`;
    });

    // 行内代码
    content = content.replace(/`([^`]+)`/g, '<code>$1</code>');

    // 粗体
    content = content.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

    // 斜体
    content = content.replace(/\*([^*]+)\*/g, '<em>$1</em>');

    return content;
  }

  private escapeHTML(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
}
```

### 使用场景

```bash
# 场景 1：保存重要对话
> /export important-discussion.html
Exported to: important-discussion.html

# 场景 2：分享给团队
> /export team-review.html
# 发送 HTML 文件给团队成员

# 场景 3：归档历史决策
> /export architecture-decisions-2026-02.html
# 归档技术决策讨论
```

---

## 命令 4：/reload - 重载扩展和技能

### 语法

```bash
/reload
```

### 功能

热重载 Extensions 和 Skills，无需重启 Pi。

### 实现原理

```typescript
// 重载命令
class ReloadCommand {
  async execute(): Promise<void> {
    console.log('Reloading extensions and skills...');

    // 1. 重载 Extensions
    await this.reloadExtensions();

    // 2. 重载 Skills
    await this.reloadSkills();

    console.log('Reload complete!');
  }

  private async reloadExtensions(): Promise<void> {
    // 1. 卸载所有 Extensions
    for (const [name, ext] of extensionManager.extensions) {
      try {
        await ext.onUnload();
        console.log(`Unloaded extension: ${name}`);
      } catch (error) {
        console.error(`Error unloading extension ${name}:`, error);
      }
    }

    extensionManager.extensions.clear();

    // 2. 清除 require 缓存
    this.clearRequireCache('.pi/extensions');

    // 3. 重新扫描 Extensions 目录
    const extensionDirs = [
      path.join(process.cwd(), '.pi', 'extensions'),
      path.join(os.homedir(), '.pi', 'extensions')
    ];

    for (const dir of extensionDirs) {
      if (!fs.existsSync(dir)) continue;

      const files = await fs.readdir(dir);

      for (const file of files) {
        if (!file.endsWith('.ts') && !file.endsWith('.js')) continue;

        const filePath = path.join(dir, file);

        try {
          // 4. 加载 Extension
          const ExtensionClass = require(filePath).default;
          const ext = new ExtensionClass();

          // 5. 初始化 Extension
          await ext.onLoad();

          extensionManager.extensions.set(ext.name, ext);
          console.log(`Loaded extension: ${ext.name}`);
        } catch (error) {
          console.error(`Error loading extension ${file}:`, error);
        }
      }
    }
  }

  private async reloadSkills(): Promise<void> {
    // 1. 清除 Skills 缓存
    skillManager.skills.clear();

    // 2. 重新扫描 Skills 目录
    const skillDirs = [
      path.join(process.cwd(), '.pi', 'skills'),
      path.join(os.homedir(), '.pi', 'skills')
    ];

    for (const dir of skillDirs) {
      if (!fs.existsSync(dir)) continue;

      const files = await fs.readdir(dir);

      for (const file of files) {
        if (!file.endsWith('.md')) continue;

        const filePath = path.join(dir, file);
        const content = await fs.readFile(filePath, 'utf-8');

        // 3. 解析 Skill
        const skill = this.parseSkill(content);

        skillManager.skills.set(skill.name, skill);
        console.log(`Loaded skill: ${skill.name}`);
      }
    }
  }

  private clearRequireCache(directory: string): void {
    const fullPath = path.resolve(directory);

    for (const key of Object.keys(require.cache)) {
      if (key.startsWith(fullPath)) {
        delete require.cache[key];
      }
    }
  }
}
```

### 使用场景

```bash
# 场景 1：开发 Extension
# 修改 Extension 代码
$ vim .pi/extensions/my-tool.ts

# 在 pi 中重载
> /reload
Unloaded extension: my-tool
Loaded extension: my-tool
Reload complete!

# 测试修改
> 请使用 my-tool

# 场景 2：添加新 Skill
$ cat > .pi/skills/code-review.md << 'EOF'
---
name: code-review
description: Code review workflow
---
...
EOF

> /reload
Loaded skill: code-review
Reload complete!

# 场景 3：更新 Extension
# 从 GitHub 拉取最新版本
$ cd .pi/extensions
$ git pull

> /reload
# 所有 Extensions 重新加载
```

---

## 命令 5：/hotkeys - 查看快捷键

### 语法

```bash
/hotkeys
```

### 功能

显示所有可用的快捷键。

### 实现原理

```typescript
// 快捷键命令
class HotkeysCommand {
  execute(): void {
    const hotkeys = this.getHotkeys();

    console.log('Pi Keyboard Shortcuts:\n');

    for (const [category, keys] of Object.entries(hotkeys)) {
      console.log(chalk.bold(`${category}:`));

      for (const key of keys) {
        console.log(`  ${chalk.cyan(key.shortcut.padEnd(20))} ${key.description}`);
      }

      console.log('');
    }
  }

  private getHotkeys(): Record<string, Hotkey[]> {
    return {
      'Model Management': [
        { shortcut: 'Ctrl+L', description: 'Open model selector' },
        { shortcut: 'Ctrl+P', description: 'Cycle to next scoped model' },
        { shortcut: 'Shift+Ctrl+P', description: 'Cycle to previous scoped model' },
        { shortcut: 'Shift+Tab', description: 'Cycle thinking level' }
      ],

      'Editor': [
        { shortcut: 'Shift+Enter', description: 'New line (macOS/Linux)' },
        { shortcut: 'Ctrl+Enter', description: 'New line (Windows)' },
        { shortcut: 'Tab', description: 'Trigger file completion' },
        { shortcut: 'Ctrl+C', description: 'Clear editor (press twice to quit)' },
        { shortcut: 'Escape', description: 'Cancel current operation' }
      ],

      'Output Control': [
        { shortcut: 'Ctrl+O', description: 'Fold/unfold tool output' },
        { shortcut: 'Ctrl+T', description: 'Fold/unfold thinking blocks' }
      ],

      'Navigation': [
        { shortcut: 'Up/Down', description: 'Navigate command history' },
        { shortcut: 'Page Up/Down', description: 'Scroll conversation' },
        { shortcut: 'Home/End', description: 'Jump to start/end' }
      ]
    };
  }
}
```

### 输出示例

```
Pi Keyboard Shortcuts:

Model Management:
  Ctrl+L               Open model selector
  Ctrl+P               Cycle to next scoped model
  Shift+Ctrl+P         Cycle to previous scoped model
  Shift+Tab            Cycle thinking level

Editor:
  Shift+Enter          New line (macOS/Linux)
  Ctrl+Enter           New line (Windows)
  Tab                  Trigger file completion
  Ctrl+C               Clear editor (press twice to quit)
  Escape               Cancel current operation

Output Control:
  Ctrl+O               Fold/unfold tool output
  Ctrl+T               Fold/unfold thinking blocks

Navigation:
  Up/Down              Navigate command history
  Page Up/Down         Scroll conversation
  Home/End             Jump to start/end
```

---

## 系统命令最佳实践

### 实践 1：定期检查设置

```bash
# 每次开始新项目时
> /settings
# 确认默认模型和 Scoped models 配置

# 调整 Compaction 阈值
compactThreshold: 100000  # 100K tokens
```

---

### 实践 2：使用 /copy 提高效率

```bash
# 生成代码后立即复制
> 请写一个 React 组件
AI: [生成代码]
> /copy
# 粘贴到编辑器，无需手动选择

# 复制特定代码块
> 请给出前端和后端实现
AI: [前端代码] [后端代码]
> /copy
# 选择需要的代码块
```

---

### 实践 3：导出重要讨论

```bash
# 技术决策讨论
> /export architecture-decision-2026-02-18.html

# 代码审查记录
> /export code-review-auth-module.html

# 学习笔记
> /export learning-notes-typescript.html
```

---

### 实践 4：快速迭代 Extensions

```bash
# 开发流程
1. 修改 Extension 代码
2. /reload
3. 测试
4. 重复 1-3

# 无需重启 Pi，保持会话上下文
```

---

## 快速参考

```typescript
// 系统命令
interface SystemCommands {
  // 配置管理
  settings: '/settings',          // 打开设置界面

  // 内容操作
  copy: '/copy',                  // 复制最后一条消息
  export: '/export [filename]',   // 导出会话为 HTML

  // 扩展管理
  reload: '/reload',              // 重载 Extensions 和 Skills

  // 帮助
  hotkeys: '/hotkeys',            // 查看快捷键
  changelog: '/changelog',        // 查看更新日志
  quit: '/quit | /exit',          // 退出 Pi
}

// 配置文件
interface ConfigFiles {
  globalSettings: '~/.pi/settings.json',
  projectSettings: '.pi/settings.json',
  models: '~/.pi/models.json',
  auth: '~/.pi/auth.json',
}
```

---

**来源：**
- [Pi Coding Agent README](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/README.md) - 2026-02
- [Commands 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/README.md#commands) - 2026-02
- [Settings 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/settings.md) - 2026-02
- [Keybindings 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/keybindings.md) - 2026-02
