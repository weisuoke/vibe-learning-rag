# 最小可用

掌握以下内容，就能开始进行 Milvus 分布式优化：

## 4.1 理解 Milvus 分布式架构的三层结构

**核心概念**：Milvus 采用存储计算分离的分布式架构

```
访问层（Proxy）
    ↓
协调层（Coordinator）
    ↓
执行层（Worker Nodes）
    ↓
存储层（Object Storage + Meta Storage）
```

**关键组件**：
- **Proxy**：接收客户端请求，路由到对应的 Worker
- **Coordinator**：管理元数据和任务调度（RootCoord、DataCoord、QueryCoord）
- **Worker Nodes**：执行实际的数据操作（DataNode、QueryNode、IndexNode）
- **Storage**：持久化数据（MinIO/S3 + etcd）

**为什么重要**：
- 理解架构才能知道优化哪些环节
- 不同组件的瓶颈不同，需要针对性优化

```python
from pymilvus import connections, utility

# 连接到 Milvus 集群
connections.connect(
    alias="default",
    host="localhost",
    port="19530"
)

# 查看集群拓扑
print("=== Milvus 集群信息 ===")
print(f"版本: {utility.get_server_version()}")

# 在生产环境中，你可以通过 Milvus 的 metrics 接口查看详细的节点信息
# http://localhost:9091/metrics
```

---

## 4.2 配置负载均衡策略

**核心概念**：让每个 QueryNode 的工作量尽可能均衡

**最简单的配置**：使用 Milvus 的默认负载均衡策略

```yaml
# milvus.yaml
queryCoord:
  balanceIntervalSeconds: 60  # 每60秒检查一次负载均衡
  overloadedMemoryThresholdPercentage: 90  # 内存使用超过90%触发均衡

queryNode:
  gracefulStopTimeout: 30  # 优雅停机时间（秒）
```

**Python 代码验证负载均衡**：

```python
from pymilvus import Collection, connections
import time

connections.connect(alias="default", host="localhost", port="19530")

# 创建 Collection
collection = Collection("load_balance_test")

# 加载 Collection 到内存
collection.load()

# 查询多次，观察负载分布
for i in range(10):
    results = collection.search(
        data=[[0.1] * 128],
        anns_field="embedding",
        param={"metric_type": "L2", "params": {"nprobe": 10}},
        limit=10
    )
    print(f"查询 {i+1} 完成")
    time.sleep(0.5)

# 在生产环境中，通过 Prometheus 监控各个 QueryNode 的 CPU/内存使用情况
# 如果负载均衡生效，各节点的资源使用应该相近
```

**这个配置足以**：
- 避免某些节点过载而其他节点空闲
- 在节点故障时自动重新分配负载
- 支持动态扩缩容

---

## 4.3 启用网络压缩

**核心概念**：减少节点间传输的数据量

**最简单的配置**：启用 gRPC 压缩

```yaml
# milvus.yaml
grpc:
  client:
    compressionEnabled: true  # 启用客户端压缩
  server:
    compressionEnabled: true  # 启用服务端压缩
```

**效果**：
- 向量数据传输量减少 50-70%
- 网络带宽占用降低
- 对于高维向量（> 512维）效果更明显

**Python 代码验证**：

```python
from pymilvus import Collection, connections
import time

connections.connect(alias="default", host="localhost", port="19530")

collection = Collection("network_test")
collection.load()

# 查询大量数据，观察网络流量
start_time = time.time()

results = collection.search(
    data=[[0.1] * 1024] * 100,  # 100个查询，每个1024维
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=100  # 每个查询返回100个结果
)

elapsed = time.time() - start_time
print(f"查询耗时: {elapsed:.2f}秒")

# 启用压缩后，相同查询的网络传输时间应该明显减少
# 可以通过 tcpdump 或 Wireshark 抓包验证
```

---

## 4.4 调整内存缓存大小

**核心概念**：增大缓存可以减少磁盘 I/O，加速查询

**最简单的配置**：根据可用内存调整缓存

```yaml
# milvus.yaml
queryNode:
  cache:
    enabled: true
    memoryLimit: 10737418240  # 10GB（根据实际内存调整）
```

**经验法则**：
- 缓存大小 = 可用内存的 50-70%
- 至少预留 2GB 给系统和其他进程
- 如果内存充足，可以将所有热数据加载到内存

**Python 代码验证**：

```python
from pymilvus import Collection, connections
import time

connections.connect(alias="default", host="localhost", port="19530")

collection = Collection("cache_test")
collection.load()

# 第一次查询（冷启动，从磁盘加载）
start_time = time.time()
results = collection.search(
    data=[[0.1] * 128],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10
)
cold_time = time.time() - start_time
print(f"冷启动查询耗时: {cold_time:.3f}秒")

# 第二次查询（缓存命中）
start_time = time.time()
results = collection.search(
    data=[[0.1] * 128],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10
)
hot_time = time.time() - start_time
print(f"缓存命中查询耗时: {hot_time:.3f}秒")

print(f"性能提升: {cold_time / hot_time:.1f}x")
# 缓存命中后，查询速度通常提升 5-10 倍
```

---

## 4.5 配置合理的副本数

**核心概念**：副本数影响可用性和性能

**最简单的配置**：根据 SLA 要求选择副本数

```python
from pymilvus import Collection, connections

connections.connect(alias="default", host="localhost", port="19530")

collection = Collection("replica_test")

# 设置副本数
collection.load(replica_number=2)  # 2个副本

# 副本数选择：
# - 1个副本：最低成本，但单点故障
# - 2个副本：平衡可用性和成本（推荐）
# - 3个副本：高可用，但成本高
```

**副本数的影响**：

| 副本数 | 可用性 | 查询性能 | 存储成本 | 适用场景 |
|--------|--------|----------|----------|----------|
| 1 | 低（99%） | 基准 | 1x | 开发/测试 |
| 2 | 中（99.9%） | 1.5-1.8x | 2x | 生产环境（推荐） |
| 3 | 高（99.99%） | 2-2.5x | 3x | 关键业务 |

**Python 代码验证**：

```python
from pymilvus import Collection, connections
import time

connections.connect(alias="default", host="localhost", port="19530")

collection = Collection("replica_test")

# 测试不同副本数的性能
for replica_num in [1, 2, 3]:
    # 释放之前的加载
    collection.release()

    # 加载指定副本数
    collection.load(replica_number=replica_num)
    time.sleep(5)  # 等待加载完成

    # 并发查询测试
    start_time = time.time()
    for _ in range(100):
        collection.search(
            data=[[0.1] * 128],
            anns_field="embedding",
            param={"metric_type": "L2", "params": {"nprobe": 10}},
            limit=10
        )
    elapsed = time.time() - start_time

    print(f"副本数 {replica_num}: {elapsed:.2f}秒 ({100/elapsed:.1f} QPS)")

# 预期结果：副本数越多，并发查询性能越好
```

---

## 这些知识足以

掌握以上 5 个核心配置，你就能：

✅ **理解 Milvus 分布式架构**
- 知道哪些组件影响性能
- 明白优化的切入点

✅ **配置基本的负载均衡**
- 避免节点过载
- 支持自动故障转移

✅ **减少网络开销**
- 启用压缩降低带宽占用
- 加速数据传输

✅ **优化查询性能**
- 调整缓存大小
- 减少磁盘 I/O

✅ **提升系统可用性**
- 配置合理的副本数
- 平衡性能和成本

---

## 快速检查清单

在开始分布式优化前，确认以下配置：

- [ ] 已部署 Milvus 分布式集群（至少 2 个 QueryNode）
- [ ] 已启用负载均衡（`balanceIntervalSeconds > 0`）
- [ ] 已启用网络压缩（`grpc.compressionEnabled = true`）
- [ ] 已配置内存缓存（`queryNode.cache.memoryLimit > 0`）
- [ ] 已设置副本数（`replica_number >= 2`）

---

## 下一步学习

掌握最小可用知识后，可以深入学习：

1. **负载均衡策略**：一致性哈希、动态权重、热点数据处理
2. **网络优化**：连接池、超时配置、数据本地化
3. **存储优化**：WAL 配置、Compaction 策略、SSD vs HDD
4. **监控与调优**：Prometheus 指标、性能分析、瓶颈定位

**记住**：分布式优化是一个持续的过程，从最小可用配置开始，根据实际负载逐步调优。
