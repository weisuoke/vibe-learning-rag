# 核心概念3：依赖服务检查策略

> 数据库、Redis、外部API、消息队列、文件系统的健康检查策略

---

## 概述

AI Agent 后端通常依赖多个外部服务：
- **数据库**（PostgreSQL）：存储对话历史、用户数据
- **缓存**（Redis）：缓存 Embedding、会话状态
- **外部 API**（OpenAI/Anthropic）：LLM 推理
- **向量数据库**（pgvector）：语义检索
- **消息队列**（可选）：异步任务处理
- **文件系统**：日志、临时文件

本文介绍如何检查这些依赖服务的健康状态。

---

## 1. 数据库连接池健康检查

### 1.1 为什么检查数据库？

**数据库是最关键的依赖：**
- 存储用户数据、对话历史
- 失败 → 服务完全不可用
- 需要快速检测故障

### 1.2 检查策略

#### 策略1：简单连接检查

```python
async def check_database() -> bool:
    """检查数据库连接"""
    try:
        await asyncio.wait_for(
            db.execute("SELECT 1"),
            timeout=3.0
        )
        return True
    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        return False
```

**优点：** 简单快速
**缺点：** 只检查连接，不检查性能

#### 策略2：连接池状态检查

```python
from sqlalchemy.pool import Pool

async def check_database_pool() -> dict:
    """检查数据库连接池状态"""
    try:
        # 执行简单查询
        await asyncio.wait_for(
            db.execute("SELECT 1"),
            timeout=3.0
        )

        # 获取连接池状态
        pool: Pool = db.engine.pool
        pool_status = {
            "size": pool.size(),              # 连接池大小
            "checked_in": pool.checkedin(),   # 可用连接数
            "checked_out": pool.checkedout(), # 使用中的连接数
            "overflow": pool.overflow(),      # 溢出连接数
        }

        # 判断连接池是否健康
        if pool_status["checked_out"] >= pool.size() * 0.9:
            # 90% 的连接都在使用，可能过载
            logger.warning(f"Database pool near capacity: {pool_status}")

        return {
            "healthy": True,
            "pool": pool_status
        }
    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        return {
            "healthy": False,
            "error": str(e)
        }
```

**优点：** 可以检测连接池耗尽
**缺点：** 稍微复杂

#### 策略3：性能检查

```python
import time

async def check_database_performance() -> dict:
    """检查数据库性能"""
    try:
        start_time = time.time()

        # 执行简单查询
        await asyncio.wait_for(
            db.execute("SELECT 1"),
            timeout=3.0
        )

        duration = time.time() - start_time

        # 判断性能
        if duration > 1.0:
            # 查询超过 1 秒，性能下降
            logger.warning(f"Database query slow: {duration:.3f}s")
            return {
                "healthy": True,
                "degraded": True,
                "duration": duration
            }

        return {
            "healthy": True,
            "degraded": False,
            "duration": duration
        }
    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        return {
            "healthy": False,
            "error": str(e)
        }
```

### 1.3 完整实现

```python
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.pool import Pool
import asyncio
import time

class DatabaseHealthChecker:
    def __init__(self, engine):
        self.engine = engine

    async def check(self) -> dict:
        """完整的数据库健康检查"""
        try:
            start_time = time.time()

            # 1. 执行简单查询
            async with AsyncSession(self.engine) as session:
                await asyncio.wait_for(
                    session.execute("SELECT 1"),
                    timeout=3.0
                )

            duration = time.time() - start_time

            # 2. 获取连接池状态
            pool: Pool = self.engine.pool
            pool_status = {
                "size": pool.size(),
                "checked_in": pool.checkedin(),
                "checked_out": pool.checkedout(),
                "overflow": pool.overflow(),
            }

            # 3. 判断健康状态
            healthy = True
            degraded = False
            warnings = []

            # 检查性能
            if duration > 1.0:
                degraded = True
                warnings.append(f"Slow query: {duration:.3f}s")

            # 检查连接池
            if pool_status["checked_out"] >= pool.size() * 0.9:
                degraded = True
                warnings.append("Connection pool near capacity")

            return {
                "healthy": healthy,
                "degraded": degraded,
                "duration": duration,
                "pool": pool_status,
                "warnings": warnings
            }

        except asyncio.TimeoutError:
            return {
                "healthy": False,
                "error": "Database query timeout"
            }
        except Exception as e:
            return {
                "healthy": False,
                "error": str(e)
            }

# 使用
db_checker = DatabaseHealthChecker(engine)

@app.get("/ready")
async def ready():
    db_status = await db_checker.check()

    if not db_status["healthy"]:
        raise HTTPException(503, detail=db_status)

    return {"status": "ready", "database": db_status}
```

---

## 2. Redis 缓存健康检查

### 2.1 为什么检查 Redis？

**Redis 通常是可选依赖：**
- 缓存 Embedding、会话状态
- 失败 → 服务降级（不使用缓存）
- 不应该导致服务完全不可用

### 2.2 检查策略

#### 策略1：PING 命令

```python
async def check_redis() -> bool:
    """检查 Redis 连接"""
    try:
        await asyncio.wait_for(
            redis.ping(),
            timeout=3.0
        )
        return True
    except Exception as e:
        logger.error(f"Redis health check failed: {e}")
        return False
```

#### 策略2：读写测试

```python
async def check_redis_readwrite() -> dict:
    """检查 Redis 读写功能"""
    try:
        # 写入测试数据
        test_key = "health_check:test"
        test_value = "ok"

        await asyncio.wait_for(
            redis.set(test_key, test_value, ex=10),  # 10 秒过期
            timeout=3.0
        )

        # 读取测试数据
        value = await asyncio.wait_for(
            redis.get(test_key),
            timeout=3.0
        )

        if value != test_value:
            return {
                "healthy": False,
                "error": "Redis read/write mismatch"
            }

        # 删除测试数据
        await redis.delete(test_key)

        return {"healthy": True}

    except Exception as e:
        logger.error(f"Redis health check failed: {e}")
        return {
            "healthy": False,
            "error": str(e)
        }
```

#### 策略3：性能检查

```python
import time

async def check_redis_performance() -> dict:
    """检查 Redis 性能"""
    try:
        start_time = time.time()

        # PING 命令
        await asyncio.wait_for(
            redis.ping(),
            timeout=3.0
        )

        duration = time.time() - start_time

        # 判断性能
        if duration > 0.1:
            # PING 超过 100ms，性能下降
            logger.warning(f"Redis slow: {duration:.3f}s")
            return {
                "healthy": True,
                "degraded": True,
                "duration": duration
            }

        return {
            "healthy": True,
            "degraded": False,
            "duration": duration
        }

    except Exception as e:
        logger.error(f"Redis health check failed: {e}")
        return {
            "healthy": False,
            "error": str(e)
        }
```

### 2.3 完整实现

```python
import redis.asyncio as redis
import asyncio
import time

class RedisHealthChecker:
    def __init__(self, redis_client):
        self.redis = redis_client

    async def check(self) -> dict:
        """完整的 Redis 健康检查"""
        try:
            start_time = time.time()

            # 1. PING 命令
            await asyncio.wait_for(
                self.redis.ping(),
                timeout=3.0
            )

            duration = time.time() - start_time

            # 2. 获取 Redis 信息
            info = await self.redis.info()
            memory_usage = info.get("used_memory_human", "unknown")
            connected_clients = info.get("connected_clients", 0)

            # 3. 判断健康状态
            healthy = True
            degraded = False
            warnings = []

            # 检查性能
            if duration > 0.1:
                degraded = True
                warnings.append(f"Slow response: {duration:.3f}s")

            # 检查连接数
            if connected_clients > 100:
                warnings.append(f"High client count: {connected_clients}")

            return {
                "healthy": healthy,
                "degraded": degraded,
                "duration": duration,
                "memory_usage": memory_usage,
                "connected_clients": connected_clients,
                "warnings": warnings
            }

        except asyncio.TimeoutError:
            return {
                "healthy": False,
                "error": "Redis timeout"
            }
        except Exception as e:
            return {
                "healthy": False,
                "error": str(e)
            }

# 使用
redis_checker = RedisHealthChecker(redis_client)

@app.get("/ready")
async def ready():
    redis_status = await redis_checker.check()

    # Redis 失败 → 降级但可用
    if not redis_status["healthy"]:
        return {
            "status": "degraded",
            "message": "Redis unavailable, caching disabled",
            "redis": redis_status
        }

    return {"status": "ready", "redis": redis_status}
```

---

## 3. 外部 API 可用性检查

### 3.1 LLM API 健康检查

**挑战：**
- LLM API 调用慢（几秒）
- 频繁调用会消耗 token
- 可能被限流

**策略：**

#### 策略1：简单连接检查

```python
async def check_llm_api() -> bool:
    """检查 LLM API 连接"""
    try:
        # 只检查 HTTP 连接，不发送真实请求
        async with httpx.AsyncClient() as client:
            response = await asyncio.wait_for(
                client.head("https://api.openai.com"),
                timeout=3.0
            )
            return response.status_code < 500
    except Exception:
        return False
```

**优点：** 快速，不消耗 token
**缺点：** 只检查连接，不检查 API 功能

#### 策略2：最小请求检查

```python
from openai import AsyncOpenAI

async def check_llm_api_minimal() -> dict:
    """检查 LLM API（最小请求）"""
    try:
        client = AsyncOpenAI()

        # 发送最小的请求（1 token）
        response = await asyncio.wait_for(
            client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[{"role": "user", "content": "hi"}],
                max_tokens=1
            ),
            timeout=5.0
        )

        return {"healthy": True}

    except Exception as e:
        logger.error(f"LLM API health check failed: {e}")
        return {
            "healthy": False,
            "error": str(e)
        }
```

**优点：** 检查真实功能
**缺点：** 消耗 token，较慢

#### 策略3：缓存 + 长TTL

```python
from datetime import datetime, timedelta

class LLMAPIHealthChecker:
    def __init__(self):
        self.cache = {
            "status": None,
            "expires_at": datetime.min
        }

    async def check(self) -> dict:
        """检查 LLM API（缓存 5 分钟）"""
        now = datetime.now()

        # 检查缓存
        if now < self.cache["expires_at"]:
            return self.cache["status"]

        # 执行检查
        try:
            async with httpx.AsyncClient() as client:
                response = await asyncio.wait_for(
                    client.head("https://api.openai.com"),
                    timeout=3.0
                )
                status = {
                    "healthy": response.status_code < 500
                }
        except Exception as e:
            status = {
                "healthy": False,
                "error": str(e)
            }

        # 更新缓存（5 分钟）
        self.cache = {
            "status": status,
            "expires_at": now + timedelta(minutes=5)
        }

        return status
```

**推荐：** 使用策略3（缓存 + 长TTL）

---

## 4. 向量数据库检查（pgvector）

### 4.1 检查策略

```python
async def check_vector_db() -> dict:
    """检查向量数据库"""
    try:
        # 1. 检查表是否存在
        result = await db.execute("""
            SELECT EXISTS (
                SELECT FROM information_schema.tables
                WHERE table_name = 'embeddings'
            )
        """)
        table_exists = result.scalar()

        if not table_exists:
            return {
                "healthy": False,
                "error": "Embeddings table not found"
            }

        # 2. 检查向量扩展
        result = await db.execute("""
            SELECT EXISTS (
                SELECT FROM pg_extension
                WHERE extname = 'vector'
            )
        """)
        extension_exists = result.scalar()

        if not extension_exists:
            return {
                "healthy": False,
                "error": "pgvector extension not installed"
            }

        # 3. 执行简单的向量查询
        await asyncio.wait_for(
            db.execute("""
                SELECT id FROM embeddings
                ORDER BY embedding <-> '[0,0,0]'
                LIMIT 1
            """),
            timeout=3.0
        )

        return {"healthy": True}

    except Exception as e:
        logger.error(f"Vector DB health check failed: {e}")
        return {
            "healthy": False,
            "error": str(e)
        }
```

---

## 5. 消息队列健康检查

### 5.1 Celery/RQ 检查

```python
from celery import Celery

async def check_celery() -> dict:
    """检查 Celery 任务队列"""
    try:
        # 检查 Celery 连接
        celery_app = Celery()
        inspect = celery_app.control.inspect()

        # 获取活跃的 worker
        active_workers = inspect.active()

        if not active_workers:
            return {
                "healthy": False,
                "error": "No active Celery workers"
            }

        # 获取队列长度
        queue_length = await redis.llen("celery")

        if queue_length > 1000:
            return {
                "healthy": True,
                "degraded": True,
                "queue_length": queue_length,
                "warning": "Queue backlog"
            }

        return {
            "healthy": True,
            "queue_length": queue_length,
            "workers": len(active_workers)
        }

    except Exception as e:
        logger.error(f"Celery health check failed: {e}")
        return {
            "healthy": False,
            "error": str(e)
        }
```

---

## 6. 文件系统与磁盘空间检查

### 6.1 检查策略

```python
import shutil

async def check_disk_space() -> dict:
    """检查磁盘空间"""
    try:
        # 获取磁盘使用情况
        usage = shutil.disk_usage("/")

        total_gb = usage.total / (1024 ** 3)
        used_gb = usage.used / (1024 ** 3)
        free_gb = usage.free / (1024 ** 3)
        percent_used = (usage.used / usage.total) * 100

        # 判断磁盘空间
        if percent_used > 90:
            return {
                "healthy": False,
                "error": f"Disk space critical: {percent_used:.1f}% used"
            }
        elif percent_used > 80:
            return {
                "healthy": True,
                "degraded": True,
                "warning": f"Disk space low: {percent_used:.1f}% used",
                "free_gb": free_gb
            }

        return {
            "healthy": True,
            "total_gb": total_gb,
            "used_gb": used_gb,
            "free_gb": free_gb,
            "percent_used": percent_used
        }

    except Exception as e:
        logger.error(f"Disk space check failed: {e}")
        return {
            "healthy": False,
            "error": str(e)
        }
```

---

## 7. 依赖服务降级策略

### 7.1 核心依赖 vs 可选依赖

**核心依赖：** 失败 → 服务不可用
- 数据库（PostgreSQL）

**可选依赖：** 失败 → 服务降级
- Redis（缓存）
- LLM API（可以使用缓存响应）
- 向量数据库（可以禁用语义检索）

### 7.2 实现示例

```python
from enum import Enum

class HealthStatus(str, Enum):
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"

@app.get("/ready")
async def ready():
    """健康检查（支持降级）"""
    checks = {
        "database": await check_database(),      # 核心依赖
        "redis": await check_redis(),            # 可选依赖
        "llm_api": await check_llm_api(),        # 可选依赖
        "vector_db": await check_vector_db(),    # 可选依赖
    }

    # 判断整体状态
    if not checks["database"]["healthy"]:
        # 数据库失败 → 不可用
        raise HTTPException(
            status_code=503,
            detail={
                "status": HealthStatus.UNHEALTHY,
                "message": "Database unavailable",
                "checks": checks
            }
        )

    # 数据库正常，检查可选依赖
    failed_optional = []
    if not checks["redis"]["healthy"]:
        failed_optional.append("redis")
    if not checks["llm_api"]["healthy"]:
        failed_optional.append("llm_api")
    if not checks["vector_db"]["healthy"]:
        failed_optional.append("vector_db")

    if failed_optional:
        # 可选依赖失败 → 降级
        return {
            "status": HealthStatus.DEGRADED,
            "message": f"Running in degraded mode: {', '.join(failed_optional)} unavailable",
            "checks": checks
        }

    # 所有依赖正常
    return {
        "status": HealthStatus.HEALTHY,
        "checks": checks
    }
```

---

## 8. 完整的依赖检查系统

### 8.1 统一的健康检查器

```python
from typing import Dict, Callable, Any
import asyncio

class DependencyHealthChecker:
    def __init__(self):
        self.dependencies = {}
        self.cache = {}
        self.cache_ttl = {}

    def register(
        self,
        name: str,
        check_func: Callable,
        critical: bool = False,
        cache_ttl: int = 30
    ):
        """注册依赖服务"""
        self.dependencies[name] = {
            "check": check_func,
            "critical": critical
        }
        self.cache_ttl[name] = cache_ttl

    async def check_one(self, name: str) -> dict:
        """检查单个依赖（带缓存）"""
        now = time.time()

        # 检查缓存
        if name in self.cache:
            cache_entry = self.cache[name]
            if now - cache_entry["timestamp"] < self.cache_ttl[name]:
                return cache_entry["result"]

        # 执行检查
        try:
            result = await self.dependencies[name]["check"]()
        except Exception as e:
            result = {
                "healthy": False,
                "error": str(e)
            }

        # 更新缓存
        self.cache[name] = {
            "timestamp": now,
            "result": result
        }

        return result

    async def check_all(self) -> dict:
        """检查所有依赖"""
        # 并发检查
        tasks = {
            name: self.check_one(name)
            for name in self.dependencies
        }

        results = await asyncio.gather(
            *tasks.values(),
            return_exceptions=True
        )

        checks = {}
        critical_failed = False

        for name, result in zip(tasks.keys(), results):
            if isinstance(result, Exception):
                checks[name] = {
                    "healthy": False,
                    "error": str(result)
                }
            else:
                checks[name] = result

            # 检查核心依赖
            if self.dependencies[name]["critical"]:
                if not checks[name].get("healthy", False):
                    critical_failed = True

        return {
            "checks": checks,
            "critical_failed": critical_failed
        }

# 使用
health_checker = DependencyHealthChecker()

# 注册依赖
health_checker.register("database", check_database, critical=True, cache_ttl=30)
health_checker.register("redis", check_redis, critical=False, cache_ttl=60)
health_checker.register("llm_api", check_llm_api, critical=False, cache_ttl=300)
health_checker.register("vector_db", check_vector_db, critical=False, cache_ttl=60)

@app.get("/ready")
async def ready():
    result = await health_checker.check_all()

    if result["critical_failed"]:
        raise HTTPException(503, detail=result)

    # 判断是否降级
    all_healthy = all(
        check.get("healthy", False)
        for check in result["checks"].values()
    )

    status = "healthy" if all_healthy else "degraded"

    return {
        "status": status,
        "checks": result["checks"]
    }
```

---

## 总结

依赖服务检查策略的关键要点：

1. **数据库**：核心依赖，检查连接池状态和性能
2. **Redis**：可选依赖，失败时降级（不使用缓存）
3. **外部 API**：使用长TTL缓存，避免频繁调用
4. **向量数据库**：检查表和扩展是否存在
5. **消息队列**：检查 worker 和队列长度
6. **文件系统**：检查磁盘空间
7. **降级策略**：区分核心和可选依赖，支持降级运行
8. **统一管理**：使用统一的健康检查器管理所有依赖

在 AI Agent 后端中，合理的依赖检查策略可以：
- 快速检测故障
- 支持降级运行
- 避免级联故障
- 提高系统可用性
