# 最小可用知识

> **核心理念**：掌握以下 20% 的核心知识，就能解决 80% 的 Compaction 使用场景

---

## 你只需要知道这 5 件事

### 1. Compaction 何时触发？

**触发公式：**
```typescript
if (contextTokens > contextWindow - reserveTokens) {
  // 触发自动压缩
  await compactSession();
}
```

**关键参数：**
- `contextWindow`: LLM 的上下文窗口大小（如 200K tokens）
- `reserveTokens`: 预留空间（默认 16384 tokens）
- `contextTokens`: 当前对话使用的 token 数

**简单理解：**
> 就像笔记本快满了（剩余空间 < 预留空间），就自动整理旧笔记。

**实际例子：**
```typescript
// Claude Opus 4: 200K context window
// 当对话使用超过 183,616 tokens (200K - 16K) 时
// 自动触发压缩
```

---

### 2. 压缩后会保留什么？

**保留内容：**
1. **压缩摘要**：旧对话的结构化总结
2. **最近对话**：最近 `keepRecentTokens` 的消息（默认 20K tokens）
3. **文件追踪**：所有读取/修改过的文件列表

**压缩摘要格式：**
```markdown
## Summary

[对话的高层次总结]

## Key Points

- [关键点 1]
- [关键点 2]
- [关键点 3]

## Files

- Read: file1.ts, file2.ts
- Modified: file3.ts
```

**类比：**
> 就像会议纪要：保留核心决策和行动项，丢弃冗长的讨论细节。

---

### 3. 如何监控 Token 使用？

**方法 1：查看 Session 文件**
```bash
# Session 文件路径
~/.pi/sessions/<session-id>.jsonl

# 查看最后一条消息的 usage
tail -1 ~/.pi/sessions/<session-id>.jsonl | jq '.usage'
```

**方法 2：在代码中监控**
```typescript
import { getLastAssistantUsage } from '@mariozechner/pi-agent-core';

// 获取最后一次 LLM 调用的 token 使用量
const usage = getLastAssistantUsage(messages);
console.log(`Input tokens: ${usage.input_tokens}`);
console.log(`Output tokens: ${usage.output_tokens}`);
```

**方法 3：使用 Extension 监控**
```typescript
// 在 Extension 中监听压缩事件
session.on('session_before_compact', (event) => {
  console.log('即将触发压缩');
  console.log(`当前 tokens: ${event.contextTokens}`);
  console.log(`上下文窗口: ${event.contextWindow}`);
});
```

---

### 4. 何时使用手动压缩？

**使用场景：**

#### 场景 1：完成一个大任务后
```bash
# 完成一个功能开发后，手动压缩
/compact 总结刚才完成的用户认证功能开发
```

#### 场景 2：切换话题前
```bash
# 从讨论架构切换到写代码前
/compact 总结架构讨论的关键决策
```

#### 场景 3：对话变得混乱时
```bash
# 对话跑偏了，手动压缩重新聚焦
/compact 总结到目前为止的进展，忽略无关讨论
```

#### 场景 4：测试压缩效果
```bash
# 开发自定义压缩扩展时
/compact 测试自定义压缩提示词
```

**手动压缩的优势：**
- ✅ 可以指定压缩指令
- ✅ 可以控制压缩时机
- ✅ 可以测试压缩效果

---

### 5. 基础配置（可选）

**配置文件：** `.pi/settings.json`

```json
{
  "compaction": {
    "enabled": true,              // 是否启用自动压缩
    "reserveTokens": 16384,       // 预留空间（默认 16K）
    "keepRecentTokens": 20000     // 保留最近消息（默认 20K）
  }
}
```

**调整建议：**

| 场景 | reserveTokens | keepRecentTokens | 说明 |
|------|---------------|------------------|------|
| **默认** | 16384 | 20000 | 适合大多数场景 |
| **长对话** | 20000 | 30000 | 保留更多上下文 |
| **短对话** | 10000 | 15000 | 更激进的压缩 |
| **成本优化** | 8192 | 10000 | 最小化 token 使用 |

**注意：**
- `reserveTokens` 太小 → 可能频繁压缩
- `keepRecentTokens` 太大 → 压缩效果不明显
- `keepRecentTokens` 太小 → 可能丢失重要上下文

---

## 这些知识足以做什么？

掌握以上 5 个核心知识点后，你可以：

### ✅ 理解 Compaction 的工作原理
- 知道何时触发压缩
- 知道压缩后保留什么
- 知道如何监控 token 使用

### ✅ 在实际项目中使用 Compaction
- 让 Agent 进行长时间对话
- 在合适的时机手动压缩
- 根据场景调整配置

### ✅ 调试 Compaction 问题
- 监控 token 使用情况
- 检查压缩摘要质量
- 调整配置参数

### ✅ 为后续学习打基础
- 理解自动压缩触发机制（核心概念 1）
- 理解压缩策略与切点算法（核心概念 2）
- 理解手动压缩与自定义指令（核心概念 3）

---

## 快速实践

### 实践 1：观察自动压缩

```bash
# 1. 启动 pi
pi

# 2. 进行长对话（让 Agent 读取大量文件）
请读取项目中所有的 TypeScript 文件并总结

# 3. 继续对话，直到触发压缩
继续分析这些文件的依赖关系

# 4. 查看 Session 文件，观察压缩摘要
tail -20 ~/.pi/sessions/<session-id>.jsonl
```

### 实践 2：使用手动压缩

```bash
# 1. 完成一个任务
请帮我实现一个用户登录功能

# 2. 手动压缩
/compact 总结用户登录功能的实现

# 3. 开始新任务
现在请帮我实现用户注册功能
```

### 实践 3：调整配置

```bash
# 1. 创建配置文件
mkdir -p .pi
cat > .pi/settings.json << 'EOF'
{
  "compaction": {
    "enabled": true,
    "reserveTokens": 20000,
    "keepRecentTokens": 30000
  }
}
EOF

# 2. 重启 pi 使配置生效
pi

# 3. 观察压缩行为的变化
```

---

## 常见问题速查

### Q1: 如何知道压缩是否触发了？
**A:** 查看 Session 文件中是否有 `role: "summary"` 的消息。

### Q2: 压缩会丢失信息吗？
**A:** 会丢失细节，但保留关键信息。JSONL 文件保留完整历史。

### Q3: 可以禁用自动压缩吗？
**A:** 可以，在 `.pi/settings.json` 中设置 `"enabled": false`。

### Q4: 手动压缩和自动压缩有什么区别？
**A:** 手动压缩可以指定压缩指令，自动压缩使用默认提示词。

### Q5: 如何优化压缩成本？
**A:** 使用更便宜的模型（如 Gemini Flash）进行压缩（见实战代码 02）。

---

## 下一步学习

现在你已经掌握了 Compaction 的最小可用知识，可以：

1. **深入理解**：学习核心概念（03_核心概念_*.md）
2. **实战练习**：运行实战代码（07_实战代码_*.md）
3. **类比理解**：阅读双重类比（05_双重类比.md）
4. **避免误区**：学习反直觉点（06_反直觉点.md）

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
