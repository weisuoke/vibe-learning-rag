# 实战代码 场景3: 连接管理

生产环境级别的 Milvus 2.6 连接管理实战,包括连接池、重连机制、超时处理和最佳实践。

---

## 场景概述

**目标**: 实现健壮的 Milvus 连接管理,确保生产环境的稳定性和性能。

**适用场景**:
- 高并发应用
- 长时间运行的服务
- 需要自动恢复的系统
- 分布式应用

---

## 连接管理核心概念

### 连接生命周期

```
创建连接 → 使用连接 → 连接异常 → 重连 → 关闭连接
```

### 连接管理挑战

| 挑战 | 影响 | 解决方案 |
|------|------|---------|
| **连接超时** | 请求失败 | 超时重试 |
| **网络中断** | 服务不可用 | 自动重连 |
| **连接泄漏** | 资源耗尽 | 连接池管理 |
| **并发冲突** | 性能下降 | 连接池复用 |

---

## 场景1: 单例连接管理

### 实现单例模式

```python
#!/usr/bin/env python3
"""
Milvus 单例连接管理
"""

from pymilvus import MilvusClient
from typing import Optional
import threading

class MilvusConnectionManager:
    """Milvus 连接管理器 (单例模式)"""

    _instance: Optional['MilvusConnectionManager'] = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._client: Optional[MilvusClient] = None
            self._uri = "http://localhost:19530"
            self._timeout = 10.0
            self._initialized = True

    def connect(self, uri: str = None, timeout: float = None):
        """建立连接"""
        if uri:
            self._uri = uri
        if timeout:
            self._timeout = timeout

        if self._client is None:
            self._client = MilvusClient(
                uri=self._uri,
                timeout=self._timeout
            )
            print(f"✅ 连接到 Milvus: {self._uri}")

    def get_client(self) -> MilvusClient:
        """获取客户端"""
        if self._client is None:
            self.connect()
        return self._client

    def close(self):
        """关闭连接"""
        if self._client is not None:
            self._client = None
            print("✅ 连接已关闭")

# 使用示例
def example_singleton():
    """单例模式示例"""
    print("=" * 60)
    print("单例连接管理示例")
    print("=" * 60)
    print()

    # 创建第一个实例
    manager1 = MilvusConnectionManager()
    manager1.connect()

    # 创建第二个实例 (实际是同一个实例)
    manager2 = MilvusConnectionManager()

    # 验证是同一个实例
    print(f"manager1 is manager2: {manager1 is manager2}")
    print()

    # 使用客户端
    client = manager1.get_client()
    collections = client.list_collections()
    print(f"Collection 数量: {len(collections)}")
    print()

    # 关闭连接
    manager1.close()

if __name__ == "__main__":
    example_singleton()
```

---

## 场景2: 连接池管理

### 实现连接池

```python
#!/usr/bin/env python3
"""
Milvus 连接池管理
"""

from pymilvus import MilvusClient
from typing import List, Optional
import threading
import queue
import time

class MilvusConnectionPool:
    """Milvus 连接池"""

    def __init__(
        self,
        uri: str = "http://localhost:19530",
        pool_size: int = 10,
        timeout: float = 10.0
    ):
        self.uri = uri
        self.pool_size = pool_size
        self.timeout = timeout
        self._pool: queue.Queue = queue.Queue(maxsize=pool_size)
        self._lock = threading.Lock()
        self._created_connections = 0

        # 初始化连接池
        self._initialize_pool()

    def _initialize_pool(self):
        """初始化连接池"""
        for _ in range(self.pool_size):
            client = self._create_connection()
            self._pool.put(client)

    def _create_connection(self) -> MilvusClient:
        """创建新连接"""
        with self._lock:
            self._created_connections += 1
            print(f"创建连接 #{self._created_connections}")

        return MilvusClient(uri=self.uri, timeout=self.timeout)

    def get_connection(self, timeout: float = 5.0) -> MilvusClient:
        """从连接池获取连接"""
        try:
            client = self._pool.get(timeout=timeout)
            return client
        except queue.Empty:
            raise TimeoutError("连接池已满,无法获取连接")

    def return_connection(self, client: MilvusClient):
        """归还连接到连接池"""
        try:
            self._pool.put_nowait(client)
        except queue.Full:
            # 连接池已满,关闭连接
            pass

    def close_all(self):
        """关闭所有连接"""
        while not self._pool.empty():
            try:
                client = self._pool.get_nowait()
                # pymilvus 2.6 没有显式的 close 方法
                # 连接会在对象销毁时自动关闭
            except queue.Empty:
                break

        print(f"✅ 关闭所有连接 (共 {self._created_connections} 个)")

    def get_stats(self) -> dict:
        """获取连接池统计信息"""
        return {
            "pool_size": self.pool_size,
            "available": self._pool.qsize(),
            "in_use": self.pool_size - self._pool.qsize(),
            "created": self._created_connections
        }

# 使用示例
def example_connection_pool():
    """连接池示例"""
    print("=" * 60)
    print("连接池管理示例")
    print("=" * 60)
    print()

    # 创建连接池
    pool = MilvusConnectionPool(pool_size=5)
    print(f"连接池初始化完成: {pool.get_stats()}")
    print()

    # 模拟并发使用
    def worker(worker_id: int):
        """工作线程"""
        client = pool.get_connection()
        print(f"Worker {worker_id} 获取连接")

        try:
            # 执行操作
            collections = client.list_collections()
            print(f"Worker {worker_id} 查询成功: {len(collections)} 个 Collection")
            time.sleep(0.5)  # 模拟操作耗时
        finally:
            # 归还连接
            pool.return_connection(client)
            print(f"Worker {worker_id} 归还连接")

    # 创建多个线程
    threads = []
    for i in range(10):
        t = threading.Thread(target=worker, args=(i,))
        threads.append(t)
        t.start()

    # 等待所有线程完成
    for t in threads:
        t.join()

    print()
    print(f"最终统计: {pool.get_stats()}")
    print()

    # 关闭连接池
    pool.close_all()

if __name__ == "__main__":
    example_connection_pool()
```

---

## 场景3: 自动重连机制

### 实现重连装饰器

```python
#!/usr/bin/env python3
"""
Milvus 自动重连机制
"""

from pymilvus import MilvusClient
from functools import wraps
import time
from typing import Callable, Any

class MilvusClientWithRetry:
    """带重试机制的 Milvus 客户端"""

    def __init__(
        self,
        uri: str = "http://localhost:19530",
        max_retries: int = 3,
        retry_delay: float = 1.0,
        timeout: float = 10.0
    ):
        self.uri = uri
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.timeout = timeout
        self._client: Optional[MilvusClient] = None
        self._connect()

    def _connect(self):
        """建立连接"""
        self._client = MilvusClient(uri=self.uri, timeout=self.timeout)
        print(f"✅ 连接到 Milvus: {self.uri}")

    def _reconnect(self):
        """重新连接"""
        print("⚠️  尝试重新连接...")
        self._client = None
        time.sleep(self.retry_delay)
        self._connect()

    def with_retry(self, func: Callable) -> Callable:
        """重试装饰器"""
        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            last_exception = None

            for attempt in range(self.max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    print(f"❌ 尝试 {attempt + 1}/{self.max_retries} 失败: {e}")

                    if attempt < self.max_retries - 1:
                        # 重新连接
                        try:
                            self._reconnect()
                        except Exception as reconnect_error:
                            print(f"❌ 重连失败: {reconnect_error}")
                            time.sleep(self.retry_delay)
                    else:
                        print(f"❌ 达到最大重试次数,放弃")

            raise last_exception

        return wrapper

    def list_collections(self):
        """列出 Collection (带重试)"""
        @self.with_retry
        def _list_collections():
            return self._client.list_collections()

        return _list_collections()

    def search(self, collection_name: str, data: list, limit: int = 10, **kwargs):
        """检索 (带重试)"""
        @self.with_retry
        def _search():
            return self._client.search(
                collection_name=collection_name,
                data=data,
                limit=limit,
                **kwargs
            )

        return _search()

# 使用示例
def example_auto_retry():
    """自动重试示例"""
    print("=" * 60)
    print("自动重连机制示例")
    print("=" * 60)
    print()

    # 创建带重试的客户端
    client = MilvusClientWithRetry(
        uri="http://localhost:19530",
        max_retries=3,
        retry_delay=1.0
    )

    # 测试正常操作
    print("[测试 1] 正常操作:")
    collections = client.list_collections()
    print(f"✅ Collection 数量: {len(collections)}")
    print()

    # 测试重试机制 (模拟连接失败)
    print("[测试 2] 模拟连接失败:")
    # 注意: 这里只是演示,实际使用中连接失败会自动重试
    try:
        collections = client.list_collections()
        print(f"✅ Collection 数量: {len(collections)}")
    except Exception as e:
        print(f"❌ 最终失败: {e}")
    print()

if __name__ == "__main__":
    example_auto_retry()
```

---

## 场景4: 上下文管理器

### 实现上下文管理器

```python
#!/usr/bin/env python3
"""
Milvus 上下文管理器
"""

from pymilvus import MilvusClient
from typing import Optional

class MilvusConnection:
    """Milvus 连接上下文管理器"""

    def __init__(
        self,
        uri: str = "http://localhost:19530",
        timeout: float = 10.0,
        auto_close: bool = True
    ):
        self.uri = uri
        self.timeout = timeout
        self.auto_close = auto_close
        self._client: Optional[MilvusClient] = None

    def __enter__(self) -> MilvusClient:
        """进入上下文"""
        self._client = MilvusClient(uri=self.uri, timeout=self.timeout)
        print(f"✅ 连接到 Milvus: {self.uri}")
        return self._client

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文"""
        if self.auto_close and self._client is not None:
            self._client = None
            print("✅ 连接已关闭")

        # 处理异常
        if exc_type is not None:
            print(f"❌ 发生异常: {exc_type.__name__}: {exc_val}")
            return False  # 不抑制异常

        return True

# 使用示例
def example_context_manager():
    """上下文管理器示例"""
    print("=" * 60)
    print("上下文管理器示例")
    print("=" * 60)
    print()

    # 使用上下文管理器
    print("[示例 1] 正常使用:")
    with MilvusConnection() as client:
        collections = client.list_collections()
        print(f"Collection 数量: {len(collections)}")
    print()

    # 异常处理
    print("[示例 2] 异常处理:")
    try:
        with MilvusConnection() as client:
            # 模拟异常
            raise ValueError("模拟异常")
    except ValueError as e:
        print(f"捕获异常: {e}")
    print()

if __name__ == "__main__":
    example_context_manager()
```

---

## 场景5: 完整的连接管理类

### 生产级连接管理

```python
#!/usr/bin/env python3
"""
生产级 Milvus 连接管理
"""

from pymilvus import MilvusClient
from typing import Optional, Callable, Any
from functools import wraps
import threading
import time
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class ProductionMilvusClient:
    """生产级 Milvus 客户端"""

    def __init__(
        self,
        uri: str = "http://localhost:19530",
        timeout: float = 10.0,
        max_retries: int = 3,
        retry_delay: float = 1.0,
        health_check_interval: float = 60.0
    ):
        self.uri = uri
        self.timeout = timeout
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.health_check_interval = health_check_interval

        self._client: Optional[MilvusClient] = None
        self._lock = threading.Lock()
        self._last_health_check = 0.0
        self._is_healthy = False

        # 初始化连接
        self._connect()

        # 启动健康检查线程
        self._start_health_check()

    def _connect(self):
        """建立连接"""
        with self._lock:
            try:
                self._client = MilvusClient(uri=self.uri, timeout=self.timeout)
                self._is_healthy = True
                logger.info(f"连接到 Milvus: {self.uri}")
            except Exception as e:
                self._is_healthy = False
                logger.error(f"连接失败: {e}")
                raise

    def _reconnect(self):
        """重新连接"""
        logger.warning("尝试重新连接...")
        with self._lock:
            self._client = None
            time.sleep(self.retry_delay)
            self._connect()

    def _health_check(self):
        """健康检查"""
        try:
            if self._client is not None:
                self._client.list_collections()
                self._is_healthy = True
                self._last_health_check = time.time()
                logger.debug("健康检查通过")
        except Exception as e:
            self._is_healthy = False
            logger.error(f"健康检查失败: {e}")
            try:
                self._reconnect()
            except Exception as reconnect_error:
                logger.error(f"重连失败: {reconnect_error}")

    def _start_health_check(self):
        """启动健康检查线程"""
        def health_check_loop():
            while True:
                time.sleep(self.health_check_interval)
                self._health_check()

        thread = threading.Thread(target=health_check_loop, daemon=True)
        thread.start()
        logger.info("健康检查线程已启动")

    def with_retry(self, func: Callable) -> Callable:
        """重试装饰器"""
        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            last_exception = None

            for attempt in range(self.max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    logger.error(f"尝试 {attempt + 1}/{self.max_retries} 失败: {e}")

                    if attempt < self.max_retries - 1:
                        try:
                            self._reconnect()
                        except Exception as reconnect_error:
                            logger.error(f"重连失败: {reconnect_error}")
                            time.sleep(self.retry_delay)

            raise last_exception

        return wrapper

    def list_collections(self):
        """列出 Collection (带重试)"""
        @self.with_retry
        def _list_collections():
            return self._client.list_collections()

        return _list_collections()

    def search(self, collection_name: str, data: list, limit: int = 10, **kwargs):
        """检索 (带重试)"""
        @self.with_retry
        def _search():
            return self._client.search(
                collection_name=collection_name,
                data=data,
                limit=limit,
                **kwargs
            )

        return _search()

    def insert(self, collection_name: str, data: list):
        """插入数据 (带重试)"""
        @self.with_retry
        def _insert():
            return self._client.insert(
                collection_name=collection_name,
                data=data
            )

        return _insert()

    def is_healthy(self) -> bool:
        """检查连接是否健康"""
        return self._is_healthy

    def get_stats(self) -> dict:
        """获取统计信息"""
        return {
            "uri": self.uri,
            "is_healthy": self._is_healthy,
            "last_health_check": self._last_health_check,
            "health_check_interval": self.health_check_interval
        }

# 使用示例
def example_production_client():
    """生产级客户端示例"""
    print("=" * 60)
    print("生产级连接管理示例")
    print("=" * 60)
    print()

    # 创建生产级客户端
    client = ProductionMilvusClient(
        uri="http://localhost:19530",
        max_retries=3,
        retry_delay=1.0,
        health_check_interval=30.0
    )

    # 检查健康状态
    print(f"连接健康: {client.is_healthy()}")
    print(f"统计信息: {client.get_stats()}")
    print()

    # 执行操作
    try:
        collections = client.list_collections()
        print(f"✅ Collection 数量: {len(collections)}")
    except Exception as e:
        print(f"❌ 操作失败: {e}")

    # 等待一段时间,观察健康检查
    print("\n等待健康检查...")
    time.sleep(5)

    print(f"连接健康: {client.is_healthy()}")

if __name__ == "__main__":
    example_production_client()
```

---

## 最佳实践

### 1. 连接管理原则

```python
# ✅ 推荐: 单例模式
class MilvusManager:
    _instance = None

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = MilvusClient(uri="http://localhost:19530")
        return cls._instance

# ❌ 不推荐: 频繁创建连接
for i in range(100):
    client = MilvusClient(uri="http://localhost:19530")  # 浪费资源
    client.search(...)
```

### 2. 错误处理

```python
# ✅ 推荐: 细粒度异常处理
from pymilvus.exceptions import MilvusException

try:
    results = client.search(...)
except ConnectionError:
    # 处理连接错误
    logger.error("连接错误,尝试重连")
    client.reconnect()
except MilvusException as e:
    # 处理 Milvus 特定错误
    logger.error(f"Milvus 错误: {e}")
except Exception as e:
    # 处理其他错误
    logger.error(f"未知错误: {e}")

# ❌ 不推荐: 忽略异常
try:
    results = client.search(...)
except:
    pass  # 忽略异常
```

### 3. 资源清理

```python
# ✅ 推荐: 使用上下文管理器
with MilvusConnection() as client:
    results = client.search(...)
# 自动清理资源

# ❌ 不推荐: 不清理资源
client = MilvusClient(uri="http://localhost:19530")
results = client.search(...)
# 没有清理资源
```

### 4. 超时配置

```python
# ✅ 推荐: 根据场景配置超时
# 快速查询
client = MilvusClient(uri="http://localhost:19530", timeout=5.0)

# 大批量插入
client = MilvusClient(uri="http://localhost:19530", timeout=60.0)

# ❌ 不推荐: 使用默认超时
client = MilvusClient(uri="http://localhost:19530")  # 可能不适合所有场景
```

---

## 性能优化

### 连接池大小配置

```python
# 根据并发量配置连接池大小
# 公式: pool_size = concurrent_requests * 1.5

# 低并发 (< 10 QPS)
pool = MilvusConnectionPool(pool_size=5)

# 中并发 (10-100 QPS)
pool = MilvusConnectionPool(pool_size=20)

# 高并发 (> 100 QPS)
pool = MilvusConnectionPool(pool_size=50)
```

### 连接复用

```python
# ✅ 推荐: 复用连接
client = MilvusClient(uri="http://localhost:19530")

for i in range(1000):
    results = client.search(...)  # 复用同一个连接

# ❌ 不推荐: 每次创建新连接
for i in range(1000):
    client = MilvusClient(uri="http://localhost:19530")
    results = client.search(...)  # 性能差
```

---

## 监控和告警

### 连接监控指标

```python
class MilvusConnectionMonitor:
    """连接监控"""

    def __init__(self, client: ProductionMilvusClient):
        self.client = client
        self.metrics = {
            "total_requests": 0,
            "failed_requests": 0,
            "reconnections": 0,
            "avg_response_time": 0.0
        }

    def record_request(self, success: bool, response_time: float):
        """记录请求"""
        self.metrics["total_requests"] += 1
        if not success:
            self.metrics["failed_requests"] += 1

        # 更新平均响应时间
        n = self.metrics["total_requests"]
        self.metrics["avg_response_time"] = (
            (self.metrics["avg_response_time"] * (n - 1) + response_time) / n
        )

    def get_metrics(self) -> dict:
        """获取指标"""
        return {
            **self.metrics,
            "error_rate": self.metrics["failed_requests"] / max(self.metrics["total_requests"], 1),
            "is_healthy": self.client.is_healthy()
        }
```

---

## 总结

### 核心要点

1. **单例模式**: 避免频繁创建连接
2. **连接池**: 提升并发性能
3. **自动重连**: 提升系统稳定性
4. **上下文管理器**: 自动资源清理
5. **健康检查**: 主动发现问题
6. **错误处理**: 细粒度异常处理
7. **监控告警**: 实时掌握连接状态

### 核心代码模板

```python
# 生产环境推荐配置
client = ProductionMilvusClient(
    uri="http://localhost:19530",
    timeout=10.0,
    max_retries=3,
    retry_delay=1.0,
    health_check_interval=60.0
)

# 使用连接
try:
    results = client.search(
        collection_name="test",
        data=[[0.1, 0.2, ...]],
        limit=10
    )
except Exception as e:
    logger.error(f"检索失败: {e}")
```

### 下一步

- 阅读 **07_实战代码_场景4_端到端RAG.md** 学习 RAG 系统集成
- 阅读 **09_化骨绵掌.md** 深入理解原理
- 阅读 **08_面试必问.md** 准备面试

---

**参考文献**:
- pymilvus Documentation: https://milvus.io/docs/install-pymilvus.md
- Connection Pool Best Practices: https://en.wikipedia.org/wiki/Connection_pool
- Python Threading: https://docs.python.org/3/library/threading.html
