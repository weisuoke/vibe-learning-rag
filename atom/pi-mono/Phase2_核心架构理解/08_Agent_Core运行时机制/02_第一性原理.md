# 第一性原理

> 回到 Agent Core 最基本的真理，从源头思考代理运行时的本质

---

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题，而不是通过类比或经验推理。

在软件工程中，第一性原理思维意味着：
- 不问"别人怎么做"，而问"问题的本质是什么"
- 不从现有框架出发，而从根本需求出发
- 不追求功能堆砌，而追求最小可行方案

---

## Agent Core 的第一性原理

### 1. 最基础的定义

**Agent Core = 一个能够自主调用工具的 LLM 循环**

仅此而已！没有更基础的了。

拆解这个定义：
- **LLM**：大语言模型，能理解自然语言并生成响应
- **工具**：可执行的函数（读文件、写文件、运行命令等）
- **循环**：重复"调用 LLM → 执行工具 → 更新上下文"直到任务完成
- **自主**：LLM 自己决定何时调用工具、何时停止

**用 TypeScript 表达这个定义：**

```typescript
// Agent Core 的最小实现（~30 行）
async function agentCore(userMessage: string, tools: Tool[]) {
  const context = [{ role: 'user', content: userMessage }];

  while (true) {
    // 1. 调用 LLM
    const response = await llm.chat(context, tools);
    context.push({ role: 'assistant', content: response.content });

    // 2. 检查是否有工具调用
    if (!response.toolCalls || response.toolCalls.length === 0) {
      return response.content; // 任务完成
    }

    // 3. 执行工具
    for (const call of response.toolCalls) {
      const result = await executeTool(call.name, call.params);
      context.push({ role: 'tool', content: result });
    }
  }
}
```

这就是 Agent Core 的全部本质！其他一切（状态管理、事件流、UI 更新）都是在这个基础上的工程实现。

---

### 2. 为什么需要 Agent Core？

**核心问题：如何让 LLM 与外部世界交互？**

#### 问题的根源

LLM 本身是"无手无脚"的：
- ✅ 能理解："请帮我创建一个 TypeScript 文件"
- ❌ 不能执行：无法直接操作文件系统
- ✅ 能推理："需要先读取现有代码，再修改"
- ❌ 不能行动：无法读取文件或运行命令

**类比：** LLM 就像一个聪明的大脑，但没有手脚。Agent Core 就是给大脑装上手脚的机制。

#### 为什么不能简单地"LLM 生成代码 → 人工执行"？

这种方式的问题：
1. **无反馈循环**：LLM 不知道执行结果，无法根据错误调整
2. **无状态记忆**：每次对话都是独立的，无法追踪任务进度
3. **无自主性**：需要人工判断每一步，无法自动化

**Agent Core 解决的核心问题：**
```
LLM（思考） + Tools（行动） + Loop（反馈） = 自主 Agent
```

---

### 3. Agent Core 的三层价值

#### 价值 1：赋予 LLM 行动能力

**本质：** 将 LLM 从"顾问"变成"执行者"

**没有 Agent Core：**
```
用户：帮我创建一个 hello.ts 文件
LLM：你可以运行 `echo "console.log('hello')" > hello.ts`
用户：[手动执行命令]
用户：文件创建好了
LLM：很好！
```

**有了 Agent Core：**
```
用户：帮我创建一个 hello.ts 文件
Agent Core：
  1. LLM 决定调用 write 工具
  2. 执行 write({ path: 'hello.ts', content: "console.log('hello')" })
  3. 返回结果给 LLM
  4. LLM 确认完成
用户：[文件已自动创建]
```

**类比：**
- **TypeScript/Node.js**：从 `console.log(plan)` 到 `fs.writeFileSync(path, content)`
- **日常生活**：从"告诉你怎么做"到"帮你做完"

---

#### 价值 2：实现反馈驱动的自我纠正

**本质：** LLM 能根据执行结果调整策略

**示例：文件不存在时的自我纠正**

```typescript
// 第 1 轮：尝试编辑文件
LLM: 调用 edit({ path: 'config.ts', ... })
Tool Result: Error: File not found

// 第 2 轮：LLM 看到错误，调整策略
LLM: 调用 read({ path: '.' }) // 先列出文件
Tool Result: [package.json, src/index.ts, ...]

// 第 3 轮：LLM 发现文件不存在，改为创建
LLM: 调用 write({ path: 'config.ts', ... })
Tool Result: Success
```

**为什么这很重要？**
- 真实世界充满不确定性（文件可能不存在、命令可能失败）
- 静态规划无法应对所有情况
- 反馈循环让 Agent 能动态适应

**类比：**
- **TypeScript/Node.js**：try-catch 错误处理 + 重试逻辑
- **日常生活**：做菜时尝味道，根据味道调整调料

---

#### 价值 3：构建可扩展的自主系统

**本质：** 通过工具注册机制，Agent 能力可无限扩展

**Pi 的极简哲学：**
```typescript
// 核心只提供 4 个工具
const coreTools = ['read', 'write', 'edit', 'bash'];

// 但可以通过扩展添加任意工具
agent.registerTool('search_web', webSearchTool);
agent.registerTool('query_database', dbQueryTool);
agent.registerTool('call_api', apiCallTool);
```

**为什么这种设计强大？**
1. **核心极简**：4 个工具足以完成编码任务
2. **按需扩展**：需要什么能力就注册什么工具
3. **组合爆炸**：N 个工具可以组合出 N! 种能力

**实际应用：**
- **Coding Agent**：read + write + edit + bash → 完整开发流程
- **Slack Bot**：+ send_message + read_channel → 自动回复
- **数据分析 Agent**：+ query_db + plot_chart → 自动生成报告

**类比：**
- **TypeScript/Node.js**：Express 中间件系统（核心简单，插件丰富）
- **日常生活**：瑞士军刀（基础工具 + 可替换模块）

---

### 4. 从第一性原理推导 Pi-mono 的设计

**推理链：**

```
1. 前提：Agent = LLM + Loop + Tools
   ↓
2. 推导：Loop 的本质是"调用 LLM → 执行工具 → 更新上下文"
   ↓
3. 推导：Loop 应该何时停止？
   → 当 LLM 不再请求工具调用时
   → 不需要 max-steps 限制（信任模型）
   ↓
4. 推导：需要多少工具？
   → 前沿模型理解"编码代理"的上下文
   → 能组合基础工具完成复杂任务
   → 4 个工具（read/write/edit/bash）足够
   ↓
5. 推导：如何验证工具调用？
   → 使用 TypeBox + AJV 进行 schema 验证
   → 验证失败 → 返回错误给 LLM → 模型自我纠正
   ↓
6. 推导：如何管理状态？
   → 需要持久化（重启后恢复）
   → 需要分支（探索不同方案）
   → 需要跨 Provider 可移植
   → JSONL 追加日志 + parentId 树形结构
   ↓
7. 推导：如何与 UI 交互？
   → 事件驱动架构（agent.on('event', handler)）
   → 工具结果分离：output（LLM）vs details（UI）
   ↓
8. 最终设计：Pi-mono Agent Core
   - 极简循环（loop until done）
   - 4 个核心工具
   - TypeBox 验证 + 自我纠正
   - JSONL 状态管理
   - 事件流 UI 更新
```

**这个推理链展示了：**
- Pi-mono 的每个设计决策都源于第一性原理
- 没有多余的功能（极简哲学）
- 每个组件都有明确的理由

---

### 5. 与其他 Agent 框架的第一性原理对比

#### LangChain Agent

**设计理念：** 功能完备的工具箱

```typescript
// LangChain 提供大量预置组件
import { AgentExecutor, createReactAgent } from 'langchain/agents';
import { ChatOpenAI } from 'langchain/chat_models';
import { SerpAPI, Calculator, WikipediaQueryRun } from 'langchain/tools';

const agent = await createReactAgent({
  llm: new ChatOpenAI(),
  tools: [new SerpAPI(), new Calculator(), new WikipediaQueryRun()],
  maxIterations: 10, // 需要设置最大迭代次数
});
```

**第一性原理分析：**
- ✅ 提供丰富的预置工具
- ❌ 复杂度高（需要理解 AgentExecutor、ReAct 等概念）
- ❌ 需要 maxIterations 限制（不信任模型）

---

#### Pi-mono Agent Core

**设计理念：** 极简核心 + 可扩展

```typescript
// Pi-mono 只提供核心机制
import { Agent } from '@mariozechner/pi-agent-core';

const agent = new Agent({
  llm: anthropicProvider,
  tools: builtInTools, // 仅 4 个工具
  // 无 maxIterations（信任模型自我终止）
});
```

**第一性原理分析：**
- ✅ 核心极简（30 行实现）
- ✅ 信任模型（无 max-steps）
- ✅ 按需扩展（通过 Extensions）

---

#### 对比总结

| 维度 | LangChain | Pi-mono | 第一性原理视角 |
|------|-----------|---------|---------------|
| **核心复杂度** | 高（多层抽象） | 低（单层循环） | Pi 更接近本质 |
| **工具数量** | 50+ 预置工具 | 4 个核心工具 | Pi 体现"少即是多" |
| **循环控制** | maxIterations | loop until done | Pi 信任模型能力 |
| **扩展方式** | 继承 + 配置 | 工具注册 | Pi 更灵活 |
| **学习曲线** | 陡峭 | 平缓 | Pi 更易理解 |

**结论：** Pi-mono 更忠实于"Agent = LLM + Loop + Tools"的第一性原理。

---

### 6. 第一性原理在实际开发中的应用

#### 应用 1：设计自定义 Agent

**错误方式（堆砌功能）：**
```typescript
// ❌ 添加大量"可能有用"的工具
agent.registerTool('read', readTool);
agent.registerTool('write', writeTool);
agent.registerTool('search', searchTool);
agent.registerTool('translate', translateTool);
agent.registerTool('summarize', summarizeTool);
agent.registerTool('format', formatTool);
// ... 20 个工具
```

**正确方式（第一性原理）：**
```typescript
// ✅ 从任务本质出发
// 问：这个 Agent 的核心任务是什么？
// 答：代码审查

// 问：完成代码审查需要哪些最基础的能力？
// 答：读取代码 + 运行测试 + 生成报告

agent.registerTool('read', readTool);      // 读取代码
agent.registerTool('bash', bashTool);      // 运行测试
agent.registerTool('write', writeTool);    // 生成报告
// 仅 3 个工具！
```

---

#### 应用 2：调试 Agent 行为

**问题：** Agent 陷入无限循环

**错误调试方式（治标）：**
```typescript
// ❌ 添加 maxIterations 限制
const agent = new Agent({ maxIterations: 10 });
```

**正确调试方式（第一性原理）：**
```typescript
// ✅ 回到本质：为什么 LLM 不停止？
// 1. 检查工具结果是否清晰
console.log(toolResult); // 是否包含明确的成功/失败信息？

// 2. 检查系统提示是否引导停止
systemPrompt += "\n当任务完成时，不要调用任何工具，直接回复用户。";

// 3. 检查工具是否返回了错误但 LLM 没理解
toolResult = {
  output: "Error: File not found", // ✅ 清晰
  // 而不是：
  // output: "null" // ❌ 模糊
};
```

---

#### 应用 3：优化 Agent 性能

**问题：** Agent 响应慢

**错误优化方式（盲目优化）：**
```typescript
// ❌ 添加缓存、并行执行等复杂机制
agent.enableCache();
agent.enableParallelTools();
```

**正确优化方式（第一性原理）：**
```typescript
// ✅ 回到本质：瓶颈在哪？
// 1. 测量每个环节的耗时
console.time('llm_call');
await llm.chat(context);
console.timeEnd('llm_call'); // 2000ms

console.time('tool_execution');
await executeTool(call);
console.timeEnd('tool_execution'); // 50ms

// 2. 发现瓶颈：LLM 调用占 95% 时间
// 3. 针对性优化：减少 LLM 调用次数
// - 优化系统提示（让 LLM 一次调用多个工具）
// - 使用更快的模型（Haiku vs Opus）
// - 减少上下文长度（Compaction）
```

---

### 7. 一句话总结第一性原理

**Agent Core 是"LLM + 循环 + 工具"的最小实现，通过信任模型的自主性和自我纠正能力，用 4 个基础工具实现无限扩展的代理系统。**

---

## 第一性原理思维练习

**问自己这些问题：**

1. **如果重新设计 Agent Core，你会从哪里开始？**
   - ✅ 从"LLM 如何与外部世界交互"这个根本问题开始
   - ❌ 从"其他框架怎么做"开始

2. **为什么 Pi 只需要 4 个工具？**
   - ✅ 因为前沿模型理解编码上下文，能组合基础工具
   - ❌ 因为作者懒得实现更多工具

3. **为什么不需要 max-steps？**
   - ✅ 因为信任模型能自我终止（第一性原理：模型理解任务完成）
   - ❌ 因为无限循环不会发生

4. **JSONL 为什么比 JSON 更适合 Session 存储？**
   - ✅ 因为追加写入是最基础的持久化操作（第一性原理：最小 I/O）
   - ❌ 因为 JSONL 看起来更酷

5. **为什么工具结果要分 output 和 details？**
   - ✅ 因为 LLM 和 UI 的需求不同（第一性原理：关注点分离）
   - ❌ 因为这样代码更复杂

**如果你能从第一性原理回答这些问题，说明你真正理解了 Agent Core 的设计哲学！**

---

## 延伸阅读

**第一性原理相关：**
- Elon Musk 的第一性原理思维
- Richard Feynman 的"从基础推导"方法
- Unix 哲学："做一件事并做好"

**Agent 架构相关：**
- "Agents are just LLM + loop + tools" (Reddit r/LangChain, 2025)
- "The Agent Deployment Gap" (ZenML Blog, 2025)
- "AI Agents in 2026: Practical Architecture" (Andrii Furmanets, 2026)

**Pi-mono 设计哲学：**
- "What I learned building an opinionated and minimal coding agent" (Mario Zechner, 2025)
- "Pi: The Minimal Agent Within OpenClaw" (Armin Ronacher, 2026)
- "Agentic AI: Pi — Anatomy of a minimal coding agent" (Medium, 2026)

---

[^1]: 第一性原理思维源于物理学，由 Elon Musk 推广到工程领域
[^2]: Pi-mono 的设计体现了 Unix 哲学："做一件事并做好"
[^3]: "Loop until done" 是对模型能力的信任，也是极简设计的体现
[^4]: 4 个工具的设计源于对"编码代理"本质的第一性原理思考
[^5]: JSONL 追加日志是最接近"持久化"本质的数据结构
