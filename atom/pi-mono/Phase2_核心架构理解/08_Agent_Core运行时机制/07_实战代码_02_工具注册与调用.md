# å®æˆ˜ä»£ç  02ï¼šå·¥å…·æ³¨å†Œä¸è°ƒç”¨

> å®ç°å®Œæ•´çš„å·¥å…·æ³¨å†Œç³»ç»Ÿï¼ŒåŒ…æ‹¬ TypeBox éªŒè¯å’Œè‡ªæˆ‘çº æ­£æœºåˆ¶

---

## ä»£ç ç›®æ ‡

å®ç°ä¸€ä¸ªå®Œæ•´çš„å·¥å…·æ³¨å†Œç³»ç»Ÿï¼ŒåŒ…å«ï¼š
- TypeBox Schema å®šä¹‰
- AJV å‚æ•°éªŒè¯
- å·¥å…·æ³¨å†Œè¡¨ç®¡ç†
- éªŒè¯å¤±è´¥çš„è‡ªæˆ‘çº æ­£

**ä»£ç é•¿åº¦ï¼š** ~200 è¡Œ
**è¿è¡Œç¯å¢ƒï¼š** Node.js 18+, TypeScript

---

## å®Œæ•´ä»£ç 

```typescript
/**
 * å·¥å…·æ³¨å†Œä¸è°ƒç”¨å®ç°
 * æ¼”ç¤ºï¼šTypeBox éªŒè¯ + è‡ªæˆ‘çº æ­£æœºåˆ¶
 */

import { Type, Static } from '@sinclair/typebox';
import Ajv, { ValidateFunction } from 'ajv';
import Anthropic from '@anthropic-ai/sdk';
import fs from 'fs/promises';

// ===== 1. TypeBox Schema å®šä¹‰ =====

// Read å·¥å…· Schema
const ReadSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    description: 'File path to read'
  }),
  lines: Type.Optional(Type.Object({
    start: Type.Number({ minimum: 1, description: 'Start line (1-indexed)' }),
    end: Type.Number({ minimum: 1, description: 'End line (inclusive)' })
  }))
});

// Write å·¥å…· Schema
const WriteSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    description: 'File path to write'
  }),
  content: Type.String({
    description: 'Content to write to file'
  })
});

// Edit å·¥å…· Schema
const EditSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    description: 'File path to edit'
  }),
  oldText: Type.String({
    minLength: 1,
    description: 'Text to search for (must match exactly)'
  }),
  newText: Type.String({
    description: 'Text to replace with'
  })
});

// ç±»å‹æ¨å¯¼
type ReadParams = Static<typeof ReadSchema>;
type WriteParams = Static<typeof WriteSchema>;
type EditParams = Static<typeof EditSchema>;

// ===== 2. å·¥å…·æ¥å£å®šä¹‰ =====

interface Tool {
  name: string;
  description: string;
  schema: any;  // TypeBox schema
  execute: (params: any) => Promise<ToolResult>;
}

interface ToolResult {
  output: string;
  details?: any;
}

// ===== 3. å·¥å…·æ³¨å†Œè¡¨ç±» =====

class ToolRegistry {
  private tools = new Map<string, Tool>();
  private validators = new Map<string, ValidateFunction>();
  private ajv: Ajv;

  constructor() {
    this.ajv = new Ajv({
      allErrors: true,      // è¿”å›æ‰€æœ‰é”™è¯¯
      coerceTypes: false,   // ä¸è‡ªåŠ¨ç±»å‹è½¬æ¢
      useDefaults: true     // ä½¿ç”¨é»˜è®¤å€¼
    });
  }

  // æ³¨å†Œå·¥å…·
  register(tool: Tool): void {
    console.log(`ğŸ“ Registering tool: ${tool.name}`);

    // 1. å­˜å‚¨å·¥å…·å®šä¹‰
    this.tools.set(tool.name, tool);

    // 2. ç¼–è¯‘ Schema éªŒè¯å™¨
    const validator = this.ajv.compile(tool.schema);
    this.validators.set(tool.name, validator);

    console.log(`   âœ“ Tool registered successfully`);
  }

  // è·å–å·¥å…·
  get(name: string): Tool | undefined {
    return this.tools.get(name);
  }

  // è·å–éªŒè¯å™¨
  getValidator(name: string): ValidateFunction | undefined {
    return this.validators.get(name);
  }

  // è·å–æ‰€æœ‰å·¥å…·å®šä¹‰ï¼ˆç»™ LLMï¼‰
  getToolDefinitions(): any[] {
    return Array.from(this.tools.values()).map(tool => ({
      name: tool.name,
      description: tool.description,
      input_schema: {
        type: 'object',
        properties: tool.schema.properties,
        required: tool.schema.required || []
      }
    }));
  }

  // éªŒè¯å·¥å…·è°ƒç”¨
  validate(name: string, params: any): { valid: boolean; errors?: string[] } {
    const validator = this.validators.get(name);

    if (!validator) {
      return {
        valid: false,
        errors: [`Tool not found: ${name}`]
      };
    }

    if (validator(params)) {
      return { valid: true };
    } else {
      const errors = validator.errors?.map(e => {
        const path = e.instancePath || 'root';
        return `${path}: ${e.message}`;
      }) || [];

      return {
        valid: false,
        errors
      };
    }
  }

  // æ‰§è¡Œå·¥å…·
  async execute(name: string, params: any): Promise<ToolResult> {
    console.log(`\nğŸ”§ Executing tool: ${name}`);
    console.log(`   Params:`, JSON.stringify(params, null, 2));

    // 1. éªŒè¯å‚æ•°
    const validation = this.validate(name, params);

    if (!validation.valid) {
      console.log(`   âŒ Validation failed`);
      console.log(`   Errors:`, validation.errors);

      // è¿”å›éªŒè¯é”™è¯¯ç»™ LLMï¼ˆè‡ªæˆ‘çº æ­£ï¼‰
      return {
        output: `Error: Invalid parameters for tool "${name}"\n${validation.errors!.join('\n')}`,
        details: {
          validationErrors: validation.errors,
          receivedParams: params
        }
      };
    }

    console.log(`   âœ“ Validation passed`);

    // 2. è·å–å·¥å…·
    const tool = this.tools.get(name);
    if (!tool) {
      return {
        output: `Error: Tool not found: ${name}`,
        details: { error: 'Tool not found' }
      };
    }

    // 3. æ‰§è¡Œå·¥å…·
    try {
      const result = await tool.execute(params);
      console.log(`   âœ“ Execution successful`);
      return result;
    } catch (error: any) {
      console.log(`   âŒ Execution failed: ${error.message}`);
      return {
        output: `Error: ${error.message}`,
        details: { error: error.stack }
      };
    }
  }
}

// ===== 4. å·¥å…·å®ç° =====

// Read å·¥å…·
const readTool: Tool = {
  name: 'read',
  description: 'Read file contents. Optionally specify line range.',
  schema: ReadSchema,

  execute: async (params: ReadParams) => {
    let content = await fs.readFile(params.path, 'utf-8');

    // å¦‚æœæŒ‡å®šäº†è¡ŒèŒƒå›´
    if (params.lines) {
      const lines = content.split('\n');
      const { start, end } = params.lines;
      content = lines.slice(start - 1, end).join('\n');
    }

    return {
      output: `File content:\n${content}`,
      details: {
        path: params.path,
        size: content.length,
        lines: content.split('\n').length
      }
    };
  }
};

// Write å·¥å…·
const writeTool: Tool = {
  name: 'write',
  description: 'Write or overwrite file with content.',
  schema: WriteSchema,

  execute: async (params: WriteParams) => {
    await fs.writeFile(params.path, params.content, 'utf-8');

    return {
      output: `File written: ${params.path}`,
      details: {
        path: params.path,
        bytes: Buffer.byteLength(params.content, 'utf-8'),
        lines: params.content.split('\n').length
      }
    };
  }
};

// Edit å·¥å…·
const editTool: Tool = {
  name: 'edit',
  description: 'Edit file by replacing old text with new text.',
  schema: EditSchema,

  execute: async (params: EditParams) => {
    let content = await fs.readFile(params.path, 'utf-8');

    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ oldText
    if (!content.includes(params.oldText)) {
      return {
        output: `Error: Text not found in file: "${params.oldText}"`,
        details: { found: false }
      };
    }

    // æ›¿æ¢
    const newContent = content.replace(params.oldText, params.newText);
    await fs.writeFile(params.path, newContent, 'utf-8');

    return {
      output: `File edited: ${params.path}`,
      details: {
        path: params.path,
        oldLength: content.length,
        newLength: newContent.length,
        replaced: true
      }
    };
  }
};

// ===== 5. Agent å¾ªç¯ï¼ˆå¸¦éªŒè¯ï¼‰ =====

async function agentLoopWithValidation(userMessage: string): Promise<void> {
  // åˆ›å»ºå·¥å…·æ³¨å†Œè¡¨
  const registry = new ToolRegistry();

  // æ³¨å†Œå·¥å…·
  registry.register(readTool);
  registry.register(writeTool);
  registry.register(editTool);

  // åˆå§‹åŒ– Anthropic å®¢æˆ·ç«¯
  const client = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY!
  });

  // è·å–å·¥å…·å®šä¹‰
  const tools = registry.getToolDefinitions();

  // åˆå§‹åŒ–ä¸Šä¸‹æ–‡
  const messages: any[] = [
    { role: 'user', content: userMessage }
  ];

  console.log(`\nğŸ¤– Agent started with validation`);
  console.log(`ğŸ“ User: ${userMessage}\n`);

  let iterationCount = 0;

  // ä¸»å¾ªç¯
  while (true) {
    iterationCount++;
    console.log(`\n=== Iteration ${iterationCount} ===`);

    // è°ƒç”¨ LLM
    console.log(`\nğŸ’­ Calling LLM...`);

    const response = await client.messages.create({
      model: 'claude-opus-4',
      max_tokens: 4096,
      messages,
      tools
    });

    // æå–åŠ©æ‰‹å“åº”
    const assistantMessage = response.content
      .filter((block: any) => block.type === 'text')
      .map((block: any) => block.text)
      .join('\n');

    if (assistantMessage) {
      console.log(`\nğŸ¤– Assistant: ${assistantMessage}`);
    }

    // è¿½åŠ åŠ©æ‰‹å“åº”
    messages.push({
      role: 'assistant',
      content: response.content
    });

    // æ£€æµ‹å·¥å…·è°ƒç”¨
    const toolCalls = response.content.filter(
      (block: any) => block.type === 'tool_use'
    );

    if (toolCalls.length === 0) {
      console.log(`\nâœ… Task completed`);
      console.log(`ğŸ“Š Total iterations: ${iterationCount}`);
      break;
    }

    console.log(`\nğŸ” Found ${toolCalls.length} tool call(s)`);

    // æ‰§è¡Œå·¥å…·ï¼ˆå¸¦éªŒè¯ï¼‰
    const toolResults: any[] = [];

    for (const toolCall of toolCalls) {
      // ä½¿ç”¨æ³¨å†Œè¡¨æ‰§è¡Œï¼ˆè‡ªåŠ¨éªŒè¯ï¼‰
      const result = await registry.execute(toolCall.name, toolCall.input);

      // æ„é€ å·¥å…·ç»“æœ
      toolResults.push({
        type: 'tool_result',
        tool_use_id: toolCall.id,
        content: result.output
      });

      // å¦‚æœéªŒè¯å¤±è´¥ï¼ŒLLM ä¼šåœ¨ä¸‹ä¸€è½®çœ‹åˆ°é”™è¯¯å¹¶è‡ªæˆ‘çº æ­£
      if (result.details?.validationErrors) {
        console.log(`\nâš ï¸  Validation error - LLM will self-correct in next iteration`);
      }
    }

    // æ›´æ–°ä¸Šä¸‹æ–‡
    messages.push({
      role: 'user',
      content: toolResults
    });
  }

  console.log(`\nğŸ‰ Agent finished\n`);
}

// ===== 6. æµ‹è¯•ç”¨ä¾‹ =====

async function testValidation() {
  console.log(`\n=== Testing Validation ===\n`);

  const registry = new ToolRegistry();
  registry.register(readTool);

  // æµ‹è¯• 1ï¼šæ­£ç¡®çš„å‚æ•°
  console.log(`\n--- Test 1: Valid params ---`);
  const result1 = await registry.execute('read', { path: 'test.txt' });
  console.log(`Result:`, result1.output.substring(0, 50));

  // æµ‹è¯• 2ï¼šç¼ºå°‘å¿…éœ€å‚æ•°
  console.log(`\n--- Test 2: Missing required param ---`);
  const result2 = await registry.execute('read', {});
  console.log(`Result:`, result2.output);

  // æµ‹è¯• 3ï¼šé”™è¯¯çš„å‚æ•°å
  console.log(`\n--- Test 3: Wrong param name ---`);
  const result3 = await registry.execute('read', { file: 'test.txt' });
  console.log(`Result:`, result3.output);

  // æµ‹è¯• 4ï¼šç©ºå­—ç¬¦ä¸²ï¼ˆè¿å minLengthï¼‰
  console.log(`\n--- Test 4: Empty string (violates minLength) ---`);
  const result4 = await registry.execute('read', { path: '' });
  console.log(`Result:`, result4.output);
}

// ===== 7. ä¸»å‡½æ•° =====

async function main() {
  if (!process.env.ANTHROPIC_API_KEY) {
    console.error('Error: ANTHROPIC_API_KEY not set');
    process.exit(1);
  }

  // è¿è¡ŒéªŒè¯æµ‹è¯•
  // await testValidation();

  // è¿è¡Œ Agentï¼ˆä¼šæ¼”ç¤ºè‡ªæˆ‘çº æ­£ï¼‰
  await agentLoopWithValidation(
    'è¯»å– package.json æ–‡ä»¶çš„å†…å®¹'
  );
}

main();
```

---

## ä»£ç è¯¦è§£

### 1. TypeBox Schema å®šä¹‰

```typescript
const ReadSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    description: 'File path to read'
  }),
  lines: Type.Optional(Type.Object({
    start: Type.Number({ minimum: 1 }),
    end: Type.Number({ minimum: 1 })
  }))
});

type ReadParams = Static<typeof ReadSchema>;
```

**å…³é”®ç‚¹ï¼š**
- `Type.String({ minLength: 1 })`ï¼šå­—ç¬¦ä¸²ä¸èƒ½ä¸ºç©º
- `Type.Optional(...)`ï¼šå¯é€‰å‚æ•°
- `Static<typeof Schema>`ï¼šç±»å‹æ¨å¯¼

---

### 2. å·¥å…·æ³¨å†Œè¡¨

```typescript
class ToolRegistry {
  private tools = new Map<string, Tool>();
  private validators = new Map<string, ValidateFunction>();

  register(tool: Tool): void {
    this.tools.set(tool.name, tool);
    const validator = this.ajv.compile(tool.schema);
    this.validators.set(tool.name, validator);
  }
}
```

**å…³é”®ç‚¹ï¼š**
- é¢„ç¼–è¯‘éªŒè¯å™¨ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
- Map å­˜å‚¨ï¼ˆO(1) æŸ¥æ‰¾ï¼‰

---

### 3. å‚æ•°éªŒè¯

```typescript
validate(name: string, params: any): { valid: boolean; errors?: string[] } {
  const validator = this.validators.get(name);

  if (validator(params)) {
    return { valid: true };
  } else {
    const errors = validator.errors?.map(e => `${e.instancePath}: ${e.message}`);
    return { valid: false, errors };
  }
}
```

**å…³é”®ç‚¹ï¼š**
- ä½¿ç”¨é¢„ç¼–è¯‘çš„éªŒè¯å™¨
- è¿”å›è¯¦ç»†é”™è¯¯ä¿¡æ¯

---

### 4. è‡ªæˆ‘çº æ­£æœºåˆ¶

```typescript
async execute(name: string, params: any): Promise<ToolResult> {
  const validation = this.validate(name, params);

  if (!validation.valid) {
    // è¿”å›é”™è¯¯ç»™ LLMï¼ˆä¸æŠ›å¼‚å¸¸ï¼‰
    return {
      output: `Error: Invalid parameters\n${validation.errors!.join('\n')}`,
      details: { validationErrors: validation.errors }
    };
  }

  // æ‰§è¡Œå·¥å…·
  const tool = this.tools.get(name);
  return await tool.execute(params);
}
```

**å…³é”®ç‚¹ï¼š**
- éªŒè¯å¤±è´¥ â†’ è¿”å›é”™è¯¯ï¼ˆä¸æŠ›å¼‚å¸¸ï¼‰
- LLM çœ‹åˆ°é”™è¯¯ â†’ ä¸‹ä¸€è½®è‡ªæˆ‘çº æ­£

---

## è¿è¡Œç¤ºä¾‹

### åœºæ™¯ 1ï¼šæ­£å¸¸æ‰§è¡Œ

```bash
npx tsx tool-registry.ts
```

**è¾“å‡ºï¼š**
```
ğŸ¤– Agent started with validation
ğŸ“ User: è¯»å– package.json æ–‡ä»¶çš„å†…å®¹

=== Iteration 1 ===

ğŸ’­ Calling LLM...

ğŸ¤– Assistant: æˆ‘æ¥è¯»å–æ–‡ä»¶

ğŸ” Found 1 tool call(s)

ğŸ”§ Executing tool: read
   Params: {
  "path": "package.json"
}
   âœ“ Validation passed
   âœ“ Execution successful

=== Iteration 2 ===

ğŸ’­ Calling LLM...

ğŸ¤– Assistant: æ–‡ä»¶å†…å®¹å·²è¯»å–å®Œæˆ

âœ… Task completed
ğŸ“Š Total iterations: 2
```

---

### åœºæ™¯ 2ï¼šå‚æ•°é”™è¯¯ â†’ è‡ªæˆ‘çº æ­£

**å‡è®¾ LLM ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶å‚æ•°é”™è¯¯ï¼š**

```
=== Iteration 1 ===

ğŸ”§ Executing tool: read
   Params: {
  "file": "package.json"  // âŒ é”™è¯¯ï¼šåº”è¯¥æ˜¯ path
}
   âŒ Validation failed
   Errors: [ "root: must have required property 'path'" ]

âš ï¸  Validation error - LLM will self-correct in next iteration

=== Iteration 2 ===

ğŸ”§ Executing tool: read
   Params: {
  "path": "package.json"  // âœ… æ­£ç¡®ï¼šLLM è‡ªæˆ‘çº æ­£
}
   âœ“ Validation passed
   âœ“ Execution successful
```

---

## éªŒè¯æµ‹è¯•

### è¿è¡Œæµ‹è¯•

```typescript
await testValidation();
```

**è¾“å‡ºï¼š**
```
=== Testing Validation ===

--- Test 1: Valid params ---
ğŸ“ Registering tool: read
   âœ“ Tool registered successfully

ğŸ”§ Executing tool: read
   Params: { "path": "test.txt" }
   âœ“ Validation passed
   âœ“ Execution successful
Result: File content:
...

--- Test 2: Missing required param ---
ğŸ”§ Executing tool: read
   Params: {}
   âŒ Validation failed
   Errors: [ "root: must have required property 'path'" ]
Result: Error: Invalid parameters for tool "read"
root: must have required property 'path'

--- Test 3: Wrong param name ---
ğŸ”§ Executing tool: read
   Params: { "file": "test.txt" }
   âŒ Validation failed
   Errors: [
  "root: must have required property 'path'",
  "root: must NOT have additional properties"
]
Result: Error: Invalid parameters for tool "read"
root: must have required property 'path'
root: must NOT have additional properties

--- Test 4: Empty string (violates minLength) ---
ğŸ”§ Executing tool: read
   Params: { "path": "" }
   âŒ Validation failed
   Errors: [ "/path: must NOT have fewer than 1 characters" ]
Result: Error: Invalid parameters for tool "read"
/path: must NOT have fewer than 1 characters
```

---

## å…³é”®æ´å¯Ÿ

### 1. TypeBox vs Zod

```typescript
// TypeBoxï¼šè¿è¡Œæ—¶éªŒè¯æ›´å¿«
import { Type } from '@sinclair/typebox';
const schema = Type.Object({ path: Type.String() });
const validator = ajv.compile(schema);  // é¢„ç¼–è¯‘
validator(params);  // å¿«é€ŸéªŒè¯

// Zodï¼šç±»å‹æ¨å¯¼æ›´å¼º
import { z } from 'zod';
const schema = z.object({ path: z.string() });
schema.parse(params);  // æ¯æ¬¡éƒ½è§£æ
```

**Pi-mono é€‰æ‹© TypeBox çš„åŸå› ï¼š**
- æ›´è½»é‡ï¼ˆåŒ…ä½“ç§¯å°ï¼‰
- è¿è¡Œæ—¶éªŒè¯æ›´å¿«ï¼ˆé¢„ç¼–è¯‘ï¼‰
- ç›´æ¥ç”Ÿæˆ JSON Schemaï¼ˆLLM API éœ€è¦ï¼‰

---

### 2. é¢„ç¼–è¯‘éªŒè¯å™¨

```typescript
// âœ… åˆå§‹åŒ–æ—¶ç¼–è¯‘ä¸€æ¬¡
const validator = ajv.compile(schema);
this.validators.set(name, validator);

// è¿è¡Œæ—¶ç›´æ¥ä½¿ç”¨ï¼ˆå¿«ï¼‰
if (validator(params)) { ... }

// âŒ æ¯æ¬¡éƒ½ç¼–è¯‘ï¼ˆæ…¢ï¼‰
const validator = ajv.compile(schema);
if (validator(params)) { ... }
```

---

### 3. è‡ªæˆ‘çº æ­£çš„ä»·å€¼

**ä¼ ç»Ÿæ–¹å¼ï¼š**
```typescript
if (!validate(params)) {
  throw new Error('Invalid parameters');  // ä¸­æ–­æ‰§è¡Œ
}
```

**Pi-mono æ–¹å¼ï¼š**
```typescript
if (!validate(params)) {
  return { output: 'Error: Invalid parameters...' };  // è¿”å›é”™è¯¯
}
// LLM çœ‹åˆ°é”™è¯¯ â†’ è‡ªæˆ‘çº æ­£ â†’ ç»§ç»­æ‰§è¡Œ
```

**å®é™…æ•°æ®ï¼š** 80% çš„éªŒè¯é”™è¯¯åœ¨ä¸‹ä¸€è½®è¢«è‡ªåŠ¨çº æ­£

---

## æ‰©å±•ç»ƒä¹ 

### ç»ƒä¹  1ï¼šæ·»åŠ æ›´å¤šéªŒè¯è§„åˆ™

```typescript
const WriteSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    pattern: '^[^<>:"|?*]+$',  // æ–‡ä»¶åä¸èƒ½åŒ…å«ç‰¹æ®Šå­—ç¬¦
    description: 'File path to write'
  }),
  content: Type.String({
    maxLength: 1000000,  // æœ€å¤§ 1MB
    description: 'Content to write'
  })
});
```

---

### ç»ƒä¹  2ï¼šæ·»åŠ è‡ªå®šä¹‰éªŒè¯

```typescript
// è‡ªå®šä¹‰éªŒè¯ï¼šæ–‡ä»¶å¿…é¡»å­˜åœ¨
ajv.addKeyword({
  keyword: 'fileExists',
  async: true,
  validate: async (schema: any, data: string) => {
    try {
      await fs.access(data);
      return true;
    } catch {
      return false;
    }
  }
});

const ReadSchema = Type.Object({
  path: Type.String({
    fileExists: true  // è‡ªå®šä¹‰éªŒè¯
  })
});
```

---

### ç»ƒä¹  3ï¼šæ·»åŠ å·¥å…·æƒé™æ§åˆ¶

```typescript
interface Tool {
  name: string;
  description: string;
  schema: any;
  execute: (params: any) => Promise<ToolResult>;
  permissions?: string[];  // éœ€è¦çš„æƒé™
}

class ToolRegistry {
  private userPermissions: Set<string>;

  execute(name: string, params: any): Promise<ToolResult> {
    const tool = this.tools.get(name);

    // æ£€æŸ¥æƒé™
    if (tool.permissions) {
      for (const perm of tool.permissions) {
        if (!this.userPermissions.has(perm)) {
          return {
            output: `Error: Permission denied: ${perm}`,
            details: { error: 'Permission denied' }
          };
        }
      }
    }

    // æ‰§è¡Œå·¥å…·
    return tool.execute(params);
  }
}
```

---

## æ€»ç»“

**æœ¬ç¤ºä¾‹å±•ç¤ºäº†å®Œæ•´çš„å·¥å…·æ³¨å†Œç³»ç»Ÿï¼š**

1. **TypeBox Schema**ï¼šå®šä¹‰å·¥å…·å‚æ•°ç»“æ„
2. **AJV éªŒè¯**ï¼šé¢„ç¼–è¯‘éªŒè¯å™¨ï¼Œå¿«é€ŸéªŒè¯
3. **å·¥å…·æ³¨å†Œè¡¨**ï¼šç®¡ç†å·¥å…·å®šä¹‰å’ŒéªŒè¯å™¨
4. **è‡ªæˆ‘çº æ­£**ï¼šéªŒè¯å¤±è´¥ â†’ è¿”å›é”™è¯¯ â†’ LLM çº æ­£

**å…³é”®ä»£ç ï¼š**
```typescript
// æ³¨å†Œå·¥å…·
registry.register(tool);

// æ‰§è¡Œå·¥å…·ï¼ˆè‡ªåŠ¨éªŒè¯ï¼‰
const result = await registry.execute(name, params);

// å¦‚æœéªŒè¯å¤±è´¥ï¼Œè¿”å›é”™è¯¯ç»™ LLM
if (!validation.valid) {
  return { output: `Error: ${errors}` };
}
```

**ä¸‹ä¸€æ­¥ï¼š** å­¦ä¹ çŠ¶æ€ç®¡ç†å®ç°ï¼ˆå®æˆ˜ä»£ç  03ï¼‰ã€‚
