# Session 管理与分支 - 核心概念 03：Fork 与会话创建

> 深入理解 /new、/resume、/fork 命令的工作原理和使用场景

---

## 概述

Pi 提供三种会话创建方式：
- `/new` - 创建全新会话
- `/resume` - 恢复历史会话
- `/fork` - 从当前节点创建分支

---

## 1. /new - 创建新会话

### 1.1 基本用法

```bash
# 创建新会话
/new

# 创建并命名
/new my-project
```

### 1.2 工作原理

```typescript
class SessionManager {
  async createNewSession(name?: string): Promise<Session> {
    // 1. 生成 Session ID
    const sessionId = name || this.generateSessionId();

    // 2. 创建 JSONL 文件
    const filePath = path.join(this.sessionsDir, `${sessionId}.jsonl`);

    // 3. 写入初始元数据
    await fs.appendFile(filePath, JSON.stringify({
      id: '0',
      type: 'metadata',
      sessionId,
      created: Date.now(),
      version: '1.0'
    }) + '\n');

    // 4. 返回 Session 对象
    return new Session(sessionId, filePath);
  }

  private generateSessionId(): string {
    return Math.random().toString(36).substring(2, 15);
  }
}
```

### 1.3 使用场景

**场景 1：开始新项目**
```bash
pi
/new project-auth
User: 实现用户认证系统
```

**场景 2：清空上下文**
```bash
# 当前会话太长，想重新开始
/new
User: 新的任务...
```

---

## 2. /resume - 恢复会话

### 2.1 基本用法

```bash
# 交互式选择
/resume

# 直接指定 Session ID
/resume abc123

# 按名称恢复
/resume project-auth
```

### 2.2 工作原理

```typescript
class SessionManager {
  async resumeSession(sessionId?: string): Promise<Session> {
    if (!sessionId) {
      // 显示会话列表供选择
      const sessions = await this.listSessions();
      sessionId = await this.promptUserToSelect(sessions);
    }

    // 1. 读取 JSONL 文件
    const filePath = path.join(this.sessionsDir, `${sessionId}.jsonl`);
    const content = await fs.readFile(filePath, 'utf-8');

    // 2. 解析所有条目
    const entries = content
      .split('\n')
      .filter(line => line.trim())
      .map(line => JSON.parse(line));

    // 3. 重建上下文
    const context = this.buildContext(entries);

    // 4. 返回 Session 对象
    return new Session(sessionId, filePath, context);
  }

  private async listSessions(): Promise<SessionInfo[]> {
    const files = await fs.readdir(this.sessionsDir);
    const sessions: SessionInfo[] = [];

    for (const file of files) {
      if (file.endsWith('.jsonl')) {
        const sessionId = file.replace('.jsonl', '');
        const filePath = path.join(this.sessionsDir, file);
        const stats = await fs.stat(filePath);

        sessions.push({
          id: sessionId,
          lastModified: stats.mtime.getTime(),
          size: stats.size
        });
      }
    }

    // 按最后修改时间排序
    sessions.sort((a, b) => b.lastModified - a.lastModified);
    return sessions;
  }
}
```

### 2.3 使用场景

**场景 1：跨设备工作**
```bash
# 在电脑 A 上
pi
/new project-x
# 工作...

# 在电脑 B 上
pi
/resume project-x
# 继续工作...
```

**场景 2：长期项目**
```bash
# 昨天的工作
pi
/new feature-login
# 开发...

# 今天继续
pi
/resume feature-login
# 继续开发...
```

---

## 3. /fork - 创建分支

### 3.1 基本用法

```bash
# 从当前节点 Fork
/fork

# Fork 选择器
Fork from which point?
1. [Current] User: 实现功能 A
2. [Parent] Assistant: 好的...
3. [Root] User: 开始项目

Select (1-3): 1
```

### 3.2 工作原理

```typescript
class SessionManager {
  async forkSession(
    originalSessionId: string,
    fromNodeId: string,
    newSessionId?: string
  ): Promise<Session> {
    // 1. 读取原始会话
    const originalEntries = await this.readSession(originalSessionId);

    // 2. 获取到指定节点的历史路径
    const historyPath = this.getHistoryPath(originalEntries, fromNodeId);

    // 3. 创建新会话
    newSessionId = newSessionId || this.generateSessionId();
    const newFilePath = path.join(this.sessionsDir, `${newSessionId}.jsonl`);

    // 4. 写入继承的历史
    for (const entry of historyPath) {
      await fs.appendFile(newFilePath, JSON.stringify(entry) + '\n');
    }

    // 5. 添加 Fork 元数据
    await fs.appendFile(newFilePath, JSON.stringify({
      type: 'fork_metadata',
      parentSessionId: originalSessionId,
      forkFromNodeId: fromNodeId,
      timestamp: Date.now()
    }) + '\n');

    // 6. 返回新 Session
    return new Session(newSessionId, newFilePath);
  }

  private getHistoryPath(
    entries: SessionEntry[],
    targetNodeId: string
  ): SessionEntry[] {
    const nodeMap = new Map(entries.map(e => [e.id, e]));
    const path: SessionEntry[] = [];

    // 从目标节点向上追溯
    let currentId: string | undefined = targetNodeId;
    while (currentId) {
      const node = nodeMap.get(currentId);
      if (!node) break;

      path.unshift(node); // 添加到路径开头
      currentId = node.parentId;
    }

    return path;
  }
}
```

### 3.3 Fork 选择器

**三种 Fork 选项：**

```typescript
interface ForkOption {
  label: string;
  description: string;
  nodeId: string;
}

class ForkSelector {
  async selectForkPoint(currentNodeId: string): Promise<string> {
    const options: ForkOption[] = [
      {
        label: 'Current',
        description: '从当前节点 Fork（保留完整历史）',
        nodeId: currentNodeId
      },
      {
        label: 'Parent',
        description: '从父节点 Fork（减少一层历史）',
        nodeId: await this.getParentNodeId(currentNodeId)
      },
      {
        label: 'Root',
        description: '从根节点 Fork（最小历史）',
        nodeId: await this.getRootNodeId()
      }
    ];

    // 显示选项
    console.log('Fork from which point?');
    options.forEach((opt, i) => {
      console.log(`${i + 1}. [${opt.label}] ${opt.description}`);
    });

    // 获取用户选择
    const choice = await this.promptUser('Select (1-3): ');
    return options[parseInt(choice) - 1].nodeId;
  }
}
```

### 3.4 使用场景

**场景 1：尝试不同方案**
```bash
# 实现了方案 A
User: 实现功能 A
Assistant: 使用方案 A 完成

# Fork 尝试方案 B
/fork
User: 改用方案 B
Assistant: 使用方案 B 完成

# 现在有两个分支可以对比
```

**场景 2：保存检查点**
```bash
# 功能完成
User: 功能 A 完成并测试通过

# 创建检查点
/fork
/name checkpoint-feature-a

# 继续开发功能 B
User: 开始开发功能 B
# 如果出问题，可以回到检查点
```

---

## 4. 三种方式的对比

### 4.1 特性对比

| 特性 | /new | /resume | /fork |
|------|------|---------|-------|
| **创建新文件** | ✅ | ❌ | ✅ |
| **保留历史** | ❌ | ✅ | ✅（部分） |
| **上下文** | 空 | 完整 | 继承到 Fork 点 |
| **使用场景** | 新项目 | 继续工作 | 尝试方案 |
| **文件数量** | +1 | 0 | +1 |

### 4.2 决策树

```
需要创建会话？
├─ 是否需要历史上下文？
│  ├─ 不需要 → /new
│  └─ 需要
│     ├─ 继续原会话 → /resume
│     └─ 创建新分支 → /fork
└─ 否 → 继续当前会话
```

### 4.3 TypeScript 实现

```typescript
class SessionDecisionHelper {
  async suggestCommand(context: {
    hasCurrentSession: boolean;
    needsHistory: boolean;
    wantsNewBranch: boolean;
  }): Promise<string> {
    if (!context.hasCurrentSession) {
      return '/new';
    }

    if (!context.needsHistory) {
      return '/new';
    }

    if (context.wantsNewBranch) {
      return '/fork';
    }

    return '/resume';
  }
}
```

---

## 5. 高级用法

### 5.1 批量创建会话

```typescript
class BatchSessionCreator {
  async createMultipleSessions(names: string[]): Promise<Session[]> {
    const sessions: Session[] = [];

    for (const name of names) {
      const session = await this.sessionManager.createNewSession(name);
      sessions.push(session);
    }

    return sessions;
  }

  // 使用示例
  async setupProject() {
    const sessions = await this.createMultipleSessions([
      'project-backend',
      'project-frontend',
      'project-database'
    ]);

    console.log(`Created ${sessions.length} sessions`);
  }
}
```

### 5.2 智能 Fork

```typescript
class SmartFork {
  async forkWithStrategy(strategy: 'minimal' | 'recent' | 'full') {
    const currentNodeId = await this.getCurrentNodeId();

    let forkFromNodeId: string;

    switch (strategy) {
      case 'minimal':
        // Fork 从根节点
        forkFromNodeId = await this.getRootNodeId();
        break;

      case 'recent':
        // Fork 从最近 10 条消息
        forkFromNodeId = await this.getNodeNStepsBack(10);
        break;

      case 'full':
        // Fork 从当前节点
        forkFromNodeId = currentNodeId;
        break;
    }

    return await this.sessionManager.forkSession(
      this.currentSessionId,
      forkFromNodeId
    );
  }
}
```

### 5.3 自动命名

```typescript
class AutoNaming {
  async autoNameSession(sessionId: string) {
    // 1. 读取会话内容
    const entries = await this.sessionManager.readSession(sessionId);

    // 2. 提取关键词
    const keywords = this.extractKeywords(entries);

    // 3. 生成名称
    const name = keywords.slice(0, 3).join('-');

    // 4. 重命名会话
    await this.sessionManager.renameSession(sessionId, name);

    return name;
  }

  private extractKeywords(entries: SessionEntry[]): string[] {
    // 简单的关键词提取
    const text = entries
      .filter(e => e.type === 'message')
      .map(e => e.content)
      .join(' ');

    // 提取常见技术词汇
    const techWords = [
      'login', 'auth', 'api', 'database', 'frontend',
      'backend', 'test', 'deploy', 'bug', 'feature'
    ];

    return techWords.filter(word =>
      text.toLowerCase().includes(word)
    );
  }
}
```

---

## 6. 实战示例

### 示例 1：多方案对比工作流

```typescript
async function compareApproaches() {
  const manager = new SessionManager();

  // 1. 创建基础会话
  const baseSession = await manager.createNewSession('feature-auth');
  await baseSession.appendMessage('user', '实现用户认证');
  await baseSession.appendMessage('assistant', '基础实现完成');

  // 2. Fork 方案 A
  const sessionA = await manager.forkSession(
    baseSession.id,
    await baseSession.getCurrentNodeId()
  );
  await manager.renameSession(sessionA.id, 'feature-auth-jwt');
  await sessionA.appendMessage('user', '使用 JWT 认证');

  // 3. Fork 方案 B
  const sessionB = await manager.forkSession(
    baseSession.id,
    await baseSession.getCurrentNodeId()
  );
  await manager.renameSession(sessionB.id, 'feature-auth-session');
  await sessionB.appendMessage('user', '使用 Session 认证');

  // 4. 对比结果
  console.log('方案 A:', await sessionA.getContext());
  console.log('方案 B:', await sessionB.getContext());
}
```

### 示例 2：检查点工作流

```typescript
async function checkpointWorkflow() {
  const manager = new SessionManager();

  // 1. 创建主会话
  const mainSession = await manager.createNewSession('project-main');

  // 2. 开发功能 A
  await mainSession.appendMessage('user', '开发功能 A');
  await mainSession.appendMessage('assistant', '功能 A 完成');

  // 3. 创建检查点
  const checkpoint1 = await manager.forkSession(
    mainSession.id,
    await mainSession.getCurrentNodeId()
  );
  await manager.renameSession(checkpoint1.id, 'checkpoint-feature-a');

  // 4. 继续开发功能 B
  await mainSession.appendMessage('user', '开发功能 B');
  await mainSession.appendMessage('assistant', '功能 B 完成');

  // 5. 如果功能 B 出问题，恢复到检查点
  const restored = await manager.resumeSession('checkpoint-feature-a');
  console.log('恢复到检查点:', restored.id);
}
```

### 示例 3：团队协作工作流

```typescript
async function teamCollaborationWorkflow() {
  const manager = new SessionManager();

  // 1. 团队成员 A 创建会话
  const teamSession = await manager.createNewSession('team-project');
  await teamSession.appendMessage('user', '项目需求讨论');

  // 2. 团队成员 B Fork 并实现后端
  const backendSession = await manager.forkSession(
    teamSession.id,
    await teamSession.getCurrentNodeId()
  );
  await manager.renameSession(backendSession.id, 'team-project-backend');
  await backendSession.appendMessage('user', '实现后端 API');

  // 3. 团队成员 C Fork 并实现前端
  const frontendSession = await manager.forkSession(
    teamSession.id,
    await teamSession.getCurrentNodeId()
  );
  await manager.renameSession(frontendSession.id, 'team-project-frontend');
  await frontendSession.appendMessage('user', '实现前端界面');

  // 4. 查看所有分支
  const sessions = await manager.listSessions();
  console.log('团队会话:', sessions);
}
```

---

## 7. 最佳实践

### 7.1 命名规范

```typescript
// 推荐的命名规范
const namingConventions = {
  // 项目类型
  feature: 'feature-{name}',
  bugfix: 'bugfix-{issue}',
  refactor: 'refactor-{component}',
  experiment: 'exp-{idea}',

  // 检查点
  checkpoint: 'checkpoint-{milestone}',

  // 团队协作
  team: 'team-{project}-{member}',

  // 临时会话
  temp: 'temp-{date}'
};

// 使用示例
await manager.createNewSession('feature-user-login');
await manager.createNewSession('bugfix-auth-error');
await manager.createNewSession('checkpoint-v1.0');
```

### 7.2 会话组织

```typescript
class SessionOrganizer {
  async organizeByProject() {
    const sessions = await this.manager.listSessions();

    // 按项目分组
    const grouped = new Map<string, SessionInfo[]>();

    for (const session of sessions) {
      const project = session.id.split('-')[0];
      if (!grouped.has(project)) {
        grouped.set(project, []);
      }
      grouped.get(project)!.push(session);
    }

    return grouped;
  }

  async cleanupOldSessions(olderThanDays: number) {
    const sessions = await this.manager.listSessions();
    const cutoffTime = Date.now() - olderThanDays * 24 * 60 * 60 * 1000;

    for (const session of sessions) {
      if (session.lastModified < cutoffTime) {
        await this.manager.deleteSession(session.id);
      }
    }
  }
}
```

### 7.3 Fork 策略

```typescript
// 何时使用 Fork
const forkStrategies = {
  // 1. A/B 测试
  abTesting: async () => {
    const base = await getCurrentSession();
    const variantA = await fork(base, 'current');
    const variantB = await fork(base, 'current');
    return { variantA, variantB };
  },

  // 2. 保存检查点
  checkpoint: async () => {
    const current = await getCurrentSession();
    const checkpoint = await fork(current, 'current');
    await rename(checkpoint, `checkpoint-${Date.now()}`);
    return checkpoint;
  },

  // 3. 实验性开发
  experiment: async () => {
    const main = await getCurrentSession();
    const exp = await fork(main, 'current');
    await rename(exp, `exp-${generateId()}`);
    return exp;
  }
};
```

---

## 学习检查清单

完成本节学习后，你应该能够：

- [ ] 使用 /new 创建新会话
- [ ] 使用 /resume 恢复历史会话
- [ ] 使用 /fork 创建分支
- [ ] 理解三种方式的区别和使用场景
- [ ] 实现自定义的会话管理器
- [ ] 应用最佳实践组织会话

---

**版本：** v1.0
**最后更新：** 2026-02-18
**维护者：** Claude Code
