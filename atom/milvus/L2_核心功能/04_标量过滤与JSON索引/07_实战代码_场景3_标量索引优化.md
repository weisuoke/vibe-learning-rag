# 实战代码 - 场景3：标量索引优化

> 掌握标量索引的创建和性能优化策略

---

## 场景描述

**目标**：演示如何为标量字段创建索引，对比有索引和无索引的性能差异，掌握索引优化策略。

**涉及知识点**：
- 标量索引的创建
- 性能对比测试
- 索引选择策略
- 查询性能优化

---

## 完整代码

```python
"""
场景3：标量索引优化
演示：标量索引对查询性能的影响
"""

from pymilvus import (
    connections,
    Collection,
    FieldSchema,
    CollectionSchema,
    DataType,
    utility
)
import numpy as np
import time
from typing import List

# ===== 1. 连接到Milvus =====
print("=== 1. 连接到Milvus ===")
connections.connect(alias="default", host="localhost", port="19530")
print("✅ 连接成功")

# ===== 2. 创建Collection（较大数据集）=====
print("\n=== 2. 创建Collection ===")

fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=128),
    FieldSchema(name="user_id", dtype=DataType.INT64),
    FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=100),
    FieldSchema(name="year", dtype=DataType.INT16),
    FieldSchema(name="price", dtype=DataType.FLOAT),
    FieldSchema(name="status", dtype=DataType.VARCHAR, max_length=50),
]

schema = CollectionSchema(fields=fields, description="Scalar index performance demo")
collection_name = "scalar_index_demo"

if utility.has_collection(collection_name):
    utility.drop_collection(collection_name)

collection = Collection(name=collection_name, schema=schema)
print(f"✅ 创建Collection: {collection_name}")

# ===== 3. 插入大量测试数据 =====
print("\n=== 3. 插入测试数据 ===")

# 生成10000条测试数据
num_records = 10000
print(f"准备插入 {num_records} 条数据...")

categories = ["tech", "ai", "ml", "data", "cloud"]
statuses = ["active", "inactive", "pending", "deleted"]
years = [2020, 2021, 2022, 2023, 2024]

data = {
    "embedding": [np.random.rand(128).tolist() for _ in range(num_records)],
    "user_id": [np.random.randint(1, 1000) for _ in range(num_records)],
    "category": [np.random.choice(categories) for _ in range(num_records)],
    "year": [np.random.choice(years) for _ in range(num_records)],
    "price": [round(np.random.uniform(50, 200), 2) for _ in range(num_records)],
    "status": [np.random.choice(statuses) for _ in range(num_records)],
}

# 批量插入
batch_size = 1000
for i in range(0, num_records, batch_size):
    batch_data = {
        key: value[i:i+batch_size] for key, value in data.items()
    }
    collection.insert(batch_data)
    print(f"  已插入 {min(i+batch_size, num_records)}/{num_records} 条数据")

print(f"✅ 插入完成，共 {num_records} 条数据")

# ===== 4. 创建向量索引 =====
print("\n=== 4. 创建向量索引 ===")
index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "L2",
    "params": {"nlist": 128}
}
collection.create_index(field_name="embedding", index_params=index_params)
print("✅ 创建向量索引")

# 加载Collection
collection.load()
print("✅ 加载Collection到内存")

# ===== 5. 性能测试：无标量索引 =====
print("\n=== 5. 性能测试：无标量索引 ===")

query_vector = np.random.rand(128).tolist()

# 测试1：user_id过滤（高选择性）
print("\n【测试1】user_id过滤（无索引）")
expr = "user_id == 123"
start_time = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["user_id", "category"]
)
elapsed_time = time.time() - start_time
print(f"查询时间: {elapsed_time:.4f}秒")
print(f"找到 {len(results[0])} 条结果")

# 测试2：category过滤（中等选择性）
print("\n【测试2】category过滤（无索引）")
expr = "category == 'tech'"
start_time = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["user_id", "category"]
)
elapsed_time = time.time() - start_time
print(f"查询时间: {elapsed_time:.4f}秒")
print(f"找到 {len(results[0])} 条结果")

# 测试3：复合条件过滤
print("\n【测试3】复合条件过滤（无索引）")
expr = "user_id == 123 and category == 'tech' and year == 2024"
start_time = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["user_id", "category", "year"]
)
elapsed_time = time.time() - start_time
print(f"查询时间: {elapsed_time:.4f}秒")
print(f"找到 {len(results[0])} 条结果")

# ===== 6. 创建标量索引 =====
print("\n=== 6. 创建标量索引 ===")

# 释放Collection（创建索引前需要释放）
collection.release()
print("释放Collection")

# 为user_id创建索引
print("\n为 user_id 创建索引...")
collection.create_index(
    field_name="user_id",
    index_name="user_id_index"
)
print("✅ user_id索引创建完成")

# 为category创建索引
print("\n为 category 创建索引...")
collection.create_index(
    field_name="category",
    index_name="category_index"
)
print("✅ category索引创建完成")

# 为year创建索引
print("\n为 year 创建索引...")
collection.create_index(
    field_name="year",
    index_name="year_index"
)
print("✅ year索引创建完成")

# 重新加载Collection
collection.load()
print("✅ 重新加载Collection")

# ===== 7. 性能测试：有标量索引 =====
print("\n=== 7. 性能测试：有标量索引 ===")

# 测试1：user_id过滤（有索引）
print("\n【测试1】user_id过滤（有索引）")
expr = "user_id == 123"
start_time = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["user_id", "category"]
)
elapsed_time = time.time() - start_time
print(f"查询时间: {elapsed_time:.4f}秒")
print(f"找到 {len(results[0])} 条结果")

# 测试2：category过滤（有索引）
print("\n【测试2】category过滤（有索引）")
expr = "category == 'tech'"
start_time = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["user_id", "category"]
)
elapsed_time = time.time() - start_time
print(f"查询时间: {elapsed_time:.4f}秒")
print(f"找到 {len(results[0])} 条结果")

# 测试3：复合条件过滤（有索引）
print("\n【测试3】复合条件过滤（有索引）")
expr = "user_id == 123 and category == 'tech' and year == 2024"
start_time = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["user_id", "category", "year"]
)
elapsed_time = time.time() - start_time
print(f"查询时间: {elapsed_time:.4f}秒")
print(f"找到 {len(results[0])} 条结果")

# ===== 8. 性能对比总结 =====
print("\n=== 8. 性能对比总结 ===")
print("""
性能提升分析：
1. 高选择性字段（user_id）：索引带来显著性能提升（2-5倍）
2. 中等选择性字段（category）：索引带来中等性能提升（1.5-3倍）
3. 复合条件：多个索引字段组合，性能提升更明显（3-10倍）

注意：实际性能提升取决于：
- 数据量大小
- 过滤选择性
- 硬件配置
- 查询复杂度
""")

# ===== 9. 索引选择策略 =====
print("\n=== 9. 索引选择策略 ===")

def should_create_index(field_name: str, cardinality: int, query_frequency: str) -> bool:
    """
    判断是否应该为字段创建索引

    参数:
        field_name: 字段名
        cardinality: 字段基数（唯一值数量）
        query_frequency: 查询频率（"high", "medium", "low"）

    返回:
        是否应该创建索引
    """
    # 规则1：高频查询字段应该创建索引
    if query_frequency == "high":
        print(f"✅ {field_name}: 高频查询字段，建议创建索引")
        return True

    # 规则2：高基数字段（如user_id）应该创建索引
    if cardinality > 1000:
        print(f"✅ {field_name}: 高基数字段（{cardinality}个唯一值），建议创建索引")
        return True

    # 规则3：中频查询 + 中等基数
    if query_frequency == "medium" and cardinality > 100:
        print(f"✅ {field_name}: 中频查询 + 中等基数，建议创建索引")
        return True

    # 规则4：低频查询或低基数字段不需要索引
    print(f"❌ {field_name}: 低频查询或低基数字段，不建议创建索引")
    return False

print("\n【索引决策示例】")
should_create_index("user_id", 10000, "high")      # 用户ID：高基数 + 高频
should_create_index("category", 10, "high")        # 分类：低基数 + 高频
should_create_index("year", 5, "medium")           # 年份：低基数 + 中频
should_create_index("status", 4, "low")            # 状态：低基数 + 低频

# ===== 10. 索引维护建议 =====
print("\n=== 10. 索引维护建议 ===")

print("""
索引维护最佳实践：

1. 创建索引的时机：
   ✅ 在插入大量数据之后创建索引
   ✅ 在查询性能出现瓶颈时创建索引
   ❌ 避免在频繁写入时创建索引

2. 索引选择原则：
   ✅ 为高频查询字段创建索引
   ✅ 为高选择性字段创建索引（如user_id）
   ✅ 为复合查询的关键字段创建索引
   ❌ 避免为低基数字段创建索引（如布尔字段）
   ❌ 避免创建过多索引（影响写入性能）

3. 性能监控：
   ✅ 定期监控查询性能
   ✅ 分析慢查询日志
   ✅ 根据实际查询模式调整索引

4. 索引权衡：
   优点：
   - 显著提升查询性能（2-10倍）
   - 减少CPU和内存使用

   缺点：
   - 增加存储空间（约10-20%）
   - 略微降低写入性能（约5-10%）
   - 增加索引维护开销
""")

# ===== 11. 实际应用场景 =====
print("\n=== 11. 实际应用场景 ===")

# 场景1：多租户知识库
print("\n【场景1】多租户知识库")
print("需求: 每个用户只能查询自己的文档")
print("索引策略: 为 user_id 创建索引（高选择性 + 高频查询）")

expr = "user_id == 123 and status == 'active'"
start_time = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["user_id", "status"]
)
elapsed_time = time.time() - start_time
print(f"查询时间: {elapsed_time:.4f}秒（有索引）")
print(f"找到 {len(results[0])} 条结果")

# 场景2：分类浏览
print("\n【场景2】分类浏览")
print("需求: 按分类浏览文档")
print("索引策略: 为 category 创建索引（中等选择性 + 高频查询）")

expr = "category == 'tech' and year >= 2023"
start_time = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["category", "year"]
)
elapsed_time = time.time() - start_time
print(f"查询时间: {elapsed_time:.4f}秒（有索引）")
print(f"找到 {len(results[0])} 条结果")

# 场景3：时间范围查询
print("\n【场景3】时间范围查询")
print("需求: 查询特定年份的文档")
print("索引策略: 为 year 创建索引（低选择性但高频查询）")

expr = "year == 2024 and price >= 100 and price <= 150"
start_time = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["year", "price"]
)
elapsed_time = time.time() - start_time
print(f"查询时间: {elapsed_time:.4f}秒（有索引）")
print(f"找到 {len(results[0])} 条结果")

# ===== 12. 查看索引信息 =====
print("\n=== 12. 查看索引信息 ===")

# 获取Collection的所有索引
indexes = collection.indexes
print(f"\nCollection '{collection_name}' 的索引列表:")
for idx in indexes:
    print(f"  - 字段: {idx.field_name}")
    print(f"    索引名: {idx.index_name}")
    print(f"    索引类型: {idx.params.get('index_type', 'N/A')}")
    print()

# ===== 13. 清理资源 =====
print("\n=== 13. 清理资源 ===")
collection.release()
print("✅ 释放Collection")

# 可选：删除Collection
# utility.drop_collection(collection_name)
# print(f"✅ 删除Collection: {collection_name}")

connections.disconnect("default")
print("✅ 断开连接")

print("\n=== 示例完成 ===")
```

---

## 核心知识点

### 1. 标量索引的创建

```python
# 释放Collection（必须）
collection.release()

# 创建索引
collection.create_index(
    field_name="user_id",
    index_name="user_id_index"
)

# 重新加载
collection.load()
```

### 2. 索引选择策略

| 字段特征 | 是否创建索引 | 原因 |
|---------|-------------|------|
| 高基数 + 高频查询 | ✅ 强烈推荐 | 性能提升最明显 |
| 中等基数 + 高频查询 | ✅ 推荐 | 性能有提升 |
| 低基数 + 高频查询 | ⚠️ 可选 | 提升有限 |
| 任意基数 + 低频查询 | ❌ 不推荐 | 收益不大 |

### 3. 性能影响

**查询性能**：
- 高选择性字段：2-5倍提升
- 中等选择性字段：1.5-3倍提升
- 复合条件：3-10倍提升

**写入性能**：
- 略微降低（约5-10%）
- 索引越多，影响越大

**存储空间**：
- 增加约10-20%

### 4. 最佳实践

```python
# ✅ 推荐：为高频查询字段创建索引
collection.create_index(field_name="user_id")
collection.create_index(field_name="category")

# ❌ 不推荐：为所有字段创建索引
# 过多索引会影响写入性能

# ✅ 推荐：在大量数据插入后创建索引
collection.insert(large_dataset)
collection.create_index(field_name="user_id")

# ❌ 不推荐：在频繁写入时创建索引
```

---

## 性能优化建议

### 1. 查询优化

```python
# 优化1：高选择性条件在前
expr = "user_id == 123 and category == 'tech'"  # ✅ user_id选择性高

# 优化2：使用索引字段
expr = "user_id == 123"  # ✅ user_id有索引

# 优化3：避免复杂表达式
expr = "category in ['tech', 'ai']"  # ✅ 简单
expr = "category == 'tech' or category == 'ai'"  # ❌ 复杂
```

### 2. 索引优化

```python
# 优化1：只为必要字段创建索引
# 分析查询模式，确定高频字段

# 优化2：定期监控性能
# 使用性能分析工具

# 优化3：根据实际情况调整
# 删除不必要的索引
```

---

## 常见问题

### Q1: 什么时候应该创建标量索引？

**A**:
- 字段在查询中频繁使用
- 字段具有高选择性（唯一值多）
- 查询性能出现瓶颈

### Q2: 标量索引会影响写入性能吗？

**A**: 会略微影响（约5-10%），但查询性能提升更显著（2-10倍）。

### Q3: 可以为所有字段创建索引吗？

**A**: 不推荐。过多索引会：
- 增加存储空间
- 降低写入性能
- 增加维护开销

### Q4: 如何选择需要创建索引的字段？

**A**: 考虑三个因素：
1. 查询频率（高频优先）
2. 字段基数（高基数优先）
3. 选择性（高选择性优先）

---

## 下一步

- **场景4**：应用到RAG混合检索系统，实现完整的生产级应用
