# 实战代码 02 - 单元测试实战

## 场景1：测试 Pydantic 数据验证

### 被测试代码

```python
# app/models/message.py
"""消息模型"""
from pydantic import BaseModel, Field, validator
from datetime import datetime

class Message(BaseModel):
    """消息模型"""
    role: str = Field(..., pattern="^(user|assistant|system)$")
    content: str = Field(..., min_length=1, max_length=10000)
    timestamp: datetime = Field(default_factory=datetime.now)
    metadata: dict = Field(default_factory=dict)

    @validator("content")
    def content_not_empty(cls, v):
        """验证内容不为空"""
        if not v.strip():
            raise ValueError("Content cannot be empty or whitespace")
        return v.strip()

    @validator("metadata")
    def metadata_size_limit(cls, v):
        """验证元数据大小"""
        if len(str(v)) > 1000:
            raise ValueError("Metadata too large")
        return v

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
```

### 测试代码

```python
# tests/test_message_model.py
"""消息模型测试"""
import pytest
from pydantic import ValidationError
from datetime import datetime
from app.models.message import Message


class TestMessageCreation:
    """消息创建测试"""

    def test_create_message_valid(self):
        """测试：创建有效消息"""
        msg = Message(
            role="user",
            content="Hello, world!"
        )
        assert msg.role == "user"
        assert msg.content == "Hello, world!"
        assert isinstance(msg.timestamp, datetime)
        assert msg.metadata == {}

    def test_create_message_with_metadata(self):
        """测试：创建带元数据的消息"""
        metadata = {"source": "api", "user_id": 123}
        msg = Message(
            role="assistant",
            content="Response",
            metadata=metadata
        )
        assert msg.metadata == metadata

    def test_create_message_with_custom_timestamp(self):
        """测试：创建自定义时间戳的消息"""
        custom_time = datetime(2024, 1, 1, 12, 0, 0)
        msg = Message(
            role="system",
            content="System message",
            timestamp=custom_time
        )
        assert msg.timestamp == custom_time


class TestMessageValidation:
    """消息验证测试"""

    def test_invalid_role(self):
        """测试：无效角色"""
        with pytest.raises(ValidationError) as exc_info:
            Message(role="invalid", content="Test")

        errors = exc_info.value.errors()
        assert any("role" in str(e) for e in errors)

    @pytest.mark.parametrize("role", ["user", "assistant", "system"])
    def test_valid_roles(self, role):
        """测试：所有有效角色"""
        msg = Message(role=role, content="Test")
        assert msg.role == role

    def test_empty_content(self):
        """测试：空内容"""
        with pytest.raises(ValidationError) as exc_info:
            Message(role="user", content="")

        errors = exc_info.value.errors()
        assert any("content" in str(e) for e in errors)

    def test_whitespace_content(self):
        """测试：纯空白内容"""
        with pytest.raises(ValidationError, match="cannot be empty"):
            Message(role="user", content="   ")

    def test_content_too_long(self):
        """测试：内容过长"""
        long_content = "x" * 10001
        with pytest.raises(ValidationError) as exc_info:
            Message(role="user", content=long_content)

        errors = exc_info.value.errors()
        assert any("content" in str(e) for e in errors)

    def test_content_trimmed(self):
        """测试：内容自动去除空白"""
        msg = Message(role="user", content="  Hello  ")
        assert msg.content == "Hello"

    def test_metadata_too_large(self):
        """测试：元数据过大"""
        large_metadata = {"data": "x" * 1000}
        with pytest.raises(ValidationError, match="too large"):
            Message(role="user", content="Test", metadata=large_metadata)


class TestMessageSerialization:
    """消息序列化测试"""

    def test_to_dict(self):
        """测试：转换为字典"""
        msg = Message(role="user", content="Hello")
        data = msg.dict()

        assert data["role"] == "user"
        assert data["content"] == "Hello"
        assert "timestamp" in data
        assert "metadata" in data

    def test_to_json(self):
        """测试：转换为 JSON"""
        msg = Message(role="user", content="Hello")
        json_str = msg.json()

        assert "user" in json_str
        assert "Hello" in json_str
        assert isinstance(json_str, str)

    def test_from_dict(self):
        """测试：从字典创建"""
        data = {
            "role": "assistant",
            "content": "Response",
            "timestamp": "2024-01-01T12:00:00",
            "metadata": {"key": "value"}
        }
        msg = Message(**data)

        assert msg.role == "assistant"
        assert msg.content == "Response"
```

**运行测试**：

```bash
pytest tests/test_message_model.py -v
```

---

## 场景2：测试文本处理函数

### 被测试代码

```python
# app/utils/text_processing.py
"""文本处理工具"""
import re
from typing import List

def clean_text(text: str) -> str:
    """清理文本"""
    # 移除多余空白
    text = re.sub(r'\s+', ' ', text)
    # 去除首尾空白
    text = text.strip()
    return text

def split_sentences(text: str) -> List[str]:
    """分割句子"""
    # 简单的句子分割（按句号、问号、感叹号）
    sentences = re.split(r'[.!?]+', text)
    # 清理并过滤空句子
    sentences = [s.strip() for s in sentences if s.strip()]
    return sentences

def count_words(text: str) -> int:
    """统计单词数"""
    words = text.split()
    return len(words)

def truncate_text(text: str, max_length: int, suffix: str = "...") -> str:
    """截断文本"""
    if len(text) <= max_length:
        return text

    # 确保有空间放置后缀
    if max_length < len(suffix):
        return text[:max_length]

    # 截断并添加后缀
    truncated = text[:max_length - len(suffix)]
    return truncated + suffix

def extract_keywords(text: str, top_n: int = 5) -> List[str]:
    """提取关键词（简单实现：最常见的词）"""
    # 转小写并分词
    words = text.lower().split()

    # 过滤停用词
    stop_words = {"the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for"}
    words = [w for w in words if w not in stop_words]

    # 统计词频
    word_freq = {}
    for word in words:
        word_freq[word] = word_freq.get(word, 0) + 1

    # 排序并返回前 N 个
    sorted_words = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)
    return [word for word, _ in sorted_words[:top_n]]
```

### 测试代码

```python
# tests/test_text_processing.py
"""文本处理工具测试"""
import pytest
from app.utils.text_processing import (
    clean_text,
    split_sentences,
    count_words,
    truncate_text,
    extract_keywords
)


class TestCleanText:
    """文本清理测试"""

    def test_clean_text_basic(self):
        """测试：基本清理"""
        text = "  Hello   world  "
        result = clean_text(text)
        assert result == "Hello world"

    def test_clean_text_multiple_spaces(self):
        """测试：多个空格"""
        text = "Hello    world"
        result = clean_text(text)
        assert result == "Hello world"

    def test_clean_text_newlines(self):
        """测试：换行符"""
        text = "Hello\n\nworld"
        result = clean_text(text)
        assert result == "Hello world"

    def test_clean_text_tabs(self):
        """测试：制表符"""
        text = "Hello\t\tworld"
        result = clean_text(text)
        assert result == "Hello world"

    def test_clean_text_empty(self):
        """测试：空字符串"""
        assert clean_text("") == ""

    def test_clean_text_only_whitespace(self):
        """测试：纯空白"""
        assert clean_text("   \n\t  ") == ""


class TestSplitSentences:
    """句子分割测试"""

    def test_split_sentences_basic(self):
        """测试：基本分割"""
        text = "Hello. How are you? I'm fine!"
        sentences = split_sentences(text)
        assert len(sentences) == 3
        assert sentences[0] == "Hello"
        assert sentences[1] == "How are you"
        assert sentences[2] == "I'm fine"

    def test_split_sentences_multiple_punctuation(self):
        """测试：多个标点符号"""
        text = "Really?! Yes!!"
        sentences = split_sentences(text)
        assert len(sentences) == 2

    def test_split_sentences_no_punctuation(self):
        """测试：无标点符号"""
        text = "Hello world"
        sentences = split_sentences(text)
        assert len(sentences) == 1
        assert sentences[0] == "Hello world"

    def test_split_sentences_empty(self):
        """测试：空字符串"""
        assert split_sentences("") == []


class TestCountWords:
    """单词统计测试"""

    @pytest.mark.parametrize("text,expected", [
        ("Hello world", 2),
        ("One", 1),
        ("", 0),
        ("  ", 0),
        ("Hello  world  test", 3),
    ])
    def test_count_words(self, text, expected):
        """测试：单词统计（参数化）"""
        assert count_words(text) == expected


class TestTruncateText:
    """文本截断测试"""

    def test_truncate_text_no_truncation(self):
        """测试：不需要截断"""
        text = "Hello"
        result = truncate_text(text, max_length=10)
        assert result == "Hello"

    def test_truncate_text_basic(self):
        """测试：基本截断"""
        text = "Hello world, this is a test"
        result = truncate_text(text, max_length=15)
        assert result == "Hello world,..."
        assert len(result) == 15

    def test_truncate_text_custom_suffix(self):
        """测试：自定义后缀"""
        text = "Hello world"
        result = truncate_text(text, max_length=8, suffix=">>")
        assert result == "Hello >>>"
        assert len(result) == 8

    def test_truncate_text_max_length_too_small(self):
        """测试：最大长度过小"""
        text = "Hello world"
        result = truncate_text(text, max_length=2)
        assert result == "He"
        assert len(result) == 2

    @pytest.mark.parametrize("text,max_length,expected_length", [
        ("Hello world", 5, 5),
        ("Hello world", 10, 10),
        ("Hello world", 20, 11),  # 不截断
    ])
    def test_truncate_text_lengths(self, text, max_length, expected_length):
        """测试：各种长度（参数化）"""
        result = truncate_text(text, max_length)
        assert len(result) == expected_length


class TestExtractKeywords:
    """关键词提取测试"""

    def test_extract_keywords_basic(self):
        """测试：基本提取"""
        text = "Python is great. Python is powerful. Python is easy."
        keywords = extract_keywords(text, top_n=3)

        assert "python" in keywords
        assert "great" in keywords or "powerful" in keywords or "easy" in keywords

    def test_extract_keywords_filters_stop_words(self):
        """测试：过滤停用词"""
        text = "The cat and the dog"
        keywords = extract_keywords(text, top_n=5)

        # 停用词不应出现
        assert "the" not in keywords
        assert "and" not in keywords

        # 实际词应出现
        assert "cat" in keywords
        assert "dog" in keywords

    def test_extract_keywords_top_n(self):
        """测试：返回前 N 个"""
        text = "apple banana cherry apple banana apple"
        keywords = extract_keywords(text, top_n=2)

        assert len(keywords) == 2
        assert keywords[0] == "apple"  # 出现3次
        assert keywords[1] == "banana"  # 出现2次

    def test_extract_keywords_empty(self):
        """测试：空文本"""
        keywords = extract_keywords("", top_n=5)
        assert keywords == []

    def test_extract_keywords_only_stop_words(self):
        """测试：只有停用词"""
        text = "the and or but"
        keywords = extract_keywords(text, top_n=5)
        assert keywords == []
```

**运行测试**：

```bash
pytest tests/test_text_processing.py -v
```

---

## 场景3：测试异步函数

### 被测试代码

```python
# app/services/async_service.py
"""异步服务"""
import asyncio
from typing import List

async def fetch_data(url: str, timeout: float = 5.0) -> dict:
    """异步获取数据"""
    await asyncio.sleep(0.1)  # 模拟网络请求
    return {"url": url, "data": "test data"}

async def fetch_multiple(urls: List[str]) -> List[dict]:
    """并发获取多个数据"""
    tasks = [fetch_data(url) for url in urls]
    results = await asyncio.gather(*tasks)
    return results

async def process_with_retry(
    data: str,
    max_retries: int = 3
) -> str:
    """带重试的处理"""
    for attempt in range(max_retries):
        try:
            # 模拟可能失败的操作
            await asyncio.sleep(0.05)
            if len(data) == 0:
                raise ValueError("Empty data")
            return data.upper()
        except ValueError:
            if attempt == max_retries - 1:
                raise
            await asyncio.sleep(0.1)

async def stream_data(count: int):
    """流式生成数据"""
    for i in range(count):
        await asyncio.sleep(0.01)
        yield f"item_{i}"
```

### 测试代码

```python
# tests/test_async_service.py
"""异步服务测试"""
import pytest
import asyncio
from app.services.async_service import (
    fetch_data,
    fetch_multiple,
    process_with_retry,
    stream_data
)


class TestFetchData:
    """数据获取测试"""

    @pytest.mark.asyncio
    async def test_fetch_data_basic(self):
        """测试：基本数据获取"""
        result = await fetch_data("https://example.com")

        assert result["url"] == "https://example.com"
        assert "data" in result

    @pytest.mark.asyncio
    async def test_fetch_data_timeout(self):
        """测试：超时参数"""
        result = await fetch_data("https://example.com", timeout=10.0)
        assert result is not None


class TestFetchMultiple:
    """并发获取测试"""

    @pytest.mark.asyncio
    async def test_fetch_multiple_basic(self):
        """测试：并发获取多个"""
        urls = [
            "https://example.com/1",
            "https://example.com/2",
            "https://example.com/3"
        ]
        results = await fetch_multiple(urls)

        assert len(results) == 3
        assert all("url" in r for r in results)
        assert all("data" in r for r in results)

    @pytest.mark.asyncio
    async def test_fetch_multiple_empty(self):
        """测试：空列表"""
        results = await fetch_multiple([])
        assert results == []

    @pytest.mark.asyncio
    async def test_fetch_multiple_performance(self):
        """测试：并发性能"""
        import time

        urls = [f"https://example.com/{i}" for i in range(10)]

        start = time.time()
        results = await fetch_multiple(urls)
        duration = time.time() - start

        # 并发执行应该比串行快
        # 10个请求，每个0.1秒，串行需要1秒，并发应该接近0.1秒
        assert duration < 0.5  # 给一些余量
        assert len(results) == 10


class TestProcessWithRetry:
    """重试处理测试"""

    @pytest.mark.asyncio
    async def test_process_with_retry_success(self):
        """测试：处理成功"""
        result = await process_with_retry("hello")
        assert result == "HELLO"

    @pytest.mark.asyncio
    async def test_process_with_retry_failure(self):
        """测试：处理失败"""
        with pytest.raises(ValueError, match="Empty data"):
            await process_with_retry("")

    @pytest.mark.asyncio
    async def test_process_with_retry_custom_retries(self):
        """测试：自定义重试次数"""
        with pytest.raises(ValueError):
            await process_with_retry("", max_retries=5)


class TestStreamData:
    """流式数据测试"""

    @pytest.mark.asyncio
    async def test_stream_data_basic(self):
        """测试：基本流式数据"""
        items = []
        async for item in stream_data(5):
            items.append(item)

        assert len(items) == 5
        assert items[0] == "item_0"
        assert items[4] == "item_4"

    @pytest.mark.asyncio
    async def test_stream_data_empty(self):
        """测试：空流"""
        items = []
        async for item in stream_data(0):
            items.append(item)

        assert items == []

    @pytest.mark.asyncio
    async def test_stream_data_collect_all(self):
        """测试：收集所有数据"""
        items = [item async for item in stream_data(3)]

        assert len(items) == 3
        assert all(item.startswith("item_") for item in items)


class TestAsyncConcurrency:
    """异步并发测试"""

    @pytest.mark.asyncio
    async def test_concurrent_tasks(self):
        """测试：并发任务"""
        async def task(n: int) -> int:
            await asyncio.sleep(0.01)
            return n * 2

        # 并发执行多个任务
        results = await asyncio.gather(
            task(1),
            task(2),
            task(3)
        )

        assert results == [2, 4, 6]

    @pytest.mark.asyncio
    async def test_task_cancellation(self):
        """测试：任务取消"""
        async def long_task():
            await asyncio.sleep(10)
            return "done"

        task = asyncio.create_task(long_task())

        # 取消任务
        task.cancel()

        with pytest.raises(asyncio.CancelledError):
            await task
```

**运行测试**：

```bash
pytest tests/test_async_service.py -v
```

---

## 场景4：测试业务逻辑

### 被测试代码

```python
# app/services/user_service.py
"""用户服务"""
from typing import Optional
from app.models.user import User

class UserService:
    """用户服务"""

    def __init__(self):
        self.users = {}  # 简单的内存存储

    def create_user(self, username: str, email: str) -> User:
        """创建用户"""
        if username in self.users:
            raise ValueError(f"User {username} already exists")

        user = User(username=username, email=email)
        self.users[username] = user
        return user

    def get_user(self, username: str) -> Optional[User]:
        """获取用户"""
        return self.users.get(username)

    def update_user(self, username: str, email: str) -> User:
        """更新用户"""
        user = self.get_user(username)
        if user is None:
            raise ValueError(f"User {username} not found")

        user.email = email
        return user

    def delete_user(self, username: str) -> bool:
        """删除用户"""
        if username not in self.users:
            return False

        del self.users[username]
        return True

    def list_users(self) -> list[User]:
        """列出所有用户"""
        return list(self.users.values())

    def count_users(self) -> int:
        """统计用户数"""
        return len(self.users)
```

### 测试代码

```python
# tests/test_user_service.py
"""用户服务测试"""
import pytest
from app.services.user_service import UserService
from app.models.user import User


@pytest.fixture
def service():
    """用户服务 fixture"""
    return UserService()


@pytest.fixture
def service_with_users(service):
    """带用户的服务 fixture"""
    service.create_user("alice", "alice@example.com")
    service.create_user("bob", "bob@example.com")
    return service


class TestCreateUser:
    """创建用户测试"""

    def test_create_user_success(self, service):
        """测试：创建用户成功"""
        user = service.create_user("alice", "alice@example.com")

        assert user.username == "alice"
        assert user.email == "alice@example.com"
        assert service.count_users() == 1

    def test_create_user_duplicate(self, service):
        """测试：创建重复用户"""
        service.create_user("alice", "alice@example.com")

        with pytest.raises(ValueError, match="already exists"):
            service.create_user("alice", "another@example.com")

    def test_create_multiple_users(self, service):
        """测试：创建多个用户"""
        service.create_user("alice", "alice@example.com")
        service.create_user("bob", "bob@example.com")

        assert service.count_users() == 2


class TestGetUser:
    """获取用户测试"""

    def test_get_user_exists(self, service_with_users):
        """测试：获取存在的用户"""
        user = service_with_users.get_user("alice")

        assert user is not None
        assert user.username == "alice"

    def test_get_user_not_exists(self, service):
        """测试：获取不存在的用户"""
        user = service.get_user("nonexistent")
        assert user is None


class TestUpdateUser:
    """更新用户测试"""

    def test_update_user_success(self, service_with_users):
        """测试：更新用户成功"""
        user = service_with_users.update_user("alice", "newemail@example.com")

        assert user.email == "newemail@example.com"

        # 验证更新已保存
        updated = service_with_users.get_user("alice")
        assert updated.email == "newemail@example.com"

    def test_update_user_not_exists(self, service):
        """测试：更新不存在的用户"""
        with pytest.raises(ValueError, match="not found"):
            service.update_user("nonexistent", "email@example.com")


class TestDeleteUser:
    """删除用户测试"""

    def test_delete_user_success(self, service_with_users):
        """测试：删除用户成功"""
        result = service_with_users.delete_user("alice")

        assert result is True
        assert service_with_users.get_user("alice") is None
        assert service_with_users.count_users() == 1

    def test_delete_user_not_exists(self, service):
        """测试：删除不存在的用户"""
        result = service.delete_user("nonexistent")
        assert result is False


class TestListUsers:
    """列出用户测试"""

    def test_list_users_empty(self, service):
        """测试：空列表"""
        users = service.list_users()
        assert users == []

    def test_list_users_multiple(self, service_with_users):
        """测试：多个用户"""
        users = service_with_users.list_users()

        assert len(users) == 2
        usernames = [u.username for u in users]
        assert "alice" in usernames
        assert "bob" in usernames


class TestCountUsers:
    """统计用户测试"""

    def test_count_users_empty(self, service):
        """测试：空服务"""
        assert service.count_users() == 0

    def test_count_users_after_operations(self, service):
        """测试：操作后统计"""
        assert service.count_users() == 0

        service.create_user("alice", "alice@example.com")
        assert service.count_users() == 1

        service.create_user("bob", "bob@example.com")
        assert service.count_users() == 2

        service.delete_user("alice")
        assert service.count_users() == 1
```

**运行测试**：

```bash
pytest tests/test_user_service.py -v
```

---

## 总结

### 核心要点

1. **Pydantic 测试**：测试数据验证、序列化、反序列化
2. **文本处理测试**：测试各种边界条件和特殊情况
3. **异步测试**：使用 `@pytest.mark.asyncio` 测试异步函数
4. **业务逻辑测试**：测试服务层的完整业务流程

### 最佳实践

- 使用 fixture 准备测试数据
- 使用参数化减少重复代码
- 测试边界条件和异常情况
- 使用清晰的测试命名
- 每个测试只测试一个功能点
