# æ‰©å±•ä¸å®šåˆ¶

> é€šè¿‡ Extensions æ‰©å±•å’Œå®šåˆ¶ Pi çš„å››ä¸ªåŸºç¡€å·¥å…·

---

## Extension åŸºç¡€

### Extension ç»“æ„

```typescript
// my-extension.ts
import { Extension } from '@mariozechner/pi-agent-core'

export const myExtension: Extension = {
  name: 'my-extension',
  version: '1.0.0',

  // æ³¨å†Œæ–°å·¥å…·
  tools: [
    {
      name: 'my-tool',
      description: 'My custom tool',
      execute: async (input: string) => {
        return `Processed: ${input}`
      }
    }
  ],

  // æ³¨å†Œ hooks
  hooks: {
    beforeSpawn: async (command, options) => {
      console.log(`Executing: ${command}`)
      return { command, ...options }
    }
  }
}
```

---

## åœºæ™¯ 1ï¼šæ·»åŠ ç¼“å­˜å±‚

```typescript
// cache-extension.ts
import { Extension } from '@mariozechner/pi-agent-core'
import fs from 'fs'
import crypto from 'crypto'

class CacheExtension {
  private cache: Map<string, string> = new Map()
  private cacheDir = '.pi-cache'

  constructor() {
    if (!fs.existsSync(this.cacheDir)) {
      fs.mkdirSync(this.cacheDir)
    }
  }

  /**
   * è®¡ç®—ç¼“å­˜é”®
   */
  private getCacheKey(path: string): string {
    return crypto.createHash('md5').update(path).digest('hex')
  }

  /**
   * åˆ›å»ºæ‰©å±•
   */
  createExtension(): Extension {
    return {
      name: 'cache',
      version: '1.0.0',

      tools: [
        {
          name: 'read',
          override: true,
          execute: async (path: string) => {
            // æ£€æŸ¥ç¼“å­˜
            const cacheKey = this.getCacheKey(path)

            if (this.cache.has(cacheKey)) {
              console.log(`ğŸ“¦ Cache hit: ${path}`)
              return this.cache.get(cacheKey)!
            }

            // è¯»å–æ–‡ä»¶
            console.log(`ğŸ“– Reading: ${path}`)
            const content = fs.readFileSync(path, 'utf-8')

            // ç¼“å­˜ç»“æœ
            this.cache.set(cacheKey, content)

            return content
          }
        }
      ],

      hooks: {
        afterWrite: async (path: string) => {
          // å†™å…¥åæ¸…é™¤ç¼“å­˜
          const cacheKey = this.getCacheKey(path)
          this.cache.delete(cacheKey)
          console.log(`ğŸ—‘ï¸  Cache cleared: ${path}`)
        },

        afterEdit: async (path: string) => {
          // ç¼–è¾‘åæ¸…é™¤ç¼“å­˜
          const cacheKey = this.getCacheKey(path)
          this.cache.delete(cacheKey)
          console.log(`ğŸ—‘ï¸  Cache cleared: ${path}`)
        }
      }
    }
  }
}

export const cacheExtension = new CacheExtension().createExtension()
```

---

## åœºæ™¯ 2ï¼šæ·»åŠ  LSP è¯Šæ–­

```typescript
// lsp-extension.ts
import { Extension } from '@mariozechner/pi-agent-core'
import { execSync } from 'child_process'

class LSPExtension {
  /**
   * è¿è¡Œ TypeScript è¯Šæ–­
   */
  private async runDiagnostics(path: string): Promise<string[]> {
    try {
      execSync(`tsc --noEmit ${path}`, { encoding: 'utf-8' })
      return []
    } catch (error) {
      const output = error.stdout || error.stderr
      return this.parseDiagnostics(output)
    }
  }

  /**
   * è§£æè¯Šæ–­è¾“å‡º
   */
  private parseDiagnostics(output: string): string[] {
    const lines = output.split('\n')
    return lines.filter(line => line.includes('error TS'))
  }

  /**
   * åˆ›å»ºæ‰©å±•
   */
  createExtension(): Extension {
    return {
      name: 'lsp-diagnostics',
      version: '1.0.0',

      hooks: {
        afterWrite: async (path: string) => {
          if (!path.match(/\.(ts|tsx)$/)) return

          console.log(`\nğŸ” Running diagnostics...`)
          const diagnostics = await this.runDiagnostics(path)

          if (diagnostics.length === 0) {
            console.log(`âœ… No errors found`)
          } else {
            console.log(`âŒ Found ${diagnostics.length} errors:`)
            diagnostics.forEach(d => console.log(`  ${d}`))
          }
        },

        afterEdit: async (path: string) => {
          if (!path.match(/\.(ts|tsx)$/)) return

          console.log(`\nğŸ” Running diagnostics...`)
          const diagnostics = await this.runDiagnostics(path)

          if (diagnostics.length === 0) {
            console.log(`âœ… No errors found`)
          } else {
            console.log(`âŒ Found ${diagnostics.length} errors:`)
            diagnostics.forEach(d => console.log(`  ${d}`))
          }
        }
      }
    }
  }
}

export const lspExtension = new LSPExtension().createExtension()
```

---

## åœºæ™¯ 3ï¼šæ·»åŠ å®‰å…¨æ£€æŸ¥

```typescript
// security-extension.ts
import { Extension } from '@mariozechner/pi-agent-core'

class SecurityExtension {
  private dangerousCommands = [
    /rm\s+-rf\s+\//,
    /dd\s+if=/,
    /mkfs/,
    /:\(\)\{\s*:\|:&\s*\};:/  // Fork bomb
  ]

  private sensitivePatterns = [
    /password\s*=\s*['"][^'"]+['"]/i,
    /api[_-]?key\s*=\s*['"][^'"]+['"]/i,
    /secret\s*=\s*['"][^'"]+['"]/i
  ]

  /**
   * æ£€æŸ¥å±é™©å‘½ä»¤
   */
  private isDangerousCommand(command: string): boolean {
    return this.dangerousCommands.some(pattern => pattern.test(command))
  }

  /**
   * æ£€æŸ¥æ•æ„Ÿä¿¡æ¯
   */
  private hasSensitiveInfo(content: string): string[] {
    const matches: string[] = []

    for (const pattern of this.sensitivePatterns) {
      const match = content.match(pattern)
      if (match) {
        matches.push(match[0])
      }
    }

    return matches
  }

  /**
   * åˆ›å»ºæ‰©å±•
   */
  createExtension(): Extension {
    return {
      name: 'security',
      version: '1.0.0',

      hooks: {
        beforeSpawn: async (command, options) => {
          // æ£€æŸ¥å±é™©å‘½ä»¤
          if (this.isDangerousCommand(command)) {
            throw new Error(`ğŸš« Dangerous command blocked: ${command}`)
          }

          // æ£€æŸ¥ force push
          if (command.includes('git push --force')) {
            console.log(`âš ï¸  Warning: Force push detected`)
            // å¯ä»¥æ·»åŠ ç”¨æˆ·ç¡®è®¤é€»è¾‘
          }

          return { command, ...options }
        },

        beforeWrite: async (path, content) => {
          // æ£€æŸ¥æ•æ„Ÿä¿¡æ¯
          const sensitive = this.hasSensitiveInfo(content)

          if (sensitive.length > 0) {
            console.log(`âš ï¸  Warning: Sensitive information detected:`)
            sensitive.forEach(s => console.log(`  - ${s}`))
            // å¯ä»¥æ·»åŠ ç”¨æˆ·ç¡®è®¤é€»è¾‘
          }

          return { path, content }
        }
      }
    }
  }
}

export const securityExtension = new SecurityExtension().createExtension()
```

---

## åœºæ™¯ 4ï¼šæ·»åŠ è¿œç¨‹æ‰§è¡Œ

```typescript
// ssh-extension.ts
import { Extension } from '@mariozechner/pi-agent-core'
import { execSync } from 'child_process'
import fs from 'fs'

class SSHExtension {
  constructor(
    private host: string,
    private user: string
  ) {}

  /**
   * åœ¨è¿œç¨‹æœåŠ¡å™¨æ‰§è¡Œå‘½ä»¤
   */
  private async remoteExec(command: string): Promise<string> {
    const sshCommand = `ssh ${this.user}@${this.host} "${command}"`
    return execSync(sshCommand, { encoding: 'utf-8' })
  }

  /**
   * è¯»å–è¿œç¨‹æ–‡ä»¶
   */
  private async remoteRead(path: string): Promise<string> {
    return this.remoteExec(`cat ${path}`)
  }

  /**
   * å†™å…¥è¿œç¨‹æ–‡ä»¶
   */
  private async remoteWrite(path: string, content: string): Promise<void> {
    // è½¬ä¹‰å†…å®¹
    const escaped = content.replace(/"/g, '\\"')
    await this.remoteExec(`echo "${escaped}" > ${path}`)
  }

  /**
   * åˆ›å»ºæ‰©å±•
   */
  createExtension(): Extension {
    return {
      name: 'ssh-remote',
      version: '1.0.0',

      tools: [
        {
          name: 'read',
          override: true,
          execute: async (path: string) => {
            console.log(`ğŸ“– Reading from ${this.host}: ${path}`)
            return this.remoteRead(path)
          }
        },
        {
          name: 'write',
          override: true,
          execute: async (path: string, content: string) => {
            console.log(`ğŸ“ Writing to ${this.host}: ${path}`)
            await this.remoteWrite(path, content)
          }
        }
      ],

      hooks: {
        beforeSpawn: async (command, options) => {
          // åœ¨è¿œç¨‹æœåŠ¡å™¨æ‰§è¡Œå‘½ä»¤
          console.log(`ğŸ–¥ï¸  Executing on ${this.host}: ${command}`)
          return {
            command: `ssh ${this.user}@${this.host} "${command}"`,
            ...options
          }
        }
      }
    }
  }
}

export const sshExtension = new SSHExtension('server.com', 'user').createExtension()
```

---

## åœºæ™¯ 5ï¼šæ·»åŠ æ ¼å¼åŒ–

```typescript
// format-extension.ts
import { Extension } from '@mariozechner/pi-agent-core'
import { execSync } from 'child_process'

class FormatExtension {
  /**
   * æ ¼å¼åŒ–æ–‡ä»¶
   */
  private async formatFile(path: string): Promise<void> {
    if (path.match(/\.(ts|tsx|js|jsx)$/)) {
      execSync(`prettier --write ${path}`)
      console.log(`âœ¨ Formatted: ${path}`)
    }
  }

  /**
   * åˆ›å»ºæ‰©å±•
   */
  createExtension(): Extension {
    return {
      name: 'auto-format',
      version: '1.0.0',

      hooks: {
        afterWrite: async (path: string) => {
          await this.formatFile(path)
        },

        afterEdit: async (path: string) => {
          await this.formatFile(path)
        }
      }
    }
  }
}

export const formatExtension = new FormatExtension().createExtension()
```

---

## æ³¨å†Œå’Œä½¿ç”¨ Extensions

### æ–¹æ³• 1ï¼šé€šè¿‡é…ç½®æ–‡ä»¶

```json
// .pi/extensions.json
{
  "extensions": [
    "./extensions/cache-extension.js",
    "./extensions/lsp-extension.js",
    "./extensions/security-extension.js"
  ]
}
```

### æ–¹æ³• 2ï¼šé€šè¿‡ä»£ç 

```typescript
// extensions/index.ts
import { registerExtension } from '@mariozechner/pi-agent-core'
import { cacheExtension } from './cache-extension'
import { lspExtension } from './lsp-extension'
import { securityExtension } from './security-extension'

// æ³¨å†Œæ‰©å±•
registerExtension(cacheExtension)
registerExtension(lspExtension)
registerExtension(securityExtension)
```

---

## æœ€ä½³å®è·µ

### 1. Extension å‘½å

```typescript
// âœ… å¥½çš„å‘½å
name: 'cache'
name: 'lsp-diagnostics'
name: 'ssh-remote'

// âŒ ä¸å¥½çš„å‘½å
name: 'ext1'
name: 'my_extension'
```

### 2. é”™è¯¯å¤„ç†

```typescript
hooks: {
  beforeSpawn: async (command, options) => {
    try {
      // æ£€æŸ¥é€»è¾‘
      return { command, ...options }
    } catch (error) {
      console.error('Extension error:', error.message)
      throw error
    }
  }
}
```

### 3. æ€§èƒ½è€ƒè™‘

```typescript
// âœ… å¥½çš„åšæ³•ï¼šåªåœ¨éœ€è¦æ—¶è¿è¡Œ
afterWrite: async (path: string) => {
  if (!path.match(/\.(ts|tsx)$/)) return
  await runDiagnostics(path)
}

// âŒ ä¸å¥½çš„åšæ³•ï¼šæ€»æ˜¯è¿è¡Œ
afterWrite: async (path: string) => {
  await runDiagnostics(path)  // å¯¹æ‰€æœ‰æ–‡ä»¶è¿è¡Œ
}
```

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2026-02-19
**ç»´æŠ¤è€…ï¼š** Claude Code
