# åç›´è§‰ç‚¹ï¼šé“¾å¼è°ƒè¯•ä¸æ—¥å¿—

## ä»€ä¹ˆæ˜¯åç›´è§‰ç‚¹ï¼Ÿ

**åç›´è§‰ç‚¹**æ˜¯æŒ‡é‚£äº›çœ‹èµ·æ¥ç†æ‰€å½“ç„¶ï¼Œä½†å®é™…ä¸Šä¸ç›´è§‰ç›¸åçš„çŸ¥è¯†ç‚¹ã€‚

ç†è§£è¿™äº›åç›´è§‰ç‚¹ï¼Œå¯ä»¥é¿å…å¸¸è§çš„è¯¯åŒºå’Œé™·é˜±ã€‚

---

## è¯¯åŒº1ï¼šastream_events ä¸å½±å“æ€§èƒ½

### ç›´è§‰è®¤ä¸º

"è°ƒè¯•å·¥å…·åªæ˜¯æŸ¥çœ‹æ•°æ®ï¼Œä¸ä¼šå½±å“æ€§èƒ½ã€‚"

å°±åƒç”¨React DevToolsæŸ¥çœ‹ç»„ä»¶ï¼Œä¸ä¼šè®©åº”ç”¨å˜æ…¢ã€‚

---

### å®é™…æƒ…å†µ

**astream_events() æœ‰10-20%çš„æ€§èƒ½å¼€é”€ï¼**

**åŸå› **ï¼š
1. **äº‹ä»¶åºåˆ—åŒ–**ï¼šæ¯ä¸ªäº‹ä»¶éƒ½éœ€è¦åºåˆ—åŒ–æˆJSON
2. **å†…å­˜å ç”¨**ï¼šäº‹ä»¶æµä¼šå ç”¨é¢å¤–å†…å­˜
3. **å¼‚æ­¥å¼€é”€**ï¼šå¼‚æ­¥è¿­ä»£å™¨æœ‰é¢å¤–å¼€é”€
4. **æ•°æ®å¤åˆ¶**ï¼šäº‹ä»¶æ•°æ®éœ€è¦å¤åˆ¶

---

### æ€§èƒ½æµ‹è¯•

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from dotenv import load_dotenv
import asyncio
import time

load_dotenv()

prompt = ChatPromptTemplate.from_template("å›ç­”é—®é¢˜: {question}")
model = ChatOpenAI(model="gpt-4o-mini")
chain = prompt | model | StrOutputParser()

# æµ‹è¯•1: ä¸ä½¿ç”¨astream_events
async def test_without_events():
    start = time.time()
    result = await chain.ainvoke({"question": "ä»€ä¹ˆæ˜¯LCEL?"})
    duration = time.time() - start
    print(f"Without events: {duration:.2f}s")
    return duration

# æµ‹è¯•2: ä½¿ç”¨astream_events
async def test_with_events():
    start = time.time()
    async for event in chain.astream_events(
        {"question": "ä»€ä¹ˆæ˜¯LCEL?"},
        version="v2"
    ):
        pass  # åªéå†ï¼Œä¸å¤„ç†
    duration = time.time() - start
    print(f"With events: {duration:.2f}s")
    return duration

# è¿è¡Œæµ‹è¯•
async def run_tests():
    without = await test_without_events()
    with_events = await test_with_events()
    overhead = (with_events - without) / without * 100
    print(f"Performance overhead: {overhead:.1f}%")

asyncio.run(run_tests())
```

**è¾“å‡ºç¤ºä¾‹**ï¼š
```
Without events: 1.23s
With events: 1.45s
Performance overhead: 17.9%
```

---

### æ­£ç¡®åšæ³•

**å¼€å‘é˜¶æ®µ**ï¼šæ”¾å¿ƒä½¿ç”¨ï¼Œæ€§èƒ½ä¸æ˜¯é¦–è¦è€ƒè™‘

```python
# å¼€å‘æ—¶ï¼šè¯¦ç»†è°ƒè¯•
async for event in chain.astream_events(input, version="v2"):
    print(f"{event['event']}: {event['name']}")
```

**ç”Ÿäº§é˜¶æ®µ**ï¼šç§»é™¤æˆ–ä½¿ç”¨é‡‡æ ·

```python
# ç”Ÿäº§æ—¶ï¼šç§»é™¤è°ƒè¯•ä»£ç 
result = await chain.ainvoke(input)

# æˆ–è€…ï¼šä½¿ç”¨é‡‡æ ·ï¼ˆåªè°ƒè¯•1%çš„è¯·æ±‚ï¼‰
import random
if random.random() < 0.01:  # 1%é‡‡æ ·
    async for event in chain.astream_events(input, version="v2"):
        logger.debug(f"{event['event']}: {event['name']}")
```

---

### å…³é”®è®°å¿†ç‚¹

- âŒ **é”™è¯¯**ï¼šastream_events æ²¡æœ‰æ€§èƒ½å¼€é”€
- âœ… **æ­£ç¡®**ï¼šastream_events æœ‰10-20%å¼€é”€ï¼Œç”Ÿäº§ç¯å¢ƒè°¨æ…ä½¿ç”¨
- ğŸ’¡ **å»ºè®®**ï¼šå¼€å‘ç”¨ï¼Œç”Ÿäº§ç§»é™¤æˆ–é‡‡æ ·

---

## è¯¯åŒº2ï¼šå›è°ƒå¤„ç†å™¨ä¼šè‡ªåŠ¨å¼‚æ­¥æ‰§è¡Œ

### ç›´è§‰è®¤ä¸º

"å›è°ƒå¤„ç†å™¨æ˜¯å¼‚æ­¥çš„ï¼Œä¸ä¼šé˜»å¡é“¾æ‰§è¡Œã€‚"

å°±åƒJavaScriptçš„å›è°ƒå‡½æ•°ï¼Œä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹ã€‚

---

### å®é™…æƒ…å†µ

**åŒæ­¥å›è°ƒä¼šé˜»å¡é“¾æ‰§è¡Œï¼**

**åŸå› **ï¼š
1. **é»˜è®¤åŒæ­¥**ï¼š`BaseCallbackHandler` çš„æ–¹æ³•æ˜¯åŒæ­¥çš„
2. **é¡ºåºæ‰§è¡Œ**ï¼šå›è°ƒæŒ‰é¡ºåºæ‰§è¡Œï¼Œå‰ä¸€ä¸ªä¸å®Œæˆï¼Œåä¸€ä¸ªä¸å¼€å§‹
3. **é˜»å¡é“¾**ï¼šå›è°ƒæ‰§è¡Œæ—¶ï¼Œé“¾ä¼šç­‰å¾…

---

### é˜»å¡ç¤ºä¾‹

```python
from langchain_core.callbacks import BaseCallbackHandler
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from dotenv import load_dotenv
import time

load_dotenv()

# åŒæ­¥å›è°ƒï¼ˆä¼šé˜»å¡ï¼‰
class SlowLogHandler(BaseCallbackHandler):
    def on_chain_start(self, serialized, inputs, **kwargs):
        print("Logging started...")
        time.sleep(2)  # æ¨¡æ‹Ÿæ…¢é€Ÿæ—¥å¿—å†™å…¥
        print("Logging completed")

prompt = ChatPromptTemplate.from_template("å›ç­”é—®é¢˜: {question}")
model = ChatOpenAI(model="gpt-4o-mini")
chain = prompt | model

# æµ‹è¯•
start = time.time()
result = chain.invoke(
    {"question": "ä»€ä¹ˆæ˜¯LCEL?"},
    config={"callbacks": [SlowLogHandler()]}
)
duration = time.time() - start
print(f"Total time: {duration:.2f}s")  # ä¼šåŒ…å«2ç§’çš„æ—¥å¿—æ—¶é—´
```

**è¾“å‡ºç¤ºä¾‹**ï¼š
```
Logging started...
Logging completed
Total time: 3.45s  # åŒ…å«2ç§’çš„æ—¥å¿—æ—¶é—´
```

---

### æ­£ç¡®åšæ³•

**æ–¹æ¡ˆ1ï¼šä½¿ç”¨å¼‚æ­¥å›è°ƒ**

```python
from langchain_core.callbacks import AsyncCallbackHandler
import asyncio

class AsyncLogHandler(AsyncCallbackHandler):
    async def on_chain_start(self, serialized, inputs, **kwargs):
        print("Logging started...")
        await asyncio.sleep(2)  # å¼‚æ­¥ç­‰å¾…
        print("Logging completed")

# ä½¿ç”¨å¼‚æ­¥è°ƒç”¨
result = await chain.ainvoke(
    {"question": "ä»€ä¹ˆæ˜¯LCEL?"},
    config={"callbacks": [AsyncLogHandler()]}
)
```

**æ–¹æ¡ˆ2ï¼šåå°ä»»åŠ¡**

```python
import threading

class BackgroundLogHandler(BaseCallbackHandler):
    def on_chain_start(self, serialized, inputs, **kwargs):
        # åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œ
        def log_in_background():
            time.sleep(2)
            print("Logging completed")

        thread = threading.Thread(target=log_in_background)
        thread.daemon = True
        thread.start()
        print("Logging started (background)")

# ä¸ä¼šé˜»å¡é“¾æ‰§è¡Œ
result = chain.invoke(
    {"question": "ä»€ä¹ˆæ˜¯LCEL?"},
    config={"callbacks": [BackgroundLogHandler()]}
)
```

**æ–¹æ¡ˆ3ï¼šå¿«é€Ÿå›è°ƒ**

```python
import queue

class FastLogHandler(BaseCallbackHandler):
    def __init__(self):
        self.log_queue = queue.Queue()

    def on_chain_start(self, serialized, inputs, **kwargs):
        # å¿«é€Ÿæ”¾å…¥é˜Ÿåˆ—ï¼Œä¸é˜»å¡
        self.log_queue.put(("chain_start", inputs))

# å¦ä¸€ä¸ªçº¿ç¨‹å¤„ç†é˜Ÿåˆ—
def process_logs(log_queue):
    while True:
        event_type, data = log_queue.get()
        # æ…¢é€Ÿå¤„ç†
        time.sleep(2)
        print(f"Logged: {event_type}")
```

---

### å…³é”®è®°å¿†ç‚¹

- âŒ **é”™è¯¯**ï¼šå›è°ƒå¤„ç†å™¨è‡ªåŠ¨å¼‚æ­¥æ‰§è¡Œ
- âœ… **æ­£ç¡®**ï¼šåŒæ­¥å›è°ƒä¼šé˜»å¡é“¾æ‰§è¡Œ
- ğŸ’¡ **å»ºè®®**ï¼šä½¿ç”¨ `AsyncCallbackHandler` æˆ–åå°ä»»åŠ¡

---

## è¯¯åŒº3ï¼šç›‘æ§è¶Šè¯¦ç»†è¶Šå¥½

### ç›´è§‰è®¤ä¸º

"ç›‘æ§æ•°æ®è¶Šå¤šè¶Šå¥½ï¼Œå¯ä»¥çœ‹åˆ°æ‰€æœ‰ç»†èŠ‚ã€‚"

å°±åƒå¥åº·ä½“æ£€ï¼Œæ£€æŸ¥é¡¹ç›®è¶Šå¤šè¶Šå¥½ã€‚

---

### å®é™…æƒ…å†µ

**è¿‡åº¦ç›‘æ§ä¼šå¢åŠ æˆæœ¬å’Œå¤æ‚åº¦ï¼**

**é—®é¢˜**ï¼š
1. **å­˜å‚¨æˆæœ¬**ï¼šè¯¦ç»†æ—¥å¿—å ç”¨å¤§é‡å­˜å‚¨ç©ºé—´
2. **ç½‘ç»œå¼€é”€**ï¼šä¸Šä¼ ç›‘æ§æ•°æ®æ¶ˆè€—å¸¦å®½
3. **æŸ¥è¯¢æ…¢**ï¼šæ•°æ®å¤ªå¤šï¼ŒæŸ¥è¯¢å˜æ…¢
4. **ä¿¡å™ªæ¯”ä½**ï¼šå…³é”®ä¿¡æ¯è¢«æ·¹æ²¡
5. **ç»´æŠ¤æˆæœ¬**ï¼šå¤æ‚çš„ç›‘æ§ç³»ç»Ÿéš¾ä»¥ç»´æŠ¤

---

### è¿‡åº¦ç›‘æ§ç¤ºä¾‹

```python
from langchain_core.callbacks import BaseCallbackHandler
import json
import time

class OverlyDetailedHandler(BaseCallbackHandler):
    """è¿‡åº¦è¯¦ç»†çš„ç›‘æ§ï¼ˆä¸æ¨èï¼‰"""

    def on_chain_start(self, serialized, inputs, **kwargs):
        self._log({
            "event": "chain_start",
            "timestamp": time.time(),
            "serialized": serialized,  # å¤§é‡åºåˆ—åŒ–æ•°æ®
            "inputs": inputs,
            "kwargs": kwargs,
            "stack_trace": self._get_stack_trace(),  # å †æ ˆä¿¡æ¯
            "memory_usage": self._get_memory_usage(),  # å†…å­˜ä½¿ç”¨
            "cpu_usage": self._get_cpu_usage(),  # CPUä½¿ç”¨
        })

    def on_llm_start(self, serialized, prompts, **kwargs):
        self._log({
            "event": "llm_start",
            "timestamp": time.time(),
            "serialized": serialized,
            "prompts": prompts,  # å®Œæ•´prompt
            "kwargs": kwargs,
            "model_config": self._get_model_config(),
        })

    def on_llm_end(self, response, **kwargs):
        self._log({
            "event": "llm_end",
            "timestamp": time.time(),
            "response": str(response),  # å®Œæ•´å“åº”
            "token_usage": response.llm_output,
            "kwargs": kwargs,
        })

    def _log(self, data):
        # æ¯ä¸ªäº‹ä»¶éƒ½å†™å…¥æ–‡ä»¶ï¼ˆæ…¢ï¼‰
        with open("detailed_logs.jsonl", "a") as f:
            f.write(json.dumps(data, ensure_ascii=False) + "\n")

# é—®é¢˜ï¼š
# 1. æ—¥å¿—æ–‡ä»¶å¿«é€Ÿå¢é•¿ï¼ˆæ¯å¤©GBçº§åˆ«ï¼‰
# 2. å†™å…¥æ–‡ä»¶é˜»å¡é“¾æ‰§è¡Œ
# 3. åŒ…å«å¤§é‡æ— ç”¨ä¿¡æ¯
# 4. éš¾ä»¥æŸ¥è¯¢å’Œåˆ†æ
```

---

### æ­£ç¡®åšæ³•

**åŸåˆ™**ï¼šåªè®°å½•å…³é”®ä¿¡æ¯ï¼Œä½¿ç”¨åˆ†çº§ç›‘æ§

**çº§åˆ«1ï¼šæœ€å°ç›‘æ§ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰**

```python
class MinimalHandler(BaseCallbackHandler):
    """æœ€å°ç›‘æ§ï¼šåªè®°å½•å…³é”®æŒ‡æ ‡"""

    def on_chain_start(self, serialized, inputs, **kwargs):
        self.start_time = time.time()

    def on_chain_end(self, outputs, **kwargs):
        duration = time.time() - self.start_time
        # åªè®°å½•å…³é”®æŒ‡æ ‡
        logger.info(f"chain_duration={duration:.2f}s")

    def on_chain_error(self, error, **kwargs):
        # åªè®°å½•é”™è¯¯
        logger.error(f"chain_error={str(error)}")
```

**çº§åˆ«2ï¼šæ ‡å‡†ç›‘æ§ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰**

```python
class StandardHandler(BaseCallbackHandler):
    """æ ‡å‡†ç›‘æ§ï¼šå…³é”®æŒ‡æ ‡ + é‡‡æ ·è¯¦æƒ…"""

    def __init__(self, sample_rate=0.01):
        self.sample_rate = sample_rate
        self.start_time = None

    def on_chain_start(self, serialized, inputs, **kwargs):
        self.start_time = time.time()
        # é‡‡æ ·è®°å½•è¾“å…¥
        if random.random() < self.sample_rate:
            logger.debug(f"inputs={inputs}")

    def on_chain_end(self, outputs, **kwargs):
        duration = time.time() - self.start_time
        # æ€»æ˜¯è®°å½•å…³é”®æŒ‡æ ‡
        logger.info(f"duration={duration:.2f}s")
        # é‡‡æ ·è®°å½•è¾“å‡º
        if random.random() < self.sample_rate:
            logger.debug(f"outputs={str(outputs)[:100]}")

    def on_llm_end(self, response, **kwargs):
        # æ€»æ˜¯è®°å½•Tokenä½¿ç”¨
        tokens = response.llm_output.get("token_usage", {})
        logger.info(f"tokens={tokens}")
```

**çº§åˆ«3ï¼šè¯¦ç»†ç›‘æ§ï¼ˆè°ƒè¯•ç¯å¢ƒï¼‰**

```python
class DetailedHandler(BaseCallbackHandler):
    """è¯¦ç»†ç›‘æ§ï¼šä»…ç”¨äºè°ƒè¯•"""

    def on_chain_start(self, serialized, inputs, **kwargs):
        logger.debug(f"chain_start: {inputs}")

    def on_llm_start(self, serialized, prompts, **kwargs):
        logger.debug(f"llm_start: {prompts}")

    def on_llm_end(self, response, **kwargs):
        logger.debug(f"llm_end: {response.content}")
```

---

### ç›‘æ§åˆ†çº§ç­–ç•¥

| ç¯å¢ƒ | ç›‘æ§çº§åˆ« | è®°å½•å†…å®¹ | é‡‡æ ·ç‡ |
|------|----------|----------|--------|
| **ç”Ÿäº§** | æœ€å° | å»¶è¿Ÿã€é”™è¯¯ã€Token | 100% |
| **ç”Ÿäº§** | æ ‡å‡† | + é‡‡æ ·è¾“å…¥è¾“å‡º | 1-5% |
| **é¢„å‘å¸ƒ** | è¯¦ç»† | æ‰€æœ‰äº‹ä»¶ | 10-20% |
| **å¼€å‘** | å®Œæ•´ | æ‰€æœ‰ç»†èŠ‚ | 100% |

---

### æˆæœ¬å¯¹æ¯”

**åœºæ™¯**ï¼šæ¯å¤©100ä¸‡æ¬¡é“¾æ‰§è¡Œ

| ç›‘æ§çº§åˆ« | æ—¥å¿—å¤§å° | å­˜å‚¨æˆæœ¬/æœˆ | æŸ¥è¯¢é€Ÿåº¦ |
|----------|----------|-------------|----------|
| **è¿‡åº¦** | 500GB | $100+ | æ…¢ |
| **æ ‡å‡†** | 50GB | $10 | å¿« |
| **æœ€å°** | 5GB | $1 | å¾ˆå¿« |

---

### å…³é”®è®°å¿†ç‚¹

- âŒ **é”™è¯¯**ï¼šç›‘æ§è¶Šè¯¦ç»†è¶Šå¥½
- âœ… **æ­£ç¡®**ï¼šç›‘æ§è¦åˆ†çº§ï¼Œç”Ÿäº§ç¯å¢ƒåªè®°å½•å…³é”®æŒ‡æ ‡
- ğŸ’¡ **å»ºè®®**ï¼šä½¿ç”¨é‡‡æ ·ç­–ç•¥ï¼Œå¹³è¡¡æˆæœ¬å’Œå¯è§‚æµ‹æ€§

---

## è¯¯åŒº4ï¼šLangSmithæ˜¯å…è´¹çš„

### ç›´è§‰è®¤ä¸º

"LangSmithæ˜¯LangChainå®˜æ–¹å·¥å…·ï¼Œåº”è¯¥å…è´¹ä½¿ç”¨ã€‚"

---

### å®é™…æƒ…å†µ

**LangSmithæœ‰ä½¿ç”¨é™åˆ¶å’Œè´¹ç”¨ï¼**

**å…è´¹è®¡åˆ’**ï¼š
- 5,000 traces/æœˆ
- ä¿ç•™30å¤©
- åŸºç¡€åŠŸèƒ½

**ä»˜è´¹è®¡åˆ’**ï¼š
- Developer: $39/æœˆï¼ˆ50,000 tracesï¼‰
- Team: $199/æœˆï¼ˆ500,000 tracesï¼‰
- Enterprise: å®šåˆ¶ä»·æ ¼

**è¶…å‡ºé™åˆ¶**ï¼š
- è‡ªåŠ¨åœæ­¢è¿½è¸ª
- æˆ–æŒ‰é‡è®¡è´¹

---

### æˆæœ¬è®¡ç®—

**åœºæ™¯**ï¼šä¸­ç­‰è§„æ¨¡åº”ç”¨

```python
# å‡è®¾ï¼š
# - æ¯å¤©10,000æ¬¡é“¾æ‰§è¡Œ
# - æ¯æœˆ300,000æ¬¡é“¾æ‰§è¡Œ

# å…è´¹è®¡åˆ’ï¼š5,000 traces/æœˆ
# éœ€è¦ï¼š300,000 / 5,000 = 60å€

# ä»˜è´¹è®¡åˆ’ï¼šTeam ($199/æœˆ)
# å¯ä»¥ï¼š500,000 traces/æœˆ
# è¶³å¤Ÿä½¿ç”¨
```

---

### æ­£ç¡®åšæ³•

**æ–¹æ¡ˆ1ï¼šä½¿ç”¨é‡‡æ ·**

```python
import os
import random

# åªè¿½è¸ª10%çš„è¯·æ±‚
if random.random() < 0.1:
    os.environ["LANGCHAIN_TRACING_V2"] = "true"
else:
    os.environ["LANGCHAIN_TRACING_V2"] = "false"

result = chain.invoke(input)
```

**æ–¹æ¡ˆ2ï¼šæ¡ä»¶è¿½è¸ª**

```python
# åªè¿½è¸ªé”™è¯¯æˆ–æ…¢è¯·æ±‚
def should_trace(duration, error):
    if error:
        return True  # æ€»æ˜¯è¿½è¸ªé”™è¯¯
    if duration > 5.0:
        return True  # è¿½è¸ªæ…¢è¯·æ±‚
    return random.random() < 0.01  # 1%é‡‡æ ·

# ä½¿ç”¨
start = time.time()
try:
    result = chain.invoke(input)
    duration = time.time() - start
    error = None
except Exception as e:
    duration = time.time() - start
    error = e

if should_trace(duration, error):
    # é‡æ–°æ‰§è¡Œå¹¶è¿½è¸ª
    os.environ["LANGCHAIN_TRACING_V2"] = "true"
    result = chain.invoke(input)
```

**æ–¹æ¡ˆ3ï¼šä½¿ç”¨å¼€æºæ›¿ä»£**

```python
# OpenTelemetryï¼ˆå¼€æºï¼‰
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider

# å¯¼å‡ºåˆ°è‡ªå·±çš„ç›‘æ§ç³»ç»Ÿ
trace.set_tracer_provider(TracerProvider())
# å…è´¹ï¼Œä½†éœ€è¦è‡ªå·±æ­å»ºç›‘æ§ç³»ç»Ÿ
```

---

### å…³é”®è®°å¿†ç‚¹

- âŒ **é”™è¯¯**ï¼šLangSmithå®Œå…¨å…è´¹
- âœ… **æ­£ç¡®**ï¼šLangSmithæœ‰ä½¿ç”¨é™åˆ¶ï¼Œè¶…å‡ºéœ€ä»˜è´¹
- ğŸ’¡ **å»ºè®®**ï¼šä½¿ç”¨é‡‡æ ·æˆ–å¼€æºæ›¿ä»£æ–¹æ¡ˆ

---

## è¯¯åŒº5ï¼šæ‰€æœ‰äº‹ä»¶éƒ½éœ€è¦å¤„ç†

### ç›´è§‰è®¤ä¸º

"æ—¢ç„¶æœ‰è¿™ä¹ˆå¤šäº‹ä»¶ç±»å‹ï¼Œåº”è¯¥éƒ½å¤„ç†ä¸€éã€‚"

---

### å®é™…æƒ…å†µ

**å¤§å¤šæ•°äº‹ä»¶ä½ ä¸éœ€è¦å…³å¿ƒï¼**

**å¸¸è§äº‹ä»¶**ï¼š
- `on_chain_start/end` - é“¾å¼€å§‹/ç»“æŸ
- `on_llm_start/end` - LLMå¼€å§‹/ç»“æŸ
- `on_tool_start/end` - å·¥å…·å¼€å§‹/ç»“æŸ
- `on_retriever_start/end` - æ£€ç´¢å¼€å§‹/ç»“æŸ
- `on_prompt_start/end` - Promptå¼€å§‹/ç»“æŸ
- `on_parser_start/end` - è§£æå™¨å¼€å§‹/ç»“æŸ

**å®é™…éœ€è¦**ï¼š
- 90%çš„åœºæ™¯åªéœ€è¦ `on_chain_start/end`
- 5%çš„åœºæ™¯éœ€è¦ `on_llm_start/end`
- 5%çš„åœºæ™¯éœ€è¦å…¶ä»–äº‹ä»¶

---

### è¿‡åº¦å¤„ç†ç¤ºä¾‹

```python
class OverlyComplexHandler(BaseCallbackHandler):
    """è¿‡åº¦å¤æ‚ï¼ˆä¸æ¨èï¼‰"""

    def on_chain_start(self, serialized, inputs, **kwargs):
        logger.info("Chain started")

    def on_chain_end(self, outputs, **kwargs):
        logger.info("Chain ended")

    def on_prompt_start(self, serialized, inputs, **kwargs):
        logger.info("Prompt started")

    def on_prompt_end(self, outputs, **kwargs):
        logger.info("Prompt ended")

    def on_llm_start(self, serialized, prompts, **kwargs):
        logger.info("LLM started")

    def on_llm_end(self, response, **kwargs):
        logger.info("LLM ended")

    def on_parser_start(self, serialized, inputs, **kwargs):
        logger.info("Parser started")

    def on_parser_end(self, outputs, **kwargs):
        logger.info("Parser ended")

    # ... è¿˜æœ‰æ›´å¤šæ–¹æ³•

# é—®é¢˜ï¼š
# 1. ä»£ç å†—é•¿
# 2. æ—¥å¿—å™ªéŸ³å¤§
# 3. ç»´æŠ¤å›°éš¾
```

---

### æ­£ç¡®åšæ³•

**åŸåˆ™**ï¼šåªå¤„ç†å…³é”®äº‹ä»¶

```python
class SimpleHandler(BaseCallbackHandler):
    """ç®€å•æœ‰æ•ˆï¼ˆæ¨èï¼‰"""

    def on_chain_start(self, serialized, inputs, **kwargs):
        self.start_time = time.time()
        logger.info(f"Request: {inputs}")

    def on_chain_end(self, outputs, **kwargs):
        duration = time.time() - self.start_time
        logger.info(f"Response: {outputs}, Duration: {duration:.2f}s")

    def on_chain_error(self, error, **kwargs):
        logger.error(f"Error: {error}")

# åªå¤„ç†3ä¸ªå…³é”®äº‹ä»¶ï¼Œç®€å•æ¸…æ™°
```

---

### äº‹ä»¶é€‰æ‹©æŒ‡å—

| éœ€æ±‚ | éœ€è¦çš„äº‹ä»¶ |
|------|------------|
| **åŸºç¡€æ—¥å¿—** | `on_chain_start/end/error` |
| **æ€§èƒ½ç›‘æ§** | + `on_llm_start/end` |
| **è°ƒè¯•Prompt** | + `on_prompt_end` |
| **è°ƒè¯•æ£€ç´¢** | + `on_retriever_end` |
| **è°ƒè¯•å·¥å…·** | + `on_tool_start/end` |

---

### å…³é”®è®°å¿†ç‚¹

- âŒ **é”™è¯¯**ï¼šæ‰€æœ‰äº‹ä»¶éƒ½éœ€è¦å¤„ç†
- âœ… **æ­£ç¡®**ï¼šåªå¤„ç†å…³é”®äº‹ä»¶ï¼Œä¿æŒç®€å•
- ğŸ’¡ **å»ºè®®**ï¼šä» `on_chain_start/end/error` å¼€å§‹

---

## åç›´è§‰ç‚¹æ€»ç»“

### äº”å¤§è¯¯åŒº

| è¯¯åŒº | ç›´è§‰ | å®é™… | æ­£ç¡®åšæ³• |
|------|------|------|----------|
| **æ€§èƒ½å¼€é”€** | è°ƒè¯•æ— å¼€é”€ | 10-20%å¼€é”€ | ç”Ÿäº§ç§»é™¤æˆ–é‡‡æ · |
| **å¼‚æ­¥æ‰§è¡Œ** | å›è°ƒè‡ªåŠ¨å¼‚æ­¥ | åŒæ­¥å›è°ƒé˜»å¡ | ä½¿ç”¨AsyncCallbackHandler |
| **ç›‘æ§è¯¦ç»†åº¦** | è¶Šè¯¦ç»†è¶Šå¥½ | è¿‡åº¦ç›‘æ§å¢åŠ æˆæœ¬ | åˆ†çº§ç›‘æ§ï¼Œé‡‡æ ·ç­–ç•¥ |
| **LangSmithæˆæœ¬** | å®Œå…¨å…è´¹ | æœ‰ä½¿ç”¨é™åˆ¶ | é‡‡æ ·æˆ–å¼€æºæ›¿ä»£ |
| **äº‹ä»¶å¤„ç†** | éƒ½è¦å¤„ç† | åªéœ€å…³é”®äº‹ä»¶ | åªå¤„ç†å¿…è¦äº‹ä»¶ |

---

### æ ¸å¿ƒåŸåˆ™

1. **æ€§èƒ½ä¼˜å…ˆ**ï¼šå¼€å‘å¯ä»¥ç‰ºç‰²æ€§èƒ½ï¼Œç”Ÿäº§å¿…é¡»ä¼˜åŒ–
2. **å¼‚æ­¥ä¼˜å…ˆ**ï¼šå›è°ƒå¤„ç†å™¨ä¼˜å…ˆä½¿ç”¨å¼‚æ­¥
3. **æˆæœ¬æ„è¯†**ï¼šç›‘æ§è¦è€ƒè™‘æˆæœ¬ï¼Œä¸æ˜¯è¶Šå¤šè¶Šå¥½
4. **ç®€å•ä¼˜å…ˆ**ï¼šåªå¤„ç†å¿…è¦çš„äº‹ä»¶ï¼Œä¿æŒä»£ç ç®€å•

---

### å®è·µå»ºè®®

**å¼€å‘é˜¶æ®µ**ï¼š
- âœ… ä½¿ç”¨ `astream_events()` è¯¦ç»†è°ƒè¯•
- âœ… å®ç°è¯¦ç»†çš„å›è°ƒå¤„ç†å™¨
- âœ… è®°å½•æ‰€æœ‰äº‹ä»¶

**ç”Ÿäº§é˜¶æ®µ**ï¼š
- âœ… ç§»é™¤ `astream_events()` æˆ–ä½¿ç”¨é‡‡æ ·
- âœ… ä½¿ç”¨ `AsyncCallbackHandler`
- âœ… åªè®°å½•å…³é”®æŒ‡æ ‡
- âœ… ä½¿ç”¨åˆ†çº§ç›‘æ§ç­–ç•¥
- âœ… è€ƒè™‘æˆæœ¬å’Œæ€§èƒ½

---

## æœ€åçš„è¯

ç†è§£è¿™äº›åç›´è§‰ç‚¹ï¼Œå¯ä»¥å¸®åŠ©ä½ ï¼š

1. **é¿å…æ€§èƒ½é™·é˜±**ï¼šçŸ¥é“è°ƒè¯•å·¥å…·çš„å¼€é”€
2. **é¿å…é˜»å¡é—®é¢˜**ï¼šæ­£ç¡®ä½¿ç”¨å¼‚æ­¥å›è°ƒ
3. **æ§åˆ¶æˆæœ¬**ï¼šåˆç†è®¾è®¡ç›‘æ§ç­–ç•¥
4. **ä¿æŒç®€å•**ï¼šåªå¤„ç†å¿…è¦çš„äº‹ä»¶

**è®°ä½**ï¼šè°ƒè¯•å’Œæ—¥å¿—æ˜¯ä¸ºäº†æé«˜æ•ˆç‡ï¼Œè€Œä¸æ˜¯å¢åŠ è´Ÿæ‹…ã€‚åˆç†ä½¿ç”¨ï¼Œæ‰èƒ½å‘æŒ¥æœ€å¤§ä»·å€¼ã€‚

---

**ç‰ˆæœ¬ä¿¡æ¯**
- LangChain: v0.3+ (2025-2026)
- Python: 3.13+
- æœ€åæ›´æ–°: 2026-02-20
