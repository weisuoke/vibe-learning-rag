# 核心概念2：动态字段的数据操作

> 深入理解动态字段的插入、查询、更新和删除操作

---

## 概述

本文将详细讲解动态字段的完整数据操作流程：
1. 插入动态字段数据
2. 查询动态字段数据
3. 更新动态字段数据
4. 删除包含动态字段的数据
5. 批量操作优化

---

## 1. 插入动态字段数据

### 1.1 基本插入操作

```python
from pymilvus import connections, Collection, CollectionSchema, FieldSchema, DataType

# 连接Milvus
connections.connect(host="localhost", port="19530")

# 创建启用动态Schema的Collection
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=1000)
]

schema = CollectionSchema(fields=fields, enable_dynamic_field=True)
collection = Collection(name="dynamic_insert_demo", schema=schema)

# 插入数据（包含动态字段）
data = [
    {
        "text": "Document 1",
        "embedding": [0.1] * 768,
        # 动态字段
        "author": "Alice",
        "category": "tech",
        "priority": 5
    },
    {
        "text": "Document 2",
        "embedding": [0.2] * 768,
        # 不同的动态字段
        "author": "Bob",
        "tags": ["AI", "ML"],
        "is_public": True
    }
]

# 执行插入
result = collection.insert(data)
collection.flush()

print(f"✅ 插入成功，ID列表: {result.primary_keys}")
```

**关键点**：
- 动态字段无需预先定义，自动识别
- 每条数据可以有不同的动态字段
- 插入后需要调用`flush()`确保数据持久化

---

### 1.2 支持的动态字段类型

```python
# Milvus支持的动态字段类型
data = [
    {
        "text": "Type demo",
        "embedding": [0.1] * 768,

        # 基本类型
        "string_field": "Hello",           # VARCHAR
        "int_field": 42,                   # INT64
        "float_field": 3.14,               # DOUBLE
        "bool_field": True,                # BOOL

        # 数组类型
        "int_array": [1, 2, 3],           # ARRAY<INT64>
        "float_array": [1.1, 2.2, 3.3],   # ARRAY<DOUBLE>
        "string_array": ["a", "b", "c"],  # ARRAY<VARCHAR>

        # JSON类型
        "json_field": {                    # JSON
            "nested": {
                "key": "value"
            },
            "array": [1, 2, 3]
        }
    }
]

collection.insert(data)
collection.flush()
```

**类型推断规则**：
- Python `str` → Milvus `VARCHAR`
- Python `int` → Milvus `INT64`
- Python `float` → Milvus `DOUBLE`
- Python `bool` → Milvus `BOOL`
- Python `list` → Milvus `ARRAY`
- Python `dict` → Milvus `JSON`

---

### 1.3 批量插入优化

```python
import numpy as np

# 批量插入（推荐：每批1000-10000条）
batch_size = 5000
total_docs = 50000

for i in range(0, total_docs, batch_size):
    batch_data = []
    for j in range(batch_size):
        doc_id = i + j
        batch_data.append({
            "text": f"Document {doc_id}",
            "embedding": np.random.rand(768).tolist(),
            # 动态字段
            "author": f"Author_{doc_id % 100}",
            "category": f"Category_{doc_id % 10}",
            "priority": doc_id % 5
        })

    # 批量插入
    collection.insert(batch_data)

    # 每10批flush一次
    if (i // batch_size) % 10 == 0:
        collection.flush()
        print(f"✅ 已插入 {i + batch_size} 条数据")

# 最后flush
collection.flush()
print(f"✅ 总共插入 {total_docs} 条数据")
```

**性能优化建议**：
- 批量大小：1000-10000条
- 定期flush：每10批flush一次
- 避免频繁flush：flush是昂贵操作

---

### 1.4 插入时的类型验证

```python
class DynamicFieldValidator:
    """动态字段类型验证器"""

    def __init__(self):
        self.field_types = {}

    def validate_and_insert(self, collection, data):
        """验证类型并插入"""
        for item in data:
            for field_name, value in item.items():
                # 跳过固定字段
                if field_name in ["text", "embedding"]:
                    continue

                # 获取类型
                value_type = type(value).__name__

                # 检查类型一致性
                if field_name in self.field_types:
                    if self.field_types[field_name] != value_type:
                        raise TypeError(
                            f"字段 '{field_name}' 类型不一致: "
                            f"期望 {self.field_types[field_name]}, "
                            f"实际 {value_type}"
                        )
                else:
                    # 记录类型
                    self.field_types[field_name] = value_type

        # 验证通过，插入数据
        result = collection.insert(data)
        collection.flush()
        return result

# 使用示例
validator = DynamicFieldValidator()

# 第一批数据
data1 = [
    {"text": "doc1", "embedding": [0.1]*768, "priority": 5}
]
validator.validate_and_insert(collection, data1)

# 第二批数据（类型一致）
data2 = [
    {"text": "doc2", "embedding": [0.2]*768, "priority": 3}
]
validator.validate_and_insert(collection, data2)  # ✅ 成功

# 第三批数据（类型不一致）
data3 = [
    {"text": "doc3", "embedding": [0.3]*768, "priority": "high"}
]
try:
    validator.validate_and_insert(collection, data3)  # ❌ 失败
except TypeError as e:
    print(f"类型验证失败: {e}")
```

---

## 2. 查询动态字段数据

### 2.1 基本查询操作

```python
# 查询所有字段（包括动态字段）
results = collection.query(
    expr="id > 0",
    output_fields=["*"]  # * 表示所有字段
)

for result in results[:3]:
    print(f"ID: {result['id']}")
    print(f"Text: {result['text']}")
    print(f"Author: {result.get('author', 'N/A')}")  # 动态字段
    print(f"Category: {result.get('category', 'N/A')}")  # 动态字段
    print("---")
```

**关键点**：
- `output_fields=["*"]`：返回所有字段（包括动态字段）
- 使用`.get()`方法：安全访问可能不存在的动态字段
- 动态字段可能不存在：不是所有数据都有相同的动态字段

---

### 2.2 指定返回的动态字段

```python
# 只返回特定字段
results = collection.query(
    expr="id > 0",
    output_fields=["text", "author", "category"],  # 指定字段
    limit=10
)

for result in results:
    print(f"Text: {result['text']}")
    print(f"Author: {result.get('author', 'Unknown')}")
    print(f"Category: {result.get('category', 'Uncategorized')}")
    print("---")
```

**性能优化**：
- 只返回需要的字段，减少网络传输
- 避免返回大型JSON字段

---

### 2.3 按动态字段过滤

```python
# 按动态字段过滤（等值查询）
results = collection.query(
    expr='author == "Alice"',  # 动态字段过滤
    output_fields=["*"]
)
print(f"✅ 找到 {len(results)} 条 Alice 的数据")

# 按动态字段过滤（范围查询）
results = collection.query(
    expr='priority > 3',  # 动态字段范围查询
    output_fields=["*"]
)
print(f"✅ 找到 {len(results)} 条高优先级数据")

# 组合过滤（固定字段 + 动态字段）
results = collection.query(
    expr='text like "Document%" and author == "Alice"',
    output_fields=["*"]
)
print(f"✅ 找到 {len(results)} 条符合条件的数据")

# 复杂过滤
results = collection.query(
    expr='(author == "Alice" or author == "Bob") and priority > 3',
    output_fields=["*"]
)
```

**支持的过滤操作**：
- 等值：`==`, `!=`
- 比较：`>`, `<`, `>=`, `<=`
- 逻辑：`and`, `or`, `not`
- 成员：`in`, `not in`
- 模糊：`like`

---

### 2.4 向量检索 + 动态字段过滤

```python
# 创建索引
index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "L2",
    "params": {"nlist": 128}
}
collection.create_index(field_name="embedding", index_params=index_params)
collection.load()

# 向量检索 + 动态字段过滤
query_vector = [0.15] * 768
search_params = {"metric_type": "L2", "params": {"nprobe": 10}}

results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param=search_params,
    limit=10,
    expr='author == "Alice" and priority > 3',  # 动态字段过滤
    output_fields=["text", "author", "priority"]
)

for hits in results:
    for hit in hits:
        print(f"ID: {hit.id}, Distance: {hit.distance:.4f}")
        print(f"Text: {hit.entity.get('text')}")
        print(f"Author: {hit.entity.get('author')}")
        print(f"Priority: {hit.entity.get('priority')}")
        print("---")
```

**性能注意**：
- 动态字段过滤会降低检索性能（无索引）
- 建议先用固定字段过滤，再用动态字段过滤

---

### 2.5 分页查询

```python
# 分页查询动态字段
page_size = 100
offset = 0

while True:
    results = collection.query(
        expr=f"id >= {offset}",
        output_fields=["*"],
        limit=page_size
    )

    if not results:
        break

    # 处理当前页数据
    for result in results:
        print(f"ID: {result['id']}, Author: {result.get('author', 'N/A')}")

    # 更新offset
    offset = results[-1]['id'] + 1

    print(f"✅ 已处理 {offset} 条数据")
```

---

## 3. 更新动态字段数据

### 3.1 Milvus不支持直接更新

**重要**：Milvus不支持直接更新操作，需要先删除再插入

```python
# ❌ 错误：Milvus不支持update操作
# collection.update({"id": 1, "priority": 10})  # 不存在此方法

# ✅ 正确：先删除再插入
def update_document(collection, doc_id, updates):
    """更新文档（先删除再插入）"""

    # 步骤1：查询原始数据
    results = collection.query(
        expr=f"id == {doc_id}",
        output_fields=["*"]
    )

    if not results:
        print(f"❌ 文档 {doc_id} 不存在")
        return False

    # 步骤2：合并更新
    original_data = results[0]
    updated_data = {**original_data, **updates}

    # 步骤3：删除原始数据
    collection.delete(expr=f"id == {doc_id}")

    # 步骤4：插入更新后的数据
    collection.insert([updated_data])
    collection.flush()

    print(f"✅ 文档 {doc_id} 更新成功")
    return True

# 使用示例
update_document(
    collection,
    doc_id=1,
    updates={"priority": 10, "tags": ["updated", "important"]}
)
```

---

### 3.2 批量更新优化

```python
def batch_update_documents(collection, updates_dict):
    """批量更新文档

    Args:
        collection: Milvus Collection
        updates_dict: {doc_id: {field: value, ...}, ...}
    """

    # 步骤1：查询所有需要更新的文档
    doc_ids = list(updates_dict.keys())
    id_expr = " or ".join([f"id == {doc_id}" for doc_id in doc_ids])

    results = collection.query(
        expr=id_expr,
        output_fields=["*"]
    )

    # 步骤2：合并更新
    updated_data = []
    for result in results:
        doc_id = result['id']
        if doc_id in updates_dict:
            updated_doc = {**result, **updates_dict[doc_id]}
            updated_data.append(updated_doc)

    # 步骤3：删除原始数据
    collection.delete(expr=id_expr)

    # 步骤4：批量插入更新后的数据
    collection.insert(updated_data)
    collection.flush()

    print(f"✅ 批量更新 {len(updated_data)} 条文档")

# 使用示例
updates = {
    1: {"priority": 10, "tags": ["important"]},
    2: {"priority": 5, "category": "updated"},
    3: {"author": "Charlie", "is_public": False}
}

batch_update_documents(collection, updates)
```

---

### 3.3 更新动态字段的类型

```python
# ❌ 错误：不能改变动态字段的类型
# 第一次插入
data1 = [{"text": "doc1", "embedding": [0.1]*768, "priority": 5}]  # INT64
collection.insert(data1)

# 尝试更新为不同类型
data2 = [{"text": "doc1", "embedding": [0.1]*768, "priority": "high"}]  # VARCHAR
# 这会导致类型不一致错误

# ✅ 正确：保持类型一致
data2 = [{"text": "doc1", "embedding": [0.1]*768, "priority": 10}]  # INT64
```

---

## 4. 删除包含动态字段的数据

### 4.1 按主键删除

```python
# 按主键删除
collection.delete(expr="id == 1")
collection.flush()
print("✅ 删除ID为1的文档")

# 批量删除
collection.delete(expr="id in [1, 2, 3, 4, 5]")
collection.flush()
print("✅ 批量删除5条文档")
```

---

### 4.2 按动态字段删除

```python
# 按动态字段删除
collection.delete(expr='author == "Alice"')
collection.flush()
print("✅ 删除所有Alice的文档")

# 按动态字段范围删除
collection.delete(expr='priority < 3')
collection.flush()
print("✅ 删除所有低优先级文档")

# 组合条件删除
collection.delete(expr='author == "Bob" and category == "tech"')
collection.flush()
print("✅ 删除符合条件的文档")
```

**性能注意**：
- 按动态字段删除需要全表扫描（无索引）
- 大规模删除建议先查询ID，再按ID删除

---

### 4.3 优化的删除策略

```python
def optimized_delete_by_dynamic_field(collection, field_name, field_value):
    """优化的按动态字段删除

    策略：先查询ID，再按ID删除（避免重复扫描）
    """

    # 步骤1：查询符合条件的ID
    results = collection.query(
        expr=f'{field_name} == "{field_value}"',
        output_fields=["id"]
    )

    if not results:
        print("❌ 没有找到符合条件的文档")
        return 0

    # 步骤2：按ID批量删除
    ids = [r['id'] for r in results]
    id_expr = " or ".join([f"id == {doc_id}" for doc_id in ids])

    collection.delete(expr=id_expr)
    collection.flush()

    print(f"✅ 删除 {len(ids)} 条文档")
    return len(ids)

# 使用示例
deleted_count = optimized_delete_by_dynamic_field(
    collection,
    field_name="author",
    field_value="Alice"
)
```

---

## 5. 完整的CRUD示例

```python
from pymilvus import connections, Collection, CollectionSchema, FieldSchema, DataType
import numpy as np

class DynamicSchemaManager:
    """动态Schema数据管理器"""

    def __init__(self, collection_name, dim=768):
        # 连接Milvus
        connections.connect(host="localhost", port="19530")

        # 创建Collection
        fields = [
            FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
            FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=dim),
            FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=2000)
        ]

        schema = CollectionSchema(fields=fields, enable_dynamic_field=True)
        self.collection = Collection(name=collection_name, schema=schema)

        # 创建索引
        index_params = {
            "index_type": "IVF_FLAT",
            "metric_type": "L2",
            "params": {"nlist": 128}
        }
        self.collection.create_index(field_name="embedding", index_params=index_params)
        self.collection.load()

    def insert(self, documents):
        """插入文档"""
        result = self.collection.insert(documents)
        self.collection.flush()
        return result.primary_keys

    def query_by_id(self, doc_id):
        """按ID查询"""
        results = self.collection.query(
            expr=f"id == {doc_id}",
            output_fields=["*"]
        )
        return results[0] if results else None

    def query_by_dynamic_field(self, field_name, field_value):
        """按动态字段查询"""
        results = self.collection.query(
            expr=f'{field_name} == "{field_value}"',
            output_fields=["*"]
        )
        return results

    def search(self, query_vector, top_k=10, filter_expr=None):
        """向量检索"""
        search_params = {"metric_type": "L2", "params": {"nprobe": 10}}

        results = self.collection.search(
            data=[query_vector],
            anns_field="embedding",
            param=search_params,
            limit=top_k,
            expr=filter_expr,
            output_fields=["*"]
        )
        return results[0]

    def update(self, doc_id, updates):
        """更新文档"""
        # 查询原始数据
        original = self.query_by_id(doc_id)
        if not original:
            return False

        # 合并更新
        updated = {**original, **updates}

        # 删除并重新插入
        self.collection.delete(expr=f"id == {doc_id}")
        self.collection.insert([updated])
        self.collection.flush()
        return True

    def delete(self, doc_id):
        """删除文档"""
        self.collection.delete(expr=f"id == {doc_id}")
        self.collection.flush()

    def delete_by_dynamic_field(self, field_name, field_value):
        """按动态字段删除"""
        # 先查询ID
        results = self.query_by_dynamic_field(field_name, field_value)
        if not results:
            return 0

        # 按ID删除
        ids = [r['id'] for r in results]
        id_expr = " or ".join([f"id == {doc_id}" for doc_id in ids])
        self.collection.delete(expr=id_expr)
        self.collection.flush()
        return len(ids)

# 使用示例
manager = DynamicSchemaManager("crud_demo")

# 1. 插入数据
docs = [
    {
        "text": "Document 1",
        "embedding": np.random.rand(768).tolist(),
        "author": "Alice",
        "category": "tech",
        "priority": 5
    },
    {
        "text": "Document 2",
        "embedding": np.random.rand(768).tolist(),
        "author": "Bob",
        "category": "science",
        "priority": 3
    }
]
ids = manager.insert(docs)
print(f"✅ 插入成功，IDs: {ids}")

# 2. 查询数据
doc = manager.query_by_id(ids[0])
print(f"✅ 查询结果: {doc}")

# 3. 按动态字段查询
results = manager.query_by_dynamic_field("author", "Alice")
print(f"✅ 找到 {len(results)} 条Alice的数据")

# 4. 向量检索
query_vec = np.random.rand(768).tolist()
results = manager.search(query_vec, top_k=5, filter_expr='priority > 3')
print(f"✅ 检索到 {len(results)} 条结果")

# 5. 更新数据
manager.update(ids[0], {"priority": 10, "tags": ["important"]})
print(f"✅ 更新成功")

# 6. 删除数据
manager.delete(ids[1])
print(f"✅ 删除成功")

# 7. 按动态字段删除
deleted_count = manager.delete_by_dynamic_field("author", "Alice")
print(f"✅ 删除 {deleted_count} 条数据")
```

---

## 总结

### 核心要点

1. **插入**：动态字段自动识别，支持多种类型，批量插入优化
2. **查询**：`output_fields=["*"]`返回所有字段，支持动态字段过滤
3. **更新**：Milvus不支持直接更新，需要先删除再插入
4. **删除**：支持按动态字段删除，但性能较低（无索引）
5. **优化**：批量操作、类型验证、分层查询

### 最佳实践

1. **批量操作**：每批1000-10000条，定期flush
2. **类型一致性**：在应用层验证类型
3. **查询优化**：先用固定字段过滤，再用动态字段过滤
4. **删除优化**：先查询ID，再按ID删除
5. **更新策略**：高频更新字段应使用固定Schema

---

**记住**：动态字段提供灵活性，但需要注意类型一致性和性能优化。
