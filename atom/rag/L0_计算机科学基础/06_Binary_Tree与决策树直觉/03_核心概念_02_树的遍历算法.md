# 树的遍历算法 - 核心概念详解

> 深入理解四种遍历算法：前序、中序、后序、层序（递归+迭代实现）

---

## 概述

树的遍历是访问树中所有节点的过程。不同的遍历顺序对应不同的算法语义，是理解树算法的关键。

**学习目标：**
- 掌握四种遍历方式的定义和实现
- 理解递归和迭代两种实现方式
- 理解不同遍历顺序的应用场景
- 能够根据需求选择合适的遍历方式

---

## 1. 前序遍历（Pre-order Traversal）

### 1.1 定义

**前序遍历**：根 → 左 → 右

**访问顺序：**
1. 先访问根节点
2. 再递归访问左子树
3. 最后递归访问右子树

### 1.2 递归实现

```python
def preorder_recursive(root):
    """前序遍历（递归）"""
    if not root:
        return []

    # 根 → 左 → 右
    result = [root.val]
    result.extend(preorder_recursive(root.left))
    result.extend(preorder_recursive(root.right))

    return result

# 示例：
#       1
#      / \
#     2   3
#    / \
#   4   5
# 输出：[1, 2, 4, 5, 3]
```

### 1.3 迭代实现

```python
def preorder_iterative(root):
    """前序遍历（迭代）"""
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.val)

        # 先右后左（因为栈是 LIFO）
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result
```

**关键洞察：**
- 使用栈模拟递归
- 先压右子节点，再压左子节点
- 保证左子节点先出栈

### 1.4 应用场景

```python
# 应用1：复制树
def copy_tree(root):
    """前序遍历复制树"""
    if not root:
        return None

    # 先复制根节点
    new_node = TreeNode(root.val)
    # 再复制左右子树
    new_node.left = copy_tree(root.left)
    new_node.right = copy_tree(root.right)

    return new_node

# 应用2：序列化树
def serialize(root):
    """前序遍历序列化树"""
    if not root:
        return "null"

    # 根 → 左 → 右
    return f"{root.val},{serialize(root.left)},{serialize(root.right)}"

# 应用3：行为树执行
class BehaviorNode:
    def execute(self):
        """前序执行：先决策再执行"""
        print(f"执行: {self.name}")  # 先执行当前节点
        if self.left:
            self.left.execute()      # 再执行左子树
        if self.right:
            self.right.execute()     # 最后执行右子树
```

---

## 2. 中序遍历（In-order Traversal）

### 2.1 定义

**中序遍历**：左 → 根 → 右

**访问顺序：**
1. 先递归访问左子树
2. 再访问根节点
3. 最后递归访问右子树

### 2.2 递归实现

```python
def inorder_recursive(root):
    """中序遍历（递归）"""
    if not root:
        return []

    # 左 → 根 → 右
    result = []
    result.extend(inorder_recursive(root.left))
    result.append(root.val)
    result.extend(inorder_recursive(root.right))

    return result

# BST 示例：
#       4
#      / \
#     2   6
#    / \ / \
#   1  3 5  7
# 输出：[1, 2, 3, 4, 5, 6, 7]（有序）
```

### 2.3 迭代实现

```python
def inorder_iterative(root):
    """中序遍历（迭代）"""
    result = []
    stack = []
    current = root

    while current or stack:
        # 一直往左走
        while current:
            stack.append(current)
            current = current.left

        # 访问节点
        current = stack.pop()
        result.append(current.val)

        # 转向右子树
        current = current.right

    return result
```

**关键洞察：**
- 先一直往左走到底
- 回溯时访问节点
- 再转向右子树

### 2.4 应用场景

```python
# 应用1：BST 排序输出
def inorder_bst(root):
    """BST 中序遍历 = 有序输出"""
    if not root:
        return []
    return inorder_bst(root.left) + [root.val] + inorder_bst(root.right)

# 应用2：验证 BST
def is_valid_bst(root):
    """验证是否为有效的 BST"""
    def inorder(node):
        if not node:
            return []
        return inorder(node.left) + [node.val] + inorder(node.right)

    values = inorder(root)
    # BST 的中序遍历应该是严格递增的
    return all(values[i] < values[i+1] for i in range(len(values)-1))

# 应用3：找到 BST 中第 k 小的元素
def kth_smallest(root, k):
    """BST 中第 k 小的元素"""
    def inorder(node):
        if not node:
            return []
        return inorder(node.left) + [node.val] + inorder(node.right)

    values = inorder(root)
    return values[k-1] if k <= len(values) else None
```

---

## 3. 后序遍历（Post-order Traversal）

### 3.1 定义

**后序遍历**：左 → 右 → 根

**访问顺序：**
1. 先递归访问左子树
2. 再递归访问右子树
3. 最后访问根节点

### 3.2 递归实现

```python
def postorder_recursive(root):
    """后序遍历（递归）"""
    if not root:
        return []

    # 左 → 右 → 根
    result = []
    result.extend(postorder_recursive(root.left))
    result.extend(postorder_recursive(root.right))
    result.append(root.val)

    return result

# 示例：
#       1
#      / \
#     2   3
#    / \
#   4   5
# 输出：[4, 5, 2, 3, 1]
```

### 3.3 迭代实现

```python
def postorder_iterative(root):
    """后序遍历（迭代）"""
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.val)

        # 先左后右
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)

    # 反转结果（根右左 → 左右根）
    return result[::-1]
```

**关键洞察：**
- 先按"根→右→左"顺序访问
- 最后反转结果得到"左→右→根"

### 3.4 应用场景

```python
# 应用1：计算树的高度
def height(root):
    """后序遍历计算高度"""
    if not root:
        return 0

    # 先计算左右子树高度
    left_h = height(root.left)
    right_h = height(root.right)

    # 再计算当前节点高度
    return max(left_h, right_h) + 1

# 应用2：删除树
def delete_tree(root):
    """后序遍历删除树"""
    if not root:
        return

    # 先删除左右子树
    delete_tree(root.left)
    delete_tree(root.right)

    # 再删除根节点
    print(f"删除节点: {root.val}")
    del root

# 应用3：计算表达式树
def eval_expr(root):
    """后序遍历计算表达式树"""
    if not root:
        return 0

    # 叶子节点：数字
    if not root.left and not root.right:
        return root.val

    # 先计算左右子树
    left_val = eval_expr(root.left)
    right_val = eval_expr(root.right)

    # 再应用运算符
    if root.val == '+':
        return left_val + right_val
    elif root.val == '-':
        return left_val - right_val
    elif root.val == '*':
        return left_val * left_val
    elif root.val == '/':
        return left_val / right_val

# 应用4：决策树剪枝
def prune_tree(root):
    """后序遍历剪枝"""
    if not root:
        return None

    # 先处理子树
    root.left = prune_tree(root.left)
    root.right = prune_tree(root.right)

    # 再处理当前节点
    if is_leaf(root) and should_prune(root):
        return None

    return root
```

---

## 4. 层序遍历（Level-order Traversal）

### 4.1 定义

**层序遍历**：逐层访问节点（广度优先）

**访问顺序：**
1. 从根节点开始
2. 逐层从左到右访问
3. 使用队列实现

### 4.2 基本实现

```python
from collections import deque

def levelorder(root):
    """层序遍历"""
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        node = queue.popleft()
        result.append(node.val)

        # 先左后右入队
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

    return result

# 示例：
#       1
#      / \
#     2   3
#    / \
#   4   5
# 输出：[1, 2, 3, 4, 5]
```

### 4.3 按层分组

```python
def levelorder_by_level(root):
    """层序遍历：按层分组"""
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        level_size = len(queue)  # 当前层的节点数
        level_nodes = []

        for _ in range(level_size):
            node = queue.popleft()
            level_nodes.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(level_nodes)

    return result

# 示例：
#       1
#      / \
#     2   3
#    / \
#   4   5
# 输出：[[1], [2, 3], [4, 5]]
```

### 4.4 应用场景

```python
# 应用1：打印树结构
def print_tree_by_level(root):
    """按层打印树"""
    if not root:
        return

    queue = deque([root])
    level = 0

    while queue:
        level_size = len(queue)
        print(f"Level {level}:", end=" ")

        for _ in range(level_size):
            node = queue.popleft()
            print(node.val, end=" ")

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        print()
        level += 1

# 应用2：TreeRAG 分层检索
def tree_rag_retrieve(root, query_embedding, max_depth=3):
    """TreeRAG 分层检索"""
    results = []
    queue = deque([(root, 0)])  # (节点, 深度)

    while queue:
        node, depth = queue.popleft()

        # 计算相似度
        sim = cosine_similarity(query_embedding, node.embedding)

        # 如果相似度高，加入结果
        if sim > 0.7:
            results.append((node.content, sim))

        # 如果未达到最大深度且相似度足够高，继续检索子节点
        if depth < max_depth and sim > 0.5:
            for child in node.children:
                queue.append((child, depth + 1))

    return sorted(results, key=lambda x: x[1], reverse=True)[:5]

# 应用3：最短路径
def min_depth(root):
    """找到最短路径（根到叶子）"""
    if not root:
        return 0

    queue = deque([(root, 1)])  # (节点, 深度)

    while queue:
        node, depth = queue.popleft()

        # 如果是叶子节点，返回深度
        if not node.left and not node.right:
            return depth

        if node.left:
            queue.append((node.left, depth + 1))
        if node.right:
            queue.append((node.right, depth + 1))

    return 0

# 应用4：锯齿形层序遍历
def zigzag_levelorder(root):
    """锯齿形层序遍历"""
    if not root:
        return []

    result = []
    queue = deque([root])
    left_to_right = True

    while queue:
        level_size = len(queue)
        level_nodes = []

        for _ in range(level_size):
            node = queue.popleft()
            level_nodes.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        # 奇数层从左到右，偶数层从右到左
        if not left_to_right:
            level_nodes.reverse()

        result.append(level_nodes)
        left_to_right = not left_to_right

    return result
```

---

## 5. 遍历方式对比

### 5.1 对比表

| 遍历方式 | 访问顺序 | 数据结构 | 时间复杂度 | 空间复杂度 | 典型应用 |
|---------|---------|---------|-----------|-----------|---------|
| **前序** | 根→左→右 | 栈/递归 | O(n) | O(h) | 复制树、序列化 |
| **中序** | 左→根→右 | 栈/递归 | O(n) | O(h) | BST 排序 |
| **后序** | 左→右→根 | 栈/递归 | O(n) | O(h) | 删除树、计算高度 |
| **层序** | 逐层访问 | 队列 | O(n) | O(w) | 分层检索、最短路径 |

**注：**
- n = 节点数
- h = 树的高度
- w = 树的最大宽度

### 5.2 选择标准

```python
def choose_traversal(task):
    """根据任务选择遍历方式"""
    if task == "复制树" or task == "序列化":
        return "前序遍历"
    elif task == "BST排序" or task == "有序访问":
        return "中序遍历"
    elif task == "删除树" or task == "计算高度":
        return "后序遍历"
    elif task == "分层检索" or task == "最短路径":
        return "层序遍历"
    else:
        return "根据具体需求选择"
```

### 5.3 递归 vs 迭代

| 特性 | 递归 | 迭代 |
|------|------|------|
| **代码简洁性** | 简洁 | 复杂 |
| **理解难度** | 易于理解 | 较难理解 |
| **空间复杂度** | O(h) 递归栈 | O(h) 显式栈 |
| **栈溢出风险** | 有（深度过大） | 无 |
| **性能** | 略慢（函数调用开销） | 略快 |
| **推荐场景** | 学习、原型 | 生产环境 |

---

## 6. 综合示例

### 示例1：四种遍历对比

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

# 构建示例树
#       1
#      / \
#     2   3
#    / \
#   4   5

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

# 四种遍历
print("前序遍历:", preorder_recursive(root))    # [1, 2, 4, 5, 3]
print("中序遍历:", inorder_recursive(root))     # [4, 2, 5, 1, 3]
print("后序遍历:", postorder_recursive(root))   # [4, 5, 2, 3, 1]
print("层序遍历:", levelorder(root))            # [1, 2, 3, 4, 5]
```

### 示例2：遍历的实际应用

```python
# 应用1：序列化和反序列化
def serialize(root):
    """前序遍历序列化"""
    if not root:
        return "null"
    return f"{root.val},{serialize(root.left)},{serialize(root.right)}"

def deserialize(data):
    """前序遍历反序列化"""
    def build(values):
        val = next(values)
        if val == "null":
            return None
        node = TreeNode(int(val))
        node.left = build(values)
        node.right = build(values)
        return node

    return build(iter(data.split(',')))

# 测试
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)

serialized = serialize(root)
print(f"序列化: {serialized}")  # "1,2,null,null,3,null,null"

deserialized = deserialize(serialized)
print(f"反序列化: {preorder_recursive(deserialized)}")  # [1, 2, 3]

# 应用2：BST 转有序数组
def bst_to_sorted_array(root):
    """中序遍历 BST → 有序数组"""
    if not root:
        return []
    return bst_to_sorted_array(root.left) + [root.val] + bst_to_sorted_array(root.right)

# 应用3：计算树的所有路径
def all_paths(root):
    """前序遍历找到所有路径"""
    if not root:
        return []

    if not root.left and not root.right:
        return [[root.val]]

    paths = []
    for left_path in all_paths(root.left):
        paths.append([root.val] + left_path)
    for right_path in all_paths(root.right):
        paths.append([root.val] + right_path)

    return paths

# 测试
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(all_paths(root))
# [[1, 2, 4], [1, 2, 5], [1, 3]]
```

### 示例3：遍历的性能对比

```python
import time

def benchmark_traversal(root, traversal_func, name):
    """性能测试"""
    start = time.time()
    result = traversal_func(root)
    end = time.time()
    print(f"{name}: {len(result)} 个节点, 耗时 {(end-start)*1000:.2f}ms")

# 构建大树
def build_large_tree(depth):
    """构建深度为 depth 的完全二叉树"""
    if depth == 0:
        return None
    root = TreeNode(1)
    root.left = build_large_tree(depth - 1)
    root.right = build_large_tree(depth - 1)
    return root

# 测试
large_tree = build_large_tree(15)  # 2^15 - 1 = 32767 个节点

benchmark_traversal(large_tree, preorder_recursive, "前序遍历（递归）")
benchmark_traversal(large_tree, preorder_iterative, "前序遍历（迭代）")
benchmark_traversal(large_tree, inorder_recursive, "中序遍历（递归）")
benchmark_traversal(large_tree, inorder_iterative, "中序遍历（迭代）")
benchmark_traversal(large_tree, postorder_recursive, "后序遍历（递归）")
benchmark_traversal(large_tree, postorder_iterative, "后序遍历（迭代）")
benchmark_traversal(large_tree, levelorder, "层序遍历")
```

---

## 7. 高级遍历技巧

### 7.1 Morris 遍历（O(1) 空间）

```python
def morris_inorder(root):
    """Morris 中序遍历：O(1) 空间"""
    result = []
    current = root

    while current:
        if not current.left:
            # 没有左子树，访问当前节点
            result.append(current.val)
            current = current.right
        else:
            # 找到左子树的最右节点
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right

            if not predecessor.right:
                # 建立线索
                predecessor.right = current
                current = current.left
            else:
                # 恢复树结构
                predecessor.right = None
                result.append(current.val)
                current = current.right

    return result
```

### 7.2 垂直遍历

```python
from collections import defaultdict, deque

def vertical_traversal(root):
    """垂直遍历：按列访问"""
    if not root:
        return []

    # 记录每个节点的列号和行号
    column_table = defaultdict(list)
    queue = deque([(root, 0, 0)])  # (节点, 行, 列)

    while queue:
        node, row, col = queue.popleft()
        column_table[col].append((row, node.val))

        if node.left:
            queue.append((node.left, row + 1, col - 1))
        if node.right:
            queue.append((node.right, row + 1, col + 1))

    # 按列号排序，每列内按行号和值排序
    result = []
    for col in sorted(column_table.keys()):
        column_table[col].sort()
        result.append([val for row, val in column_table[col]])

    return result
```

### 7.3 边界遍历

```python
def boundary_traversal(root):
    """边界遍历：左边界 + 叶子 + 右边界"""
    if not root:
        return []

    result = [root.val]

    # 左边界（不包括叶子）
    def left_boundary(node):
        if not node or (not node.left and not node.right):
            return
        result.append(node.val)
        if node.left:
            left_boundary(node.left)
        else:
            left_boundary(node.right)

    # 叶子节点
    def leaves(node):
        if not node:
            return
        if not node.left and not node.right:
            result.append(node.val)
            return
        leaves(node.left)
        leaves(node.right)

    # 右边界（不包括叶子）
    def right_boundary(node):
        if not node or (not node.left and not node.right):
            return
        if node.right:
            right_boundary(node.right)
        else:
            right_boundary(node.left)
        result.append(node.val)

    left_boundary(root.left)
    leaves(root)
    right_boundary(root.right)

    return result
```

---

## 学习检查清单

完成本文档学习后，你应该能够：

- [ ] 实现四种遍历的递归版本
- [ ] 实现四种遍历的迭代版本
- [ ] 理解不同遍历顺序的语义
- [ ] 根据任务选择合适的遍历方式
- [ ] 理解递归和迭代的优缺点
- [ ] 实现层序遍历的按层分组
- [ ] 实现 Morris 遍历（进阶）
- [ ] 实现垂直遍历和边界遍历（进阶）

---

## 参考资源

### 教程
- [GeeksforGeeks - Tree Traversal Techniques](https://www.geeksforgeeks.org/python/tree-traversal-techniques-in-python/) (2025)
- [W3Schools - Python Binary Trees](https://www.w3schools.com/python/python_dsa_binarytrees.asp)

### LeetCode 练习
- [144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)
- [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)
- [145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)
- [102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+, AI Agent 开发, RAG 系统
**学习时间**: 30-40 分钟
