# 【面试必问】Session管理

> Session 管理的高频面试问题和标准答案

---

## 问题1：Session 和数据库连接有什么区别？

### 标准答案

**Session 不是数据库连接，而是工作单元 + 身份映射 + 事务边界的组合。**

**核心区别：**

| 维度 | 数据库连接 | Session |
|------|-----------|---------|
| **本质** | 物理的 TCP 连接 | 逻辑的工作单元 |
| **生命周期** | 长期存在（连接池复用） | 短期存在（请求级别） |
| **创建成本** | 高（TCP 握手） | 低（从池中借用连接） |
| **线程安全** | 取决于实现 | 不是线程安全 |
| **作用** | 传输 SQL 语句 | 管理对象状态和事务 |

**详细解释：**

```python
# 连接：物理的 TCP 连接
engine = create_engine("postgresql://...", pool_size=10)
# Engine 管理10个物理连接

# Session：逻辑的工作单元
session = SessionLocal()  # 从池中借用连接
session.query(User).all()  # 使用连接
session.close()  # 归还连接到池中（不是关闭连接）
```

**类比：**
- **连接** = 图书馆的座位（有限资源，长期存在）
- **Session** = 借书证（可以频繁申请和归还）

---

## 问题2：为什么 Session 不是线程安全的？

### 标准答案

**Session 维护了内部状态（身份映射、待提交对象），多个线程同时操作会导致状态不一致。**

**原因：**

1. **身份映射不是线程安全的**

```python
# 线程1
session.add(User(name='Alice'))

# 线程2（同时发生）
session.add(User(name='Bob'))

# 身份映射中的对象顺序不确定
```

2. **事务边界不明确**

```python
# 线程1
session.add(User(name='Alice'))
session.commit()  # 会提交线程2的操作吗？

# 线程2（同时发生）
session.add(User(name='Bob'))
```

3. **对象状态混乱**

```python
# 线程1
user = session.query(User).filter_by(id=1).first()
user.name = 'Alice'

# 线程2（同时发生）
user = session.query(User).filter_by(id=1).first()
user.name = 'Bob'

# commit 时，谁的修改生效？
```

**解决方案：**

```python
# 每个请求独立 Session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users")
def get_users(db: Session = Depends(get_db)):
    return db.query(User).all()
```

---

## 问题3：Session 的生命周期是什么？

### 标准答案

**Session 的生命周期：创建 → 使用 → 提交/回滚 → 关闭**

```
┌─────────────────────────────────────┐
│  1. 创建 Session                     │
│     session = SessionLocal()         │
├─────────────────────────────────────┤
│  2. 使用 Session                     │
│     session.add(obj)                 │
│     session.query(Model).all()       │
├─────────────────────────────────────┤
│  3. 提交或回滚                       │
│     session.commit()                 │
│     或 session.rollback()            │
├─────────────────────────────────────┤
│  4. 关闭 Session                     │
│     session.close()                  │
└─────────────────────────────────────┘
```

**最佳实践：**

```python
# 使用上下文管理器
with SessionLocal() as session:
    # 使用 Session
    session.add(User(name='Alice'))
    session.commit()
    # 自动关闭
```

**FastAPI 集成：**

```python
def get_db():
    db = SessionLocal()
    try:
        yield db  # 使用 Session
    finally:
        db.close()  # 自动关闭

@app.post("/users")
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    # 使用 db
    db.add(User(**user.dict()))
    db.commit()
    # 自动关闭
```

---

## 问题4：commit 和 flush 有什么区别？

### 标准答案

**flush 是将 Session 中的操作同步到数据库，但不提交事务；commit 是提交事务，使数据持久化。**

| 操作 | flush | commit |
|------|-------|--------|
| **作用** | 同步到数据库 | 提交事务 |
| **SQL 执行** | 执行 INSERT/UPDATE/DELETE | 执行 COMMIT |
| **数据可见性** | 当前事务可见 | 所有事务可见 |
| **回滚** | 可以回滚 | 不可以回滚 |
| **自动触发** | 查询前自动触发（autoflush） | 不会自动触发 |

**示例：**

```python
session = SessionLocal()

# 添加对象
session.add(User(name='Alice'))

# flush：同步到数据库，但不提交
session.flush()
# 此时执行了 INSERT SQL，但事务未提交
# 当前事务可以查询到 Alice，其他事务查询不到

# commit：提交事务
session.commit()
# 此时执行了 COMMIT，数据持久化
# 所有事务都可以查询到 Alice
```

**autoflush 示例：**

```python
session.add(User(name='Alice'))

# 查询前自动 flush
user = session.query(User).filter_by(name='Alice').first()
# 自动执行 INSERT SQL，然后执行 SELECT SQL
```

---

## 问题5：什么时候需要 rollback？

### 标准答案

**当操作失败或需要撤销未提交的操作时，需要 rollback。**

**场景1：异常处理**

```python
session = SessionLocal()
try:
    session.add(User(name='Alice'))
    session.add(Order(user_id=1))
    session.commit()
except Exception as e:
    session.rollback()  # 撤销所有操作
    raise
finally:
    session.close()
```

**场景2：业务逻辑验证**

```python
session = SessionLocal()

user = User(name='Alice')
session.add(user)
session.flush()  # 获取 user.id

# 业务逻辑验证
if not is_valid_user(user):
    session.rollback()  # 撤销操作
    raise ValueError("Invalid user")

session.commit()
```

**场景3：测试环境**

```python
# 测试用例
def test_create_user():
    session = SessionLocal()
    try:
        user = User(name='Alice')
        session.add(user)
        session.commit()

        # 验证
        assert session.query(User).count() == 1
    finally:
        session.rollback()  # 撤销测试数据
        session.close()
```

**注意：** rollback 只能撤销未 commit 的操作，已经 commit 的数据无法撤销。

---

## 问题6：Session 的 autoflush 和 autocommit 有什么区别？

### 标准答案

**autoflush 是查询前自动同步到数据库，autocommit 是每个操作自动提交事务。**

| 配置 | autoflush | autocommit |
|------|-----------|-----------|
| **默认值** | True | False |
| **作用** | 查询前自动 flush | 每个操作自动 commit |
| **推荐** | 保持默认（True） | 保持默认（False） |

**autoflush 示例：**

```python
# autoflush=True（默认）
session.add(User(name='Alice'))

# 查询前自动 flush
user = session.query(User).filter_by(name='Alice').first()
# 自动执行 INSERT，然后执行 SELECT

# autoflush=False
SessionLocal = sessionmaker(bind=engine, autoflush=False)
session = SessionLocal()

session.add(User(name='Alice'))

# 查询前不会 flush
user = session.query(User).filter_by(name='Alice').first()
# 只执行 SELECT，查询不到 Alice
```

**autocommit 示例：**

```python
# autocommit=False（默认，推荐）
session.add(User(name='Alice'))
session.commit()  # 显式提交

# autocommit=True（不推荐）
SessionLocal = sessionmaker(bind=engine, autocommit=True)
session = SessionLocal()

with session.begin():  # 需要显式开启事务
    session.add(User(name='Alice'))
    # 自动提交
```

**为什么不推荐 autocommit=True？**
- 失去事务控制
- 无法批量操作
- 性能下降

---

## 问题7：如何在 FastAPI 中正确使用 Session？

### 标准答案

**使用依赖注入（Depends）管理 Session 生命周期。**

**标准模式：**

```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql://user:password@localhost:5432/mydb"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

```python
# main.py
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session

app = FastAPI()

@app.post("/users")
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    db_user = User(**user.dict())
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user
```

**为什么这样设计？**

1. **自动管理生命周期**：请求结束后自动关闭 Session
2. **异常安全**：即使发生异常，也会关闭 Session
3. **依赖注入**：可以在多个路由中复用
4. **测试友好**：可以在测试中替换 get_db

**错误示范：**

```python
# ❌ 错误：全局 Session
global_session = SessionLocal()

@app.get("/users")
def get_users():
    return global_session.query(User).all()  # 线程不安全

# ❌ 错误：手动管理 Session
@app.get("/users")
def get_users():
    session = SessionLocal()
    users = session.query(User).all()
    session.close()
    return users  # 可能忘记关闭
```

---

## 问题8：Session 的对象状态有哪些？

### 标准答案

**Session 中的对象有4种状态：Transient、Pending、Persistent、Detached。**

```
┌─────────────────────────────────────┐
│  Transient（临时）                   │
│  对象刚创建，Session 不知道它        │
└─────────────────────────────────────┘
              ↓ session.add()
┌─────────────────────────────────────┐
│  Pending（待持久化）                 │
│  对象已加入 Session，但未提交        │
└─────────────────────────────────────┘
              ↓ session.commit()
┌─────────────────────────────────────┐
│  Persistent（持久化）                │
│  对象已提交，Session 追踪它          │
└─────────────────────────────────────┘
              ↓ session.close()
┌─────────────────────────────────────┐
│  Detached（分离）                    │
│  Session 关闭，对象脱离管理          │
└─────────────────────────────────────┘
```

**示例：**

```python
# Transient
user = User(name='Alice')
print(inspect(user).transient)  # True

# Pending
session.add(user)
print(inspect(user).pending)  # True

# Persistent
session.commit()
print(inspect(user).persistent)  # True

# Detached
session.close()
print(inspect(user).detached)  # True
```

**状态转换：**

```python
from sqlalchemy import inspect

user = User(name='Alice')

# Transient → Pending
session.add(user)

# Pending → Persistent
session.commit()

# Persistent → Detached
session.close()

# Detached → Persistent
session.add(user)  # 重新加入 Session
```

---

## 问题9：如何避免 Session 连接泄漏？

### 标准答案

**使用上下文管理器或依赖注入，确保 Session 总是被关闭。**

**方法1：上下文管理器**

```python
with SessionLocal() as session:
    users = session.query(User).all()
    # 自动关闭
```

**方法2：try-finally**

```python
session = SessionLocal()
try:
    users = session.query(User).all()
finally:
    session.close()  # 确保关闭
```

**方法3：FastAPI 依赖注入**

```python
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()  # 确保关闭

@app.get("/users")
def get_users(db: Session = Depends(get_db)):
    return db.query(User).all()
```

**检测连接泄漏：**

```python
# 查看连接池状态
from sqlalchemy import event

@event.listens_for(engine, "connect")
def receive_connect(dbapi_conn, connection_record):
    print(f"Connection opened: {dbapi_conn}")

@event.listens_for(engine, "close")
def receive_close(dbapi_conn, connection_record):
    print(f"Connection closed: {dbapi_conn}")
```

---

## 问题10：Session 的 expire_on_commit 是什么？

### 标准答案

**expire_on_commit 控制 commit 后对象是否过期，默认为 True。**

**expire_on_commit=True（默认）：**

```python
user = User(name='Alice')
session.add(user)
session.commit()

# commit 后对象过期
print(user.name)  # 重新查询数据库
```

**expire_on_commit=False：**

```python
SessionLocal = sessionmaker(bind=engine, expire_on_commit=False)
session = SessionLocal()

user = User(name='Alice')
session.add(user)
session.commit()

# commit 后对象不过期
print(user.name)  # 使用缓存数据，不查询数据库
```

**为什么默认是 True？**

```python
# 场景：其他地方修改了数据库
user = User(name='Alice')
session.add(user)
session.commit()

# 其他地方修改了数据库
# UPDATE users SET name='Bob' WHERE id=1

# 如果 expire_on_commit=False
print(user.name)  # 'Alice'（过期数据）

# 如果 expire_on_commit=True
print(user.name)  # 'Bob'（重新查询）
```

**什么时候设置为 False？**
- 性能优化：避免频繁查询
- 离线对象：Session 关闭后仍需使用对象

---

## 高频追问

### 追问1：Session 和 Engine 的关系？

**答案：**
- **Engine**：管理连接池，全局单例，线程安全
- **SessionMaker**：Session 工厂，配置模板
- **Session**：请求级别，不线程安全，用完即关

```python
# Engine：全局单例
engine = create_engine("postgresql://...")

# SessionMaker：工厂
SessionLocal = sessionmaker(bind=engine)

# Session：请求级别
session = SessionLocal()
```

### 追问2：如何在异步环境中使用 Session？

**答案：**

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

# 创建异步引擎
engine = create_async_engine("postgresql+asyncpg://...")

# 创建异步 SessionMaker
AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)

# 使用异步 Session
async def get_users():
    async with AsyncSessionLocal() as session:
        result = await session.execute(select(User))
        return result.scalars().all()
```

### 追问3：如何处理 Session 的并发问题？

**答案：**
- 每个请求独立 Session
- 使用乐观锁（version 字段）
- 使用悲观锁（SELECT FOR UPDATE）

```python
# 乐观锁
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    name = Column(String)
    version = Column(Integer, default=0)

# 悲观锁
user = session.query(User).with_for_update().filter_by(id=1).first()
user.name = 'Alice'
session.commit()
```

---

## 总结

**Session 管理的核心要点：**

1. **Session 不是连接**：是工作单元 + 身份映射 + 事务边界
2. **不是线程安全**：每个请求独立 Session
3. **生命周期管理**：创建 → 使用 → 提交/回滚 → 关闭
4. **flush vs commit**：flush 同步到数据库，commit 提交事务
5. **rollback 时机**：异常处理、业务验证、测试环境
6. **autoflush vs autocommit**：autoflush 默认 True，autocommit 默认 False
7. **FastAPI 集成**：使用依赖注入（Depends）
8. **对象状态**：Transient → Pending → Persistent → Detached
9. **避免连接泄漏**：使用上下文管理器或依赖注入
10. **expire_on_commit**：默认 True，commit 后对象过期

---

**记住：** Session 是工作单元，不是连接；每个请求独立 Session；用完即关，避免泄漏。
