# 实战代码 07：Web 界面集成示例

> React + TypeScript Web 界面集成示例，提供可视化的会话管理界面

---

## 代码概览

本文实现完整的 Web 界面，包括：

1. **会话列表**：显示所有会话
2. **树形可视化**：可视化会话树结构
3. **分支导航**：交互式分支切换
4. **消息显示**：显示对话历史
5. **实时更新**：WebSocket 实时同步

---

## React 组件实现

### 主应用组件

```typescript
// App.tsx
import React, { useState, useEffect } from 'react';
import { SessionManager } from './session-manager';
import { SessionTree } from './components/SessionTree';
import { MessageList } from './components/MessageList';
import { BranchSelector } from './components/BranchSelector';
import { ChatInput } from './components/ChatInput';

export const App: React.FC = () => {
  const [manager, setManager] = useState<SessionManager | null>(null);
  const [currentBranch, setCurrentBranch] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);

  useEffect(() => {
    // 初始化 SessionManager
    const mgr = new SessionManager('session.jsonl');
    setManager(mgr);
    setCurrentBranch(mgr.getLeafId());
    updateMessages(mgr);

    return () => mgr.close();
  }, []);

  const updateMessages = (mgr: SessionManager) => {
    const context = mgr.buildContext();
    setMessages(context);
  };

  const handleSendMessage = async (content: string) => {
    if (!manager) return;

    manager.addUserMessage(content);

    // 调用 AI（示例）
    const aiResponse = await callAI(content);
    manager.addAssistantMessage(aiResponse);

    updateMessages(manager);
    setCurrentBranch(manager.getLeafId());
  };

  const handleBranchSwitch = (branchId: string) => {
    if (!manager) return;

    manager.switchToBranch(branchId);
    updateMessages(manager);
    setCurrentBranch(branchId);
  };

  const handleCreateBranch = (fromId: string) => {
    if (!manager) return;

    manager.branch(fromId);
    updateMessages(manager);
    setCurrentBranch(manager.getLeafId());
  };

  return (
    <div className="app">
      <div className="sidebar">
        <h2>Session Tree</h2>
        {manager && (
          <SessionTree
            manager={manager}
            currentBranch={currentBranch}
            onBranchClick={handleBranchSwitch}
            onCreateBranch={handleCreateBranch}
          />
        )}
      </div>

      <div className="main">
        <div className="header">
          <h1>AI Chat</h1>
          {manager && (
            <BranchSelector
              manager={manager}
              currentBranch={currentBranch}
              onBranchSelect={handleBranchSwitch}
            />
          )}
        </div>

        <MessageList messages={messages} />
        <ChatInput onSend={handleSendMessage} />
      </div>
    </div>
  );
};

async function callAI(content: string): Promise<string> {
  // 模拟 AI 调用
  return `Response to: ${content}`;
}
```

### 会话树组件

```typescript
// components/SessionTree.tsx
import React from 'react';
import { SessionManager } from '../session-manager';
import { TreeNode } from '../types';

interface SessionTreeProps {
  manager: SessionManager;
  currentBranch: string;
  onBranchClick: (branchId: string) => void;
  onCreateBranch: (fromId: string) => void;
}

export const SessionTree: React.FC<SessionTreeProps> = ({
  manager,
  currentBranch,
  onBranchClick,
  onCreateBranch
}) => {
  const tree = manager.getTree();

  if (!tree) {
    return <div>No session tree</div>;
  }

  return (
    <div className="session-tree">
      <TreeNodeComponent
        node={tree}
        currentBranch={currentBranch}
        onBranchClick={onBranchClick}
        onCreateBranch={onCreateBranch}
        depth={0}
      />
    </div>
  );
};

interface TreeNodeComponentProps {
  node: TreeNode;
  currentBranch: string;
  onBranchClick: (branchId: string) => void;
  onCreateBranch: (fromId: string) => void;
  depth: number;
}

const TreeNodeComponent: React.FC<TreeNodeComponentProps> = ({
  node,
  currentBranch,
  onBranchClick,
  onCreateBranch,
  depth
}) => {
  const isCurrent = node.entry.id === currentBranch;
  const isLeaf = node.children.length === 0;

  return (
    <div className="tree-node" style={{ marginLeft: `${depth * 20}px` }}>
      <div
        className={`node-content ${isCurrent ? 'current' : ''} ${isLeaf ? 'leaf' : ''}`}
        onClick={() => onBranchClick(node.entry.id)}
      >
        <span className="node-type">[{node.entry.type}]</span>
        <span className="node-content-text">
          {node.entry.content?.substring(0, 30) || node.entry.id}
        </span>
        {isCurrent && <span className="current-marker">← current</span>}
      </div>

      {isLeaf && (
        <button
          className="branch-button"
          onClick={(e) => {
            e.stopPropagation();
            onCreateBranch(node.entry.id);
          }}
        >
          + Branch
        </button>
      )}

      {node.children.map((child) => (
        <TreeNodeComponent
          key={child.entry.id}
          node={child}
          currentBranch={currentBranch}
          onBranchClick={onBranchClick}
          onCreateBranch={onCreateBranch}
          depth={depth + 1}
        />
      ))}
    </div>
  );
};
```

### 消息列表组件

```typescript
// components/MessageList.tsx
import React, { useRef, useEffect } from 'react';
import { Message } from '../types';

interface MessageListProps {
  messages: Message[];
}

export const MessageList: React.FC<MessageListProps> = ({ messages }) => {
  const bottomRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div className="message-list">
      {messages.map((message, index) => (
        <MessageComponent key={index} message={message} />
      ))}
      <div ref={bottomRef} />
    </div>
  );
};

interface MessageComponentProps {
  message: Message;
}

const MessageComponent: React.FC<MessageComponentProps> = ({ message }) => {
  return (
    <div className={`message message-${message.role}`}>
      <div className="message-role">{message.role}</div>
      <div className="message-content">{message.content}</div>
    </div>
  );
};
```

### 分支选择器组件

```typescript
// components/BranchSelector.tsx
import React, { useState } from 'react';
import { SessionManager } from '../session-manager';

interface BranchSelectorProps {
  manager: SessionManager;
  currentBranch: string;
  onBranchSelect: (branchId: string) => void;
}

export const BranchSelector: React.FC<BranchSelectorProps> = ({
  manager,
  currentBranch,
  onBranchSelect
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const branches = manager.getAllBranches();

  return (
    <div className="branch-selector">
      <button onClick={() => setIsOpen(!isOpen)}>
        Branches ({branches.length})
      </button>

      {isOpen && (
        <div className="branch-dropdown">
          {branches.map((branch, index) => (
            <div
              key={branch.id}
              className={`branch-item ${branch.id === currentBranch ? 'active' : ''}`}
              onClick={() => {
                onBranchSelect(branch.id);
                setIsOpen(false);
              }}
            >
              <div className="branch-label">Branch {index + 1}</div>
              <div className="branch-info">
                {branch.messageCount} messages
              </div>
              <div className="branch-preview">
                {branch.lastMessage?.substring(0, 40)}...
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

### 聊天输入组件

```typescript
// components/ChatInput.tsx
import React, { useState } from 'react';

interface ChatInputProps {
  onSend: (content: string) => void;
}

export const ChatInput: React.FC<ChatInputProps> = ({ onSend }) => {
  const [input, setInput] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (input.trim()) {
      onSend(input);
      setInput('');
    }
  };

  return (
    <form className="chat-input" onSubmit={handleSubmit}>
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Type a message..."
      />
      <button type="submit">Send</button>
    </form>
  );
};
```

---

## 样式实现

```css
/* styles.css */
.app {
  display: flex;
  height: 100vh;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

.sidebar {
  width: 300px;
  background: #f5f5f5;
  border-right: 1px solid #ddd;
  overflow-y: auto;
  padding: 20px;
}

.main {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.header {
  padding: 20px;
  border-bottom: 1px solid #ddd;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* Session Tree */
.session-tree {
  font-family: monospace;
  font-size: 14px;
}

.tree-node {
  margin: 5px 0;
}

.node-content {
  padding: 5px 10px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.2s;
}

.node-content:hover {
  background: #e0e0e0;
}

.node-content.current {
  background: #007bff;
  color: white;
}

.node-content.leaf {
  font-weight: bold;
}

.node-type {
  color: #666;
  margin-right: 5px;
}

.current-marker {
  margin-left: 10px;
  font-size: 12px;
}

.branch-button {
  margin-left: 10px;
  padding: 2px 8px;
  font-size: 12px;
  background: #28a745;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
}

/* Message List */
.message-list {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.message {
  margin: 15px 0;
  padding: 15px;
  border-radius: 8px;
}

.message-user {
  background: #e3f2fd;
  margin-left: 20%;
}

.message-assistant {
  background: #f5f5f5;
  margin-right: 20%;
}

.message-system {
  background: #fff3cd;
  font-style: italic;
}

.message-role {
  font-weight: bold;
  margin-bottom: 5px;
  text-transform: uppercase;
  font-size: 12px;
  color: #666;
}

.message-content {
  line-height: 1.5;
}

/* Branch Selector */
.branch-selector {
  position: relative;
}

.branch-selector button {
  padding: 8px 16px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.branch-dropdown {
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 5px;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  min-width: 250px;
  max-height: 400px;
  overflow-y: auto;
  z-index: 1000;
}

.branch-item {
  padding: 12px;
  border-bottom: 1px solid #eee;
  cursor: pointer;
  transition: background 0.2s;
}

.branch-item:hover {
  background: #f5f5f5;
}

.branch-item.active {
  background: #e3f2fd;
}

.branch-label {
  font-weight: bold;
  margin-bottom: 5px;
}

.branch-info {
  font-size: 12px;
  color: #666;
  margin-bottom: 5px;
}

.branch-preview {
  font-size: 13px;
  color: #333;
}

/* Chat Input */
.chat-input {
  display: flex;
  padding: 20px;
  border-top: 1px solid #ddd;
}

.chat-input input {
  flex: 1;
  padding: 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

.chat-input button {
  margin-left: 10px;
  padding: 12px 24px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

.chat-input button:hover {
  background: #0056b3;
}
```

---

## 高级功能

### WebSocket 实时同步

```typescript
// hooks/useRealtimeSync.ts
import { useEffect } from 'react';
import { SessionManager } from '../session-manager';

export const useRealtimeSync = (
  manager: SessionManager,
  onUpdate: () => void
) => {
  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8080');

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'message_added') {
        // 重新加载会话
        onUpdate();
      }
    };

    return () => ws.close();
  }, [manager, onUpdate]);
};
```

### 键盘快捷键

```typescript
// hooks/useKeyboardShortcuts.ts
import { useEffect } from 'react';

export const useKeyboardShortcuts = (handlers: {
  onBranch?: () => void;
  onBack?: () => void;
  onForward?: () => void;
}) => {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 'b':
            e.preventDefault();
            handlers.onBranch?.();
            break;
          case '[':
            e.preventDefault();
            handlers.onBack?.();
            break;
          case ']':
            e.preventDefault();
            handlers.onForward?.();
            break;
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handlers]);
};
```

### 导出功能

```typescript
// components/ExportButton.tsx
import React from 'react';
import { SessionManager } from '../session-manager';

interface ExportButtonProps {
  manager: SessionManager;
}

export const ExportButton: React.FC<ExportButtonProps> = ({ manager }) => {
  const handleExport = () => {
    const messages = manager.buildContext();
    const text = messages
      .map(m => `[${m.role.toUpperCase()}] ${m.content}`)
      .join('\n\n');

    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'session-export.txt';
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <button onClick={handleExport}>
      Export Session
    </button>
  );
};
```

---

## 后端 API 实现

```typescript
// server.ts
import express from 'express';
import { SessionManager } from './session-manager';
import { WebSocketServer } from 'ws';

const app = express();
const wss = new WebSocketServer({ port: 8080 });

app.use(express.json());

const manager = new SessionManager('session.jsonl');

// 获取会话树
app.get('/api/tree', (req, res) => {
  const tree = manager.getTree();
  res.json(tree);
});

// 获取消息
app.get('/api/messages', (req, res) => {
  const messages = manager.buildContext();
  res.json(messages);
});

// 添加消息
app.post('/api/messages', (req, res) => {
  const { content, type } = req.body;
  const id = manager.addMessage(content, type);

  // 广播更新
  wss.clients.forEach(client => {
    client.send(JSON.stringify({ type: 'message_added', id }));
  });

  res.json({ id });
});

// 创建分支
app.post('/api/branch', (req, res) => {
  const { branchFromId } = req.body;
  manager.branch(branchFromId);

  wss.clients.forEach(client => {
    client.send(JSON.stringify({ type: 'branch_created', branchFromId }));
  });

  res.json({ success: true });
});

// 获取所有分支
app.get('/api/branches', (req, res) => {
  const branches = manager.getAllBranches();
  res.json(branches);
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

---

## 完整示例

```typescript
// index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';
import './styles.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Session Manager</title>
</head>
<body>
  <div id="root"></div>
</body>
</html>
```

---

## 关键要点总结

1. **React 组件化**：模块化的组件设计
2. **树形可视化**：直观的会话树展示
3. **实时同步**：WebSocket 实时更新
4. **交互式导航**：友好的用户界面
5. **完整集成**：前后端完整实现

---

**下一步**：准备面试 → `08_面试必问.md`
