# docker-compose编排 - 核心概念：服务定义与编排

## 概述

**服务（Services）** 是 docker-compose 的核心概念，每个服务代表一个容器实例。服务定义包括镜像来源、端口映射、环境变量、依赖关系等配置。

**本文涵盖：**
1. 服务定义的基本语法
2. 镜像来源配置（image vs build）
3. 依赖关系管理（depends_on）
4. 容器命名和重启策略
5. 服务间通信机制

---

## 1. 服务定义基本语法

### 1.1 最简单的服务定义

```yaml
version: '3.8'

services:
  api:
    image: python:3.13-slim
    ports:
      - "8000:8000"
```

**说明：**
- `services`：定义所有服务的根节点
- `api`：服务名称（可以自定义）
- `image`：使用的 Docker 镜像
- `ports`：端口映射（主机端口:容器端口）

### 1.2 完整的服务定义

```yaml
services:
  api:
    # 镜像来源
    image: my-api:latest
    # 或者构建镜像
    build:
      context: .
      dockerfile: Dockerfile

    # 容器名称
    container_name: my-api-container

    # 端口映射
    ports:
      - "8000:8000"

    # 环境变量
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
      - DEBUG=true

    # 依赖关系
    depends_on:
      - db

    # 数据卷
    volumes:
      - .:/app

    # 网络
    networks:
      - my-network

    # 重启策略
    restart: unless-stopped

    # 命令覆盖
    command: uvicorn app.main:app --host 0.0.0.0 --reload
```

---

## 2. 镜像来源配置

### 2.1 使用现有镜像（image）

**适用场景：** 使用公共镜像或已构建的镜像

```yaml
services:
  # 使用官方镜像
  db:
    image: postgres:14-alpine

  # 使用私有仓库镜像
  api:
    image: registry.example.com/my-api:latest
```

**前端类比：**
```javascript
// 使用 npm 包（不需要自己构建）
import express from 'express';
```

### 2.2 构建镜像（build）

**适用场景：** 需要自定义镜像

#### 简单构建

```yaml
services:
  api:
    build: .  # 使用当前目录的 Dockerfile
```

#### 指定 Dockerfile

```yaml
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile.dev
```

#### 构建参数

```yaml
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        - PYTHON_VERSION=3.13
        - APP_ENV=development
```

**Dockerfile 示例：**
```dockerfile
ARG PYTHON_VERSION=3.13
FROM python:${PYTHON_VERSION}-slim

ARG APP_ENV
ENV APP_ENV=${APP_ENV}

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0"]
```

**前端类比：**
```javascript
// 自己构建代码（需要编译）
import { build } from 'vite';
await build({ mode: 'development' });
```

### 2.3 image + build 组合

```yaml
services:
  api:
    image: my-api:latest  # 构建后的镜像名称
    build: .              # 构建配置
```

**说明：**
- `build`：定义如何构建镜像
- `image`：构建后的镜像名称（用于缓存和推送）

---

## 3. 依赖关系管理（depends_on）

### 3.1 简单依赖

```yaml
services:
  api:
    depends_on:
      - db
      - redis

  db:
    image: postgres:14-alpine

  redis:
    image: redis:7-alpine
```

**效果：**
- 启动顺序：db → redis → api
- 停止顺序：api → redis → db

**前端类比：**
```javascript
// 模块依赖
import { connectDB } from './db';
import { connectRedis } from './redis';

async function startApp() {
  await connectDB();    // 先连接数据库
  await connectRedis(); // 再连接 Redis
  startServer();        // 最后启动服务器
}
```

### 3.2 条件依赖（推荐）

```yaml
services:
  api:
    depends_on:
      db:
        condition: service_healthy  # 等待健康检查通过
      redis:
        condition: service_started  # 等待容器启动

  db:
    image: postgres:14-alpine
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
      timeout: 3s
      retries: 5

  redis:
    image: redis:7-alpine
```

**条件类型：**

| 条件 | 说明 | 适用场景 |
|------|------|---------|
| `service_started` | 容器启动 | 启动快的服务（Redis） |
| `service_healthy` | 健康检查通过 | 需要初始化的服务（数据库） |
| `service_completed_successfully` | 容器成功退出 | 初始化任务 |

### 3.3 复杂依赖场景

```yaml
services:
  # API 依赖数据库和缓存
  api:
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      migration:
        condition: service_completed_successfully

  # 数据库迁移依赖数据库
  migration:
    image: my-api:latest
    command: alembic upgrade head
    depends_on:
      db:
        condition: service_healthy

  # 数据库
  db:
    image: postgres:14-alpine
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s

  # 缓存
  redis:
    image: redis:7-alpine
```

**启动顺序：**
```
1. db 启动并通过健康检查
   ↓
2. migration 运行并成功退出
   ↓
3. redis 启动
   ↓
4. api 启动
```

---

## 4. 容器命名和重启策略

### 4.1 容器命名（container_name）

```yaml
services:
  api:
    container_name: my-ai-agent-api
    image: my-api:latest
```

**注意：**
- ✅ 方便识别和管理
- ❌ 不能启动多个实例（名称冲突）
- ❌ 不适合扩展（replicas）

**推荐：**
```yaml
# 开发环境：使用 container_name（方便调试）
services:
  api:
    container_name: dev-api

# 生产环境：不使用 container_name（支持扩展）
services:
  api:
    image: my-api:latest
    # 不设置 container_name
```

### 4.2 重启策略（restart）

```yaml
services:
  api:
    restart: unless-stopped
```

**重启策略：**

| 策略 | 说明 | 适用场景 |
|------|------|---------|
| `no` | 不自动重启（默认） | 开发环境、一次性任务 |
| `always` | 总是重启 | 生产环境（但会在手动停止后也重启） |
| `on-failure` | 失败时重启 | 需要区分正常退出和异常退出 |
| `unless-stopped` | 除非手动停止，否则重启 | 生产环境（推荐） |

**示例：**

```yaml
services:
  # 开发环境：不自动重启
  api-dev:
    restart: "no"

  # 生产环境：除非手动停止，否则重启
  api-prod:
    restart: unless-stopped

  # 初始化任务：失败时重启
  migration:
    restart: on-failure
    command: alembic upgrade head
```

**前端类比：**
```javascript
// restart: always = PM2 自动重启
pm2 start app.js --restart-delay=3000

// restart: no = 手动启动
node app.js
```

---

## 5. 服务间通信

### 5.1 默认网络通信

**docker-compose 自动创建网络，服务间可以通过服务名通信。**

```yaml
services:
  api:
    environment:
      # 通过服务名访问数据库
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
      # 通过服务名访问 Redis
      - REDIS_URL=redis://redis:6379

  db:
    image: postgres:14-alpine

  redis:
    image: redis:7-alpine
```

**Python 代码：**
```python
import psycopg2
import redis

# 通过服务名连接数据库
conn = psycopg2.connect(
    host="db",  # 服务名
    port=5432,
    user="user",
    password="pass",
    database="mydb"
)

# 通过服务名连接 Redis
r = redis.Redis(host="redis", port=6379)
```

**前端类比：**
```javascript
// 在同一个 localhost 上通信
fetch('http://localhost:3000/api')  // 前端调用后端
```

### 5.2 自定义网络

```yaml
services:
  api:
    networks:
      - frontend
      - backend

  db:
    networks:
      - backend

  nginx:
    networks:
      - frontend

networks:
  frontend:
  backend:
```

**网络隔离：**
- `api` 可以访问 `db` 和 `nginx`（在两个网络中）
- `nginx` 不能访问 `db`（不在同一网络）

### 5.3 端口映射 vs 服务间通信

```yaml
services:
  # API：暴露到主机
  api:
    ports:
      - "8000:8000"  # 主机可以访问

  # 数据库：不暴露到主机
  db:
    # 不设置 ports
    # 只有容器内部可以访问
```

**说明：**
- **ports**：暴露到主机（外部可以访问）
- **不设置 ports**：只在容器网络内部可以访问（更安全）

**最佳实践：**
```yaml
services:
  # API：暴露到主机（用户需要访问）
  api:
    ports:
      - "8000:8000"

  # 数据库：不暴露（只有 API 需要访问）
  db:
    # 不设置 ports

  # Redis：不暴露（只有 API 需要访问）
  redis:
    # 不设置 ports
```

---

## 6. 命令覆盖（command）

### 6.1 覆盖 Dockerfile 的 CMD

```yaml
services:
  api:
    image: my-api:latest
    command: uvicorn app.main:app --host 0.0.0.0 --reload
```

**Dockerfile：**
```dockerfile
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0"]
```

**docker-compose.yml 会覆盖 Dockerfile 的 CMD。**

### 6.2 开发环境 vs 生产环境

```yaml
# docker-compose.dev.yml（开发环境）
services:
  api:
    command: uvicorn app.main:app --reload  # 热重载

# docker-compose.prod.yml（生产环境）
services:
  api:
    command: uvicorn app.main:app --workers 4  # 多进程
```

---

## 7. 在 AI Agent 开发中的完整示例

### 7.1 基础配置

```yaml
version: '3.8'

services:
  # FastAPI 应用
  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ai-agent-api
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/agent_db
      - REDIS_URL=redis://redis:6379
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    volumes:
      - .:/app
    command: uvicorn app.main:app --host 0.0.0.0 --reload
    restart: unless-stopped
    networks:
      - app-network

  # PostgreSQL 数据库
  db:
    image: postgres:14-alpine
    container_name: ai-agent-db
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=agent_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
      timeout: 3s
      retries: 5
    restart: unless-stopped
    networks:
      - app-network

  # Redis 缓存
  redis:
    image: redis:7-alpine
    container_name: ai-agent-redis
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - app-network

volumes:
  postgres_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

### 7.2 添加数据库迁移

```yaml
services:
  # 数据库迁移（在 API 启动前运行）
  migration:
    build: .
    command: alembic upgrade head
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/agent_db
    depends_on:
      db:
        condition: service_healthy
    networks:
      - app-network
    restart: on-failure

  # API（依赖迁移完成）
  api:
    depends_on:
      migration:
        condition: service_completed_successfully
      redis:
        condition: service_started
```

### 7.3 添加管理工具

```yaml
services:
  # pgAdmin（数据库管理工具）
  pgadmin:
    image: dpage/pgadmin4
    container_name: ai-agent-pgadmin
    ports:
      - "5050:80"
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@example.com
      - PGADMIN_DEFAULT_PASSWORD=admin
    depends_on:
      - db
    networks:
      - app-network
    profiles: ["dev"]  # 只在开发环境启动
```

---

## 8. 最佳实践

### 8.1 服务命名

```yaml
# ✅ 推荐：清晰的服务名
services:
  api:
  db:
  redis:
  worker:

# ❌ 不推荐：模糊的服务名
services:
  app:
  database:
  cache:
  background:
```

### 8.2 依赖管理

```yaml
# ✅ 推荐：使用健康检查
services:
  api:
    depends_on:
      db:
        condition: service_healthy

  db:
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s

# ❌ 不推荐：只依赖启动
services:
  api:
    depends_on:
      - db
```

### 8.3 端口映射

```yaml
# ✅ 推荐：只暴露必要的端口
services:
  api:
    ports:
      - "8000:8000"  # 暴露 API

  db:
    # 不暴露端口（只在内部访问）

# ❌ 不推荐：暴露所有端口
services:
  db:
    ports:
      - "5432:5432"  # 不必要的暴露
```

### 8.4 重启策略

```yaml
# ✅ 推荐：根据环境选择
services:
  # 开发环境
  api-dev:
    restart: "no"

  # 生产环境
  api-prod:
    restart: unless-stopped

# ❌ 不推荐：所有环境都用 always
services:
  api:
    restart: always  # 手动停止后也会重启
```

---

## 9. 常见问题

### Q1: 为什么 API 连接数据库失败？

**A:** 可能是 depends_on 只等待容器启动，不等待服务就绪。

**解决：**
```yaml
services:
  api:
    depends_on:
      db:
        condition: service_healthy  # 等待健康检查

  db:
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
```

### Q2: 如何在容器内访问主机服务？

**A:** 使用特殊主机名 `host.docker.internal`

```yaml
services:
  api:
    environment:
      - EXTERNAL_API=http://host.docker.internal:3000
```

### Q3: 如何查看服务日志？

**A:** 使用 docker-compose logs

```bash
# 查看所有服务日志
docker-compose logs

# 查看特定服务日志
docker-compose logs api

# 实时查看日志
docker-compose logs -f api
```

### Q4: 如何重启单个服务？

**A:** 使用 docker-compose restart

```bash
# 重启单个服务
docker-compose restart api

# 重启所有服务
docker-compose restart
```

### Q5: 如何扩展服务实例？

**A:** 使用 docker-compose up --scale

```bash
# 启动 3 个 API 实例
docker-compose up --scale api=3

# 注意：不能设置 container_name
```

---

## 10. 总结

**服务定义的核心要素：**
1. **镜像来源**：image（现有镜像）或 build（构建镜像）
2. **依赖关系**：depends_on + healthcheck（确保启动顺序和就绪状态）
3. **端口映射**：只暴露必要的端口
4. **环境变量**：配置与代码分离
5. **重启策略**：根据环境选择合适的策略
6. **服务间通信**：通过服务名访问

**在 AI Agent 开发中：**
- API 依赖数据库和缓存
- 使用健康检查确保数据库就绪
- 只暴露 API 端口，数据库和缓存不暴露
- 开发环境使用代码热重载
- 生产环境使用自动重启

---

**版本：** v1.0
**最后更新：** 2026-02-12
