# 实战代码06: 前端集成示例

> 完整的前端流式输出集成示例,包括 React、Vue 和原生 JavaScript

---

## 概述

本节提供完整的前端集成示例,涵盖所有流式输出场景的前端实现。

**学习目标:**
- 掌握 EventSource API 的使用
- 实现 React 和 Vue 的流式组件
- 处理错误和重连
- 优化用户体验

---

## 1. 原生 JavaScript 实现

### 1.1 基础 EventSource

```html
<!DOCTYPE html>
<html>
<head>
    <title>SSE 流式输出</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #messages { border: 1px solid #ccc; padding: 10px; min-height: 200px; }
        .message { padding: 5px; margin: 5px 0; background: #f0f0f0; }
    </style>
</head>
<body>
    <h1>SSE 流式输出示例</h1>
    <button onclick="startStream()">开始</button>
    <button onclick="stopStream()">停止</button>
    <div id="messages"></div>

    <script>
        let eventSource = null;

        function startStream() {
            if (eventSource) {
                eventSource.close();
            }

            document.getElementById('messages').innerHTML = '';
            eventSource = new EventSource('http://localhost:8000/stream');

            eventSource.onmessage = (event) => {
                addMessage(event.data);
            };

            eventSource.addEventListener('done', (event) => {
                addMessage('完成: ' + event.data, 'green');
                eventSource.close();
            });

            eventSource.onerror = () => {
                addMessage('连接错误', 'red');
            };
        }

        function stopStream() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
        }

        function addMessage(text, color = 'black') {
            const div = document.createElement('div');
            div.className = 'message';
            div.textContent = text;
            div.style.color = color;
            document.getElementById('messages').appendChild(div);
        }
    </script>
</body>
</html>
```

### 1.2 使用 Fetch API

```html
<!DOCTYPE html>
<html>
<head>
    <title>Fetch 流式输出</title>
</head>
<body>
    <h1>Fetch 流式输出示例</h1>
    <button onclick="startStream()">开始</button>
    <div id="output"></div>

    <script>
        async function startStream() {
            const response = await fetch('http://localhost:8000/stream', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer token'  // 可以添加自定义头
                },
                body: JSON.stringify({ message: 'Hello' })
            });

            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        document.getElementById('output').textContent += data;
                    }
                }
            }
        }
    </script>
</body>
</html>
```

---

## 2. React 完整实现

### 2.1 通用流式客户端 Hook

```javascript
/**
 * 通用流式客户端 Hook
 * 文件: src/hooks/useStreamingClient.js
 */

import { useState, useRef, useCallback } from 'react';

export function useStreamingClient(url, options = {}) {
    const [isStreaming, setIsStreaming] = useState(false);
    const [error, setError] = useState(null);
    const eventSourceRef = useRef(null);
    const handlersRef = useRef({});

    // 注册事件处理器
    const on = useCallback((eventType, handler) => {
        handlersRef.current[eventType] = handler;
    }, []);

    // 开始流式连接
    const start = useCallback((params = {}) => {
        if (isStreaming) return;

        setError(null);
        setIsStreaming(true);

        // 构建 URL
        const queryString = new URLSearchParams(params).toString();
        const fullUrl = queryString ? `${url}?${queryString}` : url;

        // 创建 EventSource
        const eventSource = new EventSource(fullUrl);
        eventSourceRef.current = eventSource;

        // 监听消息
        eventSource.onmessage = (event) => {
            const handler = handlersRef.current['message'];
            if (handler) handler(event.data);
        };

        // 监听错误
        eventSource.onerror = (error) => {
            setError('连接错误');
            setIsStreaming(false);
            const handler = handlersRef.current['error'];
            if (handler) handler(error);
        };

        // 监听自定义事件
        Object.keys(handlersRef.current).forEach(eventType => {
            if (eventType !== 'message' && eventType !== 'error') {
                eventSource.addEventListener(eventType, (event) => {
                    const handler = handlersRef.current[eventType];
                    if (handler) {
                        try {
                            const data = JSON.parse(event.data);
                            handler(data);
                        } catch {
                            handler(event.data);
                        }
                    }
                });
            }
        });

        return () => {
            eventSource.close();
        };
    }, [url, isStreaming]);

    // 停止流式连接
    const stop = useCallback(() => {
        if (eventSourceRef.current) {
            eventSourceRef.current.close();
            eventSourceRef.current = null;
            setIsStreaming(false);
        }
    }, []);

    return {
        isStreaming,
        error,
        start,
        stop,
        on
    };
}
```

### 2.2 聊天组件

```javascript
/**
 * 聊天组件
 * 文件: src/components/ChatStream.jsx
 */

import React, { useState, useEffect, useRef } from 'react';
import { useStreamingClient } from '../hooks/useStreamingClient';

function ChatStream() {
    const [messages, setMessages] = useState([]);
    const [input, setInput] = useState('');
    const [currentMessage, setCurrentMessage] = useState('');
    const messagesEndRef = useRef(null);

    const { isStreaming, error, start, stop, on } = useStreamingClient(
        'http://localhost:8000/chat'
    );

    // 注册事件处理器
    useEffect(() => {
        on('start', () => {
            setCurrentMessage('');
        });

        on('message', (data) => {
            try {
                const parsed = JSON.parse(data);
                setCurrentMessage(prev => prev + parsed.token);
            } catch {
                setCurrentMessage(prev => prev + data);
            }
        });

        on('done', (data) => {
            setMessages(prev => [...prev, {
                role: 'assistant',
                content: data.full_response || currentMessage
            }]);
            setCurrentMessage('');
        });

        on('error', (data) => {
            console.error('Stream error:', data);
        });
    }, [on, currentMessage]);

    // 自动滚动到底部
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages, currentMessage]);

    const sendMessage = () => {
        if (!input.trim() || isStreaming) return;

        // 添加用户消息
        setMessages(prev => [...prev, {
            role: 'user',
            content: input
        }]);

        // 开始流式生成
        start({ message: input });
        setInput('');
    };

    return (
        <div className="chat-container">
            <div className="messages">
                {messages.map((msg, index) => (
                    <div key={index} className={`message ${msg.role}`}>
                        <strong>{msg.role === 'user' ? '你' : 'AI'}:</strong>
                        <div>{msg.content}</div>
                    </div>
                ))}

                {currentMessage && (
                    <div className="message assistant">
                        <strong>AI:</strong>
                        <div>
                            {currentMessage}
                            <span className="cursor">▋</span>
                        </div>
                    </div>
                )}

                <div ref={messagesEndRef} />
            </div>

            {error && <div className="error">{error}</div>}

            <div className="input-area">
                <input
                    type="text"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                    placeholder="输入消息..."
                    disabled={isStreaming}
                />
                <button onClick={sendMessage} disabled={isStreaming}>
                    {isStreaming ? '生成中...' : '发送'}
                </button>
            </div>

            <style jsx>{`
                .chat-container {
                    display: flex;
                    flex-direction: column;
                    height: 600px;
                    max-width: 800px;
                    margin: 0 auto;
                    border: 1px solid #ccc;
                }

                .messages {
                    flex: 1;
                    overflow-y: auto;
                    padding: 20px;
                }

                .message {
                    margin-bottom: 15px;
                    padding: 10px;
                    border-radius: 8px;
                }

                .message.user {
                    background: #e3f2fd;
                }

                .message.assistant {
                    background: #f5f5f5;
                }

                .cursor {
                    animation: blink 1s infinite;
                }

                @keyframes blink {
                    0%, 50% { opacity: 1; }
                    51%, 100% { opacity: 0; }
                }

                .error {
                    padding: 10px;
                    background: #ffebee;
                    color: #c62828;
                }

                .input-area {
                    display: flex;
                    padding: 10px;
                    border-top: 1px solid #ccc;
                }

                .input-area input {
                    flex: 1;
                    padding: 10px;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                }

                .input-area button {
                    margin-left: 10px;
                    padding: 10px 20px;
                    background: #2196f3;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                }

                .input-area button:disabled {
                    background: #ccc;
                    cursor: not-allowed;
                }
            `}</style>
        </div>
    );
}

export default ChatStream;
```

---

## 3. Vue 完整实现

### 3.1 通用流式客户端 Composable

```javascript
/**
 * 通用流式客户端 Composable
 * 文件: src/composables/useStreamingClient.js
 */

import { ref, onUnmounted } from 'vue';

export function useStreamingClient(url, options = {}) {
    const isStreaming = ref(false);
    const error = ref(null);
    let eventSource = null;
    const handlers = {};

    // 注册事件处理器
    const on = (eventType, handler) => {
        handlers[eventType] = handler;
    };

    // 开始流式连接
    const start = (params = {}) => {
        if (isStreaming.value) return;

        error.value = null;
        isStreaming.value = true;

        // 构建 URL
        const queryString = new URLSearchParams(params).toString();
        const fullUrl = queryString ? `${url}?${queryString}` : url;

        // 创建 EventSource
        eventSource = new EventSource(fullUrl);

        // 监听消息
        eventSource.onmessage = (event) => {
            const handler = handlers['message'];
            if (handler) handler(event.data);
        };

        // 监听错误
        eventSource.onerror = (err) => {
            error.value = '连接错误';
            isStreaming.value = false;
            const handler = handlers['error'];
            if (handler) handler(err);
        };

        // 监听自定义事件
        Object.keys(handlers).forEach(eventType => {
            if (eventType !== 'message' && eventType !== 'error') {
                eventSource.addEventListener(eventType, (event) => {
                    const handler = handlers[eventType];
                    if (handler) {
                        try {
                            const data = JSON.parse(event.data);
                            handler(data);
                        } catch {
                            handler(event.data);
                        }
                    }
                });
            }
        });
    };

    // 停止流式连接
    const stop = () => {
        if (eventSource) {
            eventSource.close();
            eventSource = null;
            isStreaming.value = false;
        }
    };

    // 组件卸载时关闭连接
    onUnmounted(() => {
        stop();
    });

    return {
        isStreaming,
        error,
        start,
        stop,
        on
    };
}
```

### 3.2 聊天组件

```vue
<!--
聊天组件
文件: src/components/ChatStream.vue
-->

<template>
  <div class="chat-container">
    <div class="messages" ref="messagesContainer">
      <div
        v-for="(msg, index) in messages"
        :key="index"
        :class="['message', msg.role]"
      >
        <strong>{{ msg.role === 'user' ? '你' : 'AI' }}:</strong>
        <div>{{ msg.content }}</div>
      </div>

      <div v-if="currentMessage" class="message assistant">
        <strong>AI:</strong>
        <div>
          {{ currentMessage }}
          <span class="cursor">▋</span>
        </div>
      </div>
    </div>

    <div v-if="error" class="error">{{ error }}</div>

    <div class="input-area">
      <input
        v-model="input"
        @keypress.enter="sendMessage"
        :disabled="isStreaming"
        placeholder="输入消息..."
      />
      <button @click="sendMessage" :disabled="isStreaming">
        {{ isStreaming ? '生成中...' : '发送' }}
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useStreamingClient } from '../composables/useStreamingClient';

const messages = ref([]);
const input = ref('');
const currentMessage = ref('');
const messagesContainer = ref(null);

const { isStreaming, error, start, stop, on } = useStreamingClient(
  'http://localhost:8000/chat'
);

// 注册事件处理器
on('start', () => {
  currentMessage.value = '';
});

on('message', (data) => {
  try {
    const parsed = JSON.parse(data);
    currentMessage.value += parsed.token;
  } catch {
    currentMessage.value += data;
  }
});

on('done', (data) => {
  messages.value.push({
    role: 'assistant',
    content: data.full_response || currentMessage.value
  });
  currentMessage.value = '';
});

on('error', (data) => {
  console.error('Stream error:', data);
});

// 自动滚动到底部
watch([messages, currentMessage], async () => {
  await nextTick();
  if (messagesContainer.value) {
    messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
  }
});

const sendMessage = () => {
  if (!input.value.trim() || isStreaming.value) return;

  messages.value.push({
    role: 'user',
    content: input.value
  });

  start({ message: input.value });
  input.value = '';
};
</script>

<style scoped>
.chat-container {
  display: flex;
  flex-direction: column;
  height: 600px;
  max-width: 800px;
  margin: 0 auto;
  border: 1px solid #ccc;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.message {
  margin-bottom: 15px;
  padding: 10px;
  border-radius: 8px;
}

.message.user {
  background: #e3f2fd;
}

.message.assistant {
  background: #f5f5f5;
}

.cursor {
  animation: blink 1s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.error {
  padding: 10px;
  background: #ffebee;
  color: #c62828;
}

.input-area {
  display: flex;
  padding: 10px;
  border-top: 1px solid #ccc;
}

.input-area input {
  flex: 1;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.input-area button {
  margin-left: 10px;
  padding: 10px 20px;
  background: #2196f3;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.input-area button:disabled {
  background: #ccc;
  cursor: not-allowed;
}
</style>
```

---

## 4. 错误处理和重连

### 4.1 带重连的客户端

```javascript
/**
 * 带重连的流式客户端
 * 文件: src/utils/StreamingClientWithRetry.js
 */

class StreamingClientWithRetry {
    constructor(url, options = {}) {
        this.url = url;
        this.maxRetries = options.maxRetries || 5;
        this.retryDelay = options.retryDelay || 1000;
        this.retryCount = 0;
        this.eventSource = null;
        this.handlers = {};
        this.isConnected = false;
    }

    on(eventType, handler) {
        this.handlers[eventType] = handler;
        return this;
    }

    connect(params = {}) {
        const queryString = new URLSearchParams(params).toString();
        const fullUrl = queryString ? `${this.url}?${queryString}` : this.url;

        this.eventSource = new EventSource(fullUrl);

        this.eventSource.onopen = () => {
            this.isConnected = true;
            this.retryCount = 0;
            const handler = this.handlers['open'];
            if (handler) handler();
        };

        this.eventSource.onmessage = (event) => {
            const handler = this.handlers['message'];
            if (handler) handler(event.data);
        };

        this.eventSource.onerror = (error) => {
            this.isConnected = false;

            const handler = this.handlers['error'];
            if (handler) handler(error);

            // 自动重连
            if (this.retryCount < this.maxRetries) {
                this.retryCount++;
                const delay = this.retryDelay * Math.pow(2, this.retryCount - 1);

                console.log(`重连中... (${this.retryCount}/${this.maxRetries}), 延迟: ${delay}ms`);

                setTimeout(() => {
                    this.eventSource.close();
                    this.connect(params);
                }, delay);
            } else {
                console.error('超过最大重连次数');
                this.close();
            }
        };

        // 注册自定义事件
        Object.keys(this.handlers).forEach(eventType => {
            if (!['open', 'message', 'error'].includes(eventType)) {
                this.eventSource.addEventListener(eventType, (event) => {
                    const handler = this.handlers[eventType];
                    if (handler) {
                        try {
                            const data = JSON.parse(event.data);
                            handler(data);
                        } catch {
                            handler(event.data);
                        }
                    }
                });
            }
        });
    }

    close() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
            this.isConnected = false;
        }
    }
}

export default StreamingClientWithRetry;
```

### 4.2 使用示例

```javascript
/**
 * 使用带重连的客户端
 */

import StreamingClientWithRetry from './StreamingClientWithRetry';

const client = new StreamingClientWithRetry('http://localhost:8000/stream', {
    maxRetries: 5,
    retryDelay: 1000
});

client
    .on('open', () => {
        console.log('连接成功');
    })
    .on('message', (data) => {
        console.log('收到消息:', data);
    })
    .on('error', (error) => {
        console.error('连接错误:', error);
    })
    .on('done', (data) => {
        console.log('完成:', data);
        client.close();
    });

client.connect({ message: 'Hello' });
```

---

## 5. 性能优化

### 5.1 虚拟滚动

```javascript
/**
 * 虚拟滚动聊天组件
 * 文件: src/components/VirtualScrollChat.jsx
 */

import React, { useState, useRef } from 'react';
import { FixedSizeList } from 'react-window';

function VirtualScrollChat() {
    const [messages, setMessages] = useState([]);
    const listRef = useRef(null);

    const Row = ({ index, style }) => {
        const msg = messages[index];
        return (
            <div style={style} className={`message ${msg.role}`}>
                <strong>{msg.role === 'user' ? '你' : 'AI'}:</strong>
                <div>{msg.content}</div>
            </div>
        );
    };

    return (
        <div>
            <FixedSizeList
                ref={listRef}
                height={500}
                itemCount={messages.length}
                itemSize={80}
                width="100%"
            >
                {Row}
            </FixedSizeList>
        </div>
    );
}

export default VirtualScrollChat;
```

### 5.2 防抖和节流

```javascript
/**
 * 防抖和节流工具
 * 文件: src/utils/throttle.js
 */

// 节流: 限制函数执行频率
export function throttle(func, delay) {
    let lastCall = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastCall >= delay) {
            lastCall = now;
            return func.apply(this, args);
        }
    };
}

// 防抖: 延迟执行,多次调用只执行最后一次
export function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// 使用示例
const handleScroll = throttle(() => {
    console.log('滚动事件');
}, 100);

const handleInput = debounce((value) => {
    console.log('输入:', value);
}, 300);
```

---

## 6. 测试

### 6.1 React 组件测试

```javascript
/**
 * React 组件测试
 * 文件: src/components/__tests__/ChatStream.test.jsx
 */

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import ChatStream from '../ChatStream';

// Mock EventSource
global.EventSource = jest.fn(() => ({
    addEventListener: jest.fn(),
    close: jest.fn(),
    onmessage: null,
    onerror: null
}));

describe('ChatStream', () => {
    test('renders chat interface', () => {
        render(<ChatStream />);
        expect(screen.getByPlaceholderText('输入消息...')).toBeInTheDocument();
        expect(screen.getByText('发送')).toBeInTheDocument();
    });

    test('sends message on button click', async () => {
        render(<ChatStream />);

        const input = screen.getByPlaceholderText('输入消息...');
        const button = screen.getByText('发送');

        fireEvent.change(input, { target: { value: 'Hello' } });
        fireEvent.click(button);

        await waitFor(() => {
            expect(screen.getByText('你:')).toBeInTheDocument();
        });
    });
});
```

---

## 总结

**本节要点:**

1. **原生 JavaScript**: EventSource 和 Fetch API 的使用
2. **React 实现**: Hook 和组件的完整实现
3. **Vue 实现**: Composable 和组件的完整实现
4. **错误处理**: 重连机制和错误提示
5. **性能优化**: 虚拟滚动、防抖节流

**关键代码:**
```javascript
const eventSource = new EventSource(url);
eventSource.onmessage = (event) => {
    console.log(event.data);
};
```

**下一步:**

掌握了前端集成后,可以学习:
- 错误处理与重试
- 性能优化
- 化骨绵掌

---

**记住:** 前端集成是流式输出的最后一环,良好的前端实现能大幅提升用户体验。
