# 核心概念2：任务队列对比

> 深入对比 BackgroundTasks 和任务队列（Celery/RQ），掌握选择标准

---

## 1. 为什么需要任务队列？

### 1.1 BackgroundTasks 的局限性

虽然 BackgroundTasks 简单易用，但有明确的限制：

```python
# BackgroundTasks 的问题场景

# 问题1：长时间任务
@app.post("/train-model")
async def train_model(bg: BackgroundTasks):
    bg.add_task(train_ml_model)  # 可能需要几小时
    return {"status": "started"}
    # 问题：服务器重启，任务丢失

# 问题2：任务失败无重试
@app.post("/send-email")
async def send_email(bg: BackgroundTasks):
    bg.add_task(send_email_task)
    return {"status": "ok"}
    # 问题：邮件服务器故障，任务失败，无法重试

# 问题3：无法查询任务状态
@app.post("/process")
async def process(bg: BackgroundTasks):
    bg.add_task(long_task)
    return {"status": "processing"}
    # 问题：用户无法查询任务进度

# 问题4：无法定时执行
# BackgroundTasks 无法实现定时任务
```

**核心问题：** BackgroundTasks 与请求生命周期绑定，缺乏持久化和高级特性。

---

## 2. 任务队列架构

### 2.1 Celery 架构

```
┌─────────────────────────────────────────────────────────┐
│                    Celery 架构                           │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  FastAPI 应用                                            │
│  ┌──────────────┐                                       │
│  │  路由函数     │                                       │
│  │  task.delay() │ ──────┐                              │
│  └──────────────┘        │                              │
│                          ↓                               │
│                   ┌─────────────┐                       │
│                   │ 消息代理     │                       │
│                   │ (Redis/     │                       │
│                   │  RabbitMQ)  │                       │
│                   └─────────────┘                       │
│                          │                               │
│                          ↓                               │
│                   ┌─────────────┐                       │
│                   │ Celery      │                       │
│                   │ Worker      │                       │
│                   │ (独立进程)   │                       │
│                   └─────────────┘                       │
│                          │                               │
│                          ↓                               │
│                   ┌─────────────┐                       │
│                   │ 结果后端     │                       │
│                   │ (Redis/DB)  │                       │
│                   └─────────────┘                       │
└─────────────────────────────────────────────────────────┘
```

**关键组件：**
1. **消息代理（Broker）**：存储任务队列（Redis/RabbitMQ）
2. **Worker**：独立进程，执行任务
3. **结果后端（Backend）**：存储任务结果

### 2.2 BackgroundTasks 架构

```
┌─────────────────────────────────────────────────────────┐
│              BackgroundTasks 架构                        │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  FastAPI 应用（单进程）                                  │
│  ┌──────────────────────────────────────┐              │
│  │  路由函数                             │              │
│  │  background_tasks.add_task()         │              │
│  │         ↓                             │              │
│  │  内部队列（内存）                     │              │
│  │         ↓                             │              │
│  │  后台线程池                           │              │
│  │  （与应用在同一进程）                 │              │
│  └──────────────────────────────────────┘              │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

**关键特点：**
- 单进程内执行
- 任务存储在内存中
- 无持久化

---

## 3. 详细对比

### 3.1 功能对比表

| 特性 | BackgroundTasks | Celery | RQ |
|------|----------------|--------|-----|
| **部署复杂度** | ⭐ 无需额外服务 | ⭐⭐⭐ 需要 Broker + Worker | ⭐⭐ 需要 Redis + Worker |
| **任务持久化** | ❌ 无 | ✅ 持久化到 Broker | ✅ 持久化到 Redis |
| **任务重试** | ❌ 无 | ✅ 自动重试 | ✅ 自动重试 |
| **任务状态查询** | ❌ 无 | ✅ 支持 | ✅ 支持 |
| **定时任务** | ❌ 无 | ✅ Celery Beat | ❌ 需要额外工具 |
| **任务优先级** | ❌ 无 | ✅ 支持 | ✅ 支持 |
| **分布式执行** | ❌ 单进程 | ✅ 多 Worker | ✅ 多 Worker |
| **任务超时控制** | ❌ 无 | ✅ 支持 | ✅ 支持 |
| **任务取消** | ❌ 无 | ✅ 支持 | ✅ 支持 |
| **监控工具** | ❌ 无 | ✅ Flower | ✅ RQ Dashboard |
| **学习曲线** | ⭐ 简单 | ⭐⭐⭐ 复杂 | ⭐⭐ 中等 |
| **适用场景** | 短任务（< 30秒） | 长任务、关键任务 | 中等任务 |

### 3.2 代码对比

#### BackgroundTasks 示例

```python
from fastapi import FastAPI, BackgroundTasks

app = FastAPI()

def send_email(email: str):
    # 发送邮件
    print(f"发送邮件到 {email}")

@app.post("/register")
async def register(email: str, bg: BackgroundTasks):
    # 添加后台任务
    bg.add_task(send_email, email)
    return {"message": "注册成功"}

# 优点：简单，无需配置
# 缺点：无持久化，无重试，无状态查询
```

#### Celery 示例

```python
from fastapi import FastAPI
from celery import Celery

app = FastAPI()

# 配置 Celery
celery_app = Celery(
    'tasks',
    broker='redis://localhost:6379/0',
    backend='redis://localhost:6379/1'
)

@celery_app.task(bind=True, max_retries=3)
def send_email(self, email: str):
    try:
        # 发送邮件
        print(f"发送邮件到 {email}")
    except Exception as e:
        # 自动重试
        raise self.retry(exc=e, countdown=60)

@app.post("/register")
async def register(email: str):
    # 提交任务到 Celery
    task = send_email.delay(email)
    return {
        "message": "注册成功",
        "task_id": task.id  # 可以查询任务状态
    }

@app.get("/task/{task_id}")
async def get_task_status(task_id: str):
    task = celery_app.AsyncResult(task_id)
    return {
        "status": task.state,
        "result": task.result
    }

# 优点：持久化、重试、状态查询
# 缺点：需要部署 Redis 和 Worker
```

#### RQ 示例

```python
from fastapi import FastAPI
from redis import Redis
from rq import Queue

app = FastAPI()

# 配置 RQ
redis_conn = Redis(host='localhost', port=6379)
queue = Queue(connection=redis_conn)

def send_email(email: str):
    # 发送邮件
    print(f"发送邮件到 {email}")

@app.post("/register")
async def register(email: str):
    # 提交任务到 RQ
    job = queue.enqueue(send_email, email)
    return {
        "message": "注册成功",
        "job_id": job.id
    }

@app.get("/job/{job_id}")
async def get_job_status(job_id: str):
    job = queue.fetch_job(job_id)
    return {
        "status": job.get_status(),
        "result": job.result
    }

# 优点：简单、持久化、状态查询
# 缺点：功能比 Celery 少
```

---

## 4. 选择决策树

### 4.1 决策流程

```
开始
  ↓
任务时间 < 30秒？
  ├─ 是 → 任务失败可接受？
  │        ├─ 是 → 使用 BackgroundTasks ✅
  │        └─ 否 → 需要重试？
  │                 ├─ 是 → 使用 Celery/RQ
  │                 └─ 否 → 使用 BackgroundTasks
  │
  └─ 否 → 任务时间 > 5分钟？
           ├─ 是 → 使用 Celery ✅
           └─ 否 → 需要定时任务？
                    ├─ 是 → 使用 Celery ✅
                    └─ 否 → 使用 RQ 或 Celery
```

### 4.2 场景选择指南

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| 发送邮件（5秒） | BackgroundTasks | 简单、快速 |
| 生成缩略图（10秒） | BackgroundTasks 或 RQ | 都可以 |
| 处理大文件（2分钟） | RQ 或 Celery | 需要持久化 |
| 训练模型（1小时） | Celery | 长时间任务 |
| 定时任务 | Celery Beat | 唯一选择 |
| 对话日志记录（1秒） | BackgroundTasks | 失败可接受 |
| 文档 Embedding 生成（10秒） | BackgroundTasks | 可以接受偶尔失败 |
| 批量数据导入（10分钟） | Celery | 关键任务 |
| 发送 Webhook（3秒） | BackgroundTasks + 重试逻辑 | 简单场景 |

---

## 5. 混合使用策略

### 5.1 渐进式迁移

**阶段1：开发阶段**
```python
# 使用 BackgroundTasks 快速开发
@app.post("/process")
async def process(bg: BackgroundTasks):
    bg.add_task(process_data)
    return {"status": "ok"}
```

**阶段2：生产准备**
```python
# 关键任务迁移到 Celery
@app.post("/process")
async def process():
    task = process_data.delay()  # Celery
    return {"task_id": task.id}

# 非关键任务保留 BackgroundTasks
@app.post("/log")
async def log(bg: BackgroundTasks):
    bg.add_task(write_log)  # BackgroundTasks
    return {"status": "ok"}
```

### 5.2 混合架构示例

```python
from fastapi import FastAPI, BackgroundTasks
from celery import Celery

app = FastAPI()
celery_app = Celery('tasks', broker='redis://localhost:6379')

# 非关键任务：BackgroundTasks
def log_action(action: str):
    with open("log.txt", "a") as f:
        f.write(f"{action}\n")

# 关键任务：Celery
@celery_app.task(bind=True, max_retries=3)
def generate_embedding(self, text: str):
    try:
        # 生成 Embedding
        return embedding
    except Exception as e:
        raise self.retry(exc=e, countdown=60)

@app.post("/upload")
async def upload(
    file: UploadFile,
    background_tasks: BackgroundTasks
):
    # 保存文件
    file_path = save_file(file)

    # 关键任务：用 Celery
    task = generate_embedding.delay(file_path)

    # 非关键任务：用 BackgroundTasks
    background_tasks.add_task(log_action, f"上传文件: {file.filename}")

    return {
        "message": "上传成功",
        "task_id": task.id
    }
```

---

## 6. 从 BackgroundTasks 迁移到 Celery

### 6.1 迁移步骤

**步骤1：安装 Celery**
```bash
uv add celery redis
```

**步骤2：创建 Celery 应用**
```python
# app/celery_app.py
from celery import Celery

celery_app = Celery(
    'tasks',
    broker='redis://localhost:6379/0',
    backend='redis://localhost:6379/1'
)

celery_app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,
)
```

**步骤3：定义任务**
```python
# app/tasks.py
from app.celery_app import celery_app

@celery_app.task(bind=True, max_retries=3)
def send_email(self, email: str, subject: str, body: str):
    try:
        # 发送邮件逻辑
        pass
    except Exception as e:
        raise self.retry(exc=e, countdown=60)
```

**步骤4：在路由中使用**
```python
# app/main.py
from fastapi import FastAPI
from app.tasks import send_email

app = FastAPI()

@app.post("/register")
async def register(email: str):
    # 提交任务到 Celery
    task = send_email.delay(email, "欢迎", "感谢注册")
    return {
        "message": "注册成功",
        "task_id": task.id
    }
```

**步骤5：启动 Worker**
```bash
celery -A app.celery_app worker --loglevel=info
```

### 6.2 迁移对比

**迁移前（BackgroundTasks）：**
```python
def send_email(email: str):
    # 发送邮件
    pass

@app.post("/register")
async def register(email: str, bg: BackgroundTasks):
    bg.add_task(send_email, email)
    return {"message": "注册成功"}
```

**迁移后（Celery）：**
```python
@celery_app.task
def send_email(email: str):
    # 发送邮件
    pass

@app.post("/register")
async def register(email: str):
    send_email.delay(email)
    return {"message": "注册成功"}
```

**变化：**
- 任务函数添加 `@celery_app.task` 装饰器
- `bg.add_task()` 改为 `task.delay()`
- 需要启动独立的 Worker 进程

---

## 7. 性能和资源对比

### 7.1 资源消耗

| 方案 | 内存 | CPU | 网络 | 存储 |
|------|------|-----|------|------|
| BackgroundTasks | 低 | 低 | 无 | 无 |
| Celery | 中 | 中 | 中（Redis） | 中（Redis） |
| RQ | 中 | 中 | 中（Redis） | 中（Redis） |

### 7.2 吞吐量对比

**场景：** 1000个任务，每个任务耗时1秒

**BackgroundTasks：**
```
单进程顺序执行
总时间：1000秒
吞吐量：1 任务/秒
```

**Celery（4个 Worker）：**
```
4个 Worker 并发执行
总时间：250秒
吞吐量：4 任务/秒
```

**Celery（10个 Worker）：**
```
10个 Worker 并发执行
总时间：100秒
吞吐量：10 任务/秒
```

---

## 8. 在 AI Agent 中的应用

### 8.1 典型场景分类

**使用 BackgroundTasks：**
- 对话日志记录（1秒）
- 用户行为统计（2秒）
- 发送通知（3秒）
- 更新缓存（1秒）

**使用 Celery：**
- 批量文档处理（几分钟）
- 模型微调训练（几小时）
- 定时数据同步（定时任务）
- 大规模 Embedding 生成（几分钟）

### 8.2 实战示例

```python
from fastapi import FastAPI, BackgroundTasks
from app.celery_app import celery_app

app = FastAPI()

# 非关键任务：BackgroundTasks
def log_conversation(user_id: int, message: str):
    # 记录对话
    pass

# 关键任务：Celery
@celery_app.task(bind=True, max_retries=3)
def process_document(self, file_path: str):
    try:
        # 1. 解析文档
        text = extract_text(file_path)

        # 2. 生成 Embedding
        embedding = generate_embedding(text)

        # 3. 存储到向量数据库
        store_to_vectordb(embedding)

        return {"status": "success"}
    except Exception as e:
        raise self.retry(exc=e, countdown=60)

@app.post("/chat")
async def chat(
    user_id: int,
    message: str,
    background_tasks: BackgroundTasks
):
    # 生成回复
    response = generate_response(message)

    # 非关键：记录日志（BackgroundTasks）
    background_tasks.add_task(log_conversation, user_id, message)

    return {"response": response}

@app.post("/upload")
async def upload(file: UploadFile):
    # 保存文件
    file_path = save_file(file)

    # 关键：处理文档（Celery）
    task = process_document.delay(file_path)

    return {
        "message": "上传成功",
        "task_id": task.id
    }

@app.get("/task/{task_id}")
async def get_task_status(task_id: str):
    task = celery_app.AsyncResult(task_id)
    return {
        "status": task.state,
        "result": task.result if task.ready() else None
    }
```

---

## 9. 总结

### 9.1 核心区别

| 维度 | BackgroundTasks | Celery/RQ |
|------|----------------|-----------|
| **架构** | 进程内 | 分布式 |
| **持久化** | 无 | 有 |
| **可靠性** | 低 | 高 |
| **复杂度** | 低 | 高 |
| **适用场景** | 简单任务 | 复杂任务 |

### 9.2 选择建议

**使用 BackgroundTasks 当：**
- ✅ 任务时间 < 30秒
- ✅ 失败可以接受
- ✅ 开发/测试环境
- ✅ 简单项目

**使用 Celery 当：**
- ✅ 任务时间 > 30秒
- ✅ 关键任务，必须成功
- ✅ 需要定时任务
- ✅ 生产环境

**使用 RQ 当：**
- ✅ 介于两者之间
- ✅ 需要持久化但不需要 Celery 的复杂功能
- ✅ 已经使用 Redis

### 9.3 最佳实践

1. **从简单开始**：先用 BackgroundTasks，需要时再迁移
2. **混合使用**：非关键任务用 BackgroundTasks，关键任务用 Celery
3. **监控告警**：无论用哪个，都要有监控和告警
4. **错误处理**：BackgroundTasks 需要手动错误处理，Celery 有内置重试

---

**版本：** v1.0
**最后更新：** 2026-02-11
