# 核心概念：进程管理与信号传递

> 深入理解 Uvicorn/Gunicorn 的信号处理和多进程环境下的优雅关闭

---

## 什么是进程管理？

**进程管理（Process Management）** 是指在多进程环境中，协调主进程和工作进程的启动、运行和关闭。

**核心概念：**
- **主进程（Master Process）**：管理工作进程的生命周期
- **工作进程（Worker Process）**：实际处理请求的进程
- **信号传递（Signal Propagation）**：主进程向工作进程传递信号

**类比：**
- **前端视角**：类似于 PM2 管理多个 Node.js 进程
- **日常视角**：类似于餐厅经理管理多个服务员

---

## Uvicorn 的进程模型

### 1. 单进程模式

**默认模式：** Uvicorn 运行在单进程中

```bash
# 单进程模式
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

**特点：**
- 只有一个进程
- 信号直接发送给该进程
- 优雅关闭简单直接

**信号处理：**
```python
# Uvicorn 内部的信号处理（简化版）
import signal

def handle_exit(sig, frame):
    """处理退出信号"""
    # 1. 停止接收新连接
    server.should_exit = True

    # 2. 等待现有连接完成
    # Uvicorn 会自动等待

signal.signal(signal.SIGTERM, handle_exit)
signal.signal(signal.SIGINT, handle_exit)
```

### 2. 多进程模式

**使用 --workers 参数：**

```bash
# 多进程模式（4个工作进程）
uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4
```

**进程结构：**
```
主进程 (PID 1000)
├── 工作进程 1 (PID 1001)
├── 工作进程 2 (PID 1002)
├── 工作进程 3 (PID 1003)
└── 工作进程 4 (PID 1004)
```

**信号传递流程：**
```
1. 操作系统发送 SIGTERM 到主进程 (PID 1000)
   ↓
2. 主进程捕获信号
   ↓
3. 主进程向所有工作进程发送 SIGTERM
   ↓
4. 工作进程执行优雅关闭
   ↓
5. 主进程等待所有工作进程退出
   ↓
6. 主进程退出
```

---

## Gunicorn 的进程模型

### 1. Gunicorn + Uvicorn Workers

**推荐的生产配置：**

```bash
# 使用 Gunicorn 管理多个 Uvicorn 工作进程
gunicorn app.main:app \
  --workers 4 \
  --worker-class uvicorn.workers.UvicornWorker \
  --bind 0.0.0.0:8000
```

**进程结构：**
```
Gunicorn 主进程 (PID 1000)
├── Uvicorn Worker 1 (PID 1001)
├── Uvicorn Worker 2 (PID 1002)
├── Uvicorn Worker 3 (PID 1003)
└── Uvicorn Worker 4 (PID 1004)
```

### 2. Gunicorn 的信号处理

**Gunicorn 支持的信号：**

| 信号 | 作用 | 优雅关闭 |
|------|------|---------|
| SIGTERM | 优雅关闭 | ✅ 是 |
| SIGINT | 快速关闭 | ❌ 否 |
| SIGQUIT | 优雅关闭 | ✅ 是 |
| SIGHUP | 重新加载配置 | - |
| SIGUSR1 | 重新打开日志文件 | - |
| SIGUSR2 | 优雅重启 | ✅ 是 |

**优雅关闭流程：**
```python
# Gunicorn 主进程的信号处理（简化版）

def handle_term(sig, frame):
    """处理 SIGTERM 信号"""
    # 1. 设置关闭标志
    self.alive = False

    # 2. 向所有工作进程发送 SIGTERM
    for worker in self.workers.values():
        os.kill(worker.pid, signal.SIGTERM)

    # 3. 等待工作进程退出（最多 graceful_timeout 秒）
    timeout = self.cfg.graceful_timeout  # 默认30秒

    # 4. 超时后发送 SIGKILL
    for worker in self.workers.values():
        if worker.is_alive():
            os.kill(worker.pid, signal.SIGKILL)
```

### 3. Gunicorn 配置文件

**gunicorn.conf.py：**

```python
"""
Gunicorn 配置文件
"""

# 工作进程数
workers = 4

# 工作进程类型
worker_class = "uvicorn.workers.UvicornWorker"

# 绑定地址
bind = "0.0.0.0:8000"

# 优雅关闭超时时间（秒）
graceful_timeout = 30

# 工作进程超时时间（秒）
timeout = 120

# 保持连接时间（秒）
keepalive = 5

# 日志配置
accesslog = "-"  # 输出到 stdout
errorlog = "-"   # 输出到 stderr
loglevel = "info"

# 进程名称
proc_name = "myapp"

# 预加载应用（可以减少内存使用）
preload_app = True

# 工作进程重启前的最大请求数（防止内存泄漏）
max_requests = 1000
max_requests_jitter = 50

# 钩子函数
def on_starting(server):
    """服务器启动时"""
    print("Gunicorn 主进程启动")

def on_reload(server):
    """重新加载时"""
    print("Gunicorn 重新加载")

def when_ready(server):
    """服务器就绪时"""
    print("Gunicorn 就绪")

def pre_fork(server, worker):
    """工作进程 fork 前"""
    print(f"工作进程 {worker.pid} 即将启动")

def post_fork(server, worker):
    """工作进程 fork 后"""
    print(f"工作进程 {worker.pid} 已启动")

def pre_exec(server):
    """重新执行前"""
    print("Gunicorn 即将重新执行")

def worker_int(worker):
    """工作进程收到 SIGINT"""
    print(f"工作进程 {worker.pid} 收到 SIGINT")

def worker_abort(worker):
    """工作进程异常终止"""
    print(f"工作进程 {worker.pid} 异常终止")

def worker_exit(server, worker):
    """工作进程退出"""
    print(f"工作进程 {worker.pid} 退出")
```

**使用配置文件：**
```bash
gunicorn app.main:app -c gunicorn.conf.py
```

---

## 多进程环境下的优雅关闭

### 1. 主进程的职责

```python
"""
主进程的优雅关闭逻辑
"""

class MasterProcess:
    def __init__(self):
        self.workers = {}  # 工作进程字典
        self.alive = True  # 运行标志

    def handle_sigterm(self, sig, frame):
        """处理 SIGTERM 信号"""
        print("主进程收到 SIGTERM")

        # 1. 设置关闭标志
        self.alive = False

        # 2. 向所有工作进程发送 SIGTERM
        for pid, worker in self.workers.items():
            print(f"向工作进程 {pid} 发送 SIGTERM")
            os.kill(pid, signal.SIGTERM)

        # 3. 等待工作进程退出
        self.wait_for_workers(timeout=30)

    def wait_for_workers(self, timeout: int):
        """等待工作进程退出"""
        start_time = time.time()

        while self.workers:
            # 检查超时
            if time.time() - start_time > timeout:
                print(f"等待超时，强制终止剩余工作进程")
                for pid in self.workers.keys():
                    os.kill(pid, signal.SIGKILL)
                break

            # 检查工作进程状态
            for pid in list(self.workers.keys()):
                try:
                    # 非阻塞等待
                    wpid, status = os.waitpid(pid, os.WNOHANG)
                    if wpid == pid:
                        print(f"工作进程 {pid} 已退出")
                        del self.workers[pid]
                except ChildProcessError:
                    # 进程已经不存在
                    del self.workers[pid]

            time.sleep(0.1)

        print("所有工作进程已退出")
```

### 2. 工作进程的职责

```python
"""
工作进程的优雅关闭逻辑
"""

class WorkerProcess:
    def __init__(self):
        self.accepting_requests = True
        self.active_requests = 0

    def handle_sigterm(self, sig, frame):
        """处理 SIGTERM 信号"""
        print(f"工作进程 {os.getpid()} 收到 SIGTERM")

        # 1. 停止接收新请求
        self.accepting_requests = False

        # 2. 等待现有请求完成
        self.wait_for_requests()

        # 3. 清理资源
        self.cleanup_resources()

        # 4. 退出
        sys.exit(0)

    def wait_for_requests(self):
        """等待请求完成"""
        while self.active_requests > 0:
            print(f"等待 {self.active_requests} 个请求完成...")
            time.sleep(0.1)

    def cleanup_resources(self):
        """清理资源"""
        # 关闭数据库连接
        # 关闭 Redis 连接
        # 等等
        pass
```

---

## Docker 环境中的信号传递

### 1. 确保 Python 进程是 PID 1

**问题：** 如果使用 shell 形式的 CMD，shell 是 PID 1，Python 进程收不到信号

```dockerfile
# ❌ 错误：shell 是 PID 1
CMD python app.py

# 进程树：
# PID 1: /bin/sh -c python app.py
# PID 2: python app.py
# SIGTERM 发送给 PID 1 (shell)，不会传递给 Python
```

**解决方案1：使用 exec 形式**

```dockerfile
# ✅ 正确：Python 是 PID 1
CMD ["python", "app.py"]

# 进程树：
# PID 1: python app.py
# SIGTERM 直接发送给 Python
```

**解决方案2：使用 exec 替换 shell**

```dockerfile
# ✅ 正确：使用 exec 替换 shell
CMD exec python app.py

# 进程树：
# PID 1: python app.py
```

**解决方案3：使用 tini**

```dockerfile
# ✅ 正确：使用 tini 作为 init 进程
RUN apt-get update && apt-get install -y tini

ENTRYPOINT ["/usr/bin/tini", "--"]
CMD ["python", "app.py"]

# 进程树：
# PID 1: tini
# PID 2: python app.py
# tini 会正确传递信号
```

### 2. Gunicorn 在 Docker 中

```dockerfile
FROM python:3.13-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

# 使用 exec 形式，确保 Gunicorn 是 PID 1
CMD ["gunicorn", "app.main:app", \
     "--workers", "4", \
     "--worker-class", "uvicorn.workers.UvicornWorker", \
     "--bind", "0.0.0.0:8000", \
     "--graceful-timeout", "30"]
```

**测试信号传递：**
```bash
# 启动容器
docker run -d --name myapp myapp:latest

# 查看进程树
docker exec myapp ps aux

# 发送 SIGTERM
docker stop myapp  # 默认等待10秒

# 查看日志
docker logs myapp
```

---

## Kubernetes 环境中的信号传递

### 1. Pod 删除流程

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  terminationGracePeriodSeconds: 60  # 优雅关闭超时
  containers:
  - name: app
    image: myapp:latest
    lifecycle:
      preStop:
        exec:
          command: ["/bin/sh", "-c", "sleep 5"]
```

**删除流程：**
```
1. kubectl delete pod myapp
   ↓
2. Pod 状态变为 Terminating
   ↓
3. 执行 preStop 钩子（5秒）
   ↓
4. 向容器的 PID 1 发送 SIGTERM
   ↓
5. 等待 terminationGracePeriodSeconds（60秒）
   ↓
6. 如果容器还在运行，发送 SIGKILL
```

### 2. 与健康检查的配合

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  terminationGracePeriodSeconds: 60
  containers:
  - name: app
    image: myapp:latest
    ports:
    - containerPort: 8000
    livenessProbe:
      httpGet:
        path: /health
        port: 8000
      initialDelaySeconds: 10
      periodSeconds: 10
    readinessProbe:
      httpGet:
        path: /ready
        port: 8000
      initialDelaySeconds: 5
      periodSeconds: 5
    lifecycle:
      preStop:
        exec:
          # 给5秒时间让 readiness 探测失败
          # 这样负载均衡器会停止发送新请求
          command: ["/bin/sh", "-c", "sleep 5"]
```

**优雅关闭流程：**
```
1. kubectl delete pod myapp
   ↓
2. Pod 状态变为 Terminating
   ↓
3. readiness 探测失败，从 Service 中移除
   ↓
4. 执行 preStop 钩子（sleep 5）
   ↓
5. 向容器发送 SIGTERM
   ↓
6. 应用执行优雅关闭
   ↓
7. 等待 terminationGracePeriodSeconds
```

---

## 完整示例：生产级进程管理

```python
"""
生产级进程管理实现
演示：主进程和工作进程的协调
"""

import os
import sys
import signal
import time
import multiprocessing
from typing import Dict

class WorkerProcess:
    """工作进程"""

    def __init__(self, worker_id: int):
        self.worker_id = worker_id
        self.accepting_requests = True
        self.active_requests = 0

    def run(self):
        """运行工作进程"""
        # 注册信号处理器
        signal.signal(signal.SIGTERM, self.handle_sigterm)
        signal.signal(signal.SIGINT, self.handle_sigterm)

        print(f"工作进程 {self.worker_id} (PID {os.getpid()}) 启动")

        # 模拟处理请求
        while self.accepting_requests:
            # 处理请求...
            time.sleep(1)

        print(f"工作进程 {self.worker_id} 退出")

    def handle_sigterm(self, sig, frame):
        """处理 SIGTERM 信号"""
        print(f"工作进程 {self.worker_id} 收到信号 {sig}")

        # 停止接收新请求
        self.accepting_requests = False

        # 等待现有请求完成
        while self.active_requests > 0:
            time.sleep(0.1)

        # 退出
        sys.exit(0)

class MasterProcess:
    """主进程"""

    def __init__(self, num_workers: int = 4):
        self.num_workers = num_workers
        self.workers: Dict[int, multiprocessing.Process] = {}
        self.alive = True

    def run(self):
        """运行主进程"""
        # 注册信号处理器
        signal.signal(signal.SIGTERM, self.handle_sigterm)
        signal.signal(signal.SIGINT, self.handle_sigterm)

        print(f"主进程 (PID {os.getpid()}) 启动")

        # 启动工作进程
        self.spawn_workers()

        # 主循环
        while self.alive:
            # 检查工作进程状态
            self.manage_workers()
            time.sleep(1)

        print("主进程退出")

    def spawn_workers(self):
        """启动工作进程"""
        for i in range(self.num_workers):
            self.spawn_worker(i)

    def spawn_worker(self, worker_id: int):
        """启动单个工作进程"""
        worker = WorkerProcess(worker_id)
        process = multiprocessing.Process(
            target=worker.run,
            name=f"worker-{worker_id}"
        )
        process.start()

        self.workers[process.pid] = process
        print(f"启动工作进程 {worker_id} (PID {process.pid})")

    def manage_workers(self):
        """管理工作进程"""
        # 检查工作进程是否存活
        for pid, process in list(self.workers.items()):
            if not process.is_alive():
                print(f"工作进程 {pid} 已退出")
                del self.workers[pid]

                # 如果还在运行，重启工作进程
                if self.alive:
                    self.spawn_worker(len(self.workers))

    def handle_sigterm(self, sig, frame):
        """处理 SIGTERM 信号"""
        print(f"主进程收到信号 {sig}")

        # 设置关闭标志
        self.alive = False

        # 向所有工作进程发送 SIGTERM
        for pid, process in self.workers.items():
            print(f"向工作进程 {pid} 发送 SIGTERM")
            os.kill(pid, signal.SIGTERM)

        # 等待工作进程退出
        self.wait_for_workers(timeout=30)

    def wait_for_workers(self, timeout: int):
        """等待工作进程退出"""
        start_time = time.time()

        while self.workers:
            # 检查超时
            if time.time() - start_time > timeout:
                print("等待超时，强制终止剩余工作进程")
                for pid in self.workers.keys():
                    os.kill(pid, signal.SIGKILL)
                break

            # 等待工作进程退出
            for pid, process in list(self.workers.items()):
                process.join(timeout=0.1)
                if not process.is_alive():
                    print(f"工作进程 {pid} 已退出")
                    del self.workers[pid]

        print("所有工作进程已退出")

# ===== 使用示例 =====
if __name__ == "__main__":
    master = MasterProcess(num_workers=4)
    master.run()
```

---

## 总结

### 核心要点

1. **Uvicorn 进程模型**：
   - 单进程：信号直接处理
   - 多进程：主进程协调工作进程

2. **Gunicorn 进程管理**：
   - 主进程管理工作进程生命周期
   - 支持多种信号（SIGTERM、SIGQUIT、SIGUSR2）
   - 配置 graceful_timeout 控制超时

3. **Docker 环境**：
   - 确保 Python 进程是 PID 1
   - 使用 exec 形式或 tini

4. **Kubernetes 环境**：
   - 配置 terminationGracePeriodSeconds
   - 使用 preStop 钩子
   - 与健康检查配合

### 检查清单

- [ ] 理解主进程和工作进程的职责
- [ ] 配置 Gunicorn graceful_timeout
- [ ] 确保 Docker 中 Python 是 PID 1
- [ ] 配置 Kubernetes terminationGracePeriodSeconds
- [ ] 实现 preStop 钩子
- [ ] 测试信号传递流程
- [ ] 监控工作进程状态

---

**下一步**：学习 **03_核心概念_08_连接池优雅关闭.md**，了解如何正确关闭 SQLAlchemy 和 Redis 连接池。
