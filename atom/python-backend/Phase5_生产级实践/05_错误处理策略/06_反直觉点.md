# 错误处理策略 - 反直觉点

## 误区1：所有错误都应该重试 ❌

**错误观点：**
"为了提高可靠性，所有错误都应该自动重试"

**为什么错？**

并非所有错误都是临时性的，有些错误是永久性的：

```python
# ❌ 错误示例：盲目重试所有错误
@retry(stop=stop_after_attempt(3))
async def call_api(user_id: int):
    user = await db.get_user(user_id)
    if user is None:
        raise ValueError("用户不存在")  # 永久性错误，重试无意义
    return user

# 用户不存在 → 重试 3 次 → 浪费 7 秒 → 还是失败
```

**正确理解：**

错误分为两类：
- **临时性错误**（可重试）：网络抖动、Rate Limit、服务过载
- **永久性错误**（不可重试）：参数错误、认证失败、资源不存在

```python
# ✅ 正确示例：只重试临时性错误
class RetryableError(Exception):
    """可重试的错误"""
    pass

class NonRetryableError(Exception):
    """不可重试的错误"""
    pass

def should_retry(error: Exception) -> bool:
    """判断是否应该重试"""
    # 明确标记的错误
    if isinstance(error, RetryableError):
        return True
    if isinstance(error, NonRetryableError):
        return False

    # 根据 HTTP 状态码判断
    if hasattr(error, 'status_code'):
        # 可重试：429（Rate Limit）、500（服务器错误）、503（服务不可用）、504（网关超时）
        return error.status_code in [429, 500, 502, 503, 504]

    return False

@retry(
    stop=stop_after_attempt(3),
    retry=retry_if_exception(should_retry)  # 只重试临时性错误
)
async def call_api(user_id: int):
    user = await db.get_user(user_id)
    if user is None:
        raise NonRetryableError("用户不存在")  # 不会重试
    return user
```

**为什么人们容易这样错？**

因为"重试"听起来很安全，感觉"多试几次总没坏处"。但实际上：
- 重试永久性错误 → 浪费资源（CPU、内存、网络）
- 重试加剧负载 → 可能导致雪崩
- 用户等待时间过长 → 糟糕的用户体验

**类比：**
- ❌ 错误：钥匙丢了，在门口重试开门 3 次
- ✅ 正确：钥匙丢了，立即去配钥匙

---

## 误区2：重试次数越多越好 ❌

**错误观点：**
"重试 10 次比重试 3 次更可靠"

**为什么错？**

重试次数过多会导致：
1. **用户等待时间过长**：指数退避 10 次 = 1023 秒 ≈ 17 分钟
2. **资源浪费**：大量请求堆积，占用连接池
3. **雪崩效应**：所有客户端同时重试，加剧服务负载

```python
# ❌ 错误示例：重试 10 次
@retry(
    stop=stop_after_attempt(10),
    wait=wait_exponential(multiplier=1, min=1, max=60)
)
async def call_llm(prompt: str):
    return await openai.chat.completions.create(...)

# 重试间隔：1s, 2s, 4s, 8s, 16s, 32s, 60s, 60s, 60s, 60s
# 总等待时间：1 + 2 + 4 + 8 + 16 + 32 + 60*4 = 303 秒 ≈ 5 分钟
# 用户：我只是问个问题，为什么要等 5 分钟？
```

**正确理解：**

**最佳实践：3 次重试**

```python
# ✅ 正确示例：重试 3 次（指数退避）
@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10)
)
async def call_llm(prompt: str):
    return await openai.chat.completions.create(...)

# 重试间隔：1s, 2s, 4s
# 总等待时间：7 秒
# 恢复概率：87.5%（假设每次成功率 50%）
```

**为什么是 3 次？**

数学推导：
- 假设临时故障的恢复概率是 50%
- 重试 1 次：成功率 = 1 - 0.5^2 = 75%
- 重试 2 次：成功率 = 1 - 0.5^3 = 87.5%
- 重试 3 次：成功率 = 1 - 0.5^4 = 93.75%
- 重试 10 次：成功率 = 1 - 0.5^11 = 99.95%

**权衡：**
- 3 次重试：87.5% 成功率，7 秒等待时间 ✅
- 10 次重试：99.95% 成功率，303 秒等待时间 ❌

**为什么人们容易这样错？**

因为直觉上"重试越多越安全"，但忽略了：
- 用户体验：等待时间过长
- 资源消耗：连接池、内存、CPU
- 雪崩风险：大量重试加剧负载

**类比：**
- ❌ 错误：电话占线，重拨 10 次（等 17 分钟）
- ✅ 正确：电话占线，重拨 3 次（等 7 秒），然后发短信

---

## 误区3：熔断器会导致服务不可用 ❌

**错误观点：**
"熔断器会拒绝请求，导致服务不可用，不如不用"

**为什么错？**

熔断器的目的是**防止雪崩**，而非"拒绝服务"。

**没有熔断器的后果：**
```python
# ❌ 没有熔断器
async def call_llm(prompt: str):
    # LLM 服务已经挂了，但还在不断重试
    return await retry_with_backoff(
        _call_llm_internal,
        max_attempts=3,
        prompt=prompt
    )

# 场景：LLM 服务挂了
# 1. 用户 A 请求 → 重试 3 次 → 失败（等待 7 秒）
# 2. 用户 B 请求 → 重试 3 次 → 失败（等待 7 秒）
# 3. 用户 C 请求 → 重试 3 次 → 失败（等待 7 秒）
# ...
# 100 个用户 → 300 次重试 → 加剧 LLM 服务负载 → 雪崩
```

**有熔断器的结果：**
```python
# ✅ 有熔断器
llm_breaker = CircuitBreaker(failure_threshold=0.5, timeout=30)

async def call_llm(prompt: str):
    return await llm_breaker.call(
        retry_with_backoff,
        max_attempts=3,
        func=_call_llm_internal,
        prompt=prompt
    )

# 场景：LLM 服务挂了
# 1. 用户 A 请求 → 重试 3 次 → 失败（等待 7 秒）
# 2. 用户 B 请求 → 重试 3 次 → 失败（等待 7 秒）
# 3. 熔断器打开（失败率 > 50%）
# 4. 用户 C 请求 → 立即返回错误（等待 0 秒）
# 5. 用户 D 请求 → 立即返回错误（等待 0 秒）
# ...
# 30 秒后，熔断器进入半开状态，尝试恢复
```

**熔断器的价值：**
1. **快速失败**：服务已经挂了，不要浪费资源重试
2. **防止雪崩**：减少对故障服务的请求，给它恢复的机会
3. **用户体验**：立即返回错误，而非等待 7 秒

**正确理解：**

熔断器不是"拒绝服务"，而是"保护服务"：

```python
class CircuitBreaker:
    """熔断器（带降级策略）"""
    def __init__(
        self,
        failure_threshold: float = 0.5,
        timeout: int = 30,
        fallback=None  # 降级策略
    ):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.fallback = fallback
        self.state = "closed"
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None

    async def call(self, func, *args, **kwargs):
        if self.state == "open":
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "half_open"
            else:
                # 熔断状态：返回降级响应
                if self.fallback:
                    return await self.fallback(*args, **kwargs)
                raise CircuitBreakerOpenError("服务暂时不可用")

        try:
            result = await func(*args, **kwargs)
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise

# 使用示例：带降级策略
async def fallback_response(prompt: str):
    """降级响应：返回缓存或默认回复"""
    cached = await get_cached_response(prompt)
    if cached:
        return cached
    return "抱歉，服务暂时不可用，请稍后重试"

llm_breaker = CircuitBreaker(
    failure_threshold=0.5,
    timeout=30,
    fallback=fallback_response  # 降级策略
)
```

**为什么人们容易这样错？**

因为"熔断"听起来像"断电"，感觉会导致服务不可用。但实际上：
- 没有熔断器：服务已经不可用，还在浪费资源
- 有熔断器：快速失败，保护服务，给它恢复的机会

**类比：**
- ❌ 错误：电路短路，继续供电 → 火灾
- ✅ 正确：电路短路，保险丝熔断 → 保护电路 → 修复后恢复

---

## 误区4：超时时间越长越好 ❌

**错误观点：**
"超时时间设置长一点，避免误杀正常请求"

**为什么错？**

超时时间过长会导致：
1. **用户等待时间过长**：用户体验差
2. **资源泄漏**：连接一直占用，无法释放
3. **级联超时**：上游超时，下游也超时

```python
# ❌ 错误示例：超时时间过长
@app.post("/chat")
async def chat(message: str):
    try:
        # 超时 300 秒（5 分钟）
        async with asyncio.timeout(300):
            response = await call_llm(message)
            return {"response": response}
    except asyncio.TimeoutError:
        raise HTTPException(status_code=504, detail="超时")

# 用户：我只是问个问题，为什么要等 5 分钟？
```

**正确理解：**

**超时时间应该根据服务类型设置：**

| 服务类型 | 推荐超时时间 | 理由 |
|---------|------------|------|
| 数据库查询 | 5-10s | 应该很快 |
| 向量检索 | 10-20s | 取决于数据量 |
| LLM 生成（短文本） | 30s | 生成时间较短 |
| LLM 生成（长文本） | 60s | 生成时间较长 |
| 文档解析 | 30-60s | 取决于文档大小 |

```python
# ✅ 正确示例：根据服务类型设置超时
@app.post("/chat")
async def chat(message: str):
    try:
        # LLM 调用：30 秒超时
        async with asyncio.timeout(30):
            response = await call_llm(message)
            return {"response": response}
    except asyncio.TimeoutError:
        raise HTTPException(
            status_code=504,
            detail="LLM 服务响应超时，请稍后重试"
        )

@app.post("/search")
async def search(query: str):
    try:
        # 向量检索：10 秒超时
        async with asyncio.timeout(10):
            results = await vector_search(query)
            return {"results": results}
    except asyncio.TimeoutError:
        raise HTTPException(
            status_code=504,
            detail="检索超时，请稍后重试"
        )
```

**级联超时：**

上游超时应该比下游超时更长：

```python
# ✅ 正确示例：级联超时
@app.post("/chat")
async def chat(message: str):
    try:
        # 上游超时：35 秒
        async with asyncio.timeout(35):
            # 下游超时：30 秒
            response = await call_llm_with_timeout(message, timeout=30)
            return {"response": response}
    except asyncio.TimeoutError:
        raise HTTPException(status_code=504, detail="请求超时")

async def call_llm_with_timeout(message: str, timeout: float):
    """LLM 调用（带超时）"""
    try:
        async with asyncio.timeout(timeout):
            return await call_llm(message)
    except asyncio.TimeoutError:
        raise LLMTimeoutError(f"LLM 调用超时（{timeout}s）")
```

**为什么人们容易这样错？**

因为担心"超时时间太短会误杀正常请求"，但忽略了：
- 用户体验：等待时间过长
- 资源泄漏：连接一直占用
- 级联超时：上游超时，下游也超时

**类比：**
- ❌ 错误：餐厅等位 5 小时（怕错过座位）
- ✅ 正确：餐厅等位 30 分钟（超时就去其他餐厅）

---

## 误区5：生产环境应该隐藏所有错误信息 ❌

**错误观点：**
"生产环境不应该返回任何错误信息，只返回 '服务器错误'"

**为什么错？**

完全隐藏错误信息会导致：
1. **用户无法修正错误**：不知道哪里错了
2. **开发者无法追踪问题**：没有 Request ID，无法定位
3. **糟糕的用户体验**：用户感到困惑和沮丧

```python
# ❌ 错误示例：完全隐藏错误信息
@app.exception_handler(Exception)
async def global_error_handler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content={"error": "服务器错误"}  # 用户：什么错误？怎么修正？
    )
```

**正确理解：**

**区分用户友好的错误信息和技术细节：**

```python
# ✅ 正确示例：环境感知的错误详情
import os
import traceback
import uuid

@app.exception_handler(Exception)
async def global_error_handler(request: Request, exc: Exception):
    # 生成 Request ID
    request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))

    # 记录详细错误日志（开发者可见）
    logger.error(
        "unhandled_exception",
        request_id=request_id,
        error_type=type(exc).__name__,
        error_message=str(exc),
        path=request.url.path,
        method=request.method,
        stack_trace=traceback.format_exc()
    )

    # 开发环境：返回详细错误（方便调试）
    if os.getenv("ENVIRONMENT") == "development":
        return JSONResponse(
            status_code=500,
            content={
                "error": str(exc),
                "type": type(exc).__name__,
                "traceback": traceback.format_exc(),
                "request_id": request_id
            }
        )

    # 生产环境：返回友好提示 + Request ID（用户可见）
    return JSONResponse(
        status_code=500,
        content={
            "error": "服务器内部错误，请稍后重试",
            "error_code": "INTERNAL_ERROR",
            "request_id": request_id  # 用户可以提供给客服
        }
    )
```

**业务异常应该返回详细信息：**

```python
# ✅ 正确示例：业务异常返回详细信息
class TextTooLongError(Exception):
    """文本过长"""
    def __init__(self, max_length: int, actual_length: int):
        self.max_length = max_length
        self.actual_length = actual_length
        super().__init__(f"文本过长（{actual_length} > {max_length}）")

@app.exception_handler(TextTooLongError)
async def text_too_long_handler(request: Request, exc: TextTooLongError):
    return JSONResponse(
        status_code=422,
        content={
            "error": f"输入文本过长，请缩短至 {exc.max_length} 字以内",
            "error_code": "TEXT_TOO_LONG",
            "max_length": exc.max_length,
            "actual_length": exc.actual_length
        }
    )

# 用户看到：
# {
#   "error": "输入文本过长，请缩短至 2000 字以内",
#   "error_code": "TEXT_TOO_LONG",
#   "max_length": 2000,
#   "actual_length": 3500
# }
# 用户知道：我输入了 3500 字，需要缩短到 2000 字
```

**为什么人们容易这样错？**

因为担心"暴露技术细节会有安全风险"，但忽略了：
- 用户需要知道如何修正错误
- 开发者需要 Request ID 追踪问题
- 业务异常不是安全风险

**类比：**
- ❌ 错误：ATM 机只显示"错误"（用户：什么错误？）
- ✅ 正确：ATM 机显示"余额不足"（用户：哦，我知道了）

---

## 总结

**3 个常见误区：**

1. **所有错误都应该重试** ❌
   - 正确：只重试临时性错误（网络、Rate Limit、服务过载）
   - 永久性错误（参数错误、认证失败）不应该重试

2. **重试次数越多越好** ❌
   - 正确：3 次重试（87.5% 成功率，7 秒等待时间）
   - 10 次重试（99.95% 成功率，303 秒等待时间）用户体验差

3. **熔断器会导致服务不可用** ❌
   - 正确：熔断器防止雪崩，保护服务
   - 快速失败 + 降级策略 = 更好的用户体验

4. **超时时间越长越好** ❌
   - 正确：根据服务类型设置超时（数据库 5-10s，LLM 30-60s）
   - 级联超时：上游超时 > 下游超时

5. **生产环境应该隐藏所有错误信息** ❌
   - 正确：区分用户友好的错误信息和技术细节
   - 业务异常返回详细信息 + Request ID

**核心原则：**
- 区分临时性和永久性错误
- 平衡可靠性和用户体验
- 快速失败优于无限等待
- 用户友好的错误信息 + 开发者友好的日志
