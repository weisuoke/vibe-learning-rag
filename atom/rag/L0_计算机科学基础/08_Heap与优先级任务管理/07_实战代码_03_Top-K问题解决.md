# 实战代码03: Top-K问题解决

## 核心目标

**实现多种Top-K解法,对比性能,应用到RAG文档检索场景。**

---

## 1. 基础实现

```python
import heapq

def top_k_largest_heap(nums, k):
    """
    使用min-heap找Top-K最大值

    时间复杂度: O(n log k)
    空间复杂度: O(k)
    """
    if k <= 0:
        return []
    if k >= len(nums):
        return sorted(nums, reverse=True)

    heap = []

    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)

    return sorted(heap, reverse=True)

def top_k_largest_sort(nums, k):
    """
    使用排序找Top-K最大值

    时间复杂度: O(n log n)
    空间复杂度: O(1)
    """
    nums_copy = nums.copy()
    nums_copy.sort(reverse=True)
    return nums_copy[:k]

# 测试
nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]
print(top_k_largest_heap(nums, 3))  # [9, 6, 5]
print(top_k_largest_sort(nums, 3))  # [9, 6, 5]
```

---

## 2. 流式Top-K

```python
class StreamingTopK:
    """流式Top-K维护"""

    def __init__(self, k):
        self.k = k
        self.heap = []

    def add(self, value):
        """添加新值"""
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, value)
        elif value > self.heap[0]:
            heapq.heapreplace(self.heap, value)

    def get_top_k(self):
        """获取Top-K"""
        return sorted(self.heap, reverse=True)

    def get_threshold(self):
        """获取门槛值"""
        return self.heap[0] if len(self.heap) == self.k else float('-inf')

# 使用示例
stream = StreamingTopK(k=3)
for val in [3, 1, 4, 1, 5, 9, 2, 6]:
    stream.add(val)
    print(f"Added {val}, Top-3: {stream.get_top_k()}, Threshold: {stream.get_threshold()}")
```

---

## 3. RAG文档检索

```python
import numpy as np
import heapq

class RAGTopKRetriever:
    """RAG Top-K文档检索器"""

    def __init__(self, k=10):
        self.k = k

    def retrieve(self, query_emb, doc_embs):
        """
        检索Top-K文档

        Args:
            query_emb: 查询向量 (d,)
            doc_embs: [(doc_id, embedding), ...]

        Returns:
            Top-K文档列表 [(score, doc_id), ...]
        """
        heap = []

        for doc_id, doc_emb in doc_embs:
            score = self.cosine_similarity(query_emb, doc_emb)

            if len(heap) < self.k:
                heapq.heappush(heap, (score, doc_id))
            elif score > heap[0][0]:
                heapq.heapreplace(heap, (score, doc_id))

        return sorted(heap, reverse=True)

    @staticmethod
    def cosine_similarity(a, b):
        """计算余弦相似度"""
        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

# 使用示例
retriever = RAGTopKRetriever(k=5)

# 模拟查询
query_emb = np.random.rand(768)
doc_embs = [(f"doc_{i}", np.random.rand(768)) for i in range(100)]

top_docs = retriever.retrieve(query_emb, doc_embs)
print("Top-5 documents:")
for score, doc_id in top_docs:
    print(f"  {doc_id}: {score:.4f}")
```

---

## 4. 性能对比

```python
import time
import random

def benchmark_top_k(n, k):
    """性能对比测试"""
    nums = [random.randint(1, 1000000) for _ in range(n)]

    # 方法1: 排序
    start = time.time()
    result1 = sorted(nums, reverse=True)[:k]
    time_sort = time.time() - start

    # 方法2: Heap
    start = time.time()
    result2 = heapq.nlargest(k, nums)
    time_heap = time.time() - start

    print(f"n={n}, k={k}:")
    print(f"  排序:    {time_sort:.4f}s")
    print(f"  Heap:    {time_heap:.4f}s")
    print(f"  加速比:  {time_sort/time_heap:.2f}x")

# 测试
benchmark_top_k(n=1000000, k=10)
benchmark_top_k(n=1000000, k=1000)
benchmark_top_k(n=1000000, k=100000)
```

---

## 5. Top-K变种

```python
from collections import Counter

def top_k_frequent(nums, k):
    """Top-K频繁元素"""
    count = Counter(nums)
    heap = []

    for num, freq in count.items():
        if len(heap) < k:
            heapq.heappush(heap, (freq, num))
        elif freq > heap[0][0]:
            heapq.heapreplace(heap, (freq, num))

    return [num for freq, num in sorted(heap, reverse=True)]

def find_kth_largest(nums, k):
    """第K大元素"""
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)

    return heap[0]

# 测试
nums = [1, 1, 1, 2, 2, 3]
print(top_k_frequent(nums, 2))  # [1, 2]

nums = [3, 2, 1, 5, 6, 4]
print(find_kth_largest(nums, 2))  # 5
```

---

## 6. 一句话总结

**Top-K问题使用min-heap维护K个最大值(时间O(n log k)、空间O(k)),优于排序的O(n log n),广泛应用于RAG文档检索、推荐系统和搜索引擎,支持流式处理和多种变种。**
