# 核心概念：多轮对话上下文管理

> Session管理、历史存储与对话状态追踪

---

## 概念定义

### 什么是多轮对话上下文管理？

**多轮对话上下文管理**是指在对话式RAG系统中，为每个用户维护独立的对话会话（Session），存储和管理对话历史，并在生成回答时利用这些历史信息的技术。

**核心要素：**
1. **Session隔离**：不同用户的对话互不干扰
2. **历史存储**：记录每轮对话的问题和回答
3. **上下文获取**：在需要时提取相关的历史信息
4. **状态追踪**：跟踪对话的主题、意图等状态信息

### 为什么对话式RAG需要它？

**问题场景：**
```
用户A: "什么是RAG？"
用户B: "什么是Transformer？"
用户A: "它有什么优势？"  ← 系统需要知道"它"指的是RAG，而不是Transformer
```

如果没有上下文管理：
- ❌ 无法区分不同用户的对话
- ❌ 无法理解"它"指代什么
- ❌ 每次都要重新询问背景信息

有了上下文管理：
- ✅ 每个用户有独立的Session
- ✅ 系统记住了用户A在问RAG
- ✅ 可以连贯地回答追问

### 与单轮RAG的核心区别

| 维度 | 单轮RAG | 多轮对话RAG |
|------|---------|-------------|
| 记忆能力 | 无记忆，每次独立 | 记住历史对话 |
| Session管理 | 不需要 | 必需 |
| 数据结构 | 单个Query | `{session_id: [Message]}` |
| 状态 | 无状态 | 有状态 |
| 复杂度 | 简单 | 中等 |
| 存储需求 | 无 | 需要存储历史 |

---

## 技术原理

### 1. Session管理机制

**Session的本质：**
- Session是一个逻辑概念，代表一次完整的对话会话
- 每个Session有唯一的ID（如`user_123_session_456`）
- Session内包含多轮对话（Question-Answer对）

**Session生命周期：**
```
创建Session → 添加对话 → 添加对话 → ... → 清空/过期
    ↓            ↓           ↓                    ↓
 分配ID      记录Q&A     记录Q&A            释放资源
```

**Session隔离策略：**
```python
# 方案1：基于用户ID
session_id = f"user_{user_id}"  # 每个用户一个Session

# 方案2：基于用户ID + 时间戳
session_id = f"user_{user_id}_{timestamp}"  # 每次新对话一个Session

# 方案3：基于用户ID + 主题
session_id = f"user_{user_id}_topic_{topic}"  # 每个主题一个Session
```

### 2. 对话历史存储结构

**Message数据结构：**
```python
from dataclasses import dataclass
from datetime import datetime
from typing import Literal

@dataclass
class Message:
    role: Literal["user", "assistant", "system"]  # 角色
    content: str                                   # 内容
    timestamp: datetime                            # 时间戳
    metadata: dict = None                          # 元数据（可选）
```

**为什么需要这些字段？**
- `role`：区分是用户问题还是系统回答
- `content`：实际的文本内容
- `timestamp`：用于排序、过期判断
- `metadata`：存储额外信息（如检索到的文档ID、Token数等）

**存储结构：**
```python
# 内存存储（简单场景）
sessions = {
    "user_123": [
        Message(role="user", content="什么是RAG？", timestamp=...),
        Message(role="assistant", content="RAG是...", timestamp=...),
        Message(role="user", content="它有什么优势？", timestamp=...),
        Message(role="assistant", content="RAG的优势...", timestamp=...),
    ],
    "user_456": [...]
}

# 数据库存储（生产环境）
# Table: conversations
# Columns: session_id, role, content, timestamp, metadata
```

### 3. 上下文窗口滑动策略

**问题：** 对话越来越长，不能无限存储所有历史

**解决方案：** 滑动窗口

```python
def get_context(session_id: str, window_size: int = 5):
    """
    获取最近N轮对话作为上下文
    """
    all_messages = sessions[session_id]

    # 只保留最近window_size轮（每轮=1个user+1个assistant）
    recent_messages = all_messages[-(window_size * 2):]

    return recent_messages
```

**滑动窗口示意图：**
```
完整历史：[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10]
                                    ↑
                              window_size=3
                                    ↓
上下文：                        [M5, M6, M7, M8, M9, M10]
                                 ↑___3轮对话___↑
```

**窗口大小选择：**
- 太小（如1-2轮）：丢失重要上下文
- 太大（如20轮）：超过Context Window，成本高
- 推荐：3-5轮（根据实际场景调整）

### 4. 对话状态追踪

**什么是对话状态？**
- 当前讨论的主题
- 用户的意图（询问、确认、反驳等）
- 关键实体（人名、地名、产品名等）

**为什么需要状态追踪？**
```
用户: "我想了解RAG"  ← 状态：主题=RAG，意图=学习
助手: "RAG是检索增强生成..."
用户: "有哪些应用场景？"  ← 状态：主题=RAG应用，意图=询问
助手: "RAG可以用于..."
用户: "第一个场景详细说说"  ← 状态：主题=RAG应用场景1，意图=深入
```

**简单的状态追踪实现：**
```python
@dataclass
class ConversationState:
    session_id: str
    current_topic: str = None      # 当前主题
    mentioned_entities: list = None  # 提到的实体
    user_intent: str = None        # 用户意图

    def update_from_message(self, message: Message):
        """从消息中更新状态"""
        # 简单实现：使用LLM提取
        # 生产环境：使用NER、意图识别模型
        pass
```

---

## 实现方案

### 方案1：简单列表存储（适合短对话）

**适用场景：**
- 对话轮次少（<20轮）
- 单机部署
- 不需要持久化

**实现代码：**
```python
from typing import Dict, List
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Message:
    role: str
    content: str
    timestamp: datetime

class SimpleConversationManager:
    def __init__(self, max_history: int = 20):
        self.sessions: Dict[str, List[Message]] = {}
        self.max_history = max_history

    def add_message(self, session_id: str, role: str, content: str):
        """添加消息到会话"""
        if session_id not in self.sessions:
            self.sessions[session_id] = []

        message = Message(
            role=role,
            content=content,
            timestamp=datetime.now()
        )

        self.sessions[session_id].append(message)

        # 滑动窗口：超过max_history就删除最早的
        if len(self.sessions[session_id]) > self.max_history:
            self.sessions[session_id] = self.sessions[session_id][-self.max_history:]

    def get_context(self, session_id: str, last_n: int = 5) -> List[Message]:
        """获取最近N轮对话"""
        if session_id not in self.sessions:
            return []

        # 每轮=2条消息（user+assistant），所以取last_n*2条
        return self.sessions[session_id][-(last_n * 2):]

    def clear_session(self, session_id: str):
        """清空会话"""
        if session_id in self.sessions:
            del self.sessions[session_id]
```

**优点：**
- ✅ 实现简单，代码少
- ✅ 性能高（内存操作）
- ✅ 无需额外依赖

**缺点：**
- ❌ 重启后数据丢失
- ❌ 无法跨机器共享
- ❌ 内存占用随用户数增长

---

### 方案2：数据库持久化（适合长期会话）

**适用场景：**
- 需要持久化存储
- 多机部署
- 对话轮次多

**数据库表设计：**
```sql
CREATE TABLE conversations (
    id SERIAL PRIMARY KEY,
    session_id VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL,
    content TEXT NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB,
    INDEX idx_session_timestamp (session_id, timestamp)
);
```

**实现代码：**
```python
import psycopg2
from typing import List

class DatabaseConversationManager:
    def __init__(self, db_config: dict):
        self.conn = psycopg2.connect(**db_config)

    def add_message(self, session_id: str, role: str, content: str):
        """添加消息到数据库"""
        with self.conn.cursor() as cur:
            cur.execute(
                """
                INSERT INTO conversations (session_id, role, content)
                VALUES (%s, %s, %s)
                """,
                (session_id, role, content)
            )
        self.conn.commit()

    def get_context(self, session_id: str, last_n: int = 5) -> List[Message]:
        """从数据库获取最近N轮对话"""
        with self.conn.cursor() as cur:
            cur.execute(
                """
                SELECT role, content, timestamp
                FROM conversations
                WHERE session_id = %s
                ORDER BY timestamp DESC
                LIMIT %s
                """,
                (session_id, last_n * 2)
            )

            rows = cur.fetchall()
            messages = [
                Message(role=row[0], content=row[1], timestamp=row[2])
                for row in reversed(rows)  # 反转回时间顺序
            ]

            return messages

    def clear_session(self, session_id: str):
        """删除会话"""
        with self.conn.cursor() as cur:
            cur.execute(
                "DELETE FROM conversations WHERE session_id = %s",
                (session_id,)
            )
        self.conn.commit()
```

**优点：**
- ✅ 数据持久化
- ✅ 支持多机部署
- ✅ 可以查询历史对话

**缺点：**
- ❌ 需要数据库依赖
- ❌ 性能略低于内存
- ❌ 需要维护数据库

---

### 方案3：混合策略（内存+持久化）

**适用场景：**
- 需要高性能
- 也需要持久化
- 生产环境推荐

**设计思路：**
- 热数据（最近N轮）存内存
- 冷数据（更早的历史）存数据库
- 定期同步内存到数据库

**实现代码：**
```python
class HybridConversationManager:
    def __init__(self, db_config: dict, cache_size: int = 10):
        self.db_manager = DatabaseConversationManager(db_config)
        self.cache: Dict[str, List[Message]] = {}
        self.cache_size = cache_size

    def add_message(self, session_id: str, role: str, content: str):
        """添加消息（先写缓存，异步写数据库）"""
        message = Message(role=role, content=content, timestamp=datetime.now())

        # 写缓存
        if session_id not in self.cache:
            self.cache[session_id] = []
        self.cache[session_id].append(message)

        # 缓存满了就写数据库
        if len(self.cache[session_id]) > self.cache_size:
            self._flush_to_db(session_id)

        # 异步写数据库（生产环境使用消息队列）
        self.db_manager.add_message(session_id, role, content)

    def get_context(self, session_id: str, last_n: int = 5) -> List[Message]:
        """获取上下文（优先从缓存）"""
        # 先从缓存获取
        cached = self.cache.get(session_id, [])

        if len(cached) >= last_n * 2:
            return cached[-(last_n * 2):]

        # 缓存不够，从数据库补充
        db_messages = self.db_manager.get_context(session_id, last_n)
        return db_messages

    def _flush_to_db(self, session_id: str):
        """将缓存刷到数据库"""
        # 保留最近cache_size条在缓存
        self.cache[session_id] = self.cache[session_id][-self.cache_size:]
```

**优点：**
- ✅ 读写性能高（缓存）
- ✅ 数据不丢失（持久化）
- ✅ 兼顾性能和可靠性

**缺点：**
- ❌ 实现复杂
- ❌ 需要处理缓存一致性

---

## RAG应用场景

### 场景1：智能客服机器人

**需求：** 记住用户的订单号、问题类型，避免重复询问

**对话示例：**
```
用户: "我的订单什么时候发货？"
客服: "请提供您的订单号"
用户: "12345"  ← 上下文管理记住了在问订单
客服: "订单12345预计明天发货"
用户: "能加急吗？"  ← 上下文管理知道是在问订单12345
客服: "可以，加急后今天发货，需要额外支付10元"
用户: "好的，加急"  ← 上下文管理知道是确认加急订单12345
客服: "已为您的订单12345开启加急服务"
```

**实现要点：**
```python
# 提取关键实体并存储到状态
state = ConversationState(
    session_id="user_123",
    current_topic="订单查询",
    mentioned_entities={"order_id": "12345"},
    user_intent="加急配送"
)

# 在生成回答时注入状态
prompt = f"""
用户正在咨询订单{state.mentioned_entities['order_id']}的配送问题。
用户意图：{state.user_intent}
请基于以下信息回答...
"""
```

---

### 场景2：文档问答助手

**需求：** 追踪讨论的文档章节，理解上下文

**对话示例：**
```
用户: "RAG的检索模块是怎么工作的？"
助手: "检索模块使用向量相似度匹配..."  ← 记住主题=RAG检索
用户: "它支持哪些向量数据库？"  ← "它"=检索模块
助手: "支持ChromaDB、Faiss、Milvus..."
用户: "第一个怎么安装？"  ← "第一个"=ChromaDB
助手: "ChromaDB安装：pip install chromadb"
```

**实现要点：**
```python
# 使用上下文管理追踪讨论主题
def chat(session_id: str, query: str):
    # 1. 获取历史
    history = manager.get_context(session_id, last_n=3)

    # 2. 提取当前主题
    if history:
        topic = extract_topic(history)  # "RAG检索模块"

    # 3. 在检索时使用主题信息
    search_query = f"{topic} {query}"  # "RAG检索模块 支持哪些向量数据库"

    # 4. 检索和生成...
```

---

### 场景3：代码助手

**需求：** 记住之前的代码修改上下文

**对话示例：**
```
用户: "帮我写一个FastAPI的用户注册接口"
助手: [生成代码]  ← 记住了在写FastAPI接口
用户: "加上邮箱验证"  ← 上下文：在修改用户注册接口
助手: [修改代码，添加邮箱验证]
用户: "再加上密码强度检查"  ← 上下文：继续修改同一个接口
助手: [继续修改代码]
```

**实现要点：**
```python
# 在状态中记录代码上下文
state = ConversationState(
    session_id="user_123",
    current_topic="FastAPI用户注册接口",
    mentioned_entities={
        "code_file": "api/users.py",
        "function": "register_user",
        "modifications": ["邮箱验证", "密码强度检查"]
    }
)

# 在生成代码时使用上下文
prompt = f"""
你正在修改{state.mentioned_entities['function']}函数。
已完成的修改：{state.mentioned_entities['modifications']}
现在需要：{query}
"""
```

---

## 在RAG开发中的应用

### 完整的对话式RAG流程

```python
def conversational_rag(session_id: str, user_query: str) -> str:
    # 1. 获取对话历史
    history = conversation_manager.get_context(session_id, last_n=5)

    # 2. 指代消解（下一个核心概念会详细讲）
    if history:
        resolved_query = resolve_coreference(user_query, history)
    else:
        resolved_query = user_query

    # 3. 向量检索
    docs = vector_store.search(resolved_query, top_k=3)

    # 4. 构建Prompt（注入历史）
    history_text = "\n".join([f"{m.role}: {m.content}" for m in history[-3:]])

    prompt = f"""
    对话历史:
    {history_text}

    参考文档:
    {docs}

    用户问题: {user_query}

    请基于对话历史和参考文档回答问题。
    """

    # 5. LLM生成
    answer = llm.generate(prompt)

    # 6. 保存到历史
    conversation_manager.add_message(session_id, "user", user_query)
    conversation_manager.add_message(session_id, "assistant", answer)

    return answer
```

---

## 总结

**多轮对话上下文管理的核心：**
1. **Session隔离**：每个用户独立的对话空间
2. **历史存储**：结构化存储对话记录
3. **滑动窗口**：控制上下文长度
4. **状态追踪**：记录主题、实体、意图

**三种实现方案：**
- 简单列表：适合原型和小规模
- 数据库持久化：适合生产环境
- 混合策略：性能和可靠性兼顾

**下一步学习：**
- `04_核心概念_历史压缩.md` - 如何在Context Window限制下保留关键信息
- `05_核心概念_指代消解.md` - 如何理解"它"、"这个"等指代词
