# 最小可用知识

> 掌握以下内容，就能开始使用 FastAPI 的路由与依赖注入

---

## 4.1 定义基础路由

**核心：** 用装饰器定义 API 端点

```python
from fastapi import FastAPI

app = FastAPI()

# GET 请求 - 获取数据
@app.get("/")
async def root():
    return {"message": "Hello World"}

# POST 请求 - 创建数据
@app.post("/items")
async def create_item(name: str, price: float):
    return {"name": name, "price": price}

# 路径参数 - 动态路由
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}

# 查询参数 - URL 参数
@app.get("/search")
async def search(q: str, limit: int = 10):
    return {"query": q, "limit": limit}
```

**前端类比：**
```javascript
// Express
app.get('/users/:userId', (req, res) => {
  res.json({ userId: req.params.userId })
})

// FastAPI - 自动解析和验证
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}
```

---

## 4.2 使用 Pydantic 模型验证请求体

**核心：** 用 Pydantic 模型自动验证和解析 JSON 请求体

```python
from pydantic import BaseModel, Field

class CreateUserRequest(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: str
    age: int = Field(..., ge=0, le=150)

@app.post("/users")
async def create_user(user: CreateUserRequest):
    # user 已经被验证和解析
    return {"username": user.username, "email": user.email}
```

**自动验证：**
- ✅ 类型检查（username 必须是字符串）
- ✅ 长度限制（username 3-50 字符）
- ✅ 范围限制（age 0-150）
- ❌ 验证失败自动返回 422 错误

**前端类比：**
```typescript
// TypeScript interface（只是类型提示）
interface CreateUserRequest {
  username: string;
  email: string;
  age: number;
}

// FastAPI Pydantic（运行时验证）
class CreateUserRequest(BaseModel):
    username: str
    email: str
    age: int
```

---

## 4.3 基础依赖注入

**核心：** 用 `Depends()` 注入可复用的依赖

```python
from fastapi import Depends

# 定义依赖函数
def get_current_user(token: str):
    # 验证 token，返回用户信息
    if token != "valid-token":
        raise HTTPException(status_code=401, detail="Invalid token")
    return {"user_id": 1, "username": "alice"}

# 使用依赖
@app.get("/profile")
async def get_profile(user: dict = Depends(get_current_user)):
    # user 已经被注入
    return {"profile": user}
```

**依赖链：**
```python
# 依赖1：获取数据库连接
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 依赖2：获取当前用户（依赖于 get_db）
def get_current_user(db: Session = Depends(get_db)):
    # 使用 db 查询用户
    return db.query(User).first()

# 路由：使用依赖链
@app.get("/profile")
async def get_profile(user: User = Depends(get_current_user)):
    return {"username": user.username}
```

**前端类比：**
```javascript
// Express 中间件
app.get('/profile', authMiddleware, (req, res) => {
  // req.user 由中间件设置
  res.json({ profile: req.user })
})

// FastAPI 依赖注入
@app.get("/profile")
async def get_profile(user: dict = Depends(get_current_user)):
    return {"profile": user}
```

---

## 4.4 定义响应模型

**核心：** 用 `response_model` 定义响应格式

```python
class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    # 不包含 password

class User(BaseModel):
    id: int
    username: str
    email: str
    password: str  # 敏感信息

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    # 返回完整的 User 对象
    user = User(
        id=user_id,
        username="alice",
        email="alice@example.com",
        password="secret123"  # 不会被返回
    )
    # FastAPI 自动过滤，只返回 UserResponse 定义的字段
    return user
```

**自动过滤：**
- ✅ 只返回 `response_model` 定义的字段
- ✅ 自动验证响应数据
- ✅ 生成 OpenAPI 文档

---

## 4.5 组合使用：完整的 CRUD API

```python
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel
from typing import List

app = FastAPI()

# 模拟数据库
fake_db = {}
next_id = 1

# 请求模型
class CreateItemRequest(BaseModel):
    name: str
    price: float

# 响应模型
class ItemResponse(BaseModel):
    id: int
    name: str
    price: float

# 依赖：验证 item 是否存在
def get_item_or_404(item_id: int):
    if item_id not in fake_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return fake_db[item_id]

# CREATE - 创建
@app.post("/items", response_model=ItemResponse, status_code=201)
async def create_item(item: CreateItemRequest):
    global next_id
    new_item = ItemResponse(id=next_id, name=item.name, price=item.price)
    fake_db[next_id] = new_item
    next_id += 1
    return new_item

# READ - 读取单个
@app.get("/items/{item_id}", response_model=ItemResponse)
async def get_item(item: ItemResponse = Depends(get_item_or_404)):
    return item

# READ - 读取列表
@app.get("/items", response_model=List[ItemResponse])
async def list_items():
    return list(fake_db.values())

# UPDATE - 更新
@app.put("/items/{item_id}", response_model=ItemResponse)
async def update_item(
    item_id: int,
    update: CreateItemRequest,
    existing_item: ItemResponse = Depends(get_item_or_404)
):
    updated_item = ItemResponse(id=item_id, name=update.name, price=update.price)
    fake_db[item_id] = updated_item
    return updated_item

# DELETE - 删除
@app.delete("/items/{item_id}", status_code=204)
async def delete_item(item_id: int, item: ItemResponse = Depends(get_item_or_404)):
    del fake_db[item_id]
    return None
```

**运行：**
```bash
# 安装依赖
uv add fastapi uvicorn

# 运行服务器
uvicorn main:app --reload

# 测试 API
curl -X POST http://localhost:8000/items \
  -H "Content-Type: application/json" \
  -d '{"name": "Book", "price": 29.99}'

curl http://localhost:8000/items/1
```

---

## 这些知识足以

完成以上学习后，你可以：

- ✅ **定义 RESTful API** - GET/POST/PUT/DELETE 路由
- ✅ **自动验证请求** - 用 Pydantic 模型验证请求体
- ✅ **复用依赖逻辑** - 用 Depends() 注入数据库连接、认证等
- ✅ **控制响应格式** - 用 response_model 过滤敏感信息
- ✅ **构建 CRUD API** - 完整的增删改查接口

---

## 与 Express 的对比总结

| 功能 | Express | FastAPI |
|------|---------|---------|
| 路由定义 | `app.get('/path', handler)` | `@app.get("/path")` |
| 参数解析 | 手动 `req.params`、`req.query` | 自动解析到函数参数 |
| 请求体验证 | express-validator | Pydantic 自动验证 |
| 依赖注入 | 中间件 `app.use()` | `Depends()` |
| 响应过滤 | 手动 `delete user.password` | `response_model` 自动过滤 |
| 类型安全 | TypeScript（编译时） | Python 类型注解（运行时） |

---

## 下一步学习

掌握最小可用知识后，可以深入学习：

1. **核心概念** - 路由系统、依赖注入、响应模型的深入原理
2. **实战代码** - 数据库集成、认证授权、AI Agent API
3. **进阶技巧** - 依赖缓存、子依赖、依赖覆盖

---

**记住：** 20% 的核心知识解决 80% 的问题，先掌握这些基础，再逐步深入！
