# 核心概念03：NFA非确定性有限自动机

> **定义**：NFA（Nondeterministic Finite Automaton）是允许多个转移和ε-转移的有限状态自动机

---

## 一、形式化定义

### 1.1 NFA的五元组

```
M = (Q, Σ, δ, q0, F)

其中：
- Q：有限状态集合
- Σ：有限输入字母表
- δ：状态转移函数 δ: Q × (Σ ∪ {ε}) → P(Q)（非确定性）
- q0：初始状态，q0 ∈ Q
- F：接受状态集合，F ⊆ Q
```

**关键特征**：
- **非确定性**：δ(q, a) = {q1, q2, ...}（可能多个转移）
- **ε-转移**：允许不消耗输入的转移
- **幂集**：转移函数返回状态集合的幂集P(Q)

---

### 1.2 NFA vs DFA

| 特性 | NFA | DFA |
|------|-----|-----|
| **转移函数** | δ: Q × (Σ ∪ {ε}) → P(Q) | δ: Q × Σ → Q |
| **确定性** | 可能多个转移 | 唯一转移 |
| **ε-转移** | 允许 | 不允许 |
| **设计难度** | 简单直观 | 复杂 |
| **状态数** | 通常较少 | 可能很多 |
| **执行效率** | O(n × 2^m) | O(n) |
| **实现难度** | 复杂（回溯） | 简单（查表） |

---

## 二、Python实现

### 2.1 完整NFA类

```python
from typing import Set, Dict, Tuple, FrozenSet
from dataclasses import dataclass

@dataclass
class NFA:
    """非确定性有限自动机"""
    states: Set[str]
    alphabet: Set[str]
    transitions: Dict[Tuple[str, str], Set[str]]  # 返回状态集合
    initial_state: str
    accept_states: Set[str]

    def epsilon_closure(self, states: Set[str]) -> Set[str]:
        """
        计算ε-闭包：从给定状态集合通过ε-转移可达的所有状态

        算法：
        1. 初始化闭包为输入状态集合
        2. 迭代添加通过ε-转移可达的状态
        3. 直到闭包不再增长
        """
        closure = set(states)
        stack = list(states)

        while stack:
            state = stack.pop()
            # 查找ε-转移
            epsilon_transitions = self.transitions.get((state, 'ε'), set())
            for next_state in epsilon_transitions:
                if next_state not in closure:
                    closure.add(next_state)
                    stack.append(next_state)

        return closure

    def move(self, states: Set[str], symbol: str) -> Set[str]:
        """
        计算move操作：从状态集合读取符号后可达的状态集合

        Args:
            states: 当前状态集合
            symbol: 输入符号

        Returns:
            读取符号后可达的状态集合
        """
        result = set()
        for state in states:
            next_states = self.transitions.get((state, symbol), set())
            result.update(next_states)
        return result

    def accepts(self, input_string: str) -> bool:
        """
        判断NFA是否接受输入字符串

        算法：
        1. 从初始状态的ε-闭包开始
        2. 对每个输入符号：
           a. 计算move操作
           b. 计算ε-闭包
        3. 检查最终状态集合是否包含接受状态
        """
        # 初始状态的ε-闭包
        current_states = self.epsilon_closure({self.initial_state})

        for symbol in input_string:
            if symbol not in self.alphabet:
                raise ValueError(f"Invalid symbol: {symbol}")

            # move + ε-closure
            current_states = self.move(current_states, symbol)
            current_states = self.epsilon_closure(current_states)

        # 检查是否有接受状态
        return bool(current_states & self.accept_states)

    def trace(self, input_string: str) -> list[Set[str]]:
        """追踪NFA的执行过程"""
        current_states = self.epsilon_closure({self.initial_state})
        trace = [current_states.copy()]

        for symbol in input_string:
            current_states = self.move(current_states, symbol)
            current_states = self.epsilon_closure(current_states)
            trace.append(current_states.copy())

        return trace
```

---

### 2.2 实战示例

**示例1：识别包含"ab"的字符串**

```python
def create_contains_ab_nfa() -> NFA:
    """
    创建识别包含子串"ab"的NFA

    状态：
    - q0: 初始状态
    - q1: 读到'a'
    - q2: 读到"ab"（接受状态）

    特点：使用ε-转移和非确定性
    """
    return NFA(
        states={'q0', 'q1', 'q2'},
        alphabet={'a', 'b'},
        transitions={
            # 从q0可以读任意字符保持在q0（非确定性）
            ('q0', 'a'): {'q0', 'q1'},  # 读'a'可以保持或进入q1
            ('q0', 'b'): {'q0'},        # 读'b'保持在q0
            # 从q1读'b'进入q2
            ('q1', 'b'): {'q2'},
            # 从q2读任意字符保持在q2
            ('q2', 'a'): {'q2'},
            ('q2', 'b'): {'q2'},
        },
        initial_state='q0',
        accept_states={'q2'}
    )

# 测试
nfa = create_contains_ab_nfa()
test_cases = [
    ("ab", True),
    ("aab", True),
    ("bab", True),
    ("ba", False),
    ("abb", True),
    ("a", False),
]

for input_str, expected in test_cases:
    result = nfa.accepts(input_str)
    print(f"{'✅' if result == expected else '❌'} '{input_str}' → {result}")
```

**示例2：正则表达式(a|b)*abb**

```python
def create_regex_nfa() -> NFA:
    """
    创建识别正则表达式(a|b)*abb的NFA

    使用ε-转移实现选择和闭包
    """
    return NFA(
        states={'q0', 'q1', 'q2', 'q3'},
        alphabet={'a', 'b'},
        transitions={
            # (a|b)*部分：在q0循环
            ('q0', 'a'): {'q0', 'q1'},  # 读'a'可以循环或开始匹配"abb"
            ('q0', 'b'): {'q0'},        # 读'b'循环
            # abb部分
            ('q1', 'b'): {'q2'},        # 匹配第二个'b'
            ('q2', 'b'): {'q3'},        # 匹配第三个'b'
        },
        initial_state='q0',
        accept_states={'q3'}
    )
```

**示例3：使用ε-转移的NFA**

```python
def create_epsilon_nfa() -> NFA:
    """
    创建使用ε-转移的NFA

    识别：a*b*
    使用ε-转移连接两个部分
    """
    return NFA(
        states={'q0', 'q1', 'q2'},
        alphabet={'a', 'b'},
        transitions={
            # ε-转移：可以跳过a*部分
            ('q0', 'ε'): {'q1'},
            # a*部分
            ('q0', 'a'): {'q0'},
            # 从a*到b*的ε-转移
            ('q0', 'ε'): {'q1'},
            # b*部分
            ('q1', 'b'): {'q1'},
            # 到接受状态的ε-转移
            ('q1', 'ε'): {'q2'},
        },
        initial_state='q0',
        accept_states={'q2'}
    )

# 测试ε-闭包
nfa = create_epsilon_nfa()
print("ε-closure({q0}):", nfa.epsilon_closure({'q0'}))
# 输出：{'q0', 'q1', 'q2'}（通过ε-转移可达）
```

---

## 三、NFA到DFA的转换

### 3.1 子集构造算法

**核心思想**：DFA的每个状态对应NFA的状态集合

**算法步骤**：
```
1. 初始状态：ε-closure({q0})
2. 对每个未处理的DFA状态S：
   a. 对每个输入符号a：
      - 计算T = ε-closure(move(S, a))
      - 如果T是新状态，加入待处理队列
      - 添加转移：δ'(S, a) = T
3. 接受状态：包含NFA接受状态的DFA状态
```

---

### 3.2 Python实现

```python
def nfa_to_dfa(nfa: NFA) -> 'DFA':
    """
    将NFA转换为等价的DFA（子集构造算法）

    Returns:
        等价的DFA
    """
    from dataclasses import dataclass

    # DFA状态用frozenset表示（NFA状态集合）
    initial_dfa_state = frozenset(nfa.epsilon_closure({nfa.initial_state}))

    dfa_states = {initial_dfa_state}
    dfa_transitions = {}
    dfa_accept_states = set()
    unmarked_states = [initial_dfa_state]

    # 如果初始状态包含NFA接受状态，则为DFA接受状态
    if initial_dfa_state & nfa.accept_states:
        dfa_accept_states.add(initial_dfa_state)

    while unmarked_states:
        current_dfa_state = unmarked_states.pop()

        for symbol in nfa.alphabet:
            # 计算move + ε-closure
            next_nfa_states = nfa.move(set(current_dfa_state), symbol)
            next_dfa_state = frozenset(nfa.epsilon_closure(next_nfa_states))

            if not next_dfa_state:
                continue

            # 添加转移
            dfa_transitions[(current_dfa_state, symbol)] = next_dfa_state

            # 如果是新状态，加入队列
            if next_dfa_state not in dfa_states:
                dfa_states.add(next_dfa_state)
                unmarked_states.append(next_dfa_state)

                # 检查是否为接受状态
                if next_dfa_state & nfa.accept_states:
                    dfa_accept_states.add(next_dfa_state)

    # 转换为DFA格式（状态名称简化）
    state_mapping = {s: f"q{i}" for i, s in enumerate(dfa_states)}

    return DFA(
        states=set(state_mapping.values()),
        alphabet=nfa.alphabet,
        transitions={
            (state_mapping[s], a): state_mapping[t]
            for (s, a), t in dfa_transitions.items()
        },
        initial_state=state_mapping[initial_dfa_state],
        accept_states={state_mapping[s] for s in dfa_accept_states}
    )


# 测试转换
print("=== NFA到DFA转换测试 ===")
nfa = create_contains_ab_nfa()
dfa = nfa_to_dfa(nfa)

print(f"NFA状态数: {len(nfa.states)}")
print(f"DFA状态数: {len(dfa.states)}")

test_cases = [("ab", True), ("aab", True), ("ba", False)]
for input_str, expected in test_cases:
    nfa_result = nfa.accepts(input_str)
    dfa_result = dfa.accepts(input_str)
    print(f"{'✅' if nfa_result == dfa_result == expected else '❌'} "
          f"'{input_str}' → NFA:{nfa_result}, DFA:{dfa_result}")
```

---

## 四、NFA的优势与局限

### 4.1 优势

**1. 设计简单直观**：
- 符合人类思维
- 易于从正则表达式构造
- 状态数通常较少

**2. 表达简洁**：
- ε-转移简化设计
- 非确定性减少状态数
- 易于组合和修改

**3. 理论价值**：
- 与DFA等价
- 正则表达式的自然表示
- 编译原理的基础

---

### 4.2 局限

**1. 执行效率低**：
- 需要维护状态集合
- 最坏情况O(n × 2^m)
- 不适合实时系统

**2. 实现复杂**：
- 需要回溯或并行探索
- ε-闭包计算开销
- 难以硬件实现

**3. 不确定性**：
- 行为不可预测
- 难以调试
- 生产环境需转换为DFA

---

## 五、AI Agent中的应用

### 5.1 多路径探索

**场景**：Agent需要尝试多种策略

```python
from enum import Enum
from typing import Set

class AgentState(Enum):
    START = "start"
    STRATEGY_A = "strategy_a"
    STRATEGY_B = "strategy_b"
    SUCCESS = "success"
    FAILED = "failed"

class MultiStrategyAgent:
    """使用NFA模型的多策略Agent"""

    def __init__(self):
        # NFA：允许非确定性选择策略
        self.transitions = {
            (AgentState.START, 'try'): {
                AgentState.STRATEGY_A,
                AgentState.STRATEGY_B
            },  # 非确定性：同时尝试两种策略
            (AgentState.STRATEGY_A, 'success'): {AgentState.SUCCESS},
            (AgentState.STRATEGY_A, 'failed'): {AgentState.FAILED},
            (AgentState.STRATEGY_B, 'success'): {AgentState.SUCCESS},
            (AgentState.STRATEGY_B, 'failed'): {AgentState.FAILED},
        }

    def explore_all_paths(self, query: str) -> Set[AgentState]:
        """并行探索所有可能路径"""
        current_states = {AgentState.START}

        # 尝试所有策略
        current_states = self.transitions[(AgentState.START, 'try')]

        results = set()
        for state in current_states:
            # 执行策略
            if state == AgentState.STRATEGY_A:
                result = self._try_strategy_a(query)
            else:
                result = self._try_strategy_b(query)

            # 记录结果
            event = 'success' if result else 'failed'
            results.update(self.transitions.get((state, event), set()))

        return results

    def _try_strategy_a(self, query: str) -> bool:
        """策略A：精确匹配"""
        # 实现策略A
        return True

    def _try_strategy_b(self, query: str) -> bool:
        """策略B：模糊匹配"""
        # 实现策略B
        return False
```

---

### 5.2 正则表达式匹配

**场景**：验证用户输入格式

```python
def regex_to_nfa(pattern: str) -> NFA:
    """
    将正则表达式转换为NFA（Thompson构造）

    支持的操作：
    - 连接：ab
    - 选择：a|b
    - 闭包：a*
    """
    # 简化实现，实际需要完整的正则表达式解析器
    pass

# 使用示例
email_pattern = r"[a-z]+@[a-z]+\.[a-z]+"
email_nfa = regex_to_nfa(email_pattern)

# 验证邮箱
print(email_nfa.accepts("user@example.com"))  # True
print(email_nfa.accepts("invalid"))           # False
```

---

## 六、NFA设计技巧

### 6.1 使用ε-转移简化设计

**示例：连接两个NFA**

```python
def concatenate_nfa(nfa1: NFA, nfa2: NFA) -> NFA:
    """
    连接两个NFA：L(nfa1) · L(nfa2)

    方法：用ε-转移连接nfa1的接受状态到nfa2的初始状态
    """
    new_transitions = nfa1.transitions.copy()
    new_transitions.update(nfa2.transitions)

    # 添加ε-转移
    for accept_state in nfa1.accept_states:
        new_transitions[(accept_state, 'ε')] = {nfa2.initial_state}

    return NFA(
        states=nfa1.states | nfa2.states,
        alphabet=nfa1.alphabet | nfa2.alphabet,
        transitions=new_transitions,
        initial_state=nfa1.initial_state,
        accept_states=nfa2.accept_states
    )
```

---

### 6.2 非确定性减少状态数

**对比**：
```python
# DFA：识别以"ab"结尾（需要3个状态）
dfa_states = {'q0', 'q1', 'q2'}

# NFA：识别以"ab"结尾（只需2个状态+非确定性）
nfa_states = {'q0', 'q1'}
nfa_transitions = {
    ('q0', 'a'): {'q0', 'q1'},  # 非确定性
    ('q0', 'b'): {'q0'},
    ('q1', 'b'): {'q1'},  # 接受状态
}
```

---

## 七、总结

### 核心要点

1. **非确定性**：允许多个转移和ε-转移
2. **等价性**：NFA ⟺ DFA（子集构造）
3. **设计优势**：简单直观、状态数少
4. **执行劣势**：效率低、实现复杂
5. **应用场景**：正则表达式、多路径探索

### NFA vs DFA选择

| 场景 | 选择 | 原因 |
|------|------|------|
| **设计阶段** | NFA | 简单直观 |
| **执行阶段** | DFA | 高效可靠 |
| **正则引擎** | NFA→DFA | 先构造后优化 |
| **多策略探索** | NFA | 并行尝试 |
| **生产环境** | DFA | 确定性 |

### 学习建议

1. **理解非确定性**：多个转移的含义
2. **掌握ε-闭包**：计算算法
3. **学习子集构造**：NFA到DFA转换
4. **实践应用**：正则表达式、多路径探索
5. **对比DFA**：理解权衡取舍

---

## 参考资料

1. **经典理论**：
   - Wikipedia - Nondeterministic finite automaton
   - GeeksforGeeks - Conversion from NFA to DFA (2025-12)
   - Medium - The Subset Construction Algorithm
   - Stanford - Guide to the Subset Construction

2. **实现参考**：
   - Stack Overflow - NFA implementation
   - YouTube - NFA to DFA Conversion Explained

3. **AI Agent应用**：
   - Multi-path exploration in AI agents
   - Regex-based input validation

---

**版本**: v1.0
**最后更新**: 2026-02-14
**代码行数**: ~450行
