# 自定义Tool - 实战代码06：多Tool组合

> 完整可运行的多Tool组合示例，演示复杂任务的Tool协作

---

## 概述

复杂任务通常需要多个Tool协作完成。本文演示如何设计和组合多个Tool。

**场景示例：**
1. 订单查询 + 物流追踪
2. 用户查询 + 订单统计
3. 天气查询 + 行程建议
4. 数据查询 + 报表生成

---

## 完整示例：智能客服Agent

```python
"""
智能客服Agent示例
演示：多个Tool协作处理客户咨询
"""

import os
import asyncpg
import httpx
from typing import Optional
from langchain.tools import tool
from langchain_openai import ChatOpenAI
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
from dotenv import load_dotenv

load_dotenv()

# 全局资源
db_pool = None
http_client = httpx.AsyncClient(timeout=10.0)

# ===== 初始化 =====
async def init_db_pool():
    global db_pool
    if db_pool is None:
        db_pool = await asyncpg.create_pool(
            os.getenv("DATABASE_URL"),
            min_size=5,
            max_size=20
        )
    return db_pool

# ===== Tool 1：订单查询 =====
class OrderInput(BaseModel):
    order_id: str = Field(pattern=r'^ORD-\d{6}$')

@tool(args_schema=OrderInput)
async def get_order_details(order_id: str) -> str:
    """获取订单详细信息

    适用场景：
    - 用户询问"我的订单ORD-123456怎么样了？"
    """
    try:
        pool = await init_db_pool()
        async with pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT order_id, status, total_amount, created_at, user_id
                FROM orders WHERE order_id = $1
                """,
                order_id
            )

            if not row:
                return f"订单{order_id}不存在"

            status_map = {
                'pending': '待支付',
                'paid': '已支付',
                'shipped': '已发货',
                'completed': '已完成'
            }

            return f"""订单{order_id}：
状态：{status_map.get(row['status'], row['status'])}
金额：¥{row['total_amount']}
下单时间：{row['created_at'].strftime('%Y-%m-%d %H:%M')}
"""
    except Exception as e:
        return f"查询失败：{str(e)}"

# ===== Tool 2：物流追踪 =====
@tool(args_schema=OrderInput)
async def track_shipment(order_id: str) -> str:
    """追踪订单物流信息

    适用场景：
    - 用户询问"订单ORD-123456什么时候到？"
    - 用户询问"我的快递到哪了？"
    """
    try:
        # 模拟调用物流API
        tracking_info = {
            "status": "运输中",
            "location": "北京分拨中心",
            "estimated_delivery": "2024-03-20",
            "history": [
                "2024-03-15 10:00 - 已揽收",
                "2024-03-16 08:00 - 到达北京分拨中心",
                "2024-03-17 14:00 - 派送中"
            ]
        }

        return f"""订单{order_id}物流信息：
当前状态：{tracking_info['status']}
当前位置：{tracking_info['location']}
预计送达：{tracking_info['estimated_delivery']}

物流轨迹：
{chr(10).join(tracking_info['history'])}
"""
    except Exception as e:
        return f"查询失败：{str(e)}"

# ===== Tool 3：用户信息查询 =====
class UserInput(BaseModel):
    user_id: int = Field(gt=0)

@tool(args_schema=UserInput)
async def get_user_info(user_id: int) -> str:
    """获取用户信息和统计

    适用场景：
    - 客服查询用户信息
    """
    try:
        pool = await init_db_pool()
        async with pool.acquire() as conn:
            user = await conn.fetchrow(
                "SELECT username, email FROM users WHERE id = $1",
                user_id
            )

            if not user:
                return f"用户{user_id}不存在"

            stats = await conn.fetchrow(
                """
                SELECT COUNT(*) as order_count,
                       COALESCE(SUM(total_amount), 0) as total_spent
                FROM orders WHERE user_id = $1
                """,
                user_id
            )

            return f"""用户信息：
用户名：{user['username']}
邮箱：{user['email']}
订单总数：{stats['order_count']}
消费总额：¥{stats['total_spent']}
"""
    except Exception as e:
        return f"查询失败：{str(e)}"

# ===== Tool 4：发送通知 =====
class NotifyInput(BaseModel):
    user_id: int = Field(gt=0)
    message: str = Field(min_length=1, max_length=500)

@tool(args_schema=NotifyInput)
async def send_notification(user_id: int, message: str) -> str:
    """发送通知给用户

    适用场景：
    - 客服需要通知用户
    """
    try:
        # 模拟发送通知
        return f"已向用户{user_id}发送通知：{message}"
    except Exception as e:
        return f"发送失败：{str(e)}"

# ===== Tool 5：转人工 =====
@tool
def escalate_to_human(reason: str) -> str:
    """转接人工客服

    适用场景：
    - 问题无法自动解决
    - 用户要求人工服务
    """
    return f"已转接人工客服。原因：{reason}"

# ===== 创建Agent =====
async def create_customer_service_agent():
    """创建智能客服Agent"""

    # 定义所有Tools
    tools = [
        get_order_details,
        track_shipment,
        get_user_info,
        send_notification,
        escalate_to_human
    ]

    # 创建LLM
    llm = ChatOpenAI(model="gpt-4", temperature=0)

    # 创建Prompt
    prompt = ChatPromptTemplate.from_messages([
        ("system", """你是一个智能客服助手，可以帮助用户查询订单、追踪物流、查看账户信息。

处理原则：
1. 优先使用工具查询准确信息
2. 如果需要多个信息，依次调用相关工具
3. 如果无法解决问题，转接人工客服
4. 回答要友好、专业、准确

可用工具：
- get_order_details: 查询订单详情
- track_shipment: 追踪物流信息
- get_user_info: 查询用户信息
- send_notification: 发送通知
- escalate_to_human: 转人工客服
"""),
        ("human", "{input}"),
        ("placeholder", "{agent_scratchpad}"),
    ])

    # 创建Agent
    agent = create_tool_calling_agent(llm, tools, prompt)

    # 创建执行器
    agent_executor = AgentExecutor(
        agent=agent,
        tools=tools,
        verbose=True,
        max_iterations=5
    )

    return agent_executor

# ===== 测试场景 =====
async def test_scenarios():
    """测试多Tool组合场景"""

    agent = await create_customer_service_agent()

    # 场景1：查询订单和物流
    print("=== 场景1：查询订单和物流 ===")
    result = await agent.ainvoke({
        "input": "我的订单ORD-123456怎么样了？什么时候能到？"
    })
    print(f"回答：{result['output']}\n")

    # 场景2：查询用户信息
    print("=== 场景2：查询用户信息 ===")
    result = await agent.ainvoke({
        "input": "帮我查一下用户ID 1的信息和消费情况"
    })
    print(f"回答：{result['output']}\n")

    # 场景3：复杂咨询（需要多个Tool）
    print("=== 场景3：复杂咨询 ===")
    result = await agent.ainvoke({
        "input": "我是用户1，想查一下我的订单ORD-123456，如果已发货请告诉我物流信息"
    })
    print(f"回答：{result['output']}\n")

# ===== 清理资源 =====
async def cleanup():
    global db_pool
    if db_pool:
        await db_pool.close()
    await http_client.aclose()

if __name__ == "__main__":
    import asyncio

    async def main():
        try:
            await test_scenarios()
        finally:
            await cleanup()

    asyncio.run(main())
```

---

## 执行流程示例

### 场景：用户询问订单和物流

```
用户："我的订单ORD-123456怎么样了？什么时候能到？"
    ↓
Agent分析：需要两个信息
    1. 订单状态
    2. 物流信息
    ↓
调用Tool 1：get_order_details("ORD-123456")
    返回：订单状态为"已发货"
    ↓
调用Tool 2：track_shipment("ORD-123456")
    返回：物流信息
    ↓
Agent整合：生成最终回答
    ↓
输出："您的订单ORD-123456已发货，当前在北京分拨中心，预计2024-03-20送达。"
```

---

## 最佳实践

### 1. Tool设计原则

```python
# ✅ 每个Tool职责单一
get_order_details()  # 只查订单
track_shipment()     # 只查物流

# ❌ Tool职责混乱
get_order_and_shipment()  # 做太多事
```

### 2. Tool描述要明确适用场景

```python
@tool
def get_order_details(order_id: str) -> str:
    """获取订单详细信息

    适用场景：
    - 用户询问"我的订单XXX怎么样了？"
    - 用户询问"订单XXX的状态"

    不适用场景：
    - 查询物流信息（应该用track_shipment）
    """
```

### 3. Agent Prompt要说明Tool用法

```python
prompt = """你是智能客服，可以使用以下工具：

1. get_order_details: 查询订单状态和金额
2. track_shipment: 查询物流信息
3. get_user_info: 查询用户信息

处理流程：
- 如果用户问订单状态，用get_order_details
- 如果用户问物流，用track_shipment
- 如果需要多个信息，依次调用相关工具
"""
```

---

## 总结

多Tool组合的核心：
1. **Tool职责单一**：每个Tool只做一件事
2. **清晰的描述**：说明适用场景
3. **Agent协调**：LLM决定调用哪些Tool
4. **结果整合**：LLM整合多个Tool的结果

**记住：** Tool越简单越好，复杂逻辑由Agent协调！
