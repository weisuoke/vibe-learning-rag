# Session 管理与分支 - 实战代码 03：Fork 实验性开发

> 使用 Fork 进行 A/B 测试和多方案探索的完整代码示例

---

## 场景：从当前点 Fork 尝试不同方案

实现：
- Fork 会话创建
- 多方案并行开发
- 方案对比和选择
- 最佳实践应用

---

## 完整代码实现

```typescript
/**
 * Fork 实验性开发实战示例
 * 演示：使用 Fork 进行 A/B 测试和多方案探索
 */

import fs from 'fs/promises';
import path from 'path';

// ===== 类型定义省略（与前面示例相同）=====

// ===== Fork 管理器 =====

class ForkManager {
  constructor(private sessionsDir: string) {}

  // Fork 会话
  async forkSession(
    originalSessionId: string,
    fromNodeId: string,
    newSessionId?: string
  ): Promise<Session> {
    // 1. 读取原始会话
    const originalStorage = new SessionStorage(originalSessionId, this.sessionsDir);
    const originalEntries = await originalStorage.readAll();

    // 2. 获取到指定节点的历史路径
    const historyPath = this.getHistoryPath(originalEntries, fromNodeId);

    // 3. 创建新会话
    newSessionId = newSessionId || this.generateSessionId();
    const newStorage = new SessionStorage(newSessionId, this.sessionsDir);

    // 4. 写入继承的历史
    for (const entry of historyPath) {
      await newStorage.append(entry);
    }

    // 5. 添加 Fork 元数据
    await newStorage.append({
      id: this.generateId(),
      type: 'fork_metadata',
      parentSessionId: originalSessionId,
      forkFromNodeId: fromNodeId,
      timestamp: Date.now()
    });

    // 6. 返回新 Session
    return new Session(newSessionId, this.sessionsDir);
  }

  private getHistoryPath(entries: SessionEntry[], targetNodeId: string): SessionEntry[] {
    const nodeMap = new Map(entries.map(e => [e.id, e]));
    const path: SessionEntry[] = [];

    let currentId: string | undefined = targetNodeId;
    while (currentId) {
      const node = nodeMap.get(currentId);
      if (!node) break;

      path.unshift(node);
      currentId = node.parentId;
    }

    return path;
  }

  private generateSessionId(): string {
    return Math.random().toString(36).substring(2, 15);
  }

  private generateId(): string {
    return Math.random().toString(36).substring(2, 15);
  }
}

// ===== 方案比较器 =====

class SolutionComparator {
  // 比较多个方案
  async compareSolutions(sessionIds: string[], sessionsDir: string): Promise<ComparisonResult> {
    const solutions: SolutionInfo[] = [];

    for (const sessionId of sessionIds) {
      const session = new Session(sessionId, sessionsDir);
      const messages = await session.getMessages();
      const name = await session.getName();

      solutions.push({
        sessionId,
        name: name || sessionId,
        messageCount: messages.length,
        lastMessage: messages[messages.length - 1]?.content || '',
        messages
      });
    }

    return {
      solutions,
      recommendation: this.recommendBestSolution(solutions)
    };
  }

  private recommendBestSolution(solutions: SolutionInfo[]): string {
    // 简单的推荐逻辑：选择消息最多的方案
    let best = solutions[0];
    for (const solution of solutions) {
      if (solution.messageCount > best.messageCount) {
        best = solution;
      }
    }
    return best.sessionId;
  }
}

interface SolutionInfo {
  sessionId: string;
  name: string;
  messageCount: number;
  lastMessage: string;
  messages: MessageEntry[];
}

interface ComparisonResult {
  solutions: SolutionInfo[];
  recommendation: string;
}

// ===== 使用示例 =====

async function main() {
  console.log('=== Fork 实验性开发示例 ===\n');

  const sessionsDir = path.join(process.cwd(), '.demo-sessions');
  await fs.mkdir(sessionsDir, { recursive: true });

  const manager = new SessionManager(sessionsDir);
  const forkManager = new ForkManager(sessionsDir);

  // 1. 创建基础会话
  console.log('1. 创建基础会话');
  const baseSession = await manager.createSession('base-implementation');
  await baseSession.setName('基础实现');

  await baseSession.appendMessage('user', '实现用户认证系统');
  await baseSession.appendMessage('assistant', '好的，我来实现基础的用户认证系统...');
  await baseSession.appendMessage('user', '实现登录和注册功能');
  await baseSession.appendMessage('assistant', '已完成基础的登录和注册功能');

  const baseMessages = await baseSession.getMessages();
  const lastNodeId = baseMessages[baseMessages.length - 1].id;
  console.log(`   基础会话创建完成，包含 ${baseMessages.length} 条消息\n`);

  // 2. Fork 方案 A：使用 JWT 认证
  console.log('2. Fork 方案 A：使用 JWT 认证');
  const solutionA = await forkManager.forkSession(
    baseSession.id,
    lastNodeId,
    'solution-jwt'
  );
  await solutionA.setName('方案A-JWT认证');

  await solutionA.appendMessage('user', '使用 JWT 进行身份认证');
  await solutionA.appendMessage('assistant', '好的，实现 JWT 认证...');
  await solutionA.appendMessage('assistant', '- 生成 JWT token\n- 验证 token\n- 刷新 token');
  await solutionA.appendMessage('user', '测试通过');

  const messagesA = await solutionA.getMessages();
  console.log(`   方案 A 完成，包含 ${messagesA.length} 条消息\n`);

  // 3. Fork 方案 B：使用 Session 认证
  console.log('3. Fork 方案 B：使用 Session 认证');
  const solutionB = await forkManager.forkSession(
    baseSession.id,
    lastNodeId,
    'solution-session'
  );
  await solutionB.setName('方案B-Session认证');

  await solutionB.appendMessage('user', '使用 Session 进行身份认证');
  await solutionB.appendMessage('assistant', '好的，实现 Session 认证...');
  await solutionB.appendMessage('assistant', '- 创建 Session\n- 存储 Session\n- 验证 Session');
  await solutionB.appendMessage('user', '测试通过');

  const messagesB = await solutionB.getMessages();
  console.log(`   方案 B 完成，包含 ${messagesB.length} 条消息\n`);

  // 4. Fork 方案 C：使用 OAuth 认证
  console.log('4. Fork 方案 C：使用 OAuth 认证');
  const solutionC = await forkManager.forkSession(
    baseSession.id,
    lastNodeId,
    'solution-oauth'
  );
  await solutionC.setName('方案C-OAuth认证');

  await solutionC.appendMessage('user', '使用 OAuth 2.0 进行身份认证');
  await solutionC.appendMessage('assistant', '好的，实现 OAuth 认证...');
  await solutionC.appendMessage('assistant', '- 集成 OAuth provider\n- 处理回调\n- 获取用户信息');
  await solutionC.appendMessage('user', '测试通过');

  const messagesC = await solutionC.getMessages();
  console.log(`   方案 C 完成，包含 ${messagesC.length} 条消息\n`);

  // 5. 列出所有方案
  console.log('5. 列出所有方案');
  const sessions = await manager.listSessions();
  console.log(`   总共 ${sessions.length} 个会话:`);
  sessions.forEach((s, i) => {
    console.log(`   ${i + 1}. ${s.name} (${s.entryCount} entries)`);
  });
  console.log();

  // 6. 对比方案
  console.log('6. 对比方案');
  const comparator = new SolutionComparator();
  const comparison = await comparator.compareSolutions(
    [solutionA.id, solutionB.id, solutionC.id],
    sessionsDir
  );

  console.log('   方案对比:');
  comparison.solutions.forEach((sol, i) => {
    console.log(`\n   方案 ${i + 1}: ${sol.name}`);
    console.log(`   - 消息数: ${sol.messageCount}`);
    console.log(`   - 最后消息: ${sol.lastMessage}`);
  });

  console.log(`\n   推荐方案: ${comparison.recommendation}\n`);

  // 7. 查看方案详情
  console.log('7. 查看方案 A 详情');
  const contextA = await solutionA.getContext();
  console.log('   完整对话:');
  contextA.forEach((msg, i) => {
    console.log(`   ${i + 1}. ${msg.role}: ${msg.content.substring(0, 50)}...`);
  });

  console.log('\n=== 示例完成 ===');

  // 清理
  await fs.rm(sessionsDir, { recursive: true, force: true });
}

// 运行示例
main().catch(console.error);
```

---

## 运行输出示例

```
=== Fork 实验性开发示例 ===

1. 创建基础会话
   基础会话创建完成，包含 4 条消息

2. Fork 方案 A：使用 JWT 认证
   方案 A 完成，包含 8 条消息

3. Fork 方案 B：使用 Session 认证
   方案 B 完成，包含 8 条消息

4. Fork 方案 C：使用 OAuth 认证
   方案 C 完成，包含 8 条消息

5. 列出所有方案
   总共 4 个会话:
   1. 方案C-OAuth认证 (10 entries)
   2. 方案B-Session认证 (10 entries)
   3. 方案A-JWT认证 (10 entries)
   4. 基础实现 (6 entries)

6. 对比方案
   方案对比:

   方案 1: 方案A-JWT认证
   - 消息数: 8
   - 最后消息: 测试通过

   方案 2: 方案B-Session认证
   - 消息数: 8
   - 最后消息: 测试通过

   方案 3: 方案C-OAuth认证
   - 消息数: 8
   - 最后消息: 测试通过

   推荐方案: solution-jwt

7. 查看方案 A 详情
   完整对话:
   1. user: 实现用户认证系统...
   2. assistant: 好的，我来实现基础的用户认证系统......
   3. user: 实现登录和注册功能...
   4. assistant: 已完成基础的登录和注册功能...
   5. user: 使用 JWT 进行身份认证...
   6. assistant: 好的，实现 JWT 认证......
   7. assistant: - 生成 JWT token\n- 验证 token\n- 刷新 tok...
   8. user: 测试通过...

=== 示例完成 ===
```

---

## 应用场景

### 场景 1：技术选型

```typescript
async function technicalSelection() {
  // 基础实现
  const base = await manager.createSession('base');
  await base.appendMessage('user', '实现数据存储');

  // Fork 多个技术方案
  const mongodb = await forkManager.forkSession(base.id, lastNodeId, 'tech-mongodb');
  await mongodb.setName('MongoDB方案');

  const postgresql = await forkManager.forkSession(base.id, lastNodeId, 'tech-postgresql');
  await postgresql.setName('PostgreSQL方案');

  const redis = await forkManager.forkSession(base.id, lastNodeId, 'tech-redis');
  await redis.setName('Redis方案');

  // 对比并选择
  const comparison = await comparator.compareSolutions([
    mongodb.id,
    postgresql.id,
    redis.id
  ], sessionsDir);

  console.log('推荐方案:', comparison.recommendation);
}
```

### 场景 2：性能优化

```typescript
async function performanceOptimization() {
  // 基础实现
  const base = await manager.createSession('base-performance');
  await base.appendMessage('user', '当前性能基准');

  // Fork 多个优化方案
  const caching = await forkManager.forkSession(base.id, lastNodeId, 'opt-caching');
  await caching.setName('缓存优化');

  const indexing = await forkManager.forkSession(base.id, lastNodeId, 'opt-indexing');
  await indexing.setName('索引优化');

  const parallel = await forkManager.forkSession(base.id, lastNodeId, 'opt-parallel');
  await parallel.setName('并行处理');

  // 测试并对比结果
}
```

---

## 学习检查清单

完成本节学习后，你应该能够：

- [ ] 实现 Fork 管理器
- [ ] 创建多个并行方案
- [ ] 对比不同方案
- [ ] 选择最佳方案
- [ ] 应用于实际技术选型

---

**版本：** v1.0
**最后更新：** 2026-02-18
**维护者：** Claude Code
