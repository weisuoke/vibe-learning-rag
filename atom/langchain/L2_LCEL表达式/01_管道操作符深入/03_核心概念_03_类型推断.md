# æ ¸å¿ƒæ¦‚å¿µ3ï¼šç±»å‹æ¨æ–­ä¸ç±»å‹å®‰å…¨

> æ·±å…¥ç†è§£ LCEL çš„ç±»å‹ç³»ç»Ÿã€Pydantic v2 é›†æˆå’Œ IDE æ”¯æŒ

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£æ·±å…¥æ¢è®¨ LCEL çš„ç±»å‹ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š
- Python ç±»å‹æç¤ºåœ¨ LCEL ä¸­çš„åº”ç”¨
- Pydantic v2 é›†æˆï¼ˆLangChain v0.3+ï¼‰
- è¾“å…¥è¾“å‡º schema æ¨æ–­
- IDE è‡ªåŠ¨è¡¥å…¨å’Œé”™è¯¯æ£€æµ‹
- ç±»å‹å®‰å…¨çš„æœ€ä½³å®è·µ

---

## 1. ä¸ºä»€ä¹ˆéœ€è¦ç±»å‹ç³»ç»Ÿï¼Ÿ

### 1.1 é—®é¢˜åœºæ™¯

**æ— ç±»å‹ä»£ç çš„é—®é¢˜**ï¼š

```python
# æ— ç±»å‹æç¤º
chain = step_a | step_b | step_c

# è¿è¡Œæ—¶æ‰å‘ç°é”™è¯¯
result = chain.invoke({"wrong_key": "value"})
# ğŸ’¥ KeyError: 'expected_key'
```

**ç±»å‹å®‰å…¨çš„å¥½å¤„**ï¼š

```python
from typing import TypedDict

class InputType(TypedDict):
    expected_key: str

# æœ‰ç±»å‹æç¤º
chain: Runnable[InputType, str] = step_a | step_b | step_c

# IDE ä¼šæç¤ºé”™è¯¯
result = chain.invoke({"wrong_key": "value"})
# âš ï¸ IDE: Type mismatch - missing 'expected_key'
```

### 1.2 ç±»å‹ç³»ç»Ÿçš„ä»·å€¼

**å¼€å‘æ—¶å‘ç°é”™è¯¯ > è¿è¡Œæ—¶å‘ç°é”™è¯¯**

| é˜¶æ®µ | å‘ç°æ—¶é—´ | ä¿®å¤æˆæœ¬ | å½±å“èŒƒå›´ |
|------|----------|----------|----------|
| å¼€å‘æ—¶ï¼ˆIDE æç¤ºï¼‰ | ç«‹å³ | æä½ | å¼€å‘è€… |
| æµ‹è¯•æ—¶ | åˆ†é’Ÿ-å°æ—¶ | ä½ | å›¢é˜Ÿ |
| ç”Ÿäº§æ—¶ | å¤©-å‘¨ | é«˜ | ç”¨æˆ· |

**2025-2026 å¢å¼º**ï¼š
- Pydantic v2 é›†æˆï¼šæ›´å¼ºçš„è¿è¡Œæ—¶éªŒè¯
- é›¶æ€§èƒ½å¼€é”€ï¼šç±»å‹æ£€æŸ¥åœ¨å¼€å‘æ—¶å®Œæˆ
- IDE æ”¯æŒï¼šVSCodeã€PyCharm è‡ªåŠ¨è¡¥å…¨

---

## 2. Python ç±»å‹æç¤ºåŸºç¡€

### 2.1 åŸºç¡€ç±»å‹æ³¨è§£

```python
from typing import List, Dict, Optional, Union

# åŸºç¡€ç±»å‹
def process_string(text: str) -> str:
    return text.upper()

# å¤åˆç±»å‹
def process_list(items: List[str]) -> Dict[str, int]:
    return {item: len(item) for item in items}

# å¯é€‰ç±»å‹
def get_value(key: str) -> Optional[str]:
    return data.get(key)  # å¯èƒ½è¿”å› None

# è”åˆç±»å‹
def parse_input(value: Union[str, int]) -> str:
    return str(value)
```

### 2.2 TypedDict

**å®šä¹‰ç»“æ„åŒ–å­—å…¸ç±»å‹**ï¼š

```python
from typing import TypedDict

class UserInput(TypedDict):
    name: str
    age: int
    email: str

class UserOutput(TypedDict):
    user_id: int
    name: str
    created_at: str

# ä½¿ç”¨
def create_user(input: UserInput) -> UserOutput:
    return {
        "user_id": 123,
        "name": input["name"],
        "created_at": "2026-02-19"
    }

# IDE ä¼šæ£€æŸ¥
user = create_user({
    "name": "Alice",
    "age": 30,
    "email": "alice@example.com"
})  # âœ… ç±»å‹æ­£ç¡®

user = create_user({
    "name": "Bob"
    # âŒ IDE æç¤ºï¼šç¼ºå°‘ 'age' å’Œ 'email'
})
```

### 2.3 æ³›å‹ï¼ˆGenericï¼‰

**å®šä¹‰å¯å¤ç”¨çš„ç±»å‹**ï¼š

```python
from typing import TypeVar, Generic

Input = TypeVar("Input")
Output = TypeVar("Output")

class Processor(Generic[Input, Output]):
    """æ³›å‹å¤„ç†å™¨"""

    def process(self, input: Input) -> Output:
        raise NotImplementedError

# å…·ä½“å®ç°
class StringToInt(Processor[str, int]):
    def process(self, input: str) -> int:
        return len(input)

# ä½¿ç”¨
processor: Processor[str, int] = StringToInt()
result: int = processor.process("hello")  # IDE çŸ¥é“ result æ˜¯ int
```

---

## 3. LCEL ä¸­çš„ç±»å‹ç³»ç»Ÿ

### 3.1 Runnable çš„ç±»å‹å‚æ•°

**Runnable æ˜¯æ³›å‹ç±»**ï¼š

```python
from langchain_core.runnables import Runnable
from typing import TypeVar

Input = TypeVar("Input")
Output = TypeVar("Output")

class Runnable(Generic[Input, Output]):
    """
    Runnable åŸºç±»

    ç±»å‹å‚æ•°ï¼š
    - Input: è¾“å…¥ç±»å‹
    - Output: è¾“å‡ºç±»å‹
    """

    def invoke(self, input: Input, config=None) -> Output:
        raise NotImplementedError
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```python
from langchain_core.runnables import Runnable
from typing import TypedDict

class QueryInput(TypedDict):
    query: str

class AnswerOutput(TypedDict):
    answer: str
    confidence: float

# å®šä¹‰ç±»å‹åŒ–çš„ Runnable
qa_chain: Runnable[QueryInput, AnswerOutput] = ...

# IDE çŸ¥é“è¾“å…¥è¾“å‡ºç±»å‹
result: AnswerOutput = qa_chain.invoke({"query": "What is AI?"})
print(result["answer"])  # âœ… IDE è‡ªåŠ¨è¡¥å…¨
print(result["score"])   # âŒ IDE æç¤ºé”™è¯¯ï¼šæ²¡æœ‰ 'score' å­—æ®µ
```

### 3.2 ç®¡é“ç»„åˆçš„ç±»å‹æ¨æ–­

**ç±»å‹è‡ªåŠ¨æ¨æ–­**ï¼š

```python
from langchain_core.runnables import Runnable

# å®šä¹‰ä¸‰ä¸ª Runnable
step_a: Runnable[str, int] = ...       # str â†’ int
step_b: Runnable[int, list] = ...      # int â†’ list
step_c: Runnable[list, str] = ...      # list â†’ str

# ç»„åˆ
chain = step_a | step_b | step_c

# ç±»å‹æ¨æ–­
# chain: Runnable[str, str]
# è¾“å…¥ç±»å‹ = step_a çš„è¾“å…¥ç±»å‹ (str)
# è¾“å‡ºç±»å‹ = step_c çš„è¾“å‡ºç±»å‹ (str)

# IDE çŸ¥é“ç±»å‹
result: str = chain.invoke("hello")  # âœ… ç±»å‹æ­£ç¡®
```

**ç±»å‹ä¸åŒ¹é…æ£€æµ‹**ï¼š

```python
step_a: Runnable[str, int] = ...       # str â†’ int
step_b: Runnable[str, list] = ...      # str â†’ list (ä¸åŒ¹é…ï¼)

# IDE ä¼šæç¤ºé”™è¯¯
chain = step_a | step_b
# âš ï¸ Type mismatch: step_a outputs int, but step_b expects str
```

### 3.3 è¾“å…¥è¾“å‡º Schema

**è·å– Runnable çš„ schema**ï¼š

```python
from langchain_core.runnables import Runnable

chain: Runnable = prompt | llm | parser

# è·å–è¾“å…¥ schema
input_schema = chain.input_schema()
print(input_schema)
# {
#   "type": "object",
#   "properties": {
#     "topic": {"type": "string"}
#   }
# }

# è·å–è¾“å‡º schema
output_schema = chain.output_schema()
print(output_schema)
# {"type": "string"}
```

---

## 4. Pydantic v2 é›†æˆ

### 4.1 LangChain v0.3+ çš„å˜åŒ–

**é‡å¤§å˜æ›´**ï¼šLangChain v0.3+ å®Œå…¨è¿ç§»åˆ° Pydantic v2

```python
# LangChain v0.2ï¼ˆPydantic v1ï¼‰
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int

# LangChain v0.3+ï¼ˆPydantic v2ï¼‰
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str = Field(description="User's name")
    age: int = Field(ge=0, description="User's age")
```

**å‚è€ƒèµ„æº**ï¼š
- [LangChain v0.3 è¿ç§»æŒ‡å—](https://changelog.langchain.com/announcements/langchain-v0-3-migrating-to-pydantic-2-for-python-peer-dependencies-for-javascript)

### 4.2 Pydantic æ¨¡å‹åœ¨ LCEL ä¸­çš„ä½¿ç”¨

**å®šä¹‰ Pydantic æ¨¡å‹**ï¼š

```python
from pydantic import BaseModel, Field
from typing import List

class Query(BaseModel):
    """æŸ¥è¯¢è¾“å…¥"""
    query: str = Field(description="User's question")
    max_results: int = Field(default=5, ge=1, le=100)

class Document(BaseModel):
    """æ–‡æ¡£"""
    content: str
    score: float = Field(ge=0.0, le=1.0)

class Answer(BaseModel):
    """ç­”æ¡ˆè¾“å‡º"""
    answer: str
    sources: List[Document]
    confidence: float = Field(ge=0.0, le=1.0)
```

**åœ¨ Runnable ä¸­ä½¿ç”¨**ï¼š

```python
from langchain_core.runnables import Runnable

class QARunnable(Runnable[Query, Answer]):
    """ç±»å‹å®‰å…¨çš„ QA Runnable"""

    def invoke(self, input: Query, config=None) -> Answer:
        # Pydantic è‡ªåŠ¨éªŒè¯è¾“å…¥
        # input.query ä¿è¯æ˜¯ str
        # input.max_results ä¿è¯åœ¨ 1-100 ä¹‹é—´

        # å¤„ç†é€»è¾‘
        docs = self.retrieve(input.query, input.max_results)

        # è¿”å› Pydantic æ¨¡å‹
        return Answer(
            answer="AI is...",
            sources=docs,
            confidence=0.95
        )

# ä½¿ç”¨
qa = QARunnable()

# âœ… æ­£ç¡®è¾“å…¥
result = qa.invoke(Query(query="What is AI?", max_results=10))

# âŒ é”™è¯¯è¾“å…¥ï¼ˆPydantic ä¼šæŠ›å‡º ValidationErrorï¼‰
result = qa.invoke(Query(query="What is AI?", max_results=200))
# ValidationError: max_results must be <= 100
```

### 4.3 PydanticOutputParser

**è§£æ LLM è¾“å‡ºä¸º Pydantic æ¨¡å‹**ï¼š

```python
from langchain.output_parsers import PydanticOutputParser
from langchain.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field

# å®šä¹‰è¾“å‡ºç»“æ„
class Joke(BaseModel):
    setup: str = Field(description="The setup of the joke")
    punchline: str = Field(description="The punchline of the joke")
    rating: int = Field(ge=1, le=10, description="Humor rating")

# åˆ›å»ºè§£æå™¨
parser = PydanticOutputParser(pydantic_object=Joke)

# åœ¨ prompt ä¸­åŒ…å«æ ¼å¼è¯´æ˜
prompt = ChatPromptTemplate.from_template(
    "Tell a joke about {topic}.\n\n{format_instructions}"
)

# ç»„åˆ
llm = ChatOpenAI(model="gpt-4o-mini")
chain = prompt | llm | parser

# æ‰§è¡Œï¼ˆè¿”å› Pydantic å¯¹è±¡ï¼‰
joke: Joke = chain.invoke({
    "topic": "programming",
    "format_instructions": parser.get_format_instructions()
})

# ç±»å‹å®‰å…¨è®¿é—®
print(f"Setup: {joke.setup}")
print(f"Punchline: {joke.punchline}")
print(f"Rating: {joke.rating}/10")

# IDE è‡ªåŠ¨è¡¥å…¨
joke.  # IDE ä¼šæç¤º setup, punchline, rating
```

### 4.4 with_structured_output()

**2025-2026 æ–°ç‰¹æ€§**ï¼šç›´æ¥ä» LLM è·å–ç»“æ„åŒ–è¾“å‡º

```python
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field

class ExtractedInfo(BaseModel):
    """ä»æ–‡æœ¬ä¸­æå–çš„ä¿¡æ¯"""
    person_name: str = Field(description="Person's name")
    age: int = Field(description="Person's age")
    occupation: str = Field(description="Person's occupation")

# ä½¿ç”¨ with_structured_output
llm = ChatOpenAI(model="gpt-4o-mini")
structured_llm = llm.with_structured_output(ExtractedInfo)

# ç›´æ¥è¿”å› Pydantic å¯¹è±¡
result: ExtractedInfo = structured_llm.invoke(
    "Alice is a 30-year-old software engineer."
)

print(result.person_name)  # "Alice"
print(result.age)          # 30
print(result.occupation)   # "software engineer"
```

**å‚è€ƒèµ„æº**ï¼š
- [Pydantic v2 å·¥å…·é›†æˆ](https://changelog.langchain.com/announcements/improved-pydantic-2-support-with-langchain-tool-apis)

---

## 5. IDE æ”¯æŒ

### 5.1 VSCode é…ç½®

**å®‰è£… Python æ‰©å±•**ï¼š

```json
// .vscode/settings.json
{
  "python.analysis.typeCheckingMode": "basic",  // æˆ– "strict"
  "python.linting.mypyEnabled": true,
  "python.linting.enabled": true
}
```

**æ•ˆæœ**ï¼š
- è‡ªåŠ¨è¡¥å…¨å­—æ®µå
- ç±»å‹ä¸åŒ¹é…è­¦å‘Š
- å‡½æ•°ç­¾åæç¤º

### 5.2 PyCharm é…ç½®

**å¯ç”¨ç±»å‹æ£€æŸ¥**ï¼š

```
Settings â†’ Editor â†’ Inspections â†’ Python â†’ Type Checker
âœ… Enable type checker
```

**æ•ˆæœ**ï¼š
- å®æ—¶ç±»å‹æ£€æŸ¥
- é‡æ„æ”¯æŒï¼ˆé‡å‘½åå­—æ®µä¼šè‡ªåŠ¨æ›´æ–°æ‰€æœ‰å¼•ç”¨ï¼‰
- è·³è½¬åˆ°å®šä¹‰

### 5.3 mypy é™æ€ç±»å‹æ£€æŸ¥

**å®‰è£… mypy**ï¼š

```bash
uv add --dev mypy
```

**é…ç½®**ï¼š

```ini
# mypy.ini
[mypy]
python_version = 3.13
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
```

**è¿è¡Œæ£€æŸ¥**ï¼š

```bash
mypy your_script.py
```

**ç¤ºä¾‹è¾“å‡º**ï¼š

```
your_script.py:10: error: Argument 1 to "invoke" has incompatible type "Dict[str, str]"; expected "QueryInput"
your_script.py:15: error: "AnswerOutput" has no attribute "score"
Found 2 errors in 1 file (checked 1 source file)
```

---

## 6. ç±»å‹å®‰å…¨çš„æœ€ä½³å®è·µ

### 6.1 ä½¿ç”¨ TypedDict å®šä¹‰æ¥å£

**æ¨è**ï¼š

```python
from typing import TypedDict

class RAGInput(TypedDict):
    query: str
    max_docs: int

class RAGOutput(TypedDict):
    answer: str
    sources: list[str]

# ç±»å‹å®‰å…¨çš„ RAG é“¾
rag_chain: Runnable[RAGInput, RAGOutput] = ...
```

**ä¸æ¨è**ï¼š

```python
# æ— ç±»å‹æç¤º
rag_chain = retriever | prompt | llm | parser

# è¿è¡Œæ—¶æ‰çŸ¥é“éœ€è¦ä»€ä¹ˆè¾“å…¥
result = rag_chain.invoke({"query": "..."})  # ç¼ºå°‘ max_docsï¼Ÿ
```

### 6.2 ä½¿ç”¨ Pydantic æ¨¡å‹è¿›è¡ŒéªŒè¯

**æ¨è**ï¼š

```python
from pydantic import BaseModel, Field, validator

class RAGInput(BaseModel):
    query: str = Field(min_length=1, max_length=500)
    max_docs: int = Field(ge=1, le=100)

    @validator("query")
    def query_not_empty(cls, v):
        if not v.strip():
            raise ValueError("Query cannot be empty")
        return v

# Pydantic è‡ªåŠ¨éªŒè¯
rag_chain: Runnable[RAGInput, RAGOutput] = ...
```

**ä¸æ¨è**ï¼š

```python
# æ‰‹åŠ¨éªŒè¯
def validate_input(input: dict):
    if not input.get("query"):
        raise ValueError("Missing query")
    if not 1 <= input.get("max_docs", 0) <= 100:
        raise ValueError("Invalid max_docs")
    # ... æ›´å¤šéªŒè¯
```

### 6.3 æ˜ç¡®æ ‡æ³¨ Runnable ç±»å‹

**æ¨è**ï¼š

```python
from langchain_core.runnables import Runnable

# æ˜ç¡®ç±»å‹
retriever: Runnable[str, list[str]] = ...
formatter: Runnable[list[str], str] = ...
llm: Runnable[str, str] = ...

# ç»„åˆæ—¶ IDE ä¼šæ£€æŸ¥ç±»å‹
chain = retriever | formatter | llm  # âœ… ç±»å‹åŒ¹é…
```

**ä¸æ¨è**ï¼š

```python
# æ— ç±»å‹æ ‡æ³¨
retriever = ...
formatter = ...
llm = ...

# IDE æ— æ³•æ£€æŸ¥ç±»å‹
chain = retriever | formatter | llm  # âš ï¸ å¯èƒ½ç±»å‹ä¸åŒ¹é…
```

### 6.4 ä½¿ç”¨ç±»å‹å®ˆå«

**ç±»å‹å®ˆå«**ï¼šè¿è¡Œæ—¶æ£€æŸ¥ç±»å‹

```python
from typing import TypedDict, TYPE_CHECKING

class QueryInput(TypedDict):
    query: str

def is_query_input(obj: dict) -> bool:
    """ç±»å‹å®ˆå«ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯ QueryInput"""
    return isinstance(obj, dict) and "query" in obj

# ä½¿ç”¨
def process(input: dict):
    if is_query_input(input):
        # åœ¨è¿™ä¸ªåˆ†æ”¯ä¸­ï¼ŒIDE çŸ¥é“ input æ˜¯ QueryInput
        query = input["query"]  # âœ… ç±»å‹å®‰å…¨
    else:
        raise ValueError("Invalid input")
```

---

## 7. ç±»å‹æ¨æ–­çš„é™åˆ¶

### 7.1 åŠ¨æ€ç±»å‹çš„é™åˆ¶

**é—®é¢˜**ï¼šPython æ˜¯åŠ¨æ€ç±»å‹è¯­è¨€

```python
# ç±»å‹æç¤ºåªæ˜¯"æç¤º"ï¼Œä¸æ˜¯å¼ºåˆ¶
def process(input: str) -> int:
    return "not an int"  # âš ï¸ IDE è­¦å‘Šï¼Œä½†è¿è¡Œæ—¶ä¸æŠ¥é”™

# è°ƒç”¨
result = process("hello")  # è¿è¡Œæ—¶ä¸ä¼šæ£€æŸ¥ç±»å‹
```

**è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨ Pydantic è¿›è¡Œè¿è¡Œæ—¶éªŒè¯

```python
from pydantic import BaseModel, validator

class Output(BaseModel):
    value: int

    @validator("value")
    def check_type(cls, v):
        if not isinstance(v, int):
            raise TypeError("value must be int")
        return v

# è¿è¡Œæ—¶éªŒè¯
output = Output(value="not an int")  # ğŸ’¥ ValidationError
```

### 7.2 å¤æ‚ç±»å‹æ¨æ–­

**é—®é¢˜**ï¼šå¤æ‚çš„ç±»å‹è½¬æ¢éš¾ä»¥æ¨æ–­

```python
from langchain_core.runnables import RunnableLambda

# å¤æ‚çš„ lambda
complex_transform = RunnableLambda(
    lambda x: {
        "result": [
            {"key": k, "value": v}
            for k, v in x.items()
        ]
    }
)

# IDE éš¾ä»¥æ¨æ–­è¾“å‡ºç±»å‹
chain = input_step | complex_transform | output_step
# âš ï¸ ç±»å‹æ¨æ–­å¯èƒ½ä¸å‡†ç¡®
```

**è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨æ˜ç¡®çš„ç±»å‹æ³¨è§£

```python
from typing import TypedDict, List

class TransformInput(TypedDict):
    data: dict

class TransformOutput(TypedDict):
    result: List[dict]

def complex_transform_typed(input: TransformInput) -> TransformOutput:
    return {
        "result": [
            {"key": k, "value": v}
            for k, v in input["data"].items()
        ]
    }

# æ˜ç¡®ç±»å‹
transform: Runnable[TransformInput, TransformOutput] = RunnableLambda(
    complex_transform_typed
)
```

### 7.3 ç¬¬ä¸‰æ–¹åº“çš„ç±»å‹æ”¯æŒ

**é—®é¢˜**ï¼šæŸäº›åº“ç¼ºå°‘ç±»å‹æç¤º

```python
# æŸäº›æ—§åº“æ²¡æœ‰ç±»å‹æç¤º
from old_library import OldClass

# IDE æ— æ³•æ¨æ–­ç±»å‹
result = OldClass().process(input)  # âš ï¸ ç±»å‹æœªçŸ¥
```

**è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨ type stubs æˆ–æ‰‹åŠ¨æ ‡æ³¨

```python
from typing import cast

# æ‰‹åŠ¨æ ‡æ³¨
result: str = cast(str, OldClass().process(input))

# æˆ–åˆ›å»º type stub æ–‡ä»¶ï¼ˆ.pyiï¼‰
```

---

## 8. å®æˆ˜ç¤ºä¾‹

### 8.1 ç±»å‹å®‰å…¨çš„ RAG ç®¡é“

```python
from typing import TypedDict, List
from pydantic import BaseModel, Field
from langchain_core.runnables import Runnable, RunnableLambda
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.prompts import ChatPromptTemplate
from langchain.output_parsers import PydanticOutputParser

# å®šä¹‰ç±»å‹
class QueryInput(TypedDict):
    query: str
    max_docs: int

class Document(BaseModel):
    content: str
    score: float = Field(ge=0.0, le=1.0)

class RAGOutput(BaseModel):
    answer: str
    sources: List[Document]
    confidence: float = Field(ge=0.0, le=1.0)

# å®šä¹‰æ­¥éª¤
def embed_query(input: QueryInput) -> List[float]:
    embeddings = OpenAIEmbeddings()
    return embeddings.embed_query(input["query"])

def retrieve_docs(input: dict) -> List[Document]:
    # ä½¿ç”¨ embedding æ£€ç´¢
    # æ¨¡æ‹Ÿæ£€ç´¢
    return [
        Document(content="Doc 1", score=0.9),
        Document(content="Doc 2", score=0.8)
    ]

def format_prompt(input: dict) -> dict:
    docs_text = "\n\n".join([doc.content for doc in input["docs"]])
    return {
        "context": docs_text,
        "question": input["query"]
    }

# åˆ›å»ºè§£æå™¨
parser = PydanticOutputParser(pydantic_object=RAGOutput)

# ç»„åˆç®¡é“ï¼ˆç±»å‹å®‰å…¨ï¼‰
from langchain_core.runnables import RunnablePassthrough

rag_chain: Runnable[QueryInput, RAGOutput] = (
    RunnablePassthrough.assign(
        embedding=RunnableLambda(embed_query)
    )
    | RunnablePassthrough.assign(
        docs=RunnableLambda(retrieve_docs)
    )
    | RunnableLambda(format_prompt)
    | ChatPromptTemplate.from_template(
        "Context: {context}\n\nQuestion: {question}\n\n"
        "Provide answer with sources and confidence.\n\n"
        "{format_instructions}"
    )
    | ChatOpenAI(model="gpt-4o-mini")
    | parser
)

# ä½¿ç”¨ï¼ˆç±»å‹å®‰å…¨ï¼‰
result: RAGOutput = rag_chain.invoke({
    "query": "What is LangChain?",
    "max_docs": 5
})

# IDE è‡ªåŠ¨è¡¥å…¨
print(result.answer)
print(result.confidence)
for doc in result.sources:
    print(f"- {doc.content} (score: {doc.score})")
```

### 8.2 ç±»å‹å®‰å…¨çš„å¤šæ­¥æ¨ç†

```python
from typing import TypedDict, List
from pydantic import BaseModel, Field

class ReasoningStep(BaseModel):
    """æ¨ç†æ­¥éª¤"""
    step_number: int
    thought: str
    action: str
    observation: str

class ReasoningOutput(BaseModel):
    """æ¨ç†è¾“å‡º"""
    steps: List[ReasoningStep]
    final_answer: str
    confidence: float = Field(ge=0.0, le=1.0)

# ç±»å‹å®‰å…¨çš„æ¨ç†é“¾
reasoning_chain: Runnable[str, ReasoningOutput] = (
    thought_generator
    | action_executor
    | observation_collector
    | answer_synthesizer
)

# ä½¿ç”¨
result: ReasoningOutput = reasoning_chain.invoke(
    "How many R's are in the word 'strawberry'?"
)

# ç±»å‹å®‰å…¨è®¿é—®
for step in result.steps:
    print(f"Step {step.step_number}: {step.thought}")
print(f"Answer: {result.final_answer}")
```

---

## 9. æ€§èƒ½è€ƒè™‘

### 9.1 ç±»å‹æ£€æŸ¥çš„æ€§èƒ½å¼€é”€

**å…³é”®ç‚¹**ï¼šç±»å‹æ£€æŸ¥åœ¨å¼€å‘æ—¶å®Œæˆï¼Œè¿è¡Œæ—¶é›¶å¼€é”€

```python
# å¼€å‘æ—¶
# - IDE æ£€æŸ¥ç±»å‹ï¼ˆå®æ—¶ï¼‰
# - mypy æ£€æŸ¥ç±»å‹ï¼ˆCI/CDï¼‰

# è¿è¡Œæ—¶
# - ç±»å‹æç¤ºè¢«å¿½ç•¥
# - æ²¡æœ‰æ€§èƒ½å¼€é”€
```

**Pydantic éªŒè¯çš„å¼€é”€**ï¼š

```python
from pydantic import BaseModel
import time

class Data(BaseModel):
    value: int

# éªŒè¯å¼€é”€
start = time.time()
for i in range(10000):
    Data(value=i)
elapsed = time.time() - start
print(f"Pydantic validation: {elapsed:.3f}s")

# æ— éªŒè¯
start = time.time()
for i in range(10000):
    {"value": i}
elapsed = time.time() - start
print(f"No validation: {elapsed:.3f}s")

# ç»“æœï¼šPydantic æœ‰è½»å¾®å¼€é”€ï¼Œä½†æ¢æ¥ç±»å‹å®‰å…¨
```

### 9.2 ä¼˜åŒ–å»ºè®®

**1. åªåœ¨è¾¹ç•ŒéªŒè¯**ï¼š

```python
# âœ… åœ¨è¾“å…¥è¾¹ç•ŒéªŒè¯
def api_endpoint(input: UserInput) -> UserOutput:
    # Pydantic éªŒè¯è¾“å…¥
    validated = UserInput(**input)

    # å†…éƒ¨å¤„ç†ä¸éœ€è¦éªŒè¯
    result = internal_process(validated)

    return result

# âŒ ä¸è¦åœ¨æ¯ä¸ªå†…éƒ¨å‡½æ•°éƒ½éªŒè¯
def internal_process(input: UserInput) -> dict:
    # ä¸éœ€è¦å†æ¬¡éªŒè¯
    pass
```

**2. ä½¿ç”¨ TypedDict è€Œé Pydantic**ï¼ˆå¦‚æœä¸éœ€è¦éªŒè¯ï¼‰ï¼š

```python
# è½»é‡çº§ï¼ˆæ— éªŒè¯ï¼‰
class LightweightInput(TypedDict):
    query: str

# é‡é‡çº§ï¼ˆæœ‰éªŒè¯ï¼‰
class ValidatedInput(BaseModel):
    query: str = Field(min_length=1)

# é€‰æ‹©åˆé€‚çš„
# - å†…éƒ¨æ¥å£ï¼šTypedDict
# - å¤–éƒ¨æ¥å£ï¼šPydantic
```

---

## 10. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ç±»å‹ç³»ç»Ÿçš„ä»·å€¼**ï¼š
   - å¼€å‘æ—¶å‘ç°é”™è¯¯
   - IDE è‡ªåŠ¨è¡¥å…¨
   - é›¶è¿è¡Œæ—¶å¼€é”€

2. **Pydantic v2 é›†æˆ**ï¼š
   - LangChain v0.3+ å®Œå…¨æ”¯æŒ
   - è¿è¡Œæ—¶éªŒè¯
   - ç»“æ„åŒ–è¾“å‡º

3. **æœ€ä½³å®è·µ**ï¼š
   - ä½¿ç”¨ TypedDict å®šä¹‰æ¥å£
   - ä½¿ç”¨ Pydantic è¿›è¡ŒéªŒè¯
   - æ˜ç¡®æ ‡æ³¨ Runnable ç±»å‹
   - ä½¿ç”¨ mypy é™æ€æ£€æŸ¥

4. **IDE æ”¯æŒ**ï¼š
   - VSCode + Python æ‰©å±•
   - PyCharm ç±»å‹æ£€æŸ¥
   - mypy é™æ€åˆ†æ

### å­¦ä¹ æ£€æŸ¥

å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] ä½¿ç”¨ TypedDict å®šä¹‰ç»“æ„åŒ–ç±»å‹
- [ ] ä½¿ç”¨ Pydantic æ¨¡å‹è¿›è¡ŒéªŒè¯
- [ ] ç†è§£ Runnable çš„æ³›å‹ç±»å‹
- [ ] é…ç½® IDE è¿›è¡Œç±»å‹æ£€æŸ¥
- [ ] ä½¿ç”¨ mypy è¿›è¡Œé™æ€åˆ†æ
- [ ] å®ç°ç±»å‹å®‰å…¨çš„ LCEL ç®¡é“
- [ ] ä½¿ç”¨ PydanticOutputParser è§£æè¾“å‡º
- [ ] ä½¿ç”¨ with_structured_output() è·å–ç»“æ„åŒ–è¾“å‡º

---

**ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2026-02-19
**ç»´æŠ¤è€…**: Claude Code

**å‚è€ƒèµ„æº**:
- [LangChain v0.3 Pydantic v2 è¿ç§»](https://changelog.langchain.com/announcements/langchain-v0-3-migrating-to-pydantic-2-for-python-peer-dependencies-for-javascript)
- [Pydantic v2 å·¥å…·é›†æˆ](https://changelog.langchain.com/announcements/improved-pydantic-2-support-with-langchain-tool-apis)
- [Pydantic è¾“å‡ºéªŒè¯æŒ‡å—](https://machinelearningmastery.com/the-complete-guide-to-using-pydantic-for-validating-llm-outputs)

**ä¸‹ä¸€æ­¥**: é˜…è¯» `07_å®æˆ˜ä»£ç _01_åŸºç¡€ç®¡é“ç»„åˆ.md` æŸ¥çœ‹å®é™…ä»£ç ç¤ºä¾‹
