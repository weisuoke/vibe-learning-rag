# 核心概念 02：循环迭代机制

> 深入理解 Agent Core 的单次迭代流程和循环控制机制

---

## 概念定义

**循环迭代机制**是指 Agent Core 在每次循环中执行的完整流程：调用 LLM → 检测工具调用 → 执行工具 → 更新上下文 → 判断是否继续。

**一句话：** 每次迭代就是"问 LLM → 执行工具 → 记录结果"的完整循环。

---

## 单次迭代的完整流程

### 流程图

```
┌─────────────────────────────────────────────────────────┐
│                    单次迭代流程                          │
└─────────────────────────────────────────────────────────┘

1. 调用 LLM
   ├─ 输入：当前上下文（用户消息 + 历史对话 + 工具结果）
   ├─ 输出：助手响应（可能包含工具调用）
   └─ 发出事件：'message'

2. 检测工具调用
   ├─ 解析响应中的 toolCalls 数组
   ├─ 如果为空 → 任务完成，退出循环
   └─ 如果非空 → 继续执行工具

3. 执行工具（可能多个）
   ├─ 对每个工具调用：
   │  ├─ 验证参数（TypeBox + AJV）
   │  ├─ 执行工具函数
   │  ├─ 获取结果（output + details）
   │  └─ 发出事件：'tool_call', 'tool_result'
   └─ 收集所有工具结果

4. 更新上下文
   ├─ 将助手响应追加到上下文
   ├─ 将工具结果追加到上下文
   └─ 上下文累积，供下一轮使用

5. 判断是否继续
   ├─ 如果有工具调用 → 继续下一轮迭代
   └─ 如果无工具调用 → 任务完成，退出循环
```

---

## 详细代码实现

### 完整的单次迭代

```typescript
async function* singleIteration(context: Message[]): AsyncGenerator<Event> {
  // ===== 步骤 1：调用 LLM =====
  console.log('Step 1: Calling LLM...');

  const response = await llm.chat({
    messages: context,
    tools: toolDefinitions,  // 工具定义（schema）
    temperature: 0.7,
    maxTokens: 4096
  });

  // 发出助手消息事件
  yield {
    type: 'message',
    role: 'assistant',
    content: response.content,
    timestamp: Date.now()
  };

  // 将助手响应追加到上下文
  context.push({
    role: 'assistant',
    content: response.content,
    toolCalls: response.toolCalls
  });

  // ===== 步骤 2：检测工具调用 =====
  console.log('Step 2: Detecting tool calls...');

  if (!response.toolCalls || response.toolCalls.length === 0) {
    // 无工具调用 → 任务完成
    yield {
      type: 'done',
      reason: 'no_tool_calls',
      timestamp: Date.now()
    };
    return;  // 退出循环
  }

  console.log(`Found ${response.toolCalls.length} tool calls`);

  // ===== 步骤 3：执行工具 =====
  for (const toolCall of response.toolCalls) {
    console.log(`Step 3: Executing tool: ${toolCall.name}`);

    // 发出工具调用事件
    yield {
      type: 'tool_call',
      toolCall,
      timestamp: Date.now()
    };

    // 3.1 验证参数
    const validator = validators.get(toolCall.name);
    if (!validator(toolCall.params)) {
      // 验证失败 → 返回错误给 LLM
      const errorResult = {
        output: `Error: Invalid parameters\n${JSON.stringify(validator.errors)}`,
        details: { validationErrors: validator.errors }
      };

      yield {
        type: 'tool_result',
        toolCallId: toolCall.id,
        result: errorResult,
        timestamp: Date.now()
      };

      // 将错误结果追加到上下文
      context.push({
        role: 'tool',
        toolCallId: toolCall.id,
        content: errorResult.output
      });

      continue;  // 继续下一个工具调用
    }

    // 3.2 执行工具
    try {
      const executor = toolExecutors.get(toolCall.name);
      const result = await executor(toolCall.params);

      // 发出工具结果事件
      yield {
        type: 'tool_result',
        toolCallId: toolCall.id,
        result,
        timestamp: Date.now()
      };

      // ===== 步骤 4：更新上下文 =====
      context.push({
        role: 'tool',
        toolCallId: toolCall.id,
        content: result.output  // 只将 output 给 LLM
      });

    } catch (error) {
      // 执行错误 → 返回错误给 LLM
      const errorResult = {
        output: `Error: ${error.message}`,
        details: { error: error.stack }
      };

      yield {
        type: 'tool_result',
        toolCallId: toolCall.id,
        result: errorResult,
        timestamp: Date.now()
      };

      context.push({
        role: 'tool',
        toolCallId: toolCall.id,
        content: errorResult.output
      });
    }
  }

  // ===== 步骤 5：判断是否继续 =====
  // 有工具调用 → 继续下一轮迭代（由外层循环控制）
  console.log('Step 5: Iteration complete, continuing to next iteration...');
}
```

---

## "Loop Until Done" 哲学

### Pi-mono 的循环控制

**核心代码：**

```typescript
async function* agentLoop(userMessage: string) {
  const context: Message[] = [
    { role: 'user', content: userMessage }
  ];

  // 无限循环！
  while (true) {
    // 单次迭代
    for await (const event of singleIteration(context)) {
      yield event;

      // 如果是 'done' 事件 → 退出循环
      if (event.type === 'done') {
        return;
      }
    }
  }
}
```

**关键点：**
- `while (true)`：看起来是无限循环
- 实际由 LLM 控制：当 LLM 不再请求工具调用时，自然终止
- 无需 `maxIterations` 限制

---

### 为什么这样设计？

**1. 信任模型的自主性**

```typescript
// ❌ 不信任模型：需要人为限制
for (let i = 0; i < maxIterations; i++) {
  const response = await llm.chat(context);
  // ...
}

// ✅ 信任模型：让模型自己决定
while (true) {
  const response = await llm.chat(context);
  if (!response.toolCalls) break;  // 模型决定停止
  // ...
}
```

**2. 适应任务复杂度**

```typescript
// 简单任务：2-3 次迭代
用户：创建 hello.ts
迭代 1：write('hello.ts', ...)
迭代 2：完成

// 复杂任务：10+ 次迭代
用户：创建 TypeScript 项目
迭代 1：write('package.json', ...)
迭代 2：write('tsconfig.json', ...)
迭代 3：bash('mkdir src')
迭代 4：write('src/index.ts', ...)
迭代 5：bash('npm install')
迭代 6：bash('npm test')
迭代 7：完成
```

**3. 处理不确定性**

```typescript
// 任务：修改配置文件

// 迭代 1：尝试读取
read('config.ts')
→ Error: File not found

// 迭代 2：LLM 看到错误，调整策略
bash('ls -la')
→ 列出文件

// 迭代 3：LLM 发现文件不存在，改为创建
write('config.ts', ...)
→ 成功

// 迭代 4：完成
```

---

## 事件流机制

### 事件类型

```typescript
type Event =
  | { type: 'message'; role: 'assistant'; content: string }
  | { type: 'tool_call'; toolCall: ToolCall }
  | { type: 'tool_result'; toolCallId: string; result: ToolResult }
  | { type: 'done'; reason: string }
  | { type: 'error'; error: Error };
```

---

### 事件发出时机

```typescript
async function* agentLoop(userMessage: string) {
  const context = [{ role: 'user', content: userMessage }];

  while (true) {
    // 1. 调用 LLM → 发出 'message' 事件
    const response = await llm.chat(context);
    yield { type: 'message', content: response.content };

    if (!response.toolCalls) {
      // 2. 无工具调用 → 发出 'done' 事件
      yield { type: 'done', reason: 'no_tool_calls' };
      return;
    }

    for (const call of response.toolCalls) {
      // 3. 工具调用 → 发出 'tool_call' 事件
      yield { type: 'tool_call', toolCall: call };

      const result = await executeTool(call);

      // 4. 工具结果 → 发出 'tool_result' 事件
      yield { type: 'tool_result', result };

      context.push({ role: 'tool', content: result.output });
    }
  }
}
```

---

### UI 监听事件

```typescript
// UI 代码
const agent = new Agent({ ... });

// 监听助手消息
agent.on('message', (event) => {
  console.log('Assistant:', event.content);
  ui.appendMessage('assistant', event.content);
});

// 监听工具调用
agent.on('tool_call', (event) => {
  console.log(`Calling ${event.toolCall.name}...`);
  ui.showToolCall(event.toolCall);
});

// 监听工具结果
agent.on('tool_result', (event) => {
  console.log('Result:', event.result.output);
  ui.showToolResult(event.result);
});

// 监听完成
agent.on('done', (event) => {
  console.log('Task completed:', event.reason);
  ui.showCompletion();
});

// 运行 Agent
for await (const event of agent.run('Create hello.ts')) {
  // 事件已通过 agent.on() 处理
}
```

---

## 上下文累积机制

### Context 数组的演变

```typescript
// 初始状态
context = [
  { role: 'user', content: '创建 hello.ts' }
];

// 迭代 1：LLM 响应
context = [
  { role: 'user', content: '创建 hello.ts' },
  { role: 'assistant', content: '我来创建文件', toolCalls: [...] }
];

// 迭代 1：工具执行
context = [
  { role: 'user', content: '创建 hello.ts' },
  { role: 'assistant', content: '我来创建文件', toolCalls: [...] },
  { role: 'tool', toolCallId: 'call-1', content: 'File created' }
];

// 迭代 2：LLM 响应
context = [
  { role: 'user', content: '创建 hello.ts' },
  { role: 'assistant', content: '我来创建文件', toolCalls: [...] },
  { role: 'tool', toolCallId: 'call-1', content: 'File created' },
  { role: 'assistant', content: '文件已创建完成' }
];

// 迭代 2：无工具调用 → 任务完成
```

---

### Context 的作用

**1. 提供历史信息**

```typescript
// LLM 能看到完整历史
const response = await llm.chat({
  messages: context,  // 包含所有历史消息
  tools: toolDefinitions
});
```

**2. 支持多轮对话**

```typescript
// 用户追问
context.push({ role: 'user', content: '改成 TypeScript' });

// LLM 能理解上下文
const response = await llm.chat({ messages: context });
// LLM 知道之前创建了 hello.ts，现在要改成 TypeScript
```

**3. 工具结果反馈**

```typescript
// 工具结果追加到上下文
context.push({
  role: 'tool',
  content: 'Error: File not found'
});

// LLM 在下一轮看到错误，调整策略
```

---

## 循环终止条件

### 正常终止

**条件：LLM 不再请求工具调用**

```typescript
const response = await llm.chat(context);

if (!response.toolCalls || response.toolCalls.length === 0) {
  // 正常终止
  yield { type: 'done', reason: 'no_tool_calls' };
  return;
}
```

**示例：**

```typescript
// 最后一轮迭代
LLM 响应：{
  content: "文件已创建完成，任务完成。",
  toolCalls: []  // 无工具调用
}

// 循环终止
```

---

### 异常终止（可选）

**Pi-mono 不强制异常终止，但可以添加监控：**

```typescript
let iterationCount = 0;
const MAX_ITERATIONS_WARNING = 50;

while (true) {
  iterationCount++;

  // 监控但不强制终止
  if (iterationCount > MAX_ITERATIONS_WARNING) {
    console.warn(`Agent 已运行 ${iterationCount} 次迭代`);
    // 但仍然继续运行
  }

  const response = await llm.chat(context);
  if (!response.toolCalls) break;
  // ...
}
```

---

## 性能优化

### 1. 并行工具执行

**如果工具之间无依赖，可以并行执行：**

```typescript
// ❌ 串行执行
for (const call of toolCalls) {
  const result = await executeTool(call);
  results.push(result);
}

// ✅ 并行执行
const results = await Promise.all(
  toolCalls.map(call => executeTool(call))
);
```

**注意：** Pi-mono 默认串行执行，因为工具之间可能有依赖（如先 read 再 edit）。

---

### 2. 流式响应

**使用 SSE（Server-Sent Events）实时推送：**

```typescript
// 服务端
async function* streamAgent(userMessage: string) {
  for await (const event of agent.run(userMessage)) {
    // 实时推送事件
    yield `data: ${JSON.stringify(event)}\n\n`;
  }
}

// 客户端
const eventSource = new EventSource('/api/agent');
eventSource.onmessage = (e) => {
  const event = JSON.parse(e.data);
  handleEvent(event);
};
```

---

### 3. Context 压缩

**当 Context 过长时，使用 Compaction：**

```typescript
if (context.length > 100) {
  // 压缩历史消息
  context = await compactContext(context);
}
```

---

## 实际应用场景

### 场景 1：简单任务（2-3 次迭代）

```typescript
// 任务：创建文件
用户：创建 hello.ts

// 迭代 1
LLM: 调用 write('hello.ts', "console.log('hello')")
Tool: File created

// 迭代 2
LLM: 文件已创建完成
Tool: 无工具调用 → 终止
```

---

### 场景 2：复杂任务（10+ 次迭代）

```typescript
// 任务：创建 TypeScript 项目
用户：创建一个 TypeScript 项目

// 迭代 1
LLM: 调用 write('package.json', ...)
Tool: File created

// 迭代 2
LLM: 调用 write('tsconfig.json', ...)
Tool: File created

// 迭代 3
LLM: 调用 bash('mkdir src')
Tool: Directory created

// 迭代 4
LLM: 调用 write('src/index.ts', ...)
Tool: File created

// 迭代 5
LLM: 调用 bash('npm install')
Tool: Dependencies installed

// 迭代 6
LLM: 调用 bash('npm test')
Tool: Tests passed

// 迭代 7
LLM: 项目创建完成
Tool: 无工具调用 → 终止
```

---

### 场景 3：错误恢复（自我纠正）

```typescript
// 任务：修改配置文件
用户：修改 config.ts 的端口为 8080

// 迭代 1：尝试读取
LLM: 调用 read('config.ts')
Tool: Error: File not found

// 迭代 2：LLM 看到错误，调整策略
LLM: 调用 bash('ls -la')
Tool: package.json, src/, README.md

// 迭代 3：LLM 发现文件不存在，改为创建
LLM: 调用 write('config.ts', 'export const port = 8080')
Tool: File created

// 迭代 4：完成
LLM: 配置文件已创建
Tool: 无工具调用 → 终止
```

---

## 总结

**循环迭代机制的核心要点：**

1. **单次迭代**：LLM 调用 → 工具检测 → 工具执行 → 上下文更新
2. **Loop Until Done**：无限循环，由 LLM 决定何时停止
3. **事件流**：每个步骤发出事件，UI 实时更新
4. **上下文累积**：历史消息累积，供 LLM 参考
5. **自我纠正**：错误作为反馈，LLM 调整策略

**关键洞察：**
- 循环由 LLM 控制，不是代码控制
- 每次迭代都是完整的"思考 → 行动 → 反馈"循环
- 上下文累积是 Agent 的"记忆"

**下一步：** 理解循环迭代后，学习工具注册系统（核心概念 03）。
