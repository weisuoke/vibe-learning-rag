# 实战代码：基础验证场景

> 完整可运行的基础请求体验证示例

---

## 场景概述

本文提供4个完整的基础验证场景，涵盖用户注册、商品创建、订单提交和配置更新。所有代码都可以直接运行。

---

## 场景1：用户注册 API

### 需求

- 验证用户名（3-20个字符，只能包含字母、数字、下划线）
- 验证邮箱格式
- 验证密码强度（至少8个字符，包含大小写字母和数字）
- 验证年龄（18-150岁）

### 完整代码

```python
"""
场景1：用户注册 API
演示基础字段验证和自定义验证器
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field, EmailStr, validator
from typing import Optional
import re

app = FastAPI(title="用户注册 API")

# ===== 数据模型 =====

class UserRegister(BaseModel):
    """用户注册请求模型"""

    username: str = Field(
        ...,
        min_length=3,
        max_length=20,
        description="用户名，3-20个字符",
        example="alice123"
    )

    email: EmailStr = Field(
        ...,
        description="邮箱地址",
        example="alice@example.com"
    )

    password: str = Field(
        ...,
        min_length=8,
        max_length=50,
        description="密码，至少8个字符",
        example="SecurePass123"
    )

    age: int = Field(
        ...,
        ge=18,
        le=150,
        description="年龄，18-150岁",
        example=25
    )

    bio: Optional[str] = Field(
        default="",
        max_length=500,
        description="个人简介",
        example="Hello, I'm Alice!"
    )

    # ===== 自定义验证器 =====

    @validator('username')
    def username_alphanumeric_underscore(cls, v):
        """验证用户名只能包含字母、数字、下划线"""
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('用户名只能包含字母、数字、下划线')
        # 不能以数字开头
        if v[0].isdigit():
            raise ValueError('用户名不能以数字开头')
        return v

    @validator('password')
    def password_strength(cls, v):
        """验证密码强度"""
        # 至少包含一个大写字母
        if not re.search(r'[A-Z]', v):
            raise ValueError('密码必须包含至少一个大写字母')
        # 至少包含一个小写字母
        if not re.search(r'[a-z]', v):
            raise ValueError('密码必须包含至少一个小写字母')
        # 至少包含一个数字
        if not re.search(r'\d', v):
            raise ValueError('密码必须包含至少一个数字')
        return v

    @validator('bio')
    def bio_not_only_whitespace(cls, v):
        """验证个人简介不能只包含空格"""
        if v and not v.strip():
            raise ValueError('个人简介不能只包含空格')
        return v.strip() if v else ""


class UserResponse(BaseModel):
    """用户响应模型（不包含密码）"""

    id: int
    username: str
    email: str
    age: int
    bio: str

    class Config:
        json_schema_extra = {
            "example": {
                "id": 1,
                "username": "alice123",
                "email": "alice@example.com",
                "age": 25,
                "bio": "Hello, I'm Alice!"
            }
        }


# ===== API 端点 =====

# 模拟数据库
users_db = []
user_id_counter = 1


@app.post("/register", response_model=UserResponse, status_code=201)
async def register_user(user: UserRegister):
    """
    用户注册端点

    验证规则：
    - 用户名：3-20个字符，只能包含字母、数字、下划线，不能以数字开头
    - 邮箱：有效的邮箱格式
    - 密码：至少8个字符，包含大小写字母和数字
    - 年龄：18-150岁
    """
    global user_id_counter

    # 检查用户名是否已存在
    if any(u["username"] == user.username for u in users_db):
        raise HTTPException(status_code=400, detail="用户名已存在")

    # 检查邮箱是否已存在
    if any(u["email"] == user.email for u in users_db):
        raise HTTPException(status_code=400, detail="邮箱已被注册")

    # 创建用户（实际应用中应该加密密码）
    new_user = {
        "id": user_id_counter,
        "username": user.username,
        "email": user.email,
        "password": user.password,  # 实际应该加密
        "age": user.age,
        "bio": user.bio
    }

    users_db.append(new_user)
    user_id_counter += 1

    # 返回用户信息（不包含密码）
    return UserResponse(
        id=new_user["id"],
        username=new_user["username"],
        email=new_user["email"],
        age=new_user["age"],
        bio=new_user["bio"]
    )


@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    """获取用户信息"""
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        raise HTTPException(status_code=404, detail="用户不存在")

    return UserResponse(
        id=user["id"],
        username=user["username"],
        email=user["email"],
        age=user["age"],
        bio=user["bio"]
    )


# ===== 测试代码 =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("场景1：用户注册 API")
    print("=" * 50)
    print("\n启动服务器...")
    print("访问 http://localhost:8000/docs 查看 API 文档")
    print("\n测试用例：")
    print("1. 正确的注册请求：")
    print('   POST /register')
    print('   {"username": "alice123", "email": "alice@example.com", "password": "SecurePass123", "age": 25}')
    print("\n2. 用户名太短：")
    print('   {"username": "ab", ...}  # 错误：用户名至少3个字符')
    print("\n3. 密码不符合强度要求：")
    print('   {"password": "weak"}  # 错误：密码必须包含大小写字母和数字')
    print("\n4. 年龄不在范围内：")
    print('   {"age": 15}  # 错误：年龄必须在18-150之间')
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 运行输出示例

```bash
# 启动服务器
python scenario1_user_register.py

# 测试正确的请求
curl -X POST "http://localhost:8000/register" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "alice123",
    "email": "alice@example.com",
    "password": "SecurePass123",
    "age": 25,
    "bio": "Hello, I am Alice!"
  }'

# 响应（201）
{
  "id": 1,
  "username": "alice123",
  "email": "alice@example.com",
  "age": 25,
  "bio": "Hello, I am Alice!"
}

# 测试错误的请求（用户名太短）
curl -X POST "http://localhost:8000/register" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "ab",
    "email": "bob@example.com",
    "password": "SecurePass123",
    "age": 25
  }'

# 响应（422）
{
  "detail": [
    {
      "loc": ["body", "username"],
      "msg": "ensure this value has at least 3 characters",
      "type": "value_error.any_str.min_length"
    }
  ]
}
```

---

## 场景2：商品创建 API

### 需求

- 验证商品名称（1-100个字符）
- 验证价格（大于0）
- 验证库存（非负整数）
- 验证标签（1-10个标签，每个标签1-20个字符）
- 验证折扣（0-1之间的浮点数）

### 完整代码

```python
"""
场景2：商品创建 API
演示数字约束、集合验证和可选字段
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field, validator
from typing import List, Optional
from datetime import datetime

app = FastAPI(title="商品管理 API")

# ===== 数据模型 =====

class ProductCreate(BaseModel):
    """商品创建请求模型"""

    name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="商品名称",
        example="MacBook Pro 16"
    )

    description: Optional[str] = Field(
        default="",
        max_length=1000,
        description="商品描述",
        example="高性能笔记本电脑"
    )

    price: float = Field(
        ...,
        gt=0,
        description="商品价格（元）",
        example=19999.99
    )

    stock: int = Field(
        ...,
        ge=0,
        description="库存数量",
        example=100
    )

    tags: List[str] = Field(
        default_factory=list,
        min_items=1,
        max_items=10,
        description="商品标签",
        example=["电子产品", "笔记本", "Apple"]
    )

    discount: float = Field(
        default=0.0,
        ge=0.0,
        le=1.0,
        description="折扣（0-1之间，0表示无折扣）",
        example=0.1
    )

    is_active: bool = Field(
        default=True,
        description="是否上架",
        example=True
    )

    # ===== 自定义验证器 =====

    @validator('name')
    def name_not_only_whitespace(cls, v):
        """验证商品名称不能只包含空格"""
        if not v.strip():
            raise ValueError('商品名称不能只包含空格')
        return v.strip()

    @validator('tags')
    def tags_valid(cls, v):
        """验证标签"""
        if not v:
            raise ValueError('至少需要一个标签')

        # 去重并转换为小写
        unique_tags = list(set(tag.lower().strip() for tag in v if tag.strip()))

        if not unique_tags:
            raise ValueError('标签不能为空')

        # 验证每个标签的长度
        for tag in unique_tags:
            if len(tag) < 1 or len(tag) > 20:
                raise ValueError(f'标签 "{tag}" 长度必须在1-20个字符之间')

        return unique_tags

    @validator('price')
    def price_two_decimals(cls, v):
        """价格最多保留两位小数"""
        return round(v, 2)


class ProductResponse(BaseModel):
    """商品响应模型"""

    id: int
    name: str
    description: str
    price: float
    stock: int
    tags: List[str]
    discount: float
    final_price: float  # 折后价
    is_active: bool
    created_at: datetime

    class Config:
        json_schema_extra = {
            "example": {
                "id": 1,
                "name": "MacBook Pro 16",
                "description": "高性能笔记本电脑",
                "price": 19999.99,
                "stock": 100,
                "tags": ["电子产品", "笔记本", "apple"],
                "discount": 0.1,
                "final_price": 17999.99,
                "is_active": True,
                "created_at": "2024-01-01T00:00:00"
            }
        }


# ===== API 端点 =====

# 模拟数据库
products_db = []
product_id_counter = 1


@app.post("/products", response_model=ProductResponse, status_code=201)
async def create_product(product: ProductCreate):
    """
    创建商品端点

    验证规则：
    - 名称：1-100个字符，不能只包含空格
    - 价格：大于0，最多两位小数
    - 库存：非负整数
    - 标签：1-10个标签，每个标签1-20个字符
    - 折扣：0-1之间的浮点数
    """
    global product_id_counter

    # 计算折后价
    final_price = round(product.price * (1 - product.discount), 2)

    # 创建商品
    new_product = {
        "id": product_id_counter,
        "name": product.name,
        "description": product.description,
        "price": product.price,
        "stock": product.stock,
        "tags": product.tags,
        "discount": product.discount,
        "final_price": final_price,
        "is_active": product.is_active,
        "created_at": datetime.now()
    }

    products_db.append(new_product)
    product_id_counter += 1

    return ProductResponse(**new_product)


@app.get("/products/{product_id}", response_model=ProductResponse)
async def get_product(product_id: int):
    """获取商品信息"""
    product = next((p for p in products_db if p["id"] == product_id), None)
    if not product:
        raise HTTPException(status_code=404, detail="商品不存在")

    return ProductResponse(**product)


@app.get("/products", response_model=List[ProductResponse])
async def list_products(
    skip: int = Field(default=0, ge=0),
    limit: int = Field(default=10, ge=1, le=100)
):
    """获取商品列表"""
    return [ProductResponse(**p) for p in products_db[skip:skip + limit]]


# ===== 测试代码 =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("场景2：商品创建 API")
    print("=" * 50)
    print("\n启动服务器...")
    print("访问 http://localhost:8000/docs 查看 API 文档")
    print("\n测试用例：")
    print("1. 正确的创建请求：")
    print('   POST /products')
    print('   {"name": "MacBook Pro", "price": 19999.99, "stock": 100, "tags": ["电子产品"], "discount": 0.1}')
    print("\n2. 价格为负数：")
    print('   {"price": -100}  # 错误：价格必须大于0')
    print("\n3. 标签为空：")
    print('   {"tags": []}  # 错误：至少需要一个标签')
    print("\n4. 折扣超出范围：")
    print('   {"discount": 1.5}  # 错误：折扣必须在0-1之间')
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 场景3：订单提交 API

### 需求

- 验证订单项列表（至少1个订单项）
- 验证每个订单项的商品ID和数量
- 验证收货地址信息
- 验证总金额与订单项金额一致

### 完整代码

```python
"""
场景3：订单提交 API
演示嵌套模型验证和跨字段验证
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field, validator, root_validator
from typing import List
from datetime import datetime

app = FastAPI(title="订单管理 API")

# ===== 数据模型 =====

class OrderItem(BaseModel):
    """订单项模型"""

    product_id: int = Field(..., gt=0, description="商品ID")
    quantity: int = Field(..., ge=1, le=100, description="购买数量")
    price: float = Field(..., gt=0, description="单价")

    @validator('price')
    def price_two_decimals(cls, v):
        """价格最多保留两位小数"""
        return round(v, 2)


class Address(BaseModel):
    """收货地址模型"""

    recipient: str = Field(..., min_length=2, max_length=50, description="收货人")
    phone: str = Field(..., pattern=r'^\d{11}$', description="手机号")
    province: str = Field(..., min_length=2, max_length=20, description="省份")
    city: str = Field(..., min_length=2, max_length=20, description="城市")
    district: str = Field(..., min_length=2, max_length=20, description="区县")
    detail: str = Field(..., min_length=5, max_length=200, description="详细地址")

    @validator('recipient', 'province', 'city', 'district', 'detail')
    def not_only_whitespace(cls, v):
        """验证不能只包含空格"""
        if not v.strip():
            raise ValueError('不能只包含空格')
        return v.strip()


class OrderCreate(BaseModel):
    """订单创建请求模型"""

    items: List[OrderItem] = Field(..., min_items=1, description="订单项列表")
    address: Address = Field(..., description="收货地址")
    total_amount: float = Field(..., gt=0, description="订单总金额")
    note: str = Field(default="", max_length=500, description="订单备注")

    @root_validator
    def check_total_amount(cls, values):
        """验证总金额与订单项金额一致"""
        items = values.get('items', [])
        total = values.get('total_amount', 0)

        # 计算订单项总金额
        calculated_total = sum(item.price * item.quantity for item in items)
        calculated_total = round(calculated_total, 2)

        # 允许0.01的误差（浮点数精度问题）
        if abs(calculated_total - total) > 0.01:
            raise ValueError(
                f'订单总金额不正确：期望 {calculated_total}，实际 {total}'
            )

        # 更新为计算后的总金额
        values['total_amount'] = calculated_total
        return values


class OrderResponse(BaseModel):
    """订单响应模型"""

    id: int
    items: List[OrderItem]
    address: Address
    total_amount: float
    note: str
    status: str
    created_at: datetime


# ===== API 端点 =====

# 模拟数据库
orders_db = []
order_id_counter = 1


@app.post("/orders", response_model=OrderResponse, status_code=201)
async def create_order(order: OrderCreate):
    """
    创建订单端点

    验证规则：
    - 订单项：至少1个，每个商品ID>0，数量1-100
    - 收货地址：所有字段必填，手机号11位数字
    - 总金额：必须等于所有订单项金额之和
    """
    global order_id_counter

    # 创建订单
    new_order = {
        "id": order_id_counter,
        "items": [item.dict() for item in order.items],
        "address": order.address.dict(),
        "total_amount": order.total_amount,
        "note": order.note,
        "status": "pending",
        "created_at": datetime.now()
    }

    orders_db.append(new_order)
    order_id_counter += 1

    return OrderResponse(**new_order)


@app.get("/orders/{order_id}", response_model=OrderResponse)
async def get_order(order_id: int):
    """获取订单信息"""
    order = next((o for o in orders_db if o["id"] == order_id), None)
    if not order:
        raise HTTPException(status_code=404, detail="订单不存在")

    return OrderResponse(**order)


# ===== 测试代码 =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("场景3：订单提交 API")
    print("=" * 50)
    print("\n启动服务器...")
    print("访问 http://localhost:8000/docs 查看 API 文档")
    print("\n测试用例：")
    print("1. 正确的订单：")
    print('   POST /orders')
    print('   {')
    print('     "items": [{"product_id": 1, "quantity": 2, "price": 99.99}],')
    print('     "address": {...},')
    print('     "total_amount": 199.98')
    print('   }')
    print("\n2. 总金额不正确：")
    print('   {"total_amount": 100}  # 错误：与订单项金额不符')
    print("\n3. 订单项为空：")
    print('   {"items": []}  # 错误：至少需要一个订单项')
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 核心要点

1. **Field 约束** - 使用 min_length、max_length、ge、le 等约束
2. **自定义验证器** - 使用 @validator 实现复杂验证逻辑
3. **嵌套模型** - 使用 Pydantic 模型作为字段类型
4. **跨字段验证** - 使用 @root_validator 验证多个字段的关系
5. **响应模型** - 使用 response_model 过滤敏感信息

---

**版本：** v1.0
**最后更新：** 2026-02-11
