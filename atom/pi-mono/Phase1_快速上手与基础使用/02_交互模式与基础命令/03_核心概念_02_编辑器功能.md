# 核心概念 02：编辑器功能

> 深入理解 Pi 编辑器的四大核心功能：@文件引用、Tab 补全、!命令执行、多行输入

---

## 概念定义

**Pi 编辑器是底部输入区域，提供 @文件引用（上下文注入）、Tab 补全（路径自动完成）、!命令执行（输出捕获）、多行输入（复杂讨论）四大核心功能，实现高效的 AI 编码协作。**

---

## 功能 1：@文件引用（File Reference）

### 原理

**@文件引用将文件内容注入到 LLM 上下文中，让 AI 能够"看到"代码。**

```typescript
// 工作流程
async function handleFileReference(input: string) {
  // 1. 解析 @引用
  const references = parseFileReferences(input);
  // references = ['@src/auth.ts', '@src/api.ts']

  // 2. 读取文件内容
  const fileContents = await Promise.all(
    references.map(ref => fs.readFile(ref.path, 'utf-8'))
  );

  // 3. 构建 LLM 上下文
  const context = {
    userMessage: input.replace(/@\S+/g, ''),  // 移除 @引用
    files: references.map((ref, i) => ({
      path: ref.path,
      content: fileContents[i]
    }))
  };

  // 4. 发送给 LLM
  const response = await llm.chat([
    {
      role: 'user',
      content: `Files:\n${context.files.map(f =>
        `\n--- ${f.path} ---\n${f.content}`
      ).join('\n')}\n\nQuestion: ${context.userMessage}`
    }
  ]);

  return response;
}
```

---

### 三种使用模式

#### 模式 1：精确路径

```bash
# 直接指定完整路径
@src/auth.ts
@src/api/users.ts
@tests/auth.test.ts
```

**适用场景：**
- 你知道确切的文件路径
- 文件路径不长
- 需要引用特定文件

---

#### 模式 2：模糊搜索

```bash
# 输入部分文件名
@auth

# Pi 会列出所有匹配的文件
Suggestions:
  src/auth.ts
  src/auth/index.ts
  src/api/auth.ts
  tests/auth.test.ts
```

**实现原理：**
```typescript
async function fuzzySearchFiles(query: string): Promise<string[]> {
  // 1. 使用 glob 搜索
  const pattern = `**/*${query}*`;
  const files = await glob(pattern, {
    ignore: ['node_modules/**', '.git/**', 'dist/**']
  });

  // 2. 按相关性排序
  return files.sort((a, b) => {
    // 文件名完全匹配优先
    const aBasename = path.basename(a);
    const bBasename = path.basename(b);

    if (aBasename.includes(query) && !bBasename.includes(query)) {
      return -1;
    }
    if (!aBasename.includes(query) && bBasename.includes(query)) {
      return 1;
    }

    // 路径更短的优先
    return a.length - b.length;
  });
}
```

**适用场景：**
- 不记得完整路径
- 文件名很长
- 探索项目结构

---

#### 模式 3：多文件引用

```bash
# 同时引用多个文件
@src/auth.ts @src/api.ts @src/types.ts

# 或者分行
@src/auth.ts
@src/api.ts
@src/types.ts
```

**LLM 上下文构建：**
```typescript
// 多文件上下文
const context = `
Files:

--- src/auth.ts ---
export function authenticate(token: string) {
  // ...
}

--- src/api.ts ---
export async function fetchUser(id: string) {
  // ...
}

--- src/types.ts ---
export interface User {
  id: string;
  name: string;
}

Question: 请审查这三个文件的代码质量
`;
```

**适用场景：**
- 代码审查（审查多个相关文件）
- 重构（需要同时修改多个文件）
- 架构分析（理解模块间关系）

---

### 性能优化

```typescript
// 优化 1：文件大小限制
const MAX_FILE_SIZE = 100 * 1024;  // 100KB

async function readFileWithLimit(path: string): Promise<string> {
  const stats = await fs.stat(path);

  if (stats.size > MAX_FILE_SIZE) {
    // 文件太大，只读取前 N 行
    const content = await readFirstNLines(path, 500);
    return `${content}\n\n[File truncated: too large]`;
  }

  return fs.readFile(path, 'utf-8');
}

// 优化 2：缓存文件内容
const fileCache = new Map<string, { content: string; mtime: number }>();

async function readFileWithCache(path: string): Promise<string> {
  const stats = await fs.stat(path);
  const cached = fileCache.get(path);

  if (cached && cached.mtime === stats.mtimeMs) {
    return cached.content;
  }

  const content = await fs.readFile(path, 'utf-8');
  fileCache.set(path, { content, mtime: stats.mtimeMs });

  return content;
}

// 优化 3：并行读取
async function readMultipleFiles(paths: string[]): Promise<string[]> {
  return Promise.all(paths.map(readFileWithCache));
}
```

---

## 功能 2：Tab 补全（Tab Completion）

### 原理

**Tab 补全通过文件系统扫描和模糊匹配，提供路径自动完成。**

```typescript
// Tab 补全实现
class TabCompletion {
  async trigger(input: string, cursorPosition: number): Promise<string[]> {
    // 1. 提取光标前的文本
    const textBeforeCursor = input.substring(0, cursorPosition);

    // 2. 检查是否在 @引用中
    const match = textBeforeCursor.match(/@(\S*)$/);
    if (!match) {
      return [];
    }

    const query = match[1];

    // 3. 分割路径
    const parts = query.split('/');
    const directory = parts.slice(0, -1).join('/') || '.';
    const prefix = parts[parts.length - 1];

    // 4. 扫描目录
    const entries = await fs.readdir(directory, { withFileTypes: true });

    // 5. 过滤匹配项
    const suggestions = entries
      .filter(entry => entry.name.startsWith(prefix))
      .map(entry => {
        const fullPath = path.join(directory, entry.name);
        return entry.isDirectory() ? `${fullPath}/` : fullPath;
      });

    return suggestions;
  }

  // 应用补全
  apply(input: string, cursorPosition: number, suggestion: string): string {
    const textBeforeCursor = input.substring(0, cursorPosition);
    const textAfterCursor = input.substring(cursorPosition);

    // 替换 @引用
    const replaced = textBeforeCursor.replace(/@\S*$/, `@${suggestion}`);

    return replaced + textAfterCursor;
  }
}
```

---

### 补全策略

#### 策略 1：目录优先

```typescript
// 目录显示在前面
const suggestions = [
  'src/',           // 目录
  'tests/',         // 目录
  'package.json',   // 文件
  'README.md'       // 文件
];
```

---

#### 策略 2：智能排序

```typescript
function sortSuggestions(suggestions: string[], query: string): string[] {
  return suggestions.sort((a, b) => {
    // 1. 前缀匹配优先
    const aStartsWith = a.startsWith(query);
    const bStartsWith = b.startsWith(query);
    if (aStartsWith && !bStartsWith) return -1;
    if (!aStartsWith && bStartsWith) return 1;

    // 2. 包含匹配次之
    const aIncludes = a.includes(query);
    const bIncludes = b.includes(query);
    if (aIncludes && !bIncludes) return -1;
    if (!aIncludes && bIncludes) return 1;

    // 3. 字母顺序
    return a.localeCompare(b);
  });
}
```

---

#### 策略 3：忽略模式

```typescript
const IGNORE_PATTERNS = [
  'node_modules/**',
  '.git/**',
  'dist/**',
  'build/**',
  '.next/**',
  'coverage/**',
  '*.log',
  '.DS_Store'
];

async function getFilteredSuggestions(directory: string): Promise<string[]> {
  const entries = await fs.readdir(directory, { withFileTypes: true });

  return entries.filter(entry => {
    const fullPath = path.join(directory, entry.name);

    // 检查是否匹配忽略模式
    return !IGNORE_PATTERNS.some(pattern =>
      minimatch(fullPath, pattern)
    );
  });
}
```

---

### UI 交互

```typescript
// 补全 UI 状态
interface CompletionState {
  active: boolean;
  suggestions: string[];
  selectedIndex: number;
  query: string;
}

// 键盘事件处理
async function handleKeyPress(key: string, state: CompletionState) {
  switch (key) {
    case 'tab':
      if (!state.active) {
        // 触发补全
        state.suggestions = await tabCompletion.trigger(input, cursor);
        state.active = true;
        state.selectedIndex = 0;
      } else {
        // 循环选择
        state.selectedIndex = (state.selectedIndex + 1) % state.suggestions.length;
      }
      break;

    case 'shift+tab':
      // 反向循环
      state.selectedIndex = (state.selectedIndex - 1 + state.suggestions.length) % state.suggestions.length;
      break;

    case 'enter':
      if (state.active) {
        // 应用选中的补全
        const suggestion = state.suggestions[state.selectedIndex];
        input = tabCompletion.apply(input, cursor, suggestion);
        state.active = false;
      }
      break;

    case 'escape':
      // 取消补全
      state.active = false;
      break;

    default:
      // 其他按键：关闭补全
      if (state.active) {
        state.active = false;
      }
      break;
  }
}
```

---

## 功能 3：!命令执行（Command Execution）

### 原理

**!命令执行通过 child_process 执行 shell 命令，并捕获输出。**

```typescript
// 命令执行实现
async function executeCommand(command: string, sendOutput: boolean): Promise<string> {
  return new Promise((resolve, reject) => {
    const child = spawn('sh', ['-c', command], {
      cwd: process.cwd(),
      env: process.env,
      shell: true
    });

    let stdout = '';
    let stderr = '';

    child.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    child.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    child.on('close', (code) => {
      const output = stdout + stderr;

      if (sendOutput) {
        // !command：发送输出给 AI
        resolve(output);
      } else {
        // !!command：不发送输出
        resolve('');
      }
    });

    child.on('error', (error) => {
      reject(error);
    });
  });
}
```

---

### 两种模式

#### 模式 1：!command（发送输出）

```bash
# 执行命令并将输出发送给 AI
!npm test

# AI 会收到测试输出
[Command: npm test]
FAIL src/auth.test.ts
  ● authenticate › should reject invalid tokens

    expect(received).toBe(expected)

    Expected: false
    Received: true

      42 |   it('should reject invalid tokens', () => {
      43 |     const result = authenticate('invalid');
    > 44 |     expect(result).toBe(false);
         |                    ^
      45 |   });

# 然后你可以问 AI
请分析这个测试失败的原因
```

**适用场景：**
- 测试失败需要分析
- 编译错误需要修复
- Git 状态需要决策
- 日志输出需要解释

---

#### 模式 2：!!command（不发送输出）

```bash
# 只执行命令，不发送输出给 AI
!!npm run build
!!git add .
!!docker-compose up -d
```

**适用场景：**
- 构建打包（输出太长）
- Git 操作（不需要 AI 看）
- 启动服务（后台运行）
- 清理操作（无需分析）

---

### 安全考虑

```typescript
// 安全检查
function validateCommand(command: string): { safe: boolean; reason?: string } {
  // 1. 禁止危险命令
  const dangerousCommands = [
    'rm -rf /',
    'dd if=/dev/zero',
    'mkfs',
    ':(){ :|:& };:',  // Fork bomb
  ];

  for (const dangerous of dangerousCommands) {
    if (command.includes(dangerous)) {
      return { safe: false, reason: 'Dangerous command detected' };
    }
  }

  // 2. 警告破坏性操作
  const destructivePatterns = [
    /rm\s+-rf/,
    /git\s+reset\s+--hard/,
    /git\s+clean\s+-fd/,
  ];

  for (const pattern of destructivePatterns) {
    if (pattern.test(command)) {
      // 需要用户确认
      return { safe: false, reason: 'Destructive operation requires confirmation' };
    }
  }

  return { safe: true };
}

// 执行前检查
async function safeExecuteCommand(command: string): Promise<string> {
  const validation = validateCommand(command);

  if (!validation.safe) {
    const confirmed = await askUserConfirmation(
      `Warning: ${validation.reason}\nDo you want to proceed?`
    );

    if (!confirmed) {
      throw new Error('Command execution cancelled');
    }
  }

  return executeCommand(command, true);
}
```

---

### 输出处理

```typescript
// 输出大小限制
const MAX_OUTPUT_SIZE = 10 * 1024;  // 10KB

function truncateOutput(output: string): string {
  if (output.length <= MAX_OUTPUT_SIZE) {
    return output;
  }

  const half = Math.floor(MAX_OUTPUT_SIZE / 2);
  return (
    output.substring(0, half) +
    '\n\n[... output truncated ...]\n\n' +
    output.substring(output.length - half)
  );
}

// ANSI 颜色代码移除
function stripAnsiCodes(output: string): string {
  return output.replace(/\x1b\[[0-9;]*m/g, '');
}

// 格式化输出
function formatCommandOutput(command: string, output: string): string {
  return `
[Command: ${command}]
\`\`\`
${stripAnsiCodes(truncateOutput(output))}
\`\`\`
`;
}
```

---

## 功能 4：多行输入（Multiline Input）

### 原理

**多行输入通过特殊按键组合（Shift+Enter 或 Ctrl+Enter）实现换行。**

```typescript
// 多行输入处理
class MultilineEditor {
  private lines: string[] = [''];
  private cursor: { line: number; column: number } = { line: 0, column: 0 };

  handleKeyPress(key: string, modifiers: { shift: boolean; ctrl: boolean }) {
    if (key === 'enter') {
      if (modifiers.shift || modifiers.ctrl) {
        // Shift+Enter 或 Ctrl+Enter：换行
        this.insertNewline();
      } else {
        // Enter：提交
        this.submit();
      }
    } else if (key === 'backspace') {
      this.handleBackspace();
    } else if (key === 'delete') {
      this.handleDelete();
    } else if (key === 'up') {
      this.moveCursorUp();
    } else if (key === 'down') {
      this.moveCursorDown();
    } else if (key === 'left') {
      this.moveCursorLeft();
    } else if (key === 'right') {
      this.moveCursorRight();
    } else {
      this.insertCharacter(key);
    }
  }

  private insertNewline() {
    const currentLine = this.lines[this.cursor.line];
    const before = currentLine.substring(0, this.cursor.column);
    const after = currentLine.substring(this.cursor.column);

    this.lines[this.cursor.line] = before;
    this.lines.splice(this.cursor.line + 1, 0, after);

    this.cursor.line++;
    this.cursor.column = 0;
  }

  private handleBackspace() {
    if (this.cursor.column > 0) {
      // 删除当前行的字符
      const line = this.lines[this.cursor.line];
      this.lines[this.cursor.line] =
        line.substring(0, this.cursor.column - 1) +
        line.substring(this.cursor.column);
      this.cursor.column--;
    } else if (this.cursor.line > 0) {
      // 合并到上一行
      const currentLine = this.lines[this.cursor.line];
      const previousLine = this.lines[this.cursor.line - 1];

      this.lines[this.cursor.line - 1] = previousLine + currentLine;
      this.lines.splice(this.cursor.line, 1);

      this.cursor.line--;
      this.cursor.column = previousLine.length;
    }
  }

  getContent(): string {
    return this.lines.join('\n');
  }
}
```

---

### 平台差异

```typescript
// 不同平台的换行键
const NEWLINE_KEY = {
  darwin: 'shift+enter',   // macOS
  linux: 'shift+enter',    // Linux
  win32: 'ctrl+enter'      // Windows
};

function getNewlineKey(): string {
  return NEWLINE_KEY[process.platform] || 'shift+enter';
}

// 显示提示
function getInputHint(): string {
  const key = getNewlineKey();
  return `Press ${key} for newline, Enter to submit`;
}
```

---

### UI 渲染

```typescript
// 多行输入渲染
function renderMultilineEditor(editor: MultilineEditor): string[] {
  const lines: string[] = [];

  // 渲染提示符（只在第一行）
  lines.push(chalk.bold('> ') + editor.lines[0]);

  // 渲染其他行（缩进对齐）
  for (let i = 1; i < editor.lines.length; i++) {
    lines.push('  ' + editor.lines[i]);
  }

  // 渲染光标
  const cursorLine = editor.cursor.line;
  const cursorColumn = editor.cursor.column + (cursorLine === 0 ? 2 : 2);  // 考虑提示符

  lines[cursorLine] =
    lines[cursorLine].substring(0, cursorColumn) +
    chalk.inverse(' ') +  // 光标
    lines[cursorLine].substring(cursorColumn + 1);

  return lines;
}
```

---

## 综合应用场景

### 场景 1：代码审查

```bash
# 引用多个文件并请求审查
@src/auth.ts @src/api.ts @tests/auth.test.ts

请审查这三个文件：
1. 代码质量如何？
2. 是否有安全问题？
3. 测试覆盖是否充分？
```

---

### 场景 2：Bug 修复

```bash
# 执行测试并分析失败原因
!npm test

测试失败了，请帮我：
1. 分析失败原因
2. 定位问题代码
3. 提供修复方案
```

---

### 场景 3：重构建议

```bash
# 引用文件并请求重构
@src/legacy-code.js

这是一个旧的 JavaScript 文件，请帮我：
1. 转换为 TypeScript
2. 使用现代 ES6+ 语法
3. 添加类型注解
4. 优化代码结构
```

---

### 场景 4：架构分析

```bash
# 引用多个模块文件
@src/auth/ @src/api/ @src/database/

请分析这个项目的架构：
1. 模块间的依赖关系
2. 是否有循环依赖？
3. 是否符合单一职责原则？
4. 有哪些改进建议？
```

---

## 快速参考

```typescript
// Pi 编辑器四大功能
interface EditorFeatures {
  // 1. @文件引用
  fileReference: {
    syntax: '@path/to/file',
    modes: ['精确路径', '模糊搜索', '多文件引用'],
    trigger: '@',
  };

  // 2. Tab 补全
  tabCompletion: {
    trigger: 'Tab',
    navigation: ['Tab: 下一个', 'Shift+Tab: 上一个'],
    apply: 'Enter',
    cancel: 'Escape',
  };

  // 3. !命令执行
  commandExecution: {
    sendOutput: '!command',
    silentExecution: '!!command',
    examples: ['!npm test', '!!npm run build'],
  };

  // 4. 多行输入
  multilineInput: {
    newline: 'Shift+Enter (macOS/Linux) | Ctrl+Enter (Windows)',
    submit: 'Enter',
  };
}
```

---

**来源：**
- [Pi Coding Agent README](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/README.md) - 2026-02
- [Editor 实现](https://github.com/badlogic/pi-mono/tree/main/packages/coding-agent/src/editor) - 2026-02
- [Keybindings 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/keybindings.md) - 2026-02
