# 自定义Tool - 实战代码04：文件操作工具

> 完整可运行的文件操作Tool示例，涵盖读写文件、搜索文件、解析文档等场景

---

## 概述

文件操作Tool让Agent能够读取、写入、搜索文件。本文提供安全的文件操作实现。

**技术要点：**
- 路径验证（防止路径遍历攻击）
- 异步文件操作（aiofiles）
- 文件格式处理（JSON、CSV、PDF）
- 错误处理

---

## 环境准备

```bash
# 安装依赖
uv add aiofiles pypdf langchain langchain-openai python-dotenv
```

---

## 示例1：读取文件Tool

### 完整代码

```python
"""
文件读取Tool示例
演示：安全地读取文件内容
"""

import os
import aiofiles
from pathlib import Path
from langchain.tools import tool
from pydantic import BaseModel, Field
from dotenv import load_dotenv

load_dotenv()

# 定义允许访问的目录
ALLOWED_DIR = Path("/Users/wuxiao/Documents/allowed_files").resolve()

# ===== 1. 路径验证 =====
def validate_path(file_path: str) -> Path:
    """验证文件路径安全性"""
    # 解析为绝对路径
    path = Path(file_path).resolve()

    # 检查是否在允许的目录内
    if not str(path).startswith(str(ALLOWED_DIR)):
        raise ValueError(f"不允许访问路径：{file_path}")

    return path

# ===== 2. 定义参数Schema =====
class FileInput(BaseModel):
    """文件操作参数"""
    file_path: str = Field(
        description="文件路径，相对于允许目录的路径",
        min_length=1,
        max_length=500
    )

# ===== 3. 定义Tool =====
@tool(args_schema=FileInput)
async def read_file(file_path: str) -> str:
    """读取文件内容

    读取指定文件的文本内容。

    适用场景：
    - 用户询问"读取config.json文件"
    - 用户询问"查看README.md的内容"
    - 用户询问"打开data.txt"

    Args:
        file_path: 文件路径

    Returns:
        文件内容

    注意事项：
    - 只能读取允许目录内的文件
    - 仅支持文本文件
    - 大文件可能读取较慢
    """
    try:
        # 验证路径
        path = validate_path(file_path)

        # 检查文件是否存在
        if not path.exists():
            return f"错误：文件{file_path}不存在。"

        if not path.is_file():
            return f"错误：{file_path}不是文件。"

        # 读取文件
        async with aiofiles.open(path, 'r', encoding='utf-8') as f:
            content = await f.read()

        # 限制返回长度
        if len(content) > 10000:
            return f"文件内容（前10000字符）：\n{content[:10000]}\n\n...（文件太大，已截断）"

        return f"文件内容：\n{content}"

    except ValueError as e:
        return f"错误：{str(e)}"

    except UnicodeDecodeError:
        return f"错误：文件{file_path}不是文本文件。"

    except Exception as e:
        return f"读取失败：{str(e)}"

# ===== 4. 写入文件Tool =====
@tool
async def write_file(file_path: str, content: str) -> str:
    """写入文件

    将内容写入指定文件。

    Args:
        file_path: 文件路径
        content: 文件内容

    Returns:
        写入结果
    """
    try:
        path = validate_path(file_path)

        # 创建父目录
        path.parent.mkdir(parents=True, exist_ok=True)

        # 写入文件
        async with aiofiles.open(path, 'w', encoding='utf-8') as f:
            await f.write(content)

        return f"文件已写入：{file_path}（{len(content)}字符）"

    except ValueError as e:
        return f"错误：{str(e)}"

    except Exception as e:
        return f"写入失败：{str(e)}"

# ===== 5. 搜索文件Tool =====
@tool
async def search_files(pattern: str) -> str:
    """搜索文件

    在允许目录中搜索匹配的文件。

    Args:
        pattern: 搜索模式，如'*.txt'、'config.*'

    Returns:
        匹配的文件列表
    """
    try:
        # 搜索文件
        matches = list(ALLOWED_DIR.glob(f"**/{pattern}"))

        if not matches:
            return f"未找到匹配'{pattern}'的文件。"

        # 格式化结果
        files = []
        for path in matches[:20]:  # 限制20个
            rel_path = path.relative_to(ALLOWED_DIR)
            size = path.stat().st_size
            files.append(f"- {rel_path} ({size}字节)")

        result = f"找到{len(matches)}个文件：\n" + "\n".join(files)

        if len(matches) > 20:
            result += f"\n\n...（还有{len(matches) - 20}个文件未显示）"

        return result

    except Exception as e:
        return f"搜索失败：{str(e)}"

# ===== 6. 测试 =====
async def test_file_tools():
    """测试文件工具"""
    print("=== 测试文件工具 ===\n")

    # 测试1：写入文件
    print("测试1：写入文件")
    result = await write_file.ainvoke({
        "file_path": "test.txt",
        "content": "Hello, World!"
    })
    print(result)
    print()

    # 测试2：读取文件
    print("测试2：读取文件")
    result = await read_file.ainvoke({"file_path": "test.txt"})
    print(result)
    print()

    # 测试3：搜索文件
    print("测试3：搜索文件")
    result = await search_files.ainvoke({"pattern": "*.txt"})
    print(result)
    print()

if __name__ == "__main__":
    import asyncio
    asyncio.run(test_file_tools())
```

---

## 示例2：PDF解析Tool

```python
"""
PDF解析Tool示例
演示：读取PDF文件内容
"""

import pypdf
from langchain.tools import tool
from pathlib import Path

@tool
async def read_pdf(file_path: str) -> str:
    """读取PDF文件

    提取PDF文件的文本内容。

    Args:
        file_path: PDF文件路径

    Returns:
        PDF文本内容
    """
    try:
        path = validate_path(file_path)

        if not path.exists():
            return f"错误：文件{file_path}不存在。"

        # 读取PDF
        reader = pypdf.PdfReader(str(path))

        # 提取所有页面的文本
        text = ""
        for page in reader.pages:
            text += page.extract_text() + "\n"

        if not text.strip():
            return f"错误：PDF文件{file_path}没有可提取的文本。"

        # 限制长度
        if len(text) > 10000:
            return f"PDF内容（前10000字符）：\n{text[:10000]}\n\n...（内容太长，已截断）"

        return f"PDF内容：\n{text}"

    except ValueError as e:
        return f"错误：{str(e)}"

    except Exception as e:
        return f"读取PDF失败：{str(e)}"
```

---

## 示例3：JSON文件Tool

```python
"""
JSON文件Tool示例
演示：读写JSON文件
"""

import json
import aiofiles
from langchain.tools import tool

@tool
async def read_json(file_path: str) -> str:
    """读取JSON文件

    读取并解析JSON文件。

    Args:
        file_path: JSON文件路径

    Returns:
        JSON内容（格式化）
    """
    try:
        path = validate_path(file_path)

        async with aiofiles.open(path, 'r', encoding='utf-8') as f:
            content = await f.read()

        # 解析JSON
        data = json.loads(content)

        # 格式化输出
        formatted = json.dumps(data, indent=2, ensure_ascii=False)

        return f"JSON内容：\n{formatted}"

    except json.JSONDecodeError as e:
        return f"错误：JSON格式错误 - {str(e)}"

    except ValueError as e:
        return f"错误：{str(e)}"

    except Exception as e:
        return f"读取失败：{str(e)}"

@tool
async def write_json(file_path: str, data: dict) -> str:
    """写入JSON文件

    将数据写入JSON文件。

    Args:
        file_path: JSON文件路径
        data: 要写入的数据（字典）

    Returns:
        写入结果
    """
    try:
        path = validate_path(file_path)

        # 格式化JSON
        content = json.dumps(data, indent=2, ensure_ascii=False)

        # 写入文件
        async with aiofiles.open(path, 'w', encoding='utf-8') as f:
            await f.write(content)

        return f"JSON已写入：{file_path}"

    except ValueError as e:
        return f"错误：{str(e)}"

    except Exception as e:
        return f"写入失败：{str(e)}"
```

---

## 最佳实践

### 1. 路径验证（安全关键）

```python
# ✅ 推荐：严格验证路径
def validate_path(file_path: str) -> Path:
    path = Path(file_path).resolve()
    if not str(path).startswith(str(ALLOWED_DIR)):
        raise ValueError("不允许访问")
    return path

# ❌ 危险：不验证路径
def read_file(file_path: str):
    with open(file_path) as f:  # 可能被路径遍历攻击
        return f.read()
```

### 2. 异步文件操作

```python
# ✅ 推荐：异步读写
async with aiofiles.open(path, 'r') as f:
    content = await f.read()

# ❌ 不推荐：同步读写（阻塞）
with open(path, 'r') as f:
    content = f.read()
```

### 3. 错误处理

```python
try:
    content = await read_file(path)
except FileNotFoundError:
    return "文件不存在"
except PermissionError:
    return "没有权限"
except UnicodeDecodeError:
    return "不是文本文件"
```

### 4. 大文件处理

```python
# 限制读取长度
if len(content) > 10000:
    content = content[:10000] + "\n...（已截断）"
```

---

## 安全注意事项

### 1. 防止路径遍历

```python
# ❌ 危险
file_path = "../../../etc/passwd"  # 可能访问系统文件

# ✅ 安全
path = Path(file_path).resolve()
if not str(path).startswith(str(ALLOWED_DIR)):
    raise ValueError("不允许访问")
```

### 2. 限制文件大小

```python
# 检查文件大小
if path.stat().st_size > 10 * 1024 * 1024:  # 10MB
    return "文件太大，无法读取"
```

### 3. 限制文件类型

```python
# 只允许特定扩展名
ALLOWED_EXTENSIONS = {'.txt', '.json', '.md', '.csv'}
if path.suffix not in ALLOWED_EXTENSIONS:
    return "不支持的文件类型"
```

---

## 总结

文件操作Tool的核心：
1. **路径验证**：防止路径遍历攻击
2. **异步操作**：使用aiofiles
3. **错误处理**：友好的错误提示
4. **安全限制**：文件大小、类型、目录

**记住：** 文件操作Tool必须严格验证路径，防止安全漏洞！
