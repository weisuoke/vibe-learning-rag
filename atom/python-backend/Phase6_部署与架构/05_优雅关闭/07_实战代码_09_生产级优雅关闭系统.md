# 实战代码：生产级优雅关闭系统

> 完整的生产级优雅关闭系统实现

---

## 代码说明

本示例演示一个完整的生产级优雅关闭系统，整合了所有核心功能：
- 信号处理
- 请求排空
- 资源清理
- 异步任务管理
- 超时控制
- 分阶段关闭
- 监控和日志

**运行环境：**
- Python 3.13+
- FastAPI
- SQLAlchemy (async)
- Redis (async)

---

## 完整代码

```python
"""
生产级优雅关闭系统
演示：完整的优雅关闭实现，包含所有核心功能

运行方式：
    python 07_实战代码_09_生产级优雅关闭系统.py

测试方式：
    1. 启动应用
    2. 发送多个不同类型的请求
    3. 按 Ctrl+C 测试优雅关闭
"""

import signal
import asyncio
import sys
import time
from contextlib import asynccontextmanager
from typing import Set, Dict, Optional
from dataclasses import dataclass
from enum import Enum

from fastapi import FastAPI, Request, BackgroundTasks
from fastapi.responses import JSONResponse, StreamingResponse
from sqlalchemy.ext.asyncio import create_async_engine, AsyncEngine
from redis.asyncio import Redis
import structlog
import uvicorn

# ===== 1. 配置 =====
@dataclass
class ShutdownConfig:
    """优雅关闭配置"""
    request_draining_timeout: int = 30
    background_tasks_timeout: int = 10
    resource_cleanup_timeout: int = 10
    global_timeout: int = 60

config = ShutdownConfig()

# ===== 2. 日志配置 =====
structlog.configure(
    processors=[
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.add_log_level,
        structlog.dev.ConsoleRenderer()
    ]
)
logger = structlog.get_logger()

# ===== 3. 全局状态 =====
class ShutdownState(Enum):
    """关闭状态"""
    RUNNING = "running"
    DRAINING = "draining"
    CLEANING = "cleaning"
    SHUTDOWN = "shutdown"

shutdown_event = asyncio.Event()
shutdown_state = ShutdownState.RUNNING
accepting_requests = True
active_requests = 0
background_tasks_set: Set[asyncio.Task] = set()
streaming_tasks: Set[asyncio.Task] = set()

# 统计信息
stats = {
    "total_requests": 0,
    "completed_requests": 0,
    "rejected_requests": 0,
    "background_tasks_completed": 0,
    "background_tasks_cancelled": 0,
}

# ===== 4. 资源管理器 =====
class ResourceManager:
    """资源管理器"""

    def __init__(self):
        self.db_engine: Optional[AsyncEngine] = None
        self.redis_client: Optional[Redis] = None
        self.initialized = False

    async def initialize(self):
        """初始化资源"""
        logger.info("初始化资源")

        # 数据库
        self.db_engine = create_async_engine(
            "sqlite+aiosqlite:///./test.db",
            pool_size=10,
            max_overflow=20,
        )

        # Redis
        try:
            self.redis_client = Redis.from_url(
                "redis://localhost:6379/0",
                socket_connect_timeout=5,
            )
            await self.redis_client.ping()
            logger.info("Redis 连接成功")
        except Exception as e:
            logger.warning("Redis 连接失败", error=str(e))
            self.redis_client = None

        self.initialized = True
        logger.info("资源初始化完成")

    async def cleanup(self, timeout: int = 10):
        """清理资源"""
        logger.info("开始资源清理", timeout=timeout)

        # Redis
        if self.redis_client:
            try:
                await asyncio.wait_for(
                    self.redis_client.close(),
                    timeout=timeout
                )
                logger.info("Redis 已关闭")
            except asyncio.TimeoutError:
                logger.warning("Redis 关闭超时")
            except Exception as e:
                logger.error("Redis 关闭失败", error=str(e))

        # 数据库
        if self.db_engine:
            try:
                await asyncio.wait_for(
                    self.db_engine.dispose(),
                    timeout=timeout
                )
                logger.info("数据库已关闭")
            except asyncio.TimeoutError:
                logger.warning("数据库关闭超时")
            except Exception as e:
                logger.error("数据库关闭失败", error=str(e))

        logger.info("资源清理完成")

resource_manager = ResourceManager()

# ===== 5. 信号处理器 =====
def signal_handler(signum, frame):
    """信号处理器"""
    signal_name = signal.Signals(signum).name
    logger.info("收到信号", signal=signal_name, signum=signum)
    shutdown_event.set()

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

# ===== 6. lifespan 上下文管理器 =====
@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    logger.info("应用启动")

    # 初始化资源
    await resource_manager.initialize()

    # 启动关闭监听器
    asyncio.create_task(shutdown_monitor())

    logger.info("应用启动完成")

    yield

    logger.info("应用关闭")

app = FastAPI(title="生产级优雅关闭系统", lifespan=lifespan)

# ===== 7. 请求排空中间件 =====
@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    """请求排空中间件"""
    global active_requests, stats

    # 检查是否正在关闭
    if not accepting_requests:
        stats["rejected_requests"] += 1
        return JSONResponse(
            status_code=503,
            content={
                "error": "Server is shutting down",
                "state": shutdown_state.value,
            },
            headers={"Retry-After": "10"}
        )

    # 记录请求
    stats["total_requests"] += 1
    active_requests += 1

    try:
        response = await call_next(request)
        stats["completed_requests"] += 1
        return response

    finally:
        active_requests -= 1

# ===== 8. 示例路由 =====
@app.get("/")
async def root():
    """根路由"""
    return {
        "message": "生产级优雅关闭系统",
        "state": shutdown_state.value,
        "stats": stats,
    }

@app.get("/fast")
async def fast_endpoint():
    """快速端点（1秒）"""
    await asyncio.sleep(1)
    return {"message": "Fast response"}

@app.get("/slow")
async def slow_endpoint():
    """慢速端点（10秒，支持中断）"""
    for i in range(10):
        if shutdown_event.is_set():
            logger.info("慢速端点被中断", step=i)
            return {"message": "Interrupted", "step": i}

        await asyncio.sleep(1)

    return {"message": "Slow response completed"}

@app.post("/background")
async def background_endpoint(background_tasks: BackgroundTasks):
    """后台任务端点"""
    task = asyncio.create_task(background_worker())
    background_tasks_set.add(task)
    task.add_done_callback(background_tasks_set.discard)

    return {"message": "Background task started"}

@app.get("/stream")
async def stream_endpoint():
    """流式响应端点"""
    async def generate():
        task = asyncio.current_task()
        streaming_tasks.add(task)

        try:
            for i in range(20):
                if shutdown_event.is_set():
                    yield f"data: {{'type': 'end', 'reason': 'shutdown'}}\n\n"
                    break

                yield f"data: {{'chunk': {i}}}\n\n"
                await asyncio.sleep(0.5)

        finally:
            streaming_tasks.discard(task)

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )

@app.get("/status")
async def status_endpoint():
    """状态端点"""
    return {
        "state": shutdown_state.value,
        "accepting_requests": accepting_requests,
        "active_requests": active_requests,
        "background_tasks": len(background_tasks_set),
        "streaming_tasks": len(streaming_tasks),
        "stats": stats,
    }

# ===== 9. 后台任务 =====
async def background_worker():
    """后台工作线程"""
    try:
        for i in range(10):
            if shutdown_event.is_set():
                logger.info("后台任务被中断", step=i)
                stats["background_tasks_cancelled"] += 1
                return

            await asyncio.sleep(1)

        stats["background_tasks_completed"] += 1
        logger.info("后台任务完成")

    except asyncio.CancelledError:
        logger.info("后台任务被取消")
        stats["background_tasks_cancelled"] += 1
        raise

# ===== 10. 优雅关闭逻辑 =====
class GracefulShutdownManager:
    """优雅关闭管理器"""

    def __init__(self, config: ShutdownConfig):
        self.config = config
        self.start_time: Optional[float] = None

    def remaining_time(self) -> float:
        """计算剩余时间"""
        if self.start_time is None:
            return self.config.global_timeout

        elapsed = time.time() - self.start_time
        return max(0, self.config.global_timeout - elapsed)

    async def execute_stage(
        self,
        stage_name: str,
        stage_func,
        stage_timeout: int
    ) -> bool:
        """执行一个阶段"""
        # 计算实际超时时间
        actual_timeout = min(stage_timeout, self.remaining_time())

        if actual_timeout <= 0:
            logger.warning("全局超时，跳过阶段", stage=stage_name)
            return False

        logger.info(
            "执行阶段",
            stage=stage_name,
            timeout=actual_timeout,
            remaining=self.remaining_time()
        )

        try:
            await asyncio.wait_for(
                stage_func(),
                timeout=actual_timeout
            )
            logger.info("阶段完成", stage=stage_name)
            return True

        except asyncio.TimeoutError:
            logger.warning("阶段超时", stage=stage_name, timeout=actual_timeout)
            return False

        except Exception as e:
            logger.error("阶段失败", stage=stage_name, error=str(e))
            return False

    async def wait_for_requests(self):
        """等待请求完成"""
        global accepting_requests, shutdown_state
        accepting_requests = False
        shutdown_state = ShutdownState.DRAINING

        logger.info("等待请求完成", active_requests=active_requests)

        while active_requests > 0:
            await asyncio.sleep(0.1)

        logger.info("所有请求已完成")

    async def cleanup_background_tasks(self):
        """清理后台任务"""
        logger.info("清理后台任务", count=len(background_tasks_set))

        if not background_tasks_set:
            return

        # 等待任务完成
        try:
            await asyncio.gather(*background_tasks_set, return_exceptions=True)
        except Exception as e:
            logger.error("后台任务清理失败", error=str(e))

        logger.info("后台任务已清理")

    async def cleanup_streaming_tasks(self):
        """清理流式响应任务"""
        logger.info("清理流式响应", count=len(streaming_tasks))

        if not streaming_tasks:
            return

        # 等待任务完成
        try:
            await asyncio.gather(*streaming_tasks, return_exceptions=True)
        except Exception as e:
            logger.error("流式响应清理失败", error=str(e))

        logger.info("流式响应已清理")

    async def cleanup_resources(self):
        """清理资源"""
        global shutdown_state
        shutdown_state = ShutdownState.CLEANING

        await resource_manager.cleanup(
            timeout=self.config.resource_cleanup_timeout
        )

    async def shutdown(self):
        """执行优雅关闭"""
        global shutdown_state

        self.start_time = time.time()

        logger.info(
            "开始优雅关闭",
            global_timeout=self.config.global_timeout
        )

        # 阶段1：请求排空
        await self.execute_stage(
            "请求排空",
            self.wait_for_requests,
            self.config.request_draining_timeout
        )

        # 阶段2：流式响应清理
        await self.execute_stage(
            "流式响应清理",
            self.cleanup_streaming_tasks,
            10
        )

        # 阶段3：后台任务清理
        await self.execute_stage(
            "后台任务清理",
            self.cleanup_background_tasks,
            self.config.background_tasks_timeout
        )

        # 阶段4：资源清理
        await self.execute_stage(
            "资源清理",
            self.cleanup_resources,
            self.config.resource_cleanup_timeout
        )

        # 打印统计
        elapsed = time.time() - self.start_time
        logger.info(
            "优雅关闭完成",
            elapsed=f"{elapsed:.2f}s",
            stats=stats
        )

        shutdown_state = ShutdownState.SHUTDOWN
        sys.exit(0)

shutdown_manager = GracefulShutdownManager(config)

async def shutdown_monitor():
    """监听关闭信号"""
    await shutdown_event.wait()
    await shutdown_manager.shutdown()

# ===== 11. 主函数 =====
def main():
    """主函数"""
    print("="*60)
    print("生产级优雅关闭系统")
    print("="*60 + "\n")

    print("配置:")
    print(f"  请求排空超时: {config.request_draining_timeout}秒")
    print(f"  后台任务超时: {config.background_tasks_timeout}秒")
    print(f"  资源清理超时: {config.resource_cleanup_timeout}秒")
    print(f"  全局超时: {config.global_timeout}秒")
    print()

    print("测试端点:")
    print("  GET  /           - 根路由")
    print("  GET  /fast       - 快速端点（1秒）")
    print("  GET  /slow       - 慢速端点（10秒）")
    print("  POST /background - 后台任务")
    print("  GET  /stream     - 流式响应")
    print("  GET  /status     - 状态查询")
    print()

    print("测试方式:")
    print("  1. 发送多个不同类型的请求")
    print("  2. 按 Ctrl+C 测试优雅关闭")
    print("  3. 观察日志输出")
    print()

    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info"
    )

if __name__ == "__main__":
    main()
```

---

## 测试脚本

创建测试脚本 `test_graceful_shutdown.sh`：

```bash
#!/bin/bash

echo "=== 测试生产级优雅关闭系统 ==="
echo

# 1. 发送快速请求
echo "1. 发送快速请求..."
curl -s http://localhost:8000/fast &

# 2. 发送慢速请求
echo "2. 发送慢速请求..."
curl -s http://localhost:8000/slow &

# 3. 启动后台任务
echo "3. 启动后台任务..."
curl -s -X POST http://localhost:8000/background &

# 4. 启动流式响应
echo "4. 启动流式响应..."
curl -s http://localhost:8000/stream &

# 等待1秒
sleep 1

# 5. 查看状态
echo
echo "5. 查看状态..."
curl -s http://localhost:8000/status | python -m json.tool

# 等待2秒
sleep 2

# 6. 发送 SIGTERM
echo
echo "6. 发送 SIGTERM 信号..."
PID=$(pgrep -f "python.*07_实战代码_09")
if [ -n "$PID" ]; then
    echo "进程 PID: $PID"
    kill -SIGTERM $PID
else
    echo "未找到进程"
fi

echo
echo "=== 测试完成 ==="
```

运行测试：

```bash
chmod +x test_graceful_shutdown.sh
./test_graceful_shutdown.sh
```

---

## 预期输出

### 启动时

```
============================================================
生产级优雅关闭系统
============================================================

配置:
  请求排空超时: 30秒
  后台任务超时: 10秒
  资源清理超时: 10秒
  全局超时: 60秒

测试端点:
  GET  /           - 根路由
  GET  /fast       - 快速端点（1秒）
  GET  /slow       - 慢速端点（10秒）
  POST /background - 后台任务
  GET  /stream     - 流式响应
  GET  /status     - 状态查询

2026-02-13T02:05:19.803Z [info     ] 应用启动
2026-02-13T02:05:19.850Z [info     ] 初始化资源
2026-02-13T02:05:19.900Z [info     ] Redis 连接成功
2026-02-13T02:05:19.950Z [info     ] 资源初始化完成
2026-02-13T02:05:20.000Z [info     ] 应用启动完成
```

### 优雅关闭时

```
2026-02-13T02:05:25.000Z [info     ] 收到信号                signal=SIGTERM signum=15
2026-02-13T02:05:25.010Z [info     ] 开始优雅关闭            global_timeout=60
2026-02-13T02:05:25.020Z [info     ] 执行阶段                stage=请求排空 timeout=30 remaining=60.0
2026-02-13T02:05:25.030Z [info     ] 等待请求完成            active_requests=2
2026-02-13T02:05:26.040Z [info     ] 所有请求已完成
2026-02-13T02:05:26.050Z [info     ] 阶段完成                stage=请求排空
2026-02-13T02:05:26.060Z [info     ] 执行阶段                stage=流式响应清理 timeout=10 remaining=59.0
2026-02-13T02:05:26.070Z [info     ] 清理流式响应            count=1
2026-02-13T02:05:26.500Z [info     ] 流式响应已清理
2026-02-13T02:05:26.510Z [info     ] 阶段完成                stage=流式响应清理
2026-02-13T02:05:26.520Z [info     ] 执行阶段                stage=后台任务清理 timeout=10 remaining=58.5
2026-02-13T02:05:26.530Z [info     ] 清理后台任务            count=1
2026-02-13T02:05:27.540Z [info     ] 后台任务被中断          step=3
2026-02-13T02:05:27.550Z [info     ] 后台任务已清理
2026-02-13T02:05:27.560Z [info     ] 阶段完成                stage=后台任务清理
2026-02-13T02:05:27.570Z [info     ] 执行阶段                stage=资源清理 timeout=10 remaining=57.5
2026-02-13T02:05:27.580Z [info     ] 开始资源清理            timeout=10
2026-02-13T02:05:27.650Z [info     ] Redis 已关闭
2026-02-13T02:05:27.700Z [info     ] 数据库已关闭
2026-02-13T02:05:27.710Z [info     ] 资源清理完成
2026-02-13T02:05:27.720Z [info     ] 阶段完成                stage=资源清理
2026-02-13T02:05:27.730Z [info     ] 优雅关闭完成            elapsed=2.72s stats={'total_requests': 4, 'completed_requests': 2, 'rejected_requests': 0, 'background_tasks_completed': 0, 'background_tasks_cancelled': 1}
```

---

## 核心特性

### 1. 分阶段关闭

- 请求排空
- 流式响应清理
- 后台任务清理
- 资源清理

### 2. 超时控制

- 全局超时
- 分阶段超时
- 动态剩余时间计算

### 3. 状态管理

- RUNNING：正常运行
- DRAINING：请求排空中
- CLEANING：资源清理中
- SHUTDOWN：已关闭

### 4. 统计信息

- 总请求数
- 完成请求数
- 拒绝请求数
- 后台任务统计

### 5. 结构化日志

- 使用 structlog
- 包含上下文信息
- 易于分析和监控

---

## 总结

本示例演示了一个完整的生产级优雅关闭系统，包含：

1. **完整的关闭流程**：请求排空 → 任务清理 → 资源清理
2. **超时控制**：全局超时 + 分阶段超时
3. **状态管理**：清晰的状态转换
4. **监控和日志**：结构化日志 + 统计信息
5. **错误处理**：每个阶段的异常处理

**关键要点：**
- 分阶段执行，每个阶段独立超时
- 使用结构化日志记录关键事件
- 收集统计信息用于监控
- 优雅降级，超时后继续下一阶段

**下一步：** 学习如何在 Kubernetes 环境中配置优雅关闭。
