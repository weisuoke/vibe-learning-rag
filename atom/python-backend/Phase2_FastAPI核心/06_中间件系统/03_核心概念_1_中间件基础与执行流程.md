# 核心概念 1：中间件基础与执行流程

本文详细讲解 FastAPI 中间件的基础概念和执行流程。

---

## 1. 什么是中间件？

### 1.1 定义

**中间件（Middleware）是一个函数，它在每个请求到达路由处理函数之前和响应返回客户端之后执行。**

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def my_middleware(request: Request, call_next):
    # 请求到达路由之前执行
    print("Before request")

    # 调用下一个中间件或路由处理函数
    response = await call_next(request)

    # 响应返回客户端之前执行
    print("After request")

    return response
```

### 1.2 中间件的三个要素

**1. 接收请求对象（Request）**

中间件接收原始的 HTTP 请求对象，可以访问：
- 请求方法（GET、POST 等）
- 请求路径（/users、/api/chat 等）
- 请求头（Authorization、Content-Type 等）
- 客户端信息（IP 地址、User-Agent 等）

```python
@app.middleware("http")
async def inspect_request(request: Request, call_next):
    print(f"Method: {request.method}")
    print(f"Path: {request.url.path}")
    print(f"Headers: {request.headers}")
    print(f"Client: {request.client.host}")

    response = await call_next(request)
    return response
```

**2. 调用下一个处理器（call_next）**

`call_next` 是一个异步函数，它会：
- 调用下一个中间件（如果有）
- 或者调用路由处理函数（如果没有更多中间件）
- 返回响应对象

```python
@app.middleware("http")
async def my_middleware(request: Request, call_next):
    # call_next 会调用下一个中间件或路由
    response = await call_next(request)
    # response 是最终的响应对象
    return response
```

**3. 返回响应对象（Response）**

中间件必须返回一个响应对象，可以：
- 直接返回 `call_next()` 的结果
- 修改响应对象后返回
- 创建新的响应对象返回（提前返回）

```python
from fastapi.responses import JSONResponse

@app.middleware("http")
async def modify_response(request: Request, call_next):
    response = await call_next(request)

    # 修改响应头
    response.headers["X-Custom-Header"] = "MyValue"

    return response

@app.middleware("http")
async def early_return(request: Request, call_next):
    if request.url.path == "/blocked":
        # 提前返回，不调用 call_next
        return JSONResponse(
            {"error": "This path is blocked"},
            status_code=403
        )

    response = await call_next(request)
    return response
```

---

## 2. 中间件的执行流程

### 2.1 洋葱模型（Onion Model）

FastAPI 的中间件使用**洋葱模型**执行，这是一个非常重要的概念。

**什么是洋葱模型？**

想象一个洋葱，有多层：
- 最外层：第一个注册的中间件
- 中间层：第二个注册的中间件
- 最内层：路由处理函数

请求从外到内穿过每一层，响应从内到外返回每一层。

```
请求流程：
客户端 → 中间件1 → 中间件2 → 中间件3 → 路由 → 中间件3 → 中间件2 → 中间件1 → 客户端
         ↓before  ↓before  ↓before  ↓     ↑after   ↑after   ↑after
```

### 2.2 执行顺序示例

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def middleware_1(request: Request, call_next):
    print("1: before")
    response = await call_next(request)
    print("1: after")
    return response

@app.middleware("http")
async def middleware_2(request: Request, call_next):
    print("2: before")
    response = await call_next(request)
    print("2: after")
    return response

@app.middleware("http")
async def middleware_3(request: Request, call_next):
    print("3: before")
    response = await call_next(request)
    print("3: after")
    return response

@app.get("/test")
async def test():
    print("Route handler")
    return {"message": "ok"}

# 访问 /test 的输出：
# 1: before
# 2: before
# 3: before
# Route handler
# 3: after
# 2: after
# 1: after
```

**关键点：**
- 先注册的中间件在**最外层**
- 后注册的中间件在**最内层**
- 请求从外到内，响应从内到外

### 2.3 为什么是洋葱模型？

因为每个中间件都要：
1. 在请求到达下一层之前做一些事（before）
2. 调用 `await call_next(request)` 让请求继续传递
3. 在响应返回上一层之前做一些事（after）

这就像剥洋葱，一层一层进去，再一层一层出来。

**实际应用：**

```python
@app.middleware("http")
async def timing_middleware(request: Request, call_next):
    # Before: 记录开始时间
    start_time = time.time()

    # 调用下一层
    response = await call_next(request)

    # After: 计算耗时
    duration = time.time() - start_time
    response.headers["X-Process-Time"] = str(duration)

    return response
```

---

## 3. 中间件的注册方式

### 3.1 装饰器方式（推荐）

使用 `@app.middleware("http")` 装饰器注册中间件。

```python
@app.middleware("http")
async def my_middleware(request: Request, call_next):
    # 中间件逻辑
    response = await call_next(request)
    return response
```

**优点：**
- 简单直观
- 适合简单的中间件
- 代码紧凑

**缺点：**
- 不能传递初始化参数
- 不能有状态

### 3.2 类方式

使用类实现中间件，继承 `BaseHTTPMiddleware`。

```python
from starlette.middleware.base import BaseHTTPMiddleware

class MyMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, custom_param: str):
        super().__init__(app)
        self.custom_param = custom_param

    async def dispatch(self, request: Request, call_next):
        print(f"Custom param: {self.custom_param}")
        response = await call_next(request)
        return response

# 注册
app.add_middleware(MyMiddleware, custom_param="value")
```

**优点：**
- 可以传递初始化参数
- 可以有状态（实例变量）
- 适合复杂的中间件

**缺点：**
- 代码稍微复杂一些

### 3.3 内置中间件

FastAPI 提供了一些内置中间件，可以直接使用。

```python
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware

# CORS 中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# GZip 压缩中间件
app.add_middleware(GZipMiddleware, minimum_size=1000)

# 可信主机中间件
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["example.com", "*.example.com"]
)
```

---

## 4. 中间件的执行时机

### 4.1 请求前处理（Before）

在 `await call_next(request)` 之前的代码，会在请求到达路由之前执行。

**典型用途：**
- 记录请求日志
- 验证认证信息
- 检查限流
- 修改请求对象

```python
@app.middleware("http")
async def before_request(request: Request, call_next):
    # 请求前处理
    print(f"Incoming request: {request.method} {request.url.path}")

    # 验证认证
    token = request.headers.get("authorization")
    if not token:
        return JSONResponse({"error": "Unauthorized"}, status_code=401)

    # 设置请求状态
    request.state.start_time = time.time()

    response = await call_next(request)
    return response
```

### 4.2 响应后处理（After）

在 `await call_next(request)` 之后的代码，会在响应返回客户端之前执行。

**典型用途：**
- 添加响应头
- 记录响应日志
- 计算请求耗时
- 修改响应内容

```python
@app.middleware("http")
async def after_request(request: Request, call_next):
    response = await call_next(request)

    # 响应后处理
    print(f"Response status: {response.status_code}")

    # 添加响应头
    response.headers["X-Custom-Header"] = "MyValue"

    # 计算耗时
    if hasattr(request.state, "start_time"):
        duration = time.time() - request.state.start_time
        response.headers["X-Process-Time"] = f"{duration:.3f}"

    return response
```

### 4.3 提前返回（Early Return）

如果不调用 `call_next()`，直接返回响应，可以拦截请求。

**典型用途：**
- 认证失败
- 限流超限
- 维护模式
- 路径黑名单

```python
@app.middleware("http")
async def early_return_middleware(request: Request, call_next):
    # 维护模式
    if os.getenv("MAINTENANCE_MODE") == "true":
        return JSONResponse(
            {"error": "Service under maintenance"},
            status_code=503
        )

    # 路径黑名单
    if request.url.path in ["/blocked", "/forbidden"]:
        return JSONResponse(
            {"error": "Access denied"},
            status_code=403
        )

    # 继续处理
    response = await call_next(request)
    return response
```

---

## 5. request.state 状态传递

### 5.1 什么是 request.state？

`request.state` 是一个特殊的对象，用于在中间件和路由之间传递数据。

**特点：**
- 每个请求都有独立的 `state` 对象
- 可以在中间件中设置，在路由中读取
- 不会影响其他请求

```python
@app.middleware("http")
async def set_state(request: Request, call_next):
    # 在中间件中设置状态
    request.state.user_id = "user_123"
    request.state.request_id = "req_456"
    request.state.start_time = time.time()

    response = await call_next(request)
    return response

@app.get("/users/me")
async def get_current_user(request: Request):
    # 在路由中读取状态
    user_id = request.state.user_id
    request_id = request.state.request_id

    return {
        "user_id": user_id,
        "request_id": request_id
    }
```

### 5.2 典型应用场景

**场景1：认证信息传递**

```python
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    token = request.headers.get("authorization", "").replace("Bearer ", "")

    if token:
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
            # 设置用户信息
            request.state.user = {
                "id": payload["user_id"],
                "email": payload["email"],
                "role": payload["role"]
            }
        except:
            pass

    response = await call_next(request)
    return response

@app.get("/api/profile")
async def get_profile(request: Request):
    # 直接使用用户信息，不需要再验证 token
    if not hasattr(request.state, "user"):
        raise HTTPException(401, "Unauthorized")

    user = request.state.user
    return {"user": user}
```

**场景2：请求追踪**

```python
import uuid

@app.middleware("http")
async def request_id_middleware(request: Request, call_next):
    # 生成请求 ID
    request_id = str(uuid.uuid4())
    request.state.request_id = request_id

    response = await call_next(request)

    # 添加到响应头
    response.headers["X-Request-ID"] = request_id

    return response

@app.get("/api/data")
async def get_data(request: Request):
    # 在日志中使用请求 ID
    request_id = request.state.request_id
    print(f"[{request_id}] Processing request...")

    return {"data": "..."}
```

**场景3：性能监控**

```python
@app.middleware("http")
async def performance_middleware(request: Request, call_next):
    # 记录开始时间
    request.state.start_time = time.time()

    response = await call_next(request)

    # 计算耗时
    duration = time.time() - request.state.start_time

    # 记录慢请求
    if duration > 1.0:
        print(f"Slow request: {request.method} {request.url.path} - {duration:.3f}s")

    return response
```

---

## 6. 中间件的执行顺序设计

### 6.1 顺序的重要性

中间件的执行顺序非常重要，不同的顺序会导致不同的行为。

**示例：日志中间件的位置**

```python
# ❌ 错误：日志中间件在认证中间件之后
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 认证逻辑...
    response = await call_next(request)
    return response

@app.middleware("http")
async def log_middleware(request: Request, call_next):
    start = time.time()
    response = await call_next(request)
    duration = time.time() - start
    print(f"Duration: {duration:.3f}s")  # 不包括认证时间
    return response

# ✅ 正确：日志中间件在认证中间件之前
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    start = time.time()
    response = await call_next(request)
    duration = time.time() - start
    print(f"Duration: {duration:.3f}s")  # 包括认证时间
    return response

@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 认证逻辑...
    response = await call_next(request)
    return response
```

### 6.2 推荐的顺序

**通用原则：**

1. **日志中间件**：最外层（最先注册）
   - 记录完整的请求时间
   - 记录所有请求（包括被拦截的）

2. **CORS 中间件**：外层
   - 确保跨域请求能正常处理
   - 在认证之前处理 OPTIONS 请求

3. **认证中间件**：中层
   - 在业务逻辑之前验证身份
   - 避免未认证用户访问业务逻辑

4. **限流中间件**：内层
   - 在认证之后再检查限流
   - 避免浪费资源在未认证用户上

5. **业务中间件**：最内层（最后注册）
   - 业务相关的逻辑
   - 依赖前面中间件的结果

**示例：**

```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
import time

app = FastAPI()

# 1. 日志中间件（最外层）
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    start = time.time()
    print(f"→ {request.method} {request.url.path}")

    response = await call_next(request)

    duration = time.time() - start
    print(f"← {response.status_code} ({duration:.3f}s)")

    return response

# 2. CORS 中间件（外层）
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# 3. 认证中间件（中层）
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    if request.url.path.startswith("/api/"):
        token = request.headers.get("authorization")
        if not token:
            return JSONResponse({"error": "Unauthorized"}, status_code=401)
        # 验证 token...
        request.state.user_id = "user_123"

    response = await call_next(request)
    return response

# 4. 限流中间件（内层）
rate_limit_store = {}

@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    client_ip = request.client.host
    # 限流逻辑...
    response = await call_next(request)
    return response
```

---

## 7. 在 AI Agent 后端中的应用

### 7.1 为什么 AI Agent 后端需要中间件？

**核心问题：** LLM API 调用很贵（每次几分钱到几块钱），必须防止滥用。

**中间件的作用：**
1. **认证**：只有授权用户才能调用
2. **限流**：每个用户每分钟最多 N 次请求
3. **日志**：记录谁在什么时候调用了什么
4. **错误处理**：LLM API 失败时返回友好错误

### 7.2 完整示例

```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import time

app = FastAPI()

# 1. CORS：允许前端跨域调用
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# 2. 日志：记录每个请求
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    start = time.time()
    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {request.method} {request.url.path}")

    response = await call_next(request)

    duration = time.time() - start
    print(f"  ↳ {response.status_code} ({duration:.3f}s)")

    return response

# 3. 认证：验证 JWT
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 公开路径不需要认证
    public_paths = ["/", "/docs", "/openapi.json", "/login"]
    if request.url.path in public_paths:
        return await call_next(request)

    # 验证 token
    token = request.headers.get("authorization", "").replace("Bearer ", "")
    if not token:
        return JSONResponse({"error": "Missing token"}, status_code=401)

    try:
        # 验证 JWT（简化版）
        # payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        # request.state.user_id = payload["user_id"]
        request.state.user_id = "user_123"  # 示例
    except:
        return JSONResponse({"error": "Invalid token"}, status_code=401)

    response = await call_next(request)
    return response

# 4. 限流：防止滥用
rate_limit_store = {}

@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    user_id = getattr(request.state, "user_id", None)
    if not user_id:
        return await call_next(request)

    now = time.time()

    # 初始化用户记录
    if user_id not in rate_limit_store:
        rate_limit_store[user_id] = []

    # 清理 1 分钟前的记录
    rate_limit_store[user_id] = [
        t for t in rate_limit_store[user_id]
        if now - t < 60
    ]

    # 检查限流（每分钟最多 10 次）
    if len(rate_limit_store[user_id]) >= 10:
        return JSONResponse(
            {"error": "Rate limit exceeded. Max 10 requests per minute."},
            status_code=429
        )

    # 记录本次请求
    rate_limit_store[user_id].append(now)

    response = await call_next(request)
    return response

# 业务路由
@app.post("/api/agent/chat")
async def chat(request: Request, message: str):
    user_id = request.state.user_id

    # 调用 LLM API（示例）
    # response = await call_llm(message)

    return {
        "user_id": user_id,
        "response": f"Echo: {message}"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 总结

**中间件基础与执行流程的核心要点：**

1. **中间件是拦截器**：在请求前后执行
2. **洋葱模型**：先注册在外层，后注册在内层
3. **三个要素**：接收 request、调用 call_next、返回 response
4. **状态传递**：使用 request.state 在中间件和路由之间传递数据
5. **执行顺序**：日志 → CORS → 认证 → 限流 → 业务
6. **AI Agent 应用**：保护 LLM API 的第一道防线

**下一步学习：**
- 核心概念 2：内置中间件与 CORS
- 核心概念 3：自定义中间件开发
