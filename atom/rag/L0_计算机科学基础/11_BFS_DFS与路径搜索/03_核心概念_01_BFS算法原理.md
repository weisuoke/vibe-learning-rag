# 核心概念 01：BFS 算法原理

## 一句话定义

**BFS（广度优先搜索）是使用队列实现的层序遍历算法，按照距离起点的远近逐层访问节点，保证找到的路径是最短路径。**

---

## 核心思想

BFS 的核心思想可以用一个简单的比喻理解：

**想象你在一个迷宫的入口，想找到出口：**
- 你先探索所有距离入口1步的位置
- 然后探索所有距离入口2步的位置
- 再探索所有距离入口3步的位置
- ...直到找到出口

这样保证了你找到的路径是最短的（步数最少）。

---

## 算法实现

### 1. 队列实现（推荐）

```python
from collections import deque
from typing import Dict, List, Set

def bfs(graph: Dict[str, List[str]], start: str) -> List[str]:
    """
    BFS 遍历图

    参数:
        graph: 邻接表表示的图 {'A': ['B', 'C'], 'B': ['D'], ...}
        start: 起始节点

    返回:
        按 BFS 顺序访问的节点列表
    """
    # 1. 初始化
    visited = set([start])  # 已访问节点集合
    queue = deque([start])  # 待访问队列（FIFO）
    result = []             # 访问顺序

    # 2. 循环直到队列为空
    while queue:
        # 3. 取出队首节点
        node = queue.popleft()  # O(1) 时间复杂度
        result.append(node)

        # 4. 访问所有未访问的邻居
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)      # 标记为已访问
                queue.append(neighbor)     # 加入队列

    return result
```

**关键点：**
1. **队列（FIFO）**：先进先出，保证层序遍历
2. **visited 集合**：避免重复访问，防止无限循环
3. **立即标记**：节点加入队列时就标记为已访问（而非出队时）

---

### 2. 层序遍历（带层级信息）

```python
def bfs_with_level(graph: Dict[str, List[str]], start: str) -> Dict[str, int]:
    """
    BFS 遍历并记录每个节点的层级

    返回:
        {节点: 层级} 字典，层级表示距离起点的最短距离
    """
    visited = {start: 0}  # {节点: 层级}
    queue = deque([(start, 0)])  # (节点, 层级)

    while queue:
        node, level = queue.popleft()

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited[neighbor] = level + 1
                queue.append((neighbor, level + 1))

    return visited
```

**输出示例：**
```python
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [], 'E': [], 'F': []
}

result = bfs_with_level(graph, 'A')
# {'A': 0, 'B': 1, 'C': 1, 'D': 2, 'E': 2, 'F': 2}
```

---

### 3. 路径重建（记录父节点）

```python
def bfs_with_path(graph: Dict[str, List[str]], start: str, target: str) -> List[str]:
    """
    BFS 查找最短路径

    返回:
        从 start 到 target 的最短路径，如果不存在返回 []
    """
    if start == target:
        return [start]

    visited = {start}
    queue = deque([start])
    parent = {start: None}  # 记录每个节点的父节点

    # BFS 搜索
    while queue:
        node = queue.popleft()

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = node  # 记录父节点
                queue.append(neighbor)

                # 找到目标，重建路径
                if neighbor == target:
                    path = []
                    current = target
                    while current is not None:
                        path.append(current)
                        current = parent[current]
                    return path[::-1]  # 反转路径

    return []  # 未找到路径
```

**路径重建原理：**
```
父节点记录：A ← B ← D ← target
反向追溯：target → D → B → A
反转得到：A → B → D → target
```

---

## 复杂度分析

### 时间复杂度：O(V + E)

**V = 节点数，E = 边数**

**分析：**
- 每个节点入队、出队各一次：O(V)
- 每条边被检查一次：O(E)
- 总时间：O(V + E)

**示例：**
```python
# 图：5个节点，6条边
graph = {
    'A': ['B', 'C'],      # 2条边
    'B': ['D'],           # 1条边
    'C': ['D', 'E'],      # 2条边
    'D': ['E'],           # 1条边
    'E': []
}

# 时间复杂度：O(5 + 6) = O(11)
```

---

### 空间复杂度：O(V)

**分析：**
- `visited` 集合：O(V)
- `queue` 队列：最坏情况存储所有节点 O(V)
- `parent` 字典（如果需要）：O(V)
- 总空间：O(V)

**最坏情况：完全二叉树的最后一层**
```
层级0：1个节点
层级1：2个节点
层级2：4个节点
...
层级h：2^h 个节点

最后一层占总节点数的约 50%
队列最大长度 ≈ V/2 = O(V)
```

---

## BFS 的关键特性

### 特性1：最短路径保证

**定理：** BFS 在无权图中找到的路径一定是最短路径（边数最少）

**证明：**
```
假设 BFS 找到的路径不是最短路径：
1. 设 BFS 找到的路径长度为 d
2. 设存在更短路径长度为 d' < d
3. 则更短路径上的节点应该在第 d' 层被访问
4. 但 BFS 按层序遍历，第 d' 层一定在第 d 层之前访问
5. 矛盾！因此 BFS 找到的路径一定是最短的
```

**应用：**
- 社交网络：找最近的共同好友
- 路由算法：找最少跳数的路径
- 知识图谱：找最短推理链

---

### 特性2：层序遍历

**BFS 按照距离起点的远近逐层访问：**
```
层级0：起点
层级1：距离起点1步的所有节点
层级2：距离起点2步的所有节点
...
```

**可视化：**
```
图结构：
    A
   / \
  B   C
 / \   \
D   E   F

BFS 访问顺序：
层级0: [A]
层级1: [B, C]
层级2: [D, E, F]

输出：A → B → C → D → E → F
```

---

### 特性3：完整性

**BFS 保证访问所有可达节点，且每个节点恰好访问一次**

**证明：**
- `visited` 集合确保不重复访问
- 队列机制确保所有邻居都会被加入
- 因此所有可达节点都会被访问

---

## 在 RAG 中的应用

### 应用1：知识图谱广度检索

**场景：** 检索与查询相关的所有实体（不超过 m 跳）

```python
def kg_bfs_retrieval(kg, query_entities: List[str], max_hops: int = 2) -> Set[str]:
    """
    从查询实体出发，BFS 扩展 m-hop 邻域

    应用：KG2RAG 的第一步（广度扩展）
    """
    expanded = set(query_entities)
    queue = deque([(e, 0) for e in query_entities])

    while queue:
        entity, depth = queue.popleft()

        if depth >= max_hops:
            continue

        # 获取邻居实体
        neighbors = kg.get_neighbors(entity)
        for neighbor in neighbors:
            if neighbor not in expanded:
                expanded.add(neighbor)
                queue.append((neighbor, depth + 1))

    return expanded
```

**实际效果：**
```
查询："Einstein 的理论"
起点实体：[Einstein]

1-hop 扩展：
- 相对论
- 光电效应
- 诺贝尔奖
- ...

2-hop 扩展：
- 时空弯曲（相对论的邻居）
- 量子力学（光电效应的邻居）
- GPS技术（相对论的应用）
- ...

结果：获得所有相关实体，用于后续检索
```

**来源：** KG2RAG (NAACL 2025) - https://arxiv.org/abs/2502.06864

---

### 应用2：ARK 框架的全局搜索

**场景：** 自适应检索的第一步（广度起步）

```python
def ark_global_search(kg, query: str, top_k: int = 10) -> List[str]:
    """
    ARK 框架的全局词法搜索（BFS 风格）

    特点：
    - 快速覆盖候选实体
    - 为后续深度扩展提供起点
    """
    # 词法匹配（类似 BFS 的第一层）
    candidates = kg.lexical_search(query, top_k=top_k)

    return candidates
```

**为什么用 BFS？**
- 快速覆盖：一次性获取多个候选实体
- 广度优先：不深入单个实体，保持多样性
- 为深度扩展提供起点：后续根据 LLM 决策深入

**来源：** ARK (2026.01) - https://arxiv.org/abs/2601.13969

---

### 应用3：社交网络推荐

**场景：** 推荐好友（先推荐近的，再推荐远的）

```python
def friend_recommendation(social_graph, user: str, max_distance: int = 3) -> Dict[int, List[str]]:
    """
    基于 BFS 的好友推荐

    返回:
        {距离: [好友列表]}
        距离1：一度好友
        距离2：二度好友
        ...
    """
    recommendations = {}
    visited = {user: 0}
    queue = deque([(user, 0)])

    while queue:
        current, distance = queue.popleft()

        if distance >= max_distance:
            continue

        for friend in social_graph.get(current, []):
            if friend not in visited:
                visited[friend] = distance + 1
                queue.append((friend, distance + 1))

                # 按距离分组
                if distance + 1 not in recommendations:
                    recommendations[distance + 1] = []
                recommendations[distance + 1].append(friend)

    return recommendations
```

---

## BFS vs DFS 对比

| 维度 | BFS | DFS |
|------|-----|-----|
| **数据结构** | 队列（FIFO） | 栈（LIFO）或递归 |
| **遍历顺序** | 层序（先近后远） | 深度优先（一条路走到底） |
| **最短路径** | ✅ 保证最短 | ❌ 不保证 |
| **空间复杂度** | O(V) - 需要存储整层 | O(h) - 只需存储路径 |
| **适用场景** | 最短路径、广度检索 | 路径探索、深度推理 |
| **RAG 应用** | 邻域扩展、候选检索 | 推理链构建、因果探索 |

---

## 常见变体

### 1. 双向 BFS

**优化：** 从起点和终点同时搜索，相遇时停止

```python
def bidirectional_bfs(graph, start, target):
    """
    双向 BFS：从起点和终点同时搜索

    时间复杂度：O(b^(d/2)) vs 单向 O(b^d)
    其中 b 是分支因子，d 是深度
    """
    if start == target:
        return [start]

    # 前向搜索
    forward_visited = {start: None}
    forward_queue = deque([start])

    # 后向搜索
    backward_visited = {target: None}
    backward_queue = deque([target])

    while forward_queue and backward_queue:
        # 前向扩展一层
        if forward_queue:
            node = forward_queue.popleft()
            for neighbor in graph.get(node, []):
                if neighbor in backward_visited:
                    # 相遇！重建路径
                    return reconstruct_path(forward_visited, backward_visited, neighbor)
                if neighbor not in forward_visited:
                    forward_visited[neighbor] = node
                    forward_queue.append(neighbor)

        # 后向扩展一层
        if backward_queue:
            node = backward_queue.popleft()
            for neighbor in graph.get(node, []):
                if neighbor in forward_visited:
                    # 相遇！重建路径
                    return reconstruct_path(forward_visited, backward_visited, neighbor)
                if neighbor not in backward_visited:
                    backward_visited[neighbor] = node
                    backward_queue.append(neighbor)

    return []  # 未找到路径
```

**优势：**
- 搜索空间减少：O(b^(d/2) + b^(d/2)) << O(b^d)
- 适用于大规模图

---

### 2. 限制深度的 BFS

**应用：** 控制检索范围，避免爆炸性增长

```python
def limited_bfs(graph, start, max_depth):
    """
    限制深度的 BFS

    应用：KG2RAG 中限制 m-hop 邻域
    """
    visited = {start: 0}
    queue = deque([(start, 0)])
    result = []

    while queue:
        node, depth = queue.popleft()
        result.append(node)

        if depth >= max_depth:
            continue  # 不再扩展

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited[neighbor] = depth + 1
                queue.append((neighbor, depth + 1))

    return result
```

---

## 实战技巧

### 技巧1：使用 deque 而非 list

```python
# ❌ 不推荐：list 的 pop(0) 是 O(n)
queue = [start]
while queue:
    node = queue.pop(0)  # O(n) 时间复杂度

# ✅ 推荐：deque 的 popleft() 是 O(1)
from collections import deque
queue = deque([start])
while queue:
    node = queue.popleft()  # O(1) 时间复杂度
```

---

### 技巧2：立即标记已访问

```python
# ❌ 错误：出队时才标记
queue = deque([start])
while queue:
    node = queue.popleft()
    if node in visited:  # 可能重复入队
        continue
    visited.add(node)

# ✅ 正确：入队时就标记
visited = {start}
queue = deque([start])
while queue:
    node = queue.popleft()
    for neighbor in graph[node]:
        if neighbor not in visited:
            visited.add(neighbor)  # 立即标记
            queue.append(neighbor)
```

**原因：** 立即标记避免同一节点多次入队，节省空间和时间。

---

### 技巧3：处理断开的图

```python
def bfs_all_components(graph):
    """
    遍历所有连通分量
    """
    visited = set()
    components = []

    for node in graph:
        if node not in visited:
            # 从未访问的节点开始新的 BFS
            component = bfs_component(graph, node, visited)
            components.append(component)

    return components

def bfs_component(graph, start, visited):
    """BFS 遍历一个连通分量"""
    component = []
    queue = deque([start])
    visited.add(start)

    while queue:
        node = queue.popleft()
        component.append(node)

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return component
```

---

## 学习检查

理解了 BFS 算法原理后，你应该能回答：

- [ ] BFS 使用什么数据结构？（队列 FIFO）
- [ ] BFS 的时间复杂度是多少？（O(V + E)）
- [ ] BFS 为什么能保证最短路径？（层序遍历，先访问近的节点）
- [ ] 如何用 BFS 重建路径？（记录父节点，反向追溯）
- [ ] BFS 在 RAG 中的应用场景？（知识图谱广度检索、邻域扩展）

---

## 下一步

学完 BFS 算法原理后，建议继续学习：
1. `03_核心概念_02_DFS算法原理.md` - 理解 DFS 的实现
2. `03_核心概念_03_遍历策略对比.md` - 对比 BFS 和 DFS
3. `07_实战代码_场景1_基础BFS_DFS实现.md` - 动手实践

---

**版本：** v1.0
**最后更新：** 2026-02-14
**参考文献：**
- KG2RAG (NAACL 2025): https://arxiv.org/abs/2502.06864
- ARK (2026.01): https://arxiv.org/abs/2601.13969
