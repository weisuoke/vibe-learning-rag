# 核心概念 06：Tool 实现模式

> **深入理解 MCP Tool 的 Schema 设计、参数验证和错误处理策略**

---

## 概述

MCP Tool 的实现遵循严格的模式和最佳实践，确保工具定义清晰、参数验证可靠、错误处理优雅。

```
Tool 实现核心模式：
├─ Schema 设计 → JSON Schema + Zod 验证
├─ 参数验证 → 类型检查、边界验证、格式验证
├─ 执行模式 → 同步/异步、流式处理
└─ 错误处理 → 协议错误 vs 执行错误
```

**本质**：Tool 是 MCP Server 暴露给 AI 模型的可调用函数，通过严格的 Schema 定义和验证机制，确保模型能够正确理解和调用工具。

[Source: Tools - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/server/tools)

---

## Tool Schema 设计

### 工具定义结构

完整的工具定义包含以下字段：

```typescript
interface Tool {
  name: string;              // 唯一标识符（1-128字符）
  title?: string;            // 可选的人类可读名称
  description: string;       // 功能描述（给 AI 看）
  icons?: Icon[];            // 可选的图标数组
  inputSchema: JSONSchema;   // 参数定义（JSON Schema）
  outputSchema?: JSONSchema; // 可选的输出验证
  annotations?: object;      // 可选的行为属性
}
```

**关键约束**：

- `name` **应该**在 1-128 个字符之间
- `name` **应该**区分大小写
- `name` **应该**仅包含：大小写字母（A-Z, a-z）、数字（0-9）、下划线（_）、连字符（-）、点（.）
- `name` **不应该**包含空格、逗号或其他特殊字符
- `name` **应该**在服务器内唯一

**有效工具名称示例**：
- `getUser`
- `DATA_EXPORT_v2`
- `admin.tools.list`
- `slack_send_message`（推荐：包含服务上下文）

[Source: Tools - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/server/tools)

### 工具命名最佳实践

**避免命名冲突**：

```typescript
// ❌ 错误：名称过于通用
"send_message"
"create_issue"
"list_tasks"

// ✅ 正确：包含服务上下文
"slack_send_message"
"github_create_issue"
"asana_list_tasks"
```

**命名约定**：

- 使用 `snake_case` 格式（TypeScript/Node.js）
- 使用清晰的动作导向名称
- 包含服务名称前缀以避免冲突
- 避免版本号或日期

[Source: Node/TypeScript MCP Server Implementation Guide](https://github.com/anthropics/skills/blob/main/skills/mcp-builder/reference/node_mcp_server.md)

### 描述字段设计

**关键原则**：

- `description` 字段**必须**显式提供（JSDoc 注释不会自动提取）
- 描述应该告诉模型**何时**使用工具
- 描述应该清晰说明工具的**功能**和**限制**

**示例对比**：

```typescript
// ❌ 错误：描述过于简单
{
  name: "search_users",
  description: "Search users"
}

// ✅ 正确：描述详细清晰
{
  name: "search_users",
  description: "Searches for users by name or email with pagination and format options. Returns basic user information including name, email, and role. Use this when you need to find specific users or verify user existence. Maximum 100 results per query."
}
```

[Source: Implementing MCP: Tips and Pitfalls](https://nearform.com/digital-community/implementing-model-context-protocol-mcp-tips-tricks-and-pitfalls/)

---

## 参数验证模式

### JSON Schema 基础

MCP 工具使用 JSON Schema 定义参数：

- 默认使用 JSON Schema 2020-12（如果没有 `$schema` 字段）
- `inputSchema` **必须**是有效的 JSON Schema 对象（不能为 null）
- 支持类型检查、边界验证、格式验证

**无参数工具的正确定义**：

```json
{
  "name": "get_current_time",
  "description": "Returns the current server time",
  "inputSchema": {
    "type": "object",
    "additionalProperties": false
  }
}
```

[Source: Tools - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/server/tools)

### Zod Schema 验证（TypeScript）

**推荐模式**：使用 Zod 进行运行时输入验证和类型安全。

**完整示例**：

```typescript
import { z } from "zod";

// 定义响应格式枚举
enum ResponseFormat {
  MARKDOWN = "markdown",
  JSON = "json"
}

// Zod schema 定义
const UserSearchInputSchema = z.object({
  query: z.string()
    .min(2, "Query must be at least 2 characters")
    .max(200, "Query must not exceed 200 characters")
    .describe("Search string to match against names/emails"),

  limit: z.number()
    .int()
    .min(1)
    .max(100)
    .default(20)
    .describe("Maximum results to return"),

  offset: z.number()
    .int()
    .min(0)
    .default(0)
    .describe("Number of results to skip for pagination"),

  response_format: z.nativeEnum(ResponseFormat)
    .default(ResponseFormat.MARKDOWN)
    .describe("Output format: 'markdown' for human-readable or 'json' for machine-readable")
}).strict();

// 从 Zod schema 推导类型
type UserSearchInput = z.infer<typeof UserSearchInputSchema>;
```

**关键点**：

- 使用 `.min()` 和 `.max()` 设置边界
- 使用 `.describe()` 添加参数描述
- 使用 `.default()` 设置默认值
- 使用 `.strict()` 禁止额外属性
- 使用 `z.infer<>` 推导 TypeScript 类型

[Source: Node/TypeScript MCP Server Implementation Guide](https://github.com/anthropics/skills/blob/main/skills/mcp-builder/reference/node_mcp_server.md)

### 高级验证模式

**自定义验证规则**：

```typescript
const DateInputSchema = z.object({
  date: z.string()
    .refine((val) => !isNaN(Date.parse(val)), {
      message: "Invalid date format. Please provide a valid date string."
    })
    .refine((val) => new Date(val) > new Date(), {
      message: "Date must be in the future"
    })
});
```

**条件验证**：

```typescript
const CreateTaskSchema = z.object({
  title: z.string().min(1).max(200),
  priority: z.enum(["low", "medium", "high"]),
  due_date: z.string().optional(),
  assignee: z.string().optional()
}).refine(
  (data) => {
    // 高优先级任务必须有截止日期
    if (data.priority === "high" && !data.due_date) {
      return false;
    }
    return true;
  },
  {
    message: "High priority tasks must have a due date"
  }
);
```

---

## 工具注册模式

### TypeScript 注册模式

**现代 API（推荐）**：

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

const server = new McpServer({
  name: "example-mcp",
  version: "1.0.0"
});

// 使用 registerTool 方法
server.registerTool(
  "search_users",
  {
    title: "Search Users",
    description: "Searches for users by name or email with pagination and format options",
    inputSchema: UserSearchInputSchema,
    outputSchema: z.object({
      users: z.array(z.object({
        id: z.string(),
        name: z.string(),
        email: z.string().email(),
        role: z.string().optional()
      })),
      total: z.number(),
      hasMore: z.boolean()
    })
  },
  async ({ query, limit, offset, response_format }) => {
    try {
      const results = await searchUsers(query, limit, offset);

      const output = {
        users: results.users,
        total: results.total,
        hasMore: offset + limit < results.total
      };

      const content = response_format === ResponseFormat.JSON
        ? [{ type: "text", text: JSON.stringify(output, null, 2) }]
        : [{ type: "text", text: formatAsMarkdown(output) }];

      return {
        content,
        structuredContent: output
      };
    } catch (error) {
      throw new Error(`User search failed: ${error.message}`);
    }
  }
);
```

**重要提示**：

- **使用**：`server.registerTool()`, `server.registerResource()`, `server.registerPrompt()`
- **不要使用**：旧的已弃用 API，如 `server.tool()`, `server.setRequestHandler()`
- `register*` 方法提供更好的类型安全和自动 schema 处理

[Source: Node/TypeScript MCP Server Implementation Guide](https://github.com/anthropics/skills/blob/main/skills/mcp-builder/reference/node_mcp_server.md)

### Python 注册模式

**FastMCP 风格**：

```python
from mcp.server.fastmcp import FastMCP
from typing import Literal

mcp = FastMCP("example-mcp")

@mcp.tool()
async def search_users(
    query: str,
    limit: int = 20,
    offset: int = 0,
    response_format: Literal["markdown", "json"] = "markdown"
) -> str:
    """Searches for users by name or email with pagination and format options.

    Args:
        query: Search string to match against names/emails (2-200 chars)
        limit: Maximum results to return (1-100, default: 20)
        offset: Number of results to skip for pagination (default: 0)
        response_format: Output format ('markdown' or 'json', default: 'markdown')

    Returns:
        Formatted search results
    """
    # 参数验证
    if len(query) < 2 or len(query) > 200:
        raise ValueError("Query must be between 2 and 200 characters")

    if not 1 <= limit <= 100:
        raise ValueError("Limit must be between 1 and 100")

    if offset < 0:
        raise ValueError("Offset must be non-negative")

    # 执行搜索
    results = await search_users_impl(query, limit, offset)

    # 格式化输出
    if response_format == "json":
        return json.dumps(results, indent=2)
    else:
        return format_as_markdown(results)
```

**关键点**：

- 使用 `@mcp.tool()` 装饰器
- 使用 Python 类型提示进行参数验证
- 使用详细的 docstring 描述功能
- 框架自动推导 JSON Schema

---

## 执行模式

### 同步 vs 异步

**异步执行（推荐）**：

```typescript
// TypeScript 异步工具
server.registerTool(
  "get_weather_forecast",
  {
    title: "Get Weather Forecast",
    description: "Get weather forecast for a location",
    inputSchema: z.object({
      latitude: z.number(),
      longitude: z.number()
    })
  },
  async ({ latitude, longitude }) => {
    // 异步获取数据
    const pointsData = await makeNWSRequest(
      `${NWS_API_BASE}/points/${latitude},${longitude}`
    );

    const forecastData = await makeNWSRequest(
      pointsData.properties.forecast
    );

    return {
      content: [
        {
          type: "text",
          text: formatForecast(forecastData)
        }
      ]
    };
  }
);
```

```python
# Python 异步工具
@mcp.tool()
async def get_weather_forecast(latitude: float, longitude: float) -> str:
    """Get weather forecast for a location."""
    # 异步获取数据
    points_url = f"{NWS_API_BASE}/points/{latitude},{longitude}"
    points_data = await make_nws_request(points_url)

    forecast_url = points_data["properties"]["forecast"]
    forecast_data = await make_nws_request(forecast_url)

    return format_forecast(forecast_data)
```

### 流式处理

**进度更新**：

```typescript
server.registerTool(
  "process_large_dataset",
  {
    title: "Process Large Dataset",
    description: "Process a large dataset with progress updates",
    inputSchema: z.object({
      dataset_id: z.string()
    })
  },
  async ({ dataset_id }, { sendProgress }) => {
    const totalSteps = 100;

    for (let i = 0; i < totalSteps; i++) {
      // 发送进度更新
      await sendProgress({
        progress: i,
        total: totalSteps,
        message: `Processing step ${i + 1} of ${totalSteps}`
      });

      // 执行处理
      await processStep(dataset_id, i);
    }

    return {
      content: [
        {
          type: "text",
          text: "Dataset processing complete"
        }
      ]
    };
  }
);
```

[Source: Implementing MCP: Tips and Pitfalls](https://nearform.com/digital-community/implementing-model-context-protocol-mcp-tips-tricks-and-pitfalls/)

---

## 错误处理策略

### 两种错误机制

MCP 工具使用两种错误报告机制：

1. **协议错误**：标准 JSON-RPC 错误
   - 未知工具
   - 格式错误的请求
   - 服务器错误

2. **工具执行错误**：在结果中使用 `isError: true`
   - API 失败
   - 输入验证错误
   - 业务逻辑错误

**关键区别**：

- **工具执行错误**包含可操作的反馈，语言模型可以用来自我纠正和重试
- **协议错误**表示请求结构本身的问题，模型不太可能修复

客户端**应该**将工具执行错误提供给语言模型以启用自我纠正。

[Source: Tools - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/server/tools)

### 协议错误示例

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": {
    "code": -32602,
    "message": "Unknown tool: invalid_tool_name"
  }
}
```

### 工具执行错误示例

**输入验证错误**：

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Invalid departure date: must be in the future. Current date is 08/08/2025."
      }
    ],
    "isError": true
  }
}
```

**API 失败错误**：

```typescript
server.registerTool(
  "fetch_user_data",
  {
    title: "Fetch User Data",
    description: "Fetch user data from external API",
    inputSchema: z.object({
      user_id: z.string()
    })
  },
  async ({ user_id }) => {
    try {
      const userData = await fetchFromAPI(user_id);

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(userData)
          }
        ]
      };
    } catch (error) {
      // 返回工具执行错误
      return {
        content: [
          {
            type: "text",
            text: `Failed to fetch user data: ${error.message}. Please check the user_id and try again.`
          }
        ],
        isError: true
      };
    }
  }
);
```

### 错误处理最佳实践

**1. 提供清晰的错误消息**：

```typescript
// ❌ 错误：消息不清晰
"Error: Invalid input"

// ✅ 正确：消息清晰且可操作
"Invalid departure date: must be in the future. Current date is 08/08/2025. Please provide a date after 08/08/2025."
```

**2. 包含上下文信息**：

```typescript
return {
  content: [
    {
      type: "text",
      text: `User not found: ${user_id}. Available users: ${availableUsers.join(", ")}`
    }
  ],
  isError: true
};
```

**3. 使用结构化错误**：

```typescript
const output = {
  error: {
    code: "INVALID_DATE",
    message: "Date must be in the future",
    details: {
      provided: date,
      current: new Date().toISOString(),
      suggestion: "Please provide a date after " + new Date().toISOString()
    }
  }
};

return {
  content: [
    {
      type: "text",
      text: JSON.stringify(output, null, 2)
    }
  ],
  structuredContent: output,
  isError: true
};
```

---

## 输出 Schema 验证

### 定义输出 Schema

工具可以提供输出 schema 用于结构化结果验证：

```typescript
server.registerTool(
  "get_weather_data",
  {
    title: "Weather Data Retriever",
    description: "Get current weather data for a location",
    inputSchema: z.object({
      location: z.string()
    }),
    outputSchema: z.object({
      temperature: z.number().describe("Temperature in celsius"),
      conditions: z.string().describe("Weather conditions description"),
      humidity: z.number().describe("Humidity percentage")
    })
  },
  async ({ location }) => {
    const data = await fetchWeatherData(location);

    const output = {
      temperature: data.temp,
      conditions: data.conditions,
      humidity: data.humidity
    };

    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(output)
        }
      ],
      structuredContent: output
    };
  }
);
```

**要求**：

- 如果提供了输出 schema，服务器**必须**提供符合此 schema 的结构化结果
- 客户端**应该**根据此 schema 验证结构化结果

**好处**：

- 启用严格的 schema 验证
- 提供类型信息以更好地与编程语言集成
- 指导客户端和 LLM 正确解析和使用返回的数据
- 支持更好的文档和开发者体验

[Source: Tools - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/server/tools)

---

## 高级模式

### 工具组合

**元服务器模式**：

```typescript
// 创建元服务器，组合多个后端服务器
const metaServer = new McpServer({
  name: "meta-mcp-server",
  version: "1.0.0"
});

// 路由到不同的后端服务器
metaServer.registerTool(
  "unified_search",
  {
    title: "Unified Search",
    description: "Search across multiple services",
    inputSchema: z.object({
      query: z.string(),
      services: z.array(z.enum(["github", "slack", "jira"]))
    })
  },
  async ({ query, services }) => {
    const results = await Promise.all(
      services.map(service => {
        switch (service) {
          case "github":
            return githubServer.callTool("search_repos", { query });
          case "slack":
            return slackServer.callTool("search_messages", { query });
          case "jira":
            return jiraServer.callTool("search_issues", { query });
        }
      })
    );

    return {
      content: [
        {
          type: "text",
          text: formatUnifiedResults(results)
        }
      ]
    };
  }
);
```

[Source: Implementing MCP: Tips and Pitfalls](https://nearform.com/digital-community/implementing-model-context-protocol-mcp-tips-tricks-and-pitfalls/)

### 响应格式优化

**为 LLM 优化响应**：

```typescript
function formatAsMarkdown(data: any): string {
  // 简洁、结构化的 Markdown
  return `## Search Results\n\n` +
    `Found ${data.total} total users\n\n` +
    `### Users\n` +
    data.users.map((u: any) =>
      `- **${u.name}** (${u.email})${u.role ? ` *${u.role}*` : ''}`
    ).join('\n') +
    `\n\n*Showing ${data.users.length} of ${data.total} results*`;
}
```

**关键原则**：

- 简洁且专注于调用者实际需要的信息
- 结构化为 JSON 或小型、格式良好的 Markdown 片段
- 对于大型数据集，分页结果或提供后续工具
- 避免低信号文本墙

[Source: Implementing MCP: Tips and Pitfalls](https://nearform.com/digital-community/implementing-model-context-protocol-mcp-tips-tricks-and-pitfalls/)

---

## 总结

### 核心要点

1. **Schema 设计**：使用 Zod 进行运行时验证和类型安全
2. **命名约定**：使用 snake_case，包含服务上下文，避免冲突
3. **参数验证**：详细的边界检查、格式验证、自定义规则
4. **错误处理**：区分协议错误和执行错误，提供可操作的反馈
5. **输出优化**：简洁、结构化、为 LLM 优化的响应格式

### 关键约束

- ✅ 工具名称：1-128 字符，区分大小写，仅字母数字和 _-.
- ✅ 描述字段：必须显式提供，清晰说明何时使用
- ✅ 输入 Schema：必须是有效的 JSON Schema 对象
- ✅ 错误处理：使用 isError: true 报告执行错误
- ✅ 输出 Schema：如果提供，必须符合 schema

### 下一步

- 阅读 [03_核心概念_07_Resource管理](./03_核心概念_07_Resource管理.md) 了解资源管理
- 阅读 [07_实战代码_02_数据库连接器](./07_实战代码_02_数据库连接器.md) 查看完整实现

---

**参考资源**：
- [Source: Tools - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/server/tools)
- [Source: Node/TypeScript MCP Server Implementation Guide](https://github.com/anthropics/skills/blob/main/skills/mcp-builder/reference/node_mcp_server.md)
- [Source: Implementing MCP: Tips and Pitfalls](https://nearform.com/digital-community/implementing-model-context-protocol-mcp-tips-tricks-and-pitfalls/)
