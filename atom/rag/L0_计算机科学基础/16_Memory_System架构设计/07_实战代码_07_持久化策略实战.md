# 实战代码：持久化策略实战

> **实现生产级的数据持久化系统**

---

## Write-through 实现

```python
import json
from pathlib import Path
from typing import Any

class WriteThroughCache:
    """Write-through 缓存（立即持久化）"""

    def __init__(self, storage_path: str):
        self.cache = {}
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(exist_ok=True)

    def put(self, key: str, value: Any) -> None:
        """写入数据（立即持久化）"""
        # 1. 写入缓存
        self.cache[key] = value

        # 2. 立即持久化
        file_path = self.storage_path / f"{key}.json"
        file_path.write_text(json.dumps(value))
        print(f"✅ 立即持久化: {key}")

    def get(self, key: str) -> Any:
        """读取数据"""
        if key in self.cache:
            return self.cache[key]

        file_path = self.storage_path / f"{key}.json"
        if file_path.exists():
            value = json.loads(file_path.read_text())
            self.cache[key] = value
            return value

        return None
```

---

## Write-back 实现

```python
import time

class WriteBackCache:
    """Write-back 缓存（延迟持久化）"""

    def __init__(self, storage_path: str, flush_interval: int = 5):
        self.cache = {}
        self.dirty_keys = set()
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(exist_ok=True)
        self.flush_interval = flush_interval
        self.last_flush = time.time()

    def put(self, key: str, value: Any) -> None:
        """写入数据（只写缓存）"""
        self.cache[key] = value
        self.dirty_keys.add(key)

        # 定期刷新
        if time.time() - self.last_flush > self.flush_interval:
            self.flush()

    def flush(self) -> int:
        """批量持久化"""
        if not self.dirty_keys:
            return 0

        count = 0
        for key in self.dirty_keys:
            if key in self.cache:
                file_path = self.storage_path / f"{key}.json"
                file_path.write_text(json.dumps(self.cache[key]))
                count += 1

        self.dirty_keys.clear()
        self.last_flush = time.time()
        print(f"✅ 批量持久化: {count} 个键")
        return count
```

---

## WAL 实现

```python
from datetime import datetime

class WALCache:
    """Write-ahead Log 缓存"""

    def __init__(self, storage_path: str, wal_path: str):
        self.cache = {}
        self.storage_path = Path(storage_path)
        self.wal_path = Path(wal_path)
        self.storage_path.mkdir(exist_ok=True)
        self.wal_file = open(self.wal_path, 'a')

        # 启动时恢复
        self._recover_from_wal()

    def put(self, key: str, value: Any) -> None:
        """写入数据（先写 WAL）"""
        # 1. 先写 WAL
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "operation": "PUT",
            "key": key,
            "value": value
        }
        self.wal_file.write(json.dumps(log_entry) + "\n")
        self.wal_file.flush()

        # 2. 写入缓存
        self.cache[key] = value

    def flush(self) -> None:
        """批量持久化到数据文件"""
        for key, value in self.cache.items():
            file_path = self.storage_path / f"{key}.json"
            file_path.write_text(json.dumps(value))

        # 清空 WAL
        self.wal_file.close()
        self.wal_path.unlink()
        self.wal_file = open(self.wal_path, 'a')

    def _recover_from_wal(self) -> None:
        """从 WAL 恢复数据"""
        if not self.wal_path.exists():
            return

        with open(self.wal_path, 'r') as f:
            for line in f:
                entry = json.loads(line)
                if entry["operation"] == "PUT":
                    self.cache[entry["key"]] = entry["value"]

        print(f"✅ 从 WAL 恢复: {len(self.cache)} 个键")
```

---

## PostgreSQL 持久化

```python
import psycopg2
from psycopg2.extras import Json

class PostgresPersistence:
    """PostgreSQL 持久化"""

    def __init__(self, db_config: dict):
        self.conn = psycopg2.connect(**db_config)
        self._create_table()

    def _create_table(self) -> None:
        """创建表"""
        cursor = self.conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS cache_data (
                key TEXT PRIMARY KEY,
                value JSONB NOT NULL,
                created_at TIMESTAMP DEFAULT NOW(),
                updated_at TIMESTAMP DEFAULT NOW()
            )
        """)
        self.conn.commit()

    def save(self, key: str, value: Any) -> None:
        """保存数据"""
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO cache_data (key, value)
            VALUES (%s, %s)
            ON CONFLICT (key)
            DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()
        """, (key, Json(value)))
        self.conn.commit()

    def load(self, key: str) -> Any:
        """加载数据"""
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT value FROM cache_data WHERE key = %s
        """, (key,))
        result = cursor.fetchone()
        return result[0] if result else None
```

---

## 混合策略

```python
class HybridPersistence:
    """混合持久化策略"""

    def __init__(self, db_config: dict):
        self.cache = {}
        self.dirty_keys = set()
        self.db = PostgresPersistence(db_config)

    def put(self, key: str, value: Any, critical: bool = False) -> None:
        """写入数据"""
        self.cache[key] = value

        if critical:
            # 关键数据：Write-through
            self.db.save(key, value)
            print(f"✅ 关键数据立即持久化: {key}")
        else:
            # 非关键数据：Write-back
            self.dirty_keys.add(key)

    def flush(self) -> int:
        """批量持久化"""
        count = 0
        for key in self.dirty_keys:
            if key in self.cache:
                self.db.save(key, self.cache[key])
                count += 1

        self.dirty_keys.clear()
        print(f"✅ 批量持久化: {count} 个键")
        return count
```

---

## AI Agent 应用

```python
class AgentMemoryPersistence:
    """AI Agent 记忆持久化"""

    def __init__(self, db_config: dict):
        self.persistence = HybridPersistence(db_config)

    def save_conversation(self, user_id: str, messages: list, critical: bool = False):
        """保存对话"""
        key = f"conv:{user_id}"
        self.persistence.put(key, messages, critical=critical)

    def save_preference(self, user_id: str, pref_key: str, value: Any):
        """保存偏好（关键数据）"""
        key = f"pref:{user_id}:{pref_key}"
        self.persistence.put(key, value, critical=True)

    def load_conversation(self, user_id: str) -> list:
        """加载对话"""
        key = f"conv:{user_id}"
        return self.persistence.cache.get(key) or []
```

---

## 参考资源

- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Google ADK Context Engineering](https://medium.com/@juanc.olamendy/context-engineering-in-google-adk-the-ultimate-guide-to-building-scalable-ai-agents-f8d7683f9c60)
- [2026 Memory Stack](https://alok-mishra.com/2026/01/07/a-2026-memory-stack-for-enterprise-agents)
