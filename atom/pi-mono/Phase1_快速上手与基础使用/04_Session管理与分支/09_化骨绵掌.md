# Session 管理与分支 - 化骨绵掌

> 10个2分钟知识卡片，快速掌握 Session 管理的核心要点

---

## 卡片 1：Session 的本质

**一句话：** Session 是 AI Agent 的"记忆本"，记录完整的对话历史和决策过程。

**举例：**
```typescript
// Session = 对话历史 + 树形结构 + 持久化
const session = {
  entries: [
    { id: '1', content: '问题' },
    { id: '2', parentId: '1', content: '回答' }
  ],
  storage: 'JSONL 文件'
};
```

**应用：** 在 Pi Coding Agent 中，每次对话都自动保存到 Session，实现有状态的 AI 交互。

---

## 卡片 2：JSONL 追加日志

**一句话：** JSONL 是每行一个 JSON 的追加日志格式，只追加不修改，高效且可靠。

**举例：**
```jsonl
{"id":"1","type":"message","content":"Hello"}
{"id":"2","parentId":"1","type":"message","content":"Hi"}
```

**应用：** Pi Session 使用 JSONL 存储，每次对话只追加新行，不需要重写整个文件，性能极高。

---

## 卡片 3：id/parentId 链接

**一句话：** 通过 id 和 parentId 建立节点关系，构建树形结构。

**举例：**
```typescript
// 线性：1 -> 2 -> 3
[
  { id: '1' },
  { id: '2', parentId: '1' },
  { id: '3', parentId: '2' }
]

// 分支：1 -> 2, 1 -> 3
[
  { id: '1' },
  { id: '2', parentId: '1' },
  { id: '3', parentId: '1' }
]
```

**应用：** 支持原地分支，无需创建新文件，所有分支在同一个 JSONL 文件中。

---

## 卡片 4：/tree 时间旅行

**一句话：** /tree 命令可视化会话树，支持导航到任意历史节点。

**举例：**
```
/tree
├─ 1: 实现功能 A
│  ├─ 2: 方案 A
│  └─ 3: 方案 B
```

**应用：** 回到历史节点查看不同方案，对比决策过程，实现"时间旅行"。

---

## 卡片 5：/fork 创建分支

**一句话：** /fork 从当前节点创建新分支，保留历史，开始新探索。

**举例：**
```bash
# 当前在节点 2
/fork
# 创建新分支，继承到节点 2 的历史
```

**应用：** 尝试不同实现方案，A/B 测试，保存检查点，所有分支都保留。

---

## 卡片 6：Compaction 压缩

**一句话：** Compaction 总结旧消息，保留新消息，优化上下文大小，完整历史不变。

**举例：**
```typescript
// 压缩前：100 条消息
// 压缩后：摘要 + 最近 20 条消息
// JSONL 文件：仍然保留所有 100 条
```

**应用：** 当 Session 太大时，使用 /compact 优化性能，降低 Token 消耗。

---

## 卡片 7：原地分支

**一句话：** 所有分支在同一个文件中，通过 parentId 区分，不创建新文件。

**举例：**
```
session.jsonl:  // 单文件
  { id: '1', content: 'A' }
  { id: '2', parentId: '1', content: 'B' }
  { id: '3', parentId: '1', content: 'C' }  // 分支
```

**应用：** 节省存储空间，简化文件管理，高效创建分支。

---

## 卡片 8：Context 重建

**一句话：** 从目标节点向上追溯到根节点，重建完整的对话上下文。

**举例：**
```typescript
// 目标节点：5
// 路径：1 -> 2 -> 4 -> 5
// Context：[节点1, 节点2, 节点4, 节点5]
```

**应用：** 跳转到历史节点后，自动重建该节点的完整上下文，传给 LLM。

---

## 卡片 9：Session 命名

**一句话：** 使用 /name 命名会话，方便识别和管理。

**举例：**
```bash
/name feature-user-login
/name bugfix-auth-error
/name exp-new-algorithm
```

**应用：** 按项目、功能、类型命名，快速找到需要的会话。

---

## 卡片 10：跨设备同步

**一句话：** Session 存储在文件中，可以跨设备备份、恢复和同步。

**举例：**
```bash
# 设备 A
cp ~/.pi/sessions/abc123.jsonl ~/Dropbox/

# 设备 B
cp ~/Dropbox/abc123.jsonl ~/.pi/sessions/
```

**应用：** 在多台设备间同步会话，实现无缝工作切换。

---

## 快速参考

### 核心命令

| 命令 | 作用 | 使用场景 |
|------|------|---------|
| `/new` | 创建新会话 | 开始新项目 |
| `/resume` | 恢复会话 | 继续之前的工作 |
| `/tree` | 查看会话树 | 导航历史、对比方案 |
| `/fork` | 创建分支 | 尝试不同方案 |
| `/name` | 命名会话 | 方便管理 |
| `/compact` | 压缩会话 | 优化性能 |

### 核心概念

| 概念 | 定义 | 类比 |
|------|------|------|
| **JSONL** | 每行一个 JSON | 日记本逐行记录 |
| **id/parentId** | 节点链接 | 家族关系链 |
| **树形结构** | 分支关系 | 决策树 |
| **原地分支** | 单文件多分支 | 同一本笔记本记录多个方案 |
| **Compaction** | 压缩优化 | 整理笔记本 |
| **时间旅行** | 跳转历史 | 翻阅日记 |

### 最佳实践

**命名规范：**
- `feature-{name}` - 功能开发
- `bugfix-{issue}` - Bug 修复
- `exp-{idea}` - 实验性开发
- `checkpoint-{milestone}` - 检查点

**使用场景：**
- **日常开发**：/new → 工作 → /name
- **多方案探索**：/fork → 尝试方案 A → /tree → /fork → 尝试方案 B
- **长期项目**：/resume → 继续工作 → /compact（定期）
- **团队协作**：/fork → 各自开发 → 对比结果

**性能优化：**
- 超过 100 条消息时考虑 /compact
- 使用 /tree 访问完整历史
- 定期清理旧会话（30天+）

---

## 常见误区

| 误区 | 正确理解 |
|------|---------|
| ❌ Fork 会创建新文件 | ✅ 单文件树形结构 |
| ❌ Compaction 会丢失历史 | ✅ JSONL 保留完整历史 |
| ❌ Fork 只是复制会话 | ✅ 创建父子关系，选择性继承 |

---

## 实战技巧

### 技巧 1：快速切换项目

```bash
# 项目 A
pi
/resume project-a
# 工作...

# 切换到项目 B
/new project-b
# 工作...

# 回到项目 A
/resume project-a
```

### 技巧 2：保存检查点

```bash
# 功能完成
User: 功能 A 完成

# 保存检查点
/fork
/name checkpoint-feature-a

# 继续开发
User: 开发功能 B
```

### 技巧 3：对比方案

```bash
# 实现方案 A
User: 使用方案 A

# Fork 尝试方案 B
/fork
User: 使用方案 B

# 对比
/tree
# 查看两个分支的差异
```

---

## 记忆口诀

**Session 管理三要素：**
1. **JSONL 存储** - 追加日志，高效可靠
2. **树形结构** - id/parentId，原地分支
3. **时间旅行** - /tree 导航，/fork 探索

**四大核心命令：**
- `/new` - 新建
- `/resume` - 恢复
- `/tree` - 导航
- `/fork` - 分支

**记住：**
- Session = 对话历史 + 树形结构 + 持久化
- JSONL = 只追加，不修改
- Fork = 保留历史，创建新路径
- Compaction = 优化上下文，保留完整历史

---

## 学习路径

### 初学者（第1天）
1. 理解 Session 的基本概念
2. 学会使用 /new 和 /resume
3. 尝试 /name 命名会话

### 进阶（第2-3天）
4. 学会使用 /tree 导航
5. 学会使用 /fork 创建分支
6. 理解 JSONL 存储格式

### 高级（第4-7天）
7. 理解树形结构原理
8. 学会使用 /compact 优化
9. 实现自定义 Session 管理器
10. 应用于实际项目

---

## 延伸学习

### 相关概念
- **LLM Context Window** - 理解为什么需要 Compaction
- **Git 分支模型** - 对比 Git 和 Pi 的分支设计
- **Event Sourcing** - JSONL 追加日志的设计模式
- **AI Agent Memory** - Session 作为短期记忆的角色

### 进阶主题
- **Phase 2.11** - Session 存储与树形结构（深入）
- **Phase 2.12** - Compaction 压缩机制（深入）
- **Phase 3** - 定制化开发（扩展 Session 功能）

---

## 总结

**Session 管理的核心价值：**
1. ✅ **有状态交互** - AI Agent 能记住对话历史
2. ✅ **多路径探索** - 支持并行尝试不同方案
3. ✅ **决策可追溯** - 完整记录决策过程
4. ✅ **时间旅行** - 可以回到任意历史节点
5. ✅ **跨设备同步** - 支持多设备协作

**记住这句话：**
> Session 管理是 AI Agent 的"记忆系统"，通过 JSONL 追加日志和树形结构，实现有状态的多路径探索与时间旅行。

---

**版本：** v1.0
**最后更新：** 2026-02-18
**维护者：** Claude Code
