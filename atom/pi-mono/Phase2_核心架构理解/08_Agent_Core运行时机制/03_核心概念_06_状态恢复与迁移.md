# 核心概念 06：状态恢复与迁移

> 深入理解 Agent Core 如何从 JSONL 文件恢复会话状态，以及如何在不同 LLM Provider 之间迁移

---

## 概念定义

**状态恢复与迁移**是指从 JSONL Session 文件重建 Agent 的上下文状态，以及在不同 LLM Provider（Anthropic、OpenAI、Google）之间转换消息格式的机制。

**一句话：** 状态恢复就是"读取历史 → 重建上下文"，状态迁移就是"统一格式 → 跨平台兼容"。

---

## Session 加载机制

### Session Loader 类

```typescript
class SessionLoader {
  private sessionPath: string;
  private entries: SessionEntry[] = [];
  private branch: SessionBranch;

  constructor(sessionPath: string) {
    this.sessionPath = sessionPath;
    this.load();
  }

  // 加载 Session 文件
  private load(): void {
    const content = fs.readFileSync(this.sessionPath, 'utf-8');
    const lines = content.split('\n');

    for (const line of lines) {
      if (line.trim()) {
        try {
          const entry = JSON.parse(line);
          this.entries.push(entry);
        } catch (error) {
          console.error('Failed to parse line:', line, error);
        }
      }
    }

    // 构建树形结构
    this.branch = new SessionBranch(this.entries);
  }

  // 获取所有条目
  getEntries(): SessionEntry[] {
    return this.entries;
  }

  // 获取分支管理器
  getBranch(): SessionBranch {
    return this.branch;
  }

  // 获取元数据
  getMetadata(): SessionMetadata {
    const firstEntry = this.entries[0];
    const lastEntry = this.entries[this.entries.length - 1];

    return {
      sessionId: path.basename(this.sessionPath, '.jsonl'),
      entryCount: this.entries.length,
      startTime: firstEntry?.timestamp,
      lastTime: lastEntry?.timestamp,
      branches: this.branch.getBranchPoints().length
    };
  }

  // 获取特定分支的上下文
  getContext(branchLeafId?: string): Message[] {
    // 确定叶子节点
    const leaves = this.branch.getLeaves();
    const leafId = branchLeafId || leaves[0]?.id;

    if (!leafId) {
      return [];
    }

    // 获取从根到叶子的路径
    const path = this.branch.getPath(leafId);

    // 转换为 Message 格式
    return this.entriesToMessages(path);
  }

  // 将 SessionEntry 转换为 Message
  private entriesToMessages(entries: SessionEntry[]): Message[] {
    const messages: Message[] = [];

    for (const entry of entries) {
      if (entry.type === 'user') {
        messages.push({
          role: 'user',
          content: entry.content
        });
      } else if (entry.type === 'assistant') {
        messages.push({
          role: 'assistant',
          content: entry.content,
          toolCalls: entry.toolCalls
        });
      } else if (entry.type === 'tool_result') {
        messages.push({
          role: 'tool',
          content: entry.output,
          toolCallId: entry.toolCallId
        });
      }
    }

    return messages;
  }
}
```

---

### 使用示例

```typescript
// 加载 Session
const loader = new SessionLoader('~/.pi/sessions/session-123.jsonl');

// 获取元数据
const metadata = loader.getMetadata();
console.log('Session ID:', metadata.sessionId);
console.log('Entry count:', metadata.entryCount);
console.log('Branches:', metadata.branches);

// 获取主分支的上下文
const context = loader.getContext();
console.log('Messages:', context.length);

// 获取特定分支的上下文
const branchContext = loader.getContext('msg-5');
console.log('Branch messages:', branchContext.length);

// 恢复 Agent
const agent = new Agent({
  provider,
  context  // 使用恢复的上下文
});
```

---

## 跨 Provider 消息格式归一化

### Provider 差异

**Anthropic 格式：**

```typescript
// Anthropic 消息格式
{
  role: 'assistant',
  content: [
    {
      type: 'thinking',
      thinking: 'Let me analyze this...'  // Anthropic 特有
    },
    {
      type: 'text',
      text: 'I will create the file'
    }
  ],
  tool_calls: [...]
}
```

**OpenAI 格式：**

```typescript
// OpenAI 消息格式
{
  role: 'assistant',
  content: 'I will create the file',  // 简单字符串
  tool_calls: [...]
  // 没有 thinking
}
```

**Google 格式：**

```typescript
// Google 消息格式
{
  role: 'model',  // 不是 'assistant'
  parts: [
    { text: 'I will create the file' }
  ],
  functionCalls: [...]  // 不是 tool_calls
}
```

---

### 统一消息格式

**NormalizedMessage 接口：**

```typescript
interface NormalizedMessage {
  role: 'user' | 'assistant' | 'tool';
  content: string;
  toolCalls?: ToolCall[];
  toolCallId?: string;
  thinking?: string;  // 可选：Anthropic thinking trace
  metadata?: {
    provider: string;
    originalFormat?: any;
  };
}
```

---

### Message Normalizer 类

```typescript
class MessageNormalizer {
  // 归一化消息（任意 Provider → 统一格式）
  static normalize(
    message: any,
    provider: 'anthropic' | 'openai' | 'google'
  ): NormalizedMessage {
    switch (provider) {
      case 'anthropic':
        return this.normalizeAnthropic(message);
      case 'openai':
        return this.normalizeOpenAI(message);
      case 'google':
        return this.normalizeGoogle(message);
      default:
        throw new Error(`Unknown provider: ${provider}`);
    }
  }

  // Anthropic → 统一格式
  private static normalizeAnthropic(message: any): NormalizedMessage {
    let content = '';
    let thinking: string | undefined;

    // 处理 content 数组
    if (Array.isArray(message.content)) {
      for (const block of message.content) {
        if (block.type === 'text') {
          content += block.text;
        } else if (block.type === 'thinking') {
          thinking = block.thinking;
        }
      }
    } else {
      content = message.content;
    }

    return {
      role: message.role,
      content,
      toolCalls: message.tool_calls,
      thinking,
      metadata: {
        provider: 'anthropic',
        originalFormat: message
      }
    };
  }

  // OpenAI → 统一格式
  private static normalizeOpenAI(message: any): NormalizedMessage {
    return {
      role: message.role,
      content: message.content || '',
      toolCalls: message.tool_calls,
      metadata: {
        provider: 'openai',
        originalFormat: message
      }
    };
  }

  // Google → 统一格式
  private static normalizeGoogle(message: any): NormalizedMessage {
    // Google 使用 'model' 而不是 'assistant'
    const role = message.role === 'model' ? 'assistant' : message.role;

    // 提取文本内容
    let content = '';
    if (message.parts) {
      for (const part of message.parts) {
        if (part.text) {
          content += part.text;
        }
      }
    }

    // 转换 functionCalls 为 toolCalls
    const toolCalls = message.functionCalls?.map((fc: any) => ({
      id: fc.id || generateId(),
      name: fc.name,
      params: fc.args
    }));

    return {
      role,
      content,
      toolCalls,
      metadata: {
        provider: 'google',
        originalFormat: message
      }
    };
  }

  // 统一格式 → Provider 格式
  static denormalize(
    message: NormalizedMessage,
    targetProvider: 'anthropic' | 'openai' | 'google'
  ): any {
    switch (targetProvider) {
      case 'anthropic':
        return this.denormalizeAnthropic(message);
      case 'openai':
        return this.denormalizeOpenAI(message);
      case 'google':
        return this.denormalizeGoogle(message);
      default:
        throw new Error(`Unknown provider: ${targetProvider}`);
    }
  }

  // 统一格式 → Anthropic
  private static denormalizeAnthropic(message: NormalizedMessage): any {
    const content: any[] = [];

    // 添加 thinking（如果有）
    if (message.thinking) {
      content.push({
        type: 'thinking',
        thinking: message.thinking
      });
    }

    // 添加文本内容
    if (message.content) {
      content.push({
        type: 'text',
        text: message.content
      });
    }

    return {
      role: message.role,
      content: content.length > 0 ? content : message.content,
      tool_calls: message.toolCalls
    };
  }

  // 统一格式 → OpenAI
  private static denormalizeOpenAI(message: NormalizedMessage): any {
    return {
      role: message.role,
      content: message.content,
      tool_calls: message.toolCalls
      // OpenAI 不支持 thinking，会丢失
    };
  }

  // 统一格式 → Google
  private static denormalizeGoogle(message: NormalizedMessage): any {
    // 'assistant' → 'model'
    const role = message.role === 'assistant' ? 'model' : message.role;

    // 文本内容 → parts
    const parts = message.content ? [{ text: message.content }] : [];

    // toolCalls → functionCalls
    const functionCalls = message.toolCalls?.map(tc => ({
      id: tc.id,
      name: tc.name,
      args: tc.params
    }));

    return {
      role,
      parts,
      functionCalls
      // Google 不支持 thinking，会丢失
    };
  }
}
```

---

### 使用示例

```typescript
// Anthropic 消息
const anthropicMessage = {
  role: 'assistant',
  content: [
    { type: 'thinking', thinking: 'Let me analyze...' },
    { type: 'text', text: 'I will create the file' }
  ],
  tool_calls: [...]
};

// 归一化
const normalized = MessageNormalizer.normalize(anthropicMessage, 'anthropic');
console.log(normalized);
// {
//   role: 'assistant',
//   content: 'I will create the file',
//   thinking: 'Let me analyze...',
//   toolCalls: [...],
//   metadata: { provider: 'anthropic' }
// }

// 转换为 OpenAI 格式
const openaiMessage = MessageNormalizer.denormalize(normalized, 'openai');
console.log(openaiMessage);
// {
//   role: 'assistant',
//   content: 'I will create the file',
//   tool_calls: [...]
//   // thinking 丢失
// }

// 转换为 Google 格式
const googleMessage = MessageNormalizer.denormalize(normalized, 'google');
console.log(googleMessage);
// {
//   role: 'model',
//   parts: [{ text: 'I will create the file' }],
//   functionCalls: [...]
//   // thinking 丢失
// }
```

---

## Session 迁移实现

### Session Migrator 类

```typescript
class SessionMigrator {
  // 迁移 Session（Provider A → Provider B）
  static migrate(
    sourcePath: string,
    sourceProvider: 'anthropic' | 'openai' | 'google',
    targetProvider: 'anthropic' | 'openai' | 'google',
    targetPath: string
  ): void {
    // 1. 加载源 Session
    const loader = new SessionLoader(sourcePath);
    const entries = loader.getEntries();

    // 2. 归一化所有消息
    const normalized = entries.map(entry => {
      if (entry.type === 'assistant') {
        return {
          ...entry,
          normalized: MessageNormalizer.normalize(entry, sourceProvider)
        };
      }
      return entry;
    });

    // 3. 转换为目标格式
    const migrated = normalized.map(entry => {
      if (entry.normalized) {
        const denormalized = MessageNormalizer.denormalize(
          entry.normalized,
          targetProvider
        );
        return {
          ...entry,
          ...denormalized,
          metadata: {
            ...entry.metadata,
            migratedFrom: sourceProvider,
            migratedTo: targetProvider,
            migratedAt: Date.now()
          }
        };
      }
      return entry;
    });

    // 4. 写入目标文件
    const writer = fs.createWriteStream(targetPath);
    for (const entry of migrated) {
      writer.write(JSON.stringify(entry) + '\n');
    }
    writer.end();

    console.log(`Migrated ${entries.length} entries from ${sourceProvider} to ${targetProvider}`);
  }

  // 检查迁移兼容性
  static checkCompatibility(
    sourceProvider: string,
    targetProvider: string
  ): CompatibilityReport {
    const report: CompatibilityReport = {
      compatible: true,
      warnings: [],
      lossyFields: []
    };

    // Anthropic → OpenAI/Google：会丢失 thinking
    if (sourceProvider === 'anthropic' && targetProvider !== 'anthropic') {
      report.warnings.push('Thinking traces will be lost');
      report.lossyFields.push('thinking');
    }

    // Google → Anthropic/OpenAI：角色名称转换
    if (sourceProvider === 'google') {
      report.warnings.push('Role names will be converted (model → assistant)');
    }

    // OpenAI/Google → Anthropic：可能需要调整 content 格式
    if (targetProvider === 'anthropic') {
      report.warnings.push('Content will be converted to Anthropic format');
    }

    return report;
  }
}

interface CompatibilityReport {
  compatible: boolean;
  warnings: string[];
  lossyFields: string[];
}
```

---

### 使用示例

```typescript
// 检查兼容性
const report = SessionMigrator.checkCompatibility('anthropic', 'openai');
console.log('Compatible:', report.compatible);
console.log('Warnings:', report.warnings);
// Warnings: ['Thinking traces will be lost']

// 迁移 Session
SessionMigrator.migrate(
  '~/.pi/sessions/anthropic-session.jsonl',  // 源文件
  'anthropic',                                // 源 Provider
  'openai',                                   // 目标 Provider
  '~/.pi/sessions/openai-session.jsonl'      // 目标文件
);

// 加载迁移后的 Session
const loader = new SessionLoader('~/.pi/sessions/openai-session.jsonl');
const context = loader.getContext();

// 使用 OpenAI Provider
const agent = new Agent({
  provider: new OpenAIProvider({ model: 'gpt-4' }),
  context
});
```

---

## 增量恢复机制

### 增量加载

**场景：** Session 文件很大（数千条消息），不需要一次性加载全部。

```typescript
class IncrementalSessionLoader {
  private sessionPath: string;
  private currentOffset: number = 0;
  private batchSize: number = 100;

  constructor(sessionPath: string, batchSize: number = 100) {
    this.sessionPath = sessionPath;
    this.batchSize = batchSize;
  }

  // 加载下一批条目
  async loadNext(): Promise<SessionEntry[]> {
    const stream = fs.createReadStream(this.sessionPath, {
      start: this.currentOffset,
      encoding: 'utf-8'
    });

    const rl = readline.createInterface({ input: stream });
    const entries: SessionEntry[] = [];
    let count = 0;

    for await (const line of rl) {
      if (line.trim()) {
        entries.push(JSON.parse(line));
        count++;

        if (count >= this.batchSize) {
          break;
        }
      }

      this.currentOffset += Buffer.byteLength(line + '\n', 'utf-8');
    }

    return entries;
  }

  // 检查是否还有更多条目
  hasMore(): boolean {
    const stats = fs.statSync(this.sessionPath);
    return this.currentOffset < stats.size;
  }

  // 重置到开始
  reset(): void {
    this.currentOffset = 0;
  }
}
```

---

### 使用示例

```typescript
// 创建增量加载器
const loader = new IncrementalSessionLoader('session-123.jsonl', 100);

// 逐批加载
while (loader.hasMore()) {
  const batch = await loader.loadNext();
  console.log(`Loaded ${batch.length} entries`);

  // 处理这批条目
  for (const entry of batch) {
    processEntry(entry);
  }
}
```

---

## 状态快照与回滚

### Snapshot 机制

**场景：** 在某个时刻保存 Agent 状态，后续可以回滚。

```typescript
class SessionSnapshot {
  private snapshots: Map<string, SessionEntry[]> = new Map();

  // 创建快照
  createSnapshot(name: string, entries: SessionEntry[]): void {
    this.snapshots.set(name, [...entries]);  // 深拷贝
    console.log(`Snapshot created: ${name} (${entries.length} entries)`);
  }

  // 恢复快照
  restoreSnapshot(name: string): SessionEntry[] | undefined {
    const snapshot = this.snapshots.get(name);
    if (snapshot) {
      console.log(`Snapshot restored: ${name} (${snapshot.length} entries)`);
      return [...snapshot];  // 深拷贝
    }
    return undefined;
  }

  // 列出所有快照
  listSnapshots(): string[] {
    return Array.from(this.snapshots.keys());
  }

  // 删除快照
  deleteSnapshot(name: string): boolean {
    return this.snapshots.delete(name);
  }
}
```

---

### 使用示例

```typescript
// 创建快照管理器
const snapshots = new SessionSnapshot();

// 加载 Session
const loader = new SessionLoader('session-123.jsonl');
const entries = loader.getEntries();

// 创建快照（在重要操作前）
snapshots.createSnapshot('before-refactor', entries);

// 执行操作...
// （可能修改 Session）

// 如果出错，恢复快照
const restored = snapshots.restoreSnapshot('before-refactor');
if (restored) {
  // 使用恢复的状态
  const context = new SessionBranch(restored).getContext();
}
```

---

## 实际应用场景

### 场景 1：恢复中断的会话

```typescript
// 用户关闭 Agent，稍后重新打开

// 加载最近的 Session
const recentSessions = fs.readdirSync(SESSION_DIR)
  .filter(f => f.endsWith('.jsonl'))
  .map(f => ({
    path: path.join(SESSION_DIR, f),
    mtime: fs.statSync(path.join(SESSION_DIR, f)).mtime
  }))
  .sort((a, b) => b.mtime.getTime() - a.mtime.getTime());

const latestSession = recentSessions[0].path;

// 恢复上下文
const loader = new SessionLoader(latestSession);
const context = loader.getContext();

// 继续对话
const agent = new Agent({ provider, context });
await agent.run('继续之前的任务');
```

---

### 场景 2：切换 LLM Provider

```typescript
// 用户想从 Anthropic 切换到 OpenAI

// 1. 检查兼容性
const report = SessionMigrator.checkCompatibility('anthropic', 'openai');
if (report.warnings.length > 0) {
  console.warn('Migration warnings:', report.warnings);
}

// 2. 迁移 Session
SessionMigrator.migrate(
  'anthropic-session.jsonl',
  'anthropic',
  'openai',
  'openai-session.jsonl'
);

// 3. 使用新 Provider
const loader = new SessionLoader('openai-session.jsonl');
const context = loader.getContext();

const agent = new Agent({
  provider: new OpenAIProvider({ model: 'gpt-4' }),
  context
});
```

---

### 场景 3：分支探索

```typescript
// 用户想尝试不同方案

// 加载 Session
const loader = new SessionLoader('session-123.jsonl');
const branch = loader.getBranch();

// 列出所有分支
const leaves = branch.getLeaves();
console.log('Available branches:');
for (const leaf of leaves) {
  const path = branch.getPath(leaf.id);
  console.log(`- Branch ${leaf.id}: ${path.length} messages`);
}

// 选择一个分支
const selectedBranch = leaves[1];
const context = loader.getContext(selectedBranch.id);

// 从这个分支继续
const agent = new Agent({ provider, context });
```

---

### 场景 4：调试与回放

```typescript
// 开发者想调试 Agent 行为

// 加载 Session
const loader = new SessionLoader('session-123.jsonl');
const entries = loader.getEntries();

// 逐步回放
for (let i = 0; i < entries.length; i++) {
  const entry = entries[i];
  console.log(`\n=== Step ${i + 1} ===`);
  console.log(`Type: ${entry.type}`);
  console.log(`Content:`, entry.content || entry.output);

  // 在某个点暂停
  if (entry.type === 'tool_result' && !entry.success) {
    console.log('Error detected! Pausing...');
    break;
  }
}

// 从错误点重新开始
const contextUpToError = loader.getContext(entries[i - 1].id);
const agent = new Agent({ provider, context: contextUpToError });
```

---

## 性能优化

### 1. 懒加载

```typescript
// 只加载需要的部分
class LazySessionLoader {
  private index: Map<string, number>;  // id → line number

  constructor(sessionPath: string) {
    this.buildIndex(sessionPath);
  }

  // 构建索引（只读取 id 和 line number）
  private buildIndex(sessionPath: string): void {
    const lines = fs.readFileSync(sessionPath, 'utf-8').split('\n');
    this.index = new Map();

    lines.forEach((line, index) => {
      if (line.trim()) {
        const entry = JSON.parse(line);
        this.index.set(entry.id, index);
      }
    });
  }

  // 按需加载特定条目
  loadEntry(entryId: string): SessionEntry | undefined {
    const lineNumber = this.index.get(entryId);
    if (lineNumber === undefined) return undefined;

    const lines = fs.readFileSync(this.sessionPath, 'utf-8').split('\n');
    return JSON.parse(lines[lineNumber]);
  }
}
```

---

### 2. 缓存

```typescript
class CachedSessionLoader {
  private cache: Map<string, Message[]> = new Map();

  getContext(branchLeafId: string): Message[] {
    // 检查缓存
    if (this.cache.has(branchLeafId)) {
      return this.cache.get(branchLeafId)!;
    }

    // 加载并缓存
    const context = this.loadContext(branchLeafId);
    this.cache.set(branchLeafId, context);

    return context;
  }

  // 清除缓存
  clearCache(): void {
    this.cache.clear();
  }
}
```

---

### 3. 压缩

```typescript
// 对于非常大的 Session，可以压缩存储
import zlib from 'zlib';

class CompressedSessionWriter {
  private gzipStream: zlib.Gzip;
  private writeStream: fs.WriteStream;

  constructor(sessionPath: string) {
    this.writeStream = fs.createWriteStream(sessionPath + '.gz');
    this.gzipStream = zlib.createGzip();
    this.gzipStream.pipe(this.writeStream);
  }

  append(entry: SessionEntry): void {
    const line = JSON.stringify(entry) + '\n';
    this.gzipStream.write(line);
  }

  close(): void {
    this.gzipStream.end();
  }
}

// 读取压缩的 Session
class CompressedSessionLoader {
  load(sessionPath: string): SessionEntry[] {
    const content = fs.readFileSync(sessionPath);
    const decompressed = zlib.gunzipSync(content).toString('utf-8');
    const lines = decompressed.split('\n');

    return lines
      .filter(line => line.trim())
      .map(line => JSON.parse(line));
  }
}
```

---

## 总结

**状态恢复与迁移的核心要点：**

1. **Session 加载**：从 JSONL 文件重建上下文
2. **消息归一化**：统一不同 Provider 的消息格式
3. **跨 Provider 迁移**：Anthropic ↔ OpenAI ↔ Google
4. **增量恢复**：逐批加载大型 Session
5. **快照回滚**：保存和恢复特定时刻的状态
6. **性能优化**：懒加载、缓存、压缩

**关键洞察：**
- Session 是持久化的完整历史
- Context 是当前分支的工作记忆
- 归一化使得跨 Provider 迁移成为可能
- Thinking trace 等特有字段在迁移时可能丢失
- 增量加载和缓存优化大型 Session 的性能

**完成：** 至此，6 个核心概念全部讲解完毕。下一步生成实战代码示例。
