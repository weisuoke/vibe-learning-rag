# 实战代码06：手写结构化日志

## 学习目标

从零实现一个简单的结构化日志系统，深入理解structlog的工作原理。

---

## 为什么要手写？

**教育目的：** 通过手写实现，理解：
1. 日志处理器（Processor）的工作原理
2. 上下文管理的实现方式
3. JSON序列化的细节
4. 日志级别过滤的机制

**注意：** 生产环境应该使用成熟的库（如structlog），这里只是为了学习。

---

## 第一步：最简单的日志类

### 示例1：基础Logger

```python
# examples/logging/44_simple_logger.py
import json
from datetime import datetime
from typing import Any, Dict

class SimpleLogger:
    """最简单的结构化日志实现"""

    def log(self, event: str, **kwargs):
        """记录日志"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "event": event,
            **kwargs
        }

        # 输出JSON
        print(json.dumps(log_entry))

# 使用
logger = SimpleLogger()

logger.log("user_login", user_id="user_123", ip="192.168.1.1")
logger.log("api_call", endpoint="/users", method="GET")
```

**输出：**
```json
{"timestamp": "2024-01-15T10:30:45.123456Z", "event": "user_login", "user_id": "user_123", "ip": "192.168.1.1"}
{"timestamp": "2024-01-15T10:30:46.123456Z", "event": "api_call", "endpoint": "/users", "method": "GET"}
```

---

## 第二步：添加日志级别

### 示例2：支持日志级别

```python
# examples/logging/45_logger_with_levels.py
import json
from datetime import datetime
from typing import Any, Dict
from enum import IntEnum

class LogLevel(IntEnum):
    """日志级别"""
    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50

class Logger:
    """支持日志级别的Logger"""

    def __init__(self, min_level: LogLevel = LogLevel.INFO):
        self.min_level = min_level

    def _log(self, level: LogLevel, event: str, **kwargs):
        """内部日志方法"""
        # 过滤低于最小级别的日志
        if level < self.min_level:
            return

        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "level": level.name.lower(),
            "event": event,
            **kwargs
        }

        print(json.dumps(log_entry))

    def debug(self, event: str, **kwargs):
        self._log(LogLevel.DEBUG, event, **kwargs)

    def info(self, event: str, **kwargs):
        self._log(LogLevel.INFO, event, **kwargs)

    def warning(self, event: str, **kwargs):
        self._log(LogLevel.WARNING, event, **kwargs)

    def error(self, event: str, **kwargs):
        self._log(LogLevel.ERROR, event, **kwargs)

    def critical(self, event: str, **kwargs):
        self._log(LogLevel.CRITICAL, event, **kwargs)

# 使用
logger = Logger(min_level=LogLevel.INFO)

logger.debug("debug_message")  # 不会输出
logger.info("info_message")    # 会输出
logger.error("error_message")  # 会输出
```

---

## 第三步：实现处理器（Processor）

### 示例3：处理器链

```python
# examples/logging/46_processor_chain.py
import json
from datetime import datetime
from typing import Any, Dict, Callable, List

# 处理器类型
Processor = Callable[[Dict[str, Any]], Dict[str, Any]]

class Logger:
    """支持处理器链的Logger"""

    def __init__(self, processors: List[Processor] = None):
        self.processors = processors or []

    def log(self, event: str, **kwargs):
        """记录日志"""
        # 初始日志数据
        log_data = {
            "event": event,
            **kwargs
        }

        # 依次通过处理器
        for processor in self.processors:
            log_data = processor(log_data)

        # 输出
        print(json.dumps(log_data))

# 处理器实现
def add_timestamp(log_data: Dict[str, Any]) -> Dict[str, Any]:
    """添加时间戳处理器"""
    log_data["timestamp"] = datetime.utcnow().isoformat() + "Z"
    return log_data

def add_log_level(log_data: Dict[str, Any]) -> Dict[str, Any]:
    """添加日志级别处理器"""
    log_data["level"] = "info"
    return log_data

def add_hostname(log_data: Dict[str, Any]) -> Dict[str, Any]:
    """添加主机名处理器"""
    import socket
    log_data["hostname"] = socket.gethostname()
    return log_data

# 使用
logger = Logger(processors=[
    add_timestamp,
    add_log_level,
    add_hostname
])

logger.log("user_login", user_id="user_123")
```

**输出：**
```json
{"event": "user_login", "user_id": "user_123", "timestamp": "2024-01-15T10:30:45.123456Z", "level": "info", "hostname": "my-computer"}
```

---

## 第四步：实现上下文管理

### 示例4：手写上下文管理

```python
# examples/logging/47_context_management.py
import json
from datetime import datetime
from typing import Any, Dict, List, Callable
from contextvars import ContextVar

# 上下文变量
_context: ContextVar[Dict[str, Any]] = ContextVar("log_context", default={})

class Logger:
    """支持上下文的Logger"""

    def __init__(self, processors: List[Callable] = None):
        self.processors = processors or []

    def bind(self, **kwargs):
        """绑定上下文"""
        current_context = _context.get().copy()
        current_context.update(kwargs)
        _context.set(current_context)

    def unbind(self, *keys):
        """解绑上下文"""
        current_context = _context.get().copy()
        for key in keys:
            current_context.pop(key, None)
        _context.set(current_context)

    def clear(self):
        """清理上下文"""
        _context.set({})

    def log(self, event: str, **kwargs):
        """记录日志"""
        # 合并上下文和当前日志数据
        log_data = {
            **_context.get(),  # 上下文数据
            "event": event,
            **kwargs           # 当前日志数据
        }

        # 通过处理器
        for processor in self.processors:
            log_data = processor(log_data)

        print(json.dumps(log_data))

# 处理器
def add_timestamp(log_data: Dict[str, Any]) -> Dict[str, Any]:
    log_data["timestamp"] = datetime.utcnow().isoformat() + "Z"
    return log_data

# 使用
logger = Logger(processors=[add_timestamp])

# 绑定上下文
logger.bind(request_id="req_123", user_id="user_456")

# 所有日志自动包含上下文
logger.log("request_start")
logger.log("processing")
logger.log("request_end")

# 清理上下文
logger.clear()
```

**输出：**
```json
{"request_id": "req_123", "user_id": "user_456", "event": "request_start", "timestamp": "..."}
{"request_id": "req_123", "user_id": "user_456", "event": "processing", "timestamp": "..."}
{"request_id": "req_123", "user_id": "user_456", "event": "request_end", "timestamp": "..."}
```

---

## 第五步：实现多种输出格式

### 示例5：支持JSON和人类可读格式

```python
# examples/logging/48_multiple_formats.py
import json
from datetime import datetime
from typing import Any, Dict, List, Callable
from contextvars import ContextVar

_context: ContextVar[Dict[str, Any]] = ContextVar("log_context", default={})

class Renderer:
    """渲染器基类"""

    def render(self, log_data: Dict[str, Any]) -> str:
        raise NotImplementedError

class JSONRenderer(Renderer):
    """JSON渲染器"""

    def render(self, log_data: Dict[str, Any]) -> str:
        return json.dumps(log_data)

class ConsoleRenderer(Renderer):
    """人类可读渲染器"""

    def render(self, log_data: Dict[str, Any]) -> str:
        timestamp = log_data.get("timestamp", "")
        level = log_data.get("level", "info")
        event = log_data.get("event", "")

        # 提取其他字段
        other_fields = {k: v for k, v in log_data.items()
                       if k not in ["timestamp", "level", "event"]}

        # 格式化其他字段
        fields_str = " ".join(f"{k}={v}" for k, v in other_fields.items())

        return f"{timestamp} [{level:8}] {event:30} {fields_str}"

class Logger:
    """完整的Logger实现"""

    def __init__(
        self,
        processors: List[Callable] = None,
        renderer: Renderer = None
    ):
        self.processors = processors or []
        self.renderer = renderer or JSONRenderer()

    def bind(self, **kwargs):
        current_context = _context.get().copy()
        current_context.update(kwargs)
        _context.set(current_context)

    def clear(self):
        _context.set({})

    def log(self, event: str, **kwargs):
        log_data = {
            **_context.get(),
            "event": event,
            **kwargs
        }

        for processor in self.processors:
            log_data = processor(log_data)

        # 渲染并输出
        output = self.renderer.render(log_data)
        print(output)

# 处理器
def add_timestamp(log_data: Dict[str, Any]) -> Dict[str, Any]:
    log_data["timestamp"] = datetime.utcnow().isoformat() + "Z"
    return log_data

def add_level(log_data: Dict[str, Any]) -> Dict[str, Any]:
    log_data["level"] = "info"
    return log_data

# 测试JSON格式
print("=== JSON格式 ===")
json_logger = Logger(
    processors=[add_timestamp, add_level],
    renderer=JSONRenderer()
)

json_logger.bind(request_id="req_123")
json_logger.log("user_login", user_id="user_456")

# 测试人类可读格式
print("\n=== 人类可读格式 ===")
console_logger = Logger(
    processors=[add_timestamp, add_level],
    renderer=ConsoleRenderer()
)

console_logger.bind(request_id="req_123")
console_logger.log("user_login", user_id="user_456")
```

---

## 第六步：实现日志级别过滤

### 示例6：完整的日志级别支持

```python
# examples/logging/49_complete_logger.py
import json
from datetime import datetime
from typing import Any, Dict, List, Callable, Optional
from contextvars import ContextVar
from enum import IntEnum

_context: ContextVar[Dict[str, Any]] = ContextVar("log_context", default={})

class LogLevel(IntEnum):
    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50

class Renderer:
    def render(self, log_data: Dict[str, Any]) -> str:
        raise NotImplementedError

class JSONRenderer(Renderer):
    def render(self, log_data: Dict[str, Any]) -> str:
        return json.dumps(log_data)

class ConsoleRenderer(Renderer):
    def render(self, log_data: Dict[str, Any]) -> str:
        timestamp = log_data.get("timestamp", "")[:19]
        level = log_data.get("level", "info")
        event = log_data.get("event", "")

        other_fields = {k: v for k, v in log_data.items()
                       if k not in ["timestamp", "level", "event"]}

        fields_str = " ".join(f"{k}={v}" for k, v in other_fields.items())

        return f"{timestamp} [{level:8}] {event:30} {fields_str}"

class Logger:
    """完整的Logger实现"""

    def __init__(
        self,
        min_level: LogLevel = LogLevel.INFO,
        processors: List[Callable] = None,
        renderer: Renderer = None
    ):
        self.min_level = min_level
        self.processors = processors or []
        self.renderer = renderer or JSONRenderer()

    def bind(self, **kwargs):
        current_context = _context.get().copy()
        current_context.update(kwargs)
        _context.set(current_context)

    def clear(self):
        _context.set({})

    def _log(self, level: LogLevel, event: str, **kwargs):
        # 过滤
        if level < self.min_level:
            return

        log_data = {
            **_context.get(),
            "event": event,
            "level": level.name.lower(),
            **kwargs
        }

        for processor in self.processors:
            log_data = processor(log_data)

        output = self.renderer.render(log_data)
        print(output)

    def debug(self, event: str, **kwargs):
        self._log(LogLevel.DEBUG, event, **kwargs)

    def info(self, event: str, **kwargs):
        self._log(LogLevel.INFO, event, **kwargs)

    def warning(self, event: str, **kwargs):
        self._log(LogLevel.WARNING, event, **kwargs)

    def error(self, event: str, **kwargs):
        self._log(LogLevel.ERROR, event, **kwargs)

    def critical(self, event: str, **kwargs):
        self._log(LogLevel.CRITICAL, event, **kwargs)

# 处理器
def add_timestamp(log_data: Dict[str, Any]) -> Dict[str, Any]:
    log_data["timestamp"] = datetime.utcnow().isoformat() + "Z"
    return log_data

# 使用
logger = Logger(
    min_level=LogLevel.INFO,
    processors=[add_timestamp],
    renderer=ConsoleRenderer()
)

logger.bind(request_id="req_123")

logger.debug("debug_message")    # 不会输出
logger.info("info_message")      # 会输出
logger.warning("warning_message")  # 会输出
logger.error("error_message")    # 会输出
```

---

## 第七步：实现文件输出

### 示例7：支持文件输出

```python
# examples/logging/50_file_output.py
import json
from datetime import datetime
from typing import Any, Dict, List, Callable, Optional, TextIO
from contextvars import ContextVar
from enum import IntEnum
import sys

_context: ContextVar[Dict[str, Any]] = ContextVar("log_context", default={})

class LogLevel(IntEnum):
    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50

class Renderer:
    def render(self, log_data: Dict[str, Any]) -> str:
        raise NotImplementedError

class JSONRenderer(Renderer):
    def render(self, log_data: Dict[str, Any]) -> str:
        return json.dumps(log_data)

class Logger:
    """支持文件输出的Logger"""

    def __init__(
        self,
        min_level: LogLevel = LogLevel.INFO,
        processors: List[Callable] = None,
        renderer: Renderer = None,
        output: TextIO = None
    ):
        self.min_level = min_level
        self.processors = processors or []
        self.renderer = renderer or JSONRenderer()
        self.output = output or sys.stdout

    def bind(self, **kwargs):
        current_context = _context.get().copy()
        current_context.update(kwargs)
        _context.set(current_context)

    def clear(self):
        _context.set({})

    def _log(self, level: LogLevel, event: str, **kwargs):
        if level < self.min_level:
            return

        log_data = {
            **_context.get(),
            "event": event,
            "level": level.name.lower(),
            **kwargs
        }

        for processor in self.processors:
            log_data = processor(log_data)

        output = self.renderer.render(log_data)

        # 写入输出
        self.output.write(output + "\n")
        self.output.flush()

    def info(self, event: str, **kwargs):
        self._log(LogLevel.INFO, event, **kwargs)

    def error(self, event: str, **kwargs):
        self._log(LogLevel.ERROR, event, **kwargs)

# 处理器
def add_timestamp(log_data: Dict[str, Any]) -> Dict[str, Any]:
    log_data["timestamp"] = datetime.utcnow().isoformat() + "Z"
    return log_data

# 使用：输出到文件
with open("app.log", "a") as f:
    logger = Logger(
        processors=[add_timestamp],
        renderer=JSONRenderer(),
        output=f
    )

    logger.bind(request_id="req_123")
    logger.info("user_login", user_id="user_456")
    logger.error("api_failed", error="timeout")

print("日志已写入 app.log")
```

---

## 第八步：完整的手写实现

### 示例8：生产级手写Logger

```python
# my_logger.py
"""
手写的结构化日志系统

这是一个教育性的实现，展示了结构化日志的核心原理。
生产环境应该使用成熟的库（如structlog）。
"""

import json
import sys
from datetime import datetime
from typing import Any, Dict, List, Callable, Optional, TextIO
from contextvars import ContextVar
from enum import IntEnum

# 全局上下文
_context: ContextVar[Dict[str, Any]] = ContextVar("log_context", default={})

class LogLevel(IntEnum):
    """日志级别"""
    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50

class Renderer:
    """渲染器基类"""

    def render(self, log_data: Dict[str, Any]) -> str:
        raise NotImplementedError

class JSONRenderer(Renderer):
    """JSON渲染器"""

    def __init__(self, indent: Optional[int] = None):
        self.indent = indent

    def render(self, log_data: Dict[str, Any]) -> str:
        return json.dumps(log_data, indent=self.indent, ensure_ascii=False)

class ConsoleRenderer(Renderer):
    """人类可读渲染器"""

    def render(self, log_data: Dict[str, Any]) -> str:
        timestamp = log_data.get("timestamp", "")[:19]
        level = log_data.get("level", "info").upper()
        event = log_data.get("event", "")

        # 提取其他字段
        other_fields = {k: v for k, v in log_data.items()
                       if k not in ["timestamp", "level", "event"]}

        # 格式化
        fields_str = " ".join(f"{k}={v}" for k, v in other_fields.items())

        # 颜色（可选）
        level_colors = {
            "DEBUG": "\033[36m",    # 青色
            "INFO": "\033[32m",     # 绿色
            "WARNING": "\033[33m",  # 黄色
            "ERROR": "\033[31m",    # 红色
            "CRITICAL": "\033[35m"  # 紫色
        }
        reset = "\033[0m"

        color = level_colors.get(level, "")

        return f"{timestamp} {color}[{level:8}]{reset} {event:30} {fields_str}"

class Logger:
    """完整的Logger实现"""

    def __init__(
        self,
        name: str = "root",
        min_level: LogLevel = LogLevel.INFO,
        processors: List[Callable] = None,
        renderer: Renderer = None,
        output: TextIO = None
    ):
        self.name = name
        self.min_level = min_level
        self.processors = processors or []
        self.renderer = renderer or JSONRenderer()
        self.output = output or sys.stdout

    def bind(self, **kwargs):
        """绑定上下文"""
        current_context = _context.get().copy()
        current_context.update(kwargs)
        _context.set(current_context)

    def unbind(self, *keys):
        """解绑上下文"""
        current_context = _context.get().copy()
        for key in keys:
            current_context.pop(key, None)
        _context.set(current_context)

    def clear(self):
        """清理上下文"""
        _context.set({})

    def _log(self, level: LogLevel, event: str, **kwargs):
        """内部日志方法"""
        # 级别过滤
        if level < self.min_level:
            return

        # 构建日志数据
        log_data = {
            **_context.get(),  # 上下文
            "event": event,
            "level": level.name.lower(),
            **kwargs
        }

        # 通过处理器
        for processor in self.processors:
            try:
                log_data = processor(log_data)
            except Exception as e:
                # 处理器失败不应该影响日志记录
                print(f"Processor failed: {e}", file=sys.stderr)

        # 渲染
        try:
            output = self.renderer.render(log_data)
        except Exception as e:
            # 渲染失败，使用简单格式
            output = f"[RENDER ERROR] {log_data}"

        # 输出
        try:
            self.output.write(output + "\n")
            self.output.flush()
        except Exception as e:
            print(f"Failed to write log: {e}", file=sys.stderr)

    def debug(self, event: str, **kwargs):
        self._log(LogLevel.DEBUG, event, **kwargs)

    def info(self, event: str, **kwargs):
        self._log(LogLevel.INFO, event, **kwargs)

    def warning(self, event: str, **kwargs):
        self._log(LogLevel.WARNING, event, **kwargs)

    def error(self, event: str, **kwargs):
        self._log(LogLevel.ERROR, event, **kwargs)

    def critical(self, event: str, **kwargs):
        self._log(LogLevel.CRITICAL, event, **kwargs)

# 常用处理器
def add_timestamp(log_data: Dict[str, Any]) -> Dict[str, Any]:
    """添加时间戳"""
    log_data["timestamp"] = datetime.utcnow().isoformat() + "Z"
    return log_data

def add_hostname(log_data: Dict[str, Any]) -> Dict[str, Any]:
    """添加主机名"""
    import socket
    log_data["hostname"] = socket.gethostname()
    return log_data

def mask_sensitive_data(log_data: Dict[str, Any]) -> Dict[str, Any]:
    """脱敏敏感数据"""
    sensitive_keys = ["password", "api_key", "token", "secret"]

    for key in sensitive_keys:
        if key in log_data:
            value = log_data[key]
            if isinstance(value, str) and len(value) > 8:
                log_data[key] = value[:4] + "***" + value[-4:]
            else:
                log_data[key] = "***REDACTED***"

    return log_data

# 工厂函数
def get_logger(
    name: str = "root",
    json_output: bool = False,
    min_level: LogLevel = LogLevel.INFO
) -> Logger:
    """获取Logger实例"""

    processors = [
        add_timestamp,
        mask_sensitive_data
    ]

    if json_output:
        renderer = JSONRenderer()
    else:
        renderer = ConsoleRenderer()

    return Logger(
        name=name,
        min_level=min_level,
        processors=processors,
        renderer=renderer
    )

# 使用示例
if __name__ == "__main__":
    # 创建logger
    logger = get_logger(json_output=False)

    # 绑定上下文
    logger.bind(request_id="req_123", user_id="user_456")

    # 记录日志
    logger.debug("debug_message", x=1)
    logger.info("user_login", ip="192.168.1.1")
    logger.warning("slow_query", duration_ms=3000)
    logger.error("api_failed", error="timeout")

    # 测试敏感数据脱敏
    logger.info("auth", api_key="sk-1234567890abcdef")

    # 清理上下文
    logger.clear()
```

---

## 对比：手写 vs structlog

### 功能对比

| 功能 | 手写实现 | structlog |
|------|---------|-----------|
| 基础日志 | ✅ | ✅ |
| 日志级别 | ✅ | ✅ |
| 处理器链 | ✅ | ✅ |
| 上下文管理 | ✅ | ✅ |
| 多种渲染器 | ✅ | ✅ |
| 性能优化 | ❌ | ✅ |
| 异步支持 | ❌ | ✅ |
| 标准库集成 | ❌ | ✅ |
| 测试覆盖 | ❌ | ✅ |
| 文档完善 | ❌ | ✅ |

### 代码对比

**手写实现：**
```python
from my_logger import get_logger

logger = get_logger()
logger.bind(request_id="req_123")
logger.info("user_login", user_id="user_456")
```

**structlog：**
```python
import structlog

logger = structlog.get_logger()
structlog.contextvars.bind_contextvars(request_id="req_123")
logger.info("user_login", user_id="user_456")
```

**结论：** API几乎相同，但structlog更成熟、更高效。

---

## 学到了什么？

### 核心原理

1. **处理器链模式**
   - 日志数据依次通过多个处理器
   - 每个处理器负责一个功能
   - 灵活组合

2. **上下文管理**
   - 使用contextvars存储上下文
   - 异步安全
   - 自动传递

3. **渲染器模式**
   - 分离数据和表现
   - 支持多种输出格式
   - 易于扩展

4. **日志级别过滤**
   - 在记录前过滤
   - 减少性能开销
   - 灵活控制

### 为什么使用structlog？

1. **性能优化**：经过大量优化
2. **功能完善**：支持更多特性
3. **稳定可靠**：经过充分测试
4. **社区支持**：活跃的社区
5. **标准集成**：与标准库无缝集成

---

## 总结

### 核心要点

1. **手写实现帮助理解原理**
   - 处理器链
   - 上下文管理
   - 渲染器模式

2. **生产环境使用成熟库**
   - structlog
   - python-json-logger
   - 标准库logging

3. **关键设计模式**
   - 责任链模式（处理器）
   - 策略模式（渲染器）
   - 上下文管理（contextvars）

### 最佳实践

1. 学习时手写实现理解原理
2. 生产环境使用成熟库
3. 理解核心设计模式
4. 根据需求选择合适的库

### 下一步

- 【实战代码07】：生产级日志系统
- 【实战代码08】：AI Agent日志监控
