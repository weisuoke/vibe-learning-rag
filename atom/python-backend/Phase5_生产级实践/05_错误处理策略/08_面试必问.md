# 错误处理策略 - 面试必问

## 问题："如何设计一个生产级的错误处理策略？"

**普通回答（❌ 不出彩）：**
"使用 try-catch 捕获异常，记录日志，返回错误信息给用户。"

**出彩回答（✅ 推荐）：**

> **错误处理策略需要从三个层面设计：**
>
> **1. 异常分层（分类处理）**
> - 业务异常（422）：用户输入错误，可以修正
> - 系统异常（500）：数据库连接失败，需要开发者介入
> - 外部服务异常（503）：LLM API 失败，需要重试或降级
>
> **2. 自动恢复机制**
> - 重试机制：临时性错误（网络抖动、Rate Limit）自动重试 3 次，指数退避（1s, 2s, 4s）
> - 熔断器：失败率超过 50% 时打开熔断器，30 秒后尝试恢复，防止雪崩
> - 超时控制：所有外部调用设置超时（LLM 30s，数据库 5s），防止资源泄漏
>
> **3. 可观测性**
> - 结构化日志：使用 structlog 记录 JSON 格式日志
> - Request ID：追踪请求完整生命周期
> - 错误上下文：收集请求、错误、业务上下文
> - 错误监控：集成 Sentry 进行错误追踪和告警
>
> **在 AI Agent API 中的实践：**
> - LLM 调用失败 → 重试 3 次 → 熔断保护 → 降级响应（返回缓存）
> - 数据库连接失败 → 重试 3 次 → 记录详细日志 → 返回 500
> - 用户输入错误 → 立即返回 422 → 提示如何修正

**为什么这个回答出彩？**
1. ✅ 系统化思考：从分类、恢复、监控三个层面设计
2. ✅ 具体数字：重试 3 次、失败率 50%、超时 30s
3. ✅ 实际应用：联系 AI Agent API 的具体场景
4. ✅ 展示深度：不仅知道怎么做，还知道为什么这么做

---

## 问题："重试机制和熔断器有什么区别？"

**普通回答（❌ 不出彩）：**
"重试是失败后再试一次，熔断器是失败太多次就不再尝试。"

**出彩回答（✅ 推荐）：**

> **重试机制和熔断器是两种互补的错误处理策略：**
>
> **重试机制（Retry）：**
> - **目的**：自动恢复临时性故障
> - **触发条件**：单次请求失败
> - **作用范围**：单个请求
> - **适用场景**：网络抖动、Rate Limit、服务临时过载
> - **实现**：指数退避（1s, 2s, 4s），最多重试 3 次
>
> **熔断器（Circuit Breaker）：**
> - **目的**：防止雪崩效应，保护服务
> - **触发条件**：失败率超过阈值（如 50%）
> - **作用范围**：所有请求
> - **适用场景**：服务持续故障，无法短时间恢复
> - **实现**：三状态状态机（Closed → Open → Half-Open）
>
> **协作使用：**
> ```
> 请求失败 → 重试 3 次（指数退避）
>   ↓
> 重试失败 → 熔断器记录失败
>   ↓
> 失败率 > 50% → 熔断器打开
>   ↓
> 后续请求 → 立即返回错误（不再重试）
>   ↓
> 30 秒后 → 熔断器进入半开状态 → 测试请求
>   ↓
> 测试成功 → 熔断器关闭 → 恢复正常
> ```
>
> **类比：**
> - 重试 = 打电话占线，重拨 3 次
> - 熔断器 = 电话一直占线，停止拨打，30 秒后再试

**为什么这个回答出彩？**
1. ✅ 对比清晰：从目的、触发条件、作用范围、适用场景对比
2. ✅ 协作关系：说明两者如何配合使用
3. ✅ 具体数字：重试 3 次、失败率 50%、超时 30 秒
4. ✅ 生动类比：用打电话类比，易于理解
