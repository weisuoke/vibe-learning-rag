# 化骨绵掌 - 10个知识卡片

## 卡片1：Kubernetes的本质是什么？

**一句话：** Kubernetes是一个声明式的容器编排系统，通过控制循环持续调谐实际状态到期望状态。

**举例：**
```yaml
# 你声明期望状态
apiVersion: apps/v1
kind: Deployment
spec:
  replicas: 3  # 我要3个副本

# Kubernetes持续工作
while true:
    if 当前副本数 != 3:
        调整到3个
    sleep(10秒)
```

**应用：** 在RAG系统中，你只需声明"我要5个QueryNode"，Kubernetes自动创建、监控、恢复，无需人工干预。

---

## 卡片2：Helm解决了什么问题？

**一句话：** Helm将多个Kubernetes资源打包成可复用、可配置的Chart，解决了配置管理和版本控制问题。

**举例：**
```bash
# 没有Helm：管理11个YAML文件
kubectl apply -f proxy.yaml
kubectl apply -f querynode.yaml
# ... 9个文件

# 有Helm：一条命令
helm install milvus milvus/milvus

# 不同环境不同配置
helm install milvus-dev milvus/milvus -f dev-values.yaml
helm install milvus-prod milvus/milvus -f prod-values.yaml
```

**应用：** RAG系统需要在开发、测试、生产环境部署，Helm让你用一套Chart + 不同values.yaml管理所有环境。

---

## 卡片3：Operator比Helm高级在哪里？

**一句话：** Operator = Helm + 持续运维逻辑 + 领域知识，它不仅部署应用，还持续监控和自动化运维。

**举例：**
```python
# Helm：一次性操作
helm install milvus milvus/milvus
# 部署完就结束了

# Operator：持续运行
while true:
    if querynode_cpu > 80%:
        scale_up()  # 自动扩容
    if pod_crashed:
        restart()   # 自动重启
    if backup_time:
        backup()    # 自动备份
    sleep(10)
```

**应用：** 大规模RAG系统需要自动化运维，Operator可以自动扩缩容、故障恢复、定时备份，减少人工介入。

---

## 卡片4：Deployment vs StatefulSet的本质区别

**一句话：** Deployment管理无状态应用（Pod可随意替换），StatefulSet管理有状态应用（Pod有固定身份和存储）。

**举例：**
```yaml
# Deployment：Pod名称随机
milvus-proxy-7d8f9c-abc123
milvus-proxy-7d8f9c-def456
# 删除重建 → 名称变化，但功能一样

# StatefulSet：Pod名称固定
milvus-datanode-0
milvus-datanode-1
# 删除重建 → 名称不变，数据持久化
```

**应用：** Milvus的Proxy/QueryNode用Deployment（无状态），DataNode/Coordinator用StatefulSet（有状态，需要持久化数据）。

---

## 卡片5：Pod反亲和性为什么重要？

**一句话：** Pod反亲和性确保副本分布在不同节点，避免单节点故障导致服务中断。

**举例：**
```yaml
# 没有反亲和性
节点A：querynode-0, querynode-1, querynode-2
节点B：空
节点C：空
# 节点A故障 → 所有QueryNode挂掉 → 服务中断

# 有反亲和性
节点A：querynode-0
节点B：querynode-1
节点C：querynode-2
# 节点A故障 → 只有querynode-0挂掉 → 服务继续
```

**应用：** RAG系统的向量检索服务需要高可用，配置反亲和性后，单节点故障不影响服务。

---

## 卡片6：HPA如何工作？

**一句话：** HPA（Horizontal Pod Autoscaler）根据CPU/内存等指标自动调整Pod副本数。

**举例：**
```yaml
minReplicas: 2
maxReplicas: 20
targetCPUUtilizationPercentage: 70

# 工作流程
当前CPU: 85% > 70% → 扩容（增加副本）
当前CPU: 50% < 70% → 缩容（减少副本）
```

**应用：** 文档问答系统流量波动大（白天1000 QPS，夜间100 QPS），HPA自动调整QueryNode数量，节省60-80%成本。

---

## 卡片7：Service的作用是什么？

**一句话：** Service提供稳定的访问入口和负载均衡，屏蔽Pod的动态变化。

**举例：**
```python
# 没有Service：直接访问Pod IP
connect("10.0.1.10:19530")  # Pod重启 → IP变化 → 连接失败

# 有Service：访问Service名称
connect("milvus-proxy.default.svc.cluster.local:19530")
# Pod重启 → Service自动更新后端 → 连接正常
```

**应用：** RAG系统的客户端连接Milvus时，使用Service名称而非Pod IP，Pod重启或扩缩容不影响连接。

---

## 卡片8：ConfigMap vs Secret的区别

**一句话：** ConfigMap存储非敏感配置，Secret存储敏感信息（密码、密钥），Secret会base64编码。

**举例：**
```yaml
# ConfigMap：普通配置
apiVersion: v1
kind: ConfigMap
data:
  log.level: "info"
  segment.maxSize: "1024"

# Secret：敏感信息
apiVersion: v1
kind: Secret
type: Opaque
data:
  s3-access-key: bWluaW9hZG1pbg==  # base64编码
  s3-secret-key: bWluaW9hZG1pbjEyMw==
```

**应用：** Milvus的日志级别、segment大小用ConfigMap，S3的access key/secret key用Secret。

---

## 卡片9：滚动更新如何实现零停机？

**一句话：** 滚动更新逐个替换Pod，确保始终有足够的副本在线，实现零停机部署。

**举例：**
```yaml
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1        # 最多多1个Pod
    maxUnavailable: 0  # 最多少0个Pod

# 更新过程（3个副本）
1. 创建新Pod-4（总共4个）
2. 等待Pod-4就绪
3. 删除旧Pod-1（总共3个）
4. 创建新Pod-5（总共4个）
5. 等待Pod-5就绪
6. 删除旧Pod-2（总共3个）
7. 创建新Pod-6（总共4个）
8. 等待Pod-6就绪
9. 删除旧Pod-3（总共3个）
# 整个过程始终有3个Pod在线
```

**应用：** RAG系统升级Milvus版本时，滚动更新确保服务不中断，用户无感知。

---

## 卡片10：资源requests vs limits的区别

**一句话：** requests是保证分配的资源，limits是最大可使用的资源，超过limits会被杀掉（OOM）。

**举例：**
```yaml
resources:
  requests:
    cpu: 4        # Kubernetes保证分配4核
    memory: 16Gi  # Kubernetes保证分配16GB
  limits:
    cpu: 8        # 最多使用8核（超过会被限流）
    memory: 32Gi  # 最多使用32GB（超过会被OOM杀掉）

# 调度决策
节点剩余资源：6核CPU，20GB内存
requests: 4核，16GB → 可以调度 ✅
limits: 8核，32GB → 不影响调度决策
```

**应用：** QueryNode配置requests=16Gi确保有足够内存加载向量，limits=32Gi防止内存泄漏影响其他Pod。

---

## 知识卡片总结

### 核心概念关系图

```
Kubernetes（容器编排平台）
    ├── Helm（包管理器）
    │   └── Chart（应用包）
    │       └── values.yaml（配置）
    │
    ├── Operator（自动化运维）
    │   ├── CRD（自定义资源）
    │   └── Controller（控制器）
    │
    ├── 工作负载
    │   ├── Deployment（无状态）
    │   └── StatefulSet（有状态）
    │
    ├── 网络
    │   ├── Service（服务发现）
    │   └── Ingress（外部访问）
    │
    ├── 配置
    │   ├── ConfigMap（普通配置）
    │   └── Secret（敏感信息）
    │
    ├── 存储
    │   └── PersistentVolume（持久化）
    │
    └── 自动化
        ├── HPA（水平扩缩容）
        └── VPA（垂直扩缩容）
```

### 10个卡片的学习路径

```
基础概念（卡片1-4）
    ↓
Kubernetes是什么 → Helm解决什么 → Operator高级在哪 → Deployment vs StatefulSet
    ↓
高可用配置（卡片5-7）
    ↓
Pod反亲和性 → HPA自动扩缩容 → Service负载均衡
    ↓
配置管理（卡片8-10）
    ↓
ConfigMap vs Secret → 滚动更新 → 资源配置
```

### 在RAG系统中的应用总结

| 卡片 | RAG应用场景 | 价值 |
|------|-----------|------|
| 1. Kubernetes本质 | 声明式管理Milvus集群 | 自动化运维 |
| 2. Helm | 多环境部署（开发/测试/生产） | 配置管理 |
| 3. Operator | 大规模集群自动化 | 降低运维成本 |
| 4. Deployment vs StatefulSet | 正确选择工作负载类型 | 性能优化 |
| 5. Pod反亲和性 | 向量检索服务高可用 | 99.9%可用性 |
| 6. HPA | 应对流量波动 | 节省60-80%成本 |
| 7. Service | 客户端稳定连接 | 服务稳定性 |
| 8. ConfigMap vs Secret | 安全配置管理 | 数据安全 |
| 9. 滚动更新 | 零停机升级 | 用户无感知 |
| 10. 资源配置 | 防止OOM | 服务稳定性 |

---

## 快速记忆口诀

```
Kubernetes声明式，控制循环持续调
Helm打包配置化，一键部署真高效
Operator更智能，自动运维不用愁
Deployment无状态，StatefulSet有身份
Pod反亲和性，高可用不担心
HPA自动扩，流量波动不用慌
Service做代理，负载均衡真方便
ConfigMap存配置，Secret藏密钥
滚动更新零停机，用户体验不打折
资源配置要合理，requests保证limits限
```

---

## 学习检查清单

通过10个卡片，你应该能够回答：

- [ ] Kubernetes的核心工作原理是什么？
- [ ] Helm解决了什么问题？
- [ ] Operator和Helm有什么区别？
- [ ] 什么时候用Deployment，什么时候用StatefulSet？
- [ ] 如何保证Milvus集群的高可用？
- [ ] HPA如何根据负载自动扩缩容？
- [ ] Service如何提供稳定的访问入口？
- [ ] ConfigMap和Secret有什么区别？
- [ ] 滚动更新如何实现零停机？
- [ ] 资源requests和limits有什么区别？

---

## 下一步学习

掌握这10个知识卡片后，你已经具备了：
- ✅ Kubernetes核心概念的理解
- ✅ Milvus在Kubernetes上部署的能力
- ✅ 生产环境配置和优化的知识

继续深入学习：
- **实战代码**：完成所有部署场景的实践
- **监控告警**：学习Prometheus + Grafana
- **故障排查**：掌握常见问题的解决方法
- **性能优化**：调优资源配置和网络性能
