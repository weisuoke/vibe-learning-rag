# 07_实战代码_02_AVL树实现

## 场景描述

**目标：** 实现完整的AVL树，包含自动平衡维护

**应用场景：**
- 需要严格O(log n)性能保证的场景
- 查找密集型应用
- 对话历史的时间索引

---

## 完整实现

```python
"""
AVL树完整实现
自动维护平衡，保证所有操作O(log n)
"""

from typing import Optional, List, Any
from dataclasses import dataclass


@dataclass
class AVLNode:
    """AVL树节点"""
    val: int
    left: Optional['AVLNode'] = None
    right: Optional['AVLNode'] = None
    height: int = 1
    data: Any = None

    def __repr__(self):
        return f"AVLNode({self.val}, h={self.height})"


class AVLTree:
    """AVL树实现"""

    def __init__(self):
        self.root: Optional[AVLNode] = None
        self.size = 0

    # ==================== 辅助方法 ====================

    def height(self, node: Optional[AVLNode]) -> int:
        """获取节点高度"""
        return node.height if node else 0

    def balance_factor(self, node: Optional[AVLNode]) -> int:
        """计算平衡因子 = 左子树高度 - 右子树高度"""
        if not node:
            return 0
        return self.height(node.left) - self.height(node.right)

    def update_height(self, node: AVLNode) -> None:
        """更新节点高度"""
        node.height = max(self.height(node.left), self.height(node.right)) + 1

    # ==================== 旋转操作 ====================

    def rotate_right(self, y: AVLNode) -> AVLNode:
        """
        右旋（LL情况）
              y                x
             / \              / \
            x   T3    →      T1  y
           / \                  / \
          T1 T2                T2 T3
        """
        x = y.left
        T2 = x.right

        # 执行旋转
        x.right = y
        y.left = T2

        # 更新高度（先更新y，再更新x）
        self.update_height(y)
        self.update_height(x)

        return x  # 新的根节点

    def rotate_left(self, x: AVLNode) -> AVLNode:
        """
        左旋（RR情况）
            x                y
           / \              / \
          T1  y     →      x  T3
             / \          / \
            T2 T3        T1 T2
        """
        y = x.right
        T2 = y.left

        # 执行旋转
        y.left = x
        x.right = T2

        # 更新高度
        self.update_height(x)
        self.update_height(y)

        return y  # 新的根节点

    # ==================== 平衡维护 ====================

    def balance(self, node: AVLNode) -> AVLNode:
        """
        平衡节点
        根据平衡因子判断并执行相应的旋转
        """
        # 更新高度
        self.update_height(node)

        # 计算平衡因子
        bf = self.balance_factor(node)

        # LL情况：左子树的左子树太高
        if bf > 1 and self.balance_factor(node.left) >= 0:
            return self.rotate_right(node)

        # RR情况：右子树的右子树太高
        if bf < -1 and self.balance_factor(node.right) <= 0:
            return self.rotate_left(node)

        # LR情况：左子树的右子树太高
        if bf > 1 and self.balance_factor(node.left) < 0:
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)

        # RL情况：右子树的左子树太高
        if bf < -1 and self.balance_factor(node.right) > 0:
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node

    # ==================== 核心操作 ====================

    def insert(self, val: int, data: Any = None) -> None:
        """插入值并自动平衡"""
        self.root = self._insert(self.root, val, data)
        self.size += 1

    def _insert(self, node: Optional[AVLNode], val: int, data: Any) -> AVLNode:
        """递归插入"""
        # 1. 标准BST插入
        if not node:
            return AVLNode(val, data=data)

        if val < node.val:
            node.left = self._insert(node.left, val, data)
        elif val > node.val:
            node.right = self._insert(node.right, val, data)
        else:
            # 重复值：更新数据
            node.data = data
            return node

        # 2. 平衡节点
        return self.balance(node)

    def delete(self, val: int) -> bool:
        """删除值并自动平衡"""
        if not self.search(val):
            return False

        self.root = self._delete(self.root, val)
        self.size -= 1
        return True

    def _delete(self, node: Optional[AVLNode], val: int) -> Optional[AVLNode]:
        """递归删除"""
        if not node:
            return None

        # 1. 标准BST删除
        if val < node.val:
            node.left = self._delete(node.left, val)
        elif val > node.val:
            node.right = self._delete(node.right, val)
        else:
            # 找到要删除的节点
            if not node.left:
                return node.right
            if not node.right:
                return node.left

            # 双子节点：用后继节点替换
            successor = self._find_min(node.right)
            node.val = successor.val
            node.data = successor.data
            node.right = self._delete(node.right, successor.val)

        # 2. 平衡节点
        return self.balance(node)

    def search(self, val: int) -> Optional[AVLNode]:
        """查找值"""
        return self._search(self.root, val)

    def _search(self, node: Optional[AVLNode], val: int) -> Optional[AVLNode]:
        """递归查找"""
        if not node or node.val == val:
            return node

        if val < node.val:
            return self._search(node.left, val)
        return self._search(node.right, val)

    # ==================== 辅助操作 ====================

    def _find_min(self, node: AVLNode) -> AVLNode:
        """找到最小值节点"""
        while node.left:
            node = node.left
        return node

    def inorder(self) -> List[int]:
        """中序遍历"""
        result = []
        self._inorder(self.root, result)
        return result

    def _inorder(self, node: Optional[AVLNode], result: List[int]) -> None:
        """递归中序遍历"""
        if node:
            self._inorder(node.left, result)
            result.append(node.val)
            self._inorder(node.right, result)

    def is_balanced(self) -> bool:
        """验证AVL树是否平衡"""
        def check(node: Optional[AVLNode]) -> bool:
            if not node:
                return True

            bf = self.balance_factor(node)
            if abs(bf) > 1:
                return False

            return check(node.left) and check(node.right)

        return check(self.root)

    def get_structure(self) -> List[str]:
        """获取树结构（用于可视化）"""
        lines = []

        def build_lines(node: Optional[AVLNode], prefix: str = "", is_tail: bool = True):
            if not node:
                return

            lines.append(f"{prefix}{'└── ' if is_tail else '├── '}{node.val} (h={node.height}, bf={self.balance_factor(node)})")

            children = [node.left, node.right]
            for i, child in enumerate(children):
                if child:
                    extension = "    " if is_tail else "│   "
                    build_lines(child, prefix + extension, i == len([c for c in children if c]) - 1)

        build_lines(self.root)
        return lines

    def __len__(self) -> int:
        """返回节点数量"""
        return self.size

    def __repr__(self) -> str:
        """字符串表示"""
        if not self.root:
            return "AVLTree(empty)"
        return f"AVLTree(size={self.size}, height={self.height(self.root)}, balanced={self.is_balanced()})"


# ==================== 测试代码 ====================

def test_avl_tree():
    """测试AVL树的所有功能"""
    print("=" * 60)
    print("AVL树完整测试")
    print("=" * 60)

    # 1. 创建AVL树并插入数据
    avl = AVLTree()
    values = [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 65]

    print("\n1. 插入数据:", values)
    for val in values:
        avl.insert(val)
        print(f"   插入{val}后: 高度={avl.height(avl.root)}, 平衡={avl.is_balanced()}")

    print(f"\n   最终AVL树: {avl}")
    print(f"   有序序列: {avl.inorder()}")

    # 2. 树结构可视化
    print("\n2. 树结构:")
    for line in avl.get_structure():
        print(f"   {line}")

    # 3. 测试最坏情况（有序插入）
    print("\n3. 有序插入测试（最坏情况）:")
    avl_ordered = AVLTree()
    ordered_values = list(range(1, 16))

    print(f"   插入序列: {ordered_values}")
    for val in ordered_values:
        avl_ordered.insert(val)

    print(f"   AVL树: {avl_ordered}")
    print(f"   高度: {avl_ordered.height(avl_ordered.root)} (理想高度: {len(ordered_values).bit_length()})")
    print(f"   是否平衡: {avl_ordered.is_balanced()}")

    print("\n   树结构:")
    for line in avl_ordered.get_structure()[:10]:  # 只显示前10行
        print(f"   {line}")

    # 4. 删除测试
    print("\n4. 删除测试:")
    delete_vals = [20, 30, 50]
    for val in delete_vals:
        success = avl.delete(val)
        print(f"   删除{val}: {'成功' if success else '失败'}")
        print(f"   高度={avl.height(avl.root)}, 平衡={avl.is_balanced()}")

    print(f"   当前序列: {avl.inorder()}")

    # 5. 性能对比：AVL vs 普通BST
    print("\n5. 性能对比（有序插入10000个节点）:")
    import time

    # AVL树
    avl_perf = AVLTree()
    start = time.time()
    for i in range(10000):
        avl_perf.insert(i)
    avl_time = time.time() - start

    # 普通BST（模拟）
    from collections import deque
    bst_height = 10000  # 退化为链表

    print(f"   AVL树:")
    print(f"     插入时间: {avl_time:.4f}秒")
    print(f"     树高: {avl_perf.height(avl_perf.root)}")
    print(f"     理论高度: {10000.bit_length()}")

    print(f"   普通BST（有序插入）:")
    print(f"     树高: {bst_height} (退化为链表)")

    # 查找性能对比
    start = time.time()
    for i in range(0, 10000, 100):
        avl_perf.search(i)
    avl_search_time = time.time() - start

    print(f"\n   查找100次:")
    print(f"     AVL树: {avl_search_time:.4f}秒")
    print(f"     普通BST: ~{avl_search_time * (bst_height / avl_perf.height(avl_perf.root)):.4f}秒 (估算)")

    # 6. 旋转统计
    print("\n6. 旋转操作演示:")
    demo_avl = AVLTree()

    # LL情况
    print("   LL情况（插入1, 2, 3）:")
    for val in [3, 2, 1]:
        demo_avl.insert(val)
    for line in demo_avl.get_structure():
        print(f"     {line}")

    # RR情况
    demo_avl = AVLTree()
    print("\n   RR情况（插入3, 2, 1）:")
    for val in [1, 2, 3]:
        demo_avl.insert(val)
    for line in demo_avl.get_structure():
        print(f"     {line}")

    # LR情况
    demo_avl = AVLTree()
    print("\n   LR情况（插入3, 1, 2）:")
    for val in [3, 1, 2]:
        demo_avl.insert(val)
    for line in demo_avl.get_structure():
        print(f"     {line}")

    # RL情况
    demo_avl = AVLTree()
    print("\n   RL情况（插入1, 3, 2）:")
    for val in [1, 3, 2]:
        demo_avl.insert(val)
    for line in demo_avl.get_structure():
        print(f"     {line}")


# ==================== AI Agent应用示例 ====================

class ConversationHistoryIndex:
    """对话历史的时间索引（使用AVL树）"""

    def __init__(self):
        self.avl = AVLTree()

    def add_message(self, timestamp: int, message: str):
        """添加消息"""
        self.avl.insert(timestamp, data=message)

    def get_message(self, timestamp: int) -> Optional[str]:
        """获取特定时间的消息"""
        node = self.avl.search(timestamp)
        return node.data if node else None

    def get_recent_messages(self, hours: int = 24) -> List[str]:
        """获取最近N小时的消息"""
        import time
        now = int(time.time())
        start = now - hours * 3600

        messages = []

        def collect(node: Optional[AVLNode]):
            if not node:
                return

            if start < node.val:
                collect(node.left)

            if start <= node.val <= now:
                messages.append(node.data)

            if node.val < now:
                collect(node.right)

        collect(self.avl.root)
        return messages

    def delete_old_messages(self, before_timestamp: int) -> int:
        """删除指定时间之前的消息"""
        count = 0

        def collect_old(node: Optional[AVLNode], old_timestamps: List[int]):
            if not node:
                return
            collect_old(node.left, old_timestamps)
            if node.val < before_timestamp:
                old_timestamps.append(node.val)
            collect_old(node.right, old_timestamps)

        old_timestamps = []
        collect_old(self.avl.root, old_timestamps)

        for ts in old_timestamps:
            if self.avl.delete(ts):
                count += 1

        return count

    def __repr__(self):
        return f"ConversationHistoryIndex(messages={len(self.avl)}, height={self.avl.height(self.avl.root)})"


def test_conversation_index():
    """测试对话历史索引"""
    print("\n" + "=" * 60)
    print("对话历史索引测试")
    print("=" * 60)

    import time

    history = ConversationHistoryIndex()

    # 添加消息
    base_time = int(time.time())
    messages = [
        (base_time - 3600 * 48, "两天前的消息"),
        (base_time - 3600 * 24, "一天前的消息"),
        (base_time - 3600 * 12, "12小时前的消息"),
        (base_time - 3600 * 6, "6小时前的消息"),
        (base_time - 3600, "1小时前的消息"),
        (base_time, "刚刚的消息"),
    ]

    print("\n1. 添加消息:")
    for ts, msg in messages:
        history.add_message(ts, msg)
        print(f"   {msg}")

    print(f"\n   {history}")

    # 获取最近24小时的消息
    print("\n2. 获取最近24小时的消息:")
    recent = history.get_recent_messages(24)
    for msg in recent:
        print(f"   {msg}")

    # 删除旧消息
    print("\n3. 删除24小时前的消息:")
    deleted = history.delete_old_messages(base_time - 3600 * 24)
    print(f"   删除了{deleted}条消息")
    print(f"   {history}")


if __name__ == "__main__":
    test_avl_tree()
    test_conversation_index()
```

---

## 关键知识点

### 1. 平衡因子

```python
balance_factor = height(left) - height(right)

AVL树要求：-1 ≤ BF ≤ 1
```

### 2. 四种旋转情况

| 情况 | 不平衡形态 | 操作 | 判断条件 |
|------|-----------|------|----------|
| LL | 左-左 | 右旋 | BF > 1 且 left.BF ≥ 0 |
| RR | 右-右 | 左旋 | BF < -1 且 right.BF ≤ 0 |
| LR | 左-右 | 左旋+右旋 | BF > 1 且 left.BF < 0 |
| RL | 右-左 | 右旋+左旋 | BF < -1 且 right.BF > 0 |

### 3. 高度更新

```python
# 先更新子节点，再更新父节点
self.update_height(y)
self.update_height(x)
```

---

## 性能分析

| 操作 | AVL树 | 普通BST（最坏） |
|------|-------|----------------|
| 插入 | O(log n) | O(n) |
| 删除 | O(log n) | O(n) |
| 查找 | O(log n) | O(n) |
| 树高 | O(log n) | O(n) |

**AVL树的优势：** 严格保证O(log n)，适合查找密集型应用

---

## 学习检查清单

- [ ] 能手写AVL树的4种旋转
- [ ] 理解平衡因子的计算和判断
- [ ] 掌握插入和删除后的平衡维护
- [ ] 能应用AVL树到实际场景
- [ ] 理解AVL树与普通BST的性能差异

---

**记住：** AVL树通过旋转操作维护严格平衡，保证所有操作O(log n)，是查找密集型应用的最佳选择。
