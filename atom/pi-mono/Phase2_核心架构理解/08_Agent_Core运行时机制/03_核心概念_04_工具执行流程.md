# 核心概念 04：工具执行流程

> 深入理解 Agent Core 如何解析、验证和执行工具调用

---

## 概念定义

**工具执行流程**是指从 LLM 返回工具调用请求，到工具执行完成并返回结果的完整过程，包括解析、验证、执行、错误处理和结果封装。

**一句话：** 工具执行流程就是"解析请求 → 验证参数 → 执行操作 → 返回结果"的完整链路。

---

## 工具执行的完整流程

### 流程图

```
┌─────────────────────────────────────────────────────────┐
│                  工具执行完整流程                         │
└─────────────────────────────────────────────────────────┘

1. 解析工具调用
   ├─ LLM 响应包含 toolCalls 数组
   ├─ 提取：工具名、参数、调用 ID
   └─ 发出事件：'tool_call'

2. 查找工具定义
   ├─ 从工具注册表查找工具
   ├─ 如果不存在 → 返回错误
   └─ 获取：schema、validator、executor

3. 验证参数（TypeBox + AJV）
   ├─ 使用预编译的验证器
   ├─ 如果验证失败 → 返回错误给 LLM（自我纠正）
   └─ 如果验证成功 → 继续执行

4. 执行工具函数
   ├─ 调用工具的 execute 函数
   ├─ 可能是同步或异步
   ├─ 捕获执行错误
   └─ 获取结果：{ output, details }

5. 封装结果
   ├─ output：返回给 LLM（简洁）
   ├─ details：返回给 UI（详细）
   └─ 发出事件：'tool_result'

6. 更新上下文
   ├─ 将工具结果追加到上下文
   ├─ 仅将 output 给 LLM（节省 tokens）
   └─ details 通过事件给 UI
```

---

## 详细代码实现

### 完整的工具执行函数

```typescript
async function executeTool(
  toolCall: ToolCall,
  registry: ToolRegistry
): Promise<ToolResult> {

  // ===== 步骤 1：解析工具调用 =====
  const { id, name, params } = toolCall;

  console.log(`Executing tool: ${name}`);
  console.log(`Params:`, JSON.stringify(params, null, 2));

  // 发出工具调用事件
  eventEmitter.emit('tool_call', {
    type: 'tool_call',
    toolCall,
    timestamp: Date.now()
  });

  // ===== 步骤 2：查找工具定义 =====
  const tool = registry.get(name);

  if (!tool) {
    // 工具不存在
    const errorResult = {
      output: `Error: Tool not found: ${name}`,
      details: {
        error: 'Tool not found',
        availableTools: Array.from(registry.tools.keys())
      }
    };

    eventEmitter.emit('tool_result', {
      type: 'tool_result',
      toolCallId: id,
      result: errorResult,
      timestamp: Date.now()
    });

    return errorResult;
  }

  // ===== 步骤 3：验证参数 =====
  const validator = registry.getValidator(name);

  if (!validator(params)) {
    // 验证失败 → 返回错误给 LLM
    const validationErrors = validator.errors?.map(e => ({
      path: e.instancePath,
      message: e.message,
      params: e.params
    })) || [];

    const errorResult = {
      output: `Error: Invalid parameters for tool "${name}"\n${
        validationErrors.map(e => `- ${e.path}: ${e.message}`).join('\n')
      }`,
      details: {
        validationErrors,
        receivedParams: params,
        expectedSchema: tool.schema
      }
    };

    console.log('Validation failed:', validationErrors);

    eventEmitter.emit('tool_result', {
      type: 'tool_result',
      toolCallId: id,
      result: errorResult,
      timestamp: Date.now()
    });

    return errorResult;
  }

  console.log('Validation passed');

  // ===== 步骤 4：执行工具函数 =====
  try {
    const startTime = Date.now();

    // 执行工具（可能是异步）
    const result = await tool.execute(params);

    const executionTime = Date.now() - startTime;
    console.log(`Tool executed in ${executionTime}ms`);

    // ===== 步骤 5：封装结果 =====
    const toolResult: ToolResult = {
      output: result.output,
      details: {
        ...result.details,
        executionTime,
        toolName: name,
        success: true
      }
    };

    // 发出工具结果事件
    eventEmitter.emit('tool_result', {
      type: 'tool_result',
      toolCallId: id,
      result: toolResult,
      timestamp: Date.now()
    });

    return toolResult;

  } catch (error) {
    // 执行错误 → 返回错误给 LLM
    console.error(`Tool execution error:`, error);

    const errorResult = {
      output: `Error executing tool "${name}": ${error.message}`,
      details: {
        error: error.message,
        stack: error.stack,
        toolName: name,
        success: false
      }
    };

    eventEmitter.emit('tool_result', {
      type: 'tool_result',
      toolCallId: id,
      result: errorResult,
      timestamp: Date.now()
    });

    return errorResult;
  }
}
```

---

## 工具调用解析

### LLM 响应格式

**Anthropic 格式：**

```typescript
// LLM 响应
{
  role: 'assistant',
  content: '我来创建文件',
  tool_calls: [
    {
      id: 'toolu_01A2B3C4D5E6F7G8H9I0J1K2',
      type: 'function',
      function: {
        name: 'write',
        arguments: '{"path":"hello.ts","content":"console.log(\'hello\')"}'
      }
    }
  ]
}
```

**OpenAI 格式：**

```typescript
// LLM 响应
{
  role: 'assistant',
  content: '我来创建文件',
  tool_calls: [
    {
      id: 'call_abc123',
      type: 'function',
      function: {
        name: 'write',
        arguments: '{"path":"hello.ts","content":"console.log(\'hello\')"}'
      }
    }
  ]
}
```

---

### 统一解析函数

```typescript
function parseToolCalls(response: LLMResponse): ToolCall[] {
  if (!response.tool_calls || response.tool_calls.length === 0) {
    return [];
  }

  return response.tool_calls.map(tc => {
    // 解析 JSON 参数
    let params: any;
    try {
      params = JSON.parse(tc.function.arguments);
    } catch (error) {
      console.error('Failed to parse tool arguments:', error);
      params = {};
    }

    return {
      id: tc.id,
      name: tc.function.name,
      params
    };
  });
}

// 使用
const response = await llm.chat(context);
const toolCalls = parseToolCalls(response);

for (const call of toolCalls) {
  const result = await executeTool(call, registry);
  // ...
}
```

---

## 参数验证详解

### TypeBox Schema 验证

**示例：Read 工具验证**

```typescript
import { Type } from '@sinclair/typebox';
import Ajv from 'ajv';

// 定义 Schema
const ReadSchema = Type.Object({
  path: Type.String({
    minLength: 1,
    description: 'File path to read'
  }),
  lines: Type.Optional(Type.Object({
    start: Type.Number({ minimum: 1 }),
    end: Type.Number({ minimum: 1 })
  }))
});

// 编译验证器
const ajv = new Ajv({ allErrors: true });
const validate = ajv.compile(ReadSchema);

// 验证参数
const params1 = { path: 'hello.ts' };
console.log(validate(params1));  // true

const params2 = { path: '' };  // 空路径
console.log(validate(params2));  // false
console.log(validate.errors);
// [
//   {
//     instancePath: '/path',
//     message: 'must NOT have fewer than 1 characters'
//   }
// ]

const params3 = { file: 'hello.ts' };  // 错误的参数名
console.log(validate(params3));  // false
console.log(validate.errors);
// [
//   {
//     instancePath: '',
//     message: "must have required property 'path'"
//   },
//   {
//     instancePath: '',
//     message: 'must NOT have additional properties'
//   }
// ]
```

---

### 验证失败的自我纠正

**Pi-mono 的核心机制：验证失败 → 返回错误给 LLM → 模型自我纠正**

```typescript
// 循环 1：LLM 调用工具，参数错误
toolCall: {
  name: 'read',
  params: { file: 'hello.ts' }  // ❌ 应该是 path，不是 file
}

// 验证失败，返回错误
toolResult: {
  output: `Error: Invalid parameters for tool "read"
- : must have required property 'path'
- : must NOT have additional properties (found: file)`,
  details: {
    validationErrors: [...],
    receivedParams: { file: 'hello.ts' },
    expectedSchema: { ... }
  }
}

// 循环 2：LLM 看到错误，自我纠正
toolCall: {
  name: 'read',
  params: { path: 'hello.ts' }  // ✅ 参数正确
}

// 验证成功，执行工具
toolResult: {
  output: "File content: console.log('hello')",
  details: { path: 'hello.ts', size: 23 }
}
```

**实际数据：** Pi-mono 中 80% 的验证错误在下一轮被自动纠正[^1]

---

## 同步 vs 异步执行

### 同步工具

**示例：简单计算工具**

```typescript
const calculatorTool: Tool = {
  name: 'calculate',
  description: 'Perform basic calculations',
  schema: Type.Object({
    expression: Type.String()
  }),

  // 同步执行
  execute: (params) => {
    const result = eval(params.expression);  // 注意：实际应用中不要用 eval
    return {
      output: `Result: ${result}`,
      details: { expression: params.expression, result }
    };
  }
};
```

---

### 异步工具

**示例：文件读取工具**

```typescript
const readTool: Tool = {
  name: 'read',
  description: 'Read file contents',
  schema: Type.Object({
    path: Type.String()
  }),

  // 异步执行
  execute: async (params) => {
    const content = await fs.readFile(params.path, 'utf-8');
    return {
      output: `File content:\n${content}`,
      details: { path: params.path, size: content.length }
    };
  }
};
```

---

### 执行器处理

```typescript
async function executeTool(toolCall: ToolCall): Promise<ToolResult> {
  const tool = registry.get(toolCall.name);

  // 统一处理同步和异步
  const result = await Promise.resolve(tool.execute(toolCall.params));

  return result;
}
```

---

## 工具结果结构

### Output vs Details

**核心设计：分离 LLM 和 UI 的需求**

```typescript
interface ToolResult {
  // 返回给 LLM 的内容（简洁，节省 tokens）
  output: string;

  // 返回给 UI 的详细信息（丰富，提供更多上下文）
  details?: {
    [key: string]: any;
  };
}
```

---

### 实际示例

**Read 工具：**

```typescript
// 工具执行结果
{
  output: "File content:\nconsole.log('hello')",  // 给 LLM
  details: {                                       // 给 UI
    path: 'hello.ts',
    size: 23,
    lines: 1,
    encoding: 'utf-8',
    lastModified: '2026-02-19T10:00:00Z'
  }
}

// LLM 看到的（追加到上下文）
{
  role: 'tool',
  content: "File content:\nconsole.log('hello')"  // 仅 output
}

// UI 看到的（通过事件）
{
  type: 'tool_result',
  result: {
    output: "File content:\nconsole.log('hello')",
    details: { path: 'hello.ts', size: 23, ... }  // 完整信息
  }
}
```

**Bash 工具：**

```typescript
// 工具执行结果
{
  output: "Dependencies installed successfully",  // 给 LLM
  details: {                                      // 给 UI
    command: 'npm install express',
    stdout: 'added 50 packages...',
    stderr: '',
    exitCode: 0,
    executionTime: 3500
  }
}
```

---

### 为什么分离 Output 和 Details？

**1. Token 效率**

```typescript
// ❌ 不分离：所有信息都给 LLM
{
  role: 'tool',
  content: JSON.stringify({
    path: 'hello.ts',
    size: 23,
    lines: 1,
    encoding: 'utf-8',
    lastModified: '2026-02-19T10:00:00Z',
    content: "console.log('hello')"
  })
}
// 浪费 tokens！LLM 不需要这么多细节

// ✅ 分离：只给 LLM 必要信息
{
  role: 'tool',
  content: "File content:\nconsole.log('hello')"
}
// 节省 tokens，LLM 只需要文件内容
```

**2. UI 展示需求**

```typescript
// UI 可以展示丰富的信息
<ToolResult>
  <ToolName>read</ToolName>
  <Output>File content: console.log('hello')</Output>
  <Details>
    <Path>hello.ts</Path>
    <Size>23 bytes</Size>
    <Lines>1</Lines>
    <LastModified>2026-02-19 10:00:00</LastModified>
  </Details>
</ToolResult>
```

**3. 调试和监控**

```typescript
// details 包含调试信息
{
  output: "Command executed",
  details: {
    command: 'npm test',
    executionTime: 2500,  // 性能监控
    exitCode: 0,          // 调试信息
    stdout: '...',        // 完整输出
    stderr: ''            // 错误输出
  }
}
```

---

## 错误处理策略

### 三种错误类型

**1. 工具不存在**

```typescript
// LLM 调用了不存在的工具
toolCall: { name: 'unknown_tool', params: {} }

// 返回错误
{
  output: "Error: Tool not found: unknown_tool\nAvailable tools: read, write, edit, bash",
  details: {
    error: 'Tool not found',
    requestedTool: 'unknown_tool',
    availableTools: ['read', 'write', 'edit', 'bash']
  }
}
```

---

**2. 参数验证失败**

```typescript
// LLM 参数错误
toolCall: { name: 'read', params: { file: 'hello.ts' } }

// 返回验证错误
{
  output: `Error: Invalid parameters for tool "read"
- : must have required property 'path'
- : must NOT have additional properties (found: file)`,
  details: {
    validationErrors: [...],
    receivedParams: { file: 'hello.ts' },
    expectedSchema: { type: 'object', properties: { path: { type: 'string' } } }
  }
}
```

---

**3. 执行错误**

```typescript
// 工具执行失败
toolCall: { name: 'read', params: { path: 'nonexistent.ts' } }

// 返回执行错误
{
  output: "Error: ENOENT: no such file or directory, open 'nonexistent.ts'",
  details: {
    error: 'ENOENT: no such file or directory',
    path: 'nonexistent.ts',
    errno: -2,
    code: 'ENOENT'
  }
}
```

---

### 错误处理的最佳实践

**1. 所有错误都返回给 LLM（不抛异常）**

```typescript
// ✅ 正确：返回错误
async function executeTool(toolCall: ToolCall): Promise<ToolResult> {
  try {
    const result = await tool.execute(toolCall.params);
    return result;
  } catch (error) {
    // 不抛异常，返回错误信息
    return {
      output: `Error: ${error.message}`,
      details: { error: error.stack }
    };
  }
}

// ❌ 错误：抛异常
async function executeTool(toolCall: ToolCall): Promise<ToolResult> {
  const result = await tool.execute(toolCall.params);
  return result;  // 如果出错，异常会向上抛出，中断循环
}
```

---

**2. 错误信息要清晰**

```typescript
// ✅ 清晰的错误信息
{
  output: `Error: File not found: 'config.ts'
Suggestion: Check if the file exists or create it first.`
}

// ❌ 模糊的错误信息
{
  output: "Error: ENOENT"  // LLM 难以理解
}
```

---

**3. 提供上下文信息**

```typescript
// ✅ 包含上下文
{
  output: `Error: Invalid SQL syntax in query: "SELCT * FROM users"
Did you mean: "SELECT * FROM users"?`,
  details: {
    query: 'SELCT * FROM users',
    suggestion: 'SELECT * FROM users',
    errorPosition: 0
  }
}

// ❌ 缺少上下文
{
  output: "Error: Syntax error"
}
```

---

## 并行 vs 串行执行

### 串行执行（Pi-mono 默认）

**适用场景：工具之间有依赖**

```typescript
// 示例：先读取文件，再编辑
for (const toolCall of toolCalls) {
  const result = await executeTool(toolCall);
  context.push({ role: 'tool', content: result.output });
}

// 执行顺序：
// 1. read('config.ts') → 获取内容
// 2. edit('config.ts', ...) → 基于内容编辑
```

---

### 并行执行（可选优化）

**适用场景：工具之间无依赖**

```typescript
// 示例：同时读取多个文件
const results = await Promise.all(
  toolCalls.map(call => executeTool(call))
);

for (const result of results) {
  context.push({ role: 'tool', content: result.output });
}

// 执行顺序：
// 1. read('file1.ts') ┐
// 2. read('file2.ts') ├─ 并行执行
// 3. read('file3.ts') ┘
```

**注意：** Pi-mono 默认串行执行，因为：
- 工具之间可能有隐式依赖
- 串行执行更容易调试
- 性能差异通常不大（工具执行很快）

---

## 实际应用场景

### 场景 1：文件操作

```typescript
// 任务：创建并编辑文件

// 工具调用 1：创建文件
toolCall: { name: 'write', params: { path: 'hello.ts', content: 'console.log("hello")' } }
toolResult: { output: 'File written: hello.ts' }

// 工具调用 2：编辑文件
toolCall: { name: 'edit', params: { path: 'hello.ts', oldText: 'hello', newText: 'world' } }
toolResult: { output: 'File edited: hello.ts' }
```

---

### 场景 2：命令执行

```typescript
// 任务：安装依赖并运行测试

// 工具调用 1：安装依赖
toolCall: { name: 'bash', params: { command: 'npm install' } }
toolResult: { output: 'added 50 packages in 3.5s' }

// 工具调用 2：运行测试
toolCall: { name: 'bash', params: { command: 'npm test' } }
toolResult: { output: 'All tests passed (10/10)' }
```

---

### 场景 3：错误恢复

```typescript
// 任务：读取配置文件

// 工具调用 1：尝试读取
toolCall: { name: 'read', params: { path: 'config.ts' } }
toolResult: { output: 'Error: File not found: config.ts' }

// LLM 看到错误，调整策略

// 工具调用 2：列出文件
toolCall: { name: 'bash', params: { command: 'ls -la' } }
toolResult: { output: 'package.json\nsrc/\nREADME.md' }

// LLM 发现文件不存在，改为创建

// 工具调用 3：创建文件
toolCall: { name: 'write', params: { path: 'config.ts', content: '...' } }
toolResult: { output: 'File written: config.ts' }
```

---

## 性能优化

### 1. 验证器预编译

```typescript
// ✅ 初始化时编译
const validators = new Map();
for (const [name, schema] of Object.entries(toolSchemas)) {
  validators.set(name, ajv.compile(schema));  // 预编译
}

// 运行时直接使用
const validate = validators.get(toolCall.name);
if (!validate(toolCall.params)) {
  // 快速验证
}
```

---

### 2. 结果缓存（可选）

```typescript
// 对于幂等工具，可以缓存结果
const resultCache = new Map<string, ToolResult>();

async function executeTool(toolCall: ToolCall): Promise<ToolResult> {
  // 生成缓存键
  const cacheKey = `${toolCall.name}:${JSON.stringify(toolCall.params)}`;

  // 检查缓存
  if (resultCache.has(cacheKey)) {
    return resultCache.get(cacheKey)!;
  }

  // 执行工具
  const result = await tool.execute(toolCall.params);

  // 缓存结果（仅对幂等工具）
  if (tool.idempotent) {
    resultCache.set(cacheKey, result);
  }

  return result;
}
```

---

### 3. 超时控制

```typescript
async function executeTool(
  toolCall: ToolCall,
  timeout: number = 30000
): Promise<ToolResult> {

  // 使用 Promise.race 实现超时
  const timeoutPromise = new Promise<ToolResult>((_, reject) => {
    setTimeout(() => reject(new Error('Tool execution timeout')), timeout);
  });

  const executionPromise = tool.execute(toolCall.params);

  try {
    return await Promise.race([executionPromise, timeoutPromise]);
  } catch (error) {
    return {
      output: `Error: ${error.message}`,
      details: { error: error.stack, timeout }
    };
  }
}
```

---

## 总结

**工具执行流程的核心要点：**

1. **解析**：从 LLM 响应中提取工具调用
2. **验证**：TypeBox + AJV 验证参数
3. **执行**：调用工具函数（同步/异步）
4. **封装**：output（LLM）+ details（UI）
5. **错误处理**：所有错误返回给 LLM，不抛异常
6. **自我纠正**：验证失败 → LLM 看到错误 → 自动修正

**关键洞察：**
- 工具执行是 Agent 的"手脚"
- 验证失败是学习机会，不是失败
- Output/Details 分离优化 token 使用
- 错误信息要清晰，帮助 LLM 理解

**下一步：** 理解工具执行后，学习状态持久化机制（核心概念 05）。

---

[^1]: Pi-mono internal metrics: 80% validation errors self-corrected in next iteration
