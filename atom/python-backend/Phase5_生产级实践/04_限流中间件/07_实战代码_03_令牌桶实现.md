# 实战代码3：令牌桶实现

> 手写令牌桶算法的完整实现

---

## 基础实现

```python
"""令牌桶限流器 - 基础实现"""
import time

class TokenBucket:
    def __init__(self, rate: float, capacity: float):
        self.rate = rate
        self.capacity = capacity
        self.tokens = capacity
        self.last_time = time.time()

    def acquire(self, tokens: int = 1) -> bool:
        now = time.time()
        elapsed = now - self.last_time

        self.tokens = min(self.capacity, self.tokens + elapsed * self.rate)
        self.last_time = now

        if self.tokens >= tokens:
            self.tokens -= tokens
            return True
        return False
```

---

## Redis + Lua 实现

```python
"""令牌桶限流器 - Redis + Lua 实现"""
import redis
import time

class RedisTokenBucket:
    LUA_SCRIPT = """
    local key = KEYS[1]
    local rate = tonumber(ARGV[1])
    local capacity = tonumber(ARGV[2])
    local now = tonumber(ARGV[3])
    local requested = tonumber(ARGV[4])

    local state = redis.call('HMGET', key, 'tokens', 'last_time')
    local tokens = tonumber(state[1]) or capacity
    local last_time = tonumber(state[2]) or now

    local elapsed = now - last_time
    tokens = math.min(capacity, tokens + elapsed * rate)

    if tokens >= requested then
        tokens = tokens - requested
        redis.call('HMSET', key, 'tokens', tokens, 'last_time', now)
        redis.call('EXPIRE', key, 3600)
        return 1
    end
    return 0
    """

    def __init__(self, redis_client: redis.Redis, key: str, rate: float, capacity: float):
        self.redis = redis_client
        self.key = key
        self.rate = rate
        self.capacity = capacity
        self.script_sha = self.redis.script_load(self.LUA_SCRIPT)

    def acquire(self, tokens: int = 1) -> bool:
        now = time.time()
        result = self.redis.evalsha(
            self.script_sha, 1, self.key,
            self.rate, self.capacity, now, tokens
        )
        return result == 1
```

---

## FastAPI 集成

```python
"""令牌桶限流 - FastAPI 集成"""
from fastapi import FastAPI, Depends, HTTPException, Request
from enum import Enum
import redis

app = FastAPI()
redis_client = redis.Redis()

class UserTier(str, Enum):
    FREE = "free"
    PRO = "pro"

RATE_LIMITS = {
    UserTier.FREE: {"rate": 1, "capacity": 10},
    UserTier.PRO: {"rate": 100, "capacity": 1000}
}

def get_rate_limiter(user_id: str, user_tier: UserTier):
    limits = RATE_LIMITS[user_tier]
    return RedisTokenBucket(
        redis_client, f"user:{user_id}:rate_limit",
        limits["rate"], limits["capacity"]
    )

async def rate_limit(request: Request):
    user_id = request.headers.get("X-User-ID", "anonymous")
    user_tier = UserTier(request.headers.get("X-User-Tier", "free"))
    limiter = get_rate_limiter(user_id, user_tier)

    if not limiter.acquire():
        raise HTTPException(status_code=429, detail="Rate limit exceeded")

@app.post("/chat")
async def chat(message: str, _: None = Depends(rate_limit)):
    return {"response": f"Echo: {message}"}
```

---

**记住：** 令牌桶是最实用的限流算法，支持突发流量，适合大多数场景。
