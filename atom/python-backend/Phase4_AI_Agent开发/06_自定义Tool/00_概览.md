# 自定义Tool - 概览

> 为 AI Agent 创建自定义工具，让 LLM 能够调用外部 API、数据库、文件系统等资源

---

## 文档结构

本知识点包含以下10个维度：

### 基础理解
1. **30字核心** - 一句话理解自定义Tool
2. **第一性原理** - 从根本理解为什么需要自定义Tool
3. **核心概念** - 4个核心技术（拆分为4个文件）
   - Tool定义方式（@tool装饰器、Tool类、StructuredTool、BaseTool）
   - 参数验证与Schema（Pydantic、Field、类型注解）
   - Tool描述与LLM理解（描述最佳实践、LLM选择机制）
   - 异步Tool与资源管理（async/await、连接池、超时处理）

### 实战应用
4. **最小可用** - 20%核心知识快速上手
5. **双重类比** - 前端开发类比 + 日常生活类比
6. **实战代码** - 8个完整可运行示例（拆分为8个场景）
   - API调用工具（天气API、新闻API）
   - 数据库查询工具（订单查询、用户信息）
   - 向量检索工具（知识库检索）
   - 文件操作工具（读写文件、搜索文件）
   - 计算处理工具（数学计算、数据转换）
   - 多Tool组合（复杂任务协作）
   - FastAPI集成（依赖注入、流式响应）
   - 生产实践（日志、监控、限流、缓存）

### 进阶提升
7. **反直觉点** - 3个常见误区
8. **面试必问** - 2个高频问题
9. **化骨绵掌** - 10个2分钟知识卡片
10. **一句话总结** - 整个知识点的精华

---

## 学习路径

### 推荐学习顺序

```
30字核心 → 第一性原理 → 最小可用 → 核心概念（4个文件）→ 实战代码（8个场景）→ 其他维度
    ↓          ↓           ↓              ↓                    ↓              ↓
  快速理解   深度理解    快速上手      技术细节              实战应用        查漏补缺
```

### 学习时间建议

- **快速入门**（1小时）：30字核心 + 最小可用 + 实战代码01
- **深入理解**（3小时）：第一性原理 + 核心概念（4个文件）
- **实战掌握**（5小时）：实战代码（8个场景）
- **全面精通**（8小时）：所有维度

---

## 与 AI Agent 开发的关系

### 为什么需要自定义Tool？

**LLM 的局限性：**
- ✅ 擅长：文本理解、生成、推理
- ❌ 不擅长：实时数据获取、精确计算、外部系统交互

**自定义Tool 的价值：**
- 让 Agent 能够调用外部 API（天气、新闻、股票）
- 让 Agent 能够查询数据库（订单、用户、产品）
- 让 Agent 能够操作文件（读写、搜索、解析）
- 让 Agent 能够执行计算（数学、数据转换）

### 在 AI Agent 后端中的应用

| 场景 | 自定义Tool 的作用 | 示例 |
|------|------------------|------|
| **智能客服** | 查询订单状态、物流信息 | `get_order_status(order_id)` |
| **数据分析** | 查询数据库、生成报表 | `query_sales_data(start_date, end_date)` |
| **知识问答** | 检索向量数据库 | `search_knowledge_base(query)` |
| **文档处理** | 读取、解析、搜索文件 | `read_pdf(file_path)` |
| **任务自动化** | 调用外部 API | `send_email(to, subject, body)` |

---

## 核心技术栈

### LangChain Tool 系统

```python
from langchain.tools import tool, Tool, StructuredTool, BaseTool
from langchain.pydantic_v1 import BaseModel, Field
```

### 4种Tool定义方式

1. **@tool装饰器**（推荐）- 最简单，适合大多数场景
2. **Tool类** - 简单场景，快速定义
3. **StructuredTool** - 复杂参数，需要详细验证
4. **BaseTool继承** - 高级定制，完全控制

### 关键要素

- **Tool名称**：LLM 用来识别工具
- **Tool描述**：LLM 用来决定何时调用
- **参数Schema**：定义输入参数的类型和验证规则
- **执行逻辑**：实际的工具功能实现

---

## 学习检查清单

完成本知识点后，你应该能够：

### 基础能力
- [ ] 理解自定义Tool的本质和价值
- [ ] 掌握4种Tool定义方式
- [ ] 使用@tool装饰器创建简单工具
- [ ] 使用Pydantic定义参数Schema
- [ ] 编写清晰的Tool描述

### 实战能力
- [ ] 创建API调用工具（httpx）
- [ ] 创建数据库查询工具（asyncpg）
- [ ] 创建向量检索工具（pgvector）
- [ ] 创建文件操作工具（路径验证）
- [ ] 创建计算处理工具（安全求值）

### 进阶能力
- [ ] 实现异步Tool（async/await）
- [ ] 管理资源（连接池、超时）
- [ ] 处理Tool调用错误
- [ ] 组合多个Tool完成复杂任务
- [ ] 将Tool集成到FastAPI端点

### 生产能力
- [ ] 添加日志记录
- [ ] 实现性能监控
- [ ] 处理限流和缓存
- [ ] 编写Tool单元测试
- [ ] 优化Tool性能

---

## 前置知识

学习本知识点前，建议先掌握：

- ✅ **Python基础**：async/await、装饰器、类型注解
- ✅ **Pydantic**：数据验证、BaseModel
- ✅ **FastAPI**：依赖注入、异常处理
- ✅ **LangChain基础**：LCEL、Agent执行器

---

## 后续学习

完成本知识点后，可以继续学习：

- → **流式输出集成**：将Tool调用结果流式返回
- → **对话记忆管理**：在多轮对话中使用Tool
- → **生产级实践**：错误处理、日志、监控
- → **部署与架构**：容器化、健康检查

---

## 快速参考

### 最简单的Tool

```python
from langchain.tools import tool

@tool
def get_weather(city: str) -> str:
    """获取指定城市的天气信息"""
    return f"{city}的天气：晴天，25°C"
```

### 带参数验证的Tool

```python
from langchain.tools import tool
from pydantic import BaseModel, Field

class WeatherInput(BaseModel):
    city: str = Field(description="城市名称，如'北京'")
    unit: str = Field(default="celsius", description="温度单位：celsius或fahrenheit")

@tool(args_schema=WeatherInput)
def get_weather(city: str, unit: str = "celsius") -> str:
    """获取指定城市的天气信息"""
    return f"{city}的天气：晴天，25°C"
```

### 异步Tool

```python
import httpx
from langchain.tools import tool

@tool
async def fetch_news(topic: str) -> str:
    """获取指定主题的最新新闻"""
    async with httpx.AsyncClient() as client:
        response = await client.get(f"https://api.news.com/search?q={topic}")
        return response.json()
```

---

**版本：** v1.0
**最后更新：** 2026-02-12
**预计学习时间：** 8小时（快速入门1小时）
