# 实战代码3：错误处理与降级

> 构建生产级的容错链

---

## 场景描述

**目标**：构建一个带完整错误处理的生产级 RAG 链，包含重试、降级、超时控制。

**功能需求**：
1. 自动重试临时性错误
2. 降级到备用模型
3. 超时控制
4. 错误日志记录
5. 可观测性集成

---

## 完整代码

```python
"""
生产级错误处理示例
演示：重试、降级、超时控制
"""

import os
import time
import logging
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_chroma import Chroma
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough
from langchain_core.documents import Document
from langchain.callbacks.base import BaseCallbackHandler
from openai import RateLimitError, APIConnectionError

load_dotenv()

# ===== 1. 配置日志 =====
print("=== 步骤1: 配置日志 ===\n")

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

print("日志配置完成")
print()

# ===== 2. 自定义错误处理回调 =====
print("=== 步骤2: 创建错误处理回调 ===\n")

class ErrorHandlingCallback(BaseCallbackHandler):
    """错误处理回调"""

    def __init__(self):
        self.errors = []
        self.retries = []
        self.fallbacks = []

    def on_chain_error(self, error: Exception, **kwargs):
        """链执行失败时调用"""
        error_info = {
            "timestamp": time.time(),
            "error_type": type(error).__name__,
            "error_message": str(error),
            "chain_name": kwargs.get("name", "unknown")
        }
        self.errors.append(error_info)
        logger.error(f"链执行失败: {error_info}")

    def on_retry(self, **kwargs):
        """重试时调用"""
        retry_info = {
            "timestamp": time.time(),
            "attempt": kwargs.get("attempt", 0)
        }
        self.retries.append(retry_info)
        logger.warning(f"重试: 第 {retry_info['attempt']} 次")

    def print_summary(self):
        """打印错误摘要"""
        print("\n=== 错误处理摘要 ===")
        print(f"总错误数: {len(self.errors)}")
        print(f"重试次数: {len(self.retries)}")
        print(f"降级次数: {len(self.fallbacks)}")

        if self.errors:
            print("\n错误详情:")
            for i, error in enumerate(self.errors, 1):
                print(f"{i}. {error['error_type']}: {error['error_message']}")

print("错误处理回调创建完成")
print()

# ===== 3. 准备测试数据 =====
print("=== 步骤3: 准备测试数据 ===\n")

documents = [
    Document(
        page_content="向量数据库用于存储和检索向量数据，支持高效的相似度搜索。",
        metadata={"source": "doc1"}
    ),
    Document(
        page_content="RAG 结合检索和生成，先检索相关文档，再基于文档生成答案。",
        metadata={"source": "doc2"}
    )
]

embeddings = OpenAIEmbeddings(model="text-embedding-3-small")
vectorstore = Chroma.from_documents(
    documents=documents,
    embedding=embeddings,
    collection_name="error_handling_demo"
)
retriever = vectorstore.as_retriever(search_kwargs={"k": 2})

print("测试数据准备完成")
print()

# ===== 4. 构建基础链 =====
print("=== 步骤4: 构建基础链 ===\n")

prompt = ChatPromptTemplate.from_template("""
根据以下上下文回答问题：

上下文：{context}
问题：{question}

答案：
""")

# 主 LLM（可能失败）
main_llm = ChatOpenAI(
    model="gpt-4o-mini",
    temperature=0,
    request_timeout=10  # 10秒超时
)

parser = StrOutputParser()

# 基础链
base_chain = (
    {
        "context": retriever,
        "question": RunnablePassthrough()
    }
    | prompt
    | main_llm
    | parser
)

print("基础链构建完成")
print()

# ===== 5. 添加重试逻辑 =====
print("=== 步骤5: 添加重试逻辑 ===\n")

# 添加重试
chain_with_retry = base_chain.with_retry(
    stop_after_attempt=3,           # 最多重试3次
    wait_exponential_jitter=True,   # 指数退避 + 随机抖动
    retry_if_exception_type=(       # 只重试临时性错误
        RateLimitError,
        APIConnectionError,
        TimeoutError
    )
)

print("重试配置:")
print("  最大重试次数: 3")
print("  重试策略: 指数退避 + 随机抖动")
print("  重试错误类型: RateLimitError, APIConnectionError, TimeoutError")
print()

# ===== 6. 添加降级方案 =====
print("=== 步骤6: 添加降级方案 ===\n")

# 备用 LLM 1：GPT-3.5（更便宜）
fallback_llm1 = ChatOpenAI(
    model="gpt-3.5-turbo",
    temperature=0,
    request_timeout=10
)

fallback_chain1 = (
    {
        "context": retriever,
        "question": RunnablePassthrough()
    }
    | prompt
    | fallback_llm1
    | parser
)

# 备用 LLM 2：更短的超时（更快失败）
fallback_llm2 = ChatOpenAI(
    model="gpt-3.5-turbo",
    temperature=0,
    request_timeout=5  # 5秒超时
)

fallback_chain2 = (
    {
        "context": retriever,
        "question": RunnablePassthrough()
    }
    | prompt
    | fallback_llm2
    | parser
)

# 组合降级链
chain_with_fallbacks = chain_with_retry.with_fallbacks([
    fallback_chain1,
    fallback_chain2
])

print("降级配置:")
print("  主链: GPT-4o-mini (10s 超时)")
print("  备用链1: GPT-3.5-turbo (10s 超时)")
print("  备用链2: GPT-3.5-turbo (5s 超时)")
print()

# ===== 7. 添加超时控制 =====
print("=== 步骤7: 添加超时控制 ===\n")

# 添加全局超时
production_chain = chain_with_fallbacks.with_config({
    "timeout": 30,  # 30秒全局超时
    "run_name": "production_rag_chain",
    "tags": ["production", "rag"]
})

print("超时配置:")
print("  全局超时: 30秒")
print("  运行名称: production_rag_chain")
print("  标签: production, rag")
print()

# ===== 8. 测试正常情况 =====
print("=== 步骤8: 测试正常情况 ===\n")

error_callback = ErrorHandlingCallback()

question = "什么是向量数据库？"
print(f"问题: {question}")

try:
    start = time.time()
    answer = production_chain.invoke(
        question,
        config={"callbacks": [error_callback]}
    )
    duration = time.time() - start

    print(f"答案: {answer}")
    print(f"耗时: {duration:.2f}秒")
    print("✅ 执行成功")
except Exception as e:
    print(f"❌ 执行失败: {e}")

print()

# ===== 9. 模拟错误场景 =====
print("=== 步骤9: 模拟错误场景 ===\n")

# 模拟 API 限流错误
class FlakyLLM:
    """不稳定的 LLM（用于测试）"""

    def __init__(self, fail_count=2):
        self.fail_count = fail_count
        self.attempt = 0

    def invoke(self, input):
        self.attempt += 1
        print(f"  尝试 {self.attempt}/{self.fail_count + 1}")

        if self.attempt <= self.fail_count:
            print(f"  ❌ 模拟失败")
            raise RateLimitError("Rate limit exceeded")

        print(f"  ✅ 成功")
        return "这是一个模拟的答案"

print("测试重试机制:")
flaky_llm = FlakyLLM(fail_count=2)

try:
    # 手动重试逻辑（演示）
    for attempt in range(4):
        try:
            result = flaky_llm.invoke("test")
            print(f"最终结果: {result}")
            break
        except RateLimitError as e:
            if attempt < 3:
                wait_time = 2 ** attempt
                print(f"  等待 {wait_time} 秒后重试...")
                time.sleep(wait_time)
            else:
                print(f"  达到最大重试次数")
                raise
except Exception as e:
    print(f"最终失败: {e}")

print()

# ===== 10. 测试降级场景 =====
print("=== 步骤10: 测试降级场景 ===\n")

print("模拟主链失败，测试降级:")

# 创建一个总是失败的主链
class AlwaysFailLLM:
    def invoke(self, input):
        raise ValueError("主链不可用")

# 模拟降级
print("1. 尝试主链...")
try:
    AlwaysFailLLM().invoke("test")
except ValueError as e:
    print(f"   ❌ 主链失败: {e}")

print("2. 尝试备用链1...")
try:
    result = "备用链1的答案"
    print(f"   ✅ 备用链1成功: {result}")
except Exception as e:
    print(f"   ❌ 备用链1失败: {e}")

print()

# ===== 11. 批量处理的错误处理 =====
print("=== 步骤11: 批量处理的错误处理 ===\n")

def safe_batch_invoke(chain, inputs):
    """安全的批量调用"""
    results = []
    errors = []

    for i, input in enumerate(inputs):
        try:
            result = chain.invoke(input)
            results.append({
                "index": i,
                "input": input,
                "success": True,
                "result": result
            })
        except Exception as e:
            results.append({
                "index": i,
                "input": input,
                "success": False,
                "error": str(e)
            })
            errors.append({
                "index": i,
                "input": input,
                "error": e
            })

    return results, errors

# 测试批量处理
test_questions = [
    "什么是向量数据库？",
    "什么是 RAG？",
    "什么是 Embedding？"
]

print(f"批量处理 {len(test_questions)} 个问题...")
results, errors = safe_batch_invoke(production_chain, test_questions)

print(f"\n结果:")
print(f"  成功: {sum(1 for r in results if r['success'])}/{len(test_questions)}")
print(f"  失败: {len(errors)}")

for result in results:
    if result['success']:
        print(f"  ✅ {result['input'][:30]}...")
    else:
        print(f"  ❌ {result['input'][:30]}... - {result['error']}")

print()

# ===== 12. 错误统计和分析 =====
print("=== 步骤12: 错误统计和分析 ===\n")

error_callback.print_summary()
print()

# ===== 13. 生产环境最佳实践 =====
print("=== 步骤13: 生产环境最佳实践 ===\n")

print("生产环境配置清单:")
print("  ✅ 添加重试逻辑（with_retry）")
print("  ✅ 添加降级方案（with_fallbacks）")
print("  ✅ 设置超时控制（timeout）")
print("  ✅ 配置日志记录（logging）")
print("  ✅ 添加错误回调（callbacks）")
print("  ✅ 集成可观测性（LangSmith）")
print()

print("推荐配置:")
print("""
production_chain = (
    base_chain
    .with_retry(
        stop_after_attempt=3,
        wait_exponential_jitter=True,
        retry_if_exception_type=(RateLimitError, APIConnectionError)
    )
    .with_fallbacks([fallback_chain1, fallback_chain2])
    .with_config({
        "timeout": 30,
        "run_name": "production",
        "tags": ["production"],
        "callbacks": [ErrorHandlingCallback()]
    })
)
""")
print()

# ===== 14. 集成 LangSmith =====
print("=== 步骤14: 集成 LangSmith ===\n")

print("启用 LangSmith 追踪:")
print("""
import os
os.environ["LANGSMITH_TRACING"] = "true"
os.environ["LANGSMITH_API_KEY"] = "your_key"
os.environ["LANGSMITH_PROJECT"] = "production"

# 自动追踪所有执行
result = production_chain.invoke(question)

# 在 LangSmith 控制台查看：
# - 重试次数和时间
# - 降级路径
# - 错误详情和堆栈
# - 性能指标
""")
print()

# ===== 15. 监控和告警 =====
print("=== 步骤15: 监控和告警 ===\n")

class MonitoringCallback(BaseCallbackHandler):
    """监控回调"""

    def __init__(self):
        self.metrics = {
            "total_calls": 0,
            "successful_calls": 0,
            "failed_calls": 0,
            "retry_count": 0,
            "fallback_count": 0,
            "total_duration": 0
        }

    def on_chain_start(self, **kwargs):
        self.metrics["total_calls"] += 1
        self.start_time = time.time()

    def on_chain_end(self, **kwargs):
        self.metrics["successful_calls"] += 1
        duration = time.time() - self.start_time
        self.metrics["total_duration"] += duration

    def on_chain_error(self, **kwargs):
        self.metrics["failed_calls"] += 1

    def print_metrics(self):
        print("监控指标:")
        print(f"  总调用数: {self.metrics['total_calls']}")
        print(f"  成功: {self.metrics['successful_calls']}")
        print(f"  失败: {self.metrics['failed_calls']}")
        print(f"  成功率: {self.metrics['successful_calls'] / max(self.metrics['total_calls'], 1) * 100:.1f}%")
        print(f"  平均耗时: {self.metrics['total_duration'] / max(self.metrics['successful_calls'], 1):.2f}秒")

        # 告警逻辑
        success_rate = self.metrics['successful_calls'] / max(self.metrics['total_calls'], 1)
        if success_rate < 0.95:
            print(f"  ⚠️  告警: 成功率低于 95%")

monitoring = MonitoringCallback()
print("监控回调创建完成")
print()

# ===== 16. 完整示例 =====
print("=== 步骤16: 完整示例 ===\n")

print("执行生产级 RAG 链:")

final_chain = production_chain.with_config({
    "callbacks": [error_callback, monitoring]
})

questions = [
    "什么是向量数据库？",
    "RAG 的优势是什么？"
]

for question in questions:
    print(f"\n问题: {question}")
    try:
        answer = final_chain.invoke(question)
        print(f"答案: {answer[:100]}...")
    except Exception as e:
        print(f"错误: {e}")

print()
monitoring.print_metrics()
print()

print("演示完成！")
```

---

## 运行输出示例

```
=== 步骤1: 配置日志 ===

日志配置完成

=== 步骤2: 创建错误处理回调 ===

错误处理回调创建完成

=== 步骤3: 准备测试数据 ===

测试数据准备完成

=== 步骤4: 构建基础链 ===

基础链构建完成

=== 步骤5: 添加重试逻辑 ===

重试配置:
  最大重试次数: 3
  重试策略: 指数退避 + 随机抖动
  重试错误类型: RateLimitError, APIConnectionError, TimeoutError

=== 步骤6: 添加降级方案 ===

降级配置:
  主链: GPT-4o-mini (10s 超时)
  备用链1: GPT-3.5-turbo (10s 超时)
  备用链2: GPT-3.5-turbo (5s 超时)

=== 步骤7: 添加超时控制 ===

超时配置:
  全局超时: 30秒
  运行名称: production_rag_chain
  标签: production, rag

=== 步骤8: 测试正常情况 ===

问题: 什么是向量数据库？
答案: 向量数据库用于存储和检索向量数据，支持高效的相似度搜索。
耗时: 1.23秒
✅ 执行成功

=== 步骤9: 模拟错误场景 ===

测试重试机制:
  尝试 1/3
  ❌ 模拟失败
  等待 1 秒后重试...
  尝试 2/3
  ❌ 模拟失败
  等待 2 秒后重试...
  尝试 3/3
  ✅ 成功
最终结果: 这是一个模拟的答案

=== 步骤10: 测试降级场景 ===

模拟主链失败，测试降级:
1. 尝试主链...
   ❌ 主链失败: 主链不可用
2. 尝试备用链1...
   ✅ 备用链1成功: 备用链1的答案

=== 步骤11: 批量处理的错误处理 ===

批量处理 3 个问题...

结果:
  成功: 3/3
  失败: 0
  ✅ 什么是向量数据库？...
  ✅ 什么是 RAG？...
  ✅ 什么是 Embedding？...

=== 步骤12: 错误统计和分析 ===

=== 错误处理摘要 ===
总错误数: 0
重试次数: 0
降级次数: 0

=== 步骤13: 生产环境最佳实践 ===

生产环境配置清单:
  ✅ 添加重试逻辑（with_retry）
  ✅ 添加降级方案（with_fallbacks）
  ✅ 设置超时控制（timeout）
  ✅ 配置日志记录（logging）
  ✅ 添加错误回调（callbacks）
  ✅ 集成可观测性（LangSmith）

推荐配置:

production_chain = (
    base_chain
    .with_retry(
        stop_after_attempt=3,
        wait_exponential_jitter=True,
        retry_if_exception_type=(RateLimitError, APIConnectionError)
    )
    .with_fallbacks([fallback_chain1, fallback_chain2])
    .with_config({
        "timeout": 30,
        "run_name": "production",
        "tags": ["production"],
        "callbacks": [ErrorHandlingCallback()]
    })
)

=== 步骤14: 集成 LangSmith ===

启用 LangSmith 追踪:

import os
os.environ["LANGSMITH_TRACING"] = "true"
os.environ["LANGSMITH_API_KEY"] = "your_key"
os.environ["LANGSMITH_PROJECT"] = "production"

# 自动追踪所有执行
result = production_chain.invoke(question)

# 在 LangSmith 控制台查看：
# - 重试次数和时间
# - 降级路径
# - 错误详情和堆栈
# - 性能指标

=== 步骤15: 监控和告警 ===

监控回调创建完成

=== 步骤16: 完整示例 ===

执行生产级 RAG 链:

问题: 什么是向量数据库？
答案: 向量数据库用于存储和检索向量数据，支持高效的相似度搜索。...

问题: RAG 的优势是什么？
答案: RAG 结合检索和生成，先检索相关文档，再基于文档生成答案。...

监控指标:
  总调用数: 2
  成功: 2
  失败: 0
  成功率: 100.0%
  平均耗时: 1.15秒

演示完成！
```

---

## 代码详解

### 1. 重试配置

```python
chain_with_retry = base_chain.with_retry(
    stop_after_attempt=3,
    wait_exponential_jitter=True,
    retry_if_exception_type=(RateLimitError, APIConnectionError)
)
```

**关键点**：
- 最多重试3次
- 指数退避 + 随机抖动
- 只重试临时性错误

### 2. 降级配置

```python
chain_with_fallbacks = chain_with_retry.with_fallbacks([
    fallback_chain1,
    fallback_chain2
])
```

**关键点**：
- 多层降级
- 主链 → 备用链1 → 备用链2
- 逐步降低性能要求

### 3. 错误回调

```python
class ErrorHandlingCallback(BaseCallbackHandler):
    def on_chain_error(self, error, **kwargs):
        # 记录错误
        logger.error(f"链执行失败: {error}")
```

**关键点**：
- 记录所有错误
- 统计重试和降级
- 生成错误报告

---

## 2025-2026 最佳实践

### 1. 错误分类

| 错误类型 | 处理策略 |
|---------|----------|
| `RateLimitError` | 重试 + 指数退避 |
| `APIConnectionError` | 重试 |
| `TimeoutError` | 重试 + 增加超时 |
| `AuthenticationError` | 立即失败 |
| `ModelNotFoundError` | 降级 |

### 2. 监控指标

- 总调用数
- 成功率
- 重试次数
- 降级次数
- 平均耗时

### 3. 告警规则

- 成功率 < 95%
- 平均耗时 > 5秒
- 降级次数 > 10%

---

## 学习检查清单

- [ ] 理解重试机制
- [ ] 理解降级策略
- [ ] 理解错误回调
- [ ] 能运行完整代码
- [ ] 能配置监控告警
- [ ] 了解 2025-2026 最佳实践

---

**版本**: v1.0
**最后更新**: 2026-02-18
**参考来源**:
- LangChain 官方文档
- Medium - 7 Retry & Timeout Policies
