# 面试必问

## 核心目标

**掌握队列与任务调度的5个经典面试题，涵盖基础实现、算法设计、系统设计三个层次。**

---

## 题目1：用两个栈实现队列

### 问题描述

**难度**：⭐⭐
**类型**：数据结构实现
**考察点**：栈和队列的本质区别

实现一个队列，只能使用两个栈作为辅助数据结构。

```python
class MyQueue:
    def __init__(self):
        # 实现队列的入队、出队、查看队首操作
        pass

    def push(self, x: int) -> None:
        """入队"""
        pass

    def pop(self) -> int:
        """出队"""
        pass

    def peek(self) -> int:
        """查看队首元素"""
        pass

    def empty(self) -> bool:
        """判断队列是否为空"""
        pass
```

### 解题思路

**核心洞察**：
- 栈是LIFO（后进先出）
- 队列是FIFO（先进先出）
- 两个栈可以反转顺序

**策略**：
1. **入栈(stack_in)**：所有入队操作都push到stack_in
2. **出栈(stack_out)**：出队时从stack_out pop
3. **转移**：当stack_out为空时，将stack_in的所有元素转移到stack_out

**图解**：
```
入队: 1, 2, 3

stack_in: [1, 2, 3]  (栈顶是3)
stack_out: []

出队时转移:
stack_in: []
stack_out: [3, 2, 1]  (栈顶是1)

出队: 1
stack_out: [3, 2]  (栈顶是2)
```

### 完整实现

```python
class MyQueue:
    def __init__(self):
        self.stack_in = []   # 入队栈
        self.stack_out = []  # 出队栈

    def push(self, x: int) -> None:
        """入队：O(1)"""
        self.stack_in.append(x)

    def pop(self) -> int:
        """出队：均摊O(1)"""
        self._move_if_needed()
        return self.stack_out.pop()

    def peek(self) -> int:
        """查看队首：均摊O(1)"""
        self._move_if_needed()
        return self.stack_out[-1]

    def empty(self) -> bool:
        """判空：O(1)"""
        return not self.stack_in and not self.stack_out

    def _move_if_needed(self):
        """将stack_in的元素转移到stack_out"""
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())

# 测试
queue = MyQueue()
queue.push(1)
queue.push(2)
print(queue.peek())  # 1
print(queue.pop())   # 1
print(queue.empty()) # False
```

### 时间复杂度分析

- **入队**：O(1)
- **出队**：均摊O(1)
  - 最坏情况：O(n)（需要转移n个元素）
  - 均摊分析：每个元素最多被转移一次，所以均摊O(1)

### AI Agent应用

```python
class TaskQueue:
    """任务队列：用两个栈实现优先级调整"""

    def __init__(self):
        self.normal_stack = []    # 普通任务
        self.priority_stack = []  # 优先级任务

    def add_task(self, task, is_priority=False):
        if is_priority:
            self.priority_stack.append(task)
        else:
            self.normal_stack.append(task)

    def get_task(self):
        # 优先处理priority_stack
        if self.priority_stack:
            return self.priority_stack.pop()
        elif self.normal_stack:
            return self.normal_stack.pop()
        return None
```

---

## 题目2：设计任务调度器

### 问题描述

**难度**：⭐⭐⭐
**类型**：系统设计
**考察点**：优先级队列、限流、防饥饿

设计一个任务调度器，满足以下要求：
1. 支持任务优先级（1-10，1最高）
2. 限流：每秒最多处理N个任务
3. 防饥饿：低优先级任务等待超过T秒后自动提升优先级

### 解题思路

**核心组件**：
1. **优先级队列**：管理任务顺序
2. **限流器**：控制处理速率
3. **时间戳**：记录任务等待时间

**防饥饿策略**：
```
adjusted_priority = original_priority - (wait_time / max_wait_time)
```

### 完整实现

```python
import heapq
import asyncio
from dataclasses import dataclass, field
from typing import Any
from datetime import datetime

@dataclass(order=True)
class Task:
    priority: float
    timestamp: float = field(compare=False)
    task_id: str = field(compare=False)
    data: Any = field(compare=False)

class TaskScheduler:
    def __init__(self, rate_limit=10, max_wait_time=60):
        self.heap = []
        self.rate_limit = rate_limit
        self.max_wait_time = max_wait_time
        self.interval = 1.0 / rate_limit

    async def add_task(self, task_id, data, priority=5):
        """添加任务"""
        timestamp = asyncio.get_event_loop().time()
        task = Task(
            priority=priority,
            timestamp=timestamp,
            task_id=task_id,
            data=data
        )
        heapq.heappush(self.heap, task)

    async def process(self):
        """处理任务"""
        while True:
            if not self.heap:
                await asyncio.sleep(0.1)
                continue

            # 检查是否有任务需要提升优先级
            current_time = asyncio.get_event_loop().time()
            self._adjust_priorities(current_time)

            # 取出最高优先级任务
            task = heapq.heappop(self.heap)

            # 限流
            await asyncio.sleep(self.interval)

            # 执行任务
            await self._execute(task)

    def _adjust_priorities(self, current_time):
        """调整优先级防止饥饿"""
        adjusted_heap = []
        for task in self.heap:
            wait_time = current_time - task.timestamp

            if wait_time > self.max_wait_time:
                # 提升优先级
                adjusted_priority = task.priority - (wait_time / self.max_wait_time)
                task = Task(
                    priority=adjusted_priority,
                    timestamp=task.timestamp,
                    task_id=task.task_id,
                    data=task.data
                )

            adjusted_heap.append(task)

        heapq.heapify(adjusted_heap)
        self.heap = adjusted_heap

    async def _execute(self, task):
        """执行任务"""
        print(f"执行任务: {task.task_id}, 优先级: {task.priority:.2f}")
        await asyncio.sleep(0.1)  # 模拟任务执行

# 测试
async def main():
    scheduler = TaskScheduler(rate_limit=5, max_wait_time=10)

    # 启动处理器
    asyncio.create_task(scheduler.process())

    # 添加任务
    await scheduler.add_task("task1", "数据1", priority=5)
    await scheduler.add_task("task2", "数据2", priority=1)
    await scheduler.add_task("task3", "数据3", priority=10)

    # 等待10秒，观察优先级调整
    await asyncio.sleep(15)

asyncio.run(main())
```

### 扩展问题

**Q1：如何支持任务取消？**
```python
class TaskScheduler:
    def __init__(self):
        self.heap = []
        self.cancelled_tasks = set()

    async def cancel_task(self, task_id):
        self.cancelled_tasks.add(task_id)

    async def process(self):
        while True:
            task = heapq.heappop(self.heap)

            # 跳过已取消的任务
            if task.task_id in self.cancelled_tasks:
                continue

            await self._execute(task)
```

**Q2：如何支持任务依赖？**
```python
class TaskScheduler:
    def __init__(self):
        self.heap = []
        self.dependencies = {}  # task_id -> [依赖的task_id]
        self.completed = set()

    async def add_task(self, task_id, data, priority, depends_on=None):
        if depends_on:
            self.dependencies[task_id] = depends_on

        task = Task(priority, time.time(), task_id, data)
        heapq.heappush(self.heap, task)

    async def process(self):
        while True:
            task = heapq.heappop(self.heap)

            # 检查依赖是否完成
            if task.task_id in self.dependencies:
                deps = self.dependencies[task.task_id]
                if not all(dep in self.completed for dep in deps):
                    # 依赖未完成，重新入队
                    heapq.heappush(self.heap, task)
                    await asyncio.sleep(0.1)
                    continue

            await self._execute(task)
            self.completed.add(task.task_id)
```

---

## 题目3：实现LRU缓存

### 问题描述

**难度**：⭐⭐⭐
**类型**：数据结构设计
**考察点**：双端队列、哈希表

实现一个LRU（Least Recently Used）缓存，支持O(1)的get和put操作。

```python
class LRUCache:
    def __init__(self, capacity: int):
        pass

    def get(self, key: int) -> int:
        """获取值，如果不存在返回-1"""
        pass

    def put(self, key: int, value: int) -> None:
        """插入或更新值"""
        pass
```

### 解题思路

**核心数据结构**：
1. **哈希表**：O(1)查找
2. **双向链表**：O(1)移动节点

**策略**：
- get：将节点移到链表头部
- put：插入到链表头部，如果满了删除尾部节点

### 完整实现

```python
class Node:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> Node
        self.head = Node()  # 虚拟头节点
        self.tail = Node()  # 虚拟尾节点
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1

        node = self.cache[key]
        self._move_to_head(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            # 更新值
            node = self.cache[key]
            node.value = value
            self._move_to_head(node)
        else:
            # 插入新节点
            node = Node(key, value)
            self.cache[key] = node
            self._add_to_head(node)

            if len(self.cache) > self.capacity:
                # 删除尾部节点
                removed = self._remove_tail()
                del self.cache[removed.key]

    def _add_to_head(self, node):
        """添加节点到头部"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def _remove_node(self, node):
        """移除节点"""
        node.prev.next = node.next
        node.next.prev = node.prev

    def _move_to_head(self, node):
        """移动节点到头部"""
        self._remove_node(node)
        self._add_to_head(node)

    def _remove_tail(self):
        """移除尾部节点"""
        node = self.tail.prev
        self._remove_node(node)
        return node

# 测试
cache = LRUCache(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # 1
cache.put(3, 3)      # 淘汰key=2
print(cache.get(2))  # -1
```

### AI Agent应用

```python
class AgentResponseCache:
    """Agent响应缓存：LRU策略"""

    def __init__(self, capacity=100):
        self.cache = LRUCache(capacity)

    async def get_response(self, query):
        # 尝试从缓存获取
        cached = self.cache.get(hash(query))
        if cached != -1:
            return cached

        # 调用LLM
        response = await call_llm_api(query)

        # 缓存响应
        self.cache.put(hash(query), response)

        return response
```

---

## 题目4：设计限流器

### 问题描述

**难度**：⭐⭐⭐⭐
**类型**：系统设计
**考察点**：令牌桶、滑动窗口

设计一个限流器，支持每秒最多N个请求。

### 解题思路

**方案1：令牌桶算法**
- 固定速率生成令牌
- 请求消耗令牌
- 令牌不足则拒绝

**方案2：滑动窗口算法**
- 记录每个请求的时间戳
- 统计最近1秒内的请求数
- 超过限制则拒绝

### 实现：令牌桶算法

```python
import asyncio
from datetime import datetime

class TokenBucket:
    def __init__(self, rate_limit=10):
        self.rate_limit = rate_limit
        self.tokens = rate_limit
        self.last_update = datetime.now()

    async def acquire(self):
        """获取令牌"""
        now = datetime.now()
        elapsed = (now - self.last_update).total_seconds()

        # 补充令牌
        self.tokens = min(
            self.rate_limit,
            self.tokens + elapsed * self.rate_limit
        )
        self.last_update = now

        if self.tokens >= 1:
            self.tokens -= 1
            return True
        else:
            # 等待令牌
            wait_time = (1 - self.tokens) / self.rate_limit
            await asyncio.sleep(wait_time)
            self.tokens = 0
            return True

# 使用
limiter = TokenBucket(rate_limit=10)

async def call_api():
    await limiter.acquire()
    # 调用API
    pass
```

### 实现：滑动窗口算法

```python
from collections import deque
import time

class SlidingWindow:
    def __init__(self, rate_limit=10, window_size=1.0):
        self.rate_limit = rate_limit
        self.window_size = window_size
        self.requests = deque()

    def acquire(self):
        """获取许可"""
        now = time.time()

        # 移除过期请求
        while self.requests and now - self.requests[0] > self.window_size:
            self.requests.popleft()

        if len(self.requests) < self.rate_limit:
            self.requests.append(now)
            return True
        else:
            return False

# 使用
limiter = SlidingWindow(rate_limit=10)

def call_api():
    if limiter.acquire():
        # 调用API
        pass
    else:
        # 拒绝请求
        raise Exception("Rate limit exceeded")
```

---

## 题目5：多Agent任务队列设计

### 问题描述

**难度**：⭐⭐⭐⭐⭐
**类型**：系统设计
**考察点**：分布式队列、负载均衡、容错

设计一个多Agent任务队列系统，满足：
1. 支持多个Agent并发处理任务
2. 任务失败自动重试
3. Agent故障时任务重新分配
4. 支持任务优先级

### 解题思路

**核心组件**：
1. **任务队列**：存储待处理任务
2. **Agent池**：管理Agent状态
3. **心跳检测**：检测Agent健康状态
4. **重试机制**：处理失败任务

### 简化实现

```python
import asyncio
import heapq
from enum import Enum
from dataclasses import dataclass
from typing import Dict, Set

class TaskStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class Task:
    task_id: str
    priority: int
    data: dict
    retry_count: int = 0
    max_retries: int = 3

class Agent:
    def __init__(self, agent_id):
        self.agent_id = agent_id
        self.is_alive = True
        self.current_task = None

    async def process(self, task):
        """处理任务"""
        try:
            print(f"Agent {self.agent_id} 处理任务 {task.task_id}")
            await asyncio.sleep(1)  # 模拟处理
            return True
        except Exception as e:
            print(f"任务失败: {e}")
            return False

class MultiAgentQueue:
    def __init__(self, num_agents=3):
        self.task_queue = []
        self.agents: Dict[str, Agent] = {}
        self.running_tasks: Dict[str, Task] = {}
        self.completed_tasks: Set[str] = set()

        # 创建Agent
        for i in range(num_agents):
            agent = Agent(f"agent_{i}")
            self.agents[agent.agent_id] = agent

    async def add_task(self, task: Task):
        """添加任务"""
        heapq.heappush(self.task_queue, (task.priority, task))

    async def start(self):
        """启动调度器"""
        workers = [
            self._agent_worker(agent)
            for agent in self.agents.values()
        ]
        await asyncio.gather(*workers)

    async def _agent_worker(self, agent: Agent):
        """Agent工作循环"""
        while True:
            if not self.task_queue:
                await asyncio.sleep(0.1)
                continue

            # 获取任务
            priority, task = heapq.heappop(self.task_queue)
            self.running_tasks[task.task_id] = task
            agent.current_task = task

            # 处理任务
            success = await agent.process(task)

            if success:
                self.completed_tasks.add(task.task_id)
                del self.running_tasks[task.task_id]
            else:
                # 重试
                task.retry_count += 1
                if task.retry_count < task.max_retries:
                    heapq.heappush(self.task_queue, (priority, task))
                else:
                    print(f"任务 {task.task_id} 失败，超过最大重试次数")

            agent.current_task = None

# 测试
async def main():
    queue = MultiAgentQueue(num_agents=3)

    # 添加任务
    for i in range(10):
        task = Task(
            task_id=f"task_{i}",
            priority=i % 3,
            data={"index": i}
        )
        await queue.add_task(task)

    # 启动
    await queue.start()

asyncio.run(main())
```

---

## 面试技巧总结

### 回答框架

1. **理解问题**：复述问题，确认需求
2. **分析约束**：时间复杂度、空间复杂度、并发性
3. **提出方案**：从简单到复杂，说明权衡
4. **编写代码**：边写边解释
5. **测试验证**：给出测试用例
6. **优化讨论**：讨论可能的优化方向

### 常见追问

**Q1：如何处理分布式场景？**
- 使用Redis/RabbitMQ作为队列
- 使用分布式锁保证任务不重复
- 使用心跳检测Agent健康状态

**Q2：如何保证任务不丢失？**
- 持久化队列（Redis AOF/RDB）
- 任务确认机制（ACK）
- 死信队列（DLQ）

**Q3：如何优化性能？**
- 批量处理任务
- 使用异步I/O
- 增加Agent数量
- 使用缓存减少重复计算

---

**关键洞察**：面试中的队列问题不仅考察数据结构实现，更考察系统设计能力。要能够从简单实现出发，逐步讨论分布式、容错、性能优化等话题。
