# 实战代码7：生产级最佳实践

## 完整可运行示例

```python
"""
生产级Redis缓存最佳实践
演示：连接池、监控、错误处理、配置管理
"""

import redis
from redis import ConnectionPool
import asyncio
import time
from typing import Optional
from dataclasses import dataclass
import logging

# ===== 1. 配置管理 =====

@dataclass
class RedisConfig:
    """Redis配置"""
    host: str = "localhost"
    port: int = 6379
    db: int = 0
    max_connections: int = 20
    socket_timeout: int = 5
    socket_connect_timeout: int = 5
    retry_on_timeout: bool = True
    decode_responses: bool = True

# ===== 2. 连接池管理 =====

class RedisConnectionManager:
    """Redis连接管理器"""

    def __init__(self, config: RedisConfig):
        self.config = config
        self.pool = None
        self.client = None

    def connect(self):
        """建立连接"""
        self.pool = ConnectionPool(
            host=self.config.host,
            port=self.config.port,
            db=self.config.db,
            max_connections=self.config.max_connections,
            socket_timeout=self.config.socket_timeout,
            socket_connect_timeout=self.config.socket_connect_timeout,
            retry_on_timeout=self.config.retry_on_timeout,
            decode_responses=self.config.decode_responses
        )
        self.client = redis.Redis(connection_pool=self.pool)

        # 测试连接
        try:
            self.client.ping()
            print(f"✅ Redis连接成功: {self.config.host}:{self.config.port}")
        except redis.ConnectionError as e:
            print(f"❌ Redis连接失败: {e}")
            raise

    def close(self):
        """关闭连接"""
        if self.pool:
            self.pool.disconnect()
            print("✅ Redis连接已关闭")

    def get_client(self) -> redis.Redis:
        """获取客户端"""
        if not self.client:
            self.connect()
        return self.client

# ===== 3. 监控和统计 =====

class CacheMonitor:
    """缓存监控器"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.logger = logging.getLogger(__name__)

    def record_hit(self, cache_type: str):
        """记录缓存命中"""
        key = f"cache:stats:{cache_type}:hits"
        self.redis.incr(key)
        self.redis.expire(key, 86400)  # 24小时

    def record_miss(self, cache_type: str):
        """记录缓存未命中"""
        key = f"cache:stats:{cache_type}:misses"
        self.redis.incr(key)
        self.redis.expire(key, 86400)

    def get_stats(self, cache_type: str) -> dict:
        """获取统计信息"""
        hits = int(self.redis.get(f"cache:stats:{cache_type}:hits") or 0)
        misses = int(self.redis.get(f"cache:stats:{cache_type}:misses") or 0)
        total = hits + misses

        return {
            "cache_type": cache_type,
            "hits": hits,
            "misses": misses,
            "total": total,
            "hit_rate": hits / total if total > 0 else 0.0
        }

    def get_redis_info(self) -> dict:
        """获取Redis服务器信息"""
        info = self.redis.info()
        return {
            "used_memory": info.get("used_memory_human"),
            "connected_clients": info.get("connected_clients"),
            "total_commands": info.get("total_commands_processed"),
            "keyspace_hits": info.get("keyspace_hits"),
            "keyspace_misses": info.get("keyspace_misses"),
        }

# ===== 4. 错误处理 =====

class ResilientCache:
    """容错缓存"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.logger = logging.getLogger(__name__)

    async def get_with_fallback(
        self,
        key: str,
        fetch_func,
        fallback_value: Optional[str] = None
    ) -> Optional[str]:
        """带降级的缓存获取"""
        try:
            # 尝试从缓存获取
            cached = self.redis.get(key)
            if cached:
                return cached

            # 调用数据源
            data = await fetch_func()

            # 尝试缓存
            try:
                self.redis.setex(key, 3600, data)
            except redis.RedisError as e:
                self.logger.warning(f"缓存写入失败: {e}")

            return data

        except redis.RedisError as e:
            self.logger.error(f"Redis错误: {e}")

            # 降级：直接调用数据源
            try:
                return await fetch_func()
            except Exception as fetch_error:
                self.logger.error(f"数据源调用失败: {fetch_error}")
                return fallback_value

# ===== 5. 健康检查 =====

class HealthChecker:
    """健康检查"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    def check_health(self) -> dict:
        """检查Redis健康状态"""
        try:
            # 1. Ping测试
            start = time.time()
            self.redis.ping()
            latency = (time.time() - start) * 1000

            # 2. 写入测试
            test_key = "health:check"
            self.redis.setex(test_key, 10, "ok")

            # 3. 读取测试
            value = self.redis.get(test_key)

            # 4. 删除测试
            self.redis.delete(test_key)

            return {
                "status": "healthy",
                "latency_ms": round(latency, 2),
                "read_write": "ok"
            }

        except redis.RedisError as e:
            return {
                "status": "unhealthy",
                "error": str(e)
            }

# ===== 6. 完整示例 =====

async def production_example():
    """生产级使用示例"""

    # 1. 初始化
    config = RedisConfig(
        host="localhost",
        port=6379,
        max_connections=20
    )

    manager = RedisConnectionManager(config)
    manager.connect()
    client = manager.get_client()

    # 2. 监控
    monitor = CacheMonitor(client)

    # 3. 容错缓存
    resilient_cache = ResilientCache(client)

    # 模拟数据获取
    async def fetch_data():
        await asyncio.sleep(0.1)
        return "data"

    # 使用容错缓存
    result = await resilient_cache.get_with_fallback(
        "test_key",
        fetch_data,
        fallback_value="default"
    )
    print(f"结果: {result}")

    # 4. 统计
    monitor.record_hit("llm")
    monitor.record_miss("llm")
    stats = monitor.get_stats("llm")
    print(f"\n统计: {stats}")

    # 5. 健康检查
    checker = HealthChecker(client)
    health = checker.check_health()
    print(f"\n健康状态: {health}")

    # 6. Redis信息
    info = monitor.get_redis_info()
    print(f"\nRedis信息: {info}")

    # 7. 清理
    manager.close()

# 运行示例
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(production_example())
```

## FastAPI集成

```python
"""
FastAPI中的生产级Redis集成
"""

from fastapi import FastAPI, Depends, HTTPException
from contextlib import asynccontextmanager

# 全局连接管理器
redis_manager = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    global redis_manager

    # 启动时：建立Redis连接
    config = RedisConfig()
    redis_manager = RedisConnectionManager(config)
    redis_manager.connect()

    yield

    # 关闭时：断开Redis连接
    redis_manager.close()

app = FastAPI(lifespan=lifespan)

def get_redis_client():
    """依赖注入：获取Redis客户端"""
    return redis_manager.get_client()

@app.get("/health")
async def health_check(client: redis.Redis = Depends(get_redis_client)):
    """健康检查端点"""
    checker = HealthChecker(client)
    health = checker.check_health()

    if health["status"] != "healthy":
        raise HTTPException(status_code=503, detail=health)

    return health

@app.get("/stats/{cache_type}")
async def get_cache_stats(
    cache_type: str,
    client: redis.Redis = Depends(get_redis_client)
):
    """获取缓存统计"""
    monitor = CacheMonitor(client)
    return monitor.get_stats(cache_type)
```

## 学习检查清单

- [ ] 实现连接池管理
- [ ] 实现监控和统计
- [ ] 实现错误处理和降级
- [ ] 实现健康检查
- [ ] 在FastAPI中集成Redis
- [ ] 理解生产环境的最佳实践
