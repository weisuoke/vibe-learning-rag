# 核心概念1：邻接矩阵表示

> 用二维数组表示图的边关系

---

## 一句话定义

**邻接矩阵是用二维数组matrix[i][j]表示节点i到j是否有边的图表示方法，查询边O(1)但空间复杂度O(V²)。**

---

## 核心原理

### 基本思想

```python
# 3个节点的有向图
# A → B
# A → C
# B → C

# 邻接矩阵表示
matrix = [
    [0, 1, 1],  # A的行：A→B(1), A→C(1)
    [0, 0, 1],  # B的行：B→C(1)
    [0, 0, 0]   # C的行：无出边
]

# matrix[i][j] = 1 表示节点i到j有边
# matrix[i][j] = 0 表示节点i到j无边
```

**核心规则：**
- 行索引 = 起点节点
- 列索引 = 终点节点
- 值 = 边的存在性（0或1）或权重

---

## 完整实现

### 基础版本

```python
class AdjacencyMatrix:
    """邻接矩阵实现（基础版）"""

    def __init__(self, num_nodes, directed=True):
        """
        num_nodes: 节点数量
        directed: True表示有向图，False表示无向图
        """
        self.num_nodes = num_nodes
        self.directed = directed
        # 初始化全0矩阵
        self.matrix = [[0] * num_nodes for _ in range(num_nodes)]
        # 节点ID到索引的映射
        self.node_to_index = {}
        self.index_to_node = {}
        self.next_index = 0

    def add_node(self, node):
        """添加节点"""
        if node not in self.node_to_index:
            if self.next_index >= self.num_nodes:
                raise ValueError("超过最大节点数")
            self.node_to_index[node] = self.next_index
            self.index_to_node[self.next_index] = node
            self.next_index += 1

    def add_edge(self, u, v, weight=1):
        """添加边：u → v"""
        # 确保节点存在
        if u not in self.node_to_index:
            self.add_node(u)
        if v not in self.node_to_index:
            self.add_node(v)

        # 获取索引
        i = self.node_to_index[u]
        j = self.node_to_index[v]

        # 添加边
        self.matrix[i][j] = weight

        # 无向图需要添加反向边
        if not self.directed:
            self.matrix[j][i] = weight

    def has_edge(self, u, v):
        """检查边是否存在 - O(1)"""
        if u not in self.node_to_index or v not in self.node_to_index:
            return False
        i = self.node_to_index[u]
        j = self.node_to_index[v]
        return self.matrix[i][j] != 0

    def get_neighbors(self, node):
        """获取节点的邻居 - O(V)"""
        if node not in self.node_to_index:
            return []

        i = self.node_to_index[node]
        neighbors = []

        # 遍历整行
        for j in range(self.num_nodes):
            if self.matrix[i][j] != 0:
                neighbors.append(self.index_to_node[j])

        return neighbors

    def get_weight(self, u, v):
        """获取边的权重"""
        if not self.has_edge(u, v):
            return None
        i = self.node_to_index[u]
        j = self.node_to_index[v]
        return self.matrix[i][j]

    def remove_edge(self, u, v):
        """删除边"""
        if u in self.node_to_index and v in self.node_to_index:
            i = self.node_to_index[u]
            j = self.node_to_index[v]
            self.matrix[i][j] = 0
            if not self.directed:
                self.matrix[j][i] = 0

    def print_matrix(self):
        """打印矩阵（调试用）"""
        print("   ", end="")
        for i in range(self.next_index):
            print(f"{self.index_to_node[i]:3}", end=" ")
        print()

        for i in range(self.next_index):
            print(f"{self.index_to_node[i]:3}", end=" ")
            for j in range(self.next_index):
                print(f"{self.matrix[i][j]:3}", end=" ")
            print()

# 使用示例
g = AdjacencyMatrix(5, directed=True)
g.add_edge("A", "B")
g.add_edge("A", "C")
g.add_edge("B", "C")

print("邻接矩阵：")
g.print_matrix()
# 输出：
#      A   B   C
#  A   0   1   1
#  B   0   0   1
#  C   0   0   0

print(f"\nA的邻居: {g.get_neighbors('A')}")  # ['B', 'C']
print(f"A→B存在: {g.has_edge('A', 'B')}")   # True
print(f"B→A存在: {g.has_edge('B', 'A')}")   # False
```

### 带权重的版本

```python
class WeightedAdjacencyMatrix(AdjacencyMatrix):
    """带权重的邻接矩阵"""

    def __init__(self, num_nodes, directed=True):
        super().__init__(num_nodes, directed)
        # 使用None表示无边，而不是0
        self.matrix = [[None] * num_nodes for _ in range(num_nodes)]

    def add_edge(self, u, v, weight):
        """添加带权重的边"""
        if u not in self.node_to_index:
            self.add_node(u)
        if v not in self.node_to_index:
            self.add_node(v)

        i = self.node_to_index[u]
        j = self.node_to_index[v]

        self.matrix[i][j] = weight

        if not self.directed:
            self.matrix[j][i] = weight

    def has_edge(self, u, v):
        """检查边是否存在"""
        if u not in self.node_to_index or v not in self.node_to_index:
            return False
        i = self.node_to_index[u]
        j = self.node_to_index[v]
        return self.matrix[i][j] is not None

    def get_neighbors(self, node):
        """获取邻居及权重"""
        if node not in self.node_to_index:
            return []

        i = self.node_to_index[node]
        neighbors = []

        for j in range(self.num_nodes):
            if self.matrix[i][j] is not None:
                neighbor_node = self.index_to_node[j]
                weight = self.matrix[i][j]
                neighbors.append((neighbor_node, weight))

        return neighbors

# 使用示例：城市距离图
g = WeightedAdjacencyMatrix(4, directed=False)
g.add_edge("北京", "上海", 1200)
g.add_edge("北京", "广州", 2100)
g.add_edge("上海", "广州", 1400)

print("北京的邻居:", g.get_neighbors("北京"))
# [('上海', 1200), ('广州', 2100)]
```

---

## 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| **添加边** | O(1) | 直接设置matrix[i][j] |
| **删除边** | O(1) | 直接设置matrix[i][j] = 0 |
| **查询边** | O(1) | 直接访问matrix[i][j] |
| **获取邻居** | O(V) | 需要遍历整行 |
| **获取度数** | O(V) | 需要遍历整行/列 |
| **遍历所有边** | O(V²) | 需要遍历整个矩阵 |

**关键洞察：**
- ✅ 查询边是否存在：O(1) - 最大优势
- ❌ 获取邻居：O(V) - 即使只有少数邻居也要遍历整行
- ❌ 空间复杂度：O(V²) - 稀疏图浪费空间

---

## 空间复杂度分析

```python
# 空间复杂度：O(V²)

# 示例：1000个节点的图
V = 1000
space = V * V = 1,000,000 个元素

# 如果每个元素4字节（int）
memory = 1,000,000 * 4 bytes = 4 MB

# 如果只有5000条边（稀疏图）
# 实际需要的空间：5000 * 2 = 10,000 个元素
# 浪费的空间：1,000,000 - 10,000 = 990,000 个元素
# 空间利用率：1%
```

**结论：稀疏图使用邻接矩阵非常浪费空间！**

---

## 有向图 vs 无向图

### 有向图

```python
# 有向图：A → B ≠ B → A
matrix = [
    [0, 1, 0],  # A → B
    [0, 0, 1],  # B → C
    [0, 0, 0]   # C无出边
]

# 矩阵不对称
```

### 无向图

```python
# 无向图：A - B = B - A
matrix = [
    [0, 1, 1],  # A - B, A - C
    [1, 0, 1],  # B - A, B - C
    [1, 1, 0]   # C - A, C - B
]

# 矩阵对称（沿对角线对称）
# matrix[i][j] = matrix[j][i]
```

**实现差异：**

```python
# 有向图：只设置一个方向
def add_edge_directed(matrix, i, j):
    matrix[i][j] = 1

# 无向图：设置两个方向
def add_edge_undirected(matrix, i, j):
    matrix[i][j] = 1
    matrix[j][i] = 1  # 对称
```

---

## 适用场景

### ✅ 适合使用邻接矩阵的场景

1. **密集图**
   ```python
   # 完全图或接近完全图
   # 边数接近 V * (V-1) / 2
   ```

2. **需要频繁查询边是否存在**
   ```python
   # 例如：判断两个用户是否是朋友
   if matrix[user1][user2]:
       print("是朋友")
   ```

3. **小规模图**
   ```python
   # 节点数 < 100
   # 空间开销可接受
   ```

4. **矩阵运算**
   ```python
   # 需要进行矩阵乘法等运算
   # 例如：计算图的传递闭包
   ```

### ❌ 不适合使用邻接矩阵的场景

1. **稀疏图**
   ```python
   # 知识图谱：10万实体，50万关系
   # 密度：50万 / (10万 * 10万) = 0.005%
   # 浪费99.995%的空间！
   ```

2. **大规模图**
   ```python
   # 社交网络：100万用户
   # 需要：100万 * 100万 * 4字节 = 4TB内存
   # 不现实！
   ```

3. **需要频繁遍历邻居**
   ```python
   # 图遍历算法（BFS/DFS）
   # 每次都要遍历整行，效率低
   ```

---

## 在AI Agent中的应用

### 应用1：小规模实体关系矩阵

```python
# 场景：3个实体的关系矩阵
entities = ["张三", "阿里巴巴", "杭州"]

# 关系矩阵
relations = [
    [0, 1, 1],  # 张三 → 阿里巴巴, 杭州
    [0, 0, 1],  # 阿里巴巴 → 杭州
    [0, 0, 0]   # 杭州 → 无
]

# 快速查询：张三和阿里巴巴有关系吗？
has_relation = relations[0][1]  # O(1)
```

### 应用2：权限矩阵

```python
# 场景：用户-资源权限矩阵
users = ["admin", "user1", "user2"]
resources = ["read", "write", "delete"]

permissions = [
    [1, 1, 1],  # admin: 全部权限
    [1, 1, 0],  # user1: 读写
    [1, 0, 0]   # user2: 只读
]

# 快速检查权限
def has_permission(user_id, resource_id):
    return permissions[user_id][resource_id] == 1
```

### 应用3：相似度矩阵

```python
import numpy as np

# 场景：文档相似度矩阵
docs = ["doc1", "doc2", "doc3"]

# 计算余弦相似度
similarity_matrix = np.array([
    [1.0, 0.8, 0.3],
    [0.8, 1.0, 0.5],
    [0.3, 0.5, 1.0]
])

# 找最相似的文档
def find_most_similar(doc_id):
    similarities = similarity_matrix[doc_id]
    # 排除自己
    similarities[doc_id] = -1
    most_similar = np.argmax(similarities)
    return docs[most_similar]

print(find_most_similar(0))  # doc2（相似度0.8）
```

---

## 优化技巧

### 技巧1：使用稀疏矩阵

```python
from scipy.sparse import lil_matrix

# 稀疏矩阵表示（只存储非零元素）
sparse_matrix = lil_matrix((1000, 1000))
sparse_matrix[0, 1] = 1
sparse_matrix[0, 2] = 1

# 节省空间：只存储非零元素
```

### 技巧2：位图优化

```python
# 使用位图存储0/1矩阵
import bitarray

# 1000个节点的位图
n = 1000
bitmap = bitarray.bitarray(n * n)
bitmap.setall(0)

# 设置边
def set_edge(i, j):
    bitmap[i * n + j] = 1

# 查询边
def has_edge(i, j):
    return bitmap[i * n + j]

# 空间节省：8倍（1 bit vs 8 bits）
```

### 技巧3：对称矩阵优化

```python
# 无向图的矩阵是对称的
# 只存储上三角或下三角

class SymmetricMatrix:
    def __init__(self, n):
        # 只存储上三角：n*(n+1)/2 个元素
        self.data = [0] * (n * (n + 1) // 2)
        self.n = n

    def _index(self, i, j):
        """将(i,j)映射到一维索引"""
        if i > j:
            i, j = j, i  # 确保i <= j
        return i * self.n - i * (i + 1) // 2 + j

    def set(self, i, j, value):
        self.data[self._index(i, j)] = value

    def get(self, i, j):
        return self.data[self._index(i, j)]

# 空间节省：50%
```

---

## 对比邻接表

| 特性 | 邻接矩阵 | 邻接表 |
|------|----------|--------|
| **空间复杂度** | O(V²) | O(V+E) |
| **查询边** | O(1) | O(degree) |
| **获取邻居** | O(V) | O(1) |
| **添加边** | O(1) | O(1) |
| **删除边** | O(1) | O(degree) |
| **适合场景** | 密集图、小规模 | 稀疏图、大规模 |
| **内存占用** | 大 | 小 |

**选择建议：**
```python
def choose_representation(num_nodes, num_edges):
    density = num_edges / (num_nodes * (num_nodes - 1))

    if density > 0.5:
        return "邻接矩阵"  # 密集图
    else:
        return "邻接表"    # 稀疏图（推荐）
```

---

## 实战练习

### 练习1：实现无向图

```python
# 实现一个无向图的邻接矩阵
# 要求：
# 1. 添加边时自动添加反向边
# 2. 矩阵对称
# 3. 能计算节点的度数

class UndirectedGraph:
    def __init__(self, n):
        self.matrix = [[0] * n for _ in range(n)]
        self.n = n

    def add_edge(self, i, j):
        # TODO: 实现
        pass

    def degree(self, i):
        # TODO: 计算节点i的度数
        pass
```

### 练习2：矩阵乘法求路径

```python
# 使用矩阵乘法计算两跳路径
# A^2[i][j] 表示从i到j的两跳路径数量

import numpy as np

def count_two_hop_paths(matrix):
    # TODO: 实现
    pass
```

---

## 总结

**邻接矩阵的核心特点：**
1. ✅ O(1)查询边是否存在
2. ❌ O(V²)空间复杂度
3. ❌ O(V)获取邻居
4. ✅ 适合密集图和小规模图
5. ❌ 不适合稀疏图和大规模图

**在AI Agent中的应用：**
- 小规模实体关系矩阵
- 权限矩阵
- 相似度矩阵
- 需要频繁查询边的场景

**关键洞察：**
- 99%的实际应用（知识图谱、社交网络）都是稀疏图
- 稀疏图应该使用邻接表，不是邻接矩阵
- 邻接矩阵适合特定场景，不是通用方案

---

**下一步：** 学习 `03_核心概念_02_邻接表表示.md` - 更适合实际应用的表示方法
