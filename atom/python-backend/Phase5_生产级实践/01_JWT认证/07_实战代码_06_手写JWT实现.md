# JWT认证 - 实战代码06：手写JWT实现

## 概述

本章从零实现JWT编码器和解码器，深入理解JWT的工作原理。

---

## 为什么要手写JWT？

**学习价值：**
- 深入理解JWT的三部分结构
- 理解Base64URL编码原理
- 理解HMAC-SHA256签名机制
- 面试时展示深度理解

**生产环境：**
- ❌ 不推荐手写（使用python-jose等成熟库）
- ✅ 理解原理后更好地使用库
- ✅ 调试和排查问题时有帮助

---

## 手写Base64URL编码器

### Base64URL vs Base64

**区别：**
```
Base64:     使用 +, /, =
Base64URL:  使用 -, _, 去掉=
```

**为什么需要Base64URL？**
- URL中 `+` 会被解析为空格
- URL中 `/` 是路径分隔符
- URL中 `=` 是查询参数分隔符

### 实现Base64URL编码器

```python
"""
手写Base64URL编码器
演示：从零实现Base64URL编码和解码
"""

import base64


class Base64URLEncoder:
    """Base64URL编码器"""

    @staticmethod
    def encode(data: bytes) -> str:
        """
        Base64URL编码

        Args:
            data: 要编码的字节数据

        Returns:
            Base64URL编码的字符串
        """
        # 1. 标准Base64编码
        b64 = base64.urlsafe_b64encode(data).decode('utf-8')

        # 2. 去掉末尾的=填充
        return b64.rstrip('=')

    @staticmethod
    def decode(encoded: str) -> bytes:
        """
        Base64URL解码

        Args:
            encoded: Base64URL编码的字符串

        Returns:
            解码后的字节数据
        """
        # 1. 添加=填充（Base64要求长度是4的倍数）
        padding = 4 - len(encoded) % 4
        if padding != 4:
            encoded += '=' * padding

        # 2. 标准Base64解码
        return base64.urlsafe_b64decode(encoded)


# ===== 测试 =====

encoder = Base64URLEncoder()

# 测试编码
data = b"Hello, JWT!"
encoded = encoder.encode(data)
print(f"原始数据: {data}")
print(f"编码后: {encoded}")

# 测试解码
decoded = encoder.decode(encoded)
print(f"解码后: {decoded}")
print(f"解码正确: {data == decoded}")
```

---

## 手写HMAC-SHA256签名器

### HMAC原理

**HMAC（Hash-based Message Authentication Code）**：
```
HMAC(key, message) = H((key ⊕ opad) || H((key ⊕ ipad) || message))

其中：
- H = 哈希函数（SHA256）
- opad = 外部填充（0x5c重复）
- ipad = 内部填充（0x36重复）
- ⊕ = 异或运算
- || = 连接
```

### 实现HMAC-SHA256签名器

```python
"""
手写HMAC-SHA256签名器
演示：从零实现HMAC签名
"""

import hashlib


class HMACSigner:
    """HMAC-SHA256签名器"""

    def __init__(self, key: bytes):
        """
        初始化签名器

        Args:
            key: 密钥
        """
        self.block_size = 64  # SHA256的块大小

        # 处理密钥长度
        if len(key) > self.block_size:
            # 密钥太长，先哈希
            key = hashlib.sha256(key).digest()

        if len(key) < self.block_size:
            # 密钥太短，填充到块大小
            key = key + b'\x00' * (self.block_size - len(key))

        self.key = key

    def sign(self, message: bytes) -> bytes:
        """
        生成HMAC签名

        Args:
            message: 要签名的消息

        Returns:
            签名（32字节）
        """
        # 1. 计算内部填充密钥（key ⊕ ipad）
        ipad = bytes([0x36] * self.block_size)
        inner_key = bytes([k ^ i for k, i in zip(self.key, ipad)])

        # 2. 内部哈希：H((key ⊕ ipad) || message)
        inner_hash = hashlib.sha256(inner_key + message).digest()

        # 3. 计算外部填充密钥（key ⊕ opad）
        opad = bytes([0x5c] * self.block_size)
        outer_key = bytes([k ^ o for k, o in zip(self.key, opad)])

        # 4. 外部哈希：H((key ⊕ opad) || inner_hash)
        outer_hash = hashlib.sha256(outer_key + inner_hash).digest()

        return outer_hash

    def verify(self, message: bytes, signature: bytes) -> bool:
        """
        验证HMAC签名

        Args:
            message: 消息
            signature: 签名

        Returns:
            签名是否有效
        """
        expected_signature = self.sign(message)

        # 使用恒定时间比较，防止时序攻击
        return self._constant_time_compare(signature, expected_signature)

    def _constant_time_compare(self, a: bytes, b: bytes) -> bool:
        """恒定时间比较"""
        if len(a) != len(b):
            return False

        result = 0
        for x, y in zip(a, b):
            result |= x ^ y

        return result == 0


# ===== 测试 =====

# 创建签名器
key = b"your-secret-key"
signer = HMACSigner(key)

# 生成签名
message = b"Header.Payload"
signature = signer.sign(message)
print(f"消息: {message}")
print(f"签名: {signature.hex()}")

# 验证签名
is_valid = signer.verify(message, signature)
print(f"签名有效: {is_valid}")

# 测试篡改
tampered_message = b"Header.TamperedPayload"
is_valid = signer.verify(tampered_message, signature)
print(f"篡改后签名有效: {is_valid}")


# ===== 与标准库对比 =====
import hmac

stdlib_signature = hmac.new(key, message, hashlib.sha256).digest()
print(f"\n手写实现: {signature.hex()}")
print(f"标准库实现: {stdlib_signature.hex()}")
print(f"结果相同: {signature == stdlib_signature}")
```

---

## 手写JWT编码器

### 完整实现

```python
"""
手写JWT编码器
演示：从零实现JWT的生成和验证
"""

import json
import hashlib
from datetime import datetime, timedelta
from typing import Dict, Any, Optional


class SimpleJWT:
    """简化的JWT实现"""

    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        """
        初始化JWT编码器

        Args:
            secret_key: 密钥
            algorithm: 签名算法（目前只支持HS256）
        """
        if algorithm != "HS256":
            raise ValueError("目前只支持HS256算法")

        self.secret_key = secret_key
        self.algorithm = algorithm
        self.encoder = Base64URLEncoder()
        self.signer = HMACSigner(secret_key.encode('utf-8'))

    def encode(
        self,
        payload: Dict[str, Any],
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """
        生成JWT

        Args:
            payload: 要编码的数据
            expires_delta: 过期时间（从现在开始）

        Returns:
            JWT字符串
        """
        # 1. 创建Header
        header = {
            "alg": self.algorithm,
            "typ": "JWT"
        }

        # 2. 编码Header
        header_json = json.dumps(header, separators=(',', ':')).encode('utf-8')
        header_encoded = self.encoder.encode(header_json)

        # 3. 添加标准字段到Payload
        payload = payload.copy()
        now = datetime.utcnow()
        payload['iat'] = int(now.timestamp())

        if expires_delta:
            payload['exp'] = int((now + expires_delta).timestamp())

        # 4. 编码Payload
        payload_json = json.dumps(payload, separators=(',', ':')).encode('utf-8')
        payload_encoded = self.encoder.encode(payload_json)

        # 5. 创建签名
        message = f"{header_encoded}.{payload_encoded}".encode('utf-8')
        signature = self.signer.sign(message)
        signature_encoded = self.encoder.encode(signature)

        # 6. 组合成完整的JWT
        return f"{header_encoded}.{payload_encoded}.{signature_encoded}"

    def decode(self, token: str) -> Dict[str, Any]:
        """
        验证并解码JWT

        Args:
            token: JWT字符串

        Returns:
            Payload数据

        Raises:
            ValueError: Token无效或已过期
        """
        # 1. 分割Token
        parts = token.split('.')
        if len(parts) != 3:
            raise ValueError("无效的JWT格式")

        header_encoded, payload_encoded, signature_encoded = parts

        # 2. 验证签名
        message = f"{header_encoded}.{payload_encoded}".encode('utf-8')
        signature = self.encoder.decode(signature_encoded)

        if not self.signer.verify(message, signature):
            raise ValueError("签名验证失败")

        # 3. 解码Header
        header_json = self.encoder.decode(header_encoded).decode('utf-8')
        header = json.loads(header_json)

        # 4. 检查算法
        if header.get('alg') != self.algorithm:
            raise ValueError(f"不支持的算法: {header.get('alg')}")

        # 5. 解码Payload
        payload_json = self.encoder.decode(payload_encoded).decode('utf-8')
        payload = json.loads(payload_json)

        # 6. 检查过期时间
        if 'exp' in payload:
            if payload['exp'] < int(datetime.utcnow().timestamp()):
                raise ValueError("Token已过期")

        return payload


# ===== 使用示例 =====

# 1. 创建JWT编码器
jwt_encoder = SimpleJWT(secret_key="your-secret-key")

# 2. 生成Token
payload = {
    "user_id": 123,
    "username": "alice",
    "role": "admin"
}
token = jwt_encoder.encode(payload, expires_delta=timedelta(minutes=15))
print(f"生成的Token:\n{token}\n")

# 3. 验证并解码Token
try:
    decoded_payload = jwt_encoder.decode(token)
    print(f"解码的Payload: {decoded_payload}")
except ValueError as e:
    print(f"验证失败: {e}")

# 4. 测试篡改
print("\n测试篡改:")
tampered_token = token[:-5] + "xxxxx"  # 修改签名
try:
    jwt_encoder.decode(tampered_token)
except ValueError as e:
    print(f"篡改检测成功: {e}")

# 5. 测试过期
print("\n测试过期:")
expired_token = jwt_encoder.encode(
    payload,
    expires_delta=timedelta(seconds=-1)  # 已经过期
)
try:
    jwt_encoder.decode(expired_token)
except ValueError as e:
    print(f"过期检测成功: {e}")
```

---

## 与python-jose对比

### 功能对比

```python
"""
手写实现 vs python-jose
演示：对比两种实现的结果
"""

from jose import jwt as jose_jwt

# 配置
secret_key = "your-secret-key"
payload = {"user_id": 123, "username": "alice"}


# ===== 使用python-jose =====
token_jose = jose_jwt.encode(payload, secret_key, algorithm="HS256")
payload_jose = jose_jwt.decode(token_jose, secret_key, algorithms=["HS256"])

print("=== python-jose ===")
print(f"Token: {token_jose[:50]}...")
print(f"Payload: {payload_jose}")


# ===== 使用手写实现 =====
jwt_encoder = SimpleJWT(secret_key)
token_simple = jwt_encoder.encode(payload)
payload_simple = jwt_encoder.decode(token_simple)

print("\n=== 手写实现 ===")
print(f"Token: {token_simple[:50]}...")
print(f"Payload: {payload_simple}")


# ===== 交叉验证 =====
print("\n=== 交叉验证 ===")

# 用python-jose验证手写实现生成的Token
try:
    payload_cross = jose_jwt.decode(token_simple, secret_key, algorithms=["HS256"])
    print(f"✓ python-jose可以验证手写实现的Token")
    print(f"  Payload: {payload_cross}")
except Exception as e:
    print(f"✗ python-jose无法验证手写实现的Token: {e}")

# 用手写实现验证python-jose生成的Token
try:
    payload_cross = jwt_encoder.decode(token_jose)
    print(f"✓ 手写实现可以验证python-jose的Token")
    print(f"  Payload: {payload_cross}")
except Exception as e:
    print(f"✗ 手写实现无法验证python-jose的Token: {e}")
```

---

## 完整的手写JWT库

### 生产级特性

```python
"""
完整的手写JWT库
演示：添加更多特性
"""

from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta
import json
import hashlib


class JWTError(Exception):
    """JWT错误基类"""
    pass


class ExpiredSignatureError(JWTError):
    """Token已过期"""
    pass


class InvalidSignatureError(JWTError):
    """签名无效"""
    pass


class InvalidTokenError(JWTError):
    """Token无效"""
    pass


class FullJWT:
    """完整的JWT实现"""

    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.encoder = Base64URLEncoder()
        self.signer = HMACSigner(secret_key.encode('utf-8'))

    def encode(
        self,
        payload: Dict[str, Any],
        expires_delta: Optional[timedelta] = None,
        issuer: Optional[str] = None,
        audience: Optional[str] = None
    ) -> str:
        """
        生成JWT（支持更多标准字段）

        Args:
            payload: 要编码的数据
            expires_delta: 过期时间
            issuer: 签发者（iss）
            audience: 接收方（aud）

        Returns:
            JWT字符串
        """
        # 创建Header
        header = {
            "alg": self.algorithm,
            "typ": "JWT"
        }

        # 编码Header
        header_json = json.dumps(header, separators=(',', ':')).encode('utf-8')
        header_encoded = self.encoder.encode(header_json)

        # 添加标准字段
        payload = payload.copy()
        now = datetime.utcnow()
        payload['iat'] = int(now.timestamp())

        if expires_delta:
            payload['exp'] = int((now + expires_delta).timestamp())

        if issuer:
            payload['iss'] = issuer

        if audience:
            payload['aud'] = audience

        # 编码Payload
        payload_json = json.dumps(payload, separators=(',', ':')).encode('utf-8')
        payload_encoded = self.encoder.encode(payload_json)

        # 创建签名
        message = f"{header_encoded}.{payload_encoded}".encode('utf-8')
        signature = self.signer.sign(message)
        signature_encoded = self.encoder.encode(signature)

        return f"{header_encoded}.{payload_encoded}.{signature_encoded}"

    def decode(
        self,
        token: str,
        verify: bool = True,
        audience: Optional[str] = None,
        issuer: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        验证并解码JWT（支持更多验证选项）

        Args:
            token: JWT字符串
            verify: 是否验证签名
            audience: 期望的接收方
            issuer: 期望的签发者

        Returns:
            Payload数据

        Raises:
            JWTError: Token无效或已过期
        """
        # 分割Token
        parts = token.split('.')
        if len(parts) != 3:
            raise InvalidTokenError("无效的JWT格式")

        header_encoded, payload_encoded, signature_encoded = parts

        # 验证签名
        if verify:
            message = f"{header_encoded}.{payload_encoded}".encode('utf-8')
            signature = self.encoder.decode(signature_encoded)

            if not self.signer.verify(message, signature):
                raise InvalidSignatureError("签名验证失败")

        # 解码Header
        header_json = self.encoder.decode(header_encoded).decode('utf-8')
        header = json.loads(header_json)

        # 检查算法
        if header.get('alg') != self.algorithm:
            raise InvalidTokenError(f"不支持的算法: {header.get('alg')}")

        # 解码Payload
        payload_json = self.encoder.decode(payload_encoded).decode('utf-8')
        payload = json.loads(payload_json)

        # 检查过期时间
        if 'exp' in payload:
            if payload['exp'] < int(datetime.utcnow().timestamp()):
                raise ExpiredSignatureError("Token已过期")

        # 检查接收方
        if audience and payload.get('aud') != audience:
            raise InvalidTokenError(f"接收方不匹配: 期望 {audience}, 实际 {payload.get('aud')}")

        # 检查签发者
        if issuer and payload.get('iss') != issuer:
            raise InvalidTokenError(f"签发者不匹配: 期望 {issuer}, 实际 {payload.get('iss')}")

        return payload


# ===== 使用示例 =====

jwt_encoder = FullJWT(secret_key="your-secret-key")

# 1. 生成带完整字段的Token
token = jwt_encoder.encode(
    payload={"user_id": 123, "username": "alice"},
    expires_delta=timedelta(minutes=15),
    issuer="https://api.example.com",
    audience="https://app.example.com"
)
print(f"Token: {token[:50]}...")

# 2. 验证Token（检查issuer和audience）
try:
    payload = jwt_encoder.decode(
        token,
        issuer="https://api.example.com",
        audience="https://app.example.com"
    )
    print(f"✓ Token有效: {payload}")
except JWTError as e:
    print(f"✗ Token无效: {e}")

# 3. 测试audience不匹配
try:
    payload = jwt_encoder.decode(
        token,
        audience="https://wrong-app.example.com"
    )
except InvalidTokenError as e:
    print(f"✓ 检测到audience不匹配: {e}")
```

---

## 性能对比

### 基准测试

```python
"""
性能对比
演示：手写实现 vs python-jose
"""

import time
from jose import jwt as jose_jwt

secret_key = "your-secret-key"
payload = {"user_id": 123, "username": "alice"}

# 测试次数
iterations = 10000


# ===== 测试python-jose =====
start = time.time()
for _ in range(iterations):
    token = jose_jwt.encode(payload, secret_key, algorithm="HS256")
    jose_jwt.decode(token, secret_key, algorithms=["HS256"])
jose_time = time.time() - start


# ===== 测试手写实现 =====
jwt_encoder = SimpleJWT(secret_key)
start = time.time()
for _ in range(iterations):
    token = jwt_encoder.encode(payload)
    jwt_encoder.decode(token)
simple_time = time.time() - start


# ===== 结果 =====
print(f"测试次数: {iterations}")
print(f"python-jose: {jose_time:.3f}秒")
print(f"手写实现: {simple_time:.3f}秒")
print(f"性能差距: {simple_time / jose_time:.2f}x")
```

**预期结果：**
```
测试次数: 10000
python-jose: 0.523秒
手写实现: 1.247秒
性能差距: 2.38x
```

**结论：**
- python-jose更快（使用C扩展）
- 手写实现性能可接受（纯Python）
- 生产环境推荐使用python-jose

---

## 在FastAPI中使用手写JWT

### 集成示例

```python
"""
在FastAPI中使用手写JWT
演示：完整的认证系统
"""

from fastapi import FastAPI, Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

app = FastAPI()
security = HTTPBearer()

# 使用手写JWT
jwt_encoder = FullJWT(secret_key="your-secret-key")


async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """验证Token并返回用户信息"""
    try:
        payload = jwt_encoder.decode(credentials.credentials)
        return payload

    except ExpiredSignatureError:
        raise HTTPException(401, "Token已过期")

    except InvalidSignatureError:
        raise HTTPException(401, "签名验证失败")

    except JWTError:
        raise HTTPException(401, "无效的Token")


@app.post("/login")
async def login(username: str, password: str):
    """登录端点"""
    # 验证密码...

    # 生成Token
    token = jwt_encoder.encode(
        payload={"user_id": 123, "username": username},
        expires_delta=timedelta(minutes=15)
    )

    return {"access_token": token, "token_type": "bearer"}


@app.get("/protected")
async def protected_route(current_user: dict = Depends(get_current_user)):
    """受保护的端点"""
    return {"user": current_user}
```

---

## 总结

**本章实现了：**
1. Base64URL编码器
2. HMAC-SHA256签名器
3. 简化的JWT编码器
4. 完整的JWT库
5. 与python-jose对比
6. 性能基准测试
7. FastAPI集成

**关键点：**
- Base64URL去掉=填充
- HMAC使用内外两次哈希
- JWT = Header.Payload.Signature
- 签名验证使用恒定时间比较
- 手写实现帮助理解原理
- 生产环境使用成熟库

**手写实现的价值：**
- 深入理解JWT工作原理
- 面试时展示技术深度
- 调试问题时有帮助
- 但生产环境应使用python-jose

**下一步：**
- 学习生产级最佳实践
- 学习完整AI Agent API
