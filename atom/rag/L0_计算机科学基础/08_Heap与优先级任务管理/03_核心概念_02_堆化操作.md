# 核心概念02: 堆化操作

## 核心目标

**深入理解Heapify操作的原理、实现和优化,包括heapify-up、heapify-down、build heap的完整分析。**

---

## 1. Heapify-up (上浮/Sift Up)

### 1.1 操作场景

**何时使用:** 新元素插入到heap末尾后,需要恢复heap性质。

**问题:** 新元素可能比父节点小(min-heap),违反heap性质。

**解决:** 将新元素与父节点比较,如果违反heap性质则交换,重复直到满足heap性质或到达根节点。

### 1.2 算法步骤

```python
def heapify_up(heap, i):
    """
    向上调整heap性质

    Args:
        heap: 数组表示的heap
        i: 需要调整的节点索引

    时间复杂度: O(log n)
    空间复杂度: O(1)
    """
    while i > 0:
        parent = (i - 1) // 2

        if heap[i] < heap[parent]:  # Min-heap
            # 违反heap性质,交换
            heap[i], heap[parent] = heap[parent], heap[i]
            i = parent  # 继续向上
        else:
            # 满足heap性质,停止
            break
```

### 1.3 可视化过程

**示例:** 插入3到heap [5, 10, 15, 20, 25]

```
初始状态:
       5
      / \
    10   15
   / \
  20  25

插入3到末尾:
       5
      / \
    10   15
   / \   /
  20 25 3

Step 1: 比较3和15 (父节点)
3 < 15, 交换:
       5
      / \
    10   3
   / \   /
  20 25 15

Step 2: 比较3和5 (父节点)
3 < 5, 交换:
       3
      / \
    10   5
   / \   /
  20 25 15

Step 3: 到达根节点,停止
```

### 1.4 循环不变量

**不变量:** 每次迭代后,除了i到root的路径外,其他部分仍满足heap性质。

**证明:**
1. 初始:新元素插入末尾,除了可能违反与父节点的关系外,其他部分满足heap性质
2. 维护:交换i和parent后,i的子树仍满足heap性质(因为i原来就比子节点小)
3. 终止:i=0或heap[i]≥heap[parent],整个heap满足heap性质

### 1.5 时间复杂度分析

```
最坏情况:新元素是最小值,需要一路上浮到根
路径长度 = 树高度 = ⌊log₂ n⌋
每次迭代:1次比较 + 可能1次交换 = O(1)
总复杂度: O(log n)

最好情况:新元素比父节点大,不需要交换
复杂度: O(1)

平均情况:期望上浮高度约为log n / 2
复杂度: O(log n)
```

### 1.6 优化技巧

**优化1: 减少交换次数**

```python
def heapify_up_optimized(heap, i):
    """
    优化版heapify-up:用赋值代替交换

    减少交换次数:从2n次赋值减少到n+1次
    """
    value = heap[i]  # 保存要上浮的值

    while i > 0:
        parent = (i - 1) // 2

        if value < heap[parent]:
            heap[i] = heap[parent]  # 父节点下移
            i = parent
        else:
            break

    heap[i] = value  # 最终位置赋值
```

**性能对比:**

```python
# 标准版:每次交换3次赋值
heap[i], heap[parent] = heap[parent], heap[i]

# 优化版:总共n+1次赋值
# 假设上浮k层:
# 标准版: 3k次赋值
# 优化版: k+1次赋值
# 节省: 2k-1次赋值
```

---

## 2. Heapify-down (下沉/Sift Down)

### 2.1 操作场景

**何时使用:** 删除根节点后,末尾元素移到根,需要恢复heap性质。

**问题:** 根节点可能比子节点大(min-heap),违反heap性质。

**解决:** 将根节点与较小的子节点比较,如果违反heap性质则交换,重复直到满足heap性质或到达叶子节点。

### 2.2 算法步骤

```python
def heapify_down(heap, i, n=None):
    """
    向下调整heap性质

    Args:
        heap: 数组表示的heap
        i: 需要调整的节点索引
        n: heap大小(默认为len(heap))

    时间复杂度: O(log n)
    空间复杂度: O(1)
    """
    if n is None:
        n = len(heap)

    while 2 * i + 1 < n:  # 有左子节点
        left = 2 * i + 1
        right = 2 * i + 2
        smallest = i

        # 找出i, left, right中最小的
        if heap[left] < heap[smallest]:
            smallest = left

        if right < n and heap[right] < heap[smallest]:
            smallest = right

        if smallest != i:
            # 违反heap性质,交换
            heap[i], heap[smallest] = heap[smallest], heap[i]
            i = smallest  # 继续向下
        else:
            # 满足heap性质,停止
            break
```

### 2.3 可视化过程

**示例:** 从heap [3, 10, 5, 20, 25, 15]删除3

```
初始状态:
       3
      / \
    10   5
   / \   /
  20 25 15

删除3,末尾元素15移到根:
       15
      / \
    10   5
   / \
  20 25

Step 1: 比较15, 10, 5
最小是5,交换15和5:
       5
      / \
    10   15
   / \
  20 25

Step 2: 15是叶子节点,停止
```

### 2.4 循环不变量

**不变量:** 每次迭代后,除了i到leaf的一条路径外,其他部分仍满足heap性质。

**证明:**
1. 初始:末尾元素移到根,除了可能违反与子节点的关系外,其他部分满足heap性质
2. 维护:交换i和smallest后,i的父节点仍满足heap性质(因为smallest原来就比i小)
3. 终止:i是叶子节点或heap[i]≤min(heap[left], heap[right]),整个heap满足heap性质

### 2.5 时间复杂度分析

```
最坏情况:根节点是最大值,需要一路下沉到叶子
路径长度 = 树高度 = ⌊log₂ n⌋
每次迭代:2次比较 + 可能1次交换 = O(1)
总复杂度: O(log n)

最好情况:根节点比子节点小,不需要交换
复杂度: O(1)

平均情况:期望下沉高度约为log n / 2
复杂度: O(log n)
```

### 2.6 优化技巧

**优化1: 减少比较次数**

```python
def heapify_down_optimized(heap, i, n=None):
    """
    优化版heapify-down:先找到插入位置,再赋值
    """
    if n is None:
        n = len(heap)

    value = heap[i]  # 保存要下沉的值

    while 2 * i + 1 < n:
        left = 2 * i + 1
        right = 2 * i + 2

        # 找出左右子节点中较小的
        if right < n and heap[right] < heap[left]:
            child = right
        else:
            child = left

        if heap[child] < value:
            heap[i] = heap[child]  # 子节点上移
            i = child
        else:
            break

    heap[i] = value  # 最终位置赋值
```

---

## 3. Build Heap (建堆)

### 3.1 两种方法对比

**方法1: 逐个插入 - O(n log n)**

```python
def build_heap_insert(arr):
    """
    通过逐个插入建堆

    时间复杂度: O(n log n)
    """
    heap = []
    for x in arr:  # n次
        heappush(heap, x)  # O(log n)
    return heap
```

**方法2: 自底向上heapify - O(n)**

```python
def build_heap_heapify(arr):
    """
    通过自底向上heapify建堆

    时间复杂度: O(n)
    """
    n = len(arr)
    # 从最后一个非叶子节点开始
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, i, n)
    return arr
```

### 3.2 为什么heapify是O(n)?

**关键洞察:** 大部分节点在底层,heapify工作量小。

**工作量分析:**

```
完全二叉树的节点分布:
- 高度0(叶子): 约n/2个节点,heapify工作量0
- 高度1: 约n/4个节点,heapify工作量1
- 高度2: 约n/8个节点,heapify工作量2
- 高度h: 约n/2^(h+1)个节点,heapify工作量h

总工作量 W = Σ(h=0 to log n) [n/2^(h+1) * h]
           = n * Σ(h=0 to log n) [h/2^(h+1)]
           = n * S

其中 S = Σ(h=0 to ∞) [h/2^(h+1)]
```

**几何级数求和:**

```
设 S = 1/2 + 2/4 + 3/8 + 4/16 + ...
   2S = 1 + 2/2 + 3/4 + 4/8 + ...

2S - S = 1 + 1/2 + 1/4 + 1/8 + ...  (等比数列,首项1,公比1/2)
     S = 1 / (1 - 1/2) = 2

因此 W = n * 2 = O(n)
```

### 3.3 可视化过程

**示例:** 从数组[20, 10, 30, 5, 15, 25, 35]建堆

```
初始数组:
       20
      /  \
    10    30
   / \    / \
  5  15  25 35

Step 1: heapify(i=2, val=30)
30 > 25, 交换:
       20
      /  \
    10    25
   / \    / \
  5  15  30 35

Step 2: heapify(i=1, val=10)
10 > 5, 交换:
       20
      /  \
    5     25
   / \    / \
  10 15  30 35

Step 3: heapify(i=0, val=20)
20 > 5, 交换:
       5
      /  \
    20    25
   / \    / \
  10 15  30 35

继续heapify(i=1, val=20):
20 > 10, 交换:
       5
      /  \
    10    25
   / \    / \
  20 15  30 35

完成!
```

### 3.4 性能实测

```python
import heapq
import time
import random

def benchmark_build_heap(n):
    """性能对比"""
    arr1 = [random.randint(1, 1000) for _ in range(n)]
    arr2 = arr1.copy()

    # 方法1: 逐个插入
    start = time.time()
    heap1 = []
    for x in arr1:
        heapq.heappush(heap1, x)
    time_insert = time.time() - start

    # 方法2: heapify
    start = time.time()
    heapq.heapify(arr2)
    time_heapify = time.time() - start

    print(f"n={n:6d}: insert={time_insert:.4f}s, "
          f"heapify={time_heapify:.4f}s, "
          f"speedup={time_insert/time_heapify:.2f}x")

# 测试
for n in [1000, 10000, 100000, 1000000]:
    benchmark_build_heap(n)

# 输出示例:
# n=  1000: insert=0.0012s, heapify=0.0003s, speedup=4.00x
# n= 10000: insert=0.0156s, heapify=0.0031s, speedup=5.03x
# n=100000: insert=0.1891s, heapify=0.0342s, speedup=5.53x
# n=1000000: insert=2.1234s, heapify=0.3845s, speedup=5.52x
```

---

## 4. Heapify操作的应用

### 4.1 Insert操作

```python
def heap_insert(heap, value):
    """
    插入元素到heap

    步骤:
    1. 将元素添加到末尾
    2. heapify-up恢复heap性质

    时间复杂度: O(log n)
    """
    heap.append(value)
    heapify_up(heap, len(heap) - 1)
```

### 4.2 Extract-min操作

```python
def heap_extract_min(heap):
    """
    删除并返回最小元素

    步骤:
    1. 保存根节点(最小值)
    2. 末尾元素移到根
    3. heapify-down恢复heap性质

    时间复杂度: O(log n)
    """
    if not heap:
        raise IndexError("extract from empty heap")

    if len(heap) == 1:
        return heap.pop()

    min_val = heap[0]
    heap[0] = heap.pop()  # 末尾元素移到根
    heapify_down(heap, 0)

    return min_val
```

### 4.3 Decrease-key操作

```python
def heap_decrease_key(heap, i, new_value):
    """
    减小节点i的值

    步骤:
    1. 更新值
    2. heapify-up恢复heap性质

    时间复杂度: O(log n)
    应用: Dijkstra算法、Prim算法
    """
    if new_value > heap[i]:
        raise ValueError("new value is larger than current value")

    heap[i] = new_value
    heapify_up(heap, i)
```

### 4.4 Increase-key操作

```python
def heap_increase_key(heap, i, new_value):
    """
    增大节点i的值

    步骤:
    1. 更新值
    2. heapify-down恢复heap性质

    时间复杂度: O(log n)
    """
    if new_value < heap[i]:
        raise ValueError("new value is smaller than current value")

    heap[i] = new_value
    heapify_down(heap, i)
```

---

## 5. Python heapq实现分析

### 5.1 heappush实现

```python
# Python标准库heapq的heappush实现(简化版)
def heappush(heap, item):
    """Push item onto heap, maintaining the heap invariant."""
    heap.append(item)
    _siftup(heap, len(heap) - 1)

def _siftup(heap, pos):
    """上浮操作(heapify-up)"""
    endpos = len(heap)
    startpos = pos
    newitem = heap[pos]

    # 向上冒泡
    while pos > 0:
        parentpos = (pos - 1) >> 1  # 等价于(pos-1)//2
        parent = heap[parentpos]
        if newitem < parent:
            heap[pos] = parent
            pos = parentpos
        else:
            break

    heap[pos] = newitem
```

### 5.2 heappop实现

```python
# Python标准库heapq的heappop实现(简化版)
def heappop(heap):
    """Pop the smallest item off the heap, maintaining the heap invariant."""
    lastelt = heap.pop()  # 末尾元素
    if heap:
        returnitem = heap[0]
        heap[0] = lastelt
        _siftdown(heap, 0)
        return returnitem
    return lastelt

def _siftdown(heap, pos):
    """下沉操作(heapify-down)"""
    endpos = len(heap)
    startpos = pos
    newitem = heap[pos]

    # 向下沉降
    childpos = 2 * pos + 1  # 左子节点
    while childpos < endpos:
        # 找出较小的子节点
        rightpos = childpos + 1
        if rightpos < endpos and not heap[childpos] < heap[rightpos]:
            childpos = rightpos

        # 比较并下沉
        if newitem > heap[childpos]:
            heap[pos] = heap[childpos]
            pos = childpos
            childpos = 2 * pos + 1
        else:
            break

    heap[pos] = newitem
```

### 5.3 heapify实现

```python
# Python标准库heapq的heapify实现(简化版)
def heapify(x):
    """Transform list into a heap, in-place, in O(n) time."""
    n = len(x)
    # 从最后一个非叶子节点开始,向前heapify
    for i in reversed(range(n // 2)):
        _siftdown(x, i)
```

---

## 6. RAG应用场景

### 6.1 动态Top-K检索

```python
import heapq

class DynamicTopK:
    """
    动态维护Top-K文档

    应用: RAG系统中,文档相似度动态更新时维护Top-K
    """
    def __init__(self, k):
        self.k = k
        self.heap = []  # Min-heap

    def add_document(self, doc_id, score):
        """
        添加文档

        使用heapify-up维护heap性质
        """
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, (score, doc_id))
        elif score > self.heap[0][0]:
            heapq.heapreplace(self.heap, (score, doc_id))

    def update_score(self, doc_id, new_score):
        """
        更新文档分数

        需要重建heap(因为heapq不支持decrease-key)
        """
        # 移除旧分数
        self.heap = [(s, d) for s, d in self.heap if d != doc_id]
        heapq.heapify(self.heap)

        # 添加新分数
        self.add_document(doc_id, new_score)

    def get_top_k(self):
        """返回Top-K文档(按分数降序)"""
        return sorted(self.heap, reverse=True)
```

### 6.2 AI Agent任务调度

```python
import heapq
from enum import IntEnum
import time

class Priority(IntEnum):
    URGENT = 0
    HIGH = 1
    NORMAL = 2
    LOW = 3

class AgentScheduler:
    """
    AI Agent任务调度器

    使用heapify操作维护优先级队列
    """
    def __init__(self):
        self.task_queue = []
        self.task_counter = 0

    def submit_task(self, priority, task_id, action):
        """
        提交任务

        使用heapify-up插入任务
        """
        heapq.heappush(
            self.task_queue,
            (priority, self.task_counter, task_id, action)
        )
        self.task_counter += 1

    def execute_next(self):
        """
        执行下一个任务

        使用heapify-down删除最高优先级任务
        """
        if not self.task_queue:
            return None

        priority, _, task_id, action = heapq.heappop(self.task_queue)
        return action()

    def apply_aging(self):
        """
        应用aging机制

        使用heapify重建heap
        """
        current_time = time.time()
        aged_tasks = []

        while self.task_queue:
            priority, counter, task_id, action = heapq.heappop(self.task_queue)
            # 优先级提升
            new_priority = max(0, priority - 1)
            aged_tasks.append((new_priority, counter, task_id, action))

        # 重建heap
        self.task_queue = aged_tasks
        heapq.heapify(self.task_queue)
```

---

## 7. 常见陷阱

### 陷阱1: 忘记边界检查

```python
# ❌ 错误:没有检查右子节点是否存在
def heapify_down_wrong(heap, i):
    left = 2 * i + 1
    right = 2 * i + 2

    if heap[i] > heap[right]:  # 可能越界!
        heap[i], heap[right] = heap[right], heap[i]

# ✅ 正确:检查边界
def heapify_down_correct(heap, i):
    n = len(heap)
    left = 2 * i + 1
    right = 2 * i + 2

    if right < n and heap[i] > heap[right]:
        heap[i], heap[right] = heap[right], heap[i]
```

### 陷阱2: heapify方向错误

```python
# ❌ 错误:插入后用heapify-down
def insert_wrong(heap, value):
    heap.append(value)
    heapify_down(heap, len(heap) - 1)  # 错误!

# ✅ 正确:插入后用heapify-up
def insert_correct(heap, value):
    heap.append(value)
    heapify_up(heap, len(heap) - 1)
```

### 陷阱3: build heap的起始位置错误

```python
# ❌ 错误:从最后一个节点开始
def build_heap_wrong(arr):
    n = len(arr)
    for i in range(n - 1, -1, -1):  # 包括叶子节点
        heapify_down(arr, i)

# ✅ 正确:从最后一个非叶子节点开始
def build_heap_correct(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):  # 只处理非叶子节点
        heapify_down(arr, i)
```

---

## 8. 一句话总结

**Heapify操作包括heapify-up(插入后向上调整,O(log n))、heapify-down(删除后向下调整,O(log n))、build heap(自底向上heapify,O(n)),是heap所有操作的基础,核心是通过局部调整恢复全局heap性质。**
