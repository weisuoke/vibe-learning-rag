# 核心概念

掌握三个最核心的概念，覆盖 90% 的 RAG 混合检索场景。

---

## 核心概念1：BM25 关键词检索

**BM25（Best Matching 25）是基于词频统计的经典检索算法，通过计算查询词在文档中的出现频率来评估相关性。**

### BM25 的核心公式

```
BM25(D, Q) = Σ IDF(qi) × TF(qi, D) × (k1 + 1) / (TF(qi, D) + k1 × (1 - b + b × |D|/avgdl))

其中：
- TF(qi, D)：词 qi 在文档 D 中的出现次数
- IDF(qi)：词 qi 的逆文档频率（越稀有越重要）
- |D|：文档长度
- avgdl：平均文档长度
- k1, b：调节参数（通常 k1=1.2, b=0.75）
```

### 直觉理解

```
BM25 的核心思想：

1. 词频（TF）：一个词在文档中出现越多，文档越可能相关
   "Python" 出现 5 次 > 出现 1 次

2. 逆文档频率（IDF）：一个词越稀有，越有区分度
   "asyncio" 比 "the" 更有价值

3. 文档长度归一化：长文档不应该因为词多而占优势
   1000 字文档出现 5 次 ≈ 100 字文档出现 1 次
```

### Python 实现

```python
from rank_bm25 import BM25Okapi
import jieba

# 准备文档
documents = [
    "Python 异步编程使用 asyncio 库实现并发",
    "JavaScript 的 async/await 语法糖简化异步代码",
    "Python 多线程与多进程的区别和使用场景",
    "asyncio 是 Python 3.4 引入的异步 IO 框架"
]

# 中文分词
tokenized_docs = [list(jieba.cut(doc)) for doc in documents]

# 创建 BM25 索引
bm25 = BM25Okapi(tokenized_docs)

# 查询
query = "Python 异步编程"
tokenized_query = list(jieba.cut(query))

# 获取分数
scores = bm25.get_scores(tokenized_query)
print("BM25 分数:", scores)
# 输出: [2.89, 0.45, 0.67, 1.23]

# 获取 Top-K 结果
top_k = bm25.get_top_n(tokenized_query, documents, n=2)
print("Top-2 结果:", top_k)
```

### BM25 的优缺点

| 优点 | 缺点 |
|------|------|
| ✅ 精确匹配关键词 | ❌ 不理解同义词 |
| ✅ 无需训练，开箱即用 | ❌ 不理解语义 |
| ✅ 计算快，资源消耗低 | ❌ 对拼写错误敏感 |
| ✅ 对专有名词效果好 | ❌ 无法处理跨语言 |

### 在 RAG 开发中的应用

```python
# BM25 适合的场景
queries_good_for_bm25 = [
    "Python 3.12 新特性",      # 版本号精确匹配
    "TypeError: 'NoneType'",   # 错误信息精确匹配
    "pip install langchain",   # 命令精确匹配
    "API_KEY 配置方法"          # 专有名词匹配
]

# BM25 不擅长的场景
queries_bad_for_bm25 = [
    "如何让代码跑得更快",       # 需要理解"快"="性能"
    "怎么处理程序崩溃",         # 需要理解"崩溃"="异常"
    "提升代码质量的方法"        # 需要理解"质量"的含义
]
```

---

## 核心概念2：向量语义检索

**向量检索通过将文本转换为高维向量，利用向量相似度找到语义相关的文档。**

### 向量检索的核心流程

```
┌─────────────────────────────────────────────────────────────┐
│                    向量检索流程                               │
│                                                             │
│  Query: "如何提升代码性能"                                    │
│         ↓                                                   │
│  Embedding Model                                            │
│         ↓                                                   │
│  Query Vector: [0.12, -0.34, 0.56, ...]                     │
│         ↓                                                   │
│  计算与所有文档向量的余弦相似度                                │
│         ↓                                                   │
│  返回相似度最高的 K 个文档                                    │
│                                                             │
│  结果：                                                      │
│  - "Python 性能优化指南" (相似度: 0.89)                       │
│  - "代码执行速度提升技巧" (相似度: 0.85)  ← 没有"性能"也能匹配  │
│  - "程序运行效率改进" (相似度: 0.82)                          │
└─────────────────────────────────────────────────────────────┘
```

### Python 实现

```python
from openai import OpenAI
import numpy as np

client = OpenAI()

def get_embedding(text: str) -> list[float]:
    """获取文本的 Embedding 向量"""
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    return response.data[0].embedding

def cosine_similarity(a: list, b: list) -> float:
    """计算余弦相似度"""
    a, b = np.array(a), np.array(b)
    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

# 准备文档
documents = [
    "Python 性能优化指南",
    "代码执行速度提升技巧",
    "JavaScript 入门教程",
    "数据库查询优化方法"
]

# 生成文档向量
doc_embeddings = [get_embedding(doc) for doc in documents]

# 查询
query = "如何让程序跑得更快"
query_embedding = get_embedding(query)

# 计算相似度
similarities = [
    cosine_similarity(query_embedding, doc_emb)
    for doc_emb in doc_embeddings
]

# 排序返回
results = sorted(
    zip(documents, similarities),
    key=lambda x: x[1],
    reverse=True
)

for doc, score in results[:3]:
    print(f"{score:.3f}: {doc}")
# 输出:
# 0.892: Python 性能优化指南
# 0.856: 代码执行速度提升技巧
# 0.734: 数据库查询优化方法
```

### 向量检索的优缺点

| 优点 | 缺点 |
|------|------|
| ✅ 理解语义相似 | ❌ 精确术语匹配可能不准 |
| ✅ 处理同义词、近义词 | ❌ 需要 Embedding 模型 |
| ✅ 跨语言检索能力 | ❌ 有计算成本 |
| ✅ 对拼写错误容忍 | ❌ 对专有名词效果差 |

### 在 RAG 开发中的应用

```python
# 向量检索适合的场景
queries_good_for_vector = [
    "如何让代码跑得更快",       # 语义理解"快"="性能"
    "程序老是出问题怎么办",     # 理解"出问题"="异常/错误"
    "怎么写出好代码"            # 理解"好"="质量/规范"
]

# 向量检索不擅长的场景
queries_bad_for_vector = [
    "Python 3.12.1",           # 版本号可能匹配到其他版本
    "error code: E001",        # 错误码需要精确匹配
    "pip install xxx==1.2.3"   # 命令需要精确匹配
]
```

---

## 核心概念3：分数融合策略

**分数融合是将多个检索器的结果合并成一个统一排序列表的方法。**

### 为什么需要分数融合？

```
问题：BM25 和向量检索的分数不在同一尺度

BM25 分数：[0, +∞)，通常在 0-30 之间
向量相似度：[-1, 1]，通常在 0.5-1 之间

直接相加没有意义！
```

### 三种主流融合策略

#### 1. 倒数排名融合（RRF - Reciprocal Rank Fusion）

```python
def reciprocal_rank_fusion(
    results_list: list[list[str]],
    k: int = 60
) -> list[tuple[str, float]]:
    """
    RRF 融合算法

    公式：RRF_score(d) = Σ 1 / (k + rank(d))

    参数：
    - results_list: 多个检索器的结果列表
    - k: 平滑参数，默认 60
    """
    scores = {}

    for results in results_list:
        for rank, doc_id in enumerate(results, 1):
            if doc_id not in scores:
                scores[doc_id] = 0
            scores[doc_id] += 1 / (k + rank)

    # 按分数排序
    return sorted(scores.items(), key=lambda x: x[1], reverse=True)

# 示例
bm25_results = ["doc1", "doc3", "doc2", "doc4"]
vector_results = ["doc2", "doc1", "doc4", "doc3"]

fused = reciprocal_rank_fusion([bm25_results, vector_results])
print(fused)
# [('doc1', 0.032), ('doc2', 0.032), ('doc3', 0.031), ('doc4', 0.031)]
```

**RRF 的优点：**
- ✅ 不需要归一化分数
- ✅ 对异常值不敏感
- ✅ 简单有效，广泛使用

#### 2. 分数归一化后加权

```python
def normalize_scores(scores: list[float]) -> list[float]:
    """Min-Max 归一化到 [0, 1]"""
    min_s, max_s = min(scores), max(scores)
    if max_s == min_s:
        return [0.5] * len(scores)
    return [(s - min_s) / (max_s - min_s) for s in scores]

def weighted_fusion(
    bm25_results: list[tuple[str, float]],
    vector_results: list[tuple[str, float]],
    bm25_weight: float = 0.3,
    vector_weight: float = 0.7
) -> list[tuple[str, float]]:
    """
    加权融合

    步骤：
    1. 分别归一化两个检索器的分数
    2. 按权重加权求和
    """
    # 归一化
    bm25_docs = [r[0] for r in bm25_results]
    bm25_scores = normalize_scores([r[1] for r in bm25_results])

    vector_docs = [r[0] for r in vector_results]
    vector_scores = normalize_scores([r[1] for r in vector_results])

    # 合并分数
    scores = {}
    for doc, score in zip(bm25_docs, bm25_scores):
        scores[doc] = scores.get(doc, 0) + score * bm25_weight

    for doc, score in zip(vector_docs, vector_scores):
        scores[doc] = scores.get(doc, 0) + score * vector_weight

    return sorted(scores.items(), key=lambda x: x[1], reverse=True)

# 示例
bm25 = [("doc1", 15.2), ("doc3", 12.1), ("doc2", 8.5)]
vector = [("doc2", 0.92), ("doc1", 0.85), ("doc4", 0.78)]

fused = weighted_fusion(bm25, vector, bm25_weight=0.4, vector_weight=0.6)
print(fused)
```

**加权融合的优点：**
- ✅ 可以调整两种检索的重要性
- ✅ 适合已知哪种检索更适合业务场景

#### 3. Convex Combination（凸组合）

```python
def convex_combination(
    bm25_results: dict[str, float],
    vector_results: dict[str, float],
    alpha: float = 0.5
) -> list[tuple[str, float]]:
    """
    凸组合融合

    公式：score = α × bm25_score + (1-α) × vector_score

    要求：两个分数都已归一化到 [0, 1]
    """
    all_docs = set(bm25_results.keys()) | set(vector_results.keys())

    scores = {}
    for doc in all_docs:
        bm25_score = bm25_results.get(doc, 0)
        vector_score = vector_results.get(doc, 0)
        scores[doc] = alpha * bm25_score + (1 - alpha) * vector_score

    return sorted(scores.items(), key=lambda x: x[1], reverse=True)
```

### 融合策略对比

| 策略 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| RRF | 简单、无需归一化 | 忽略分数差异 | 通用场景，首选 |
| 加权融合 | 可调权重 | 需要归一化 | 已知检索偏好 |
| 凸组合 | 数学性质好 | 需要归一化 | 学术研究 |

### 在 RAG 开发中的选择

```python
# 推荐：使用 RRF，简单有效
def hybrid_search_with_rrf(query, bm25_index, vector_store, k=10):
    # BM25 检索
    bm25_results = bm25_index.search(query, top_k=k*2)

    # 向量检索
    vector_results = vector_store.search(query, top_k=k*2)

    # RRF 融合
    fused = reciprocal_rank_fusion([
        [r['id'] for r in bm25_results],
        [r['id'] for r in vector_results]
    ])

    return fused[:k]
```

---

## 三个概念的关系

```
┌─────────────────────────────────────────────────────────────┐
│                    混合检索流程                               │
│                                                             │
│  用户查询: "Python 异步编程怎么优化性能"                       │
│         │                                                   │
│         ├──────────────────┬──────────────────┐             │
│         ↓                  ↓                  │             │
│  ┌─────────────┐    ┌─────────────┐          │             │
│  │   BM25      │    │  向量检索    │          │             │
│  │             │    │             │          │             │
│  │ 匹配:       │    │ 匹配:       │          │             │
│  │ "Python"   │    │ 语义相似    │          │             │
│  │ "异步"     │    │ "性能优化"  │          │             │
│  │ "性能"     │    │             │          │             │
│  └──────┬──────┘    └──────┬──────┘          │             │
│         │                  │                  │             │
│         └────────┬─────────┘                  │             │
│                  ↓                            │             │
│         ┌─────────────┐                       │             │
│         │  分数融合    │ ←─────────────────────┘             │
│         │   (RRF)     │                                     │
│         └──────┬──────┘                                     │
│                ↓                                            │
│         最终排序结果                                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

**下一步：** [04_最小可用](./04_最小可用.md) - 掌握 20% 核心知识解决 80% 问题
