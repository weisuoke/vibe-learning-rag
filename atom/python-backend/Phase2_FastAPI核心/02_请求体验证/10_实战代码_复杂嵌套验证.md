# 实战代码：复杂嵌套验证

> 完整可运行的复杂嵌套数据结构验证示例

---

## 场景概述

本文提供2个复杂嵌套验证场景：AI Agent 配置验证和 RAG 系统配置验证。展示如何验证深层嵌套的数据结构。

---

## 场景1：AI Agent 配置验证

### 需求

- 验证 Agent 基础配置（模型、温度、最大token）
- 验证工具列表（每个工具有名称、描述、参数定义）
- 验证记忆配置（类型、最大消息数、持久化选项）
- 验证提示词模板（系统提示、用户提示、变量）

### 完整代码

```python
"""
场景1：AI Agent 配置验证
演示深层嵌套模型和复杂验证逻辑
"""

from fastapi import FastAPI
from pydantic import BaseModel, Field, validator, root_validator
from typing import List, Dict, Any, Optional, Literal
from enum import Enum

app = FastAPI(title="AI Agent 配置 API")

# ===== 枚举类型 =====

class ModelType(str, Enum):
    """LLM 模型类型"""
    GPT4 = "gpt-4"
    GPT35 = "gpt-3.5-turbo"
    CLAUDE3 = "claude-3-opus"

class MemoryType(str, Enum):
    """记忆类型"""
    BUFFER = "buffer"
    SUMMARY = "summary"
    VECTOR = "vector"

class ParameterType(str, Enum):
    """参数类型"""
    STRING = "string"
    INTEGER = "integer"
    FLOAT = "float"
    BOOLEAN = "boolean"

# ===== 嵌套模型 =====

class ParameterSchema(BaseModel):
    """工具参数定义"""
    name: str = Field(..., min_length=1, max_length=50)
    type: ParameterType
    description: str = Field(..., min_length=1, max_length=200)
    required: bool = Field(default=True)
    default: Optional[Any] = None

    @validator('name')
    def name_snake_case(cls, v):
        """参数名必须是 snake_case"""
        import re
        if not re.match(r'^[a-z][a-z0-9_]*$', v):
            raise ValueError('参数名必须是 snake_case 格式')
        return v

class Tool(BaseModel):
    """工具定义"""
    name: str = Field(..., min_length=1, max_length=50)
    description: str = Field(..., min_length=10, max_length=500)
    parameters: List[ParameterSchema] = Field(default_factory=list)
    enabled: bool = Field(default=True)

    @validator('name')
    def name_alphanumeric_underscore(cls, v):
        """工具名只能包含字母、数字、下划线"""
        import re
        if not re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', v):
            raise ValueError('工具名必须以字母开头，只能包含字母、数字、下划线')
        return v

    @validator('parameters')
    def check_required_params(cls, v):
        """检查必需参数"""
        required_params = [p for p in v if p.required]
        if not required_params and v:
            # 如果有参数但都不是必需的，给出警告（这里简化为验证通过）
            pass
        return v

class MemoryConfig(BaseModel):
    """记忆配置"""
    type: MemoryType
    max_messages: int = Field(default=10, ge=1, le=100)
    persist: bool = Field(default=False)
    persist_path: Optional[str] = Field(default=None, max_length=200)

    @root_validator
    def check_persist_path(cls, values):
        """如果启用持久化，必须提供路径"""
        persist = values.get('persist')
        persist_path = values.get('persist_path')

        if persist and not persist_path:
            raise ValueError('启用持久化时必须提供 persist_path')
        if not persist and persist_path:
            # 如果未启用持久化，忽略路径
            values['persist_path'] = None

        return values

class PromptTemplate(BaseModel):
    """提示词模板"""
    system: str = Field(..., min_length=10, max_length=2000)
    user: Optional[str] = Field(default=None, max_length=1000)
    variables: List[str] = Field(default_factory=list)

    @validator('system', 'user')
    def not_only_whitespace(cls, v):
        """提示词不能只包含空格"""
        if v and not v.strip():
            raise ValueError('提示词不能只包含空格')
        return v.strip() if v else v

    @root_validator
    def check_variables_in_template(cls, values):
        """检查变量是否在模板中使用"""
        system = values.get('system', '')
        user = values.get('user', '')
        variables = values.get('variables', [])

        for var in variables:
            placeholder = f'{{{var}}}'
            if placeholder not in system and placeholder not in user:
                raise ValueError(f'变量 {var} 未在模板中使用')

        return values

class AgentConfig(BaseModel):
    """Agent 完整配置"""
    name: str = Field(..., min_length=3, max_length=50)
    description: str = Field(..., min_length=10, max_length=500)

    # LLM 配置
    model: ModelType = Field(default=ModelType.GPT4)
    temperature: float = Field(default=0.7, ge=0.0, le=2.0)
    max_tokens: int = Field(default=1000, ge=1, le=4000)

    # 工具配置
    tools: List[Tool] = Field(default_factory=list, max_items=20)

    # 记忆配置
    memory: MemoryConfig

    # 提示词配置
    prompt: PromptTemplate

    # 其他配置
    stream: bool = Field(default=False)
    max_iterations: int = Field(default=5, ge=1, le=20)

    @validator('name')
    def name_valid(cls, v):
        """Agent 名称验证"""
        import re
        if not re.match(r'^[a-zA-Z][a-zA-Z0-9_-]*$', v):
            raise ValueError('名称必须以字母开头，只能包含字母、数字、下划线、连字符')
        return v

    @root_validator
    def check_tool_names_unique(cls, values):
        """检查工具名称唯一性"""
        tools = values.get('tools', [])
        tool_names = [t.name for t in tools]

        if len(tool_names) != len(set(tool_names)):
            raise ValueError('工具名称必须唯一')

        return values

# ===== API 端点 =====

configs_db = {}

@app.post("/agent/config", status_code=201)
async def create_agent_config(config: AgentConfig):
    """
    创建 Agent 配置

    验证规则：
    - 名称：3-50个字符，字母开头
    - 模型：gpt-4、gpt-3.5-turbo、claude-3-opus
    - 温度：0-2之间
    - 工具：最多20个，名称唯一
    - 记忆：启用持久化时必须提供路径
    - 提示词：变量必须在模板中使用
    """
    configs_db[config.name] = config.dict()
    return {"message": "配置创建成功", "name": config.name}

@app.get("/agent/config/{name}")
async def get_agent_config(name: str):
    """获取 Agent 配置"""
    if name not in configs_db:
        return {"error": "配置不存在"}, 404
    return configs_db[name]

# ===== 测试代码 =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("场景1：AI Agent 配置验证")
    print("=" * 50)
    print("\n测试配置示例：")

    # 创建测试配置
    test_config = {
        "name": "my-agent",
        "description": "A helpful AI assistant",
        "model": "gpt-4",
        "temperature": 0.7,
        "max_tokens": 1000,
        "tools": [
            {
                "name": "search",
                "description": "Search the web for information",
                "parameters": [
                    {
                        "name": "query",
                        "type": "string",
                        "description": "Search query",
                        "required": True
                    }
                ]
            }
        ],
        "memory": {
            "type": "buffer",
            "max_messages": 10,
            "persist": True,
            "persist_path": "/data/memory.json"
        },
        "prompt": {
            "system": "You are a helpful assistant. User name: {user_name}",
            "variables": ["user_name"]
        }
    }

    print("\n启动服务器...")
    print("访问 http://localhost:8000/docs 查看 API 文档")
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 场景2：RAG 系统配置验证

### 需求

- 验证文档加载配置（支持的文件类型、最大文件大小）
- 验证分块配置（分块大小、重叠大小、分块策略）
- 验证 Embedding 配置（模型、维度、批处理大小）
- 验证向量存储配置（类型、连接信息、索引配置）
- 验证检索配置（检索策略、重排序、混合检索权重）

### 完整代码

```python
"""
场景2：RAG 系统配置验证
演示复杂配置验证和条件验证
"""

from fastapi import FastAPI
from pydantic import BaseModel, Field, validator, root_validator
from typing import List, Dict, Optional, Literal
from enum import Enum

app = FastAPI(title="RAG 系统配置 API")

# ===== 枚举类型 =====

class ChunkStrategy(str, Enum):
    """分块策略"""
    FIXED = "fixed"
    SEMANTIC = "semantic"
    RECURSIVE = "recursive"

class VectorStoreType(str, Enum):
    """向量存储类型"""
    CHROMA = "chroma"
    FAISS = "faiss"
    MILVUS = "milvus"

class RetrievalStrategy(str, Enum):
    """检索策略"""
    VECTOR = "vector"
    BM25 = "bm25"
    HYBRID = "hybrid"

# ===== 嵌套模型 =====

class DocumentLoaderConfig(BaseModel):
    """文档加载配置"""
    supported_types: List[str] = Field(
        default=["pdf", "txt", "md"],
        min_items=1,
        max_items=10
    )
    max_file_size_mb: int = Field(default=10, ge=1, le=100)
    encoding: str = Field(default="utf-8")

    @validator('supported_types')
    def types_lowercase(cls, v):
        """文件类型转换为小写"""
        return [t.lower().strip() for t in v]

class ChunkConfig(BaseModel):
    """分块配置"""
    strategy: ChunkStrategy = Field(default=ChunkStrategy.FIXED)
    chunk_size: int = Field(default=500, ge=100, le=2000)
    chunk_overlap: int = Field(default=50, ge=0, le=500)
    separators: List[str] = Field(default=["\n\n", "\n", " "])

    @root_validator
    def check_overlap(cls, values):
        """检查重叠大小不能超过分块大小"""
        chunk_size = values.get('chunk_size', 0)
        chunk_overlap = values.get('chunk_overlap', 0)

        if chunk_overlap >= chunk_size:
            raise ValueError('chunk_overlap 必须小于 chunk_size')

        # 建议重叠大小不超过分块大小的50%
        if chunk_overlap > chunk_size * 0.5:
            # 这里只是警告，不抛出异常
            pass

        return values

class EmbeddingConfig(BaseModel):
    """Embedding 配置"""
    model: str = Field(default="text-embedding-3-small")
    dimension: int = Field(default=1536, ge=128, le=4096)
    batch_size: int = Field(default=32, ge=1, le=256)
    normalize: bool = Field(default=True)

    @validator('model')
    def model_valid(cls, v):
        """验证模型名称"""
        valid_models = [
            "text-embedding-3-small",
            "text-embedding-3-large",
            "text-embedding-ada-002"
        ]
        if v not in valid_models:
            raise ValueError(f'模型必须是以下之一: {valid_models}')
        return v

class VectorStoreConfig(BaseModel):
    """向量存储配置"""
    type: VectorStoreType
    connection_string: Optional[str] = None
    collection_name: str = Field(default="documents", min_length=1)
    index_type: str = Field(default="HNSW")
    metric_type: str = Field(default="cosine")

    @root_validator
    def check_connection(cls, values):
        """检查连接配置"""
        store_type = values.get('type')
        connection_string = values.get('connection_string')

        # Milvus 需要连接字符串
        if store_type == VectorStoreType.MILVUS and not connection_string:
            raise ValueError('Milvus 需要提供 connection_string')

        # Chroma 和 FAISS 不需要连接字符串
        if store_type in [VectorStoreType.CHROMA, VectorStoreType.FAISS]:
            if connection_string:
                values['connection_string'] = None

        return values

class RetrievalConfig(BaseModel):
    """检索配置"""
    strategy: RetrievalStrategy = Field(default=RetrievalStrategy.VECTOR)
    top_k: int = Field(default=5, ge=1, le=20)
    threshold: float = Field(default=0.7, ge=0.0, le=1.0)

    # 混合检索权重
    bm25_weight: Optional[float] = Field(default=None, ge=0.0, le=1.0)
    vector_weight: Optional[float] = Field(default=None, ge=0.0, le=1.0)

    # 重排序配置
    rerank: bool = Field(default=False)
    rerank_model: Optional[str] = None
    rerank_top_n: Optional[int] = Field(default=None, ge=1, le=10)

    @root_validator
    def check_hybrid_weights(cls, values):
        """检查混合检索权重"""
        strategy = values.get('strategy')
        bm25_weight = values.get('bm25_weight')
        vector_weight = values.get('vector_weight')

        if strategy == RetrievalStrategy.HYBRID:
            # 混合检索必须提供权重
            if bm25_weight is None or vector_weight is None:
                raise ValueError('混合检索必须提供 bm25_weight 和 vector_weight')

            # 权重之和必须为 1.0
            if abs(bm25_weight + vector_weight - 1.0) > 0.001:
                raise ValueError('bm25_weight + vector_weight 必须等于 1.0')
        else:
            # 非混合检索不需要权重
            values['bm25_weight'] = None
            values['vector_weight'] = None

        return values

    @root_validator
    def check_rerank_config(cls, values):
        """检查重排序配置"""
        rerank = values.get('rerank')
        rerank_model = values.get('rerank_model')
        rerank_top_n = values.get('rerank_top_n')

        if rerank:
            # 启用重排序必须提供模型
            if not rerank_model:
                raise ValueError('启用重排序必须提供 rerank_model')

            # 设置默认 rerank_top_n
            if rerank_top_n is None:
                values['rerank_top_n'] = min(values.get('top_k', 5), 10)
        else:
            # 未启用重排序，清空配置
            values['rerank_model'] = None
            values['rerank_top_n'] = None

        return values

class RAGConfig(BaseModel):
    """RAG 系统完整配置"""
    name: str = Field(..., min_length=3, max_length=50)
    description: str = Field(..., min_length=10, max_length=500)

    # 各模块配置
    document_loader: DocumentLoaderConfig
    chunking: ChunkConfig
    embedding: EmbeddingConfig
    vector_store: VectorStoreConfig
    retrieval: RetrievalConfig

    # 生成配置
    llm_model: str = Field(default="gpt-4")
    llm_temperature: float = Field(default=0.7, ge=0.0, le=2.0)
    llm_max_tokens: int = Field(default=1000, ge=1, le=4000)

    @root_validator
    def check_embedding_dimension_match(cls, values):
        """检查 Embedding 维度与向量存储配置匹配"""
        embedding_dim = values.get('embedding', {}).dimension if isinstance(values.get('embedding'), EmbeddingConfig) else None
        vector_store = values.get('vector_store')

        # 这里可以添加更多维度匹配检查
        # 简化示例，实际应用中可能需要更复杂的验证

        return values

# ===== API 端点 =====

rag_configs_db = {}

@app.post("/rag/config", status_code=201)
async def create_rag_config(config: RAGConfig):
    """
    创建 RAG 配置

    验证规则：
    - 分块：重叠大小 < 分块大小
    - Embedding：支持的模型和维度
    - 向量存储：Milvus 需要连接字符串
    - 检索：混合检索权重之和为 1.0
    - 重排序：启用时必须提供模型
    """
    rag_configs_db[config.name] = config.dict()
    return {"message": "RAG 配置创建成功", "name": config.name}

@app.get("/rag/config/{name}")
async def get_rag_config(name: str):
    """获取 RAG 配置"""
    if name not in rag_configs_db:
        return {"error": "配置不存在"}, 404
    return rag_configs_db[name]

# ===== 测试代码 =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("场景2：RAG 系统配置验证")
    print("=" * 50)
    print("\n测试配置示例：")

    test_config = {
        "name": "my-rag-system",
        "description": "A RAG system for document Q&A",
        "document_loader": {
            "supported_types": ["pdf", "txt", "md"],
            "max_file_size_mb": 10
        },
        "chunking": {
            "strategy": "fixed",
            "chunk_size": 500,
            "chunk_overlap": 50
        },
        "embedding": {
            "model": "text-embedding-3-small",
            "dimension": 1536,
            "batch_size": 32
        },
        "vector_store": {
            "type": "chroma",
            "collection_name": "documents"
        },
        "retrieval": {
            "strategy": "hybrid",
            "top_k": 5,
            "threshold": 0.7,
            "bm25_weight": 0.3,
            "vector_weight": 0.7,
            "rerank": True,
            "rerank_model": "cross-encoder/ms-marco-MiniLM-L-6-v2"
        }
    }

    print("\n启动服务器...")
    print("访问 http://localhost:8000/docs 查看 API 文档")
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 核心要点

1. **深层嵌套** - 使用多层 Pydantic 模型构建复杂配置
2. **条件验证** - 使用 @root_validator 实现条件验证逻辑
3. **枚举类型** - 使用 Enum 限制可选值
4. **跨模块验证** - 验证不同模块配置之间的一致性
5. **默认值处理** - 根据条件自动设置或清空字段

---

**版本：** v1.0
**最后更新：** 2026-02-11
