# 第一性原理

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

不是问"别人用什么检索方法"，而是问"为什么需要混合检索"。

---

## 混合检索的第一性原理

### 1. 最基础的定义

**混合检索 = 多种检索方法的结果融合**

仅此而已！没有更基础的了。

把这个定义拆开：
- **多种检索方法**：至少两种不同原理的检索（如 BM25 + 向量）
- **结果融合**：把多个检索结果合并成一个排序列表

```python
# 最简单的"混合检索"
def hybrid_search(query, documents, k=5):
    # 方法1：关键词检索
    bm25_results = bm25_search(query, documents)

    # 方法2：语义检索
    vector_results = vector_search(query, documents)

    # 融合结果
    return merge_results(bm25_results, vector_results, k)
```

### 2. 为什么需要混合检索？

**核心问题：如何找到所有相关的文档，不遗漏？**

让我们从两种检索方法的本质差异推导：

#### 关键词检索（BM25）的本质

```
BM25 的核心假设：
"如果查询词在文档中出现，且出现频率高，则文档相关"

工作原理：
Query: "Python 异步编程"
       ↓
统计每个文档中 "Python"、"异步"、"编程" 的出现次数
       ↓
计算 TF-IDF 分数
       ↓
返回分数最高的文档
```

**BM25 的优势：**
- ✅ 精确匹配专有名词、代码、版本号
- ✅ 不需要训练，开箱即用
- ✅ 计算快，资源消耗低

**BM25 的盲区：**
- ❌ 不理解同义词（"快速" vs "高效"）
- ❌ 不理解语义（"如何提升性能" vs "优化代码速度"）
- ❌ 对拼写错误敏感

#### 语义检索（向量）的本质

```
向量检索的核心假设：
"语义相似的文本，在向量空间中距离相近"

工作原理：
Query: "Python 异步编程"
       ↓
转换为向量 [0.1, 0.3, -0.2, ...]
       ↓
计算与所有文档向量的余弦相似度
       ↓
返回最相似的文档
```

**向量检索的优势：**
- ✅ 理解语义相似（"快速" ≈ "高效"）
- ✅ 跨语言检索能力
- ✅ 对拼写错误容忍

**向量检索的盲区：**
- ❌ 可能漏掉精确术语（"Python 3.12" 可能匹配到 "Python 3.11"）
- ❌ 对专有名词、代码片段效果差
- ❌ 需要 Embedding 模型，有计算成本

#### 两种方法的互补性

```
┌─────────────────────────────────────────────────────────────┐
│                    检索能力覆盖图                             │
│                                                             │
│  ┌─────────────────┐     ┌─────────────────┐               │
│  │                 │     │                 │               │
│  │    BM25 擅长    │     │   向量检索擅长   │               │
│  │                 │     │                 │               │
│  │  • 精确术语     │     │  • 语义相似     │               │
│  │  • 代码片段     │     │  • 同义词理解   │               │
│  │  • 版本号       │     │  • 意图理解     │               │
│  │  • 专有名词     │     │  • 模糊查询     │               │
│  │                 │     │                 │               │
│  └────────┬────────┘     └────────┬────────┘               │
│           │                       │                         │
│           └───────────┬───────────┘                         │
│                       │                                     │
│                       ▼                                     │
│              ┌─────────────────┐                           │
│              │   混合检索覆盖   │                           │
│              │   两者的并集     │                           │
│              └─────────────────┘                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3. 混合检索的三层价值

#### 价值1：提升召回率（Recall）

**问题**：单一方法总有盲区，会漏掉相关文档

**解决**：两种方法互补，覆盖更多场景

```
召回率对比实验（假设数据）：

查询："如何优化 Python 代码性能"

BM25 召回的文档：
- ✅ "Python 性能优化指南"（精确匹配"Python"、"性能"）
- ❌ 漏掉 "提升代码执行速度的技巧"（没有"性能"这个词）

向量检索召回的文档：
- ✅ "提升代码执行速度的技巧"（语义相似）
- ❌ 漏掉 "Python 3.12 性能改进"（版本号匹配不精确）

混合检索召回的文档：
- ✅ "Python 性能优化指南"
- ✅ "提升代码执行速度的技巧"
- ✅ "Python 3.12 性能改进"

召回率：BM25 (60%) + 向量 (70%) → 混合 (90%+)
```

#### 价值2：提升鲁棒性（Robustness）

**问题**：用户查询方式多样，单一方法难以应对

**解决**：混合检索对不同查询类型都有较好表现

| 查询类型 | BM25 | 向量 | 混合 |
|----------|------|------|------|
| 精确术语查询 | ⭐⭐⭐ | ⭐ | ⭐⭐⭐ |
| 自然语言问题 | ⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| 代码片段搜索 | ⭐⭐⭐ | ⭐ | ⭐⭐⭐ |
| 模糊意图查询 | ⭐ | ⭐⭐⭐ | ⭐⭐⭐ |

#### 价值3：降低对单一模型的依赖

**问题**：Embedding 模型可能在某些领域表现不佳

**解决**：BM25 作为兜底，保证基本检索能力

```python
# 即使 Embedding 模型对某领域效果差，BM25 仍能工作
def robust_search(query, documents):
    bm25_results = bm25_search(query, documents)  # 始终可靠
    vector_results = vector_search(query, documents)  # 可能不稳定

    # 融合时可以调整权重
    return merge_results(
        bm25_results,
        vector_results,
        bm25_weight=0.4,  # 保证基本召回
        vector_weight=0.6  # 利用语义能力
    )
```

### 4. 从第一性原理推导混合检索设计

**推理链：**

```
1. RAG 需要检索相关文档
   ↓
2. "相关"有两种含义：词汇匹配 + 语义相似
   ↓
3. BM25 擅长词汇匹配，向量擅长语义相似
   ↓
4. 用户查询方式多样，无法预测
   ↓
5. 单一方法必然有盲区
   ↓
6. 结论：需要混合检索，取长补短
   ↓
7. 进一步：需要合理的分数融合策略
```

### 5. 一句话总结第一性原理

**混合检索的本质是承认"没有完美的单一检索方法"，通过组合不同原理的检索器，实现能力互补，最大化召回相关文档。**

---

## 第一性原理的实践指导

| 原理 | 实践指导 |
|------|----------|
| 两种方法互补 | 同时部署 BM25 和向量检索 |
| 召回率优先 | 初检阶段多召回，后续用 ReRank 精排 |
| 查询类型多样 | 不要假设用户会怎么问，混合检索更稳健 |
| 融合策略重要 | 根据业务场景调整 BM25/向量的权重 |

---

## 什么时候不需要混合检索？

| 场景 | 是否需要 | 原因 |
|------|----------|------|
| 纯代码搜索 | ❌ 可选 | BM25 足够，代码是精确匹配场景 |
| 纯问答场景 | ❌ 可选 | 向量检索足够，用户用自然语言提问 |
| 通用知识库 | ✅ 需要 | 查询类型多样，需要两种能力 |
| 企业文档搜索 | ✅ 需要 | 既有术语又有自然语言描述 |

---

**核心洞察**：混合检索不是"高级功能"，而是对"检索本质"的深刻理解——没有银弹，组合才是王道。

---

**下一步：** [03_核心概念](./03_核心概念.md) - 掌握 BM25、向量检索、分数融合三大核心概念
