# 最小可用知识

> 掌握以下内容，就能理解 Agent Core 的核心运行机制

---

## 4.1 Agent 执行循环的本质

**Agent Core 的核心就是一个异步生成器循环：**

```typescript
async function* agentLoop(userMessage: string) {
  let context = [{ role: 'user', content: userMessage }];

  while (true) {
    // 1. 调用 LLM
    const response = await llm.chat(context);
    yield { type: 'assistant', content: response };

    // 2. 检测工具调用
    const toolCalls = detectToolCalls(response);
    if (toolCalls.length === 0) break; // 没有工具调用，任务完成

    // 3. 执行工具
    for (const call of toolCalls) {
      const result = await executeTool(call);
      yield { type: 'tool', result };
      context.push({ role: 'tool', content: result });
    }
  }
}
```

**核心理念：** "Loop just loops until done" - 循环会一直运行，直到 LLM 不再请求工具调用[^1]

**为什么不需要 max-steps？** Pi 证明了前沿模型（Claude Opus 4、GPT-4）能够可靠地自我终止，无需人为限制[^2]

---

## 4.2 仅需 4 个工具

**Pi 的极简哲学：只提供 4 个内置工具**

```typescript
const builtInTools = {
  read: { description: 'Read file contents', schema: ReadSchema },
  write: { description: 'Write file contents', schema: WriteSchema },
  edit: { description: 'Edit file with search/replace', schema: EditSchema },
  bash: { description: 'Execute bash command', schema: BashSchema }
};
```

**为什么只需要 4 个工具？**
- 前沿模型理解"编码代理"的上下文
- 模型知道如何组合基础工具完成复杂任务
- 更多工具 ≠ 更强能力，反而增加选择复杂度[^3]

**实际应用：**
- `read` + `write` → 创建新文件
- `read` + `edit` → 修改现有代码
- `bash` → 运行测试、安装依赖、git 操作
- 组合使用 → 完成任何编码任务

---

## 4.3 工具注册与验证

**使用 TypeBox 定义工具 schema（不是 Zod）：**

```typescript
import { Type } from '@sinclair/typebox';
import Ajv from 'ajv';

// 定义工具 schema
const ReadToolSchema = Type.Object({
  path: Type.String({ description: 'File path to read' }),
  lines: Type.Optional(Type.Object({
    start: Type.Number(),
    end: Type.Number()
  }))
});

// 注册工具
const toolRegistry = new Map();
toolRegistry.set('read', {
  schema: ReadToolSchema,
  execute: async (params) => {
    const content = await fs.readFile(params.path, 'utf-8');
    return { output: content, details: { path: params.path } };
  }
});

// 验证工具调用
const ajv = new Ajv();
const validate = ajv.compile(ReadToolSchema);
if (!validate(toolCall.params)) {
  // 验证失败 → 返回错误给模型，让模型自我纠正
  return { error: validate.errors };
}
```

**关键点：**
- **TypeBox**：运行时类型验证（比 Zod 更轻量）
- **AJV**：JSON Schema 验证器
- **自我纠正**：验证失败时，错误信息作为工具结果返回给 LLM，模型会自动修正参数[^4]

---

## 4.4 状态持久化：JSONL 追加日志

**Session 存储使用 JSONL（JSON Lines）格式：**

```typescript
// Session 文件：~/.pi/sessions/abc123.jsonl
// 每行一个 JSON 对象，追加写入

// 用户消息
{"id":"msg-1","type":"user","content":"创建 hello.ts","timestamp":1708300000}

// 助手响应
{"id":"msg-2","type":"assistant","content":"我来创建文件","timestamp":1708300001}

// 工具调用
{"id":"msg-3","type":"tool","name":"write","params":{"path":"hello.ts","content":"console.log('hello')"},"timestamp":1708300002}

// 工具结果
{"id":"msg-4","type":"tool_result","toolCallId":"msg-3","output":"File written","timestamp":1708300003}

// 分支（parentId 指向分支点）
{"id":"msg-5","parentId":"msg-2","type":"user","content":"改成 TypeScript","timestamp":1708300010}
```

**为什么用 JSONL？**
- **追加写入**：不需要重写整个文件，性能好
- **树形结构**：通过 `parentId` 实现分支，单文件存储多个分支
- **跨 Provider 可移植**：统一格式，可在 Anthropic、OpenAI、Google 之间迁移[^5]

---

## 4.5 事件流与 UI 更新

**Agent Core 通过事件流向 UI 推送更新：**

```typescript
// Agent Core 发出事件
agent.on('message', (msg) => {
  // UI 接收助手消息
  console.log('Assistant:', msg.content);
});

agent.on('tool_call', (call) => {
  // UI 显示工具调用
  console.log(`Calling ${call.name}...`);
});

agent.on('tool_result', (result) => {
  // UI 显示工具结果
  console.log('Result:', result.output);
});

agent.on('done', () => {
  // 任务完成
  console.log('Task completed');
});
```

**工具结果的双重结构：**
```typescript
interface ToolResult {
  output: string;    // 返回给 LLM 的内容（简洁）
  details?: any;     // 返回给 UI 的详细信息（丰富）
}

// 示例：read 工具
{
  output: "File content: console.log('hello')",  // LLM 看到的
  details: {                                      // UI 看到的
    path: "hello.ts",
    size: 23,
    lines: 1,
    encoding: "utf-8"
  }
}
```

**为什么分离 output 和 details？**
- **output**：控制 LLM 上下文大小，避免 token 浪费
- **details**：UI 可以展示更丰富的信息（文件大小、执行时间等）

---

## 这些知识足以：

✅ **理解 Agent Core 的核心循环机制**
- LLM 调用 → 工具检测 → 执行 → 上下文更新 → 循环

✅ **理解 Pi 的极简哲学**
- 仅 4 个工具（read/write/edit/bash）
- 无 max-steps 限制，信任模型自我终止
- TypeBox + AJV 验证，模型自我纠正

✅ **理解状态管理机制**
- JSONL 追加日志
- 单文件树形结构（parentId 分支）
- 跨 Provider 可移植

✅ **理解事件流与 UI 交互**
- 事件驱动架构
- output（LLM）vs details（UI）分离

✅ **为深入学习打基础**
- 后续可学习：自定义工具、Sub-Agents、MCP 集成
- 理解了核心机制，扩展开发就水到渠成

---

## 快速验证理解

**问自己这些问题：**

1. Agent Core 的循环什么时候终止？
   - ✅ 当 LLM 不再请求工具调用时

2. 为什么 Pi 只需要 4 个工具？
   - ✅ 前沿模型理解编码代理上下文，能组合基础工具完成复杂任务

3. 工具验证失败时会发生什么？
   - ✅ 错误信息返回给 LLM，模型自我纠正参数

4. Session 分支如何实现？
   - ✅ JSONL 中通过 `parentId` 字段指向分支点

5. 工具结果的 output 和 details 有什么区别？
   - ✅ output 给 LLM（简洁），details 给 UI（丰富）

如果能回答这 5 个问题，说明你已经掌握了 Agent Core 的最小可用知识！

---

[^1]: Medium: "Agentic AI: Pi — Anatomy of a minimal coding agent powering OpenClaw" (2026)
[^2]: Reddit r/LangChain: "Agents are just LLM + loop + tools" discussion (2025)
[^3]: Pi-mono philosophy: "Frontier models understand what a coding agent is"
[^4]: Pi-mono: Validation failures returned to model as tool results for self-correction
[^5]: Pi-mono: Session format enables cross-provider portability (Anthropic ↔ OpenAI ↔ Google)
