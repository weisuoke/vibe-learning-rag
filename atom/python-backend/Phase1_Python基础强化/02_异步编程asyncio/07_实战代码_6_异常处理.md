# 实战代码6：异常处理与超时

> 完整可运行的异步异常处理示例

---

## 示例概述

本示例演示如何在 asyncio 中处理异常和超时，包括：
1. 基础异常处理
2. 超时控制
3. 任务取消
4. 重试机制
5. 优雅降级
6. 错误聚合

**适合场景：** 生产环境、可靠性要求高的应用

---

## 完整代码

```python
"""
asyncio 异常处理与超时示例
演示：在异步代码中正确处理异常和超时
"""

import asyncio
from typing import Optional, List
import random


# ===== 1. 基础异常处理 =====
print("=== 1. 基础异常处理 ===\n")


async def may_fail(success_rate: float = 0.5) -> str:
    """可能失败的异步函数"""
    await asyncio.sleep(0.1)

    if random.random() > success_rate:
        raise ValueError("操作失败")

    return "成功"


async def example_1():
    """示例1：基础异常处理"""
    print("示例1：基础异常处理")

    # 使用 try-except 捕获异常
    try:
        result = await may_fail(success_rate=0.3)
        print(f"  结果: {result}")
    except ValueError as e:
        print(f"  捕获异常: {e}")

    print()


# ===== 2. 超时控制 =====
print("=== 2. 超时控制 ===\n")


async def slow_operation(duration: float) -> str:
    """慢操作"""
    await asyncio.sleep(duration)
    return f"完成（耗时 {duration}秒）"


async def example_2():
    """示例2：超时控制"""
    print("示例2：超时控制")

    # 使用 asyncio.wait_for 设置超时
    try:
        result = await asyncio.wait_for(
            slow_operation(5.0),
            timeout=2.0
        )
        print(f"  结果: {result}")
    except asyncio.TimeoutError:
        print("  操作超时")

    print()


# ===== 3. 任务取消 =====
print("=== 3. 任务取消 ===\n")


async def cancellable_task():
    """可取消的任务"""
    try:
        print("  任务开始")
        await asyncio.sleep(10)
        print("  任务完成")
    except asyncio.CancelledError:
        print("  任务被取消")
        # 清理资源
        raise  # 重新抛出异常


async def example_3():
    """示例3：任务取消"""
    print("示例3：任务取消")

    task = asyncio.create_task(cancellable_task())

    # 等待 1 秒后取消任务
    await asyncio.sleep(1)
    task.cancel()

    try:
        await task
    except asyncio.CancelledError:
        print("  主函数捕获取消异常")

    print()


# ===== 4. gather 的异常处理 =====
print("=== 4. gather 的异常处理 ===\n")


async def task_success(task_id: int) -> str:
    """成功的任务"""
    await asyncio.sleep(0.1)
    return f"任务 {task_id} 成功"


async def task_failure(task_id: int) -> str:
    """失败的任务"""
    await asyncio.sleep(0.1)
    raise ValueError(f"任务 {task_id} 失败")


async def example_4():
    """示例4：gather 的异常处理"""
    print("示例4：gather 的异常处理")

    # 默认行为：任何一个失败就抛出异常
    print("默认行为:")
    try:
        results = await asyncio.gather(
            task_success(1),
            task_failure(2),
            task_success(3)
        )
    except ValueError as e:
        print(f"  捕获异常: {e}")

    # 使用 return_exceptions=True 继续执行
    print("\n使用 return_exceptions=True:")
    results = await asyncio.gather(
        task_success(1),
        task_failure(2),
        task_success(3),
        return_exceptions=True
    )

    for i, result in enumerate(results, 1):
        if isinstance(result, Exception):
            print(f"  任务 {i}: 失败 - {result}")
        else:
            print(f"  任务 {i}: {result}")

    print()


# ===== 5. 重试机制 =====
print("=== 5. 重试机制 ===\n")


async def unreliable_operation(success_rate: float = 0.3) -> str:
    """不可靠的操作"""
    await asyncio.sleep(0.2)

    if random.random() > success_rate:
        raise ConnectionError("连接失败")

    return "操作成功"


async def retry_operation(
    operation,
    max_retries: int = 3,
    delay: float = 1.0
) -> str:
    """带重试的操作"""
    for attempt in range(max_retries):
        try:
            print(f"  尝试 {attempt + 1}/{max_retries}")
            result = await operation()
            print(f"  成功")
            return result

        except Exception as e:
            if attempt == max_retries - 1:
                print(f"  所有尝试都失败")
                raise

            print(f"  失败: {e}，{delay}秒后重试")
            await asyncio.sleep(delay)


async def example_5():
    """示例5：重试机制"""
    print("示例5：重试机制")

    try:
        result = await retry_operation(
            lambda: unreliable_operation(success_rate=0.4),
            max_retries=3,
            delay=0.5
        )
        print(f"  最终结果: {result}")
    except Exception as e:
        print(f"  最终失败: {e}")

    print()


# ===== 6. 指数退避重试 =====
print("=== 6. 指数退避重试 ===\n")


async def retry_with_backoff(
    operation,
    max_retries: int = 5,
    initial_delay: float = 1.0,
    backoff_factor: float = 2.0
) -> str:
    """指数退避重试"""
    delay = initial_delay

    for attempt in range(max_retries):
        try:
            print(f"  尝试 {attempt + 1}/{max_retries}")
            result = await operation()
            return result

        except Exception as e:
            if attempt == max_retries - 1:
                raise

            print(f"  失败: {e}，等待 {delay:.1f}秒后重试")
            await asyncio.sleep(delay)
            delay *= backoff_factor  # 指数增长


async def example_6():
    """示例6：指数退避重试"""
    print("示例6：指数退避重试")

    try:
        result = await retry_with_backoff(
            lambda: unreliable_operation(success_rate=0.2),
            max_retries=5,
            initial_delay=0.5,
            backoff_factor=2.0
        )
        print(f"  成功: {result}")
    except Exception as e:
        print(f"  最终失败: {e}")

    print()


# ===== 7. 超时 + 重试 =====
print("=== 7. 超时 + 重试 ===\n")


async def retry_with_timeout(
    operation,
    max_retries: int = 3,
    timeout: float = 5.0,
    delay: float = 1.0
) -> str:
    """带超时的重试"""
    for attempt in range(max_retries):
        try:
            print(f"  尝试 {attempt + 1}/{max_retries}")

            # 设置超时
            result = await asyncio.wait_for(
                operation(),
                timeout=timeout
            )

            print(f"  成功")
            return result

        except asyncio.TimeoutError:
            if attempt == max_retries - 1:
                print(f"  所有尝试都超时")
                raise

            print(f"  超时，{delay}秒后重试")
            await asyncio.sleep(delay)

        except Exception as e:
            if attempt == max_retries - 1:
                raise

            print(f"  失败: {e}，{delay}秒后重试")
            await asyncio.sleep(delay)


async def example_7():
    """示例7：超时 + 重试"""
    print("示例7：超时 + 重试")

    try:
        result = await retry_with_timeout(
            lambda: slow_operation(3.0),
            max_retries=3,
            timeout=2.0,
            delay=0.5
        )
        print(f"  结果: {result}")
    except asyncio.TimeoutError:
        print("  最终超时")

    print()


# ===== 8. 优雅降级 =====
print("=== 8. 优雅降级 ===\n")


async def primary_service() -> str:
    """主服务"""
    await asyncio.sleep(0.1)
    if random.random() > 0.3:
        raise ConnectionError("主服务不可用")
    return "主服务响应"


async def fallback_service() -> str:
    """备用服务"""
    await asyncio.sleep(0.1)
    return "备用服务响应"


async def service_with_fallback() -> str:
    """带降级的服务"""
    try:
        print("  尝试主服务...")
        result = await primary_service()
        print(f"  主服务成功")
        return result

    except Exception as e:
        print(f"  主服务失败: {e}")
        print("  切换到备用服务...")

        try:
            result = await fallback_service()
            print(f"  备用服务成功")
            return result

        except Exception as e:
            print(f"  备用服务也失败: {e}")
            raise


async def example_8():
    """示例8：优雅降级"""
    print("示例8：优雅降级")

    try:
        result = await service_with_fallback()
        print(f"  最终结果: {result}")
    except Exception as e:
        print(f"  所有服务都失败: {e}")

    print()


# ===== 9. 错误聚合 =====
print("=== 9. 错误聚合 ===\n")


async def batch_operation(items: List[int]) -> dict:
    """批量操作，聚合错误"""
    results = []
    errors = []

    for item in items:
        try:
            if item % 3 == 0:
                raise ValueError(f"项目 {item} 处理失败")

            await asyncio.sleep(0.1)
            results.append({"item": item, "status": "success"})

        except Exception as e:
            errors.append({"item": item, "error": str(e)})

    return {
        "success_count": len(results),
        "error_count": len(errors),
        "results": results,
        "errors": errors
    }


async def example_9():
    """示例9：错误聚合"""
    print("示例9：错误聚合")

    items = list(range(1, 11))
    result = await batch_operation(items)

    print(f"  成功: {result['success_count']}")
    print(f"  失败: {result['error_count']}")

    if result['errors']:
        print("  错误详情:")
        for error in result['errors']:
            print(f"    - 项目 {error['item']}: {error['error']}")

    print()


# ===== 10. 实际应用：API 调用错误处理 =====
print("=== 10. 实际应用：API 调用错误处理 ===\n")


class APIError(Exception):
    """API 错误基类"""
    pass


class RateLimitError(APIError):
    """限流错误"""
    pass


class ServerError(APIError):
    """服务器错误"""
    pass


async def call_api(endpoint: str) -> dict:
    """模拟 API 调用"""
    await asyncio.sleep(0.2)

    rand = random.random()

    if rand < 0.2:
        raise RateLimitError("API 限流")
    elif rand < 0.4:
        raise ServerError("服务器错误")
    elif rand < 0.6:
        raise asyncio.TimeoutError("请求超时")

    return {"endpoint": endpoint, "data": "success"}


async def robust_api_call(
    endpoint: str,
    max_retries: int = 3
) -> Optional[dict]:
    """健壮的 API 调用"""
    for attempt in range(max_retries):
        try:
            print(f"  调用 {endpoint}（尝试 {attempt + 1}/{max_retries}）")

            result = await asyncio.wait_for(
                call_api(endpoint),
                timeout=5.0
            )

            print(f"  成功")
            return result

        except RateLimitError:
            # 限流：等待更长时间
            wait_time = 2.0 * (attempt + 1)
            print(f"  限流，等待 {wait_time}秒")
            await asyncio.sleep(wait_time)

        except ServerError:
            # 服务器错误：短暂等待后重试
            print(f"  服务器错误，1秒后重试")
            await asyncio.sleep(1.0)

        except asyncio.TimeoutError:
            # 超时：立即重试
            print(f"  超时，立即重试")

        except Exception as e:
            # 其他错误：不重试
            print(f"  未知错误: {e}")
            raise

    print(f"  所有尝试都失败")
    return None


async def example_10():
    """示例10：API 调用错误处理"""
    print("示例10：API 调用错误处理")

    result = await robust_api_call("/users", max_retries=5)

    if result:
        print(f"  API 响应: {result}")
    else:
        print(f"  API 调用失败")

    print()


# ===== 11. 实际应用：数据库操作错误处理 =====
print("=== 11. 实际应用：数据库操作错误处理 ===\n")


class DatabaseError(Exception):
    """数据库错误"""
    pass


async def db_operation() -> str:
    """模拟数据库操作"""
    await asyncio.sleep(0.1)

    if random.random() > 0.5:
        raise DatabaseError("数据库连接失败")

    return "数据库操作成功"


async def safe_db_operation() -> Optional[str]:
    """安全的数据库操作"""
    try:
        result = await asyncio.wait_for(
            db_operation(),
            timeout=5.0
        )
        return result

    except asyncio.TimeoutError:
        print("  数据库操作超时")
        return None

    except DatabaseError as e:
        print(f"  数据库错误: {e}")
        return None

    except Exception as e:
        print(f"  未知错误: {e}")
        raise


async def example_11():
    """示例11：数据库操作错误处理"""
    print("示例11：数据库操作错误处理")

    result = await safe_db_operation()

    if result:
        print(f"  结果: {result}")
    else:
        print(f"  操作失败，使用默认值")

    print()


# ===== 12. 上下文管理器的异常处理 =====
print("=== 12. 上下文管理器的异常处理 ===\n")


class AsyncResource:
    """异步资源"""

    async def __aenter__(self):
        print("  获取资源")
        await asyncio.sleep(0.1)
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print(f"  释放资源（异常类型: {exc_type}）")
        await asyncio.sleep(0.1)

        # 返回 True 表示异常已处理
        if exc_type is ValueError:
            print("  异常已处理")
            return True

        # 返回 False 或 None 表示异常继续传播
        return False

    async def operation(self):
        print("  执行操作")
        raise ValueError("操作失败")


async def example_12():
    """示例12：上下文管理器的异常处理"""
    print("示例12：上下文管理器的异常处理")

    try:
        async with AsyncResource() as resource:
            await resource.operation()
    except ValueError:
        print("  外部捕获异常")

    print()


# ===== 主函数 =====


async def main():
    """主函数：运行所有示例"""
    print("=" * 60)
    print("asyncio 异常处理与超时示例")
    print("=" * 60)
    print()

    # 运行所有示例
    await example_1()
    await example_2()
    await example_3()
    await example_4()
    await example_5()
    await example_6()
    await example_7()
    await example_8()
    await example_9()
    await example_10()
    await example_11()
    await example_12()

    print("=" * 60)
    print("所有示例运行完成！")
    print("=" * 60)


# ===== 运行程序 =====

if __name__ == "__main__":
    asyncio.run(main())
```

---

## 关键知识点

### 1. 基础异常处理

```python
try:
    result = await async_operation()
except ValueError as e:
    print(f"错误: {e}")
```

### 2. 超时控制

```python
try:
    result = await asyncio.wait_for(
        async_operation(),
        timeout=5.0
    )
except asyncio.TimeoutError:
    print("超时")
```

### 3. 任务取消

```python
task = asyncio.create_task(async_operation())
task.cancel()

try:
    await task
except asyncio.CancelledError:
    print("任务被取消")
```

### 4. gather 异常处理

```python
# 继续执行所有任务
results = await asyncio.gather(
    *tasks,
    return_exceptions=True
)

for result in results:
    if isinstance(result, Exception):
        print(f"错误: {result}")
```

### 5. 重试机制

```python
for attempt in range(max_retries):
    try:
        return await operation()
    except Exception:
        if attempt == max_retries - 1:
            raise
        await asyncio.sleep(delay)
```

---

## 异常类型

| 异常 | 说明 | 处理方式 |
|------|------|---------|
| `asyncio.TimeoutError` | 操作超时 | 重试或降级 |
| `asyncio.CancelledError` | 任务被取消 | 清理资源 |
| `ConnectionError` | 连接失败 | 重试 |
| `ValueError` | 参数错误 | 修正参数 |
| `Exception` | 通用异常 | 记录日志 |

---

## 重试策略

| 策略 | 适用场景 | 示例 |
|------|---------|------|
| 固定延迟 | 临时故障 | 每次等待 1 秒 |
| 指数退避 | 服务过载 | 1s, 2s, 4s, 8s |
| 立即重试 | 网络抖动 | 不等待 |
| 不重试 | 参数错误 | 直接失败 |

---

## 最佳实践

### 1. 区分可重试和不可重试的错误

```python
# ✅ 正确：区分错误类型
try:
    result = await operation()
except ConnectionError:
    # 可重试
    await retry()
except ValueError:
    # 不可重试
    raise
```

### 2. 设置合理的超时

```python
# ✅ 正确：根据操作类型设置超时
await asyncio.wait_for(
    db_query(),
    timeout=5.0  # 数据库查询
)

await asyncio.wait_for(
    llm_api(),
    timeout=30.0  # LLM API 调用
)
```

### 3. 使用优雅降级

```python
# ✅ 正确：提供备用方案
try:
    result = await primary_service()
except Exception:
    result = await fallback_service()
```

---

## 常见错误

### 错误1：忘记重新抛出 CancelledError

```python
# ❌ 错误：吞掉取消异常
try:
    await operation()
except asyncio.CancelledError:
    pass  # 任务无法被取消

# ✅ 正确：重新抛出
try:
    await operation()
except asyncio.CancelledError:
    # 清理资源
    raise  # 重新抛出
```

### 错误2：无限重试

```python
# ❌ 错误：可能无限重试
while True:
    try:
        return await operation()
    except Exception:
        await asyncio.sleep(1)

# ✅ 正确：限制重试次数
for attempt in range(max_retries):
    try:
        return await operation()
    except Exception:
        if attempt == max_retries - 1:
            raise
```

### 错误3：忽略超时异常

```python
# ❌ 错误：忽略超时
try:
    result = await asyncio.wait_for(operation(), timeout=5.0)
except asyncio.TimeoutError:
    result = None  # 可能导致问题

# ✅ 正确：正确处理超时
try:
    result = await asyncio.wait_for(operation(), timeout=5.0)
except asyncio.TimeoutError:
    # 记录日志、重试或降级
    raise
```

---

## 学习检查

完成本示例后，你应该能够：

- [ ] 使用 try-except 处理异步异常
- [ ] 使用 asyncio.wait_for 设置超时
- [ ] 正确取消任务并处理 CancelledError
- [ ] 在 gather 中处理多个任务的异常
- [ ] 实现重试机制（固定延迟和指数退避）
- [ ] 实现优雅降级
- [ ] 聚合批量操作的错误
- [ ] 在生产环境中正确处理异常

---

## 下一步

- **继续学习**：阅读【化骨绵掌】了解更多细节
- **实际应用**：在 AI Agent 项目中实现健壮的错误处理
- **监控告警**：添加日志和监控，及时发现问题
