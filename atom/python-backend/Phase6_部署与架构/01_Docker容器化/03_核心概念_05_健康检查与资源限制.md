# 核心概念5：健康检查与资源限制

## 概述

健康检查和资源限制是生产环境容器化的关键配置，确保应用的高可用性和资源使用的合理性。

---

## 一、健康检查（HEALTHCHECK）

### 1. 为什么需要健康检查？

**问题：** 容器进程运行不代表应用正常工作。

```bash
# 容器进程正在运行
docker ps
# CONTAINER ID   STATUS
# abc123         Up 5 minutes

# 但应用可能已经崩溃
curl http://localhost:8000
# curl: (52) Empty reply from server
```

**健康检查的作用：**
- ✅ 检测应用是否真正可用
- ✅ 自动重启不健康的容器
- ✅ 负载均衡器可以移除不健康的实例

### 2. HEALTHCHECK 指令

**语法：**

```dockerfile
HEALTHCHECK [OPTIONS] CMD command
```

**选项：**
- `--interval=<duration>`: 检查间隔（默认 30s）
- `--timeout=<duration>`: 超时时间（默认 30s）
- `--start-period=<duration>`: 启动宽限期（默认 0s）
- `--retries=<n>`: 重试次数（默认 3）

**示例：**

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1
```

### 3. 健康检查端点设计

**FastAPI 健康检查端点：**

```python
# app/main.py
from fastapi import FastAPI, HTTPException
from sqlalchemy import text
import redis

app = FastAPI()

@app.get("/health")
async def health_check():
    """
    健康检查端点
    检查：
    1. API 服务是否运行
    2. 数据库连接是否正常
    3. Redis 连接是否正常
    """
    health_status = {
        "status": "healthy",
        "checks": {}
    }

    # 检查数据库连接
    try:
        from app.core.database import engine
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
        health_status["checks"]["database"] = "connected"
    except Exception as e:
        health_status["status"] = "unhealthy"
        health_status["checks"]["database"] = f"error: {str(e)}"
        raise HTTPException(status_code=503, detail=health_status)

    # 检查 Redis 连接
    try:
        from app.core.cache import redis_client
        redis_client.ping()
        health_status["checks"]["redis"] = "connected"
    except Exception as e:
        health_status["status"] = "unhealthy"
        health_status["checks"]["redis"] = f"error: {str(e)}"
        raise HTTPException(status_code=503, detail=health_status)

    return health_status
```

### 4. Dockerfile 中配置健康检查

```dockerfile
FROM python:3.13-slim

WORKDIR /app

# 安装 curl（用于健康检查）
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 8000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 5. 使用 Python 脚本进行健康检查

**优势：** 不需要安装 curl，减小镜像体积。

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD python -c "import requests; requests.get('http://localhost:8000/health', timeout=2).raise_for_status()"
```

### 6. 查看健康状态

```bash
# 查看容器健康状态
docker ps
# CONTAINER ID   STATUS
# abc123         Up 5 minutes (healthy)

# 查看健康检查日志
docker inspect --format='{{json .State.Health}}' abc123 | jq
{
  "Status": "healthy",
  "FailingStreak": 0,
  "Log": [
    {
      "Start": "2026-02-12T10:00:00Z",
      "End": "2026-02-12T10:00:01Z",
      "ExitCode": 0,
      "Output": "{\"status\":\"healthy\"}"
    }
  ]
}
```

### 7. 容器重启策略

**配合健康检查自动重启：**

```bash
# 运行容器并设置重启策略
docker run -d \
  --name api \
  --restart unless-stopped \
  -p 8000:8000 \
  my-app

# 重启策略：
# - no: 不自动重启（默认）
# - on-failure: 失败时重启
# - always: 总是重启
# - unless-stopped: 除非手动停止，否则总是重启
```

**docker-compose 配置：**

```yaml
version: '3.8'
services:
  api:
    build: .
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 5s
```

---

## 二、资源限制

### 1. 为什么需要资源限制？

**问题：** 容器可以无限制使用宿主机资源。

```bash
# 运行容器（无资源限制）
docker run -d --name api my-app

# 容器可能占用所有 CPU 和内存
# 导致宿主机其他服务无法正常运行
```

### 2. CPU 限制

**限制 CPU 使用：**

```bash
# 限制容器使用 1 个 CPU
docker run -d --cpus=1 my-app

# 限制容器使用 0.5 个 CPU
docker run -d --cpus=0.5 my-app

# 限制容器使用 2 个 CPU
docker run -d --cpus=2 my-app
```

**CPU 份额（相对权重）：**

```bash
# 容器 A 获得 1024 份额
docker run -d --cpu-shares=1024 --name api-a my-app

# 容器 B 获得 512 份额
docker run -d --cpu-shares=512 --name api-b my-app

# 当 CPU 资源紧张时，A 获得 2/3 的 CPU，B 获得 1/3
```

### 3. 内存限制

**限制内存使用：**

```bash
# 限制容器使用 512MB 内存
docker run -d --memory=512m my-app

# 限制容器使用 1GB 内存
docker run -d --memory=1g my-app

# 限制内存 + Swap
docker run -d --memory=512m --memory-swap=1g my-app
# 容器可以使用 512MB 内存 + 512MB Swap
```

**内存预留：**

```bash
# 预留 256MB 内存（软限制）
docker run -d --memory-reservation=256m my-app
```

### 4. 查看资源使用情况

```bash
# 查看容器资源使用
docker stats

# 输出示例
CONTAINER ID   NAME   CPU %   MEM USAGE / LIMIT   MEM %   NET I/O
abc123         api    2.5%    256MB / 512MB       50%     1.2MB / 800KB

# 查看单个容器
docker stats api

# 只显示一次（不实时更新）
docker stats --no-stream
```

### 5. docker-compose 资源限制

```yaml
version: '3.8'
services:
  api:
    build: .
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    restart: unless-stopped
```

### 6. AI Agent API 资源配置建议

**小型应用：**
```yaml
services:
  api:
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
```

**中型应用：**
```yaml
services:
  api:
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
```

**大型应用：**
```yaml
services:
  api:
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 2G
```

---

## 三、优雅关闭

### 1. 为什么需要优雅关闭？

**问题：** 容器停止时，进程被强制杀死。

```bash
# 停止容器
docker stop api

# 容器内进程收到 SIGTERM 信号
# 10秒后收到 SIGKILL 信号（强制杀死）
```

**优雅关闭的作用：**
- ✅ 完成正在处理的请求
- ✅ 关闭数据库连接
- ✅ 保存未完成的任务
- ✅ 清理临时文件

### 2. FastAPI 优雅关闭

```python
# app/main.py
import signal
import sys
from fastapi import FastAPI

app = FastAPI()

# 全局变量：标记是否正在关闭
is_shutting_down = False

@app.on_event("startup")
async def startup_event():
    """应用启动时执行"""
    print("Application starting up...")

@app.on_event("shutdown")
async def shutdown_event():
    """应用关闭时执行"""
    global is_shutting_down
    is_shutting_down = True
    print("Application shutting down...")

    # 关闭数据库连接
    from app.core.database import engine
    engine.dispose()
    print("Database connections closed")

    # 关闭 Redis 连接
    from app.core.cache import redis_client
    redis_client.close()
    print("Redis connection closed")

def signal_handler(sig, frame):
    """处理 SIGTERM 信号"""
    print(f"Received signal {sig}, shutting down gracefully...")
    sys.exit(0)

# 注册信号处理器
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)
```

### 3. 中间件：拒绝新请求

```python
# app/middleware/shutdown.py
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

class ShutdownMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # 如果正在关闭，拒绝新请求
        if is_shutting_down:
            return Response(
                content="Service is shutting down",
                status_code=503
            )
        return await call_next(request)

# app/main.py
app.add_middleware(ShutdownMiddleware)
```

### 4. Dockerfile 配置

```dockerfile
FROM python:3.13-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 8000

# 使用 Exec 形式（确保进程 PID 为 1）
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

# ❌ 不要使用 Shell 形式（进程 PID 不是 1，无法接收信号）
# CMD uvicorn app.main:app --host 0.0.0.0 --port 8000
```

### 5. 停止容器时的超时时间

```bash
# 默认超时 10 秒
docker stop api

# 自定义超时时间（30 秒）
docker stop -t 30 api

# docker-compose 配置
docker-compose down --timeout 30
```

---

## 四、完整示例：生产级配置

### Dockerfile

```dockerfile
FROM python:3.13-slim AS builder

WORKDIR /app

RUN pip install --no-cache-dir uv

COPY pyproject.toml uv.lock ./

RUN uv sync --frozen --no-dev

FROM python:3.13-slim

# 安装 curl（用于健康检查）
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

RUN groupadd -r appuser && useradd -r -g appuser appuser

WORKDIR /app

COPY --from=builder /app/.venv /app/.venv

COPY --chown=appuser:appuser app/ app/

ENV PATH="/app/.venv/bin:$PATH" \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

USER appuser

EXPOSE 8000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

# 优雅关闭（使用 Exec 形式）
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### docker-compose.yml

```yaml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    networks:
      - aiagent-network
    volumes:
      - api_logs:/app/logs
    environment:
      - DATABASE_URL=postgresql://aiagent:secret@db:5432/aiagent
      - REDIS_URL=redis://redis:6379/0
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '1'
          memory: 512M
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 5s

  db:
    image: postgres:14-alpine
    networks:
      - aiagent-network
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=aiagent
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=aiagent
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U aiagent"]
      interval: 10s
      timeout: 3s
      retries: 3

  redis:
    image: redis:7-alpine
    networks:
      - aiagent-network
    volumes:
      - redis_data:/data
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3

networks:
  aiagent-network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:
  api_logs:
```

---

## 总结

**健康检查：**
1. ✅ 设计健康检查端点（检查数据库、Redis 等依赖）
2. ✅ 配置 HEALTHCHECK 指令
3. ✅ 设置合理的检查间隔和超时时间
4. ✅ 配置容器重启策略

**资源限制：**
1. ✅ 限制 CPU 使用（--cpus）
2. ✅ 限制内存使用（--memory）
3. ✅ 监控资源使用情况（docker stats）
4. ✅ 根据应用规模调整资源配置

**优雅关闭：**
1. ✅ 使用 Exec 形式的 CMD（确保进程 PID 为 1）
2. ✅ 处理 SIGTERM 信号
3. ✅ 关闭数据库和 Redis 连接
4. ✅ 拒绝新请求，完成正在处理的请求

---

**版本：** v1.0
**最后更新：** 2026-02-12
**适用于：** Python 3.13+ / FastAPI / AI Agent 后端开发
