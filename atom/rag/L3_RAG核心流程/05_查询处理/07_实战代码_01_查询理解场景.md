# 实战代码 01：查询理解场景

## 概述

本文提供查询理解的完整可运行代码示例，涵盖意图识别、实体提取、歧义消解等核心功能。所有代码基于 Python 3.13+，使用 OpenAI API。

---

## 场景 1：基础查询理解系统

### 需求

构建一个基础的查询理解系统，能够：
1. 识别查询意图
2. 提取关键实体
3. 消解歧义
4. 补充上下文

### 完整代码

```python
from openai import OpenAI
from dataclasses import dataclass
from typing import List, Dict, Optional
import json

client = OpenAI()

@dataclass
class QueryUnderstanding:
    """查询理解结果"""
    original_query: str
    intent: str
    entities: List[Dict[str, str]]
    resolved_query: str
    context: Dict[str, any]
    confidence: float

# 1. 意图识别
def detect_intent(query: str) -> str:
    """识别查询意图"""
    prompt = f"""分析以下查询的意图类型。

意图类型：
- concept: 概念解释
- how-to: 操作指导
- troubleshooting: 问题诊断
- comparison: 对比分析
- fact: 事实查询
- exploratory: 探索式搜索

查询：{query}

只输出意图类型，不要解释。"""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.1
    )

    return response.choices[0].message.content.strip()

# 2. 实体提取
def extract_entities(query: str) -> List[Dict[str, str]]:
    """提取查询中的实体"""
    prompt = f"""从以下查询中提取关键实体。

实体类型：
- 技术栈：编程语言、框架、库
- 概念：技术概念、术语
- 操作：动作、任务
- 属性：特征、指标

查询：{query}

以 JSON 格式输出：
{{
  "entities": [
    {{"text": "实体文本", "type": "实体类型"}}
  ]
}}"""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.1,
        response_format={"type": "json_object"}
    )

    result = json.loads(response.choices[0].message.content)
    return result.get("entities", [])

# 3. 歧义消解
def resolve_ambiguity(query: str, entities: List[Dict[str, str]]) -> str:
    """消解查询中的歧义"""
    # 领域知识库
    domain_knowledge = {
        "GIL": "Global Interpreter Lock (Python)",
        "RAG": "Retrieval-Augmented Generation",
        "LLM": "Large Language Model",
        "API": "Application Programming Interface"
    }

    resolved = query

    # 扩展缩写
    for entity in entities:
        text = entity["text"]
        if text in domain_knowledge:
            full_name = domain_knowledge[text]
            resolved = resolved.replace(text, f"{text} ({full_name})")

    return resolved

# 4. 上下文补充
def enrich_context(
    query: str,
    intent: str,
    entities: List[Dict[str, str]]
) -> Dict[str, any]:
    """补充查询上下文"""
    return {
        "original_query": query,
        "intent": intent,
        "entities": entities,
        "domain": "技术",
        "complexity": "simple" if len(query.split()) < 10 else "complex",
        "requires_code": any(e["type"] == "操作" for e in entities)
    }

# 5. 完整查询理解流程
def understand_query(query: str) -> QueryUnderstanding:
    """完整的查询理解流程"""
    print(f"原始查询: {query}\n")

    # 1. 意图识别
    intent = detect_intent(query)
    print(f"意图类型: {intent}")

    # 2. 实体提取
    entities = extract_entities(query)
    print(f"提取实体: {entities}")

    # 3. 歧义消解
    resolved_query = resolve_ambiguity(query, entities)
    print(f"消解歧义: {resolved_query}")

    # 4. 上下文补充
    context = enrich_context(query, intent, entities)
    print(f"上下文: {context}\n")

    # 5. 计算置信度
    confidence = 0.9 if intent != "exploratory" else 0.7

    return QueryUnderstanding(
        original_query=query,
        intent=intent,
        entities=entities,
        resolved_query=resolved_query,
        context=context,
        confidence=confidence
    )

# 测试
if __name__ == "__main__":
    test_queries = [
        "什么是 Python 的 GIL？",
        "如何优化 RAG 系统性能？",
        "对比 LangChain 和 LlamaIndex"
    ]

    for query in test_queries:
        understanding = understand_query(query)
        print(f"理解结果: {understanding}\n")
        print("-" * 80 + "\n")
```

### 运行结果

```
原始查询: 什么是 Python 的 GIL？

意图类型: concept
提取实体: [{'text': 'Python', 'type': '技术栈'}, {'text': 'GIL', 'type': '概念'}]
消解歧义: 什么是 Python 的 GIL (Global Interpreter Lock (Python))？
上下文: {'original_query': '什么是 Python 的 GIL？', 'intent': 'concept', 'entities': [{'text': 'Python', 'type': '技术栈'}, {'text': 'GIL', 'type': '概念'}], 'domain': '技术', 'complexity': 'simple', 'requires_code': False}

理解结果: QueryUnderstanding(original_query='什么是 Python 的 GIL？', intent='concept', entities=[{'text': 'Python', 'type': '技术栈'}, {'text': 'GIL', 'type': '概念'}], resolved_query='什么是 Python 的 GIL (Global Interpreter Lock (Python))？', context={'original_query': '什么是 Python 的 GIL？', 'intent': 'concept', 'entities': [{'text': 'Python', 'type': '技术栈'}, {'text': 'GIL', 'type': '概念'}], 'domain': '技术', 'complexity': 'simple', 'requires_code': False}, confidence=0.9)
```

---

## 场景 2：混合意图识别（规则 + LLM）

### 需求

实现一个混合意图识别系统，简单查询用规则，复杂查询用 LLM。

### 完整代码

```python
import re
from typing import Optional

class HybridIntentDetector:
    """混合意图识别器"""

    def __init__(self):
        # 规则库
        self.rules = {
            "concept": [r"什么是", r"是什么", r"定义", r"概念"],
            "how-to": [r"如何", r"怎么", r"怎样", r"方法"],
            "troubleshooting": [r"为什么", r"原因", r"错误", r"问题", r"不工作"],
            "comparison": [r"对比", r"比较", r"vs", r"区别", r"优缺点"],
            "fact": [r"什么时候", r"哪里", r"谁", r"多少", r"日期"]
        }

    def detect_by_rules(self, query: str) -> Optional[str]:
        """基于规则的意图识别"""
        query_lower = query.lower()

        for intent, patterns in self.rules.items():
            for pattern in patterns:
                if re.search(pattern, query_lower):
                    return intent

        return None

    def detect_by_llm(self, query: str) -> str:
        """基于 LLM 的意图识别"""
        prompt = f"""分析查询意图：

查询：{query}

意图类型（concept/how-to/troubleshooting/comparison/fact/exploratory）："""

        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1
        )

        return response.choices[0].message.content.strip()

    def detect(self, query: str) -> Dict[str, any]:
        """混合意图识别"""
        # 1. 尝试规则匹配
        rule_intent = self.detect_by_rules(query)

        if rule_intent:
            return {
                "intent": rule_intent,
                "method": "rule",
                "confidence": 0.95
            }

        # 2. 使用 LLM
        llm_intent = self.detect_by_llm(query)

        return {
            "intent": llm_intent,
            "method": "llm",
            "confidence": 0.85
        }

# 测试
if __name__ == "__main__":
    detector = HybridIntentDetector()

    test_queries = [
        "什么是 Transformer？",  # 规则匹配
        "如何提升 RAG 准确性？",  # 规则匹配
        "RAG 系统的性能瓶颈在哪里？",  # LLM 识别
        "对比 LangChain 和 LlamaIndex"  # 规则匹配
    ]

    for query in test_queries:
        result = detector.detect(query)
        print(f"查询: {query}")
        print(f"结果: {result}\n")
```

### 运行结果

```
查询: 什么是 Transformer？
结果: {'intent': 'concept', 'method': 'rule', 'confidence': 0.95}

查询: 如何提升 RAG 准确性？
结果: {'intent': 'how-to', 'method': 'rule', 'confidence': 0.95}

查询: RAG 系统的性能瓶颈在哪里？
结果: {'intent': 'troubleshooting', 'method': 'llm', 'confidence': 0.85}

查询: 对比 LangChain 和 LlamaIndex
结果: {'intent': 'comparison', 'method': 'rule', 'confidence': 0.95}
```

---

## 场景 3：上下文感知的查询理解

### 需求

实现一个上下文感知的查询理解系统，能够利用对话历史理解当前查询。

### 完整代码

```python
from typing import List

class ContextAwareQueryUnderstanding:
    """上下文感知的查询理解"""

    def __init__(self):
        self.conversation_history: List[Dict[str, str]] = []

    def add_to_history(self, query: str, response: str):
        """添加到对话历史"""
        self.conversation_history.append({
            "query": query,
            "response": response
        })

    def resolve_references(self, query: str) -> str:
        """解析指代词"""
        if not self.conversation_history:
            return query

        # 检查是否包含指代词
        pronouns = ["它", "这个", "那个", "这", "那", "他", "她"]

        has_pronoun = any(p in query for p in pronouns)

        if not has_pronoun:
            return query

        # 使用 LLM 解析指代
        history_text = "\n".join([
            f"Q: {h['query']}\nA: {h['response'][:100]}..."
            for h in self.conversation_history[-3:]  # 只用最近3轮
        ])

        prompt = f"""基于对话历史，解析当前查询中的指代词。

对话历史：
{history_text}

当前查询：{query}

解析后的查询（替换指代词为具体内容）："""

        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1
        )

        return response.choices[0].message.content.strip()

    def understand(self, query: str) -> Dict[str, any]:
        """理解查询"""
        # 1. 解析指代
        resolved_query = self.resolve_references(query)

        # 2. 意图识别
        intent = detect_intent(resolved_query)

        # 3. 实体提取
        entities = extract_entities(resolved_query)

        return {
            "original_query": query,
            "resolved_query": resolved_query,
            "intent": intent,
            "entities": entities,
            "has_context": query != resolved_query
        }

# 测试
if __name__ == "__main__":
    understanding = ContextAwareQueryUnderstanding()

    # 第一轮对话
    query1 = "什么是 RAG？"
    result1 = understanding.understand(query1)
    print(f"Q1: {query1}")
    print(f"R1: {result1}\n")

    # 模拟回答
    understanding.add_to_history(
        query1,
        "RAG 是 Retrieval-Augmented Generation 的缩写..."
    )

    # 第二轮对话（包含指代）
    query2 = "它的优势是什么？"
    result2 = understanding.understand(query2)
    print(f"Q2: {query2}")
    print(f"R2: {result2}\n")

    # 模拟回答
    understanding.add_to_history(
        query2,
        "RAG 的优势包括..."
    )

    # 第三轮对话（包含指代）
    query3 = "如何实现它？"
    result3 = understanding.understand(query3)
    print(f"Q3: {query3}")
    print(f"R3: {result3}\n")
```

### 运行结果

```
Q1: 什么是 RAG？
R1: {'original_query': '什么是 RAG？', 'resolved_query': '什么是 RAG？', 'intent': 'concept', 'entities': [{'text': 'RAG', 'type': '概念'}], 'has_context': False}

Q2: 它的优势是什么？
R2: {'original_query': '它的优势是什么？', 'resolved_query': 'RAG 的优势是什么？', 'intent': 'concept', 'entities': [{'text': 'RAG', 'type': '概念'}, {'text': '优势', 'type': '属性'}], 'has_context': True}

Q3: 如何实现它？
R3: {'original_query': '如何实现它？', 'resolved_query': '如何实现 RAG？', 'intent': 'how-to', 'entities': [{'text': 'RAG', 'type': '概念'}, {'text': '实现', 'type': '操作'}], 'has_context': True}
```

---

## 场景 4：查询理解与检索策略选择

### 需求

根据查询理解结果，自动选择最佳的检索策略。

### 完整代码

```python
class QueryUnderstandingWithStrategy:
    """查询理解 + 策略选择"""

    def __init__(self):
        self.detector = HybridIntentDetector()

    def select_retrieval_strategy(
        self,
        intent: str,
        entities: List[Dict[str, str]],
        complexity: str
    ) -> Dict[str, any]:
        """选择检索策略"""
        # 根据意图选择策略
        if intent == "concept":
            strategy = "hyde"
            reason = "概念解释类查询适合使用 HyDE"
        elif intent == "how-to":
            strategy = "rewrite"
            reason = "操作指导类查询适合查询改写"
        elif intent == "comparison":
            strategy = "decompose"
            reason = "对比分析类查询适合查询分解"
        elif intent == "fact":
            strategy = "direct"
            reason = "事实查询直接检索即可"
        else:
            strategy = "multi-query"
            reason = "探索式搜索适合多查询生成"

        # 根据复杂度调整参数
        if complexity == "complex":
            if strategy == "multi-query":
                num_queries = 5
            elif strategy == "decompose":
                max_sub_queries = 5
            else:
                num_queries = 3
        else:
            num_queries = 3
            max_sub_queries = 3

        return {
            "strategy": strategy,
            "reason": reason,
            "parameters": {
                "num_queries": num_queries if strategy in ["multi-query"] else None,
                "max_sub_queries": max_sub_queries if strategy == "decompose" else None
            }
        }

    def understand_and_plan(self, query: str) -> Dict[str, any]:
        """理解查询并规划检索策略"""
        print(f"原始查询: {query}\n")

        # 1. 意图识别
        intent_result = self.detector.detect(query)
        intent = intent_result["intent"]
        print(f"意图: {intent} (方法: {intent_result['method']})")

        # 2. 实体提取
        entities = extract_entities(query)
        print(f"实体: {entities}")

        # 3. 判断复杂度
        complexity = "complex" if len(query.split()) >= 10 else "simple"
        print(f"复杂度: {complexity}")

        # 4. 选择策略
        strategy = self.select_retrieval_strategy(intent, entities, complexity)
        print(f"检索策略: {strategy}\n")

        return {
            "query": query,
            "intent": intent,
            "entities": entities,
            "complexity": complexity,
            "strategy": strategy
        }

# 测试
if __name__ == "__main__":
    planner = QueryUnderstandingWithStrategy()

    test_queries = [
        "什么是 Transformer 的自注意力机制？",
        "如何优化 RAG 系统的检索准确性？",
        "对比 LangChain 和 LlamaIndex 在 RAG 开发中的优缺点",
        "Python 3.13 的发布日期是什么？"
    ]

    for query in test_queries:
        result = planner.understand_and_plan(query)
        print("-" * 80 + "\n")
```

### 运行结果

```
原始查询: 什么是 Transformer 的自注意力机制？

意图: concept (方法: rule)
实体: [{'text': 'Transformer', 'type': '概念'}, {'text': '自注意力机制', 'type': '概念'}]
复杂度: simple
检索策略: {'strategy': 'hyde', 'reason': '概念解释类查询适合使用 HyDE', 'parameters': {'num_queries': None, 'max_sub_queries': None}}

--------------------------------------------------------------------------------

原始查询: 如何优化 RAG 系统的检索准确性？

意图: how-to (方法: rule)
实体: [{'text': 'RAG', 'type': '概念'}, {'text': '优化', 'type': '操作'}, {'text': '检索准确性', 'type': '属性'}]
复杂度: simple
检索策略: {'strategy': 'rewrite', 'reason': '操作指导类查询适合查询改写', 'parameters': {'num_queries': None, 'max_sub_queries': None}}

--------------------------------------------------------------------------------

原始查询: 对比 LangChain 和 LlamaIndex 在 RAG 开发中的优缺点

意图: comparison (方法: rule)
实体: [{'text': 'LangChain', 'type': '技术栈'}, {'text': 'LlamaIndex', 'type': '技术栈'}, {'text': 'RAG', 'type': '概念'}]
复杂度: complex
检索策略: {'strategy': 'decompose', 'reason': '对比分析类查询适合查询分解', 'parameters': {'num_queries': None, 'max_sub_queries': 5}}

--------------------------------------------------------------------------------

原始查询: Python 3.13 的发布日期是什么？

意图: fact (方法: rule)
实体: [{'text': 'Python 3.13', 'type': '技术栈'}, {'text': '发布日期', 'type': '属性'}]
复杂度: simple
检索策略: {'strategy': 'direct', 'reason': '事实查询直接检索即可', 'parameters': {'num_queries': None, 'max_sub_queries': None}}
```

---

## 总结

### 关键要点

1. **混合方法最优**：规则 + LLM，平衡成本和准确率
2. **上下文感知**：利用对话历史理解指代词
3. **策略选择**：根据意图自动选择检索策略
4. **可扩展性**：模块化设计，易于扩展新功能

### 代码特点

- 所有代码可直接运行
- 使用 Python 3.13+ 特性
- 基于 OpenAI API
- 模块化设计，易于集成

### 下一步

将查询理解结果应用到实际的 RAG 检索流程中，参考后续的实战代码文件。
