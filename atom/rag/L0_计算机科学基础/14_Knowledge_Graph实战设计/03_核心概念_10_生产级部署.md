# 核心概念 10：生产级部署

## 生产环境要求

**生产级知识图谱系统需要考虑**：
- 高可用性：99.9%以上的可用性
- 可扩展性：支持数据和查询量增长
- 性能优化：毫秒级查询响应
- 安全性：数据加密和访问控制
- 监控告警：实时监控和故障预警
- 备份恢复：数据安全和灾难恢复

---

## Neo4j集群部署

### 架构设计

```
┌─────────────────────────────────┐
│  负载均衡器（HAProxy/Nginx）     │
└─────────────────────────────────┘
           ↓
┌─────────────────────────────────┐
│  Neo4j集群                       │
│  ┌──────────┬──────────┬────────┐│
│  │ Leader   │ Follower │Follower││
│  │ (读写)   │ (只读)   │(只读)  ││
│  └──────────┴──────────┴────────┘│
└─────────────────────────────────┘
           ↓
┌─────────────────────────────────┐
│  持久化存储                      │
└─────────────────────────────────┘
```

### Docker Compose部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  neo4j-core1:
    image: neo4j:5.15-enterprise
    hostname: core1
    container_name: neo4j-core1
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=neo4j/password
      - NEO4J_dbms_mode=CORE
      - NEO4J_causal__clustering_initial__discovery__members=core1:5000,core2:5000,core3:5000
      - NEO4J_dbms_memory_heap_initial__size=2G
      - NEO4J_dbms_memory_heap_max__size=4G
      - NEO4J_dbms_memory_pagecache_size=2G
    volumes:
      - neo4j-core1-data:/data
      - neo4j-core1-logs:/logs
    networks:
      - neo4j-network

  neo4j-core2:
    image: neo4j:5.15-enterprise
    hostname: core2
    container_name: neo4j-core2
    ports:
      - "7475:7474"
      - "7688:7687"
    environment:
      - NEO4J_AUTH=neo4j/password
      - NEO4J_dbms_mode=CORE
      - NEO4J_causal__clustering_initial__discovery__members=core1:5000,core2:5000,core3:5000
      - NEO4J_dbms_memory_heap_initial__size=2G
      - NEO4J_dbms_memory_heap_max__size=4G
    volumes:
      - neo4j-core2-data:/data
      - neo4j-core2-logs:/logs
    networks:
      - neo4j-network

  neo4j-core3:
    image: neo4j:5.15-enterprise
    hostname: core3
    container_name: neo4j-core3
    ports:
      - "7476:7474"
      - "7689:7687"
    environment:
      - NEO4J_AUTH=neo4j/password
      - NEO4J_dbms_mode=CORE
      - NEO4J_causal__clustering_initial__discovery__members=core1:5000,core2:5000,core3:5000
      - NEO4J_dbms_memory_heap_initial__size=2G
      - NEO4J_dbms_memory_heap_max__size=4G
    volumes:
      - neo4j-core3-data:/data
      - neo4j-core3-logs:/logs
    networks:
      - neo4j-network

volumes:
  neo4j-core1-data:
  neo4j-core1-logs:
  neo4j-core2-data:
  neo4j-core2-logs:
  neo4j-core3-data:
  neo4j-core3-logs:

networks:
  neo4j-network:
    driver: bridge
```

---

## 性能优化

### 1. 索引策略

```cypher
// 创建索引
CREATE INDEX person_name FOR (p:Person) ON (p.name);
CREATE INDEX company_name FOR (c:Company) ON (c.name);

// 复合索引
CREATE INDEX person_name_age FOR (p:Person) ON (p.name, p.age);

// 全文索引
CREATE FULLTEXT INDEX entity_fulltext FOR (e:Entity) ON EACH [e.name, e.description];

// 向量索引
CREATE VECTOR INDEX entity_embedding FOR (e:Entity) ON (e.embedding)
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'cosine'
  }
};

// 查看索引使用情况
CALL db.indexes() YIELD name, state, populationPercent;
```

### 2. 查询优化

```python
"""查询优化示例"""

# ❌ 慢查询：全表扫描
slow_query = """
MATCH (p:Person)
WHERE p.name = 'Zhang San'
RETURN p
"""

# ✅ 快查询：使用索引
fast_query = """
MATCH (p:Person {name: 'Zhang San'})
RETURN p
"""

# ❌ 慢查询：笛卡尔积
slow_query = """
MATCH (p:Person), (c:Company)
WHERE p.company_id = c.id
RETURN p, c
"""

# ✅ 快查询：使用关系
fast_query = """
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
RETURN p, c
"""

# 使用PROFILE分析
profile_query = """
PROFILE
MATCH (p:Person {name: 'Zhang San'})-[:WORKS_AT]->(c:Company)
RETURN p, c
"""
```

### 3. 批量操作

```python
"""批量导入优化"""

from neo4j import GraphDatabase

driver = GraphDatabase.driver("bolt://localhost:7687", auth=("neo4j", "password"))

def batch_import(triples: list, batch_size: int = 1000):
    """批量导入三元组"""
    with driver.session() as session:
        for i in range(0, len(triples), batch_size):
            batch = triples[i:i + batch_size]

            session.run("""
                UNWIND $batch AS triple
                MERGE (s:Entity {name: triple.subject})
                MERGE (o:Entity {name: triple.object})
                MERGE (s)-[r:RELATION {type: triple.predicate}]->(o)
            """, batch=batch)

            print(f"导入进度: {min(i + batch_size, len(triples))}/{len(triples)}")

# 使用
triples = [
    {"subject": "Zhang San", "predicate": "WORKS_AT", "object": "Alibaba"},
    # ... 更多三元组
]
batch_import(triples)
```

---

## 监控与告警

### 1. Prometheus监控

```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'neo4j'
    static_configs:
      - targets: ['localhost:2004']
    metrics_path: '/metrics'
```

### 2. 关键指标

```python
"""监控指标收集"""

from prometheus_client import Counter, Histogram, Gauge
import time

# 定义指标
query_counter = Counter('neo4j_queries_total', 'Total number of queries')
query_duration = Histogram('neo4j_query_duration_seconds', 'Query duration')
active_connections = Gauge('neo4j_active_connections', 'Active connections')

def monitored_query(session, query, params=None):
    """带监控的查询"""
    query_counter.inc()

    start_time = time.time()
    try:
        result = session.run(query, params or {})
        return list(result)
    finally:
        duration = time.time() - start_time
        query_duration.observe(duration)
```

### 3. 日志配置

```python
"""结构化日志"""

import logging
import json
from datetime import datetime

class StructuredLogger:
    """结构化日志器"""

    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.INFO)

        handler = logging.StreamHandler()
        handler.setFormatter(logging.Formatter('%(message)s'))
        self.logger.addHandler(handler)

    def log(self, level: str, message: str, **kwargs):
        """记录日志"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level,
            "message": message,
            **kwargs
        }
        self.logger.info(json.dumps(log_entry))

# 使用
logger = StructuredLogger("graphrag")
logger.log("INFO", "Query executed", query="MATCH (p:Person) RETURN p", duration=0.123)
```

---

## 备份与恢复

### 1. 定期备份

```bash
#!/bin/bash
# backup.sh

BACKUP_DIR="/backups/neo4j"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="neo4j_backup_$DATE.dump"

# 停止Neo4j
docker-compose stop neo4j-core1

# 备份数据
docker run --rm \
  -v neo4j-core1-data:/data \
  -v $BACKUP_DIR:/backup \
  neo4j:5.15-enterprise \
  neo4j-admin database dump neo4j --to-path=/backup/$BACKUP_FILE

# 启动Neo4j
docker-compose start neo4j-core1

# 清理旧备份（保留7天）
find $BACKUP_DIR -name "neo4j_backup_*.dump" -mtime +7 -delete

echo "Backup completed: $BACKUP_FILE"
```

### 2. 恢复数据

```bash
#!/bin/bash
# restore.sh

BACKUP_FILE=$1

if [ -z "$BACKUP_FILE" ]; then
    echo "Usage: ./restore.sh <backup_file>"
    exit 1
fi

# 停止Neo4j
docker-compose stop neo4j-core1

# 恢复数据
docker run --rm \
  -v neo4j-core1-data:/data \
  -v /backups/neo4j:/backup \
  neo4j:5.15-enterprise \
  neo4j-admin database load neo4j --from-path=/backup/$BACKUP_FILE --overwrite-destination=true

# 启动Neo4j
docker-compose start neo4j-core1

echo "Restore completed from: $BACKUP_FILE"
```

---

## 安全配置

### 1. 访问控制

```cypher
// 创建用户
CREATE USER reader SET PASSWORD 'reader_password';
CREATE USER writer SET PASSWORD 'writer_password';

// 授权
GRANT TRAVERSE ON GRAPH * NODES * TO reader;
GRANT MATCH {*} ON GRAPH * TO reader;

GRANT ALL ON GRAPH * TO writer;

// 查看权限
SHOW USER PRIVILEGES;
```

### 2. SSL/TLS配置

```yaml
# docker-compose.yml
services:
  neo4j:
    environment:
      - NEO4J_dbms_ssl_policy_bolt_enabled=true
      - NEO4J_dbms_ssl_policy_bolt_base__directory=/ssl
      - NEO4J_dbms_ssl_policy_bolt_private__key=private.key
      - NEO4J_dbms_ssl_policy_bolt_public__certificate=public.crt
    volumes:
      - ./ssl:/ssl
```

### 3. 网络隔离

```yaml
# docker-compose.yml
networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true  # 内部网络，不暴露到外部

services:
  api:
    networks:
      - frontend
      - backend

  neo4j:
    networks:
      - backend  # 只在内部网络
```

---

## 高可用配置

### 1. 读写分离

```python
"""读写分离"""

from neo4j import GraphDatabase, WRITE_ACCESS, READ_ACCESS

class HANeo4jClient:
    """高可用Neo4j客户端"""

    def __init__(self, uri: str, user: str, password: str):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def write_query(self, query: str, params: dict = None):
        """写查询（路由到Leader）"""
        with self.driver.session(default_access_mode=WRITE_ACCESS) as session:
            return session.run(query, params or {})

    def read_query(self, query: str, params: dict = None):
        """读查询（路由到Follower）"""
        with self.driver.session(default_access_mode=READ_ACCESS) as session:
            return session.run(query, params or {})

# 使用
client = HANeo4jClient("neo4j://localhost:7687", "neo4j", "password")

# 写操作
client.write_query("CREATE (p:Person {name: 'Zhang San'})")

# 读操作
result = client.read_query("MATCH (p:Person) RETURN p")
```

### 2. 故障转移

```python
"""自动故障转移"""

import time
from typing import List

class FailoverClient:
    """故障转移客户端"""

    def __init__(self, uris: List[str], user: str, password: str):
        self.uris = uris
        self.user = user
        self.password = password
        self.current_uri = 0
        self.driver = self._create_driver()

    def _create_driver(self):
        """创建驱动"""
        return GraphDatabase.driver(
            self.uris[self.current_uri],
            auth=(self.user, self.password)
        )

    def query(self, cypher: str, params: dict = None, max_retries: int = 3):
        """带重试的查询"""
        for attempt in range(max_retries):
            try:
                with self.driver.session() as session:
                    return list(session.run(cypher, params or {}))
            except Exception as e:
                print(f"Query failed (attempt {attempt + 1}): {e}")

                if attempt < max_retries - 1:
                    # 切换到下一个节点
                    self.current_uri = (self.current_uri + 1) % len(self.uris)
                    self.driver.close()
                    self.driver = self._create_driver()
                    time.sleep(1)
                else:
                    raise

# 使用
client = FailoverClient(
    uris=["bolt://core1:7687", "bolt://core2:7687", "bolt://core3:7687"],
    user="neo4j",
    password="password"
)

result = client.query("MATCH (p:Person) RETURN p")
```

---

## 容量规划

### 1. 硬件配置建议

| 数据规模 | CPU | 内存 | 存储 | 网络 |
|---------|-----|------|------|------|
| 小型（<1M节点） | 4核 | 16GB | 100GB SSD | 1Gbps |
| 中型（1M-10M节点） | 8核 | 32GB | 500GB SSD | 10Gbps |
| 大型（10M-100M节点） | 16核 | 64GB | 1TB SSD | 10Gbps |
| 超大型（>100M节点） | 32核+ | 128GB+ | 2TB+ SSD | 10Gbps+ |

### 2. 内存配置

```bash
# neo4j.conf

# 堆内存（用于查询执行）
dbms.memory.heap.initial_size=4G
dbms.memory.heap.max_size=8G

# 页缓存（用于图数据缓存）
dbms.memory.pagecache.size=4G

# 事务状态内存
dbms.memory.transaction.total.max=2G
```

---

## 生产检查清单

### 部署前检查

- [ ] 集群配置正确
- [ ] 索引已创建
- [ ] 备份策略已配置
- [ ] 监控已部署
- [ ] 日志已配置
- [ ] 安全配置已启用
- [ ] 性能测试已完成
- [ ] 故障转移已测试

### 运维检查

- [ ] 每日备份验证
- [ ] 监控指标正常
- [ ] 磁盘空间充足
- [ ] 查询性能正常
- [ ] 集群状态健康
- [ ] 日志无异常
- [ ] 安全审计通过

---

## 故障排查

### 常见问题

**1. 查询慢**
```cypher
// 检查查询计划
PROFILE
MATCH (p:Person {name: 'Zhang San'})
RETURN p

// 检查索引
CALL db.indexes()

// 检查统计信息
CALL db.stats.retrieve('GRAPH')
```

**2. 内存不足**
```bash
# 检查内存使用
docker stats neo4j-core1

# 调整堆内存
NEO4J_dbms_memory_heap_max__size=8G
```

**3. 连接失败**
```python
# 检查连接
from neo4j import GraphDatabase

try:
    driver = GraphDatabase.driver("bolt://localhost:7687", auth=("neo4j", "password"))
    with driver.session() as session:
        result = session.run("RETURN 1")
        print("Connection OK")
except Exception as e:
    print(f"Connection failed: {e}")
```

---

## 总结

### 生产部署关键点

1. **高可用**：集群部署、故障转移
2. **性能优化**：索引、查询优化、批量操作
3. **监控告警**：Prometheus、日志、指标
4. **备份恢复**：定期备份、恢复测试
5. **安全配置**：访问控制、SSL/TLS、网络隔离

### 最佳实践

1. **使用集群**：至少3个核心节点
2. **读写分离**：写操作到Leader，读操作到Follower
3. **定期备份**：每日备份，保留7天
4. **监控告警**：实时监控，及时告警
5. **性能测试**：上线前压力测试
6. **容量规划**：预留50%增长空间

---

**引用来源**：
- [Neo4j运维手册](https://neo4j.com/docs/operations-manual/)
- [Neo4j集群部署](https://neo4j.com/docs/operations-manual/current/clustering/)
- [Neo4j性能优化](https://neo4j.com/docs/operations-manual/current/performance/)
- [Neo4j监控](https://neo4j.com/docs/operations-manual/current/monitoring/)

---

**版本**：v1.0
**最后更新**：2026-02-14
**维护者**：Claude Code
