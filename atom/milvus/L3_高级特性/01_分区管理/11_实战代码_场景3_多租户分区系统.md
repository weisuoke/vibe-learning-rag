# 实战代码 - 场景3: 多租户分区系统

完整演示多租户系统的分区策略，包括租户分区创建、数据隔离、安全检索、租户管理。

---

## 场景描述

**目标**: 构建一个 SaaS 知识库系统，使用分区实现多租户数据隔离

**需求**:
- 为每个租户创建独立分区
- 插入数据时自动路由到租户分区
- 检索时强制租户隔离，防止跨租户访问
- 支持租户的注册、下线、数据迁移
- 监控租户的数据量和使用情况

---

## 完整代码

```python
"""
Milvus 多租户分区系统示例
演示：租户分区创建、数据隔离、安全检索、租户管理
"""

from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType, utility
import numpy as np
from datetime import datetime
from typing import List, Dict, Optional

# ===== 1. 连接到 Milvus =====
print("=== 1. 连接到 Milvus ===")
connections.connect("default", host="localhost", port="19530")
print("✓ 连接成功")

# ===== 2. 创建 Collection =====
print("\n=== 2. 创建 Collection ===")

collection_name = "saas_knowledge_base"

if utility.has_collection(collection_name):
    utility.drop_collection(collection_name)

fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=128),
    FieldSchema(name="document_text", dtype=DataType.VARCHAR, max_length=1000),
    FieldSchema(name="tenant_id", dtype=DataType.VARCHAR, max_length=50),
    FieldSchema(name="doc_type", dtype=DataType.VARCHAR, max_length=50),
    FieldSchema(name="created_at", dtype=DataType.INT64)
]

schema = CollectionSchema(fields, description="SaaS 知识库 - 多租户分区")
collection = Collection(collection_name, schema)
print(f"✓ 创建 Collection: {collection_name}")

# ===== 3. 租户管理器 =====
print("\n=== 3. 租户管理器 ===")

class TenantManager:
    """租户管理器"""

    def __init__(self, collection):
        self.collection = collection
        self.tenants = {}  # 租户信息缓存

    def onboard_tenant(self, tenant_id: str, company_name: str) -> str:
        """租户注册"""
        partition_name = f"tenant_{tenant_id}"

        # 检查租户是否已存在
        if self.collection.has_partition(partition_name):
            print(f"⚠ 租户已存在: {company_name} ({tenant_id})")
            return partition_name

        # 创建租户分区
        self.collection.create_partition(
            partition_name,
            description=f"租户: {company_name}"
        )

        # 缓存租户信息
        self.tenants[tenant_id] = {
            "company_name": company_name,
            "partition_name": partition_name,
            "created_at": datetime.now()
        }

        print(f"✓ 租户注册成功: {company_name} ({tenant_id})")
        return partition_name

    def offboard_tenant(self, tenant_id: str):
        """租户下线（删除分区和数据）"""
        partition_name = f"tenant_{tenant_id}"

        if not self.collection.has_partition(partition_name):
            print(f"⚠ 租户不存在: {tenant_id}")
            return

        # 删除分区（会删除所有数据）
        self.collection.drop_partition(partition_name)

        # 从缓存中移除
        if tenant_id in self.tenants:
            del self.tenants[tenant_id]

        print(f"✓ 租户下线成功: {tenant_id}")

    def get_tenant_stats(self, tenant_id: str) -> Dict:
        """获取租户统计信息"""
        partition_name = f"tenant_{tenant_id}"

        if not self.collection.has_partition(partition_name):
            return None

        partition = self.collection.partition(partition_name)

        stats = {
            "tenant_id": tenant_id,
            "partition_name": partition_name,
            "document_count": partition.num_entities,
            "is_loaded": partition.is_loaded
        }

        return stats

    def list_all_tenants(self) -> List[Dict]:
        """列出所有租户"""
        tenants = []

        for partition in self.collection.partitions:
            if partition.name.startswith("tenant_"):
                tenant_id = partition.name.replace("tenant_", "")
                stats = self.get_tenant_stats(tenant_id)
                if stats:
                    tenants.append(stats)

        return tenants

# 创建租户管理器
tenant_manager = TenantManager(collection)

# ===== 4. 注册租户 =====
print("\n=== 4. 注册租户 ===")

# 注册3个租户
tenants = [
    ("company_a", "科技公司A"),
    ("company_b", "金融公司B"),
    ("company_c", "教育公司C")
]

for tenant_id, company_name in tenants:
    tenant_manager.onboard_tenant(tenant_id, company_name)

# ===== 5. 插入数据到租户分区 =====
print("\n=== 5. 插入数据到租户分区 ===")

def insert_tenant_document(tenant_id: str, doc_text: str, doc_type: str = "general"):
    """插入文档到租户分区"""
    partition_name = f"tenant_{tenant_id}"

    # 检查租户分区是否存在
    if not collection.has_partition(partition_name):
        print(f"⚠ 租户不存在: {tenant_id}")
        return None

    # 生成 Embedding（模拟）
    embedding = np.random.rand(128).tolist()

    # 准备数据
    data = [
        [embedding],
        [doc_text],
        [tenant_id],
        [doc_type],
        [int(datetime.now().timestamp())]
    ]

    # 插入到租户分区
    partition = collection.partition(partition_name)
    result = partition.insert(data)

    return result.primary_keys[0]

# 为每个租户插入文档
print("\n为租户插入文档:")
for tenant_id, company_name in tenants:
    for i in range(100):
        doc_text = f"Document {i} for {company_name}"
        doc_type = np.random.choice(["technical", "business", "legal"])
        doc_id = insert_tenant_document(tenant_id, doc_text, doc_type)

    print(f"✓ 为 {company_name} 插入 100 条文档")

collection.flush()
print("\n✓ 数据已刷新到磁盘")

# ===== 6. 创建索引 =====
print("\n=== 6. 创建索引 ===")

index_params = {
    "index_type": "HNSW",
    "metric_type": "COSINE",
    "params": {"M": 16, "efConstruction": 256}
}

collection.create_index("embedding", index_params)
print("✓ 创建 HNSW 索引")

# ===== 7. 加载租户分区 =====
print("\n=== 7. 加载租户分区 ===")

# 加载所有租户分区
for tenant_id, _ in tenants:
    partition_name = f"tenant_{tenant_id}"
    partition = collection.partition(partition_name)
    partition.load()
    print(f"✓ 加载租户分区: {partition_name}")

# ===== 8. 安全检索（租户隔离）=====
print("\n=== 8. 安全检索（租户隔离）===")

def search_for_tenant(tenant_id: str, query_text: str, limit: int = 5) -> List:
    """为租户检索文档（强制租户隔离）"""
    partition_name = f"tenant_{tenant_id}"

    # 检查租户分区是否存在
    if not collection.has_partition(partition_name):
        print(f"⚠ 租户不存在: {tenant_id}")
        return []

    # 生成查询向量（模拟）
    query_vector = np.random.rand(128).tolist()

    # 强制只检索当前租户的分区
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=limit,
        partition_names=[partition_name],  # 强制租户隔离
        output_fields=["document_text", "tenant_id", "doc_type"]
    )

    return results

# 测试：为 company_a 检索
print("\n测试：为 company_a 检索")
results = search_for_tenant("company_a", "技术文档")

print(f"✓ 检索完成，返回 {len(results[0])} 条结果")
print("\n检索结果:")
for i, hit in enumerate(results[0]):
    print(f"  {i+1}. ID: {hit.id}, 距离: {hit.distance:.4f}")
    print(f"     租户: {hit.entity.get('tenant_id')}")
    print(f"     类型: {hit.entity.get('doc_type')}")
    print(f"     文本: {hit.entity.get('document_text')[:50]}...")

# 验证租户隔离
print("\n验证租户隔离:")
for hit in results[0]:
    tenant_id = hit.entity.get('tenant_id')
    if tenant_id != "company_a":
        print(f"⚠ 警告：检索到其他租户的数据！租户: {tenant_id}")
    else:
        print(f"✓ 租户隔离正确: {tenant_id}")

# ===== 9. 租户统计信息 =====
print("\n=== 9. 租户统计信息 ===")

all_tenants = tenant_manager.list_all_tenants()

print("\n租户统计:")
print(f"{'租户ID':<15} {'分区名':<25} {'文档数量':<10} {'加载状态':<10}")
print("-" * 70)

for tenant in all_tenants:
    status = "已加载" if tenant["is_loaded"] else "未加载"
    print(f"{tenant['tenant_id']:<15} {tenant['partition_name']:<25} {tenant['document_count']:<10} {status:<10}")

# ===== 10. 跨租户检索测试（应该失败）=====
print("\n=== 10. 跨租户检索测试（应该失败）===")

def attempt_cross_tenant_search(tenant_id: str, target_tenant_id: str):
    """尝试跨租户检索（测试安全性）"""
    print(f"\n尝试：租户 {tenant_id} 访问租户 {target_tenant_id} 的数据")

    # 正确的做法：只检索当前租户的分区
    partition_name = f"tenant_{tenant_id}"

    query_vector = np.random.rand(128).tolist()
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=5,
        partition_names=[partition_name],  # 只能访问自己的分区
        output_fields=["tenant_id"]
    )

    # 检查结果
    for hit in results[0]:
        result_tenant = hit.entity.get('tenant_id')
        if result_tenant != tenant_id:
            print(f"⚠ 安全漏洞：访问到其他租户的数据！")
            return False

    print(f"✓ 安全检查通过：只能访问自己的数据")
    return True

# 测试跨租户访问
attempt_cross_tenant_search("company_a", "company_b")

# ===== 11. 租户数据迁移 =====
print("\n=== 11. 租户数据迁移 ===")

def migrate_tenant_data(source_tenant_id: str, target_tenant_id: str):
    """迁移租户数据到另一个租户"""
    source_partition = f"tenant_{source_tenant_id}"
    target_partition = f"tenant_{target_tenant_id}"

    # 检查源租户是否存在
    if not collection.has_partition(source_partition):
        print(f"⚠ 源租户不存在: {source_tenant_id}")
        return

    # 确保目标租户存在
    if not collection.has_partition(target_partition):
        print(f"⚠ 目标租户不存在: {target_tenant_id}")
        return

    # 查询源租户的所有数据
    results = collection.query(
        expr="id >= 0",
        output_fields=["id", "embedding", "document_text", "doc_type"],
        partition_names=[source_partition],
        limit=1000
    )

    if not results:
        print(f"源租户 {source_tenant_id} 没有数据")
        return

    # 插入到目标租户
    target_partition_obj = collection.partition(target_partition)

    embeddings = [r["embedding"] for r in results]
    texts = [r["document_text"] for r in results]
    doc_types = [r["doc_type"] for r in results]
    timestamps = [int(datetime.now().timestamp())] * len(results)
    tenant_ids = [target_tenant_id] * len(results)

    data = [embeddings, texts, tenant_ids, doc_types, timestamps]
    target_partition_obj.insert(data)

    collection.flush()

    print(f"✓ 迁移 {len(results)} 条数据从 {source_tenant_id} 到 {target_tenant_id}")

# 示例：迁移数据（实际场景中谨慎使用）
# migrate_tenant_data("company_a", "company_b")

# ===== 12. 租户下线 =====
print("\n=== 12. 租户下线 ===")

# 下线一个租户（示例）
print("\n下线租户 company_c:")
tenant_manager.offboard_tenant("company_c")

# 验证下线
remaining_tenants = tenant_manager.list_all_tenants()
print(f"\n剩余租户数量: {len(remaining_tenants)}")
for tenant in remaining_tenants:
    print(f"  - {tenant['tenant_id']}")

# ===== 13. 清理资源 =====
print("\n=== 13. 清理资源 ===")

for partition in collection.partitions:
    if partition.is_loaded:
        partition.release()

connections.disconnect("default")
print("✓ 清理完成")

print("\n=== 多租户分区系统演示完成 ===")
```

---

## 运行输出示例

```
=== 1. 连接到 Milvus ===
✓ 连接成功

=== 2. 创建 Collection ===
✓ 创建 Collection: saas_knowledge_base

=== 3. 租户管理器 ===

=== 4. 注册租户 ===
✓ 租户注册成功: 科技公司A (company_a)
✓ 租户注册成功: 金融公司B (company_b)
✓ 租户注册成功: 教育公司C (company_c)

=== 5. 插入数据到租户分区 ===

为租户插入文档:
✓ 为 科技公司A 插入 100 条文档
✓ 为 金融公司B 插入 100 条文档
✓ 为 教育公司C 插入 100 条文档

✓ 数据已刷新到磁盘

=== 6. 创建索引 ===
✓ 创建 HNSW 索引

=== 7. 加载租户分区 ===
✓ 加载租户分区: tenant_company_a
✓ 加载租户分区: tenant_company_b
✓ 加载租户分区: tenant_company_c

=== 8. 安全检索（租户隔离）===

测试：为 company_a 检索
✓ 检索完成，返回 5 条结果

检索结果:
  1. ID: 442844556789123456, 距离: 0.8234
     租户: company_a
     类型: technical
     文本: Document 23 for 科技公司A...
  2. ID: 442844556789123457, 距离: 0.8156
     租户: company_a
     类型: business
     文本: Document 45 for 科技公司A...
  ...

验证租户隔离:
✓ 租户隔离正确: company_a
✓ 租户隔离正确: company_a
✓ 租户隔离正确: company_a
✓ 租户隔离正确: company_a
✓ 租户隔离正确: company_a

=== 9. 租户统计信息 ===

租户统计:
租户ID           分区名                      文档数量      加载状态
----------------------------------------------------------------------
company_a       tenant_company_a          100        已加载
company_b       tenant_company_b          100        已加载
company_c       tenant_company_c          100        已加载

=== 10. 跨租户检索测试（应该失败）===

尝试：租户 company_a 访问租户 company_b 的数据
✓ 安全检查通过：只能访问自己的数据

=== 11. 租户数据迁移 ===

=== 12. 租户下线 ===

下线租户 company_c:
✓ 租户下线成功: company_c

剩余租户数量: 2
  - company_a
  - company_b

=== 13. 清理资源 ===
✓ 清理完成

=== 多租户分区系统演示完成 ===
```

---

## 关键知识点

### 1. 租户分区命名

```python
# 租户分区命名规范
partition_name = f"tenant_{tenant_id}"

# 示例
# tenant_company_a
# tenant_company_b
# tenant_user_12345
```

### 2. 租户注册

```python
def onboard_tenant(tenant_id, company_name):
    """租户注册"""
    partition_name = f"tenant_{tenant_id}"

    # 创建租户分区
    collection.create_partition(
        partition_name,
        description=f"租户: {company_name}"
    )

    return partition_name
```

### 3. 强制租户隔离

```python
def search_for_tenant(tenant_id, query_vector):
    """强制租户隔离的检索"""
    partition_name = f"tenant_{tenant_id}"

    # 强制只检索当前租户的分区
    results = collection.search(
        query_vector,
        partition_names=[partition_name],  # 关键：强制指定租户分区
        limit=10
    )

    return results
```

### 4. 租户下线

```python
def offboard_tenant(tenant_id):
    """租户下线"""
    partition_name = f"tenant_{tenant_id}"

    # 删除分区（会删除所有数据）
    collection.drop_partition(partition_name)
```

---

## 安全性保障

### 1. 应用层隔离

```python
# 在应用层强制检查租户ID
def search_with_auth(user_tenant_id, query_vector):
    """带认证的检索"""
    # 从用户会话中获取租户ID
    tenant_id = get_tenant_from_session()

    # 验证租户ID
    if tenant_id != user_tenant_id:
        raise PermissionError("无权访问其他租户的数据")

    # 检索
    return search_for_tenant(tenant_id, query_vector)
```

### 2. 存储层隔离

```python
# 通过分区实现存储层隔离
# 即使应用层有bug，也无法跨租户访问数据
results = collection.search(
    query_vector,
    partition_names=[f"tenant_{tenant_id}"]  # 物理隔离
)
```

### 3. 审计日志

```python
def search_with_audit(tenant_id, query_vector):
    """带审计的检索"""
    # 记录审计日志
    log_audit({
        "action": "search",
        "tenant_id": tenant_id,
        "timestamp": datetime.now()
    })

    # 执行检索
    return search_for_tenant(tenant_id, query_vector)
```

---

## 多租户策略对比

| 策略 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **分区隔离** | 物理隔离，安全性高 | 租户数量受限 | 中小规模（< 200租户） |
| **标量过滤** | 灵活，租户数量无限 | 安全性依赖应用层 | 大规模（> 200租户） |
| **独立Collection** | 完全隔离，性能最优 | 管理复杂，资源占用大 | 大客户、高安全要求 |

---

## 总结

本示例演示了多租户分区系统的完整实战：

1. ✅ 租户注册和分区创建
2. ✅ 数据插入到租户分区
3. ✅ 强制租户隔离的安全检索
4. ✅ 租户统计信息
5. ✅ 跨租户访问测试（安全验证）
6. ✅ 租户数据迁移
7. ✅ 租户下线

多租户分区是 SaaS 系统的核心架构模式，通过分区实现数据隔离和安全保障。
