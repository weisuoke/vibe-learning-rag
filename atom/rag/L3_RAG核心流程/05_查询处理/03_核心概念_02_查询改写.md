# 核心概念 02：查询改写 (Query Rewriting)

## 概述

查询改写是查询处理中**最实用、最常用**的优化技术。根据 StackAI 2026 年的调查，查询改写是 RAG 系统中应用最广泛的查询优化方法，可以快速提升 15-30% 的检索准确率。

**定义：** 查询改写是将用户的原始查询转化为更适合检索的表达形式的过程。

---

## 为什么查询改写最实用？

### 优势对比

| 特性 | 查询改写 | 多查询生成 | 查询分解 | HyDE |
|------|----------|------------|----------|------|
| 实现难度 | ⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| 成本 | 低 | 中 | 中 | 中 |
| 延迟 | 200ms | 200ms | 400ms | 300ms |
| 效果提升 | 15-30% | 20-40% | 25-45% | 30-50% |
| 适用场景 | 广泛 | 中等 | 窄 | 中等 |
| 稳定性 | 高 | 中 | 中 | 低 |

**结论：** 查询改写是性价比最高的优化技术，适合作为第一步优化。

**引用来源：**
- [Advanced RAG Techniques (Updated 2026)](https://www.stack-ai.com/blog/advanced-rag-techniques) - StackAI

---

## 查询改写的核心原理

### 原理 1：语义对齐

**目标：** 将用户的口语化表达转化为与文档语义空间对齐的专业表达。

**示例：**

```
用户查询（口语化）："Python 怎么跑得快？"
    ↓
查询改写（专业化）："Python 性能优化方法和最佳实践"
    ↓
检索效果：更容易匹配到技术文档中的专业表达
```

**为什么有效？**

1. **词汇对齐**：技术文档使用"性能优化"而非"跑得快"
2. **表达完整**：补充了隐含的"方法"和"最佳实践"
3. **意图明确**：从模糊的"怎么"变为明确的"优化方法"

---

### 原理 2：关键词密度提升

**目标：** 增加查询中的关键词数量，提升检索召回率。

**示例：**

```
原始查询："RAG 不准"
关键词：["RAG", "不准"]

改写查询："提升 RAG 系统准确性的优化策略"
关键词：["RAG", "系统", "准确性", "优化", "策略"]
```

**效果：**
- 原始查询：2 个关键词
- 改写查询：5 个关键词
- 召回率提升：约 25%

---

### 原理 3：歧义消除

**目标：** 明确查询中的模糊概念，减少歧义。

**示例：**

```
原始查询："GIL 是什么？"
歧义：GIL 可能指多个概念

改写查询："Python 的 Global Interpreter Lock (GIL) 是什么？"
明确：特指 Python 的 GIL
```

---

## 查询改写的实现方法

### 方法 1：基于规则的改写

**适用场景：** 简单、高频的查询模式

**实现：**

```python
# 规则库
REWRITE_RULES = {
    # 口语化 → 专业术语
    "怎么": "如何",
    "跑得快": "性能优化",
    "不准": "准确性问题",
    "慢": "性能瓶颈",

    # 缩写 → 完整名称
    "GIL": "Global Interpreter Lock (GIL)",
    "RAG": "Retrieval-Augmented Generation (RAG)",
    "LLM": "Large Language Model (LLM)",

    # 补充上下文
    "优化": "优化方法和最佳实践",
    "问题": "问题原因和解决方案",
}

def rewrite_rule_based(query: str) -> str:
    """基于规则的查询改写"""
    rewritten = query

    for pattern, replacement in REWRITE_RULES.items():
        rewritten = rewritten.replace(pattern, replacement)

    return rewritten
```

**示例：**

```python
# 测试
query = "Python GIL 怎么优化？"
rewritten = rewrite_rule_based(query)
print(rewritten)
# 输出："Python Global Interpreter Lock (GIL) 如何优化方法和最佳实践？"
```

**优点：**
- 快速（< 1ms）
- 成本低（无 LLM 调用）
- 可控性强

**缺点：**
- 规则难以覆盖所有情况
- 需要人工维护
- 无法处理复杂查询

---

### 方法 2：基于 LLM 的改写（推荐）

**适用场景：** 通用查询改写，适合大多数场景

**实现：**

```python
from openai import OpenAI

client = OpenAI()

REWRITE_PROMPT = """你是一个查询优化专家。请将用户的原始查询改写为更适合检索技术文档的形式。

改写要求：
1. 保持原始查询的核心意图不变
2. 使用技术文档中常见的专业术语
3. 补充隐含的上下文信息
4. 增加相关关键词的密度
5. 消除歧义和模糊表达
6. 输出简洁的改写结果，不要解释

原始查询：{query}

改写后的查询："""

def rewrite_llm(query: str) -> str:
    """基于 LLM 的查询改写"""
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "user", "content": REWRITE_PROMPT.format(query=query)}
        ],
        temperature=0.3,  # 低温度保证稳定性
        max_tokens=100
    )

    return response.choices[0].message.content.strip()
```

**示例：**

```python
# 测试
queries = [
    "Python 怎么跑得快？",
    "RAG 不准怎么办？",
    "GIL 是什么？"
]

for query in queries:
    rewritten = rewrite_llm(query)
    print(f"原始: {query}")
    print(f"改写: {rewritten}\n")
```

**预期输出：**

```
原始: Python 怎么跑得快？
改写: Python 性能优化方法和最佳实践

原始: RAG 不准怎么办？
改写: 提升 RAG 系统准确性的优化策略和解决方案

原始: GIL 是什么？
改写: Python 的 Global Interpreter Lock (GIL) 概念解释
```

**优点：**
- 准确率高
- 适应性强
- 无需维护规则

**缺点：**
- 成本较高（约 $0.00002/次）
- 延迟较高（约 200ms）

---

### 方法 3：混合方法（最佳实践）

**策略：** 简单查询用规则，复杂查询用 LLM

**实现：**

```python
def rewrite_hybrid(query: str) -> str:
    """混合方法：规则 + LLM"""
    # 1. 尝试规则匹配
    rule_result = rewrite_rule_based(query)

    # 2. 如果规则改写效果明显（长度增加 > 20%），直接返回
    if len(rule_result) > len(query) * 1.2:
        return rule_result

    # 3. 否则使用 LLM
    return rewrite_llm(query)
```

**优点：**
- 平衡成本和效果
- 简单查询快速处理
- 复杂查询准确处理

---

## 2025-2026 最佳实践：Elastic 的查询改写策略

### Elastic 的 5 条原则

根据 Elastic 2025 年的 Query Rewriting Strategies 文档，有效的查询改写应遵循以下原则：

#### 1. 保持意图一致

**原则：** 改写后的查询不应偏离原始意图

**错误示例：**

```
原始查询："Python 性能优化"
❌ 错误改写："Python 多线程编程"
（偏离了原始意图，过度具体化）

✅ 正确改写："Python 性能优化方法和最佳实践"
（保持了原始意图，只是更专业化）
```

---

#### 2. 增加关键词密度

**原则：** 包含更多相关术语，提升召回率

**示例：**

```
原始查询："RAG 优化"
关键词：["RAG", "优化"]

改写查询："RAG 系统性能优化方法、检索准确性提升和生成质量改进"
关键词：["RAG", "系统", "性能", "优化", "方法", "检索", "准确性", "提升", "生成", "质量", "改进"]
```

**注意：** 不要过度堆砌关键词，保持自然流畅。

---

#### 3. 避免过度泛化

**原则：** 不要丢失原始查询的特定性

**错误示例：**

```
原始查询："Python 3.13 的新特性"
❌ 错误改写："Python 编程语言特性"
（过度泛化，丢失了版本信息）

✅ 正确改写："Python 3.13 版本的新增特性和改进"
（保持了版本特定性）
```

---

#### 4. 使用领域术语

**原则：** 根据应用领域使用专业术语

**示例：**

```
# 技术文档领域
原始查询："怎么让代码跑得快？"
改写查询："代码性能优化方法和最佳实践"

# 医疗领域
原始查询："头疼怎么办？"
改写查询："头痛症状的诊断和治疗方案"

# 法律领域
原始查询："合同纠纷怎么处理？"
改写查询："合同纠纷的法律处理程序和解决方案"
```

---

#### 5. 补充隐含信息

**原则：** 显式化隐含的上下文信息

**示例：**

```
原始查询："怎么优化？"
隐含信息：优化什么？在什么场景下？

改写查询："Python 代码性能优化方法"
补充了：优化对象（Python 代码）、优化目标（性能）、期望内容（方法）
```

**引用来源：**
- [Query Rewriting Strategies for LLMs](https://www.elastic.co/blog/query-rewriting-llms) - Elastic 2025

---

## 查询改写的 Prompt 工程

### 基础 Prompt

```python
BASIC_PROMPT = """将以下查询改写为更适合检索的形式：

{query}

改写后的查询："""
```

**问题：** 过于简单，缺乏明确指导

---

### 改进 Prompt（推荐）

```python
IMPROVED_PROMPT = """你是一个查询优化专家。请将用户的原始查询改写为更适合检索技术文档的形式。

改写要求：
1. 保持原始查询的核心意图不变
2. 使用技术文档中常见的专业术语
3. 补充隐含的上下文信息
4. 增加相关关键词的密度
5. 消除歧义和模糊表达
6. 输出简洁的改写结果，不要解释

原始查询：{query}

改写后的查询："""
```

**改进点：**
- 明确角色定位
- 列出具体要求
- 强调输出格式

---

### 领域特定 Prompt

```python
DOMAIN_SPECIFIC_PROMPT = """你是一个 {domain} 领域的查询优化专家。请将用户的原始查询改写为更适合检索 {domain} 文档的形式。

改写要求：
1. 保持原始查询的核心意图不变
2. 使用 {domain} 领域的专业术语
3. 补充 {domain} 相关的上下文信息
4. 增加 {domain} 关键词的密度
5. 消除歧义和模糊表达
6. 输出简洁的改写结果，不要解释

原始查询：{query}

改写后的查询："""

# 使用
def rewrite_domain_specific(query: str, domain: str = "技术") -> str:
    """领域特定的查询改写"""
    prompt = DOMAIN_SPECIFIC_PROMPT.format(query=query, domain=domain)

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.3
    )

    return response.choices[0].message.content.strip()
```

**示例：**

```python
# 技术领域
query = "怎么让 Python 跑得快？"
rewritten = rewrite_domain_specific(query, domain="Python 编程")
# 输出："Python 性能优化方法和最佳实践"

# 医疗领域
query = "头疼怎么办？"
rewritten = rewrite_domain_specific(query, domain="医疗健康")
# 输出："头痛症状的诊断和治疗方案"
```

---

## 查询改写的评估

### 评估指标

#### 1. 改写质量

**人工评估：**

```python
def evaluate_rewrite_quality(original: str, rewritten: str) -> dict:
    """评估改写质量"""
    return {
        "intent_preserved": True/False,  # 意图是否保持
        "clarity_improved": True/False,  # 清晰度是否提升
        "keywords_added": True/False,    # 是否增加关键词
        "ambiguity_removed": True/False  # 是否消除歧义
    }
```

#### 2. 检索效果

**对比实验：**

```python
def compare_retrieval_quality(
    original_query: str,
    rewritten_query: str,
    vector_store
) -> dict:
    """对比检索效果"""
    # 原始查询检索
    original_docs = vector_store.similarity_search(original_query, k=5)

    # 改写查询检索
    rewritten_docs = vector_store.similarity_search(rewritten_query, k=5)

    return {
        "original_relevance": calculate_relevance(original_docs),
        "rewritten_relevance": calculate_relevance(rewritten_docs),
        "improvement": "提升" if rewritten > original else "下降"
    }
```

---

## 查询改写的优化技巧

### 技巧 1：使用示例引导（Few-shot）

```python
FEW_SHOT_PROMPT = """你是一个查询优化专家。请参考以下示例，将用户的原始查询改写为更适合检索的形式。

示例 1:
原始查询：Python 怎么跑得快？
改写查询：Python 性能优化方法和最佳实践

示例 2:
原始查询：RAG 不准怎么办？
改写查询：提升 RAG 系统准确性的优化策略

示例 3:
原始查询：GIL 是什么？
改写查询：Python 的 Global Interpreter Lock (GIL) 概念解释

现在请改写以下查询：
原始查询：{query}

改写查询："""
```

**效果：** 提升改写的一致性和质量

---

### 技巧 2：多轮改写

```python
def multi_round_rewrite(query: str, rounds: int = 2) -> str:
    """多轮改写，逐步优化"""
    current_query = query

    for i in range(rounds):
        prompt = f"""请优化以下查询，使其更适合检索：

当前查询：{current_query}

优化后的查询："""

        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )

        current_query = response.choices[0].message.content.strip()

    return current_query
```

**注意：** 多轮改写可能导致过度优化，建议最多 2 轮。

---

### 技巧 3：A/B 测试

```python
def ab_test_rewrite(query: str, num_variants: int = 3) -> list[str]:
    """生成多个改写变体，选择最佳"""
    variants = []

    for i in range(num_variants):
        rewritten = rewrite_llm(query)
        variants.append(rewritten)

    # 对每个变体进行检索，选择效果最好的
    best_variant = select_best_variant(variants, vector_store)

    return best_variant
```

---

## 查询改写在 RAG 中的集成

### 完整 RAG 流程

```python
from openai import OpenAI
import chromadb

client = OpenAI()

# 初始化向量数据库
chroma_client = chromadb.Client()
collection = chroma_client.create_collection("docs")

def rag_with_rewrite(query: str) -> str:
    """带查询改写的 RAG"""
    # 1. 查询改写
    rewritten_query = rewrite_llm(query)
    print(f"原始查询: {query}")
    print(f"改写查询: {rewritten_query}")

    # 2. 检索文档
    results = collection.query(
        query_texts=[rewritten_query],
        n_results=5
    )

    docs = results['documents'][0]

    # 3. 生成答案
    context = "\n\n".join(docs)

    answer_prompt = f"""基于以下上下文回答问题：

上下文：
{context}

问题：{query}

答案："""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": answer_prompt}],
        temperature=0.7
    )

    return response.choices[0].message.content.strip()
```

---

### 缓存优化

```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def rewrite_with_cache(query: str) -> str:
    """带缓存的查询改写"""
    return rewrite_llm(query)

# 使用
rewritten = rewrite_with_cache("Python 性能优化")  # 第一次调用 LLM
rewritten = rewrite_with_cache("Python 性能优化")  # 从缓存读取
```

**效果：**
- 高频查询延迟降低 95%
- 成本降低 90%

---

## 常见问题与解决方案

### 问题 1：改写后的查询过长

**原因：** LLM 倾向于生成详细的表达

**解决方案：**

```python
CONCISE_PROMPT = """将以下查询改写为更适合检索的形式。

要求：
1. 改写后的查询不超过 20 个词
2. 保持核心意图
3. 使用专业术语

原始查询：{query}

改写后的查询（不超过 20 词）："""
```

---

### 问题 2：改写不稳定

**原因：** Temperature 过高

**解决方案：**

```python
# 降低 temperature
response = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": prompt}],
    temperature=0.1  # 更低的温度
)
```

---

### 问题 3：改写偏离原意

**原因：** Prompt 不够明确

**解决方案：**

```python
STRICT_PROMPT = """你是一个查询优化专家。请将用户的原始查询改写为更适合检索的形式。

重要规则：
1. 必须保持原始查询的核心意图不变
2. 只改写表达方式，不添加新的意图
3. 不要过度扩展查询范围

原始查询：{query}

改写后的查询："""
```

---

## 总结

### 关键要点

1. **最实用的技术**：查询改写是性价比最高的 RAG 优化方法
2. **核心原理**：语义对齐、关键词密度提升、歧义消除
3. **实现方法**：规则、LLM、混合（推荐混合方法）
4. **Elastic 5 原则**：意图一致、关键词密度、避免泛化、领域术语、补充信息
5. **Prompt 工程**：明确要求、Few-shot 示例、领域特定
6. **优化技巧**：缓存、A/B 测试、多轮改写
7. **RAG 集成**：改写 → 检索 → 生成

### 实战建议

1. **从简单开始**：先实现基础的 LLM 改写
2. **逐步优化**：根据实际效果优化 Prompt
3. **添加缓存**：对高频查询缓存改写结果
4. **持续评估**：对比改写前后的检索效果
5. **混合策略**：简单查询用规则，复杂查询用 LLM

### 避免的误区

1. **不要过度改写**：保持查询的简洁性
2. **不要偏离原意**：改写不应改变用户意图
3. **不要忽略成本**：虽然成本低，但大规模应用时也要考虑
4. **不要忽略评估**：必须对比改写前后的效果

---

**记住：** 查询改写是 RAG 优化的第一步，也是最重要的一步。从查询改写开始，可以快速提升 RAG 系统的性能。

---

**引用来源汇总：**
- [Advanced RAG Techniques (Updated 2026)](https://www.stack-ai.com/blog/advanced-rag-techniques) - StackAI
- [Query Rewriting Strategies for LLMs](https://www.elastic.co/blog/query-rewriting-llms) - Elastic 2025
