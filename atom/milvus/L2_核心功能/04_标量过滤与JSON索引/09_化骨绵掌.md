# 化骨绵掌

> 10个2分钟知识卡片，系统掌握标量过滤

---

## 卡片1：直觉理解

**一句话：** 标量过滤就是在向量检索时添加"if条件"，只返回同时满足语义相似和业务规则的结果。

**举例：**
```python
# 没有标量过滤：找相似的文档
results = search(query_vector)  # 返回语义相似的文档

# 有标量过滤：找相似且符合条件的文档
results = search(query_vector, expr="year == 2024")  # 返回语义相似且2024年的文档
```

**应用：** 在RAG系统中，用户查询"最新的AI技术"，标量过滤确保返回的文档既语义相关又是最新的。

---

## 卡片2：形式化定义

**一句话：** 标量过滤是一个布尔表达式，对Collection中的每条记录进行判断，只有表达式为true的记录才参与向量检索。

**举例：**
```python
expr = "year == 2024 and category == 'tech'"
# 对每条记录r：
# if (r.year == 2024 and r.category == 'tech'):
#     参与向量检索
# else:
#     跳过
```

**应用：** 理解这个定义，就能明白为什么标量过滤能提升性能——它减少了需要计算向量距离的记录数量。

---

## 卡片3：表达式语法核心

**一句话：** 表达式语法与Python高度一致，使用`==`而非`=`，字符串用单引号，布尔值用小写。

**举例：**
```python
# 比较运算符
expr = "year == 2024"      # 等于（注意是==）
expr = "price > 100"       # 大于

# 成员检查
expr = "category in ['tech', 'ai']"  # 在列表中

# 模糊匹配
expr = "title like 'Python%'"  # 以Python开头
```

**应用：** 掌握这些基础语法，就能构建90%的过滤条件。

---

## 卡片4：布尔运算符

**一句话：** 使用`and`/`or`/`not`组合多个条件，优先级是not > and > or，建议用括号明确优先级。

**举例：**
```python
# AND：所有条件都必须满足
expr = "year == 2024 and category == 'tech'"

# OR：至少一个条件满足
expr = "category == 'tech' or category == 'ai'"

# 混合：使用括号明确优先级
expr = "(category == 'tech' or category == 'ai') and year == 2024"
```

**应用：** 复杂业务规则需要组合多个条件，掌握布尔运算符是关键。

---

## 卡片5：数据类型匹配

**一句话：** 过滤值的类型必须与字段类型匹配，整数用数字，字符串用单引号，布尔值用小写true/false。

**举例：**
```python
# ✅ 正确：类型匹配
expr = "year == 2024"              # INT字段，数字值
expr = "category == 'tech'"        # VARCHAR字段，单引号字符串
expr = "is_published == true"      # BOOL字段，小写布尔值

# ❌ 错误：类型不匹配
expr = "year == '2024'"            # 字符串不能匹配整数字段
expr = "is_published == True"      # 大写布尔值不支持
```

**应用：** 类型不匹配是最常见的错误，记住这个规则能避免90%的问题。

---

## 卡片6：执行顺序

**一句话：** Milvus采用"先过滤后检索"策略，先通过标量过滤缩小候选集，再在候选集上执行向量检索。

**举例：**
```python
# 100万条文档，其中10万条year == 2024
results = search(query_vector, expr="year == 2024")

# 执行顺序：
# 1. 标量过滤：100万 → 10万（快速）
# 2. 向量检索：计算10万次距离（较慢）
# 3. 返回Top 10

# 而不是：
# 1. 向量检索：计算100万次距离（非常慢）
# 2. 标量过滤：从结果中筛选
```

**应用：** 理解执行顺序，就能明白为什么标量过滤能提升性能。

---

## 卡片7：标量索引

**一句话：** 为高频过滤字段创建标量索引，可以将过滤复杂度从O(n)降低到O(log n)或O(1)，性能提升10倍以上。

**举例：**
```python
# 创建标量索引
collection.create_index(
    field_name="year",
    index_name="year_index"
)

# 有索引：快速定位year == 2024的记录
# 无索引：需要扫描所有记录
```

**应用：** 在生产环境中，为user_id、category、year等高频过滤字段创建索引是必须的。

---

## 卡片8：性能优化策略

**一句话：** 优化性能的四个层面：创建索引、提高选择性、简化表达式、优化数据建模。

**举例：**
```python
# 1. 创建索引
collection.create_index(field_name="user_id")

# 2. 高选择性条件在前
expr = "user_id == 12345 and category == 'tech'"  # user_id选择性高

# 3. 使用in代替多个or
expr = "category in ['tech', 'ai']"  # 比多个or更高效

# 4. 统一数据格式
# 插入时统一转小写，避免大小写问题
```

**应用：** 这四个策略能解决大部分性能问题。

---

## 卡片9：RAG混合检索

**一句话：** 在RAG系统中，标量过滤用于实现多租户隔离、时间范围检索、权限控制等核心功能。

**举例：**
```python
# 多租户知识库
expr = f"user_id == {current_user_id}"

# 时间范围检索
expr = f"publish_time >= {start_time} and publish_time <= {end_time}"

# 权限控制
expr = f"(is_public == true or owner_id == {user_id})"

# 组合使用
expr = f"""
    user_id == {user_id}
    and publish_time >= {start_time}
    and category in ['tech', 'ai']
"""
```

**应用：** RAG系统的每一次检索都是向量相似度+标量过滤的混合查询。

---

## 卡片10：常见误区总结

**一句话：** 避开三大误区：标量过滤不影响性能（错）、标量过滤在检索之后执行（错）、可以在表达式中使用向量字段（错）。

**举例：**
```python
# 误区1：标量过滤不影响性能
# 真相：没有索引时性能很差，有索引时性能很好

# 误区2：标量过滤在检索之后执行
# 真相：先过滤后检索，减少向量计算量

# 误区3：可以在表达式中使用向量字段
# 真相：表达式只能用于标量字段
expr = "year == 2024"  # ✅ 标量字段
expr = "embedding == [...]"  # ❌ 向量字段不支持
```

**应用：** 理解这些误区，能避免90%的错误和性能问题。

---

## 学习检查清单

完成10个卡片学习后，检查是否掌握：

- [ ] 能用一句话解释标量过滤的本质
- [ ] 理解"先过滤后检索"的执行顺序
- [ ] 掌握表达式语法的核心规则
- [ ] 能使用and/or/not组合复杂条件
- [ ] 理解数据类型匹配的重要性
- [ ] 知道何时需要创建标量索引
- [ ] 能构建动态过滤表达式
- [ ] 理解标量过滤在RAG中的应用
- [ ] 能优化标量过滤的性能
- [ ] 避开常见的三大误区

---

## 进阶学习路径

掌握这10个卡片后，建议：

1. **实践代码**：运行4个实战场景，从基础到RAG应用
2. **深入原理**：学习标量索引的实现原理（B树、哈希表）
3. **性能调优**：在实际项目中测试不同索引策略的性能
4. **架构设计**：设计支持多租户、权限控制的RAG系统

---

## 快速参考

| 概念 | 核心要点 |
|------|---------|
| 本质 | 在向量检索时添加属性条件 |
| 语法 | 类似Python，`==`而非`=` |
| 执行 | 先过滤后检索 |
| 性能 | 需要标量索引优化 |
| 应用 | RAG混合检索的核心 |
