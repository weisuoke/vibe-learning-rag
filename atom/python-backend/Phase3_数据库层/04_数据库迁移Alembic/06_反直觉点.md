# 反直觉点

### 误区1：autogenerate 能检测所有变更 ❌

**为什么错？**

Alembic 的 `--autogenerate` 功能虽然强大，但**不是万能的**，有很多变更它无法自动检测：

**无法检测的变更：**
1. **表名或列名的重命名**（会被识别为删除+创建）
2. **索引名称的变更**
3. **约束的变更**（如 CHECK 约束）
4. **枚举类型的变更**（PostgreSQL ENUM）
5. **数据库特定的类型**（如 PostgreSQL 的 JSONB、数组类型）
6. **触发器、存储过程、视图**
7. **数据迁移**（修改现有数据）

**为什么人们容易这样错？**

因为 autogenerate 在大多数简单场景下工作得很好（加表、加字段、删字段），让人误以为它能处理所有情况。就像自动驾驶在高速公路上很好用，但在复杂路况下还是需要人工接管。

**正确理解：**

```python
# 场景：重命名字段
# 旧模型
class User(Base):
    username = Column(String)

# 新模型
class User(Base):
    name = Column(String)  # 重命名 username -> name

# autogenerate 会生成（错误）：
def upgrade():
    op.drop_column('users', 'username')  # 删除旧字段
    op.add_column('users', sa.Column('name', sa.String()))  # 添加新字段
    # 问题：数据丢失了！

# 正确的手动编辑：
def upgrade():
    op.alter_column('users', 'username', new_column_name='name')  # 重命名字段
    # 数据保留！
```

**实际应用中的处理：**

```python
# 1. 运行 autogenerate
alembic revision --autogenerate -m "rename username to name"

# 2. 检查生成的迁移脚本
# versions/abc123_rename_username_to_name.py

# 3. 手动修改迁移脚本
def upgrade():
    # 修改前：
    # op.drop_column('users', 'username')
    # op.add_column('users', sa.Column('name', sa.String()))

    # 修改后：
    op.alter_column('users', 'username', new_column_name='name')

def downgrade():
    op.alter_column('users', 'name', new_column_name='username')
```

**记住：**
> autogenerate 是助手，不是替代品。生成后必须人工检查和修改。

---

### 误区2：迁移脚本可以随意修改 ❌

**为什么错？**

一旦迁移脚本被应用到数据库（尤其是生产环境），**就不应该再修改它**。修改已应用的迁移脚本会导致：

1. **版本不一致**：不同环境的数据库结构不同
2. **无法追溯**：不知道哪个环境应用了哪个版本
3. **回滚失败**：downgrade 函数可能不匹配实际数据库状态

**为什么人们容易这样错？**

因为在本地开发时，修改迁移脚本很方便，而且看起来"没问题"。就像在草稿纸上涂改很容易，但在已经发布的书上涂改就会造成混乱。

**正确理解：**

```python
# 错误做法：修改已应用的迁移
# versions/abc123_add_avatar.py（已应用到生产环境）
def upgrade():
    op.add_column('users', sa.Column('avatar', sa.String()))
    # 后来发现需要加索引，直接修改这个文件：
    op.create_index('idx_user_avatar', 'users', ['avatar'])  # ❌ 错误！

# 问题：
# - 生产环境已经应用了旧版本（没有索引）
# - 新环境应用的是新版本（有索引）
# - 两个环境的数据库结构不一致！

# 正确做法：创建新迁移
# versions/abc123_add_avatar.py（不修改）
def upgrade():
    op.add_column('users', sa.Column('avatar', sa.String()))

# versions/def456_add_avatar_index.py（新迁移）
def upgrade():
    op.create_index('idx_user_avatar', 'users', ['avatar'])
```

**特殊情况：本地开发时可以修改**

```bash
# 如果迁移还没有推送到远程仓库，可以修改
# 1. 回滚迁移
alembic downgrade -1

# 2. 删除迁移文件
rm alembic/versions/abc123_add_avatar.py

# 3. 重新生成迁移
alembic revision --autogenerate -m "add avatar with index"

# 4. 应用新迁移
alembic upgrade head
```

**记住：**
> 迁移脚本一旦推送到远程仓库或应用到生产环境，就应该视为不可变（immutable）。

---

### 误区3：downgrade 总是安全的 ❌

**为什么错？**

虽然 Alembic 支持回滚（downgrade），但**回滚并不总是安全的**，尤其是涉及数据删除的操作：

**危险的回滚场景：**
1. **删除列**：回滚会重新创建列，但数据已丢失
2. **删除表**：回滚会重新创建表，但数据已丢失
3. **修改列类型**：回滚可能导致数据截断或转换失败
4. **删除索引**：回滚会重新创建索引，但可能很慢（大表）

**为什么人们容易这样错？**

因为 Alembic 的 upgrade/downgrade 看起来是对称的，让人误以为回滚总是能恢复到之前的状态。就像以为"撤销"按钮能恢复所有操作，但有些操作（如删除文件）是不可逆的。

**正确理解：**

```python
# 场景：删除不再使用的字段
# versions/abc123_remove_old_field.py
def upgrade():
    op.drop_column('users', 'old_field')  # 删除字段

def downgrade():
    op.add_column('users', sa.Column('old_field', sa.String()))  # 重新创建字段
    # 问题：字段重新创建了，但数据丢失了！

# 更安全的做法：分两步迁移
# 第1步：标记字段为可空（保留数据）
# versions/abc123_deprecate_old_field.py
def upgrade():
    op.alter_column('users', 'old_field', nullable=True)
    # 在代码中停止使用这个字段

def downgrade():
    op.alter_column('users', 'old_field', nullable=False)

# 第2步：几周后确认没问题，再删除字段
# versions/def456_remove_old_field.py
def upgrade():
    op.drop_column('users', 'old_field')

def downgrade():
    # 明确标注：回滚会丢失数据
    op.add_column('users', sa.Column('old_field', sa.String()))
    # 警告：数据已丢失，无法恢复
```

**生产环境的回滚策略：**

```python
# 1. 只回滚 schema 变更，不回滚数据删除
def upgrade():
    # 添加新字段
    op.add_column('users', sa.Column('new_field', sa.String()))

def downgrade():
    # 回滚：删除新字段（安全，因为是新字段）
    op.drop_column('users', 'new_field')

# 2. 对于危险操作，downgrade 抛出异常
def upgrade():
    op.drop_column('users', 'important_field')

def downgrade():
    raise Exception("Cannot downgrade: data loss is irreversible")
    # 或者：
    # op.add_column('users', sa.Column('important_field', sa.String()))
    # print("WARNING: Data has been lost and cannot be recovered")
```

**记住：**
> downgrade 只能回滚 schema 变更，无法恢复已删除的数据。生产环境应该避免回滚，而是通过新迁移修复问题。

---

## 其他常见误区

### 误区4：迁移脚本的顺序不重要 ❌

**错误观点：** "迁移脚本只要都执行了就行，顺序无所谓"

**正确理解：**
- 迁移脚本有严格的依赖顺序（版本链）
- 必须按照 `down_revision` 指定的顺序执行
- 跳过中间版本会导致数据库状态不一致

```python
# 版本链：
# None -> abc123 -> def456 -> ghi789

# 错误：直接跳到 ghi789
alembic upgrade ghi789  # ❌ 会报错

# 正确：按顺序升级
alembic upgrade head  # ✅ 自动按顺序执行所有迁移
```

### 误区5：alembic_version 表可以手动修改 ❌

**错误观点：** "如果版本不对，直接改 alembic_version 表就行"

**正确理解：**
- `alembic_version` 表是 Alembic 的内部状态
- 手动修改会导致 Alembic 认为某些迁移已执行（实际未执行）
- 应该使用 `alembic stamp` 命令修改版本

```bash
# 错误：手动修改数据库
UPDATE alembic_version SET version_num = 'abc123';  # ❌

# 正确：使用 alembic stamp
alembic stamp abc123  # ✅
```

### 误区6：生产环境可以直接运行 autogenerate ❌

**错误观点：** "在生产环境直接运行 `alembic revision --autogenerate` 很方便"

**正确理解：**
- autogenerate 需要连接数据库并读取当前 schema
- 在生产环境运行可能生成错误的迁移（如果生产环境和代码不同步）
- 应该在开发环境生成迁移，测试后再应用到生产环境

```bash
# 错误流程：
# 1. 在生产环境运行 autogenerate
ssh production-server
alembic revision --autogenerate -m "add field"  # ❌ 危险！

# 正确流程：
# 1. 在开发环境生成迁移
alembic revision --autogenerate -m "add field"

# 2. 检查并测试迁移
alembic upgrade head  # 在开发环境测试

# 3. 提交到 git
git add versions/abc123_add_field.py
git commit -m "add field migration"
git push

# 4. 在生产环境应用迁移
ssh production-server
git pull
alembic upgrade head  # ✅ 只应用迁移，不生成
```

### 误区7：迁移脚本只能用 op.* 函数 ❌

**错误观点：** "迁移脚本只能用 Alembic 提供的 op.* 函数"

**正确理解：**
- 迁移脚本是普通的 Python 代码
- 可以使用 `op.execute()` 执行原生 SQL
- 可以使用 SQLAlchemy 的 ORM 进行数据迁移

```python
# 场景：迁移数据
def upgrade():
    # 1. 添加新字段
    op.add_column('users', sa.Column('full_name', sa.String()))

    # 2. 使用原生 SQL 迁移数据
    op.execute("""
        UPDATE users
        SET full_name = first_name || ' ' || last_name
    """)

    # 3. 删除旧字段
    op.drop_column('users', 'first_name')
    op.drop_column('users', 'last_name')

# 或者使用 SQLAlchemy ORM
from sqlalchemy.orm import Session
from app.models import User

def upgrade():
    bind = op.get_bind()
    session = Session(bind=bind)

    # 使用 ORM 迁移数据
    users = session.query(User).all()
    for user in users:
        user.full_name = f"{user.first_name} {user.last_name}"
    session.commit()
```

---

## 总结：Alembic 的反直觉点

| 误区 | 正确理解 |
|------|---------|
| autogenerate 能检测所有变更 | 只能检测基本变更，重命名、约束等需要手动编辑 |
| 迁移脚本可以随意修改 | 已应用的迁移不应修改，应创建新迁移 |
| downgrade 总是安全的 | 涉及数据删除的回滚不安全，数据无法恢复 |
| 迁移顺序不重要 | 必须按版本链顺序执行 |
| 可以手动改 alembic_version | 应该使用 `alembic stamp` 命令 |
| 生产环境可以运行 autogenerate | 应该在开发环境生成，生产环境只应用 |
| 只能用 op.* 函数 | 可以执行原生 SQL 和使用 ORM |

**记住：**
> Alembic 是强大的工具，但需要理解其限制和最佳实践。autogenerate 是助手不是替代品，迁移脚本是不可变的，回滚不总是安全的。
