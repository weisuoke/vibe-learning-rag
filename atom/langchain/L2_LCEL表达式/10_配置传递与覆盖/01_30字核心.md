# 30字核心

> **一句话本质**: 配置传递与覆盖是LangChain中通过RunnableConfig字典在链式调用中传播、合并和动态调整运行时参数的机制。

---

## 核心本质

**配置传递与覆盖 = 运行时参数的传播 + 合并规则 + 动态调整**

---

## 三个关键点

### 1. 配置是什么？

RunnableConfig是一个TypedDict，包含8个字段：

```python
{
    "tags": ["tag1", "tag2"],              # 标签列表
    "metadata": {"user": "alice"},         # 元数据字典
    "callbacks": [callback1, callback2],   # 回调列表
    "run_name": "my_chain",                # 运行名称
    "max_concurrency": 5,                  # 最大并发数
    "recursion_limit": 25,                 # 递归限制
    "configurable": {"model": "gpt-4"},    # 可配置字段
    "run_id": "uuid-1234"                  # 运行ID
}
```

### 2. 如何传递？

配置在链式调用中自动传播：

```python
chain = prompt | llm | parser
result = chain.invoke(input, config=config)
# config自动传递给prompt、llm、parser
```

### 3. 如何覆盖？

后来的配置覆盖前面的（简单字段），或连接/合并（复杂字段）：

```python
base_config = {"tags": ["base"], "max_concurrency": 5}
custom_config = {"tags": ["custom"], "max_concurrency": 10}

merged = merge_configs(base_config, custom_config)
# 结果: {"tags": ["base", "custom"], "max_concurrency": 10}
```

---

## 为什么重要？

1. **统一控制**: 一次配置，全链生效
2. **灵活调整**: 运行时动态修改参数
3. **可观测性**: 通过callbacks追踪执行
4. **性能优化**: 通过max_concurrency控制并发
5. **安全控制**: 通过recursion_limit防止无限循环

---

## 最简示例

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate

# 创建链
prompt = ChatPromptTemplate.from_template("Tell me a joke about {topic}")
llm = ChatOpenAI()
chain = prompt | llm

# 使用配置
config = {
    "tags": ["joke", "production"],
    "metadata": {"user_id": "user-123"},
    "max_concurrency": 5
}

result = chain.invoke({"topic": "programming"}, config=config)
# config自动传递给prompt和llm
```

---

## 记忆口诀

**"配置字典，链式传播，后来覆盖，动态调整"**

- **配置字典**: RunnableConfig是TypedDict
- **链式传播**: 自动传递给所有组件
- **后来覆盖**: merge_configs合并规则
- **动态调整**: 运行时修改参数

---

## 下一步

- 深入理解：[02_第一性原理](./02_第一性原理.md)
- 快速上手：[04_最小可用](./04_最小可用.md)
- 详细学习：[03_核心概念_01_RunnableConfig结构与字段](./03_核心概念_01_RunnableConfig结构与字段.md)
