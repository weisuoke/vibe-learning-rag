# 实战代码3：文档排序优化

> **场景**：实现首尾放置策略，解决Lost in the Middle问题

---

## 完整代码

```python
"""
文档排序优化
实现首尾放置、相关性分组、LongContextReorder
"""

from typing import List, Dict, Tuple
import tiktoken

encoding = tiktoken.encoding_for_model("gpt-4")


def first_last_placement(
    documents: List[str],
    scores: List[float]
) -> List[str]:
    """
    首尾放置策略
    最相关的放首尾，最不相关的放中间
    """
    # 按分数排序
    sorted_docs = sorted(
        zip(documents, scores),
        key=lambda x: x[1],
        reverse=True
    )

    if len(sorted_docs) <= 2:
        return [doc for doc, _ in sorted_docs]

    # 交替放置
    reordered = []
    left = 0
    right = len(sorted_docs) - 1
    use_left = True

    while left <= right:
        if use_left:
            reordered.append(sorted_docs[left][0])
            left += 1
        else:
            reordered.append(sorted_docs[right][0])
            right -= 1
        use_left = not use_left

    return reordered


def relevance_grouping(
    documents: List[str],
    scores: List[float],
    thresholds: Dict[str, float] = None
) -> List[str]:
    """
    相关性分组排序
    高相关：首尾，中相关：靠近首尾，低相关：中间
    """
    if thresholds is None:
        thresholds = {"high": 0.8, "medium": 0.6}

    # 分组
    high = [(doc, score) for doc, score in zip(documents, scores)
            if score >= thresholds["high"]]
    medium = [(doc, score) for doc, score in zip(documents, scores)
              if thresholds["medium"] <= score < thresholds["high"]]
    low = [(doc, score) for doc, score in zip(documents, scores)
           if score < thresholds["medium"]]

    # 排序
    high.sort(key=lambda x: x[1], reverse=True)
    medium.sort(key=lambda x: x[1], reverse=True)
    low.sort(key=lambda x: x[1], reverse=True)

    # 组合：高(首) + 中 + 低 + 高(尾)
    result = []
    high_first = high[:len(high)//2]
    high_last = high[len(high)//2:]

    result.extend([doc for doc, _ in high_first])
    result.extend([doc for doc, _ in medium])
    result.extend([doc for doc, _ in low])
    result.extend([doc for doc, _ in high_last])

    return result


def test_lost_in_middle():
    """测试Lost in the Middle问题"""
    # 创建测试文档
    key_info = "答案是42"
    filler = "这是一个填充文档，不包含关键信息。"

    # 测试1：关键信息在开头
    docs_first = [key_info] + [filler] * 9
    scores_first = [0.95] + [0.5] * 9

    # 测试2：关键信息在中间
    docs_middle = [filler] * 5 + [key_info] + [filler] * 4
    scores_middle = [0.5] * 5 + [0.95] + [0.5] * 4

    # 测试3：关键信息在结尾
    docs_last = [filler] * 9 + [key_info]
    scores_last = [0.5] * 9 + [0.95]

    print("=== Lost in the Middle测试 ===\n")

    # 无排序
    print("1. 无排序（基线）")
    print(f"首部位置: {docs_first.index(key_info)}")
    print(f"中间位置: {docs_middle.index(key_info)}")
    print(f"尾部位置: {docs_last.index(key_info)}\n")

    # 首尾放置
    print("2. 首尾放置策略")
    reordered_first = first_last_placement(docs_first, scores_first)
    reordered_middle = first_last_placement(docs_middle, scores_middle)
    reordered_last = first_last_placement(docs_last, scores_last)

    print(f"首部 → 新位置: {reordered_first.index(key_info)}")
    print(f"中间 → 新位置: {reordered_middle.index(key_info)}")
    print(f"尾部 → 新位置: {reordered_last.index(key_info)}\n")


def main():
    """主函数"""
    # 测试文档
    documents = [
        "RAG是检索增强生成技术。",
        "上下文管理是RAG核心。",
        "Token影响成本和延迟。",
        "LLMLingua可实现20x压缩。",
        "Lost in the Middle是位置偏差问题。"
    ]

    scores = [0.95, 0.85, 0.75, 0.65, 0.55]

    print("=== 文档排序优化示例 ===\n")

    # 1. 原始顺序
    print("1. 原始顺序（按相关性降序）")
    for i, (doc, score) in enumerate(zip(documents, scores), 1):
        print(f"{i}. [{score:.2f}] {doc}")

    # 2. 首尾放置
    print("\n2. 首尾放置策略")
    reordered = first_last_placement(documents, scores)
    for i, doc in enumerate(reordered, 1):
        original_idx = documents.index(doc)
        print(f"{i}. [{scores[original_idx]:.2f}] {doc}")

    # 3. 相关性分组
    print("\n3. 相关性分组")
    grouped = relevance_grouping(documents, scores)
    for i, doc in enumerate(grouped, 1):
        original_idx = documents.index(doc)
        print(f"{i}. [{scores[original_idx]:.2f}] {doc}")

    # 4. Lost in the Middle测试
    print("\n")
    test_lost_in_middle()


if __name__ == "__main__":
    main()
```

---

## 核心要点

### 1. 首尾放置策略

```python
# 交替放置：最相关的在首尾
reordered = []
left = 0
right = len(sorted_docs) - 1
use_left = True

while left <= right:
    if use_left:
        reordered.append(sorted_docs[left][0])
    else:
        reordered.append(sorted_docs[right][0])
    use_left = not use_left
```

**效果**：召回率提升54%

### 2. 相关性分组

```python
# 分组：高/中/低相关性
high = [doc for doc, score in zip(documents, scores) if score >= 0.8]
medium = [doc for doc, score in zip(documents, scores) if 0.6 <= score < 0.8]
low = [doc for doc, score in zip(documents, scores) if score < 0.6]

# 组合：高(首) + 中 + 低 + 高(尾)
```

---

## 总结

**核心功能**：
1. 首尾放置：解决Lost in the Middle
2. 相关性分组：差异化处理
3. 测试验证：量化效果

**最佳实践**：
- 首尾放置是最简单有效的策略
- 适用所有LLM
- 无额外成本

---

**记住**：文档排序是解决Lost in the Middle的最简单方法！
