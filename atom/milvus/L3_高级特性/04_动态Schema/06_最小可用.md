# 最小可用操作集

> 掌握动态Schema的核心操作，5分钟快速上手

---

## 核心操作流程

```
启用动态Schema → 插入动态字段 → 查询动态字段 → 过滤动态字段
```

---

## 操作 1: 启用动态Schema

### 最小代码

```python
from pymilvus import Collection, CollectionSchema, FieldSchema, DataType

# 定义固定字段
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=1000)
]

# 启用动态Schema
schema = CollectionSchema(
    fields=fields,
    description="Collection with dynamic schema",
    enable_dynamic_field=True  # 关键参数
)

# 创建Collection
collection = Collection(name="dynamic_collection", schema=schema)
print(f"✅ 动态Schema已启用")
```

### 核心要点

- **`enable_dynamic_field=True`**: 启用动态字段的唯一开关
- **固定字段**: 必须包含主键和向量字段
- **动态字段**: 无需预先定义，插入时自动识别

---

## 操作 2: 插入动态字段

### 最小代码

```python
# 准备数据（包含动态字段）
data = [
    {
        "text": "Milvus is a vector database",
        "embedding": [0.1] * 768,
        # 动态字段（无需预先定义）
        "author": "Alice",
        "category": "database",
        "tags": ["vector", "search"],
        "metadata": {"version": "2.4", "language": "en"}
    },
    {
        "text": "RAG combines retrieval and generation",
        "embedding": [0.2] * 768,
        # 不同的动态字段
        "author": "Bob",
        "category": "AI",
        "priority": 5,
        "is_public": True
    }
]

# 插入数据
collection.insert(data)
collection.flush()
print(f"✅ 插入 {len(data)} 条数据（包含动态字段）")
```

### 核心要点

- **自动识别**: 动态字段无需预先定义，自动识别并存储
- **灵活类型**: 支持字符串、数字、布尔、列表、字典等类型
- **不同字段**: 每条数据可以有不同的动态字段

---

## 操作 3: 查询动态字段

### 最小代码

```python
# 加载Collection
collection.load()

# 查询所有字段（包括动态字段）
results = collection.query(
    expr="id > 0",
    output_fields=["*"]  # * 表示所有字段（包括动态字段）
)

for result in results:
    print(f"ID: {result['id']}")
    print(f"Text: {result['text']}")
    print(f"Author: {result.get('author', 'N/A')}")  # 动态字段
    print(f"Category: {result.get('category', 'N/A')}")  # 动态字段
    print("---")
```

### 核心要点

- **`output_fields=["*"]`**: 返回所有字段（包括动态字段）
- **`output_fields=["author", "category"]`**: 指定返回特定动态字段
- **`.get()` 方法**: 安全访问可能不存在的动态字段

---

## 操作 4: 过滤动态字段

### 最小代码

```python
# 按动态字段过滤
results = collection.query(
    expr='author == "Alice"',  # 过滤动态字段
    output_fields=["text", "author", "category"]
)

print(f"✅ 找到 {len(results)} 条 Alice 的数据")

# 复杂过滤
results = collection.query(
    expr='category == "database" and priority > 3',
    output_fields=["*"]
)
```

### 核心要点

- **标量过滤**: 动态字段支持标量过滤（`==`, `!=`, `>`, `<`, `in`, `not in`）
- **组合过滤**: 支持 `and`, `or`, `not` 组合
- **限制**: 动态字段不支持索引，过滤性能较低

---

## 操作 5: 向量检索 + 动态字段过滤

### 最小代码

```python
# 向量检索 + 动态字段过滤
search_params = {"metric_type": "L2", "params": {"nprobe": 10}}

results = collection.search(
    data=[[0.15] * 768],  # 查询向量
    anns_field="embedding",
    param=search_params,
    limit=5,
    expr='category == "database"',  # 动态字段过滤
    output_fields=["text", "author", "category"]
)

for hits in results:
    for hit in hits:
        print(f"ID: {hit.id}, Distance: {hit.distance}")
        print(f"Text: {hit.entity.get('text')}")
        print(f"Author: {hit.entity.get('author')}")
        print("---")
```

### 核心要点

- **混合检索**: 向量检索 + 动态字段过滤
- **性能影响**: 动态字段过滤会降低检索性能
- **最佳实践**: 高频过滤字段应定义为固定字段

---

## 完整最小示例

```python
from pymilvus import connections, Collection, CollectionSchema, FieldSchema, DataType
import numpy as np

# 1. 连接 Milvus
connections.connect(host="localhost", port="19530")

# 2. 创建启用动态Schema的Collection
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=128),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=500)
]

schema = CollectionSchema(
    fields=fields,
    enable_dynamic_field=True  # 启用动态Schema
)

collection = Collection(name="quick_start_dynamic", schema=schema)

# 3. 插入数据（包含动态字段）
data = [
    {
        "text": "Document 1",
        "embedding": np.random.rand(128).tolist(),
        "author": "Alice",
        "category": "tech"
    },
    {
        "text": "Document 2",
        "embedding": np.random.rand(128).tolist(),
        "author": "Bob",
        "category": "science",
        "priority": 5
    }
]

collection.insert(data)
collection.flush()

# 4. 创建索引
index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "L2",
    "params": {"nlist": 128}
}
collection.create_index(field_name="embedding", index_params=index_params)

# 5. 加载Collection
collection.load()

# 6. 查询动态字段
results = collection.query(
    expr='author == "Alice"',
    output_fields=["*"]
)

print(f"✅ 查询结果: {len(results)} 条")
for result in results:
    print(f"Text: {result['text']}, Author: {result['author']}")

# 7. 向量检索 + 动态字段过滤
search_results = collection.search(
    data=[np.random.rand(128).tolist()],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=2,
    expr='category == "tech"',
    output_fields=["text", "author", "category"]
)

print(f"✅ 检索结果: {len(search_results[0])} 条")

# 8. 清理
collection.release()
collection.drop()
connections.disconnect()
```

---

## 核心参数速查

| 参数 | 说明 | 默认值 | 推荐值 |
|------|------|--------|--------|
| `enable_dynamic_field` | 启用动态Schema | `False` | `True` |
| `output_fields` | 返回字段列表 | `[]` | `["*"]` 或指定字段 |
| `expr` | 过滤表达式 | `""` | 根据需求设置 |

---

## 常见错误

### 错误 1: 未启用动态Schema

```python
# ❌ 错误：未启用动态Schema
schema = CollectionSchema(fields=fields)  # enable_dynamic_field默认为False
collection = Collection(name="test", schema=schema)
collection.insert([{"text": "test", "embedding": [0.1]*128, "author": "Alice"}])
# 报错：Field 'author' not found in schema
```

**解决方案**: 创建Schema时设置 `enable_dynamic_field=True`

### 错误 2: 动态字段类型不一致

```python
# ❌ 错误：同一动态字段类型不一致
data = [
    {"text": "doc1", "embedding": [0.1]*128, "priority": 5},      # priority是int
    {"text": "doc2", "embedding": [0.2]*128, "priority": "high"}  # priority是str
]
collection.insert(data)
# 可能导致查询错误
```

**解决方案**: 保持同一动态字段的类型一致

### 错误 3: 动态字段创建索引

```python
# ❌ 错误：尝试为动态字段创建索引
collection.create_index(field_name="author", index_params={...})
# 报错：Cannot create index on dynamic field
```

**解决方案**: 动态字段不支持索引，高频查询字段应定义为固定字段

---

## 性能对比

| 操作 | 固定字段 | 动态字段 | 性能差异 |
|------|---------|---------|---------|
| 插入 | 快 | 快 | 相近 |
| 查询（无过滤） | 快 | 快 | 相近 |
| 标量过滤 | 快（有索引） | 慢（无索引） | 10-100x |
| 向量检索 | 快 | 快 | 相近 |
| 混合检索 | 快 | 慢 | 5-50x |

---

## 最佳实践

### ✅ 适合使用动态Schema的场景

1. **元数据不确定**: 数据结构经常变化
2. **低频查询字段**: 不需要高性能过滤
3. **快速原型**: 快速验证想法，无需预先设计Schema
4. **多模态数据**: 不同类型数据有不同属性

### ❌ 不适合使用动态Schema的场景

1. **高频过滤字段**: 需要快速标量过滤
2. **需要索引**: 需要为字段创建索引
3. **严格类型约束**: 需要强类型检查
4. **大规模生产**: 性能要求极高的场景

---

## 下一步

- **深入理解**: 阅读 **02_第一性原理.md** 理解动态Schema的底层原理
- **核心概念**: 学习 **03-05 核心概念** 掌握完整技术细节
- **实战应用**: 实践 **09-13 实战代码** 五个场景
- **避免踩坑**: 查看 **08_反直觉点.md** 了解常见误区

---

**记住**: 动态Schema提供灵活性，但牺牲了性能和类型安全。根据实际需求权衡使用。
