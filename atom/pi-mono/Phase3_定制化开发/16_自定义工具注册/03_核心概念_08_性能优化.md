# 核心概念 08：性能优化

> **提升效率 - 四大优化策略**

## 概述

性能优化是工具开发的重要环节。本文介绍四大优化策略：输出截断、流式更新、缓存结果、并发控制。

---

## 优化策略

### 1. 输出截断

**问题**: 工具输出过大,影响性能和用户体验

**解决方案**: 截断输出,保存完整内容到文件

**示例**:
```typescript
const MAX_OUTPUT_SIZE = 10000;

const execute = async (params, context) => {
  const output = await generateLargeOutput();
  
  if (output.length > MAX_OUTPUT_SIZE) {
    const truncated = output.substring(0, MAX_OUTPUT_SIZE);
    const filePath = `/tmp/output-${Date.now()}.txt`;
    await fs.writeFile(filePath, output);
    
    return {
      content: truncated + `\n\n[Output truncated. Full output saved to ${filePath}]`,
      metadata: {
        truncated: true,
        fullOutputPath: filePath
      }
    };
  }
  
  return { content: output };
};
```

### 2. 流式更新

**问题**: 长时间运行的工具没有进度反馈

**解决方案**: 使用 onUpdate 提供实时进度

**示例**:
```typescript
const execute = async (params, context) => {
  const { onUpdate } = context;
  
  let result = '';
  for (let i = 0; i < 100; i++) {
    const chunk = await processChunk(i);
    result += chunk;
    
    if (i % 10 === 0) {
      onUpdate?.({ content: `Processing: ${i}%` });
    }
  }
  
  return { content: result };
};
```

### 3. 缓存结果

**问题**: 重复调用相同参数的工具

**解决方案**: 缓存结果,避免重复计算

**示例**:
```typescript
const cache = new Map();

const execute = async ({ query }, context) => {
  if (cache.has(query)) {
    context.logger.info('Cache hit');
    return { content: cache.get(query) };
  }
  
  const result = await expensiveQuery(query);
  cache.set(query, result);
  
  return { content: result };
};
```

### 4. 并发控制

**问题**: 大量并发请求导致资源耗尽

**解决方案**: 限制并发数量

**示例**:
```typescript
import pLimit from 'p-limit';

const limit = pLimit(5);

const execute = async ({ urls }, context) => {
  const results = await Promise.all(
    urls.map(url => 
      limit(() => fetch(url))
    )
  );
  
  return { content: JSON.stringify(results) };
};
```

---

## 总结

**四大优化策略**:
1. **输出截断**: 限制输出大小
2. **流式更新**: 实时进度反馈
3. **缓存结果**: 避免重复计算
4. **并发控制**: 限制并发数量

理解这些优化策略,你就能编写出高性能的工具!
