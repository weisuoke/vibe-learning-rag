# 实战代码 3：认证中间件

本文提供完整的认证中间件实现，包括 JWT 认证、API Key 认证和基于角色的访问控制。

---

## 1. 基础 JWT 认证

### 1.1 简单 JWT 认证中间件

```python
"""
基础 JWT 认证中间件
演示：验证 JWT token，设置用户信息
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import jwt
from datetime import datetime, timedelta

app = FastAPI()

# JWT 配置
SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"

# 公开路径（不需要认证）
PUBLIC_PATHS = ["/", "/login", "/register", "/docs", "/openapi.json"]

@app.middleware("http")
async def jwt_auth_middleware(request: Request, call_next):
    # 跳过公开路径
    if request.url.path in PUBLIC_PATHS:
        return await call_next(request)

    # 获取 Authorization 头
    authorization = request.headers.get("authorization", "")

    if not authorization.startswith("Bearer "):
        return JSONResponse(
            {"error": "Missing or invalid authorization header"},
            status_code=401
        )

    # 提取 token
    token = authorization.replace("Bearer ", "")

    try:
        # 验证 token
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])

        # 设置用户信息到 request.state
        request.state.user_id = payload["user_id"]
        request.state.user_email = payload["email"]

    except jwt.ExpiredSignatureError:
        return JSONResponse(
            {"error": "Token expired"},
            status_code=401
        )
    except jwt.InvalidTokenError:
        return JSONResponse(
            {"error": "Invalid token"},
            status_code=401
        )

    # 继续处理
    response = await call_next(request)
    return response

# 登录端点（生成 token）
@app.post("/login")
async def login(email: str, password: str):
    # 简化版：实际应该验证密码
    if email == "user@example.com" and password == "password":
        # 生成 token
        payload = {
            "user_id": "user_123",
            "email": email,
            "exp": datetime.utcnow() + timedelta(hours=24)
        }
        token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

        return {"token": token}

    return JSONResponse(
        {"error": "Invalid credentials"},
        status_code=401
    )

# 受保护的端点
@app.get("/api/profile")
async def get_profile(request: Request):
    return {
        "user_id": request.state.user_id,
        "email": request.state.user_email
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 1. 登录获取 token
$ curl -X POST "http://localhost:8000/login?email=user@example.com&password=password"
{"token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."}

# 2. 使用 token 访问受保护端点
$ curl -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..." \
  http://localhost:8000/api/profile
{"user_id":"user_123","email":"user@example.com"}

# 3. 不带 token 访问（失败）
$ curl http://localhost:8000/api/profile
{"error":"Missing or invalid authorization header"}
```

---

## 2. 路径匹配认证

### 2.1 基于路径前缀的认证

```python
"""
路径匹配认证中间件
演示：只对特定路径前缀进行认证
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import jwt

app = FastAPI()

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"

# 需要认证的路径前缀
PROTECTED_PREFIXES = ["/api/", "/admin/"]

# 公开路径（即使在保护前缀下也不需要认证）
PUBLIC_PATHS = ["/api/health", "/api/docs"]

@app.middleware("http")
async def path_based_auth(request: Request, call_next):
    path = request.url.path

    # 检查是否为公开路径
    if path in PUBLIC_PATHS:
        return await call_next(request)

    # 检查是否需要认证
    needs_auth = any(path.startswith(prefix) for prefix in PROTECTED_PREFIXES)

    if not needs_auth:
        return await call_next(request)

    # 验证 token
    authorization = request.headers.get("authorization", "")

    if not authorization.startswith("Bearer "):
        return JSONResponse(
            {"error": "Unauthorized"},
            status_code=401
        )

    token = authorization.replace("Bearer ", "")

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        request.state.user_id = payload["user_id"]
    except:
        return JSONResponse(
            {"error": "Invalid token"},
            status_code=401
        )

    response = await call_next(request)
    return response

# 公开端点
@app.get("/")
async def root():
    return {"message": "Public endpoint"}

# 受保护端点
@app.get("/api/users")
async def get_users(request: Request):
    return {"user_id": request.state.user_id, "users": []}

# 公开的 API 端点（在保护前缀下）
@app.get("/api/health")
async def health_check():
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 3. API Key 认证

### 3.1 API Key 认证中间件

```python
"""
API Key 认证中间件
演示：使用 API Key 进行认证
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

# 模拟 API Key 数据库
API_KEYS = {
    "sk_test_123456": {"user_id": "user_1", "name": "Test Key"},
    "sk_prod_789012": {"user_id": "user_2", "name": "Production Key"},
}

@app.middleware("http")
async def api_key_auth(request: Request, call_next):
    # 跳过公开路径
    if request.url.path in ["/", "/docs", "/openapi.json"]:
        return await call_next(request)

    # 获取 API Key（从请求头或查询参数）
    api_key = request.headers.get("x-api-key") or request.query_params.get("api_key")

    if not api_key:
        return JSONResponse(
            {"error": "Missing API key"},
            status_code=401
        )

    # 验证 API Key
    if api_key not in API_KEYS:
        return JSONResponse(
            {"error": "Invalid API key"},
            status_code=401
        )

    # 设置用户信息
    key_info = API_KEYS[api_key]
    request.state.user_id = key_info["user_id"]
    request.state.api_key_name = key_info["name"]

    response = await call_next(request)
    return response

@app.get("/api/data")
async def get_data(request: Request):
    return {
        "user_id": request.state.user_id,
        "api_key_name": request.state.api_key_name,
        "data": "sensitive data"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 使用请求头
$ curl -H "X-API-Key: sk_test_123456" http://localhost:8000/api/data
{"user_id":"user_1","api_key_name":"Test Key","data":"sensitive data"}

# 使用查询参数
$ curl "http://localhost:8000/api/data?api_key=sk_test_123456"
{"user_id":"user_1","api_key_name":"Test Key","data":"sensitive data"}

# 无效的 API Key
$ curl -H "X-API-Key: invalid_key" http://localhost:8000/api/data
{"error":"Invalid API key"}
```

---

## 4. 基于角色的访问控制（RBAC）

### 4.1 RBAC 认证中间件

```python
"""
基于角色的访问控制（RBAC）中间件
演示：根据用户角色控制访问权限
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import jwt

app = FastAPI()

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"

# 路径权限配置
PATH_PERMISSIONS = {
    "/api/users": ["admin", "user"],
    "/api/admin": ["admin"],
    "/api/reports": ["admin", "manager"],
}

@app.middleware("http")
async def rbac_middleware(request: Request, call_next):
    # 跳过公开路径
    if request.url.path in ["/", "/login", "/docs", "/openapi.json"]:
        return await call_next(request)

    # 验证 token
    authorization = request.headers.get("authorization", "")

    if not authorization.startswith("Bearer "):
        return JSONResponse(
            {"error": "Unauthorized"},
            status_code=401
        )

    token = authorization.replace("Bearer ", "")

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        request.state.user_id = payload["user_id"]
        request.state.user_role = payload["role"]
    except:
        return JSONResponse(
            {"error": "Invalid token"},
            status_code=401
        )

    # 检查权限
    path = request.url.path
    if path in PATH_PERMISSIONS:
        required_roles = PATH_PERMISSIONS[path]
        if request.state.user_role not in required_roles:
            return JSONResponse(
                {
                    "error": "Forbidden",
                    "message": f"Requires one of: {', '.join(required_roles)}"
                },
                status_code=403
            )

    response = await call_next(request)
    return response

# 登录端点（生成不同角色的 token）
@app.post("/login")
async def login(email: str, role: str = "user"):
    from datetime import datetime, timedelta

    payload = {
        "user_id": "user_123",
        "email": email,
        "role": role,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    return {"token": token, "role": role}

# 不同权限的端点
@app.get("/api/users")
async def get_users(request: Request):
    return {
        "user_id": request.state.user_id,
        "role": request.state.user_role,
        "users": []
    }

@app.get("/api/admin")
async def admin_panel(request: Request):
    return {
        "message": "Admin panel",
        "role": request.state.user_role
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 1. 以 user 角色登录
$ curl -X POST "http://localhost:8000/login?email=user@example.com&role=user"
{"token":"...","role":"user"}

# 2. 访问 /api/users（成功）
$ curl -H "Authorization: Bearer <user_token>" http://localhost:8000/api/users
{"user_id":"user_123","role":"user","users":[]}

# 3. 访问 /api/admin（失败）
$ curl -H "Authorization: Bearer <user_token>" http://localhost:8000/api/admin
{"error":"Forbidden","message":"Requires one of: admin"}

# 4. 以 admin 角色登录
$ curl -X POST "http://localhost:8000/login?email=admin@example.com&role=admin"
{"token":"...","role":"admin"}

# 5. 访问 /api/admin（成功）
$ curl -H "Authorization: Bearer <admin_token>" http://localhost:8000/api/admin
{"message":"Admin panel","role":"admin"}
```

---

## 5. 多种认证方式支持

### 5.1 支持 JWT 和 API Key 的认证中间件

```python
"""
多种认证方式支持
演示：同时支持 JWT 和 API Key 认证
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import jwt

app = FastAPI()

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"

API_KEYS = {
    "sk_test_123456": {"user_id": "user_1", "role": "user"},
    "sk_admin_789012": {"user_id": "admin_1", "role": "admin"},
}

@app.middleware("http")
async def multi_auth_middleware(request: Request, call_next):
    # 跳过公开路径
    if request.url.path in ["/", "/login", "/docs", "/openapi.json"]:
        return await call_next(request)

    # 尝试 JWT 认证
    authorization = request.headers.get("authorization", "")
    if authorization.startswith("Bearer "):
        token = authorization.replace("Bearer ", "")
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            request.state.user_id = payload["user_id"]
            request.state.user_role = payload.get("role", "user")
            request.state.auth_method = "jwt"
            return await call_next(request)
        except:
            pass  # JWT 验证失败，尝试其他方式

    # 尝试 API Key 认证
    api_key = request.headers.get("x-api-key") or request.query_params.get("api_key")
    if api_key and api_key in API_KEYS:
        key_info = API_KEYS[api_key]
        request.state.user_id = key_info["user_id"]
        request.state.user_role = key_info["role"]
        request.state.auth_method = "api_key"
        return await call_next(request)

    # 所有认证方式都失败
    return JSONResponse(
        {
            "error": "Unauthorized",
            "message": "Please provide a valid JWT token or API key"
        },
        status_code=401
    )

@app.get("/api/data")
async def get_data(request: Request):
    return {
        "user_id": request.state.user_id,
        "role": request.state.user_role,
        "auth_method": request.state.auth_method,
        "data": "sensitive data"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 6. Token 刷新机制

### 6.1 支持 Token 刷新的认证中间件

```python
"""
Token 刷新机制
演示：支持 access token 和 refresh token
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import jwt
from datetime import datetime, timedelta

app = FastAPI()

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"

# Access token 有效期：15 分钟
ACCESS_TOKEN_EXPIRE_MINUTES = 15
# Refresh token 有效期：7 天
REFRESH_TOKEN_EXPIRE_DAYS = 7

@app.middleware("http")
async def token_auth_middleware(request: Request, call_next):
    # 跳过公开路径
    if request.url.path in ["/", "/login", "/refresh", "/docs", "/openapi.json"]:
        return await call_next(request)

    # 获取 token
    authorization = request.headers.get("authorization", "")

    if not authorization.startswith("Bearer "):
        return JSONResponse(
            {"error": "Missing authorization header"},
            status_code=401
        )

    token = authorization.replace("Bearer ", "")

    try:
        # 验证 access token
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])

        # 检查 token 类型
        if payload.get("type") != "access":
            return JSONResponse(
                {"error": "Invalid token type"},
                status_code=401
            )

        request.state.user_id = payload["user_id"]

    except jwt.ExpiredSignatureError:
        return JSONResponse(
            {
                "error": "Token expired",
                "message": "Please refresh your token"
            },
            status_code=401
        )
    except jwt.InvalidTokenError:
        return JSONResponse(
            {"error": "Invalid token"},
            status_code=401
        )

    response = await call_next(request)
    return response

# 登录端点（生成 access token 和 refresh token）
@app.post("/login")
async def login(email: str, password: str):
    # 简化版：实际应该验证密码
    if email == "user@example.com" and password == "password":
        user_id = "user_123"

        # 生成 access token
        access_payload = {
            "user_id": user_id,
            "type": "access",
            "exp": datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        }
        access_token = jwt.encode(access_payload, SECRET_KEY, algorithm=ALGORITHM)

        # 生成 refresh token
        refresh_payload = {
            "user_id": user_id,
            "type": "refresh",
            "exp": datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
        }
        refresh_token = jwt.encode(refresh_payload, SECRET_KEY, algorithm=ALGORITHM)

        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "bearer"
        }

    return JSONResponse(
        {"error": "Invalid credentials"},
        status_code=401
    )

# 刷新 token 端点
@app.post("/refresh")
async def refresh_token(refresh_token: str):
    try:
        # 验证 refresh token
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])

        # 检查 token 类型
        if payload.get("type") != "refresh":
            return JSONResponse(
                {"error": "Invalid token type"},
                status_code=401
            )

        user_id = payload["user_id"]

        # 生成新的 access token
        access_payload = {
            "user_id": user_id,
            "type": "access",
            "exp": datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        }
        new_access_token = jwt.encode(access_payload, SECRET_KEY, algorithm=ALGORITHM)

        return {
            "access_token": new_access_token,
            "token_type": "bearer"
        }

    except jwt.ExpiredSignatureError:
        return JSONResponse(
            {"error": "Refresh token expired"},
            status_code=401
        )
    except jwt.InvalidTokenError:
        return JSONResponse(
            {"error": "Invalid refresh token"},
            status_code=401
        )

# 受保护端点
@app.get("/api/profile")
async def get_profile(request: Request):
    return {"user_id": request.state.user_id}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 1. 登录获取 tokens
$ curl -X POST "http://localhost:8000/login?email=user@example.com&password=password"
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
  "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
  "token_type": "bearer"
}

# 2. 使用 access token 访问 API
$ curl -H "Authorization: Bearer <access_token>" http://localhost:8000/api/profile
{"user_id":"user_123"}

# 3. access token 过期后，使用 refresh token 刷新
$ curl -X POST "http://localhost:8000/refresh?refresh_token=<refresh_token>"
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
  "token_type": "bearer"
}
```

---

## 7. 在 AI Agent 后端中的应用

### 7.1 AI Agent 认证中间件

```python
"""
AI Agent 后端认证中间件
演示：保护 LLM API 调用
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import jwt
from datetime import datetime, timedelta

app = FastAPI()

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"

# 公开路径
PUBLIC_PATHS = ["/", "/docs", "/openapi.json", "/login"]

# Agent API 路径前缀
AGENT_API_PREFIX = "/api/agent/"

@app.middleware("http")
async def ai_agent_auth(request: Request, call_next):
    # 跳过公开路径
    if request.url.path in PUBLIC_PATHS:
        return await call_next(request)

    # 只对 Agent API 进行认证
    if not request.url.path.startswith(AGENT_API_PREFIX):
        return await call_next(request)

    # 验证 token
    authorization = request.headers.get("authorization", "")

    if not authorization.startswith("Bearer "):
        return JSONResponse(
            {
                "error": "Unauthorized",
                "message": "Please provide a valid JWT token to access AI Agent API"
            },
            status_code=401
        )

    token = authorization.replace("Bearer ", "")

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])

        # 设置用户信息
        request.state.user_id = payload["user_id"]
        request.state.user_email = payload["email"]
        request.state.user_plan = payload.get("plan", "free")  # 用户套餐

        # 检查用户套餐（可选）
        if request.state.user_plan == "free":
            # 免费用户可能有额外限制
            request.state.max_tokens = 1000
        else:
            request.state.max_tokens = 4000

    except jwt.ExpiredSignatureError:
        return JSONResponse(
            {"error": "Token expired"},
            status_code=401
        )
    except jwt.InvalidTokenError:
        return JSONResponse(
            {"error": "Invalid token"},
            status_code=401
        )

    response = await call_next(request)
    return response

# 登录端点
@app.post("/login")
async def login(email: str, password: str):
    # 简化版
    if email == "user@example.com" and password == "password":
        payload = {
            "user_id": "user_123",
            "email": email,
            "plan": "pro",
            "exp": datetime.utcnow() + timedelta(days=30)
        }
        token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

        return {"token": token}

    return JSONResponse(
        {"error": "Invalid credentials"},
        status_code=401
    )

# Agent API 端点
@app.post("/api/agent/chat")
async def chat(request: Request, message: str):
    user_id = request.state.user_id
    max_tokens = request.state.max_tokens

    # 调用 LLM API（示例）
    response = f"Echo: {message}"

    return {
        "user_id": user_id,
        "response": response,
        "max_tokens": max_tokens
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 总结

**认证中间件的核心要点：**

1. **JWT 认证**：使用 JWT token 进行无状态认证
2. **API Key 认证**：使用 API Key 进行简单认证
3. **RBAC**：基于角色的访问控制
4. **多种认证方式**：同时支持 JWT 和 API Key
5. **Token 刷新**：使用 access token 和 refresh token
6. **路径匹配**：只对特定路径进行认证
7. **AI Agent 应用**：保护 LLM API 调用

**最佳实践：**
- 使用 HTTPS 传输 token
- 设置合理的 token 过期时间
- 使用强密钥（SECRET_KEY）
- 实现 token 刷新机制
- 记录认证失败日志
- 在 AI Agent 后端中根据用户套餐限制资源

**下一步学习：**
- 实战代码 4：限流中间件
- 实战代码 5：错误处理中间件
