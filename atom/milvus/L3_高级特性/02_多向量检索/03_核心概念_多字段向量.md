# 核心概念1：多字段向量

> 如何在一个 Collection 中定义和管理多个向量字段

---

## 什么是多字段向量？

**一句话定义：** 在单个 Milvus Collection 中定义多个 `FLOAT_VECTOR` 类型的字段，每个字段存储对象的不同维度特征。

```python
from pymilvus import CollectionSchema, FieldSchema, DataType

# 定义包含多个向量字段的 Schema
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=1000),

    # 向量字段1：文本内容的向量（OpenAI Embedding）
    FieldSchema(name="text_vector", dtype=DataType.FLOAT_VECTOR, dim=1536),

    # 向量字段2：标题的向量（BGE Embedding）
    FieldSchema(name="title_vector", dtype=DataType.FLOAT_VECTOR, dim=768),

    # 向量字段3：图片的向量（CLIP Embedding）
    FieldSchema(name="image_vector", dtype=DataType.FLOAT_VECTOR, dim=512),
]

schema = CollectionSchema(fields=fields, description="多向量检索示例")
```

---

## 核心特性

### 特性1：每个向量字段独立

**含义：** 每个向量字段有自己的维度、索引类型、度量方式

```python
from pymilvus import Collection

collection = Collection("multi_vector_demo", schema=schema)

# 为 text_vector 创建 HNSW 索引（COSINE 度量）
collection.create_index(
    field_name="text_vector",
    index_params={
        "index_type": "HNSW",
        "metric_type": "COSINE",
        "params": {"M": 16, "efConstruction": 200}
    }
)

# 为 title_vector 创建 IVF_FLAT 索引（L2 度量）
collection.create_index(
    field_name="title_vector",
    index_params={
        "index_type": "IVF_FLAT",
        "metric_type": "L2",
        "params": {"nlist": 128}
    }
)

# 为 image_vector 创建 HNSW 索引（IP 度量）
collection.create_index(
    field_name="image_vector",
    index_params={
        "index_type": "HNSW",
        "metric_type": "IP",
        "params": {"M": 32, "efConstruction": 400}
    }
)
```

**关键点：**
- 不同向量字段可以使用不同的索引类型（HNSW、IVF_FLAT、FLAT等）
- 不同向量字段可以使用不同的度量方式（COSINE、L2、IP）
- 索引参数可以根据字段特点单独优化

---

### 特性2：向量维度可以不同

**含义：** 不同向量字段的维度可以不同，取决于 Embedding 模型

```python
# 示例：不同 Embedding 模型的维度
embeddings = {
    "text_vector": {
        "model": "text-embedding-3-small",  # OpenAI
        "dim": 1536
    },
    "title_vector": {
        "model": "BAAI/bge-small-zh-v1.5",  # BGE
        "dim": 512
    },
    "image_vector": {
        "model": "openai/clip-vit-base-patch32",  # CLIP
        "dim": 512
    }
}

# 定义 Schema 时指定各自的维度
fields = [
    FieldSchema(name="text_vector", dtype=DataType.FLOAT_VECTOR, dim=1536),
    FieldSchema(name="title_vector", dtype=DataType.FLOAT_VECTOR, dim=512),
    FieldSchema(name="image_vector", dtype=DataType.FLOAT_VECTOR, dim=512),
]
```

**为什么维度可以不同？**
- 每个向量字段是独立的存储和索引
- 检索时分别计算相似度，不需要维度对齐
- 融合时只看排名或归一化后的分数，不直接比较向量

---

### 特性3：插入数据时必须提供所有向量

**含义：** 插入数据时，每个向量字段都必须有值（除非设置为可选）

```python
# 准备数据
data = [
    {
        "text": "Python 是一种高级编程语言",
        "text_vector": get_text_embedding("Python 是一种高级编程语言"),
        "title_vector": get_title_embedding("Python 简介"),
        "image_vector": get_image_embedding("python_logo.png")
    },
    {
        "text": "Java 是一种面向对象的语言",
        "text_vector": get_text_embedding("Java 是一种面向对象的语言"),
        "title_vector": get_title_embedding("Java 入门"),
        "image_vector": get_image_embedding("java_logo.png")
    }
]

# 插入数据
collection.insert(data)

# ❌ 错误：缺少某个向量字段
data_incomplete = [
    {
        "text": "C++ 是一种系统编程语言",
        "text_vector": get_text_embedding("C++ 是一种系统编程语言"),
        # 缺少 title_vector 和 image_vector
    }
]
# collection.insert(data_incomplete)  # 会报错！
```

**如何处理可选向量字段？**
```python
# 方案1：使用零向量占位
zero_vector = [0.0] * 512
data_with_placeholder = {
    "text": "C++ 是一种系统编程语言",
    "text_vector": get_text_embedding("C++ 是一种系统编程语言"),
    "title_vector": zero_vector,  # 占位
    "image_vector": zero_vector   # 占位
}

# 方案2：设计时只保留必需的向量字段
# 如果某个向量字段经常缺失，考虑不将其作为向量字段
```

---

## 在实际应用中的使用

### 场景1：文档问答系统（文本 + 图表）

```python
from pymilvus import Collection, CollectionSchema, FieldSchema, DataType

# 1. 定义 Schema
fields = [
    FieldSchema(name="doc_id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="content", dtype=DataType.VARCHAR, max_length=5000),
    FieldSchema(name="image_url", dtype=DataType.VARCHAR, max_length=500),

    # 文本向量：文档内容的语义表示
    FieldSchema(name="text_vector", dtype=DataType.FLOAT_VECTOR, dim=1536),

    # 图片向量：图表的视觉特征
    FieldSchema(name="image_vector", dtype=DataType.FLOAT_VECTOR, dim=512),
]

schema = CollectionSchema(fields=fields, description="文档问答知识库")
collection = Collection("doc_qa", schema=schema)

# 2. 创建索引
collection.create_index("text_vector", {
    "index_type": "HNSW",
    "metric_type": "COSINE",
    "params": {"M": 16, "efConstruction": 200}
})

collection.create_index("image_vector", {
    "index_type": "HNSW",
    "metric_type": "COSINE",
    "params": {"M": 16, "efConstruction": 200}
})

# 3. 插入文档
from openai import OpenAI
import clip
import torch

client = OpenAI()
clip_model, preprocess = clip.load("ViT-B/32")

def get_text_embedding(text):
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    return response.data[0].embedding

def get_image_embedding(image_path):
    from PIL import Image
    image = preprocess(Image.open(image_path)).unsqueeze(0)
    with torch.no_grad():
        features = clip_model.encode_image(image)
    return features.squeeze().tolist()

# 插入数据
docs = [
    {
        "content": "Python 的安装步骤：1. 下载安装包 2. 运行安装程序 3. 配置环境变量",
        "image_url": "https://example.com/python_install.png",
        "text_vector": get_text_embedding("Python 的安装步骤：1. 下载安装包 2. 运行安装程序 3. 配置环境变量"),
        "image_vector": get_image_embedding("python_install.png")
    }
]

collection.insert(docs)
collection.load()
```

---

### 场景2：电商搜索（商品描述 + 商品图片）

```python
# 1. 定义 Schema
fields = [
    FieldSchema(name="product_id", dtype=DataType.INT64, is_primary=True),
    FieldSchema(name="name", dtype=DataType.VARCHAR, max_length=200),
    FieldSchema(name="description", dtype=DataType.VARCHAR, max_length=2000),
    FieldSchema(name="price", dtype=DataType.FLOAT),
    FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=100),

    # 商品描述向量
    FieldSchema(name="desc_vector", dtype=DataType.FLOAT_VECTOR, dim=1536),

    # 商品图片向量
    FieldSchema(name="image_vector", dtype=DataType.FLOAT_VECTOR, dim=512),
]

schema = CollectionSchema(fields=fields, description="电商商品库")
collection = Collection("products", schema=schema)

# 2. 创建索引
collection.create_index("desc_vector", {
    "index_type": "IVF_FLAT",
    "metric_type": "COSINE",
    "params": {"nlist": 1024}
})

collection.create_index("image_vector", {
    "index_type": "IVF_FLAT",
    "metric_type": "COSINE",
    "params": {"nlist": 512}
})

# 3. 插入商品
products = [
    {
        "product_id": 1001,
        "name": "红色连衣裙",
        "description": "夏季新款红色连衣裙，适合约会和聚会",
        "price": 299.0,
        "category": "女装",
        "desc_vector": get_text_embedding("夏季新款红色连衣裙，适合约会和聚会"),
        "image_vector": get_image_embedding("dress_1001.jpg")
    }
]

collection.insert(products)
collection.load()
```

---

## 设计原则

### 原则1：向量字段数量控制在2-3个

**原因：**
- 每个向量字段都需要单独的索引和检索
- 向量字段过多会显著降低性能
- 融合算法的复杂度随字段数量增加

**推荐：**
- 小型应用：2个向量字段（如文本 + 图片）
- 中型应用：3个向量字段（如文本 + 标题 + 图片）
- 大型应用：考虑拆分成多个 Collection

---

### 原则2：选择有区分度的向量字段

**判断标准：**
```python
def should_add_vector_field(field_name, existing_fields):
    """是否应该添加这个向量字段？"""
    # 1. 是否提供独特信息？
    if is_redundant(field_name, existing_fields):
        return False

    # 2. 是否显著提升准确率？（实测提升>10%）
    if not improves_accuracy(field_name, threshold=0.1):
        return False

    # 3. 维护成本是否可接受？
    if not is_maintainable(field_name):
        return False

    return True

# 示例
# ✅ text_vector：核心内容，必需
# ✅ image_vector：图片信息，与文本互补
# ❌ title_vector：标题通常包含在文本中，冗余
# ❌ summary_vector：摘要与文本高度相关，冗余
```

---

### 原则3：统一度量方式（如果可能）

**推荐：** 所有向量字段使用相同的度量方式（如 COSINE）

**好处：**
- 分数范围一致，便于融合
- 可以使用加权平均等简单融合算法
- 便于调试和优化

```python
# ✅ 推荐：统一使用 COSINE
collection.create_index("text_vector", {
    "index_type": "HNSW",
    "metric_type": "COSINE",  # 统一
    "params": {"M": 16}
})

collection.create_index("image_vector", {
    "index_type": "HNSW",
    "metric_type": "COSINE",  # 统一
    "params": {"M": 16}
})

# ⚠️ 不推荐：混合度量方式（除非有特殊原因）
collection.create_index("text_vector", {
    "metric_type": "COSINE"  # 0-1
})

collection.create_index("image_vector", {
    "metric_type": "L2"  # 0-∞
})
# 融合时需要归一化或使用 RRF
```

---

## 常见问题

### Q1：向量字段可以动态添加吗？

**答：** 不可以。Schema 定义后不能修改。

**解决方案：**
```python
# 方案1：重新创建 Collection（推荐）
# 1. 导出数据
# 2. 删除旧 Collection
# 3. 创建新 Collection（包含新字段）
# 4. 重新插入数据

# 方案2：创建新 Collection，保留旧 Collection
# 适合需要保持服务可用的场景
```

---

### Q2：向量字段可以为空吗？

**答：** 不可以。插入数据时必须提供所有向量字段的值。

**解决方案：**
```python
# 使用零向量占位
zero_vector = [0.0] * dim

data = {
    "text": "示例文本",
    "text_vector": get_text_embedding("示例文本"),
    "image_vector": zero_vector  # 如果没有图片，用零向量
}
```

---

### Q3：如何选择向量维度？

**答：** 向量维度由 Embedding 模型决定，不能随意修改。

**常见模型的维度：**
| 模型 | 维度 |
|------|------|
| text-embedding-3-small (OpenAI) | 1536 |
| text-embedding-3-large (OpenAI) | 3072 |
| BAAI/bge-small-zh-v1.5 | 512 |
| BAAI/bge-large-zh-v1.5 | 1024 |
| openai/clip-vit-base-patch32 | 512 |

---

## 总结

**多字段向量的核心要点：**

1. **定义**：在单个 Collection 中定义多个 `FLOAT_VECTOR` 字段
2. **独立性**：每个向量字段有独立的维度、索引、度量方式
3. **完整性**：插入数据时必须提供所有向量字段的值
4. **数量控制**：建议2-3个向量字段，不宜过多
5. **区分度**：只保留有独特信息的向量字段
6. **统一度量**：尽量使用相同的度量方式（如 COSINE）

---

**继续学习：** [04_核心概念_混合检索.md](./04_核心概念_混合检索.md)
