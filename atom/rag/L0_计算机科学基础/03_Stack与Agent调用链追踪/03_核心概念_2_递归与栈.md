# 核心概念2：递归与栈

> 理解递归的本质：递归就是隐式使用栈

---

## 概念定义

**递归（Recursion）**：函数直接或间接调用自身的编程技术

**递归与栈的关系**：每次递归调用都会在调用栈上创建新的栈帧，递归返回时按 LIFO 顺序弹出栈帧

```
递归 = 函数调用自身 = 栈的隐式使用
```

---

## 1. 递归的本质

### 1.1 递归的定义

**递归函数必须包含两部分：**

1. **基础情况（Base Case）**：递归终止条件
2. **递归情况（Recursive Case）**：函数调用自身

```python
def factorial(n):
    # 基础情况：递归终止
    if n <= 1:
        return 1

    # 递归情况：调用自身
    return n * factorial(n - 1)

# 计算 5!
result = factorial(5)  # 5 * 4 * 3 * 2 * 1 = 120
print(result)
```

### 1.2 递归的执行过程

**调用栈的变化：**

```python
def factorial(n, depth=0):
    """带深度显示的阶乘函数"""
    indent = "  " * depth
    print(f"{indent}→ factorial({n}) 调用")

    if n <= 1:
        print(f"{indent}← factorial({n}) 返回 1")
        return 1

    result = n * factorial(n - 1, depth + 1)
    print(f"{indent}← factorial({n}) 返回 {result}")
    return result

# 执行
factorial(4)
```

**输出：**
```
→ factorial(4) 调用
  → factorial(3) 调用
    → factorial(2) 调用
      → factorial(1) 调用
      ← factorial(1) 返回 1
    ← factorial(2) 返回 2
  ← factorial(3) 返回 6
← factorial(4) 返回 24
```

**调用栈可视化：**
```
步骤1: [factorial(4)]
步骤2: [factorial(4), factorial(3)]
步骤3: [factorial(4), factorial(3), factorial(2)]
步骤4: [factorial(4), factorial(3), factorial(2), factorial(1)]
步骤5: [factorial(4), factorial(3), factorial(2)]  ← factorial(1) 返回
步骤6: [factorial(4), factorial(3)]                ← factorial(2) 返回
步骤7: [factorial(4)]                              ← factorial(3) 返回
步骤8: []                                          ← factorial(4) 返回
```

### 1.3 递归与迭代的对比

```python
# 递归版本
def sum_recursive(n):
    if n == 0:
        return 0
    return n + sum_recursive(n - 1)

# 迭代版本
def sum_iterative(n):
    total = 0
    for i in range(1, n + 1):
        total += i
    return total

# 测试
print(sum_recursive(5))   # 15
print(sum_iterative(5))   # 15
```

**对比：**

| 特性 | 递归 | 迭代 |
|------|------|------|
| **代码简洁性** | 简洁，直观 | 可能较复杂 |
| **空间复杂度** | O(n)（栈空间） | O(1) |
| **时间复杂度** | 有函数调用开销 | 无额外开销 |
| **适用场景** | 树、图、分治 | 简单循环 |
| **栈溢出风险** | 有 | 无 |

---

## 2. 调用栈的工作机制

### 2.1 栈帧的结构

**每个栈帧包含：**
- 函数参数
- 局部变量
- 返回地址
- 保存的寄存器

```python
import sys
import inspect

def show_call_stack():
    """显示当前调用栈"""
    frame = inspect.currentframe()
    stack = []

    while frame:
        info = inspect.getframeinfo(frame)
        stack.append({
            'function': info.function,
            'line': info.lineno,
            'locals': len(frame.f_locals)
        })
        frame = frame.f_back

    return stack

def func_c():
    print("在 func_c 中")
    stack = show_call_stack()
    for i, frame in enumerate(stack):
        print(f"  栈帧 {i}: {frame['function']} (行 {frame['line']}, {frame['locals']} 个局部变量)")

def func_b():
    x = 10
    func_c()

def func_a():
    y = 20
    func_b()

func_a()
```

**输出示例：**
```
在 func_c 中
  栈帧 0: show_call_stack (行 8, 3 个局部变量)
  栈帧 1: func_c (行 18, 1 个局部变量)
  栈帧 2: func_b (行 23, 1 个局部变量)
  栈帧 3: func_a (行 27, 1 个局部变量)
```

### 2.2 递归深度限制

**Python 的递归深度限制：**

```python
import sys

# 查看默认递归深度限制
print(f"默认递归深度: {sys.getrecursionlimit()}")  # 通常是 1000

# 测试递归深度
def deep_recursion(n):
    if n == 0:
        return 0
    return 1 + deep_recursion(n - 1)

try:
    result = deep_recursion(1500)  # 超过限制
except RecursionError as e:
    print(f"递归错误: {e}")

# 可以增加限制（谨慎使用）
sys.setrecursionlimit(2000)
print(f"新的递归深度: {sys.getrecursionlimit()}")
```

**为什么有限制？**
- 防止无限递归导致栈溢出
- 保护系统资源
- 每个线程的栈空间有限（通常 8MB）

### 2.3 栈溢出的原因

```python
# 原因1：忘记基础情况
def infinite_recursion(n):
    return infinite_recursion(n + 1)  # 永远不会停止

# 原因2：基础情况永远不会到达
def wrong_base_case(n):
    if n == 0:
        return 0
    return wrong_base_case(n + 1)  # n 越来越大，永远不会等于 0

# 原因3：递归深度过大
def too_deep(n):
    if n == 0:
        return 0
    return too_deep(n - 1)

# too_deep(10000)  # 会栈溢出
```

---

## 3. 递归的经典应用

### 3.1 斐波那契数列

```python
# 递归版本（简单但低效）
def fibonacci_recursive(n):
    """时间复杂度: O(2^n)"""
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

# 递归 + 记忆化（高效）
def fibonacci_memo(n, memo=None):
    """时间复杂度: O(n)"""
    if memo is None:
        memo = {}

    if n in memo:
        return memo[n]

    if n <= 1:
        return n

    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]

# 迭代版本（最高效）
def fibonacci_iterative(n):
    """时间复杂度: O(n), 空间复杂度: O(1)"""
    if n <= 1:
        return n

    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

# 测试
print(fibonacci_recursive(10))    # 55
print(fibonacci_memo(10))         # 55
print(fibonacci_iterative(10))    # 55
```

### 3.2 树的遍历

```python
class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 前序遍历（递归）
def preorder_recursive(root):
    """根 → 左 → 右"""
    if not root:
        return []
    return [root.val] + preorder_recursive(root.left) + preorder_recursive(root.right)

# 中序遍历（递归）
def inorder_recursive(root):
    """左 → 根 → 右"""
    if not root:
        return []
    return inorder_recursive(root.left) + [root.val] + inorder_recursive(root.right)

# 后序遍历（递归）
def postorder_recursive(root):
    """左 → 右 → 根"""
    if not root:
        return []
    return postorder_recursive(root.left) + postorder_recursive(root.right) + [root.val]

# 构建测试树
#       1
#      / \
#     2   3
#    / \
#   4   5
root = TreeNode(1,
    TreeNode(2, TreeNode(4), TreeNode(5)),
    TreeNode(3)
)

print("前序:", preorder_recursive(root))  # [1, 2, 4, 5, 3]
print("中序:", inorder_recursive(root))   # [4, 2, 5, 1, 3]
print("后序:", postorder_recursive(root))  # [4, 5, 2, 3, 1]
```

### 3.3 分治算法

```python
def merge_sort(arr):
    """归并排序 - 经典分治算法"""
    # 基础情况
    if len(arr) <= 1:
        return arr

    # 分解
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    # 合并
    return merge(left, right)

def merge(left, right):
    """合并两个有序数组"""
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result

# 测试
arr = [38, 27, 43, 3, 9, 82, 10]
sorted_arr = merge_sort(arr)
print(f"排序结果: {sorted_arr}")
```

---

## 4. 递归转迭代

### 4.1 为什么要转换？

**原因：**
- 避免栈溢出
- 提高性能（减少函数调用开销）
- 控制内存使用

### 4.2 转换方法：使用显式栈

```python
# 递归版本：计算表达式树
class ExprNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def eval_recursive(node):
    """递归计算表达式树"""
    if not node:
        return 0

    # 叶子节点（数字）
    if not node.left and not node.right:
        return int(node.val)

    # 递归计算左右子树
    left_val = eval_recursive(node.left)
    right_val = eval_recursive(node.right)

    # 根据操作符计算
    if node.val == '+':
        return left_val + right_val
    elif node.val == '*':
        return left_val * right_val
    return 0

# 迭代版本：使用显式栈
def eval_iterative(root):
    """迭代计算表达式树"""
    if not root:
        return 0

    # 使用两个栈：一个存节点，一个存结果
    node_stack = [root]
    result_stack = []

    # 后序遍历（左 → 右 → 根）
    while node_stack:
        node = node_stack[-1]

        # 叶子节点
        if not node.left and not node.right:
            node_stack.pop()
            result_stack.append(int(node.val))
        # 已经处理过子节点
        elif len(result_stack) >= 2 and (not node.left or result_stack):
            node_stack.pop()
            right_val = result_stack.pop()
            left_val = result_stack.pop()

            if node.val == '+':
                result_stack.append(left_val + right_val)
            elif node.val == '*':
                result_stack.append(left_val * right_val)
        # 需要先处理子节点
        else:
            if node.right:
                node_stack.append(node.right)
            if node.left:
                node_stack.append(node.left)

    return result_stack[0] if result_stack else 0

# 构建表达式树: (3 + 5) * 2
#       *
#      / \
#     +   2
#    / \
#   3   5
tree = ExprNode('*',
    ExprNode('+', ExprNode('3'), ExprNode('5')),
    ExprNode('2')
)

print(f"递归结果: {eval_recursive(tree)}")    # 16
print(f"迭代结果: {eval_iterative(tree)}")    # 16
```

### 4.3 尾递归优化

**尾递归**：递归调用是函数的最后一个操作

```python
# 非尾递归
def factorial_non_tail(n):
    if n <= 1:
        return 1
    return n * factorial_non_tail(n - 1)  # 递归后还要乘 n

# 尾递归
def factorial_tail(n, acc=1):
    if n <= 1:
        return acc
    return factorial_tail(n - 1, n * acc)  # 递归是最后操作

# Python 不支持尾递归优化，需要手动转换为迭代
def factorial_optimized(n):
    acc = 1
    while n > 1:
        acc *= n
        n -= 1
    return acc

print(factorial_non_tail(5))   # 120
print(factorial_tail(5))        # 120
print(factorial_optimized(5))   # 120
```

---

## 5. 在 AI Agent 中的应用

### 5.1 递归任务分解

```python
from typing import List, Dict, Any

class TaskDecomposer:
    """递归分解复杂任务"""

    def __init__(self, max_depth=5):
        self.max_depth = max_depth
        self.call_stack = []

    def decompose(self, task: str, depth=0) -> List[str]:
        """递归分解任务"""
        # 记录调用栈
        self.call_stack.append(f"decompose({task}, depth={depth})")
        indent = "  " * depth
        print(f"{indent}→ 分解任务: {task}")

        # 基础情况1：达到最大深度
        if depth >= self.max_depth:
            print(f"{indent}  达到最大深度，直接执行")
            self.call_stack.pop()
            return [task]

        # 基础情况2：任务足够简单
        if self.is_simple(task):
            print(f"{indent}  任务简单，直接执行")
            self.call_stack.pop()
            return [task]

        # 递归情况：分解为子任务
        subtasks = self.split_task(task)
        print(f"{indent}  分解为 {len(subtasks)} 个子任务")

        results = []
        for i, subtask in enumerate(subtasks):
            print(f"{indent}  处理子任务 {i+1}/{len(subtasks)}")
            sub_results = self.decompose(subtask, depth + 1)
            results.extend(sub_results)

        print(f"{indent}← 完成任务: {task}")
        self.call_stack.pop()
        return results

    def is_simple(self, task: str) -> bool:
        """判断任务是否简单"""
        return len(task) < 20

    def split_task(self, task: str) -> List[str]:
        """分解任务（简化示例）"""
        if "写文章" in task:
            return ["研究主题", "列大纲", "撰写内容", "校对修改"]
        elif "研究主题" in task:
            return ["查找资料", "阅读文献", "总结要点"]
        else:
            return [task]

    def get_call_stack(self) -> List[str]:
        """获取当前调用栈"""
        return self.call_stack.copy()

# 使用示例
decomposer = TaskDecomposer(max_depth=3)
result = decomposer.decompose("写一篇关于 AI 的文章")

print("\n最终任务列表:")
for i, task in enumerate(result, 1):
    print(f"{i}. {task}")
```

### 5.2 知识图谱遍历

```python
class KnowledgeGraph:
    """知识图谱递归遍历"""

    def __init__(self):
        self.graph = {
            'AI': ['机器学习', '深度学习', 'NLP'],
            '机器学习': ['监督学习', '无监督学习'],
            '深度学习': ['CNN', 'RNN', 'Transformer'],
            'NLP': ['分词', 'Embedding', '语义理解'],
            'Transformer': ['Self-Attention', 'Position Encoding']
        }
        self.visited = set()

    def dfs_recursive(self, node: str, depth=0) -> List[str]:
        """深度优先搜索（递归）"""
        indent = "  " * depth
        print(f"{indent}→ 访问节点: {node}")

        # 标记为已访问
        self.visited.add(node)
        result = [node]

        # 递归访问子节点
        if node in self.graph:
            for child in self.graph[node]:
                if child not in self.visited:
                    child_results = self.dfs_recursive(child, depth + 1)
                    result.extend(child_results)

        print(f"{indent}← 完成节点: {node}")
        return result

    def dfs_iterative(self, start: str) -> List[str]:
        """深度优先搜索（迭代 + 显式栈）"""
        stack = [(start, 0)]  # (节点, 深度)
        visited = set()
        result = []

        while stack:
            node, depth = stack.pop()

            if node in visited:
                continue

            indent = "  " * depth
            print(f"{indent}→ 访问节点: {node}")

            visited.add(node)
            result.append(node)

            # 将子节点压入栈（逆序，保证顺序一致）
            if node in self.graph:
                for child in reversed(self.graph[node]):
                    if child not in visited:
                        stack.append((child, depth + 1))

        return result

# 测试
print("=== 递归版本 ===")
kg1 = KnowledgeGraph()
result1 = kg1.dfs_recursive('AI')
print(f"\n遍历结果: {result1}\n")

print("=== 迭代版本 ===")
kg2 = KnowledgeGraph()
result2 = kg2.dfs_iterative('AI')
print(f"\n遍历结果: {result2}")
```

### 5.3 Recursive LLM (2026)

```python
class RecursiveLLM:
    """递归语言模型 - 2026 年最新技术"""

    def __init__(self, max_depth=10):
        self.max_depth = max_depth
        self.call_history = []

    def solve(self, problem: str, depth=0) -> str:
        """递归解决问题"""
        self.call_history.append({
            'depth': depth,
            'problem': problem
        })

        indent = "  " * depth
        print(f"{indent}→ RLM 深度 {depth}: {problem[:50]}...")

        # 基础情况1：达到最大深度
        if depth >= self.max_depth:
            print(f"{indent}  达到最大深度，使用迭代深化")
            return self._iterative_deepening(problem)

        # 基础情况2：问题足够简单
        if self._is_simple(problem):
            result = self._execute_simple(problem)
            print(f"{indent}← 返回结果: {result[:50]}...")
            return result

        # 递归情况：分解问题
        subproblems = self._decompose(problem)
        print(f"{indent}  分解为 {len(subproblems)} 个子问题")

        sub_results = []
        for i, subproblem in enumerate(subproblems):
            print(f"{indent}  子问题 {i+1}/{len(subproblems)}")
            sub_result = self.solve(subproblem, depth + 1)
            sub_results.append(sub_result)

        # 整合结果
        final_result = self._combine(sub_results)
        print(f"{indent}← 完成: {problem[:50]}...")
        return final_result

    def _is_simple(self, problem: str) -> bool:
        """判断问题是否简单"""
        return len(problem) < 30

    def _execute_simple(self, problem: str) -> str:
        """执行简单问题"""
        return f"解决: {problem}"

    def _decompose(self, problem: str) -> List[str]:
        """分解问题"""
        # 简化示例
        if "分析" in problem:
            return ["收集数据", "处理数据", "得出结论"]
        return [problem]

    def _combine(self, results: List[str]) -> str:
        """整合结果"""
        return " → ".join(results)

    def _iterative_deepening(self, problem: str) -> str:
        """迭代深化搜索（避免栈溢出）"""
        return f"迭代解决: {problem}"

    def get_call_depth(self) -> int:
        """获取最大调用深度"""
        return max(h['depth'] for h in self.call_history) if self.call_history else 0

# 使用示例
rlm = RecursiveLLM(max_depth=3)
result = rlm.solve("分析 2026 年 AI Agent 发展趋势")
print(f"\n最终结果: {result}")
print(f"最大调用深度: {rlm.get_call_depth()}")
```

---

## 6. 递归的优化技巧

### 6.1 记忆化（Memoization）

```python
from functools import lru_cache

# 方法1：手动记忆化
def fib_memo(n, memo=None):
    if memo is None:
        memo = {}
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]

# 方法2：使用装饰器
@lru_cache(maxsize=None)
def fib_cached(n):
    if n <= 1:
        return n
    return fib_cached(n-1) + fib_cached(n-2)

# 性能对比
import time

start = time.time()
result1 = fib_memo(35)
time1 = time.time() - start

start = time.time()
result2 = fib_cached(35)
time2 = time.time() - start

print(f"手动记忆化: {time1:.4f}s")
print(f"装饰器缓存: {time2:.4f}s")
```

### 6.2 深度限制

```python
def safe_recursion(n, depth=0, max_depth=100):
    """带深度限制的递归"""
    if depth >= max_depth:
        raise RecursionError(f"超过最大深度 {max_depth}")

    if n == 0:
        return 0
    return 1 + safe_recursion(n - 1, depth + 1, max_depth)
```

### 6.3 迭代深化搜索（IDDFS）

```python
def iddfs(start, goal, max_depth=10):
    """迭代深化深度优先搜索"""
    for depth_limit in range(max_depth + 1):
        print(f"尝试深度限制: {depth_limit}")
        result = dfs_limited(start, goal, depth_limit)
        if result:
            return result
    return None

def dfs_limited(node, goal, depth_limit, depth=0):
    """深度限制的 DFS"""
    if depth > depth_limit:
        return None
    if node == goal:
        return [node]

    # 递归搜索
    for child in get_children(node):
        result = dfs_limited(child, goal, depth_limit, depth + 1)
        if result:
            return [node] + result
    return None
```

---

## 总结

**递归的本质：**
- 递归 = 函数调用自身 = 隐式使用栈
- 每次递归调用创建新栈帧
- 递归返回时按 LIFO 顺序弹出

**递归的优势：**
- 代码简洁直观
- 适合树、图、分治问题
- 直接映射问题的递归定义

**递归的挑战：**
- 栈空间有限（可能溢出）
- 函数调用有开销
- 需要正确的终止条件

**在 AI Agent 中的应用：**
- 递归任务分解
- 知识图谱遍历
- Recursive LLM (2026)
- 决策树搜索

**记住：** 理解递归就是理解栈，掌握递归就是掌握问题分解的艺术！
