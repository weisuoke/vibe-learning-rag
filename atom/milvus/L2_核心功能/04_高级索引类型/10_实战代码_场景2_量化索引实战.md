# 实战代码：量化索引实战

> 场景：大规模文档检索（5000万文档，成本优化）

---

## 场景描述

**业务需求**：
- 文档数：5000万
- 向量维度：768（BERT Embedding）
- 原始存储：143 GB
- 目标：降低存储成本，保持召回率>95%

**技术方案**：对比IVF_SQ8和IVF_PQ，选择最优方案

---

## 完整代码实现

```python
"""
量化索引实战：大规模文档检索
演示：IVF_SQ8和IVF_PQ的对比测试
"""

import numpy as np
import time
from pymilvus import (
    connections, Collection, FieldSchema,
    CollectionSchema, DataType, utility
)

# ===== 1. 环境准备 =====
print("=== 环境准备 ===")
connections.connect("default", host="localhost", port="19530")
print("✓ 已连接到Milvus")

# ===== 2. 创建测试Collection =====
print("\n=== 创建测试Collection ===")

def create_collection(name, description):
    """创建Collection"""
    if utility.has_collection(name):
        utility.drop_collection(name)
    
    fields = [
        FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=False),
        FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768),
        FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=1000)
    ]
    schema = CollectionSchema(fields, description=description)
    return Collection(name, schema)

# 创建三个Collection用于对比
collections = {
    "baseline": create_collection("doc_baseline", "基准：IVF_FLAT"),
    "sq8": create_collection("doc_sq8", "优化1：IVF_SQ8"),
    "pq": create_collection("doc_pq", "优化2：IVF_PQ")
}

print("✓ 已创建3个Collection用于对比")

# ===== 3. 插入测试数据 =====
print("\n=== 插入测试数据 ===")

num_entities = 50_000  # 5万条数据用于测试
print(f"生成 {num_entities:,} 条测试数据...")

ids = list(range(num_entities))
embeddings = np.random.randn(num_entities, 768).astype(np.float32)
# 归一化（模拟BERT输出）
embeddings = embeddings / np.linalg.norm(embeddings, axis=1, keepdims=True)
texts = [f"文档内容_{i}" for i in range(num_entities)]

# 批量插入到所有Collection
for name, collection in collections.items():
    print(f"  插入数据到 {name}...")
    collection.insert([ids, embeddings.tolist(), texts])
    collection.flush()

print(f"✓ 数据插入完成")

# ===== 4. 创建不同类型的索引 =====
print("\n=== 创建索引 ===")

# 基准：IVF_FLAT（无量化）
print("\n1. IVF_FLAT（基准）")
baseline_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "L2",
    "params": {"nlist": 1024}
}
start = time.time()
collections["baseline"].create_index("embedding", baseline_params)
baseline_build_time = time.time() - start
print(f"   构建时间: {baseline_build_time:.2f} 秒")

# 优化1：IVF_SQ8（标量量化）
print("\n2. IVF_SQ8（标量量化，4x压缩）")
sq8_params = {
    "index_type": "IVF_SQ8",
    "metric_type": "L2",
    "params": {"nlist": 1024}
}
start = time.time()
collections["sq8"].create_index("embedding", sq8_params)
sq8_build_time = time.time() - start
print(f"   构建时间: {sq8_build_time:.2f} 秒")

# 优化2：IVF_PQ（乘积量化）
print("\n3. IVF_PQ（乘积量化，8x压缩）")
pq_params = {
    "index_type": "IVF_PQ",
    "metric_type": "L2",
    "params": {
        "nlist": 1024,
        "m": 96,      # 768 / 8 = 96
        "nbits": 8
    }
}
start = time.time()
collections["pq"].create_index("embedding", pq_params)
pq_build_time = time.time() - start
print(f"   构建时间: {pq_build_time:.2f} 秒")

# 加载所有Collection
for collection in collections.values():
    collection.load()

print("\n✓ 所有索引创建完成")

# ===== 5. 存储成本分析 =====
print("\n=== 存储成本分析 ===")

N = 50_000_000  # 5000万（实际规模）
D = 768

# 计算存储大小
baseline_gb = N * D * 4 / (1024**3)
sq8_gb = N * D * 1 / (1024**3)
pq_gb = N * 96 * 1 / (1024**3)

print(f"\n实际规模（5000万向量）存储对比：")
print(f"{'索引类型':<15} {'存储大小':<12} {'压缩比':<10} {'月成本($10/GB)':<15}")
print("-" * 55)
print(f"{'IVF_FLAT':<15} {baseline_gb:>8.2f} GB  {'1x':<10} ${baseline_gb * 10:>10.2f}")
print(f"{'IVF_SQ8':<15} {sq8_gb:>8.2f} GB  {'4x':<10} ${sq8_gb * 10:>10.2f}")
print(f"{'IVF_PQ':<15} {pq_gb:>8.2f} GB  {'8x':<10} ${pq_gb * 10:>10.2f}")

savings_sq8 = (baseline_gb - sq8_gb) / baseline_gb * 100
savings_pq = (baseline_gb - pq_gb) / baseline_gb * 100

print(f"\n成本节省：")
print(f"  IVF_SQ8: {savings_sq8:.1f}%")
print(f"  IVF_PQ:  {savings_pq:.1f}%")

# ===== 6. 性能测试 =====
print("\n=== 性能测试 ===")

# 生成测试查询
num_queries = 100
query_vectors = np.random.randn(num_queries, 768).astype(np.float32)
query_vectors = query_vectors / np.linalg.norm(query_vectors, axis=1, keepdims=True)

search_params = {"metric_type": "L2", "params": {"nprobe": 16}}

results_data = {}

for name, collection in collections.items():
    print(f"\n测试 {name}...")
    
    # 延迟测试
    latencies = []
    for query in query_vectors[:10]:  # 测试10个查询
        start = time.time()
        collection.search(
            data=[query.tolist()],
            anns_field="embedding",
            param=search_params,
            limit=10
        )
        latencies.append((time.time() - start) * 1000)
    
    avg_latency = np.mean(latencies)
    
    # 批量测试
    start = time.time()
    results = collection.search(
        data=query_vectors.tolist(),
        anns_field="embedding",
        param=search_params,
        limit=10
    )
    batch_time = time.time() - start
    qps = num_queries / batch_time
    
    results_data[name] = {
        "latency": avg_latency,
        "qps": qps,
        "results": results
    }
    
    print(f"  平均延迟: {avg_latency:.2f} ms")
    print(f"  QPS: {qps:.0f}")

# ===== 7. 召回率测试 =====
print("\n=== 召回率测试 ===")

# 使用baseline的结果作为ground truth
baseline_results = results_data["baseline"]["results"]

def calculate_recall(test_results, ground_truth, k=10):
    """计算召回率"""
    total_recall = 0
    for test_res, gt_res in zip(test_results, ground_truth):
        test_ids = set([hit.id for hit in test_res[:k]])
        gt_ids = set([hit.id for hit in gt_res[:k]])
        recall = len(test_ids & gt_ids) / k
        total_recall += recall
    return total_recall / len(test_results)

sq8_recall = calculate_recall(results_data["sq8"]["results"], baseline_results)
pq_recall = calculate_recall(results_data["pq"]["results"], baseline_results)

print(f"召回率@10（以IVF_FLAT为基准）：")
print(f"  IVF_FLAT: 100.0%（基准）")
print(f"  IVF_SQ8:  {sq8_recall * 100:.1f}%")
print(f"  IVF_PQ:   {pq_recall * 100:.1f}%")

# ===== 8. 综合对比 =====
print("\n" + "="*70)
print("综合对比")
print("="*70)

print(f"\n{'指标':<20} {'IVF_FLAT':<15} {'IVF_SQ8':<15} {'IVF_PQ':<15}")
print("-" * 70)
print(f"{'存储（5000万）':<20} {baseline_gb:>10.2f} GB  {sq8_gb:>10.2f} GB  {pq_gb:>10.2f} GB")
print(f"{'压缩比':<20} {'1x':>15} {'4x':>15} {'8x':>15}")
print(f"{'月成本($10/GB)':<20} ${baseline_gb * 10:>13.2f}  ${sq8_gb * 10:>13.2f}  ${pq_gb * 10:>13.2f}")
print(f"{'构建时间':<20} {baseline_build_time:>12.2f}s  {sq8_build_time:>12.2f}s  {pq_build_time:>12.2f}s")
print(f"{'平均延迟':<20} {results_data['baseline']['latency']:>12.2f}ms {results_data['sq8']['latency']:>12.2f}ms {results_data['pq']['latency']:>12.2f}ms")
print(f"{'QPS':<20} {results_data['baseline']['qps']:>14.0f}  {results_data['sq8']['qps']:>14.0f}  {results_data['pq']['qps']:>14.0f}")
print(f"{'召回率@10':<20} {'100.0%':>15} {sq8_recall * 100:>13.1f}%  {pq_recall * 100:>13.1f}%")

# ===== 9. 参数调优：PQ的m值对比 =====
print("\n=== 参数调优：PQ的m值对比 ===")

m_values = [48, 64, 96, 128]  # 不同的子向量数量
print(f"\n{'m值':<10} {'压缩比':<12} {'预期召回率':<15} {'说明':<30}")
print("-" * 70)

for m in m_values:
    compression = 768 / m
    # 经验估计：m越大召回率越高
    recall_estimate = 0.88 + (m / 128) * 0.10
    
    if m == 48:
        note = "最大压缩，召回率较低"
    elif m == 64:
        note = "平衡方案"
    elif m == 96:
        note = "推荐配置"
    else:
        note = "高精度，压缩较少"
    
    print(f"{m:<10} {compression:>8.1f}x    {recall_estimate:>12.1%}    {note:<30}")

# ===== 10. 决策建议 =====
print("\n" + "="*70)
print("决策建议")
print("="*70)

print("\n根据测试结果：")
print(f"\n1. 如果召回率要求 > 97%：")
print(f"   推荐：IVF_SQ8")
print(f"   理由：召回率 {sq8_recall * 100:.1f}%，成本节省 {savings_sq8:.1f}%")

print(f"\n2. 如果召回率要求 > 93%：")
print(f"   推荐：IVF_PQ (m=96)")
print(f"   理由：召回率 {pq_recall * 100:.1f}%，成本节省 {savings_pq:.1f}%")

print(f"\n3. 如果成本最敏感：")
print(f"   推荐：IVF_PQ (m=64)")
print(f"   理由：压缩比 12x，召回率约 94%")

print(f"\n✓ 对于大部分RAG应用，推荐使用 IVF_PQ (m=96)")
print(f"  - 召回率 {pq_recall * 100:.1f}% 对RAG足够")
print(f"  - 成本节省 {savings_pq:.1f}%")
print(f"  - 延迟增加可接受")

# ===== 11. 清理资源 =====
print("\n=== 清理资源 ===")
for collection in collections.values():
    collection.release()
print("✓ 已释放所有Collection")
```

---

## 运行输出示例

```
=== 环境准备 ===
✓ 已连接到Milvus

=== 创建测试Collection ===
✓ 已创建3个Collection用于对比

=== 插入测试数据 ===
生成 50,000 条测试数据...
  插入数据到 baseline...
  插入数据到 sq8...
  插入数据到 pq...
✓ 数据插入完成

=== 创建索引 ===

1. IVF_FLAT（基准）
   构建时间: 2.34 秒

2. IVF_SQ8（标量量化，4x压缩）
   构建时间: 2.56 秒

3. IVF_PQ（乘积量化，8x压缩）
   构建时间: 3.12 秒

✓ 所有索引创建完成

=== 存储成本分析 ===

实际规模（5000万向量）存储对比：
索引类型         存储大小      压缩比      月成本($10/GB) 
-------------------------------------------------------
IVF_FLAT          143.05 GB  1x         $   1430.51
IVF_SQ8            35.76 GB  4x         $    357.63
IVF_PQ             17.88 GB  8x         $    178.81

成本节省：
  IVF_SQ8: 75.0%
  IVF_PQ:  87.5%

=== 性能测试 ===

测试 baseline...
  平均延迟: 12.34 ms
  QPS: 456

测试 sq8...
  平均延迟: 13.67 ms
  QPS: 423

测试 pq...
  平均延迟: 15.89 ms
  QPS: 389

=== 召回率测试 ===
召回率@10（以IVF_FLAT为基准）：
  IVF_FLAT: 100.0%（基准）
  IVF_SQ8:  97.3%
  IVF_PQ:   94.8%

======================================================================
综合对比
======================================================================

指标                   IVF_FLAT        IVF_SQ8         IVF_PQ         
----------------------------------------------------------------------
存储（5000万）            143.05 GB       35.76 GB       17.88 GB
压缩比                            1x              4x              8x
月成本($10/GB)           $   1430.51     $    357.63     $    178.81
构建时间                      2.34s           2.56s           3.12s
平均延迟                     12.34ms         13.67ms         15.89ms
QPS                            456             423             389
召回率@10                   100.0%          97.3%           94.8%

=== 参数调优：PQ的m值对比 ===

m值        压缩比        预期召回率       说明                          
----------------------------------------------------------------------
48             16.0x         88.8%    最大压缩，召回率较低          
64             12.0x         93.8%    平衡方案                      
96              8.0x         96.3%    推荐配置                      
128             6.0x         98.0%    高精度，压缩较少              

======================================================================
决策建议
======================================================================

根据测试结果：

1. 如果召回率要求 > 97%：
   推荐：IVF_SQ8
   理由：召回率 97.3%，成本节省 75.0%

2. 如果召回率要求 > 93%：
   推荐：IVF_PQ (m=96)
   理由：召回率 94.8%，成本节省 87.5%

3. 如果成本最敏感：
   推荐：IVF_PQ (m=64)
   理由：压缩比 12x，召回率约 94%

✓ 对于大部分RAG应用，推荐使用 IVF_PQ (m=96)
  - 召回率 94.8% 对RAG足够
  - 成本节省 87.5%
  - 延迟增加可接受

=== 清理资源 ===
✓ 已释放所有Collection
```

---

## 关键要点

### 1. 量化索引的价值
- **成本优化**：IVF_PQ节省87.5%存储成本
- **精度保持**：召回率94.8%对RAG足够
- **性能可接受**：延迟增加约30%

### 2. 选择建议
- **高精度场景**：IVF_SQ8（召回率97%+）
- **平衡场景**：IVF_PQ m=96（推荐）
- **成本敏感**：IVF_PQ m=64（最大压缩）

### 3. 生产部署
- 在实际数据上测试召回率
- 监控存储和内存使用
- 根据业务需求调整m值

---

## 下一步

- **混合检索**：[11_实战代码_场景3_稀疏向量实战](./11_实战代码_场景3_稀疏向量实战.md)
- **综合优化**：[12_实战代码_场景4_RAG性能优化](./12_实战代码_场景4_RAG性能优化.md)
