# 核心概念1：管道操作符语法

## 概述

管道操作符 `|` 是 LangChain LCEL 的核心语法，用于连接实现了 Runnable 接口的组件。

**一句话定义**：用 `|` 符号将多个 Runnable 组件从左到右连接，形成数据流管道。

---

## 1. 基础语法

### 1.1 最简单的管道

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser

# 三个 Runnable 组件
prompt = ChatPromptTemplate.from_template("讲一个关于{topic}的笑话")
model = ChatOpenAI(model="gpt-4o-mini")
parser = StrOutputParser()

# 用 | 连接
chain = prompt | model | parser

# 调用
result = chain.invoke({"topic": "程序员"})
print(result)
```

**语法规则**：
- `|` 左边和右边都必须是 Runnable 对象
- 数据从左到右流动
- 左边的输出类型必须匹配右边的输入类型

---

## 2. 数据流方向

### 2.1 从左到右

```python
# 数据流：input → prompt → model → parser → output
chain = prompt | model | parser

# 等价于（但更易读）
# output = parser.parse(model.invoke(prompt.format(input)))
```

**可视化**：
```
用户输入 {"topic": "AI"}
    ↓
prompt: 生成 ChatPromptValue
    ↓
model: 生成 AIMessage
    ↓
parser: 提取字符串
    ↓
最终输出 "AI 笑话..."
```

### 2.2 为什么是从左到右？

**设计理由**：
1. **符合阅读习惯**：人类从左到右阅读
2. **与 Unix 管道一致**：`cat file.txt | grep "error" | wc -l`
3. **直观表达数据流**：箭头方向 `→` 与管道方向一致

**对比其他方向**：
```python
# 数学函数组合：从右到左
(g ∘ f)(x) = g(f(x))  # 先执行 f，再执行 g

# LangChain 管道：从左到右
chain = f | g  # 先执行 f，再执行 g
```

---

## 3. 多步骤管道

### 3.1 线性管道

```python
# 5步管道
chain = (
    step1
    | step2
    | step3
    | step4
    | step5
)

# 等价于
chain = step1 | step2 | step3 | step4 | step5
```

**推荐写法**：
```python
# ✅ 好：每行一个步骤，易读
chain = (
    prompt
    | model
    | parser
    | validator
    | formatter
)

# ❌ 差：一行太长，难读
chain = prompt | model | parser | validator | formatter
```

### 3.2 嵌套管道

```python
# 管道可以嵌套
sub_chain = prompt | model
full_chain = sub_chain | parser

# 等价于
full_chain = prompt | model | parser
```

**实际应用**：
```python
# 复用子管道
translation_chain = translator | formatter

# 在不同场景使用
en_to_zh = english_prompt | translation_chain
zh_to_en = chinese_prompt | translation_chain
```

---

## 4. 类型匹配规则

### 4.1 类型必须匹配

```python
# ✅ 正确：类型匹配
ChatPromptTemplate  →  ChatPromptValue
ChatModel           →  AIMessage
StrOutputParser     →  str

chain = prompt | model | parser  # 类型链：dict → ChatPromptValue → AIMessage → str
```

```python
# ❌ 错误：类型不匹配
chain = prompt | parser  # ChatPromptValue → StrOutputParser (不匹配！)
```

### 4.2 常见类型流转

| 组件类型 | 输入类型 | 输出类型 |
|----------|----------|----------|
| ChatPromptTemplate | dict | ChatPromptValue |
| ChatModel | ChatPromptValue | AIMessage |
| StrOutputParser | AIMessage | str |
| JsonOutputParser | AIMessage | dict |
| RunnableLambda | Any | Any (自定义) |
| RunnablePassthrough | Any | Any (原样传递) |

### 4.3 类型检查

```python
# 运行时类型检查
try:
    chain = prompt | parser  # 类型不匹配
    result = chain.invoke({"topic": "AI"})
except Exception as e:
    print(f"类型错误: {e}")
    # 输出: StrOutputParser expected AIMessage, got ChatPromptValue
```

---

## 5. 特殊语法：字典输入

### 5.1 字典作为管道起点

```python
from langchain_core.runnables import RunnablePassthrough

# 场景：需要传递多个值
chain = (
    {
        "context": retriever,           # 检索上下文
        "question": RunnablePassthrough()  # 传递原始问题
    }
    | prompt
    | model
    | parser
)

# 调用
answer = chain.invoke("什么是向量数据库？")
```

**数据流**：
```
输入: "什么是向量数据库？"
    ↓
字典构建:
  - context: retriever.invoke("什么是向量数据库？") → [doc1, doc2, ...]
  - question: "什么是向量数据库？"
    ↓
prompt: 使用 {context} 和 {question} 构建提示
    ↓
model: 生成答案
    ↓
parser: 提取文本
    ↓
输出: "向量数据库是..."
```

### 5.2 字典的键必须匹配 Prompt 变量

```python
# Prompt 定义了两个变量
prompt = ChatPromptTemplate.from_template(
    "上下文：{context}\n问题：{question}"
)

# ✅ 正确：字典的键匹配 prompt 的变量
chain = (
    {
        "context": retriever,
        "question": RunnablePassthrough()
    }
    | prompt
    | model
    | parser
)

# ❌ 错误：键不匹配
chain = (
    {
        "ctx": retriever,  # 应该是 "context"
        "q": RunnablePassthrough()  # 应该是 "question"
    }
    | prompt  # 会报错：缺少 context 和 question
    | model
    | parser
)
```

### 5.3 字典值可以是 Runnable 或 Lambda

```python
chain = (
    {
        "context": retriever,                    # Runnable
        "question": RunnablePassthrough(),       # Runnable
        "timestamp": lambda x: datetime.now(),   # Lambda 函数
        "user_id": lambda x: "user_123"          # Lambda 函数
    }
    | prompt
    | model
    | parser
)
```

---

## 6. 括号的使用

### 6.1 何时需要括号

```python
# ✅ 推荐：多行管道用括号
chain = (
    prompt
    | model
    | parser
)

# ✅ 可以：单行管道不需要括号
chain = prompt | model | parser

# ❌ 错误：多行不用括号会报语法错误
chain = prompt
    | model  # SyntaxError
    | parser
```

### 6.2 括号与优先级

```python
# 括号控制执行顺序
chain1 = (prompt | model) | parser  # 先组合 prompt 和 model
chain2 = prompt | (model | parser)  # 先组合 model 和 parser

# 实际上两者等价，因为 | 是左结合的
# chain1 和 chain2 的执行顺序相同
```

---

## 7. 管道的返回值

### 7.1 管道返回新的 Runnable

```python
# 管道操作返回 RunnableSequence
chain = prompt | model | parser

print(type(chain))
# 输出: <class 'langchain_core.runnables.base.RunnableSequence'>

# RunnableSequence 也是 Runnable
isinstance(chain, Runnable)  # True
```

### 7.2 管道可以继续组合

```python
# 基础链
base_chain = prompt | model

# 继续组合
full_chain = base_chain | parser

# 再继续组合
enhanced_chain = full_chain | validator

# 等价于
enhanced_chain = prompt | model | parser | validator
```

---

## 8. 在 AI Agent 中的应用

### 8.1 简单问答链

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser

# 构建问答链
qa_chain = (
    ChatPromptTemplate.from_template("回答问题：{question}")
    | ChatOpenAI(model="gpt-4o-mini")
    | StrOutputParser()
)

# 使用
answer = qa_chain.invoke({"question": "什么是 LangChain？"})
```

### 8.2 RAG 检索增强生成

```python
from langchain_core.runnables import RunnablePassthrough
from langchain_chroma import Chroma
from langchain_openai import OpenAIEmbeddings

# 创建检索器
vector_store = Chroma(
    collection_name="docs",
    embedding_function=OpenAIEmbeddings()
)
retriever = vector_store.as_retriever()

# 构建 RAG 链
rag_chain = (
    {
        "context": retriever,
        "question": RunnablePassthrough()
    }
    | ChatPromptTemplate.from_template(
        "基于上下文回答：{context}\n\n问题：{question}"
    )
    | ChatOpenAI(model="gpt-4o-mini")
    | StrOutputParser()
)

# 使用
answer = rag_chain.invoke("什么是向量数据库？")
```

### 8.3 多步推理链

```python
# 步骤1: 分析问题
analyzer = (
    ChatPromptTemplate.from_template("分析问题：{question}")
    | ChatOpenAI(model="gpt-4o-mini")
    | StrOutputParser()
)

# 步骤2: 生成答案
generator = (
    ChatPromptTemplate.from_template("基于分析生成答案：{analysis}")
    | ChatOpenAI(model="gpt-4o-mini")
    | StrOutputParser()
)

# 组合成多步链
reasoning_chain = (
    {"analysis": analyzer, "question": RunnablePassthrough()}
    | generator
)
```

---

## 9. 语法糖对比

### 9.1 管道 vs 嵌套调用

```python
# 管道语法（推荐）
chain = prompt | model | parser
result = chain.invoke(input)

# 等价的嵌套调用（不推荐）
result = parser.parse(
    model.invoke(
        prompt.format(input)
    )
)
```

**管道的优势**：
- 从左到右，易读
- 可以分步调试
- 支持多种调用方式（invoke/batch/stream）

### 9.2 管道 vs 方法链

```python
# 管道语法（LangChain）
chain = prompt | model | parser

# 方法链语法（假设）
chain = prompt.then(model).then(parser)
```

**为什么选择管道**：
- 更简洁（`|` vs `.then()`）
- 更 Pythonic（运算符重载）
- 更灵活（可以用在任何 Runnable）

---

## 10. 常见错误

### 错误1：类型不匹配

```python
# ❌ 错误
chain = prompt | parser  # 跳过了 model

# ✅ 正确
chain = prompt | model | parser
```

### 错误2：字典键不匹配

```python
# Prompt 期望 {context} 和 {question}
prompt = ChatPromptTemplate.from_template("{context}\n{question}")

# ❌ 错误：键名不对
chain = (
    {"ctx": retriever, "q": RunnablePassthrough()}
    | prompt
)

# ✅ 正确
chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
)
```

### 错误3：忘记括号

```python
# ❌ 错误：多行不用括号
chain = prompt
    | model  # SyntaxError
    | parser

# ✅ 正确
chain = (
    prompt
    | model
    | parser
)
```

---

## 11. 最佳实践

### 实践1：每行一个步骤

```python
# ✅ 好：清晰易读
chain = (
    prompt
    | model
    | parser
    | validator
)

# ❌ 差：一行太长
chain = prompt | model | parser | validator
```

### 实践2：给复杂管道命名

```python
# ✅ 好：子管道有意义的名字
retrieval_chain = retriever | reranker
generation_chain = prompt | model | parser

rag_chain = (
    {"context": retrieval_chain, "question": RunnablePassthrough()}
    | generation_chain
)

# ❌ 差：全部内联，难以理解
rag_chain = (
    {"context": retriever | reranker, "question": RunnablePassthrough()}
    | prompt | model | parser
)
```

### 实践3：类型注释

```python
from langchain_core.runnables import Runnable

# ✅ 好：添加类型注释
qa_chain: Runnable[dict, str] = (
    prompt
    | model
    | parser
)

# 类型注释帮助 IDE 提供更好的补全
```

---

## 12. 语法总结

| 语法 | 说明 | 示例 |
|------|------|------|
| `a \| b` | 连接两个 Runnable | `prompt \| model` |
| `a \| b \| c` | 连接多个 Runnable | `prompt \| model \| parser` |
| `(a \| b)` | 括号分组 | `(prompt \| model) \| parser` |
| `{k: v} \| a` | 字典作为起点 | `{"context": retriever} \| prompt` |
| `a \| {k: v}` | 字典作为终点（少见） | `model \| {"result": parser}` |

---

## 13. 快速参考

### 基础模板

```python
# 最简单的链
chain = prompt | model | parser

# RAG 链
rag_chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
    | model
    | parser
)

# 多步链
multi_step = (
    step1
    | step2
    | step3
)
```

### 调用方式

```python
# 同步
result = chain.invoke(input)

# 异步
result = await chain.ainvoke(input)

# 批量
results = chain.batch([input1, input2])

# 流式
for chunk in chain.stream(input):
    print(chunk, end="")
```

---

## 14. 学习检查

完成本节后，检查是否掌握：

- [ ] 能写出 `prompt | model | parser` 基础链
- [ ] 理解数据从左到右流动
- [ ] 知道类型必须匹配
- [ ] 能使用字典传递多个值
- [ ] 知道何时需要括号
- [ ] 能识别常见语法错误
- [ ] 能在 RAG 场景中应用管道语法

---

[Source: LangChain Official Docs - https://python.langchain.com/docs/concepts/]
[Source: Pinecone LCEL Tutorial - https://www.pinecone.io/learn/series/langchain/langchain-expression-language]
