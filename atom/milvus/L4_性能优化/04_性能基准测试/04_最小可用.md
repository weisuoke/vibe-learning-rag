# 最小可用

> 掌握以下内容，就能开始进行 Milvus 性能基准测试

---

## 4.1 理解核心指标

**性能测试的三大核心指标：**

```python
# 1. QPS (Queries Per Second) - 吞吐量
# 含义：每秒能处理多少个查询请求
qps = total_queries / total_time_seconds

# 2. 延迟 (Latency) - 响应时间
# 含义：单个查询从发起到返回结果的时间
latency_ms = (end_time - start_time) * 1000

# 3. 召回率 (Recall) - 准确性
# 含义：检索结果中真正相关的比例
recall = len(retrieved_relevant) / len(all_relevant)
```

**在 Milvus 中的应用：**
- QPS：评估系统吞吐能力
- 延迟：评估用户体验（P50、P95、P99）
- 召回率：评估检索质量

---

## 4.2 编写基础性能测试脚本

**最简单的性能测试代码：**

```python
import time
from pymilvus import connections, Collection

# 连接 Milvus
connections.connect("default", host="localhost", port="19530")
collection = Collection("my_collection")

# 准备测试数据
test_vectors = [[0.1] * 768 for _ in range(100)]  # 100个测试向量

# 性能测试
start_time = time.time()
for vector in test_vectors:
    results = collection.search(
        data=[vector],
        anns_field="embedding",
        param={"metric_type": "L2", "params": {"nprobe": 10}},
        limit=10
    )
end_time = time.time()

# 计算指标
total_time = end_time - start_time
qps = len(test_vectors) / total_time
avg_latency = (total_time / len(test_vectors)) * 1000

print(f"QPS: {qps:.2f}")
print(f"平均延迟: {avg_latency:.2f}ms")
```

**这段代码能做什么：**
- ✅ 测试基本的查询性能
- ✅ 计算 QPS 和平均延迟
- ✅ 快速验证系统是否正常工作

---

## 4.3 对比不同配置的性能

**测试不同 nprobe 值的性能差异：**

```python
import time
from pymilvus import Collection

collection = Collection("my_collection")
test_vector = [[0.1] * 768]

# 测试不同 nprobe 值
nprobe_values = [10, 50, 100]

for nprobe in nprobe_values:
    start = time.time()

    # 执行100次查询
    for _ in range(100):
        collection.search(
            data=test_vector,
            anns_field="embedding",
            param={"metric_type": "L2", "params": {"nprobe": nprobe}},
            limit=10
        )

    elapsed = time.time() - start
    avg_latency = (elapsed / 100) * 1000

    print(f"nprobe={nprobe}: 平均延迟={avg_latency:.2f}ms")
```

**输出示例：**
```
nprobe=10: 平均延迟=15.23ms
nprobe=50: 平均延迟=35.67ms
nprobe=100: 平均延迟=68.45ms
```

**这段代码能做什么：**
- ✅ 对比不同参数的性能
- ✅ 找到性能和召回率的平衡点
- ✅ 为参数调优提供数据支持

---

## 4.4 计算召回率

**验证检索结果的准确性：**

```python
import numpy as np
from pymilvus import Collection

def calculate_recall(ground_truth_ids, search_result_ids, k=10):
    """
    计算 Recall@K

    Args:
        ground_truth_ids: 真实的相关结果ID列表
        search_result_ids: 检索返回的结果ID列表
        k: 取前K个结果

    Returns:
        召回率 (0-1之间)
    """
    ground_truth_set = set(ground_truth_ids[:k])
    search_result_set = set(search_result_ids[:k])

    # 计算交集
    intersection = ground_truth_set & search_result_set

    # 召回率 = 检索到的相关结果数 / 真实相关结果数
    recall = len(intersection) / len(ground_truth_set)

    return recall

# 使用示例
collection = Collection("my_collection")

# 1. 使用 FLAT 索引获取真实结果（ground truth）
ground_truth = collection.search(
    data=[[0.1] * 768],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {}},
    limit=100
)
ground_truth_ids = [hit.id for hit in ground_truth[0]]

# 2. 使用 HNSW 索引获取检索结果
search_result = collection.search(
    data=[[0.1] * 768],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"ef": 64}},
    limit=100
)
search_result_ids = [hit.id for hit in search_result[0]]

# 3. 计算召回率
recall = calculate_recall(ground_truth_ids, search_result_ids, k=10)
print(f"Recall@10: {recall:.2%}")
```

**这段代码能做什么：**
- ✅ 量化检索质量
- ✅ 对比不同索引类型的准确性
- ✅ 验证参数调优是否影响召回率

---

## 4.5 使用 Locust 进行压力测试

**测试高并发场景下的性能：**

```python
# locustfile.py
from locust import User, task, between
from pymilvus import connections, Collection
import random

class MilvusUser(User):
    wait_time = between(0.1, 0.5)  # 每次请求间隔0.1-0.5秒

    def on_start(self):
        """初始化连接"""
        connections.connect("default", host="localhost", port="19530")
        self.collection = Collection("my_collection")
        self.collection.load()

    @task
    def search_vector(self):
        """执行向量检索"""
        # 生成随机向量
        vector = [random.random() for _ in range(768)]

        # 执行检索
        self.collection.search(
            data=[vector],
            anns_field="embedding",
            param={"metric_type": "L2", "params": {"nprobe": 10}},
            limit=10
        )

# 运行命令：
# locust -f locustfile.py --host=http://localhost:19530
```

**这段代码能做什么：**
- ✅ 模拟多用户并发访问
- ✅ 测试系统在高负载下的表现
- ✅ 发现性能瓶颈和稳定性问题

---

## 这些知识足以

完成以上5个部分的学习后，你已经能够：

✅ **量化性能表现**
- 计算 QPS、延迟、召回率等核心指标
- 用数据说话，而非主观感受

✅ **对比不同配置**
- 测试不同索引类型的性能差异
- 测试不同参数配置的性能差异
- 找到最优配置

✅ **验证检索质量**
- 计算召回率，确保检索准确性
- 平衡性能和准确性

✅ **进行压力测试**
- 模拟高并发场景
- 发现性能瓶颈

✅ **为后续学习打基础**
- 理解性能测试的核心概念
- 掌握基本的测试方法和工具
- 为深入学习性能优化做准备

---

## 快速实践

**5分钟快速测试：**

```python
import time
from pymilvus import connections, Collection

# 1. 连接
connections.connect("default", host="localhost", port="19530")
collection = Collection("my_collection")
collection.load()

# 2. 准备测试数据
test_vectors = [[0.1] * 768 for _ in range(100)]

# 3. 性能测试
start = time.time()
for vector in test_vectors:
    collection.search(
        data=[vector],
        anns_field="embedding",
        param={"metric_type": "L2", "params": {"nprobe": 10}},
        limit=10
    )
elapsed = time.time() - start

# 4. 输出结果
print(f"总耗时: {elapsed:.2f}秒")
print(f"QPS: {100/elapsed:.2f}")
print(f"平均延迟: {(elapsed/100)*1000:.2f}ms")
```

**运行这段代码，你就完成了第一次性能测试！**

---

## 下一步学习

掌握了最小可用知识后，可以深入学习：

1. **核心概念1：性能测试方法论** - 系统化的测试设计方法
2. **核心概念2：性能测试工具** - 专业的测试工具和框架
3. **核心概念3：性能指标分析** - 深入理解各种性能指标
4. **实战代码** - 更复杂的测试场景和优化技巧

---

## 常见问题

**Q1: 测试多少次才准确？**
- 单次测试：不准确，受偶然因素影响
- 建议：至少100次，取平均值和百分位数

**Q2: 测试环境要求？**
- 独立环境：避免其他程序干扰
- 稳定网络：避免网络波动影响
- 预热系统：先执行几次查询，让缓存生效

**Q3: 如何选择测试数据？**
- 真实数据：最好使用生产环境的真实数据
- 数据规模：与生产环境一致
- 数据分布：与生产环境一致

**Q4: QPS 多少算好？**
- 没有绝对标准，取决于：
  - 硬件配置（CPU、内存）
  - 索引类型（HNSW、IVF_FLAT）
  - 数据规模（向量数量、维度）
  - 查询参数（top_k、nprobe）
- 建议：与业务需求对比，而非追求绝对值
