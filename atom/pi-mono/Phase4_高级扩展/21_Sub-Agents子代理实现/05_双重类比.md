# 双重类比

## 类比1：Sub-Agent 本身

### TypeScript/Node.js 类比：子进程（Child Process）

**相似性**：
- Sub-Agent 就像 Node.js 的 `child_process.spawn()`
- 每个子进程有独立的内存空间和执行环境
- 父进程通过 IPC（进程间通信）与子进程交互
- 子进程可以并行执行

```typescript
// Node.js 子进程
import { spawn } from 'child_process';

const child = spawn('node', ['worker.js']);
child.stdout.on('data', (data) => {
  console.log(`Output: ${data}`);
});

// Sub-Agent（概念上类似）
const result = await callTool('subagent', {
  agent: 'worker',
  task: 'Process data'
});
```

**关键区别**：
- 子进程运行任意程序，Sub-Agent 运行 `pi` 进程
- Sub-Agent 有 AI 能力（LLM），子进程只是执行代码

### 日常生活类比：分包商（Subcontractor）

**相似性**：
- 你是总承包商（主 Agent），有一个大项目
- 你雇佣专业分包商（Sub-Agents）处理特定任务
- 每个分包商有自己的工具和专业知识
- 分包商独立工作，完成后向你汇报

**场景**：
```
你要装修房子（复杂任务）
  ↓
雇佣电工（Scout Agent）→ 检查电路
雇佣水管工（Planner Agent）→ 设计管道布局
雇佣木工（Worker Agent）→ 安装家具
雇佣验收员（Reviewer Agent）→ 检查质量
  ↓
每个分包商独立工作，互不干扰
```

**关键特点**：
- 专业化：每个分包商有专长
- 独立性：各自有工具和工作空间
- 协作：通过你（总承包商）协调

---

## 类比2：Agent 发现机制

### TypeScript/Node.js 类比：服务注册与发现

**相似性**：
- Agent 发现就像微服务架构中的服务注册
- 用户级别 agents = 全局服务注册中心（如 Consul）
- 项目级别 agents = 本地服务配置（如 docker-compose.yml）

```typescript
// 服务注册（类比 Agent 定义）
const serviceRegistry = {
  'scout': {
    endpoint: '/scout',
    capabilities: ['read', 'grep', 'find'],
    model: 'fast'
  },
  'worker': {
    endpoint: '/worker',
    capabilities: ['all'],
    model: 'powerful'
  }
};

// 服务发现（类比 Agent 发现）
function discoverService(name: string) {
  return serviceRegistry[name];
}
```

**关键相似点**：
- 动态发现：运行时查找可用服务/agents
- 配置驱动：通过配置文件定义服务/agents
- 优先级：本地配置覆盖全局配置

### 日常生活类比：通讯录

**相似性**：
- 用户级别 agents = 你的个人通讯录（随身携带）
- 项目级别 agents = 项目团队通讯录（项目特定）
- Agent 发现 = 查找通讯录找专家

**场景**：
```
你需要找专家帮忙
  ↓
先查个人通讯录（用户 agents）
  ├─ 找到了 → 直接联系
  └─ 没找到 → 查项目通讯录（项目 agents）
      ├─ 找到了 → 确认是否信任 → 联系
      └─ 没找到 → 报错
```

**关键特点**：
- 个人通讯录：始终可用，完全信任
- 项目通讯录：项目特定，需要验证
- 优先级：项目通讯录优先（如果启用）

---

## 类比3：三种执行模式

### TypeScript/Node.js 类比：异步编程模式

**Single Mode = 单个 Promise**
```typescript
// Single Mode
const result = await fetchData();

// Sub-Agent Single
const result = await callTool('subagent', {
  agent: 'scout',
  task: 'Find auth code'
});
```

**Parallel Mode = Promise.all()**
```typescript
// Parallel Mode
const results = await Promise.all([
  fetchUsers(),
  fetchPosts(),
  fetchComments()
]);

// Sub-Agent Parallel
const results = await callTool('subagent', {
  tasks: [
    { agent: 'scout', task: 'Find users' },
    { agent: 'scout', task: 'Find posts' },
    { agent: 'scout', task: 'Find comments' }
  ]
});
```

**Chain Mode = 链式 Promise**
```typescript
// Chain Mode
const result = await fetchData()
  .then(data => processData(data))
  .then(processed => saveData(processed));

// Sub-Agent Chain
const result = await callTool('subagent', {
  chain: [
    { agent: 'scout', task: 'Find data' },
    { agent: 'planner', task: 'Process {previous}' },
    { agent: 'worker', task: 'Save {previous}' }
  ]
});
```

### 日常生活类比：做饭流程

**Single Mode = 做一道菜**
```
你：做一道宫保鸡丁
  ↓
厨师：完成 → 上菜
```

**Parallel Mode = 同时做多道菜**
```
你：同时做三道菜
  ↓
厨师1：做宫保鸡丁 ┐
厨师2：做麻婆豆腐 ├→ 并行
厨师3：做酸辣汤   ┘
  ↓
三道菜同时上桌
```

**Chain Mode = 流水线做菜**
```
你：做一道复杂的菜
  ↓
厨师1：准备食材 → 传给厨师2
  ↓
厨师2：炒制 → 传给厨师3
  ↓
厨师3：装盘 → 上菜
```

**关键区别**：
- Single：一个任务，一个结果
- Parallel：多个独立任务，多个结果
- Chain：多个依赖任务，最终一个结果

---

## 类比4：任务委托机制

### TypeScript/Node.js 类比：函数调用 vs 进程生成

**函数调用（共享上下文）**
```typescript
// 函数调用 - 共享内存
function processData(data: string) {
  // 可以访问外部变量
  return data.toUpperCase();
}

const result = processData("hello"); // 共享上下文
```

**进程生成（隔离上下文）**
```typescript
// 进程生成 - 独立内存
import { spawn } from 'child_process';

const child = spawn('pi', ['--mode', 'json', 'Task: process data']);
// 完全独立的上下文，无法访问父进程变量
```

**Sub-Agent 是后者**：
- 每个 Sub-Agent 是独立的 `pi` 进程
- 有自己的上下文窗口
- 通过 JSON 输出传递结果

### 日常生活类比：委托任务

**内部委托（共享信息）**
```
你：小王，帮我整理这些文件
小王：好的（可以看到你桌上的所有文件）
```

**外部委托（隔离信息）**
```
你：外包公司，帮我整理这些文件
外包公司：请发送文件（无法看到你的其他信息）
  ↓
你：发送文件
  ↓
外包公司：完成 → 返回结果
```

**Sub-Agent 是外部委托**：
- 主 Agent 不能直接访问 Sub-Agent 的"思考过程"
- 只能通过任务描述和结果输出交互
- 完全隔离，互不干扰

---

## 类比5：上下文隔离

### TypeScript/Node.js 类比：内存空间隔离

**共享内存（单 Agent）**
```typescript
// 所有变量在同一个作用域
let context = "";
context += "User request...";
context += "Tool call 1...";
context += "Tool call 2...";
// 上下文越来越大，可能超出限制
```

**独立内存（Sub-Agents）**
```typescript
// 每个进程有独立的内存空间
// 主进程
let mainContext = "User request...";

// 子进程1（独立内存）
let subContext1 = "Task 1...";

// 子进程2（独立内存）
let subContext2 = "Task 2...";

// 互不影响，各自有完整的内存空间
```

**类比 Docker 容器**：
```typescript
// 主机（主 Agent）
Host: {
  context: "Main context"
}

// 容器1（Sub-Agent 1）
Container1: {
  context: "Sub context 1",
  isolated: true
}

// 容器2（Sub-Agent 2）
Container2: {
  context: "Sub context 2",
  isolated: true
}
```

### 日常生活类比：工作空间

**共享办公室（单 Agent）**
```
你在一个办公室工作
  ↓
桌上堆满了所有项目的文件
  ↓
找东西很困难，容易混乱
```

**独立办公室（Sub-Agents）**
```
你是项目经理，有自己的办公室
  ↓
每个团队成员有自己的办公室
  ├─ 成员1：只有项目A的文件
  ├─ 成员2：只有项目B的文件
  └─ 成员3：只有项目C的文件
  ↓
各自专注，互不干扰
```

**关键优势**：
- 专注：每个空间只有相关信息
- 清晰：不会被无关信息干扰
- 可扩展：每个空间都有完整容量

---

## 类比总结表

| Sub-Agents 概念 | TypeScript/Node.js 类比 | 日常生活类比 |
|----------------|------------------------|--------------|
| **Sub-Agent** | 子进程（child_process） | 分包商 |
| **Agent 发现** | 服务注册与发现 | 通讯录 |
| **Single Mode** | 单个 Promise | 做一道菜 |
| **Parallel Mode** | Promise.all() | 同时做多道菜 |
| **Chain Mode** | 链式 Promise | 流水线做菜 |
| **任务委托** | 进程生成（spawn） | 外部委托 |
| **上下文隔离** | 独立内存空间 | 独立办公室 |
| **Agent 定义** | 服务配置文件 | 员工简历 |
| **工具集** | API 端点列表 | 工具箱 |
| **模型选择** | 服务器规格 | 员工技能等级 |
| **安全模型** | 权限控制（ACL） | 门禁系统 |
| **确认提示** | OAuth 授权 | 访客登记 |

---

## 核心洞察

### 1. 进程隔离 = 独立思考空间

**TypeScript 视角**：
```typescript
// 不是这样（函数调用，共享上下文）
function subAgent(task: string) {
  // 可以访问外部变量
}

// 而是这样（进程隔离，独立上下文）
spawn('pi', ['--mode', 'json', `Task: ${task}`]);
```

**生活视角**：
- 不是在同一个房间里讨论（会互相干扰）
- 而是每个人在自己的房间里工作（专注且独立）

### 2. 专业化 = 不同的工具箱

**TypeScript 视角**：
```typescript
// Scout Agent（轻量级）
{
  tools: ['read', 'grep', 'find'],
  model: 'claude-haiku-4-5'  // 快速、便宜
}

// Worker Agent（全功能）
{
  tools: ['all'],
  model: 'claude-sonnet-4'  // 强大、昂贵
}
```

**生活视角**：
- 侦查员：只带望远镜和笔记本（轻装上阵）
- 施工队：带全套工具（重装备）

### 3. 协作 = 结果传递

**TypeScript 视角**：
```typescript
// Chain 模式
const step1Result = await agent1.execute();
const step2Result = await agent2.execute(step1Result);
const step3Result = await agent3.execute(step2Result);
```

**生活视角**：
- 接力赛：每个人跑完自己的一段，传递接力棒
- 流水线：每个工位完成自己的工作，传递给下一个

---

## 记住这些类比

1. **Sub-Agent = 分包商**：专业、独立、协作
2. **Agent 发现 = 通讯录**：查找、验证、联系
3. **执行模式 = 做饭方式**：单道菜、多道菜、流水线
4. **任务委托 = 外部委托**：隔离、专注、结果导向
5. **上下文隔离 = 独立办公室**：专注、清晰、可扩展

**核心理念**：Sub-Agents 不是简单的函数调用，而是独立的"思考者"，有自己的工具、知识和工作空间。
