# 核心概念：响应模型

> FastAPI 的响应模型：用 response_model 定义响应格式，自动过滤和验证

---

## 什么是响应模型？

**响应模型 = 定义 API 响应的数据结构和格式**

```
路由函数返回数据 → 响应模型验证 → 过滤字段 → 返回给客户端
```

**核心作用：**
1. **数据过滤** - 自动过滤敏感字段（如 password）
2. **数据验证** - 确保响应数据符合定义
3. **文档生成** - 自动生成 API 文档
4. **类型安全** - 编辑器提示和类型检查

---

## 1. 基础响应模型

### 1.1 定义响应模型

**使用 Pydantic 模型：**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    # 不包含 password

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    # 假设从数据库获取用户
    user = {
        "id": user_id,
        "username": "alice",
        "email": "alice@example.com",
        "password": "secret123"  # 敏感信息
    }
    # FastAPI 自动过滤 password 字段
    return user

# 响应：
# {
#   "id": 1,
#   "username": "alice",
#   "email": "alice@example.com"
# }
# password 字段被自动过滤
```

**为什么需要响应模型？**

```python
# ❌ 不使用响应模型
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = db.query(User).get(user_id)
    # 需要手动删除敏感字段
    return {
        "id": user.id,
        "username": user.username,
        "email": user.email
        # 忘记删除 password 会泄露敏感信息
    }

# ✅ 使用响应模型
@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    user = db.query(User).get(user_id)
    # FastAPI 自动过滤，不会泄露 password
    return user
```

---

### 1.2 响应模型的优势

**1. 自动过滤字段：**

```python
class User(BaseModel):
    id: int
    username: str
    email: str
    password: str
    is_active: bool
    created_at: datetime

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    # 只包含需要返回的字段

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    user = User(
        id=1,
        username="alice",
        email="alice@example.com",
        password="secret123",
        is_active=True,
        created_at=datetime.now()
    )
    # 返回完整的 User 对象
    # FastAPI 自动过滤，只返回 UserResponse 定义的字段
    return user
```

**2. 数据验证：**

```python
class ItemResponse(BaseModel):
    id: int
    name: str
    price: float

@app.get("/items/{item_id}", response_model=ItemResponse)
async def get_item(item_id: int):
    # 如果返回的数据不符合 ItemResponse，FastAPI 会抛出错误
    return {
        "id": item_id,
        "name": "Laptop",
        "price": "invalid"  # ❌ 类型错误，FastAPI 会报错
    }
```

**3. 自动文档：**

```python
@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    """获取用户信息"""
    return user

# 访问 /docs 可以看到：
# - 响应示例
# - 响应字段说明
# - 响应数据类型
```

---

## 2. 响应模型配置

### 2.1 response_model_exclude

**排除特定字段：**

```python
class User(BaseModel):
    id: int
    username: str
    email: str
    password: str

@app.get(
    "/users/{user_id}",
    response_model=User,
    response_model_exclude={"password"}  # 排除 password
)
async def get_user(user_id: int):
    return User(
        id=user_id,
        username="alice",
        email="alice@example.com",
        password="secret123"
    )

# 响应：
# {
#   "id": 1,
#   "username": "alice",
#   "email": "alice@example.com"
# }
```

**排除多个字段：**

```python
@app.get(
    "/users/{user_id}",
    response_model=User,
    response_model_exclude={"password", "email"}
)
async def get_user(user_id: int):
    return user
```

---

### 2.2 response_model_include

**只包含特定字段：**

```python
class User(BaseModel):
    id: int
    username: str
    email: str
    password: str
    is_active: bool
    created_at: datetime

@app.get(
    "/users/{user_id}",
    response_model=User,
    response_model_include={"id", "username"}  # 只包含这两个字段
)
async def get_user(user_id: int):
    return user

# 响应：
# {
#   "id": 1,
#   "username": "alice"
# }
```

---

### 2.3 response_model_exclude_unset

**排除未设置的字段：**

```python
class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

@app.post(
    "/items",
    response_model=Item,
    response_model_exclude_unset=True  # 排除未设置的字段
)
async def create_item(item: Item):
    return item

# 请求：
# {"name": "Laptop", "price": 999.99}

# 响应（不包含 description 和 tax）：
# {
#   "name": "Laptop",
#   "price": 999.99
# }
```

---

### 2.4 response_model_exclude_defaults

**排除默认值字段：**

```python
class Item(BaseModel):
    name: str
    description: str = "No description"
    price: float
    tax: float = 0.0

@app.post(
    "/items",
    response_model=Item,
    response_model_exclude_defaults=True  # 排除默认值
)
async def create_item(item: Item):
    return item

# 请求：
# {"name": "Laptop", "price": 999.99}

# 响应（不包含 description 和 tax，因为它们是默认值）：
# {
#   "name": "Laptop",
#   "price": 999.99
# }
```

---

### 2.5 response_model_exclude_none

**排除 None 值字段：**

```python
class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

@app.get(
    "/items/{item_id}",
    response_model=Item,
    response_model_exclude_none=True  # 排除 None 值
)
async def get_item(item_id: int):
    return Item(
        name="Laptop",
        description=None,
        price=999.99,
        tax=None
    )

# 响应（不包含 description 和 tax）：
# {
#   "name": "Laptop",
#   "price": 999.99
# }
```

---

## 3. 多个响应模型

### 3.1 不同状态码的响应

**定义多个响应模型：**

```python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    id: int
    name: str
    price: float

class ErrorResponse(BaseModel):
    detail: str

@app.get(
    "/items/{item_id}",
    response_model=Item,
    responses={
        200: {"model": Item, "description": "Successful response"},
        404: {"model": ErrorResponse, "description": "Item not found"},
        400: {"model": ErrorResponse, "description": "Invalid request"}
    }
)
async def get_item(item_id: int):
    if item_id < 1:
        raise HTTPException(
            status_code=400,
            detail="Invalid item ID"
        )

    item = db.query(Item).get(item_id)
    if not item:
        raise HTTPException(
            status_code=404,
            detail="Item not found"
        )

    return item
```

---

### 3.2 联合类型响应

**使用 Union 返回不同类型：**

```python
from typing import Union
from pydantic import BaseModel

class UserResponse(BaseModel):
    id: int
    username: str
    type: str = "user"

class AdminResponse(BaseModel):
    id: int
    username: str
    permissions: list[str]
    type: str = "admin"

@app.get("/users/{user_id}", response_model=Union[UserResponse, AdminResponse])
async def get_user(user_id: int):
    user = db.query(User).get(user_id)

    if user.is_admin:
        return AdminResponse(
            id=user.id,
            username=user.username,
            permissions=user.permissions
        )
    else:
        return UserResponse(
            id=user.id,
            username=user.username
        )
```

---

## 4. 列表响应

### 4.1 返回列表

**使用 List[Model]：**

```python
from typing import List
from pydantic import BaseModel

class Item(BaseModel):
    id: int
    name: str
    price: float

@app.get("/items", response_model=List[Item])
async def list_items():
    items = db.query(Item).all()
    return items

# 响应：
# [
#   {"id": 1, "name": "Laptop", "price": 999.99},
#   {"id": 2, "name": "Mouse", "price": 29.99}
# ]
```

---

### 4.2 分页响应

**包装列表响应：**

```python
from typing import List, Generic, TypeVar
from pydantic import BaseModel

T = TypeVar('T')

class PaginatedResponse(BaseModel, Generic[T]):
    items: List[T]
    total: int
    page: int
    page_size: int
    total_pages: int

class Item(BaseModel):
    id: int
    name: str
    price: float

@app.get("/items", response_model=PaginatedResponse[Item])
async def list_items(page: int = 1, page_size: int = 10):
    skip = (page - 1) * page_size
    items = db.query(Item).offset(skip).limit(page_size).all()
    total = db.query(Item).count()

    return PaginatedResponse(
        items=items,
        total=total,
        page=page,
        page_size=page_size,
        total_pages=(total + page_size - 1) // page_size
    )

# 响应：
# {
#   "items": [
#     {"id": 1, "name": "Laptop", "price": 999.99},
#     {"id": 2, "name": "Mouse", "price": 29.99}
#   ],
#   "total": 100,
#   "page": 1,
#   "page_size": 10,
#   "total_pages": 10
# }
```

---

## 5. 嵌套响应模型

### 5.1 嵌套模型

**定义嵌套结构：**

```python
from typing import List
from pydantic import BaseModel

class Tag(BaseModel):
    name: str
    color: str

class Author(BaseModel):
    id: int
    username: str

class Post(BaseModel):
    id: int
    title: str
    content: str
    author: Author
    tags: List[Tag]

@app.get("/posts/{post_id}", response_model=Post)
async def get_post(post_id: int):
    post = db.query(Post).get(post_id)
    return post

# 响应：
# {
#   "id": 1,
#   "title": "FastAPI Tutorial",
#   "content": "...",
#   "author": {
#     "id": 1,
#     "username": "alice"
#   },
#   "tags": [
#     {"name": "python", "color": "blue"},
#     {"name": "fastapi", "color": "green"}
#   ]
# }
```

---

### 5.2 循环引用

**处理循环引用：**

```python
from typing import List, Optional
from pydantic import BaseModel

class User(BaseModel):
    id: int
    username: str
    posts: List['Post'] = []

    class Config:
        from_attributes = True

class Post(BaseModel):
    id: int
    title: str
    author: Optional[User] = None

    class Config:
        from_attributes = True

# 更新前向引用
User.model_rebuild()

@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: int):
    user = db.query(User).get(user_id)
    return user
```

---

## 6. 状态码

### 6.1 自定义状态码

**使用 status_code 参数：**

```python
from fastapi import status

# 201 Created
@app.post("/items", status_code=status.HTTP_201_CREATED)
async def create_item(item: Item):
    return item

# 204 No Content
@app.delete("/items/{item_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_item(item_id: int):
    db.delete(item_id)
    return None

# 202 Accepted
@app.post("/tasks", status_code=status.HTTP_202_ACCEPTED)
async def create_task(task: Task):
    # 异步任务
    return {"message": "Task accepted"}
```

**常用状态码：**

| 状态码 | 含义 | 使用场景 |
|--------|------|----------|
| 200 | OK | 成功获取资源 |
| 201 | Created | 成功创建资源 |
| 202 | Accepted | 请求已接受，但未完成 |
| 204 | No Content | 成功删除资源 |
| 400 | Bad Request | 请求参数错误 |
| 401 | Unauthorized | 未认证 |
| 403 | Forbidden | 无权限 |
| 404 | Not Found | 资源不存在 |
| 422 | Unprocessable Entity | 验证失败 |
| 500 | Internal Server Error | 服务器错误 |

---

### 6.2 动态状态码

**使用 Response 对象：**

```python
from fastapi import Response, status

@app.post("/items")
async def create_item(item: Item, response: Response):
    if item.id:
        # 更新现有资源
        response.status_code = status.HTTP_200_OK
    else:
        # 创建新资源
        response.status_code = status.HTTP_201_CREATED

    return item
```

---

## 7. 响应头

### 7.1 自定义响应头

**使用 Response 对象：**

```python
from fastapi import Response

@app.get("/items/{item_id}")
async def get_item(item_id: int, response: Response):
    item = db.query(Item).get(item_id)

    # 添加自定义响应头
    response.headers["X-Item-ID"] = str(item_id)
    response.headers["X-Custom-Header"] = "custom-value"

    return item
```

**在路由装饰器中定义：**

```python
@app.get(
    "/items/{item_id}",
    response_model=Item,
    responses={
        200: {
            "description": "Successful response",
            "headers": {
                "X-Item-ID": {
                    "description": "The item ID",
                    "schema": {"type": "integer"}
                }
            }
        }
    }
)
async def get_item(item_id: int, response: Response):
    response.headers["X-Item-ID"] = str(item_id)
    return item
```

---

## 8. 特殊响应类型

### 8.1 JSONResponse

**自定义 JSON 响应：**

```python
from fastapi.responses import JSONResponse

@app.get("/items/{item_id}")
async def get_item(item_id: int):
    if item_id < 1:
        return JSONResponse(
            status_code=400,
            content={"detail": "Invalid item ID"}
        )

    item = db.query(Item).get(item_id)
    if not item:
        return JSONResponse(
            status_code=404,
            content={"detail": "Item not found"}
        )

    return item
```

---

### 8.2 PlainTextResponse

**返回纯文本：**

```python
from fastapi.responses import PlainTextResponse

@app.get("/health", response_class=PlainTextResponse)
async def health_check():
    return "OK"
```

---

### 8.3 HTMLResponse

**返回 HTML：**

```python
from fastapi.responses import HTMLResponse

@app.get("/", response_class=HTMLResponse)
async def root():
    return """
    <html>
        <head><title>FastAPI</title></head>
        <body><h1>Hello, FastAPI!</h1></body>
    </html>
    """
```

---

### 8.4 FileResponse

**返回文件：**

```python
from fastapi.responses import FileResponse

@app.get("/download/{filename}")
async def download_file(filename: str):
    file_path = f"/path/to/files/{filename}"
    return FileResponse(
        path=file_path,
        filename=filename,
        media_type="application/octet-stream"
    )
```

---

### 8.5 StreamingResponse

**流式响应：**

```python
from fastapi.responses import StreamingResponse
import asyncio

async def generate_data():
    for i in range(10):
        yield f"data: {i}\n\n"
        await asyncio.sleep(1)

@app.get("/stream")
async def stream():
    return StreamingResponse(
        generate_data(),
        media_type="text/event-stream"
    )
```

---

## 9. 在 AI Agent 后端中的应用

### 9.1 对话响应

```python
from pydantic import BaseModel
from typing import List

class Message(BaseModel):
    role: str
    content: str

class ChatResponse(BaseModel):
    reply: str
    conversation_id: str
    messages: List[Message]

@app.post("/chat", response_model=ChatResponse)
async def chat(message: str, conversation_id: str | None = None):
    # 处理对话
    reply = process_message(message, conversation_id)

    return ChatResponse(
        reply=reply,
        conversation_id=conversation_id or "new",
        messages=[
            Message(role="user", content=message),
            Message(role="assistant", content=reply)
        ]
    )
```

---

### 9.2 流式对话响应

```python
from fastapi.responses import StreamingResponse

async def generate_chat_stream(message: str):
    # 调用 LLM 流式 API
    async for chunk in llm.stream(message):
        yield f"data: {chunk}\n\n"

@app.post("/chat/stream")
async def chat_stream(message: str):
    return StreamingResponse(
        generate_chat_stream(message),
        media_type="text/event-stream"
    )
```

---

### 9.3 文档上传响应

```python
class DocumentResponse(BaseModel):
    id: int
    title: str
    status: str
    chunks_count: int
    created_at: datetime

@app.post("/documents", response_model=DocumentResponse, status_code=201)
async def upload_document(file: UploadFile):
    # 处理文档
    doc_id = process_document(file)

    return DocumentResponse(
        id=doc_id,
        title=file.filename,
        status="processing",
        chunks_count=0,
        created_at=datetime.now()
    )
```

---

### 9.4 搜索结果响应

```python
from typing import List

class SearchResult(BaseModel):
    id: int
    title: str
    content: str
    score: float

class SearchResponse(BaseModel):
    query: str
    results: List[SearchResult]
    total: int
    took_ms: int

@app.get("/search", response_model=SearchResponse)
async def search(q: str, limit: int = 10):
    start_time = time.time()

    results = vector_search(q, limit=limit)

    return SearchResponse(
        query=q,
        results=results,
        total=len(results),
        took_ms=int((time.time() - start_time) * 1000)
    )
```

---

## 总结

### 响应模型的核心要点

1. **response_model** - 定义响应格式
2. **自动过滤** - 排除敏感字段
3. **数据验证** - 确保响应数据正确
4. **配置选项** - exclude、include、exclude_unset 等
5. **状态码** - 自定义 HTTP 状态码
6. **特殊响应** - JSON、HTML、文件、流式等

### 与 Express 的对比

| 特性 | Express | FastAPI |
|------|---------|---------|
| 响应格式 | 手动 `res.json()` | `response_model` 自动 |
| 字段过滤 | 手动删除字段 | 自动过滤 |
| 数据验证 | 手动验证 | Pydantic 自动验证 |
| API 文档 | 手动编写 | 自动生成 |
| 类型安全 | ❌ 否 | ✅ 是 |

---

**记住：** 响应模型是 FastAPI 的安全保障，正确使用可以避免敏感信息泄露！
