# 最小可用

> 掌握20%的核心知识，解决80%的后台任务场景

---

掌握以下内容，就能开始使用 FastAPI 后台任务：

---

## 4.1 基础用法：添加后台任务

**核心：** 在路由函数中注入 `BackgroundTasks`，用 `add_task()` 添加任务

```python
from fastapi import FastAPI, BackgroundTasks

app = FastAPI()

# 定义后台任务函数
def write_log(message: str):
    with open("log.txt", "a") as f:
        f.write(f"{message}\n")

# 在路由中使用
@app.post("/action")
async def do_action(background_tasks: BackgroundTasks):
    # 添加后台任务
    background_tasks.add_task(write_log, "用户执行了操作")

    # 立即返回
    return {"status": "ok"}
```

**关键点：**
- `BackgroundTasks` 通过依赖注入获取
- `add_task(函数, 参数1, 参数2, ...)` 添加任务
- 响应返回后，任务自动执行

---

## 4.2 传递参数给后台任务

**核心：** 后台任务函数可以接收任意参数

```python
def send_email(email: str, subject: str, body: str):
    print(f"发送邮件到 {email}")
    print(f"主题: {subject}")
    print(f"内容: {body}")

@app.post("/register")
async def register(
    email: str,
    username: str,
    background_tasks: BackgroundTasks
):
    # 传递多个参数
    background_tasks.add_task(
        send_email,
        email,                          # 位置参数
        subject="欢迎注册",              # 关键字参数
        body=f"你好 {username}！"
    )

    return {"message": "注册成功"}
```

**关键点：**
- 支持位置参数和关键字参数
- 参数在任务执行时传递
- 可以传递任何可序列化的数据

---

## 4.3 添加多个后台任务

**核心：** 可以添加多个任务，按顺序执行

```python
def task1():
    print("任务1执行")

def task2():
    print("任务2执行")

def task3():
    print("任务3执行")

@app.post("/multi-tasks")
async def multi_tasks(background_tasks: BackgroundTasks):
    # 添加多个任务
    background_tasks.add_task(task1)
    background_tasks.add_task(task2)
    background_tasks.add_task(task3)

    return {"message": "已添加3个后台任务"}

# 执行顺序：响应返回 → task1 → task2 → task3
```

**关键点：**
- 任务按添加顺序执行
- 前一个任务完成后才执行下一个
- 所有任务在同一个后台线程中执行

---

## 4.4 异步后台任务

**核心：** 后台任务可以是异步函数

```python
import asyncio

# 异步后台任务
async def async_task(name: str):
    print(f"开始异步任务: {name}")
    await asyncio.sleep(2)  # 模拟异步操作
    print(f"完成异步任务: {name}")

@app.post("/async-task")
async def create_async_task(background_tasks: BackgroundTasks):
    # 添加异步任务
    background_tasks.add_task(async_task, "数据处理")

    return {"message": "异步任务已启动"}
```

**关键点：**
- 使用 `async def` 定义异步任务
- 可以使用 `await` 调用其他异步函数
- 适合 I/O 密集型操作（网络请求、数据库查询）

---

## 4.5 在 AI Agent 中的典型应用

**场景1：文档上传后处理**

```python
from fastapi import UploadFile

async def process_document(filename: str):
    """后台处理文档：解析 + 生成 Embedding"""
    # 1. 解析文档
    text = extract_text(filename)

    # 2. 生成 Embedding
    embedding = generate_embedding(text)

    # 3. 存储到向量数据库
    store_to_db(embedding)

@app.post("/upload")
async def upload(
    file: UploadFile,
    background_tasks: BackgroundTasks
):
    # 保存文件
    filename = save_file(file)

    # 后台处理
    background_tasks.add_task(process_document, filename)

    return {"message": "上传成功，正在处理"}
```

**场景2：对话后记录日志**

```python
async def log_conversation(user_id: str, message: str, response: str):
    """记录对话到数据库"""
    await db.conversations.insert({
        "user_id": user_id,
        "message": message,
        "response": response,
        "timestamp": datetime.now()
    })

@app.post("/chat")
async def chat(
    user_id: str,
    message: str,
    background_tasks: BackgroundTasks
):
    # 生成回复
    response = generate_response(message)

    # 后台记录日志
    background_tasks.add_task(log_conversation, user_id, message, response)

    return {"response": response}
```

---

## 这些知识足以：

- ✅ 在 FastAPI 中使用后台任务
- ✅ 处理简单的异步操作（发邮件、记录日志）
- ✅ 优化 API 响应速度
- ✅ 在 AI Agent 项目中应用后台任务
- ✅ 为学习任务队列（Celery）打基础

---

## 快速参考

| 操作 | 代码 |
|------|------|
| 注入 BackgroundTasks | `async def route(background_tasks: BackgroundTasks)` |
| 添加任务 | `background_tasks.add_task(func, arg1, arg2)` |
| 异步任务 | `async def task(): await ...` |
| 多个任务 | 多次调用 `add_task()` |

---

## 下一步学习

掌握最小可用知识后，建议深入学习：

- → **核心概念1**：BackgroundTasks 的执行机制和生命周期
- → **核心概念2**：何时用 BackgroundTasks，何时用 Celery
- → **核心概念3**：生产环境的错误处理和监控

---

**版本：** v1.0
**最后更新：** 2026-02-11
