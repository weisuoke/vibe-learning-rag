# 核心概念3：并发执行（Tasks 和并发模式）

> 理解如何在 asyncio 中实现真正的并发

---

## 什么是并发执行？

**一句话定义：** 并发执行是指在单线程中同时处理多个异步任务，通过事件循环调度实现高效的资源利用。

---

## 直觉理解

### 类比：厨师做多道菜

**串行执行（效率低）：**
```
1. 做菜A（10分钟）→ 等待完成
2. 做菜B（10分钟）→ 等待完成
3. 做菜C（10分钟）→ 等待完成
总耗时：30分钟
```

**并发执行（效率高）：**
```
1. 启动菜A（炖汤，需要10分钟）
2. 不等待，启动菜B（蒸鱼，需要10分钟）
3. 不等待，启动菜C（炒菜，需要10分钟）
4. 等待所有菜完成
总耗时：10分钟（最慢的那道菜）
```

**并发执行就是"同时启动多个任务，等待所有任务完成"**

---

## Task：异步任务的封装

### 1. 什么是 Task？

**Task 是协程的包装器，用于在事件循环中调度协程执行。**

```python
import asyncio

async def fetch_data():
    await asyncio.sleep(1)
    return "data"

async def main():
    # 创建 Task 对象
    task = asyncio.create_task(fetch_data())
    print(type(task))  # <class 'asyncio.Task'>

    # Task 会在后台运行
    print("Task 已创建，继续执行...")

    # 等待 Task 完成
    result = await task
    print(result)

asyncio.run(main())
```

**输出：**
```
<class 'asyncio.Task'>
Task 已创建，继续执行...
data
```

### 2. Task vs 协程对象

| 特性 | 协程对象 | Task 对象 |
|------|---------|----------|
| **创建方式** | 调用 `async def` 函数 | `asyncio.create_task()` |
| **执行时机** | 必须 `await` 才执行 | 创建后立即加入事件循环 |
| **后台运行** | 不支持 | 支持 |
| **取消** | 不支持 | 支持 `task.cancel()` |
| **状态查询** | 不支持 | 支持 `task.done()` |
| **结果获取** | `await coro` | `await task` 或 `task.result()` |

```python
import asyncio

async def example():
    await asyncio.sleep(0.1)
    return "done"

async def main():
    # 协程对象：不会自动执行
    coro = example()
    print("协程对象创建，但未执行")

    # Task 对象：立即加入事件循环
    task = asyncio.create_task(example())
    print("Task 创建，已在后台运行")

    # 等待完成
    result1 = await coro
    result2 = await task

asyncio.run(main())
```

### 3. Task 的生命周期

```python
import asyncio

async def long_task():
    await asyncio.sleep(2)
    return "done"

async def main():
    # 1. 创建 Task（Pending 状态）
    task = asyncio.create_task(long_task())
    print(f"状态: {task.done()}")  # False

    # 2. 运行中（Running 状态）
    await asyncio.sleep(0.1)
    print(f"状态: {task.done()}")  # False

    # 3. 完成（Done 状态）
    await task
    print(f"状态: {task.done()}")  # True
    print(f"结果: {task.result()}")  # "done"

asyncio.run(main())
```

---

## 并发模式1：asyncio.gather()

### 1. 基本用法

**同时执行多个协程，等待所有完成：**

```python
import asyncio
import time

async def fetch_user(user_id: int):
    print(f"开始获取用户 {user_id}")
    await asyncio.sleep(1)
    print(f"完成获取用户 {user_id}")
    return {"id": user_id, "name": f"User{user_id}"}

async def main():
    start = time.time()

    # 并发执行3个任务
    results = await asyncio.gather(
        fetch_user(1),
        fetch_user(2),
        fetch_user(3)
    )

    print(f"总耗时: {time.time() - start:.2f}秒")
    print(f"结果: {results}")

asyncio.run(main())
```

**输出：**
```
开始获取用户 1
开始获取用户 2
开始获取用户 3
完成获取用户 1
完成获取用户 2
完成获取用户 3
总耗时: 1.00秒
结果: [{'id': 1, 'name': 'User1'}, {'id': 2, 'name': 'User2'}, {'id': 3, 'name': 'User3'}]
```

**关键特性：**
- 所有任务同时启动
- 等待所有任务完成
- 返回结果列表（顺序与输入顺序一致）
- 总耗时 = 最慢任务的耗时

### 2. 错误处理

**默认行为：任何一个任务失败，整体失败**

```python
import asyncio

async def task_success():
    await asyncio.sleep(0.1)
    return "success"

async def task_failure():
    await asyncio.sleep(0.1)
    raise ValueError("任务失败")

async def main():
    try:
        results = await asyncio.gather(
            task_success(),
            task_failure(),
            task_success()
        )
    except ValueError as e:
        print(f"捕获异常: {e}")

asyncio.run(main())
```

**输出：**
```
捕获异常: 任务失败
```

**使用 return_exceptions=True 继续执行：**

```python
async def main():
    results = await asyncio.gather(
        task_success(),
        task_failure(),
        task_success(),
        return_exceptions=True  # 不抛出异常，返回异常对象
    )

    for i, result in enumerate(results):
        if isinstance(result, Exception):
            print(f"任务 {i} 失败: {result}")
        else:
            print(f"任务 {i} 成功: {result}")

asyncio.run(main())
```

**输出：**
```
任务 0 成功: success
任务 1 失败: 任务失败
任务 2 成功: success
```

### 3. 动态任务列表

```python
import asyncio

async def fetch_data(url: str):
    await asyncio.sleep(0.1)
    return f"Data from {url}"

async def main():
    urls = [
        "https://api1.com",
        "https://api2.com",
        "https://api3.com"
    ]

    # 动态创建任务列表
    tasks = [fetch_data(url) for url in urls]

    # 并发执行
    results = await asyncio.gather(*tasks)

    for url, result in zip(urls, results):
        print(f"{url}: {result}")

asyncio.run(main())
```

---

## 并发模式2：asyncio.create_task()

### 1. 创建后台任务

**不立即等待，稍后再等待：**

```python
import asyncio

async def background_task(name: str):
    print(f"{name}: 开始")
    await asyncio.sleep(1)
    print(f"{name}: 完成")
    return f"{name} result"

async def main():
    # 创建任务，不等待
    task1 = asyncio.create_task(background_task("Task1"))
    task2 = asyncio.create_task(background_task("Task2"))

    # 继续执行其他操作
    print("主函数继续执行...")
    await asyncio.sleep(0.5)
    print("主函数做了一些其他事情")

    # 稍后等待任务完成
    result1 = await task1
    result2 = await task2

    print(f"结果: {result1}, {result2}")

asyncio.run(main())
```

**输出：**
```
Task1: 开始
Task2: 开始
主函数继续执行...
主函数做了一些其他事情
Task1: 完成
Task2: 完成
结果: Task1 result, Task2 result
```

### 2. 任务命名（调试用）

```python
import asyncio

async def fetch_data():
    await asyncio.sleep(1)
    return "data"

async def main():
    # 给任务命名，方便调试
    task = asyncio.create_task(fetch_data(), name="fetch_data_task")
    print(f"任务名称: {task.get_name()}")

    result = await task
    print(result)

asyncio.run(main())
```

### 3. 任务取消

```python
import asyncio

async def long_running_task():
    try:
        print("任务开始")
        await asyncio.sleep(10)
        print("任务完成")
    except asyncio.CancelledError:
        print("任务被取消")
        raise  # 重新抛出异常

async def main():
    task = asyncio.create_task(long_running_task())

    # 等待 1 秒后取消任务
    await asyncio.sleep(1)
    task.cancel()

    try:
        await task
    except asyncio.CancelledError:
        print("主函数捕获取消异常")

asyncio.run(main())
```

**输出：**
```
任务开始
任务被取消
主函数捕获取消异常
```

---

## 并发模式3：asyncio.wait()

### 1. 基本用法

**更灵活的并发控制：**

```python
import asyncio

async def task(name: str, delay: float):
    await asyncio.sleep(delay)
    return f"{name} done"

async def main():
    tasks = [
        asyncio.create_task(task("A", 1)),
        asyncio.create_task(task("B", 2)),
        asyncio.create_task(task("C", 3))
    ]

    # 等待所有任务完成
    done, pending = await asyncio.wait(tasks)

    for task in done:
        print(task.result())

asyncio.run(main())
```

### 2. 等待策略

**FIRST_COMPLETED：第一个完成就返回**

```python
import asyncio

async def task(name: str, delay: float):
    await asyncio.sleep(delay)
    return f"{name} done"

async def main():
    tasks = [
        asyncio.create_task(task("A", 1)),
        asyncio.create_task(task("B", 2)),
        asyncio.create_task(task("C", 3))
    ]

    # 等待第一个完成
    done, pending = await asyncio.wait(
        tasks,
        return_when=asyncio.FIRST_COMPLETED
    )

    print(f"完成: {len(done)}, 待完成: {len(pending)}")

    # 取消剩余任务
    for task in pending:
        task.cancel()

asyncio.run(main())
```

**输出：**
```
完成: 1, 待完成: 2
```

**FIRST_EXCEPTION：第一个异常就返回**

```python
async def task_success(name: str):
    await asyncio.sleep(1)
    return f"{name} success"

async def task_failure(name: str):
    await asyncio.sleep(0.5)
    raise ValueError(f"{name} failed")

async def main():
    tasks = [
        asyncio.create_task(task_success("A")),
        asyncio.create_task(task_failure("B")),
        asyncio.create_task(task_success("C"))
    ]

    # 等待第一个异常
    done, pending = await asyncio.wait(
        tasks,
        return_when=asyncio.FIRST_EXCEPTION
    )

    for task in done:
        try:
            print(task.result())
        except Exception as e:
            print(f"异常: {e}")

asyncio.run(main())
```

### 3. 超时控制

```python
import asyncio

async def slow_task():
    await asyncio.sleep(5)
    return "done"

async def main():
    task = asyncio.create_task(slow_task())

    # 等待最多 2 秒
    done, pending = await asyncio.wait(
        [task],
        timeout=2.0
    )

    if pending:
        print("任务超时，取消任务")
        for t in pending:
            t.cancel()
    else:
        print(f"任务完成: {task.result()}")

asyncio.run(main())
```

---

## 并发模式4：asyncio.wait_for()

### 1. 单个任务超时

```python
import asyncio

async def slow_operation():
    await asyncio.sleep(5)
    return "done"

async def main():
    try:
        # 设置 2 秒超时
        result = await asyncio.wait_for(
            slow_operation(),
            timeout=2.0
        )
        print(result)
    except asyncio.TimeoutError:
        print("操作超时")

asyncio.run(main())
```

**输出：**
```
操作超时
```

### 2. 在 AI Agent 中的应用

```python
import asyncio
from openai import AsyncOpenAI

client = AsyncOpenAI()

async def generate_with_timeout(prompt: str, timeout: float = 30.0):
    """带超时的 LLM 调用"""
    try:
        result = await asyncio.wait_for(
            client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}]
            ),
            timeout=timeout
        )
        return result.choices[0].message.content
    except asyncio.TimeoutError:
        return "LLM 调用超时，请稍后重试"

async def main():
    response = await generate_with_timeout("解释量子计算", timeout=10.0)
    print(response)

asyncio.run(main())
```

---

## 并发模式5：asyncio.as_completed()

### 1. 按完成顺序处理结果

```python
import asyncio
import random

async def fetch_data(url: str):
    delay = random.uniform(0.1, 1.0)
    await asyncio.sleep(delay)
    return f"Data from {url} (delay: {delay:.2f}s)"

async def main():
    urls = [f"https://api{i}.com" for i in range(5)]

    # 创建任务
    tasks = [fetch_data(url) for url in urls]

    # 按完成顺序处理
    for coro in asyncio.as_completed(tasks):
        result = await coro
        print(result)

asyncio.run(main())
```

**输出（按完成顺序）：**
```
Data from https://api2.com (delay: 0.15s)
Data from https://api0.com (delay: 0.23s)
Data from https://api4.com (delay: 0.45s)
Data from https://api1.com (delay: 0.67s)
Data from https://api3.com (delay: 0.89s)
```

### 2. 实时显示进度

```python
import asyncio

async def process_item(item_id: int):
    await asyncio.sleep(1)
    return f"Item {item_id} processed"

async def main():
    items = range(10)
    tasks = [process_item(i) for i in items]

    completed = 0
    total = len(tasks)

    for coro in asyncio.as_completed(tasks):
        result = await coro
        completed += 1
        print(f"[{completed}/{total}] {result}")

asyncio.run(main())
```

---

## 并发模式对比

| 模式 | 用途 | 返回值 | 错误处理 | 超时控制 |
|------|------|--------|---------|---------|
| `gather()` | 并发执行，等待所有完成 | 结果列表 | 默认抛出异常 | 不支持 |
| `create_task()` | 创建后台任务 | Task 对象 | 需要手动处理 | 配合 wait_for |
| `wait()` | 灵活的并发控制 | (done, pending) | 需要手动处理 | 支持 |
| `wait_for()` | 单个任务超时 | 任务结果 | 抛出 TimeoutError | 支持 |
| `as_completed()` | 按完成顺序处理 | 迭代器 | 需要手动处理 | 不支持 |

---

## 在 AI Agent 开发中的应用

### 1. 并发调用多个 LLM API

```python
import asyncio
from openai import AsyncOpenAI
from anthropic import AsyncAnthropic

openai_client = AsyncOpenAI()
anthropic_client = AsyncAnthropic()

async def call_openai(prompt: str):
    response = await openai_client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )
    return ("OpenAI", response.choices[0].message.content)

async def call_anthropic(prompt: str):
    response = await anthropic_client.messages.create(
        model="claude-3-opus-20240229",
        messages=[{"role": "user", "content": prompt}],
        max_tokens=1024
    )
    return ("Anthropic", response.content[0].text)

async def get_multiple_responses(prompt: str):
    """并发调用多个 LLM，获取多个回答"""
    responses = await asyncio.gather(
        call_openai(prompt),
        call_anthropic(prompt),
        return_exceptions=True
    )

    results = []
    for response in responses:
        if isinstance(response, Exception):
            print(f"API 调用失败: {response}")
        else:
            provider, content = response
            results.append({"provider": provider, "content": content})

    return results

async def main():
    responses = await get_multiple_responses("什么是异步编程？")
    for resp in responses:
        print(f"\n{resp['provider']}:")
        print(resp['content'][:200])

asyncio.run(main())
```

### 2. 并发处理多个用户请求

```python
from fastapi import FastAPI
import asyncio

app = FastAPI()

async def process_user_request(user_id: int, prompt: str):
    """处理单个用户请求"""
    # 模拟 LLM 调用
    await asyncio.sleep(1)
    return {"user_id": user_id, "response": f"Response for {prompt}"}

@app.post("/batch")
async def batch_process(requests: list[dict]):
    """并发处理多个用户请求"""
    tasks = [
        process_user_request(req["user_id"], req["prompt"])
        for req in requests
    ]

    # 并发执行，最多 10 秒超时
    try:
        results = await asyncio.wait_for(
            asyncio.gather(*tasks, return_exceptions=True),
            timeout=10.0
        )
        return {"results": results}
    except asyncio.TimeoutError:
        return {"error": "批处理超时"}
```

### 3. 流式响应 + 后台任务

```python
from fastapi import FastAPI, BackgroundTasks
from fastapi.responses import StreamingResponse
import asyncio

app = FastAPI()

async def generate_stream(prompt: str):
    """流式生成响应"""
    for i in range(10):
        await asyncio.sleep(0.1)
        yield f"Chunk {i}\n"

async def log_request(user_id: int, prompt: str):
    """后台记录请求"""
    await asyncio.sleep(1)
    print(f"记录请求: user={user_id}, prompt={prompt}")

@app.get("/stream")
async def stream_response(
    prompt: str,
    user_id: int,
    background_tasks: BackgroundTasks
):
    # 后台记录请求
    background_tasks.add_task(log_request, user_id, prompt)

    # 流式返回响应
    return StreamingResponse(
        generate_stream(prompt),
        media_type="text/plain"
    )
```

---

## 性能优化技巧

### 1. 控制并发数量

```python
import asyncio

async def fetch_data(url: str):
    await asyncio.sleep(0.1)
    return f"Data from {url}"

async def fetch_with_limit(urls: list[str], limit: int = 10):
    """限制并发数量"""
    semaphore = asyncio.Semaphore(limit)

    async def fetch_with_sem(url: str):
        async with semaphore:
            return await fetch_data(url)

    tasks = [fetch_with_sem(url) for url in urls]
    return await asyncio.gather(*tasks)

async def main():
    urls = [f"https://api{i}.com" for i in range(100)]

    # 最多同时 10 个并发
    results = await fetch_with_limit(urls, limit=10)
    print(f"处理了 {len(results)} 个请求")

asyncio.run(main())
```

### 2. 批量处理

```python
import asyncio

async def process_batch(items: list):
    """批量处理"""
    await asyncio.sleep(0.1)
    return [f"Processed {item}" for item in items]

async def process_in_batches(items: list, batch_size: int = 10):
    """分批处理大量数据"""
    results = []

    for i in range(0, len(items), batch_size):
        batch = items[i:i + batch_size]
        batch_results = await process_batch(batch)
        results.extend(batch_results)

    return results

async def main():
    items = list(range(100))
    results = await process_in_batches(items, batch_size=10)
    print(f"处理了 {len(results)} 个项目")

asyncio.run(main())
```

### 3. 超时和重试

```python
import asyncio

async def fetch_with_retry(url: str, max_retries: int = 3, timeout: float = 5.0):
    """带重试和超时的请求"""
    for attempt in range(max_retries):
        try:
            result = await asyncio.wait_for(
                fetch_data(url),
                timeout=timeout
            )
            return result
        except asyncio.TimeoutError:
            if attempt == max_retries - 1:
                raise
            print(f"重试 {attempt + 1}/{max_retries}")
            await asyncio.sleep(1)  # 等待后重试
```

---

## 学习检查

完成本节后，你应该能够：

- [ ] 理解 Task 和协程对象的区别
- [ ] 使用 `asyncio.gather()` 并发执行多个任务
- [ ] 使用 `asyncio.create_task()` 创建后台任务
- [ ] 使用 `asyncio.wait()` 灵活控制并发
- [ ] 使用 `asyncio.wait_for()` 设置超时
- [ ] 使用 `asyncio.as_completed()` 按完成顺序处理
- [ ] 在 AI Agent 开发中应用并发模式
- [ ] 控制并发数量和批量处理

---

## 下一步

- **实战练习**：完成【实战代码】中的并发示例
- **深入理解**：阅读【化骨绵掌】了解更多细节
- **项目应用**：在实际项目中应用这些并发模式
