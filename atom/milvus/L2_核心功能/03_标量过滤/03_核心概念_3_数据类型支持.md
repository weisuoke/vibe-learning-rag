# 核心概念3：数据类型支持

> 理解不同数据类型支持的运算符和使用场景

---

## Milvus 支持的标量数据类型

Milvus 支持以下标量数据类型用于过滤：

| 数据类型 | 说明 | 存储范围 | 示例 |
|---------|------|---------|------|
| **INT8** | 8位整数 | -128 ~ 127 | `age`, `status_code` |
| **INT16** | 16位整数 | -32,768 ~ 32,767 | `year`, `count` |
| **INT32** | 32位整数 | -2^31 ~ 2^31-1 | `user_id`, `product_id` |
| **INT64** | 64位整数 | -2^63 ~ 2^63-1 | `timestamp`, `large_id` |
| **FLOAT** | 32位浮点数 | ~7位精度 | `price`, `score` |
| **DOUBLE** | 64位浮点数 | ~15位精度 | `latitude`, `longitude` |
| **BOOL** | 布尔值 | true/false | `is_published`, `is_deleted` |
| **VARCHAR** | 变长字符串 | 最大65535字节 | `title`, `category` |

---

## 1. 整数类型（INT8, INT16, INT32, INT64）

### 1.1 支持的运算符

**所有比较运算符和成员检查**

```python
# 相等性
expr = "user_id == 12345"
expr = "year != 2023"

# 大小比较
expr = "age > 18"
expr = "count >= 100"
expr = "score < 60"
expr = "year <= 2024"

# 成员检查
expr = "user_id in [101, 102, 103]"
expr = "year not in [2020, 2021]"

# 范围查询
expr = "year >= 2020 and year <= 2024"
expr = "price > 100 and price < 500"
```

### 1.2 使用场景

```python
# INT8：状态码、小范围枚举
expr = "status_code == 1"  # 0=inactive, 1=active, 2=suspended

# INT16：年份、计数
expr = "year == 2024"
expr = "view_count > 1000"

# INT32：用户ID、产品ID
expr = "user_id == 12345"
expr = "product_id in [1001, 1002, 1003]"

# INT64：时间戳、大ID
expr = "timestamp >= 1704067200"  # 2024-01-01 00:00:00 UTC
expr = "document_id == 9223372036854775807"
```

### 1.3 注意事项

**整数溢出**

```python
# INT32 最大值：2,147,483,647
expr = "user_id == 2147483648"  # ❌ 溢出！应该使用 INT64

# INT64 最大值：9,223,372,036,854,775,807
expr = "large_id == 9223372036854775807"  # ✅ 正确
```

**时间戳存储**

```python
# 推荐：使用 INT64 存储时间戳（秒）
import time
timestamp = int(time.time())  # 1704067200
expr = f"publish_time >= {timestamp}"

# 或者使用毫秒时间戳
timestamp_ms = int(time.time() * 1000)  # 1704067200000
expr = f"publish_time_ms >= {timestamp_ms}"
```

---

## 2. 浮点数类型（FLOAT, DOUBLE）

### 2.1 支持的运算符

**所有比较运算符和成员检查**

```python
# 相等性（注意精度问题）
expr = "price == 99.99"
expr = "score != 0.0"

# 大小比较
expr = "price > 100.5"
expr = "similarity >= 0.8"
expr = "temperature < -10.5"
expr = "rating <= 4.5"

# 成员检查
expr = "price in [99.99, 199.99, 299.99]"

# 范围查询
expr = "price >= 100.0 and price <= 500.0"
expr = "similarity > 0.7 and similarity < 0.95"
```

### 2.2 使用场景

```python
# FLOAT：价格、评分、相似度
expr = "price >= 99.99"
expr = "rating > 4.0"
expr = "similarity >= 0.8"

# DOUBLE：地理坐标、高精度计算
expr = "latitude >= 39.9 and latitude <= 40.1"
expr = "longitude >= 116.3 and longitude <= 116.5"
expr = "precision_value == 3.141592653589793"
```

### 2.3 注意事项

**浮点数精度问题**

```python
# ❌ 不推荐：直接比较浮点数相等
expr = "price == 99.99"  # 可能因为精度问题匹配不到

# ✅ 推荐：使用范围查询
expr = "price >= 99.98 and price <= 100.00"

# 或者：存储为整数（分）
# 数据库存储：9999（表示99.99元）
expr = "price_cents == 9999"
```

**特殊值**

```python
# 注意：Milvus 不支持 NaN、Infinity 的过滤
# 插入数据时应该避免这些特殊值
import math
if not math.isnan(value) and not math.isinf(value):
    # 插入数据
    pass
```

---

## 3. 布尔类型（BOOL）

### 3.1 支持的运算符

**只支持相等性运算符**

```python
# 相等性
expr = "is_published == true"
expr = "is_deleted == false"
expr = "is_featured != true"

# 成员检查（较少使用）
expr = "is_active in [true]"  # 等价于 is_active == true
```

**不支持大小比较**

```python
# ❌ 错误：布尔值不支持大小比较
expr = "is_published > false"  # 不支持！
expr = "is_deleted >= true"    # 不支持！
```

### 3.2 使用场景

```python
# 状态标记
expr = "is_published == true"
expr = "is_deleted == false"
expr = "is_active == true"

# 特性标记
expr = "is_featured == true"
expr = "is_premium == true"
expr = "is_verified == true"

# 组合使用
expr = "is_published == true and is_deleted == false"
expr = "(is_featured == true or is_hot == true) and is_active == true"
```

### 3.3 注意事项

**必须使用小写**

```python
# ❌ 错误：大写
expr = "is_published == True"
expr = "is_deleted == FALSE"

# ✅ 正确：小写
expr = "is_published == true"
expr = "is_deleted == false"
```

**不要使用数值**

```python
# ❌ 错误：使用数值
expr = "is_published == 1"
expr = "is_deleted == 0"

# ✅ 正确：使用布尔值
expr = "is_published == true"
expr = "is_deleted == false"
```

---

## 4. 字符串类型（VARCHAR）

### 4.1 支持的运算符

**相等性、成员检查、模糊匹配**

```python
# 相等性
expr = "category == 'tech'"
expr = "status != 'deleted'"

# 成员检查
expr = "category in ['tech', 'ai', 'ml']"
expr = "status not in ['deleted', 'spam']"

# 模糊匹配
expr = "title like 'Python%'"
expr = "content like '%机器学习%'"
```

**不支持大小比较**

```python
# ❌ 错误：字符串不支持大小比较
expr = "category > 'tech'"  # 不支持！
expr = "title >= 'Python'"  # 不支持！
```

### 4.2 使用场景

```python
# 分类、标签
expr = "category == 'tech'"
expr = "tags in ['python', 'ai', 'ml']"

# 状态
expr = "status == 'published'"
expr = "status not in ['deleted', 'draft']"

# 标题、内容搜索
expr = "title like 'Python%'"
expr = "author == 'John Doe'"

# 语言、地区
expr = "language == 'zh'"
expr = "region in ['CN', 'US', 'EU']"
```

### 4.3 注意事项

**必须使用单引号**

```python
# ❌ 错误：使用双引号
expr = "category == \"tech\""

# ✅ 正确：使用单引号
expr = "category == 'tech'"
```

**区分大小写**

```python
# 数据库存储：Tech（首字母大写）
expr = "category == 'tech'"  # ❌ 匹配不到
expr = "category == 'Tech'"  # ✅ 匹配成功

# 解决方案：统一大小写
# 插入时：category.lower()
# 查询时：expr = "category == 'tech'"
```

**最大长度限制**

```python
# VARCHAR 需要指定最大长度
from pymilvus import FieldSchema, DataType

field = FieldSchema(
    name="title",
    dtype=DataType.VARCHAR,
    max_length=500  # 必须指定，最大65535
)

# 插入数据时，字符串长度不能超过 max_length
data = [
    {"id": 1, "title": "a" * 500},  # ✅ 正确
    {"id": 2, "title": "a" * 501},  # ❌ 错误：超过最大长度
]
```

**转义特殊字符**

```python
# 字符串中包含单引号
expr = "title == 'It\\'s a book'"  # It's a book

# 字符串中包含反斜杠
expr = "path == 'C:\\\\Users\\\\Documents'"  # C:\Users\Documents
```

---

## 5. 数据类型对照表

### 5.1 运算符支持矩阵

| 数据类型 | == | != | > | < | >= | <= | in | not in | like |
|---------|----|----|---|---|----|----|----|----|------|
| INT8/16/32/64 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ |
| FLOAT/DOUBLE | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ |
| BOOL | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ | ❌ |
| VARCHAR | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ |

### 5.2 使用场景对照

| 场景 | 推荐类型 | 示例字段 |
|------|---------|---------|
| 用户ID、产品ID | INT32/INT64 | `user_id`, `product_id` |
| 时间戳 | INT64 | `created_at`, `updated_at` |
| 年份、计数 | INT16/INT32 | `year`, `view_count` |
| 价格、评分 | FLOAT/DOUBLE | `price`, `rating` |
| 地理坐标 | DOUBLE | `latitude`, `longitude` |
| 状态标记 | BOOL | `is_published`, `is_deleted` |
| 分类、标签 | VARCHAR | `category`, `tags` |
| 标题、内容 | VARCHAR | `title`, `description` |

---

## 6. 类型转换和兼容性

### 6.1 隐式类型转换

**Milvus 不支持隐式类型转换**

```python
# ❌ 错误：类型不匹配
# 数据库中 user_id 是 INT64
expr = "user_id == '12345'"  # 字符串，不会自动转换为整数

# ✅ 正确：类型匹配
expr = "user_id == 12345"  # 整数
```

### 6.2 数值类型兼容性

**整数类型之间可以比较**

```python
# INT32 字段与 INT64 值比较
expr = "user_id == 12345"  # ✅ 正确，只要值在范围内

# 浮点数与整数比较
expr = "price > 100"  # ✅ 正确，100 会被视为 100.0
```

### 6.3 字符串与数值

**不能混用**

```python
# ❌ 错误：字符串与数值比较
expr = "year == '2024'"  # year 是 INT16，'2024' 是字符串

# ✅ 正确：类型匹配
expr = "year == 2024"
```

---

## 7. 实战示例

### 示例1：完整的 Schema 定义

```python
from pymilvus import FieldSchema, CollectionSchema, DataType, Collection

# 定义字段
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=768),

    # 整数字段
    FieldSchema(name="user_id", dtype=DataType.INT64),
    FieldSchema(name="year", dtype=DataType.INT16),
    FieldSchema(name="view_count", dtype=DataType.INT32),

    # 浮点数字段
    FieldSchema(name="price", dtype=DataType.FLOAT),
    FieldSchema(name="rating", dtype=DataType.DOUBLE),

    # 布尔字段
    FieldSchema(name="is_published", dtype=DataType.BOOL),
    FieldSchema(name="is_deleted", dtype=DataType.BOOL),

    # 字符串字段
    FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=500),
    FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=100),
    FieldSchema(name="author", dtype=DataType.VARCHAR, max_length=200),
]

# 创建 Schema
schema = CollectionSchema(fields=fields, description="Document collection")

# 创建 Collection
collection = Collection(name="documents", schema=schema)
```

### 示例2：多类型混合过滤

```python
from pymilvus import connections
import time

connections.connect("default", host="localhost", port="19530")

# 构建复杂过滤条件
current_timestamp = int(time.time())
expr = f"""
    user_id == 12345
    and year >= 2024
    and price >= 50.0 and price <= 200.0
    and rating > 4.0
    and is_published == true
    and is_deleted == false
    and category in ['tech', 'ai', 'ml']
    and title like 'Python%'
"""

# 执行查询
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=10,
    expr=expr,
    output_fields=["title", "category", "price", "rating"]
)
```

### 示例3：类型安全的动态过滤

```python
def build_filter_expr(filters: dict) -> str:
    """构建类型安全的过滤表达式"""
    conditions = []

    # 整数字段
    if "user_id" in filters:
        conditions.append(f"user_id == {int(filters['user_id'])}")

    if "year" in filters:
        conditions.append(f"year == {int(filters['year'])}")

    # 浮点数字段
    if "min_price" in filters:
        conditions.append(f"price >= {float(filters['min_price'])}")

    if "max_price" in filters:
        conditions.append(f"price <= {float(filters['max_price'])}")

    # 布尔字段
    if "is_published" in filters:
        value = "true" if filters["is_published"] else "false"
        conditions.append(f"is_published == {value}")

    # 字符串字段（注意转义）
    if "category" in filters:
        category = filters["category"].replace("'", "\\'")
        conditions.append(f"category == '{category}'")

    if "categories" in filters:
        # 列表转换为字符串
        cats = [f"'{c}'" for c in filters["categories"]]
        conditions.append(f"category in [{', '.join(cats)}]")

    return " and ".join(conditions) if conditions else None

# 使用示例
filters = {
    "user_id": 12345,
    "year": 2024,
    "min_price": 50.0,
    "max_price": 200.0,
    "is_published": True,
    "categories": ["tech", "ai"]
}

expr = build_filter_expr(filters)
print(expr)
# 输出：user_id == 12345 and year == 2024 and price >= 50.0 and price <= 200.0 and is_published == true and category in ['tech', 'ai']
```

---

## 核心要点总结

1. **整数类型**：支持所有比较和成员检查，用于ID、时间戳、计数
2. **浮点数类型**：支持所有比较和成员检查，注意精度问题
3. **布尔类型**：只支持相等性，必须使用小写 `true`/`false`
4. **字符串类型**：支持相等性、成员检查和模糊匹配，必须用单引号
5. **类型匹配**：过滤值的类型必须与字段类型匹配，不支持隐式转换
6. **大小写敏感**：字符串比较区分大小写，建议统一处理

**记住**：选择合适的数据类型，使用正确的运算符，注意类型匹配。
