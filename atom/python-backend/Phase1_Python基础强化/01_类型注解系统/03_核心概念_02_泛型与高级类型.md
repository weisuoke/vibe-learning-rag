# 核心概念2：泛型与高级类型

详细讲解 Python 类型注解的泛型系统和高级类型特性。

---

## 概述

泛型（Generic）允许定义可复用的类型模板，高级类型提供更精确的类型约束。

---

## 1. 泛型基础（Generic）

### 1.1 什么是泛型

**一句话：** 泛型是类型的参数化，让函数/类可以适用于多种类型而保持类型安全。

```python
from typing import TypeVar, List

# 定义类型变量
T = TypeVar('T')

def get_first_item(items: List[T]) -> T | None:
    """获取列表第一个元素，保持类型"""
    return items[0] if items else None

# 使用
numbers = [1, 2, 3]
first_number = get_first_item(numbers)  # 类型：int | None

names = ["Alice", "Bob"]
first_name = get_first_item(names)  # 类型：str | None
```

**类比 TypeScript：**

```typescript
// TypeScript 泛型
function getFirstItem<T>(items: T[]): T | undefined {
    return items[0];
}

const firstNumber = getFirstItem([1, 2, 3]);  // number | undefined
const firstName = getFirstItem(["Alice", "Bob"]);  // string | undefined
```

### 1.2 泛型函数

```python
from typing import TypeVar, List, Tuple

T = TypeVar('T')
U = TypeVar('U')

# 单个类型参数
def reverse_list(items: List[T]) -> List[T]:
    """反转列表，保持元素类型"""
    return items[::-1]

# 多个类型参数
def zip_lists(list1: List[T], list2: List[U]) -> List[Tuple[T, U]]:
    """合并两个列表，保持各自类型"""
    return list(zip(list1, list2))

# 使用
numbers = reverse_list([1, 2, 3])  # List[int]
names = reverse_list(["Alice", "Bob"])  # List[str]

pairs = zip_lists([1, 2], ["a", "b"])  # List[Tuple[int, str]]
```

### 1.3 泛型类

```python
from typing import TypeVar, Generic, Optional, List

T = TypeVar('T')

class Stack(Generic[T]):
    """泛型栈实现"""

    def __init__(self):
        self._items: List[T] = []

    def push(self, item: T) -> None:
        """压栈"""
        self._items.append(item)

    def pop(self) -> Optional[T]:
        """出栈"""
        return self._items.pop() if self._items else None

    def peek(self) -> Optional[T]:
        """查看栈顶"""
        return self._items[-1] if self._items else None

    def is_empty(self) -> bool:
        """是否为空"""
        return len(self._items) == 0

# 使用
int_stack = Stack[int]()
int_stack.push(1)
int_stack.push(2)
print(int_stack.pop())  # 2（类型：Optional[int]）

str_stack = Stack[str]()
str_stack.push("hello")
str_stack.push("world")
print(str_stack.pop())  # "world"（类型：Optional[str]）
```

### 1.4 约束类型变量

```python
from typing import TypeVar

# 约束为特定类型
NumberT = TypeVar('NumberT', int, float)

def add_numbers(a: NumberT, b: NumberT) -> NumberT:
    """只能是 int 或 float"""
    return a + b  # type: ignore

# 使用
result1 = add_numbers(1, 2)  # int
result2 = add_numbers(1.5, 2.5)  # float
# result3 = add_numbers("a", "b")  # ❌ mypy 报错

# 约束为某个基类的子类
from typing import TypeVar

class Animal:
    def make_sound(self) -> str:
        return "..."

class Dog(Animal):
    def make_sound(self) -> str:
        return "Woof!"

class Cat(Animal):
    def make_sound(self) -> str:
        return "Meow!"

AnimalT = TypeVar('AnimalT', bound=Animal)

def make_animal_sound(animal: AnimalT) -> str:
    """只接受 Animal 或其子类"""
    return animal.make_sound()

# 使用
dog = Dog()
cat = Cat()
print(make_animal_sound(dog))  # "Woof!"
print(make_animal_sound(cat))  # "Meow!"
```

---

## 2. Protocol（结构化类型）

### 2.1 什么是 Protocol

**一句话：** Protocol 定义结构化类型（duck typing），只要对象有指定的方法/属性就符合类型。

```python
from typing import Protocol

class Drawable(Protocol):
    """可绘制的协议"""
    def draw(self) -> str:
        ...

class Circle:
    def draw(self) -> str:
        return "Drawing circle"

class Square:
    def draw(self) -> str:
        return "Drawing square"

def render(shape: Drawable) -> None:
    """渲染任何可绘制的对象"""
    print(shape.draw())

# 使用（不需要继承 Drawable）
circle = Circle()
square = Square()
render(circle)  # ✅ Circle 有 draw 方法
render(square)  # ✅ Square 有 draw 方法
```

**类比 TypeScript：**

```typescript
// TypeScript interface（结构化类型）
interface Drawable {
    draw(): string;
}

class Circle {
    draw(): string {
        return "Drawing circle";
    }
}

function render(shape: Drawable): void {
    console.log(shape.draw());
}

render(new Circle());  // ✅ Circle 有 draw 方法
```

### 2.2 Protocol 的优势

```python
from typing import Protocol

# 传统方式：需要继承
from abc import ABC, abstractmethod

class DrawableABC(ABC):
    @abstractmethod
    def draw(self) -> str:
        pass

class Circle(DrawableABC):  # 必须继承
    def draw(self) -> str:
        return "Drawing circle"

# Protocol 方式：不需要继承
class DrawableProtocol(Protocol):
    def draw(self) -> str:
        ...

class Square:  # 不需要继承
    def draw(self) -> str:
        return "Drawing square"

def render(shape: DrawableProtocol) -> None:
    print(shape.draw())

render(Square())  # ✅ 只要有 draw 方法就行
```

### 2.3 实际应用：数据库连接

```python
from typing import Protocol, Optional

class DatabaseConnection(Protocol):
    """数据库连接协议"""
    def execute(self, query: str) -> list[dict]:
        ...

    def close(self) -> None:
        ...

class PostgresConnection:
    def execute(self, query: str) -> list[dict]:
        # PostgreSQL 实现
        return []

    def close(self) -> None:
        # 关闭连接
        pass

class MySQLConnection:
    def execute(self, query: str) -> list[dict]:
        # MySQL 实现
        return []

    def close(self) -> None:
        # 关闭连接
        pass

def query_users(db: DatabaseConnection) -> list[dict]:
    """查询用户，支持任何数据库"""
    return db.execute("SELECT * FROM users")

# 使用
pg_db = PostgresConnection()
mysql_db = MySQLConnection()

users1 = query_users(pg_db)  # ✅
users2 = query_users(mysql_db)  # ✅
```

---

## 3. Literal 类型（字面量类型）

### 3.1 基本用法

```python
from typing import Literal

# 限定为特定值
def set_log_level(level: Literal["debug", "info", "warning", "error"]) -> None:
    """日志级别只能是这四个值"""
    print(f"Log level set to: {level}")

# 使用
set_log_level("debug")  # ✅
set_log_level("info")  # ✅
# set_log_level("trace")  # ❌ mypy 报错

# 数字字面量
def set_port(port: Literal[80, 443, 8000, 8080]) -> None:
    """端口只能是这几个值"""
    print(f"Port set to: {port}")

set_port(8000)  # ✅
# set_port(9000)  # ❌ mypy 报错
```

### 3.2 在 FastAPI 中的应用

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import Literal

app = FastAPI()

class ChatRequest(BaseModel):
    message: str
    model: Literal["gpt-4", "gpt-3.5-turbo", "claude-3"]  # 只能是这三个模型
    temperature: float = 0.7

@app.post("/chat")
async def chat(request: ChatRequest):
    # FastAPI 自动验证 model 只能是三个值之一
    return {"model": request.model, "message": request.message}

# 请求体：
# {
#   "message": "Hello",
#   "model": "gpt-4"  // ✅
# }
# {
#   "message": "Hello",
#   "model": "gpt-5"  // ❌ 422 错误
# }
```

### 3.3 结合 Union 使用

```python
from typing import Literal, Union

# 定义状态类型
Status = Literal["pending", "running", "completed", "failed"]

def update_task_status(task_id: int, status: Status) -> None:
    """更新任务状态"""
    print(f"Task {task_id} status: {status}")

# 或者用 Union
HttpMethod = Literal["GET"] | Literal["POST"] | Literal["PUT"] | Literal["DELETE"]

def make_request(url: str, method: HttpMethod) -> None:
    """发送 HTTP 请求"""
    print(f"{method} {url}")
```

---

## 4. TypedDict（类型化字典）

### 4.1 基本用法

```python
from typing import TypedDict

# 定义字典结构
class User(TypedDict):
    id: int
    name: str
    email: str

# 使用
user: User = {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com"
}

# mypy 检查
print(user["name"])  # ✅
# print(user["age"])  # ❌ mypy 报错：User 没有 age 字段
```

### 4.2 可选字段

```python
from typing import TypedDict, NotRequired

# Python 3.11+ 写法
class User(TypedDict):
    id: int
    name: str
    email: str
    age: NotRequired[int]  # 可选字段

# 旧写法
class UserOld(TypedDict, total=False):
    age: int  # 可选字段

class UserOld(TypedDict):
    id: int
    name: str
    email: str

# 使用
user1: User = {"id": 1, "name": "Alice", "email": "alice@example.com"}  # ✅
user2: User = {"id": 2, "name": "Bob", "email": "bob@example.com", "age": 30}  # ✅
```

### 4.3 vs Pydantic BaseModel

```python
from typing import TypedDict
from pydantic import BaseModel

# TypedDict：纯类型提示，运行时不验证
class UserDict(TypedDict):
    id: int
    name: str

user_dict: UserDict = {"id": "not an int", "name": "Alice"}  # 运行时不报错

# Pydantic：运行时验证
class UserModel(BaseModel):
    id: int
    name: str

try:
    user_model = UserModel(id="not an int", name="Alice")  # ❌ 运行时报错
except ValueError as e:
    print(e)
```

**使用场景：**
- **TypedDict**：内部数据结构，不需要运行时验证
- **Pydantic**：外部输入，需要运行时验证

---

## 5. Callable（可调用类型）

### 5.1 基本用法

```python
from typing import Callable

# 函数类型：(参数类型) -> 返回类型
Callback = Callable[[str], None]  # (str) -> None
Processor = Callable[[int, int], int]  # (int, int) -> int

def process_data(data: str, callback: Callback) -> None:
    """处理数据并调用回调"""
    result = data.upper()
    callback(result)

def my_callback(text: str) -> None:
    print(f"Callback: {text}")

# 使用
process_data("hello", my_callback)  # Callback: HELLO
```

### 5.2 高阶函数

```python
from typing import Callable, List

def map_list(
    items: List[int],
    func: Callable[[int], str]
) -> List[str]:
    """映射列表元素"""
    return [func(item) for item in items]

def int_to_str(n: int) -> str:
    return f"Number: {n}"

# 使用
numbers = [1, 2, 3]
strings = map_list(numbers, int_to_str)
print(strings)  # ["Number: 1", "Number: 2", "Number: 3"]

# 使用 lambda
strings2 = map_list(numbers, lambda x: f"Value: {x}")
```

### 5.3 装饰器类型

```python
from typing import Callable, TypeVar, Any
from functools import wraps

F = TypeVar('F', bound=Callable[..., Any])

def log_calls(func: F) -> F:
    """装饰器：记录函数调用"""
    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Finished {func.__name__}")
        return result
    return wrapper  # type: ignore

@log_calls
def greet(name: str) -> str:
    return f"Hello, {name}"

# 使用
result = greet("Alice")
# 输出：
# Calling greet
# Finished greet
```

---

## 6. NewType（新类型）

### 6.1 基本用法

```python
from typing import NewType

# 创建新类型（运行时是同一个类型，但 mypy 会区分）
UserId = NewType('UserId', int)
ProductId = NewType('ProductId', int)

def get_user(user_id: UserId) -> str:
    """获取用户"""
    return f"User {user_id}"

def get_product(product_id: ProductId) -> str:
    """获取产品"""
    return f"Product {product_id}"

# 使用
user_id = UserId(123)
product_id = ProductId(456)

print(get_user(user_id))  # ✅
# print(get_user(product_id))  # ❌ mypy 报错：类型不匹配
# print(get_user(123))  # ❌ mypy 报错：需要 UserId，不是 int
```

### 6.2 实际应用：防止混淆

```python
from typing import NewType

# 防止混淆不同单位
Meters = NewType('Meters', float)
Seconds = NewType('Seconds', float)

def calculate_speed(distance: Meters, time: Seconds) -> float:
    """计算速度（米/秒）"""
    return distance / time

# 使用
distance = Meters(100.0)
time = Seconds(10.0)
speed = calculate_speed(distance, time)  # ✅

# 防止参数顺序错误
# speed = calculate_speed(time, distance)  # ❌ mypy 报错
```

---

## 7. 实战示例

### 示例1：泛型缓存系统

```python
from typing import TypeVar, Generic, Optional, Dict
from datetime import datetime, timedelta

K = TypeVar('K')
V = TypeVar('V')

class Cache(Generic[K, V]):
    """泛型缓存实现"""

    def __init__(self, ttl_seconds: int = 300):
        self._data: Dict[K, tuple[V, datetime]] = {}
        self._ttl = timedelta(seconds=ttl_seconds)

    def set(self, key: K, value: V) -> None:
        """设置缓存"""
        self._data[key] = (value, datetime.now())

    def get(self, key: K) -> Optional[V]:
        """获取缓存"""
        if key not in self._data:
            return None

        value, timestamp = self._data[key]
        if datetime.now() - timestamp > self._ttl:
            del self._data[key]
            return None

        return value

    def clear(self) -> None:
        """清空缓存"""
        self._data.clear()

# 使用
user_cache = Cache[int, str]()  # 用户ID -> 用户名
user_cache.set(1, "Alice")
user_cache.set(2, "Bob")

name = user_cache.get(1)  # Optional[str]
if name is not None:
    print(name.upper())

config_cache = Cache[str, dict]()  # 配置名 -> 配置值
config_cache.set("database", {"host": "localhost", "port": 5432})
```

### 示例2：Protocol 实现插件系统

```python
from typing import Protocol, List

class Plugin(Protocol):
    """插件协议"""
    name: str

    def initialize(self) -> None:
        ...

    def execute(self, data: str) -> str:
        ...

class UpperCasePlugin:
    name = "uppercase"

    def initialize(self) -> None:
        print(f"Initializing {self.name}")

    def execute(self, data: str) -> str:
        return data.upper()

class ReversePlugin:
    name = "reverse"

    def initialize(self) -> None:
        print(f"Initializing {self.name}")

    def execute(self, data: str) -> str:
        return data[::-1]

class PluginManager:
    def __init__(self):
        self._plugins: List[Plugin] = []

    def register(self, plugin: Plugin) -> None:
        """注册插件"""
        plugin.initialize()
        self._plugins.append(plugin)

    def execute_all(self, data: str) -> str:
        """执行所有插件"""
        result = data
        for plugin in self._plugins:
            result = plugin.execute(result)
        return result

# 使用
manager = PluginManager()
manager.register(UpperCasePlugin())
manager.register(ReversePlugin())

result = manager.execute_all("hello")
print(result)  # "OLLEH"
```

### 示例3：Literal 实现状态机

```python
from typing import Literal
from pydantic import BaseModel

TaskStatus = Literal["pending", "running", "completed", "failed"]

class Task(BaseModel):
    id: int
    name: str
    status: TaskStatus

class TaskManager:
    def __init__(self):
        self._tasks: dict[int, Task] = {}

    def create_task(self, task_id: int, name: str) -> Task:
        """创建任务"""
        task = Task(id=task_id, name=name, status="pending")
        self._tasks[task_id] = task
        return task

    def update_status(
        self,
        task_id: int,
        status: TaskStatus
    ) -> Task:
        """更新任务状态"""
        task = self._tasks[task_id]
        task.status = status
        return task

    def get_tasks_by_status(
        self,
        status: TaskStatus
    ) -> list[Task]:
        """按状态查询任务"""
        return [t for t in self._tasks.values() if t.status == status]

# 使用
manager = TaskManager()
task = manager.create_task(1, "Process data")
manager.update_status(1, "running")
manager.update_status(1, "completed")

# manager.update_status(1, "invalid")  # ❌ mypy 报错
```

---

## 总结

### 高级类型速查表

| 类型 | 用途 | 示例 |
|------|------|------|
| **Generic[T]** | 泛型类 | `class Stack(Generic[T])` |
| **TypeVar** | 类型变量 | `T = TypeVar('T')` |
| **Protocol** | 结构化类型 | `class Drawable(Protocol)` |
| **Literal** | 字面量类型 | `Literal["a", "b"]` |
| **TypedDict** | 类型化字典 | `class User(TypedDict)` |
| **Callable** | 函数类型 | `Callable[[int], str]` |
| **NewType** | 新类型别名 | `UserId = NewType('UserId', int)` |

### 使用场景

1. **Generic**：数据结构、缓存系统、工具类
2. **Protocol**：插件系统、依赖注入、接口定义
3. **Literal**：状态机、配置选项、API 参数
4. **TypedDict**：内部数据结构、配置对象
5. **Callable**：回调函数、装饰器、高阶函数
6. **NewType**：防止类型混淆、增强类型安全

### 最佳实践

1. **优先使用 Protocol**：比抽象基类更灵活
2. **Literal 限定选项**：避免无效值
3. **TypedDict 用于内部**：Pydantic 用于外部
4. **泛型保持简单**：不要过度设计
5. **NewType 防混淆**：相同基础类型但语义不同时使用

### 下一步

学习完泛型和高级类型后，继续学习：
- mypy 静态类型检查配置
- FastAPI 中的实战应用
- 类型检查工作流集成
