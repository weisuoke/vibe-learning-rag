# 核心概念 3：自定义事件

## 一句话定义

**自定义事件是通过 `pi.events` 事件总线实现的扩展间通信机制，允许扩展之间松耦合地发送和接收消息。**

---

## 详细解释

### 什么是自定义事件？

自定义事件（Custom Events）是用户自定义的、用于扩展间通信的事件，与生命周期钩子不同，它们不是由 pi-mono 核心代码触发，而是由扩展主动发送和接收。

**核心特点：**
- **用户定义**：事件名称和参数由用户自定义
- **扩展间通信**：主要用于扩展之间的消息传递
- **松耦合**：发送者和接收者不直接依赖
- **灵活性**：可以传递任意类型的数据

**与生命周期钩子的区别：**

| 特性 | 生命周期钩子 | 自定义事件 |
|------|------------|-----------|
| 触发者 | pi-mono 核心代码 | 用户扩展 |
| 事件名称 | 预定义（如 session_start） | 用户自定义（如 my-event） |
| 用途 | 监控 Agent 生命周期 | 扩展间通信 |
| 事件总线 | pi.on() | pi.events |

### pi.events 事件总线

`pi.events` 是 pi-mono 提供的第二层事件总线，专门用于扩展间通信。

**接口定义：**
```typescript
interface EventBus {
  emit(event: string, ...args: any[]): void;
  on(event: string, handler: (...args: any[]) => void): void;
  off(event: string, handler: (...args: any[]) => void): void;
  once(event: string, handler: (...args: any[]) => void): void;
}
```

**基础用法：**
```typescript
// Extension A：发送事件
pi.events.emit('data-ready', { data: [1, 2, 3] });

// Extension B：接收事件
pi.events.on('data-ready', (payload) => {
  console.log('Received data:', payload.data);
});
```

### emit() 方法详解

`emit()` 方法用于发送自定义事件。

**方法签名：**
```typescript
emit(event: string, ...args: any[]): void
```

**参数：**
- `event`：事件名称（字符串）
- `...args`：事件参数（可变参数）

**基础用法：**
```typescript
// 发送简单事件
pi.events.emit('task-completed');

// 发送带参数的事件
pi.events.emit('task-completed', { taskId: '123', result: 'success' });

// 发送多个参数
pi.events.emit('data-processed', data, metadata, timestamp);
```

**返回值：**
- 无返回值（void）

**特点：**
- 同步发送（立即触发所有监听器）
- 不关心是否有监听器
- 不会抛出错误（即使没有监听器）

### on() 方法详解

`on()` 方法用于监听自定义事件。

**方法签名：**
```typescript
on(event: string, handler: (...args: any[]) => void): void
```

**参数：**
- `event`：事件名称（字符串）
- `handler`：事件处理器（函数）

**基础用法：**
```typescript
// 监听事件
pi.events.on('task-completed', (payload) => {
  console.log('Task completed:', payload);
});

// 监听多参数事件
pi.events.on('data-processed', (data, metadata, timestamp) => {
  console.log('Data:', data);
  console.log('Metadata:', metadata);
  console.log('Timestamp:', timestamp);
});
```

**特点：**
- 可以注册多个监听器
- 按注册顺序执行
- 支持异步处理器

### off() 和 once() 方法

**off() - 注销监听器：**
```typescript
const handler = (payload) => {
  console.log('Received:', payload);
};

// 注册
pi.events.on('my-event', handler);

// 注销
pi.events.off('my-event', handler);
```

**once() - 一次性监听器：**
```typescript
// 只执行一次
pi.events.once('initialization-complete', () => {
  console.log('Initialized!');
});
```

### 扩展间通信模式

#### 模式 1：发布-订阅（Pub-Sub）

**场景：** 一个扩展发布数据，多个扩展订阅

```typescript
// Extension A：数据提供者
export default function dataProvider(pi: ExtensionAPI) {
  pi.on('session_start', async () => {
    // 加载数据
    const data = await loadData();

    // 发布数据就绪事件
    pi.events.emit('data-ready', { data });
  });
}

// Extension B：数据消费者 1
export default function consumer1(pi: ExtensionAPI) {
  pi.events.on('data-ready', ({ data }) => {
    console.log('Consumer 1 received data:', data.length);
    processData1(data);
  });
}

// Extension C：数据消费者 2
export default function consumer2(pi: ExtensionAPI) {
  pi.events.on('data-ready', ({ data }) => {
    console.log('Consumer 2 received data:', data.length);
    processData2(data);
  });
}
```

**优势：**
- 数据提供者不需要知道有哪些消费者
- 消费者可以独立开发和部署
- 易于添加新的消费者

#### 模式 2：请求-响应（Request-Response）

**场景：** 一个扩展请求数据，另一个扩展响应

```typescript
// Extension A：请求者
export default function requester(pi: ExtensionAPI) {
  pi.on('tool_call', (tool, args) => {
    // 请求数据
    pi.events.emit('data-request', {
      requestId: generateId(),
      query: 'user-info'
    });

    // 监听响应
    pi.events.once('data-response', (response) => {
      console.log('Received response:', response);
    });
  });
}

// Extension B：响应者
export default function responder(pi: ExtensionAPI) {
  pi.events.on('data-request', async ({ requestId, query }) => {
    // 处理请求
    const data = await fetchData(query);

    // 发送响应
    pi.events.emit('data-response', {
      requestId,
      data
    });
  });
}
```

**优势：**
- 支持异步请求-响应
- 请求者和响应者解耦
- 可以实现超时和重试

#### 模式 3：事件链（Event Chain）

**场景：** 多个扩展按顺序处理事件

```typescript
// Extension A：数据加载
export default function loader(pi: ExtensionAPI) {
  pi.on('session_start', async () => {
    const rawData = await loadRawData();
    pi.events.emit('data-loaded', { rawData });
  });
}

// Extension B：数据处理
export default function processor(pi: ExtensionAPI) {
  pi.events.on('data-loaded', ({ rawData }) => {
    const processedData = processData(rawData);
    pi.events.emit('data-processed', { processedData });
  });
}

// Extension C：数据存储
export default function saver(pi: ExtensionAPI) {
  pi.events.on('data-processed', async ({ processedData }) => {
    await saveData(processedData);
    pi.events.emit('data-saved');
  });
}
```

**优势：**
- 清晰的数据流
- 每个扩展职责单一
- 易于调试和测试

#### 模式 4：广播通知（Broadcast）

**场景：** 一个扩展广播通知，所有扩展接收

```typescript
// Extension A：通知发送者
export default function notifier(pi: ExtensionAPI) {
  pi.on('agent_end', (result) => {
    // 广播通知
    pi.events.emit('agent-completed', {
      timestamp: Date.now(),
      result
    });
  });
}

// Extension B：日志记录
export default function logger(pi: ExtensionAPI) {
  pi.events.on('agent-completed', ({ timestamp, result }) => {
    console.log(`[${new Date(timestamp).toISOString()}] Agent completed`);
  });
}

// Extension C：监控上报
export default function monitor(pi: ExtensionAPI) {
  pi.events.on('agent-completed', ({ timestamp, result }) => {
    sendToMonitoring({ event: 'agent-completed', timestamp });
  });
}

// Extension D：通知发送
export default function alerter(pi: ExtensionAPI) {
  pi.events.on('agent-completed', ({ timestamp, result }) => {
    sendNotification('Agent completed successfully');
  });
}
```

**优势：**
- 一次发送，多处接收
- 扩展之间完全解耦
- 易于添加新的监听器

### 事件命名约定

为了保持代码的可维护性，建议遵循以下命名约定：

#### 1. 使用 kebab-case

```typescript
// ✅ 推荐
pi.events.emit('data-ready');
pi.events.emit('task-completed');
pi.events.emit('user-logged-in');

// ❌ 不推荐
pi.events.emit('dataReady');
pi.events.emit('TaskCompleted');
pi.events.emit('user_logged_in');
```

#### 2. 使用动词-名词结构

```typescript
// ✅ 推荐
pi.events.emit('data-loaded');      // 动词-名词
pi.events.emit('task-completed');   // 动词-名词
pi.events.emit('user-authenticated'); // 动词-名词

// ❌ 不推荐
pi.events.emit('load-data');        // 名词-动词
pi.events.emit('complete-task');    // 名词-动词
```

#### 3. 使用命名空间

```typescript
// ✅ 推荐：使用命名空间组织事件
pi.events.emit('auth:login-success');
pi.events.emit('auth:login-failed');
pi.events.emit('data:loaded');
pi.events.emit('data:processed');
pi.events.emit('ui:updated');

// ❌ 不推荐：没有命名空间
pi.events.emit('login-success');
pi.events.emit('loaded');
pi.events.emit('updated');
```

#### 4. 使用描述性名称

```typescript
// ✅ 推荐：清晰描述事件含义
pi.events.emit('user-authentication-completed');
pi.events.emit('database-connection-established');

// ❌ 不推荐：含义不清
pi.events.emit('done');
pi.events.emit('ok');
```

### 在 AI Agent 开发中的应用

#### 应用场景 1：模块化功能

```typescript
// Extension A：上下文管理
export default function contextManager(pi: ExtensionAPI) {
  let projectContext = null;

  // 加载上下文
  pi.on('session_start', async () => {
    projectContext = await loadProjectContext();
    pi.events.emit('context:loaded', { context: projectContext });
  });

  // 响应上下文请求
  pi.events.on('context:request', () => {
    pi.events.emit('context:response', { context: projectContext });
  });
}

// Extension B：代码分析
export default function codeAnalyzer(pi: ExtensionAPI) {
  pi.on('before_agent_start', (messages) => {
    // 请求上下文
    pi.events.emit('context:request');

    // 等待上下文响应
    pi.events.once('context:response', ({ context }) => {
      // 使用上下文进行代码分析
      const analysis = analyzeCode(context);
      messages.push({
        role: 'system',
        content: `Code analysis: ${analysis}`
      });
    });
  });
}
```

#### 应用场景 2：插件协作

```typescript
// Extension A：数据收集插件
export default function dataCollector(pi: ExtensionAPI) {
  const collectedData = [];

  pi.on('tool_call', (tool, args) => {
    collectedData.push({
      tool: tool.name,
      args,
      timestamp: Date.now()
    });
  });

  pi.on('agent_end', () => {
    // 发布收集的数据
    pi.events.emit('data:collected', { data: collectedData });
  });
}

// Extension B：数据分析插件
export default function dataAnalyzer(pi: ExtensionAPI) {
  pi.events.on('data:collected', ({ data }) => {
    const analysis = analyzeToolUsage(data);
    console.log('Tool usage analysis:', analysis);

    // 发布分析结果
    pi.events.emit('analysis:completed', { analysis });
  });
}

// Extension C：报告生成插件
export default function reportGenerator(pi: ExtensionAPI) {
  pi.events.on('analysis:completed', ({ analysis }) => {
    const report = generateReport(analysis);
    console.log('Report generated:', report);
  });
}
```

#### 应用场景 3：状态同步

```typescript
// Extension A：状态管理
export default function stateManager(pi: ExtensionAPI) {
  const state = {
    sessionCount: 0,
    toolCallCount: 0
  };

  pi.on('session_start', () => {
    state.sessionCount++;
    pi.events.emit('state:updated', { state });
  });

  pi.on('tool_call', () => {
    state.toolCallCount++;
    pi.events.emit('state:updated', { state });
  });
}

// Extension B：UI 更新
export default function uiUpdater(pi: ExtensionAPI) {
  pi.events.on('state:updated', ({ state }) => {
    updateUI(state);
  });
}

// Extension C：监控上报
export default function monitoring(pi: ExtensionAPI) {
  pi.events.on('state:updated', ({ state }) => {
    sendToMonitoring(state);
  });
}
```

---

## 与 2025-2026 最新技术趋势的联系

### 分布式 Node.js Event Emitter（2025年8月）

根据 2025 年 8 月的《分布式 Node.js Event Emitter》讨论 [1]，生命周期钩子在适配器管理中的应用：

**核心观点：**
- 使用生命周期钩子管理适配器的连接和断开
- 事件驱动的资源管理
- 支持分布式事件传播

**在 pi-mono 中的体现：**
```typescript
// 使用自定义事件实现分布式通信
export default function distributedExtension(pi: ExtensionAPI) {
  // 连接到远程事件总线
  pi.on('session_start', async () => {
    await connectToRemoteEventBus();
    pi.events.emit('remote:connected');
  });

  // 转发本地事件到远程
  pi.events.on('data:processed', (data) => {
    sendToRemote('data:processed', data);
  });

  // 接收远程事件
  onRemoteEvent('remote:data', (data) => {
    pi.events.emit('remote:data-received', data);
  });
}
```

---

## 代码示例

### 示例 1：基础发布-订阅

```typescript
// Extension A：发布者
export default function publisher(pi: ExtensionAPI) {
  pi.on('session_start', () => {
    console.log('Publisher: Sending greeting');
    pi.events.emit('greeting', { message: 'Hello from publisher!' });
  });
}

// Extension B：订阅者 1
export default function subscriber1(pi: ExtensionAPI) {
  pi.events.on('greeting', ({ message }) => {
    console.log('Subscriber 1 received:', message);
  });
}

// Extension C：订阅者 2
export default function subscriber2(pi: ExtensionAPI) {
  pi.events.on('greeting', ({ message }) => {
    console.log('Subscriber 2 received:', message);
  });
}
```

### 示例 2：请求-响应模式

```typescript
// Extension A：服务提供者
export default function service(pi: ExtensionAPI) {
  pi.events.on('service:request', async ({ requestId, query }) => {
    console.log('Service: Processing request', requestId);

    // 模拟异步处理
    const result = await processQuery(query);

    // 发送响应
    pi.events.emit('service:response', {
      requestId,
      result
    });
  });
}

// Extension B：服务消费者
export default function client(pi: ExtensionAPI) {
  pi.on('tool_call', (tool, args) => {
    const requestId = generateId();

    console.log('Client: Sending request', requestId);

    // 发送请求
    pi.events.emit('service:request', {
      requestId,
      query: 'get-user-data'
    });

    // 监听响应
    pi.events.once('service:response', ({ requestId: respId, result }) => {
      if (respId === requestId) {
        console.log('Client: Received response', result);
      }
    });
  });
}
```

### 示例 3：事件链处理

```typescript
// Extension A：数据加载
export default function loader(pi: ExtensionAPI) {
  pi.on('session_start', async () => {
    console.log('Loader: Loading data...');
    const rawData = await loadData();

    pi.events.emit('pipeline:data-loaded', { rawData });
  });
}

// Extension B：数据验证
export default function validator(pi: ExtensionAPI) {
  pi.events.on('pipeline:data-loaded', ({ rawData }) => {
    console.log('Validator: Validating data...');
    const isValid = validateData(rawData);

    if (isValid) {
      pi.events.emit('pipeline:data-validated', { rawData });
    } else {
      pi.events.emit('pipeline:validation-failed', { error: 'Invalid data' });
    }
  });
}

// Extension C：数据转换
export default function transformer(pi: ExtensionAPI) {
  pi.events.on('pipeline:data-validated', ({ rawData }) => {
    console.log('Transformer: Transforming data...');
    const transformedData = transformData(rawData);

    pi.events.emit('pipeline:data-transformed', { transformedData });
  });
}

// Extension D：数据存储
export default function saver(pi: ExtensionAPI) {
  pi.events.on('pipeline:data-transformed', async ({ transformedData }) => {
    console.log('Saver: Saving data...');
    await saveData(transformedData);

    pi.events.emit('pipeline:completed');
  });

  pi.events.on('pipeline:validation-failed', ({ error }) => {
    console.error('Pipeline failed:', error);
  });
}
```

### 示例 4：状态同步

```typescript
// Extension A：状态管理器
export default function stateManager(pi: ExtensionAPI) {
  const state = {
    sessions: 0,
    tools: 0,
    messages: 0
  };

  pi.on('session_start', () => {
    state.sessions++;
    pi.events.emit('state:changed', { state: { ...state } });
  });

  pi.on('tool_call', () => {
    state.tools++;
    pi.events.emit('state:changed', { state: { ...state } });
  });

  pi.on('message_end', () => {
    state.messages++;
    pi.events.emit('state:changed', { state: { ...state } });
  });

  // 响应状态查询
  pi.events.on('state:query', () => {
    pi.events.emit('state:response', { state: { ...state } });
  });
}

// Extension B：状态显示
export default function stateDisplay(pi: ExtensionAPI) {
  pi.events.on('state:changed', ({ state }) => {
    console.log('=== State Updated ===');
    console.log('Sessions:', state.sessions);
    console.log('Tools:', state.tools);
    console.log('Messages:', state.messages);
  });
}

// Extension C：状态监控
export default function stateMonitor(pi: ExtensionAPI) {
  pi.events.on('state:changed', ({ state }) => {
    if (state.tools > 100) {
      console.warn('⚠️  High tool usage detected!');
    }
  });
}
```

---

## 最佳实践

### 1. 使用命名空间组织事件

```typescript
// ✅ 推荐
pi.events.emit('auth:login-success');
pi.events.emit('data:loaded');
pi.events.emit('ui:updated');

// ❌ 不推荐
pi.events.emit('login-success');
pi.events.emit('loaded');
pi.events.emit('updated');
```

### 2. 使用 TypeScript 类型定义

```typescript
// ✅ 推荐：定义事件类型
interface CustomEvents {
  'data:loaded': { data: any[] };
  'data:processed': { result: any };
  'error:occurred': { error: Error };
}

// 使用类型安全的事件
pi.events.emit('data:loaded', { data: [1, 2, 3] });
```

### 3. 避免事件循环

```typescript
// ❌ 不推荐：可能导致无限循环
pi.events.on('event-a', () => {
  pi.events.emit('event-b');
});

pi.events.on('event-b', () => {
  pi.events.emit('event-a'); // 循环！
});

// ✅ 推荐：使用标志位防止循环
let processing = false;

pi.events.on('event-a', () => {
  if (!processing) {
    processing = true;
    pi.events.emit('event-b');
    processing = false;
  }
});
```

### 4. 清理事件监听器

```typescript
// ✅ 推荐：在扩展卸载时清理
export default function myExtension(pi: ExtensionAPI) {
  const handlers = [];

  const handler1 = (data) => { /* ... */ };
  const handler2 = (data) => { /* ... */ };

  pi.events.on('my-event', handler1);
  pi.events.on('other-event', handler2);

  handlers.push({ event: 'my-event', handler: handler1 });
  handlers.push({ event: 'other-event', handler: handler2 });

  // 清理
  pi.on('session_shutdown', () => {
    handlers.forEach(({ event, handler }) => {
      pi.events.off(event, handler);
    });
  });
}
```

---

## 参考资料

[1] 分布式 Node.js Event Emitter, Reddit 讨论, 2025年8月

---

**版本：** v1.0
**最后更新：** 2026-02-21
**维护者：** Claude Code
