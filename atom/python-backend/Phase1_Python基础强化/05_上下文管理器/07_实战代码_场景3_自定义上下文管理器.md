# 实战代码 - 场景3：自定义上下文管理器

## 概述

演示如何创建自定义上下文管理器，用于性能监控、状态管理、资源控制等场景。

---

## 场景3.1：性能计时器

```python
"""
性能计时器
演示：测量代码执行时间
"""

import time
from contextlib import contextmanager

@contextmanager
def timer(name="Operation"):
    """性能计时器上下文管理器"""
    start = time.time()
    print(f"[{name}] 开始...")

    try:
        yield
    finally:
        elapsed = time.time() - start
        print(f"[{name}] 完成，耗时: {elapsed:.3f}秒")

# 使用
with timer("数据库查询"):
    time.sleep(0.5)  # 模拟耗时操作

with timer("文件处理"):
    time.sleep(0.3)
```

---

## 场景3.2：临时状态修改

```python
"""
临时状态修改
演示：临时修改配置或环境变量
"""

import os
from contextlib import contextmanager

@contextmanager
def temp_env(**env_vars):
    """临时环境变量上下文管理器"""
    old_values = {}

    # 保存并设置新值
    for key, value in env_vars.items():
        old_values[key] = os.environ.get(key)
        os.environ[key] = str(value)
        print(f"设置环境变量: {key}={value}")

    try:
        yield
    finally:
        # 恢复原值
        for key, old_value in old_values.items():
            if old_value is None:
                os.environ.pop(key, None)
            else:
                os.environ[key] = old_value
        print("环境变量已恢复")

# 使用
with temp_env(DEBUG="true", LOG_LEVEL="debug"):
    print(f"DEBUG={os.environ.get('DEBUG')}")
    print(f"LOG_LEVEL={os.environ.get('LOG_LEVEL')}")
```

---

## 场景3.3：资源限制

```python
"""
资源限制
演示：限制代码执行时间或资源使用
"""

import signal
from contextlib import contextmanager

@contextmanager
def timeout(seconds):
    """超时上下文管理器"""
    def timeout_handler(signum, frame):
        raise TimeoutError(f"操作超时（{seconds}秒）")

    # 设置信号处理器
    old_handler = signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(seconds)

    try:
        yield
    finally:
        # 取消定时器并恢复原处理器
        signal.alarm(0)
        signal.signal(signal.SIGALRM, old_handler)

# 使用
try:
    with timeout(2):
        time.sleep(1)  # 正常完成
        print("操作完成")
except TimeoutError as e:
    print(f"超时: {e}")

try:
    with timeout(1):
        time.sleep(2)  # 超时
except TimeoutError as e:
    print(f"超时: {e}")
```

---

## 场景3.4：日志上下文

```python
"""
日志上下文
演示：为日志添加上下文信息
"""

from contextlib import contextmanager
from contextvars import ContextVar
import logging

# 上下文变量
request_id_var = ContextVar("request_id", default=None)

@contextmanager
def log_context(request_id):
    """日志上下文管理器"""
    token = request_id_var.set(request_id)
    logger.info(f"[{request_id}] 请求开始")

    try:
        yield
    finally:
        logger.info(f"[{request_id}] 请求结束")
        request_id_var.reset(token)

# 使用
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

with log_context("req-001"):
    logger.info("处理业务逻辑")
    logger.info("查询数据库")
```

---

## 在 AI Agent 后端中的应用

```python
"""
AI Agent 推理上下文
演示：管理 AI 模型推理资源
"""

@contextmanager
def ai_inference_context(model_name, device="cuda"):
    """AI 推理上下文管理器"""
    import torch

    print(f"加载模型: {model_name}")
    model = load_model(model_name)
    model.to(device)
    model.eval()

    try:
        with torch.no_grad():
            yield model
    finally:
        print(f"卸载模型: {model_name}")
        model.to("cpu")
        del model
        if device == "cuda":
            torch.cuda.empty_cache()

# 使用
@app.post("/predict")
async def predict(text: str):
    with ai_inference_context("gpt-3.5") as model:
        result = model.generate(text)
        return {"result": result}
```

---

**版本：** v1.0
**最后更新：** 2026-02-11
