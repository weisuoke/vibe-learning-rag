# 核心概念11：生产级性能优化

> 从索引、查询、系统、数据四个层面优化向量检索性能

---

## 概述

生产级向量存储需要在召回率、延迟、成本之间权衡。

**优化目标**：
- 召回率：>90%
- 查询延迟（P95）：<100ms
- QPS：>1000

---

## 1. 索引层优化

### 1.1 HNSW参数调优

**M（连接数）**：
```python
# 场景1：高召回率
index_params = {"M": 32, "efConstruction": 500}
# 召回率：98%，内存：大

# 场景2：平衡
index_params = {"M": 16, "efConstruction": 200}
# 召回率：96%，内存：中

# 场景3：低内存
index_params = {"M": 8, "efConstruction": 100}
# 召回率：92%，内存：小
```

---

### 1.2 IVF参数调优

**nlist选择**：
```python
import numpy as np

# 经验公式
nlist = int(np.sqrt(n_vectors))

# 示例
n_vectors = 1_000_000
nlist = int(np.sqrt(n_vectors))  # 1000

# 规则：
# - 太小：搜索范围大，慢
# - 太大：训练慢，聚类质量差
```

**nprobe选择**：
```python
# 召回率 vs 延迟权衡
configs = {
    "快速": {"nprobe": 5, "recall": 0.80, "latency": 10},
    "平衡": {"nprobe": 10, "recall": 0.88, "latency": 20},
    "高召回": {"nprobe": 32, "recall": 0.94, "latency": 50}
}
```

---

## 2. 查询层优化

### 2.1 动态参数调整

```python
def adaptive_search(query, complexity):
    """根据查询复杂度动态调整参数"""

    if complexity == "simple":
        # 简单查询：低参数
        ef = 16
        nprobe = 5
    elif complexity == "medium":
        # 中等查询：平衡参数
        ef = 64
        nprobe = 10
    else:
        # 复杂查询：高参数
        ef = 128
        nprobe = 32

    return collection.search(query, ef=ef, nprobe=nprobe)
```

---

### 2.2 批量查询优化

```python
# 单次查询（慢）
for query in queries:
    results = collection.search(query, limit=10)

# 批量查询（快5-10倍）
results = collection.search(
    data=queries,  # 批量查询
    limit=10,
    batch_size=100
)
```

---

### 2.3 查询缓存

```python
from functools import lru_cache
import hashlib

@lru_cache(maxsize=1000)
def cached_search(query_hash, k):
    """缓存查询结果"""
    return collection.search(query, limit=k)

# 使用
query_hash = hashlib.md5(query.tobytes()).hexdigest()
results = cached_search(query_hash, k=10)
```

---

## 3. 系统层优化

### 3.1 分布式部署

**Milvus集群**：
```yaml
# docker-compose.yml
version: '3.5'

services:
  etcd:
    image: quay.io/coreos/etcd:latest

  minio:
    image: minio/minio:latest

  milvus-standalone:
    image: milvusdb/milvus:latest
    depends_on:
      - etcd
      - minio
    ports:
      - "19530:19530"
```

---

### 3.2 GPU加速

```python
import faiss

# CPU索引
index_cpu = faiss.IndexIVFPQ(quantizer, dim, nlist, m, nbits)

# 转换到GPU
res = faiss.StandardGpuResources()
index_gpu = faiss.index_cpu_to_gpu(res, 0, index_cpu)

# 性能提升：
# - 构建：4.7倍
# - 查询：8倍
```

---

### 3.3 冷热分离

```python
# 三层存储架构
class TieredStorage:
    """冷热分离存储"""

    def __init__(self):
        self.hot = {}   # 内存：最近1周
        self.warm = {}  # SSD：最近1月
        self.cold = {}  # S3：历史数据

    def search(self, query):
        # 1. 先搜索热数据
        results = self.hot.search(query)
        if len(results) >= 10:
            return results

        # 2. 再搜索温数据
        results.extend(self.warm.search(query))
        if len(results) >= 10:
            return results[:10]

        # 3. 最后搜索冷数据
        results.extend(self.cold.search(query))
        return results[:10]
```

---

## 4. 数据层优化

### 4.1 Embedding模型选择

| 模型 | 维度 | 性能 | 适用场景 |
|------|------|------|---------|
| **text-embedding-3-small** | 1536 | 高精度 | 通用 |
| **text-embedding-3-large** | 3072 | 最高精度 | 高要求 |
| **all-MiniLM-L6-v2** | 384 | 快速 | 资源受限 |
| **multilingual-e5-large** | 1024 | 多语言 | 国际化 |

---

### 4.2 Chunking策略

```python
def optimized_chunking(text, chunk_size=512, overlap=50):
    """重叠分块提升召回"""

    chunks = []
    start = 0

    while start < len(text):
        end = start + chunk_size
        chunk = text[start:end]
        chunks.append(chunk)

        # 重叠
        start = end - overlap

    return chunks

# 效果：召回率提升15%
```

---

### 4.3 增量更新

```python
# 避免全量重建
class IncrementalIndex:
    """增量索引"""

    def __init__(self):
        self.buffer = []
        self.buffer_size = 10000

    def add(self, vector):
        """添加向量"""
        self.buffer.append(vector)

        # 达到阈值，批量插入
        if len(self.buffer) >= self.buffer_size:
            self.flush()

    def flush(self):
        """批量插入"""
        collection.insert(self.buffer)
        self.buffer.clear()
```

---

## 5. 监控与调优

### 5.1 关键指标

```python
# 监控指标
metrics = {
    # 召回率
    "recall@10": 0.88,
    "recall@50": 0.95,

    # 延迟
    "latency_p50": 10,  # ms
    "latency_p95": 20,
    "latency_p99": 50,

    # 吞吐量
    "qps": 1000,

    # 资源
    "cpu_usage": 0.60,
    "memory_usage": 0.75,
    "gpu_usage": 0.80
}
```

---

### 5.2 A/B测试

```python
def ab_test(config_a, config_b, queries):
    """A/B测试不同配置"""

    results_a = []
    results_b = []

    for query in queries:
        # 配置A
        start = time.time()
        res_a = search_with_config(query, config_a)
        latency_a = time.time() - start
        results_a.append({
            "recall": evaluate_recall(res_a),
            "latency": latency_a
        })

        # 配置B
        start = time.time()
        res_b = search_with_config(query, config_b)
        latency_b = time.time() - start
        results_b.append({
            "recall": evaluate_recall(res_b),
            "latency": latency_b
        })

    # 对比
    print(f"配置A: 召回率={np.mean([r['recall'] for r in results_a]):.2%}, "
          f"延迟={np.mean([r['latency'] for r in results_a])*1000:.1f}ms")
    print(f"配置B: 召回率={np.mean([r['recall'] for r in results_b]):.2%}, "
          f"延迟={np.mean([r['latency'] for r in results_b])*1000:.1f}ms")
```

---

## 6. 成本优化

### 6.1 内存优化

```python
# 方案1：量化压缩
# IVF-PQ：64倍压缩
# 1亿向量：286GB → 4.5GB

# 方案2：冷热分离
# 热数据（10%）：内存
# 温数据（30%）：SSD
# 冷数据（60%）：S3

# 方案3：按需加载
# 只加载需要的分片
```

---

### 6.2 计算优化

```python
# 方案1：批量查询
# 单次查询：10ms × 100 = 1000ms
# 批量查询：100ms（10倍加速）

# 方案2：GPU加速
# CPU：50ms
# GPU：6ms（8倍加速）

# 方案3：缓存
# 缓存命中率：30%
# 平均延迟：50ms × 0.7 + 1ms × 0.3 = 35.3ms
```

---

## 7. 生产案例

### 7.1 电商推荐（1000万商品）

**配置**：
```python
# Milvus + IVF-PQ
index_params = {
    "index_type": "IVF_PQ",
    "metric_type": "COSINE",
    "params": {
        "nlist": 3162,  # √10000000
        "m": 8,
        "nbits": 8
    }
}

search_params = {
    "nprobe": 16
}

# 性能：
# - 召回率：88%
# - 延迟（P95）：30ms
# - QPS：2000
# - 内存：15GB（64倍压缩）
```

---

### 7.2 企业知识库（100万文档）

**配置**：
```python
# Qdrant + HNSW
index_params = {
    "index_type": "HNSW",
    "params": {
        "m": 16,
        "ef_construct": 200
    }
}

search_params = {
    "ef": 64
}

# 性能：
# - 召回率：96%
# - 延迟（P95）：15ms
# - QPS：1500
# - 内存：3.5GB
```

---

## 8. 优化检查清单

### 索引层
- [ ] 选择合适的索引算法（HNSW/IVF）
- [ ] 调优索引参数（M、nlist）
- [ ] 考虑量化压缩（PQ/SQ）

### 查询层
- [ ] 动态调整查询参数
- [ ] 使用批量查询
- [ ] 实现查询缓存

### 系统层
- [ ] 分布式部署（如需要）
- [ ] GPU加速（如有GPU）
- [ ] 冷热分离（大规模）

### 数据层
- [ ] 选择合适的Embedding模型
- [ ] 优化Chunking策略
- [ ] 实现增量更新

### 监控
- [ ] 监控召回率
- [ ] 监控延迟（P95/P99）
- [ ] 监控资源使用

---

## 总结

### 核心要点

1. **索引优化**：选择合适算法和参数
2. **查询优化**：批量查询、缓存
3. **系统优化**：分布式、GPU、冷热分离
4. **数据优化**：Embedding、Chunking、增量更新
5. **监控调优**：A/B测试、持续优化

### 性能目标

- 召回率：>90%
- 延迟（P95）：<100ms
- QPS：>1000

### 下一步

学习 `03_核心概念_12_RAG系统集成实践.md`，了解RAG集成。
