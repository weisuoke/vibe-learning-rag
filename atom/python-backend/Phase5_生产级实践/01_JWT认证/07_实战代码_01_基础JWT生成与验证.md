# JWT认证 - 实战代码01：基础JWT生成与验证

## 概述

本章使用 python-jose 库实现 JWT 的生成和验证，这是生产环境中最常用的方式。

---

## 环境准备

### 安装依赖

```bash
# 安装 JWT 库
pip install python-jose[cryptography]

# 或使用 uv
uv add python-jose[cryptography]
```

### 导入模块

```python
from jose import jwt, JWTError
from datetime import datetime, timedelta
import os
```

---

## 基础JWT生成

### 最简单的JWT生成

```python
"""
最简单的 JWT 生成示例
演示：生成一个包含用户信息的 JWT
"""

from jose import jwt
from datetime import datetime, timedelta

# 配置
SECRET_KEY = "your-secret-key-keep-it-safe"
ALGORITHM = "HS256"


def create_simple_token(user_id: int) -> str:
    """生成最简单的 JWT"""
    # 1. 准备 Payload
    payload = {
        "user_id": user_id
    }

    # 2. 生成 JWT
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    return token


# 使用示例
token = create_simple_token(user_id=123)
print(f"生成的 Token:\n{token}\n")

# 输出
# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjN9.xxx
```

### 添加过期时间

```python
def create_token_with_expiry(user_id: int, expires_minutes: int = 15) -> str:
    """生成带过期时间的 JWT"""
    # 1. 计算过期时间
    expire = datetime.utcnow() + timedelta(minutes=expires_minutes)

    # 2. 准备 Payload
    payload = {
        "user_id": user_id,
        "exp": expire  # python-jose 会自动转换为 Unix 时间戳
    }

    # 3. 生成 JWT
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    return token


# 使用示例
token = create_token_with_expiry(user_id=123, expires_minutes=15)
print(f"15分钟后过期的 Token:\n{token}\n")
```

### 添加更多字段

```python
def create_full_token(
    user_id: int,
    username: str,
    role: str = "user",
    expires_minutes: int = 15
) -> str:
    """生成完整的 JWT"""
    expire = datetime.utcnow() + timedelta(minutes=expires_minutes)

    payload = {
        "user_id": user_id,
        "username": username,
        "role": role,
        "iat": datetime.utcnow(),  # 签发时间
        "exp": expire              # 过期时间
    }

    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    return token


# 使用示例
token = create_full_token(
    user_id=123,
    username="alice",
    role="admin",
    expires_minutes=15
)
print(f"完整 Token:\n{token}\n")
```

---

## 基础JWT验证

### 最简单的验证

```python
def verify_simple_token(token: str) -> dict:
    """验证 JWT 并返回 Payload"""
    try:
        # 解码并验证 Token
        payload = jwt.decode(
            token,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )
        return payload

    except JWTError as e:
        print(f"验证失败: {e}")
        return None


# 使用示例
token = create_simple_token(user_id=123)
payload = verify_simple_token(token)

if payload:
    print(f"验证成功，用户 ID: {payload['user_id']}")
else:
    print("验证失败")
```

### 处理不同的错误

```python
from jose import jwt, JWTError, ExpiredSignatureError

def verify_token_with_error_handling(token: str) -> dict:
    """验证 JWT，处理不同类型的错误"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return {"success": True, "payload": payload}

    except ExpiredSignatureError:
        # Token 已过期
        return {"success": False, "error": "Token 已过期"}

    except JWTError as e:
        # 其他错误（签名无效、格式错误等）
        return {"success": False, "error": f"Token 无效: {str(e)}"}


# 使用示例
token = create_token_with_expiry(user_id=123, expires_minutes=15)
result = verify_token_with_error_handling(token)

if result["success"]:
    print(f"验证成功: {result['payload']}")
else:
    print(f"验证失败: {result['error']}")
```

---

## 完整示例：生成和验证

```python
"""
JWT 生成和验证完整示例
演示：创建 Token → 验证 Token → 处理过期
"""

from jose import jwt, JWTError, ExpiredSignatureError
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
import os


class JWTManager:
    """JWT 管理器"""

    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm

    def create_token(
        self,
        data: Dict[str, Any],
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """
        生成 JWT

        Args:
            data: 要编码的数据
            expires_delta: 过期时间（从现在开始）

        Returns:
            JWT 字符串
        """
        # 复制数据，避免修改原始数据
        to_encode = data.copy()

        # 添加过期时间
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)

        to_encode.update({"exp": expire})

        # 生成 JWT
        encoded_jwt = jwt.encode(
            to_encode,
            self.secret_key,
            algorithm=self.algorithm
        )

        return encoded_jwt

    def verify_token(self, token: str) -> Dict[str, Any]:
        """
        验证 JWT

        Args:
            token: JWT 字符串

        Returns:
            包含验证结果的字典
        """
        try:
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=[self.algorithm]
            )
            return {
                "valid": True,
                "payload": payload,
                "error": None
            }

        except ExpiredSignatureError:
            return {
                "valid": False,
                "payload": None,
                "error": "expired"
            }

        except JWTError as e:
            return {
                "valid": False,
                "payload": None,
                "error": str(e)
            }


# ===== 使用示例 =====

# 1. 创建 JWT 管理器
jwt_manager = JWTManager(secret_key="your-secret-key")

# 2. 生成 Token
print("=== 生成 Token ===")
token = jwt_manager.create_token(
    data={"user_id": 123, "username": "alice", "role": "admin"},
    expires_delta=timedelta(minutes=15)
)
print(f"Token: {token[:50]}...\n")

# 3. 验证 Token
print("=== 验证 Token ===")
result = jwt_manager.verify_token(token)

if result["valid"]:
    print("✓ Token 有效")
    print(f"  用户 ID: {result['payload']['user_id']}")
    print(f"  用户名: {result['payload']['username']}")
    print(f"  角色: {result['payload']['role']}")
else:
    print(f"✗ Token 无效: {result['error']}")

# 4. 测试过期 Token
print("\n=== 测试过期 Token ===")
expired_token = jwt_manager.create_token(
    data={"user_id": 123},
    expires_delta=timedelta(seconds=-1)  # 已经过期
)
result = jwt_manager.verify_token(expired_token)

if result["valid"]:
    print("✓ Token 有效")
else:
    print(f"✗ Token 无效: {result['error']}")

# 5. 测试篡改 Token
print("\n=== 测试篡改 Token ===")
tampered_token = token[:-5] + "xxxxx"  # 修改签名
result = jwt_manager.verify_token(tampered_token)

if result["valid"]:
    print("✓ Token 有效")
else:
    print(f"✗ Token 无效: {result['error']}")
```

**运行输出：**
```
=== 生成 Token ===
Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2...

=== 验证 Token ===
✓ Token 有效
  用户 ID: 123
  用户名: alice
  角色: admin

=== 测试过期 Token ===
✗ Token 无效: expired

=== 测试篡改 Token ===
✗ Token 无效: Signature verification failed
```

---

## 在 FastAPI 中使用

### 基础集成

```python
"""
FastAPI 中使用 JWT
演示：登录 → 生成 Token → 验证 Token
"""

from fastapi import FastAPI, HTTPException, Depends, Header
from pydantic import BaseModel
from jose import jwt, JWTError
from datetime import timedelta

app = FastAPI()

# 配置
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 15

# JWT 管理器
jwt_manager = JWTManager(SECRET_KEY, ALGORITHM)


# ===== 数据模型 =====

class LoginRequest(BaseModel):
    username: str
    password: str


class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"


# ===== 模拟用户数据库 =====

fake_users_db = {
    "alice": {
        "user_id": 123,
        "username": "alice",
        "password": "password123",  # 实际应该是哈希后的密码
        "role": "admin"
    },
    "bob": {
        "user_id": 456,
        "username": "bob",
        "password": "password456",
        "role": "user"
    }
}


# ===== 路由端点 =====

@app.post("/login", response_model=TokenResponse)
async def login(request: LoginRequest):
    """登录端点：验证用户并返回 JWT"""
    # 1. 查找用户
    user = fake_users_db.get(request.username)
    if not user:
        raise HTTPException(status_code=401, detail="用户名或密码错误")

    # 2. 验证密码（实际应该用 bcrypt）
    if request.password != user["password"]:
        raise HTTPException(status_code=401, detail="用户名或密码错误")

    # 3. 生成 JWT
    token = jwt_manager.create_token(
        data={
            "user_id": user["user_id"],
            "username": user["username"],
            "role": user["role"]
        },
        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    )

    return TokenResponse(access_token=token)


@app.get("/verify")
async def verify_token_endpoint(authorization: str = Header()):
    """验证 Token 端点"""
    # 1. 检查格式
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="无效的认证格式")

    # 2. 提取 Token
    token = authorization.replace("Bearer ", "")

    # 3. 验证 Token
    result = jwt_manager.verify_token(token)

    if not result["valid"]:
        if result["error"] == "expired":
            raise HTTPException(status_code=401, detail="Token 已过期")
        else:
            raise HTTPException(status_code=401, detail="无效的 Token")

    return {
        "message": "Token 有效",
        "payload": result["payload"]
    }


@app.get("/profile")
async def get_profile(authorization: str = Header()):
    """受保护的端点：需要有效的 Token"""
    # 验证 Token
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="无效的认证格式")

    token = authorization.replace("Bearer ", "")
    result = jwt_manager.verify_token(token)

    if not result["valid"]:
        raise HTTPException(status_code=401, detail="Token 无效或已过期")

    # 返回用户信息
    payload = result["payload"]
    return {
        "user_id": payload["user_id"],
        "username": payload["username"],
        "role": payload["role"]
    }


# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 测试 API

```bash
# 1. 登录获取 Token
curl -X POST "http://localhost:8000/login" \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "password123"}'

# 响应
# {
#   "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
#   "token_type": "bearer"
# }

# 2. 验证 Token
TOKEN="<从登录响应中复制 access_token>"
curl -X GET "http://localhost:8000/verify" \
  -H "Authorization: Bearer $TOKEN"

# 响应
# {
#   "message": "Token 有效",
#   "payload": {
#     "user_id": 123,
#     "username": "alice",
#     "role": "admin",
#     "exp": 1709280000
#   }
# }

# 3. 访问受保护端点
curl -X GET "http://localhost:8000/profile" \
  -H "Authorization: Bearer $TOKEN"

# 响应
# {
#   "user_id": 123,
#   "username": "alice",
#   "role": "admin"
# }
```

---

## 环境变量管理

### 使用 python-dotenv

```python
"""
使用环境变量管理密钥
演示：从 .env 文件读取配置
"""

from dotenv import load_dotenv
import os

# 加载 .env 文件
load_dotenv()

# 读取配置
SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = os.getenv("ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "15"))

# 验证必需的配置
if not SECRET_KEY:
    raise ValueError("SECRET_KEY 环境变量未设置")

print(f"SECRET_KEY: {SECRET_KEY[:10]}...")
print(f"ALGORITHM: {ALGORITHM}")
print(f"ACCESS_TOKEN_EXPIRE_MINUTES: {ACCESS_TOKEN_EXPIRE_MINUTES}")
```

**.env 文件：**
```bash
# JWT 配置
SECRET_KEY=your-secret-key-keep-it-safe-and-random
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=15

# 数据库配置
DATABASE_URL=postgresql://user:password@localhost:5432/dbname

# API 密钥
OPENAI_API_KEY=sk-...
```

---

## 调试和日志

### 添加日志

```python
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class JWTManagerWithLogging(JWTManager):
    """带日志的 JWT 管理器"""

    def create_token(self, data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
        """生成 JWT（带日志）"""
        logger.info(f"生成 Token，用户 ID: {data.get('user_id')}")

        token = super().create_token(data, expires_delta)

        logger.debug(f"Token 生成成功: {token[:20]}...")
        return token

    def verify_token(self, token: str) -> Dict[str, Any]:
        """验证 JWT（带日志）"""
        logger.info(f"验证 Token: {token[:20]}...")

        result = super().verify_token(token)

        if result["valid"]:
            logger.info(f"Token 验证成功，用户 ID: {result['payload'].get('user_id')}")
        else:
            logger.warning(f"Token 验证失败: {result['error']}")

        return result


# 使用示例
jwt_manager = JWTManagerWithLogging(SECRET_KEY)

token = jwt_manager.create_token({"user_id": 123})
# 日志: 2024-02-12 10:00:00 - __main__ - INFO - 生成 Token，用户 ID: 123
# 日志: 2024-02-12 10:00:00 - __main__ - DEBUG - Token 生成成功: eyJhbGciOiJIUzI1NiI...

result = jwt_manager.verify_token(token)
# 日志: 2024-02-12 10:00:01 - __main__ - INFO - 验证 Token: eyJhbGciOiJIUzI1NiI...
# 日志: 2024-02-12 10:00:01 - __main__ - INFO - Token 验证成功，用户 ID: 123
```

---

## 在 AI Agent API 中的应用

### AI Agent 对话端点

```python
@app.post("/agent/chat")
async def chat(
    message: str,
    authorization: str = Header()
):
    """AI Agent 对话端点（需要认证）"""
    # 1. 验证 Token
    if not authorization.startswith("Bearer "):
        raise HTTPException(401, "无效的认证格式")

    token = authorization.replace("Bearer ", "")
    result = jwt_manager.verify_token(token)

    if not result["valid"]:
        raise HTTPException(401, "Token 无效或已过期")

    # 2. 获取用户信息
    user_id = result["payload"]["user_id"]
    username = result["payload"]["username"]

    # 3. 调用 AI Agent（简化）
    response = f"AI 回复给 {username}: 你说了 '{message}'"

    # 4. 返回响应
    return {
        "user_id": user_id,
        "message": message,
        "response": response
    }
```

**测试：**
```bash
# 1. 登录
TOKEN=$(curl -s -X POST "http://localhost:8000/login" \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "password123"}' \
  | jq -r '.access_token')

# 2. 调用 AI Agent
curl -X POST "http://localhost:8000/agent/chat?message=你好" \
  -H "Authorization: Bearer $TOKEN"

# 响应
# {
#   "user_id": 123,
#   "message": "你好",
#   "response": "AI 回复给 alice: 你说了 '你好'"
# }
```

---

## 总结

**本章学习了：**
1. 使用 python-jose 生成 JWT
2. 验证 JWT 并处理不同错误
3. 在 FastAPI 中集成 JWT
4. 环境变量管理密钥
5. 添加日志和调试
6. 在 AI Agent API 中应用

**关键点：**
- 使用 `jwt.encode()` 生成 Token
- 使用 `jwt.decode()` 验证 Token
- 处理 `ExpiredSignatureError` 和 `JWTError`
- 密钥从环境变量读取
- 添加日志方便调试

**下一步：**
- 学习用户登录注册（密码哈希）
- 学习 Token 刷新机制
- 学习依赖注入保护路由
