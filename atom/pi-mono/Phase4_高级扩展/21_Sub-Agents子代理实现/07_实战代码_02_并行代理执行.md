# å¹¶è¡Œä»£ç†æ‰§è¡Œ - å®æˆ˜ä»£ç 

> **çŸ¥è¯†ç‚¹**: Sub-Agents å­ä»£ç†å®ç° - å¹¶è¡Œä»£ç†æ‰§è¡Œæ¨¡å¼
> **éš¾åº¦**: â­â­â­â­
> **å‰ç½®çŸ¥è¯†**: åŸºç¡€å•ä»£ç†æ‰§è¡Œã€Promise.allã€å¹¶å‘æ§åˆ¶

---

## 1. åœºæ™¯æè¿°

å¹¶è¡Œä»£ç†æ‰§è¡Œæ˜¯ Sub-Agents ç³»ç»Ÿä¸­æœ€èƒ½æå‡æ€§èƒ½çš„æ¨¡å¼ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œä¸»ä»£ç†å°†å¤šä¸ªç‹¬ç«‹ä»»åŠ¡åŒæ—¶å§”æ‰˜ç»™å¤šä¸ªä¸“ä¸šåŒ–å­ä»£ç†å¹¶è¡Œæ‰§è¡Œï¼Œæ˜¾è‘—ç¼©çŸ­æ€»æ‰§è¡Œæ—¶é—´ã€‚

**å…¸å‹åº”ç”¨åœºæ™¯**:
- å¤šæ–‡ä»¶ä»£ç å®¡æŸ¥ï¼šåŒæ—¶å®¡æŸ¥å¤šä¸ªæ–‡ä»¶çš„ä»£ç å˜æ›´
- å¹¶è¡Œæµ‹è¯•æ‰§è¡Œï¼šåŒæ—¶è¿è¡Œå•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€E2Eæµ‹è¯•
- å¤šç»´åº¦åˆ†æï¼šåŒæ—¶è¿›è¡Œå®‰å…¨æ‰«æã€æ€§èƒ½åˆ†æã€ä»£ç è´¨é‡æ£€æŸ¥
- æ•°æ®å¹¶è¡Œå¤„ç†ï¼šåŒæ—¶å¤„ç†å¤šä¸ªæ•°æ®æºæˆ–æ•°æ®åˆ†ç‰‡

æ ¹æ® [Redis çš„ AI Agent Architecture ç ”ç©¶](https://redis.io/blog/ai-agent-architecture/)ï¼Œå¹¶è¡Œæ‰§è¡Œæ¨¡å¼å¯ä»¥å®ç° **3x æ›´å¿«çš„å†³ç­–é€Ÿåº¦**å’Œ **45% æ›´å°‘çš„äº¤æ¥æ¬¡æ•°**ã€‚[claude-flow](https://github.com/ruvnet/claude-flow) çš„ Ruflo v3 å¹³å°å±•ç¤ºäº† 15 ä¸ªå¹¶å‘ä»£ç†çš„ swarm æ¶æ„å®ç°ï¼Œè¯æ˜äº†å¤§è§„æ¨¡å¹¶è¡Œæ‰§è¡Œçš„å¯è¡Œæ€§ã€‚

---

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 å¹¶è¡Œæ‰§è¡Œæ¨¡å‹

å¹¶è¡Œä»£ç†æ‰§è¡Œéµå¾ªä»¥ä¸‹æ ¸å¿ƒåŸåˆ™ï¼š

1. **ä»»åŠ¡ç‹¬ç«‹æ€§**: å¹¶è¡Œä»»åŠ¡ä¹‹é—´ä¸åº”æœ‰æ•°æ®ä¾èµ–
2. **å¹¶å‘æ§åˆ¶**: é™åˆ¶åŒæ—¶æ‰§è¡Œçš„ä»£ç†æ•°é‡ï¼ˆé€šå¸¸ 4-8 ä¸ªï¼‰
3. **ç»“æœèšåˆ**: æ”¶é›†æ‰€æœ‰ä»£ç†çš„ç»“æœå¹¶ç»Ÿä¸€å¤„ç†
4. **é”™è¯¯éš”ç¦»**: å•ä¸ªä»£ç†å¤±è´¥ä¸å½±å“å…¶ä»–ä»£ç†

æ ¹æ® [SWFTE çš„ä¼ä¸šçº§å¤šä»£ç†ç³»ç»Ÿç ”ç©¶](https://www.swfte.com/blog/multi-agent-ai-systems-enterprise)ï¼Œæ€§èƒ½ä¼˜åŒ–æŠ€æœ¯å¯ä»¥å®ç° **45% æ›´å°‘çš„äº¤æ¥**å’Œ **3x æ›´å¿«çš„å†³ç­–**ã€‚

### 2.2 å¹¶å‘æ§åˆ¶ç­–ç•¥

**ä¸ºä»€ä¹ˆéœ€è¦å¹¶å‘æ§åˆ¶ï¼Ÿ**

æ ¹æ® [Reddit ç¤¾åŒºçš„ç”Ÿäº§ç»éªŒ](https://www.reddit.com/r/AI_Agents/comments/1oukxzx/tested_5_agent_frameworks_in_production_heres/)ï¼Œæ— é™åˆ¶çš„å¹¶å‘ä¼šå¯¼è‡´ï¼š
- API é€Ÿç‡é™åˆ¶è§¦å‘
- å†…å­˜æ¶ˆè€—è¿‡é«˜
- ä¸Šä¸‹æ–‡çª—å£å†²çª
- æˆæœ¬å¤±æ§

**æœ€ä½³å®è·µ**: ä½¿ç”¨ p-limit æˆ–è‡ªå®šä¹‰å¹¶å‘æ± ï¼Œé™åˆ¶åŒæ—¶æ‰§è¡Œçš„ä»£ç†æ•°é‡ä¸º 4-8 ä¸ªã€‚

### 2.3 ä¸ pi-mono çš„é›†æˆ

åœ¨ pi-mono æ¶æ„ä¸­ï¼Œå¹¶è¡Œæ‰§è¡Œé€šè¿‡ `subagent` Extension çš„ `tasks` å‚æ•°å®ç°ï¼š

```typescript
{
  tasks: [
    { agent: "code-reviewer", task: "Review auth.ts" },
    { agent: "security-auditor", task: "Scan for vulnerabilities" },
    { agent: "test-automator", task: "Generate tests" }
  ]
}
```

---

## 3. å®Œæ•´ä»£ç ç¤ºä¾‹

### 3.1 å¹¶è¡Œä»£ç†æ‰§è¡Œå™¨å®ç°

```typescript
import { ExtensionAPI } from "@pi-mono/extension-api";
import { z } from "zod";
import pLimit from "p-limit";

// å®šä¹‰å¹¶è¡Œä»»åŠ¡å‚æ•° Schema
const ParallelTasksParams = z.object({
  tasks: z.array(z.object({
    agent: z.string(),
    task: z.string(),
    context: z.record(z.any()).optional(),
  })).min(1).max(8).describe("Parallel tasks (max 8)"),
  maxConcurrency: z.number().min(1).max(8).default(4).describe("Max concurrent agents"),
});

type ParallelTasksParams = z.infer<typeof ParallelTasksParams>;

interface TaskResult {
  agent: string;
  task: string;
  success: boolean;
  output?: string;
  error?: string;
  duration: number;
  usage?: {
    inputTokens: number;
    outputTokens: number;
    totalCost: number;
  };
}

/**
 * å¹¶è¡Œä»£ç†æ‰§è¡Œå™¨
 *
 * å‚è€ƒ:
 * - https://github.com/ruvnet/claude-flow (Ruflo v3 swarm architecture)
 * - https://redis.io/blog/ai-agent-architecture/ (3x faster decisions)
 */
export class ParallelAgentExecutor {
  private singleExecutor: any; // SingleAgentExecutor from File 01
  private cwd: string;

  constructor(cwd: string, singleExecutor: any) {
    this.cwd = cwd;
    this.singleExecutor = singleExecutor;
  }

  /**
   * å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä»£ç†ä»»åŠ¡
   *
   * @param tasks - ä»»åŠ¡åˆ—è¡¨
   * @param maxConcurrency - æœ€å¤§å¹¶å‘æ•°
   * @param signal - ä¸­æ–­ä¿¡å·
   * @param onUpdate - è¿›åº¦æ›´æ–°å›è°ƒ
   * @returns æ‰€æœ‰ä»»åŠ¡çš„ç»“æœ
   */
  async executeParallel(
    tasks: Array<{ agent: string; task: string; context?: Record<string, any> }>,
    maxConcurrency: number = 4,
    signal?: AbortSignal,
    onUpdate?: (update: string) => void
  ): Promise<TaskResult[]> {
    const startTime = Date.now();

    onUpdate?.(`ğŸš€ Starting ${tasks.length} agents in parallel (max concurrency: ${maxConcurrency})`);

    // åˆ›å»ºå¹¶å‘é™åˆ¶å™¨
    const limit = pLimit(maxConcurrency);

    // åˆ›å»ºä»»åŠ¡æ‰§è¡Œå‡½æ•°
    const executeTask = async (
      taskDef: { agent: string; task: string; context?: Record<string, any> },
      index: number
    ): Promise<TaskResult> => {
      const taskStartTime = Date.now();

      try {
        onUpdate?.(`[${index + 1}/${tasks.length}] ğŸ”„ Starting ${taskDef.agent}...`);

        const result = await this.singleExecutor.execute(
          taskDef.agent,
          taskDef.task,
          taskDef.context || {},
          signal,
          (msg: string) => {
            onUpdate?.(`[${index + 1}/${tasks.length}] ${taskDef.agent}: ${msg}`);
          }
        );

        const duration = Date.now() - taskStartTime;

        onUpdate?.(`[${index + 1}/${tasks.length}] âœ… ${taskDef.agent} completed (${duration}ms)`);

        return {
          agent: taskDef.agent,
          task: taskDef.task,
          success: result.success,
          output: result.output,
          duration,
          usage: result.usage,
        };
      } catch (error) {
        const duration = Date.now() - taskStartTime;
        const errorMessage = error instanceof Error ? error.message : String(error);

        onUpdate?.(`[${index + 1}/${tasks.length}] âŒ ${taskDef.agent} failed: ${errorMessage}`);

        return {
          agent: taskDef.agent,
          task: taskDef.task,
          success: false,
          error: errorMessage,
          duration,
        };
      }
    };

    // ä½¿ç”¨ p-limit æ§åˆ¶å¹¶å‘
    const promises = tasks.map((taskDef, index) =>
      limit(() => executeTask(taskDef, index))
    );

    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    const results = await Promise.all(promises);

    const totalDuration = Date.now() - startTime;
    const successCount = results.filter(r => r.success).length;
    const failureCount = results.length - successCount;

    onUpdate?.(`\nğŸ“Š Summary: ${successCount} succeeded, ${failureCount} failed, ${totalDuration}ms total`);

    // è®¡ç®—æ€» usage
    const totalUsage = results.reduce((acc, r) => {
      if (r.usage) {
        acc.inputTokens += r.usage.inputTokens;
        acc.outputTokens += r.usage.outputTokens;
        acc.totalCost += r.usage.totalCost;
      }
      return acc;
    }, { inputTokens: 0, outputTokens: 0, totalCost: 0 });

    onUpdate?.(`ğŸ’° Total usage: ${totalUsage.inputTokens} input + ${totalUsage.outputTokens} output tokens ($${totalUsage.totalCost.toFixed(4)})`);

    return results;
  }

  /**
   * èšåˆå¤šä¸ªä»£ç†çš„ç»“æœ
   *
   * @param results - ä»»åŠ¡ç»“æœåˆ—è¡¨
   * @returns èšåˆåçš„ç»“æœ
   */
  aggregateResults(results: TaskResult[]): {
    summary: string;
    details: Array<{ agent: string; output: string }>;
    failures: Array<{ agent: string; error: string }>;
  } {
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);

    return {
      summary: `Completed ${successful.length}/${results.length} tasks successfully`,
      details: successful.map(r => ({
        agent: r.agent,
        output: r.output || "",
      })),
      failures: failed.map(r => ({
        agent: r.agent,
        error: r.error || "Unknown error",
      })),
    };
  }
}

/**
 * Extension æ³¨å†Œå‡½æ•°
 */
export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "execute_parallel_agents",
    description: "Execute multiple specialized agents in parallel for independent tasks",
    parameters: ParallelTasksParams,
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      // å‡è®¾ SingleAgentExecutor å·²ç»æ³¨å†Œ
      const singleExecutor = new (require("./single-agent-executor")).SingleAgentExecutor(ctx.cwd);
      const parallelExecutor = new ParallelAgentExecutor(ctx.cwd, singleExecutor);

      const results = await parallelExecutor.executeParallel(
        params.tasks,
        params.maxConcurrency,
        signal,
        (update) => {
          onUpdate({
            type: "progress",
            content: update,
          });
        }
      );

      // æ£€æŸ¥æ˜¯å¦æœ‰å¤±è´¥
      const failures = results.filter(r => !r.success);
      if (failures.length > 0) {
        const failureMessages = failures.map(f => `${f.agent}: ${f.error}`).join("; ");
        throw new Error(`${failures.length} agents failed: ${failureMessages}`);
      }

      const aggregated = parallelExecutor.aggregateResults(results);

      return {
        summary: aggregated.summary,
        results: aggregated.details,
        totalTasks: results.length,
        successfulTasks: results.filter(r => r.success).length,
      };
    },
  });
}
```

### 3.2 ä½¿ç”¨ç¤ºä¾‹

```typescript
// ç¤ºä¾‹ 1: å¤šæ–‡ä»¶ä»£ç å®¡æŸ¥
const reviewResults = await pi.tools.execute_parallel_agents({
  tasks: [
    { agent: "code-reviewer", task: "Review src/auth.ts for security" },
    { agent: "code-reviewer", task: "Review src/api.ts for best practices" },
    { agent: "code-reviewer", task: "Review src/db.ts for performance" },
  ],
  maxConcurrency: 3,
});

// ç¤ºä¾‹ 2: å¤šç»´åº¦åˆ†æ
const analysisResults = await pi.tools.execute_parallel_agents({
  tasks: [
    { agent: "security-auditor", task: "Scan for vulnerabilities" },
    { agent: "performance-engineer", task: "Analyze performance bottlenecks" },
    { agent: "test-automator", task: "Check test coverage" },
    { agent: "documentation-expert", task: "Verify API documentation" },
  ],
  maxConcurrency: 4,
});

// ç¤ºä¾‹ 3: å¹¶è¡Œæµ‹è¯•æ‰§è¡Œ
const testResults = await pi.tools.execute_parallel_agents({
  tasks: [
    { agent: "test-automator", task: "Run unit tests", context: { suite: "unit" } },
    { agent: "test-automator", task: "Run integration tests", context: { suite: "integration" } },
    { agent: "test-automator", task: "Run E2E tests", context: { suite: "e2e" } },
  ],
  maxConcurrency: 3,
});
```

---

## 4. ä»£ç è§£æ

### 4.1 æ ¸å¿ƒè®¾è®¡å†³ç­–

**1. å¹¶å‘æ§åˆ¶ä½¿ç”¨ p-limit**

```typescript
const limit = pLimit(maxConcurrency);
const promises = tasks.map((taskDef, index) =>
  limit(() => executeTask(taskDef, index))
);
```

è¿™ç§è®¾è®¡å‚è€ƒäº† [claude-flow çš„ swarm æ¶æ„](https://github.com/ruvnet/claude-flow)ï¼Œç¡®ä¿ä¸ä¼šåŒæ—¶å¯åŠ¨è¿‡å¤šä»£ç†ã€‚æ ¹æ®ç”Ÿäº§ç»éªŒï¼Œ4-8 ä¸ªå¹¶å‘æ˜¯æœ€ä½³å¹³è¡¡ç‚¹ã€‚

**2. Promise.all ç­‰å¾…æ‰€æœ‰ä»»åŠ¡**

```typescript
const results = await Promise.all(promises);
```

ä½¿ç”¨ `Promise.all` è€Œé `Promise.allSettled` æ˜¯å› ä¸ºæˆ‘ä»¬å¸Œæœ›åœ¨ä»»ä½•ä»»åŠ¡å¤±è´¥æ—¶èƒ½å¤Ÿå¿«é€Ÿå¤±è´¥ã€‚å¦‚æœéœ€è¦å®¹é”™ï¼Œå¯ä»¥æ”¹ç”¨ `Promise.allSettled`ã€‚

**3. å®æ—¶è¿›åº¦è¿½è¸ª**

æ¯ä¸ªä»»åŠ¡çš„è¿›åº¦éƒ½é€šè¿‡ `onUpdate` å›è°ƒå®æ—¶æŠ¥å‘Šï¼š

```typescript
onUpdate?.(`[${index + 1}/${tasks.length}] ğŸ”„ Starting ${taskDef.agent}...`);
```

è¿™æä¾›äº†é€æ˜çš„æ‰§è¡Œå¯è§æ€§ï¼Œç”¨æˆ·å¯ä»¥çœ‹åˆ°å“ªäº›ä»£ç†æ­£åœ¨è¿è¡Œã€å“ªäº›å·²å®Œæˆã€‚

### 4.2 æ€§èƒ½ä¼˜åŒ–

æ ¹æ® [Redis çš„ç ”ç©¶](https://redis.io/blog/ai-agent-architecture/)ï¼Œå¹¶è¡Œæ‰§è¡Œå¯ä»¥å®ç° 3x çš„é€Ÿåº¦æå‡ã€‚æˆ‘ä»¬çš„å®ç°é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¼˜åŒ–æ€§èƒ½ï¼š

- **å¹¶å‘é™åˆ¶**: é¿å… API é€Ÿç‡é™åˆ¶
- **ç‹¬ç«‹è¿›ç¨‹**: æ¯ä¸ªä»£ç†åœ¨ç‹¬ç«‹è¿›ç¨‹ä¸­è¿è¡Œï¼Œé¿å…å†…å­˜å†²çª
- **Usage è¿½è¸ª**: å®æ—¶ç›‘æ§ token æ¶ˆè€—å’Œæˆæœ¬

---

## 5. å®é™…æ¡ˆä¾‹åˆ†æ

### æ¡ˆä¾‹ 1: claude-flow çš„ 15-Agent Swarm æ¶æ„

**æ¥æº**: [claude-flow GitHub](https://github.com/ruvnet/claude-flow)

Ruflo v3 å¹³å°å®ç°äº† 15 ä¸ªå¹¶å‘ä»£ç†çš„ swarm æ¶æ„ï¼Œç”¨äºå®Œæ•´çš„å¼€å‘ä¸æµ‹è¯•æµç¨‹ã€‚

**å…³é”®ç‰¹æ€§**:
- **Queen-led hierarchy**: ä½¿ç”¨ queen ä»£ç†åè°ƒ worker ä»£ç†
- **Byzantine fault-tolerant consensus**: æ”¯æŒ f < n/3 çš„å®¹é”™
- **Unlimited concurrent agents**: ç†è®ºä¸Šæ”¯æŒæ— é™ä»£ç†å¹¶å‘

**æ€§èƒ½æ•°æ®**:
- 10-20x æ›´å¿«çš„ swarm ç”Ÿæˆé€Ÿåº¦
- 2.8-4.4x æ›´å¿«çš„ä»»åŠ¡æ‰§è¡Œ
- 84.8% SWE-Bench å‡†ç¡®ç‡

**ç»éªŒæ•™è®­**:
- Swarm æ¶æ„é€‚åˆå¤æ‚çš„å¤šæ­¥éª¤ä»»åŠ¡
- Queen-worker æ¨¡å¼æä¾›äº†è‰¯å¥½çš„åè°ƒæœºåˆ¶
- éœ€è¦å¼ºå¤§çš„å…±è¯†ç®—æ³•ç¡®ä¿ä¸€è‡´æ€§

### æ¡ˆä¾‹ 2: ä¼ä¸šçº§å¤šä»£ç†ç³»ç»Ÿçš„æ€§èƒ½ä¼˜åŒ–

**æ¥æº**: [SWFTE Blog - Multi-Agent AI Systems](https://www.swfte.com/blog/multi-agent-ai-systems-enterprise)

ä¼ä¸šçº§å¤šä»£ç†ç³»ç»Ÿé€šè¿‡å¹¶è¡Œæ‰§è¡Œå®ç°äº†æ˜¾è‘—çš„æ€§èƒ½æå‡ã€‚

**æ€§èƒ½æ•°æ®**:
- **45% æ›´å°‘çš„äº¤æ¥æ¬¡æ•°**: å‡å°‘ä»£ç†é—´é€šä¿¡å¼€é”€
- **3x æ›´å¿«çš„å†³ç­–é€Ÿåº¦**: å¹¶è¡Œåˆ†æå¤šä¸ªç»´åº¦
- **å®æ—¶åä½œ**: ä»£ç†é—´å®æ—¶å…±äº«ä¸Šä¸‹æ–‡

**åº”ç”¨åœºæ™¯**:
- é‡‘èé£é™©åˆ†æï¼šåŒæ—¶åˆ†æå¸‚åœºã€ä¿¡ç”¨ã€æ“ä½œé£é™©
- åŒ»ç–—è¯Šæ–­ï¼šå¹¶è¡Œå¤„ç†å½±åƒã€å®éªŒå®¤ã€ç—…å²æ•°æ®
- ä¾›åº”é“¾ä¼˜åŒ–ï¼šåŒæ—¶ä¼˜åŒ–åº“å­˜ã€ç‰©æµã€é‡‡è´­

**æœ€ä½³å®è·µ**:
- ä½¿ç”¨ orchestrator-worker æ¨¡å¼
- å®æ–½å…¨å±€é€Ÿç‡é™åˆ¶
- ç›‘æ§ä»£ç†é—´é€šä¿¡æˆæœ¬

### æ¡ˆä¾‹ 3: Reddit ç¤¾åŒºçš„ç”Ÿäº§æ¡†æ¶æµ‹è¯•

**æ¥æº**: [Reddit - Tested 5 Agent Frameworks in Production](https://www.reddit.com/r/AI_Agents/comments/1oukxzx/tested_5_agent_frameworks_in_production_heres/)

ç¤¾åŒºæˆå‘˜åœ¨ç”Ÿäº§ç¯å¢ƒä¸­æµ‹è¯•äº† 5 ä¸ªä»£ç†æ¡†æ¶ï¼Œå¯¹æ¯”äº†å¹¶è¡Œæ‰§è¡Œæ€§èƒ½ã€‚

**å…³é”®å‘ç°**:
- **LangGraph**: é€‚åˆåˆ†æ”¯å·¥ä½œæµå’ŒçŠ¶æ€ç®¡ç†
- **CrewAI**: é€‚åˆå¤šä»£ç†è§’è‰²åä½œ
- **å¹¶å‘æ§åˆ¶è‡³å…³é‡è¦**: æ— é™åˆ¶å¹¶å‘å¯¼è‡´ API é€Ÿç‡é™åˆ¶

**å®é™…é—®é¢˜**:
- æˆæœ¬å¤±æ§ï¼šå¹¶è¡Œæ‰§è¡Œå¢åŠ  token æ¶ˆè€—
- ä¸Šä¸‹æ–‡å†²çªï¼šå¤šä¸ªä»£ç†åŒæ—¶ä¿®æ”¹ç›¸åŒæ–‡ä»¶
- é”™è¯¯ä¼ æ’­ï¼šä¸€ä¸ªä»£ç†å¤±è´¥å½±å“å…¶ä»–ä»£ç†

**è§£å†³æ–¹æ¡ˆ**:
- é™åˆ¶æœ€å¤§å¹¶å‘æ•°ä¸º 4-6 ä¸ª
- ä½¿ç”¨ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†æ‰§è¡Œé¡ºåº
- å®æ–½é‡è¯•å’Œé™çº§ç­–ç•¥

---

## 6. æœ€ä½³å®è·µ

### 6.1 ä»»åŠ¡ç‹¬ç«‹æ€§éªŒè¯

**ç¡®ä¿ä»»åŠ¡é—´æ— ä¾èµ–**:

```typescript
// âœ… å¥½çš„è®¾è®¡ - ä»»åŠ¡ç‹¬ç«‹
const tasks = [
  { agent: "code-reviewer", task: "Review auth.ts" },
  { agent: "code-reviewer", task: "Review api.ts" },
  { agent: "code-reviewer", task: "Review db.ts" },
];

// âŒ ä¸å¥½çš„è®¾è®¡ - ä»»åŠ¡æœ‰ä¾èµ–
const tasks = [
  { agent: "planner", task: "Design API" },
  { agent: "coder", task: "Implement API" }, // ä¾èµ– planner çš„è¾“å‡º
  { agent: "tester", task: "Test API" },     // ä¾èµ– coder çš„è¾“å‡º
];
```

### 6.2 å¹¶å‘æ•°é‡æ§åˆ¶

æ ¹æ® [ç”Ÿäº§ç»éªŒ](https://www.reddit.com/r/AI_Agents/comments/1oukxzx/tested_5_agent_frameworks_in_production_heres/)ï¼Œæ¨èçš„å¹¶å‘æ•°ï¼š

- **2-3 ä¸ª**: ç®€å•ä»»åŠ¡ï¼Œå¿«é€Ÿå“åº”
- **4-6 ä¸ª**: æ ‡å‡†ä»»åŠ¡ï¼Œå¹³è¡¡æ€§èƒ½å’Œæˆæœ¬
- **7-8 ä¸ª**: å¤æ‚ä»»åŠ¡ï¼Œæœ€å¤§ååé‡

```typescript
// æ ¹æ®ä»»åŠ¡å¤æ‚åº¦è°ƒæ•´å¹¶å‘æ•°
const maxConcurrency = tasks.length <= 3 ? tasks.length : 4;
```

### 6.3 é”™è¯¯å¤„ç†ç­–ç•¥

**ä½¿ç”¨ Promise.allSettled å®ç°å®¹é”™**:

```typescript
// å®¹é”™æ¨¡å¼ï¼šå³ä½¿éƒ¨åˆ†å¤±è´¥ä¹Ÿç»§ç»­
const results = await Promise.allSettled(promises);
const successful = results.filter(r => r.status === "fulfilled");
const failed = results.filter(r => r.status === "rejected");
```

### 6.4 ç»“æœèšåˆæ¨¡å¼

**æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©èšåˆç­–ç•¥**:

```typescript
// ç­–ç•¥ 1: å…¨éƒ¨æˆåŠŸæ‰ç®—æˆåŠŸ
const allSuccess = results.every(r => r.success);

// ç­–ç•¥ 2: å¤šæ•°æˆåŠŸå³å¯
const majoritySuccess = results.filter(r => r.success).length > results.length / 2;

// ç­–ç•¥ 3: è‡³å°‘ä¸€ä¸ªæˆåŠŸ
const anySuccess = results.some(r => r.success);
```

### 6.5 æˆæœ¬ä¼˜åŒ–

æ ¹æ® [Redis çš„å»ºè®®](https://redis.io/blog/ai-agent-architecture/)ï¼š

```typescript
// ä½¿ç”¨è¯­ä¹‰ç¼“å­˜å‡å°‘é‡å¤è°ƒç”¨
// ç›‘æ§ token æ¶ˆè€—
const totalCost = results.reduce((sum, r) => sum + (r.usage?.totalCost || 0), 0);
if (totalCost > COST_THRESHOLD) {
  console.warn(`High cost detected: $${totalCost.toFixed(4)}`);
}
```

---

## 7. å¸¸è§é—®é¢˜

### Q1: å¹¶è¡Œæ‰§è¡Œ vs å•ä»£ç†æ‰§è¡Œçš„æ€§èƒ½å¯¹æ¯”ï¼Ÿ

**A**: æ ¹æ® [Redis çš„ç ”ç©¶](https://redis.io/blog/ai-agent-architecture/)ï¼Œå¹¶è¡Œæ‰§è¡Œå¯ä»¥å®ç° **3x æ›´å¿«çš„å†³ç­–é€Ÿåº¦**ã€‚ä½†å®é™…æå‡å–å†³äºï¼š

- ä»»åŠ¡ç‹¬ç«‹æ€§ï¼šå®Œå…¨ç‹¬ç«‹çš„ä»»åŠ¡å¯ä»¥è·å¾—æ¥è¿‘çº¿æ€§çš„åŠ é€Ÿ
- å¹¶å‘æ•°é‡ï¼š4-6 ä¸ªå¹¶å‘é€šå¸¸æ˜¯æœ€ä½³å¹³è¡¡ç‚¹
- API é€Ÿç‡é™åˆ¶ï¼šè¿‡å¤šå¹¶å‘å¯èƒ½è§¦å‘é™åˆ¶

**æ€§èƒ½å¯¹æ¯”ç¤ºä¾‹**:
- å•ä»£ç†é¡ºåºæ‰§è¡Œ 3 ä¸ªä»»åŠ¡ï¼š3 Ã— 30s = 90s
- å¹¶è¡Œæ‰§è¡Œ 3 ä¸ªä»»åŠ¡ï¼ˆå¹¶å‘ 3ï¼‰ï¼šmax(30s, 30s, 30s) = 30s
- åŠ é€Ÿæ¯”ï¼š3x

### Q2: å¦‚ä½•å¤„ç†å¹¶è¡Œä»£ç†çš„ä¸Šä¸‹æ–‡å†²çªï¼Ÿ

**A**: ä¸Šä¸‹æ–‡å†²çªæ˜¯å¹¶è¡Œæ‰§è¡Œçš„å¸¸è§é—®é¢˜ã€‚è§£å†³æ–¹æ¡ˆï¼š

```typescript
// æ–¹æ¡ˆ 1: ä½¿ç”¨ç‹¬ç«‹çš„ä¸Šä¸‹æ–‡
tasks.map((task, index) => ({
  ...task,
  context: {
    ...task.context,
    workspaceId: `workspace-${index}`, // ç‹¬ç«‹å·¥ä½œç©ºé—´
  },
}));

// æ–¹æ¡ˆ 2: ä½¿ç”¨é”æœºåˆ¶
const fileLocks = new Map<string, Promise<void>>();
```

### Q3: å¹¶è¡Œæ‰§è¡Œå¦‚ä½•æ§åˆ¶æˆæœ¬ï¼Ÿ

**A**: æˆæœ¬æ§åˆ¶ç­–ç•¥ï¼š

1. **é™åˆ¶å¹¶å‘æ•°**: å‡å°‘åŒæ—¶è¿è¡Œçš„ä»£ç†æ•°é‡
2. **ä½¿ç”¨è¯­ä¹‰ç¼“å­˜**: é¿å…é‡å¤è°ƒç”¨ç›¸åŒä»»åŠ¡
3. **ç›‘æ§ token æ¶ˆè€—**: å®æ—¶è¿½è¸ªæˆæœ¬å¹¶è®¾ç½®é˜ˆå€¼
4. **é€‰æ‹©åˆé€‚çš„æ¨¡å‹**: ç®€å•ä»»åŠ¡ä½¿ç”¨ Haikuï¼Œå¤æ‚ä»»åŠ¡ä½¿ç”¨ Sonnet

```typescript
// æˆæœ¬ç›‘æ§ç¤ºä¾‹
if (totalUsage.totalCost > MAX_COST_PER_EXECUTION) {
  throw new Error(`Cost limit exceeded: $${totalUsage.totalCost.toFixed(4)}`);
}
```

---

## 8. æ‰©å±•é˜…è¯»

### æ ¸å¿ƒèµ„æº

1. **[claude-flow/Ruflo v3](https://github.com/ruvnet/claude-flow)**
   - 15-agent swarm æ¶æ„å®ç°
   - Queen-led hierarchy æ¨¡å¼
   - Byzantine fault-tolerant consensus

2. **[Redis - AI Agent Architecture](https://redis.io/blog/ai-agent-architecture/)**
   - 3x æ›´å¿«å†³ç­–çš„å¹¶è¡Œæ¨¡å¼
   - ä¼ä¸šçº§æ¶æ„æœ€ä½³å®è·µ
   - æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

3. **[SWFTE - Multi-Agent AI Systems for Enterprise](https://www.swfte.com/blog/multi-agent-ai-systems-enterprise)**
   - 45% æ›´å°‘äº¤æ¥çš„ä¼˜åŒ–æŠ€æœ¯
   - ä¼ä¸šçº§éƒ¨ç½²ç»éªŒ
   - å®é™…æ€§èƒ½æ•°æ®

4. **[Reddit - Tested 5 Agent Frameworks in Production](https://www.reddit.com/r/AI_Agents/comments/1oukxzx/tested_5_agent_frameworks_in_production_heres/)**
   - ç”Ÿäº§ç¯å¢ƒæµ‹è¯•ç»“æœ
   - LangGraph vs CrewAI å¯¹æ¯”
   - å®é™…é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### ç›¸å…³çŸ¥è¯†ç‚¹

- `07_å®æˆ˜ä»£ç _01_åŸºç¡€å•ä»£ç†æ‰§è¡Œ.md` - å•ä»£ç†æ‰§è¡ŒåŸºç¡€
- `03_æ ¸å¿ƒæ¦‚å¿µ_03_æ‰§è¡Œæ¨¡å¼è¯¦è§£.md` - ä¸‰ç§æ‰§è¡Œæ¨¡å¼å¯¹æ¯”
- `07_å®æˆ˜ä»£ç _03_é“¾å¼å·¥ä½œæµå®ç°.md` - é“¾å¼æ‰§è¡Œæ¨¡å¼

---

**ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2026-02-21
**ä½œè€…**: Claude Code
**å®¡æ ¸**: åŸºäº 2025-2026 å¹´æœ€æ–°å®è·µ
