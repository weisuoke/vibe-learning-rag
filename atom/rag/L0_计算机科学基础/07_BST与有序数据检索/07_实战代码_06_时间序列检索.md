# 07_实战代码_06_时间序列检索

## 场景描述

**目标：** 实现基于BST的时间序列检索系统，支持高效的时间范围查询和异常检测

**应用场景：**
- AI Agent的日志查询
- 时间序列数据分析
- 异常检测与监控

**引用：** [Graph-based Agent Memory](https://arxiv.org/html/2602.05665v1)

---

## 完整实现

```python
"""
时间序列检索系统
基于BST实现高效的时间范围查询和异常检测
"""

import time
from typing import Optional, List, Dict, Any, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import statistics


@dataclass
class TimeSeriesPoint:
    """时间序列数据点"""
    timestamp: float
    value: float
    metadata: Dict[str, Any] = None

    def __lt__(self, other):
        return self.timestamp < other.timestamp


class TimeSeriesIndex:
    """时间序列索引"""

    def __init__(self):
        self.points: List[TimeSeriesPoint] = []

    def add_point(self, timestamp: float, value: float, metadata: Dict = None) -> None:
        """添加数据点"""
        point = TimeSeriesPoint(timestamp, value, metadata or {})
        # 二分插入保持有序
        left, right = 0, len(self.points)
        while left < right:
            mid = (left + right) // 2
            if self.points[mid].timestamp < timestamp:
                left = mid + 1
            else:
                right = mid
        self.points.insert(left, point)

    def range_query(self, start: float, end: float) -> List[TimeSeriesPoint]:
        """范围查询"""
        left = self._lower_bound(start)
        right = self._upper_bound(end)
        return self.points[left:right]

    def _lower_bound(self, target: float) -> int:
        """找到第一个 >= target 的位置"""
        left, right = 0, len(self.points)
        while left < right:
            mid = (left + right) // 2
            if self.points[mid].timestamp < target:
                left = mid + 1
            else:
                right = mid
        return left

    def _upper_bound(self, target: float) -> int:
        """找到第一个 > target 的位置"""
        left, right = 0, len(self.points)
        while left < right:
            mid = (left + right) // 2
            if self.points[mid].timestamp <= target:
                left = mid + 1
            else:
                right = mid
        return left

    def get_recent(self, seconds: int = 3600) -> List[TimeSeriesPoint]:
        """获取最近N秒的数据"""
        now = time.time()
        start = now - seconds
        return self.range_query(start, now)

    def sliding_window(self, window_size: int = 60) -> List[Tuple[float, List[TimeSeriesPoint]]]:
        """滑动窗口查询"""
        if not self.points:
            return []

        windows = []
        start_time = self.points[0].timestamp
        end_time = self.points[-1].timestamp

        current = start_time
        while current <= end_time:
            window_end = current + window_size
            window_points = self.range_query(current, window_end)
            if window_points:
                windows.append((current, window_points))
            current += window_size

        return windows

    def detect_anomalies(self, threshold: float = 2.0) -> List[TimeSeriesPoint]:
        """检测异常值（基于标准差）"""
        if len(self.points) < 3:
            return []

        values = [p.value for p in self.points]
        mean = statistics.mean(values)
        stdev = statistics.stdev(values)

        anomalies = []
        for point in self.points:
            z_score = abs((point.value - mean) / stdev) if stdev > 0 else 0
            if z_score > threshold:
                anomalies.append(point)

        return anomalies


# ==================== AI Agent应用 ====================

class AgentPerformanceMonitor:
    """AI Agent性能监控"""

    def __init__(self):
        self.response_times = TimeSeriesIndex()
        self.error_counts = TimeSeriesIndex()
        self.token_usage = TimeSeriesIndex()

    def log_request(self, response_time: float, tokens: int, error: bool = False) -> None:
        """记录请求"""
        timestamp = time.time()
        self.response_times.add_point(timestamp, response_time)
        self.token_usage.add_point(timestamp, tokens)
        if error:
            self.error_counts.add_point(timestamp, 1)

    def get_performance_summary(self, minutes: int = 60) -> Dict[str, Any]:
        """获取性能摘要"""
        recent_times = self.response_times.get_recent(minutes * 60)
        recent_tokens = self.token_usage.get_recent(minutes * 60)
        recent_errors = self.error_counts.get_recent(minutes * 60)

        if not recent_times:
            return {"status": "no_data"}

        times = [p.value for p in recent_times]
        tokens = [p.value for p in recent_tokens]

        return {
            "time_range": f"Last {minutes} minutes",
            "request_count": len(recent_times),
            "avg_response_time": statistics.mean(times),
            "max_response_time": max(times),
            "total_tokens": sum(tokens),
            "error_count": len(recent_errors),
            "error_rate": len(recent_errors) / len(recent_times) if recent_times else 0
        }

    def detect_performance_issues(self) -> List[str]:
        """检测性能问题"""
        issues = []

        # 检测响应时间异常
        anomalies = self.response_times.detect_anomalies(threshold=2.0)
        if anomalies:
            issues.append(f"检测到{len(anomalies)}个响应时间异常")

        # 检测错误率
        recent_errors = self.error_counts.get_recent(3600)
        if len(recent_errors) > 10:
            issues.append(f"最近1小时错误次数过多: {len(recent_errors)}")

        return issues


# ==================== 测试代码 ====================

def test_time_series():
    """测试时间序列检索"""
    print("=" * 60)
    print("时间序列检索系统测试")
    print("=" * 60)

    monitor = AgentPerformanceMonitor()

    # 模拟请求数据
    print("\n1. 模拟AI Agent请求:")
    base_time = time.time()

    # 正常请求
    for i in range(50):
        response_time = 0.5 + (i % 10) * 0.1
        tokens = 100 + (i % 20) * 10
        monitor.log_request(response_time, tokens)
        time.sleep(0.01)

    # 异常请求
    monitor.log_request(5.0, 500)  # 响应时间异常
    monitor.log_request(0.5, 100, error=True)  # 错误

    print(f"   记录了{len(monitor.response_times.points)}个请求")

    # 性能摘要
    print("\n2. 性能摘要:")
    summary = monitor.get_performance_summary(minutes=1)
    for key, value in summary.items():
        if isinstance(value, float):
            print(f"   {key}: {value:.3f}")
        else:
            print(f"   {key}: {value}")

    # 检测问题
    print("\n3. 性能问题检测:")
    issues = monitor.detect_performance_issues()
    if issues:
        for issue in issues:
            print(f"   ⚠️  {issue}")
    else:
        print("   ✅ 未检测到性能问题")

    # 滑动窗口分析
    print("\n4. 滑动窗口分析（10秒窗口）:")
    windows = monitor.response_times.sliding_window(window_size=10)
    for i, (start_time, points) in enumerate(windows[:3]):
        if points:
            avg_time = statistics.mean([p.value for p in points])
            print(f"   窗口{i+1}: {len(points)}个请求, 平均响应时间={avg_time:.3f}秒")


if __name__ == "__main__":
    test_time_series()
```

---

## 关键知识点

### 1. 滑动窗口

```python
def sliding_window(self, window_size: int = 60):
    """滑动窗口查询"""
    current = start_time
    while current <= end_time:
        window_end = current + window_size
        window_points = self.range_query(current, window_end)
        windows.append((current, window_points))
        current += window_size
```

### 2. 异常检测

```python
def detect_anomalies(self, threshold: float = 2.0):
    """基于Z-score的异常检测"""
    z_score = abs((value - mean) / stdev)
    if z_score > threshold:
        anomalies.append(point)
```

---

## 学习检查清单

- [ ] 理解时间序列索引的原理
- [ ] 掌握滑动窗口查询的实现
- [ ] 能实现基于统计的异常检测
- [ ] 能应用到AI Agent的性能监控

---

**记住：** 时间序列检索是BST在监控和分析领域的重要应用，掌握范围查询和滑动窗口是关键。
