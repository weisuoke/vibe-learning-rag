# 核心概念1：异常分层与分类

**异常分层是通过继承关系构建异常类体系，区分业务异常和系统异常，为不同类型的错误提供不同的处理策略。**

---

## 为什么需要异常分层？

**问题：** 所有错误都用 `Exception` 或 `HTTPException`，无法区分错误类型

```python
# ❌ 没有异常分层
@app.post("/chat")
async def chat(message: str):
    if len(message) > 2000:
        raise HTTPException(status_code=422, detail="文本过长")

    try:
        response = await call_llm(message)
        return {"response": response}
    except Exception as e:
        # 所有错误都返回 500，无法区分
        raise HTTPException(status_code=500, detail="服务器错误")
```

**问题：**
- 无法区分用户输入错误（422）和系统错误（500）
- 无法判断是否应该重试
- 无法提供针对性的错误处理

**解决方案：** 异常分层

```python
# ✅ 有异常分层
class AppError(Exception):
    """应用基础异常"""
    pass

class BusinessError(AppError):
    """业务异常：用户可以修正"""
    pass

class SystemError(AppError):
    """系统异常：需要开发者介入"""
    pass

class TextTooLongError(BusinessError):
    """文本过长"""
    pass

class LLMTimeoutError(SystemError):
    """LLM 超时"""
    pass

@app.post("/chat")
async def chat(message: str):
    if len(message) > 2000:
        raise TextTooLongError("文本过长")  # 业务异常

    try:
        response = await call_llm(message)
        return {"response": response}
    except Timeout:
        raise LLMTimeoutError("LLM 超时")  # 系统异常
```

---

## 异常分层的设计原则

### 1. 按照错误来源分层

**第一层：应用基础异常**
```python
class AppError(Exception):
    """应用基础异常（所有自定义异常的基类）"""
    def __init__(self, message: str, error_code: str = None):
        self.message = message
        self.error_code = error_code
        super().__init__(message)
```

**第二层：错误类型分类**
```python
class BusinessError(AppError):
    """业务异常：用户输入错误、资源不存在等"""
    pass

class SystemError(AppError):
    """系统异常：数据库连接失败、LLM 超时等"""
    pass

class ExternalError(AppError):
    """外部服务异常：第三方 API 失败"""
    pass
```

**第三层：具体异常**
```python
# 业务异常
class ValidationError(BusinessError):
    """参数验证失败"""
    pass

class ResourceNotFoundError(BusinessError):
    """资源不存在"""
    pass

class PermissionDeniedError(BusinessError):
    """权限不足"""
    pass

# 系统异常
class DatabaseError(SystemError):
    """数据库错误"""
    pass

class CacheError(SystemError):
    """缓存错误"""
    pass

# 外部服务异常
class LLMError(ExternalError):
    """LLM 服务错误"""
    pass

class VectorDBError(ExternalError):
    """向量数据库错误"""
    pass
```

---

### 2. 按照是否可重试分类

```python
class RetryableError(AppError):
    """可重试的错误（临时性错误）"""
    pass

class NonRetryableError(AppError):
    """不可重试的错误（永久性错误）"""
    pass

# 具体异常
class RateLimitError(RetryableError):
    """Rate Limit（可重试）"""
    pass

class TimeoutError(RetryableError):
    """超时（可重试）"""
    pass

class InvalidInputError(NonRetryableError):
    """无效输入（不可重试）"""
    pass

class AuthenticationError(NonRetryableError):
    """认证失败（不可重试）"""
    pass
```

---

### 3. 携带错误上下文信息

```python
class AppError(Exception):
    """应用基础异常（带上下文）"""
    def __init__(
        self,
        message: str,
        error_code: str = None,
        status_code: int = 500,
        details: dict = None
    ):
        self.message = message
        self.error_code = error_code
        self.status_code = status_code
        self.details = details or {}
        super().__init__(message)

# 使用示例
class TextTooLongError(BusinessError):
    """文本过长"""
    def __init__(self, max_length: int, actual_length: int):
        super().__init__(
            message=f"输入文本过长（{actual_length} > {max_length}）",
            error_code="TEXT_TOO_LONG",
            status_code=422,
            details={
                "max_length": max_length,
                "actual_length": actual_length
            }
        )
```

---

## 完整的异常体系设计

```python
"""
完整的异常体系设计
适用于 AI Agent API
"""

from typing import Optional, Dict, Any

# ===== 第一层：基础异常 =====
class AppError(Exception):
    """应用基础异常"""
    def __init__(
        self,
        message: str,
        error_code: Optional[str] = None,
        status_code: int = 500,
        details: Optional[Dict[str, Any]] = None
    ):
        self.message = message
        self.error_code = error_code or self.__class__.__name__
        self.status_code = status_code
        self.details = details or {}
        super().__init__(message)

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典（用于 JSON 响应）"""
        return {
            "error": self.message,
            "error_code": self.error_code,
            "details": self.details
        }

# ===== 第二层：错误类型分类 =====
class BusinessError(AppError):
    """业务异常：用户可以修正"""
    def __init__(self, message: str, error_code: str = None, details: dict = None):
        super().__init__(
            message=message,
            error_code=error_code,
            status_code=422,  # Unprocessable Entity
            details=details
        )

class SystemError(AppError):
    """系统异常：需要开发者介入"""
    def __init__(self, message: str, error_code: str = None, details: dict = None):
        super().__init__(
            message=message,
            error_code=error_code,
            status_code=500,  # Internal Server Error
            details=details
        )

class ExternalError(AppError):
    """外部服务异常"""
    def __init__(self, message: str, error_code: str = None, details: dict = None):
        super().__init__(
            message=message,
            error_code=error_code,
            status_code=503,  # Service Unavailable
            details=details
        )

# ===== 第三层：具体业务异常 =====
class ValidationError(BusinessError):
    """参数验证失败"""
    def __init__(self, field: str, message: str):
        super().__init__(
            message=f"参数验证失败: {field} - {message}",
            error_code="VALIDATION_ERROR",
            details={"field": field, "message": message}
        )

class TextTooLongError(BusinessError):
    """文本过长"""
    def __init__(self, max_length: int, actual_length: int):
        super().__init__(
            message=f"输入文本过长，请缩短至 {max_length} 字以内",
            error_code="TEXT_TOO_LONG",
            details={
                "max_length": max_length,
                "actual_length": actual_length
            }
        )

class ResourceNotFoundError(BusinessError):
    """资源不存在"""
    def __init__(self, resource_type: str, resource_id: str):
        super().__init__(
            message=f"{resource_type} 不存在: {resource_id}",
            error_code="RESOURCE_NOT_FOUND",
            details={
                "resource_type": resource_type,
                "resource_id": resource_id
            }
        )
        self.status_code = 404  # Not Found

class PermissionDeniedError(BusinessError):
    """权限不足"""
    def __init__(self, action: str, resource: str):
        super().__init__(
            message=f"权限不足: 无法执行 {action} 操作",
            error_code="PERMISSION_DENIED",
            details={
                "action": action,
                "resource": resource
            }
        )
        self.status_code = 403  # Forbidden

# ===== 第三层：具体系统异常 =====
class DatabaseError(SystemError):
    """数据库错误"""
    def __init__(self, operation: str, error: str):
        super().__init__(
            message=f"数据库操作失败: {operation}",
            error_code="DATABASE_ERROR",
            details={
                "operation": operation,
                "error": error
            }
        )

class CacheError(SystemError):
    """缓存错误"""
    def __init__(self, operation: str, error: str):
        super().__init__(
            message=f"缓存操作失败: {operation}",
            error_code="CACHE_ERROR",
            details={
                "operation": operation,
                "error": error
            }
        )

# ===== 第三层：具体外部服务异常 =====
class LLMError(ExternalError):
    """LLM 服务错误"""
    def __init__(self, provider: str, error: str):
        super().__init__(
            message=f"LLM 服务暂时不可用: {provider}",
            error_code="LLM_ERROR",
            details={
                "provider": provider,
                "error": error
            }
        )

class LLMTimeoutError(LLMError):
    """LLM 超时"""
    def __init__(self, provider: str, timeout: float):
        super().__init__(
            provider=provider,
            error=f"请求超时（{timeout}s）"
        )
        self.error_code = "LLM_TIMEOUT"

class LLMRateLimitError(LLMError):
    """LLM Rate Limit"""
    def __init__(self, provider: str, retry_after: int = None):
        super().__init__(
            provider=provider,
            error="请求频率过高"
        )
        self.error_code = "LLM_RATE_LIMIT"
        self.status_code = 429  # Too Many Requests
        if retry_after:
            self.details["retry_after"] = retry_after

class VectorDBError(ExternalError):
    """向量数据库错误"""
    def __init__(self, operation: str, error: str):
        super().__init__(
            message=f"向量数据库操作失败: {operation}",
            error_code="VECTOR_DB_ERROR",
            details={
                "operation": operation,
                "error": error
            }
        )

# ===== 可重试标记 =====
class RetryableError(AppError):
    """可重试的错误（临时性错误）"""
    pass

class NonRetryableError(AppError):
    """不可重试的错误（永久性错误）"""
    pass

# 标记可重试的异常
LLMTimeoutError.__bases__ = (LLMError, RetryableError)
LLMRateLimitError.__bases__ = (LLMError, RetryableError)
DatabaseError.__bases__ = (SystemError, RetryableError)

# 标记不可重试的异常
ValidationError.__bases__ = (BusinessError, NonRetryableError)
ResourceNotFoundError.__bases__ = (BusinessError, NonRetryableError)
PermissionDeniedError.__bases__ = (BusinessError, NonRetryableError)
```

---

## 在 FastAPI 中使用异常分层

### 1. 注册异常处理器

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import structlog

app = FastAPI()
logger = structlog.get_logger()

# ===== 业务异常处理器 =====
@app.exception_handler(BusinessError)
async def business_error_handler(request: Request, exc: BusinessError):
    """业务异常：返回 422，用户可以修正"""
    logger.warning(
        "business_error",
        error_code=exc.error_code,
        message=exc.message,
        path=request.url.path,
        details=exc.details
    )
    return JSONResponse(
        status_code=exc.status_code,
        content=exc.to_dict()
    )

# ===== 系统异常处理器 =====
@app.exception_handler(SystemError)
async def system_error_handler(request: Request, exc: SystemError):
    """系统异常：返回 500，记录详细日志"""
    logger.error(
        "system_error",
        error_code=exc.error_code,
        message=exc.message,
        path=request.url.path,
        details=exc.details
    )
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": "服务暂时不可用，请稍后重试",
            "error_code": exc.error_code
        }
    )

# ===== 外部服务异常处理器 =====
@app.exception_handler(ExternalError)
async def external_error_handler(request: Request, exc: ExternalError):
    """外部服务异常：返回 503"""
    logger.error(
        "external_error",
        error_code=exc.error_code,
        message=exc.message,
        path=request.url.path,
        details=exc.details
    )
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": exc.message,
            "error_code": exc.error_code
        }
    )

# ===== 全局异常处理器 =====
@app.exception_handler(Exception)
async def global_error_handler(request: Request, exc: Exception):
    """全局异常处理器：捕获所有未处理的异常"""
    logger.error(
        "unhandled_exception",
        error_type=type(exc).__name__,
        error_message=str(exc),
        path=request.url.path
    )
    return JSONResponse(
        status_code=500,
        content={
            "error": "服务器内部错误",
            "error_code": "INTERNAL_ERROR"
        }
    )
```

---

### 2. 在 API 端点中使用

```python
@app.post("/chat")
async def chat(message: str):
    """聊天端点"""
    # 业务校验
    if len(message) > 2000:
        raise TextTooLongError(max_length=2000, actual_length=len(message))

    if not message.strip():
        raise ValidationError(field="message", message="消息不能为空")

    # 调用 LLM
    try:
        response = await call_llm(message)
        return {"response": response}
    except Timeout:
        raise LLMTimeoutError(provider="OpenAI", timeout=30.0)
    except RateLimitExceeded:
        raise LLMRateLimitError(provider="OpenAI", retry_after=60)

@app.get("/conversations/{conversation_id}")
async def get_conversation(conversation_id: str):
    """获取对话"""
    conversation = await db.get_conversation(conversation_id)
    if conversation is None:
        raise ResourceNotFoundError(
            resource_type="Conversation",
            resource_id=conversation_id
        )
    return conversation
```

---

## 判断是否应该重试

```python
def should_retry(error: Exception) -> bool:
    """判断是否应该重试"""
    # 明确标记的错误
    if isinstance(error, RetryableError):
        return True
    if isinstance(error, NonRetryableError):
        return False

    # 根据 HTTP 状态码判断
    if hasattr(error, 'status_code'):
        # 可重试：429（Rate Limit）、500（服务器错误）、503（服务不可用）、504（网关超时）
        return error.status_code in [429, 500, 502, 503, 504]

    return False

# 使用示例
from tenacity import retry, retry_if_exception

@retry(
    stop=stop_after_attempt(3),
    retry=retry_if_exception(should_retry)
)
async def call_llm_with_retry(prompt: str):
    """调用 LLM（自动重试）"""
    try:
        return await call_llm(prompt)
    except Timeout:
        raise LLMTimeoutError(provider="OpenAI", timeout=30.0)  # 可重试
    except InvalidRequest:
        raise ValidationError(field="prompt", message="无效的提示词")  # 不可重试
```

---

## 在 AI Agent API 中的应用

### 场景1：用户输入验证

```python
@app.post("/chat")
async def chat(message: str, user_id: str):
    # 验证消息长度
    if len(message) > 2000:
        raise TextTooLongError(max_length=2000, actual_length=len(message))

    # 验证用户权限
    user = await db.get_user(user_id)
    if not user:
        raise ResourceNotFoundError(resource_type="User", resource_id=user_id)

    if not user.has_permission("chat"):
        raise PermissionDeniedError(action="chat", resource="AI Agent")

    # 调用 LLM
    response = await call_llm(message)
    return {"response": response}
```

### 场景2：LLM 调用错误处理

```python
async def call_llm(prompt: str) -> str:
    """调用 LLM（带错误处理）"""
    try:
        response = await openai.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}]
        )
        return response.choices[0].message.content
    except openai.Timeout:
        raise LLMTimeoutError(provider="OpenAI", timeout=30.0)
    except openai.RateLimitError as e:
        retry_after = int(e.response.headers.get("Retry-After", 60))
        raise LLMRateLimitError(provider="OpenAI", retry_after=retry_after)
    except openai.APIError as e:
        raise LLMError(provider="OpenAI", error=str(e))
```

### 场景3：数据库错误处理

```python
async def save_conversation(conversation: dict):
    """保存对话（带错误处理）"""
    try:
        async with db.session() as session:
            session.add(Conversation(**conversation))
            await session.commit()
    except sqlalchemy.exc.IntegrityError as e:
        raise DatabaseError(operation="save_conversation", error="数据完整性错误")
    except sqlalchemy.exc.OperationalError as e:
        raise DatabaseError(operation="save_conversation", error="数据库连接失败")
```

---

## 总结

**异常分层的核心价值：**
1. **区分错误类型**：业务异常 vs 系统异常 vs 外部服务异常
2. **针对性处理**：不同类型的错误返回不同的 HTTP 状态码
3. **可重试判断**：明确哪些错误可以重试，哪些不可以
4. **错误上下文**：携带详细的错误信息，方便调试
5. **统一响应格式**：所有错误都转换为统一的 JSON 响应

**设计原则：**
- 按照错误来源分层（业务、系统、外部）
- 按照是否可重试分类（RetryableError、NonRetryableError）
- 携带错误上下文信息（error_code、details）
- 提供统一的错误响应格式（to_dict）

**在 AI Agent API 中的应用：**
- 用户输入验证 → BusinessError
- LLM 调用失败 → ExternalError
- 数据库错误 → SystemError
- 统一异常处理器 → 返回用户友好的错误响应
