# 核心概念7：代码仓库加载

> 掌握从GitHub和本地代码仓库加载文档和代码的方法

---

## 为什么代码仓库加载重要？

代码仓库（GitHub、GitLab、本地Git仓库）包含大量技术文档和代码：
- **README.md**：项目介绍和使用说明
- **文档目录**：详细的技术文档
- **代码文件**：实际的代码实现
- **Issue和PR**：问题讨论和解决方案

**在RAG系统中，加载代码仓库能够构建技术知识库和代码问答系统。**

---

## 1. GitHub仓库加载

### 1.1 使用LangChain的GitHubLoader

```python
"""
LangChain GitHubLoader基础使用
适用场景：从GitHub仓库加载文档
"""

from langchain.document_loaders import GithubFileLoader

# 加载GitHub仓库的特定文件
loader = GithubFileLoader(
    repo="langchain-ai/langchain",  # 仓库名
    access_token="your_github_token",  # GitHub访问令牌
    github_api_url="https://api.github.com",
    file_filter=lambda file_path: file_path.endswith(".md")  # 只加载Markdown文件
)

docs = loader.load()
print(f"加载了 {len(docs)} 个文档")

# 查看文档内容
for doc in docs[:3]:
    print(f"\n文件: {doc.metadata['source']}")
    print(f"内容: {doc.page_content[:200]}...")
```

### 1.2 加载整个仓库

```python
from langchain.document_loaders import GitLoader

# 克隆并加载整个仓库
loader = GitLoader(
    clone_url="https://github.com/langchain-ai/langchain",
    repo_path="./temp/langchain",  # 本地克隆路径
    branch="master",
    file_filter=lambda file_path: file_path.endswith((".md", ".py"))
)

docs = loader.load()
print(f"加载了 {len(docs)} 个文件")
```

### 1.3 自定义GitHub加载器

```python
"""
自定义GitHub加载器
支持更灵活的文件过滤和元数据提取
"""

import os
import requests
from typing import List
from langchain.schema import Document

class CustomGitHubLoader:
    """自定义GitHub仓库加载器"""

    def __init__(
        self,
        repo: str,
        branch: str = "main",
        access_token: str = None,
        file_extensions: List[str] = None
    ):
        self.repo = repo
        self.branch = branch
        self.access_token = access_token
        self.file_extensions = file_extensions or [".md", ".py", ".js", ".ts"]

        self.api_url = f"https://api.github.com/repos/{repo}"
        self.headers = {}
        if access_token:
            self.headers["Authorization"] = f"token {access_token}"

    def load(self) -> List[Document]:
        """加载仓库文档"""
        documents = []

        # 1. 获取仓库树
        tree_url = f"{self.api_url}/git/trees/{self.branch}?recursive=1"
        response = requests.get(tree_url, headers=self.headers)
        response.raise_for_status()

        tree = response.json()

        # 2. 过滤文件
        files = [
            item for item in tree.get("tree", [])
            if item["type"] == "blob" and
            any(item["path"].endswith(ext) for ext in self.file_extensions)
        ]

        print(f"找到 {len(files)} 个匹配的文件")

        # 3. 加载每个文件
        for file_info in files[:50]:  # 限制数量避免API限制
            try:
                doc = self._load_file(file_info["path"])
                if doc:
                    documents.append(doc)
                    print(f"✅ 加载: {file_info['path']}")
            except Exception as e:
                print(f"❌ 失败: {file_info['path']} - {e}")

        return documents

    def _load_file(self, file_path: str) -> Document:
        """加载单个文件"""
        # 获取文件内容
        content_url = f"{self.api_url}/contents/{file_path}?ref={self.branch}"
        response = requests.get(content_url, headers=self.headers)
        response.raise_for_status()

        file_data = response.json()

        # 解码内容（GitHub API返回base64编码）
        import base64
        content = base64.b64decode(file_data["content"]).decode("utf-8")

        # 创建Document
        return Document(
            page_content=content,
            metadata={
                "source": f"github:{self.repo}/{file_path}",
                "repo": self.repo,
                "branch": self.branch,
                "file_path": file_path,
                "file_type": os.path.splitext(file_path)[1],
                "url": file_data["html_url"]
            }
        )

# 使用示例
loader = CustomGitHubLoader(
    repo="langchain-ai/langchain",
    branch="master",
    access_token=os.getenv("GITHUB_TOKEN"),
    file_extensions=[".md"]
)

docs = loader.load()
print(f"\n总共加载 {len(docs)} 个文档")
```

---

## 2. 本地Git仓库加载

### 2.1 使用GitPython

```python
"""
使用GitPython加载本地Git仓库
适用场景：加载本地代码仓库的文档和代码
"""

import git
import os
from typing import List
from langchain.schema import Document

class LocalGitRepoLoader:
    """本地Git仓库加载器"""

    def __init__(
        self,
        repo_path: str,
        file_extensions: List[str] = None,
        exclude_dirs: List[str] = None
    ):
        self.repo_path = repo_path
        self.file_extensions = file_extensions or [".md", ".py", ".js", ".ts"]
        self.exclude_dirs = exclude_dirs or [
            ".git", "node_modules", "__pycache__", ".venv", "venv"
        ]

        # 打开Git仓库
        try:
            self.repo = git.Repo(repo_path)
        except git.InvalidGitRepositoryError:
            raise ValueError(f"{repo_path} 不是有效的Git仓库")

    def load(self) -> List[Document]:
        """加载仓库文档"""
        documents = []

        # 遍历仓库文件
        for root, dirs, files in os.walk(self.repo_path):
            # 排除特定目录
            dirs[:] = [d for d in dirs if d not in self.exclude_dirs]

            for file in files:
                # 检查文件扩展名
                if not any(file.endswith(ext) for ext in self.file_extensions):
                    continue

                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, self.repo_path)

                try:
                    doc = self._load_file(file_path, relative_path)
                    if doc:
                        documents.append(doc)
                        print(f"✅ 加载: {relative_path}")
                except Exception as e:
                    print(f"❌ 失败: {relative_path} - {e}")

        return documents

    def _load_file(self, file_path: str, relative_path: str) -> Document:
        """加载单个文件"""
        # 读取文件内容
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # 获取Git信息
        try:
            # 最后修改时间
            commits = list(self.repo.iter_commits(paths=relative_path, max_count=1))
            if commits:
                last_commit = commits[0]
                last_modified = last_commit.committed_datetime.isoformat()
                last_author = last_commit.author.name
            else:
                last_modified = None
                last_author = None
        except:
            last_modified = None
            last_author = None

        # 创建Document
        return Document(
            page_content=content,
            metadata={
                "source": file_path,
                "relative_path": relative_path,
                "file_type": os.path.splitext(file_path)[1],
                "repo_path": self.repo_path,
                "last_modified": last_modified,
                "last_author": last_author,
                "current_branch": self.repo.active_branch.name
            }
        )

# 使用示例
loader = LocalGitRepoLoader(
    repo_path="/path/to/your/repo",
    file_extensions=[".md", ".py"],
    exclude_dirs=[".git", "node_modules", "__pycache__"]
)

docs = loader.load()
print(f"\n总共加载 {len(docs)} 个文档")
```

### 2.2 加载特定分支或提交

```python
class AdvancedGitRepoLoader(LocalGitRepoLoader):
    """高级Git仓库加载器：支持特定分支和提交"""

    def load_from_commit(self, commit_sha: str) -> List[Document]:
        """从特定提交加载文档"""
        commit = self.repo.commit(commit_sha)
        documents = []

        # 遍历提交中的文件
        for item in commit.tree.traverse():
            if item.type != 'blob':  # 只处理文件
                continue

            # 检查文件扩展名
            if not any(item.path.endswith(ext) for ext in self.file_extensions):
                continue

            try:
                # 读取文件内容
                content = item.data_stream.read().decode('utf-8')

                # 创建Document
                doc = Document(
                    page_content=content,
                    metadata={
                        "source": item.path,
                        "file_type": os.path.splitext(item.path)[1],
                        "commit_sha": commit_sha,
                        "commit_message": commit.message,
                        "commit_author": commit.author.name,
                        "commit_date": commit.committed_datetime.isoformat()
                    }
                )
                documents.append(doc)
                print(f"✅ 加载: {item.path}")
            except Exception as e:
                print(f"❌ 失败: {item.path} - {e}")

        return documents

    def load_from_branch(self, branch_name: str) -> List[Document]:
        """从特定分支加载文档"""
        # 切换到指定分支
        self.repo.git.checkout(branch_name)

        # 加载文档
        docs = self.load()

        # 切换回原分支
        self.repo.git.checkout('-')

        return docs

# 使用示例
loader = AdvancedGitRepoLoader(repo_path="/path/to/repo")

# 从特定提交加载
docs = loader.load_from_commit("abc123")

# 从特定分支加载
docs = loader.load_from_branch("develop")
```

---

## 3. 代码文件解析

### 3.1 Python代码解析

```python
"""
Python代码解析
提取函数、类、文档字符串
"""

import ast
from typing import List
from langchain.schema import Document

class PythonCodeParser:
    """Python代码解析器"""

    def parse_file(self, file_path: str) -> List[Document]:
        """解析Python文件"""
        with open(file_path, 'r', encoding='utf-8') as f:
            code = f.read()

        # 解析AST
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            print(f"语法错误: {file_path} - {e}")
            return []

        documents = []

        # 提取函数和类
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                doc = self._parse_function(node, file_path)
                if doc:
                    documents.append(doc)
            elif isinstance(node, ast.ClassDef):
                doc = self._parse_class(node, file_path)
                if doc:
                    documents.append(doc)

        return documents

    def _parse_function(self, node: ast.FunctionDef, file_path: str) -> Document:
        """解析函数"""
        # 提取文档字符串
        docstring = ast.get_docstring(node) or ""

        # 提取函数签名
        args = [arg.arg for arg in node.args.args]
        signature = f"def {node.name}({', '.join(args)})"

        # 组合内容
        content = f"{signature}\n\n{docstring}"

        return Document(
            page_content=content,
            metadata={
                "source": file_path,
                "type": "function",
                "name": node.name,
                "line_number": node.lineno,
                "signature": signature
            }
        )

    def _parse_class(self, node: ast.ClassDef, file_path: str) -> Document:
        """解析类"""
        # 提取文档字符串
        docstring = ast.get_docstring(node) or ""

        # 提取方法
        methods = [
            n.name for n in node.body
            if isinstance(n, ast.FunctionDef)
        ]

        # 组合内容
        content = f"class {node.name}\n\n{docstring}\n\n方法: {', '.join(methods)}"

        return Document(
            page_content=content,
            metadata={
                "source": file_path,
                "type": "class",
                "name": node.name,
                "line_number": node.lineno,
                "methods": methods
            }
        )

# 使用示例
parser = PythonCodeParser()
docs = parser.parse_file("example.py")

for doc in docs:
    print(f"\n{doc.metadata['type']}: {doc.metadata['name']}")
    print(f"内容: {doc.page_content[:200]}...")
```

### 3.2 使用tree-sitter解析多语言代码

```python
"""
使用tree-sitter解析多语言代码
支持Python、JavaScript、TypeScript等
"""

# 注意：需要安装 tree-sitter 和对应语言的解析器
# pip install tree-sitter tree-sitter-languages

from tree_sitter_languages import get_language, get_parser
from langchain.schema import Document

class MultiLanguageCodeParser:
    """多语言代码解析器"""

    def __init__(self, language: str):
        """
        初始化解析器
        language: 'python', 'javascript', 'typescript', 'go', 'rust', etc.
        """
        self.language = language
        self.parser = get_parser(language)

    def parse_file(self, file_path: str) -> List[Document]:
        """解析代码文件"""
        with open(file_path, 'rb') as f:
            code = f.read()

        # 解析代码
        tree = self.parser.parse(code)

        documents = []

        # 提取函数定义
        query = get_language(self.language).query("""
            (function_definition) @function
        """)

        captures = query.captures(tree.root_node)

        for node, _ in captures:
            # 提取函数代码
            function_code = code[node.start_byte:node.end_byte].decode('utf-8')

            # 创建Document
            doc = Document(
                page_content=function_code,
                metadata={
                    "source": file_path,
                    "language": self.language,
                    "type": "function",
                    "start_line": node.start_point[0],
                    "end_line": node.end_point[0]
                }
            )
            documents.append(doc)

        return documents

# 使用示例
# parser = MultiLanguageCodeParser('python')
# docs = parser.parse_file("example.py")
```

---

## 4. 在RAG中的应用

### 4.1 构建代码问答系统

```python
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.vectorstores import Chroma
from langchain.embeddings import OpenAIEmbeddings
from langchain.chains import RetrievalQA
from langchain.llms import OpenAI

# 1. 加载代码仓库
loader = LocalGitRepoLoader(
    repo_path="/path/to/your/repo",
    file_extensions=[".md", ".py"]
)
documents = loader.load()

# 2. 分块
splitter = RecursiveCharacterTextSplitter(
    chunk_size=1000,
    chunk_overlap=200
)
chunks = splitter.split_documents(documents)

# 3. 向量化并存储
embeddings = OpenAIEmbeddings()
vectorstore = Chroma.from_documents(
    chunks,
    embeddings,
    persist_directory="./code_kb"
)

# 4. 构建QA链
qa_chain = RetrievalQA.from_chain_type(
    llm=OpenAI(),
    retriever=vectorstore.as_retriever(),
    return_source_documents=True
)

# 5. 查询
result = qa_chain({"query": "如何实现用户认证？"})

print(f"答案: {result['result']}\n")
print("相关代码:")
for doc in result['source_documents']:
    print(f"- {doc.metadata['source']} (行 {doc.metadata.get('line_number', '?')})")
```

### 4.2 代码搜索和推荐

```python
def search_code(query: str, vectorstore, k: int = 5):
    """搜索相关代码"""
    # 检索相关文档
    results = vectorstore.similarity_search(query, k=k)

    print(f"找到 {len(results)} 个相关代码片段:\n")

    for i, doc in enumerate(results, 1):
        print(f"{i}. {doc.metadata['source']}")
        print(f"   类型: {doc.metadata.get('type', 'unknown')}")
        print(f"   内容: {doc.page_content[:200]}...")
        print()

# 使用示例
search_code("数据库连接", vectorstore)
```

---

## 5. 最佳实践

### 5.1 文件过滤策略

```python
# 推荐的文件过滤配置
FILE_EXTENSIONS = {
    "文档": [".md", ".rst", ".txt"],
    "Python": [".py"],
    "JavaScript": [".js", ".jsx", ".ts", ".tsx"],
    "配置": [".json", ".yaml", ".yml", ".toml"],
    "其他": [".go", ".rs", ".java", ".cpp"]
}

EXCLUDE_DIRS = [
    ".git",
    "node_modules",
    "__pycache__",
    ".venv",
    "venv",
    "dist",
    "build",
    ".next",
    "target"
]

EXCLUDE_FILES = [
    "package-lock.json",
    "yarn.lock",
    "poetry.lock"
]
```

### 5.2 增量更新策略

```python
class IncrementalGitLoader:
    """增量Git仓库加载器"""

    def __init__(self, repo_path: str, last_commit_sha: str = None):
        self.repo_path = repo_path
        self.repo = git.Repo(repo_path)
        self.last_commit_sha = last_commit_sha

    def load_changes(self) -> List[Document]:
        """只加载自上次以来的变更"""
        if not self.last_commit_sha:
            # 首次加载，加载所有文件
            return self.load_all()

        # 获取变更的文件
        changed_files = self._get_changed_files()

        documents = []
        for file_path in changed_files:
            try:
                doc = self._load_file(file_path)
                if doc:
                    documents.append(doc)
            except Exception as e:
                print(f"加载失败: {file_path} - {e}")

        return documents

    def _get_changed_files(self) -> List[str]:
        """获取变更的文件列表"""
        # 获取两个提交之间的差异
        diff = self.repo.git.diff(
            self.last_commit_sha,
            self.repo.head.commit.hexsha,
            name_only=True
        )

        return diff.split('\n') if diff else []

# 使用示例
loader = IncrementalGitLoader(
    repo_path="/path/to/repo",
    last_commit_sha="abc123"  # 上次处理的提交
)

new_docs = loader.load_changes()
print(f"新增/修改了 {len(new_docs)} 个文档")
```

---

## 总结

**代码仓库加载的核心要点：**

1. **GitHub加载**: 使用GitHub API或GitLoader
2. **本地仓库**: 使用GitPython遍历文件
3. **代码解析**: 使用AST或tree-sitter提取结构
4. **文件过滤**: 排除不必要的文件和目录
5. **增量更新**: 只加载变更的文件

**在RAG中的应用：**
- 构建代码问答系统
- 代码搜索和推荐
- 技术文档知识库
- API文档查询

---

## 参考来源

> **参考来源：**
> - [LangChain GitHub Loaders](https://python.langchain.com/docs/modules/data_connection/document_loaders/integrations/github) (2025)
> - [GitPython Documentation](https://gitpython.readthedocs.io/) (2025)
> - [tree-sitter](https://tree-sitter.github.io/tree-sitter/) - 代码解析器 (2025)

---

**版本：** v1.0
**最后更新：** 2026-02-15
**下一步：** 阅读 [03_核心概念_08_编码与错误处理.md](./03_核心概念_08_编码与错误处理.md)
