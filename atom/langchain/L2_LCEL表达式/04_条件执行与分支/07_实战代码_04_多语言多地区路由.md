# 实战代码：多语言多地区路由

> **场景**：根据用户语言和地区路由到不同的处理链，实现国际化
> **学习目标**：掌握多语言多地区路由的实现
> **预计学习时长**：45分钟

---

## 场景说明

### 业务需求

在全球化的 AI 应用中，用户来自不同的国家和地区：
- **语言差异**：中文、英文、日文、西班牙文等
- **文化差异**：不同地区的表达习惯和偏好
- **时区差异**：不同地区的时间和日期格式
- **法规差异**：不同地区的合规要求

### 解决方案

通过多语言多地区路由，提供本地化体验：
1. **语言检测**：自动识别用户输入的语言
2. **地区识别**：根据用户信息识别地区
3. **本地化处理**：使用对应语言的 prompt 和模型
4. **文化适配**：根据地区调整响应风格

### 预期效果

- **用户体验提升**：母语响应，文化适配
- **全球覆盖**：支持多种语言和地区
- **合规保证**：满足不同地区的法规要求

**参考资料**：
- Building Multilingual RAG with Milvus, LangChain, and OpenAI
- https://zilliz.com/blog/building-multilingual-rag-milvus-langchain-openai

---

## 架构设计

### 系统架构图

```
用户输入
    ↓
语言检测
    ↓
语言类型
    ├─ 中文 → 中文处理链 → 中文 Prompt → 中文响应
    ├─ 英文 → 英文处理链 → 英文 Prompt → 英文响应
    ├─ 日文 → 日文处理链 → 日文 Prompt → 日文响应
    └─ 其他 → 多语言处理链 → 通用 Prompt → 多语言响应
```

### 核心组件

1. **语言检测器**：识别输入语言
2. **多语言 Prompt 模板**：不同语言的 Prompt
3. **本地化处理链**：针对不同语言优化
4. **路由器**：根据语言选择处理链

---

## 完整代码实现

```python
from langchain_core.runnables import RunnableBranch, RunnableLambda
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from dotenv import load_dotenv
import logging
from typing import Dict, Any
import re

# 加载环境变量
load_dotenv()

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ============================================================
# 1. 语言检测器
# ============================================================

class LanguageDetector:
    """语言检测器"""

    @staticmethod
    def detect(text: str) -> str:
        """检测文本语言

        返回值：
        - "zh": 中文
        - "en": 英文
        - "ja": 日文
        - "unknown": 未知语言
        """
        # 中文检测（Unicode 范围）
        if any('\u4e00' <= char <= '\u9fff' for char in text):
            return "zh"

        # 日文检测（平假名、片假名）
        if any('\u3040' <= char <= '\u309f' or '\u30a0' <= char <= '\u30ff' for char in text):
            return "ja"

        # 英文检测（ASCII）
        if text.isascii() and any(char.isalpha() for char in text):
            return "en"

        return "unknown"

# ============================================================
# 2. 多语言 Prompt 模板
# ============================================================

class MultilingualPrompts:
    """多语言 Prompt 模板"""

    def __init__(self):
        self.prompts = {
            "zh": ChatPromptTemplate.from_template(
                """你是一个友好的AI助手。请用中文回答以下问题：

问题：{input}

要求：
1. 使用简洁、清晰的中文
2. 符合中文表达习惯
3. 提供准确的信息"""
            ),
            "en": ChatPromptTemplate.from_template(
                """You are a friendly AI assistant. Please answer the following question in English:

Question: {input}

Requirements:
1. Use clear and concise English
2. Follow English expression conventions
3. Provide accurate information"""
            ),
            "ja": ChatPromptTemplate.from_template(
                """あなたは親切なAIアシスタントです。以下の質問に日本語で答えてください：

質問：{input}

要件：
1. 明確で簡潔な日本語を使用する
2. 日本語の表現習慣に従う
3. 正確な情報を提供する"""
            ),
            "unknown": ChatPromptTemplate.from_template(
                """You are a multilingual AI assistant. Please answer the following question:

Question: {input}

Requirements:
1. Detect the language of the question
2. Respond in the same language
3. Provide accurate information"""
            )
        }

    def get_prompt(self, language: str) -> ChatPromptTemplate:
        """获取指定语言的 Prompt"""
        return self.prompts.get(language, self.prompts["unknown"])

# ============================================================
# 3. 本地化处理链
# ============================================================

class LocalizedChain:
    """本地化处理链"""

    def __init__(self, language: str, prompts: MultilingualPrompts):
        self.language = language
        self.model = ChatOpenAI(model="gpt-4o-mini", temperature=0.7)
        self.prompt = prompts.get_prompt(language)
        self.chain = self.prompt | self.model

    def invoke(self, x: Dict[str, Any]) -> str:
        """执行处理链"""
        logger.info(f"Processing in {self.language}: {x['input'][:50]}")
        result = self.chain.invoke(x)
        return result.content

# ============================================================
# 4. 多语言路由器
# ============================================================

class MultilingualRouter:
    """多语言路由器"""

    def __init__(self):
        self.detector = LanguageDetector()
        self.prompts = MultilingualPrompts()

        # 创建各语言的处理链
        self.chains = {
            "zh": LocalizedChain("zh", self.prompts),
            "en": LocalizedChain("en", self.prompts),
            "ja": LocalizedChain("ja", self.prompts),
            "unknown": LocalizedChain("unknown", self.prompts)
        }

        # 创建路由
        self.router = RunnableBranch(
            (self._is_chinese, RunnableLambda(self.chains["zh"].invoke)),
            (self._is_english, RunnableLambda(self.chains["en"].invoke)),
            (self._is_japanese, RunnableLambda(self.chains["ja"].invoke)),
            RunnableLambda(self.chains["unknown"].invoke)
        )

    def _is_chinese(self, x: Dict[str, Any]) -> bool:
        """判断是否为中文"""
        return self.detector.detect(x["input"]) == "zh"

    def _is_english(self, x: Dict[str, Any]) -> bool:
        """判断是否为英文"""
        return self.detector.detect(x["input"]) == "en"

    def _is_japanese(self, x: Dict[str, Any]) -> bool:
        """判断是否为日文"""
        return self.detector.detect(x["input"]) == "ja"

    def invoke(self, input_text: str) -> Dict[str, Any]:
        """执行路由"""
        # 检测语言
        detected_language = self.detector.detect(input_text)
        logger.info(f"Detected language: {detected_language}")

        # 执行路由
        result = self.router.invoke({"input": input_text})

        return {
            "input": input_text,
            "detected_language": detected_language,
            "output": result
        }

# ============================================================
# 5. 多地区路由器（扩展）
# ============================================================

class MultiRegionRouter:
    """多地区路由器"""

    def __init__(self):
        self.detector = LanguageDetector()
        self.prompts = MultilingualPrompts()

        # 地区配置
        self.region_configs = {
            "zh-CN": {  # 中国大陆
                "language": "zh",
                "timezone": "Asia/Shanghai",
                "date_format": "%Y年%m月%d日",
                "currency": "CNY"
            },
            "zh-TW": {  # 台湾
                "language": "zh",
                "timezone": "Asia/Taipei",
                "date_format": "%Y年%m月%d日",
                "currency": "TWD"
            },
            "en-US": {  # 美国
                "language": "en",
                "timezone": "America/New_York",
                "date_format": "%m/%d/%Y",
                "currency": "USD"
            },
            "en-GB": {  # 英国
                "language": "en",
                "timezone": "Europe/London",
                "date_format": "%d/%m/%Y",
                "currency": "GBP"
            },
            "ja-JP": {  # 日本
                "language": "ja",
                "timezone": "Asia/Tokyo",
                "date_format": "%Y年%m月%d日",
                "currency": "JPY"
            }
        }

    def detect_region(self, input_text: str, user_info: Dict[str, Any] = None) -> str:
        """检测地区"""
        # 优先使用用户信息
        if user_info and "region" in user_info:
            return user_info["region"]

        # 根据语言推断地区
        language = self.detector.detect(input_text)
        if language == "zh":
            return "zh-CN"
        elif language == "en":
            return "en-US"
        elif language == "ja":
            return "ja-JP"
        else:
            return "en-US"  # 默认

    def get_region_config(self, region: str) -> Dict[str, Any]:
        """获取地区配置"""
        return self.region_configs.get(region, self.region_configs["en-US"])

# ============================================================
# 6. 测试系统
# ============================================================

def test_multilingual_router():
    """测试多语言路由"""
    router = MultilingualRouter()

    # 测试用例
    test_cases = [
        # 中文
        ("什么是Python?", "zh"),
        ("你好，请介绍一下自己", "zh"),
        ("如何学习编程？", "zh"),

        # 英文
        ("What is Python?", "en"),
        ("Hello, please introduce yourself", "en"),
        ("How to learn programming?", "en"),

        # 日文
        ("Pythonとは何ですか？", "ja"),
        ("こんにちは、自己紹介してください", "ja"),
        ("プログラミングを学ぶ方法は？", "ja"),

        # 混合（应该检测为主要语言）
        ("What is Python? 什么是Python?", "mixed"),
    ]

    print("="*70)
    print("多语言路由测试")
    print("="*70)
    print()

    for i, (input_text, expected_lang) in enumerate(test_cases, 1):
        print(f"测试 {i}/{len(test_cases)}")
        print(f"输入: {input_text}")
        print(f"预期语言: {expected_lang}")
        print("-"*70)

        result = router.invoke(input_text)

        print(f"检测语言: {result['detected_language']}")
        print(f"输出: {result['output'][:100]}...")
        print("-"*70)
        print()

# ============================================================
# 7. 统计分析
# ============================================================

class LanguageStats:
    """语言统计"""

    def __init__(self):
        self.stats = {}

    def track(self, language: str):
        """追踪语言使用"""
        self.stats[language] = self.stats.get(language, 0) + 1

    def report(self):
        """生成统计报告"""
        print("\n" + "="*70)
        print("语言使用统计")
        print("="*70)

        total = sum(self.stats.values())
        for language, count in sorted(self.stats.items(), key=lambda x: x[1], reverse=True):
            percentage = (count / total) * 100
            print(f"{language}: {count} ({percentage:.1f}%)")

        print(f"\n总计: {total}")
        print("="*70)

# ============================================================
# 8. 主程序
# ============================================================

if __name__ == "__main__":
    test_multilingual_router()
```

---

## 运行示例和输出

### 测试1: 中文

**输入**：`什么是Python?`

**输出**：
```
测试 1/12
输入: 什么是Python?
预期语言: zh
----------------------------------------------------------------------
检测语言: zh
输出: Python是一种高级编程语言，由Guido van Rossum于1991年创建。它以简洁易读的语法和强大的功能而闻名，广泛应用于Web开发、数据分析、人工智能等领域...
----------------------------------------------------------------------
```

### 测试2: 英文

**输入**：`What is Python?`

**输出**：
```
测试 4/12
输入: What is Python?
预期语言: en
----------------------------------------------------------------------
检测语言: en
输出: Python is a high-level programming language created by Guido van Rossum in 1991. It is known for its clean and readable syntax, and is widely used in web development, data analysis, artificial intelligence, and more...
----------------------------------------------------------------------
```

### 测试3: 日文

**输入**：`Pythonとは何ですか？`

**输出**：
```
测试 7/12
输入: Pythonとは何ですか？
预期语言: ja
----------------------------------------------------------------------
检测语言: ja
输出: Pythonは、Guido van Rossumによって1991年に作成された高水準プログラミング言語です。シンプルで読みやすい構文が特徴で、Web開発、データ分析、人工知能などの分野で広く使用されています...
----------------------------------------------------------------------
```

---

## 国际化最佳实践

### 1. 语言检测优化

```python
# 使用专业的语言检测库
from langdetect import detect, detect_langs

def advanced_detect(text: str) -> str:
    """高级语言检测"""
    try:
        # 检测语言及其概率
        langs = detect_langs(text)
        # 返回概率最高的语言
        return langs[0].lang if langs else "unknown"
    except:
        # 降级到简单检测
        return LanguageDetector.detect(text)
```

### 2. 多语言 Embedding

```python
from langchain_openai import OpenAIEmbeddings

# 使用多语言 Embedding 模型
multilingual_embeddings = OpenAIEmbeddings(
    model="text-embedding-3-large"  # 支持多语言
)
```

### 3. 文化适配

```python
class CulturalAdapter:
    """文化适配器"""

    def __init__(self):
        self.cultural_rules = {
            "zh-CN": {
                "greeting": "您好",
                "politeness_level": "formal",
                "number_format": "chinese"
            },
            "en-US": {
                "greeting": "Hello",
                "politeness_level": "casual",
                "number_format": "western"
            },
            "ja-JP": {
                "greeting": "こんにちは",
                "politeness_level": "very_formal",
                "number_format": "japanese"
            }
        }

    def adapt_response(self, response: str, region: str) -> str:
        """适配响应"""
        rules = self.cultural_rules.get(region, {})
        # 应用文化规则
        # ...
        return response
```

### 4. 时区和日期格式

```python
from datetime import datetime
import pytz

def format_datetime(dt: datetime, region: str) -> str:
    """格式化日期时间"""
    region_configs = {
        "zh-CN": {
            "timezone": "Asia/Shanghai",
            "format": "%Y年%m月%d日 %H:%M"
        },
        "en-US": {
            "timezone": "America/New_York",
            "format": "%m/%d/%Y %I:%M %p"
        },
        "ja-JP": {
            "timezone": "Asia/Tokyo",
            "format": "%Y年%m月%d日 %H時%M分"
        }
    }

    config = region_configs.get(region, region_configs["en-US"])
    tz = pytz.timezone(config["timezone"])
    local_dt = dt.astimezone(tz)
    return local_dt.strftime(config["format"])
```

### 5. 货币和数字格式

```python
def format_currency(amount: float, region: str) -> str:
    """格式化货币"""
    currency_configs = {
        "zh-CN": {"symbol": "¥", "position": "before"},
        "en-US": {"symbol": "$", "position": "before"},
        "ja-JP": {"symbol": "¥", "position": "before"},
        "en-GB": {"symbol": "£", "position": "before"}
    }

    config = currency_configs.get(region, currency_configs["en-US"])
    if config["position"] == "before":
        return f"{config['symbol']}{amount:,.2f}"
    else:
        return f"{amount:,.2f}{config['symbol']}"
```

### 6. 合规性检查

```python
class ComplianceChecker:
    """合规性检查器"""

    def __init__(self):
        self.regional_rules = {
            "EU": {
                "gdpr": True,
                "data_retention_days": 90,
                "requires_consent": True
            },
            "CN": {
                "data_localization": True,
                "content_filtering": True,
                "requires_license": True
            },
            "US": {
                "ccpa": True,
                "data_retention_days": 365,
                "requires_consent": False
            }
        }

    def check_compliance(self, region: str, action: str) -> bool:
        """检查合规性"""
        rules = self.regional_rules.get(region, {})
        # 检查是否符合地区规则
        # ...
        return True
```

---

## 扩展功能

### 1. 自动翻译

```python
from langchain_openai import ChatOpenAI

class AutoTranslator:
    """自动翻译器"""

    def __init__(self):
        self.model = ChatOpenAI(model="gpt-4o-mini", temperature=0)

    def translate(self, text: str, target_language: str) -> str:
        """翻译文本"""
        prompt = f"Translate the following text to {target_language}:\n\n{text}"
        result = self.model.invoke(prompt)
        return result.content
```

### 2. 多语言知识库

```python
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings

class MultilingualKnowledgeBase:
    """多语言知识库"""

    def __init__(self):
        self.embeddings = OpenAIEmbeddings(model="text-embedding-3-large")
        self.vectorstores = {
            "zh": Chroma(embedding_function=self.embeddings, collection_name="zh"),
            "en": Chroma(embedding_function=self.embeddings, collection_name="en"),
            "ja": Chroma(embedding_function=self.embeddings, collection_name="ja")
        }

    def search(self, query: str, language: str, k: int = 5):
        """搜索知识库"""
        vectorstore = self.vectorstores.get(language)
        if vectorstore:
            return vectorstore.similarity_search(query, k=k)
        return []
```

### 3. 语言偏好学习

```python
class LanguagePreferenceLearner:
    """语言偏好学习器"""

    def __init__(self):
        self.user_preferences = {}

    def learn(self, user_id: str, language: str):
        """学习用户语言偏好"""
        if user_id not in self.user_preferences:
            self.user_preferences[user_id] = {}

        lang_count = self.user_preferences[user_id].get(language, 0)
        self.user_preferences[user_id][language] = lang_count + 1

    def get_preferred_language(self, user_id: str) -> str:
        """获取用户偏好语言"""
        if user_id in self.user_preferences:
            prefs = self.user_preferences[user_id]
            return max(prefs, key=prefs.get)
        return "en"  # 默认
```

---

## 总结

### 核心要点

1. **语言检测**：自动识别用户输入的语言
2. **本地化处理**：使用对应语言的 Prompt 和模型
3. **文化适配**：根据地区调整响应风格
4. **合规保证**：满足不同地区的法规要求

### 实际效果

- **用户体验提升**：母语响应，文化适配
- **全球覆盖**：支持多种语言和地区
- **合规保证**：满足 GDPR、CCPA 等法规

### 下一步

- 阅读 `03_核心概念_02_动态路由.md` 深入理解路由策略
- 阅读 `07_实战代码_02_多模型动态选择.md` 学习成本优化
- 阅读 `06_反直觉点.md` 了解常见误区

---

**恭喜！** 你已经完成了条件执行与分支的所有学习内容。现在你已经掌握了：
- RunnableBranch 的核心概念和实现
- 动态路由的设计策略
- 条件判断逻辑的编写方法
- 4个实战场景的完整实现

继续学习其他 LangChain 知识点，构建更强大的 AI 应用！
