# 核心概念 04：会话管理命令

> 深入理解 Pi 的 6 个会话管理命令：/new、/resume、/name、/session、/tree、/fork、/compact

---

## 概念定义

**Pi 的会话管理系统通过 6 个命令实现创建、命名、查看、分支、压缩功能，基于 JSONL 追加式存储和树形结构，支持无限分支和完整历史追溯。**

---

## 命令 1：/new - 创建新会话

### 语法

```bash
/new
```

### 功能

创建一个全新的会话，清空当前上下文。

### 实现原理

```typescript
// 创建新会话
class SessionManager {
  async createNewSession(): Promise<Session> {
    // 1. 生成会话 ID
    const sessionId = this.generateSessionId();

    // 2. 创建 JSONL 文件
    const sessionFile = path.join(
      os.homedir(),
      '.pi',
      'sessions',
      `${sessionId}.jsonl`
    );

    // 3. 写入初始元数据
    const metadata = {
      type: 'session_metadata',
      id: sessionId,
      name: sessionId,  // 默认名称
      createdAt: new Date().toISOString(),
      model: this.currentModel
    };

    await fs.appendFile(sessionFile, JSON.stringify(metadata) + '\n');

    // 4. 切换到新会话
    this.currentSession = {
      id: sessionId,
      file: sessionFile,
      messages: [],
      branches: []
    };

    return this.currentSession;
  }

  private generateSessionId(): string {
    // 使用时间戳 + 随机字符串
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    return `session-${timestamp}-${random}`;
  }
}
```

### 使用场景

```bash
# 场景 1：开始新项目
> /new
> /name project-auth
> 请帮我设计一个用户认证系统

# 场景 2：切换任务
> /new
> /name bug-fix-login
> 请帮我修复登录页面的 bug

# 场景 3：清空上下文
# 当前会话上下文太长，影响性能
> /new
# 开始全新的对话
```

---

## 命令 2：/resume - 恢复会话

### 语法

```bash
/resume [session-name]
```

### 功能

恢复之前的会话，加载完整的对话历史。

### 实现原理

```typescript
// 恢复会话
class SessionManager {
  async resumeSession(sessionName?: string): Promise<Session> {
    // 1. 如果没有指定名称，显示会话列表
    if (!sessionName) {
      const sessions = await this.listSessions();
      sessionName = await this.selectSession(sessions);
    }

    // 2. 查找会话文件
    const sessionFile = await this.findSessionFile(sessionName);
    if (!sessionFile) {
      throw new Error(`Session not found: ${sessionName}`);
    }

    // 3. 读取 JSONL 文件
    const lines = (await fs.readFile(sessionFile, 'utf-8')).split('\n');
    const messages: Message[] = [];

    for (const line of lines) {
      if (!line.trim()) continue;

      const obj = JSON.parse(line);

      if (obj.type === 'user' || obj.type === 'assistant') {
        messages.push(obj);
      }
    }

    // 4. 重建会话状态
    this.currentSession = {
      id: path.basename(sessionFile, '.jsonl'),
      file: sessionFile,
      messages: messages,
      branches: this.buildBranchTree(messages)
    };

    return this.currentSession;
  }

  private async listSessions(): Promise<SessionInfo[]> {
    const sessionsDir = path.join(os.homedir(), '.pi', 'sessions');
    const files = await fs.readdir(sessionsDir);

    const sessions: SessionInfo[] = [];

    for (const file of files) {
      if (!file.endsWith('.jsonl')) continue;

      const sessionFile = path.join(sessionsDir, file);
      const metadata = await this.readSessionMetadata(sessionFile);

      sessions.push({
        id: path.basename(file, '.jsonl'),
        name: metadata.name,
        createdAt: metadata.createdAt,
        messageCount: metadata.messageCount,
        lastModified: (await fs.stat(sessionFile)).mtime
      });
    }

    // 按最后修改时间排序
    return sessions.sort((a, b) =>
      b.lastModified.getTime() - a.lastModified.getTime()
    );
  }
}
```

### 使用场景

```bash
# 场景 1：继续之前的工作
> /resume project-auth
# 加载 project-auth 会话的完整历史
# 继续讨论用户认证系统

# 场景 2：查看历史决策
> /resume old-project
# 查看之前的技术决策和讨论

# 场景 3：切换项目
> /resume project-a
# 工作一段时间
> /resume project-b
# 切换到另一个项目
```

---

## 命令 3：/name - 命名会话

### 语法

```bash
/name <session-name>
```

### 功能

为当前会话设置一个有意义的名称。

### 实现原理

```typescript
// 命名会话
class SessionManager {
  async nameSession(name: string): Promise<void> {
    // 1. 验证名称
    if (!this.isValidSessionName(name)) {
      throw new Error('Invalid session name');
    }

    // 2. 检查名称是否已存在
    const existing = await this.findSessionByName(name);
    if (existing && existing.id !== this.currentSession.id) {
      throw new Error(`Session name already exists: ${name}`);
    }

    // 3. 更新会话元数据
    const metadata = {
      type: 'session_metadata_update',
      name: name,
      updatedAt: new Date().toISOString()
    };

    await fs.appendFile(
      this.currentSession.file,
      JSON.stringify(metadata) + '\n'
    );

    // 4. 更新内存中的会话名称
    this.currentSession.name = name;

    console.log(`Session renamed to: ${name}`);
  }

  private isValidSessionName(name: string): boolean {
    // 只允许字母、数字、连字符、下划线
    return /^[a-zA-Z0-9_-]+$/.test(name);
  }
}
```

### 使用场景

```bash
# 场景 1：创建会话后立即命名
> /new
> /name user-auth-system
> 请帮我设计用户认证系统

# 场景 2：重命名现有会话
> /name project-auth-v2
# 更新会话名称以反映新版本

# 场景 3：使用描述性名称
> /name bug-fix-login-redirect
# 使用描述性名称便于后续查找
```

---

## 命令 4：/session - 查看会话信息

### 语法

```bash
/session
```

### 功能

显示当前会话的详细信息。

### 实现原理

```typescript
// 查看会话信息
class SessionManager {
  async showSessionInfo(): Promise<SessionInfo> {
    const session = this.currentSession;

    // 1. 统计消息数量
    const userMessages = session.messages.filter(m => m.role === 'user').length;
    const assistantMessages = session.messages.filter(m => m.role === 'assistant').length;

    // 2. 统计 Token 使用
    const tokenUsage = this.calculateTokenUsage(session.messages);

    // 3. 统计分支数量
    const branchCount = this.countBranches(session.branches);

    // 4. 计算会话时长
    const duration = this.calculateDuration(session);

    // 5. 构建信息对象
    const info: SessionInfo = {
      id: session.id,
      name: session.name,
      createdAt: session.createdAt,
      lastModified: session.lastModified,
      model: session.model,
      messages: {
        total: session.messages.length,
        user: userMessages,
        assistant: assistantMessages
      },
      tokens: tokenUsage,
      branches: branchCount,
      duration: duration,
      file: session.file
    };

    // 6. 格式化输出
    this.displaySessionInfo(info);

    return info;
  }

  private calculateTokenUsage(messages: Message[]): TokenUsage {
    let inputTokens = 0;
    let outputTokens = 0;

    for (const message of messages) {
      if (message.role === 'user') {
        inputTokens += message.tokens || 0;
      } else if (message.role === 'assistant') {
        outputTokens += message.tokens || 0;
      }
    }

    return {
      input: inputTokens,
      output: outputTokens,
      total: inputTokens + outputTokens,
      cost: this.calculateCost(inputTokens, outputTokens)
    };
  }

  private displaySessionInfo(info: SessionInfo): void {
    console.log(`
Session Information:
  ID: ${info.id}
  Name: ${info.name}
  Model: ${info.model}
  Created: ${info.createdAt}
  Last Modified: ${info.lastModified}

Messages:
  Total: ${info.messages.total}
  User: ${info.messages.user}
  Assistant: ${info.messages.assistant}

Tokens:
  Input: ${info.tokens.input}
  Output: ${info.tokens.output}
  Total: ${info.tokens.total}
  Estimated Cost: $${info.tokens.cost.toFixed(4)}

Branches: ${info.branches}
Duration: ${info.duration}
File: ${info.file}
    `);
  }
}
```

### 输出示例

```
Session Information:
  ID: session-1708272000-abc123
  Name: user-auth-system
  Model: claude-opus-4
  Created: 2026-02-18T10:00:00Z
  Last Modified: 2026-02-18T12:30:00Z

Messages:
  Total: 42
  User: 21
  Assistant: 21

Tokens:
  Input: 15000
  Output: 25000
  Total: 40000
  Estimated Cost: $0.9750

Branches: 3
Duration: 2h 30m
File: /Users/username/.pi/sessions/session-1708272000-abc123.jsonl
```

---

## 命令 5：/tree - 查看会话树

### 语法

```bash
/tree
```

### 功能

显示当前会话的树形结构，包括所有分支。

### 实现原理

```typescript
// 查看会话树
class SessionManager {
  async showSessionTree(): Promise<void> {
    const session = this.currentSession;

    // 1. 构建树形结构
    const tree = this.buildTree(session.messages);

    // 2. 渲染树形视图
    this.renderTree(tree);

    // 3. 等待用户选择
    const selectedNode = await this.selectNode(tree);

    if (selectedNode) {
      // 用户选择了一个节点，可以 fork
      this.selectedNodeForFork = selectedNode;
      console.log(`Selected node: ${selectedNode.id}`);
      console.log('Use /fork to create a new branch from this point');
    }
  }

  private buildTree(messages: Message[]): TreeNode {
    // 1. 创建节点映射
    const nodes = new Map<string, TreeNode>();

    for (const message of messages) {
      nodes.set(message.id, {
        id: message.id,
        role: message.role,
        content: message.content.substring(0, 50) + '...',
        parent: message.parent,
        children: [],
        timestamp: message.timestamp
      });
    }

    // 2. 构建父子关系
    for (const node of nodes.values()) {
      if (node.parent) {
        const parentNode = nodes.get(node.parent);
        if (parentNode) {
          parentNode.children.push(node);
        }
      }
    }

    // 3. 找到根节点
    const rootNode = Array.from(nodes.values()).find(n => !n.parent);

    return rootNode!;
  }

  private renderTree(node: TreeNode, prefix: string = '', isLast: boolean = true): void {
    // 渲染当前节点
    const connector = isLast ? '└─' : '├─';
    const roleColor = node.role === 'user' ? chalk.cyan : chalk.green;

    console.log(`${prefix}${connector} ${roleColor(node.role)}: ${node.content}`);

    // 渲染子节点
    const childPrefix = prefix + (isLast ? '  ' : '│ ');

    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      const isLastChild = i === node.children.length - 1;
      this.renderTree(child, childPrefix, isLastChild);
    }
  }

  private async selectNode(tree: TreeNode): Promise<TreeNode | null> {
    // 使用交互式选择器
    const choices = this.flattenTree(tree).map(node => ({
      name: `${node.role}: ${node.content}`,
      value: node
    }));

    const answer = await inquirer.prompt([{
      type: 'list',
      name: 'node',
      message: 'Select a node to fork from (or press Escape to cancel):',
      choices: choices
    }]);

    return answer.node;
  }
}
```

### 输出示例

```
Session Tree: user-auth-system

└─ user: 请帮我设计一个用户认证系统
   └─ assistant: 我建议使用 JWT 认证...
      ├─ user: 如何实现 token 刷新？
      │  └─ assistant: 可以使用 refresh token...
      │     └─ user: 请给出代码示例
      │        └─ assistant: 这是一个完整的示例...
      └─ user: 如果使用 OAuth 2.0 呢？
         └─ assistant: OAuth 2.0 的实现方式...
            └─ user: 请对比两种方案
               └─ assistant: JWT vs OAuth 2.0...

Select a node to fork from (or press Escape to cancel):
> user: 请帮我设计一个用户认证系统
  assistant: 我建议使用 JWT 认证...
  user: 如何实现 token 刷新？
  ...
```

---

## 命令 6：/fork - 创建分支

### 语法

```bash
/fork
```

### 功能

从 /tree 选择的节点创建新分支。

### 实现原理

```typescript
// 创建分支
class SessionManager {
  async forkFromNode(): Promise<void> {
    if (!this.selectedNodeForFork) {
      throw new Error('No node selected. Use /tree to select a node first.');
    }

    const node = this.selectedNodeForFork;

    // 1. 切换到选中的节点
    this.currentBranch = node.id;

    // 2. 重建上下文
    const context = this.buildContextFromNode(node);

    // 3. 更新 LLM 上下文
    await this.updateLLMContext(context);

    console.log(`Forked from: ${node.role}: ${node.content}`);
    console.log('You can now continue the conversation from this point.');

    // 4. 清除选择
    this.selectedNodeForFork = null;
  }

  private buildContextFromNode(node: TreeNode): Message[] {
    const context: Message[] = [];

    // 从根节点到当前节点的路径
    const path = this.getPathToNode(node);

    for (const nodeId of path) {
      const message = this.findMessageById(nodeId);
      if (message) {
        context.push(message);
      }
    }

    return context;
  }

  private getPathToNode(node: TreeNode): string[] {
    const path: string[] = [];
    let current: TreeNode | undefined = node;

    while (current) {
      path.unshift(current.id);
      current = current.parent ? this.findNodeById(current.parent) : undefined;
    }

    return path;
  }
}
```

### 使用场景

```bash
# 场景 1：尝试不同方案
> /tree
# 选择 "我建议使用 JWT 认证" 这个节点
> /fork
> 如果使用 OAuth 2.0 呢？
# 从同一个起点尝试不同的方案

# 场景 2：回到历史决策点
> /tree
# 选择之前的某个决策点
> /fork
> 让我们尝试另一种方法
# 探索不同的技术路线

# 场景 3：并行实验
> /tree
# 选择实验起点
> /fork
> /name experiment-approach-1
# 创建第一个实验分支

> /tree
# 再次选择同一个起点
> /fork
> /name experiment-approach-2
# 创建第二个实验分支
```

---

## 命令 7：/compact - 压缩会话

### 语法

```bash
/compact [prompt]
```

### 功能

压缩会话历史，生成摘要以减少 Token 使用。

### 实现原理

```typescript
// 压缩会话
class SessionManager {
  async compactSession(customPrompt?: string): Promise<void> {
    const session = this.currentSession;

    // 1. 确定压缩范围
    const lastCompaction = this.findLastCompaction(session);
    const startIndex = lastCompaction ? lastCompaction.endIndex : 0;
    const endIndex = session.messages.length - 10;  // 保留最近 10 条消息

    if (endIndex <= startIndex) {
      console.log('No messages to compact');
      return;
    }

    const messagesToCompact = session.messages.slice(startIndex, endIndex);

    // 2. 生成摘要
    const summary = await this.generateSummary(messagesToCompact, customPrompt);

    // 3. 创建 Compaction 标记
    const compaction = {
      type: 'compaction',
      summary: summary,
      compactedRange: {
        start: startIndex,
        end: endIndex
      },
      messageCount: messagesToCompact.length,
      timestamp: new Date().toISOString()
    };

    // 4. 追加到 JSONL
    await fs.appendFile(
      session.file,
      JSON.stringify(compaction) + '\n'
    );

    // 5. 更新 LLM 上下文
    await this.updateLLMContextWithCompaction(compaction);

    console.log(`Compacted ${messagesToCompact.length} messages`);
    console.log(`Summary: ${summary.substring(0, 100)}...`);
  }

  private async generateSummary(messages: Message[], customPrompt?: string): Promise<string> {
    const defaultPrompt = `
Please summarize the following conversation, focusing on:
1. Key decisions made
2. Technical approaches discussed
3. Code changes implemented
4. Unresolved issues

Conversation:
${messages.map(m => `${m.role}: ${m.content}`).join('\n\n')}
    `;

    const prompt = customPrompt || defaultPrompt;

    const response = await this.llm.chat([{
      role: 'user',
      content: prompt
    }]);

    return response.content;
  }

  private async updateLLMContextWithCompaction(compaction: Compaction): Promise<void> {
    // 构建新的上下文
    const context: Message[] = [];

    // 1. 添加摘要作为系统消息
    context.push({
      role: 'system',
      content: `Previous conversation summary:\n${compaction.summary}`
    });

    // 2. 添加最近的消息
    const recentMessages = this.currentSession.messages.slice(compaction.compactedRange.end);
    context.push(...recentMessages);

    // 3. 更新 LLM 上下文
    this.llmContext = context;
  }
}
```

### 使用场景

```bash
# 场景 1：长会话优化
# 会话已经有 200 轮对话，Token 使用过高
> /compact
Compacted 180 messages
Summary: This session discussed the design and implementation...

# 场景 2：自定义摘要
> /compact 请重点总结技术决策和代码变更
Compacted 150 messages
Summary: Technical decisions: 1. Chose JWT over OAuth...

# 场景 3：定期压缩
# 每 100 轮对话自动压缩
if (session.messages.length % 100 === 0) {
  await sessionManager.compactSession();
}
```

---

## 会话管理最佳实践

### 实践 1：使用描述性名称

```bash
# ❌ 不好的命名
> /name session1
> /name test
> /name temp

# ✅ 好的命名
> /name user-auth-jwt-implementation
> /name bug-fix-login-redirect-issue
> /name refactor-api-error-handling
```

---

### 实践 2：及时创建分支

```bash
# 当需要尝试不同方案时
> /tree
# 选择决策点
> /fork
> /name approach-jwt
# 尝试 JWT 方案

> /tree
# 回到同一决策点
> /fork
> /name approach-oauth
# 尝试 OAuth 方案
```

---

### 实践 3：定期压缩长会话

```bash
# 当 Token 使用超过 100K 时
> /session
Tokens: 120K

> /compact
Compacted 200 messages
New token usage: 50K
```

---

### 实践 4：使用 /session 监控成本

```bash
# 定期检查 Token 使用和成本
> /session
Tokens: 40K
Estimated Cost: $0.9750

# 如果成本过高，考虑压缩或创建新会话
```

---

## 快速参考

```typescript
// 会话管理命令
interface SessionCommands {
  // 创建与恢复
  new: '/new',                    // 创建新会话
  resume: '/resume [name]',       // 恢复会话

  // 命名与查看
  name: '/name <name>',           // 命名会话
  session: '/session',            // 查看会话信息

  // 分支管理
  tree: '/tree',                  // 查看会话树
  fork: '/fork',                  // 创建分支

  // 优化
  compact: '/compact [prompt]',   // 压缩会话
}

// 会话存储
interface SessionStorage {
  format: 'JSONL',                // 追加式存储
  location: '~/.pi/sessions/',    // 存储位置
  structure: 'tree',              // 树形结构
  persistence: 'file',            // 文件持久化
}
```

---

**来源：**
- [Pi Coding Agent README](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/README.md) - 2026-02
- [Sessions 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/sessions.md) - 2026-02
- [Commands 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/README.md#commands) - 2026-02
