# 实战代码2：滑动窗口实现

> 手写滑动窗口算法的完整实现

---

## 滑动日志版本

```python
"""滑动窗口限流器 - 滑动日志实现"""
import time
from typing import List, Dict

class SlidingWindowLimiter:
    def __init__(self, limit: int, window: int):
        self.limit = limit
        self.window = window
        self.requests: List[float] = []

    def acquire(self) -> bool:
        now = time.time()
        self.requests = [t for t in self.requests if now - t < self.window]

        if len(self.requests) < self.limit:
            self.requests.append(now)
            return True
        return False

    def get_status(self) -> Dict:
        now = time.time()
        self.requests = [t for t in self.requests if now - t < self.window]
        return {"count": len(self.requests), "limit": self.limit}
```

---

## Redis Sorted Set 实现

```python
"""滑动窗口限流器 - Redis Sorted Set 实现"""
import redis
import time

class RedisSlidingWindowLimiter:
    LUA_SCRIPT = """
    local key = KEYS[1]
    local now = tonumber(ARGV[1])
    local window_start = tonumber(ARGV[2])
    local limit = tonumber(ARGV[3])

    redis.call('ZREMRANGEBYSCORE', key, '-inf', window_start)
    local count = redis.call('ZCARD', key)

    if count < limit then
        redis.call('ZADD', key, now, now)
        redis.call('EXPIRE', key, math.ceil(ARGV[4]))
        return 1
    end
    return 0
    """

    def __init__(self, redis_client: redis.Redis, key: str, limit: int, window: int):
        self.redis = redis_client
        self.key = key
        self.limit = limit
        self.window = window
        self.script_sha = self.redis.script_load(self.LUA_SCRIPT)

    def acquire(self) -> bool:
        now = time.time()
        window_start = now - self.window

        result = self.redis.evalsha(
            self.script_sha, 1, self.key,
            now, window_start, self.limit, self.window
        )
        return result == 1
```

---

## FastAPI 集成

```python
"""滑动窗口限流 - FastAPI 集成"""
from fastapi import FastAPI, Depends, HTTPException, Request
import redis

app = FastAPI()
redis_client = redis.Redis()

async def rate_limit(request: Request):
    user_id = request.headers.get("X-User-ID", "anonymous")
    limiter = RedisSlidingWindowLimiter(
        redis_client, f"user:{user_id}:rate_limit", limit=60, window=60
    )

    if not limiter.acquire():
        raise HTTPException(status_code=429, detail="Rate limit exceeded")

@app.post("/chat")
async def chat(message: str, _: None = Depends(rate_limit)):
    return {"response": f"Echo: {message}"}
```

---

**记住：** 滑动窗口精确但内存占用大，适合需要精确控制的场景。
