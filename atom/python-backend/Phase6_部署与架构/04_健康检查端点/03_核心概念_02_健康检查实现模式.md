# 核心概念2：健康检查实现模式

> 浅层检查 vs 深层检查、同步 vs 异步、缓存策略、超时与重试

---

## 概述

健康检查的实现需要在**准确性**、**性能**、**稳定性**之间做权衡。本文介绍健康检查的核心实现模式。

---

## 1. 浅层检查 vs 深层检查

### 1.1 浅层检查（Shallow Health Check）

**定义：** 只检查服务本身是否响应，不检查依赖服务

**特点：**
- 极快（< 10ms）
- 不依赖外部服务
- 适用于 Liveness Probe

**实现示例：**

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/health")
async def health():
    """
    浅层检查：只检查进程是否响应
    """
    return {"status": "healthy"}
```

**优点：**
- 响应快，不影响性能
- 不会因为依赖服务故障而误报
- 适合高频检查（每 5-10 秒）

**缺点：**
- 无法检测依赖服务故障
- 可能漏报（依赖服务挂了但健康检查通过）

### 1.2 深层检查（Deep Health Check）

**定义：** 检查服务及其所有依赖服务的可用性

**特点：**
- 较慢（几百毫秒到几秒）
- 检查所有依赖服务
- 适用于 Readiness Probe 或手动触发

**实现示例：**

```python
from fastapi import FastAPI, HTTPException
import asyncio

app = FastAPI()

async def check_database() -> bool:
    """检查数据库连接"""
    try:
        await asyncio.wait_for(
            db.execute("SELECT 1"),
            timeout=3.0
        )
        return True
    except Exception:
        return False

async def check_redis() -> bool:
    """检查 Redis 连接"""
    try:
        await asyncio.wait_for(
            redis.ping(),
            timeout=3.0
        )
        return True
    except Exception:
        return False

async def check_llm_api() -> bool:
    """检查 LLM API 可用性"""
    try:
        await asyncio.wait_for(
            llm_client.check_health(),
            timeout=3.0
        )
        return True
    except Exception:
        return False

@app.get("/ready")
async def ready():
    """
    深层检查：检查所有依赖服务
    """
    checks = {
        "database": await check_database(),
        "redis": await check_redis(),
        "llm_api": await check_llm_api(),
    }

    if not all(checks.values()):
        raise HTTPException(
            status_code=503,
            detail={"status": "not_ready", "checks": checks}
        )

    return {"status": "ready", "checks": checks}
```

**优点：**
- 准确（能检测依赖服务故障）
- 避免把流量发给不可用的服务

**缺点：**
- 响应慢，影响性能
- 可能因为短暂抖动而误报
- 不适合高频检查

### 1.3 分层检查策略

**最佳实践：** 结合浅层和深层检查

```python
# 层次1：浅层检查（Liveness）
@app.get("/health")
async def health():
    """只检查进程是否响应"""
    return {"status": "healthy"}

# 层次2：深层检查（Readiness，带缓存）
@app.get("/ready")
async def ready():
    """检查依赖服务（带缓存）"""
    checks = await get_cached_health_status()  # 缓存 30 秒
    if not all(checks.values()):
        raise HTTPException(503)
    return {"status": "ready", "checks": checks}

# 层次3：完整检查（手动触发）
@app.get("/health/deep")
async def deep_health():
    """详细检查，不缓存"""
    return await run_comprehensive_checks()
```

---

## 2. 同步检查 vs 异步检查

### 2.1 同步检查（Synchronous）

**定义：** 健康检查请求到达时，立即执行检查并返回结果

**实现示例：**

```python
@app.get("/ready")
async def ready():
    """同步检查：每次请求都执行检查"""
    # 串行检查（慢）
    db_ok = await check_database()      # 50ms
    redis_ok = await check_redis()      # 30ms
    llm_ok = await check_llm_api()      # 100ms
    # 总耗时：180ms

    if not (db_ok and redis_ok and llm_ok):
        raise HTTPException(503)

    return {"status": "ready"}
```

**优点：**
- 实时准确
- 实现简单

**缺点：**
- 响应慢（需要等待所有检查完成）
- 高频调用会影响性能
- 短暂抖动会导致误报

### 2.2 异步检查（Asynchronous）

**定义：** 后台定期执行检查，健康检查请求直接返回缓存结果

**实现示例：**

```python
import asyncio
from datetime import datetime, timedelta

class AsyncHealthChecker:
    def __init__(self):
        self.status = {
            "healthy": True,
            "checks": {},
            "last_check": datetime.min
        }
        self.checking = False

    async def start(self):
        """启动后台健康检查任务"""
        asyncio.create_task(self._background_check())

    async def _background_check(self):
        """后台定期检查"""
        while True:
            if not self.checking:
                self.checking = True
                try:
                    # 执行检查
                    checks = {
                        "database": await check_database(),
                        "redis": await check_redis(),
                        "llm_api": await check_llm_api(),
                    }

                    # 更新状态
                    self.status = {
                        "healthy": all(checks.values()),
                        "checks": checks,
                        "last_check": datetime.now()
                    }
                finally:
                    self.checking = False

            # 每 30 秒检查一次
            await asyncio.sleep(30)

    def get_status(self) -> dict:
        """获取当前状态（不阻塞）"""
        return self.status

# 使用
health_checker = AsyncHealthChecker()

@app.on_event("startup")
async def startup():
    await health_checker.start()

@app.get("/ready")
async def ready():
    """异步检查：直接返回缓存状态"""
    status = health_checker.get_status()

    if not status["healthy"]:
        raise HTTPException(503, detail=status)

    return status
```

**优点：**
- 响应极快（< 1ms，直接返回缓存）
- 不影响性能
- 平滑短暂抖动

**缺点：**
- 实现复杂
- 可能有延迟（最多 30 秒）
- 需要管理后台任务

### 2.3 混合模式（推荐）

**最佳实践：** 使用缓存 + 定期更新

```python
import time
from typing import Dict, Any

# 健康检查缓存
health_cache: Dict[str, Any] = {
    "last_check": 0,
    "checks": {}
}

CACHE_TTL = 30  # 缓存 30 秒

async def get_health_status() -> Dict[str, Any]:
    """获取健康状态（带缓存）"""
    now = time.time()

    # 如果缓存未过期，直接返回
    if now - health_cache["last_check"] < CACHE_TTL:
        return health_cache

    # 缓存过期，执行检查
    checks = {
        "database": await check_database(),
        "redis": await check_redis(),
        "llm_api": await check_llm_api(),
    }

    # 更新缓存
    health_cache.update({
        "last_check": now,
        "checks": checks
    })

    return health_cache

@app.get("/ready")
async def ready():
    """混合模式：缓存 + 定期更新"""
    status = await get_health_status()
    checks = status["checks"]

    if not all(checks.values()):
        raise HTTPException(503, detail=checks)

    return {"status": "ready", "checks": checks}
```

**优点：**
- 响应快（缓存命中时 < 1ms）
- 实现简单（比纯异步简单）
- 平滑短暂抖动

**缺点：**
- 第一次请求会慢（缓存未命中）
- 可能有延迟（最多 30 秒）

---

## 3. 缓存策略

### 3.1 为什么需要缓存？

**问题场景：**

```python
# 没有缓存的健康检查
@app.get("/ready")
async def ready():
    # 每次都查询数据库
    await db.execute("SELECT 1")  # 50ms
    return {"status": "ready"}

# 如果健康检查每 5 秒调用一次：
# - 每分钟 12 次查询
# - 每小时 720 次查询
# - 每天 17,280 次查询
# 对数据库造成不必要的负担
```

**解决方案：** 缓存健康检查结果

### 3.2 简单缓存实现

```python
import time
from typing import Dict, Any

# 全局缓存
health_cache: Dict[str, Any] = {
    "last_check": 0,
    "status": "unknown",
    "checks": {}
}

CACHE_TTL = 30  # 缓存 30 秒

async def get_cached_health_status() -> Dict[str, Any]:
    """获取健康状态（带缓存）"""
    now = time.time()

    # 检查缓存是否过期
    if now - health_cache["last_check"] < CACHE_TTL:
        # 缓存未过期，直接返回
        return health_cache

    # 缓存过期，执行检查
    checks = {
        "database": await check_database(),
        "redis": await check_redis(),
    }

    # 更新缓存
    health_cache.update({
        "last_check": now,
        "status": "ready" if all(checks.values()) else "not_ready",
        "checks": checks
    })

    return health_cache

@app.get("/ready")
async def ready():
    status = await get_cached_health_status()

    if status["status"] != "ready":
        raise HTTPException(503, detail=status)

    return status
```

### 3.3 分层缓存策略

**不同依赖使用不同的缓存时间：**

```python
from datetime import datetime, timedelta

class HealthChecker:
    def __init__(self):
        self.cache = {
            "database": {"status": None, "expires_at": datetime.min},
            "redis": {"status": None, "expires_at": datetime.min},
            "llm_api": {"status": None, "expires_at": datetime.min},
        }

    async def check_database(self) -> bool:
        """检查数据库（缓存 30 秒）"""
        cache = self.cache["database"]
        now = datetime.now()

        if now < cache["expires_at"]:
            return cache["status"]

        # 执行检查
        try:
            await db.execute("SELECT 1")
            status = True
        except Exception:
            status = False

        # 更新缓存
        self.cache["database"] = {
            "status": status,
            "expires_at": now + timedelta(seconds=30)
        }

        return status

    async def check_redis(self) -> bool:
        """检查 Redis（缓存 60 秒）"""
        cache = self.cache["redis"]
        now = datetime.now()

        if now < cache["expires_at"]:
            return cache["status"]

        # 执行检查
        try:
            await redis.ping()
            status = True
        except Exception:
            status = False

        # 更新缓存
        self.cache["redis"] = {
            "status": status,
            "expires_at": now + timedelta(seconds=60)
        }

        return status

    async def check_llm_api(self) -> bool:
        """检查 LLM API（缓存 120 秒）"""
        cache = self.cache["llm_api"]
        now = datetime.now()

        if now < cache["expires_at"]:
            return cache["status"]

        # 执行检查
        try:
            await llm_client.check_health()
            status = True
        except Exception:
            status = False

        # 更新缓存
        self.cache["llm_api"] = {
            "status": status,
            "expires_at": now + timedelta(seconds=120)
        }

        return status

    async def get_health_status(self) -> dict:
        """获取整体健康状态"""
        checks = {
            "database": await self.check_database(),
            "redis": await self.check_redis(),
            "llm_api": await self.check_llm_api(),
        }
        return checks
```

**缓存时间建议：**

| 依赖服务 | 缓存时间 | 原因 |
|---------|---------|------|
| 数据库 | 30秒 | 核心依赖，需要较快检测故障 |
| Redis | 60秒 | 可选依赖，可以容忍更长延迟 |
| 外部 API | 120秒 | 避免频繁调用外部服务 |

---

## 4. 超时与重试机制

### 4.1 为什么需要超时？

**问题场景：**

```python
# 没有超时的健康检查
@app.get("/ready")
async def ready():
    # 如果数据库响应慢（10 秒），健康检查也会慢
    await db.execute("SELECT 1")  # 可能需要 10 秒
    return {"status": "ready"}

# 问题：
# - 健康检查超时 → Kubernetes 认为服务不健康
# - 但实际上只是数据库慢，不是服务挂了
```

**解决方案：** 设置超时时间

### 4.2 超时实现

```python
import asyncio

async def check_database() -> bool:
    """检查数据库（带超时）"""
    try:
        # 超时 3 秒
        await asyncio.wait_for(
            db.execute("SELECT 1"),
            timeout=3.0
        )
        return True
    except asyncio.TimeoutError:
        # 超时视为不健康
        logger.warning("Database health check timeout")
        return False
    except Exception as e:
        # 其他异常也视为不健康
        logger.error(f"Database health check failed: {e}")
        return False

async def check_redis() -> bool:
    """检查 Redis（带超时）"""
    try:
        await asyncio.wait_for(
            redis.ping(),
            timeout=3.0
        )
        return True
    except asyncio.TimeoutError:
        logger.warning("Redis health check timeout")
        return False
    except Exception as e:
        logger.error(f"Redis health check failed: {e}")
        return False
```

### 4.3 重试机制

**场景：** 短暂的网络抖动导致健康检查失败

```python
async def check_with_retry(
    check_func,
    max_retries: int = 2,
    retry_delay: float = 0.5
) -> bool:
    """带重试的健康检查"""
    for attempt in range(max_retries + 1):
        try:
            result = await asyncio.wait_for(
                check_func(),
                timeout=3.0
            )
            return result
        except Exception as e:
            if attempt < max_retries:
                # 重试前等待
                await asyncio.sleep(retry_delay)
                logger.warning(f"Health check failed, retrying ({attempt + 1}/{max_retries})")
            else:
                # 最后一次重试失败
                logger.error(f"Health check failed after {max_retries} retries: {e}")
                return False

# 使用
async def check_database() -> bool:
    return await check_with_retry(
        lambda: db.execute("SELECT 1"),
        max_retries=2,
        retry_delay=0.5
    )
```

**注意：** 重试会增加健康检查的响应时间，需要权衡。

---

## 5. 健康状态模型

### 5.1 三态模型

**状态定义：**

```python
from enum import Enum

class HealthStatus(str, Enum):
    HEALTHY = "healthy"      # 所有依赖正常
    DEGRADED = "degraded"    # 部分依赖失败，但核心功能可用
    UNHEALTHY = "unhealthy"  # 核心依赖失败，不可用
```

### 5.2 实现示例

```python
@app.get("/ready")
async def ready():
    """三态健康检查"""
    checks = {
        "database": await check_database(),      # 核心依赖
        "redis": await check_redis(),            # 可选依赖
        "llm_api": await check_llm_api(),        # 可选依赖
    }

    # 判断整体状态
    if checks["database"]:
        # 数据库正常
        if checks["redis"] and checks["llm_api"]:
            status = HealthStatus.HEALTHY  # 全部正常
        else:
            status = HealthStatus.DEGRADED  # 部分失败，但可用
    else:
        # 数据库失败
        status = HealthStatus.UNHEALTHY  # 不可用
        raise HTTPException(503, detail={"status": status, "checks": checks})

    return {
        "status": status,
        "checks": checks
    }
```

### 5.3 HTTP 状态码映射

| 健康状态 | HTTP 状态码 | 说明 |
|---------|------------|------|
| HEALTHY | 200 OK | 所有依赖正常 |
| DEGRADED | 200 OK | 部分依赖失败，但可用 |
| UNHEALTHY | 503 Service Unavailable | 核心依赖失败，不可用 |

**为什么 DEGRADED 返回 200？**

- 负载均衡器会继续发送流量
- 服务可以降级运行（如使用缓存）
- 避免因为非核心依赖失败而停止服务

---

## 6. 检查优先级与依赖关系

### 6.1 依赖关系图

```
AI Agent API
  ├── 数据库（核心依赖）
  │   └── 失败 → 服务不可用
  ├── Redis（可选依赖）
  │   └── 失败 → 降级（不使用缓存）
  └── LLM API（可选依赖）
      └── 失败 → 降级（使用缓存响应）
```

### 6.2 实现示例

```python
class DependencyChecker:
    def __init__(self):
        self.dependencies = {
            "database": {"critical": True, "check": check_database},
            "redis": {"critical": False, "check": check_redis},
            "llm_api": {"critical": False, "check": check_llm_api},
        }

    async def check_all(self) -> dict:
        """检查所有依赖"""
        results = {}
        critical_failed = False

        for name, config in self.dependencies.items():
            try:
                status = await config["check"]()
                results[name] = status

                # 如果是核心依赖且失败
                if config["critical"] and not status:
                    critical_failed = True
            except Exception as e:
                logger.error(f"Failed to check {name}: {e}")
                results[name] = False

                if config["critical"]:
                    critical_failed = True

        return {
            "checks": results,
            "critical_failed": critical_failed
        }

# 使用
checker = DependencyChecker()

@app.get("/ready")
async def ready():
    result = await checker.check_all()

    if result["critical_failed"]:
        raise HTTPException(503, detail=result)

    # 核心依赖正常，但可能有可选依赖失败
    status = "healthy" if all(result["checks"].values()) else "degraded"

    return {
        "status": status,
        "checks": result["checks"]
    }
```

---

## 7. 在 AI Agent 后端中的应用

### 7.1 完整实现

```python
from fastapi import FastAPI, HTTPException
from enum import Enum
import asyncio
import time
from typing import Dict, Any

app = FastAPI()

class HealthStatus(str, Enum):
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"

class HealthChecker:
    def __init__(self):
        self.cache = {
            "last_check": 0,
            "checks": {}
        }
        self.cache_ttl = 30

    async def check_database(self) -> bool:
        """检查数据库（核心依赖）"""
        try:
            await asyncio.wait_for(
                db.execute("SELECT 1"),
                timeout=3.0
            )
            return True
        except Exception:
            return False

    async def check_redis(self) -> bool:
        """检查 Redis（可选依赖）"""
        try:
            await asyncio.wait_for(
                redis.ping(),
                timeout=3.0
            )
            return True
        except Exception:
            return False

    async def check_llm_api(self) -> bool:
        """检查 LLM API（可选依赖）"""
        try:
            await asyncio.wait_for(
                llm_client.check_health(),
                timeout=3.0
            )
            return True
        except Exception:
            return False

    async def get_health_status(self) -> Dict[str, Any]:
        """获取健康状态（带缓存）"""
        now = time.time()

        # 检查缓存
        if now - self.cache["last_check"] < self.cache_ttl:
            return self.cache

        # 并发检查所有依赖
        results = await asyncio.gather(
            self.check_database(),
            self.check_redis(),
            self.check_llm_api(),
            return_exceptions=True
        )

        checks = {
            "database": results[0] if not isinstance(results[0], Exception) else False,
            "redis": results[1] if not isinstance(results[1], Exception) else False,
            "llm_api": results[2] if not isinstance(results[2], Exception) else False,
        }

        # 更新缓存
        self.cache = {
            "last_check": now,
            "checks": checks
        }

        return self.cache

health_checker = HealthChecker()

@app.get("/health")
async def health():
    """浅层检查：只检查进程是否响应"""
    return {"status": "healthy"}

@app.get("/ready")
async def ready():
    """深层检查：检查依赖服务（带缓存）"""
    status_data = await health_checker.get_health_status()
    checks = status_data["checks"]

    # 判断整体状态
    if checks["database"]:
        # 数据库正常
        if checks["redis"] and checks["llm_api"]:
            status = HealthStatus.HEALTHY
        else:
            status = HealthStatus.DEGRADED
    else:
        # 数据库失败
        status = HealthStatus.UNHEALTHY
        raise HTTPException(
            status_code=503,
            detail={
                "status": status,
                "checks": checks,
                "message": "Database unavailable"
            }
        )

    return {
        "status": status,
        "checks": checks,
        "cached": time.time() - status_data["last_check"] < health_checker.cache_ttl
    }
```

---

## 总结

健康检查实现模式的关键要点：

1. **浅层 vs 深层**：Liveness 用浅层，Readiness 用深层
2. **同步 vs 异步**：推荐使用缓存 + 定期更新的混合模式
3. **缓存策略**：不同依赖使用不同的缓存时间
4. **超时机制**：所有依赖检查都要设置超时
5. **健康状态**：使用三态模型（健康/降级/不健康）
6. **依赖关系**：区分核心依赖和可选依赖

在 AI Agent 后端中，合理的健康检查实现可以：
- 快速检测故障（浅层检查）
- 准确判断可用性（深层检查 + 缓存）
- 避免误报（超时 + 重试）
- 支持降级运行（三态模型）
