# 实战代码2：重试装饰器实现

**场景：** 手写重试装饰器，支持指数退避和条件重试

---

## 完整代码

```python
"""
重试装饰器实现
支持：指数退避、随机抖动、条件重试
"""

import asyncio
import random
from typing import TypeVar, Callable, Awaitable, Type, Tuple
from functools import wraps

T = TypeVar('T')

def async_retry(
    max_attempts: int = 3,
    initial_delay: float = 1.0,
    max_delay: float = 10.0,
    jitter: bool = True,
    retry_on: Tuple[Type[Exception], ...] = (Exception,)
):
    """
    异步重试装饰器

    参数:
        max_attempts: 最大重试次数
        initial_delay: 初始延迟（秒）
        max_delay: 最大延迟（秒）
        jitter: 是否添加随机抖动
        retry_on: 可重试的异常类型
    """
    def decorator(func: Callable[..., Awaitable[T]]) -> Callable[..., Awaitable[T]]:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> T:
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except retry_on as e:
                    if attempt == max_attempts - 1:
                        raise

                    # 指数退避
                    delay = initial_delay * (2 ** attempt)

                    # 添加随机抖动
                    if jitter:
                        delay *= (0.5 + random.random())

                    # 限制最大延迟
                    delay = min(delay, max_delay)

                    print(f"重试 {attempt + 1}/{max_attempts}，等待 {delay:.2f}s")
                    await asyncio.sleep(delay)
                except Exception as e:
                    # 不可重试的异常，直接抛出
                    raise
        return wrapper
    return decorator

# ===== 使用示例 =====
from openai import AsyncOpenAI, Timeout, RateLimitError

client = AsyncOpenAI()

@async_retry(
    max_attempts=3,
    initial_delay=1.0,
    max_delay=10.0,
    jitter=True,
    retry_on=(Timeout, RateLimitError)
)
async def call_llm(prompt: str) -> str:
    """调用 LLM（自动重试）"""
    response = await client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        timeout=30.0
    )
    return response.choices[0].message.content

# ===== 测试 =====
async def main():
    # 测试1：正常调用
    print("=== 测试1：正常调用 ===")
    response = await call_llm("你好")
    print(f"响应: {response}")

    # 测试2：模拟超时（会重试）
    print("\n=== 测试2：模拟超时 ===")
    try:
        @async_retry(max_attempts=3, retry_on=(TimeoutError,))
        async def slow_operation():
            await asyncio.sleep(0.1)
            raise TimeoutError("模拟超时")

        await slow_operation()
    except TimeoutError:
        print("重试3次后仍然失败")

    # 测试3：不可重试的异常
    print("\n=== 测试3：不可重试的异常 ===")
    try:
        @async_retry(max_attempts=3, retry_on=(TimeoutError,))
        async def invalid_operation():
            raise ValueError("参数错误")

        await invalid_operation()
    except ValueError:
        print("不可重试的异常，立即抛出")

if __name__ == "__main__":
    asyncio.run(main())
```

---

## 运行输出

```bash
python retry_decorator.py

# 输出：
=== 测试1：正常调用 ===
响应: 你好！有什么我可以帮助你的吗？

=== 测试2：模拟超时 ===
重试 1/3，等待 0.87s
重试 2/3，等待 1.53s
重试3次后仍然失败

=== 测试3：不可重试的异常 ===
不可重试的异常，立即抛出
```
