# 实战代码 - 场景 3: 混合检索与过滤

本文档展示如何结合向量检索和标量过滤，实现更精准的检索结果。

---

## 场景描述

**目标**: 实现向量相似度检索 + 标量字段过滤的混合检索

**核心技术**:
- 向量相似度检索（语义搜索）
- 标量字段过滤（条件筛选）
- expr 表达式语法

**适用场景**:
- 文档分类检索（按类别、标签过滤）
- 时间范围检索（按时间戳过滤）
- 权限控制检索（按用户权限过滤）
- 多条件组合检索

---

## 完整代码实现

### 环境准备

```python
# 安装依赖
# pip install pymilvus numpy

from pymilvus import (
    connections,
    Collection,
    FieldSchema,
    CollectionSchema,
    DataType,
    utility
)
import numpy as np
import time
from typing import List, Dict
```

---

## 第一部分: 创建带元数据的 Collection

### 1. 定义丰富的 Schema

```python
def create_collection_with_metadata(collection_name: str = "hybrid_search_demo"):
    """
    创建带有丰富元数据的 Collection
    """
    print("=" * 60)
    print("步骤 1: 创建带元数据的 Collection")
    print("=" * 60)

    connections.connect(host="localhost", port="19530")

    # 删除旧 Collection
    if utility.has_collection(collection_name):
        utility.drop_collection(collection_name)

    # 定义 Schema（包含多个标量字段）
    fields = [
        # 主键
        FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),

        # 向量字段
        FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=128),

        # 标量字段（元数据）
        FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=2000),
        FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=50),
        FieldSchema(name="author", dtype=DataType.VARCHAR, max_length=100),
        FieldSchema(name="publish_year", dtype=DataType.INT64),
        FieldSchema(name="rating", dtype=DataType.FLOAT),
        FieldSchema(name="view_count", dtype=DataType.INT64),
        FieldSchema(name="is_featured", dtype=DataType.BOOL),
    ]

    schema = CollectionSchema(
        fields=fields,
        description="Collection with rich metadata for hybrid search"
    )

    collection = Collection(collection_name, schema)

    print(f"✓ 成功创建 Collection: {collection_name}")
    print(f"\n字段列表:")
    print(f"  - id: 主键 (auto_id=True)")
    print(f"  - embedding: 向量字段 (dim=128)")
    print(f"  - text: 文本内容")
    print(f"  - category: 分类 (technology, science, art, etc.)")
    print(f"  - author: 作者")
    print(f"  - publish_year: 发布年份")
    print(f"  - rating: 评分 (0-5)")
    print(f"  - view_count: 浏览次数")
    print(f"  - is_featured: 是否精选")
    print()

    return collection
```

---

### 2. 插入带元数据的数据

```python
def insert_data_with_metadata(collection: Collection, num_entities: int = 1000):
    """
    插入带有丰富元数据的数据
    """
    print("=" * 60)
    print("步骤 2: 插入带元数据的数据")
    print("=" * 60)

    # 定义分类和作者列表
    categories = ["technology", "science", "art", "history", "literature"]
    authors = ["Alice", "Bob", "Charlie", "David", "Eve"]

    # 生成数据
    embeddings = np.random.rand(num_entities, 128).tolist()
    texts = [f"这是第 {i} 篇文章的内容..." for i in range(num_entities)]
    categories_list = [categories[i % len(categories)] for i in range(num_entities)]
    authors_list = [authors[i % len(authors)] for i in range(num_entities)]
    publish_years = [2020 + (i % 5) for i in range(num_entities)]  # 2020-2024
    ratings = [round(3.0 + (i % 21) * 0.1, 1) for i in range(num_entities)]  # 3.0-5.0
    view_counts = [100 + i * 10 for i in range(num_entities)]
    is_featured_list = [i % 5 == 0 for i in range(num_entities)]  # 每 5 个有 1 个精选

    # 准备插入数据
    data = [
        embeddings,
        texts,
        categories_list,
        authors_list,
        publish_years,
        ratings,
        view_counts,
        is_featured_list
    ]

    # 插入数据
    print(f"插入 {num_entities} 条数据...")
    start_time = time.time()
    result = collection.insert(data)
    insert_time = time.time() - start_time

    print(f"✓ 成功插入 {len(result.primary_keys)} 条数据")
    print(f"  - 耗时: {insert_time:.3f} 秒")
    print()

    # 刷新数据
    print("刷新数据到磁盘...")
    collection.flush()
    print(f"✓ 数据已刷新，共 {collection.num_entities} 条\n")

    # 打印数据分布
    print("数据分布:")
    print(f"  - 分类: {', '.join(categories)}")
    print(f"  - 作者: {', '.join(authors)}")
    print(f"  - 年份: 2020-2024")
    print(f"  - 评分: 3.0-5.0")
    print(f"  - 精选比例: 20%")
    print()

    return result
```

---

### 3. 创建索引并加载

```python
def create_index_and_load(collection: Collection):
    """
    创建索引并加载到内存
    """
    print("=" * 60)
    print("步骤 3: 创建索引并加载")
    print("=" * 60)

    # 创建 HNSW 索引
    index_params = {
        "index_type": "HNSW",
        "metric_type": "COSINE",
        "params": {"M": 16, "efConstruction": 256}
    }

    print("创建 HNSW 索引...")
    collection.create_index("embedding", index_params)
    print("✓ 索引创建完成\n")

    # 加载到内存
    print("加载 Collection 到内存...")
    collection.load()
    print("✓ Collection 已加载\n")
```

---

## 第二部分: 基础向量检索（无过滤）

```python
def basic_vector_search(collection: Collection):
    """
    基础向量检索（无过滤）
    """
    print("=" * 60)
    print("测试 1: 基础向量检索（无过滤）")
    print("=" * 60)

    # 生成查询向量
    query_vector = np.random.rand(128).tolist()

    # 定义检索参数
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    # 执行检索
    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=10,
        output_fields=["text", "category", "author", "publish_year", "rating"]
    )

    # 打印结果
    print(f"\n检索结果 (Top-10):")
    print("-" * 60)
    for i, hit in enumerate(results[0]):
        print(f"{i+1}. 相似度: {hit.score:.4f}")
        print(f"   分类: {hit.entity.get('category')}")
        print(f"   作者: {hit.entity.get('author')}")
        print(f"   年份: {hit.entity.get('publish_year')}")
        print(f"   评分: {hit.entity.get('rating')}")
        print()
```

**输出示例**:
```
==============================================================
测试 1: 基础向量检索（无过滤）
==============================================================

检索结果 (Top-10):
--------------------------------------------------------------
1. 相似度: 0.8234
   分类: technology
   作者: Alice
   年份: 2023
   评分: 4.5

2. 相似度: 0.8102
   分类: science
   作者: Bob
   年份: 2022
   评分: 4.2

3. 相似度: 0.7998
   分类: art
   作者: Charlie
   年份: 2024
   评分: 3.8
...
```

---

## 第三部分: 单条件过滤检索

### 1. 按分类过滤

```python
def search_by_category(collection: Collection, category: str = "technology"):
    """
    按分类过滤检索
    """
    print("=" * 60)
    print(f"测试 2: 按分类过滤 (category == '{category}')")
    print("=" * 60)

    query_vector = np.random.rand(128).tolist()
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    # 使用 expr 过滤
    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=10,
        expr=f"category == '{category}'",  # 过滤条件
        output_fields=["text", "category", "author", "rating"]
    )

    print(f"\n检索结果 (只包含 {category} 分类):")
    print("-" * 60)
    for i, hit in enumerate(results[0]):
        print(f"{i+1}. 相似度: {hit.score:.4f}, 分类: {hit.entity.get('category')}, "
              f"作者: {hit.entity.get('author')}, 评分: {hit.entity.get('rating')}")
    print()
```

---

### 2. 按年份过滤

```python
def search_by_year(collection: Collection, min_year: int = 2022):
    """
    按年份过滤检索
    """
    print("=" * 60)
    print(f"测试 3: 按年份过滤 (publish_year >= {min_year})")
    print("=" * 60)

    query_vector = np.random.rand(128).tolist()
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    # 使用 expr 过滤
    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=10,
        expr=f"publish_year >= {min_year}",  # 过滤条件
        output_fields=["text", "category", "publish_year", "rating"]
    )

    print(f"\n检索结果 (只包含 {min_year} 年及以后的文章):")
    print("-" * 60)
    for i, hit in enumerate(results[0]):
        print(f"{i+1}. 相似度: {hit.score:.4f}, 年份: {hit.entity.get('publish_year')}, "
              f"分类: {hit.entity.get('category')}, 评分: {hit.entity.get('rating')}")
    print()
```

---

### 3. 按评分过滤

```python
def search_by_rating(collection: Collection, min_rating: float = 4.0):
    """
    按评分过滤检索
    """
    print("=" * 60)
    print(f"测试 4: 按评分过滤 (rating >= {min_rating})")
    print("=" * 60)

    query_vector = np.random.rand(128).tolist()
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    # 使用 expr 过滤
    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=10,
        expr=f"rating >= {min_rating}",  # 过滤条件
        output_fields=["text", "category", "author", "rating"]
    )

    print(f"\n检索结果 (只包含评分 >= {min_rating} 的文章):")
    print("-" * 60)
    for i, hit in enumerate(results[0]):
        print(f"{i+1}. 相似度: {hit.score:.4f}, 评分: {hit.entity.get('rating')}, "
              f"作者: {hit.entity.get('author')}, 分类: {hit.entity.get('category')}")
    print()
```

---

### 4. 按布尔字段过滤

```python
def search_featured_only(collection: Collection):
    """
    只检索精选文章
    """
    print("=" * 60)
    print("测试 5: 只检索精选文章 (is_featured == true)")
    print("=" * 60)

    query_vector = np.random.rand(128).tolist()
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    # 使用 expr 过滤
    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=10,
        expr="is_featured == true",  # 过滤条件
        output_fields=["text", "category", "author", "rating", "is_featured"]
    )

    print(f"\n检索结果 (只包含精选文章):")
    print("-" * 60)
    for i, hit in enumerate(results[0]):
        print(f"{i+1}. 相似度: {hit.score:.4f}, 精选: {hit.entity.get('is_featured')}, "
              f"作者: {hit.entity.get('author')}, 评分: {hit.entity.get('rating')}")
    print()
```

---

## 第四部分: 多条件组合过滤

### 1. AND 组合

```python
def search_with_and_conditions(collection: Collection):
    """
    多条件 AND 组合过滤
    """
    print("=" * 60)
    print("测试 6: 多条件 AND 组合")
    print("条件: category == 'technology' AND rating >= 4.0 AND publish_year >= 2022")
    print("=" * 60)

    query_vector = np.random.rand(128).tolist()
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    # 多条件 AND 组合
    expr = "category == 'technology' and rating >= 4.0 and publish_year >= 2022"

    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=10,
        expr=expr,
        output_fields=["text", "category", "author", "publish_year", "rating"]
    )

    print(f"\n检索结果 (满足所有条件):")
    print("-" * 60)
    for i, hit in enumerate(results[0]):
        print(f"{i+1}. 相似度: {hit.score:.4f}")
        print(f"   分类: {hit.entity.get('category')}")
        print(f"   年份: {hit.entity.get('publish_year')}")
        print(f"   评分: {hit.entity.get('rating')}")
        print(f"   作者: {hit.entity.get('author')}")
        print()
```

---

### 2. OR 组合

```python
def search_with_or_conditions(collection: Collection):
    """
    多条件 OR 组合过滤
    """
    print("=" * 60)
    print("测试 7: 多条件 OR 组合")
    print("条件: category == 'technology' OR category == 'science'")
    print("=" * 60)

    query_vector = np.random.rand(128).tolist()
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    # 多条件 OR 组合
    expr = "category == 'technology' or category == 'science'"

    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=10,
        expr=expr,
        output_fields=["text", "category", "author", "rating"]
    )

    print(f"\n检索结果 (满足任一条件):")
    print("-" * 60)
    for i, hit in enumerate(results[0]):
        print(f"{i+1}. 相似度: {hit.score:.4f}, 分类: {hit.entity.get('category')}, "
              f"作者: {hit.entity.get('author')}, 评分: {hit.entity.get('rating')}")
    print()
```

---

### 3. 复杂组合

```python
def search_with_complex_conditions(collection: Collection):
    """
    复杂条件组合过滤
    """
    print("=" * 60)
    print("测试 8: 复杂条件组合")
    print("条件: (category == 'technology' OR category == 'science') AND rating >= 4.0")
    print("=" * 60)

    query_vector = np.random.rand(128).tolist()
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    # 复杂条件组合
    expr = "(category == 'technology' or category == 'science') and rating >= 4.0"

    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=10,
        expr=expr,
        output_fields=["text", "category", "author", "rating"]
    )

    print(f"\n检索结果 (满足复杂条件):")
    print("-" * 60)
    for i, hit in enumerate(results[0]):
        print(f"{i+1}. 相似度: {hit.score:.4f}, 分类: {hit.entity.get('category')}, "
              f"评分: {hit.entity.get('rating')}, 作者: {hit.entity.get('author')}")
    print()
```

---

## 第五部分: IN 操作符

```python
def search_with_in_operator(collection: Collection):
    """
    使用 IN 操作符过滤
    """
    print("=" * 60)
    print("测试 9: IN 操作符")
    print("条件: category in ['technology', 'science', 'art']")
    print("=" * 60)

    query_vector = np.random.rand(128).tolist()
    search_params = {"metric_type": "COSINE", "params": {"ef": 64}}

    # 使用 IN 操作符
    expr = "category in ['technology', 'science', 'art']"

    results = collection.search(
        data=[query_vector],
        anns_field="embedding",
        param=search_params,
        limit=10,
        expr=expr,
        output_fields=["text", "category", "author", "rating"]
    )

    print(f"\n检索结果 (分类在指定列表中):")
    print("-" * 60)
    for i, hit in enumerate(results[0]):
        print(f"{i+1}. 相似度: {hit.score:.4f}, 分类: {hit.entity.get('category')}, "
              f"作者: {hit.entity.get('author')}, 评分: {hit.entity.get('rating')}")
    print()
```

---

## 完整测试脚本

```python
"""
Milvus 混合检索与过滤 - 完整示例
"""

def main():
    """
    主函数：完整的混合检索测试流程
    """
    print("=" * 80)
    print("Milvus 混合检索与过滤 - 完整测试")
    print("=" * 80)
    print()

    # 1. 创建 Collection
    collection = create_collection_with_metadata()

    # 2. 插入数据
    insert_data_with_metadata(collection, num_entities=1000)

    # 3. 创建索引并加载
    create_index_and_load(collection)

    # 4. 基础向量检索
    basic_vector_search(collection)

    # 5. 单条件过滤
    search_by_category(collection, "technology")
    search_by_year(collection, 2022)
    search_by_rating(collection, 4.0)
    search_featured_only(collection)

    # 6. 多条件组合
    search_with_and_conditions(collection)
    search_with_or_conditions(collection)
    search_with_complex_conditions(collection)

    # 7. IN 操作符
    search_with_in_operator(collection)

    # 8. 清理
    print("=" * 60)
    print("清理资源")
    print("=" * 60)
    collection.release()
    print("✓ Collection 已从内存释放\n")

    print("=" * 80)
    print("所有测试完成！")
    print("=" * 80)


if __name__ == "__main__":
    main()
```

---

## expr 表达式语法总结

### 比较操作符

| 操作符 | 说明 | 示例 |
|--------|------|------|
| == | 等于 | `category == 'tech'` |
| != | 不等于 | `category != 'sports'` |
| > | 大于 | `rating > 4.0` |
| < | 小于 | `rating < 3.0` |
| >= | 大于等于 | `publish_year >= 2020` |
| <= | 小于等于 | `view_count <= 1000` |

### 逻辑操作符

| 操作符 | 说明 | 示例 |
|--------|------|------|
| and | 与 | `category == 'tech' and rating > 4.0` |
| or | 或 | `category == 'tech' or category == 'science'` |
| not | 非 | `not (category == 'sports')` |

### 成员操作符

| 操作符 | 说明 | 示例 |
|--------|------|------|
| in | 包含 | `category in ['tech', 'science']` |
| not in | 不包含 | `category not in ['sports', 'entertainment']` |

---

## 关键要点总结

### 1. expr 语法规则

- 字符串必须用单引号 `'value'`
- 字段名不需要引号
- 支持括号改变优先级

### 2. 性能影响

- 过滤条件越严格，检索越快
- 建议先用标量过滤缩小范围，再做向量检索

### 3. RAG 应用场景

- 按文档类型过滤
- 按时间范围过滤
- 按权限级别过滤
- 按标签组合过滤

---

## 下一步

学习 **实战代码 - 场景 4: RAG 文档检索系统**，了解如何构建完整的 RAG 应用。
