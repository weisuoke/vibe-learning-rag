# 化骨绵掌

> **10 张知识卡片，每张 2 分钟，快速掌握 MCP Server 集成核心概念**

---

## 使用说明

**化骨绵掌**是一种快速记忆法，通过精炼的知识卡片帮助你在短时间内掌握核心概念。

**使用方法**：
- 每张卡片阅读时间：2 分钟
- 总计时间：20 分钟
- 适合场景：面试前复习、快速回顾、知识巩固

---

## 卡片 1：MCP 是什么？

### 核心定义

**MCP（Model Context Protocol）= AI 的 USB-C 标准**

```
问题：AI Agent 需要与外部世界交互
现状：每个平台都有自己的集成方案 → 碎片化
解决：MCP 提供统一的开放标准
```

### 三个核心抽象

```
Tools（工具）     → 可执行的操作（如查询数据库）
Resources（资源） → 可访问的数据（如文件内容）
Events（事件）    → 实时通知（如进度更新）
```

### 关键特性

- **标准化**：基于 JSON-RPC 2.0
- **动态发现**：运行时查询可用工具
- **语义清晰**：详细的描述和 Schema
- **开放生态**：一次实现，多处使用

### 记忆口诀

> "USB-C 连设备，MCP 连工具，统一标准促生态"

---

## 卡片 2：为什么需要 MCP？

### 问题本质

**N × M 复杂度困境**：

```
没有 MCP：
├─ N 个 AI 平台
├─ M 个工具
└─ 需要 N × M 个集成实现

有了 MCP：
├─ N 个 AI 平台实现 MCP Client
├─ M 个工具实现 MCP Server
└─ 只需 N + M 个实现
```

### 价值链

```
统一协议
    ↓
降低集成复杂度
    ↓
促进生态繁荣
    ↓
加速 AI 应用开发
    ↓
更强大的 AI Agent
```

### 对比传统方案

| 维度 | 传统方案 | MCP |
|------|---------|-----|
| 集成复杂度 | N × M | N + M |
| 发现方式 | 静态文档 | 动态查询 |
| 跨平台 | 否 | 是 |
| 生态系统 | 割裂 | 统一 |

### 记忆口诀

> "碎片化是病，标准化是药，MCP 降复杂度"

---

## 卡片 3：MCP 协议基础

### JSON-RPC 2.0

**为什么选择 JSON-RPC 2.0？**

- ✅ 简单：100% JSON
- ✅ 成熟：LSP 验证过
- ✅ 完整：请求/响应/通知/错误
- ✅ 类型安全：强类型方法

### 消息格式

```json
// 请求（需要响应）
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": { "name": "search", "arguments": {...} }
}

// 通知（不需要响应）
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized",
  "params": {}
}
```

### 单一端点哲学

```
所有操作通过：
POST /mcp  （请求/响应）
GET  /mcp  （流式事件）
```

**优势**：简单、通用、易于配置

### 记忆口诀

> "JSON-RPC 是基础，单一端点是哲学"

---

## 卡片 4：两步握手机制

### 为什么需要两步？

**Step 1: initialize（能力协商）**

```typescript
客户端 → 服务器：我支持这些能力
服务器 → 客户端：我支持这些能力 + Session ID
```

**目的**：
- 协议版本检查
- 能力协商
- 创建会话

**Step 2: notifications/initialized（就绪通知）**

```typescript
客户端 → 服务器：我准备好了，可以推送事件了
```

**目的**：
- 避免竞态条件
- 防止过早推送
- 确定性协议

### 完整流程

```
1. Client → initialize
2. Server → 返回 capabilities + sessionId
3. Client → notifications/initialized
4. Server → 开始推送事件
5. Client → 调用工具（tools/call）
```

### 记忆口诀

> "两步握手保可靠，先协商后就绪"

---

## 卡片 5：Tools 工具设计

### 工具的本质

**Tools = 可执行的操作**

```typescript
interface Tool {
  name: string;              // 工具名称
  description: string;       // 详细描述（给 AI 看）
  inputSchema: JSONSchema;   // 参数定义
}
```

### 设计原则

**1. 语义清晰**：
```typescript
// ❌ 错误
name: "query"
description: "Query data"

// ✅ 正确
name: "search_user_profiles"
description: "Searches user profiles by name, email, or ID. Use this when you need to find user information. Returns name, email, and registration date."
```

**2. 职责单一**：
- 一个工具做一件事
- 避免通用工具（如 database_operation）
- 拆分复杂操作为多个工具

**3. 描述详细**：
- 说明用途（做什么）
- 说明时机（何时用）
- 说明输入（需要什么）
- 说明输出（返回什么）
- 说明限制（注意事项）

### 记忆口诀

> "描述比实现重要，清晰比简洁重要"

---

## 卡片 6：Resources 资源管理

### 资源的本质

**Resources = 可访问的数据源**

```typescript
interface Resource {
  uri: string;               // 资源标识符
  name: string;              // 资源名称
  description: string;       // 资源描述
  mimeType?: string;         // 内容类型
}
```

### URI 设计

```
标准 URI 格式：
├─ file:///path/to/file.txt    （文件系统）
├─ mem://cache/data            （内存）
├─ db://users/table            （数据库）
└─ http://api.example.com/data （HTTP）
```

### 使用流程

```
1. resources/list  → 查看可用资源
2. resources/read  → 读取资源内容
3. 监听 resources/listChanged → 资源变更通知
```

### 与 Tools 的区别

| 维度 | Tools | Resources |
|------|-------|-----------|
| 本质 | 操作 | 数据 |
| 用途 | 执行动作 | 提供上下文 |
| 示例 | 查询数据库 | 文件内容 |

### 记忆口诀

> "Tools 是动词，Resources 是名词"

---

## 卡片 7：Events 事件系统

### 事件的本质

**Events = 服务器主动推送的通知**

### 为什么需要 SSE？

**SSE vs WebSocket**：

| 维度 | SSE | WebSocket |
|------|-----|-----------|
| 通信方向 | 单向（Server → Client） | 双向 |
| 协议 | HTTP | 独立协议 |
| 复杂度 | 低 | 高 |
| 重连 | 自动 | 手动 |

**MCP 选择 SSE**：因为只需要服务器推送

### 常见事件类型

```typescript
// 日志消息
{
  method: "notifications/message",
  params: { level: "info", data: "..." }
}

// 工具列表变更
{
  method: "notifications/tools/listChanged"
}

// 资源列表变更
{
  method: "notifications/resources/listChanged"
}
```

### 使用场景

- 长时间运行的工具进度更新
- 实时日志输出
- 资源变更通知
- Agent 事件驱动循环

### 记忆口诀

> "SSE 单向推，事件驱动 Agent"

---

## 卡片 8：三种集成模式

### 模式 1：使用现有 MCP Server

**场景**：快速集成社区工具

```json
// settings.json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/data"]
    }
  }
}
```

**优势**：最快，无需开发

### 模式 2：构建自定义 MCP Server

**场景**：提供专有工具

```typescript
const server = new Server({ name: "my-server" }, { capabilities: { tools: {} } });
server.setRequestHandler(ListToolsRequestSchema, ...);
server.setRequestHandler(CallToolRequestSchema, ...);
await server.connect(transport);
```

**优势**：完全控制，可复用

### 模式 3：创建 Pi-mono Extension

**场景**：集成 MCP 到 pi-mono

```typescript
export async function activate(api: ExtensionAPI) {
  const client = new Client(...);
  await client.connect(transport);
  const { tools } = await client.listTools();
  // 注册工具到 pi-mono
}
```

**优势**：无缝集成，扩展能力

### 决策树

```
有现成 Server？
├─ 是 → 模式 1（使用现有）
└─ 否 → 需要深度定制？
    ├─ 是 → 模式 2（构建 Server）
    └─ 否 → 模式 3（创建 Extension）
```

### 记忆口诀

> "用、建、集，三种模式各有场景"

---

## 卡片 9：常见陷阱

### 陷阱 1：stdout 输出日志

```typescript
// ❌ 错误：破坏协议
console.log("Debug info");

// ✅ 正确：使用 stderr
console.error("Debug info");
```

**原因**：stdout 是协议通信通道

### 陷阱 2：描述过于简单

```typescript
// ❌ 错误：AI 不知道何时使用
{
  name: "query",
  description: "Query data"
}

// ✅ 正确：详细说明
{
  name: "search_users",
  description: "Searches user profiles by name, email, or ID. Use this when you need to find user information. Returns name, email, and registration date."
}
```

**原因**：描述是 AI 的唯一信息源

### 陷阱 3：REST 思维

```typescript
// ❌ 错误：模仿 REST
name: "GET_users"
name: "POST_users"

// ✅ 正确：语义清晰
name: "list_users"
name: "create_user"
```

**原因**：MCP 是为 AI 设计的，不是 REST API

### 记忆口诀

> "stderr 日志，详细描述，语义命名"

---

## 卡片 10：快速参考

### 核心 API

**Server 端**：
```typescript
// 创建 Server
const server = new Server(info, capabilities);

// 注册处理器
server.setRequestHandler(ListToolsRequestSchema, handler);
server.setRequestHandler(CallToolRequestSchema, handler);

// 发送通知
server.sendNotification({ method, params });

// 连接传输层
await server.connect(transport);
```

**Client 端**：
```typescript
// 创建 Client
const client = new Client(info, capabilities);

// 连接 Server
await client.connect(transport);

// 调用方法
const { tools } = await client.listTools();
const result = await client.callTool({ name, arguments });
```

### 调试工具

```bash
# MCP Inspector
npx @modelcontextprotocol/inspector <server-command>
```

### 配置文件

```json
// settings.json（Pi-mono）
{
  "mcpServers": {
    "server-name": {
      "command": "command",
      "args": ["arg1", "arg2"]
    }
  }
}
```

### 记忆口诀

> "Server 注册处理器，Client 调用方法，Inspector 调试"

---

## 知识卡片使用技巧

### 第一遍：快速浏览（10 分钟）

- 只看"核心定义"和"记忆口诀"
- 建立整体框架
- 标记不理解的卡片

### 第二遍：深入理解（20 分钟）

- 仔细阅读每张卡片
- 理解代码示例
- 思考实际应用场景

### 第三遍：主动回忆（10 分钟）

- 遮住内容，只看标题
- 尝试回忆核心内容
- 检查遗漏的知识点

### 第四遍：实践应用（不限时）

- 构建一个简单的 MCP Server
- 使用 MCP Inspector 调试
- 集成到实际项目中

---

## 知识关联图

```
MCP Server 集成知识体系：

卡片 1（MCP 是什么）
    ↓
卡片 2（为什么需要 MCP）
    ↓
卡片 3（MCP 协议基础）
    ↓
卡片 4（两步握手机制）
    ↓
卡片 5（Tools 工具设计）
    ↓
卡片 6（Resources 资源管理）
    ↓
卡片 7（Events 事件系统）
    ↓
卡片 8（三种集成模式）
    ↓
卡片 9（常见陷阱）
    ↓
卡片 10（快速参考）
```

---

## 记忆检查清单

完成所有卡片后，检查你是否能回答以下问题：

**基础概念**：
- [ ] MCP 是什么？解决什么问题？
- [ ] MCP 的三个核心抽象是什么？
- [ ] 为什么选择 JSON-RPC 2.0？

**协议细节**：
- [ ] 两步握手的目的是什么？
- [ ] 为什么使用 SSE 而不是 WebSocket？
- [ ] stdout 为什么不能用于日志？

**实践应用**：
- [ ] 如何设计一个好的工具描述？
- [ ] 三种集成模式分别适用于什么场景？
- [ ] 如何调试 MCP Server？

**常见陷阱**：
- [ ] 为什么不能用 REST 思维设计 MCP？
- [ ] 工具描述为什么比实现重要？
- [ ] 如何避免破坏协议通信？

---

## 下一步行动

根据你的掌握程度选择：

**掌握度 < 60%**：
→ 重新阅读 [02_第一性原理](./02_第一性原理.md) 和 [04_最小可用](./04_最小可用.md)

**掌握度 60-80%**：
→ 阅读 [03_核心概念](./03_核心概念_01_MCP协议基础.md) 系列深入理解

**掌握度 > 80%**：
→ 阅读 [07_实战代码](./07_实战代码_01_简单MCP_Server.md) 系列动手实践

---

**恭喜**：你已经通过 10 张知识卡片快速掌握了 MCP Server 集成的核心概念！

**记住**：知识需要实践才能真正掌握。建议立即动手构建一个简单的 MCP Server，将理论转化为实践。
