# 03_核心概念_01_函数包装

> **本文档深入讲解 RunnableLambda 的函数包装机制，从 callable 到 Runnable 的转换过程。**

---

## 核心问题

**如何将普通 Python 函数转换为 Runnable 组件？**

这是 RunnableLambda 要解决的核心问题。本文档将深入探讨：
- 包装机制的实现原理
- 参数传递的处理方式
- 类型转换的细节
- 与 LCEL 管道的集成

---

## 基础包装机制

### 从 callable 到 Runnable

**核心转换：**

```python
# 输入：普通 Python 函数
def my_function(x: int) -> int:
    return x * 2

# 输出：Runnable 对象
runnable = RunnableLambda(my_function)

# 现在有了 Runnable 的所有能力
runnable.invoke(5)        # 10
runnable.batch([1, 2, 3]) # [2, 4, 6]
```

**转换过程：**

```
普通函数 (callable)
    ↓
RunnableLambda 包装
    ↓
Runnable 对象
    ↓
支持 invoke/batch/stream 等方法
```

---

### RunnableLambda 的内部结构

**简化版实现：**

```python
from typing import Callable, Any, Optional
import asyncio

class RunnableLambda:
    """将函数转换为 Runnable 的适配器"""

    def __init__(
        self,
        func: Callable,
        afunc: Optional[Callable] = None
    ):
        """
        初始化 RunnableLambda

        Args:
            func: 同步函数
            afunc: 可选的异步函数
        """
        self.func = func
        self.afunc = afunc

    def invoke(self, input: Any) -> Any:
        """同步调用"""
        return self.func(input)

    async def ainvoke(self, input: Any) -> Any:
        """异步调用"""
        if self.afunc:
            # 如果提供了 afunc，直接使用
            return await self.afunc(input)
        else:
            # 否则通过线程池委托同步函数
            return await asyncio.to_thread(self.func, input)

    def batch(self, inputs: list[Any]) -> list[Any]:
        """批量调用"""
        return [self.invoke(input) for input in inputs]

    async def abatch(self, inputs: list[Any]) -> list[Any]:
        """异步批量调用"""
        tasks = [self.ainvoke(input) for input in inputs]
        return await asyncio.gather(*tasks)

    def stream(self, input: Any):
        """流式调用（默认委托 invoke）"""
        result = self.invoke(input)
        yield result

    def __or__(self, other):
        """支持 | 操作符"""
        return RunnableSequence(self, other)
```

**关键点：**
1. **存储函数引用**：`self.func` 和 `self.afunc`
2. **实现 Runnable 接口**：invoke、batch、stream 等方法
3. **异步委托**：如果没有 afunc，通过线程池委托
4. **支持组合**：实现 `__or__` 方法支持 | 操作符

---

## 参数传递机制

### call_func_with_variable_args

**核心问题：** 如何处理不同签名的函数？

```python
# 函数1: 单个参数
def func1(x: int) -> int:
    return x * 2

# 函数2: 多个参数
def func2(x: int, y: int) -> int:
    return x + y

# 函数3: 接收字典
def func3(data: dict) -> str:
    return f"{data['name']}: {data['value']}"
```

**LangChain 的解决方案：`call_func_with_variable_args`**

```python
def call_func_with_variable_args(
    func: Callable,
    input: Any,
    config: Optional[dict] = None
) -> Any:
    """
    智能调用函数，根据函数签名传递参数

    Args:
        func: 要调用的函数
        input: 输入数据
        config: 可选的配置

    Returns:
        函数的返回值
    """
    import inspect

    # 获取函数签名
    sig = inspect.signature(func)
    params = sig.parameters

    # 情况1: 函数接受单个参数
    if len(params) == 1:
        return func(input)

    # 情况2: 函数接受多个参数，input 是字典
    if isinstance(input, dict):
        # 尝试解包字典
        try:
            return func(**input)
        except TypeError:
            # 如果解包失败，直接传递
            return func(input)

    # 情况3: 函数接受 config 参数
    if 'config' in params:
        return func(input, config=config)

    # 默认：直接传递
    return func(input)
```

**使用示例：**

```python
from langchain_core.runnables import RunnableLambda

# 示例1: 单参数函数
def double(x: int) -> int:
    return x * 2

runnable1 = RunnableLambda(double)
result = runnable1.invoke(5)  # 10

# 示例2: 多参数函数（通过字典传递）
def add(x: int, y: int) -> int:
    return x + y

runnable2 = RunnableLambda(add)
result = runnable2.invoke({"x": 3, "y": 4})  # 7

# 示例3: 接受 config 的函数
def process_with_config(input: str, config: dict) -> str:
    prefix = config.get("prefix", "")
    return f"{prefix}{input}"

runnable3 = RunnableLambda(process_with_config)
result = runnable3.invoke("hello", config={"prefix": ">> "})  # ">> hello"
```

---

### 参数传递的最佳实践

**推荐方式 1：单参数函数**

```python
# ✅ 好：简单清晰
def process(text: str) -> str:
    return text.upper()

runnable = RunnableLambda(process)
result = runnable.invoke("hello")  # "HELLO"
```

**推荐方式 2：接收字典**

```python
# ✅ 好：灵活且类型安全
def process(data: dict) -> dict:
    return {
        "result": data["text"].upper(),
        "length": len(data["text"])
    }

runnable = RunnableLambda(process)
result = runnable.invoke({"text": "hello"})
# {"result": "HELLO", "length": 5}
```

**不推荐方式：多参数函数**

```python
# ⚠️ 不推荐：需要字典解包，容易出错
def process(text: str, prefix: str, suffix: str) -> str:
    return f"{prefix}{text}{suffix}"

runnable = RunnableLambda(process)
# 必须传递字典
result = runnable.invoke({
    "text": "hello",
    "prefix": ">>",
    "suffix": "<<"
})
```

---

## 输入输出类型转换

### 类型匹配的重要性

**问题：** 链中的组件类型不匹配

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableLambda

# 模型输出是 AIMessage
model = ChatOpenAI(model="gpt-4")

# 函数期望 str
def process(text: str) -> str:
    return text.upper()

# ❌ 错误：类型不匹配
chain = (
    ChatPromptTemplate.from_template("Say: {text}")
    | model
    | RunnableLambda(process)  # 错误：model 输出 AIMessage，不是 str
)
```

**解决方案：添加类型转换**

```python
from langchain_core.messages import AIMessage

# ✅ 正确：添加类型转换
def extract_content(message: AIMessage) -> str:
    """从 AIMessage 提取文本内容"""
    return message.content

def process(text: str) -> str:
    """处理文本"""
    return text.upper()

chain = (
    ChatPromptTemplate.from_template("Say: {text}")
    | model
    | RunnableLambda(extract_content)  # 类型转换
    | RunnableLambda(process)          # 处理
)

result = chain.invoke({"text": "hello"})  # "HELLO"
```

---

### 常见类型转换模式

**模式 1：AIMessage → str**

```python
from langchain_core.messages import AIMessage

def message_to_str(message: AIMessage) -> str:
    """提取消息内容"""
    return message.content

runnable = RunnableLambda(message_to_str)
```

**模式 2：str → dict**

```python
import json

def str_to_dict(text: str) -> dict:
    """解析 JSON 字符串"""
    return json.loads(text)

runnable = RunnableLambda(str_to_dict)
```

**模式 3：dict → str**

```python
def dict_to_str(data: dict) -> str:
    """格式化字典为字符串"""
    return "\n".join(f"{k}: {v}" for k, v in data.items())

runnable = RunnableLambda(dict_to_str)
```

**模式 4：list → str**

```python
def list_to_str(items: list) -> str:
    """连接列表元素"""
    return ", ".join(str(item) for item in items)

runnable = RunnableLambda(list_to_str)
```

---

## 与 LCEL 管道的集成

### | 操作符的实现

**核心机制：`__or__` 方法**

```python
class RunnableLambda:
    def __or__(self, other):
        """
        支持 | 操作符

        Args:
            other: 另一个 Runnable

        Returns:
            RunnableSequence: 组合后的序列
        """
        return RunnableSequence(self, other)
```

**RunnableSequence 的简化实现：**

```python
class RunnableSequence:
    """Runnable 序列"""

    def __init__(self, *runnables):
        self.runnables = runnables

    def invoke(self, input):
        """依次调用每个 Runnable"""
        result = input
        for runnable in self.runnables:
            result = runnable.invoke(result)
        return result

    async def ainvoke(self, input):
        """异步依次调用"""
        result = input
        for runnable in self.runnables:
            result = await runnable.ainvoke(result)
        return result

    def __or__(self, other):
        """支持继续组合"""
        return RunnableSequence(*self.runnables, other)
```

---

### 组合示例

**示例 1：简单的数据处理链**

```python
from langchain_core.runnables import RunnableLambda

# 定义处理步骤
def clean(text: str) -> str:
    return text.strip().lower()

def tokenize(text: str) -> list[str]:
    return text.split()

def count(tokens: list[str]) -> int:
    return len(tokens)

# 组合成链
chain = (
    RunnableLambda(clean)
    | RunnableLambda(tokenize)
    | RunnableLambda(count)
)

# 执行
result = chain.invoke("  Hello World  ")  # 2
```

**数据流动：**

```
"  Hello World  "
    ↓ clean
"hello world"
    ↓ tokenize
["hello", "world"]
    ↓ count
2
```

---

**示例 2：与 LangChain 组件组合**

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnableLambda

# 自定义预处理
def preprocess(text: str) -> dict:
    return {"text": text.strip().lower()}

# 自定义后处理
def postprocess(text: str) -> dict:
    return {
        "result": text,
        "length": len(text),
        "words": len(text.split())
    }

# 组合完整链
chain = (
    RunnableLambda(preprocess)
    | ChatPromptTemplate.from_template("Translate to French: {text}")
    | ChatOpenAI(model="gpt-4")
    | StrOutputParser()
    | RunnableLambda(postprocess)
)

# 执行
result = chain.invoke("  Hello World  ")
# {
#     "result": "Bonjour le monde",
#     "length": 16,
#     "words": 3
# }
```

**数据流动：**

```
"  Hello World  "
    ↓ preprocess
{"text": "hello world"}
    ↓ ChatPromptTemplate
ChatPromptValue
    ↓ ChatOpenAI
AIMessage("Bonjour le monde")
    ↓ StrOutputParser
"Bonjour le monde"
    ↓ postprocess
{"result": "Bonjour le monde", "length": 16, "words": 3}
```

---

## 手写简化版实现

### 完整的 RunnableLambda 实现

```python
from typing import Callable, Any, Optional, Iterator
import asyncio
import inspect

class SimplifiedRunnableLambda:
    """
    RunnableLambda 的简化实现
    展示核心原理
    """

    def __init__(
        self,
        func: Callable,
        afunc: Optional[Callable] = None,
        name: Optional[str] = None
    ):
        """
        初始化

        Args:
            func: 同步函数
            afunc: 可选的异步函数
            name: 可选的名称（用于调试）
        """
        self.func = func
        self.afunc = afunc
        self.name = name or func.__name__

    def invoke(self, input: Any, config: Optional[dict] = None) -> Any:
        """
        同步调用

        Args:
            input: 输入数据
            config: 可选的配置

        Returns:
            函数的返回值
        """
        return self._call_func(self.func, input, config)

    async def ainvoke(self, input: Any, config: Optional[dict] = None) -> Any:
        """
        异步调用

        Args:
            input: 输入数据
            config: 可选的配置

        Returns:
            函数的返回值
        """
        if self.afunc:
            # 使用提供的异步函数
            return await self._call_func_async(self.afunc, input, config)
        else:
            # 通过线程池委托同步函数
            return await asyncio.to_thread(
                self._call_func, self.func, input, config
            )

    def batch(
        self,
        inputs: list[Any],
        config: Optional[dict] = None
    ) -> list[Any]:
        """
        批量调用

        Args:
            inputs: 输入列表
            config: 可选的配置

        Returns:
            结果列表
        """
        return [self.invoke(input, config) for input in inputs]

    async def abatch(
        self,
        inputs: list[Any],
        config: Optional[dict] = None
    ) -> list[Any]:
        """
        异步批量调用

        Args:
            inputs: 输入列表
            config: 可选的配置

        Returns:
            结果列表
        """
        tasks = [self.ainvoke(input, config) for input in inputs]
        return await asyncio.gather(*tasks)

    def stream(
        self,
        input: Any,
        config: Optional[dict] = None
    ) -> Iterator[Any]:
        """
        流式调用（默认委托 invoke）

        Args:
            input: 输入数据
            config: 可选的配置

        Yields:
            结果
        """
        result = self.invoke(input, config)
        yield result

    def __or__(self, other):
        """
        支持 | 操作符

        Args:
            other: 另一个 Runnable

        Returns:
            RunnableSequence
        """
        from langchain_core.runnables import RunnableSequence
        return RunnableSequence(self, other)

    def _call_func(
        self,
        func: Callable,
        input: Any,
        config: Optional[dict] = None
    ) -> Any:
        """
        智能调用函数

        Args:
            func: 要调用的函数
            input: 输入数据
            config: 可选的配置

        Returns:
            函数的返回值
        """
        sig = inspect.signature(func)
        params = sig.parameters

        # 情况1: 函数接受 config 参数
        if 'config' in params:
            return func(input, config=config)

        # 情况2: 函数接受单个参数
        if len(params) == 1:
            return func(input)

        # 情况3: 函数接受多个参数，input 是字典
        if isinstance(input, dict):
            try:
                return func(**input)
            except TypeError:
                return func(input)

        # 默认：直接传递
        return func(input)

    async def _call_func_async(
        self,
        func: Callable,
        input: Any,
        config: Optional[dict] = None
    ) -> Any:
        """
        异步调用函数

        Args:
            func: 要调用的异步函数
            input: 输入数据
            config: 可选的配置

        Returns:
            函数的返回值
        """
        sig = inspect.signature(func)
        params = sig.parameters

        # 情况1: 函数接受 config 参数
        if 'config' in params:
            return await func(input, config=config)

        # 情况2: 函数接受单个参数
        if len(params) == 1:
            return await func(input)

        # 情况3: 函数接受多个参数，input 是字典
        if isinstance(input, dict):
            try:
                return await func(**input)
            except TypeError:
                return await func(input)

        # 默认：直接传递
        return await func(input)

    def __repr__(self) -> str:
        """字符串表示"""
        return f"RunnableLambda({self.name})"
```

---

### 测试简化版实现

```python
# 测试代码
def test_simplified_runnable_lambda():
    # 测试1: 基础调用
    def double(x: int) -> int:
        return x * 2

    runnable = SimplifiedRunnableLambda(double)
    assert runnable.invoke(5) == 10

    # 测试2: 批量调用
    results = runnable.batch([1, 2, 3])
    assert results == [2, 4, 6]

    # 测试3: 字典参数
    def add(x: int, y: int) -> int:
        return x + y

    runnable = SimplifiedRunnableLambda(add)
    assert runnable.invoke({"x": 3, "y": 4}) == 7

    # 测试4: 链式组合
    def increment(x: int) -> int:
        return x + 1

    chain = (
        SimplifiedRunnableLambda(double)
        | SimplifiedRunnableLambda(increment)
    )
    assert chain.invoke(5) == 11  # (5 * 2) + 1

    print("所有测试通过！")

# 运行测试
test_simplified_runnable_lambda()
```

---

## 实际应用场景

### 场景 1：数据预处理

```python
from langchain_core.runnables import RunnableLambda
import re

def clean_text(text: str) -> str:
    """清洗文本"""
    # 去除空格
    text = text.strip()
    # 转小写
    text = text.lower()
    # 去除特殊字符
    text = re.sub(r'[^\w\s]', '', text)
    return text

def normalize_whitespace(text: str) -> str:
    """标准化空格"""
    return re.sub(r'\s+', ' ', text)

# 组合预处理链
preprocess_chain = (
    RunnableLambda(clean_text)
    | RunnableLambda(normalize_whitespace)
)

# 使用
text = "  Hello,   World!  "
result = preprocess_chain.invoke(text)
print(result)  # "hello world"
```

---

### 场景 2：格式转换

```python
from langchain_core.runnables import RunnableLambda
import json

def json_to_text(data: dict) -> str:
    """将 JSON 转换为文本"""
    lines = []
    for key, value in data.items():
        lines.append(f"{key}: {value}")
    return "\n".join(lines)

def text_to_json(text: str) -> dict:
    """将文本转换为 JSON"""
    result = {}
    for line in text.split('\n'):
        if ':' in line:
            key, value = line.split(':', 1)
            result[key.strip()] = value.strip()
    return result

# 使用
data = {"name": "Alice", "age": "30", "city": "NYC"}

# JSON → 文本
to_text = RunnableLambda(json_to_text)
text = to_text.invoke(data)
print(text)
# name: Alice
# age: 30
# city: NYC

# 文本 → JSON
to_json = RunnableLambda(text_to_json)
recovered = to_json.invoke(text)
print(recovered)
# {"name": "Alice", "age": "30", "city": "NYC"}
```

---

## 总结

### 核心要点

1. **包装机制**
   - RunnableLambda 将函数包装为 Runnable 对象
   - 不改变原函数，只是添加适配层

2. **参数传递**
   - 通过 `call_func_with_variable_args` 智能处理
   - 支持单参数、多参数、字典参数

3. **类型转换**
   - 确保链中组件的类型匹配
   - 添加必要的转换函数

4. **管道集成**
   - 通过 `__or__` 方法支持 | 操作符
   - 与其他 Runnable 无缝组合

---

## 引用来源

- [LangChain 源码 - RunnableLambda](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/runnables/base.py) - 官方实现
- [LangChain API Reference v0.3](https://reference.langchain.com/v0.3/python/core/runnables/) - API 文档
- [Python Inspect Module](https://docs.python.org/3/library/inspect.html) - 函数签名检查
- [Design Patterns: Adapter](https://refactoring.guru/design-patterns/adapter) - 适配器模式

---

**版本**: v1.0
**最后更新**: 2026-02-20
**适用于**: LangChain v0.3+
**Python 版本**: 3.13+
