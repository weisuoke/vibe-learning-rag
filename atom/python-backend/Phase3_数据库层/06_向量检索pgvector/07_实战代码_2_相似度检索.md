# 实战代码场景2：相似度检索

本示例演示如何使用 pgvector 进行相似度检索，包括三种距离函数、Top-K 检索、过滤条件等。

## 完整代码示例

```python
"""
pgvector 相似度检索示例
演示：三种距离函数、Top-K 检索、过滤条件、混合检索
"""

import os
import psycopg2
from openai import OpenAI
from dotenv import load_dotenv
from typing import List, Dict

# 加载环境变量
load_dotenv()

# 初始化
conn = psycopg2.connect(os.getenv("DATABASE_URL"))
cursor = conn.cursor()
client = OpenAI(
    api_key=os.getenv("OPENAI_API_KEY"),
    base_url=os.getenv("OPENAI_BASE_URL")
)

# ===== 1. 准备测试数据 =====
print("=== 1. 准备测试数据 ===")

# 创建表
cursor.execute("DROP TABLE IF EXISTS documents CASCADE")
cursor.execute("""
    CREATE TABLE documents (
        id SERIAL PRIMARY KEY,
        content TEXT NOT NULL,
        embedding vector(1536),
        category TEXT,
        priority INT,
        created_at TIMESTAMP DEFAULT NOW()
    )
""")

# 准备文档
documents = [
    {"content": "什么是向量数据库？", "category": "database", "priority": 5},
    {"content": "pgvector 是 PostgreSQL 的向量扩展", "category": "database", "priority": 4},
    {"content": "如何使用 HNSW 索引？", "category": "index", "priority": 3},
    {"content": "向量检索的性能优化技巧", "category": "performance", "priority": 5},
    {"content": "RAG 系统的架构设计", "category": "architecture", "priority": 4},
    {"content": "Embedding 模型的选择", "category": "ml", "priority": 3},
    {"content": "余弦距离和欧氏距离的区别", "category": "math", "priority": 2},
    {"content": "IVFFlat 索引的原理", "category": "index", "priority": 3},
    {"content": "向量数据库的应用场景", "category": "database", "priority": 4},
    {"content": "如何评估检索系统的召回率", "category": "evaluation", "priority": 5}
]

# 批量生成 Embedding 并插入
print(f"正在生成 {len(documents)} 个文档的 Embedding...")
texts = [doc["content"] for doc in documents]
embeddings_response = client.embeddings.create(
    input=texts,
    model="text-embedding-3-small"
)

data = [
    (doc["content"], emb.embedding, doc["category"], doc["priority"])
    for doc, emb in zip(documents, embeddings_response.data)
]

cursor.executemany(
    "INSERT INTO documents (content, embedding, category, priority) VALUES (%s, %s, %s, %s)",
    data
)
conn.commit()
print(f"✅ 已插入 {len(documents)} 条文档")

# ===== 2. 余弦距离检索 =====
print("\n=== 2. 余弦距离检索（推荐用于文本）===")

query = "向量数据库的使用方法"
query_embedding = client.embeddings.create(
    input=query,
    model="text-embedding-3-small"
).data[0].embedding

print(f"查询: {query}")

cursor.execute(
    """
    SELECT
        id,
        content,
        category,
        embedding <=> %s AS distance,
        1 - (embedding <=> %s) AS similarity
    FROM documents
    ORDER BY distance
    LIMIT 5
    """,
    (query_embedding, query_embedding)
)

print("\nTop-5 结果（余弦距离）：")
for doc_id, content, category, distance, similarity in cursor.fetchall():
    print(f"  [{category}] {content}")
    print(f"    距离: {distance:.4f}, 相似度: {similarity:.4f}")

# ===== 3. 欧氏距离检索 =====
print("\n=== 3. 欧氏距离检索 ===")

cursor.execute(
    """
    SELECT
        id,
        content,
        category,
        embedding <-> %s AS distance
    FROM documents
    ORDER BY distance
    LIMIT 5
    """,
    (query_embedding,)
)

print("\nTop-5 结果（欧氏距离）：")
for doc_id, content, category, distance in cursor.fetchall():
    print(f"  [{category}] {content}")
    print(f"    距离: {distance:.4f}")

# ===== 4. 内积距离检索 =====
print("\n=== 4. 内积距离检索 ===")

cursor.execute(
    """
    SELECT
        id,
        content,
        category,
        embedding <#> %s AS distance
    FROM documents
    ORDER BY distance
    LIMIT 5
    """,
    (query_embedding,)
)

print("\nTop-5 结果（内积距离）：")
for doc_id, content, category, distance in cursor.fetchall():
    print(f"  [{category}] {content}")
    print(f"    距离: {distance:.4f}")

# ===== 5. 动态 Top-K 检索 =====
print("\n=== 5. 动态 Top-K 检索 ===")

def search_documents(query: str, top_k: int = 5) -> List[Dict]:
    """动态 Top-K 检索"""
    query_embedding = client.embeddings.create(
        input=query,
        model="text-embedding-3-small"
    ).data[0].embedding

    cursor.execute(
        """
        SELECT
            id,
            content,
            category,
            embedding <=> %s AS distance
        FROM documents
        ORDER BY distance
        LIMIT %s
        """,
        (query_embedding, top_k)
    )

    return [
        {
            "id": row[0],
            "content": row[1],
            "category": row[2],
            "distance": row[3]
        }
        for row in cursor.fetchall()
    ]

# 测试不同的 K 值
for k in [3, 5, 10]:
    results = search_documents(query, top_k=k)
    print(f"\nTop-{k} 结果：")
    for r in results:
        print(f"  {r['content'][:30]}... (距离: {r['distance']:.4f})")

# ===== 6. 距离阈值过滤 =====
print("\n=== 6. 距离阈值过滤 ===")

threshold = 0.3
cursor.execute(
    """
    SELECT
        id,
        content,
        embedding <=> %s AS distance
    FROM documents
    WHERE embedding <=> %s < %s
    ORDER BY distance
    """,
    (query_embedding, query_embedding, threshold)
)

results = cursor.fetchall()
print(f"\n距离 < {threshold} 的结果（共 {len(results)} 条）：")
for doc_id, content, distance in results:
    print(f"  {content} (距离: {distance:.4f})")

# ===== 7. 预过滤（Filter-then-Search）=====
print("\n=== 7. 预过滤（高选择性条件）===")

# 先过滤分类，再向量检索
category_filter = "database"
cursor.execute(
    """
    SELECT
        id,
        content,
        category,
        embedding <=> %s AS distance
    FROM documents
    WHERE category = %s
    ORDER BY distance
    LIMIT 5
    """,
    (query_embedding, category_filter)
)

print(f"\n分类 = '{category_filter}' 的 Top-5 结果：")
for doc_id, content, category, distance in cursor.fetchall():
    print(f"  {content} (距离: {distance:.4f})")

# ===== 8. 后过滤（Search-then-Filter）=====
print("\n=== 8. 后过滤（低选择性条件）===")

# 先向量检索，再过滤优先级
priority_filter = 4
cursor.execute(
    """
    SELECT
        id,
        content,
        priority,
        embedding <=> %s AS distance
    FROM documents
    WHERE priority >= %s
    ORDER BY distance
    LIMIT 5
    """,
    (query_embedding, priority_filter)
)

print(f"\n优先级 >= {priority_filter} 的 Top-5 结果：")
for doc_id, content, priority, distance in cursor.fetchall():
    print(f"  {content} (优先级: {priority}, 距离: {distance:.4f})")

# ===== 9. 复杂过滤条件 =====
print("\n=== 9. 复杂过滤条件 ===")

cursor.execute(
    """
    SELECT
        id,
        content,
        category,
        priority,
        embedding <=> %s AS distance
    FROM documents
    WHERE
        category IN ('database', 'index')
        AND priority >= 3
        AND created_at > NOW() - INTERVAL '1 day'
    ORDER BY distance
    LIMIT 5
    """,
    (query_embedding,)
)

print("\n复杂过滤的 Top-5 结果：")
for doc_id, content, category, priority, distance in cursor.fetchall():
    print(f"  [{category}] {content} (优先级: {priority}, 距离: {distance:.4f})")

# ===== 10. 批量检索 =====
print("\n=== 10. 批量检索 ===")

queries = [
    "向量数据库",
    "索引优化",
    "RAG 系统"
]

print(f"批量查询 {len(queries)} 个问题：")
for i, q in enumerate(queries, 1):
    results = search_documents(q, top_k=3)
    print(f"\n查询 {i}: {q}")
    for r in results:
        print(f"  - {r['content'][:40]}... (距离: {r['distance']:.4f})")

# ===== 11. 相似度分数归一化 =====
print("\n=== 11. 相似度分数归一化 ===")

cursor.execute(
    """
    SELECT
        id,
        content,
        embedding <=> %s AS distance,
        1 - (embedding <=> %s) AS similarity,
        1 / (1 + (embedding <=> %s)) AS normalized_score
    FROM documents
    ORDER BY distance
    LIMIT 5
    """,
    (query_embedding, query_embedding, query_embedding)
)

print("\n相似度分数对比：")
for doc_id, content, distance, similarity, normalized_score in cursor.fetchall():
    print(f"  {content[:40]}...")
    print(f"    距离: {distance:.4f}, 相似度: {similarity:.4f}, 归一化分数: {normalized_score:.4f}")

# ===== 12. 混合检索（向量 + 全文）=====
print("\n=== 12. 混合检索（向量 + 全文）===")

# 添加全文索引
cursor.execute("""
    ALTER TABLE documents ADD COLUMN IF NOT EXISTS tsv tsvector
    GENERATED ALWAYS AS (to_tsvector('english', content)) STORED
""")
cursor.execute("CREATE INDEX IF NOT EXISTS documents_tsv_idx ON documents USING GIN (tsv)")
conn.commit()

# 混合检索
search_query = "vector database"
cursor.execute(
    """
    SELECT
        id,
        content,
        embedding <=> %s AS vector_distance,
        ts_rank(tsv, to_tsquery('english', %s)) AS text_rank,
        (1 - (embedding <=> %s)) * 0.7 + ts_rank(tsv, to_tsquery('english', %s)) * 0.3 AS combined_score
    FROM documents
    WHERE tsv @@ to_tsquery('english', %s)
    ORDER BY combined_score DESC
    LIMIT 5
    """,
    (query_embedding, search_query, query_embedding, search_query, search_query)
)

print(f"\n混合检索结果（查询: '{search_query}'）：")
for doc_id, content, vector_dist, text_rank, combined_score in cursor.fetchall():
    print(f"  {content}")
    print(f"    向量距离: {vector_dist:.4f}, 文本排名: {text_rank:.4f}, 综合分数: {combined_score:.4f}")

# ===== 13. 性能对比 =====
print("\n=== 13. 性能对比 ===")

import time

# 测试查询延迟
def benchmark_query(query_func, iterations=10):
    """测试查询性能"""
    times = []
    for _ in range(iterations):
        start = time.time()
        query_func()
        times.append((time.time() - start) * 1000)  # 毫秒
    return {
        "avg": sum(times) / len(times),
        "min": min(times),
        "max": max(times),
        "p95": sorted(times)[int(len(times) * 0.95)]
    }

# 测试余弦距离查询
def query_cosine():
    cursor.execute(
        "SELECT id FROM documents ORDER BY embedding <=> %s LIMIT 10",
        (query_embedding,)
    )
    cursor.fetchall()

stats = benchmark_query(query_cosine, iterations=10)
print(f"\n余弦距离查询性能（10次平均）：")
print(f"  平均: {stats['avg']:.2f}ms")
print(f"  最小: {stats['min']:.2f}ms")
print(f"  最大: {stats['max']:.2f}ms")
print(f"  P95: {stats['p95']:.2f}ms")

# ===== 14. 清理资源 =====
print("\n=== 14. 清理资源 ===")

cursor.close()
conn.close()
print("✅ 数据库连接已关闭")

print("\n=== 示例完成 ===")
```

## 运行输出示例

```
=== 1. 准备测试数据 ===
正在生成 10 个文档的 Embedding...
✅ 已插入 10 条文档

=== 2. 余弦距离检索（推荐用于文本）===
查询: 向量数据库的使用方法

Top-5 结果（余弦距离）：
  [database] 什么是向量数据库？
    距离: 0.1234, 相似度: 0.8766
  [database] pgvector 是 PostgreSQL 的向量扩展
    距离: 0.1567, 相似度: 0.8433
  [database] 向量数据库的应用场景
    距离: 0.1789, 相似度: 0.8211
  [performance] 向量检索的性能优化技巧
    距离: 0.2345, 相似度: 0.7655
  [architecture] RAG 系统的架构设计
    距离: 0.2678, 相似度: 0.7322

=== 3. 欧氏距离检索 ===

Top-5 结果（欧氏距离）：
  [database] 什么是向量数据库？
    距离: 0.4567
  [database] pgvector 是 PostgreSQL 的向量扩展
    距离: 0.5123
  [database] 向量数据库的应用场景
    距离: 0.5678
  [performance] 向量检索的性能优化技巧
    距离: 0.6234
  [architecture] RAG 系统的架构设计
    距离: 0.6789

=== 5. 动态 Top-K 检索 ===

Top-3 结果：
  什么是向量数据库？... (距离: 0.1234)
  pgvector 是 PostgreSQL 的... (距离: 0.1567)
  向量数据库的应用场景... (距离: 0.1789)

Top-5 结果：
  什么是向量数据库？... (距离: 0.1234)
  pgvector 是 PostgreSQL 的... (距离: 0.1567)
  向量数据库的应用场景... (距离: 0.1789)
  向量检索的性能优化技巧... (距离: 0.2345)
  RAG 系统的架构设计... (距离: 0.2678)

=== 6. 距离阈值过滤 ===

距离 < 0.3 的结果（共 5 条）：
  什么是向量数据库？ (距离: 0.1234)
  pgvector 是 PostgreSQL 的向量扩展 (距离: 0.1567)
  向量数据库的应用场景 (距离: 0.1789)
  向量检索的性能优化技巧 (距离: 0.2345)
  RAG 系统的架构设计 (距离: 0.2678)

=== 7. 预过滤（高选择性条件）===

分类 = 'database' 的 Top-5 结果：
  什么是向量数据库？ (距离: 0.1234)
  pgvector 是 PostgreSQL 的向量扩展 (距离: 0.1567)
  向量数据库的应用场景 (距离: 0.1789)

=== 13. 性能对比 ===

余弦距离查询性能（10次平均）：
  平均: 2.34ms
  最小: 1.89ms
  最大: 3.12ms
  P95: 2.98ms

=== 示例完成 ===
```

## 代码说明

### 1. 三种距离函数

```python
# 余弦距离（推荐用于文本）
embedding <=> query_embedding

# 欧氏距离（用于图像/音频）
embedding <-> query_embedding

# 内积距离（用于推荐系统）
embedding <#> query_embedding
```

### 2. 动态 Top-K

```python
def search_documents(query: str, top_k: int = 5):
    cursor.execute(
        "SELECT * FROM documents ORDER BY embedding <=> %s LIMIT %s",
        (query_embedding, top_k)
    )
```

### 3. 过滤策略

```python
# 预过滤（高选择性）
WHERE category = 'database'  -- 先过滤
ORDER BY embedding <=> query_embedding

# 后过滤（低选择性）
WHERE priority >= 4  -- 后过滤
ORDER BY embedding <=> query_embedding
```

### 4. 混合检索

```python
# 向量检索 70% + 全文检索 30%
(1 - (embedding <=> query_embedding)) * 0.7 +
ts_rank(tsv, to_tsquery(search_query)) * 0.3
```

## 常见问题

### Q1: 如何选择距离函数？

- **文本 Embedding**：余弦距离 `<=>`（OpenAI、Sentence-Transformers）
- **图像 Embedding**：欧氏距离 `<->`（CLIP、ResNet）
- **推荐系统**：内积距离 `<#>`（用户-物品向量）

### Q2: Top-K 应该设置多大？

```python
# 根据应用场景选择
RAG 文档问答: top_k = 3-5（只需要最相关的几个文档）
推荐系统: top_k = 10-20（需要更多候选）
相似商品: top_k = 5-10（展示给用户的数量）
```

### Q3: 如何提高检索精度？

```python
# 1. 降低距离阈值
WHERE embedding <=> query_embedding < 0.2  # 更严格

# 2. 增加 Top-K，然后重排序
results = search_documents(query, top_k=20)
reranked = rerank(results, query)[:5]  # 重排序后取 Top-5

# 3. 使用混合检索
combined_score = vector_score * 0.7 + text_score * 0.3
```

## 下一步

完成相似度检索后，可以继续学习：
- **场景3**：RAG 集成（构建完整的文档问答系统）
- **场景4**：索引优化（创建索引，提升检索性能）
