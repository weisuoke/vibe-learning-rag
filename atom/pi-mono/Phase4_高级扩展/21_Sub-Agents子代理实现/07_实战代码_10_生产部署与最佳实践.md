# 生产部署与最佳实践 - 实战代码

> **知识点**: Sub-Agents 子代理实现 - 生产环境部署与优化
> **难度**: ⭐⭐⭐⭐⭐
> **前置知识**: 所有前置实战代码、分布式系统、DevOps

---

## 1. 场景描述

将 Sub-Agents 系统从原型推向生产环境是一个复杂的工程挑战。生产环境要求极高的可靠性（SLA 99.9%+）、低延迟（< 2-5秒）、严格的成本控制、完整的可观测性和持续迭代能力。

**典型生产挑战**:
- 幻觉控制与事实核查
- 工具调用可靠性（并行、多轮）
- 长上下文管理与 token 成本爆炸
- 状态管理（跨多轮对话、长期记忆）
- 延迟优化（Cold Start、TTFT、TTLT）
- 安全与越狱防护
- 可观测性与调试
- 版本管理与持续优化

根据 [Microsoft AI Agents Production Guide](https://github.com/microsoft/ai-agents-for-beginners/blob/main/10-ai-agents-production/README.md)，生产级系统与原型的主要区别在于可靠性要求（SLA 99.9%+）、延迟要求（< 2-5秒）、成本控制（极其敏感）、安全性与隐私（必须严格）、可观测性（完整 tracing/metrics/alerting）和持续迭代能力（CI/CD、A/B测试）。

[Redis AI Agent Orchestration Platforms](https://redis.io/blog/ai-agent-orchestration-platforms) 指出，生产级基础设施需要亚毫秒级状态访问、亚100ms 向量检索、三层内存架构（短期、长期、情景记忆）和分布式状态同步。

---

## 2. 核心概念

### 2.1 生产级 vs 原型对比

| 维度 | 原型阶段 | 生产环境 |
|------|---------|---------|
| 可靠性 | 可以偶尔出错 | SLA 99.9%+ |
| 延迟 | 数秒可接受 | < 2-5秒 |
| 成本 | 不敏感 | 极其敏感 |
| 安全性 | 基本考虑 | 必须严格 |
| 可观测性 | 基本日志 | 完整 tracing |
| 迭代能力 | 手动更新 | CI/CD |

### 2.2 四种架构模式

根据 [Maxim AI Production Best Practices](https://www.getmaxim.ai/articles/best-practices-for-building-production-ready-multi-agent-systems)：

**1. Orchestrated Coordination (编排协调)**
- 中央代理管理所有通信
- 优先考虑一致性和可调试性
- 适用场景：客户支持、金融交易、合规应用

**2. Autonomous Agent Networks (自主代理网络)**
- 消除中央协调，代理直接通信
- 最大化吞吐量和容错性
- 适用场景：实时推荐、IoT 协调、内容审核

**3. Hierarchical Delegation (分层委托)**
- 代理组织成团队，监督代理协调
- 平衡集中控制和分布式执行
- 适用场景：企业平台、研究系统、电商平台

**4. Hybrid Coordination (混合协调)**
- 结合多种模式，根据任务调整
- 灵活优化不同工作负载
- 适用场景：多用途助手、平台服务

### 2.3 基础设施要求

**内存架构**（三层）:
- Short-term memory: 活跃会话工作上下文
- Long-term memory: 跨会话用户配置文件
- Episodic memory: 语义检索特定交互

**性能目标**:
- 状态访问: 亚毫秒级
- 向量检索: 亚100ms（交互式应用）
- 向量检索: 亚50ms（实时应用，100M+ 向量）

---

## 3. 完整代码示例

### 3.1 生产级监控管理器

```typescript
import { ExtensionAPI } from "@pi-mono/extension-api";
import { EventEmitter } from "events";

/**
 * 生产级监控指标
 */
interface ProductionMetrics {
  // 性能指标
  latency: {
    ttft: number;        // Time to First Token
    ttlt: number;        // Time to Last Token
    total: number;       // Total latency
    p50: number;
    p95: number;
    p99: number;
  };

  // 成本指标
  cost: {
    inputTokens: number;
    outputTokens: number;
    totalCost: number;
    costPerRequest: number;
  };

  // 可靠性指标
  reliability: {
    successRate: number;
    errorRate: number;
    toolCallSuccessRate: number;
    hallucinationRate: number;
  };

  // 代理特有指标
  agent: {
    loopCount: number;
    toolCallCount: number;
    stepDuration: number[];
  };
}

/**
 * 生产级监控管理器
 *
 * 参考:
 * - https://github.com/microsoft/ai-agents-for-beginners/blob/main/10-ai-agents-production/README.md
 * - https://redis.io/blog/ai-agent-orchestration-platforms
 */
export class ProductionMonitor extends EventEmitter {
  private metrics: Map<string, ProductionMetrics> = new Map();
  private alerts: Array<{ level: string; message: string; timestamp: Date }> = [];

  /**
   * 记录请求开始
   */
  startRequest(requestId: string): void {
    const metrics: ProductionMetrics = {
      latency: { ttft: 0, ttlt: 0, total: 0, p50: 0, p95: 0, p99: 0 },
      cost: { inputTokens: 0, outputTokens: 0, totalCost: 0, costPerRequest: 0 },
      reliability: { successRate: 0, errorRate: 0, toolCallSuccessRate: 0, hallucinationRate: 0 },
      agent: { loopCount: 0, toolCallCount: 0, stepDuration: [] },
    };

    this.metrics.set(requestId, metrics);
    this.emit("request:start", { requestId, timestamp: new Date() });
  }

  /**
   * 记录 TTFT (Time to First Token)
   */
  recordTTFT(requestId: string, ttft: number): void {
    const metrics = this.metrics.get(requestId);
    if (metrics) {
      metrics.latency.ttft = ttft;

      // 告警：TTFT 超过阈值
      if (ttft > 2000) {
        this.alert("warning", `High TTFT: ${ttft}ms for request ${requestId}`);
      }
    }
  }

  /**
   * 记录工具调用
   */
  recordToolCall(requestId: string, tool: string, success: boolean, duration: number): void {
    const metrics = this.metrics.get(requestId);
    if (metrics) {
      metrics.agent.toolCallCount++;
      metrics.agent.stepDuration.push(duration);

      if (!success) {
        this.alert("error", `Tool call failed: ${tool} in request ${requestId}`);
      }
    }
  }

  /**
   * 记录 token 使用
   */
  recordTokenUsage(requestId: string, inputTokens: number, outputTokens: number): void {
    const metrics = this.metrics.get(requestId);
    if (metrics) {
      metrics.cost.inputTokens = inputTokens;
      metrics.cost.outputTokens = outputTokens;

      // 假设 GPT-4 定价: $0.03/1K input, $0.06/1K output
      metrics.cost.totalCost = (inputTokens / 1000) * 0.03 + (outputTokens / 1000) * 0.06;
      metrics.cost.costPerRequest = metrics.cost.totalCost;

      // 告警：token 使用超过预算
      if (metrics.cost.totalCost > 1.0) {
        this.alert("warning", `High cost: $${metrics.cost.totalCost.toFixed(2)} for request ${requestId}`);
      }
    }
  }

  /**
   * 完成请求
   */
  completeRequest(requestId: string, success: boolean, totalLatency: number): void {
    const metrics = this.metrics.get(requestId);
    if (metrics) {
      metrics.latency.total = totalLatency;
      metrics.latency.ttlt = totalLatency;

      if (success) {
        metrics.reliability.successRate = 1.0;
      } else {
        metrics.reliability.errorRate = 1.0;
      }

      this.emit("request:complete", { requestId, metrics, timestamp: new Date() });

      // 计算百分位数（简化版）
      this.updatePercentiles();
    }
  }

  /**
   * 发送告警
   */
  private alert(level: string, message: string): void {
    const alert = { level, message, timestamp: new Date() };
    this.alerts.push(alert);
    this.emit("alert", alert);

    // 保留最近 1000 条告警
    if (this.alerts.length > 1000) {
      this.alerts.shift();
    }
  }

  /**
   * 更新百分位数
   */
  private updatePercentiles(): void {
    const latencies: number[] = [];

    for (const metrics of this.metrics.values()) {
      latencies.push(metrics.latency.total);
    }

    if (latencies.length === 0) return;

    latencies.sort((a, b) => a - b);

    const p50Index = Math.floor(latencies.length * 0.5);
    const p95Index = Math.floor(latencies.length * 0.95);
    const p99Index = Math.floor(latencies.length * 0.99);

    // 更新所有 metrics 的百分位数（简化）
    for (const metrics of this.metrics.values()) {
      metrics.latency.p50 = latencies[p50Index];
      metrics.latency.p95 = latencies[p95Index];
      metrics.latency.p99 = latencies[p99Index];
    }
  }

  /**
   * 获取聚合指标
   */
  getAggregateMetrics(): {
    totalRequests: number;
    successRate: number;
    avgLatency: number;
    p95Latency: number;
    p99Latency: number;
    totalCost: number;
    avgCostPerRequest: number;
  } {
    const allMetrics = Array.from(this.metrics.values());

    if (allMetrics.length === 0) {
      return {
        totalRequests: 0,
        successRate: 0,
        avgLatency: 0,
        p95Latency: 0,
        p99Latency: 0,
        totalCost: 0,
        avgCostPerRequest: 0,
      };
    }

    const totalRequests = allMetrics.length;
    const successCount = allMetrics.filter(m => m.reliability.successRate > 0).length;
    const successRate = successCount / totalRequests;

    const avgLatency = allMetrics.reduce((sum, m) => sum + m.latency.total, 0) / totalRequests;
    const p95Latency = allMetrics[0]?.latency.p95 || 0;
    const p99Latency = allMetrics[0]?.latency.p99 || 0;

    const totalCost = allMetrics.reduce((sum, m) => sum + m.cost.totalCost, 0);
    const avgCostPerRequest = totalCost / totalRequests;

    return {
      totalRequests,
      successRate,
      avgLatency,
      p95Latency,
      p99Latency,
      totalCost,
      avgCostPerRequest,
    };
  }

  /**
   * 获取最近告警
   */
  getRecentAlerts(limit: number = 10): Array<{ level: string; message: string; timestamp: Date }> {
    return this.alerts.slice(-limit);
  }
}
```

### 3.2 性能优化器

```typescript
/**
 * 性能优化器
 *
 * 实施策略:
 * - Prompt 压缩
 * - 小模型 + 大模型 Router
 * - 语义缓存
 * - 工具结果缓存
 */
export class PerformanceOptimizer {
  private cache: Map<string, { result: any; timestamp: Date; ttl: number }> = new Map();

  /**
   * 语义缓存：检查是否有相似查询的缓存结果
   */
  async checkSemanticCache(query: string, threshold: number = 0.95): Promise<any | null> {
    // 简化实现：使用字符串相似度
    // 生产环境应使用向量相似度
    for (const [cachedQuery, cached] of this.cache.entries()) {
      const similarity = this.calculateSimilarity(query, cachedQuery);

      if (similarity >= threshold) {
        const age = Date.now() - cached.timestamp.getTime();

        if (age < cached.ttl) {
          return cached.result;
        } else {
          // 缓存过期，删除
          this.cache.delete(cachedQuery);
        }
      }
    }

    return null;
  }

  /**
   * 保存到缓存
   */
  saveToCache(query: string, result: any, ttl: number = 3600000): void {
    this.cache.set(query, {
      result,
      timestamp: new Date(),
      ttl,
    });

    // 限制缓存大小
    if (this.cache.size > 1000) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }

  /**
   * 计算字符串相似度（简化版）
   */
  private calculateSimilarity(str1: string, str2: string): number {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;

    if (longer.length === 0) return 1.0;

    const editDistance = this.levenshteinDistance(longer, shorter);
    return (longer.length - editDistance) / longer.length;
  }

  /**
   * Levenshtein 距离
   */
  private levenshteinDistance(str1: string, str2: string): number {
    const matrix: number[][] = [];

    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    return matrix[str2.length][str1.length];
  }

  /**
   * Prompt 压缩：移除冗余信息
   */
  compressPrompt(prompt: string, maxLength: number = 4000): string {
    if (prompt.length <= maxLength) {
      return prompt;
    }

    // 简化实现：截断中间部分
    const start = prompt.substring(0, maxLength / 2);
    const end = prompt.substring(prompt.length - maxLength / 2);

    return `${start}\n\n[... ${prompt.length - maxLength} characters omitted ...]\n\n${end}`;
  }

  /**
   * 模型路由：根据任务复杂度选择模型
   */
  routeModel(task: string, complexity: "simple" | "medium" | "complex"): string {
    switch (complexity) {
      case "simple":
        return "claude-haiku-4-5";  // 快速、便宜
      case "medium":
        return "claude-sonnet-4-5"; // 平衡
      case "complex":
        return "claude-opus-4-5";   // 强大、昂贵
      default:
        return "claude-sonnet-4-5";
    }
  }
}
```

### 3.3 安全防护层

```typescript
/**
 * 安全防护层
 *
 * 多层防御:
 * - 输入端: Prompt Injection 检测
 * - 输出端: 内容审核、PII 脱敏
 * - 工具端: 权限控制、输入输出校验
 * - 运行时: 最大步数限制、token 预算限制
 */
export class SecurityGuard {
  private maxSteps: number = 20;
  private maxTokenBudget: number = 100000;
  private currentSteps: number = 0;
  private currentTokens: number = 0;

  /**
   * 检测 Prompt Injection
   */
  detectPromptInjection(input: string): { safe: boolean; reason?: string } {
    // 简化实现：检测常见注入模式
    const injectionPatterns = [
      /ignore\s+previous\s+instructions/i,
      /disregard\s+all\s+prior/i,
      /forget\s+everything/i,
      /new\s+instructions:/i,
      /system\s+prompt:/i,
    ];

    for (const pattern of injectionPatterns) {
      if (pattern.test(input)) {
        return {
          safe: false,
          reason: `Potential prompt injection detected: ${pattern.source}`,
        };
      }
    }

    return { safe: true };
  }

  /**
   * PII 脱敏
   */
  sanitizePII(text: string): string {
    // 简化实现：脱敏常见 PII
    let sanitized = text;

    // 邮箱
    sanitized = sanitized.replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, "[EMAIL]");

    // 电话号码
    sanitized = sanitized.replace(/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, "[PHONE]");

    // 信用卡号
    sanitized = sanitized.replace(/\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g, "[CREDIT_CARD]");

    // SSN
    sanitized = sanitized.replace(/\b\d{3}-\d{2}-\d{4}\b/g, "[SSN]");

    return sanitized;
  }

  /**
   * 检查步数限制
   */
  checkStepLimit(): { allowed: boolean; reason?: string } {
    this.currentSteps++;

    if (this.currentSteps > this.maxSteps) {
      return {
        allowed: false,
        reason: `Maximum steps (${this.maxSteps}) exceeded`,
      };
    }

    return { allowed: true };
  }

  /**
   * 检查 token 预算
   */
  checkTokenBudget(tokens: number): { allowed: boolean; reason?: string } {
    this.currentTokens += tokens;

    if (this.currentTokens > this.maxTokenBudget) {
      return {
        allowed: false,
        reason: `Token budget (${this.maxTokenBudget}) exceeded`,
      };
    }

    return { allowed: true };
  }

  /**
   * 重置计数器
   */
  reset(): void {
    this.currentSteps = 0;
    this.currentTokens = 0;
  }

  /**
   * 验证工具输入
   */
  validateToolInput(tool: string, input: any, schema: any): { valid: boolean; errors?: string[] } {
    // 简化实现：基本类型检查
    const errors: string[] = [];

    for (const [key, type] of Object.entries(schema)) {
      if (!(key in input)) {
        errors.push(`Missing required field: ${key}`);
      } else if (typeof input[key] !== type) {
        errors.push(`Invalid type for ${key}: expected ${type}, got ${typeof input[key]}`);
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
    };
  }
}
```

### 3.4 Extension 注册函数

```typescript
import { z } from "zod";

export default function (pi: ExtensionAPI) {
  const monitor = new ProductionMonitor();
  const optimizer = new PerformanceOptimizer();
  const security = new SecurityGuard();

  monitor.on("alert", (alert) => console.error(`[ALERT] ${alert.level}: ${alert.message}`));

  pi.registerTool({
    name: "execute_production_agent",
    description: "Execute agent with production monitoring, optimization, and security",
    parameters: z.object({
      agent: z.string(),
      task: z.string(),
      complexity: z.enum(["simple", "medium", "complex"]).optional(),
    }),
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      const requestId = `req_${Date.now()}`;
      const injectionCheck = security.detectPromptInjection(params.task);
      if (!injectionCheck.safe) throw new Error(`Security: ${injectionCheck.reason}`);

      monitor.startRequest(requestId);
      const startTime = Date.now();

      try {
        const cached = await optimizer.checkSemanticCache(params.task);
        if (cached) {
          monitor.completeRequest(requestId, true, Date.now() - startTime);
          return { result: cached, cached: true };
        }

        const model = optimizer.routeModel(params.task, params.complexity || "medium");
        monitor.recordTTFT(requestId, 150);
        const result = `Agent ${params.agent} completed: ${params.task}`;
        monitor.recordTokenUsage(requestId, 1000, 500);
        monitor.recordToolCall(requestId, "execute", true, 200);

        const sanitized = security.sanitizePII(result);
        optimizer.saveToCache(params.task, sanitized);
        monitor.completeRequest(requestId, true, Date.now() - startTime);

        return { result: sanitized, metrics: monitor.getAggregateMetrics(), cached: false };
      } catch (error: any) {
        monitor.completeRequest(requestId, false, Date.now() - startTime);
        throw error;
      }
    },
  });
}
```

---

## 4. 代码解析

**分层监控架构**: ProductionMonitor 收集 TTFT、TTLT、成本、成功率等关键指标，参考 [Microsoft AI Agents Production Guide](https://github.com/microsoft/ai-agents-for-beginners/blob/main/10-ai-agents-production/README.md)。

**多层安全防护**: 输入端检测 Prompt Injection → 运行时限制步数和 token → 输出端 PII 脱敏，实施深度防御。

**性能优化策略**: 语义缓存避免重复调用 + 模型路由（simple→haiku, complex→opus）+ Prompt 压缩，参考 [Redis](https://redis.io/blog/ai-agent-orchestration-platforms) 的亚100ms 目标。

---

## 5. 实际案例分析

### 案例 1: Microsoft 生产实践

[Microsoft AI Agents Production Guide](https://github.com/microsoft/ai-agents-for-beginners/blob/main/10-ai-agents-production/README.md) - 生产级系统需要 SLA 99.9%+、延迟 < 2-5秒、Top 10 工程挑战包括幻觉控制、工具调用可靠性、长上下文管理。

### 案例 2: Redis 基础设施

[Redis AI Agent Orchestration](https://redis.io/blog/ai-agent-orchestration-platforms) - Redis 8 提供 87% 更快执行、2× 吞吐量、亚毫秒级状态访问、亚100ms 向量检索、三层内存架构。

### 案例 3: Maxim AI 架构模式

[Maxim AI Best Practices](https://www.getmaxim.ai/articles/best-practices-for-building-production-ready-multi-agent-systems) - 四种架构：Orchestrated（一致性）、Autonomous（吞吐量）、Hierarchical（平衡）、Hybrid（灵活）。生产系统需要显式故障处理、状态一致性管理和协调开销优化。

---

## 6. 最佳实践

**监控**: 追踪 TTFT/TTLT、token 消耗、成功率、工具调用成功率，使用 OpenTelemetry/Langfuse。

**错误处理**: 指数退避重试 + 优雅降级 + 死信队列。

**性能优化**: 语义缓存 + 模型路由 + Prompt 压缩 + 批处理。

**安全**: Prompt Injection 检测 + 步数限制 + token 预算 + PII 脱敏 + 最小权限。

**测试**: 单元测试 + 集成测试 + 混沌测试 + 负载测试。

---

## 7. 常见问题

**Q1: 如何选择架构?** 一致性优先→Orchestrated，吞吐量优先→Autonomous，平衡→Hierarchical，灵活→Hybrid。

**Q2: 如何控制成本?** 语义缓存 + 模型路由 + Prompt 压缩 + token 预算 + 批处理。

**Q3: 如何优化延迟?** 亚毫秒级状态访问（Redis）+ 亚100ms 向量检索 + 并行工具调用 + 流式输出。

**Q4: 如何保证安全?** Prompt Injection 检测 + 步数/token 限制 + PII 脱敏 + 权限控制 + 输入输出校验。

## 8. 扩展阅读

1. **[Microsoft AI Agents Production Guide](https://github.com/microsoft/ai-agents-for-beginners/blob/main/10-ai-agents-production/README.md)** - 生产级 vs 原型、Top 10 挑战
2. **[Redis AI Agent Orchestration](https://redis.io/blog/ai-agent-orchestration-platforms)** - 基础设施、性能优化
3. **[Maxim AI Best Practices](https://www.getmaxim.ai/articles/best-practices-for-building-production-ready-multi-agent-systems)** - 四种架构模式
4. **[Azure Foundry Citadel](https://github.com/Azure-Samples/foundry-citadel-platform)** - 生产部署平台
5. **[AgentScope Runtime](https://github.com/agentscope-ai/agentscope-runtime)** - 生产运行时框架

**相关知识点**: `03_核心概念_10_使用追踪与性能监控.md`、`07_实战代码_08_错误处理与恢复.md`

---
**版本**: v1.0 | **最后更新**: 2026-02-21 | **作者**: Claude Code | **审核**: 基于 2025-2026 年最新生产实践
