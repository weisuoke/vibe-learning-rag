# 实战代码：基于输入类型的智能路由

> **场景**：根据用户输入类型（问题、命令、闲聊）路由到不同处理链
> **学习目标**：掌握基于输入类型的智能路由实现
> **预计学习时长**：45分钟

---

## 场景说明

在实际的 AI 应用中，用户的输入类型多种多样：
- **问题**：需要查询知识库或搜索引擎
- **命令**：需要执行特定操作
- **闲聊**：需要友好的对话响应

不同类型的输入需要不同的处理策略。本案例展示如何使用 RunnableBranch 实现基于输入类型的智能路由。

### 业务需求

构建一个智能助手，能够：
1. 自动识别用户输入类型
2. 根据类型选择最优处理链
3. 提供准确、友好的响应

### 预期效果

- **问题**："什么是Python?" → 查询知识库 → 返回准确答案
- **命令**："/help" → 执行帮助命令 → 返回帮助信息
- **闲聊**："你好" → 友好对话 → 返回问候语

---

## 架构设计

### 系统架构图

```
用户输入
    ↓
输入分类器
    ↓
类型判断
    ├─ 问题？ → 问题处理链 → 知识库查询 → 返回答案
    ├─ 命令？ → 命令处理链 → 执行命令 → 返回结果
    └─ 闲聊？ → 闲聊处理链 → 友好对话 → 返回响应
```

### 核心组件

1. **输入分类器**：判断输入类型
2. **问题处理链**：处理知识查询
3. **命令处理链**：执行系统命令
4. **闲聊处理链**：提供友好对话
5. **路由器**：根据类型选择处理链

---

## 完整代码实现

```python
from langchain_core.runnables import RunnableBranch, RunnableLambda
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from dotenv import load_dotenv
import logging
from typing import Dict, Any

# 加载环境变量
load_dotenv()

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ============================================================
# 1. 输入分类器
# ============================================================

class InputClassifier:
    """输入类型分类器"""

    @staticmethod
    def is_question(x: Dict[str, Any]) -> bool:
        """判断是否为问题"""
        input_text = x.get("input", "")

        # 问题特征
        question_indicators = [
            input_text.endswith("?"),
            input_text.endswith("？"),
            any(word in input_text for word in ["什么", "为什么", "如何", "怎么", "哪里"]),
            any(word in input_text.lower() for word in ["what", "why", "how", "where", "when"])
        ]

        result = any(question_indicators)
        logger.info(f"is_question: {result} for input: {input_text[:50]}")
        return result

    @staticmethod
    def is_command(x: Dict[str, Any]) -> bool:
        """判断是否为命令"""
        input_text = x.get("input", "")

        # 命令特征
        command_indicators = [
            input_text.startswith("/"),
            input_text.startswith("!"),
            any(word in input_text for word in ["执行", "运行", "打开", "关闭"]),
            any(word in input_text.lower() for word in ["execute", "run", "open", "close"])
        ]

        result = any(command_indicators)
        logger.info(f"is_command: {result} for input: {input_text[:50]}")
        return result

# ============================================================
# 2. 问题处理链
# ============================================================

class QuestionHandler:
    """问题处理器"""

    def __init__(self):
        self.model = ChatOpenAI(model="gpt-4o-mini", temperature=0)
        self.prompt = ChatPromptTemplate.from_template(
            """你是一个知识助手。请回答以下问题：

问题：{input}

要求：
1. 提供准确、简洁的答案
2. 如果不确定，说明不确定的原因
3. 必要时提供参考资料"""
        )
        self.chain = self.prompt | self.model

    def handle(self, x: Dict[str, Any]) -> str:
        """处理问题"""
        logger.info(f"QuestionHandler processing: {x['input'][:50]}")
        result = self.chain.invoke(x)
        return f"[问题回答]\n{result.content}"

# ============================================================
# 3. 命令处理链
# ============================================================

class CommandHandler:
    """命令处理器"""

    def __init__(self):
        self.commands = {
            "/help": self._help_command,
            "/status": self._status_command,
            "/clear": self._clear_command,
        }

    def handle(self, x: Dict[str, Any]) -> str:
        """处理命令"""
        input_text = x.get("input", "")
        logger.info(f"CommandHandler processing: {input_text}")

        # 提取命令
        command = input_text.split()[0] if input_text else ""

        # 执行命令
        if command in self.commands:
            return self.commands[command](x)
        else:
            return f"[命令执行]\n未知命令：{command}\n使用 /help 查看可用命令"

    def _help_command(self, x: Dict[str, Any]) -> str:
        """帮助命令"""
        return """[命令执行]
可用命令：
- /help: 显示帮助信息
- /status: 显示系统状态
- /clear: 清除对话历史"""

    def _status_command(self, x: Dict[str, Any]) -> str:
        """状态命令"""
        return """[命令执行]
系统状态：
- 模型：GPT-4o-mini
- 状态：运行中
- 会话：活跃"""

    def _clear_command(self, x: Dict[str, Any]) -> str:
        """清除命令"""
        return "[命令执行]\n对话历史已清除"

# ============================================================
# 4. 闲聊处理链
# ============================================================

class ChatHandler:
    """闲聊处理器"""

    def __init__(self):
        self.model = ChatOpenAI(model="gpt-4o-mini", temperature=0.7)
        self.prompt = ChatPromptTemplate.from_template(
            """你是一个友好的AI助手。请用轻松、友好的语气回应用户。

用户：{input}

要求：
1. 保持友好、自然的对话风格
2. 适当使用表情符号（如果合适）
3. 简短回应（1-2句话）"""
        )
        self.chain = self.prompt | self.model

    def handle(self, x: Dict[str, Any]) -> str:
        """处理闲聊"""
        logger.info(f"ChatHandler processing: {x['input'][:50]}")
        result = self.chain.invoke(x)
        return f"[闲聊回应]\n{result.content}"

# ============================================================
# 5. 智能路由器
# ============================================================

class SmartRouter:
    """智能路由器"""

    def __init__(self):
        # 初始化处理器
        self.question_handler = QuestionHandler()
        self.command_handler = CommandHandler()
        self.chat_handler = ChatHandler()

        # 创建路由
        self.router = RunnableBranch(
            (InputClassifier.is_question, RunnableLambda(self.question_handler.handle)),
            (InputClassifier.is_command, RunnableLambda(self.command_handler.handle)),
            RunnableLambda(self.chat_handler.handle)  # 默认：闲聊
        )

    def invoke(self, input_text: str) -> str:
        """执行路由"""
        return self.router.invoke({"input": input_text})

# ============================================================
# 6. 测试系统
# ============================================================

def test_smart_router():
    """测试智能路由系统"""
    router = SmartRouter()

    # 测试用例
    test_cases = [
        # 问题
        "什么是Python?",
        "为什么Python这么流行？",
        "How does Python work?",

        # 命令
        "/help",
        "/status",
        "/clear",

        # 闲聊
        "你好",
        "今天天气不错",
        "谢谢你的帮助",
    ]

    print("="*60)
    print("智能路由系统测试")
    print("="*60)

    for i, input_text in enumerate(test_cases, 1):
        print(f"\n测试 {i}/{len(test_cases)}")
        print(f"输入: {input_text}")
        print("-"*60)

        result = router.invoke(input_text)
        print(result)
        print("-"*60)

# ============================================================
# 7. 性能追踪
# ============================================================

class PerformanceTracker:
    """性能追踪器"""

    def __init__(self):
        self.stats = {
            "question": {"count": 0, "total_time": 0},
            "command": {"count": 0, "total_time": 0},
            "chat": {"count": 0, "total_time": 0}
        }

    def track(self, input_type: str, duration: float):
        """追踪性能"""
        self.stats[input_type]["count"] += 1
        self.stats[input_type]["total_time"] += duration

    def report(self):
        """生成性能报告"""
        print("\n" + "="*60)
        print("性能报告")
        print("="*60)

        total_count = sum(s["count"] for s in self.stats.values())
        total_time = sum(s["total_time"] for s in self.stats.values())

        for input_type, data in self.stats.items():
            if data["count"] > 0:
                avg_time = data["total_time"] / data["count"]
                percentage = (data["count"] / total_count) * 100

                print(f"\n{input_type.capitalize()}:")
                print(f"  请求数: {data['count']} ({percentage:.1f}%)")
                print(f"  总时间: {data['total_time']:.2f}秒")
                print(f"  平均时间: {avg_time:.2f}秒")

        print(f"\n总请求数: {total_count}")
        print(f"总时间: {total_time:.2f}秒")
        print(f"平均时间: {total_time/total_count:.2f}秒")
        print("="*60)

# ============================================================
# 8. 主程序
# ============================================================

if __name__ == "__main__":
    # 运行测试
    test_smart_router()
```

---

## 运行示例和输出

### 测试1: 问题

**输入**：`什么是Python?`

**输出**：
```
[问题回答]
Python是一种高级编程语言，由Guido van Rossum于1991年创建。它以简洁易读的语法和强大的功能而闻名，广泛应用于Web开发、数据分析、人工智能、科学计算等领域。

Python的主要特点：
1. 简洁易学：语法清晰，适合初学者
2. 功能强大：拥有丰富的标准库和第三方库
3. 跨平台：可在Windows、Linux、macOS等系统运行
4. 开源免费：完全开源，社区活跃

参考资料：https://www.python.org/
```

### 测试2: 命令

**输入**：`/help`

**输出**：
```
[命令执行]
可用命令：
- /help: 显示帮助信息
- /status: 显示系统状态
- /clear: 清除对话历史
```

### 测试3: 闲聊

**输入**：`你好`

**输出**：
```
[闲聊回应]
你好！很高兴见到你！有什么我可以帮助你的吗？😊
```

---

## 性能分析

### 响应时间对比

| 输入类型 | 平均响应时间 | 处理方式 |
|---------|------------|---------|
| **问题** | ~1.2秒 | 调用 LLM（GPT-4o-mini） |
| **命令** | ~0.01秒 | 本地处理（无 LLM 调用） |
| **闲聊** | ~0.8秒 | 调用 LLM（GPT-4o-mini，temperature=0.7） |

### 成本分析

假设每天处理1000个请求，分布如下：
- 问题：40%（400个）
- 命令：10%（100个）
- 闲聊：50%（500个）

**成本计算**：
```
问题：400 × 500 tokens × $0.0015/1K = $0.30
命令：100 × 0 tokens × $0 = $0（本地处理）
闲聊：500 × 300 tokens × $0.0015/1K = $0.23

总成本：$0.53/天
```

**对比不使用路由**（全部用 GPT-4）：
```
1000 × 500 tokens × $0.03/1K = $15/天

成本节省：(15 - 0.53) / 15 = 96.5%
```

---

## 生产环境注意事项

### 1. 输入验证

```python
def validate_input(input_text: str) -> bool:
    """验证输入"""
    # 长度检查
    if len(input_text) > 1000:
        raise ValueError("输入过长")

    # 敏感词过滤
    sensitive_words = ["敏感词1", "敏感词2"]
    if any(word in input_text for word in sensitive_words):
        raise ValueError("包含敏感词")

    return True
```

### 2. 错误处理

```python
def safe_invoke(router, input_text: str) -> str:
    """安全调用路由"""
    try:
        # 验证输入
        validate_input(input_text)

        # 执行路由
        return router.invoke(input_text)

    except ValueError as e:
        logger.error(f"输入验证失败: {e}")
        return f"错误：{e}"

    except Exception as e:
        logger.error(f"路由执行失败: {e}")
        return "抱歉，系统出现错误，请稍后重试"
```

### 3. 缓存优化

```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def cached_question_handler(input_text: str) -> str:
    """带缓存的问题处理"""
    # 相同问题直接返回缓存结果
    return question_handler.handle({"input": input_text})
```

### 4. 监控和日志

```python
from prometheus_client import Counter, Histogram

# 定义指标
route_counter = Counter(
    'route_decisions_total',
    'Total route decisions',
    ['route_type']
)

route_duration = Histogram(
    'route_duration_seconds',
    'Route execution duration',
    ['route_type']
)

def monitored_invoke(router, input_text: str) -> str:
    """带监控的路由调用"""
    # 判断类型
    if InputClassifier.is_question({"input": input_text}):
        route_type = "question"
    elif InputClassifier.is_command({"input": input_text}):
        route_type = "command"
    else:
        route_type = "chat"

    # 记录指标
    route_counter.labels(route_type=route_type).inc()

    # 执行路由
    with route_duration.labels(route_type=route_type).time():
        return router.invoke(input_text)
```

### 5. 多语言支持

```python
def detect_language(text: str) -> str:
    """检测语言"""
    # 简单的语言检测
    if any('\u4e00' <= char <= '\u9fff' for char in text):
        return "zh"
    elif text.isascii():
        return "en"
    else:
        return "unknown"

class MultilingualRouter:
    """多语言路由器"""

    def __init__(self):
        self.routers = {
            "zh": SmartRouter(),  # 中文路由
            "en": SmartRouter(),  # 英文路由
        }

    def invoke(self, input_text: str) -> str:
        """执行多语言路由"""
        lang = detect_language(input_text)
        router = self.routers.get(lang, self.routers["en"])
        return router.invoke(input_text)
```

---

## 扩展功能

### 1. 添加新的输入类型

```python
# 添加"任务"类型
class InputClassifier:
    @staticmethod
    def is_task(x: Dict[str, Any]) -> bool:
        """判断是否为任务"""
        input_text = x.get("input", "")
        task_indicators = ["提醒我", "安排", "计划", "待办"]
        return any(word in input_text for word in task_indicators)

# 添加任务处理器
class TaskHandler:
    def handle(self, x: Dict[str, Any]) -> str:
        return f"[任务创建]\n已创建任务：{x['input']}"

# 更新路由
router = RunnableBranch(
    (InputClassifier.is_question, question_handler),
    (InputClassifier.is_command, command_handler),
    (InputClassifier.is_task, task_handler),
    chat_handler
)
```

### 2. 添加上下文感知

```python
class ContextAwareRouter:
    """上下文感知路由器"""

    def __init__(self):
        self.history = []
        self.router = SmartRouter()

    def invoke(self, input_text: str) -> str:
        """执行上下文感知路由"""
        # 添加历史上下文
        context = {
            "input": input_text,
            "history": self.history[-5:]  # 最近5条历史
        }

        # 执行路由
        result = self.router.invoke(input_text)

        # 更新历史
        self.history.append({"input": input_text, "output": result})

        return result
```

---

## 总结

### 核心要点

1. **输入分类**：根据特征判断输入类型
2. **差异化处理**：不同类型使用不同处理链
3. **成本优化**：命令本地处理，节省 LLM 调用
4. **性能优化**：缓存、监控、错误处理

### 实际效果

- **成本节省**：96.5%（从 $15/天 降到 $0.53/天）
- **响应速度**：命令处理快100倍（0.01秒 vs 1.2秒）
- **用户体验**：针对性处理，更准确的响应

### 下一步

- 阅读 `07_实战代码_02_多模型动态选择.md` 学习成本优化
- 阅读 `07_实战代码_03_错误处理与降级策略.md` 学习可靠性保证
- 阅读 `03_核心概念_02_动态路由.md` 深入理解路由策略
