# 最小可用知识

> 掌握以下内容，就能开始使用 Stack 并理解 AI Agent 调用链追踪

---

## 核心理念

**20% 的核心知识解决 80% 的问题**

Stack 的本质很简单：**后进先出（LIFO）**。理解这个原理，掌握基本操作，你就能应对大部分 AI Agent 开发中的调用链追踪、状态管理和回溯搜索场景。

---

## 4.1 LIFO 原理：后进先出

**一句话：** 最后放入的元素最先被取出，就像叠盘子一样。

```python
# Stack 的核心特性：LIFO
stack = []

# 依次放入 A, B, C
stack.append('A')  # ['A']
stack.append('B')  # ['A', 'B']
stack.append('C')  # ['A', 'B', 'C']

# 取出顺序：C, B, A（后进先出）
print(stack.pop())  # 'C'
print(stack.pop())  # 'B'
print(stack.pop())  # 'A'
```

**在 AI Agent 中的应用：**
- **调用链追踪**：最新的函数调用最先返回
- **Prompt 嵌套**：最内层的 Prompt 最先执行完成
- **状态回溯**：最近的状态最先被恢复

---

## 4.2 两个基本操作：Push 和 Pop

**一句话：** Push 添加元素到栈顶，Pop 移除并返回栈顶元素，都是 O(1) 时间复杂度。

```python
class SimpleStack:
    def __init__(self):
        self.items = []

    def push(self, item):
        """添加元素到栈顶 - O(1)"""
        self.items.append(item)

    def pop(self):
        """移除并返回栈顶元素 - O(1)"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.items.pop()

    def peek(self):
        """查看栈顶元素但不移除 - O(1)"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.items[-1]

    def is_empty(self):
        """检查栈是否为空 - O(1)"""
        return len(self.items) == 0

    def size(self):
        """返回栈的大小 - O(1)"""
        return len(self.items)

# 使用示例
stack = SimpleStack()
stack.push("function_1")
stack.push("function_2")
stack.push("function_3")

print(f"栈顶元素: {stack.peek()}")  # function_3
print(f"栈大小: {stack.size()}")    # 3

print(stack.pop())  # function_3
print(stack.pop())  # function_2
print(f"剩余大小: {stack.size()}")  # 1
```

**在 AI Agent 中的应用：**
- **Push**：记录新的函数调用、保存状态快照
- **Pop**：函数返回、恢复上一个状态
- **Peek**：查看当前执行的函数、检查当前状态

---

## 4.3 递归与栈的关系

**一句话：** 递归函数调用会自动使用系统调用栈，每次递归调用都会在栈上创建新的栈帧。

```python
def factorial(n, depth=0):
    """计算阶乘 - 展示递归与栈的关系"""
    indent = "  " * depth
    print(f"{indent}→ 调用 factorial({n})")

    # 基础情况：递归终止条件
    if n <= 1:
        print(f"{indent}← 返回 1")
        return 1

    # 递归情况：调用自身
    result = n * factorial(n - 1, depth + 1)
    print(f"{indent}← 返回 {result}")
    return result

# 运行示例
print("计算 factorial(4):")
result = factorial(4)
print(f"\n最终结果: {result}")
```

**输出：**
```
计算 factorial(4):
→ 调用 factorial(4)
  → 调用 factorial(3)
    → 调用 factorial(2)
      → 调用 factorial(1)
      ← 返回 1
    ← 返回 2
  ← 返回 6
← 返回 24

最终结果: 24
```

**调用栈可视化：**
```
factorial(4)                    # 第1层
  ↓ 调用
factorial(3)                    # 第2层
  ↓ 调用
factorial(2)                    # 第3层
  ↓ 调用
factorial(1) → 返回 1           # 第4层（基础情况）
  ↑ 返回
factorial(2) → 返回 2           # 第3层
  ↑ 返回
factorial(3) → 返回 6           # 第2层
  ↑ 返回
factorial(4) → 返回 24          # 第1层
```

**在 AI Agent 中的应用：**
- **递归 Agent 规划**：Agent 调用子 Agent，形成调用链
- **深度限制**：防止递归过深导致栈溢出
- **调用链追踪**：记录 Agent 的执行路径

---

## 4.4 AI Agent 调用链追踪实战

**一句话：** 使用栈记录 Agent 的函数调用顺序，实现调用链可视化和调试。

```python
from typing import List, Dict, Any
from datetime import datetime

class AgentCallTracker:
    """AI Agent 调用链追踪器"""

    def __init__(self):
        self.call_stack: List[Dict[str, Any]] = []
        self.execution_log: List[Dict[str, Any]] = []

    def enter_function(self, func_name: str, args: Dict[str, Any] = None):
        """进入函数 - Push 到栈"""
        call_info = {
            'function': func_name,
            'args': args or {},
            'start_time': datetime.now(),
            'depth': len(self.call_stack)
        }
        self.call_stack.append(call_info)

        # 记录日志
        indent = "  " * call_info['depth']
        print(f"{indent}→ 进入 {func_name}({args})")

    def exit_function(self, result: Any = None):
        """退出函数 - Pop 出栈"""
        if not self.call_stack:
            raise RuntimeError("Call stack is empty")

        call_info = self.call_stack.pop()
        end_time = datetime.now()
        duration = (end_time - call_info['start_time']).total_seconds()

        # 记录执行日志
        log_entry = {
            **call_info,
            'end_time': end_time,
            'duration': duration,
            'result': result
        }
        self.execution_log.append(log_entry)

        # 输出日志
        indent = "  " * call_info['depth']
        print(f"{indent}← 退出 {call_info['function']} (耗时: {duration:.3f}s)")

    def get_current_call_chain(self) -> List[str]:
        """获取当前调用链"""
        return [call['function'] for call in self.call_stack]

    def print_execution_summary(self):
        """打印执行摘要"""
        print("\n" + "="*50)
        print("执行摘要:")
        print("="*50)
        for log in self.execution_log:
            indent = "  " * log['depth']
            print(f"{indent}{log['function']}: {log['duration']:.3f}s")

# 模拟 AI Agent 调用链
tracker = AgentCallTracker()

def research_agent(query: str):
    """研究 Agent - 搜索并分析信息"""
    tracker.enter_function('research_agent', {'query': query})

    # 调用子任务
    search_results = search_web(query)
    analysis = analyze_results(search_results)

    tracker.exit_function(result=analysis)
    return analysis

def search_web(query: str):
    """搜索 Agent"""
    tracker.enter_function('search_web', {'query': query})

    # 模拟搜索
    import time
    time.sleep(0.1)
    results = [f"Result for {query}"]

    tracker.exit_function(result=results)
    return results

def analyze_results(results: List[str]):
    """分析 Agent"""
    tracker.enter_function('analyze_results', {'count': len(results)})

    # 模拟分析
    import time
    time.sleep(0.15)
    analysis = f"Analyzed {len(results)} results"

    tracker.exit_function(result=analysis)
    return analysis

# 执行 Agent
print("开始执行 AI Agent 调用链:\n")
result = research_agent("AI Agent frameworks 2026")

# 打印执行摘要
tracker.print_execution_summary()

print(f"\n当前调用栈: {tracker.get_current_call_chain()}")
print(f"最终结果: {result}")
```

**输出示例：**
```
开始执行 AI Agent 调用链:

→ 进入 research_agent({'query': 'AI Agent frameworks 2026'})
  → 进入 search_web({'query': 'AI Agent frameworks 2026'})
  ← 退出 search_web (耗时: 0.101s)
  → 进入 analyze_results({'count': 1})
  ← 退出 analyze_results (耗时: 0.151s)
← 退出 research_agent (耗时: 0.253s)

==================================================
执行摘要:
==================================================
research_agent: 0.253s
  search_web: 0.101s
  analyze_results: 0.151s

当前调用栈: []
最终结果: Analyzed 1 results
```

**在 AI Agent 中的应用：**
- **调用链可视化**：清晰展示 Agent 的执行路径
- **性能分析**：统计每个函数的执行时间
- **调试支持**：快速定位问题所在的调用层级

---

## 4.5 栈溢出预防

**一句话：** 递归深度过大会导致栈溢出，需要设置深度限制或转换为迭代。

```python
import sys

# 查看 Python 默认递归深度限制
print(f"默认递归深度限制: {sys.getrecursionlimit()}")  # 通常是 1000

# 方法1: 设置递归深度限制
def safe_recursive_agent(depth: int, max_depth: int = 10):
    """带深度限制的递归 Agent"""
    if depth >= max_depth:
        print(f"达到最大深度 {max_depth}，停止递归")
        return

    print(f"深度 {depth}: 执行任务")
    safe_recursive_agent(depth + 1, max_depth)

# 方法2: 使用显式栈代替递归
def iterative_agent(max_depth: int = 10):
    """使用显式栈的迭代 Agent"""
    stack = [0]  # 初始深度

    while stack:
        depth = stack.pop()

        if depth >= max_depth:
            print(f"达到最大深度 {max_depth}，停止")
            continue

        print(f"深度 {depth}: 执行任务")

        # 模拟递归调用：将下一层深度压入栈
        stack.append(depth + 1)

print("\n方法1: 递归 + 深度限制")
safe_recursive_agent(0, max_depth=5)

print("\n方法2: 显式栈 + 迭代")
iterative_agent(max_depth=5)
```

**在 AI Agent 中的应用：**
- **深度限制**：防止 Agent 无限递归调用
- **迭代转换**：将递归 Agent 转换为迭代实现
- **资源保护**：避免栈溢出导致程序崩溃

---

## 这些知识足以

掌握以上 5 个核心知识点，你就能：

✅ **理解 Stack 的 LIFO 原理**
- 知道为什么后进先出
- 能用生活类比解释栈

✅ **实现基本的栈操作**
- 手写 push/pop/peek 方法
- 理解 O(1) 时间复杂度

✅ **理解递归与栈的关系**
- 知道递归调用如何使用栈
- 能可视化调用栈的变化

✅ **追踪 AI Agent 调用链**
- 实现简单的调用链追踪器
- 记录和分析 Agent 执行路径

✅ **预防栈溢出问题**
- 设置递归深度限制
- 将递归转换为迭代

---

## 下一步学习

掌握最小可用知识后，建议继续学习：

1. **核心概念深入**：详细理解栈帧结构、内存布局
2. **高级应用**：回溯搜索、表达式求值、括号匹配
3. **2026 AI Agent 实战**：LangGraph 状态追踪、R-MCTS 回溯、EnCompass 错误恢复

---

**记住：** Stack 的核心就是 LIFO + Push/Pop，理解这个原理，你就掌握了 80% 的应用场景！
