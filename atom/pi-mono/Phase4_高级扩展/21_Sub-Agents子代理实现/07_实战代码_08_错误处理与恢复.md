# é”™è¯¯å¤„ç†ä¸æ¢å¤ - å®æˆ˜ä»£ç 

> **çŸ¥è¯†ç‚¹**: Sub-Agents å­ä»£ç†å®ç° - é”™è¯¯å¤„ç†ä¸æ¢å¤æœºåˆ¶
> **éš¾åº¦**: â­â­â­â­â­
> **å‰ç½®çŸ¥è¯†**: åŸºç¡€å•ä»£ç†æ‰§è¡Œã€è¿›ç¨‹éš”ç¦»ã€çŠ¶æ€ç®¡ç†

---

## 1. åœºæ™¯æè¿°

åœ¨åˆ†å¸ƒå¼ Sub-Agents ç³»ç»Ÿä¸­ï¼Œé”™è¯¯å¤„ç†ä¸æ¢å¤æ˜¯ç”Ÿäº§ç¯å¢ƒçš„æ ¸å¿ƒèƒ½åŠ›ã€‚ä»£ç†å¯èƒ½å›  LLM é€Ÿç‡é™åˆ¶ã€ç½‘ç»œæ•…éšœã€å·¥å…·è°ƒç”¨å¤±è´¥æˆ–æ— é™å¾ªç¯è€Œä¸­æ–­ã€‚æœ‰æ•ˆçš„é”™è¯¯å¤„ç†æœºåˆ¶èƒ½ç¡®ä¿ç³»ç»Ÿå¼¹æ€§ã€ç”¨æˆ·ä½“éªŒå’Œæˆæœ¬æ§åˆ¶ã€‚

**å…¸å‹åº”ç”¨åœºæ™¯**:
- LLM API é€Ÿç‡é™åˆ¶å’Œè¶…æ—¶å¤„ç†
- å·¥å…·è°ƒç”¨å¤±è´¥çš„é‡è¯•ä¸é™çº§
- æ— é™å¾ªç¯æ£€æµ‹ä¸æ–­è·¯å™¨
- é•¿æ—¶é—´è¿è¡Œä»»åŠ¡çš„æ£€æŸ¥ç‚¹æ¢å¤
- åˆ†å¸ƒå¼ä»£ç†çš„æ•…éšœéš”ç¦»

æ ¹æ® [Redis AI Agent Orchestration](https://redis.io/blog/ai-agent-orchestration) (2026å¹´1æœˆ)ï¼Œç¼–æ’æ–¹æ³•å®ç° 100% å¯æ“ä½œå»ºè®®ï¼Œè€Œéåè°ƒå•ä»£ç†ç³»ç»Ÿä»… 1.7%ï¼Œæ“ä½œç‰¹å¼‚æ€§æé«˜ 80Ã—ã€‚[icepick](https://github.com/hatchet-dev/icepick) (559 stars) æä¾›æŒä¹…åŒ–æ‰§è¡Œå’Œäº‹ä»¶æ—¥å¿—é‡æ”¾æœºåˆ¶ï¼Œå®ç°ä¼˜é›…çš„æ•…éšœæ¢å¤ã€‚

---

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 é”™è¯¯åˆ†ç±»

| é”™è¯¯ç±»å‹ | ç‰¹å¾ | å¤„ç†ç­–ç•¥ |
|---------|------|---------|
| **ä¸´æ—¶é”™è¯¯** | ç½‘ç»œè¶…æ—¶ã€é€Ÿç‡é™åˆ¶ | æŒ‡æ•°é€€é¿é‡è¯• |
| **æ°¸ä¹…é”™è¯¯** | è®¤è¯å¤±è´¥ã€æ— æ•ˆè¾“å…¥ | ç«‹å³å¤±è´¥ï¼Œä¸é‡è¯• |
| **ä¸šåŠ¡é”™è¯¯** | é€»è¾‘å†²çªã€æ•°æ®ä¸ä¸€è‡´ | äººå·¥å¹²é¢„ (HITL) |

### 2.2 å¼¹æ€§æ¨¡å¼

æ ¹æ® [AI Agent Architecture Patterns](https://medium.com/@topuzas/ai-agent-architecture-patterns-engineering-for-autonomy-resilience-and-control-7f2a4888db14) (2026å¹´2æœˆ):

1. **æŒ‡æ•°é€€é¿é‡è¯•** - åº”å¯¹ LLM ä¸å¯é¢„æµ‹æ€§
2. **æ–­è·¯å™¨æ¨¡å¼** - é˜²æ­¢çº§è”æ•…éšœ
3. **æ£€æŸ¥ç‚¹æœºåˆ¶** - é•¿æ—¶é—´è¿è¡Œå·¥ä½œæµ
4. **å¹‚ç­‰æ“ä½œ** - å®‰å…¨é‡è¯•ä¿è¯
5. **ä¼˜é›…é™çº§** - éƒ¨åˆ†åŠŸèƒ½å¤±è´¥æ—¶çš„å›é€€ç­–ç•¥

### 2.3 Reasoning Circuit Breaker

**æ¡ˆä¾‹**: å®¢æˆ·æ”¯æŒä»£ç†åœ¨2åˆ†é’Ÿå†…æ‰§è¡Œäº†40æ¬¡é€€æ¬¾æ“ä½œ

**è§£å†³æ–¹æ¡ˆ**: å¦‚æœä»£ç†ä½¿ç”¨ç›¸åŒå‚æ•°è°ƒç”¨åŒä¸€å·¥å…·è¶…è¿‡3æ¬¡ï¼ˆ"Stuttering Check"ï¼‰ï¼Œæ–­è·¯å™¨è·³é—¸åˆ° Open çŠ¶æ€ï¼Œä»£ç†çŠ¶æ€è¢«æŒä¹…åŒ–ï¼Œè§¦å‘ SRE å‘Šè­¦è¿›è¡Œäººå·¥å¹²é¢„ã€‚

---

## 3. å®Œæ•´ä»£ç ç¤ºä¾‹

### 3.1 é”™è¯¯å¤„ç†ç®¡ç†å™¨

```typescript
import { ExtensionAPI } from "@pi-mono/extension-api";
import { SubagentParams } from "./types";

/**
 * é”™è¯¯ç±»å‹å®šä¹‰
 */
export enum ErrorType {
  TRANSIENT = "transient",    // ä¸´æ—¶é”™è¯¯ï¼Œå¯é‡è¯•
  PERMANENT = "permanent",    // æ°¸ä¹…é”™è¯¯ï¼Œä¸å¯é‡è¯•
  BUSINESS = "business",      // ä¸šåŠ¡é”™è¯¯ï¼Œéœ€äººå·¥å¹²é¢„
}

export interface AgentError {
  type: ErrorType;
  message: string;
  code?: string;
  retryable: boolean;
  metadata?: Record<string, any>;
}

/**
 * é‡è¯•é…ç½®
 */
export interface RetryConfig {
  maxRetries: number;
  baseDelay: number;        // åŸºç¡€å»¶è¿Ÿ (ms)
  maxDelay: number;         // æœ€å¤§å»¶è¿Ÿ (ms)
  backoffMultiplier: number; // é€€é¿å€æ•°
  jitter: boolean;          // æ·»åŠ éšæœºæŠ–åŠ¨
}

/**
 * æ–­è·¯å™¨çŠ¶æ€
 */
enum CircuitState {
  CLOSED = "closed",      // æ­£å¸¸è¿è¡Œ
  OPEN = "open",          // æ–­è·¯ï¼Œæ‹’ç»è¯·æ±‚
  HALF_OPEN = "half_open" // åŠå¼€ï¼Œå°è¯•æ¢å¤
}

/**
 * é”™è¯¯å¤„ç†ç®¡ç†å™¨
 * 
 * å‚è€ƒ:
 * - https://github.com/hatchet-dev/icepick (æŒä¹…åŒ–æ‰§è¡Œ)
 * - https://redis.io/blog/ai-agent-orchestration (å¼¹æ€§æ¨¡å¼)
 */
export class ErrorHandlingManager {
  private retryConfig: RetryConfig;
  private circuitState: CircuitState = CircuitState.CLOSED;
  private failureCount: number = 0;
  private lastFailureTime?: Date;
  private toolCallHistory: Map<string, number> = new Map();

  constructor(config?: Partial<RetryConfig>) {
    this.retryConfig = {
      maxRetries: 3,
      baseDelay: 1000,
      maxDelay: 30000,
      backoffMultiplier: 2,
      jitter: true,
      ...config,
    };
  }

  /**
   * æŒ‡æ•°é€€é¿é‡è¯•
   * 
   * å‚è€ƒ: https://github.com/EunixTech/ai-agent-flow
   */
  async retryWithBackoff<T>(
    fn: () => Promise<T>,
    errorClassifier: (error: any) => AgentError
  ): Promise<T> {
    let lastError: AgentError | undefined;

    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {
      try {
        // æ£€æŸ¥æ–­è·¯å™¨çŠ¶æ€
        if (this.circuitState === CircuitState.OPEN) {
          throw new Error("Circuit breaker is OPEN - rejecting request");
        }

        const result = await fn();
        
        // æˆåŠŸåé‡ç½®æ–­è·¯å™¨
        this.onSuccess();
        return result;

      } catch (error) {
        lastError = errorClassifier(error);

        // æ°¸ä¹…é”™è¯¯ä¸é‡è¯•
        if (!lastError.retryable) {
          this.onFailure(lastError);
          throw error;
        }

        // æœ€åä¸€æ¬¡å°è¯•å¤±è´¥
        if (attempt === this.retryConfig.maxRetries) {
          this.onFailure(lastError);
          throw error;
        }

        // è®¡ç®—å»¶è¿Ÿæ—¶é—´
        const delay = this.calculateDelay(attempt);
        console.log(`Retry attempt ${attempt + 1}/${this.retryConfig.maxRetries} after ${delay}ms`);
        
        await this.sleep(delay);
      }
    }

    throw lastError;
  }

  /**
   * è®¡ç®—é€€é¿å»¶è¿Ÿ
   */
  private calculateDelay(attempt: number): number {
    let delay = Math.min(
      this.retryConfig.baseDelay * Math.pow(this.retryConfig.backoffMultiplier, attempt),
      this.retryConfig.maxDelay
    );

    // æ·»åŠ éšæœºæŠ–åŠ¨ (Â±25%)
    if (this.retryConfig.jitter) {
      const jitter = delay * 0.25 * (Math.random() * 2 - 1);
      delay += jitter;
    }

    return Math.floor(delay);
  }

  /**
   * Stuttering Check - æ£€æµ‹æ— é™å¾ªç¯
   * 
   * å‚è€ƒ: https://medium.com/@topuzas/ai-agent-architecture-patterns
   */
  checkStuttering(toolName: string, params: string): boolean {
    const key = `${toolName}:${params}`;
    const count = (this.toolCallHistory.get(key) || 0) + 1;
    this.toolCallHistory.set(key, count);

    // ç›¸åŒå·¥å…·+å‚æ•°è°ƒç”¨è¶…è¿‡3æ¬¡ï¼Œè§¦å‘æ–­è·¯å™¨
    if (count > 3) {
      console.warn(`âš ï¸  Stuttering detected: ${toolName} called ${count} times with same params`);
      this.circuitState = CircuitState.OPEN;
      return true;
    }

    return false;
  }

  /**
   * æˆåŠŸå›è°ƒ - é‡ç½®æ–­è·¯å™¨
   */
  private onSuccess(): void {
    this.failureCount = 0;
    this.circuitState = CircuitState.CLOSED;
    this.toolCallHistory.clear();
  }

  /**
   * å¤±è´¥å›è°ƒ - æ›´æ–°æ–­è·¯å™¨çŠ¶æ€
   */
  private onFailure(error: AgentError): void {
    this.failureCount++;
    this.lastFailureTime = new Date();

    // å¤±è´¥æ¬¡æ•°è¶…è¿‡é˜ˆå€¼ï¼Œæ‰“å¼€æ–­è·¯å™¨
    if (this.failureCount >= 5) {
      this.circuitState = CircuitState.OPEN;
      console.error(`ğŸ”´ Circuit breaker OPEN after ${this.failureCount} failures`);
    }
  }

  /**
   * è·å–æ–­è·¯å™¨çŠ¶æ€
   */
  getCircuitState(): CircuitState {
    return this.circuitState;
  }

  /**
   * æ‰‹åŠ¨é‡ç½®æ–­è·¯å™¨
   */
  resetCircuit(): void {
    this.circuitState = CircuitState.CLOSED;
    this.failureCount = 0;
    this.toolCallHistory.clear();
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

/**
 * é”™è¯¯åˆ†ç±»å™¨
 */
export function classifyError(error: any): AgentError {
  const message = error.message || String(error);

  // LLM é€Ÿç‡é™åˆ¶
  if (message.includes("rate_limit") || message.includes("429")) {
    return {
      type: ErrorType.TRANSIENT,
      message: "LLM rate limit exceeded",
      code: "RATE_LIMIT",
      retryable: true,
      metadata: { error },
    };
  }

  // ç½‘ç»œè¶…æ—¶
  if (message.includes("timeout") || message.includes("ETIMEDOUT")) {
    return {
      type: ErrorType.TRANSIENT,
      message: "Network timeout",
      code: "TIMEOUT",
      retryable: true,
      metadata: { error },
    };
  }

  // è®¤è¯å¤±è´¥
  if (message.includes("auth") || message.includes("401") || message.includes("403")) {
    return {
      type: ErrorType.PERMANENT,
      message: "Authentication failed",
      code: "AUTH_FAILED",
      retryable: false,
      metadata: { error },
    };
  }

  // æ— æ•ˆè¾“å…¥
  if (message.includes("invalid") || message.includes("400")) {
    return {
      type: ErrorType.PERMANENT,
      message: "Invalid input",
      code: "INVALID_INPUT",
      retryable: false,
      metadata: { error },
    };
  }

  // é»˜è®¤ä¸ºä¸´æ—¶é”™è¯¯
  return {
    type: ErrorType.TRANSIENT,
    message: message,
    code: "UNKNOWN",
    retryable: true,
    metadata: { error },
  };
}
```

### 3.2 æ£€æŸ¥ç‚¹ä¸æ¢å¤

```typescript
/**
 * æ£€æŸ¥ç‚¹ç®¡ç†å™¨
 * 
 * å‚è€ƒ: https://github.com/hatchet-dev/icepick (äº‹ä»¶æ—¥å¿—é‡æ”¾)
 */
export interface Checkpoint {
  id: string;
  timestamp: Date;
  state: any;
  completedSteps: string[];
  metadata?: Record<string, any>;
}

export class CheckpointManager {
  private checkpoints: Map<string, Checkpoint> = new Map();

  /**
   * ä¿å­˜æ£€æŸ¥ç‚¹
   */
  async saveCheckpoint(
    executionId: string,
    state: any,
    completedSteps: string[]
  ): Promise<void> {
    const checkpoint: Checkpoint = {
      id: executionId,
      timestamp: new Date(),
      state: JSON.parse(JSON.stringify(state)), // æ·±æ‹·è´
      completedSteps: [...completedSteps],
    };

    this.checkpoints.set(executionId, checkpoint);
    console.log(`âœ… Checkpoint saved: ${executionId} (${completedSteps.length} steps)`);
  }

  /**
   * æ¢å¤æ£€æŸ¥ç‚¹
   */
  async restoreCheckpoint(executionId: string): Promise<Checkpoint | null> {
    const checkpoint = this.checkpoints.get(executionId);
    
    if (checkpoint) {
      console.log(`ğŸ”„ Restoring checkpoint: ${executionId} (${checkpoint.completedSteps.length} steps)`);
      return checkpoint;
    }

    return null;
  }

  /**
   * æ¸…ç†æ£€æŸ¥ç‚¹
   */
  clearCheckpoint(executionId: string): void {
    this.checkpoints.delete(executionId);
  }
}
```

### 3.3 é›†æˆåˆ° Subagent Extension

```typescript
import { ExtensionAPI } from "@pi-mono/extension-api";
import { ErrorHandlingManager, classifyError } from "./error-handling";
import { CheckpointManager } from "./checkpoint";

export default function (pi: ExtensionAPI) {
  const errorManager = new ErrorHandlingManager({
    maxRetries: 3,
    baseDelay: 1000,
    maxDelay: 30000,
    backoffMultiplier: 2,
    jitter: true,
  });

  const checkpointManager = new CheckpointManager();

  pi.registerTool({
    name: "subagent",
    description: "Execute sub-agents with error handling and recovery",
    parameters: SubagentParams,
    
    async execute(toolCallId, params, signal, onUpdate, ctx) {
      const executionId = `exec_${Date.now()}`;
      const completedSteps: string[] = [];

      try {
        // å°è¯•æ¢å¤æ£€æŸ¥ç‚¹
        const checkpoint = await checkpointManager.restoreCheckpoint(executionId);
        if (checkpoint) {
          console.log(`Resuming from checkpoint with ${checkpoint.completedSteps.length} completed steps`);
          completedSteps.push(...checkpoint.completedSteps);
        }

        // ä½¿ç”¨é‡è¯•æœºåˆ¶æ‰§è¡Œä»£ç†
        const result = await errorManager.retryWithBackoff(
          async () => {
            // æ£€æŸ¥ Stuttering
            const paramsKey = JSON.stringify(params);
            if (errorManager.checkStuttering("subagent", paramsKey)) {
              throw new Error("Infinite loop detected - circuit breaker triggered");
            }

            // æ‰§è¡Œä»£ç†
            const agentResult = await executeAgent(params, signal, onUpdate, ctx);
            
            // ä¿å­˜æ£€æŸ¥ç‚¹
            completedSteps.push(params.agent || "unknown");
            await checkpointManager.saveCheckpoint(executionId, agentResult, completedSteps);
            
            return agentResult;
          },
          classifyError
        );

        // æ¸…ç†æ£€æŸ¥ç‚¹
        checkpointManager.clearCheckpoint(executionId);

        return {
          type: "success" as const,
          output: result,
        };

      } catch (error) {
        // é”™è¯¯å¤„ç†
        const agentError = classifyError(error);
        
        console.error(`âŒ Agent execution failed: ${agentError.message}`);
        console.error(`   Type: ${agentError.type}, Retryable: ${agentError.retryable}`);

        // ä¸šåŠ¡é”™è¯¯éœ€è¦äººå·¥å¹²é¢„
        if (agentError.type === "business") {
          onUpdate?.({
            type: "error",
            content: `âš ï¸  Business error detected - human intervention required: ${agentError.message}`,
          });
        }

        return {
          type: "error" as const,
          error: agentError.message,
          metadata: agentError.metadata,
        };
      }
    },
  });
}

async function executeAgent(params: any, signal: any, onUpdate: any, ctx: any): Promise<string> {
  // å®é™…çš„ä»£ç†æ‰§è¡Œé€»è¾‘
  // è¿™é‡Œç®€åŒ–ä¸ºç¤ºä¾‹
  return "Agent execution result";
}
```

---

## 4. ä»£ç è§£æ

### 4.1 æŒ‡æ•°é€€é¿ç®—æ³•

```typescript
delay = min(baseDelay * (backoffMultiplier ^ attempt), maxDelay)
```

**ç¤ºä¾‹**:
- Attempt 0: 1000ms
- Attempt 1: 2000ms
- Attempt 2: 4000ms
- Attempt 3: 8000ms

æ·»åŠ  Â±25% éšæœºæŠ–åŠ¨é˜²æ­¢é›·é¸£ç¾¤æ•ˆåº” (thundering herd)ã€‚

### 4.2 Stuttering Check

æ£€æµ‹ä»£ç†æ˜¯å¦é™·å…¥æ— é™å¾ªç¯ï¼š
1. è®°å½•æ¯æ¬¡å·¥å…·è°ƒç”¨çš„ `toolName + params` ç»„åˆ
2. å¦‚æœç›¸åŒç»„åˆè°ƒç”¨è¶…è¿‡3æ¬¡ï¼Œè§¦å‘æ–­è·¯å™¨
3. æ–­è·¯å™¨æ‰“å¼€åæ‹’ç»æ–°è¯·æ±‚ï¼Œä¿æŠ¤ç³»ç»Ÿ

### 4.3 æ£€æŸ¥ç‚¹æœºåˆ¶

åŸºäº [icepick çš„äº‹ä»¶æ—¥å¿—é‡æ”¾](https://github.com/hatchet-dev/icepick):

```
Event log:
-> Start search_documents (completed)
-> Start get_document (completed)
-> Start extract_from_document (failed)

[æ¢å¤å]
-> Skip search_documents (replayed)
-> Skip get_document (replayed)
-> Retry extract_from_document
```

---

## 5. å®é™…æ¡ˆä¾‹åˆ†æ

### æ¡ˆä¾‹ 1: å¤§è§„æ¨¡ç”Ÿäº§ç¯å¢ƒ (10äº¿ tokens/å‘¨)

**æ¥æº**: [Reddit: Consuming 1 billion tokens every week](https://www.reddit.com/r/AI_Agents/comments/1kiz7ie/consuming_1_billion_tokens_every_week_heres_what)

**è§„æ¨¡**: æ¯å‘¨æ¶ˆè€— 10 äº¿ tokens

**å…³é”®ç»éªŒ**:
- å¤šç§é‡è¯•ç­–ç•¥ï¼šæŒ‡æ•°é€€é¿ã€å›ºå®šå»¶è¿Ÿã€ç«‹å³é‡è¯•
- é”™è¯¯æ¢å¤æœºåˆ¶ï¼šè‡ªåŠ¨é™çº§åˆ°å¤‡ç”¨æ¨¡å‹
- å½“æ‰€æœ‰å¤±è´¥æ—¶é€šçŸ¥ç”¨æˆ·ç»§ç»­å¤„ç†

**å®ç°**:
```typescript
const strategies = [
  { type: "exponential", maxRetries: 3 },
  { type: "fixed", delay: 5000, maxRetries: 2 },
  { type: "immediate", maxRetries: 1 },
];
```

### æ¡ˆä¾‹ 2: å®¢æˆ·æ”¯æŒä»£ç†æ— é™å¾ªç¯

**æ¥æº**: [AI Agent Architecture Patterns](https://medium.com/@topuzas/ai-agent-architecture-patterns-engineering-for-autonomy-resilience-and-control-7f2a4888db14)

**é—®é¢˜**: ä»£ç†åœ¨2åˆ†é’Ÿå†…æ‰§è¡Œäº†40æ¬¡é€€æ¬¾æ“ä½œ

**åŸå› **: API å“åº”çš„è¯­ä¹‰æ­§ä¹‰ï¼Œä»£ç†å°†"Success"è¯¯è§£ä¸º"Failure"

**è§£å†³æ–¹æ¡ˆ**:
1. å®ç° Stuttering Check (ç›¸åŒå‚æ•°è°ƒç”¨3æ¬¡è§¦å‘)
2. æ–­è·¯å™¨è·³é—¸åˆ° Open çŠ¶æ€
3. æŒä¹…åŒ–ä»£ç†çŠ¶æ€
4. è§¦å‘ SRE å‘Šè­¦è¿›è¡Œäººå·¥å¹²é¢„

### æ¡ˆä¾‹ 3: Redis ç”Ÿäº§ç³»ç»Ÿå¼¹æ€§

**æ¥æº**: [Redis AI Agent Orchestration](https://redis.io/blog/ai-agent-orchestration)

**ç»Ÿè®¡æ•°æ®**:
- ç¼–æ’æ–¹æ³•å®ç° 100% å¯æ“ä½œå»ºè®®
- éåè°ƒå•ä»£ç†ç³»ç»Ÿä»… 1.7%
- æ“ä½œç‰¹å¼‚æ€§æé«˜ 80Ã—
- è§£å†³æ–¹æ¡ˆæ­£ç¡®æ€§æé«˜ 140Ã—

**å…³é”®æ¨¡å¼**:
1. äºšæ¯«ç§’çº§çŠ¶æ€è®¿é—®ï¼ˆé˜²æ­¢ç«æ€æ¡ä»¶ï¼‰
2. è¯­ä¹‰ç¼“å­˜ï¼ˆè§£å†³ 40-50% æ‰§è¡Œæ—¶é—´å¼€é”€ï¼‰
3. 70% ç¼“å­˜å‘½ä¸­ç‡ï¼Œé™ä½ LLM æˆæœ¬ 70%

### æ¡ˆä¾‹ 4: icepick æŒä¹…åŒ–æ‰§è¡Œ

**æ¥æº**: [icepick GitHub](https://github.com/hatchet-dev/icepick)

**æ ¸å¿ƒæœºåˆ¶**: Durable Task Queue (Hatchet)

**ä¼˜åŠ¿**:
- è‡ªåŠ¨æ£€æŸ¥ç‚¹ï¼šæ‰§è¡Œå†å²è¢«ç¼“å­˜
- æ— éœ€é‡åšå·¥ä½œï¼šåªé‡æ”¾å¤±è´¥æ­¥éª¤
- å¤–éƒ¨äº‹ä»¶ç­‰å¾…ï¼šå¯ç­‰å¾…äººå·¥å®¡æ ¸è€Œä¸æ¶ˆè€—èµ„æº
- åˆ†å¸ƒå¼æ‰§è¡Œï¼šæœºå™¨å¤±è´¥æ—¶è‡ªåŠ¨é‡æ–°è°ƒåº¦

**æœ€ä½³å®è·µ**:
1. ä»£ç†åº”è¯¥æ˜¯æ— å‰¯ä½œç”¨çš„æ— çŠ¶æ€ reducer
2. ä¸åº”ä¾èµ–å¤–éƒ¨ API è°ƒç”¨ã€æ•°æ®åº“è°ƒç”¨
3. çŠ¶æ€ç”±å·¥å…·è°ƒç”¨ç»“æœå†³å®š
4. æ‰€æœ‰å·¥ä½œä½œä¸ºä»»åŠ¡æˆ–å·¥å…·è°ƒç”¨

---

## 6. æœ€ä½³å®è·µ

### 6.1 é”™è¯¯åˆ†ç±»ç­–ç•¥

```typescript
// âœ… æ­£ç¡®ï¼šæ˜ç¡®åˆ†ç±»é”™è¯¯
if (error.code === "RATE_LIMIT") {
  return { type: ErrorType.TRANSIENT, retryable: true };
}

// âŒ é”™è¯¯ï¼šæ‰€æœ‰é”™è¯¯éƒ½é‡è¯•
return { type: ErrorType.TRANSIENT, retryable: true };
```

### 6.2 é‡è¯•é…ç½®

**æ¨èé…ç½®**:
- `maxRetries`: 3-5 æ¬¡
- `baseDelay`: 1000ms
- `maxDelay`: 30000ms (30ç§’)
- `backoffMultiplier`: 2
- `jitter`: true

### 6.3 æ–­è·¯å™¨é˜ˆå€¼

**æ¨èé˜ˆå€¼**:
- Stuttering Check: 3æ¬¡ç›¸åŒè°ƒç”¨
- å¤±è´¥æ¬¡æ•°: 5æ¬¡è¿ç»­å¤±è´¥
- æ¢å¤æ—¶é—´: 60ç§’åå°è¯• Half-Open

### 6.4 æ£€æŸ¥ç‚¹é¢‘ç‡

**æ¨èç­–ç•¥**:
- æ¯å®Œæˆä¸€ä¸ªä¸»è¦æ­¥éª¤ä¿å­˜æ£€æŸ¥ç‚¹
- é•¿æ—¶é—´è¿è¡Œä»»åŠ¡æ¯5åˆ†é’Ÿä¿å­˜
- å…³é”®çŠ¶æ€å˜æ›´æ—¶ç«‹å³ä¿å­˜

### 6.5 ç›‘æ§æŒ‡æ ‡

**å…³é”®æŒ‡æ ‡**:
- é”™è¯¯ç‡ (æŒ‰ç±»å‹åˆ†ç±»)
- é‡è¯•æ¬¡æ•°å’ŒæˆåŠŸç‡
- æ–­è·¯å™¨çŠ¶æ€å˜åŒ–
- å¹³å‡æ¢å¤æ—¶é—´ (MTTR)
- æ£€æŸ¥ç‚¹ä¿å­˜/æ¢å¤æ¬¡æ•°

---

## 7. å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•åŒºåˆ†ä¸´æ—¶é”™è¯¯å’Œæ°¸ä¹…é”™è¯¯ï¼Ÿ

**A**: ä½¿ç”¨é”™è¯¯ç å’Œæ¶ˆæ¯æ¨¡å¼åŒ¹é…ï¼š
- ä¸´æ—¶é”™è¯¯: 429 (rate limit), 503 (service unavailable), timeout
- æ°¸ä¹…é”™è¯¯: 401/403 (auth), 400 (invalid input), 404 (not found)

### Q2: é‡è¯•æ¬¡æ•°åº”è¯¥è®¾ç½®å¤šå°‘ï¼Ÿ

**A**: æ ¹æ®åœºæ™¯ï¼š
- LLM API è°ƒç”¨: 3-5æ¬¡ï¼ˆé€Ÿç‡é™åˆ¶æ¢å¤å¿«ï¼‰
- å¤–éƒ¨æœåŠ¡: 2-3æ¬¡ï¼ˆé¿å…é•¿æ—¶é—´ç­‰å¾…ï¼‰
- å…³é”®æ“ä½œ: 5-10æ¬¡ï¼ˆç¡®ä¿æˆåŠŸï¼‰

### Q3: å¦‚ä½•é˜²æ­¢æ£€æŸ¥ç‚¹æ•°æ®è¿‡å¤§ï¼Ÿ

**A**: 
1. åªä¿å­˜å¿…è¦çŠ¶æ€ï¼Œä¸ä¿å­˜å®Œæ•´ä¸Šä¸‹æ–‡
2. ä½¿ç”¨è¯­ä¹‰å‹ç¼©ï¼ˆæ‘˜è¦åµŒå…¥ï¼‰
3. å®šæœŸæ¸…ç†è¿‡æœŸæ£€æŸ¥ç‚¹
4. é™åˆ¶æ£€æŸ¥ç‚¹å¤§å°ï¼ˆå¦‚ 1MBï¼‰

### Q4: æ–­è·¯å™¨æ‰“å¼€åå¦‚ä½•æ¢å¤ï¼Ÿ

**A**:
1. ç­‰å¾…å†·å´æœŸï¼ˆå¦‚60ç§’ï¼‰
2. è¿›å…¥ Half-Open çŠ¶æ€
3. å°è¯•ä¸€æ¬¡è¯·æ±‚
4. æˆåŠŸåˆ™ Closedï¼Œå¤±è´¥åˆ™ Open

### Q5: å¦‚ä½•å¤„ç†ä¸šåŠ¡é”™è¯¯ï¼Ÿ

**A**:
1. ä¸è¦è‡ªåŠ¨é‡è¯•
2. æŒä¹…åŒ–é”™è¯¯çŠ¶æ€
3. è§¦å‘ HITL (Human-in-the-loop)
4. æä¾›è¯¦ç»†é”™è¯¯ä¸Šä¸‹æ–‡

---

## 8. æ‰©å±•é˜…è¯»

### æ ¸å¿ƒèµ„æº

1. [ai-agent-flow GitHub](https://github.com/EunixTech/ai-agent-flow) - TypeScript æ¡†æ¶ï¼Œå†…ç½®é‡è¯•å’Œé”™è¯¯å¤„ç†
2. [icepick GitHub](https://github.com/hatchet-dev/icepick) - æŒä¹…åŒ–æ‰§è¡Œä¸æ•…éšœæ¢å¤
3. [Redis AI Agent Orchestration](https://redis.io/blog/ai-agent-orchestration) - ç”Ÿäº§ç³»ç»Ÿå¼¹æ€§æ¨¡å¼
4. [AI Agent Architecture Patterns](https://medium.com/@topuzas/ai-agent-architecture-patterns-engineering-for-autonomy-resilience-and-control-7f2a4888db14) - ç”Ÿäº§çº§å¼¹æ€§æ¨¡å¼

### ç¤¾åŒºè®¨è®º

5. [Reddit: Consuming 1 billion tokens](https://www.reddit.com/r/AI_Agents/comments/1kiz7ie/consuming_1_billion_tokens_every_week_heres_what) - å¤§è§„æ¨¡ç”Ÿäº§ç»éªŒ
6. [Reddit: Google's 2025 Agent Architecture](https://www.reddit.com/r/GeminiAI/comments/1pjv90t/beyond_the_hype_what_i_learned_analyzing_googles) - Agent Ops ç“¶é¢ˆåˆ†æ

### ç›¸å…³çŸ¥è¯†ç‚¹

- `03_æ ¸å¿ƒæ¦‚å¿µ_08_é”™è¯¯å¤„ç†ä¸ä¸­æ–­æœºåˆ¶.md` - ç†è®ºåŸºç¡€
- `07_å®æˆ˜ä»£ç _03_é“¾å¼å·¥ä½œæµå®ç°.md` - å·¥ä½œæµé”™è¯¯ä¼ æ’­
- `07_å®æˆ˜ä»£ç _10_ç”Ÿäº§éƒ¨ç½²ä¸æœ€ä½³å®è·µ.md` - ç”Ÿäº§ç¯å¢ƒç›‘æ§

---

**ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2026-02-21
**ä½œè€…**: Claude Code (åŸºäº 2025-2026 æœ€æ–°å®è·µ)
