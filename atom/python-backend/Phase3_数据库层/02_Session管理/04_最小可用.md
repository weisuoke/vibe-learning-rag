# 【最小可用】Session管理

> 5分钟上手 Session，快速开始数据库操作

---

## 最小可用代码

### 1. 创建 Engine 和 SessionMaker

```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

# 数据库连接字符串
DATABASE_URL = "postgresql://user:password@localhost:5432/mydb"

# 创建引擎（全局单例）
engine = create_engine(DATABASE_URL)

# 创建 SessionMaker（Session 工厂）
SessionLocal = sessionmaker(bind=engine)

# 创建 Base 类（用于定义模型）
Base = declarative_base()
```

---

### 2. 定义模型

```python
# models.py
from sqlalchemy import Column, Integer, String
from database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, index=True)
```

---

### 3. 使用 Session（基础方式）

```python
# 创建 Session
session = SessionLocal()

try:
    # 创建用户
    user = User(name="Alice", email="alice@example.com")
    session.add(user)
    session.commit()

    # 查询用户
    users = session.query(User).all()
    print(users)

except Exception as e:
    # 出错时回滚
    session.rollback()
    print(f"Error: {e}")

finally:
    # 关闭 Session
    session.close()
```

---

### 4. 使用上下文管理器（推荐）

```python
# 自动管理 Session 生命周期
with SessionLocal() as session:
    # 创建用户
    user = User(name="Bob", email="bob@example.com")
    session.add(user)
    session.commit()

    # 查询用户
    users = session.query(User).all()
    print(users)

# Session 自动关闭
```

---

### 5. FastAPI 集成（生产推荐）

```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql://user:password@localhost:5432/mydb"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

# 依赖注入函数
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

```python
# main.py
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from database import get_db
from models import User

app = FastAPI()

@app.post("/users")
def create_user(name: str, email: str, db: Session = Depends(get_db)):
    user = User(name=name, email=email)
    db.add(user)
    db.commit()
    db.refresh(user)  # 刷新对象，获取数据库生成的 ID
    return user

@app.get("/users")
def get_users(db: Session = Depends(get_db)):
    return db.query(User).all()
```

---

## 核心操作速查

### 创建（Create）

```python
with SessionLocal() as session:
    user = User(name="Alice", email="alice@example.com")
    session.add(user)
    session.commit()
```

### 查询（Read）

```python
with SessionLocal() as session:
    # 查询所有
    users = session.query(User).all()

    # 查询单个
    user = session.query(User).filter_by(id=1).first()

    # 条件查询
    users = session.query(User).filter(User.name == "Alice").all()
```

### 更新（Update）

```python
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()
    user.name = "Alice Updated"
    session.commit()
```

### 删除（Delete）

```python
with SessionLocal() as session:
    user = session.query(User).filter_by(id=1).first()
    session.delete(user)
    session.commit()
```

---

## 常见场景

### 场景1：批量插入

```python
with SessionLocal() as session:
    users = [
        User(name="Alice", email="alice@example.com"),
        User(name="Bob", email="bob@example.com"),
        User(name="Charlie", email="charlie@example.com"),
    ]
    session.add_all(users)
    session.commit()
```

### 场景2：事务回滚

```python
with SessionLocal() as session:
    try:
        user1 = User(name="Alice", email="alice@example.com")
        session.add(user1)

        # 模拟错误
        user2 = User(name="Bob", email="alice@example.com")  # 重复邮箱
        session.add(user2)

        session.commit()
    except Exception as e:
        session.rollback()  # 回滚所有操作
        print(f"Error: {e}")
```

### 场景3：只读查询（不需要 commit）

```python
with SessionLocal() as session:
    users = session.query(User).all()
    # 只读操作，不需要 commit
    return users
```

---

## 完整示例：FastAPI + SQLAlchemy

```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "postgresql://user:password@localhost:5432/mydb"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

```python
# models.py
from sqlalchemy import Column, Integer, String
from database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, index=True)
```

```python
# schemas.py
from pydantic import BaseModel

class UserCreate(BaseModel):
    name: str
    email: str

class UserResponse(BaseModel):
    id: int
    name: str
    email: str

    class Config:
        from_attributes = True
```

```python
# main.py
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session
from database import get_db, engine, Base
from models import User
from schemas import UserCreate, UserResponse

# 创建表
Base.metadata.create_all(bind=engine)

app = FastAPI()

@app.post("/users", response_model=UserResponse)
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    db_user = User(name=user.name, email=user.email)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@app.get("/users", response_model=list[UserResponse])
def get_users(db: Session = Depends(get_db)):
    return db.query(User).all()

@app.get("/users/{user_id}", response_model=UserResponse)
def get_user(user_id: int, db: Session = Depends(get_db)):
    user = db.query(User).filter_by(id=user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

@app.put("/users/{user_id}", response_model=UserResponse)
def update_user(user_id: int, user: UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(User).filter_by(id=user_id).first()
    if not db_user:
        raise HTTPException(status_code=404, detail="User not found")

    db_user.name = user.name
    db_user.email = user.email
    db.commit()
    db.refresh(db_user)
    return db_user

@app.delete("/users/{user_id}")
def delete_user(user_id: int, db: Session = Depends(get_db)):
    db_user = db.query(User).filter_by(id=user_id).first()
    if not db_user:
        raise HTTPException(status_code=404, detail="User not found")

    db.delete(db_user)
    db.commit()
    return {"message": "User deleted"}
```

---

## 运行步骤

### 1. 安装依赖

```bash
uv add fastapi uvicorn sqlalchemy psycopg2-binary
```

### 2. 启动 PostgreSQL

```bash
# 使用 Docker
docker run -d \
  --name postgres \
  -e POSTGRES_USER=user \
  -e POSTGRES_PASSWORD=password \
  -e POSTGRES_DB=mydb \
  -p 5432:5432 \
  postgres:14
```

### 3. 运行应用

```bash
uvicorn main:app --reload
```

### 4. 测试 API

```bash
# 创建用户
curl -X POST "http://localhost:8000/users" \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "email": "alice@example.com"}'

# 查询所有用户
curl "http://localhost:8000/users"

# 查询单个用户
curl "http://localhost:8000/users/1"

# 更新用户
curl -X PUT "http://localhost:8000/users/1" \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice Updated", "email": "alice@example.com"}'

# 删除用户
curl -X DELETE "http://localhost:8000/users/1"
```

---

## 核心要点

1. **Engine 是全局单例**：整个应用只创建一次
2. **SessionMaker 是工厂**：用于创建 Session
3. **Session 是请求级别**：每个请求创建一个，用完即关
4. **使用上下文管理器**：自动处理关闭和异常
5. **FastAPI 用依赖注入**：`Depends(get_db)` 是最佳实践

---

## 常见错误

### 错误1：忘记 commit

```python
# ❌ 错误：没有 commit
with SessionLocal() as session:
    user = User(name="Alice", email="alice@example.com")
    session.add(user)
    # 忘记 commit，数据不会保存

# ✅ 正确
with SessionLocal() as session:
    user = User(name="Alice", email="alice@example.com")
    session.add(user)
    session.commit()  # 必须 commit
```

### 错误2：忘记关闭 Session

```python
# ❌ 错误：没有关闭 Session
session = SessionLocal()
user = session.query(User).all()
# 忘记关闭，导致连接泄漏

# ✅ 正确：使用上下文管理器
with SessionLocal() as session:
    user = session.query(User).all()
# 自动关闭
```

### 错误3：跨请求共享 Session

```python
# ❌ 错误：全局 Session
global_session = SessionLocal()

@app.get("/users")
def get_users():
    return global_session.query(User).all()  # 线程不安全

# ✅ 正确：每个请求独立 Session
@app.get("/users")
def get_users(db: Session = Depends(get_db)):
    return db.query(User).all()
```

---

## 下一步

- 学习 **Session 创建与配置**（核心概念1）
- 学习 **事务管理**（核心概念2）
- 学习 **FastAPI 依赖注入集成**（核心概念3）

---

**记住：** Engine 全局单例，SessionMaker 是工厂，Session 请求级别，用完即关。
