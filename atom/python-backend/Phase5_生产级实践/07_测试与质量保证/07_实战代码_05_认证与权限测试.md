# 实战代码 05 - 认证与权限测试

## 项目结构

```
project/
├── app/
│   ├── auth/
│   │   ├── jwt.py
│   │   ├── password.py
│   │   └── dependencies.py
│   ├── api/
│   │   └── auth.py
│   └── models/
│       └── user.py
├── tests/
│   ├── conftest.py
│   ├── test_jwt.py
│   ├── test_password.py
│   └── test_auth_api.py
└── pytest.ini
```

---

## JWT 认证实现

### JWT 工具函数

```python
# app/auth/jwt.py
"""JWT 工具函数"""
from datetime import datetime, timedelta
from typing import Optional
import jwt
from jwt.exceptions import InvalidTokenError

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """创建访问令牌"""
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def decode_access_token(token: str) -> dict:
    """解码访问令牌"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except InvalidTokenError:
        raise ValueError("Invalid token")

def verify_token(token: str) -> bool:
    """验证令牌"""
    try:
        decode_access_token(token)
        return True
    except ValueError:
        return False
```

### 密码哈希

```python
# app/auth/password.py
"""密码哈希工具"""
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """哈希密码"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """验证密码"""
    return pwd_context.verify(plain_password, hashed_password)
```

### 认证依赖

```python
# app/auth/dependencies.py
"""认证依赖"""
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from app.auth.jwt import decode_access_token
from app.models.user import User
from app.dependencies import get_db

security = HTTPBearer()

def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """获取当前用户"""
    try:
        token = credentials.credentials
        payload = decode_access_token(token)
        user_id: int = payload.get("sub")

        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials"
            )

        user = db.query(User).filter_by(id=user_id).first()
        if user is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found"
            )

        return user

    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )

def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """获取当前活跃用户"""
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Inactive user"
        )
    return current_user

def require_admin(
    current_user: User = Depends(get_current_active_user)
) -> User:
    """要求管理员权限"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )
    return current_user
```

---

## JWT 测试

```python
# tests/test_jwt.py
"""JWT 测试"""
import pytest
from datetime import timedelta
import jwt
from app.auth.jwt import (
    create_access_token,
    decode_access_token,
    verify_token,
    SECRET_KEY,
    ALGORITHM
)


class TestCreateAccessToken:
    """创建访问令牌测试"""

    def test_create_token_basic(self):
        """测试：创建基本令牌"""
        data = {"sub": 123}
        token = create_access_token(data)

        assert isinstance(token, str)
        assert len(token) > 0

    def test_create_token_with_custom_expiry(self):
        """测试：自定义过期时间"""
        data = {"sub": 123}
        expires_delta = timedelta(minutes=60)
        token = create_access_token(data, expires_delta)

        # 解码验证
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        assert payload["sub"] == 123
        assert "exp" in payload

    def test_create_token_with_additional_data(self):
        """测试：附加数据"""
        data = {
            "sub": 123,
            "username": "alice",
            "role": "admin"
        }
        token = create_access_token(data)

        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        assert payload["sub"] == 123
        assert payload["username"] == "alice"
        assert payload["role"] == "admin"


class TestDecodeAccessToken:
    """解码访问令牌测试"""

    def test_decode_valid_token(self):
        """测试：解码有效令牌"""
        data = {"sub": 123, "username": "alice"}
        token = create_access_token(data)

        payload = decode_access_token(token)

        assert payload["sub"] == 123
        assert payload["username"] == "alice"

    def test_decode_invalid_token(self):
        """测试：解码无效令牌"""
        with pytest.raises(ValueError, match="Invalid token"):
            decode_access_token("invalid.token.here")

    def test_decode_expired_token(self):
        """测试：解码过期令牌"""
        data = {"sub": 123}
        # 创建已过期的令牌
        expires_delta = timedelta(seconds=-1)
        token = create_access_token(data, expires_delta)

        with pytest.raises(ValueError, match="Invalid token"):
            decode_access_token(token)

    def test_decode_tampered_token(self):
        """测试：解码被篡改的令牌"""
        data = {"sub": 123}
        token = create_access_token(data)

        # 篡改令牌
        tampered_token = token[:-10] + "tampered12"

        with pytest.raises(ValueError, match="Invalid token"):
            decode_access_token(tampered_token)


class TestVerifyToken:
    """验证令牌测试"""

    def test_verify_valid_token(self):
        """测试：验证有效令牌"""
        data = {"sub": 123}
        token = create_access_token(data)

        assert verify_token(token) is True

    def test_verify_invalid_token(self):
        """测试：验证无效令牌"""
        assert verify_token("invalid.token") is False

    def test_verify_expired_token(self):
        """测试：验证过期令牌"""
        data = {"sub": 123}
        expires_delta = timedelta(seconds=-1)
        token = create_access_token(data, expires_delta)

        assert verify_token(token) is False
```

---

## 密码哈希测试

```python
# tests/test_password.py
"""密码哈希测试"""
import pytest
from app.auth.password import hash_password, verify_password


class TestHashPassword:
    """密码哈希测试"""

    def test_hash_password_basic(self):
        """测试：基本哈希"""
        password = "password123"
        hashed = hash_password(password)

        assert isinstance(hashed, str)
        assert len(hashed) > 0
        assert hashed != password  # 哈希后不同

    def test_hash_password_different_each_time(self):
        """测试：每次哈希结果不同（盐值）"""
        password = "password123"
        hash1 = hash_password(password)
        hash2 = hash_password(password)

        # 由于盐值不同，哈希结果应该不同
        assert hash1 != hash2

    def test_hash_empty_password(self):
        """测试：空密码"""
        hashed = hash_password("")
        assert isinstance(hashed, str)

    @pytest.mark.parametrize("password", [
        "short",
        "verylongpasswordwithmanychars123456789",
        "password with spaces",
        "密码123",
        "p@ssw0rd!",
    ])
    def test_hash_various_passwords(self, password):
        """测试：各种密码（参数化）"""
        hashed = hash_password(password)
        assert isinstance(hashed, str)
        assert len(hashed) > 0


class TestVerifyPassword:
    """密码验证测试"""

    def test_verify_correct_password(self):
        """测试：验证正确密码"""
        password = "password123"
        hashed = hash_password(password)

        assert verify_password(password, hashed) is True

    def test_verify_incorrect_password(self):
        """测试：验证错误密码"""
        password = "password123"
        hashed = hash_password(password)

        assert verify_password("wrongpassword", hashed) is False

    def test_verify_case_sensitive(self):
        """测试：大小写敏感"""
        password = "Password123"
        hashed = hash_password(password)

        assert verify_password("password123", hashed) is False
        assert verify_password("Password123", hashed) is True

    def test_verify_empty_password(self):
        """测试：空密码"""
        hashed = hash_password("")
        assert verify_password("", hashed) is True
        assert verify_password("nonempty", hashed) is False

    @pytest.mark.parametrize("correct,incorrect", [
        ("password123", "password124"),
        ("admin", "Admin"),
        ("test@123", "test@124"),
    ])
    def test_verify_password_pairs(self, correct, incorrect):
        """测试：密码对（参数化）"""
        hashed = hash_password(correct)
        assert verify_password(correct, hashed) is True
        assert verify_password(incorrect, hashed) is False
```

---

## 认证 API 测试

### 认证 API 实现

```python
# app/api/auth.py
"""认证 API"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.models.schemas import LoginRequest, Token, UserResponse
from app.models.user import User
from app.auth.jwt import create_access_token
from app.auth.password import verify_password
from app.auth.dependencies import get_current_active_user
from app.dependencies import get_db

router = APIRouter()

@router.post("/login", response_model=Token)
def login(login_data: LoginRequest, db: Session = Depends(get_db)):
    """用户登录"""
    # 查找用户
    user = db.query(User).filter_by(username=login_data.username).first()

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password"
        )

    # 验证密码
    if not verify_password(login_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password"
        )

    # 创建访问令牌
    access_token = create_access_token(data={"sub": user.id})

    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=UserResponse)
def read_current_user(current_user: User = Depends(get_current_active_user)):
    """获取当前用户信息"""
    return current_user

@router.post("/logout")
def logout(current_user: User = Depends(get_current_active_user)):
    """用户登出"""
    # 在实际应用中，可能需要将令牌加入黑名单
    return {"message": "Successfully logged out"}
```

### 认证 API 测试

```python
# tests/test_auth_api.py
"""认证 API 测试"""
import pytest
from fastapi import status
from app.auth.password import hash_password


@pytest.fixture
def test_user(db_session):
    """测试用户"""
    from app.models.user import User

    user = User(
        username="testuser",
        email="test@example.com",
        hashed_password=hash_password("password123"),
        is_active=True,
        is_admin=False
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user


@pytest.fixture
def admin_user(db_session):
    """管理员用户"""
    from app.models.user import User

    user = User(
        username="admin",
        email="admin@example.com",
        hashed_password=hash_password("adminpass"),
        is_active=True,
        is_admin=True
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user


@pytest.fixture
def inactive_user(db_session):
    """停用用户"""
    from app.models.user import User

    user = User(
        username="inactive",
        email="inactive@example.com",
        hashed_password=hash_password("password123"),
        is_active=False,
        is_admin=False
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user


class TestLogin:
    """登录测试"""

    def test_login_success(self, client, test_user):
        """测试：登录成功"""
        response = client.post("/api/auth/login", json={
            "username": "testuser",
            "password": "password123"
        })

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert "access_token" in data
        assert data["token_type"] == "bearer"

    def test_login_wrong_password(self, client, test_user):
        """测试：错误密码"""
        response = client.post("/api/auth/login", json={
            "username": "testuser",
            "password": "wrongpassword"
        })

        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        assert "Incorrect" in response.json()["detail"]

    def test_login_nonexistent_user(self, client):
        """测试：不存在的用户"""
        response = client.post("/api/auth/login", json={
            "username": "nonexistent",
            "password": "password123"
        })

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_login_case_sensitive_username(self, client, test_user):
        """测试：用户名大小写敏感"""
        response = client.post("/api/auth/login", json={
            "username": "TestUser",  # 大写
            "password": "password123"
        })

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_login_empty_credentials(self, client):
        """测试：空凭证"""
        response = client.post("/api/auth/login", json={
            "username": "",
            "password": ""
        })

        assert response.status_code == status.HTTP_401_UNAUTHORIZED


class TestProtectedEndpoints:
    """受保护端点测试"""

    def test_access_protected_endpoint_with_token(self, client, test_user):
        """测试：使用令牌访问受保护端点"""
        # 登录获取令牌
        login_response = client.post("/api/auth/login", json={
            "username": "testuser",
            "password": "password123"
        })
        token = login_response.json()["access_token"]

        # 访问受保护端点
        response = client.get(
            "/api/auth/me",
            headers={"Authorization": f"Bearer {token}"}
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["username"] == "testuser"
        assert data["email"] == "test@example.com"

    def test_access_protected_endpoint_without_token(self, client):
        """测试：不带令牌访问受保护端点"""
        response = client.get("/api/auth/me")

        assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_access_protected_endpoint_with_invalid_token(self, client):
        """测试：使用无效令牌"""
        response = client.get(
            "/api/auth/me",
            headers={"Authorization": "Bearer invalid.token.here"}
        )

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_access_protected_endpoint_with_expired_token(self, client, test_user):
        """测试：使用过期令牌"""
        from datetime import timedelta
        from app.auth.jwt import create_access_token

        # 创建已过期的令牌
        expired_token = create_access_token(
            data={"sub": test_user.id},
            expires_delta=timedelta(seconds=-1)
        )

        response = client.get(
            "/api/auth/me",
            headers={"Authorization": f"Bearer {expired_token}"}
        )

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_access_with_inactive_user(self, client, inactive_user):
        """测试：停用用户访问"""
        # 登录（应该成功，因为只验证密码）
        login_response = client.post("/api/auth/login", json={
            "username": "inactive",
            "password": "password123"
        })
        token = login_response.json()["access_token"]

        # 访问受保护端点（应该失败，因为用户未激活）
        response = client.get(
            "/api/auth/me",
            headers={"Authorization": f"Bearer {token}"}
        )

        assert response.status_code == status.HTTP_403_FORBIDDEN
        assert "Inactive" in response.json()["detail"]


class TestLogout:
    """登出测试"""

    def test_logout_success(self, client, test_user):
        """测试：登出成功"""
        # 登录
        login_response = client.post("/api/auth/login", json={
            "username": "testuser",
            "password": "password123"
        })
        token = login_response.json()["access_token"]

        # 登出
        response = client.post(
            "/api/auth/logout",
            headers={"Authorization": f"Bearer {token}"}
        )

        assert response.status_code == status.HTTP_200_OK
        assert "logged out" in response.json()["message"]

    def test_logout_without_token(self, client):
        """测试：不带令牌登出"""
        response = client.post("/api/auth/logout")

        assert response.status_code == status.HTTP_403_FORBIDDEN


class TestAdminEndpoints:
    """管理员端点测试"""

    def test_admin_access_with_admin_user(self, client, admin_user):
        """测试：管理员访问管理员端点"""
        # 登录
        login_response = client.post("/api/auth/login", json={
            "username": "admin",
            "password": "adminpass"
        })
        token = login_response.json()["access_token"]

        # 访问管理员端点（假设有这个端点）
        # 这里只是示例，实际需要实现管理员端点
        response = client.get(
            "/api/auth/me",
            headers={"Authorization": f"Bearer {token}"}
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["username"] == "admin"

    def test_admin_access_with_regular_user(self, client, test_user):
        """测试：普通用户访问管理员端点"""
        # 登录
        login_response = client.post("/api/auth/login", json={
            "username": "testuser",
            "password": "password123"
        })
        token = login_response.json()["access_token"]

        # 尝试访问管理员端点
        # 这里需要实际的管理员端点来测试
        # 示例：假设有 /api/admin/users 端点
        # response = client.get(
        #     "/api/admin/users",
        #     headers={"Authorization": f"Bearer {token}"}
        # )
        # assert response.status_code == status.HTTP_403_FORBIDDEN


class TestTokenRefresh:
    """令牌刷新测试"""

    def test_token_contains_user_id(self, client, test_user):
        """测试：令牌包含用户 ID"""
        from app.auth.jwt import decode_access_token

        # 登录
        login_response = client.post("/api/auth/login", json={
            "username": "testuser",
            "password": "password123"
        })
        token = login_response.json()["access_token"]

        # 解码令牌
        payload = decode_access_token(token)

        assert payload["sub"] == test_user.id

    def test_multiple_logins_different_tokens(self, client, test_user):
        """测试：多次登录生成不同令牌"""
        # 第一次登录
        response1 = client.post("/api/auth/login", json={
            "username": "testuser",
            "password": "password123"
        })
        token1 = response1.json()["access_token"]

        # 第二次登录
        response2 = client.post("/api/auth/login", json={
            "username": "testuser",
            "password": "password123"
        })
        token2 = response2.json()["access_token"]

        # 令牌应该不同（因为过期时间不同）
        assert token1 != token2

        # 但两个令牌都应该有效
        response = client.get(
            "/api/auth/me",
            headers={"Authorization": f"Bearer {token1}"}
        )
        assert response.status_code == status.HTTP_200_OK

        response = client.get(
            "/api/auth/me",
            headers={"Authorization": f"Bearer {token2}"}
        )
        assert response.status_code == status.HTTP_200_OK
```

---

## 权限测试辅助函数

```python
# tests/helpers/auth_helpers.py
"""认证测试辅助函数"""
from fastapi.testclient import TestClient
from app.auth.jwt import create_access_token


def get_auth_headers(user_id: int) -> dict:
    """获取认证头"""
    token = create_access_token(data={"sub": user_id})
    return {"Authorization": f"Bearer {token}"}


def login_user(client: TestClient, username: str, password: str) -> str:
    """登录用户并返回令牌"""
    response = client.post("/api/auth/login", json={
        "username": username,
        "password": password
    })
    return response.json()["access_token"]


def create_authenticated_client(client: TestClient, user_id: int):
    """创建认证客户端"""
    class AuthenticatedClient:
        def __init__(self, client, user_id):
            self.client = client
            self.headers = get_auth_headers(user_id)

        def get(self, url, **kwargs):
            kwargs.setdefault("headers", {}).update(self.headers)
            return self.client.get(url, **kwargs)

        def post(self, url, **kwargs):
            kwargs.setdefault("headers", {}).update(self.headers)
            return self.client.post(url, **kwargs)

        def put(self, url, **kwargs):
            kwargs.setdefault("headers", {}).update(self.headers)
            return self.client.put(url, **kwargs)

        def delete(self, url, **kwargs):
            kwargs.setdefault("headers", {}).update(self.headers)
            return self.client.delete(url, **kwargs)

    return AuthenticatedClient(client, user_id)


# 使用示例
# tests/test_with_helpers.py
"""使用辅助函数的测试"""
from tests.helpers.auth_helpers import get_auth_headers, login_user


def test_with_auth_headers(client, test_user):
    """测试：使用认证头辅助函数"""
    headers = get_auth_headers(test_user.id)

    response = client.get("/api/auth/me", headers=headers)

    assert response.status_code == 200


def test_with_login_helper(client, test_user):
    """测试：使用登录辅助函数"""
    token = login_user(client, "testuser", "password123")

    response = client.get(
        "/api/auth/me",
        headers={"Authorization": f"Bearer {token}"}
    )

    assert response.status_code == 200
```

---

## 运行测试

```bash
# 运行所有认证测试
pytest tests/test_jwt.py tests/test_password.py tests/test_auth_api.py -v

# 运行特定测试类
pytest tests/test_auth_api.py::TestLogin -v

# 运行特定测试函数
pytest tests/test_auth_api.py::TestLogin::test_login_success -v

# 显示详细输出
pytest tests/test_auth_api.py -v -s

# 生成覆盖率报告
pytest tests/ --cov=app.auth --cov-report=html
```

---

## 总结

### 核心要点

1. **JWT 测试**：测试令牌创建、解码、验证、过期
2. **密码测试**：测试哈希、验证、盐值
3. **登录测试**：测试成功、失败、边界条件
4. **受保护端点**：测试有效令牌、无效令牌、过期令牌
5. **权限测试**：测试管理员权限、普通用户权限

### 最佳实践

- 使用 fixture 准备测试用户
- 测试所有认证场景（成功、失败、边界）
- 测试令牌过期和无效情况
- 测试权限隔离
- 使用辅助函数简化测试代码
