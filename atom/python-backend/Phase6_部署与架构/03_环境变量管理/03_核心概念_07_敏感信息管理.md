# 核心概念7：敏感信息管理

## 一句话定义

**敏感信息管理是保护 API 密钥、数据库密码、JWT 密钥等机密信息不被泄露的安全机制，通过环境变量、密钥管理服务、访问控制等手段确保敏感信息的安全存储和使用。**

---

## 什么是敏感信息？

### 敏感信息的类型

**1. API 密钥和访问令牌**
- OpenAI API Key
- Anthropic API Key
- AWS Access Key
- GitHub Token
- Stripe API Key

**2. 数据库凭证**
- 数据库密码
- 数据库连接字符串
- Redis 密码

**3. 加密密钥**
- JWT Secret Key
- 加密密钥
- 签名密钥

**4. 第三方服务凭证**
- OAuth Client Secret
- Webhook Secret
- SMTP 密码

---

## 为什么敏感信息管理很重要？

### 风险场景

**场景1：代码泄露**

```python
# ❌ 危险：密钥硬编码在代码中
OPENAI_API_KEY = "sk-proj-xxx"
DATABASE_URL = "postgresql://admin:password123@prod-db:5432/mydb"

# 代码提交到 git，密钥泄露到公开仓库
# 攻击者可以：
# - 使用你的 API 配额
# - 访问你的数据库
# - 窃取用户数据
```

**场景2：日志泄露**

```python
# ❌ 危险：在日志中打印密钥
logger.info(f"使用 API 密钥: {OPENAI_API_KEY}")
logger.debug(f"数据库连接: {DATABASE_URL}")

# 日志文件可能被：
# - 上传到日志服务
# - 被运维人员查看
# - 被攻击者获取
```

**场景3：错误信息泄露**

```python
# ❌ 危险：在错误信息中暴露密钥
try:
    client = OpenAI(api_key=OPENAI_API_KEY)
except Exception as e:
    print(f"连接失败: {e}, API Key: {OPENAI_API_KEY}")

# 错误信息可能被：
# - 显示在前端页面
# - 记录在错误日志
# - 发送到错误追踪服务
```

---

## 敏感信息管理的最佳实践

### 实践1：永远不要硬编码敏感信息

**错误示例：**

```python
# ❌ 硬编码在代码中
OPENAI_API_KEY = "sk-proj-xxx"
DATABASE_PASSWORD = "password123"
SECRET_KEY = "my-secret-key"
```

**正确示例：**

```python
# ✅ 从环境变量读取
import os

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
DATABASE_PASSWORD = os.getenv("DATABASE_PASSWORD")
SECRET_KEY = os.getenv("SECRET_KEY")
```

---

### 实践2：使用 .gitignore 排除敏感文件

**.gitignore：**

```bash
# 环境变量文件
.env
.env.local
.env.*.local
.env.prod
.env.production

# 密钥文件
*.key
*.pem
*.p12
*.pfx

# 配置文件
config.local.json
secrets.json

# 数据库文件
*.db
*.sqlite
*.sqlite3

# 日志文件（可能包含敏感信息）
*.log
logs/
```

---

### 实践3：提供配置模板

**.env.example（提交到 git）：**

```bash
# API 密钥
OPENAI_API_KEY=your_openai_api_key_here
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# 数据库配置
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
DATABASE_PASSWORD=your_database_password_here

# 安全配置
SECRET_KEY=your-secret-key-at-least-32-characters-long
JWT_SECRET_KEY=your-jwt-secret-key-here

# Redis 配置
REDIS_URL=redis://localhost:6379/0
REDIS_PASSWORD=your_redis_password_here
```

**README.md 说明：**

```markdown
## 环境配置

1. 复制环境变量模板：
   ```bash
   cp .env.example .env
   ```

2. 编辑 `.env` 文件，填入真实的密钥：
   ```bash
   # 不要提交 .env 文件到 git！
   ```

3. 生成安全的密钥：
   ```bash
   # 生成 SECRET_KEY
   python -c "import secrets; print(secrets.token_urlsafe(32))"
   ```
```

---

### 实践4：在日志中隐藏敏感信息

**方法1：不打印敏感信息**

```python
import logging

logger = logging.getLogger(__name__)

# ❌ 错误：打印完整的密钥
logger.info(f"API 密钥: {OPENAI_API_KEY}")

# ✅ 正确：不打印密钥
logger.info("API 密钥已加载")

# ✅ 正确：只打印部分密钥
logger.info(f"API 密钥: {OPENAI_API_KEY[:10]}...")
```

**方法2：使用日志过滤器**

```python
import logging
import re

class SensitiveDataFilter(logging.Filter):
    """过滤日志中的敏感信息"""

    PATTERNS = [
        (re.compile(r'sk-[a-zA-Z0-9]{20,}'), 'sk-***'),  # OpenAI API Key
        (re.compile(r'password["\']?\s*[:=]\s*["\']?([^"\'\s]+)'), r'password=***'),  # 密码
        (re.compile(r'Bearer\s+[a-zA-Z0-9\-._~+/]+=*'), 'Bearer ***'),  # Bearer Token
    ]

    def filter(self, record):
        message = record.getMessage()
        for pattern, replacement in self.PATTERNS:
            message = pattern.sub(replacement, message)
        record.msg = message
        record.args = ()
        return True

# 使用过滤器
logger = logging.getLogger(__name__)
logger.addFilter(SensitiveDataFilter())

# 测试
logger.info(f"API Key: sk-proj-xxxxxxxxxxxxx")  # 输出: API Key: sk-***
logger.info(f"password=secret123")  # 输出: password=***
```

---

### 实践5：在错误信息中隐藏敏感信息

```python
from openai import OpenAI
import logging

logger = logging.getLogger(__name__)

try:
    client = OpenAI(api_key=OPENAI_API_KEY)
except Exception as e:
    # ❌ 错误：暴露密钥
    logger.error(f"连接失败: {e}, API Key: {OPENAI_API_KEY}")

    # ✅ 正确：不暴露密钥
    logger.error("OpenAI 连接失败")
    logger.debug(f"错误详情: {e}")  # 只在调试模式打印详情
```

---

### 实践6：使用 Pydantic 隐藏敏感字段

```python
from pydantic import BaseModel, Field, SecretStr

class Settings(BaseModel):
    # 使用 SecretStr 隐藏敏感信息
    openai_api_key: SecretStr
    database_password: SecretStr
    secret_key: SecretStr

    # 普通字段
    database_url: str
    debug: bool = False

settings = Settings(
    openai_api_key="sk-proj-xxx",
    database_password="password123",
    secret_key="my-secret-key",
    database_url="postgresql://localhost:5432/mydb"
)

# 打印配置（敏感信息被隐藏）
print(settings)
# Settings(
#     openai_api_key=SecretStr('**********'),
#     database_password=SecretStr('**********'),
#     secret_key=SecretStr('**********'),
#     database_url='postgresql://localhost:5432/mydb',
#     debug=False
# )

# 获取真实值
real_key = settings.openai_api_key.get_secret_value()
```

---

## 生产环境的敏感信息管理

### 方案1：环境变量（基础方案）

**适用场景：** 小型项目、单机部署

```bash
# 在服务器上设置环境变量
export OPENAI_API_KEY=sk-proj-xxx
export DATABASE_PASSWORD=password123
export SECRET_KEY=my-secret-key

# 启动应用
python app.py
```

**优点：**
- 简单易用
- 不需要额外服务

**缺点：**
- 难以管理大量密钥
- 难以轮换密钥
- 难以审计访问记录

---

### 方案2：Docker Secrets（Docker Swarm）

**适用场景：** Docker Swarm 集群

```bash
# 创建 Secret
echo "sk-proj-xxx" | docker secret create openai_api_key -

# 使用 Secret
docker service create \
  --name api \
  --secret openai_api_key \
  my-api
```

```python
# 读取 Secret
def read_secret(secret_name: str) -> str:
    secret_path = f"/run/secrets/{secret_name}"
    if os.path.exists(secret_path):
        with open(secret_path) as f:
            return f.read().strip()
    return os.getenv(secret_name.upper(), "")

OPENAI_API_KEY = read_secret("openai_api_key")
```

---

### 方案3：Kubernetes Secrets

**适用场景：** Kubernetes 集群

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: api-secrets
type: Opaque
data:
  openai-api-key: <base64-encoded-key>
  database-password: <base64-encoded-password>
```

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - name: api
        env:
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: api-secrets
              key: openai-api-key
```

---

### 方案4：云平台密钥管理服务

**AWS Secrets Manager：**

```python
import boto3
import json

def get_secret(secret_name: str) -> dict:
    client = boto3.client('secretsmanager', region_name='us-east-1')
    response = client.get_secret_value(SecretId=secret_name)
    return json.loads(response['SecretString'])

# 获取密钥
secrets = get_secret('prod/api/secrets')
OPENAI_API_KEY = secrets['openai_api_key']
DATABASE_PASSWORD = secrets['database_password']
```

**Google Cloud Secret Manager：**

```python
from google.cloud import secretmanager

def get_secret(project_id: str, secret_id: str) -> str:
    client = secretmanager.SecretManagerServiceClient()
    name = f"projects/{project_id}/secrets/{secret_id}/versions/latest"
    response = client.access_secret_version(request={"name": name})
    return response.payload.data.decode('UTF-8')

OPENAI_API_KEY = get_secret('my-project', 'openai-api-key')
```

**Azure Key Vault：**

```python
from azure.identity import DefaultAzureCredential
from azure.keyvault.secrets import SecretClient

def get_secret(vault_url: str, secret_name: str) -> str:
    credential = DefaultAzureCredential()
    client = SecretClient(vault_url=vault_url, credential=credential)
    secret = client.get_secret(secret_name)
    return secret.value

OPENAI_API_KEY = get_secret('https://my-vault.vault.azure.net/', 'openai-api-key')
```

---

### 方案5：HashiCorp Vault

**适用场景：** 企业级密钥管理

```python
import hvac

# 连接到 Vault
client = hvac.Client(url='http://localhost:8200', token='my-token')

# 读取密钥
secret = client.secrets.kv.v2.read_secret_version(path='api/secrets')
OPENAI_API_KEY = secret['data']['data']['openai_api_key']
DATABASE_PASSWORD = secret['data']['data']['database_password']
```

---

## 密钥轮换策略

### 为什么需要密钥轮换？

**原因：**
- 密钥可能被泄露
- 定期轮换降低风险
- 符合安全合规要求

### 密钥轮换的实现

**方案1：手动轮换**

```bash
# 1. 生成新密钥
python -c "import secrets; print(secrets.token_urlsafe(32))"

# 2. 更新环境变量
export SECRET_KEY=new-secret-key-xxxxxxxxxxxxx

# 3. 重启应用
docker-compose restart api
```

**方案2：自动轮换（AWS Secrets Manager）**

```python
import boto3

def rotate_secret(secret_name: str):
    client = boto3.client('secretsmanager')

    # 触发轮换
    response = client.rotate_secret(
        SecretId=secret_name,
        RotationLambdaARN='arn:aws:lambda:...',
        RotationRules={
            'AutomaticallyAfterDays': 30  # 每30天自动轮换
        }
    )

    return response

# 配置自动轮换
rotate_secret('prod/api/secrets')
```

---

## 敏感信息泄露的检测

### 检测方法1：Git 历史扫描

**使用 git-secrets：**

```bash
# 安装 git-secrets
brew install git-secrets

# 配置规则
git secrets --add 'sk-[a-zA-Z0-9]{20,}'  # OpenAI API Key
git secrets --add 'password\s*=\s*["\']?[^"\'\s]+'  # 密码

# 扫描历史
git secrets --scan-history
```

**使用 truffleHog：**

```bash
# 安装 truffleHog
pip install truffleHog

# 扫描仓库
trufflehog git https://github.com/user/repo
```

---

### 检测方法2：代码扫描

**使用 detect-secrets：**

```bash
# 安装 detect-secrets
pip install detect-secrets

# 扫描代码
detect-secrets scan > .secrets.baseline

# 审计结果
detect-secrets audit .secrets.baseline
```

---

### 检测方法3：CI/CD 集成

**GitHub Actions：**

```yaml
# .github/workflows/security.yml
name: Security Scan

on: [push, pull_request]

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Scan for secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: HEAD
```

---

## 实际应用示例

### 示例1：完整的配置管理系统

```python
# app/config.py
import os
from enum import Enum
from pydantic import Field, SecretStr, field_validator
from pydantic_settings import BaseSettings

class Environment(str, Enum):
    DEV = "dev"
    TEST = "test"
    PROD = "prod"

class Settings(BaseSettings):
    # 环境标识
    env: Environment = Environment.DEV

    # 应用配置
    app_name: str = "AI Agent API"
    debug: bool = False

    # 数据库配置（敏感）
    database_url: SecretStr
    database_password: SecretStr

    # LLM 配置（敏感）
    openai_api_key: SecretStr
    openai_model: str = "gpt-4"

    # 安全配置（敏感）
    secret_key: SecretStr
    jwt_secret_key: SecretStr

    @field_validator("secret_key", "jwt_secret_key")
    @classmethod
    def validate_secret_key(cls, v: SecretStr) -> SecretStr:
        # 验证密钥长度
        if len(v.get_secret_value()) < 32:
            raise ValueError("密钥长度必须至少 32 字符")
        return v

    @field_validator("openai_api_key")
    @classmethod
    def validate_api_key(cls, v: SecretStr) -> SecretStr:
        # 验证 API 密钥格式
        key = v.get_secret_value()
        if not key.startswith("sk-"):
            raise ValueError("OpenAI API 密钥格式错误")
        return v

    class Config:
        env_file = ".env"

    def __repr__(self):
        # 隐藏敏感信息
        return (
            f"Settings("
            f"env={self.env}, "
            f"debug={self.debug}, "
            f"database_url=*****, "
            f"openai_api_key=*****, "
            f"secret_key=*****"
            f")"
        )

settings = Settings()

# 启动时验证配置
print(f"✅ 配置加载成功: {settings}")
```

---

### 示例2：日志安全配置

```python
# app/logging_config.py
import logging
import re

class SensitiveDataFilter(logging.Filter):
    """过滤日志中的敏感信息"""

    PATTERNS = [
        # API 密钥
        (re.compile(r'sk-[a-zA-Z0-9]{20,}'), 'sk-***'),
        (re.compile(r'Bearer\s+[a-zA-Z0-9\-._~+/]+=*'), 'Bearer ***'),

        # 密码
        (re.compile(r'password["\']?\s*[:=]\s*["\']?([^"\'\s]+)'), r'password=***'),
        (re.compile(r'passwd["\']?\s*[:=]\s*["\']?([^"\'\s]+)'), r'passwd=***'),

        # 数据库连接字符串
        (re.compile(r'postgresql://([^:]+):([^@]+)@'), r'postgresql://\1:***@'),
        (re.compile(r'mysql://([^:]+):([^@]+)@'), r'mysql://\1:***@'),

        # JWT Token
        (re.compile(r'eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*'), 'jwt-***'),
    ]

    def filter(self, record):
        message = record.getMessage()
        for pattern, replacement in self.PATTERNS:
            message = pattern.sub(replacement, message)
        record.msg = message
        record.args = ()
        return True

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)
logger.addFilter(SensitiveDataFilter())

# 测试
logger.info(f"API Key: sk-proj-xxxxxxxxxxxxx")  # 输出: API Key: sk-***
logger.info(f"Database: postgresql://user:password@localhost:5432/db")  # 输出: Database: postgresql://user:***@localhost:5432/db
```

---

### 示例3：错误处理安全

```python
# app/error_handlers.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import logging

logger = logging.getLogger(__name__)

app = FastAPI()

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    # ❌ 错误：直接返回异常信息（可能包含敏感信息）
    # return JSONResponse(
    #     status_code=500,
    #     content={"detail": str(exc)}
    # )

    # ✅ 正确：返回通用错误信息
    logger.error(f"未处理的异常: {exc}", exc_info=True)

    return JSONResponse(
        status_code=500,
        content={"detail": "服务器内部错误"}
    )
```

---

## 敏感信息管理检查清单

### 开发阶段

- [ ] 不在代码中硬编码敏感信息
- [ ] 使用环境变量存储敏感信息
- [ ] 配置 .gitignore 排除敏感文件
- [ ] 提供 .env.example 模板
- [ ] 使用 Pydantic SecretStr 隐藏敏感字段

### 日志和错误处理

- [ ] 不在日志中打印敏感信息
- [ ] 使用日志过滤器隐藏敏感信息
- [ ] 不在错误信息中暴露敏感信息
- [ ] 使用通用错误信息返回给用户

### 生产环境

- [ ] 使用云平台密钥管理服务
- [ ] 配置密钥轮换策略
- [ ] 限制密钥访问权限
- [ ] 审计密钥访问记录
- [ ] 监控密钥使用情况

### 安全扫描

- [ ] 扫描 Git 历史中的敏感信息
- [ ] 在 CI/CD 中集成密钥扫描
- [ ] 定期审计配置文件
- [ ] 监控异常访问行为

---

## 总结

**敏感信息管理的核心原则：**

1. **永远不要硬编码**：敏感信息不应该出现在代码中
2. **使用环境变量**：通过环境变量注入敏感信息
3. **隐藏敏感信息**：在日志、错误信息中隐藏敏感信息
4. **使用密钥管理服务**：生产环境使用专业的密钥管理服务
5. **定期轮换密钥**：降低密钥泄露的风险
6. **限制访问权限**：最小权限原则
7. **审计和监控**：记录密钥访问和使用情况

**敏感信息的类型：**
- API 密钥和访问令牌
- 数据库凭证
- 加密密钥
- 第三方服务凭证

**管理方案：**
- 开发环境：环境变量 + .env 文件
- Docker 部署：Docker Secrets
- Kubernetes 部署：Kubernetes Secrets
- 云平台部署：AWS Secrets Manager / Google Secret Manager / Azure Key Vault
- 企业级：HashiCorp Vault

**最佳实践：**
- 使用 .gitignore 排除敏感文件
- 提供 .env.example 模板
- 使用 Pydantic SecretStr 隐藏敏感字段
- 使用日志过滤器隐藏敏感信息
- 在错误信息中隐藏敏感信息
- 定期扫描代码和 Git 历史
- 配置密钥轮换策略
