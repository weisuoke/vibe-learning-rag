# 概览：Prompt Engineering进阶

## 学习地图

```
Prompt Engineering进阶
│
├─ 基础技术层（必学）
│  ├─ Few-shot Learning        ← 用示例引导行为
│  ├─ Chain-of-Thought         ← 让模型说出推理过程
│  └─ Structured Output        ← 强制JSON格式输出
│
├─ 验证增强层（提升可靠性）
│  ├─ Self-Consistency         ← 多次推理投票
│  └─ Active Prompting         ← 智能选择示例
│
├─ 推理扩展层（复杂任务）
│  ├─ Tree of Thoughts         ← 探索多条推理路径
│  ├─ ReAct                    ← 推理与行动交替
│  └─ Meta Prompting           ← 让模型写提示词
│
└─ RAG专用层（检索增强）
   ├─ Query Decomposition      ← 复杂查询拆分
   └─ RAT (2025新技术)         ← 检索增强思维链
```

---

## 为什么需要进阶技术？

### 基础版的局限

```python
# 基础Prompt：直接提问
prompt = "请分析这段代码的性能问题"
response = llm.generate(prompt)
# 问题：模型可能直接给答案，没有推理过程，难以验证
```

### 进阶版的优势

```python
# 进阶Prompt：Chain-of-Thought
prompt = """
请分析这段代码的性能问题。

请按以下步骤思考：
1. 识别代码中的循环和递归
2. 分析时间复杂度
3. 找出潜在瓶颈
4. 给出优化建议

让我们一步步思考：
"""
response = llm.generate(prompt)
# 优势：有推理过程，可验证，更可靠
```

**核心差异：**

| 维度 | 基础版 | 进阶版 |
|------|--------|--------|
| **目标** | 生成文本 | 完成任务 |
| **方法** | 单次提问 | 多步推理 |
| **可靠性** | 依赖运气 | 系统化验证 |
| **适用场景** | 简单问答 | 复杂任务 |

---

## 10大核心技术

### 1. Few-shot Learning（少样本学习）

**一句话：** 用2-5个示例教会模型做什么

**RAG应用：** 引导模型按特定格式提取文档信息

```python
# 示例：文档问答格式引导
prompt = """
根据文档回答问题，格式如下：

示例1：
文档：Python是一种解释型语言
问题：Python是什么类型的语言？
答案：解释型语言
依据：文档明确说明"Python是一种解释型语言"

示例2：
文档：FastAPI基于Starlette和Pydantic
问题：FastAPI依赖哪些库？
答案：Starlette和Pydantic
依据：文档说明"FastAPI基于Starlette和Pydantic"

现在回答：
文档：{retrieved_doc}
问题：{user_query}
答案：
"""
```

**来源：** [Prompt Engineering Guide - Few-Shot](https://www.promptingguide.ai/techniques/fewshot)

---

### 2. Chain-of-Thought (CoT)（思维链）

**一句话：** 让模型逐步推理而非直接给答案

**RAG应用：** 在检索后让模型解释为什么选择某个答案

```python
# 示例：RAG中的推理链
prompt = f"""
检索到的文档：
{retrieved_docs}

用户问题：{query}

请按以下步骤回答：
1. 分析问题的核心意图
2. 检查哪些文档片段相关
3. 综合信息得出答案
4. 说明答案的依据

让我们一步步思考：
"""
```

**来源：** [K2view 2026 Techniques](https://www.k2view.com/blog/prompt-engineering-techniques)

---

### 3. Self-Consistency（自洽性）

**一句话：** 多次推理，投票选出最可靠的答案

**RAG应用：** 对关键问题生成多个答案，选择最一致的

```python
# 示例：多路径验证
answers = []
for i in range(5):
    response = llm.generate(prompt, temperature=0.7)
    answers.append(response)

# 投票选择最常见的答案
final_answer = most_common(answers)
```

**来源：** [Prompt Engineering Guide - Self-Consistency](https://www.promptingguide.ai/techniques/consistency)

---

### 4. Tree of Thoughts (ToT)（思维树）

**一句话：** 探索多条推理分支，可以回溯

**RAG应用：** 对复杂查询尝试多种检索策略

```python
# 示例：多策略检索
strategies = [
    "直接语义检索",
    "关键词提取后检索",
    "问题改写后检索"
]

results = {}
for strategy in strategies:
    results[strategy] = execute_strategy(strategy, query)

# 评估每个策略的结果，选择最佳
best_result = evaluate_and_select(results)
```

**来源：** [Prompt Engineering Guide - ToT](https://www.promptingguide.ai/techniques/tot)

---

### 5. ReAct（推理+行动）

**一句话：** 推理与行动交替，适合需要工具调用的任务

**RAG应用：** 动态决定是否需要更多检索

```python
# 示例：动态检索
while not task_complete:
    # 推理：分析当前信息是否足够
    thought = llm.generate(f"当前信息：{context}\n是否需要更多信息？")

    if "需要" in thought:
        # 行动：执行检索
        new_docs = retriever.search(extract_query(thought))
        context += new_docs
    else:
        # 生成最终答案
        answer = llm.generate(f"基于{context}回答{query}")
        break
```

**来源：** [Prompt Engineering Guide - ReAct](https://www.promptingguide.ai/techniques/react)

---

### 6. Structured Output（结构化输出）

**一句话：** 强制模型输出JSON格式，确保可解析

**RAG应用：** 确保检索结果可以被程序处理

```python
# 示例：强制JSON输出
from openai import OpenAI

client = OpenAI()
response = client.chat.completions.create(
    model="gpt-4o-2024-08-06",
    messages=[
        {"role": "system", "content": "提取文档中的关键信息"},
        {"role": "user", "content": document}
    ],
    response_format={
        "type": "json_schema",
        "json_schema": {
            "name": "document_info",
            "schema": {
                "type": "object",
                "properties": {
                    "title": {"type": "string"},
                    "summary": {"type": "string"},
                    "keywords": {"type": "array", "items": {"type": "string"}}
                },
                "required": ["title", "summary", "keywords"]
            }
        }
    }
)
```

**来源：** [OpenAI Structured Outputs](https://developers.openai.com/api/docs/guides/structured-outputs)

---

### 7. Query Decomposition（查询分解）

**一句话：** 把复杂查询拆分成多个子查询

**RAG应用：** RAG系统的核心优化技术

```python
# 示例：复杂查询拆分
complex_query = "比较Python和JavaScript在异步编程方面的差异"

# 分解为子查询
sub_queries = [
    "Python的异步编程机制",
    "JavaScript的异步编程机制",
    "两者的主要差异"
]

# 分别检索
results = []
for sub_q in sub_queries:
    results.append(retriever.search(sub_q))

# 综合答案
final_answer = llm.generate(f"基于以下信息：{results}\n回答：{complex_query}")
```

**来源：** [NVIDIA RAG Blueprint](https://docs.nvidia.com/rag/2.3.0/query_decomposition.html)

---

### 8. RAT (Retrieval Augmented Thoughts)（检索增强思维）

**一句话：** RAG + CoT的迭代优化（2025新技术）

**RAG应用：** 在推理过程中动态检索补充信息

```python
# 示例：迭代检索+推理
context = initial_retrieval(query)

for step in range(max_steps):
    # 推理：基于当前信息思考
    thought = llm.generate(f"""
    当前信息：{context}
    问题：{query}

    下一步需要什么信息？
    """)

    if "足够" in thought:
        break

    # 检索：获取新信息
    new_info = retriever.search(extract_need(thought))
    context += new_info

# 最终答案
answer = llm.generate(f"基于完整信息：{context}\n回答：{query}")
```

**来源：** [arXiv RAT Paper](https://arxiv.org/abs/2403.05313)

---

### 9. Meta Prompting（元提示）

**一句话：** 让模型自己写提示词

**RAG应用：** 根据查询类型动态生成最优提示词

```python
# 示例：动态生成提示词
meta_prompt = f"""
用户查询：{query}
查询类型：{query_type}

请生成一个最优的提示词，用于从文档中提取答案。
提示词应该包括：
1. 明确的角色定义
2. 清晰的任务说明
3. 输出格式要求
"""

generated_prompt = llm.generate(meta_prompt)
final_answer = llm.generate(generated_prompt + f"\n文档：{docs}")
```

**来源：** [Prompt Engineering Guide - Meta Prompting](https://www.promptingguide.ai/techniques/meta-prompting)

---

### 10. Active Prompting（主动提示）

**一句话：** 基于不确定性智能选择最佳示例

**RAG应用：** 动态选择最相关的Few-shot示例

```python
# 示例：动态示例选择
# 1. 计算查询与历史示例的相似度
similarities = []
for example in example_pool:
    sim = compute_similarity(query, example['query'])
    similarities.append((sim, example))

# 2. 选择最相似的3个示例
top_examples = sorted(similarities, reverse=True)[:3]

# 3. 构建Few-shot提示
prompt = "以下是一些示例：\n"
for _, ex in top_examples:
    prompt += f"问题：{ex['query']}\n答案：{ex['answer']}\n\n"
prompt += f"现在回答：{query}"
```

**来源：** [Prompt Engineering Guide - Active Prompting](https://www.promptingguide.ai/techniques/activeprompt)

---

## 技术选择指南

### 按场景选择

| 场景 | 推荐技术 | 原因 |
|------|----------|------|
| **简单问答** | Few-shot | 快速引导格式 |
| **复杂推理** | CoT + Self-Consistency | 需要验证 |
| **多步任务** | ReAct | 需要工具调用 |
| **RAG检索** | Query Decomposition + RAT | 专为RAG设计 |
| **格式要求** | Structured Output | 确保可解析 |
| **不确定场景** | ToT | 探索多种可能 |

### 按可靠性要求选择

```
低要求（快速响应）
└─ Few-shot + CoT

中要求（平衡）
└─ CoT + Structured Output

高要求（关键任务）
└─ Self-Consistency + ToT + 验证
```

---

## 学习路径

### 初学者路径（1-2周）

```
第1周：基础技术
├─ Day 1-2: Few-shot Learning
├─ Day 3-4: Chain-of-Thought
└─ Day 5-7: Structured Output + 实战

第2周：RAG应用
├─ Day 1-3: Query Decomposition
├─ Day 4-5: RAT
└─ Day 6-7: 综合项目
```

### 进阶路径（2-3周）

```
第1周：验证技术
├─ Self-Consistency
├─ Active Prompting
└─ 实战优化

第2周：复杂推理
├─ Tree of Thoughts
├─ ReAct
└─ Meta Prompting

第3周：生产实践
└─ 综合应用 + 性能优化
```

---

## 与基础版的关系

```
基础版（04_Prompt_Engineering基础）
├─ 角色设定
├─ 指令清晰
├─ 格式控制
├─ 上下文工程
└─ 输出质量控制
    ↓
    应用这些基础原则
    ↓
进阶版（本章）
├─ Few-shot（基于示例的角色+格式）
├─ CoT（基于推理的指令）
├─ Structured Output（强化格式控制）
└─ RAT（强化上下文工程）
```

**关键区别：**
- 基础版：教你"写好一个提示词"
- 进阶版：教你"设计一个提示系统"

---

## 实战项目预览

本章将通过以下实战项目学习：

1. **Few-shot场景**：文档信息提取系统
2. **CoT场景**：代码审查助手
3. **Self-Consistency场景**：医疗问答验证
4. **ToT场景**：多策略检索系统
5. **ReAct场景**：动态RAG系统
6. **Structured Output场景**：结构化数据提取
7. **Query Decomposition场景**：复杂查询处理
8. **RAT场景**：迭代检索优化
9. **Meta Prompting场景**：自适应提示生成
10. **Active Prompting场景**：智能示例选择
11. **RAG综合应用**：生产级RAG系统

---

## 核心原则

1. **推理优先**：让模型说出思考过程
2. **验证机制**：不要相信单次输出
3. **动态调整**：根据任务动态选择策略
4. **结构化**：确保输出可被程序处理
5. **迭代优化**：通过反馈持续改进

---

## 参考资源

### 官方指南
- [Prompt Engineering Guide 2026](https://www.promptingguide.ai/)
- [OpenAI Prompt Engineering](https://platform.openai.com/docs/guides/prompt-engineering)
- [Anthropic Prompt Engineering](https://docs.anthropic.com/claude/docs/prompt-engineering)

### 学术论文
- [Chain-of-Thought Prompting](https://arxiv.org/abs/2201.11903)
- [Tree of Thoughts](https://arxiv.org/abs/2305.10601)
- [ReAct: Synergizing Reasoning and Acting](https://arxiv.org/abs/2210.03629)
- [Retrieval Augmented Thoughts (RAT)](https://arxiv.org/abs/2403.05313)

### 实践指南
- [Lakera AI Guide 2026](https://www.lakera.ai/blog/prompt-engineering-guide)
- [IBM Prompt Engineering 2026](https://www.ibm.com/think/prompt-engineering)
- [NVIDIA RAG Blueprint](https://docs.nvidia.com/rag/2.3.0/)

---

**下一步：** 阅读 `02_第一性原理.md` 理解这些技术的底层逻辑
