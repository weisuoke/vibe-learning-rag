# 实战代码：生产环境部署实战

> **本节目标**：通过安全多租户RAG API项目，掌握安全控制、限流、错误处理、监控的完整部署方案。

---

## 一、项目场景

**企业级多租户RAG API**：
- 输入验证（防注入）
- 输出过滤（PII脱敏）
- 访问控制（RBAC）
- 限流保护（防滥用）
- 完整监控（可观测性）
- 多租户隔离

**部署目标**：
- 安全性：HIPAA/PCI DSS合规
- 可用性：99.9%+
- 性能：<2秒响应
- 成本：可控预算

---

## 二、环境准备

```bash
# 安装依赖
uv add fastapi uvicorn langchain langchain-openai \
  redis pydantic slowapi prometheus-client structlog

# 配置环境
cat > .env << EOF
OPENAI_API_KEY=your_api_key_here
REDIS_HOST=localhost
REDIS_PORT=6379
RATE_LIMIT=100/hour
LANGCHAIN_TRACING_V2=true
LANGCHAIN_API_KEY=your_langsmith_key
EOF
```

---

## 三、安全层实现

### 3.1 输入验证

```python
# security/validation.py
from pydantic import BaseModel, Field, validator
import re

class QueryRequest(BaseModel):
    """查询请求（带验证）"""
    question: str = Field(..., min_length=1, max_length=1000)
    tenant_id: str = Field(..., pattern=r"^[a-zA-Z0-9_-]+$")
    user_id: str = Field(..., pattern=r"^[a-zA-Z0-9_-]+$")

    @validator("question")
    def validate_question(cls, v):
        """验证查询内容"""
        # 检测SQL注入
        sql_keywords = ["DROP", "DELETE", "INSERT", "UPDATE", "EXEC"]
        if any(keyword in v.upper() for keyword in sql_keywords):
            raise ValueError("检测到潜在的SQL注入")

        # 检测XSS
        if "<script>" in v.lower() or "javascript:" in v.lower():
            raise ValueError("检测到潜在的XSS攻击")

        # 检测Prompt注入
        injection_patterns = [
            r"忽略.*指令",
            r"ignore.*instructions",
            r"system.*prompt"
        ]
        for pattern in injection_patterns:
            if re.search(pattern, v, re.IGNORECASE):
                raise ValueError("检测到Prompt注入尝试")

        return v
```

### 3.2 PII过滤

```python
# security/pii_filter.py
import re

class PIIFilter:
    """PII过滤器"""

    PATTERNS = {
        "email": r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b",
        "phone": r"\b\d{3}[-.]?\d{3}[-.]?\d{4}\b",
        "ssn": r"\b\d{3}-\d{2}-\d{4}\b",
        "credit_card": r"\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b",
    }

    def filter(self, text: str) -> str:
        """过滤PII"""
        for pii_type, pattern in self.PATTERNS.items():
            if pii_type == "email":
                text = re.sub(pattern, "[EMAIL_REDACTED]", text)
            elif pii_type == "phone":
                text = re.sub(pattern, "[PHONE_REDACTED]", text)
            elif pii_type == "ssn":
                text = re.sub(pattern, "[SSN_REDACTED]", text)
            elif pii_type == "credit_card":
                text = re.sub(pattern, "[CARD_REDACTED]", text)

        return text
```

---

## 四、限流保护

### 4.1 Redis限流

```python
# security/rate_limiter.py
from redis import Redis
import time

class RateLimiter:
    """Redis限流器"""

    def __init__(self, redis_client: Redis):
        self.redis = redis_client

    def check_rate_limit(
        self,
        key: str,
        limit: int = 100,
        window: int = 3600
    ) -> bool:
        """检查限流

        Args:
            key: 限流键（如user_id）
            limit: 限制次数
            window: 时间窗口（秒）

        Returns:
            bool: True=允许，False=超限
        """
        current = int(time.time())
        window_start = current - window

        # 清理过期记录
        self.redis.zremrangebyscore(key, 0, window_start)

        # 获取当前计数
        count = self.redis.zcard(key)

        if count >= limit:
            return False

        # 记录本次请求
        self.redis.zadd(key, {str(current): current})
        self.redis.expire(key, window)

        return True
```

### 4.2 FastAPI集成

```python
# 使用slowapi
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from fastapi import FastAPI, Request

limiter = Limiter(key_func=get_remote_address)
app = FastAPI()
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.post("/query")
@limiter.limit("100/hour")
async def query(request: Request, query_req: QueryRequest):
    """限流保护的查询接口"""
    # 处理查询
    pass
```

---

## 五、访问控制

### 5.1 RBAC实现

```python
# security/rbac.py
from enum import Enum
from typing import Set

class Role(Enum):
    """用户角色"""
    ADMIN = "admin"
    POWER_USER = "power_user"
    STANDARD_USER = "standard_user"

class Permission(Enum):
    """权限"""
    READ = "read"
    WRITE = "write"
    DELETE = "delete"

ROLE_PERMISSIONS = {
    Role.ADMIN: {Permission.READ, Permission.WRITE, Permission.DELETE},
    Role.POWER_USER: {Permission.READ, Permission.WRITE},
    Role.STANDARD_USER: {Permission.READ},
}

class AccessControl:
    """访问控制"""

    def __init__(self):
        self.user_roles = {}

    def check_permission(self, user_id: str, permission: Permission) -> bool:
        """检查权限"""
        role = self.user_roles.get(user_id, Role.STANDARD_USER)
        allowed = ROLE_PERMISSIONS.get(role, set())
        return permission in allowed
```

### 5.2 多租户隔离

```python
# security/tenant_isolation.py
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings

class TenantIsolation:
    """多租户隔离"""

    def __init__(self):
        self.embeddings = OpenAIEmbeddings()

    def get_vectorstore(self, tenant_id: str):
        """获取租户专属向量存储"""
        return Chroma(
            collection_name=f"tenant_{tenant_id}",
            embedding_function=self.embeddings
        )

    def get_chain(self, tenant_id: str):
        """获取租户专属链"""
        vectorstore = self.get_vectorstore(tenant_id)
        retriever = vectorstore.as_retriever()

        # 创建租户专属链
        from langchain_openai import ChatOpenAI
        from langchain_core.prompts import ChatPromptTemplate
        from langchain_core.output_parsers import StrOutputParser

        prompt = ChatPromptTemplate.from_template(
            "基于上下文回答：\n\n{context}\n\n问题：{question}"
        )
        llm = ChatOpenAI(model="gpt-4o-mini")
        parser = StrOutputParser()

        def format_docs(docs):
            return "\n\n".join(doc.page_content for doc in docs)

        chain = (
            {"context": retriever | format_docs, "question": lambda x: x}
            | prompt
            | llm
            | parser
        )

        return chain.with_config(
            metadata={"tenant_id": tenant_id}
        )
```

---

## 六、完整生产API

### 6.1 主应用

```python
# main.py
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from security.validation import QueryRequest
from security.pii_filter import PIIFilter
from security.rate_limiter import RateLimiter
from security.rbac import AccessControl, Permission
from security.tenant_isolation import TenantIsolation
from monitoring.callbacks import MonitoringCallback, CostTracker
from monitoring.metrics import MetricsCallback
from redis import Redis
import structlog
import uuid
import os

# 加载环境变量
load_dotenv()

# 配置日志
structlog.configure(
    processors=[
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.add_log_level,
        structlog.processors.JSONRenderer()
    ]
)
logger = structlog.get_logger()

# 创建应用
app = FastAPI(
    title="Production RAG API",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境应限制
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 初始化组件
redis_client = Redis(
    host=os.getenv("REDIS_HOST", "localhost"),
    port=int(os.getenv("REDIS_PORT", 6379)),
    decode_responses=True
)
rate_limiter = RateLimiter(redis_client)
pii_filter = PIIFilter()
access_control = AccessControl()
tenant_isolation = TenantIsolation()


class QueryResponse(BaseModel):
    """查询响应"""
    answer: str
    correlation_id: str
    metrics: dict


@app.post("/query", response_model=QueryResponse)
async def query(request: Request, query_req: QueryRequest):
    """安全的查询接口

    安全措施:
    - 输入验证（Pydantic）
    - 限流保护（Redis）
    - 访问控制（RBAC）
    - 租户隔离
    - PII过滤
    - 完整监控
    """
    # 生成关联ID
    correlation_id = str(uuid.uuid4())

    # 绑定日志
    log = logger.bind(
        correlation_id=correlation_id,
        tenant_id=query_req.tenant_id,
        user_id=query_req.user_id
    )

    log.info("query_received", question=query_req.question)

    try:
        # 1. 限流检查
        rate_key = f"rate:{query_req.tenant_id}:{query_req.user_id}"
        if not rate_limiter.check_rate_limit(rate_key, limit=100, window=3600):
            log.warning("rate_limit_exceeded")
            raise HTTPException(status_code=429, detail="请求过于频繁")

        # 2. 权限检查
        if not access_control.check_permission(query_req.user_id, Permission.READ):
            log.warning("permission_denied")
            raise HTTPException(status_code=403, detail="权限不足")

        # 3. 获取租户专属链
        chain = tenant_isolation.get_chain(query_req.tenant_id)

        # 4. 创建监控回调
        monitoring_cb = MonitoringCallback()
        cost_tracker = CostTracker(budget=10.0)
        metrics_cb = MetricsCallback(chain_name="rag_chain")

        # 5. 执行查询
        answer = chain.invoke(
            query_req.question,
            config={
                "callbacks": [monitoring_cb, cost_tracker, metrics_cb],
                "run_name": "secure_query",
                "tags": ["production", query_req.tenant_id],
                "metadata": {
                    "correlation_id": correlation_id,
                    "tenant_id": query_req.tenant_id,
                    "user_id": query_req.user_id
                }
            }
        )

        # 6. PII过滤
        safe_answer = pii_filter.filter(answer)

        # 7. 获取指标
        metrics = monitoring_cb.get_metrics()

        log.info(
            "query_completed",
            answer_length=len(safe_answer),
            tokens=metrics["total_tokens"],
            cost=metrics["total_cost"]
        )

        return QueryResponse(
            answer=safe_answer,
            correlation_id=correlation_id,
            metrics=metrics
        )

    except HTTPException:
        raise
    except Exception as e:
        log.error("query_failed", error=str(e))
        raise HTTPException(status_code=500, detail="系统错误")


@app.get("/health")
async def health():
    """健康检查"""
    return {
        "status": "healthy",
        "version": "1.0.0"
    }


@app.get("/metrics")
async def metrics():
    """Prometheus指标"""
    from prometheus_client import generate_latest
    return generate_latest()


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info"
    )
```

---

## 七、Docker部署

### 7.1 Dockerfile

```dockerfile
# Dockerfile
FROM python:3.13-slim

WORKDIR /app

# 安装uv
RUN pip install uv

# 复制依赖文件
COPY pyproject.toml uv.lock ./

# 安装依赖
RUN uv sync --no-dev

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 8000

# 启动应用
CMD ["uv", "run", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 7.2 docker-compose.yml

```yaml
# docker-compose.yml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - LANGCHAIN_TRACING_V2=true
      - LANGCHAIN_API_KEY=${LANGCHAIN_API_KEY}
    depends_on:
      - redis
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    restart: unless-stopped

volumes:
  redis_data:
  prometheus_data:
```

### 7.3 Prometheus配置

```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'rag_api'
    static_configs:
      - targets: ['api:8000']
```

---

## 八、部署与运行

### 8.1 本地开发

```bash
# 安装依赖
uv sync

# 启动Redis
docker run -d -p 6379:6379 redis:7-alpine

# 运行API
uv run python main.py

# 测试
curl -X POST http://localhost:8000/query \
  -H "Content-Type: application/json" \
  -d '{
    "question": "什么是LCEL?",
    "tenant_id": "tenant_a",
    "user_id": "user_123"
  }'
```

### 8.2 Docker部署

```bash
# 构建镜像
docker-compose build

# 启动服务
docker-compose up -d

# 查看日志
docker-compose logs -f api

# 停止服务
docker-compose down
```

### 8.3 生产部署

```bash
# 使用环境变量
export OPENAI_API_KEY=your_key
export LANGCHAIN_API_KEY=your_key

# 启动（生产模式）
docker-compose -f docker-compose.prod.yml up -d

# 健康检查
curl http://localhost:8000/health

# 查看指标
curl http://localhost:8000/metrics
```

---

## 九、监控与告警

### 9.1 Grafana仪表板

```yaml
# grafana-dashboard.json（简化）
{
  "dashboard": {
    "title": "RAG API Monitoring",
    "panels": [
      {
        "title": "请求速率",
        "targets": [
          {
            "expr": "rate(chain_calls_total[5m])"
          }
        ]
      },
      {
        "title": "延迟分布",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, chain_latency_seconds)"
          }
        ]
      },
      {
        "title": "成本追踪",
        "targets": [
          {
            "expr": "rate(chain_cost_dollars[1h])"
          }
        ]
      }
    ]
  }
}
```

### 9.2 告警规则

```yaml
# alerts.yml
groups:
  - name: rag_api_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(chain_calls_total{status="error"}[5m]) > 0.05
        for: 5m
        annotations:
          summary: "错误率过高"

      - alert: HighLatency
        expr: histogram_quantile(0.95, chain_latency_seconds) > 3
        for: 5m
        annotations:
          summary: "延迟过高"

      - alert: HighCost
        expr: rate(chain_cost_dollars[1h]) > 10
        for: 10m
        annotations:
          summary: "成本过高"
```

---

## 十、总结

### 核心要点

1. **安全层**：输入验证 + PII过滤 + RBAC
2. **限流保护**：Redis限流 + slowapi
3. **租户隔离**：独立向量存储 + 元数据标记
4. **完整监控**：Callbacks + Prometheus + LangSmith
5. **容器化部署**：Docker + docker-compose

### 安全检查清单

- [x] 输入验证（Pydantic）
- [x] SQL/XSS/Prompt注入防护
- [x] PII检测与脱敏
- [x] 限流保护（100/hour）
- [x] 访问控制（RBAC）
- [x] 多租户隔离
- [x] 审计日志（结构化）
- [x] 成本追踪与告警
- [x] 健康检查
- [x] Prometheus指标

### 部署架构

```
用户请求
  ↓
负载均衡（Nginx）
  ↓
FastAPI应用（Docker）
  ↓
Redis（限流+缓存）
  ↓
LangChain（RAG）
  ↓
OpenAI API
  ↓
Prometheus（监控）
  ↓
Grafana（可视化）
```

### 实战收获

- ✅ 生产级安全防护
- ✅ 多租户隔离
- ✅ 完整监控体系
- ✅ 容器化部署
- ✅ HIPAA/PCI DSS合规

---

**下一步**：学习【完整项目实战】，整合所有最佳实践。
