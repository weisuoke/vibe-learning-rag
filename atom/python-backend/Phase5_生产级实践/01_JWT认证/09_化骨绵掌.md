# JWT认证 - 化骨绵掌

10个2分钟知识卡片，帮助你快速掌握 JWT 认证的核心知识。

---

## 卡片1：JWT 直觉理解

**一句话：** JWT 是一张"自证身份的电子通行证"，上面印着你的信息和防伪标签。

**举例：**
```
传统方式（Session）：
你拿着一张卡片（只有编号），保安每次都要查登记本确认你的身份

JWT 方式：
你拿着一张智能卡（印着你的信息 + 防伪标签），保安扫一下就知道你是谁
```

**应用：** 在 AI Agent API 中，每次请求都带上 JWT，服务器直接验证签名就知道用户身份，无需查询数据库。

---

## 卡片2：JWT 的三部分结构

**一句话：** JWT = Header（类型说明）+ Payload（用户信息）+ Signature（防伪签名），用点号分隔。

**举例：**
```python
jwt_token = "eyJhbGci...  .  eyJ1c2Vy...  .  5K8v7J9m..."
            ^^^^^^^^^^     ^^^^^^^^^^     ^^^^^^^^^^
            Header         Payload        Signature
            (Base64)       (Base64)       (Base64)

# 解码 Header
{"alg": "HS256", "typ": "JWT"}

# 解码 Payload
{"user_id": 123, "username": "alice", "exp": 1234567890}

# Signature 是签名，无法解码（需要密钥验证）
```

**应用：** 服务器验证 Signature 确保 Token 未被篡改，然后从 Payload 中提取用户信息。

---

## 卡片3：Base64URL 编码

**一句话：** Base64URL 是 Base64 的 URL 安全版本，用于编码 JWT 的 Header 和 Payload。

**举例：**
```python
import base64
import json

# 原始数据
data = {"user_id": 123, "username": "alice"}

# 1. 转 JSON 字符串
json_str = json.dumps(data)  # '{"user_id": 123, "username": "alice"}'

# 2. Base64 编码
encoded = base64.urlsafe_b64encode(json_str.encode()).decode()

# 3. 去掉末尾的 = 填充
encoded = encoded.rstrip("=")

print(encoded)
# eyJ1c2VyX2lkIjoxMjMsInVzZXJuYW1lIjoiYWxpY2UifQ

# 解码（任何人都能解码）
decoded = base64.urlsafe_b64decode(encoded + "==").decode()
print(decoded)
# {"user_id": 123, "username": "alice"}
```

**关键点：**
- Base64URL 不是加密，只是编码（任何人都能解码）
- 所以 Payload 不能存敏感信息（密码、信用卡号等）

**应用：** JWT 的 Header 和 Payload 都是 Base64URL 编码，可以直接解码查看内容。

---

## 卡片4：HMAC-SHA256 签名

**一句话：** HMAC-SHA256 是一种签名算法，使用密钥生成签名，确保数据未被篡改。

**举例：**
```python
import hmac
import hashlib

# 数据
message = "Header.Payload"

# 密钥（只有服务器知道）
secret_key = "your-secret-key"

# 生成签名
signature = hmac.new(
    secret_key.encode(),
    message.encode(),
    hashlib.sha256
).hexdigest()

print(signature)
# 5a3f2c1b8e9d7a6f4c2e1b9a8d7c6f5e4d3c2b1a9f8e7d6c5b4a3f2e1d0c9b8a

# 验证签名
def verify(message, signature, secret_key):
    expected = hmac.new(
        secret_key.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(signature, expected)

print(verify(message, signature, secret_key))  # True
```

**关键点：**
- 签名需要密钥，攻击者无法伪造
- 修改 message 后签名会失效
- 使用 `compare_digest` 防止时序攻击

**应用：** JWT 的 Signature 就是用 HMAC-SHA256 对 Header + Payload 签名。

---

## 卡片5：Token 过期处理

**一句话：** JWT 通过 `exp` 字段设置过期时间，过期后自动失效。

**举例：**
```python
from datetime import datetime, timedelta
from jose import jwt, JWTError

# 生成 Token（15分钟后过期）
payload = {
    "user_id": 123,
    "exp": datetime.utcnow() + timedelta(minutes=15)
}
token = jwt.encode(payload, SECRET_KEY, algorithm="HS256")

# 验证 Token
try:
    payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
    print("Token 有效")
except jwt.ExpiredSignatureError:
    print("Token 已过期")  # 15分钟后会触发
except JWTError:
    print("Token 无效")
```

**过期时间建议：**
- Access Token：15 分钟（短期，频繁使用）
- Refresh Token：7 天（长期，只用于刷新）

**应用：** AI Agent API 的 Access Token 设置 15 分钟过期，即使泄露影响也小。

---

## 卡片6：Refresh Token 机制

**一句话：** Refresh Token 是长期有效的 Token，用于刷新短期的 Access Token，平衡安全性和用户体验。

**举例：**
```python
# 登录时返回双 Token
@app.post("/login")
async def login(username: str, password: str):
    return {
        "access_token": create_token(user_id, expires=15min),   # 短期
        "refresh_token": create_token(user_id, expires=7days)   # 长期
    }

# Access Token 过期后，用 Refresh Token 刷新
@app.post("/refresh")
async def refresh(refresh_token: str):
    # 验证 Refresh Token
    payload = jwt.decode(refresh_token, REFRESH_SECRET_KEY)

    # 生成新的双 Token
    return {
        "access_token": create_token(payload["user_id"], expires=15min),
        "refresh_token": create_token(payload["user_id"], expires=7days)
    }
```

**工作流程：**
```
1. 用户登录 → 获取双 Token
2. 使用 Access Token 调用 API（15分钟内）
3. Access Token 过期 → 用 Refresh Token 刷新
4. 获取新的双 Token → 继续使用
5. Refresh Token 过期（7天后）→ 重新登录
```

**应用：** 用户 7 天内无需重新登录，但每 15 分钟自动刷新 Access Token（前端自动处理）。

---

## 卡片7：RBAC 权限模型

**一句话：** RBAC（基于角色的访问控制）通过角色来管理权限，用户拥有角色，角色拥有权限。

**举例：**
```python
# 定义角色
class Role(str, Enum):
    USER = "user"           # 普通用户
    ADMIN = "admin"         # 管理员
    SUPER_ADMIN = "super_admin"  # 超级管理员

# JWT Payload 中包含角色
payload = {
    "user_id": 123,
    "role": "admin"
}

# 检查角色的依赖函数
def require_role(required_role: Role):
    async def checker(current_user: dict = Depends(get_current_user)):
        if current_user["role"] != required_role:
            raise HTTPException(403, "权限不足")
        return current_user
    return checker

# 使用
@app.delete("/admin/user/{user_id}")
async def delete_user(
    user_id: int,
    current_user: dict = Depends(require_role(Role.ADMIN))
):
    # 只有管理员能访问
    pass
```

**角色层级：**
```
SUPER_ADMIN（超级管理员）
    ↓ 拥有所有权限
ADMIN（管理员）
    ↓ 拥有部分管理权限
USER（普通用户）
    ↓ 只有基本权限
```

**应用：** AI Agent API 中，免费用户只能调用基础模型，付费用户可以调用高级模型。

---

## 卡片8：Token 存储策略

**一句话：** Token 的存储方式直接影响安全性，推荐使用 HttpOnly Cookie。

**举例：**
```python
# ❌ 错误：存在 localStorage（容易被 XSS 攻击）
# JavaScript
localStorage.setItem('access_token', token);

# ✅ 正确：存在 HttpOnly Cookie（JavaScript 无法访问）
# Python (FastAPI)
@app.post("/login")
async def login(response: Response, username: str, password: str):
    token = create_access_token(user_id=123)

    response.set_cookie(
        key="access_token",
        value=token,
        httponly=True,      # JavaScript 无法访问
        secure=True,        # 只在 HTTPS 下传输
        samesite="lax",     # 防止 CSRF 攻击
        max_age=900         # 15分钟
    )

    return {"message": "登录成功"}
```

**存储方案对比：**

| 方案 | XSS 风险 | CSRF 风险 | 跨域 | 推荐度 |
|------|---------|----------|------|--------|
| localStorage | ❌ 高 | ✅ 低 | ✅ 好 | ❌ |
| HttpOnly Cookie | ✅ 低 | ⚠️ 中 | ⚠️ 受限 | ✅ |
| Memory | ✅ 低 | ✅ 低 | ❌ 差 | ⚠️ |

**应用：** AI Agent API 使用 HttpOnly Cookie 存储 Token，防止 XSS 攻击窃取。

---

## 卡片9：Token 黑名单

**一句话：** Token 黑名单用于撤销 JWT，将需要撤销的 Token 存入 Redis，验证时检查黑名单。

**举例：**
```python
from redis import Redis

redis_client = Redis()

# 登出时，将 Token 加入黑名单
@app.post("/logout")
async def logout(token: str):
    # 解析 Token 获取过期时间
    payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
    exp = payload["exp"]

    # 计算剩余有效时间
    ttl = exp - int(datetime.utcnow().timestamp())

    # 加入黑名单（只需存到过期时间）
    redis_client.setex(f"blacklist:{token}", ttl, "1")

    return {"message": "登出成功"}

# 验证时检查黑名单
async def get_current_user(token: str):
    # 1. 检查黑名单
    if redis_client.exists(f"blacklist:{token}"):
        raise HTTPException(401, "Token 已被撤销")

    # 2. 验证签名
    payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
    return payload
```

**优化策略：**
- Access Token（15分钟）：不使用黑名单（很快过期）
- Refresh Token（7天）：使用黑名单（需要撤销能力）

**应用：** 用户修改密码时，撤销所有 Refresh Token，强制重新登录。

---

## 卡片10：生产环境最佳实践

**一句话：** 生产环境需要考虑安全性、性能、可维护性等多个方面。

**安全检查清单：**
```python
# 1. 使用 HTTPS
# 2. Token 存储在 HttpOnly Cookie
response.set_cookie(
    key="access_token",
    value=token,
    httponly=True,
    secure=True,
    samesite="lax"
)

# 3. 短过期时间
ACCESS_TOKEN_EXPIRE = timedelta(minutes=15)
REFRESH_TOKEN_EXPIRE = timedelta(days=7)

# 4. 密钥管理
SECRET_KEY = os.getenv("SECRET_KEY")  # 从环境变量读取
assert SECRET_KEY, "SECRET_KEY 未设置"

# 5. 错误处理
@app.exception_handler(JWTError)
async def jwt_error_handler(request, exc):
    return JSONResponse(
        status_code=401,
        content={"detail": "认证失败"}
    )

# 6. 日志记录
logger.info(f"用户 {user_id} 登录成功")
logger.warning(f"Token 验证失败: {token[:10]}...")

# 7. 限流保护
@app.post("/login")
@limiter.limit("5/minute")  # 每分钟最多 5 次登录尝试
async def login(...):
    pass

# 8. CORS 配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://app.example.com"],  # 不要用 *
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["Authorization"]
)
```

**性能优化：**
```python
# 1. 缓存用户信息（减少数据库查询）
@lru_cache(maxsize=1000)
def get_user_from_db(user_id: int):
    return db.query(User).filter(User.id == user_id).first()

# 2. 使用连接池（Redis）
redis_pool = redis.ConnectionPool(
    host='localhost',
    port=6379,
    max_connections=50
)
redis_client = redis.Redis(connection_pool=redis_pool)

# 3. 异步验证
async def get_current_user(token: str):
    # 使用异步 Redis 客户端
    is_blacklisted = await redis_client.exists(f"blacklist:{token}")
    if is_blacklisted:
        raise HTTPException(401)

    payload = jwt.decode(token, SECRET_KEY)
    return payload
```

**监控指标：**
- 登录成功率
- Token 验证失败率
- Token 刷新频率
- 黑名单大小
- 平均响应时间

**应用：** AI Agent API 在生产环境中需要考虑这些最佳实践，确保安全、稳定、高性能。

---

## 总结

这 10 个知识卡片覆盖了 JWT 认证的核心知识：

1. **直觉理解** - JWT 是什么
2. **三部分结构** - Header、Payload、Signature
3. **Base64URL 编码** - 编码不是加密
4. **HMAC-SHA256 签名** - 防止篡改
5. **Token 过期** - 自动失效机制
6. **Refresh Token** - 平衡安全和体验
7. **RBAC 权限** - 基于角色的访问控制
8. **存储策略** - HttpOnly Cookie 最安全
9. **Token 黑名单** - 撤销机制
10. **生产实践** - 安全、性能、监控

掌握这些知识，你就能在 AI Agent API 中正确使用 JWT 认证！

---

## 快速参考

**生成 Token：**
```python
token = jwt.encode({"user_id": 123, "exp": ...}, SECRET_KEY, algorithm="HS256")
```

**验证 Token：**
```python
payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
```

**保护路由：**
```python
@app.get("/protected")
async def protected(current_user: dict = Depends(get_current_user)):
    return {"user_id": current_user["user_id"]}
```

**刷新 Token：**
```python
@app.post("/refresh")
async def refresh(refresh_token: str):
    payload = jwt.decode(refresh_token, REFRESH_SECRET_KEY)
    return {"access_token": create_access_token(payload["user_id"])}
```

**撤销 Token：**
```python
redis_client.setex(f"blacklist:{token}", ttl, "1")
```
