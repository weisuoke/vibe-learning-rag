# 化骨绵掌

> 10个2分钟知识卡片，快速掌握 Agentic RAG 核心要点

---

## 卡片1：直觉理解 - Agentic RAG 是什么？

**一句话：** Agentic RAG = 给 RAG 装上"大脑"（推理） + "手脚"（工具） + "团队"（多代理）

**举例：**

**传统 RAG = 图书馆管理员**
- 你问："有关于 Python 的书吗？"
- 管理员：查找 → 拿书 → 给你
- 一次性服务，不会追问

**Agentic RAG = 智能研究助手**
- 你问："我想学 Python，应该从哪里开始？"
- 助手：
  1. **思考**："初学者需要基础教程"
  2. **规划**："先找入门书，再找实战项目"
  3. **行动**：检索多个来源
  4. **反思**："这些资源适合初学者吗？"
  5. **调整**：补充检索更简单的教程
  6. **生成**：提供完整学习路径

**应用：** 复杂查询、高价值决策支持、多轮对话

---

## 卡片2：形式化定义 - RTPM 框架

**一句话：** RTPM 是 Agentic RAG 的核心架构，包含 4 个必需组件

**定义：**

```
RTPM = Reflection + Tool Use + Planning + Multi-Agent
```

| 组件 | 定义 | 作用 |
|------|------|------|
| **R**eflection | 自我评估和迭代改进 | 发现问题并改进 |
| **T**ool Use | 调用外部工具和 API | 扩展能力边界 |
| **P**lanning | 多步骤任务分解 | 处理复杂查询 |
| **M**ulti-Agent | 协作式问题求解 | 专业化分工 |

**代码示例：**
```python
# RTPM 框架的最小实现
class AgenticRAG:
    def query(self, user_query):
        # Planning：分解任务
        plan = self.planner.create_plan(user_query)

        # Tool Use：执行检索
        docs = []
        for step in plan:
            result = self.tools[step.tool].execute(step.query)

            # Reflection：评估质量
            if self.evaluator.quality(result) < 0.8:
                step = self.planner.improve(step)
                result = self.tools[step.tool].execute(step.query)

            docs.extend(result)

        # Multi-Agent：协作生成
        answer = self.agents["generator"].generate(docs, user_query)
        return answer
```

**应用：** 所有 Agentic RAG 系统都必须实现 RTPM 框架

---

## 卡片3：关键概念1 - Routing Agent（查询路由代理）

**一句话：** 根据查询类型选择合适的检索策略

**原理：**
```
用户查询 → 分析查询类型 → 选择检索策略 → 执行检索
```

**类比：**
- **前端**：路由守卫（根据请求选择处理方式）
- **日常**：医院前台（根据需求分流到不同科室）

**代码示例：**
```python
def routing_agent(query):
    # 使用 LLM 分析查询类型
    query_type = llm.classify(query)

    if query_type == "semantic":
        return vector_search(query)
    elif query_type == "exact_match":
        return keyword_search(query)
    else:
        return hybrid_search(query)
```

**应用：** 简单查询用向量检索，精确匹配用关键词检索，复杂查询用混合检索

---

## 卡片4：关键概念2 - Planning Agent（规划代理）

**一句话：** 将复杂查询分解为多个子任务，逐个执行

**原理：**
```
复杂查询 → 分解为子任务 → 逐个执行 → 合成结果
```

**类比：**
- **前端**：状态管理器（任务编排）
- **日常**：项目经理（分解任务、分配执行）

**代码示例：**
```python
def planning_agent(complex_query):
    # 使用 LLM 分解任务
    plan = llm.generate(f"将以下查询分解为子任务：{complex_query}")

    # 执行每个子任务
    results = []
    for subtask in plan:
        result = execute_subtask(subtask)
        results.append(result)

    # 合成最终答案
    return synthesize(results)
```

**应用：** "比较三家公司财报" → 分解为 "公司A财报" + "公司B财报" + "公司C财报" + "对比分析"

---

## 卡片5：关键概念3 - ReAct Framework（推理行动框架）

**一句话：** 思考 → 行动 → 观察 → 反思的循环

**原理：**
```
Thought（思考）→ Action（行动）→ Observation（观察）→ Reflection（反思）
↑                                                              ↓
└──────────────────── 不满意，继续循环 ────────────────────────┘
```

**类比：**
- **前端**：响应式编程（观察-反应循环）
- **日常**：科学实验（假设-验证-调整）

**代码示例：**
```python
def react_agent(query, max_iterations=5):
    for i in range(max_iterations):
        # Thought：思考应该使用哪个工具
        thought = agent.think(query)

        # Action：执行工具
        action = agent.act(thought)
        result = execute_tool(action)

        # Observation：观察结果
        observation = agent.observe(result)

        # Reflection：满意吗？
        if is_satisfied(observation):
            return result
        else:
            # 不满意，改进查询
            query = improve_query(query, observation)
```

**应用：** 迭代检索与验证，直到结果满意

---

## 卡片6：对比区分 - Agentic RAG vs 传统 RAG

**一句话：** 传统 RAG 是被动的一次性检索，Agentic RAG 是主动的迭代优化

**对比表：**

| 维度 | 传统 RAG | Agentic RAG |
|------|----------|-------------|
| **检索方式** | 一次性检索 | 迭代检索、自适应调整 |
| **推理能力** | 无 | 思考-行动-观察-反思循环 |
| **工具使用** | 仅向量检索 | 多种工具（检索、API、计算） |
| **决策能力** | 无（固定流程） | 自主决策（动态策略） |
| **成本** | 低（$0.01） | 高（$0.036, 3.6x） |
| **延迟** | 低（1-2s） | 高（3-30s） |
| **准确率** | 基线 | +26-78% |
| **适用场景** | 简单语义查询 | 复杂多步推理查询 |

**关键洞察：**
- 不是所有查询都需要 Agentic RAG
- 简单查询用传统 RAG 更快更便宜
- 复杂查询用 Agentic RAG 更准确

**应用：** 使用 Adaptive RAG 动态选择策略

---

## 卡片7：进阶理解 - 成本与准确率的权衡

**一句话：** Agentic RAG 成本更高，但准确率显著提升，适合高价值场景

**数据对比（2025-2026）：**

| 指标 | 传统 RAG | Agentic RAG | 提升/增加 |
|------|----------|-------------|----------|
| 准确率 | 基线 | +26-78% | 26-78% |
| 复杂查询准确率 | 基线 | 5x | 400% |
| 错误率 | 基线 | -78% | 78% |
| 成本 | $0.01 | $0.036 | 3.6x |
| 延迟 | 1-2s | 3-30s | 2-10x |

**成本分析：**

**为什么成本更高？**
1. 多次 LLM 调用（规划、反思、生成）
2. 多次检索（迭代优化）
3. 工具调用（API、数据库、计算器）

**如何控制成本？**
1. 设置最大迭代次数（3-5 次）
2. 使用更便宜的模型做路由（GPT-3.5）
3. 缓存常见查询结果
4. 使用智能记忆（Mem0）减少 90% token

**应用：** 高价值场景（医疗、法律、金融）值得使用 Agentic RAG

---

## 卡片8：高级应用 - Multi-Agent（多代理协作）

**一句话：** 多个专业代理协同工作，实现专业化分工

**架构：**
```
用户查询
    ↓
规划代理（Planning Agent）
    ↓
检索代理（Retrieval Agent）→ 获取文档
    ↓
评估代理（Evaluation Agent）→ 评估质量
    ↓
生成代理（Generation Agent）→ 生成答案
    ↓
验证代理（Validation Agent）→ 验证准确性
    ↓
最终答案
```

**类比：**
- **前端**：微服务架构（多个服务协作）
- **日常**：电影制作团队（导演、编剧、摄影师、剪辑师）

**代码示例：**
```python
class MultiAgentRAG:
    def __init__(self):
        self.planner = PlanningAgent()
        self.retriever = RetrievalAgent()
        self.evaluator = EvaluationAgent()
        self.generator = GenerationAgent()

    def query(self, user_query):
        # 1. 规划代理制定计划
        plan = self.planner.create_plan(user_query)

        # 2. 检索代理执行检索
        docs = self.retriever.execute(plan)

        # 3. 评估代理评估质量
        quality = self.evaluator.evaluate(docs)

        # 4. 如果质量够好，生成代理生成答案
        if quality > 0.8:
            answer = self.generator.generate(docs, user_query)
            return answer
```

**应用：** 复杂任务需要 3-5 个代理，简单任务 1-2 个代理足够

---

## 卡片9：在 RAG 中的应用 - 实际场景

**一句话：** Agentic RAG 适合复杂查询、高价值决策、多轮对话

**场景1：企业知识库问答**

**查询**："比较 2023 年和 2024 年公司的主要产品发布"

**传统 RAG**：
- 一次性检索 "2023 2024 产品发布"
- 可能检索不全
- 直接生成（可能不准确）

**Agentic RAG**：
1. **Planning**：分解为 "2023 产品" + "2024 产品" + "对比分析"
2. **Tool Use**：调用检索工具 3 次
3. **Reflection**：检查是否遗漏重要产品
4. **Tool Use**：补充检索
5. **生成**：基于完整信息生成对比分析

**场景2：医疗诊断辅助**

**查询**："患者症状：发热、咳嗽、胸痛，可能的诊断？"

**Agentic RAG**：
1. **Planning**：分解为 "症状分析" + "可能疾病" + "鉴别诊断"
2. **Tool Use**：检索医学知识库
3. **Multi-Agent**：
   - 检索代理：获取相关病例
   - 评估代理：评估可靠性
   - 生成代理：生成诊断建议
4. **Reflection**：交叉验证多个来源
5. **生成**：提供诊断建议 + 引用来源

**应用：** 高价值场景必须使用 Agentic RAG

---

## 卡片10：总结与延伸 - 学习路径

**一句话：** 从理解核心概念到掌握实现技术，再到生产级优化

**学习路径：**

```
阶段1：理解核心概念（1-2天）
├── RTPM 框架
├── 五大核心能力
└── 与传统 RAG 的区别
    ↓
阶段2：掌握实现技术（3-5天）
├── LangChain ReAct agent
├── LangGraph 状态图
├── 工具注册和调用
└── 多代理协作
    ↓
阶段3：实战项目（5-7天）
├── 构建 Routing Agent
├── 实现 Planning Agent
├── 集成多种检索工具
└── 构建多代理系统
    ↓
阶段4：生产级优化（7-10天）
├── 成本控制策略
├── 错误处理和重试
├── 日志和监控
└── 性能调优
```

**主流框架（2026）：**

| 框架 | 适用场景 | 学习曲线 |
|------|----------|----------|
| LangChain | 快速原型开发 | 低 |
| LangGraph | 生产级部署 | 中等 |
| LlamaIndex | 数据密集型应用 | 中等 |
| CrewAI | 多代理协作 | 中等 |
| Azure AI Search | 企业级应用 | 高 |

**关键数据（记住）：**
- 准确率提升：26-78%
- 成本增加：3.6x
- 延迟增加：2-10x
- 适用场景：复杂查询、高价值决策

**下一步：**
1. 学习 5 个核心概念文件
2. 运行 5 个实战场景代码
3. 构建自己的 Agentic RAG 系统

---

## 快速回顾

### 10个卡片总结

1. **直觉理解**：Agentic RAG = 智能研究助手（vs 图书馆管理员）
2. **形式化定义**：RTPM 框架（Reflection + Tool Use + Planning + Multi-Agent）
3. **Routing Agent**：根据查询类型选择检索策略
4. **Planning Agent**：分解复杂查询为子任务
5. **ReAct Framework**：思考-行动-观察-反思循环
6. **对比区分**：传统 RAG（被动） vs Agentic RAG（主动）
7. **成本权衡**：成本 3.6x，准确率 +26-78%
8. **Multi-Agent**：多代理协作，专业化分工
9. **实际应用**：企业知识库、医疗诊断、法律咨询
10. **学习路径**：理解 → 实现 → 实战 → 优化

### 核心要点

**定义**：Agentic RAG = 传统 RAG + 自主 AI 代理

**核心架构**：RTPM 框架
- Reflection：自我评估和改进
- Tool Use：调用多种工具
- Planning：任务分解和编排
- Multi-Agent：协作式问题求解

**性能数据**：
- 准确率：+26-78%
- 成本：3.6x
- 延迟：2-10x

**适用场景**：
- ✅ 复杂多步推理查询
- ✅ 需要工具调用的任务
- ✅ 高价值决策支持
- ❌ 简单语义查询

**主流框架**：
- LangChain：快速原型
- LangGraph：生产级
- LlamaIndex：数据密集
- CrewAI：多代理
- Azure AI Search：企业级

---

## 记忆技巧

### 记忆口诀

**RTPM 框架**：
- **R**eflection = 反思改进
- **T**ool Use = 工具使用
- **P**lanning = 规划分解
- **M**ulti-Agent = 多代理协作

**五大核心能力**：
- **Routing**：路由选择
- **Planning**：规划分解
- **ReAct**：推理行动
- **Tool Use**：工具使用
- **Multi-Agent**：多代理协作

### 类比记忆

**Agentic RAG = 智能助手**
- Routing Agent = 前台接待（分流）
- Planning Agent = 项目经理（规划）
- ReAct = 科学实验（假设-验证）
- Tool Use = 工具箱（选工具）
- Multi-Agent = 团队协作（分工）

---

## 参考资源

### 学术论文
1. arXiv 2501.09136: Agentic RAG 综述（2025）
2. arXiv 2601.07711: Agentic RAG 实验对比（2026）

### 技术博客
1. IBM: What is Agentic RAG?
2. Mem0: Agentic RAG vs Traditional RAG
3. LangCopilot: 5x Better Accuracy
4. NVIDIA: Dynamic Knowledge

### 框架文档
1. LangChain: https://docs.langchain.com
2. LangGraph: https://langchain-ai.github.io/langgraph
3. LlamaIndex: https://docs.llamaindex.ai
4. CrewAI: https://docs.crewai.com

---

**版本**: v1.0
**创建时间**: 2026-02-17
**适用人群**: 所有学习者
**预计学习时间**: 20分钟（每个卡片2分钟）
