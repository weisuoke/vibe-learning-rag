# 化骨绵掌

将关系定义拆分成10个2分钟知识卡片，每个卡片独立完整。

---

## 卡片1：关系定义的本质

**一句话：** relationship 是 ORM 中声明"对象如何访问关联对象"的配置，让我们用面向对象的方式操作关系型数据库。

**举例：**
```python
class User(Base):
    conversations = relationship("Conversation")

# 直接访问关联对象
user = session.get(User, 1)
print(user.conversations)  # 自动查询关联的对话
```

**应用：** 在 AI Agent 开发中，用户对象可以直接访问其所有对话，无需手动编写 JOIN 查询。

---

## 卡片2：外键 vs relationship

**一句话：** 外键是数据库层面的约束（保证数据完整性），relationship 是 ORM 层面的导航（方便代码访问）。

**举例：**
```python
class Conversation(Base):
    # 外键：数据库约束
    user_id = Column(Integer, ForeignKey('users.id'))

    # relationship：Python 导航
    user = relationship("User")

# 外键保证不能创建属于不存在用户的对话
# relationship 让代码可以直接访问 conversation.user
```

**应用：** 两者通常一起使用，外键保证数据完整性，relationship 简化代码。

---

## 卡片3：一对多关系的定义

**一句话：** 一对多是最常用的关系类型，外键放在"多"的一方，两边都要定义 relationship。

**举例：**
```python
# "一"的一方（父表）
class User(Base):
    conversations = relationship("Conversation", back_populates="user")

# "多"的一方（子表）
class Conversation(Base):
    user_id = Column(Integer, ForeignKey('users.id'))  # 外键
    user = relationship("User", back_populates="conversations")
```

**应用：** 用户-对话、对话-消息都是一对多关系。

---

## 卡片4：多对多关系的定义

**一句话：** 多对多需要中间表，使用 secondary 参数指定中间表。

**举例：**
```python
# 中间表
conversation_tags = Table(
    'conversation_tags',
    Base.metadata,
    Column('conversation_id', ForeignKey('conversations.id')),
    Column('tag_id', ForeignKey('tags.id'))
)

# 两边的 relationship
class Conversation(Base):
    tags = relationship("Tag", secondary=conversation_tags)

class Tag(Base):
    conversations = relationship("Conversation", secondary=conversation_tags)
```

**应用：** 对话-标签、用户-角色都是多对多关系。

---

## 卡片5：back_populates 建立双向关系

**一句话：** back_populates 显式定义双向关系，比 backref 更清晰，推荐使用。

**举例：**
```python
class User(Base):
    conversations = relationship("Conversation", back_populates="user")

class Conversation(Base):
    user = relationship("User", back_populates="conversations")

# 双向访问
user.conversations  # 用户的所有对话
conversation.user   # 对话属于哪个用户
```

**应用：** 在 AI Agent 开发中，可以从用户查对话，也可以从对话查用户。

---

## 卡片6：懒加载策略（lazy）

**一句话：** lazy 参数控制何时加载关联数据，影响查询性能。

**举例：**
```python
# lazy='select'（默认）：访问时查询
conversations = relationship("Conversation", lazy='select')

# lazy='joined'：立即 JOIN 查询
conversations = relationship("Conversation", lazy='joined')

# lazy='selectin'：批量 IN 查询（推荐）
conversations = relationship("Conversation", lazy='selectin')
```

**应用：** 使用 `lazy='selectin'` 避免 N+1 查询问题。

---

## 卡片7：N+1 查询问题

**一句话：** 循环访问关联对象时，每次访问都会触发一次查询，导致性能问题。

**举例：**
```python
# 产生 N+1 问题
users = session.query(User).all()  # 1次查询
for user in users:
    print(user.conversations)  # N次查询

# 解决方案：使用 selectinload
from sqlalchemy.orm import selectinload

users = session.query(User).options(
    selectinload(User.conversations)
).all()  # 总共2次查询
```

**应用：** 在返回用户列表及其对话时，使用 selectinload 优化性能。

---

## 卡片8：级联操作（cascade）

**一句话：** cascade 控制删除父对象时如何处理子对象。

**举例：**
```python
class User(Base):
    conversations = relationship(
        "Conversation",
        cascade="all, delete-orphan"  # 删除用户时删除所有对话
    )

# 删除用户
session.delete(user)
session.commit()  # 自动删除所有 conversations
```

**应用：** 删除用户时自动清理其所有对话和消息。

---

## 卡片9：一对一关系

**一句话：** 一对一关系使用 uselist=False 参数，表示关联对象是单个对象而非列表。

**举例：**
```python
class User(Base):
    profile = relationship("Profile", uselist=False, back_populates="user")

class Profile(Base):
    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User", back_populates="profile")

# 访问
user.profile  # 单个 Profile 对象，不是列表
```

**应用：** 用户-个人资料是一对一关系。

---

## 卡片10：自引用关系

**一句话：** 自引用关系是表引用自己，需要使用 remote_side 参数指定"远端"。

**举例：**
```python
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)

    # 关注者（多对多自引用）
    followers = relationship(
        "User",
        secondary=user_followers,
        primaryjoin=id == user_followers.c.followed_id,
        secondaryjoin=id == user_followers.c.follower_id,
        back_populates="following"
    )

    following = relationship(
        "User",
        secondary=user_followers,
        primaryjoin=id == user_followers.c.follower_id,
        secondaryjoin=id == user_followers.c.followed_id,
        back_populates="followers"
    )
```

**应用：** 用户关注系统、组织树形结构都是自引用关系。

---

## 知识卡片总结

| 卡片 | 核心概念 | 关键点 |
|-----|---------|--------|
| 1 | 关系定义本质 | ORM 层面的对象导航 |
| 2 | 外键 vs relationship | 数据库约束 vs Python 导航 |
| 3 | 一对多关系 | 外键在"多"的一方 |
| 4 | 多对多关系 | 需要中间表 + secondary |
| 5 | back_populates | 显式双向关系 |
| 6 | 懒加载策略 | 控制查询时机 |
| 7 | N+1 问题 | 使用 selectinload 优化 |
| 8 | 级联操作 | 自动处理关联数据 |
| 9 | 一对一关系 | uselist=False |
| 10 | 自引用关系 | remote_side 参数 |

---

## 学习路径

**按顺序学习这10个卡片：**

```
卡片1（本质） → 卡片2（外键vs关系） → 卡片3（一对多） → 卡片4（多对多）
    ↓
卡片5（双向关系） → 卡片6（懒加载） → 卡片7（N+1问题） → 卡片8（级联）
    ↓
卡片9（一对一） → 卡片10（自引用）
```

**学习建议：**
1. 先掌握卡片1-5（基础概念）
2. 再学习卡片6-8（性能优化）
3. 最后学习卡片9-10（进阶用法）

---

## 快速复习

**5分钟复习清单：**

- [ ] 关系定义 = ORM 层面的对象导航
- [ ] 外键 + relationship 一起使用
- [ ] 一对多：外键在"多"的一方
- [ ] 多对多：需要中间表 + secondary
- [ ] 使用 back_populates 而非 backref
- [ ] lazy='selectin' 避免 N+1 问题
- [ ] cascade 控制级联操作
- [ ] 一对一：uselist=False
- [ ] 自引用：remote_side 参数

---

## 实战练习

**练习1：定义用户-对话关系**
```python
# 要求：
# 1. 一个用户可以有多个对话
# 2. 删除用户时自动删除所有对话
# 3. 使用 selectin 加载策略

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    conversations = relationship(
        "Conversation",
        back_populates="user",
        lazy='selectin',
        cascade="all, delete-orphan"
    )

class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User", back_populates="conversations")
```

**练习2：定义对话-标签关系**
```python
# 要求：
# 1. 一个对话可以有多个标签
# 2. 一个标签可以属于多个对话
# 3. 使用中间表

conversation_tags = Table(
    'conversation_tags',
    Base.metadata,
    Column('conversation_id', ForeignKey('conversations.id'), primary_key=True),
    Column('tag_id', ForeignKey('tags.id'), primary_key=True)
)

class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)
    tags = relationship("Tag", secondary=conversation_tags, back_populates="conversations")

class Tag(Base):
    __tablename__ = 'tags'
    id = Column(Integer, primary_key=True)
    conversations = relationship("Conversation", secondary=conversation_tags, back_populates="tags")
```

**练习3：优化 N+1 查询**
```python
# 问题代码
users = session.query(User).all()
for user in users:
    print(user.conversations)  # N+1 问题

# 优化后
from sqlalchemy.orm import selectinload

users = session.query(User).options(
    selectinload(User.conversations)
).all()
for user in users:
    print(user.conversations)  # 只有2次查询
```

---

## 常见错误

**错误1：忘记定义外键**
```python
# ❌ 错误
class Conversation(Base):
    user = relationship("User")  # 缺少外键

# ✅ 正确
class Conversation(Base):
    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User")
```

**错误2：多对多忘记中间表**
```python
# ❌ 错误
class Conversation(Base):
    tags = relationship("Tag")  # 缺少 secondary

# ✅ 正确
class Conversation(Base):
    tags = relationship("Tag", secondary=conversation_tags)
```

**错误3：使用 backref 而非 back_populates**
```python
# ❌ 不推荐
class User(Base):
    conversations = relationship("Conversation", backref="user")

# ✅ 推荐
class User(Base):
    conversations = relationship("Conversation", back_populates="user")

class Conversation(Base):
    user = relationship("User", back_populates="conversations")
```

---

## 记忆口诀

> **关系定义像导航，外键约束保安全，**
> **一对多放多的方，多对多要中间表，**
> **back_populates 更清晰，selectin 避免 N+1，**
> **级联操作自动删，一对一用 uselist，**
> **自引用要 remote_side，掌握这些就够用。**
