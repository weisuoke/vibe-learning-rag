# 双重类比

## TypeScript/Node.js 类比

### 类比1：Provider = 数据库驱动

**TypeScript/Node.js场景：**
```typescript
// 不同数据库有不同的驱动
import { Pool as PgPool } from 'pg'           // PostgreSQL
import { MongoClient } from 'mongodb'         // MongoDB
import mysql from 'mysql2'                    // MySQL

// 但应用代码希望使用统一接口
interface Database {
  query(sql: string): Promise<any[]>
  close(): Promise<void>
}

// 适配器模式统一接口
class PostgresAdapter implements Database {
  constructor(private pool: PgPool) {}
  async query(sql: string) {
    const result = await this.pool.query(sql)
    return result.rows
  }
  async close() {
    await this.pool.end()
  }
}

class MongoAdapter implements Database {
  constructor(private client: MongoClient) {}
  async query(sql: string) {
    // 转换SQL到MongoDB查询
    const result = await this.client.db().collection('data').find({}).toArray()
    return result
  }
  async close() {
    await this.client.close()
  }
}

// 应用代码不关心具体数据库
async function fetchUsers(db: Database) {
  return await db.query('SELECT * FROM users')
}
```

**Pi-mono场景：**
```typescript
// 不同LLM有不同的API
// OpenAI: chat.completions.create()
// Anthropic: messages.create()
// Ollama: fetch('http://localhost:11434/v1/chat/completions')

// 但Agent代码希望使用统一接口
const stream = await pi.ai.stream(model, context, options)
// 返回统一的AssistantMessageEventStream

// Provider适配器统一接口
pi.registerProvider('ollama', {
  baseUrl: 'http://localhost:11434/v1',
  api: 'openai-completions',  // 使用OpenAI适配器
  models: [...]
})

pi.registerProvider('anthropic', {
  baseUrl: 'https://api.anthropic.com',
  api: 'anthropic-messages',  // 使用Anthropic适配器
  models: [...]
})

// Agent代码不关心具体Provider
const response = await agent.chat('Hello!')
```

**核心相似点：**
- 多种实现（数据库驱动 ↔ LLM Provider）
- 统一接口（Database ↔ AssistantMessageEventStream）
- 适配器模式（PostgresAdapter ↔ Provider适配器）
- 应用解耦（应用代码不依赖具体实现）

### 类比2：Extension = Express中间件

**TypeScript/Node.js场景：**
```typescript
import express from 'express'

const app = express()

// 中间件1：添加自定义请求头
app.use((req, res, next) => {
  req.headers['x-custom-header'] = 'value'
  next()
})

// 中间件2：代理路由
app.use('/api', (req, res, next) => {
  req.url = 'https://proxy.company.com' + req.url
  next()
})

// 中间件3：认证
app.use(async (req, res, next) => {
  const token = await getOAuthToken()
  req.headers['authorization'] = `Bearer ${token}`
  next()
})

// 应用代码不需要关心这些中间件
app.get('/users', (req, res) => {
  // 请求已经被中间件处理过了
  res.json({ users: [] })
})
```

**Pi-mono场景：**
```typescript
// Extension 1：添加自定义请求头
export default function(pi) {
  pi.registerProvider('openai', {
    headers: {
      'X-Custom-Header': 'value'
    }
  })
}

// Extension 2：代理路由
export default function(pi) {
  pi.registerProvider('openai', {
    baseUrl: 'https://proxy.company.com/v1'
  })
}

// Extension 3：OAuth认证
export default function(pi) {
  pi.registerProvider('company-llm', {
    oauth: {
      async login(callbacks) { /* OAuth流程 */ },
      async refreshToken(credentials) { /* 刷新Token */ },
      getApiKey(credentials) { return credentials.access }
    }
  })
}

// Agent代码不需要关心这些Extension
const response = await agent.chat('Hello!')
```

**核心相似点：**
- 插件化（中间件 ↔ Extension）
- 请求拦截（修改req ↔ 修改Provider配置）
- 认证注入（Bearer token ↔ OAuth）
- 透明处理（应用代码无感知）

### 类比3：OAuth = Passport.js策略

**TypeScript/Node.js场景：**
```typescript
import passport from 'passport'
import { Strategy as OAuth2Strategy } from 'passport-oauth2'

// 配置OAuth策略
passport.use('company-sso', new OAuth2Strategy({
  authorizationURL: 'https://sso.company.com/authorize',
  tokenURL: 'https://sso.company.com/token',
  clientID: 'my-app',
  clientSecret: 'secret',
  callbackURL: 'http://localhost:3000/callback'
}, async (accessToken, refreshToken, profile, done) => {
  // 验证成功，保存Token
  const user = { accessToken, refreshToken }
  done(null, user)
}))

// 使用OAuth策略
app.get('/login', passport.authenticate('company-sso'))

app.get('/callback', passport.authenticate('company-sso'), (req, res) => {
  // 登录成功，Token已保存
  res.redirect('/dashboard')
})

// 后续请求自动使用Token
app.get('/api/data', (req, res) => {
  const token = req.user.accessToken
  // 使用Token调用API
})
```

**Pi-mono场景：**
```typescript
// 配置OAuth Provider
pi.registerProvider('company-llm', {
  oauth: {
    name: 'Company AI (SSO)',

    async login(callbacks) {
      // 类似OAuth2Strategy的authorize流程
      callbacks.onDeviceCode({
        userCode: 'ABCD-1234',
        verificationUri: 'https://sso.company.com/device'
      })

      // 等待用户授权，获取Token
      const token = await pollForToken()

      return {
        access: token.access_token,
        refresh: token.refresh_token,
        expires: Date.now() + token.expires_in * 1000
      }
    },

    async refreshToken(credentials) {
      // 类似Passport的token refresh
      const newToken = await refreshAccessToken(credentials.refresh)
      return { ...credentials, access: newToken.access_token }
    },

    getApiKey(credentials) {
      // 类似req.user.accessToken
      return credentials.access
    }
  }
})

// 使用OAuth Provider
// pi会自动调用login()
await pi.login('company-llm')

// 后续请求自动使用Token
const response = await agent.chat('Hello!')
// pi会自动调用getApiKey()获取Token
// 如果Token过期，自动调用refreshToken()
```

**核心相似点：**
- 策略模式（Passport Strategy ↔ OAuth Provider）
- 登录流程（authenticate ↔ login）
- Token管理（session ↔ auth.json）
- 自动刷新（passport-oauth2-refresh ↔ refreshToken）

### 类比4：streamSimple = Axios拦截器

**TypeScript/Node.js场景：**
```typescript
import axios from 'axios'

// 请求拦截器：转换请求格式
axios.interceptors.request.use(config => {
  // 将标准格式转换为API特定格式
  if (config.data?.messages) {
    config.data = {
      prompt: config.data.messages.map(m => m.content).join('\n'),
      max_tokens: config.data.max_tokens
    }
  }
  return config
})

// 响应拦截器：转换响应格式
axios.interceptors.response.use(response => {
  // 将API特定格式转换为标准格式
  if (response.data?.completion) {
    response.data = {
      choices: [{
        message: { content: response.data.completion }
      }]
    }
  }
  return response
})

// 应用代码使用标准格式
const response = await axios.post('/api/chat', {
  messages: [{ role: 'user', content: 'Hello' }],
  max_tokens: 1000
})
```

**Pi-mono场景：**
```typescript
// streamSimple：转换请求和响应格式
function streamMyProvider(model, context, options) {
  const stream = createAssistantMessageEventStream()

  (async () => {
    // 请求拦截：转换为API特定格式
    const apiRequest = {
      prompt: context.messages.map(m => m.content).join('\n'),
      max_tokens: model.maxTokens
    }

    // 调用API
    const response = await fetch(model.baseUrl, {
      method: 'POST',
      body: JSON.stringify(apiRequest)
    })

    // 响应拦截：转换为统一事件格式
    const reader = response.body.getReader()
    while (true) {
      const { done, value } = await reader.read()
      if (done) break

      const chunk = new TextDecoder().decode(value)
      // 转换为统一的text_delta事件
      stream.push({
        type: 'text_delta',
        delta: chunk,
        partial: output
      })
    }

    stream.push({ type: 'done', message: output })
    stream.end()
  })()

  return stream
}

// 注册自定义streamSimple
pi.registerProvider('my-provider', {
  streamSimple: streamMyProvider,
  models: [...]
})
```

**核心相似点：**
- 请求转换（request interceptor ↔ 构建apiRequest）
- 响应转换（response interceptor ↔ 解析stream events）
- 格式统一（标准axios格式 ↔ AssistantMessageEventStream）
- 透明处理（应用代码无感知）

## 日常生活类比

### 类比1：Provider = 不同品牌的插座

**日常生活场景：**
- 中国插座：220V，三孔扁插
- 美国插座：110V，两孔扁插
- 欧洲插座：220V，两孔圆插
- 英国插座：230V，三孔方插

**问题：**
你的手机充电器（应用）需要在不同国家使用，但插座（Provider）都不一样。

**解决方案：**
使用万能转换器（Adapter）：
- 输入：各种插座格式
- 输出：统一的USB接口
- 你的充电器只需要USB接口，不关心插座类型

**Pi-mono对应：**
- 手机充电器 = Agent代码
- 插座 = LLM Provider（OpenAI、Anthropic、Ollama）
- 万能转换器 = Provider适配器
- USB接口 = AssistantMessageEventStream

### 类比2：OAuth = 酒店房卡系统

**日常生活场景：**

**传统钥匙（API Key）：**
- 一把钥匙永久有效
- 丢失后需要换锁
- 无法追踪使用记录

**房卡系统（OAuth）：**
1. **登记入住（login）：**
   - 前台验证身份
   - 给你一张房卡（access token）
   - 房卡有有效期（expires）
   - 前台保留主卡（refresh token）

2. **使用房卡（getApiKey）：**
   - 刷卡进入房间
   - 系统验证房卡有效性
   - 记录使用时间

3. **续期（refreshToken）：**
   - 房卡快过期时
   - 前台用主卡给你换新房卡
   - 无需重新验证身份

4. **退房（logout）：**
   - 房卡失效
   - 主卡也失效

**Pi-mono对应：**
- 前台 = OAuth服务器
- 房卡 = access token
- 主卡 = refresh token
- 刷卡 = getApiKey()
- 换卡 = refreshToken()

### 类比3：Extension = 浏览器扩展

**日常生活场景：**

**原始浏览器：**
- 只能浏览网页
- 功能固定

**安装扩展后：**
- 广告拦截器：自动拦截广告
- 翻译插件：自动翻译页面
- 密码管理器：自动填充密码
- 代理插件：自动切换代理

**特点：**
- 无需修改浏览器源码
- 扩展之间互不影响
- 可以随时启用/禁用
- 用户可以自己开发扩展

**Pi-mono对应：**
- 浏览器 = pi-coding-agent
- 扩展 = Extension
- 广告拦截器 = 代理路由Extension
- 翻译插件 = 自定义Provider Extension
- 密码管理器 = OAuth Extension

### 类比4：models.json = 通讯录

**日常生活场景：**

**通讯录：**
```
张三
  手机：138-1234-5678
  公司：ABC公司
  地址：北京市朝阳区

李四
  手机：139-8765-4321
  公司：XYZ公司
  地址：上海市浦东新区
```

**使用：**
- 想打电话给张三 → 查通讯录 → 拨打138-1234-5678
- 想打电话给李四 → 查通讯录 → 拨打139-8765-4321

**Pi-mono对应：**
```json
{
  "providers": [
    {
      "id": "ollama",
      "baseUrl": "http://localhost:11434/v1"
    }
  ],
  "models": [
    {
      "id": "ollama/llama3.2",
      "name": "Llama 3.2",
      "providerId": "ollama"
    }
  ]
}
```

**使用：**
- 想用Llama 3.2 → 查models.json → 连接http://localhost:11434/v1
- 想用GPT-4 → 查models.json → 连接https://api.openai.com/v1

**核心相似点：**
- 通讯录 = models.json
- 联系人 = Model
- 电话号码 = baseUrl
- 拨打电话 = 调用LLM API

## 类比总结表

| Pi-mono概念 | TypeScript/Node.js类比 | 日常生活类比 | 核心相似点 |
|------------|----------------------|------------|----------|
| Provider | 数据库驱动 | 不同品牌的插座 | 多种实现，统一接口 |
| Extension | Express中间件 | 浏览器扩展 | 插件化，透明处理 |
| OAuth | Passport.js策略 | 酒店房卡系统 | 认证流程，Token管理 |
| streamSimple | Axios拦截器 | 万能转换器 | 格式转换，统一输出 |
| models.json | 配置文件 | 通讯录 | 声明式配置，查找映射 |
| registerProvider | 注册中间件 | 安装扩展 | 动态注册，运行时生效 |
| AssistantMessageEventStream | 统一接口 | USB接口 | 标准化输出，解耦实现 |
