# 类型系统与泛型 - 化骨绵掌

## 10 个 2 分钟知识卡片

每个卡片独立完整，2 分钟内可看完，形成递进关系。

---

## 卡片 1：类型注解直觉理解

**一句话**：类型注解是给变量"贴标签"，让类型检查器在编译时验证操作是否合法。

**举例**：
```python
# 无标签：不知道是什么
x = get_value()
x.upper()  # 可能报错

# 有标签：明确是 str
x: str = get_value()
x.upper()  # 类型检查器验证 str 有 upper 方法
```

**应用**：在 LangChain 中，每个 Runnable 都有明确的输入输出类型，让组件组合更安全。

---

## 卡片 2：TypeVar 形式化定义

**一句话**：TypeVar 是类型的占位符，在使用时被具体类型替换，保留类型信息。

**举例**：
```python
from typing import TypeVar

T = TypeVar('T')

def identity(x: T) -> T:
    return x

# 使用时 T 被替换
result = identity(42)  # T = int
result = identity("hello")  # T = str
```

**应用**：LangChain 的 Runnable[Input, Output] 使用 TypeVar 定义输入输出类型。

---

## 卡片 3：Generic 类实现

**一句话**：Generic 让类可以接受类型参数，创建类型安全的容器。

**举例**：
```python
from typing import TypeVar, Generic

T = TypeVar('T')

class Box(Generic[T]):
    def __init__(self, value: T):
        self.value = value

    def get(self) -> T:
        return self.value

# 使用
int_box: Box[int] = Box(42)
value: int = int_box.get()  # 类型安全
```

**应用**：自定义 Runnable 时继承 Runnable[Input, Output]。

---

## 卡片 4：Protocol 结构类型

**一句话**：Protocol 定义"有什么方法"而非"是什么类"，不需要显式继承。

**举例**：
```python
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> None:
        ...

# 不需要继承 Drawable
class Circle:
    def draw(self) -> None:
        print("Drawing circle")

# 满足 Protocol
def render(obj: Drawable) -> None:
    obj.draw()

render(Circle())  # ✅
```

**应用**：LangChain 的 Runnable 实际上是 Protocol，让第三方组件无缝集成。

---

## 卡片 5：Runnable 泛型设计

**一句话**：Runnable[Input, Output] 通过泛型定义组件的输入输出类型，让 LCEL 管道类型安全。

**举例**：
```python
from langchain_core.runnables import RunnableLambda

def to_upper(text: str) -> str:
    return text.upper()

def count_words(text: str) -> int:
    return len(text.split())

# 类型自动推断
upper: Runnable[str, str] = RunnableLambda(to_upper)
counter: Runnable[str, int] = RunnableLambda(count_words)

# 组合：类型检查器验证
chain: Runnable[str, int] = upper | counter  # ✅
```

**应用**：构建类型安全的 RAG 管道，在编译时发现组合错误。

---

## 卡片 6：Callable 函数类型

**一句话**：Callable[[参数类型...], 返回类型] 定义函数签名，ParamSpec 保留完整签名。

**举例**：
```python
from typing import Callable, ParamSpec, TypeVar

P = ParamSpec('P')
T = TypeVar('T')

def decorator(func: Callable[P, T]) -> Callable[P, T]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@decorator
def add(a: int, b: int) -> int:
    return a + b

# 类型安全
result: int = add(5, 3)  # ✅
```

**应用**：RunnableLambda 接受 Callable，保留函数签名。

---

## 卡片 7：TypedDict 结构字典

**一句话**：TypedDict 定义字典的结构，让字典类型安全。

**举例**：
```python
from typing import TypedDict, Literal, NotRequired

Environment = Literal["dev", "staging", "prod"]

class Config(TypedDict):
    environment: Environment
    debug: bool
    api_key: NotRequired[str]  # 可选

# 使用
config: Config = {
    "environment": "dev",
    "debug": True
}  # ✅
```

**应用**：LangGraph 状态类型，Runnable 配置对象。

---

## 卡片 8：TypeGuard 类型守卫

**一句话**：TypeGuard 通过运行时检查收窄类型范围，让类型检查器知道精确类型。

**举例**：
```python
from typing import TypeGuard

def is_str_list(val: list) -> TypeGuard[list[str]]:
    return all(isinstance(x, str) for x in val)

def process(items: list) -> None:
    if is_str_list(items):
        # 类型检查器知道 items 是 list[str]
        for item in items:
            print(item.upper())  # ✅
```

**应用**：验证 LangChain 消息类型，检查配置有效性。

---

## 卡片 9：mypy vs pyright

**一句话**：mypy 是官方类型检查器，pyright 更快（3-5倍）且错误提示更好。

**举例**：
```bash
# mypy 检查
mypy src/
# 输出：example.py:5: error: Argument 1 to "add" has incompatible type "str"; expected "int"

# pyright 检查（更快）
pyright src/
# 输出：example.py:5:14 - error: Argument of type "Literal['hello']" cannot be assigned to parameter "a" of type "int"
```

**应用**：在 CI/CD 中同时运行两个检查器，互补提高代码质量。

---

## 卡片 10：生产环境最佳实践

**一句话**：渐进式采用类型系统，从公共 API 开始，逐步提高严格程度。

**举例**：
```python
# 第一阶段：给公共 API 加类型注解
def public_api(input: str) -> dict:
    result = _internal_helper(input)  # 内部函数暂时不加
    return result

# 第二阶段：配置 mypy 基础检查
# mypy.ini
[mypy]
warn_return_any = True

# 第三阶段：逐步提高严格程度
# disallow_untyped_defs = True

# 第四阶段：启用严格模式
# strict = True
```

**应用**：
- LangChain 项目：优先给 Runnable 组件加类型注解
- RAG 管道：确保检索器和 LLM 的类型兼容
- 团队协作：通过类型注解提高代码可读性

---

## 知识卡片总结

### 学习路径

```
1. 类型注解直觉理解（是什么）
   ↓
2. TypeVar 形式化定义（类型变量）
   ↓
3. Generic 类实现（泛型类）
   ↓
4. Protocol 结构类型（接口定义）
   ↓
5. Runnable 泛型设计（LangChain 应用）
   ↓
6. Callable 函数类型（函数签名）
   ↓
7. TypedDict 结构字典（结构化数据）
   ↓
8. TypeGuard 类型守卫（类型收窄）
   ↓
9. mypy vs pyright（工具使用）
   ↓
10. 生产环境最佳实践（实际应用）
```

### 核心概念关系图

```
类型系统
├── 基础类型注解（卡片1）
├── 泛型系统
│   ├── TypeVar（卡片2）
│   ├── Generic（卡片3）
│   └── Protocol（卡片4）
├── LangChain 应用
│   ├── Runnable[Input, Output]（卡片5）
│   ├── Callable（卡片6）
│   └── TypedDict（卡片7）
├── 高级特性
│   └── TypeGuard（卡片8）
└── 工具和实践
    ├── mypy/pyright（卡片9）
    └── 最佳实践（卡片10）
```

### 快速复习清单

**5 分钟快速复习**：
- [ ] 卡片1：类型注解 = 贴标签
- [ ] 卡片2：TypeVar = 类型占位符
- [ ] 卡片5：Runnable[Input, Output] = 类型安全组合
- [ ] 卡片9：mypy vs pyright
- [ ] 卡片10：渐进式采用

**15 分钟深度复习**：
- [ ] 所有 10 个卡片
- [ ] 每个卡片的代码示例
- [ ] LangChain 应用场景

**30 分钟完整复习**：
- [ ] 所有 10 个卡片
- [ ] 核心概念系列文档
- [ ] 实战代码示例
- [ ] 面试必问问题

---

## 实战练习

### 练习 1：类型注解基础（5 分钟）

给以下函数添加类型注解：

```python
def process_data(data, multiplier):
    result = []
    for item in data:
        result.append(item * multiplier)
    return result
```

**答案**：
```python
def process_data(data: list[int], multiplier: int) -> list[int]:
    result: list[int] = []
    for item in data:
        result.append(item * multiplier)
    return result
```

### 练习 2：泛型函数（10 分钟）

创建一个泛型函数，对列表中的每个元素应用函数：

**答案**：
```python
from typing import TypeVar, Callable

T = TypeVar('T')
U = TypeVar('U')

def map_list(items: list[T], fn: Callable[[T], U]) -> list[U]:
    return [fn(item) for item in items]

# 使用
numbers = [1, 2, 3]
strings = map_list(numbers, str)  # list[int] -> list[str]
```

### 练习 3：自定义 Runnable（15 分钟）

创建一个类型安全的自定义 Runnable：

**答案**：
```python
from langchain_core.runnables import Runnable
from typing import Any

class UppercaseRunnable(Runnable[str, str]):
    def invoke(self, input: str, config: Any = None) -> str:
        return input.upper()

# 使用
runnable: Runnable[str, str] = UppercaseRunnable()
result: str = runnable.invoke("hello")  # "HELLO"
```

---

## 学习检查清单

- [ ] 理解所有 10 个知识卡片
- [ ] 能够解释每个概念
- [ ] 完成所有实战练习
- [ ] 能够在项目中应用
- [ ] 准备好面试问题

---

## 下一步学习

- **概览** - 查看完整学习路径
- **核心概念系列** - 深入学习具体特性
- **实战代码系列** - 应用到实际项目

---

## 总结

**10 个卡片覆盖**：
1. ✅ 类型注解基础
2. ✅ TypeVar 和 Generic
3. ✅ Protocol 和 Runnable
4. ✅ 高级类型特性
5. ✅ 工具和最佳实践

**学习策略**：
- 快速复习：5 分钟看 5 个核心卡片
- 深度复习：15 分钟看所有卡片
- 完整复习：30 分钟看卡片 + 文档

**记住**：类型系统是工具，不是目的。从简单开始，逐步深入，关注实际价值。
