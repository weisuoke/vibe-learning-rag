# 化骨绵掌

> **10 张知识卡片，每张 2 分钟速记**

化骨绵掌是一种快速记忆法，将复杂知识浓缩为 10 张卡片，每张卡片 2 分钟即可掌握核心要点。

---

## 卡片 1：工具注册的本质（2分钟）

### 核心问题
**LLM 如何与外部世界交互？**

### 答案
通过"工具"（Tool）—— 一种标准化的接口，让 LLM 能够调用外部能力。

### 类比
- **LLM** = 大脑（只能思考）
- **工具** = 手脚（可以行动）
- **工具注册** = 告诉大脑"你有哪些手脚可用"

### 关键代码
```typescript
// 注册工具 = 告诉 LLM "你可以读文件"
context.registerTool({
  name: 'read_file',
  description: 'Read file content',
  parameters: Type.Object({ path: Type.String() }),
  execute: async ({ path }) => {
    return { content: await fs.readFile(path, 'utf-8') };
  }
});
```

### 记忆口诀
**"注册工具 = 扩展 LLM 能力"**

---

## 卡片 2：Tool Definition 接口（2分钟）

### 四个必需字段

| 字段 | 作用 | 给谁看 |
|------|------|--------|
| **name** | 工具标识 | LLM + 框架 |
| **description** | 工具描述 | LLM |
| **parameters** | 参数定义 | LLM |
| **execute** | 执行逻辑 | 框架 |

### 完整示例
```typescript
const weatherTool = {
  name: 'get_weather',              // 唯一标识
  description: 'Get weather',       // LLM 理解用途
  parameters: Type.Object({         // LLM 知道如何调用
    city: Type.String()
  }),
  execute: async ({ city }) => {    // 框架执行逻辑
    return { content: await fetchWeather(city) };
  }
};
```

### 记忆技巧
**"name + description + parameters + execute = 完整工具"**

### 常见错误
- ❌ 缺少 description（LLM 不知道何时调用）
- ❌ parameters 没有 description（LLM 不知道如何传参）
- ❌ execute 不是 async（框架要求）

---

## 卡片 3：TypeBox Schema 基础（2分钟）

### 为什么用 TypeBox？
1. **LLM 友好**：生成标准 JSON Schema
2. **类型安全**：TypeScript 类型推导
3. **运行时验证**：自动参数校验

### 常用类型速查

```typescript
// 基础类型
Type.String()                    // 字符串
Type.Number()                    // 数字
Type.Boolean()                   // 布尔值

// 约束
Type.String({ minLength: 1 })   // 非空字符串
Type.Number({ minimum: 0 })     // 非负数

// 可选
Type.Optional(Type.String())    // 可选字符串

// 枚举
Type.Union([
  Type.Literal('red'),
  Type.Literal('blue')
])

// 数组
Type.Array(Type.String())       // 字符串数组

// 对象
Type.Object({
  name: Type.String(),
  age: Type.Number()
})
```

### 记忆口诀
**"Type.类型({ 约束 })"**

### 最佳实践
- ✅ 每个字段都要有 description
- ✅ 使用约束（minimum, maximum, pattern）
- ✅ 可选字段用 Type.Optional()

---

## 卡片 4：execute 函数签名（2分钟）

### 函数签名
```typescript
type ExecuteFunction = (
  params: any,                    // 已验证的参数
  context: ExtensionContext       // 执行上下文
) => Promise<AgentToolResult>;    // 返回结果
```

### 三个关键点

**1. 必须是 async**
```typescript
// ✅ 正确
const execute = async (params, context) => { /* ... */ };

// ❌ 错误
const execute = (params, context) => { /* ... */ };
```

**2. 参数已验证**
```typescript
// TypeBox 已经验证过参数，可以直接使用
const execute = async ({ age }) => {
  // age 一定是 number，不需要再验证
  return { content: `Age: ${age}` };
};
```

**3. 返回 AgentToolResult**
```typescript
return {
  content: 'Result text',        // 必需
  metadata: { /* ... */ }         // 可选
};
```

### 记忆口诀
**"async + 已验证参数 + 返回 content"**

---

## 卡片 5：AgentToolResult 结构（2分钟）

### 结构定义
```typescript
interface AgentToolResult {
  content: string;           // 主要内容（必需）
  metadata?: {               // 元数据（可选）
    [key: string]: any;
  };
}
```

### 使用场景

**1. 简单结果**
```typescript
return { content: 'Hello, World!' };
```

**2. 带元数据**
```typescript
return {
  content: 'File content: ...',
  metadata: {
    fileSize: 1024,
    timestamp: new Date().toISOString()
  }
};
```

**3. 错误信息**
```typescript
return {
  content: 'Error: File not found',
  metadata: { error: true }
};
```

**4. 结构化数据**
```typescript
return {
  content: JSON.stringify(data),
  metadata: { count: data.length }
};
```

### 记忆技巧
**"content 是给 LLM 看的，metadata 是给程序用的"**

---

## 卡片 6：registerTool API（2分钟）

### API 签名
```typescript
function registerTool(
  context: ExtensionContext,
  tool: ToolDefinition
): void
```

### 使用位置
**在 Extension 的 activate 函数中**

```typescript
export const myExtension: Extension = {
  name: 'my-extension',
  version: '1.0.0',
  
  async activate(context) {
    // ✅ 在这里注册工具
    context.registerTool({
      name: 'my_tool',
      description: 'My tool',
      parameters: Type.Object({ /* ... */ }),
      execute: async (params) => { /* ... */ }
    });
    
    context.logger.info('Tool registered');
  }
};
```

### 注册时机

```
Extension 生命周期：
1. 加载 Extension
2. 调用 activate 函数  ← 在这里注册工具
3. Extension 激活完成
4. 工具可用（下次 LLM 调用时）
```

### 常见问题

**Q: 工具注册后为什么不立即可用？**
A: 需要等待所有 Extension 加载完成，然后在下次 LLM 调用时发送工具列表。

**Q: 新添加的 Extension 如何生效？**
A: 执行 `/reload` 重新加载 Extension。

### 记忆口诀
**"activate 中注册，/reload 后生效"**

---

## 卡片 7：自定义渲染（2分钟）

### 两个渲染函数

| 函数 | 触发时机 | 作用 |
|------|---------|------|
| **renderCall** | 工具调用前 | 显示"正在使用工具" |
| **renderResult** | 工具调用后 | 显示"工具返回结果" |

### 基本用法

```typescript
const tool = {
  name: 'search',
  description: 'Search files',
  parameters: Type.Object({
    query: Type.String()
  }),
  execute: async ({ query }) => {
    return { content: 'Results...' };
  },
  
  // 自定义调用显示
  renderCall: (params) => {
    return `🔍 Searching for: ${params.query}`;
  },
  
  // 自定义结果显示
  renderResult: (result) => {
    return `✅ Found results:\n${result.content}`;
  }
};
```

### 使用 pi-tui 组件

```typescript
import { Box, Text } from '@pi-mono/pi-tui';

renderResult: (result) => {
  return (
    <Box flexDirection="column">
      <Text color="green">✓ Success</Text>
      <Text>{result.content}</Text>
    </Box>
  );
}
```

### 记忆技巧
**"renderCall = 调用前，renderResult = 调用后"**

---

## 卡片 8：事件系统（2分钟）

### 两个核心事件

| 事件 | 触发时机 | 用途 |
|------|---------|------|
| **tool_call** | 工具调用前 | 记录日志、修改参数 |
| **tool_result** | 工具调用后 | 记录日志、修改结果 |

### 监听事件

```typescript
export const myExtension: Extension = {
  async activate(context) {
    // 监听工具调用
    context.on('tool_call', (event) => {
      context.logger.info('Tool called:', event.tool.name);
      context.logger.info('Parameters:', event.params);
    });
    
    // 监听工具结果
    context.on('tool_result', (event) => {
      context.logger.info('Tool result:', event.result);
    });
  }
};
```

### 实战应用

**1. 性能监控**
```typescript
context.on('tool_call', (event) => {
  event.context.session.set('startTime', Date.now());
});

context.on('tool_result', (event) => {
  const startTime = event.context.session.get('startTime');
  const duration = Date.now() - startTime;
  console.log(`Tool ${event.tool.name} took ${duration}ms`);
});
```

**2. 错误追踪**
```typescript
context.on('tool_result', (event) => {
  if (event.result.metadata?.error) {
    context.logger.error('Tool failed:', event.tool.name);
  }
});
```

### 记忆口诀
**"tool_call 前，tool_result 后"**

---

## 卡片 9：错误处理（2分钟）

### 三层错误处理

**1. Schema 验证错误（自动）**
```typescript
// TypeBox 自动验证，无需手动处理
parameters: Type.Object({
  age: Type.Number({ minimum: 0, maximum: 120 })
})
// LLM 传入 age: 200 → 自动验证失败
```

**2. 业务逻辑错误（手动）**
```typescript
const execute = async ({ userId }, context) => {
  try {
    const user = await db.findUser(userId);
    if (!user) {
      return { content: 'Error: User not found' };
    }
    return { content: JSON.stringify(user) };
  } catch (error) {
    context.logger.error('Database error:', error);
    return { content: `Error: ${error.message}` };
  }
};
```

**3. 取消操作（AbortSignal）**
```typescript
const execute = async (params, context) => {
  const { signal } = context;
  
  try {
    const data = await fetch(url, { signal });
    
    if (signal.aborted) {
      return { content: 'Operation cancelled' };
    }
    
    return { content: data };
  } catch (error) {
    if (error.name === 'AbortError') {
      return { content: 'Cancelled by user' };
    }
    return { content: `Error: ${error.message}` };
  }
};
```

### 最佳实践

```typescript
// ✅ 友好的错误信息
return { content: 'Error: File not found. Please check the path.' };

// ❌ 不友好的错误信息
return { content: 'Error: ENOENT' };
```

### 记忆口诀
**"Schema 自动验证，业务手动处理，取消检查 signal"**

---

## 卡片 10：实战最佳实践（2分钟）

### 10 条黄金法则

**1. 工具命名**
```typescript
// ✅ 使用 kebab-case
name: 'get-weather'

// ❌ 使用 camelCase
name: 'getWeather'
```

**2. 描述清晰**
```typescript
// ✅ 清晰描述用途
description: 'Get current weather for a city'

// ❌ 描述不清
description: 'Weather'
```

**3. 参数描述**
```typescript
// ✅ 每个参数都有描述
Type.Object({
  city: Type.String({ description: 'City name' })
})

// ❌ 缺少描述
Type.Object({
  city: Type.String()
})
```

**4. 使用约束**
```typescript
// ✅ 充分利用约束
Type.Number({ minimum: 1, maximum: 100 })

// ❌ 缺少约束
Type.Number()
```

**5. 错误处理**
```typescript
// ✅ 使用 try-catch
try {
  const result = await operation();
  return { content: result };
} catch (error) {
  return { content: `Error: ${error.message}` };
}
```

**6. 记录日志**
```typescript
// ✅ 记录关键信息
context.logger.info('Tool called with params:', params);
context.logger.error('Operation failed:', error);
```

**7. 状态管理**
```typescript
// ✅ 使用 session 存储状态
context.session.set('key', value);
const value = context.session.get('key');
```

**8. 支持取消**
```typescript
// ✅ 检查 AbortSignal
if (context.signal.aborted) {
  return { content: 'Cancelled' };
}
```

**9. 进度反馈**
```typescript
// ✅ 使用 onUpdate
context.onUpdate?.({ content: 'Processing 50%...' });
```

**10. 输出截断**
```typescript
// ✅ 截断大输出
if (output.length > MAX_SIZE) {
  const truncated = output.substring(0, MAX_SIZE);
  await fs.writeFile(filePath, output);
  return { 
    content: truncated + `\n[Truncated. Full: ${filePath}]` 
  };
}
```

### 记忆口诀
**"清晰命名 + 充分约束 + 错误处理 + 日志记录 + 用户体验"**

---

## 快速复习：10 张卡片总结

| 卡片 | 核心内容 | 记忆口诀 |
|------|---------|---------|
| 1 | 工具注册的本质 | 注册工具 = 扩展 LLM 能力 |
| 2 | Tool Definition 接口 | name + description + parameters + execute |
| 3 | TypeBox Schema 基础 | Type.类型({ 约束 }) |
| 4 | execute 函数签名 | async + 已验证参数 + 返回 content |
| 5 | AgentToolResult 结构 | content 给 LLM，metadata 给程序 |
| 6 | registerTool API | activate 中注册，/reload 后生效 |
| 7 | 自定义渲染 | renderCall 调用前，renderResult 调用后 |
| 8 | 事件系统 | tool_call 前，tool_result 后 |
| 9 | 错误处理 | Schema 自动，业务手动，取消检查 signal |
| 10 | 实战最佳实践 | 清晰命名 + 充分约束 + 错误处理 + 日志 + 体验 |

---

## 20 分钟速成计划

**第 1-2 分钟**：卡片 1 - 理解工具注册的本质
**第 3-4 分钟**：卡片 2 - 掌握 Tool Definition 接口
**第 5-6 分钟**：卡片 3 - 学习 TypeBox Schema 基础
**第 7-8 分钟**：卡片 4 - 理解 execute 函数签名
**第 9-10 分钟**：卡片 5 - 掌握 AgentToolResult 结构
**第 11-12 分钟**：卡片 6 - 学习 registerTool API
**第 13-14 分钟**：卡片 7 - 理解自定义渲染
**第 15-16 分钟**：卡片 8 - 掌握事件系统
**第 17-18 分钟**：卡片 9 - 学习错误处理
**第 19-20 分钟**：卡片 10 - 掌握实战最佳实践

---

## 实战演练：5 分钟写一个工具

**目标：写一个简单的计算器工具**

```typescript
export const calculatorExtension: Extension = {
  name: 'calculator',
  version: '1.0.0',
  
  async activate(context) {
    context.registerTool({
      // 卡片 2: Tool Definition
      name: 'calculate',
      description: 'Perform basic arithmetic operations',
      
      // 卡片 3: TypeBox Schema
      parameters: Type.Object({
        operation: Type.Union([
          Type.Literal('add'),
          Type.Literal('subtract'),
          Type.Literal('multiply'),
          Type.Literal('divide')
        ], { description: 'Operation type' }),
        a: Type.Number({ description: 'First number' }),
        b: Type.Number({ description: 'Second number' })
      }),
      
      // 卡片 4: execute 函数
      execute: async ({ operation, a, b }, context) => {
        // 卡片 9: 错误处理
        try {
          let result: number;
          
          switch (operation) {
            case 'add':
              result = a + b;
              break;
            case 'subtract':
              result = a - b;
              break;
            case 'multiply':
              result = a * b;
              break;
            case 'divide':
              if (b === 0) {
                return { content: 'Error: Division by zero' };
              }
              result = a / b;
              break;
          }
          
          // 卡片 10: 记录日志
          context.logger.info(`Calculated: ${a} ${operation} ${b} = ${result}`);
          
          // 卡片 5: AgentToolResult
          return {
            content: `Result: ${result}`,
            metadata: { operation, a, b, result }
          };
        } catch (error) {
          return { content: `Error: ${error.message}` };
        }
      },
      
      // 卡片 7: 自定义渲染
      renderCall: (params) => {
        return `🧮 Calculating: ${params.a} ${params.operation} ${params.b}`;
      },
      
      renderResult: (result) => {
        return `✅ ${result.content}`;
      }
    });
    
    // 卡片 6: 注册完成
    context.logger.info('Calculator tool registered');
  }
};
```

**使用方式：**
```
用户: 计算 123 + 456
AI: [调用 calculate 工具]
结果: Result: 579
```

---

## 记忆检查清单

完成 20 分钟学习后，检查是否掌握：

- [ ] 能解释工具注册的本质
- [ ] 能写出 Tool Definition 的四个字段
- [ ] 能使用 TypeBox 定义常见类型
- [ ] 能写出 execute 函数的签名
- [ ] 能构造 AgentToolResult
- [ ] 知道在哪里调用 registerTool
- [ ] 能实现 renderCall 和 renderResult
- [ ] 能监听 tool_call 和 tool_result 事件
- [ ] 能处理三层错误（Schema、业务、取消）
- [ ] 能应用 10 条最佳实践

---

## 下一步

掌握了化骨绵掌的 10 张卡片后，你可以：

1. **深入学习**：阅读其他维度的文档（第一性原理、核心概念等）
2. **实战练习**：参考实战代码示例，动手写工具
3. **阅读源码**：查看 pi-mono 的工具实现源码
4. **扩展创新**：设计自己的工具，扩展 AI Agent 能力

---

## 总结

**化骨绵掌 = 10 张卡片 × 2 分钟 = 20 分钟速成**

通过这 10 张卡片，你已经掌握了自定义工具注册的核心知识：
1. 工具注册的本质
2. Tool Definition 接口
3. TypeBox Schema 基础
4. execute 函数签名
5. AgentToolResult 结构
6. registerTool API
7. 自定义渲染
8. 事件系统
9. 错误处理
10. 实战最佳实践

现在，你可以开始注册自己的工具，扩展 AI Agent 的能力了！
