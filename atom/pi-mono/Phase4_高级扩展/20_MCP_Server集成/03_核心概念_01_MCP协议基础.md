# 核心概念 01：MCP 协议基础

> **深入理解 MCP 协议的核心规范、JSON-RPC 2.0 基础和消息类型**

---

## 协议概述

### MCP 是什么

Model Context Protocol (MCP) 是一个开放标准协议，专为 AI Agent 与外部工具和数据源的集成而设计。MCP 由 Anthropic 在 2024 年 11 月推出，并在 2025 年快速成为 AI 工具集成的事实标准。

**核心定位**：
```
MCP = AI 领域的 USB-C 标准
├─ 统一接口：所有 AI 平台和工具都遵循同一协议
├─ 动态发现：运行时查询可用工具和资源
├─ 语义清晰：详细的描述和 Schema 供 AI 理解
└─ 开放生态：促进工具的跨平台复用
```

[Source: Overview - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic)

### 协议版本

**当前最新版本**：2025-11-25

MCP 协议采用日期版本号格式（YYYY-MM-DD），确保版本的时间顺序清晰。主要版本包括：

| 版本 | 发布时间 | 主要变化 |
|------|---------|---------|
| 2024-11-05 | 2024年11月 | 初始版本发布 |
| 2025-03-26 | 2025年3月 | 增强能力协商机制 |
| 2025-11-25 | 2025年11月 | 当前最新版本，完善生命周期管理 |

**版本兼容性**：
- 客户端和服务器在初始化时协商协议版本
- 不兼容的版本会导致连接失败
- 建议始终使用最新版本以获得最佳功能

---

## JSON-RPC 2.0 基础

### 为什么选择 JSON-RPC 2.0？

MCP 基于 [JSON-RPC 2.0](https://www.jsonrpc.org/specification) 规范构建，这不是偶然的选择：

**技术优势**：

1. **简单性**：100% JSON 格式，易于实现和调试
2. **成熟性**：经过 LSP（Language Server Protocol）等项目的验证
3. **完整性**：支持请求/响应、通知、错误处理
4. **类型安全**：强类型方法定义
5. **广泛支持**：几乎所有编程语言都有实现

**与 LSP 的相似性**：

MCP 的设计深受 LSP 启发，两者都使用 JSON-RPC 2.0 作为通信协议：

```
LSP（Language Server Protocol）
├─ 目标：统一编辑器与语言服务器的通信
├─ 协议：JSON-RPC 2.0
└─ 成功案例：VS Code、Vim、Emacs 等

MCP（Model Context Protocol）
├─ 目标：统一 AI Agent 与工具的通信
├─ 协议：JSON-RPC 2.0
└─ 应用场景：Claude、ChatGPT、Cursor 等
```

[Source: Overview - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic)

### JSON-RPC 2.0 核心概念

**基本结构**：

所有 JSON-RPC 2.0 消息都包含以下字段：

```json
{
  "jsonrpc": "2.0"  // 必需：协议版本标识
}
```

**三种消息类型**：

1. **Request（请求）**：需要响应的消息
2. **Response（响应）**：对请求的回复
3. **Notification（通知）**：不需要响应的单向消息

---

## 消息类型详解

### 1. Request（请求）

**定义**：请求是从客户端发送到服务器（或反向）的消息，用于启动一个操作。

**消息结构**：

```json
{
  "jsonrpc": "2.0",
  "id": string | number,
  "method": string,
  "params?": {
    [key: string]: unknown
  }
}
```

**字段说明**：

| 字段 | 类型 | 必需 | 说明 |
|------|------|------|------|
| `jsonrpc` | string | ✅ | 必须是 "2.0" |
| `id` | string \| number | ✅ | 请求标识符，用于匹配响应 |
| `method` | string | ✅ | 要调用的方法名称 |
| `params` | object | ❌ | 方法参数（可选） |

**MCP 特殊要求**：

根据 MCP 规范，请求有以下额外要求：

- ✅ 请求**必须**包含字符串或整数 ID
- ❌ 与基础 JSON-RPC 不同，ID **不能**为 null
- ✅ 请求 ID 在同一会话中**不能**重复使用

[Source: Overview - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic)

**示例**：

```json
// 调用工具的请求
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "search_users",
    "arguments": {
      "query": "john"
    }
  }
}

// 列出资源的请求
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/list",
  "params": {}
}
```

### 2. Response（响应）

响应是对请求的回复，包含操作的结果或错误信息。

#### 2.1 Result Response（成功响应）

**定义**：当操作成功完成时发送的响应。

**消息结构**：

```json
{
  "jsonrpc": "2.0",
  "id": string | number,
  "result": {
    [key: string]: unknown
  }
}
```

**字段说明**：

| 字段 | 类型 | 必需 | 说明 |
|------|------|------|------|
| `jsonrpc` | string | ✅ | 必须是 "2.0" |
| `id` | string \| number | ✅ | 必须与请求的 ID 相同 |
| `result` | object | ✅ | 操作结果 |

**MCP 要求**：

- ✅ 结果响应**必须**包含与请求相同的 ID
- ✅ 结果响应**必须**包含 result 字段
- ✅ result **可以**是任何 JSON 对象结构

[Source: Overview - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic)

**示例**：

```json
// 工具调用的成功响应
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Found 2 users: John Doe, John Smith"
      }
    ]
  }
}

// 列出资源的成功响应
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "resources": [
      {
        "uri": "file:///data/users.json",
        "name": "users.json",
        "mimeType": "application/json"
      }
    ]
  }
}
```

#### 2.2 Error Response（错误响应）

**定义**：当操作失败或遇到错误时发送的响应。

**消息结构**：

```json
{
  "jsonrpc": "2.0",
  "id?": string | number,
  "error": {
    "code": number,
    "message": string,
    "data?": unknown
  }
}
```

**字段说明**：

| 字段 | 类型 | 必需 | 说明 |
|------|------|------|------|
| `jsonrpc` | string | ✅ | 必须是 "2.0" |
| `id` | string \| number | ⚠️ | 通常与请求相同，除非请求格式错误 |
| `error` | object | ✅ | 错误信息 |
| `error.code` | number | ✅ | 错误代码（整数） |
| `error.message` | string | ✅ | 错误描述 |
| `error.data` | any | ❌ | 额外的错误信息（可选） |

**标准错误代码**：

JSON-RPC 2.0 定义了标准错误代码：

| 代码 | 含义 | 说明 |
|------|------|------|
| -32700 | Parse error | 解析 JSON 失败 |
| -32600 | Invalid Request | 请求格式无效 |
| -32601 | Method not found | 方法不存在 |
| -32602 | Invalid params | 参数无效 |
| -32603 | Internal error | 服务器内部错误 |

**MCP 要求**：

- ✅ 错误响应**必须**包含与请求相同的 ID（除非无法读取 ID）
- ✅ 错误响应**必须**包含 error 字段，包含 code 和 message
- ✅ 错误代码**必须**是整数

[Source: Overview - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic)

**示例**：

```json
// 方法不存在的错误
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Method not found",
    "data": {
      "method": "unknown_method"
    }
  }
}

// 参数无效的错误
{
  "jsonrpc": "2.0",
  "id": 2,
  "error": {
    "code": -32602,
    "message": "Invalid params",
    "data": {
      "expected": "string",
      "received": "number"
    }
  }
}

// 协议版本不匹配的错误
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Unsupported protocol version",
    "data": {
      "supported": ["2025-11-25"],
      "requested": "1.0.0"
    }
  }
}
```

[Source: Lifecycle - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle)

### 3. Notification（通知）

**定义**：通知是从客户端发送到服务器（或反向）的单向消息，接收方**不得**发送响应。

**消息结构**：

```json
{
  "jsonrpc": "2.0",
  "method": string,
  "params?": {
    [key: string]: unknown
  }
}
```

**字段说明**：

| 字段 | 类型 | 必需 | 说明 |
|------|------|------|------|
| `jsonrpc` | string | ✅ | 必须是 "2.0" |
| `method` | string | ✅ | 通知方法名称 |
| `params` | object | ❌ | 通知参数（可选） |

**MCP 要求**：

- ❌ 通知**不得**包含 ID 字段
- ✅ 接收方**不得**发送响应

[Source: Overview - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic)

**示例**：

```json
// 初始化完成通知
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized",
  "params": {}
}

// 日志消息通知
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "info",
    "logger": "my-server",
    "data": "Server started successfully"
  }
}

// 工具列表变更通知
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/listChanged",
  "params": {}
}
```

**通知的使用场景**：

1. **生命周期事件**：如 `notifications/initialized`
2. **状态变更**：如 `notifications/tools/listChanged`
3. **日志输出**：如 `notifications/message`
4. **进度更新**：如 `notifications/progress`

---

## 生命周期管理

### 生命周期阶段

MCP 定义了严格的连接生命周期，确保正确的能力协商和状态管理：

```
1. Initialization（初始化）
   ├─ 能力协商
   ├─ 协议版本协商
   └─ 实现信息交换

2. Operation（操作）
   ├─ 正常协议通信
   ├─ 工具调用
   ├─ 资源访问
   └─ 事件推送

3. Shutdown（关闭）
   └─ 优雅终止连接
```

[Source: Lifecycle - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle)

### 初始化阶段

**两步握手机制**：

MCP 的初始化包含两个关键步骤：

#### Step 1: initialize 请求

客户端**必须**首先发送 `initialize` 请求：

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-11-25",
    "capabilities": {
      "roots": { "listChanged": true },
      "sampling": {}
    },
    "clientInfo": {
      "name": "ExampleClient",
      "version": "1.0.0"
    }
  }
}
```

服务器**必须**响应其能力和信息：

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2025-11-25",
    "capabilities": {
      "logging": {},
      "prompts": { "listChanged": true },
      "resources": { "subscribe": true },
      "tools": { "listChanged": true }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "version": "1.0.0"
    }
  }
}
```

#### Step 2: initialized 通知

成功初始化后，客户端**必须**发送 `initialized` 通知：

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

**重要约束**：

- ✅ 客户端在服务器响应 initialize 前**不应**发送其他请求（ping 除外）
- ✅ 服务器在收到 initialized 通知前**不应**发送其他请求（ping 和 logging 除外）

[Source: Lifecycle - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle)

### 版本协商

**协商流程**：

1. 客户端在 `initialize` 请求中发送其支持的协议版本（**应该**是最新版本）
2. 如果服务器支持该版本，**必须**响应相同版本
3. 否则，服务器**必须**响应其支持的另一个版本（**应该**是最新版本）
4. 如果客户端不支持服务器响应的版本，**应该**断开连接

**HTTP 传输的特殊要求**：

使用 HTTP 时，客户端**必须**在所有后续请求中包含 `MCP-Protocol-Version: <protocol-version>` HTTP 头。

[Source: Lifecycle - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle)

### 能力协商

**能力类别**：

| 类别 | 能力 | 描述 |
|------|------|------|
| **Client** | roots | 提供文件系统根目录 |
| **Client** | sampling | 支持 LLM 采样请求 |
| **Client** | elicitation | 支持服务器引导请求 |
| **Server** | prompts | 提供提示模板 |
| **Server** | resources | 提供可读资源 |
| **Server** | tools | 暴露可调用工具 |
| **Server** | logging | 发出结构化日志消息 |

**子能力**：

能力对象可以描述子能力：

- `listChanged`: 支持列表变更通知（用于 prompts、resources、tools）
- `subscribe`: 支持订阅单个项目的变更（仅 resources）

[Source: Lifecycle - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle)

### 操作阶段

在操作阶段，客户端和服务器根据协商的能力交换消息。

**双方必须**：

- 遵守协商的协议版本
- 仅使用成功协商的能力

### 关闭阶段

**stdio 传输**：

客户端**应该**通过以下方式启动关闭：

1. 关闭子进程（服务器）的输入流
2. 等待服务器退出，或在合理时间内发送 SIGTERM
3. 如果服务器在 SIGTERM 后仍未退出，发送 SIGKILL

**HTTP 传输**：

通过关闭相关的 HTTP 连接来指示关闭。

[Source: Lifecycle - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle)

---

## JSON Schema 使用

### Schema 方言

MCP 使用 JSON Schema 进行验证，规则如下：

1. **默认方言**：当 schema 不包含 `$schema` 字段时，默认为 [JSON Schema 2020-12](https://json-schema.org/draft/2020-12/schema)
2. **显式方言**：Schema **可以**包含 `$schema` 字段指定不同方言
3. **支持的方言**：实现**必须**至少支持 2020-12，**应该**记录支持的其他方言
4. **推荐**：实现者**推荐**使用 JSON Schema 2020-12

[Source: Overview - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic)

### 示例

**默认方言（2020-12）**：

```json
{
  "type": "object",
  "properties": {
    "name": { "type": "string" },
    "age": { "type": "integer", "minimum": 0 }
  },
  "required": ["name"]
}
```

**显式方言（draft-07）**：

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "name": { "type": "string" },
    "age": { "type": "integer", "minimum": 0 }
  },
  "required": ["name"]
}
```

### 实现要求

- 客户端和服务器**必须**支持没有显式 `$schema` 字段的 JSON Schema 2020-12
- 客户端和服务器**必须**根据声明或默认方言验证 schema
- 客户端和服务器**必须**优雅处理不支持的方言，返回适当的错误
- 客户端和服务器**应该**记录支持的 schema 方言

---

## 协议组件

### 核心组件

MCP 协议由几个关键组件组成：

```
MCP 协议组件：
├─ Base Protocol（基础协议）
│   └─ 核心 JSON-RPC 消息类型
├─ Lifecycle Management（生命周期管理）
│   ├─ 连接初始化
│   ├─ 能力协商
│   └─ 会话控制
├─ Authorization（授权）
│   └─ HTTP 传输的认证和授权框架
├─ Server Features（服务器特性）
│   ├─ Resources（资源）
│   ├─ Prompts（提示）
│   └─ Tools（工具）
├─ Client Features（客户端特性）
│   ├─ Sampling（采样）
│   └─ Root directory lists（根目录列表）
└─ Utilities（工具）
    ├─ Logging（日志）
    └─ Argument completion（参数补全）
```

**实现要求**：

- ✅ 所有实现**必须**支持基础协议和生命周期管理
- ✅ 其他组件**可以**根据应用需求实现

[Source: Overview - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic)

### 模块化设计

MCP 的模块化设计允许实现支持所需的功能：

**优势**：

1. **关注点分离**：每个组件职责清晰
2. **灵活性**：根据需求选择实现的组件
3. **可扩展性**：易于添加新功能
4. **互操作性**：不同实现可以协商共同支持的功能

---

## 超时处理

### 超时策略

实现**应该**为所有发送的请求建立超时：

**目的**：
- 防止连接挂起
- 防止资源耗尽

**超时处理**：

当请求在超时期限内未收到成功或错误响应时，发送方**应该**：

1. 发出取消通知
2. 停止等待响应

**进度通知的影响**：

实现**可以**在收到进度通知时重置超时时钟，因为这表明工作正在进行。

**最大超时**：

实现**应该**始终强制执行最大超时，无论进度通知如何，以限制行为不当的客户端或服务器的影响。

[Source: Lifecycle - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle)

---

## 错误处理

### 常见错误场景

实现**应该**准备处理以下错误情况：

1. **协议版本不匹配**
2. **无法协商所需能力**
3. **请求超时**

### 错误处理最佳实践

```typescript
// 服务器端错误处理
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    // 执行工具逻辑
    const result = await executeToolLogic(request.params);
    return {
      content: [{ type: "text", text: JSON.stringify(result) }]
    };
  } catch (error) {
    // 返回错误响应，不抛出异常
    return {
      content: [
        {
          type: "text",
          text: `Error: ${error.message}`
        }
      ],
      isError: true
    };
  }
});
```

---

## 协议规范资源

### 官方资源

- **TypeScript Schema**：[协议规范的源代码](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-11-25/schema.ts)
- **JSON Schema**：[自动生成的 JSON Schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-11-25/schema.json)
- **规范文档**：[完整规范文档](https://modelcontextprotocol.io/specification/2025-11-25)

### 社区资源

- **GitHub Discussions**：[参与协议讨论](https://github.com/modelcontextprotocol/specification/discussions)
- **示例实现**：[官方示例](https://github.com/modelcontextprotocol/examples)

---

## 总结

### 核心要点

1. **JSON-RPC 2.0 基础**：MCP 基于成熟的 JSON-RPC 2.0 协议
2. **三种消息类型**：Request、Response、Notification
3. **严格的生命周期**：Initialize → Operation → Shutdown
4. **能力协商**：客户端和服务器协商支持的功能
5. **模块化设计**：根据需求选择实现的组件

### 关键约束

- ✅ 请求 ID 不能为 null 且不能重复
- ✅ 通知不能包含 ID
- ✅ 必须完成两步握手（initialize + initialized）
- ✅ 必须遵守协商的协议版本和能力

### 下一步

- 阅读 [03_核心概念_02_Transport层设计](./03_核心概念_02_Transport层设计.md) 了解传输层实现
- 阅读 [03_核心概念_03_Tools与Resources](./03_核心概念_03_Tools与Resources.md) 了解工具和资源的详细规范

---

**参考资源**：
- [Source: Overview - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic)
- [Source: Lifecycle - Model Context Protocol](https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle)
- [Source: JSON-RPC 2.0 Specification](https://www.jsonrpc.org/specification)
