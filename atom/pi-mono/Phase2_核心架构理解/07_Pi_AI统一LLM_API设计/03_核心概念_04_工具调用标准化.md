# 核心概念4：工具调用标准化

> 理解如何通过 TypeBox Schema 统一不同 LLM Provider 的工具调用格式

---

## 概念定义

**工具调用标准化**是指使用统一的 Schema 定义和验证机制，使 AI Agent 能够以相同的方式调用工具，无论底层使用哪个 LLM Provider。

**核心价值：**
- **Schema 统一**：一次定义，所有 Provider 可用
- **自动验证**：TypeBox 自动生成 JSON Schema 并验证参数
- **类型安全**：TypeScript 类型推导，编译时检查
- **流式支持**：支持流式工具调用（实时返回结果）

---

## 第一性原理

### 问题的本质

**核心问题：** 不同 Provider 的工具调用格式不同，如何统一？

**OpenAI 工具格式：**
```typescript
{
  type: 'function',
  function: {
    name: 'get_weather',
    description: 'Get current weather',
    parameters: {
      type: 'object',
      properties: {
        location: { type: 'string', description: 'City name' },
        unit: { type: 'string', enum: ['celsius', 'fahrenheit'] }
      },
      required: ['location']
    }
  }
}
```

**Anthropic 工具格式：**
```typescript
{
  name: 'get_weather',
  description: 'Get current weather',
  input_schema: {
    type: 'object',
    properties: {
      location: { type: 'string', description: 'City name' },
      unit: { type: 'string', enum: ['celsius', 'fahrenheit'] }
    },
    required: ['location']
  }
}
```

**Google 工具格式：**
```typescript
{
  functionDeclarations: [{
    name: 'get_weather',
    description: 'Get current weather',
    parameters: {
      type: 'object',
      properties: {
        location: { type: 'string', description: 'City name' },
        unit: { type: 'string', enum: ['celsius', 'fahrenheit'] }
      },
      required: ['location']
    }
  }]
}
```

### 设计原则

**1. Schema First**
- 使用 TypeBox 定义 Schema
- 自动生成 JSON Schema
- 自动生成 TypeScript 类型

**2. 自动验证**
- 参数类型验证
- 必填字段检查
- 枚举值验证

**3. 统一接口**
- 所有 Provider 使用相同的工具定义
- Adapter 自动转换为 Provider 格式

**4. 流式支持**
- 支持流式工具调用
- 实时返回工具执行结果

---

## 核心实现

### 1. TypeBox Schema 定义

```typescript
import { Type, Static } from '@sinclair/typebox';

/**
 * 工具定义
 * 使用 TypeBox 定义工具的 Schema
 */
interface Tool {
  /**
   * 工具名称
   * 必须是有效的函数名（字母、数字、下划线）
   */
  name: string;

  /**
   * 工具描述
   * 告诉 LLM 这个工具的作用
   */
  description: string;

  /**
   * 参数 Schema
   * 使用 TypeBox 定义
   */
  parameters: any;  // TypeBox Schema

  /**
   * 工具执行函数（可选）
   * 如果提供，可以自动执行工具
   */
  execute?: (input: any) => Promise<any>;
}

/**
 * 示例：天气查询工具
 */
const weatherTool: Tool = {
  name: 'get_weather',
  description: 'Get current weather for a location',
  parameters: Type.Object({
    location: Type.String({
      description: 'City name, e.g., "Tokyo", "New York"'
    }),
    unit: Type.Optional(Type.Union([
      Type.Literal('celsius'),
      Type.Literal('fahrenheit')
    ], {
      description: 'Temperature unit',
      default: 'celsius'
    }))
  }),
  execute: async (input) => {
    // 实际实现会调用天气 API
    return {
      location: input.location,
      temperature: 22,
      unit: input.unit || 'celsius',
      condition: 'sunny'
    };
  }
};

/**
 * 示例：文件读取工具
 */
const readFileTool: Tool = {
  name: 'read_file',
  description: 'Read contents of a file',
  parameters: Type.Object({
    path: Type.String({
      description: 'File path'
    }),
    encoding: Type.Optional(Type.Union([
      Type.Literal('utf-8'),
      Type.Literal('ascii'),
      Type.Literal('base64')
    ], {
      default: 'utf-8'
    }))
  }),
  execute: async (input) => {
    const fs = await import('fs/promises');
    const content = await fs.readFile(input.path, input.encoding || 'utf-8');
    return { content };
  }
};

/**
 * 示例：数据库查询工具
 */
const dbQueryTool: Tool = {
  name: 'query_database',
  description: 'Query database with SQL',
  parameters: Type.Object({
    query: Type.String({
      description: 'SQL query string'
    }),
    params: Type.Optional(Type.Array(Type.Any(), {
      description: 'Query parameters'
    })),
    limit: Type.Optional(Type.Number({
      description: 'Maximum number of rows to return',
      minimum: 1,
      maximum: 1000,
      default: 100
    }))
  }),
  execute: async (input) => {
    // 实际实现会连接数据库
    return {
      rows: [],
      count: 0
    };
  }
};
```

### 2. Schema 转换器

```typescript
import { TypeCompiler } from '@sinclair/typebox/compiler';
import { Value } from '@sinclair/typebox/value';

/**
 * 工具 Schema 转换器
 * 将 TypeBox Schema 转换为不同 Provider 的格式
 */
class ToolSchemaConverter {
  /**
   * 转换为 OpenAI 格式
   */
  toOpenAI(tool: Tool): any {
    return {
      type: 'function',
      function: {
        name: tool.name,
        description: tool.description,
        parameters: this.typeboxToJsonSchema(tool.parameters)
      }
    };
  }

  /**
   * 转换为 Anthropic 格式
   */
  toAnthropic(tool: Tool): any {
    return {
      name: tool.name,
      description: tool.description,
      input_schema: this.typeboxToJsonSchema(tool.parameters)
    };
  }

  /**
   * 转换为 Google 格式
   */
  toGoogle(tool: Tool): any {
    return {
      functionDeclarations: [{
        name: tool.name,
        description: tool.description,
        parameters: this.typeboxToJsonSchema(tool.parameters)
      }]
    };
  }

  /**
   * TypeBox Schema 转换为 JSON Schema
   * TypeBox 内置支持，直接使用
   */
  private typeboxToJsonSchema(schema: any): any {
    // TypeBox Schema 本身就是 JSON Schema 兼容的
    return schema;
  }

  /**
   * 验证工具参数
   */
  validate(tool: Tool, input: any): { valid: boolean; errors?: any[] } {
    try {
      // 使用 TypeBox 的 Value.Check 验证
      const valid = Value.Check(tool.parameters, input);
      if (!valid) {
        const errors = [...Value.Errors(tool.parameters, input)];
        return { valid: false, errors };
      }
      return { valid: true };
    } catch (error) {
      return {
        valid: false,
        errors: [{ message: error.message }]
      };
    }
  }

  /**
   * 编译 Schema（性能优化）
   * 预编译 Schema 可以提高验证速度
   */
  compile(tool: Tool): (input: any) => boolean {
    const compiled = TypeCompiler.Compile(tool.parameters);
    return (input: any) => compiled.Check(input);
  }
}
```

### 3. 工具调用执行器

```typescript
/**
 * 工具调用执行器
 * 处理工具调用的完整流程
 */
class ToolExecutor {
  private tools = new Map<string, Tool>();
  private converter = new ToolSchemaConverter();

  /**
   * 注册工具
   */
  register(tool: Tool): void {
    this.tools.set(tool.name, tool);
  }

  /**
   * 批量注册工具
   */
  registerAll(tools: Tool[]): void {
    tools.forEach(tool => this.register(tool));
  }

  /**
   * 获取工具
   */
  get(name: string): Tool | undefined {
    return this.tools.get(name);
  }

  /**
   * 列出所有工具
   */
  list(): Tool[] {
    return Array.from(this.tools.values());
  }

  /**
   * 执行工具调用
   */
  async execute(
    name: string,
    input: any
  ): Promise<{ success: boolean; result?: any; error?: string }> {
    // 1. 获取工具
    const tool = this.tools.get(name);
    if (!tool) {
      return {
        success: false,
        error: `Tool "${name}" not found`
      };
    }

    // 2. 验证参数
    const validation = this.converter.validate(tool, input);
    if (!validation.valid) {
      return {
        success: false,
        error: `Invalid parameters: ${JSON.stringify(validation.errors)}`
      };
    }

    // 3. 执行工具
    if (!tool.execute) {
      return {
        success: false,
        error: `Tool "${name}" has no execute function`
      };
    }

    try {
      const result = await tool.execute(input);
      return {
        success: true,
        result
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * 批量执行工具调用
   */
  async executeAll(
    calls: Array<{ name: string; input: any }>
  ): Promise<Array<{ success: boolean; result?: any; error?: string }>> {
    return Promise.all(
      calls.map(call => this.execute(call.name, call.input))
    );
  }

  /**
   * 转换工具为 Provider 格式
   */
  toProviderFormat(provider: string): any[] {
    const tools = this.list();

    switch (provider) {
      case 'openai':
        return tools.map(tool => this.converter.toOpenAI(tool));

      case 'anthropic':
        return tools.map(tool => this.converter.toAnthropic(tool));

      case 'google':
        return tools.map(tool => this.converter.toGoogle(tool));

      default:
        throw new Error(`Unsupported provider: ${provider}`);
    }
  }
}
```

### 4. 流式工具调用

```typescript
/**
 * 流式工具调用处理器
 * 支持在流式响应中处理工具调用
 */
class StreamingToolHandler {
  private executor: ToolExecutor;
  private pendingToolCalls = new Map<string, {
    name: string;
    input: string;  // 累积的 JSON 字符串
  }>();

  constructor(executor: ToolExecutor) {
    this.executor = executor;
  }

  /**
   * 处理流式事件
   */
  async handleStreamEvent(event: StreamEvent): Promise<StreamEvent | null> {
    if (event.type === 'delta') {
      // 检查是否包含工具调用
      if (event.delta.toolCalls) {
        for (const toolCall of event.delta.toolCalls) {
          await this.handleToolCallDelta(toolCall);
        }
      }
    } else if (event.type === 'end') {
      // 流结束，执行所有待处理的工具调用
      await this.executeAllPendingToolCalls();
    }

    return event;
  }

  /**
   * 处理工具调用增量
   */
  private async handleToolCallDelta(delta: any): Promise<void> {
    const id = delta.id;
    const name = delta.name;
    const inputDelta = delta.input;

    // 累积工具调用信息
    if (!this.pendingToolCalls.has(id)) {
      this.pendingToolCalls.set(id, {
        name: name || '',
        input: ''
      });
    }

    const pending = this.pendingToolCalls.get(id)!;
    if (name) pending.name = name;
    if (inputDelta) pending.input += inputDelta;
  }

  /**
   * 执行所有待处理的工具调用
   */
  private async executeAllPendingToolCalls(): Promise<void> {
    const calls = Array.from(this.pendingToolCalls.entries());

    for (const [id, { name, input }] of calls) {
      try {
        // 解析 JSON 输入
        const parsedInput = JSON.parse(input);

        // 执行工具
        const result = await this.executor.execute(name, parsedInput);

        console.log(`Tool ${name} executed:`, result);
      } catch (error) {
        console.error(`Failed to execute tool ${name}:`, error);
      }
    }

    // 清空待处理列表
    this.pendingToolCalls.clear();
  }
}
```

---

## 在 AI Agent 中的应用

### 场景1：基础工具调用

```typescript
/**
 * 基础工具调用示例
 */
async function basicToolCalling(): Promise<void> {
  // 1. 创建工具执行器
  const executor = new ToolExecutor();

  // 2. 注册工具
  executor.register(weatherTool);
  executor.register(readFileTool);

  // 3. 创建上下文
  const context: Context = {
    systemPrompt: 'You are a helpful assistant with access to tools.',
    messages: [
      {
        role: 'user',
        content: 'What is the weather in Tokyo?'
      }
    ],
    tools: executor.list(),
    temperature: 0.7
  };

  // 4. 调用 LLM
  const converter = new MessageConverter();
  const openaiRequest = converter.toOpenAI(context);

  const openai = new OpenAI();
  const response = await openai.chat.completions.create(openaiRequest);

  // 5. 处理工具调用
  const message = converter.fromOpenAI(response);

  if (message.toolCalls) {
    for (const toolCall of message.toolCalls) {
      console.log(`Executing tool: ${toolCall.name}`);
      console.log(`Input: ${JSON.stringify(toolCall.input)}`);

      const result = await executor.execute(toolCall.name, toolCall.input);

      if (result.success) {
        console.log(`Result: ${JSON.stringify(result.result)}`);
      } else {
        console.error(`Error: ${result.error}`);
      }
    }
  }
}
```

### 场景2：多轮工具调用

```typescript
/**
 * 多轮工具调用示例
 * Agent 可以多次调用工具直到完成任务
 */
async function multiTurnToolCalling(
  userMessage: string,
  maxTurns: number = 5
): Promise<string> {
  const executor = new ToolExecutor();
  executor.registerAll([weatherTool, readFileTool, dbQueryTool]);

  const messages: Message[] = [];
  const converter = new MessageConverter();

  // 初始用户消息
  messages.push({
    role: 'user',
    content: userMessage
  });

  // 多轮对话
  for (let turn = 0; turn < maxTurns; turn++) {
    // 1. 调用 LLM
    const context: Context = {
      systemPrompt: 'You are a helpful assistant. Use tools to complete tasks.',
      messages,
      tools: executor.list(),
      temperature: 0.7
    };

    const anthropicRequest = converter.toAnthropic(context);
    const anthropic = new Anthropic();
    const response = await anthropic.messages.create(anthropicRequest);

    // 2. 处理响应
    const assistantMessage = converter.fromAnthropic(response);
    messages.push(assistantMessage);

    // 3. 检查是否有工具调用
    const toolUses = Array.isArray(assistantMessage.content)
      ? assistantMessage.content.filter(block => block.type === 'tool_use')
      : [];

    if (toolUses.length === 0) {
      // 没有工具调用，返回最终答案
      return typeof assistantMessage.content === 'string'
        ? assistantMessage.content
        : assistantMessage.content
            .filter(block => block.type === 'text')
            .map(block => block.text)
            .join('');
    }

    // 4. 执行工具调用
    const toolResults: ContentBlock[] = [];
    for (const toolUse of toolUses as ToolUseBlock[]) {
      const result = await executor.execute(toolUse.name, toolUse.input);

      toolResults.push({
        type: 'tool_result',
        toolUseId: toolUse.id,
        content: result.success
          ? JSON.stringify(result.result)
          : result.error!,
        isError: !result.success
      });
    }

    // 5. 添加工具结果消息
    messages.push({
      role: 'user',
      content: toolResults
    });
  }

  throw new Error(`Max turns (${maxTurns}) reached without completion`);
}

// 使用示例
const answer = await multiTurnToolCalling(
  'Read the file config.json and tell me the database host'
);
console.log(answer);
```

### 场景3：并行工具调用

```typescript
/**
 * 并行工具调用示例
 * 同时执行多个独立的工具调用
 */
async function parallelToolCalling(): Promise<void> {
  const executor = new ToolExecutor();
  executor.registerAll([weatherTool, readFileTool]);

  // LLM 返回多个工具调用
  const toolCalls: ToolCall[] = [
    {
      id: 'call_1',
      name: 'get_weather',
      input: { location: 'Tokyo' }
    },
    {
      id: 'call_2',
      name: 'get_weather',
      input: { location: 'New York' }
    },
    {
      id: 'call_3',
      name: 'read_file',
      input: { path: 'config.json' }
    }
  ];

  // 并行执行所有工具调用
  const results = await Promise.all(
    toolCalls.map(async (call) => {
      const result = await executor.execute(call.name, call.input);
      return {
        id: call.id,
        name: call.name,
        ...result
      };
    })
  );

  // 输出结果
  results.forEach(result => {
    console.log(`Tool ${result.name} (${result.id}):`);
    if (result.success) {
      console.log(`  Result: ${JSON.stringify(result.result)}`);
    } else {
      console.error(`  Error: ${result.error}`);
    }
  });
}
```

### 场景4：流式工具调用

```typescript
/**
 * 流式工具调用示例
 * 在流式响应中处理工具调用
 */
async function streamingToolCalling(): Promise<void> {
  const executor = new ToolExecutor();
  executor.register(weatherTool);

  const handler = new StreamingToolHandler(executor);

  const context: Context = {
    systemPrompt: 'You are a helpful assistant.',
    messages: [
      { role: 'user', content: 'What is the weather in Tokyo?' }
    ],
    tools: executor.list()
  };

  // 流式调用
  const model = getModel('openai', 'gpt-4o-mini');
  for await (const event of stream(model, context)) {
    // 处理流式事件（包括工具调用）
    await handler.handleStreamEvent(event);

    // 输出内容
    if (event.type === 'delta' && event.delta.content) {
      process.stdout.write(event.delta.content);
    }
  }
}
```

---

## 设计权衡

### 优点

1. **Schema 统一**
   - 一次定义，所有 Provider 可用
   - 降低维护成本

2. **自动验证**
   - TypeBox 自动验证参数
   - 编译时类型检查
   - 运行时参数验证

3. **类型安全**
   - TypeScript 类型推导
   - IDE 自动补全
   - 减少运行时错误

4. **性能优化**
   - TypeBox 编译器优化验证速度
   - 比 JSON Schema 验证快 10-100 倍

### 缺点

1. **学习成本**
   - 需要学习 TypeBox API
   - 比直接写 JSON Schema 复杂

2. **Provider 差异**
   - 某些 Provider 的工具调用功能有限制
   - 需要在 Adapter 中处理差异

3. **调试困难**
   - 工具调用失败时难以调试
   - 需要详细的错误信息

---

## 实际案例（2025-2026）

### 案例1：LangChain.js 的工具系统

**背景：** LangChain.js 使用 Zod 定义工具 Schema

**实现：**
```typescript
import { z } from 'zod';
import { tool } from '@langchain/core/tools';

const weatherTool = tool(
  async ({ location }) => {
    // 工具实现
    return `Weather in ${location}: sunny, 22°C`;
  },
  {
    name: 'get_weather',
    description: 'Get current weather',
    schema: z.object({
      location: z.string().describe('City name'),
      unit: z.enum(['celsius', 'fahrenheit']).optional()
    })
  }
);
```

**特点：**
- 使用 Zod 定义 Schema
- 自动生成 JSON Schema
- 类型安全

**来源：** [LangChain.js Tools](https://js.langchain.com/docs/modules/agents/tools/) (2026-02-10)

---

### 案例2：Vercel AI SDK 的工具定义

**背景：** Vercel AI SDK 使用 Zod 定义工具

**实现：**
```typescript
import { z } from 'zod';
import { generateText, tool } from 'ai';

const result = await generateText({
  model: openai('gpt-4o'),
  tools: {
    weather: tool({
      description: 'Get the weather in a location',
      parameters: z.object({
        location: z.string().describe('The location to get the weather for'),
      }),
      execute: async ({ location }) => ({
        location,
        temperature: 72 + Math.floor(Math.random() * 21) - 10,
      }),
    }),
  },
  prompt: 'What is the weather in San Francisco?',
});
```

**特点：**
- 统一的工具定义格式
- 支持多个 Provider
- 自动执行工具

**来源：** [Vercel AI SDK Tools](https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling) (2026-01-20)

---

## 学习检查清单

完成本概念学习后，你应该能够：

- [ ] 理解工具调用标准化的价值
- [ ] 能够使用 TypeBox 定义工具 Schema
- [ ] 能够实现 Schema 转换器
- [ ] 能够实现工具执行器
- [ ] 理解参数验证机制
- [ ] 能够处理多轮工具调用
- [ ] 能够实现并行工具调用
- [ ] 能够处理流式工具调用
- [ ] 理解设计权衡

---

## 参考资源

### 官方文档
- [TypeBox](https://github.com/sinclairzx81/typebox) - TypeBox 文档
- [OpenAI Function Calling](https://platform.openai.com/docs/guides/function-calling) - OpenAI 工具调用
- [Anthropic Tool Use](https://docs.anthropic.com/claude/docs/tool-use) - Anthropic 工具调用
- [Google Function Calling](https://ai.google.dev/docs/function_calling) - Google 工具调用

### 相关项目
- [LangChain.js Tools](https://js.langchain.com/docs/modules/agents/tools/) - LangChain 工具系统
- [Vercel AI SDK Tools](https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling) - Vercel 工具定义
- [Zod](https://zod.dev/) - TypeScript Schema 验证库

---

**版本：** v1.0
**最后更新：** 2026-02-19
