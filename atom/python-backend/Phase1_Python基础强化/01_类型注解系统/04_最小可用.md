# 最小可用

掌握以下内容，就能开始在 FastAPI 项目中使用类型注解：

## 4.1 基础类型注解（5个常用类型）

**最常用的5个类型：**

```python
# 1. 基础类型
name: str = "Alice"
age: int = 25
price: float = 99.99
is_active: bool = True

# 2. 列表和字典
tags: list[str] = ["python", "fastapi"]  # Python 3.9+
user_data: dict[str, int] = {"age": 25, "score": 100}

# 3. 可选类型（最重要！）
from typing import Optional

email: Optional[str] = None  # 可以是 str 或 None
# 等价于：email: str | None = None  # Python 3.10+
```

**在 FastAPI 中：**

```python
from fastapi import FastAPI
from typing import Optional

app = FastAPI()

@app.get("/users/{user_id}")
async def get_user(
    user_id: int,  # 路径参数，必须是整数
    include_email: bool = False,  # 查询参数，默认 False
    token: Optional[str] = None  # 可选的查询参数
):
    return {"user_id": user_id, "include_email": include_email}

# 访问：GET /users/123?include_email=true&token=abc
# FastAPI 自动：
# - 验证 user_id 是整数
# - 转换 include_email 为布尔值
# - token 可以不传
```

## 4.2 函数类型注解（参数 + 返回值）

**基本语法：**

```python
def function_name(param: type) -> return_type:
    pass
```

**实际例子：**

```python
# 简单函数
def greet(name: str) -> str:
    return f"Hello, {name}"

# 多个参数
def calculate_total(price: float, quantity: int, tax_rate: float = 0.1) -> float:
    return price * quantity * (1 + tax_rate)

# 无返回值
def log_message(message: str) -> None:
    print(f"[LOG] {message}")

# 返回多个值（元组）
def get_user_info(user_id: int) -> tuple[str, int]:
    return ("Alice", 25)
```

**在 FastAPI 中：**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class ChatRequest(BaseModel):
    message: str
    user_id: int

class ChatResponse(BaseModel):
    reply: str
    tokens_used: int

@app.post("/chat", response_model=ChatResponse)
async def chat(request: ChatRequest) -> ChatResponse:
    # FastAPI 自动：
    # 1. 验证请求体符合 ChatRequest
    # 2. 验证返回值符合 ChatResponse
    # 3. 生成 API 文档
    return ChatResponse(
        reply=f"You said: {request.message}",
        tokens_used=10
    )
```

## 4.3 Pydantic 模型（数据验证）

**最常用的数据模型定义：**

```python
from pydantic import BaseModel, Field
from typing import Optional

class User(BaseModel):
    id: int
    name: str
    email: str
    age: Optional[int] = None  # 可选字段
    is_active: bool = True  # 默认值

class CreateUserRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=50)  # 必填，长度限制
    email: str = Field(..., pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")  # 邮箱格式
    age: int = Field(..., ge=0, le=150)  # 年龄范围 0-150

# 使用
user_data = {"name": "Alice", "email": "alice@example.com", "age": 25}
user = CreateUserRequest(**user_data)  # 自动验证

# 如果数据不合法
try:
    bad_user = CreateUserRequest(name="", email="invalid", age=200)
except ValueError as e:
    print(e)  # 详细的验证错误信息
```

**在 FastAPI 中：**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class AgentConfig(BaseModel):
    model: str = "gpt-4"
    temperature: float = 0.7
    max_tokens: int = 1000

@app.post("/agent/configure")
async def configure_agent(config: AgentConfig):
    # FastAPI 自动验证：
    # - model 是字符串
    # - temperature 是浮点数
    # - max_tokens 是整数
    # 如果类型错误，返回 422 错误
    return {"status": "configured", "config": config}
```

## 4.4 列表和字典的类型注解

**常用集合类型：**

```python
from typing import List, Dict, Set

# 列表（元素类型相同）
names: list[str] = ["Alice", "Bob", "Charlie"]  # Python 3.9+
scores: List[int] = [95, 87, 92]  # 旧写法，兼容性更好

# 字典（键值类型）
user_ages: dict[str, int] = {"Alice": 25, "Bob": 30}
config: Dict[str, str] = {"host": "localhost", "port": "8000"}

# 集合
tags: set[str] = {"python", "fastapi", "ai"}

# 嵌套类型
users: list[dict[str, str]] = [
    {"name": "Alice", "email": "alice@example.com"},
    {"name": "Bob", "email": "bob@example.com"}
]
```

**在 AI Agent 开发中：**

```python
from typing import List, Dict, Any
from pydantic import BaseModel

class ToolCall(BaseModel):
    tool_name: str
    parameters: Dict[str, Any]  # 任意类型的字典

class AgentResponse(BaseModel):
    message: str
    tool_calls: List[ToolCall]  # 工具调用列表
    metadata: Dict[str, str]

# 使用
response = AgentResponse(
    message="I'll search for that information",
    tool_calls=[
        ToolCall(tool_name="search", parameters={"query": "Python typing"}),
        ToolCall(tool_name="calculator", parameters={"expression": "2+2"})
    ],
    metadata={"session_id": "abc123", "user_id": "user456"}
)
```

## 4.5 使用 mypy 进行类型检查

**安装和基本使用：**

```bash
# 安装 mypy
uv add --dev mypy

# 检查单个文件
mypy app/main.py

# 检查整个项目
mypy app/

# 配置文件：pyproject.toml
[tool.mypy]
python_version = "3.13"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true  # 强制所有函数都有类型注解
```

**常见错误和修复：**

```python
# ❌ 错误：类型不匹配
def get_age(user_id: int) -> int:
    return "25"  # mypy 报错：返回 str，期望 int

# ✅ 修复
def get_age(user_id: int) -> int:
    return 25

# ❌ 错误：可能是 None
def get_user_name(user_id: int) -> str:
    user = find_user(user_id)  # 可能返回 None
    return user.name  # mypy 报错：user 可能是 None

# ✅ 修复
from typing import Optional

def get_user_name(user_id: int) -> Optional[str]:
    user = find_user(user_id)
    if user is None:
        return None
    return user.name

# ❌ 错误：列表元素类型不一致
numbers: list[int] = [1, 2, "3"]  # mypy 报错

# ✅ 修复
numbers: list[int] = [1, 2, 3]
```

**在 CI/CD 中集成：**

```bash
# .github/workflows/ci.yml
- name: Type check with mypy
  run: mypy app/

# pre-commit hook
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.8.0
    hooks:
      - id: mypy
        additional_dependencies: [types-all]
```

---

## 这些知识足以：

**立即可以做的事情：**

1. ✅ 为 FastAPI 路由添加类型注解
2. ✅ 使用 Pydantic 定义请求和响应模型
3. ✅ 用 mypy 检查代码中的类型错误
4. ✅ 获得 IDE 的智能提示和自动补全
5. ✅ 让 FastAPI 自动生成 API 文档

**实际项目示例：**

```python
# app/main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Optional, List

app = FastAPI()

# 数据模型
class Message(BaseModel):
    role: str
    content: str

class ChatRequest(BaseModel):
    messages: List[Message]
    model: str = "gpt-4"
    temperature: float = 0.7

class ChatResponse(BaseModel):
    reply: str
    tokens_used: int

# API 端点
@app.post("/chat", response_model=ChatResponse)
async def chat(request: ChatRequest) -> ChatResponse:
    # 类型注解确保：
    # - request.messages 是 Message 列表
    # - request.model 是字符串
    # - request.temperature 是浮点数
    # - 返回值符合 ChatResponse 格式

    if not request.messages:
        raise HTTPException(status_code=400, detail="Messages cannot be empty")

    # 调用 LLM（简化示例）
    last_message = request.messages[-1].content
    reply = f"Echo: {last_message}"

    return ChatResponse(reply=reply, tokens_used=10)

# 运行：uvicorn app.main:app --reload
# 访问文档：http://localhost:8000/docs
```

**运行 mypy 检查：**

```bash
$ mypy app/main.py
Success: no issues found in 1 source file
```

---

## 下一步学习

掌握了最小可用知识后，可以学习：

1. **高级类型**：泛型（Generic）、协议（Protocol）、字面量（Literal）
2. **类型别名**：简化复杂类型定义
3. **类型守卫**：运行时类型检查
4. **mypy 配置**：严格模式、忽略规则

但对于日常 FastAPI 开发，上面的5个知识点已经足够！

---

## 快速参考卡

```python
# 基础类型
x: int = 1
y: str = "hello"
z: float = 3.14
flag: bool = True

# 可选类型
from typing import Optional
value: Optional[int] = None  # int 或 None

# 集合类型
names: list[str] = ["Alice", "Bob"]
ages: dict[str, int] = {"Alice": 25}

# 函数注解
def func(x: int) -> str:
    return str(x)

# Pydantic 模型
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int

# FastAPI 路由
from fastapi import FastAPI
app = FastAPI()

@app.post("/users", response_model=User)
async def create_user(user: User) -> User:
    return user

# mypy 检查
# mypy app/main.py
```
