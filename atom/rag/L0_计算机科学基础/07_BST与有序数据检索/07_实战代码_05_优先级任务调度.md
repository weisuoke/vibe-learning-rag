# 07_实战代码_05_优先级任务调度

## 场景描述

**目标：** 实现基于BST的优先级任务调度系统

**应用场景：**
- LangChain Agent的任务队列
- AI系统的资源调度
- 公平任务分配

**引用：** [OrcaLoca Framework (2025)](https://arxiv.org/html/2502.00350v2)

---

## 完整实现

```python
"""
优先级任务调度系统
基于BST实现动态优先级队列
"""

import time
from typing import Optional, List, Any, Callable
from dataclasses import dataclass, field
from enum import Enum


class TaskStatus(Enum):
    """任务状态"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class Task:
    """任务定义"""
    task_id: str
    name: str
    priority: int  # 优先级（越大越高）
    func: Callable
    args: tuple = field(default_factory=tuple)
    kwargs: dict = field(default_factory=dict)
    status: TaskStatus = TaskStatus.PENDING
    created_at: float = field(default_factory=time.time)
    started_at: Optional[float] = None
    completed_at: Optional[float] = None
    result: Any = None
    error: Optional[str] = None

    def __lt__(self, other):
        """比较优先级"""
        if self.priority != other.priority:
            return self.priority < other.priority
        return self.created_at > other.created_at  # 同优先级，先来先服务


class PriorityTaskQueue:
    """优先级任务队列"""

    def __init__(self):
        self.tasks: List[Task] = []  # 使用有序列表模拟BST
        self.task_map: dict = {}

    def add_task(self, task: Task) -> None:
        """添加任务"""
        # 二分插入保持有序
        left, right = 0, len(self.tasks)
        while left < right:
            mid = (left + right) // 2
            if self.tasks[mid] < task:
                left = mid + 1
            else:
                right = mid

        self.tasks.insert(left, task)
        self.task_map[task.task_id] = task

    def get_next_task(self) -> Optional[Task]:
        """获取最高优先级任务"""
        if not self.tasks:
            return None

        # 最后一个是最高优先级
        task = self.tasks.pop()
        return task

    def get_top_k_tasks(self, k: int) -> List[Task]:
        """获取前K个高优先级任务"""
        return self.tasks[-k:][::-1]

    def remove_task(self, task_id: str) -> bool:
        """移除任务"""
        if task_id not in self.task_map:
            return False

        task = self.task_map[task_id]
        self.tasks.remove(task)
        del self.task_map[task_id]
        return True

    def __len__(self) -> int:
        return len(self.tasks)


class TaskScheduler:
    """任务调度器"""

    def __init__(self, max_concurrent: int = 3):
        self.queue = PriorityTaskQueue()
        self.max_concurrent = max_concurrent
        self.running_tasks: List[Task] = []
        self.completed_tasks: List[Task] = []
        self.task_counter = 0

    def submit_task(self, name: str, func: Callable, priority: int = 5,
                    args: tuple = (), kwargs: dict = None) -> str:
        """提交任务"""
        task_id = f"task_{self.task_counter}"
        self.task_counter += 1

        task = Task(
            task_id=task_id,
            name=name,
            priority=priority,
            func=func,
            args=args,
            kwargs=kwargs or {}
        )

        self.queue.add_task(task)
        return task_id

    def execute_next(self) -> Optional[Task]:
        """执行下一个任务"""
        if len(self.running_tasks) >= self.max_concurrent:
            return None

        task = self.queue.get_next_task()
        if not task:
            return None

        # 执行任务
        task.status = TaskStatus.RUNNING
        task.started_at = time.time()
        self.running_tasks.append(task)

        try:
            task.result = task.func(*task.args, **task.kwargs)
            task.status = TaskStatus.COMPLETED
        except Exception as e:
            task.status = TaskStatus.FAILED
            task.error = str(e)

        task.completed_at = time.time()
        self.running_tasks.remove(task)
        self.completed_tasks.append(task)

        return task

    def get_stats(self) -> dict:
        """获取统计信息"""
        return {
            "pending": len(self.queue),
            "running": len(self.running_tasks),
            "completed": len(self.completed_tasks),
            "total": self.task_counter
        }


# ==================== AI Agent应用 ====================

class AgentTaskScheduler:
    """AI Agent任务调度器"""

    def __init__(self):
        self.scheduler = TaskScheduler(max_concurrent=2)

    def schedule_llm_call(self, prompt: str, priority: int = 5) -> str:
        """调度LLM调用"""
        def llm_call(prompt):
            # 模拟LLM调用
            time.sleep(0.1)
            return f"Response to: {prompt[:30]}..."

        return self.scheduler.submit_task(
            name="LLM Call",
            func=llm_call,
            priority=priority,
            args=(prompt,)
        )

    def schedule_retrieval(self, query: str, priority: int = 7) -> str:
        """调度检索任务"""
        def retrieve(query):
            # 模拟检索
            time.sleep(0.05)
            return [f"Doc1 for {query}", f"Doc2 for {query}"]

        return self.scheduler.submit_task(
            name="Retrieval",
            func=retrieve,
            priority=priority,
            args=(query,)
        )

    def run_all(self) -> None:
        """运行所有任务"""
        while len(self.scheduler.queue) > 0 or len(self.scheduler.running_tasks) > 0:
            self.scheduler.execute_next()


# ==================== 测试代码 ====================

def test_task_scheduler():
    """测试任务调度器"""
    print("=" * 60)
    print("优先级任务调度测试")
    print("=" * 60)

    agent = AgentTaskScheduler()

    # 提交任务
    print("\n1. 提交任务:")
    tasks = [
        ("用户查询", 10),
        ("背景检索", 7),
        ("生成回复", 5),
        ("日志记录", 1),
        ("紧急查询", 10),
    ]

    for name, priority in tasks:
        if "查询" in name:
            task_id = agent.schedule_llm_call(name, priority)
        else:
            task_id = agent.schedule_retrieval(name, priority)
        print(f"   提交任务: {name} (优先级={priority}, ID={task_id})")

    # 查看队列
    print(f"\n2. 队列状态: {agent.scheduler.get_stats()}")

    # 执行任务
    print("\n3. 执行任务:")
    agent.run_all()

    # 查看结果
    print("\n4. 完成的任务:")
    for task in agent.scheduler.completed_tasks:
        duration = task.completed_at - task.started_at
        print(f"   {task.name} (优先级={task.priority}): {duration:.3f}秒")

    print(f"\n最终状态: {agent.scheduler.get_stats()}")


if __name__ == "__main__":
    test_task_scheduler()
```

---

## 关键知识点

### 1. 优先级比较

```python
def __lt__(self, other):
    """优先级高的排在后面"""
    if self.priority != other.priority:
        return self.priority < other.priority
    return self.created_at > other.created_at  # FIFO
```

### 2. 动态调度

```python
def execute_next(self) -> Optional[Task]:
    """执行最高优先级任务"""
    task = self.queue.get_next_task()
    # 执行任务...
```

---

## 学习检查清单

- [ ] 理解优先级队列的实现
- [ ] 掌握任务调度的策略
- [ ] 能应用到AI Agent的任务管理
- [ ] 理解公平调度的原理

---

**记住：** 优先级任务调度是AI Agent中的核心组件，BST提供了高效的实现方式。
