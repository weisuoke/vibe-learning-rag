# 核心概念5：相对分数融合

> RSF (Relative Score Fusion) 是MongoDB Atlas提出的基于相对分数的融合方法，通过计算每个文档在各检索结果中的相对分数来融合结果

---

## 什么是相对分数融合？

### 一句话定义

**RSF (Relative Score Fusion) 是一种基于相对分数而非绝对分数或排名的融合算法，通过计算每个文档分数相对于最高分的比例来生成最终排序。**

### 核心特点

1. **基于相对分数**：使用分数比例而非绝对值
2. **MongoDB专用**：主要用于MongoDB Atlas Search
3. **简单直观**：计算逻辑简单易懂
4. **应用有限**：相比RRF应用场景较窄

---

## RSF算法原理

### 1. 基本公式

**相对分数计算**：

```
relative_score(d, i) = score(d, i) / max_score(i)

final_score(d) = Σ weight_i × relative_score(d, i)

其中：
- d: 文档
- i: 第i个检索结果
- score(d, i): 文档d在第i个检索结果中的分数
- max_score(i): 第i个检索结果中的最高分
- weight_i: 第i个检索结果的权重
```

### 2. 与RRF的区别

**RRF vs RSF对比**：

```
RRF (基于排名):
- 输入: 排名位置
- 公式: 1/(k + rank)
- 特点: 不依赖分数值

RSF (基于相对分数):
- 输入: 分数值
- 公式: score / max_score
- 特点: 依赖分数分布
```

**示例对比**：

```
BM25检索结果：
1. 文档A: 8.5
2. 文档B: 7.2
3. 文档C: 6.8

向量检索结果：
1. 文档D: 0.95
2. 文档A: 0.88
3. 文档E: 0.82

RRF计算（k=60）：
文档A: 1/(60+1) + 1/(60+2) = 0.0325
文档B: 1/(60+2) = 0.0161
文档D: 1/(60+1) = 0.0164

RSF计算（权重50-50）：
文档A: 0.5 × (8.5/8.5) + 0.5 × (0.88/0.95) = 0.5 + 0.463 = 0.963
文档B: 0.5 × (7.2/8.5) + 0 = 0.424
文档D: 0 + 0.5 × (0.95/0.95) = 0.5

最终排序：
RRF: A > D > B
RSF: A > D > B (相同)
```

---

## MongoDB实现

### 1. MongoDB Atlas Search RSF

**MongoDB Atlas Search**（2025-Q1）：

**特点**：
- 原生RSF支持
- 云服务集成
- 简单配置
- 适合MongoDB生态

**查询示例**：

```javascript
// MongoDB Atlas Search混合检索 + RSF
db.documents.aggregate([
  {
    $search: {
      compound: {
        should: [
          // BM25检索
          {
            text: {
              query: "Python异步编程",
              path: "content"
            }
          },
          // 向量检索
          {
            knnBeta: {
              vector: [0.23, -0.45, 0.67, ...],
              path: "embedding",
              k: 10
            }
          }
        ]
      },
      // RSF融合配置
      scoreDetails: true
    }
  },
  {
    $addFields: {
      // 计算相对分数
      relativeScore: {
        $add: [
          {
            $multiply: [
              0.5,  // BM25权重
              { $divide: ["$score.text", "$maxScore.text"] }
            ]
          },
          {
            $multiply: [
              0.5,  // 向量权重
              { $divide: ["$score.knn", "$maxScore.knn"] }
            ]
          }
        ]
      }
    }
  },
  {
    $sort: { relativeScore: -1 }
  },
  {
    $limit: 10
  }
])
```

### 2. Python实现

**手写RSF算法**：

```python
"""
RSF (Relative Score Fusion) 算法实现
演示：基于相对分数的融合方法
"""

from typing import List, Tuple, Dict
from collections import defaultdict

class RSFFusion:
    """RSF融合算法实现"""

    def __init__(self, weights: List[float] = None):
        """
        初始化RSF融合器

        Args:
            weights: 各检索结果的权重列表（默认均等）
        """
        self.weights = weights

    def fuse(
        self,
        results_list: List[List[Tuple[str, float]]],
        top_k: int = 10
    ) -> List[Tuple[str, float]]:
        """
        融合多个检索结果

        Args:
            results_list: 多个检索结果列表
                         每个结果是 [(doc_id, score), ...]
            top_k: 返回Top-K结果

        Returns:
            融合后的结果 [(doc_id, rsf_score), ...]
        """
        # 1. 设置权重（默认均等）
        if self.weights is None:
            self.weights = [1.0 / len(results_list)] * len(results_list)

        # 2. 计算每个检索结果的最高分
        max_scores = []
        for results in results_list:
            if results:
                max_score = max(score for _, score in results)
                max_scores.append(max_score)
            else:
                max_scores.append(1.0)  # 避免除零

        # 3. 计算每个文档的RSF分数
        rsf_scores = defaultdict(float)

        for i, results in enumerate(results_list):
            weight = self.weights[i]
            max_score = max_scores[i]

            for doc_id, score in results:
                # RSF公式：weight × (score / max_score)
                relative_score = score / max_score
                rsf_scores[doc_id] += weight * relative_score

        # 4. 按RSF分数降序排序
        sorted_results = sorted(
            rsf_scores.items(),
            key=lambda x: x[1],
            reverse=True
        )

        return sorted_results[:top_k]


# ===== 使用示例 =====

if __name__ == "__main__":
    # 1. 模拟检索结果
    bm25_results = [
        ("doc_A", 8.5),
        ("doc_B", 7.2),
        ("doc_C", 6.8),
        ("doc_F", 5.5)
    ]

    vector_results = [
        ("doc_D", 0.95),
        ("doc_A", 0.88),
        ("doc_E", 0.82),
        ("doc_B", 0.75)
    ]

    # 2. 创建RSF融合器（均等权重）
    print("=== RSF融合示例（均等权重50-50）===\n")
    rsf = RSFFusion(weights=[0.5, 0.5])

    # 3. 融合结果
    fused_results = rsf.fuse([bm25_results, vector_results], top_k=5)

    print("BM25检索结果：")
    for i, (doc_id, score) in enumerate(bm25_results, 1):
        print(f"{i}. {doc_id}: {score:.4f}")

    print("\n向量检索结果：")
    for i, (doc_id, score) in enumerate(vector_results, 1):
        print(f"{i}. {doc_id}: {score:.4f}")

    print("\nRSF融合结果：")
    for i, (doc_id, rsf_score) in enumerate(fused_results, 1):
        print(f"{i}. {doc_id}: {rsf_score:.6f}")

    # 4. 对比不同权重
    print("\n=== 对比不同权重 ===\n")

    weight_configs = [
        ([0.3, 0.7], "30% BM25 + 70% 向量"),
        ([0.5, 0.5], "50% BM25 + 50% 向量"),
        ([0.7, 0.3], "70% BM25 + 30% 向量")
    ]

    for weights, desc in weight_configs:
        rsf_test = RSFFusion(weights=weights)
        results = rsf_test.fuse([bm25_results, vector_results], top_k=3)
        print(f"{desc}:")
        for doc_id, score in results:
            print(f"  {doc_id}: {score:.6f}")
        print()

    # 5. 详细分析
    print("=== 详细分析（50-50权重）===\n")

    # BM25最高分
    bm25_max = max(score for _, score in bm25_results)
    print(f"BM25最高分: {bm25_max}")

    # 向量最高分
    vector_max = max(score for _, score in vector_results)
    print(f"向量最高分: {vector_max}")

    print("\n文档A的RSF分数计算：")
    print(f"  BM25相对分数: 8.5 / {bm25_max} = {8.5/bm25_max:.4f}")
    print(f"  向量相对分数: 0.88 / {vector_max} = {0.88/vector_max:.4f}")
    print(f"  RSF分数: 0.5 × {8.5/bm25_max:.4f} + 0.5 × {0.88/vector_max:.4f} = {0.5 * (8.5/bm25_max) + 0.5 * (0.88/vector_max):.6f}")

    print("\n文档B的RSF分数计算：")
    print(f"  BM25相对分数: 7.2 / {bm25_max} = {7.2/bm25_max:.4f}")
    print(f"  向量相对分数: 0.75 / {vector_max} = {0.75/vector_max:.4f}")
    print(f"  RSF分数: 0.5 × {7.2/bm25_max:.4f} + 0.5 × {0.75/vector_max:.4f} = {0.5 * (7.2/bm25_max) + 0.5 * (0.75/vector_max):.6f}")

    print("\n文档D的RSF分数计算：")
    print(f"  BM25相对分数: 无 = 0")
    print(f"  向量相对分数: 0.95 / {vector_max} = {0.95/vector_max:.4f}")
    print(f"  RSF分数: 0.5 × 0 + 0.5 × {0.95/vector_max:.4f} = {0.5 * (0.95/vector_max):.6f}")
```

**运行输出示例**：

```
=== RSF融合示例（均等权重50-50）===

BM25检索结果：
1. doc_A: 8.5000
2. doc_B: 7.2000
3. doc_C: 6.8000
4. doc_F: 5.5000

向量检索结果：
1. doc_D: 0.9500
2. doc_A: 0.8800
3. doc_E: 0.8200
4. doc_B: 0.7500

RSF融合结果：
1. doc_A: 0.963158  ← 在两个结果中都得分高
2. doc_D: 0.500000  ← 向量检索第1
3. doc_B: 0.818421  ← 在两个结果中都出现
4. doc_C: 0.400000  ← BM25检索第3
5. doc_E: 0.431579  ← 向量检索第3

=== 对比不同权重 ===

30% BM25 + 70% 向量:
  doc_A: 0.974211
  doc_D: 0.700000
  doc_B: 0.789474

50% BM25 + 50% 向量:
  doc_A: 0.963158
  doc_D: 0.500000
  doc_B: 0.818421

70% BM25 + 30% 向量:
  doc_A: 0.952105
  doc_B: 0.847368
  doc_C: 0.560000

=== 详细分析（50-50权重）===

BM25最高分: 8.5
向量最高分: 0.95

文档A的RSF分数计算：
  BM25相对分数: 8.5 / 8.5 = 1.0000
  向量相对分数: 0.88 / 0.95 = 0.9263
  RSF分数: 0.5 × 1.0000 + 0.5 × 0.9263 = 0.963158

文档B的RSF分数计算：
  BM25相对分数: 7.2 / 8.5 = 0.8471
  向量相对分数: 0.75 / 0.95 = 0.7895
  RSF分数: 0.5 × 0.8471 + 0.5 × 0.7895 = 0.818421

文档D的RSF分数计算：
  BM25相对分数: 无 = 0
  向量相对分数: 0.95 / 0.95 = 1.0000
  RSF分数: 0.5 × 0 + 0.5 × 1.0000 = 0.500000
```

---

## RSF vs RRF vs 加权融合

### 三种方法对比

| 维度 | RRF | RSF | 加权融合 |
|------|-----|-----|---------|
| **输入** | 排名位置 | 相对分数 | 绝对分数 |
| **归一化** | 不需要 | 自动（相对最高分） | 需要手动 |
| **参数** | k（1个） | 权重（N个） | λ + 归一化方法 |
| **鲁棒性** | 强 | 中等 | 弱 |
| **可解释性** | 中等 | 强 | 强 |
| **调优难度** | 简单 | 中等 | 复杂 |
| **2026主流度** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| **适用场景** | 通用 | MongoDB | 特定需求 |

### 适用场景

**RRF适合**：
- 通用混合检索场景
- 不同检索系统分数差异大
- 需要简单鲁棒的融合方法
- 生产环境标准配置

**RSF适合**：
- MongoDB Atlas Search用户
- 分数分布相对均匀
- 需要基于分数的融合
- MongoDB生态内应用

**加权融合适合**：
- 需要精细控制权重
- 检索系统分数可比
- 有充足调优资源
- 特定领域优化

---

## RSF的优势与局限

### 优势

1. **自动归一化**
   - 相对最高分自动归一化
   - 无需手动选择归一化方法
   - 简化配置

2. **直观易懂**
   - 相对分数概念直观
   - 计算逻辑简单
   - 易于理解和调试

3. **MongoDB集成**
   - MongoDB Atlas原生支持
   - 云服务无缝集成
   - 适合MongoDB生态

### 局限

1. **依赖分数分布**
   - 对最高分敏感
   - 极端值影响大
   - 分数分布不均时效果差

2. **应用场景有限**
   - 主要用于MongoDB
   - 其他平台支持少
   - 不如RRF通用

3. **鲁棒性中等**
   - 不如RRF鲁棒
   - 对分数尺度敏感
   - 需要调整权重

---

## 在RAG中的应用

### MongoDB Atlas RAG系统

**场景**：使用MongoDB Atlas构建RAG系统

**实现**：

```python
from pymongo import MongoClient
from typing import List, Dict

def mongodb_hybrid_search_rsf(
    query: str,
    query_embedding: List[float],
    collection,
    bm25_weight: float = 0.5,
    vector_weight: float = 0.5,
    top_k: int = 5
) -> List[Dict]:
    """
    MongoDB Atlas混合检索 + RSF融合

    Args:
        query: 查询文本
        query_embedding: 查询向量
        collection: MongoDB集合
        bm25_weight: BM25权重
        vector_weight: 向量权重
        top_k: 返回Top-K

    Returns:
        融合后的结果
    """
    # MongoDB Atlas Search混合检索
    pipeline = [
        {
            "$search": {
                "compound": {
                    "should": [
                        # BM25检索
                        {
                            "text": {
                                "query": query,
                                "path": "content"
                            }
                        },
                        # 向量检索
                        {
                            "knnBeta": {
                                "vector": query_embedding,
                                "path": "embedding",
                                "k": top_k * 2
                            }
                        }
                    ]
                },
                "scoreDetails": True
            }
        },
        {
            "$addFields": {
                # 计算RSF分数
                "rsfScore": {
                    "$add": [
                        {
                            "$multiply": [
                                bm25_weight,
                                {
                                    "$divide": [
                                        "$score.text",
                                        "$maxScore.text"
                                    ]
                                }
                            ]
                        },
                        {
                            "$multiply": [
                                vector_weight,
                                {
                                    "$divide": [
                                        "$score.knn",
                                        "$maxScore.knn"
                                    ]
                                }
                            ]
                        }
                    ]
                }
            }
        },
        {
            "$sort": {"rsfScore": -1}
        },
        {
            "$limit": top_k
        }
    ]

    results = list(collection.aggregate(pipeline))
    return results
```

---

## 2025-2026年最佳实践

### 1. 优先使用RRF

```python
# 推荐：优先使用RRF
# 除非你使用MongoDB Atlas，否则使用RRF

# MongoDB用户可以使用RSF
if platform == "MongoDB Atlas":
    use_rsf()
else:
    use_rrf()  # 推荐
```

### 2. MongoDB用户配置

```python
# MongoDB Atlas用户推荐配置
bm25_weight = 0.5
vector_weight = 0.5

# 根据场景调整
if query_type == "exact_match":
    bm25_weight = 0.7
    vector_weight = 0.3
elif query_type == "semantic":
    bm25_weight = 0.3
    vector_weight = 0.7
```

### 3. 监控分数分布

```python
# 监控最高分和分数分布
def monitor_score_distribution(results):
    """监控分数分布"""
    scores = [score for _, score in results]
    max_score = max(scores)
    min_score = min(scores)
    avg_score = sum(scores) / len(scores)

    print(f"最高分: {max_score:.4f}")
    print(f"最低分: {min_score:.4f}")
    print(f"平均分: {avg_score:.4f}")
    print(f"分数范围: {max_score - min_score:.4f}")
```

---

## 研究来源

1. **MongoDB: RRF and RSF Classic Hybrid Search Techniques**
   - [Medium Article](https://medium.com/mongodb/reciprocal-rank-fusion-and-relative-score-fusion-classic-hybrid-search-techniques-3bf91008b81d)
   - MongoDB官方介绍RRF和RSF的对比

2. **MongoDB Atlas Search Documentation**
   - [Official Docs](https://www.mongodb.com/docs/atlas/atlas-search/)
   - MongoDB Atlas Search官方文档

3. **Hybrid Search in MongoDB Atlas**
   - [Tutorial](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/hybrid-search/)
   - MongoDB混合检索教程

---

**版本**: v1.0
**最后更新**: 2026-02-16
**字数**: ~350行
