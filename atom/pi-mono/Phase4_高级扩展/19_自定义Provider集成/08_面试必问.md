# 面试必问

## 问题：如何在pi-mono中集成一个企业内部的LLM服务？该服务需要OAuth认证，且API格式与OpenAI不完全兼容。

### ❌ 普通回答

"我会创建一个Extension，实现OAuth登录和API调用，然后注册到pi-mono中。"

**问题：**
- 太笼统，没有具体细节
- 没有体现对pi-mono架构的理解
- 没有考虑实际工程问题

### ✅ 优秀回答（三层递进）

#### 第一层：技术方案（展示实现能力）

"我会采用Extension方式集成，具体分为三个部分：

**1. OAuth认证实现**
```typescript
oauth: {
  name: 'Company LLM (SSO)',

  async login(callbacks) {
    // Device Code Flow
    const deviceCode = await fetch('https://auth.company.com/device/code', {
      method: 'POST',
      body: new URLSearchParams({
        client_id: 'pi-agent',
        scope: 'llm.read llm.write'
      })
    })

    callbacks.onDeviceCode({
      userCode: deviceCode.user_code,
      verificationUri: deviceCode.verification_uri
    })

    // 轮询Token，处理authorization_pending和slow_down
    const token = await this.pollForToken(deviceCode.device_code, deviceCode.interval)

    return {
      access: token.access_token,
      refresh: token.refresh_token,
      expires: Date.now() + token.expires_in * 1000
    }
  },

  async refreshToken(credentials) {
    // 自动刷新机制
    const newToken = await fetch('https://auth.company.com/token', {
      method: 'POST',
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: credentials.refresh,
        client_id: 'pi-agent'
      })
    })
    return { ...credentials, access: newToken.access_token }
  },

  getApiKey(credentials) {
    return credentials.access
  }
}
```

**2. API适配**
如果API格式接近OpenAI，使用`api: 'openai-completions'`并配置`compat`选项：
```typescript
models: [{
  id: 'company-gpt-4',
  api: 'openai-completions',
  compat: {
    supportsDeveloperRole: false,  // 不支持developer角色
    maxTokensField: 'max_tokens'   // 使用max_tokens而非max_completion_tokens
  }
}]
```

如果API格式完全不同，实现`streamSimple`：
```typescript
streamSimple: async (model, context, options) => {
  const stream = createAssistantMessageEventStream()

  // 转换请求格式
  const apiRequest = this.convertToCompanyFormat(context)

  // 调用API并解析流式响应
  const response = await fetch(model.baseUrl, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${await this.getApiKey()}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(apiRequest)
  })

  // 解析SSE流并转换为统一事件格式
  for await (const event of this.parseSSE(response.body)) {
    stream.push(this.convertToUnifiedEvent(event))
  }

  return stream
}
```

**3. Extension注册**
```typescript
// ~/.pi/agent/extensions/company-llm/index.ts
export default function(pi) {
  pi.registerProvider('company-llm', {
    baseUrl: 'https://ai.company.com/v1',
    api: 'openai-completions',  // 或自定义streamSimple
    models: [...],
    oauth: { ... }
  })
}
```"

#### 第二层：工程考虑（展示工程能力）

"在实际实现中，我会特别注意以下工程问题：

**1. 安全性**
- Token存储：凭证自动存储在`~/.pi/agent/auth.json`，权限设置为600
- 环境变量：client_id等敏感信息通过环境变量管理
- HTTPS传输：确保所有OAuth请求使用HTTPS

**2. 错误处理**
- 网络错误：实现指数退避重试（1s, 2s, 4s, 8s）
- Token过期：自动调用refreshToken，对用户透明
- 授权拒绝：友好的错误提示，引导用户重新登录
- 超时处理：设备代码通常15分钟过期，需要提示用户

**3. 用户体验**
- 清晰的登录指引：显示验证URL和用户代码
- 进度反馈：使用`callbacks.onProgress()`显示等待状态
- 二维码支持：如果可能，生成二维码方便移动设备扫描
- 自动刷新：Token快过期时（提前5分钟）自动刷新

**4. 测试策略**
- Mock OAuth服务器：使用msw或nock模拟OAuth端点
- 测试各种错误场景：authorization_pending、slow_down、expired_token等
- 集成测试：使用测试环境的OAuth服务器
- 端到端测试：完整的登录→调用→刷新流程"

#### 第三层：架构理解（展示架构能力）

"这个方案体现了pi-mono的几个核心设计理念：

**1. 统一抽象**
- 无论底层API格式如何不同，都通过`AssistantMessageEventStream`统一输出
- Agent核心代码不需要关心具体Provider实现
- 符合依赖倒置原则（依赖抽象而非具体实现）

**2. 插件化设计**
- Extension系统实现了开闭原则（对扩展开放，对修改关闭）
- 新Provider的添加不影响现有功能
- 用户可以自己开发和分享Extension

**3. 渐进式复杂度**
- 简单场景：models.json配置（零代码）
- 中等复杂度：Extension + OAuth（数小时）
- 高级场景：自定义streamSimple（数天）
- 符合最小惊讶原则

**4. 安全性内置**
- OAuth凭证自动管理（存储、刷新、过期处理）
- 不需要用户手动处理Token
- 降低了安全风险

**对比其他方案：**
- 如果修改源码：失去可扩展性，无法支持私有Provider
- 如果没有统一抽象：每个Provider都需要修改Agent核心代码
- 如果没有OAuth支持：企业场景无法使用

这个设计让pi-mono既能支持公开的LLM服务，也能支持企业内部的私有服务，同时保持核心代码的简洁性和可维护性。"

---

## 评分标准

### 初级（40-60分）
- 知道使用Extension
- 能说出OAuth的基本概念
- 但缺乏具体实现细节

### 中级（60-80分）
- 能写出完整的OAuth实现代码
- 考虑了错误处理和用户体验
- 但缺乏架构层面的理解

### 高级（80-100分）
- 完整的技术方案（代码 + 工程考虑）
- 深入理解pi-mono的架构设计
- 能对比不同方案的优劣
- 体现了统一抽象、插件化、渐进式复杂度等设计理念

---

## 延伸问题

### Q1: 如果企业OAuth服务器不支持Device Code Flow，只支持Authorization Code Flow（需要浏览器重定向），怎么办？

**答案：**
使用`callbacks.onAuth()`打开浏览器：
```typescript
async login(callbacks) {
  // 启动本地回调服务器
  const callbackServer = await startCallbackServer()

  // 构造授权URL
  const authUrl = `https://auth.company.com/authorize?` +
    `client_id=pi-agent&` +
    `redirect_uri=http://localhost:${callbackServer.port}/callback&` +
    `response_type=code&` +
    `scope=llm.read llm.write`

  // 打开浏览器
  callbacks.onAuth({ url: authUrl })

  // 等待回调
  const code = await callbackServer.waitForCode()

  // 交换Token
  const token = await exchangeCodeForToken(code)

  return { access: token.access_token, ... }
}
```

### Q2: 如何处理API速率限制（Rate Limiting）？

**答案：**
在streamSimple中实现重试和退避：
```typescript
async function callWithRetry(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn()
    } catch (error) {
      if (error.status === 429) {  // Rate limit
        const retryAfter = error.headers['retry-after'] || Math.pow(2, i)
        await sleep(retryAfter * 1000)
        continue
      }
      throw error
    }
  }
  throw new Error('Max retries exceeded')
}
```

### Q3: 如何支持多租户场景（不同用户使用不同的OAuth凭证）？

**答案：**
pi-mono的OAuth凭证是按Provider存储的，天然支持多租户：
- 每个用户有自己的`~/.pi/agent/auth.json`
- 不同用户登录时获取各自的Token
- `getApiKey()`返回当前用户的access token

如果需要在同一台机器上支持多用户，可以使用环境变量区分：
```bash
PI_AUTH_FILE=~/.pi/agent/auth-user1.json pi
PI_AUTH_FILE=~/.pi/agent/auth-user2.json pi
```
