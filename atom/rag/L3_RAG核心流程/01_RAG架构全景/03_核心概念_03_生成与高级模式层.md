# 核心概念 - 生成与高级模式层（5个组件）

生成层和高级模式层是RAG系统的顶层，负责答案生成和复杂场景处理。

---

## 组件10：Prompt工程

**一句话定义：** Prompt工程负责设计LLM的输入格式，将检索结果和用户查询组织成高质量的提示词。

### 核心技术

1. **上下文注入**：如何组织检索到的文档
2. **指令设计**：如何引导LLM生成答案
3. **Few-shot示例**：提供参考答案格式

### 代码示例

```python
def build_rag_prompt(query: str, context_docs: List[str]) -> str:
    """构建RAG Prompt"""
    context = "\n\n".join([f"文档{i+1}:\n{doc}" for i, doc in enumerate(context_docs)])

    prompt = f"""你是一个专业的AI助手，请基于提供的上下文回答用户问题。

上下文信息：
{context}

用户问题：{query}

回答要求：
1. 仅基于上下文信息回答
2. 如果上下文中没有相关信息，明确说明
3. 引用具体的文档编号
4. 保持简洁准确

答案："""
    return prompt
```

---

## 组件11：生成器（LLM）

**一句话定义：** 生成器是LLM调用层，负责将Prompt转换为最终答案。

### 核心功能

1. **模型选择**：GPT-4、Claude、Gemini
2. **参数配置**：temperature、max_tokens
3. **流式输出**：提升用户体验

### 代码示例

```python
from openai import OpenAI

client = OpenAI()

def generate_answer(prompt: str, stream: bool = False):
    """生成答案"""
    response = client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.7,
        max_tokens=500,
        stream=stream
    )

    if stream:
        for chunk in response:
            if chunk.choices[0].delta.content:
                yield chunk.choices[0].delta.content
    else:
        return response.choices[0].message.content
```

---

## 组件12：Agentic RAG

**一句话定义：** Agentic RAG赋予RAG系统自主决策能力，可以规划多步检索、使用工具、反思结果。

### 核心能力

1. **自主规划**：根据查询复杂度决定检索步骤
2. **多跳推理**：逐步深入检索
3. **工具使用**：调用外部API、计算器等
4. **反思机制**：评估结果质量并调整策略

### 架构示例

```python
class AgenticRAG:
    def __init__(self, vectorstore, llm):
        self.vectorstore = vectorstore
        self.llm = llm
        self.tools = {
            "search": self.search_tool,
            "calculate": self.calculate_tool
        }

    def answer(self, query: str) -> str:
        """自主回答查询"""
        # 1. 规划步骤
        plan = self.create_plan(query)

        # 2. 执行步骤
        context = []
        for step in plan:
            if step["action"] == "search":
                results = self.search_tool(step["query"])
                context.extend(results)
            elif step["action"] == "calculate":
                result = self.calculate_tool(step["expression"])
                context.append(f"计算结果: {result}")

        # 3. 反思与调整
        if not self.is_sufficient(context, query):
            # 生成新的查询
            followup = self.generate_followup(context, query)
            more_results = self.search_tool(followup)
            context.extend(more_results)

        # 4. 生成最终答案
        return self.generate_final_answer(context, query)
```

### 在RAG开发中

- **适用场景**：复杂推理、多步骤问题、需要工具调用
- **效果提升**：处理复杂查询的成功率提升40-60%
- **成本**：LLM调用次数增加3-5倍

---

## 组件13：GraphRAG

**一句话定义：** GraphRAG通过构建知识图谱增强RAG系统，支持结构化知识检索和全局理解。

### 核心技术

1. **实体关系提取**：从文档中提取实体和关系
2. **社区检测**：发现主题聚类
3. **层次化摘要**：生成不同粒度的摘要
4. **图谱检索**：支持全局查询和局部查询

### 架构示例

```python
from graphrag import GraphRAG

# 1. 构建知识图谱
graph = GraphRAG()

# 从文档中提取实体和关系
for doc in documents:
    entities = extract_entities(doc)
    relations = extract_relations(doc)

    for entity in entities:
        graph.add_entity(entity["name"], type=entity["type"])

    for relation in relations:
        graph.add_relation(
            relation["source"],
            relation["type"],
            relation["target"]
        )

# 2. 社区检测
communities = graph.detect_communities()

# 3. 生成社区摘要
for community in communities:
    summary = generate_community_summary(community)
    graph.add_community_summary(community.id, summary)

# 4. 查询
# 全局查询（使用社区摘要）
global_answer = graph.query(
    "What are the main themes in the documents?",
    method="global"
)

# 局部查询（使用实体检索）
local_answer = graph.query(
    "What is the relationship between Python and FastAPI?",
    method="local"
)
```

### GraphRAG vs 传统RAG

| 维度 | 传统RAG | GraphRAG |
|------|---------|----------|
| **检索方式** | 向量相似度 | 图谱遍历 + 向量 |
| **全局理解** | 弱 | 强（社区摘要） |
| **关系理解** | 无 | 强（显式关系） |
| **适用场景** | 简单问答 | 复杂推理、全局分析 |
| **成本** | 低 | 高（需要图谱构建） |

### 在RAG开发中

- **适用场景**：需要理解文档间关系、全局分析、多跳推理
- **效果提升**：复杂查询准确率提升30-50%
- **实现**：Microsoft GraphRAG、Neo4j + LangChain

---

## 组件14：评估与监控

**一句话定义：** 评估与监控负责持续追踪RAG系统质量，发现问题并指导优化。

### 核心指标

**检索质量：**
- Recall@K：前K个结果中包含相关文档的比例
- Precision@K：前K个结果中相关文档的比例
- MRR（Mean Reciprocal Rank）：第一个相关文档的排名倒数

**生成质量：**
- Faithfulness：答案是否忠实于上下文
- Answer Relevancy：答案是否回答了问题
- Context Relevancy：检索的上下文是否相关

**端到端质量：**
- RAGAS框架：综合评估检索和生成质量

### 代码示例

```python
from ragas import evaluate
from ragas.metrics import (
    faithfulness,
    answer_relevancy,
    context_relevancy,
    context_recall
)

# 准备评估数据
eval_dataset = {
    "question": ["什么是RAG？", "如何优化检索？"],
    "answer": [answer1, answer2],
    "contexts": [[doc1, doc2], [doc3, doc4]],
    "ground_truth": [truth1, truth2]
}

# 评估
results = evaluate(
    dataset=eval_dataset,
    metrics=[
        faithfulness,
        answer_relevancy,
        context_relevancy,
        context_recall
    ]
)

print(f"Faithfulness: {results['faithfulness']:.2f}")
print(f"Answer Relevancy: {results['answer_relevancy']:.2f}")
print(f"Context Relevancy: {results['context_relevancy']:.2f}")
print(f"Context Recall: {results['context_recall']:.2f}")
```

### 监控策略

1. **离线评估**：定期在测试集上评估
2. **在线监控**：实时追踪关键指标
3. **人工抽样**：定期人工检查答案质量
4. **用户反馈**：收集用户满意度

---

## 生成与高级模式层总结

**5个组件的协同工作：**

```
检索结果 → Prompt工程 → 生成器 → 答案
              ↓
         Agentic RAG（复杂场景）
              ↓
         GraphRAG（结构化知识）
              ↓
         评估监控（质量保证）
```

**关键要点：**
1. **Prompt工程**：决定生成质量的关键
2. **生成器**：选择合适的LLM和参数
3. **Agentic RAG**：处理复杂推理场景
4. **GraphRAG**：增强结构化知识理解
5. **评估监控**：持续保证系统质量

**架构演进路径：**
```
基础RAG → 优化检索 → Prompt优化 → Agentic RAG → GraphRAG
  ↓          ↓           ↓            ↓           ↓
 60%       75%         80%          85%         90%
准确率    准确率      准确率       准确率      准确率
```

**下一步：** 学习实战代码，动手实现完整的RAG系统
