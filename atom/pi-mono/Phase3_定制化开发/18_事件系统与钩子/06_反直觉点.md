# 反直觉点

揭示事件系统与钩子的 3 个常见误区，帮助你避免踩坑。

---

## 误区 1：事件监听器会阻塞 Agent 运行 ❌

### 错误观点

"在事件监听器中执行耗时操作会阻塞 Agent 运行，导致性能问题。"

### 为什么错？

**正确理解：**
- 同步监听器确实会阻塞，但影响有限
- 异步监听器不会阻塞主流程
- pi-mono 的事件系统会自动捕获错误，不会中断 Agent

**实际情况：**
```typescript
// ❌ 误解：这会阻塞 Agent
pi.on('tool_call', async (tool, args) => {
  await longRunningOperation(); // 异步操作不会阻塞
});

// ✅ 正确理解：异步操作不阻塞主流程
pi.on('tool_call', async (tool, args) => {
  // 这个异步操作会在后台执行，不阻塞 Agent
  logToDatabase(tool, args).catch(console.error);
});
```

**性能测试：**
```typescript
// 测试：监听器对性能的影响
pi.on('tool_call', async (tool, args) => {
  const start = Date.now();
  await fetch('https://api.example.com/log', {
    method: 'POST',
    body: JSON.stringify({ tool: tool.name })
  });
  console.log('Logging took:', Date.now() - start, 'ms');
  // 输出：Logging took: 150ms
  // 但 Agent 继续运行，不受影响
});
```

### 为什么人们容易这样错？

**心理原因：**
1. **类比错误**：将事件监听器类比为同步函数调用
2. **经验迁移**：在其他框架中遇到过阻塞问题
3. **过度担心**：担心性能问题而不敢使用

**认知偏差：**
- 人们倾向于认为"监听器 = 阻塞"
- 忽略了异步编程的特性
- 没有实际测试就下结论

### 正确理解

**核心原则：**
1. **异步监听器不阻塞**：使用 async/await 的监听器在后台执行
2. **同步监听器影响有限**：只影响当前事件的处理，不影响整体流程
3. **错误自动捕获**：监听器中的错误不会中断 Agent

**最佳实践：**
```typescript
// ✅ 推荐：异步处理，不阻塞
pi.on('tool_call', async (tool, args) => {
  // 异步操作在后台执行
  logToDatabase(tool, args).catch(console.error);
});

// ✅ 推荐：快速同步操作
pi.on('tool_call', (tool, args) => {
  // 快速操作，影响可忽略
  console.log('Tool called:', tool.name);
});

// ⚠️ 避免：耗时同步操作
pi.on('tool_call', (tool, args) => {
  // 这会阻塞，但只影响当前事件处理
  const result = syncExpensiveOperation();
});
```

**引用：Node.js best practices (2025-2026)**

根据 Node.js best practices [1]，EventEmitter 的错误处理和性能优化建议：

- 使用异步监听器处理耗时操作
- 在监听器中捕获错误，避免未处理的异常
- 避免在监听器中执行同步阻塞操作

---

## 误区 2：Spawn Hooks 可以修改所有工具调用 ❌

### 错误观点

"Spawn Hooks 可以拦截和修改所有工具调用（read、write、edit、bash 等）。"

### 为什么错？

**正确理解：**
- Spawn Hooks **只拦截 bash 工具**
- 其他工具（read、write、edit）不会触发 Spawn Hooks
- 如果要监控所有工具，应该使用 `tool_call` 事件

**实际情况：**
```typescript
// ❌ 误解：这会拦截所有工具
pi.registerSpawnHook((command, cwd, env) => {
  console.log('Tool called'); // 只在 bash 工具时触发
  return { command, cwd, env };
});

// ✅ 正确理解：只拦截 bash 工具
pi.registerSpawnHook((command, cwd, env) => {
  console.log('Bash command:', command); // 只有 bash 命令
  return { command, cwd, env };
});

// ✅ 监控所有工具：使用 tool_call 事件
pi.on('tool_call', (tool, args) => {
  console.log('Tool called:', tool.name); // 所有工具
  // tool.name 可能是：bash, read, write, edit, etc.
});
```

**对比测试：**
```typescript
// Spawn Hook：只记录 bash 命令
pi.registerSpawnHook((command, cwd, env) => {
  console.log('[SpawnHook] Bash:', command);
  return { command, cwd, env };
});

// tool_call 事件：记录所有工具
pi.on('tool_call', (tool, args) => {
  console.log('[tool_call] Tool:', tool.name);
});

// 当 Agent 执行 read 工具时：
// 输出：[tool_call] Tool: read
// 不输出：[SpawnHook] ...

// 当 Agent 执行 bash 工具时：
// 输出：[tool_call] Tool: bash
// 输出：[SpawnHook] Bash: ls -la
```

### 为什么人们容易这样错？

**心理原因：**
1. **名称误导**："Spawn" 听起来像"生成"，容易联想到所有工具
2. **功能期望**：希望有一个统一的拦截点
3. **文档理解**：没有仔细阅读文档说明

**认知偏差：**
- 人们倾向于认为"Hook = 拦截所有"
- 忽略了 Spawn 的特定含义（进程生成）
- 没有实际测试就假设

### 正确理解

**核心原则：**
1. **Spawn Hooks 只拦截 bash**：因为 bash 工具会 spawn 子进程
2. **其他工具不触发 Spawn Hooks**：read、write、edit 是直接文件操作
3. **监控所有工具用 tool_call**：这是通用的工具调用事件

**工具分类：**
| 工具类型 | 触发 Spawn Hook | 触发 tool_call |
|---------|----------------|---------------|
| bash | ✅ 是 | ✅ 是 |
| read | ❌ 否 | ✅ 是 |
| write | ❌ 否 | ✅ 是 |
| edit | ❌ 否 | ✅ 是 |

**正确用法：**
```typescript
// ✅ 拦截 bash 命令：使用 Spawn Hook
pi.registerSpawnHook((command, cwd, env) => {
  env.MY_VAR = 'value';
  return { command, cwd, env };
});

// ✅ 监控所有工具：使用 tool_call
pi.on('tool_call', (tool, args) => {
  if (tool.name === 'bash') {
    console.log('Bash command:', args.command);
  } else if (tool.name === 'read') {
    console.log('Reading file:', args.file_path);
  } else if (tool.name === 'write') {
    console.log('Writing file:', args.file_path);
  }
});
```

**引用：Reddit 讨论 - spawn 性能问题 (2025)**

根据 Reddit 上关于 Node.js spawn 性能的讨论 [2]，spawn 操作的性能特点：

- spawn 创建子进程有一定开销
- 频繁 spawn 会影响性能
- 应该在 Spawn Hook 中避免耗时操作

---

## 误区 3：before_agent_start 可以阻止 Agent 启动 ❌

### 错误观点

"在 `before_agent_start` 钩子中抛出错误或返回 false 可以阻止 Agent 启动。"

### 为什么错？

**正确理解：**
- `before_agent_start` 只能修改消息，不能阻止启动
- 抛出错误会被捕获，不会中断 Agent
- 没有返回值的概念，只能修改 messages 数组

**实际情况：**
```typescript
// ❌ 误解：这会阻止 Agent 启动
pi.on('before_agent_start', (messages) => {
  throw new Error('Stop!'); // 错误会被捕获，Agent 继续运行
});

// ❌ 误解：返回 false 会阻止启动
pi.on('before_agent_start', (messages) => {
  return false; // 返回值被忽略
});

// ✅ 正确理解：只能修改消息
pi.on('before_agent_start', (messages) => {
  // 可以修改消息数组
  messages.push({
    role: 'system',
    content: 'Custom instruction'
  });

  // 可以清空消息（但 Agent 仍会启动）
  messages.length = 0;
});
```

**测试验证：**
```typescript
// 测试：抛出错误是否阻止启动
pi.on('before_agent_start', (messages) => {
  console.log('before_agent_start: Throwing error');
  throw new Error('Attempting to stop Agent');
});

pi.on('agent_start', () => {
  console.log('agent_start: Agent started anyway');
});

// 输出：
// before_agent_start: Throwing error
// [Error] Error in before_agent_start handler: Attempting to stop Agent
// agent_start: Agent started anyway
```

### 为什么人们容易这样错？

**心理原因：**
1. **命名误导**："before" 暗示可以阻止后续操作
2. **经验迁移**：在其他框架中 before 钩子可以阻止
3. **期望功能**：希望有一个"守门员"机制

**认知偏差：**
- 人们倾向于认为"before = 可以阻止"
- 类比到 Express 的 middleware（可以不调用 next()）
- 忽略了 pi-mono 的设计理念

### 正确理解

**核心原则：**
1. **before_agent_start 是修改点，不是阻止点**
2. **所有事件监听器都不能阻止流程**
3. **如果需要条件启动，应该在 Extension 外部控制**

**设计理念：**
- pi-mono 的事件系统是**观察者模式**，不是**拦截器模式**
- 事件监听器用于**增强功能**，不是**控制流程**
- 流程控制应该在更高层次实现

**正确用法：**
```typescript
// ✅ 修改消息
pi.on('before_agent_start', (messages) => {
  messages.push({
    role: 'system',
    content: 'Custom instruction'
  });
});

// ✅ 条件修改
pi.on('before_agent_start', (messages) => {
  if (shouldAddContext()) {
    messages.push({
      role: 'system',
      content: loadContext()
    });
  }
});

// ✅ 清空消息（极端情况）
pi.on('before_agent_start', (messages) => {
  // 清空所有消息
  messages.length = 0;
  // Agent 仍会启动，但没有消息
});
```

**如果真的需要阻止 Agent 启动：**
```typescript
// ❌ 不能在 before_agent_start 中阻止
pi.on('before_agent_start', (messages) => {
  // 无法阻止
});

// ✅ 应该在 Extension 外部控制
export default function conditionalExtension(pi: ExtensionAPI) {
  const shouldRun = checkCondition();

  if (!shouldRun) {
    console.log('Condition not met, Extension disabled');
    return; // 不注册任何监听器
  }

  // 只有条件满足才注册监听器
  pi.on('before_agent_start', (messages) => {
    // ...
  });
}
```

---

## 额外误区：事件名称可以随意命名

### 错误观点

"自定义事件的名称可以随意命名，没有规范。"

### 为什么错？

**正确理解：**
- 虽然技术上可以随意命名，但应该遵循命名约定
- 好的命名提高代码可维护性
- 团队协作需要统一的命名规范

**不良命名示例：**
```typescript
// ❌ 不推荐：含义不清
pi.events.emit('done');
pi.events.emit('ok');
pi.events.emit('event1');

// ❌ 不推荐：不一致的命名风格
pi.events.emit('dataReady');      // camelCase
pi.events.emit('task_completed'); // snake_case
pi.events.emit('UserLoggedIn');   // PascalCase
```

**良好命名示例：**
```typescript
// ✅ 推荐：使用 kebab-case
pi.events.emit('data-ready');
pi.events.emit('task-completed');
pi.events.emit('user-logged-in');

// ✅ 推荐：使用命名空间
pi.events.emit('auth:login-success');
pi.events.emit('data:loaded');
pi.events.emit('ui:updated');

// ✅ 推荐：使用动词-名词结构
pi.events.emit('data-loaded');      // 动词-名词
pi.events.emit('task-completed');   // 动词-名词
pi.events.emit('user-authenticated'); // 动词-名词
```

### 正确理解

**命名规范：**
1. **使用 kebab-case**：`data-ready`，不是 `dataReady`
2. **使用命名空间**：`auth:login-success`，不是 `login-success`
3. **使用动词-名词**：`data-loaded`，不是 `load-data`
4. **描述性名称**：`user-authentication-completed`，不是 `done`

---

## 误区总结

| 误区 | 错误观点 | 正确理解 |
|------|---------|---------|
| **误区 1** | 事件监听器会阻塞 Agent | 异步监听器不阻塞，错误自动捕获 |
| **误区 2** | Spawn Hooks 拦截所有工具 | 只拦截 bash，其他工具用 tool_call |
| **误区 3** | before_agent_start 可以阻止启动 | 只能修改消息，不能阻止流程 |

---

## 避坑指南

### 1. 性能优化

```typescript
// ✅ 推荐：异步处理
pi.on('tool_call', async (tool, args) => {
  logToDatabase(tool, args).catch(console.error);
});

// ❌ 避免：同步阻塞
pi.on('tool_call', (tool, args) => {
  syncExpensiveOperation();
});
```

### 2. 工具监控

```typescript
// ✅ 推荐：使用 tool_call 监控所有工具
pi.on('tool_call', (tool, args) => {
  console.log('Tool:', tool.name);
});

// ❌ 误解：Spawn Hook 监控所有工具
pi.registerSpawnHook((command, cwd, env) => {
  // 只有 bash 工具会触发
  return { command, cwd, env };
});
```

### 3. 流程控制

```typescript
// ✅ 推荐：在 Extension 外部控制
export default function myExtension(pi: ExtensionAPI) {
  if (!shouldRun()) {
    return; // 不注册监听器
  }

  pi.on('before_agent_start', (messages) => {
    // 修改消息
  });
}

// ❌ 误解：在 before_agent_start 中阻止
pi.on('before_agent_start', (messages) => {
  throw new Error('Stop!'); // 无法阻止
});
```

### 4. 命名规范

```typescript
// ✅ 推荐：遵循命名约定
pi.events.emit('auth:login-success');
pi.events.emit('data:loaded');

// ❌ 避免：随意命名
pi.events.emit('done');
pi.events.emit('ok');
```

---

## 参考资料

[1] Node.js best practices, https://github.com/goldbergyoni/nodebestpractices, 2025-2026 持续更新

[2] 分布式 Node.js Event Emitter, Reddit 讨论, 2025年8月

---

**版本：** v1.0
**最后更新：** 2026-02-21
**维护者：** Claude Code
