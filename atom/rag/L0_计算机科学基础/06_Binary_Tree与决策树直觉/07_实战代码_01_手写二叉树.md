# 手写二叉树 - 实战代码

> 从零实现 TreeNode 类、插入、查找

---

## 完整代码

```python
"""
手写二叉树实现
演示：从零实现二叉树的基本操作
"""

class TreeNode:
    """二叉树节点"""
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

class BinaryTree:
    """二叉树类"""
    def __init__(self):
        self.root = None
    
    # ===== 1. 插入操作 =====
    def insert(self, val):
        """插入节点（层序插入）"""
        if not self.root:
            self.root = TreeNode(val)
            return
        
        from collections import deque
        queue = deque([self.root])
        
        while queue:
            node = queue.popleft()
            
            if not node.left:
                node.left = TreeNode(val)
                return
            else:
                queue.append(node.left)
            
            if not node.right:
                node.right = TreeNode(val)
                return
            else:
                queue.append(node.right)
    
    # ===== 2. 查找操作 =====
    def search(self, val):
        """查找节点"""
        return self._search_recursive(self.root, val)
    
    def _search_recursive(self, node, val):
        if not node:
            return False
        if node.val == val:
            return True
        return (self._search_recursive(node.left, val) or 
                self._search_recursive(node.right, val))
    
    # ===== 3. 遍历操作 =====
    def preorder(self):
        """前序遍历"""
        result = []
        self._preorder_recursive(self.root, result)
        return result
    
    def _preorder_recursive(self, node, result):
        if not node:
            return
        result.append(node.val)
        self._preorder_recursive(node.left, result)
        self._preorder_recursive(node.right, result)
    
    def inorder(self):
        """中序遍历"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node, result):
        if not node:
            return
        self._inorder_recursive(node.left, result)
        result.append(node.val)
        self._inorder_recursive(node.right, result)
    
    def postorder(self):
        """后序遍历"""
        result = []
        self._postorder_recursive(self.root, result)
        return result
    
    def _postorder_recursive(self, node, result):
        if not node:
            return
        self._postorder_recursive(node.left, result)
        self._postorder_recursive(node.right, result)
        result.append(node.val)
    
    def levelorder(self):
        """层序遍历"""
        if not self.root:
            return []
        
        from collections import deque
        result = []
        queue = deque([self.root])
        
        while queue:
            node = queue.popleft()
            result.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        return result
    
    # ===== 4. 树的属性 =====
    def height(self):
        """计算树的高度"""
        return self._height_recursive(self.root)
    
    def _height_recursive(self, node):
        if not node:
            return 0
        return max(self._height_recursive(node.left),
                   self._height_recursive(node.right)) + 1
    
    def count_nodes(self):
        """计算节点数"""
        return self._count_nodes_recursive(self.root)
    
    def _count_nodes_recursive(self, node):
        if not node:
            return 0
        return 1 + self._count_nodes_recursive(node.left) + \
               self._count_nodes_recursive(node.right)
    
    def count_leaves(self):
        """计算叶子节点数"""
        return self._count_leaves_recursive(self.root)
    
    def _count_leaves_recursive(self, node):
        if not node:
            return 0
        if not node.left and not node.right:
            return 1
        return (self._count_leaves_recursive(node.left) +
                self._count_leaves_recursive(node.right))
    
    # ===== 5. 打印树结构 =====
    def print_tree(self):
        """打印树的结构"""
        self._print_tree_recursive(self.root, 0, "Root: ")
    
    def _print_tree_recursive(self, node, level, prefix):
        if node:
            print(" " * (level * 4) + prefix + str(node.val))
            if node.left or node.right:
                if node.left:
                    self._print_tree_recursive(node.left, level + 1, "L--- ")
                else:
                    print(" " * ((level + 1) * 4) + "L--- None")
                
                if node.right:
                    self._print_tree_recursive(node.right, level + 1, "R--- ")
                else:
                    print(" " * ((level + 1) * 4) + "R--- None")

# ===== 测试代码 =====
if __name__ == "__main__":
    print("=== 手写二叉树测试 ===\n")
    
    # 1. 创建二叉树
    tree = BinaryTree()
    
    # 2. 插入节点
    print("插入节点: 1, 2, 3, 4, 5")
    for val in [1, 2, 3, 4, 5]:
        tree.insert(val)
    
    # 3. 打印树结构
    print("\n树结构:")
    tree.print_tree()
    
    # 4. 遍历
    print("\n前序遍历:", tree.preorder())
    print("中序遍历:", tree.inorder())
    print("后序遍历:", tree.postorder())
    print("层序遍历:", tree.levelorder())
    
    # 5. 查找
    print("\n查找节点 3:", tree.search(3))
    print("查找节点 6:", tree.search(6))
    
    # 6. 树的属性
    print("\n树的高度:", tree.height())
    print("节点数:", tree.count_nodes())
    print("叶子节点数:", tree.count_leaves())
```

## 运行输出

```
=== 手写二叉树测试 ===

插入节点: 1, 2, 3, 4, 5

树结构:
Root: 1
    L--- 2
        L--- 4
        R--- 5
    R--- 3

前序遍历: [1, 2, 4, 5, 3]
中序遍历: [4, 2, 5, 1, 3]
后序遍历: [4, 5, 2, 3, 1]
层序遍历: [1, 2, 3, 4, 5]

查找节点 3: True
查找节点 6: False

树的高度: 3
节点数: 5
叶子节点数: 3
```

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+
