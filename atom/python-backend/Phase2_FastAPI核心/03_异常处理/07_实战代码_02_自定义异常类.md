# 实战代码2：自定义异常类

> 完整可运行的自定义异常类示例，封装业务错误

---

## 示例概述

本示例演示：
1. 创建自定义异常类封装业务错误
2. 注册异常处理器统一处理
3. 异常类携带上下文信息
4. 统一的错误响应格式

---

## 完整代码

```python
"""
FastAPI 自定义异常类示例
演示：如何创建和使用自定义异常类
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional
import logging
import uuid

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="自定义异常类示例")

# ===== 自定义异常类 =====

class AppException(Exception):
    """应用异常基类"""
    def __init__(self, message: str, code: str = None):
        self.message = message
        self.code = code or self.__class__.__name__
        super().__init__(self.message)

class UserNotFoundError(AppException):
    """用户不存在异常"""
    def __init__(self, user_id: int):
        self.user_id = user_id
        super().__init__(
            message=f"用户 {user_id} 不存在",
            code="USER_NOT_FOUND"
        )

class EmailAlreadyExistsError(AppException):
    """邮箱已存在异常"""
    def __init__(self, email: str):
        self.email = email
        super().__init__(
            message=f"邮箱 {email} 已被注册",
            code="EMAIL_ALREADY_EXISTS"
        )

class InsufficientBalanceError(AppException):
    """余额不足异常"""
    def __init__(self, user_id: int, balance: float, required: float):
        self.user_id = user_id
        self.balance = balance
        self.required = required
        super().__init__(
            message=f"余额不足，当前余额: {balance}，需要: {required}",
            code="INSUFFICIENT_BALANCE"
        )

class PermissionDeniedError(AppException):
    """权限不足异常"""
    def __init__(self, user_id: int, action: str):
        self.user_id = user_id
        self.action = action
        super().__init__(
            message=f"用户 {user_id} 无权执行操作: {action}",
            code="PERMISSION_DENIED"
        )

class ResourceConflictError(AppException):
    """资源冲突异常"""
    def __init__(self, resource_type: str, resource_id: str):
        self.resource_type = resource_type
        self.resource_id = resource_id
        super().__init__(
            message=f"{resource_type} {resource_id} 已存在或冲突",
            code="RESOURCE_CONFLICT"
        )

# ===== 统一错误响应格式 =====

def create_error_response(
    status_code: int,
    error: str,
    code: str,
    details: dict = None,
    request_id: str = None
):
    """创建统一的错误响应"""
    content = {
        "success": False,
        "error": error,
        "code": code,
        "timestamp": datetime.utcnow().isoformat()
    }

    if details:
        content["details"] = details

    if request_id:
        content["request_id"] = request_id

    return JSONResponse(status_code=status_code, content=content)

# ===== 异常处理器 =====

@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    """处理用户不存在异常"""
    logger.warning(f"用户不存在: {exc.user_id}")
    return create_error_response(
        status_code=404,
        error=exc.message,
        code=exc.code,
        details={"user_id": exc.user_id},
        request_id=getattr(request.state, "request_id", None)
    )

@app.exception_handler(EmailAlreadyExistsError)
async def email_exists_handler(request: Request, exc: EmailAlreadyExistsError):
    """处理邮箱已存在异常"""
    logger.warning(f"邮箱已存在: {exc.email}")
    return create_error_response(
        status_code=409,
        error=exc.message,
        code=exc.code,
        details={"email": exc.email},
        request_id=getattr(request.state, "request_id", None)
    )

@app.exception_handler(InsufficientBalanceError)
async def insufficient_balance_handler(request: Request, exc: InsufficientBalanceError):
    """处理余额不足异常"""
    logger.warning(f"余额不足: user_id={exc.user_id}, balance={exc.balance}, required={exc.required}")
    return create_error_response(
        status_code=400,
        error=exc.message,
        code=exc.code,
        details={
            "user_id": exc.user_id,
            "balance": exc.balance,
            "required": exc.required,
            "shortage": exc.required - exc.balance
        },
        request_id=getattr(request.state, "request_id", None)
    )

@app.exception_handler(PermissionDeniedError)
async def permission_denied_handler(request: Request, exc: PermissionDeniedError):
    """处理权限不足异常"""
    logger.warning(f"权限不足: user_id={exc.user_id}, action={exc.action}")
    return create_error_response(
        status_code=403,
        error=exc.message,
        code=exc.code,
        details={
            "user_id": exc.user_id,
            "action": exc.action
        },
        request_id=getattr(request.state, "request_id", None)
    )

@app.exception_handler(ResourceConflictError)
async def resource_conflict_handler(request: Request, exc: ResourceConflictError):
    """处理资源冲突异常"""
    logger.warning(f"资源冲突: {exc.resource_type} {exc.resource_id}")
    return create_error_response(
        status_code=409,
        error=exc.message,
        code=exc.code,
        details={
            "resource_type": exc.resource_type,
            "resource_id": exc.resource_id
        },
        request_id=getattr(request.state, "request_id", None)
    )

@app.exception_handler(AppException)
async def app_exception_handler(request: Request, exc: AppException):
    """处理所有应用异常（兜底）"""
    logger.error(f"应用异常: {exc.message}")
    return create_error_response(
        status_code=500,
        error=exc.message,
        code=exc.code,
        request_id=getattr(request.state, "request_id", None)
    )

# ===== 模拟数据库 =====
users_db = {
    1: {"id": 1, "name": "Alice", "email": "alice@example.com", "balance": 100.0, "role": "user"},
    2: {"id": 2, "name": "Bob", "email": "bob@example.com", "balance": 500.0, "role": "admin"},
}

orders_db = {}

# ===== Pydantic 模型 =====
class UserCreate(BaseModel):
    name: str
    email: EmailStr

class TransferRequest(BaseModel):
    from_user_id: int
    to_user_id: int
    amount: float

class OrderCreate(BaseModel):
    user_id: int
    product_name: str
    price: float

# ===== 路由示例 =====

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    """获取用户信息"""
    logger.info(f"获取用户: {user_id}")

    user = users_db.get(user_id)
    if not user:
        raise UserNotFoundError(user_id)

    return user

@app.post("/users")
async def create_user(user: UserCreate):
    """创建用户"""
    logger.info(f"创建用户: {user.email}")

    # 检查邮箱是否已存在
    for existing_user in users_db.values():
        if existing_user["email"] == user.email:
            raise EmailAlreadyExistsError(user.email)

    # 创建新用户
    new_id = max(users_db.keys()) + 1
    new_user = {
        "id": new_id,
        "name": user.name,
        "email": user.email,
        "balance": 0.0,
        "role": "user"
    }
    users_db[new_id] = new_user

    logger.info(f"成功创建用户: {new_user['name']}")
    return {"message": "用户创建成功", "user": new_user}

@app.post("/transfer")
async def transfer_money(transfer: TransferRequest):
    """转账"""
    logger.info(f"转账: {transfer.from_user_id} -> {transfer.to_user_id}, 金额: {transfer.amount}")

    # 检查转出用户是否存在
    from_user = users_db.get(transfer.from_user_id)
    if not from_user:
        raise UserNotFoundError(transfer.from_user_id)

    # 检查转入用户是否存在
    to_user = users_db.get(transfer.to_user_id)
    if not to_user:
        raise UserNotFoundError(transfer.to_user_id)

    # 检查余额是否足够
    if from_user["balance"] < transfer.amount:
        raise InsufficientBalanceError(
            user_id=transfer.from_user_id,
            balance=from_user["balance"],
            required=transfer.amount
        )

    # 执行转账
    from_user["balance"] -= transfer.amount
    to_user["balance"] += transfer.amount

    logger.info(f"转账成功: {from_user['name']} -> {to_user['name']}, 金额: {transfer.amount}")
    return {
        "message": "转账成功",
        "from_user": from_user,
        "to_user": to_user
    }

@app.delete("/users/{user_id}")
async def delete_user(user_id: int, current_user_id: int = 1):
    """删除用户（仅管理员）"""
    logger.info(f"删除用户: {user_id}, 操作者: {current_user_id}")

    # 检查操作者是否存在
    current_user = users_db.get(current_user_id)
    if not current_user:
        raise UserNotFoundError(current_user_id)

    # 检查权限
    if current_user["role"] != "admin":
        raise PermissionDeniedError(current_user_id, "delete_user")

    # 检查目标用户是否存在
    if user_id not in users_db:
        raise UserNotFoundError(user_id)

    # 删除用户
    deleted_user = users_db.pop(user_id)
    logger.info(f"成功删除用户: {deleted_user['name']}")

    return {"message": f"用户 {deleted_user['name']} 已删除"}

@app.post("/orders")
async def create_order(order: OrderCreate):
    """创建订单"""
    logger.info(f"创建订单: user_id={order.user_id}, product={order.product_name}")

    # 检查用户是否存在
    user = users_db.get(order.user_id)
    if not user:
        raise UserNotFoundError(order.user_id)

    # 检查余额是否足够
    if user["balance"] < order.price:
        raise InsufficientBalanceError(
            user_id=order.user_id,
            balance=user["balance"],
            required=order.price
        )

    # 生成订单 ID
    order_id = str(uuid.uuid4())

    # 检查订单是否已存在（模拟冲突）
    if order_id in orders_db:
        raise ResourceConflictError("订单", order_id)

    # 创建订单
    new_order = {
        "id": order_id,
        "user_id": order.user_id,
        "product_name": order.product_name,
        "price": order.price,
        "status": "pending",
        "created_at": datetime.utcnow().isoformat()
    }
    orders_db[order_id] = new_order

    # 扣除余额
    user["balance"] -= order.price

    logger.info(f"成功创建订单: {order_id}")
    return {"message": "订单创建成功", "order": new_order}

@app.get("/")
async def root():
    """API 根路径"""
    return {
        "message": "FastAPI 自定义异常类示例",
        "endpoints": {
            "users": "/users",
            "transfer": "/transfer",
            "orders": "/orders"
        }
    }


if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("FastAPI 自定义异常类示例")
    print("=" * 50)
    print("\n启动服务器...")
    print("访问 http://localhost:8000/docs 查看 API 文档\n")

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 运行示例

### 1. 运行服务器

```bash
python examples/fastapi_custom_exceptions.py
```

---

### 2. 测试各种异常场景

#### 场景1：用户不存在

```bash
curl http://localhost:8000/users/999
```

**响应：**
```json
{
  "success": false,
  "error": "用户 999 不存在",
  "code": "USER_NOT_FOUND",
  "details": {
    "user_id": 999
  },
  "timestamp": "2026-02-11T09:30:00.000Z"
}
```

---

#### 场景2：邮箱已存在

```bash
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Alice2",
    "email": "alice@example.com"
  }'
```

**响应：**
```json
{
  "success": false,
  "error": "邮箱 alice@example.com 已被注册",
  "code": "EMAIL_ALREADY_EXISTS",
  "details": {
    "email": "alice@example.com"
  },
  "timestamp": "2026-02-11T09:30:00.000Z"
}
```

---

#### 场景3：余额不足

```bash
curl -X POST http://localhost:8000/transfer \
  -H "Content-Type: application/json" \
  -d '{
    "from_user_id": 1,
    "to_user_id": 2,
    "amount": 1000
  }'
```

**响应：**
```json
{
  "success": false,
  "error": "余额不足，当前余额: 100.0，需要: 1000",
  "code": "INSUFFICIENT_BALANCE",
  "details": {
    "user_id": 1,
    "balance": 100.0,
    "required": 1000,
    "shortage": 900.0
  },
  "timestamp": "2026-02-11T09:30:00.000Z"
}
```

---

#### 场景4：权限不足

```bash
curl -X DELETE "http://localhost:8000/users/2?current_user_id=1"
```

**响应：**
```json
{
  "success": false,
  "error": "用户 1 无权执行操作: delete_user",
  "code": "PERMISSION_DENIED",
  "details": {
    "user_id": 1,
    "action": "delete_user"
  },
  "timestamp": "2026-02-11T09:30:00.000Z"
}
```

---

## 关键知识点

### 1. 自定义异常类的结构

```python
class AppException(Exception):
    """应用异常基类"""
    def __init__(self, message: str, code: str = None):
        self.message = message
        self.code = code or self.__class__.__name__
        super().__init__(self.message)

class UserNotFoundError(AppException):
    """用户不存在异常"""
    def __init__(self, user_id: int):
        self.user_id = user_id  # 携带上下文信息
        super().__init__(
            message=f"用户 {user_id} 不存在",
            code="USER_NOT_FOUND"
        )
```

---

### 2. 统一的错误响应格式

```python
def create_error_response(
    status_code: int,
    error: str,
    code: str,
    details: dict = None,
    request_id: str = None
):
    """创建统一的错误响应"""
    content = {
        "success": False,
        "error": error,
        "code": code,
        "timestamp": datetime.utcnow().isoformat()
    }

    if details:
        content["details"] = details

    if request_id:
        content["request_id"] = request_id

    return JSONResponse(status_code=status_code, content=content)
```

---

### 3. 异常处理器注册

```python
@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    """处理用户不存在异常"""
    logger.warning(f"用户不存在: {exc.user_id}")
    return create_error_response(
        status_code=404,
        error=exc.message,
        code=exc.code,
        details={"user_id": exc.user_id},
        request_id=getattr(request.state, "request_id", None)
    )
```

---

### 4. 在路由中使用自定义异常

```python
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = users_db.get(user_id)
    if not user:
        raise UserNotFoundError(user_id)  # 抛出自定义异常
    return user
```

---

## 最佳实践

### 1. 异常类继承结构

```python
# ✅ 好：清晰的继承结构
Exception
    ↓
AppException（应用异常基类）
    ↓
├── UserNotFoundError
├── EmailAlreadyExistsError
├── InsufficientBalanceError
└── PermissionDeniedError

# ❌ 差：所有异常都直接继承 Exception
Exception
    ↓
├── UserNotFoundError
├── EmailAlreadyExistsError
└── ...
```

---

### 2. 异常类携带上下文信息

```python
# ✅ 好：携带详细信息
class InsufficientBalanceError(AppException):
    def __init__(self, user_id: int, balance: float, required: float):
        self.user_id = user_id
        self.balance = balance
        self.required = required
        super().__init__(...)

# ❌ 差：只有错误消息
class InsufficientBalanceError(AppException):
    def __init__(self, message: str):
        super().__init__(message)
```

---

### 3. 统一的错误码

```python
# ✅ 好：使用错误码
{
  "code": "USER_NOT_FOUND",
  "error": "用户不存在"
}

# ❌ 差：没有错误码
{
  "error": "用户不存在"
}
```

---

## 小结

自定义异常类的核心价值：

1. **代码清晰**：`raise UserNotFoundError(user_id)` 比 `raise HTTPException(...)` 更直观
2. **统一处理**：所有同类异常返回相同格式
3. **携带上下文**：异常对象可以携带详细信息
4. **易于维护**：修改错误响应只需改一处

**下一步：** 学习如何使用全局异常处理器实现更高级的错误处理架构。
