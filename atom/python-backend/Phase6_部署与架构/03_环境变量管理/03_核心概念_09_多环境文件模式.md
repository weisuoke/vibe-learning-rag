# 核心概念9：多环境文件模式

## 一句话定义

**多环境文件模式是使用多个 .env 文件（如 .env.dev、.env.test、.env.prod）分别存储不同环境的配置，根据环境标识自动加载对应文件的配置管理模式。**

---

## 为什么需要多环境文件模式？

### 问题场景

**场景1：单一配置文件的问题**

```bash
# .env（所有环境共用）
DATABASE_URL=postgresql://localhost:5432/mydb
OPENAI_API_KEY=sk-dev-xxx
DEBUG=True

# 问题：
# - 开发和生产环境配置混在一起
# - 切换环境需要手动修改配置
# - 容易误用生产配置
```

**场景2：配置分组的问题**

```python
# ❌ 配置分组（不推荐）
config = {
    "dev": {
        "database_url": "postgresql://localhost:5432/dev_db",
        "debug": True
    },
    "prod": {
        "database_url": "postgresql://prod-db:5432/prod_db",
        "debug": False
    }
}

env = os.getenv("ENV", "dev")
DATABASE_URL = config[env]["database_url"]

# 问题：
# - 配置硬编码在代码中
# - 不符合 12-Factor App 原则
# - 难以管理敏感信息
```

### 多环境文件模式的解决方案

```bash
# .env.dev（开发环境）
DATABASE_URL=postgresql://localhost:5432/dev_db
OPENAI_API_KEY=sk-dev-xxx
DEBUG=True

# .env.test（测试环境）
DATABASE_URL=postgresql://test-db:5432/test_db
OPENAI_API_KEY=sk-test-xxx
DEBUG=False

# .env.prod（生产环境）
DATABASE_URL=postgresql://prod-db:5432/prod_db
OPENAI_API_KEY=sk-prod-xxx
DEBUG=False
```

```python
# 根据环境加载对应文件
import os
from dotenv import load_dotenv

env = os.getenv("ENV", "dev")
load_dotenv(f".env.{env}")

# 自动加载正确的配置
```

---

## 多环境文件模式的结构

### 标准文件结构

```
project/
├── .env                    # 基础配置（所有环境共享）
├── .env.dev                # 开发环境配置
├── .env.test               # 测试环境配置
├── .env.staging            # 预发布环境配置
├── .env.prod               # 生产环境配置（不提交到 git）
├── .env.local              # 本地配置（不提交到 git）
├── .env.example            # 配置模板（提交到 git）
└── .gitignore              # 排除敏感文件
```

---

## 文件命名规范

### 规范1：环境标识

**使用标准的环境标识：**

```bash
.env.dev        # 开发环境
.env.test       # 测试环境
.env.staging    # 预发布环境
.env.prod       # 生产环境
```

**不推荐的命名：**

```bash
.env.development  # 太长
.env.production   # 太长
.env.DEV          # 大写不统一
.env_dev          # 下划线不统一
```

---

### 规范2：特殊文件

**.env（基础配置）**
- 所有环境共享的配置
- 提交到 git
- 不包含敏感信息

**.env.local（本地配置）**
- 开发者个人配置
- 不提交到 git
- 覆盖其他配置

**.env.example（配置模板）**
- 配置示例和说明
- 提交到 git
- 不包含真实密钥

**.env.prod（生产配置）**
- 生产环境配置
- 不提交到 git
- 包含真实密钥

---

## 配置文件的内容组织

### 文件1：.env（基础配置）

**所有环境共享的配置**

```bash
# .env（提交到 git）

# 应用配置
APP_NAME=AI Agent API
LOG_LEVEL=INFO

# 数据库配置（非敏感）
DATABASE_POOL_SIZE=10
DATABASE_MAX_OVERFLOW=20

# LLM 配置（非敏感）
OPENAI_MODEL=gpt-4
OPENAI_TEMPERATURE=0.7
OPENAI_MAX_TOKENS=2000

# 安全配置（非敏感）
ACCESS_TOKEN_EXPIRE_MINUTES=30
```

---

### 文件2：.env.dev（开发环境）

**开发环境特定配置**

```bash
# .env.dev（提交到 git）

# 环境标识
ENV=dev

# 应用配置
DEBUG=True
LOG_LEVEL=DEBUG

# 数据库配置
DATABASE_URL=postgresql://localhost:5432/dev_db

# LLM 配置
OPENAI_API_KEY=sk-dev-xxx
OPENAI_BASE_URL=https://api.openai.com/v1

# Redis 配置
REDIS_URL=redis://localhost:6379/0

# 安全配置
SECRET_KEY=dev-secret-key-xxxxxxxxxxxxx
```

---

### 文件3：.env.test（测试环境）

**测试环境特定配置**

```bash
# .env.test（提交到 git）

# 环境标识
ENV=test

# 应用配置
DEBUG=False
LOG_LEVEL=INFO

# 数据库配置
DATABASE_URL=postgresql://test-db:5432/test_db

# LLM 配置
OPENAI_API_KEY=sk-test-xxx
OPENAI_BASE_URL=https://api.openai.com/v1

# Redis 配置
REDIS_URL=redis://test-redis:6379/0

# 安全配置
SECRET_KEY=test-secret-key-xxxxxxxxxxxxx
```

---

### 文件4：.env.prod（生产环境）

**生产环境特定配置**

```bash
# .env.prod（不提交到 git）

# 环境标识
ENV=prod

# 应用配置
DEBUG=False
LOG_LEVEL=WARNING

# 数据库配置
DATABASE_URL=postgresql://prod-db.example.com:5432/prod_db

# LLM 配置
OPENAI_API_KEY=sk-prod-xxxxxxxxxxxxx
OPENAI_BASE_URL=https://api.openai.com/v1

# Redis 配置
REDIS_URL=redis://prod-redis.example.com:6379/0

# 安全配置
SECRET_KEY=prod-secret-key-xxxxxxxxxxxxx
```

---

### 文件5：.env.local（本地配置）

**开发者个人配置**

```bash
# .env.local（不提交到 git）

# 覆盖开发环境配置
DATABASE_URL=postgresql://localhost:5433/my_local_db
OPENAI_API_KEY=sk-my-personal-xxx

# 个人偏好
LOG_LEVEL=DEBUG
```

---

### 文件6：.env.example（配置模板）

**配置示例和说明**

```bash
# .env.example（提交到 git）

# 环境标识
ENV=dev

# 应用配置
DEBUG=True
LOG_LEVEL=INFO

# 数据库配置
DATABASE_URL=postgresql://user:password@localhost:5432/dbname

# LLM 配置
OPENAI_API_KEY=your_openai_api_key_here
OPENAI_BASE_URL=https://api.openai.com/v1
OPENAI_MODEL=gpt-4

# Redis 配置
REDIS_URL=redis://localhost:6379/0

# 安全配置
SECRET_KEY=your-secret-key-at-least-32-characters-long
```

---

## 配置加载策略

### 策略1：单文件加载

**最简单的方式，只加载一个文件**

```python
import os
from dotenv import load_dotenv

# 根据环境加载对应文件
env = os.getenv("ENV", "dev")
load_dotenv(f".env.{env}")

print(f"✅ 加载配置文件: .env.{env}")
```

**使用：**

```bash
# 开发环境
ENV=dev python app.py

# 测试环境
ENV=test python app.py

# 生产环境
ENV=prod python app.py
```

---

### 策略2：多层加载（推荐）

**基础配置 + 环境配置 + 本地配置**

```python
import os
from dotenv import load_dotenv

# 1. 加载基础配置（所有环境共享）
load_dotenv(".env")

# 2. 加载环境配置（覆盖基础配置）
env = os.getenv("ENV", "dev")
load_dotenv(f".env.{env}", override=True)

# 3. 加载本地配置（覆盖环境配置）
load_dotenv(".env.local", override=True)

print(f"✅ 加载配置文件: .env → .env.{env} → .env.local")
```

**优先级：**
```
.env.local > .env.{env} > .env > 默认值
```

---

### 策略3：条件加载

**根据环境选择性加载**

```python
import os
from dotenv import load_dotenv

env = os.getenv("ENV", "dev")

# 加载基础配置
load_dotenv(".env")

# 根据环境加载对应文件
if env == "dev":
    load_dotenv(".env.dev", override=True)
    load_dotenv(".env.local", override=True)  # 开发环境支持本地配置
elif env == "test":
    load_dotenv(".env.test", override=True)
elif env == "prod":
    load_dotenv(".env.prod", override=True)
else:
    raise ValueError(f"无效的环境: {env}")

print(f"✅ 当前环境: {env}")
```

---

### 策略4：自动查找

**自动查找并加载配置文件**

```python
import os
from pathlib import Path
from dotenv import load_dotenv

def load_env_files():
    """自动查找并加载配置文件"""
    env = os.getenv("ENV", "dev")

    # 配置文件列表（按优先级从低到高）
    env_files = [
        ".env",                # 基础配置
        f".env.{env}",         # 环境配置
        ".env.local",          # 本地配置
    ]

    loaded_files = []
    for env_file in env_files:
        if Path(env_file).exists():
            load_dotenv(env_file, override=True)
            loaded_files.append(env_file)

    print(f"✅ 加载配置文件: {' → '.join(loaded_files)}")
    return loaded_files

# 使用
load_env_files()
```

---

## .gitignore 配置

### 标准配置

```bash
# .gitignore

# 环境变量文件
.env
.env.local
.env.*.local
.env.prod
.env.production

# 但保留配置模板
!.env.example

# 但保留开发和测试环境配置（可选）
!.env.dev
!.env.test
```

**说明：**
- `.env` 和 `.env.local` 不提交（可能包含个人配置）
- `.env.prod` 不提交（包含生产密钥）
- `.env.example` 提交（配置模板）
- `.env.dev` 和 `.env.test` 可以提交（团队共享）

---

## 实际应用示例

### 示例1：FastAPI 应用的多环境配置

**项目结构：**

```
project/
├── .env
├── .env.dev
├── .env.test
├── .env.prod
├── .env.example
├── .gitignore
├── app/
│   ├── config.py
│   └── main.py
└── README.md
```

**app/config.py：**

```python
import os
from enum import Enum
from pathlib import Path
from pydantic import Field, field_validator
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

# 加载配置文件
def load_env_files():
    env = os.getenv("ENV", "dev")

    # 加载基础配置
    load_dotenv(".env")

    # 加载环境配置
    env_file = f".env.{env}"
    if Path(env_file).exists():
        load_dotenv(env_file, override=True)
    else:
        print(f"⚠️  警告：配置文件不存在: {env_file}")

    # 加载本地配置
    if Path(".env.local").exists():
        load_dotenv(".env.local", override=True)

    print(f"✅ 当前环境: {env}")

# 启动时加载
load_env_files()

class Environment(str, Enum):
    DEV = "dev"
    TEST = "test"
    PROD = "prod"

class Settings(BaseSettings):
    env: Environment = Environment.DEV
    debug: bool = False
    database_url: str
    openai_api_key: str
    secret_key: str

    @field_validator("debug")
    @classmethod
    def validate_debug(cls, v: bool, info) -> bool:
        if info.data.get("env") == Environment.PROD and v:
            raise ValueError("生产环境不能启用调试模式")
        return v

    class Config:
        # 不需要 env_file，因为已经手动加载
        pass

settings = Settings()
```

**app/main.py：**

```python
from fastapi import FastAPI
from app.config import settings

app = FastAPI(
    title=settings.app_name,
    debug=settings.debug
)

@app.on_event("startup")
async def startup():
    print(f"🚀 启动应用")
    print(f"📍 环境: {settings.env}")
    print(f"🗄️  数据库: {settings.database_url}")
    print(f"🐛 调试模式: {settings.debug}")

@app.get("/")
def read_root():
    return {
        "env": settings.env,
        "debug": settings.debug
    }
```

---

### 示例2：Docker 多环境部署

**docker-compose.dev.yml：**

```yaml
version: '3.8'

services:
  api:
    build: .
    env_file:
      - .env
      - .env.dev
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    command: uvicorn app.main:app --host 0.0.0.0 --reload
```

**docker-compose.prod.yml：**

```yaml
version: '3.8'

services:
  api:
    build: .
    env_file:
      - .env
      - .env.prod
    ports:
      - "80:8000"
    restart: always
```

**使用：**

```bash
# 开发环境
docker-compose -f docker-compose.dev.yml up

# 生产环境
docker-compose -f docker-compose.prod.yml up -d
```

---

### 示例3：CI/CD 集成

**GitHub Actions：**

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Deploy to dev
        env:
          ENV: dev
        run: |
          # 使用 .env.dev
          docker-compose -f docker-compose.dev.yml up -d

  deploy-prod:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v2

      - name: Deploy to prod
        env:
          ENV: prod
          # 从 GitHub Secrets 读取生产配置
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
        run: |
          # 创建 .env.prod
          echo "ENV=prod" > .env.prod
          echo "DATABASE_URL=$DATABASE_URL" >> .env.prod
          echo "OPENAI_API_KEY=$OPENAI_API_KEY" >> .env.prod
          echo "SECRET_KEY=$SECRET_KEY" >> .env.prod

          # 部署
          docker-compose -f docker-compose.prod.yml up -d
```

---

## 多环境文件模式的最佳实践

### 实践1：明确文件职责

**每个文件有明确的职责：**

- `.env`：基础配置（所有环境共享）
- `.env.{env}`：环境特定配置
- `.env.local`：个人配置
- `.env.example`：配置模板

---

### 实践2：配置分层

**按层次组织配置：**

```
基础配置（.env）
    ↓
环境配置（.env.dev / .env.test / .env.prod）
    ↓
本地配置（.env.local）
    ↓
系统环境变量
```

---

### 实践3：文档化配置

**在 README.md 中说明配置文件：**

```markdown
## 环境配置

### 配置文件

- `.env`：基础配置（所有环境共享）
- `.env.dev`：开发环境配置
- `.env.test`：测试环境配置
- `.env.prod`：生产环境配置（不提交到 git）
- `.env.local`：本地配置（不提交到 git）
- `.env.example`：配置模板

### 快速开始

1. 复制配置模板：
   ```bash
   cp .env.example .env.dev
   ```

2. 编辑 `.env.dev`，填入真实的密钥

3. 启动应用：
   ```bash
   ENV=dev python app.py
   ```

### 配置优先级

```
系统环境变量 > .env.local > .env.{env} > .env > 默认值
```
```

---

### 实践4：验证配置文件

**在启动时验证配置文件是否存在：**

```python
import os
from pathlib import Path

def validate_env_files():
    """验证配置文件是否存在"""
    env = os.getenv("ENV", "dev")

    # 必需的配置文件
    required_files = [
        ".env",
        f".env.{env}"
    ]

    missing_files = []
    for file in required_files:
        if not Path(file).exists():
            missing_files.append(file)

    if missing_files:
        print(f"❌ 错误：缺少配置文件: {', '.join(missing_files)}")
        print(f"提示：请复制 .env.example 为 {missing_files[0]}")
        import sys
        sys.exit(1)

    print(f"✅ 配置文件验证通过")

# 启动时验证
validate_env_files()
```

---

### 实践5：自动生成配置文件

**提供脚本自动生成配置文件：**

```python
# scripts/setup.py
"""
初始化配置文件
"""
import secrets
from pathlib import Path

def generate_secret_key() -> str:
    """生成随机密钥"""
    return secrets.token_urlsafe(32)

def create_env_file(env: str):
    """创建环境配置文件"""
    env_file = f".env.{env}"

    if Path(env_file).exists():
        print(f"⚠️  配置文件已存在: {env_file}")
        return

    # 从模板复制
    if Path(".env.example").exists():
        with open(".env.example") as f:
            content = f.read()

        # 替换占位符
        content = content.replace("your-secret-key-at-least-32-characters-long", generate_secret_key())
        content = content.replace("ENV=dev", f"ENV={env}")

        # 写入文件
        with open(env_file, "w") as f:
            f.write(content)

        print(f"✅ 创建配置文件: {env_file}")
    else:
        print(f"❌ 错误：配置模板不存在: .env.example")

if __name__ == "__main__":
    import sys
    env = sys.argv[1] if len(sys.argv) > 1 else "dev"
    create_env_file(env)
```

**使用：**

```bash
# 创建开发环境配置
python scripts/setup.py dev

# 创建生产环境配置
python scripts/setup.py prod
```

---

## 常见问题

### Q1: 应该提交哪些配置文件到 git？

**A:** 提交非敏感的配置文件。

```bash
# 提交到 git
.env.example  # ✅ 配置模板
.env.dev      # ✅ 开发环境配置（如果不包含真实密钥）
.env.test     # ✅ 测试环境配置（如果不包含真实密钥）

# 不提交到 git
.env          # ❌ 可能包含个人配置
.env.local    # ❌ 个人配置
.env.prod     # ❌ 生产密钥
```

---

### Q2: 如何在团队中共享配置？

**A:** 使用 .env.example 作为模板。

```bash
# 1. 团队成员复制模板
cp .env.example .env.dev

# 2. 填入自己的密钥
# 编辑 .env.dev

# 3. 启动应用
ENV=dev python app.py
```

---

### Q3: 如何处理多个开发者的本地配置？

**A:** 使用 .env.local 覆盖团队配置。

```bash
# .env.dev（团队共享）
DATABASE_URL=postgresql://localhost:5432/dev_db

# .env.local（个人配置，不提交）
DATABASE_URL=postgresql://localhost:5433/my_local_db
```

---

### Q4: 如何在 Docker 中使用多环境文件？

**A:** 使用 env_file 指定多个文件。

```yaml
# docker-compose.yml
services:
  api:
    env_file:
      - .env
      - .env.dev
```

---

## 多环境文件模式 vs 其他方案

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 多环境文件模式 | 配置分离、易于管理 | 需要管理多个文件 | 推荐 |
| 单一配置文件 | 简单 | 环境配置混在一起 | 小型项目 |
| 配置分组 | 集中管理 | 不符合 12-Factor App | 不推荐 |
| 云平台配置 | 安全、集中管理 | 依赖云平台 | 生产环境 |

---

## 总结

**多环境文件模式的核心价值：**

1. **配置分离**：不同环境的配置分别存储
2. **易于管理**：每个文件职责明确
3. **安全**：敏感配置不提交到 git
4. **灵活**：支持多层配置覆盖
5. **符合 12-Factor App**：配置与代码分离

**标准文件结构：**
```
.env                # 基础配置（提交）
.env.dev            # 开发环境（提交）
.env.test           # 测试环境（提交）
.env.prod           # 生产环境（不提交）
.env.local          # 本地配置（不提交）
.env.example        # 配置模板（提交）
```

**配置加载策略：**
- 单文件加载：只加载一个文件
- 多层加载：基础 + 环境 + 本地（推荐）
- 条件加载：根据环境选择性加载
- 自动查找：自动查找并加载配置文件

**配置优先级：**
```
系统环境变量 > .env.local > .env.{env} > .env > 默认值
```

**最佳实践：**
- 明确文件职责
- 配置分层
- 文档化配置
- 验证配置文件
- 自动生成配置文件

**实际应用：**
- FastAPI 应用的多环境配置
- Docker 多环境部署
- CI/CD 集成
- 团队协作
