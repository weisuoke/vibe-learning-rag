# 核心概念1：认证机制 - 原理篇

**认证（Authentication）是验证用户身份的过程，确保"你是你"，是 Milvus 安全体系的第一道防线。**

---

## 什么是认证？

### 定义

**认证 = 验证用户声称的身份是否真实**

```
用户说："我是张三"
系统问："你能证明吗？"
用户提供：用户名 + 密码
系统验证：密码是否正确
结果：通过 → 允许访问 / 失败 → 拒绝访问
```

### 认证 vs 授权

```
认证（Authentication）：你是谁？
- 问题：证明身份
- 时机：连接时
- 失败：无法连接

授权（Authorization）：你能做什么？
- 问题：检查权限
- 时机：操作时
- 失败：操作被拒绝
```

**类比：**
- 认证 = 酒店前台验证身份证
- 授权 = 房卡只能开特定房间

---

## Milvus 认证机制的工作原理

### 架构图

```
┌─────────────────────────────────────────────────────────┐
│                    客户端                                │
│  connections.connect(user="admin", password="pass")     │
└────────────────────┬────────────────────────────────────┘
                     │ 1. 发送凭证
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  Milvus Proxy                           │
│  ┌──────────────────────────────────────────────────┐  │
│  │  认证模块（Authentication Module）                │  │
│  │  1. 接收用户名和密码                              │  │
│  │  2. 查询用户数据库                                │  │
│  │  3. 验证密码哈希                                  │  │
│  │  4. 生成会话令牌（Session Token）                 │  │
│  └──────────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────────┘
                     │ 2. 返回令牌
                     ▼
┌─────────────────────────────────────────────────────────┐
│                    客户端                                │
│  保存令牌，后续请求携带令牌                              │
└─────────────────────────────────────────────────────────┘
```

### 认证流程（详细步骤）

```python
# 步骤1：客户端发起连接
from pymilvus import connections

connections.connect(
    alias="default",
    host="localhost",
    port="19530",
    user="admin",           # 用户名
    password="Milvus123!"   # 密码
)

# 步骤2：Milvus 服务器处理
# 2.1 检查认证是否启用
if not config.authorizationEnabled:
    # 如果未启用认证，直接允许连接
    return success()

# 2.2 验证用户名是否存在
user = database.find_user(username="admin")
if not user:
    return error("用户不存在")

# 2.3 验证密码
password_hash = hash_password("Milvus123!")
if user.password_hash != password_hash:
    return error("密码错误")

# 2.4 生成会话令牌
session_token = generate_token(user_id=user.id, expiry=3600)

# 2.5 返回令牌给客户端
return success(token=session_token)

# 步骤3：客户端保存令牌
# 后续所有操作都携带这个令牌

# 步骤4：后续请求验证令牌
# 每次操作时，Milvus 检查令牌是否有效
if not validate_token(session_token):
    return error("令牌无效或已过期")
```

---

## 密码存储机制

### 为什么不能明文存储密码？

```
❌ 错误：明文存储
数据库：
user_id | username | password
1       | admin    | Milvus123!
2       | analyst  | SecurePass

风险：
- 数据库泄露 → 所有密码泄露
- 内部人员可以看到密码
- 用户在其他网站使用相同密码也会泄露
```

### 正确做法：密码哈希

```python
import hashlib
import os

# 1. 生成盐值（Salt）
salt = os.urandom(32)  # 随机32字节

# 2. 密码 + 盐值 → 哈希
password = "Milvus123!"
password_hash = hashlib.pbkdf2_hmac(
    'sha256',
    password.encode('utf-8'),
    salt,
    100000  # 迭代次数
)

# 3. 存储：盐值 + 哈希值
database.store(
    username="admin",
    salt=salt,
    password_hash=password_hash
)

# 4. 验证时
input_password = "Milvus123!"
stored_salt = database.get_salt("admin")
stored_hash = database.get_hash("admin")

# 重新计算哈希
input_hash = hashlib.pbkdf2_hmac(
    'sha256',
    input_password.encode('utf-8'),
    stored_salt,
    100000
)

# 比较哈希值
if input_hash == stored_hash:
    print("✅ 密码正确")
else:
    print("❌ 密码错误")
```

**为什么使用盐值？**

```
场景：两个用户使用相同密码

没有盐值：
user1: password="123456" → hash="abc123..."
user2: password="123456" → hash="abc123..."
❌ 哈希值相同，容易被彩虹表攻击

有盐值：
user1: password="123456" + salt1 → hash="xyz789..."
user2: password="123456" + salt2 → hash="def456..."
✅ 哈希值不同，更安全
```

---

## 会话令牌（Session Token）

### 为什么需要令牌？

```
❌ 方案1：每次操作都发送密码
collection.search(user="admin", password="Milvus123!", ...)
collection.insert(user="admin", password="Milvus123!", ...)

问题：
- 密码在网络中频繁传输，容易被窃听
- 性能差（每次都要验证密码）
- 无法撤销（除非修改密码）

✅ 方案2：使用会话令牌
# 1. 登录时获取令牌
token = login(user="admin", password="Milvus123!")

# 2. 后续操作使用令牌
collection.search(token=token, ...)
collection.insert(token=token, ...)

优点：
- 密码只传输一次
- 令牌可以设置过期时间
- 令牌可以随时撤销
- 性能更好
```

### 令牌的生命周期

```
1. 生成（Login）
   用户登录 → 验证密码 → 生成令牌

2. 使用（Active）
   每次操作携带令牌 → 验证令牌有效性

3. 刷新（Refresh）
   令牌快过期 → 刷新令牌 → 延长有效期

4. 过期（Expired）
   超过有效期 → 令牌失效 → 需要重新登录

5. 撤销（Revoked）
   用户登出 / 管理员强制下线 → 令牌立即失效
```

**令牌示例：**

```python
# JWT（JSON Web Token）格式
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiYWRtaW4iLCJleHAiOjE3MDk5OTk5OTl9.signature"

# 解码后：
{
    "user_id": "admin",
    "exp": 1709999999,  # 过期时间戳
    "iat": 1709996399,  # 签发时间戳
    "roles": ["admin"]
}
```

---

## 认证的安全威胁

### 威胁1：暴力破解（Brute Force）

**攻击方式：**
```python
# 攻击者尝试所有可能的密码
passwords = ["123456", "password", "admin", "Milvus", ...]

for password in passwords:
    try:
        connections.connect(user="admin", password=password)
        print(f"✅ 密码找到：{password}")
        break
    except:
        continue
```

**防御措施：**

1. **强密码策略**
```python
# 密码要求
- 最小长度：12字符
- 必须包含：大写字母、小写字母、数字、特殊字符
- 不能是常见密码（123456、password等）
- 不能包含用户名

# 示例：强密码
✅ "Milvus@2025!Secure"
❌ "123456"
❌ "password"
❌ "admin"
```

2. **登录失败限制**
```python
# 限制登录尝试次数
class LoginRateLimiter:
    def __init__(self):
        self.failed_attempts = {}

    def check_login(self, username, password):
        # 检查失败次数
        if self.failed_attempts.get(username, 0) >= 5:
            # 锁定账户30分钟
            if time.time() - self.last_attempt[username] < 1800:
                raise Exception("账户已锁定，请30分钟后重试")
            else:
                # 解锁
                self.failed_attempts[username] = 0

        # 验证密码
        if not verify_password(username, password):
            self.failed_attempts[username] += 1
            self.last_attempt[username] = time.time()
            raise Exception("密码错误")

        # 登录成功，重置计数
        self.failed_attempts[username] = 0
```

3. **验证码（CAPTCHA）**
```python
# 多次失败后要求验证码
if failed_attempts >= 3:
    require_captcha()
```

### 威胁2：凭证泄露（Credential Leakage）

**泄露途径：**

1. **代码中硬编码**
```python
# ❌ 危险：密码硬编码
connections.connect(
    host="milvus.example.com",
    user="admin",
    password="Milvus123!"  # 硬编码在代码中
)

# ✅ 正确：使用环境变量
import os
connections.connect(
    host=os.getenv("MILVUS_HOST"),
    user=os.getenv("MILVUS_USER"),
    password=os.getenv("MILVUS_PASSWORD")
)
```

2. **日志中泄露**
```python
# ❌ 危险：密码记录在日志中
logger.info(f"连接 Milvus: user={user}, password={password}")

# ✅ 正确：不记录敏感信息
logger.info(f"连接 Milvus: user={user}")
```

3. **版本控制系统**
```bash
# ❌ 危险：.env 文件提交到 Git
git add .env
git commit -m "Add config"

# ✅ 正确：.env 加入 .gitignore
echo ".env" >> .gitignore
```

### 威胁3：中间人攻击（Man-in-the-Middle）

**攻击方式：**
```
客户端 --[明文密码]--> 攻击者 --[转发]--> Milvus
         ↑ 被窃听
```

**防御措施：TLS 加密**
```python
# ✅ 使用 TLS 加密传输
connections.connect(
    host="milvus.example.com",
    user="admin",
    password="Milvus123!",
    secure=True,  # 启用 TLS
    server_pem_path="/path/to/cert.pem"
)

# 密码在传输过程中被加密
# 攻击者无法读取
```

---

## 认证的最佳实践

### 1. 强密码策略

```python
import re

def validate_password(password):
    """验证密码强度"""
    checks = {
        "长度": len(password) >= 12,
        "大写字母": bool(re.search(r'[A-Z]', password)),
        "小写字母": bool(re.search(r'[a-z]', password)),
        "数字": bool(re.search(r'\d', password)),
        "特殊字符": bool(re.search(r'[!@#$%^&*(),.?":{}|<>]', password))
    }

    if not all(checks.values()):
        failed = [k for k, v in checks.items() if not v]
        raise ValueError(f"密码不符合要求：{', '.join(failed)}")

    # 检查常见密码
    common_passwords = ["123456", "password", "admin", "milvus"]
    if password.lower() in common_passwords:
        raise ValueError("不能使用常见密码")

    return True

# 使用
try:
    validate_password("Milvus@2025!Secure")
    print("✅ 密码符合要求")
except ValueError as e:
    print(f"❌ {e}")
```

### 2. 定期密码轮换

```python
# 密码过期策略
class PasswordPolicy:
    def __init__(self):
        self.max_age_days = 90  # 密码有效期90天

    def check_password_age(self, user):
        last_change = user.password_last_changed
        age_days = (datetime.now() - last_change).days

        if age_days > self.max_age_days:
            raise Exception("密码已过期，请修改密码")

        if age_days > self.max_age_days - 7:
            print(f"⚠️ 密码将在 {self.max_age_days - age_days} 天后过期")
```

### 3. 多因素认证（MFA）

```python
# 双因素认证流程
def login_with_mfa(username, password, otp_code):
    # 1. 验证用户名和密码
    if not verify_password(username, password):
        raise Exception("用户名或密码错误")

    # 2. 验证 OTP（一次性密码）
    if not verify_otp(username, otp_code):
        raise Exception("验证码错误")

    # 3. 生成会话令牌
    token = generate_token(username)
    return token

# 使用
token = login_with_mfa(
    username="admin",
    password="Milvus@2025!",
    otp_code="123456"  # 从手机 App 获取
)
```

### 4. 审计日志

```python
import logging

audit_logger = logging.getLogger("milvus_auth_audit")

def log_auth_event(event_type, username, success, ip_address):
    """记录认证事件"""
    audit_logger.info({
        "timestamp": datetime.now(),
        "event": event_type,
        "username": username,
        "success": success,
        "ip_address": ip_address
    })

# 使用
log_auth_event(
    event_type="LOGIN",
    username="admin",
    success=True,
    ip_address="192.168.1.100"
)

# 审计日志示例：
# [2025-02-10 10:30:00] LOGIN username=admin success=True ip=192.168.1.100
# [2025-02-10 10:35:00] LOGIN username=hacker success=False ip=203.0.113.1
# [2025-02-10 10:36:00] LOGIN username=hacker success=False ip=203.0.113.1
# [2025-02-10 10:37:00] LOGIN username=hacker success=False ip=203.0.113.1
# ⚠️ 检测到暴力破解攻击！
```

---

## 在 RAG 系统中的应用

### 场景1：企业知识库

```python
class EnterpriseRAGAuth:
    def __init__(self):
        # 集成企业 SSO（单点登录）
        self.sso_provider = "okta"

    def authenticate(self, sso_token):
        # 1. 验证 SSO token
        user_info = self.verify_sso_token(sso_token)

        # 2. 连接 Milvus
        connections.connect(
            host="milvus.company.com",
            user=user_info["email"],
            password=self._get_service_password(),
            secure=True
        )

        # 3. 记录审计日志
        self.log_access(user_info["email"], "LOGIN")

        return user_info

# 使用
auth = EnterpriseRAGAuth()
user = auth.authenticate(sso_token="...")
# 员工使用公司账号登录，无需单独的 Milvus 密码
```

### 场景2：SaaS 知识库服务

```python
class SaaSRAGAuth:
    def __init__(self):
        self.api_keys = {}  # API Key 管理

    def create_api_key(self, tenant_id):
        """为租户创建 API Key"""
        api_key = secrets.token_urlsafe(32)
        self.api_keys[api_key] = {
            "tenant_id": tenant_id,
            "created_at": datetime.now(),
            "expires_at": datetime.now() + timedelta(days=365)
        }
        return api_key

    def authenticate_api_key(self, api_key):
        """验证 API Key"""
        if api_key not in self.api_keys:
            raise Exception("无效的 API Key")

        key_info = self.api_keys[api_key]

        # 检查过期
        if datetime.now() > key_info["expires_at"]:
            raise Exception("API Key 已过期")

        return key_info["tenant_id"]

# 使用
auth = SaaSRAGAuth()

# 租户注册时创建 API Key
api_key = auth.create_api_key(tenant_id="tenant_a")
print(f"你的 API Key: {api_key}")

# 租户使用 API Key 访问
tenant_id = auth.authenticate_api_key(api_key)
# 连接到租户专属的 Collection
```

---

## 小结

**认证机制的核心要点：**

1. **定义**：验证用户身份，确保"你是你"
2. **流程**：用户名/密码 → 验证 → 生成令牌 → 后续使用令牌
3. **安全**：密码哈希 + 盐值、TLS 加密、强密码策略
4. **威胁**：暴力破解、凭证泄露、中间人攻击
5. **最佳实践**：强密码、定期轮换、MFA、审计日志

**下一步：** 学习认证机制的实现细节和高级配置
