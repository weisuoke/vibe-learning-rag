# 核心概念 05: 消息格式化

> **本文目标**: 掌握消息格式化的高级技巧和最佳实践

---

## 概述

**消息格式化**是将变量和模板转换为最终消息的过程。理解格式化机制可以帮助你构建更灵活、更强大的提示词系统。

**核心定位**: 消息格式化是连接模板定义和实际消息的桥梁。

---

## 1. 格式化的本质

### 1.1 格式化流程

```
变量字典 → 模板 → 格式化引擎 → 消息列表
{"role": "助手"} → "你是{role}" → 替换变量 → "你是助手"
```

**完整流程**:

```python
from langchain_core.prompts import ChatPromptTemplate

# 1. 定义模板
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}"),
    ("human", "{question}")
])

# 2. 提供变量
variables = {
    "role": "Python专家",
    "question": "什么是装饰器？"
}

# 3. 格式化（内部流程）
# - 验证变量完整性
# - 替换占位符
# - 生成消息对象
messages = template.invoke(variables)

# 4. 结果
# [
#   SystemMessage(content="你是Python专家"),
#   HumanMessage(content="什么是装饰器？")
# ]
```

### 1.2 格式化引擎

**LangChain 支持两种格式化引擎**:

1. **f-string** (默认，推荐)
2. **jinja2** (强大但有安全风险)

```python
# f-string 格式（默认）
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}")
])

# jinja2 格式
template = ChatPromptTemplate.from_messages([
    ("system", "你是{{ role }}")
], template_format="jinja2")
```

---

## 2. f-string 格式化

### 2.1 基础语法

**占位符语法**: `{variable_name}`

```python
from langchain_core.prompts import ChatPromptTemplate

template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}，专长是{skill}"),
    ("human", "{question}")
])

messages = template.invoke({
    "role": "Python专家",
    "skill": "代码优化",
    "question": "如何优化代码？"
})
```

### 2.2 类型转换

**自动类型转换**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", "年龄：{age}，分数：{score}，标签：{tags}")
])

messages = template.invoke({
    "age": 25,           # int → "25"
    "score": 95.5,       # float → "95.5"
    "tags": ["A", "B"]   # list → "['A', 'B']"
})

# 结果: "年龄：25，分数：95.5，标签：['A', 'B']"
```

### 2.3 特殊字符处理

**转义大括号**:

```python
# 如果需要输出 {literal}，使用双大括号
template = ChatPromptTemplate.from_messages([
    ("system", "格式：{{key: value}}，变量：{var}")
])

messages = template.invoke({"var": "test"})
# 结果: "格式：{key: value}，变量：test"
```

### 2.4 限制和优势

**f-string 的限制**:

```python
# ❌ 不支持复杂逻辑
template = ChatPromptTemplate.from_messages([
    ("system", "{role if role else 'default'}")  # 语法错误
])

# ❌ 不支持循环
template = ChatPromptTemplate.from_messages([
    ("system", "{for item in items: item}")  # 语法错误
])
```

**f-string 的优势**:

1. **简单**: 语法简洁，易于理解
2. **安全**: 不支持代码执行，避免注入风险
3. **快速**: 性能优于 jinja2
4. **标准**: Python 原生支持

---

## 3. jinja2 格式化

### 3.1 基础语法

**占位符语法**: `{{ variable_name }}`

```python
from langchain_core.prompts import ChatPromptTemplate

template = ChatPromptTemplate.from_messages([
    ("system", "你是{{ role }}"),
    ("human", "{{ question }}")
], template_format="jinja2")

messages = template.invoke({
    "role": "助手",
    "question": "你好"
})
```

### 3.2 条件语句

**if-else 语句**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", """
    你是助手
    {% if context %}
    上下文：{{ context }}
    {% endif %}
    """),
    ("human", "{{ question }}")
], template_format="jinja2")

# 有上下文
messages = template.invoke({
    "context": "这是背景信息",
    "question": "问题"
})
# 输出包含上下文

# 无上下文
messages = template.invoke({
    "question": "问题"
})
# 输出不包含上下文
```

### 3.3 循环语句

**for 循环**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", """
    你是助手，以下是示例：
    {% for example in examples %}
    - {{ example }}
    {% endfor %}
    """),
    ("human", "{{ question }}")
], template_format="jinja2")

messages = template.invoke({
    "examples": ["示例1", "示例2", "示例3"],
    "question": "问题"
})
# 输出:
# 你是助手，以下是示例：
# - 示例1
# - 示例2
# - 示例3
```

### 3.4 过滤器

**jinja2 过滤器**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", """
    名称：{{ name | upper }}
    长度：{{ text | length }}
    默认值：{{ optional | default('无') }}
    """)
], template_format="jinja2")

messages = template.invoke({
    "name": "python",
    "text": "hello"
})
# 输出:
# 名称：PYTHON
# 长度：5
# 默认值：无
```

### 3.5 安全风险（CVE-2025-65106）

**模板注入风险**:

```python
# ❌ 危险：允许用户定义 jinja2 模板
user_template = request.get("template")  # 用户输入
template = ChatPromptTemplate.from_messages([
    ("system", user_template)
], template_format="jinja2")

# 攻击者可以注入:
# "{{ ''.__class__.__mro__[1].__subclasses__() }}"
# 可能泄露系统信息或执行代码
```

**安全建议**:

1. **优先使用 f-string**: 除非必须用 jinja2
2. **永不信任用户输入**: 不要让用户定义模板
3. **使用白名单**: 只允许预定义的模板
4. **输入验证**: 严格验证所有变量值

---

## 4. 变量注入

### 4.1 基础变量注入

**字典注入**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}"),
    ("human", "{question}")
])

# 方式1: 字典
messages = template.invoke({
    "role": "助手",
    "question": "你好"
})

# 方式2: 关键字参数（不推荐）
# messages = template.invoke(role="助手", question="你好")  # 不支持
```

### 4.2 嵌套变量

**访问嵌套属性**:

```python
# f-string 不支持嵌套访问
template = ChatPromptTemplate.from_messages([
    ("system", "用户：{user}")  # 只能传入字符串
])

# 需要手动展开
user_data = {"name": "张三", "age": 25}
messages = template.invoke({
    "user": f"{user_data['name']}, {user_data['age']}岁"
})

# jinja2 支持嵌套访问
template = ChatPromptTemplate.from_messages([
    ("system", "用户：{{ user.name }}, {{ user.age }}岁")
], template_format="jinja2")

messages = template.invoke({
    "user": {"name": "张三", "age": 25}
})
```

### 4.3 列表变量

**处理列表**:

```python
# f-string: 自动转换为字符串
template = ChatPromptTemplate.from_messages([
    ("system", "选项：{options}")
])

messages = template.invoke({
    "options": ["A", "B", "C"]
})
# 输出: "选项：['A', 'B', 'C']"

# jinja2: 可以格式化
template = ChatPromptTemplate.from_messages([
    ("system", """
    选项：
    {% for opt in options %}
    - {{ opt }}
    {% endfor %}
    """)
], template_format="jinja2")

messages = template.invoke({
    "options": ["A", "B", "C"]
})
# 输出:
# 选项：
# - A
# - B
# - C
```

### 4.4 可选变量

**处理可选变量**:

```python
# f-string: 必须提供所有变量
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}"),
    ("human", "{question}")
])

# ❌ 错误：缺少变量
# template.invoke({"role": "助手"})  # KeyError

# jinja2: 可以设置默认值
template = ChatPromptTemplate.from_messages([
    ("system", "你是{{ role | default('助手') }}")
], template_format="jinja2")

# ✅ 正确：可以省略变量
messages = template.invoke({})
# 输出: "你是助手"
```

---

## 5. 部分应用（Partial）

### 5.1 静态部分应用

**预填充固定值**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}，专长是{skill}"),
    ("human", "{question}")
])

# 部分应用：固定 role 和 skill
partial_template = template.partial(
    role="Python专家",
    skill="代码优化"
)

# 使用时只需提供 question
messages = partial_template.invoke({"question": "如何优化代码？"})
```

### 5.2 动态部分应用

**使用函数生成值**:

```python
from datetime import datetime

def get_current_time():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

template = ChatPromptTemplate.from_messages([
    ("system", "当前时间：{current_time}"),
    ("human", "{question}")
])

# 部分应用：动态时间
partial_template = template.partial(current_time=get_current_time)

# 每次调用都会获取最新时间
messages = partial_template.invoke({"question": "现在几点？"})
```

### 5.3 链式部分应用

**逐步填充变量**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}，专长是{skill}，风格是{style}"),
    ("human", "{question}")
])

# 第一步：固定角色
step1 = template.partial(role="Python专家")

# 第二步：固定专长
step2 = step1.partial(skill="代码优化")

# 第三步：固定风格
step3 = step2.partial(style="简洁明了")

# 最终只需提供问题
messages = step3.invoke({"question": "如何优化代码？"})
```

### 5.4 部分应用的使用场景

**场景1: 环境配置**:

```python
import os

template = ChatPromptTemplate.from_messages([
    ("system", "环境：{env}，版本：{version}"),
    ("human", "{question}")
])

# 从环境变量读取
partial_template = template.partial(
    env=os.getenv("ENV", "development"),
    version=os.getenv("VERSION", "1.0.0")
)
```

**场景2: 用户上下文**:

```python
def create_user_template(user_id: str):
    """为特定用户创建模板"""
    template = ChatPromptTemplate.from_messages([
        ("system", "用户ID：{user_id}，你是助手"),
        ("human", "{question}")
    ])
    return template.partial(user_id=user_id)

# 为不同用户创建模板
user1_template = create_user_template("user_123")
user2_template = create_user_template("user_456")
```

**场景3: A/B 测试**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", "{system_prompt}"),
    ("human", "{question}")
])

# 版本A
version_a = template.partial(
    system_prompt="你是友好的助手"
)

# 版本B
version_b = template.partial(
    system_prompt="你是专业的助手"
)

# 根据实验组选择
if user_in_experiment_group:
    active_template = version_b
else:
    active_template = version_a
```

---

## 6. 格式化验证

### 6.1 变量完整性验证

**自动验证**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}"),
    ("human", "{question}")
])

# 查看需要的变量
print(template.input_variables)  # ['role', 'question']

# 缺少变量会报错
try:
    template.invoke({"role": "助手"})  # 缺少 question
except KeyError as e:
    print(f"缺少变量: {e}")
```

### 6.2 自定义验证

**使用 Pydantic 验证**:

```python
from pydantic import BaseModel, Field, validator

class TemplateInput(BaseModel):
    role: str = Field(max_length=50)
    question: str = Field(max_length=500)

    @validator('role')
    def validate_role(cls, v):
        allowed_roles = ["助手", "专家", "老师"]
        if v not in allowed_roles:
            raise ValueError(f"角色必须是: {allowed_roles}")
        return v

# 验证输入
try:
    validated = TemplateInput(
        role="助手",
        question="你好"
    )
    messages = template.invoke(validated.dict())
except ValidationError as e:
    print(f"验证失败: {e}")
```

### 6.3 运行时验证

**在格式化前验证**:

```python
def safe_invoke(template, variables):
    """安全的模板调用"""
    # 1. 检查变量完整性
    required = set(template.input_variables)
    provided = set(variables.keys())
    missing = required - provided

    if missing:
        raise ValueError(f"缺少变量: {missing}")

    # 2. 检查变量类型
    for key, value in variables.items():
        if not isinstance(value, (str, int, float, list, dict)):
            raise TypeError(f"变量 {key} 类型不支持: {type(value)}")

    # 3. 格式化
    return template.invoke(variables)

# 使用
try:
    messages = safe_invoke(template, {"role": "助手", "question": "你好"})
except (ValueError, TypeError) as e:
    print(f"错误: {e}")
```

---

## 7. 高级格式化技巧

### 7.1 条件格式化

**根据条件选择模板**:

```python
def create_template(has_context: bool):
    """根据是否有上下文创建不同模板"""
    if has_context:
        return ChatPromptTemplate.from_messages([
            ("system", "你是助手"),
            ("human", "上下文：{context}"),
            ("human", "问题：{question}")
        ])
    else:
        return ChatPromptTemplate.from_messages([
            ("system", "你是助手"),
            ("human", "{question}")
        ])

# 使用
template = create_template(has_context=True)
messages = template.invoke({
    "context": "背景信息",
    "question": "问题"
})
```

### 7.2 动态消息数量

**使用 MessagesPlaceholder**:

```python
from langchain_core.prompts import MessagesPlaceholder

template = ChatPromptTemplate.from_messages([
    ("system", "你是助手"),
    MessagesPlaceholder(variable_name="dynamic_messages"),
    ("human", "{question}")
])

# 可以注入任意数量的消息
messages = template.invoke({
    "dynamic_messages": [
        HumanMessage("消息1"),
        AIMessage("回复1"),
        HumanMessage("消息2"),
        AIMessage("回复2")
    ],
    "question": "新问题"
})
```

### 7.3 格式化后处理

**修改格式化结果**:

```python
def format_with_postprocessing(template, variables):
    """格式化并后处理"""
    # 1. 格式化
    messages = template.invoke(variables)

    # 2. 后处理：添加前缀
    for msg in messages:
        if isinstance(msg, HumanMessage):
            msg.content = f"[用户] {msg.content}"
        elif isinstance(msg, AIMessage):
            msg.content = f"[AI] {msg.content}"

    return messages

# 使用
messages = format_with_postprocessing(template, {
    "role": "助手",
    "question": "你好"
})
```

### 7.4 多语言格式化

**支持多语言**:

```python
TEMPLATES = {
    "zh": ChatPromptTemplate.from_messages([
        ("system", "你是{role}"),
        ("human", "{question}")
    ]),
    "en": ChatPromptTemplate.from_messages([
        ("system", "You are {role}"),
        ("human", "{question}")
    ])
}

def format_multilingual(language: str, variables: dict):
    """多语言格式化"""
    template = TEMPLATES.get(language, TEMPLATES["en"])
    return template.invoke(variables)

# 使用
messages_zh = format_multilingual("zh", {
    "role": "助手",
    "question": "你好"
})

messages_en = format_multilingual("en", {
    "role": "assistant",
    "question": "hello"
})
```

---

## 8. 性能优化

### 8.1 模板缓存

**缓存模板对象**:

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def get_template(template_key: str):
    """缓存模板"""
    return ChatPromptTemplate.from_messages([
        ("system", "你是{role}"),
        ("human", "{question}")
    ])

# 第一次：创建模板
template = get_template("default")

# 第二次：从缓存返回
template = get_template("default")  # 快速
```

### 8.2 批量格式化

**批量处理**:

```python
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}"),
    ("human", "{question}")
])

# 批量格式化
inputs = [
    {"role": "助手", "question": "问题1"},
    {"role": "助手", "question": "问题2"},
    {"role": "助手", "question": "问题3"}
]

messages_list = template.batch(inputs)
```

### 8.3 避免重复格式化

**复用格式化结果**:

```python
# ❌ 不好：重复格式化
for i in range(100):
    messages = template.invoke({"role": "助手", "question": f"问题{i}"})
    # 每次都格式化 role

# ✅ 好：使用部分应用
partial_template = template.partial(role="助手")
for i in range(100):
    messages = partial_template.invoke({"question": f"问题{i}"})
    # role 只格式化一次
```

---

## 9. 最佳实践

### 9.1 格式化原则

**✅ 推荐做法**:

```python
# 1. 使用 f-string（安全）
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}"),
    ("human", "{question}")
])

# 2. 变量命名清晰
template = ChatPromptTemplate.from_messages([
    ("system", "你是{role}"),
    ("human", "问题：{user_question}\n上下文：{context}")
])

# 3. 验证输入
required_vars = template.input_variables
if not all(v in user_input for v in required_vars):
    raise ValueError("缺少必需变量")
```

**❌ 不推荐做法**:

```python
# 1. 使用 jinja2（除非必须）
template = ChatPromptTemplate.from_messages([
    ("system", "你是{{ role }}")
], template_format="jinja2")

# 2. 变量命名不清
template = ChatPromptTemplate.from_messages([
    ("system", "你是{x}"),
    ("human", "{y}")  # x, y 是什么？
])

# 3. 不验证输入
messages = template.invoke(user_input)  # 可能缺少变量
```

### 9.2 安全实践

**防止注入**:

```python
# ❌ 危险：允许用户定义模板
user_template = request.get("template")
template = ChatPromptTemplate.from_template(user_template)

# ✅ 安全：只允许变量值
SAFE_TEMPLATE = ChatPromptTemplate.from_messages([
    ("system", "你是助手"),
    ("human", "{user_input}")
])
user_input = request.get("question")
messages = SAFE_TEMPLATE.invoke({"user_input": user_input})
```

### 9.3 测试实践

**单元测试格式化**:

```python
import pytest

def test_template_formatting():
    """测试模板格式化"""
    template = ChatPromptTemplate.from_messages([
        ("system", "你是{role}"),
        ("human", "{question}")
    ])

    messages = template.invoke({
        "role": "助手",
        "question": "你好"
    })

    assert len(messages) == 2
    assert messages[0].content == "你是助手"
    assert messages[1].content == "你好"

def test_partial_application():
    """测试部分应用"""
    template = ChatPromptTemplate.from_messages([
        ("system", "你是{role}"),
        ("human", "{question}")
    ])

    partial = template.partial(role="助手")
    messages = partial.invoke({"question": "你好"})

    assert messages[0].content == "你是助手"
```

---

## 检查清单

完成本节学习后，你应该能够：

- [ ] 理解格式化的完整流程
- [ ] 使用 f-string 格式化（推荐）
- [ ] 了解 jinja2 格式化的能力和风险
- [ ] 使用变量注入机制
- [ ] 使用部分应用（partial）
- [ ] 验证格式化输入
- [ ] 实现高级格式化技巧
- [ ] 优化格式化性能
- [ ] 避免安全风险
- [ ] 编写格式化测试

---

**下一步**: 阅读 `03_核心概念_06_Runnable方法.md` 学习 Runnable 的调用方法
