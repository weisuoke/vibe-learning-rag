# 核心概念3: 结果合并策略

> **深入理解字典合并、错误处理和类型推断**

---

## 概述

**结果合并策略**定义了 RunnableParallel 如何收集并行执行的结果，如何处理错误，以及如何推断输出类型。

**本文内容**：
- 字典合并规则
- 错误处理策略
- 部分失败容错
- 类型推断机制
- 性能优化

**学习目标**：
- 理解结果如何合并为字典
- 掌握错误处理的最佳实践
- 学会实现部分失败容错
- 理解类型推断机制

---

## 字典合并规则

### 基本合并

```python
chain = {
    "task1": runnable1,
    "task2": runnable2,
    "task3": runnable3,
}

result = chain.invoke(input)
```

**合并过程**：

```
并行执行:
├─ task1 → result1
├─ task2 → result2
└─ task3 → result3

合并为字典:
{
    "task1": result1,
    "task2": result2,
    "task3": result3,
}
```

**合并规则**：
- 键名来自字典定义
- 值来自对应 Runnable 的输出
- 保持键的顺序（Python 3.7+）

---

### 嵌套合并

```python
chain = {
    "group1": {
        "task1a": runnable1a,
        "task1b": runnable1b,
    },
    "group2": runnable2,
}

result = chain.invoke(input)
```

**嵌套合并过程**：

```
并行执行:
├─ group1 (并行)
│   ├─ task1a → result1a
│   └─ task1b → result1b
└─ group2 → result2

合并为嵌套字典:
{
    "group1": {
        "task1a": result1a,
        "task1b": result1b,
    },
    "group2": result2,
}
```

---

### 合并顺序

```python
from collections import OrderedDict

# Python 3.7+ 字典保持插入顺序
chain = {
    "first": runnable1,
    "second": runnable2,
    "third": runnable3,
}

result = chain.invoke(input)
print(list(result.keys()))
# ['first', 'second', 'third']  # 保持顺序
```

**注意**：
- Python 3.7+ 字典保持插入顺序
- 并行执行不保证完成顺序
- 但输出字典的键顺序与定义顺序一致

---

## 错误处理策略

### 默认行为：快速失败

```python
from langchain_core.runnables import RunnableLambda

def success_task(x):
    return "成功"

def failure_task(x):
    raise ValueError("任务失败")

chain = {
    "task1": RunnableLambda(success_task),
    "task2": RunnableLambda(failure_task),  # 这个会失败
    "task3": RunnableLambda(success_task),
}

try:
    result = chain.invoke("input")
except ValueError as e:
    print(f"错误: {e}")
    # 错误: 任务失败
    # task1 和 task3 的结果都丢失了
```

**默认行为**：
- 一个任务失败，整个链失败
- 类似于 `Promise.all()`
- 已完成的任务结果也会丢失

---

### 为什么默认快速失败？

**设计理由**：

1. **安全性**
   ```python
   # 关键业务流程
   payment_chain = {
       "validate": validate_payment,
       "process": process_payment,
       "notify": send_notification,
   }
   # 如果 validate 失败，不应该继续
   ```

2. **一致性**
   ```python
   # 数据一致性要求
   data_chain = {
       "user": create_user,
       "profile": create_profile,
       "settings": create_settings,
   }
   # 如果 user 创建失败，profile 和 settings 也不应该存在
   ```

3. **明确性**
   ```python
   # 明确的失败比静默的部分成功更好
   # 开发者可以明确知道哪里出错了
   ```

---

### 部分失败容错

#### 方案1: 安全包装

```python
from langchain_core.runnables import RunnableLambda
from typing import Dict, Any

def safe_runnable(func, name: str):
    """包装函数，捕获错误"""
    def wrapper(x):
        try:
            return {
                "success": True,
                "result": func(x),
                "error": None,
            }
        except Exception as e:
            return {
                "success": False,
                "result": None,
                "error": str(e),
            }
    return RunnableLambda(wrapper)

# 使用安全包装
chain = {
    "task1": safe_runnable(task1, "任务1"),
    "task2": safe_runnable(task2, "任务2"),
    "task3": safe_runnable(task3, "任务3"),
}

result = chain.invoke("input")

# 检查结果
for key, value in result.items():
    if value["success"]:
        print(f"{key} 成功: {value['result']}")
    else:
        print(f"{key} 失败: {value['error']}")
```

---

#### 方案2: 降级策略

```python
def with_fallback(primary, fallback, name: str):
    """主任务失败时使用降级方案"""
    def wrapper(x):
        try:
            return {
                "source": "primary",
                "result": primary(x),
            }
        except Exception as e:
            return {
                "source": "fallback",
                "result": fallback(x),
                "primary_error": str(e),
            }
    return RunnableLambda(wrapper)

# 使用降级策略
chain = {
    "api_data": with_fallback(
        primary=expensive_api_call,
        fallback=lambda x: "默认数据",
        name="API调用"
    ),
}

result = chain.invoke("input")
print(f"数据来源: {result['api_data']['source']}")
print(f"数据: {result['api_data']['result']}")
```

---

#### 方案3: 重试机制

```python
import time
from typing import Callable, Any

def with_retry(func: Callable, max_retries: int = 3, delay: float = 1.0):
    """带重试的任务"""
    def wrapper(x):
        last_error = None
        for attempt in range(max_retries):
            try:
                return {
                    "success": True,
                    "result": func(x),
                    "attempts": attempt + 1,
                }
            except Exception as e:
                last_error = e
                if attempt < max_retries - 1:
                    time.sleep(delay)

        return {
            "success": False,
            "error": str(last_error),
            "attempts": max_retries,
        }

    return RunnableLambda(wrapper)

# 使用重试机制
chain = {
    "unstable_api": with_retry(unstable_api_call, max_retries=3),
}
```

---

### 错误处理完整示例

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableLambda
from dotenv import load_dotenv
import logging

load_dotenv()

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

model = ChatOpenAI(model="gpt-4")

def safe_chain(chain, name: str):
    """安全包装链"""
    def wrapper(x):
        try:
            logger.info(f"[{name}] 开始执行")
            result = chain.invoke(x)
            logger.info(f"[{name}] 执行成功")
            return {
                "success": True,
                "result": result,
                "error": None,
            }
        except Exception as e:
            logger.error(f"[{name}] 执行失败: {e}")
            return {
                "success": False,
                "result": None,
                "error": str(e),
            }
    return RunnableLambda(wrapper)

# 定义任务
summary_chain = ChatPromptTemplate.from_template("总结: {text}") | model
keywords_chain = ChatPromptTemplate.from_template("关键词: {text}") | model

# 模拟一个会失败的任务
def failing_task(x):
    raise ValueError("模拟失败")

# 使用安全包装
analysis_chain = {
    "summary": safe_chain(summary_chain, "摘要"),
    "keywords": safe_chain(keywords_chain, "关键词"),
    "failing": safe_chain(RunnableLambda(failing_task), "失败任务"),
}

result = analysis_chain.invoke({"text": "LangChain 很强大"})

# 处理结果
print("=== 执行结果 ===")
for key, value in result.items():
    if value["success"]:
        print(f"✅ {key}: {value['result']}")
    else:
        print(f"❌ {key}: {value['error']}")
```

---

## 类型推断

### 输出类型推断

```python
from typing import Dict
from langchain_core.runnables import RunnableParallel
from langchain_core.messages import AIMessage

# 类型推断
chain = {
    "summary": summary_chain,  # 输出 AIMessage
    "keywords": keywords_chain,  # 输出 AIMessage
}

# 推断的类型
# chain: RunnableParallel[Input, Dict[str, AIMessage]]
```

**推断规则**：
- 输出类型 = `Dict[str, Union[所有分支的输出类型]]`
- 如果所有分支输出类型相同，则为 `Dict[str, 该类型]`
- 如果分支输出类型不同，则为 `Dict[str, Any]`

---

### 混合类型输出

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableLambda
from langchain_core.messages import AIMessage

model = ChatOpenAI(model="gpt-4")

chain = {
    "ai_message": ChatPromptTemplate.from_template("{text}") | model,  # AIMessage
    "string": RunnableLambda(lambda x: x["text"]),  # str
    "number": RunnableLambda(lambda x: len(x["text"])),  # int
    "list": RunnableLambda(lambda x: x["text"].split()),  # List[str]
}

# 推断的类型
# chain: RunnableParallel[Dict[str, str], Dict[str, Any]]
#        输入: Dict[str, str]
#        输出: Dict[str, Any]  # 因为输出类型不同

result = chain.invoke({"text": "Hello World"})
# result: Dict[str, Any]
```

---

### 类型注解示例

```python
from typing import Dict, Any, Union
from langchain_core.runnables import RunnableParallel, RunnableLambda
from langchain_core.messages import AIMessage

def create_analysis_chain() -> RunnableParallel[Dict[str, str], Dict[str, Union[AIMessage, int]]]:
    """创建分析链，带类型注解"""
    return {
        "summary": summary_chain,  # AIMessage
        "keywords": keywords_chain,  # AIMessage
        "length": RunnableLambda(lambda x: len(x["text"])),  # int
    }

chain = create_analysis_chain()
result: Dict[str, Union[AIMessage, int]] = chain.invoke({"text": "..."})
```

---

## 性能优化

### 优化1: 控制并发数量

```python
import asyncio
from typing import Dict, Any

async def batch_parallel(tasks: Dict[str, Any], batch_size: int = 10):
    """分批并行执行"""
    results = {}
    task_items = list(tasks.items())

    for i in range(0, len(task_items), batch_size):
        batch = dict(task_items[i:i+batch_size])
        batch_results = await RunnableParallel(**batch).ainvoke(input)
        results.update(batch_results)

    return results

# 使用
tasks = {f"task{i}": create_task(i) for i in range(100)}
result = asyncio.run(batch_parallel(tasks, batch_size=10))
```

---

### 优化2: 缓存结果

```python
from functools import lru_cache
from langchain_core.runnables import RunnableLambda

@lru_cache(maxsize=128)
def cached_expensive_operation(input_str: str):
    """带缓存的昂贵操作"""
    # 模拟昂贵操作
    return expensive_computation(input_str)

chain = {
    "cached_result": RunnableLambda(cached_expensive_operation),
    "other_task": other_runnable,
}
```

---

### 优化3: 提前返回

```python
from langchain_core.runnables import RunnableLambda

def quick_check(x):
    """快速检查，提前返回"""
    if x.get("skip"):
        return {"skipped": True}
    return expensive_operation(x)

chain = {
    "check": RunnableLambda(quick_check),
    "other": other_runnable,
}
```

---

## 完整示例

### 示例1: 生产级错误处理

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableLambda
from dotenv import load_dotenv
import logging
import time
from typing import Dict, Any, Callable

load_dotenv()

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

model = ChatOpenAI(model="gpt-4")

class TaskWrapper:
    """生产级任务包装器"""

    def __init__(self, func: Callable, name: str,
                 max_retries: int = 3,
                 fallback: Callable = None):
        self.func = func
        self.name = name
        self.max_retries = max_retries
        self.fallback = fallback

    def __call__(self, x: Any) -> Dict[str, Any]:
        """执行任务"""
        start_time = time.time()
        last_error = None

        # 重试逻辑
        for attempt in range(self.max_retries):
            try:
                logger.info(f"[{self.name}] 尝试 {attempt + 1}/{self.max_retries}")
                result = self.func(x)
                elapsed = time.time() - start_time

                logger.info(f"[{self.name}] 成功 (耗时: {elapsed:.2f}s)")
                return {
                    "success": True,
                    "result": result,
                    "error": None,
                    "attempts": attempt + 1,
                    "elapsed": elapsed,
                    "source": "primary",
                }
            except Exception as e:
                last_error = e
                logger.warning(f"[{self.name}] 尝试 {attempt + 1} 失败: {e}")
                if attempt < self.max_retries - 1:
                    time.sleep(1.0)  # 重试延迟

        # 所有重试都失败，尝试降级
        if self.fallback:
            try:
                logger.info(f"[{self.name}] 使用降级方案")
                result = self.fallback(x)
                elapsed = time.time() - start_time

                return {
                    "success": True,
                    "result": result,
                    "error": str(last_error),
                    "attempts": self.max_retries,
                    "elapsed": elapsed,
                    "source": "fallback",
                }
            except Exception as e:
                logger.error(f"[{self.name}] 降级方案也失败: {e}")

        # 完全失败
        elapsed = time.time() - start_time
        logger.error(f"[{self.name}] 完全失败")
        return {
            "success": False,
            "result": None,
            "error": str(last_error),
            "attempts": self.max_retries,
            "elapsed": elapsed,
            "source": None,
        }

# 定义任务
summary_task = lambda x: (ChatPromptTemplate.from_template("总结: {text}") | model).invoke(x)
keywords_task = lambda x: (ChatPromptTemplate.from_template("关键词: {text}") | model).invoke(x)

# 模拟不稳定的任务
def unstable_task(x):
    import random
    if random.random() < 0.7:  # 70% 失败率
        raise ValueError("随机失败")
    return "成功"

# 降级方案
def fallback_task(x):
    return "降级结果"

# 构建生产级链
production_chain = {
    "summary": RunnableLambda(TaskWrapper(
        func=summary_task,
        name="摘要生成",
        max_retries=2,
    )),
    "keywords": RunnableLambda(TaskWrapper(
        func=keywords_task,
        name="关键词提取",
        max_retries=2,
    )),
    "unstable": RunnableLambda(TaskWrapper(
        func=unstable_task,
        name="不稳定任务",
        max_retries=3,
        fallback=fallback_task,
    )),
}

# 执行
result = production_chain.invoke({"text": "LangChain 让 AI 开发更简单"})

# 分析结果
print("\n=== 执行报告 ===")
for key, value in result.items():
    status = "✅" if value["success"] else "❌"
    print(f"{status} {key}:")
    print(f"  成功: {value['success']}")
    print(f"  尝试次数: {value['attempts']}")
    print(f"  耗时: {value['elapsed']:.2f}s")
    if value['source']:
        print(f"  数据来源: {value['source']}")
    if value['error']:
        print(f"  错误: {value['error']}")
    print()
```

---

### 示例2: 结果验证和过滤

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableLambda
from dotenv import load_dotenv
from typing import Dict, Any

load_dotenv()

model = ChatOpenAI(model="gpt-4")

def validate_result(result: Any, min_length: int = 10) -> Dict[str, Any]:
    """验证结果"""
    if not result:
        return {"valid": False, "reason": "结果为空"}

    content = result.content if hasattr(result, 'content') else str(result)

    if len(content) < min_length:
        return {"valid": False, "reason": f"结果太短 ({len(content)} < {min_length})"}

    return {"valid": True, "reason": None}

def validated_chain(chain, name: str, min_length: int = 10):
    """带验证的链"""
    def wrapper(x):
        result = chain.invoke(x)
        validation = validate_result(result, min_length)

        return {
            "result": result,
            "valid": validation["valid"],
            "validation_reason": validation["reason"],
        }

    return RunnableLambda(wrapper)

# 使用验证
analysis_chain = {
    "summary": validated_chain(
        ChatPromptTemplate.from_template("总结: {text}") | model,
        name="摘要",
        min_length=20
    ),
    "keywords": validated_chain(
        ChatPromptTemplate.from_template("关键词: {text}") | model,
        name="关键词",
        min_length=5
    ),
}

result = analysis_chain.invoke({"text": "LangChain 很强大"})

# 过滤有效结果
valid_results = {
    key: value["result"]
    for key, value in result.items()
    if value["valid"]
}

print("有效结果:", valid_results.keys())
```

---

## 最佳实践

### 1. 错误处理策略选择

```python
# 关键业务：快速失败（默认）
payment_chain = {
    "validate": validate_payment,
    "process": process_payment,
}
# 一个失败，全部失败

# 非关键业务：部分容错
analytics_chain = {
    "metric1": safe_runnable(metric1_task),
    "metric2": safe_runnable(metric2_task),
}
# 一个失败，其他继续
```

---

### 2. 日志记录

```python
import logging

logger = logging.getLogger(__name__)

def logged_runnable(func, name: str):
    """带日志的 Runnable"""
    def wrapper(x):
        logger.info(f"[{name}] 开始")
        try:
            result = func(x)
            logger.info(f"[{name}] 成功")
            return result
        except Exception as e:
            logger.error(f"[{name}] 失败: {e}")
            raise
    return RunnableLambda(wrapper)
```

---

### 3. 性能监控

```python
import time

def monitored_runnable(func, name: str):
    """带性能监控的 Runnable"""
    def wrapper(x):
        start = time.time()
        try:
            result = func(x)
            elapsed = time.time() - start
            print(f"[{name}] 耗时: {elapsed:.2f}s")
            return result
        except Exception as e:
            elapsed = time.time() - start
            print(f"[{name}] 失败 (耗时: {elapsed:.2f}s): {e}")
            raise
    return RunnableLambda(wrapper)
```

---

### 4. 结果验证

```python
def validated_runnable(func, validator, name: str):
    """带结果验证的 Runnable"""
    def wrapper(x):
        result = func(x)
        if not validator(result):
            raise ValueError(f"[{name}] 结果验证失败")
        return result
    return RunnableLambda(wrapper)

# 使用
chain = {
    "summary": validated_runnable(
        func=summary_task,
        validator=lambda r: len(r.content) > 10,
        name="摘要"
    ),
}
```

---

## 总结

### 核心要点

1. **字典合并**：键名来自定义，值来自 Runnable 输出
2. **默认快速失败**：一个任务失败，整个链失败
3. **部分容错**：使用安全包装实现
4. **类型推断**：输出类型为 `Dict[str, Union[所有分支类型]]`
5. **性能优化**：控制并发、缓存、提前返回

### 错误处理策略

| 场景 | 策略 | 实现 |
|------|------|------|
| 关键业务 | 快速失败 | 默认行为 |
| 非关键业务 | 部分容错 | 安全包装 |
| 不稳定服务 | 重试 + 降级 | 重试包装 + fallback |
| 数据验证 | 验证 + 过滤 | 验证包装 |

### 生产环境建议

1. **添加日志**：记录执行过程
2. **性能监控**：监控执行时间
3. **错误处理**：根据场景选择策略
4. **结果验证**：验证输出质量
5. **降级方案**：准备备用方案

---

## 下一步学习

- [实战代码1: 基础并行执行](./07_实战代码_01_基础并行执行.md) - 完整可运行示例
- [实战代码2: RAG检索场景](./07_实战代码_02_RAG检索场景.md) - RAG 中的错误处理
- [实战代码3: 多任务处理](./07_实战代码_03_多任务处理.md) - 生产级错误处理

---

## 参考资源

**官方文档**：
- [RunnableParallel API Reference](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.base.RunnableParallel.html)
- [Python asyncio.gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather)

**2025-2026 最佳实践**：
- [Building Production-Ready AI Pipelines](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557)
- [LangChain Best Practices](https://www.swarnendu.de/blog/langchain-best-practices)

---

**版本**: v1.0
**最后更新**: 2026-02-19
**适用**: LangChain 0.3+, Python 3.13+
