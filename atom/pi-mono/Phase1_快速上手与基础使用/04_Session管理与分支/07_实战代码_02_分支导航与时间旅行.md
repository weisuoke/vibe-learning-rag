# Session 管理与分支 - 实战代码 02：分支导航与时间旅行

> 实现树形导航和时间旅行功能的完整代码示例

---

## 场景：使用 /tree 回到历史节点

实现：
- 树形结构可视化
- 节点导航
- 时间旅行（跳转到历史节点）
- Context 重建

---

## 完整代码实现

```typescript
/**
 * 分支导航与时间旅行实战示例
 * 演示：树形结构构建、可视化、导航和时间旅行
 */

import fs from 'fs/promises';
import path from 'path';

// ===== 1. 类型定义 =====

interface SessionEntry {
  id: string;
  parentId?: string;
  type: string;
  content: string;
  timestamp: number;
}

interface TreeNode extends SessionEntry {
  children: TreeNode[];
  depth: number;
}

// ===== 2. 树形构建器 =====

class TreeBuilder {
  // 构建树形结构
  buildTree(entries: SessionEntry[]): TreeNode[] {
    const nodeMap = new Map<string, TreeNode>();
    const roots: TreeNode[] = [];

    // 创建节点
    entries.forEach(entry => {
      nodeMap.set(entry.id, {
        ...entry,
        children: [],
        depth: 0
      });
    });

    // 建立父子关系
    entries.forEach(entry => {
      const node = nodeMap.get(entry.id)!;

      if (entry.parentId) {
        const parent = nodeMap.get(entry.parentId);
        if (parent) {
          parent.children.push(node);
          node.depth = parent.depth + 1;
        } else {
          roots.push(node);
        }
      } else {
        roots.push(node);
      }
    });

    return roots;
  }

  // 获取到节点的路径
  getPathToNode(entries: SessionEntry[], targetId: string): SessionEntry[] {
    const nodeMap = new Map(entries.map(e => [e.id, e]));
    const path: SessionEntry[] = [];

    let currentId: string | undefined = targetId;
    while (currentId) {
      const node = nodeMap.get(currentId);
      if (!node) break;

      path.unshift(node);
      currentId = node.parentId;
    }

    return path;
  }

  // 查找节点
  findNode(roots: TreeNode[], targetId: string): TreeNode | null {
    for (const root of roots) {
      const found = this.findNodeRecursive(root, targetId);
      if (found) return found;
    }
    return null;
  }

  private findNodeRecursive(node: TreeNode, targetId: string): TreeNode | null {
    if (node.id === targetId) return node;

    for (const child of node.children) {
      const found = this.findNodeRecursive(child, targetId);
      if (found) return found;
    }

    return null;
  }
}

// ===== 3. 树形渲染器 =====

class TreeRenderer {
  render(nodes: TreeNode[], indent = '', isLast = true): string {
    let output = '';

    nodes.forEach((node, index) => {
      const isLastChild = index === nodes.length - 1;
      const connector = isLastChild ? '└─' : '├─';
      const childIndent = indent + (isLastChild ? '   ' : '│  ');

      // 渲染节点
      const preview = node.content.substring(0, 50);
      output += `${indent}${connector} ${node.id}: ${preview}\n`;

      // 递归渲染子节点
      if (node.children.length > 0) {
        output += this.render(node.children, childIndent, isLastChild);
      }
    });

    return output;
  }

  // 渲染路径
  renderPath(path: SessionEntry[]): string {
    return path.map((entry, i) => {
      const arrow = i < path.length - 1 ? ' → ' : '';
      return `${entry.id}${arrow}`;
    }).join('');
  }
}

// ===== 4. 时间旅行导航器 =====

class TimeNavigator {
  private entries: SessionEntry[];
  private currentNodeId: string;

  constructor(entries: SessionEntry[]) {
    this.entries = entries;
    this.currentNodeId = entries[entries.length - 1]?.id || '';
  }

  // 跳转到指定节点
  navigateTo(targetId: string): SessionEntry[] {
    const builder = new TreeBuilder();
    const path = builder.getPathToNode(this.entries, targetId);

    if (path.length === 0) {
      throw new Error(`Node ${targetId} not found`);
    }

    this.currentNodeId = targetId;
    return path;
  }

  // 获取当前上下文
  getCurrentContext(): SessionEntry[] {
    const builder = new TreeBuilder();
    return builder.getPathToNode(this.entries, this.currentNodeId);
  }

  // 回到父节点
  goToParent(): SessionEntry[] | null {
    const builder = new TreeBuilder();
    const currentPath = builder.getPathToNode(this.entries, this.currentNodeId);

    if (currentPath.length <= 1) {
      return null; // 已经在根节点
    }

    const parentNode = currentPath[currentPath.length - 2];
    return this.navigateTo(parentNode.id);
  }

  // 前进到子节点
  goToChild(childIndex: number): SessionEntry[] | null {
    const builder = new TreeBuilder();
    const tree = builder.buildTree(this.entries);
    const currentNode = builder.findNode(tree, this.currentNodeId);

    if (!currentNode || currentNode.children.length === 0) {
      return null;
    }

    if (childIndex >= currentNode.children.length) {
      return null;
    }

    const childNode = currentNode.children[childIndex];
    return this.navigateTo(childNode.id);
  }

  // 获取当前节点信息
  getCurrentNodeInfo(): { node: SessionEntry; hasParent: boolean; childrenCount: number } {
    const builder = new TreeBuilder();
    const tree = builder.buildTree(this.entries);
    const currentNode = builder.findNode(tree, this.currentNodeId);

    if (!currentNode) {
      throw new Error('Current node not found');
    }

    return {
      node: currentNode,
      hasParent: !!currentNode.parentId,
      childrenCount: currentNode.children.length
    };
  }
}

// ===== 5. 使用示例 =====

async function main() {
  console.log('=== 分支导航与时间旅行示例 ===\n');

  // 创建示例数据
  const entries: SessionEntry[] = [
    { id: '1', type: 'message', content: '实现用户登录功能', timestamp: Date.now() },
    { id: '2', parentId: '1', type: 'message', content: '好的，我来实现...', timestamp: Date.now() },
    { id: '3', parentId: '2', type: 'message', content: '使用 JWT 认证', timestamp: Date.now() },
    { id: '4', parentId: '3', type: 'message', content: '实现 JWT 认证...', timestamp: Date.now() },
    { id: '5', parentId: '4', type: 'message', content: '测试通过 ✓', timestamp: Date.now() },
    { id: '6', parentId: '2', type: 'message', content: '改用 Session 认证', timestamp: Date.now() },
    { id: '7', parentId: '6', type: 'message', content: '实现 Session 认证...', timestamp: Date.now() },
    { id: '8', parentId: '7', type: 'message', content: '这个方案更好 ✓', timestamp: Date.now() }
  ];

  // 1. 构建树形结构
  console.log('1. 构建树形结构');
  const builder = new TreeBuilder();
  const tree = builder.buildTree(entries);

  const renderer = new TreeRenderer();
  console.log(renderer.render(tree));

  // 2. 初始化导航器
  console.log('2. 初始化导航器（当前在节点 8）');
  const navigator = new TimeNavigator(entries);
  const currentInfo = navigator.getCurrentNodeInfo();
  console.log(`   当前节点: ${currentInfo.node.id}`);
  console.log(`   内容: ${currentInfo.node.content}`);
  console.log(`   有父节点: ${currentInfo.hasParent}`);
  console.log(`   子节点数: ${currentInfo.childrenCount}\n`);

  // 3. 时间旅行：回到节点 2
  console.log('3. 时间旅行：回到节点 2');
  const pathTo2 = navigator.navigateTo('2');
  console.log(`   路径: ${renderer.renderPath(pathTo2)}`);
  console.log(`   上下文包含 ${pathTo2.length} 个节点\n`);

  // 4. 查看当前节点的子节点
  console.log('4. 查看当前节点的子节点');
  const info2 = navigator.getCurrentNodeInfo();
  console.log(`   节点 2 有 ${info2.childrenCount} 个子节点:`);
  const tree2 = builder.buildTree(entries);
  const node2 = builder.findNode(tree2, '2');
  node2?.children.forEach((child, i) => {
    console.log(`   ${i}. ${child.id}: ${child.content}`);
  });
  console.log();

  // 5. 前进到第一个子节点（JWT 分支）
  console.log('5. 前进到第一个子节点（JWT 分支）');
  const pathTo3 = navigator.goToChild(0);
  if (pathTo3) {
    console.log(`   路径: ${renderer.renderPath(pathTo3)}`);
    console.log(`   当前节点: ${pathTo3[pathTo3.length - 1].content}\n`);
  }

  // 6. 回到节点 2
  console.log('6. 回到父节点');
  const backTo2 = navigator.goToParent();
  if (backTo2) {
    console.log(`   路径: ${renderer.renderPath(backTo2)}`);
    console.log(`   当前节点: ${backTo2[backTo2.length - 1].content}\n`);
  }

  // 7. 前进到第二个子节点（Session 分支）
  console.log('7. 前进到第二个子节点（Session 分支）');
  const pathTo6 = navigator.goToChild(1);
  if (pathTo6) {
    console.log(`   路径: ${renderer.renderPath(pathTo6)}`);
    console.log(`   当前节点: ${pathTo6[pathTo6.length - 1].content}\n`);
  }

  // 8. 对比两个分支
  console.log('8. 对比两个分支');
  const jwtPath = builder.getPathToNode(entries, '5');
  const sessionPath = builder.getPathToNode(entries, '8');

  console.log('   JWT 分支:');
  jwtPath.forEach((entry, i) => {
    console.log(`   ${i + 1}. ${entry.id}: ${entry.content}`);
  });

  console.log('\n   Session 分支:');
  sessionPath.forEach((entry, i) => {
    console.log(`   ${i + 1}. ${entry.id}: ${entry.content}`);
  });

  console.log('\n=== 示例完成 ===');
}

// 运行示例
main().catch(console.error);
```

---

## 运行输出示例

```
=== 分支导航与时间旅行示例 ===

1. 构建树形结构
├─ 1: 实现用户登录功能
   └─ 2: 好的，我来实现...
      ├─ 3: 使用 JWT 认证
      │  └─ 4: 实现 JWT 认证...
      │     └─ 5: 测试通过 ✓
      └─ 6: 改用 Session 认证
         └─ 7: 实现 Session 认证...
            └─ 8: 这个方案更好 ✓

2. 初始化导航器（当前在节点 8）
   当前节点: 8
   内容: 这个方案更好 ✓
   有父节点: true
   子节点数: 0

3. 时间旅行：回到节点 2
   路径: 1 → 2
   上下文包含 2 个节点

4. 查看当前节点的子节点
   节点 2 有 2 个子节点:
   0. 3: 使用 JWT 认证
   1. 6: 改用 Session 认证

5. 前进到第一个子节点（JWT 分支）
   路径: 1 → 2 → 3
   当前节点: 使用 JWT 认证

6. 回到父节点
   路径: 1 → 2
   当前节点: 好的，我来实现...

7. 前进到第二个子节点（Session 分支）
   路径: 1 → 2 → 6
   当前节点: 改用 Session 认证

8. 对比两个分支
   JWT 分支:
   1. 1: 实现用户登录功能
   2. 2: 好的，我来实现...
   3. 3: 使用 JWT 认证
   4. 4: 实现 JWT 认证...
   5. 5: 测试通过 ✓

   Session 分支:
   1. 1: 实现用户登录功能
   2. 2: 好的，我来实现...
   3. 6: 改用 Session 认证
   4. 7: 实现 Session 认证...
   5. 8: 这个方案更好 ✓

=== 示例完成 ===
```

---

## 应用场景

### 场景 1：调试和回溯

```typescript
async function debugWorkflow() {
  const entries: SessionEntry[] = [
    { id: '1', type: 'message', content: '实现功能 A', timestamp: Date.now() },
    { id: '2', parentId: '1', type: 'message', content: '完成', timestamp: Date.now() },
    { id: '3', parentId: '2', type: 'message', content: '添加功能 B', timestamp: Date.now() },
    { id: '4', parentId: '3', type: 'message', content: '出现 bug', timestamp: Date.now() }
  ];

  const navigator = new TimeNavigator(entries);

  // 发现 bug，回到功能 A 完成时
  console.log('发现 bug，回到功能 A 完成时');
  const pathTo2 = navigator.navigateTo('2');
  console.log(`回到节点 2: ${pathTo2[pathTo2.length - 1].content}`);

  // 从这里重新开始
  console.log('从这里重新开始开发功能 B');
}
```

### 场景 2：对比不同实现

```typescript
async function compareImplementations() {
  const builder = new TreeBuilder();
  const renderer = new TreeRenderer();

  // 构建树
  const tree = builder.buildTree(entries);

  // 找到分支点
  const branchPoint = builder.findNode(tree, '2');

  if (branchPoint && branchPoint.children.length > 1) {
    console.log('找到分支点，有多个实现方案:');

    branchPoint.children.forEach((child, i) => {
      console.log(`\n方案 ${i + 1}:`);
      console.log(renderer.render([child]));
    });
  }
}
```

---

## 学习检查清单

完成本节学习后，你应该能够：

- [ ] 实现树形结构构建
- [ ] 实现树形可视化渲染
- [ ] 实现时间旅行导航
- [ ] 实现路径查找和重建
- [ ] 对比不同分支
- [ ] 应用于实际调试场景

---

**版本：** v1.0
**最后更新：** 2026-02-18
**维护者：** Claude Code
