# 实战代码 01: 基础调用

> 完整的 Runnable 基础调用示例

---

## 代码概述

本示例演示：
1. 自定义 Runnable 实现
2. LCEL 管道组合
3. invoke/batch/stream 三种执行方式
4. 错误处理和验证
5. 与 LLM 集成

---

## 完整代码

```python
"""
Runnable 基础调用实战示例
演示：文本转换管道的完整实现

Requirements:
- Python 3.13+
- langchain-core
- langchain-openai
- python-dotenv
"""

import os
from typing import Optional, List, Dict, Any
from dotenv import load_dotenv

from langchain_core.runnables import Runnable, RunnableConfig
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser

# 加载环境变量
load_dotenv()

# ===== 1. 自定义 Runnable: 文本清洗器 =====
print("=" * 60)
print("1. 自定义 Runnable 实现")
print("=" * 60)

class TextCleaner(Runnable[str, str]):
    """
    文本清洗 Runnable

    功能：
    - 移除多余空格
    - 转换为小写
    - 移除特殊字符
    """

    def invoke(
        self,
        input: str,
        config: Optional[RunnableConfig] = None
    ) -> str:
        """同步执行文本清洗"""
        # 输入验证
        if not isinstance(input, str):
            raise TypeError(f"输入必须是字符串，实际类型: {type(input)}")

        if not input.strip():
            raise ValueError("输入不能为空")

        # 清洗逻辑
        cleaned = input.strip()  # 移除首尾空格
        cleaned = " ".join(cleaned.split())  # 移除多余空格
        cleaned = cleaned.lower()  # 转小写

        # 移除特殊字符（保留字母、数字、空格）
        cleaned = "".join(
            char for char in cleaned
            if char.isalnum() or char.isspace()
        )

        return cleaned

# 测试自定义 Runnable
cleaner = TextCleaner()

test_inputs = [
    "  Hello   World!  ",
    "Python  3.13  Release",
    "LangChain  @#$  LCEL"
]

print("\n测试文本清洗:")
for text in test_inputs:
    result = cleaner.invoke(text)
    print(f"输入: '{text}'")
    print(f"输出: '{result}'")
    print()

# ===== 2. 自定义 Runnable: 文本分析器 =====
print("=" * 60)
print("2. 文本分析 Runnable")
print("=" * 60)

class TextAnalyzer(Runnable[str, Dict[str, Any]]):
    """
    文本分析 Runnable

    功能：
    - 统计字符数、单词数
    - 检测语言类型
    - 计算平均词长
    """

    def invoke(
        self,
        input: str,
        config: Optional[RunnableConfig] = None
    ) -> Dict[str, Any]:
        """分析文本并返回统计信息"""
        import re

        # 基础统计
        char_count = len(input)
        words = input.split()
        word_count = len(words)

        # 语言检测
        has_chinese = bool(re.search(r'[\u4e00-\u9fff]', input))
        has_english = bool(re.search(r'[a-zA-Z]', input))

        # 平均词长
        avg_word_length = sum(len(word) for word in words) / word_count if word_count > 0 else 0

        return {
            "char_count": char_count,
            "word_count": word_count,
            "has_chinese": has_chinese,
            "has_english": has_english,
            "avg_word_length": round(avg_word_length, 2)
        }

# 测试文本分析
analyzer = TextAnalyzer()

test_texts = [
    "Hello World",
    "你好世界",
    "Hello 世界 Mixed Language"
]

print("\n测试文本分析:")
for text in test_texts:
    result = analyzer.invoke(text)
    print(f"文本: '{text}'")
    print(f"分析: {result}")
    print()

# ===== 3. LCEL 管道组合 =====
print("=" * 60)
print("3. LCEL 管道组合")
print("=" * 60)

# 组合清洗器和分析器
analysis_pipeline = cleaner | analyzer

print("\n测试组合管道:")
messy_text = "  Hello   World!!!  你好  世界  "
print(f"原始文本: '{messy_text}'")

result = analysis_pipeline.invoke(messy_text)
print(f"清洗后分析: {result}")
print()

# ===== 4. 与 LLM 集成 =====
print("=" * 60)
print("4. 与 LLM 集成")
print("=" * 60)

# 检查 API 密钥
if not os.getenv("OPENAI_API_KEY"):
    print("⚠️  警告: 未设置 OPENAI_API_KEY，跳过 LLM 示例")
    print("请在 .env 文件中设置 OPENAI_API_KEY")
else:
    # 定义 LLM 链
    prompt = ChatPromptTemplate.from_template(
        "将以下文本翻译成英文，保持简洁:\n\n{text}"
    )
    llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
    parser = StrOutputParser()

    # 完整管道：清洗 → 翻译 → 解析
    translation_pipeline = (
        cleaner
        | (lambda x: {"text": x})  # 转换为字典
        | prompt
        | llm
        | parser
    )

    print("\n测试翻译管道:")
    chinese_texts = [
        "  你好，世界！  ",
        "  欢迎使用  LangChain  "
    ]

    for text in chinese_texts:
        try:
            result = translation_pipeline.invoke(text)
            print(f"原文: '{text}'")
            print(f"译文: '{result}'")
            print()
        except Exception as e:
            print(f"翻译失败: {e}")
            print()

# ===== 5. batch 批量执行 =====
print("=" * 60)
print("5. batch 批量执行")
print("=" * 60)

# 批量清洗
batch_inputs = [
    "  Text  One  ",
    "  Text  Two  ",
    "  Text  Three  "
]

print("\n批量清洗测试:")
print(f"输入: {batch_inputs}")

batch_results = cleaner.batch(batch_inputs)
print(f"输出: {batch_results}")
print()

# 批量分析
print("批量分析测试:")
batch_analysis = analyzer.batch(batch_results)
for inp, result in zip(batch_inputs, batch_analysis):
    print(f"'{inp.strip()}' → {result}")
print()

# ===== 6. stream 流式执行 =====
print("=" * 60)
print("6. stream 流式执行")
print("=" * 60)

# 注意：简单的 Runnable 流式输出效果不明显
# 这里演示概念，实际流式主要用于 LLM

print("\n流式执行测试:")
test_text = "  Hello  World  "
print(f"输入: '{test_text}'")
print("流式输出: ", end="")

for chunk in cleaner.stream(test_text):
    print(f"'{chunk}'", end=" ")
print("\n")

# ===== 7. 错误处理 =====
print("=" * 60)
print("7. 错误处理")
print("=" * 60)

print("\n测试错误处理:")

# 测试 1: 空字符串
try:
    cleaner.invoke("")
except ValueError as e:
    print(f"✓ 捕获空字符串错误: {e}")

# 测试 2: 错误类型
try:
    cleaner.invoke(123)  # type: ignore
except TypeError as e:
    print(f"✓ 捕获类型错误: {e}")

# 测试 3: 带错误处理的 Runnable
class SafeTextCleaner(Runnable[str, str]):
    """带错误处理的文本清洗器"""

    def invoke(self, input: str, config: Optional[RunnableConfig] = None) -> str:
        try:
            if not isinstance(input, str):
                return f"[ERROR: 类型错误]"

            if not input.strip():
                return "[ERROR: 空字符串]"

            # 清洗逻辑
            cleaned = " ".join(input.split()).lower()
            return cleaned

        except Exception as e:
            return f"[ERROR: {str(e)}]"

safe_cleaner = SafeTextCleaner()

print("\n测试安全清洗器:")
test_cases = ["  Hello  ", "", 123, None]
for test in test_cases:
    result = safe_cleaner.invoke(test)  # type: ignore
    print(f"输入: {test!r} → 输出: '{result}'")

# ===== 8. Config 参数使用 =====
print("\n" + "=" * 60)
print("8. Config 参数使用")
print("=" * 60)

from langchain_core.callbacks import BaseCallbackHandler

class LoggingHandler(BaseCallbackHandler):
    """日志回调处理器"""

    def on_chain_start(self, serialized, inputs, **kwargs):
        print(f"  [LOG] 链开始执行: {inputs}")

    def on_chain_end(self, outputs, **kwargs):
        print(f"  [LOG] 链执行完成: {outputs}")

# 使用 Config
config = RunnableConfig(
    tags=["demo", "basic"],
    metadata={"user": "demo_user"},
    callbacks=[LoggingHandler()]
)

print("\n带 Config 的执行:")
result = cleaner.invoke("  Test  Input  ", config=config)
print(f"最终结果: '{result}'")

# ===== 9. 实际应用场景 =====
print("\n" + "=" * 60)
print("9. 实际应用场景：文本预处理管道")
print("=" * 60)

class TextPreprocessor(Runnable[str, Dict[str, Any]]):
    """
    完整的文本预处理管道

    流程：
    1. 清洗文本
    2. 分析文本
    3. 返回清洗后的文本和分析结果
    """

    def __init__(self):
        self.cleaner = TextCleaner()
        self.analyzer = TextAnalyzer()

    def invoke(
        self,
        input: str,
        config: Optional[RunnableConfig] = None
    ) -> Dict[str, Any]:
        # 清洗
        cleaned = self.cleaner.invoke(input, config)

        # 分析
        analysis = self.analyzer.invoke(cleaned, config)

        # 返回结果
        return {
            "original": input,
            "cleaned": cleaned,
            "analysis": analysis
        }

# 使用预处理器
preprocessor = TextPreprocessor()

print("\n完整预处理示例:")
raw_texts = [
    "  Hello   World!!!  ",
    "  Python  3.13  Release  ",
    "  你好  世界  Hello  World  "
]

for text in raw_texts:
    result = preprocessor.invoke(text)
    print(f"\n原始: '{result['original']}'")
    print(f"清洗: '{result['cleaned']}'")
    print(f"分析: {result['analysis']}")

# ===== 10. 性能测试 =====
print("\n" + "=" * 60)
print("10. 性能测试：invoke vs batch")
print("=" * 60)

import time

# 生成测试数据
test_data = [f"  Text  {i}  " for i in range(100)]

# 测试 invoke 循环
print("\n测试 invoke 循环:")
start = time.time()
results_invoke = [cleaner.invoke(text) for text in test_data]
time_invoke = time.time() - start
print(f"处理 {len(test_data)} 个文本")
print(f"耗时: {time_invoke:.4f} 秒")

# 测试 batch
print("\n测试 batch:")
start = time.time()
results_batch = cleaner.batch(test_data)
time_batch = time.time() - start
print(f"处理 {len(test_data)} 个文本")
print(f"耗时: {time_batch:.4f} 秒")

# 对比
print(f"\n性能对比:")
print(f"invoke 循环: {time_invoke:.4f} 秒")
print(f"batch 批量: {time_batch:.4f} 秒")
if time_invoke > time_batch:
    speedup = time_invoke / time_batch
    print(f"batch 快 {speedup:.2f}x")
else:
    print("(注: 简单操作可能看不出差异)")

# ===== 总结 =====
print("\n" + "=" * 60)
print("总结")
print("=" * 60)

print("""
本示例演示了：

1. ✓ 自定义 Runnable 实现（TextCleaner, TextAnalyzer）
2. ✓ LCEL 管道组合（cleaner | analyzer）
3. ✓ 与 LLM 集成（翻译管道）
4. ✓ invoke/batch/stream 三种执行方式
5. ✓ 错误处理和验证
6. ✓ Config 参数使用
7. ✓ 实际应用场景（文本预处理）
8. ✓ 性能对比测试

关键要点：
- Runnable 是可组合的计算单元
- LCEL 使用 | 操作符组合
- invoke 适合单次执行
- batch 适合批量处理
- stream 适合流式输出（主要用于 LLM）
- Config 用于配置和监控

下一步：
- 学习 batch 方法的高级用法（07_实战代码_02_批处理场景.md）
- 学习 stream 方法的实际应用（07_实战代码_03_流式输出.md）
""")
```

---

## 运行输出示例

```
============================================================
1. 自定义 Runnable 实现
============================================================

测试文本清洗:
输入: '  Hello   World!  '
输出: 'hello world'

输入: 'Python  3.13  Release'
输出: 'python 313 release'

输入: 'LangChain  @#$  LCEL'
输出: 'langchain lcel'

============================================================
2. 文本分析 Runnable
============================================================

测试文本分析:
文本: 'Hello World'
分析: {'char_count': 11, 'word_count': 2, 'has_chinese': False, 'has_english': True, 'avg_word_length': 5.5}

文本: '你好世界'
分析: {'char_count': 4, 'word_count': 1, 'has_chinese': True, 'has_english': False, 'avg_word_length': 4.0}

文本: 'Hello 世界 Mixed Language'
分析: {'char_count': 23, 'word_count': 4, 'has_chinese': True, 'has_english': True, 'avg_word_length': 5.0}

============================================================
3. LCEL 管道组合
============================================================

测试组合管道:
原始文本: '  Hello   World!!!  你好  世界  '
清洗后分析: {'char_count': 17, 'word_count': 4, 'has_chinese': True, 'has_english': True, 'avg_word_length': 3.75}

============================================================
4. 与 LLM 集成
============================================================

测试翻译管道:
原文: '  你好，世界！  '
译文: 'Hello, World!'

原文: '  欢迎使用  LangChain  '
译文: 'Welcome to LangChain'

============================================================
5. batch 批量执行
============================================================

批量清洗测试:
输入: ['  Text  One  ', '  Text  Two  ', '  Text  Three  ']
输出: ['text one', 'text two', 'text three']

批量分析测试:
'Text  One' → {'char_count': 8, 'word_count': 2, 'has_chinese': False, 'has_english': True, 'avg_word_length': 4.0}
'Text  Two' → {'char_count': 8, 'word_count': 2, 'has_chinese': False, 'has_english': True, 'avg_word_length': 4.0}
'Text  Three' → {'char_count': 10, 'word_count': 2, 'has_chinese': False, 'has_english': True, 'avg_word_length': 5.0}

============================================================
6. stream 流式执行
============================================================

流式执行测试:
输入: '  Hello  World  '
流式输出: 'hello world'

============================================================
7. 错误处理
============================================================

测试错误处理:
✓ 捕获空字符串错误: 输入不能为空
✓ 捕获类型错误: 输入必须是字符串，实际类型: <class 'int'>

测试安全清洗器:
输入: '  Hello  ' → 输出: 'hello'
输入: '' → 输出: '[ERROR: 空字符串]'
输入: 123 → 输出: '[ERROR: 类型错误]'
输入: None → 输出: '[ERROR: 类型错误]'

============================================================
8. Config 参数使用
============================================================

带 Config 的执行:
  [LOG] 链开始执行: Test  Input
  [LOG] 链执行完成: test input
最终结果: 'test input'

============================================================
9. 实际应用场景：文本预处理管道
============================================================

完整预处理示例:

原始: '  Hello   World!!!  '
清洗: 'hello world'
分析: {'char_count': 11, 'word_count': 2, 'has_chinese': False, 'has_english': True, 'avg_word_length': 5.5}

原始: '  Python  3.13  Release  '
清洗: 'python 313 release'
分析: {'char_count': 18, 'word_count': 3, 'has_chinese': False, 'has_english': True, 'avg_word_length': 6.0}

原始: '  你好  世界  Hello  World  '
清洗: 'hello world'
分析: {'char_count': 11, 'word_count': 2, 'has_chinese': True, 'has_english': True, 'avg_word_length': 5.5}

============================================================
10. 性能测试：invoke vs batch
============================================================

测试 invoke 循环:
处理 100 个文本
耗时: 0.0023 秒

测试 batch:
处理 100 个文本
耗时: 0.0021 秒

性能对比:
invoke 循环: 0.0023 秒
batch 批量: 0.0021 秒
batch 快 1.10x

============================================================
总结
============================================================

本示例演示了：

1. ✓ 自定义 Runnable 实现（TextCleaner, TextAnalyzer）
2. ✓ LCEL 管道组合（cleaner | analyzer）
3. ✓ 与 LLM 集成（翻译管道）
4. ✓ invoke/batch/stream 三种执行方式
5. ✓ 错误处理和验证
6. ✓ Config 参数使用
7. ✓ 实际应用场景（文本预处理）
8. ✓ 性能对比测试

关键要点：
- Runnable 是可组合的计算单元
- LCEL 使用 | 操作符组合
- invoke 适合单次执行
- batch 适合批量处理
- stream 适合流式输出（主要用于 LLM）
- Config 用于配置和监控

下一步：
- 学习 batch 方法的高级用法（07_实战代码_02_批处理场景.md）
- 学习 stream 方法的实际应用（07_实战代码_03_流式输出.md）
```

---

## 使用说明

### 1. 环境准备

```bash
# 安装依赖
uv add langchain langchain-core langchain-openai python-dotenv

# 配置 API 密钥（可选，用于 LLM 示例）
cp .env.example .env
# 编辑 .env，添加 OPENAI_API_KEY
```

### 2. 运行代码

```bash
# 激活虚拟环境
source .venv/bin/activate

# 运行示例
python 07_实战代码_01_基础调用.py
```

### 3. 修改和扩展

- 修改 `TextCleaner` 的清洗逻辑
- 添加新的 Runnable 组件
- 尝试不同的 LCEL 组合
- 集成其他 LLM 模型

---

## 学习要点

### 核心概念

1. **自定义 Runnable**：实现 `invoke` 方法即可
2. **LCEL 组合**：使用 `|` 操作符连接
3. **三种执行方式**：invoke/batch/stream
4. **错误处理**：验证输入，捕获异常
5. **Config 参数**：传递配置和回调

### 最佳实践

- ✅ 验证输入类型和内容
- ✅ 提供清晰的错误信息
- ✅ 使用类型注解
- ✅ 添加详细注释
- ✅ 测试边界情况

---

**下一步**: 阅读 [07_实战代码_02_批处理场景.md](./07_实战代码_02_批处理场景.md) 学习批量处理
