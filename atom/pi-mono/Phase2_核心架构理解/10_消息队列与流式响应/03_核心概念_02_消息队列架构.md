# 核心概念 02：消息队列架构

> **核心价值**: 消息队列是 AI Agent 管理用户输入、工具调用和 LLM 响应的核心数据结构，实现了顺序控制、优先级管理和批处理优化。

---

## 概述

在 AI Agent 系统中，消息队列负责管理所有类型的消息：
- **用户消息**（User message）
- **助手消息**（Assistant message）
- **工具调用消息**（Tool call message）
- **工具结果消息**（Tool result message）
- **Steering 消息**（Steering message）
- **Follow-up 消息**（Follow-up message）

消息队列不仅仅是一个简单的 FIFO 队列，它还需要支持：
- **优先级管理**：Steering > User > Tool results
- **批处理优化**：并行执行独立的工具调用
- **去重机制**：避免重复处理相同消息
- **状态管理**：跟踪每个消息的处理状态

---

## 1. 队列数据结构设计

### 1.1 消息类型定义

```typescript
// 消息类型枚举
export enum MessageType {
  USER = 'user',
  ASSISTANT = 'assistant',
  TOOL_CALL = 'tool-call',
  TOOL_RESULT = 'tool-result',
  STEERING = 'steering',
  FOLLOW_UP = 'follow-up'
}

// 消息优先级
export enum MessagePriority {
  CRITICAL = 0,   // Steering message
  HIGH = 1,       // User message
  NORMAL = 2,     // Tool results
  LOW = 3         // Background tasks
}

// 消息状态
export enum MessageStatus {
  PENDING = 'pending',       // 等待处理
  PROCESSING = 'processing', // 正在处理
  COMPLETED = 'completed',   // 已完成
  FAILED = 'failed',         // 失败
  CANCELLED = 'cancelled'    // 已取消
}

// 基础消息接口
export interface Message {
  id: string;
  type: MessageType;
  priority: MessagePriority;
  status: MessageStatus;
  content: string;
  timestamp: number;
  parentId?: string;  // 用于会话树结构
  metadata?: Record<string, any>;
}

// 用户消息
export interface UserMessage extends Message {
  type: MessageType.USER;
}

// 助手消息
export interface AssistantMessage extends Message {
  type: MessageType.ASSISTANT;
  toolCalls?: ToolCall[];
}

// 工具调用消息
export interface ToolCallMessage extends Message {
  type: MessageType.TOOL_CALL;
  toolName: string;
  toolArgs: Record<string, any>;
}

// 工具结果消息
export interface ToolResultMessage extends Message {
  type: MessageType.TOOL_RESULT;
  toolCallId: string;
  result: any;
  error?: string;
}

// Steering 消息
export interface SteeringMessage extends Message {
  type: MessageType.STEERING;
  priority: MessagePriority.CRITICAL;
}

// Follow-up 消息
export interface FollowUpMessage extends Message {
  type: MessageType.FOLLOW_UP;
  waitFor: string; // 等待的消息 ID
}
```

### 1.2 队列节点设计

```typescript
// 队列节点
export interface QueueNode<T = Message> {
  data: T;
  next: QueueNode<T> | null;
  prev: QueueNode<T> | null;
}

// 优先级队列节点
export interface PriorityQueueNode<T = Message> extends QueueNode<T> {
  priority: number;
}
```

### 1.3 消息队列类设计

```typescript
/**
 * 消息队列类
 * 支持优先级、批处理和去重
 */
export class MessageQueue {
  private queue: Map<MessagePriority, Message[]>;
  private processing: Set<string>;
  private completed: Set<string>;
  private maxSize: number;

  constructor(maxSize: number = 1000) {
    this.queue = new Map([
      [MessagePriority.CRITICAL, []],
      [MessagePriority.HIGH, []],
      [MessagePriority.NORMAL, []],
      [MessagePriority.LOW, []]
    ]);
    this.processing = new Set();
    this.completed = new Set();
    this.maxSize = maxSize;
  }

  /**
   * 入队：添加消息到队列
   */
  enqueue(message: Message): void {
    // 1. 检查队列大小
    if (this.size() >= this.maxSize) {
      throw new Error('Queue is full');
    }

    // 2. 去重检查
    if (this.completed.has(message.id)) {
      console.warn(`Message ${message.id} already processed`);
      return;
    }

    // 3. 根据优先级添加到对应队列
    const priorityQueue = this.queue.get(message.priority);
    if (!priorityQueue) {
      throw new Error(`Invalid priority: ${message.priority}`);
    }

    priorityQueue.push(message);
  }

  /**
   * 出队：获取下一个待处理消息
   */
  dequeue(): Message | null {
    // 按优先级顺序查找
    for (const priority of [
      MessagePriority.CRITICAL,
      MessagePriority.HIGH,
      MessagePriority.NORMAL,
      MessagePriority.LOW
    ]) {
      const priorityQueue = this.queue.get(priority);
      if (priorityQueue && priorityQueue.length > 0) {
        const message = priorityQueue.shift()!;
        this.processing.add(message.id);
        return message;
      }
    }

    return null;
  }

  /**
   * 查看队首消息（不移除）
   */
  peek(): Message | null {
    for (const priority of [
      MessagePriority.CRITICAL,
      MessagePriority.HIGH,
      MessagePriority.NORMAL,
      MessagePriority.LOW
    ]) {
      const priorityQueue = this.queue.get(priority);
      if (priorityQueue && priorityQueue.length > 0) {
        return priorityQueue[0];
      }
    }

    return null;
  }

  /**
   * 标记消息为已完成
   */
  markCompleted(messageId: string): void {
    this.processing.delete(messageId);
    this.completed.add(messageId);
  }

  /**
   * 标记消息为失败
   */
  markFailed(messageId: string): void {
    this.processing.delete(messageId);
  }

  /**
   * 取消消息
   */
  cancel(messageId: string): boolean {
    // 从所有优先级队列中移除
    for (const priorityQueue of this.queue.values()) {
      const index = priorityQueue.findIndex(m => m.id === messageId);
      if (index !== -1) {
        priorityQueue.splice(index, 1);
        return true;
      }
    }

    return false;
  }

  /**
   * 清空队列
   */
  clear(): void {
    for (const priorityQueue of this.queue.values()) {
      priorityQueue.length = 0;
    }
    this.processing.clear();
  }

  /**
   * 获取队列大小
   */
  size(): number {
    let total = 0;
    for (const priorityQueue of this.queue.values()) {
      total += priorityQueue.length;
    }
    return total;
  }

  /**
   * 检查队列是否为空
   */
  isEmpty(): boolean {
    return this.size() === 0;
  }

  /**
   * 获取指定优先级的消息数量
   */
  sizeByPriority(priority: MessagePriority): number {
    return this.queue.get(priority)?.length || 0;
  }

  /**
   * 获取所有待处理消息
   */
  getAllPending(): Message[] {
    const messages: Message[] = [];
    for (const priorityQueue of this.queue.values()) {
      messages.push(...priorityQueue);
    }
    return messages;
  }

  /**
   * 获取正在处理的消息 ID
   */
  getProcessing(): string[] {
    return Array.from(this.processing);
  }
}
```

---

## 2. 基础队列操作

### 2.1 入队操作

```typescript
// 创建消息队列
const messageQueue = new MessageQueue();

// 添加用户消息
const userMessage: UserMessage = {
  id: 'msg-001',
  type: MessageType.USER,
  priority: MessagePriority.HIGH,
  status: MessageStatus.PENDING,
  content: '帮我重构这个函数',
  timestamp: Date.now()
};

messageQueue.enqueue(userMessage);

// 添加 Steering 消息（最高优先级）
const steeringMessage: SteeringMessage = {
  id: 'msg-002',
  type: MessageType.STEERING,
  priority: MessagePriority.CRITICAL,
  status: MessageStatus.PENDING,
  content: '等等，先修复那个 bug',
  timestamp: Date.now()
};

messageQueue.enqueue(steeringMessage);

// Steering 消息会优先处理
console.log(messageQueue.peek()?.type); // 'steering'
```

### 2.2 出队操作

```typescript
// 获取下一个待处理消息
const nextMessage = messageQueue.dequeue();

if (nextMessage) {
  console.log(`Processing message: ${nextMessage.id}`);
  console.log(`Type: ${nextMessage.type}`);
  console.log(`Priority: ${nextMessage.priority}`);

  // 处理消息
  await processMessage(nextMessage);

  // 标记为已完成
  messageQueue.markCompleted(nextMessage.id);
}
```

### 2.3 优先级处理

```typescript
// 添加不同优先级的消息
messageQueue.enqueue({
  id: 'msg-003',
  type: MessageType.TOOL_RESULT,
  priority: MessagePriority.NORMAL,
  status: MessageStatus.PENDING,
  content: 'Tool result',
  timestamp: Date.now()
});

messageQueue.enqueue({
  id: 'msg-004',
  type: MessageType.STEERING,
  priority: MessagePriority.CRITICAL,
  status: MessageStatus.PENDING,
  content: 'Stop!',
  timestamp: Date.now()
});

// Steering 消息会优先处理
const next = messageQueue.dequeue();
console.log(next?.type); // 'steering'
```

---

## 3. TypeScript/Node.js 类比

### 类比 1：Event Queue

```typescript
// 消息队列类似于 Node.js 的事件队列
const eventEmitter = new EventEmitter();

// 添加事件监听器（类似于入队）
eventEmitter.on('message', (data) => {
  console.log('Processing message:', data);
});

// 触发事件（类似于出队并处理）
eventEmitter.emit('message', { type: 'user', content: 'Hello' });
```

### 类比 2：Promise Queue

```typescript
// 消息队列类似于 Promise 队列
class PromiseQueue {
  private queue: (() => Promise<any>)[] = [];
  private processing = false;

  async enqueue(task: () => Promise<any>) {
    this.queue.push(task);
    if (!this.processing) {
      await this.process();
    }
  }

  private async process() {
    this.processing = true;
    while (this.queue.length > 0) {
      const task = this.queue.shift()!;
      await task();
    }
    this.processing = false;
  }
}
```

### 类比 3：Array.sort() 优先级

```typescript
// 优先级队列类似于数组排序
const messages = [
  { id: 1, priority: 2 },
  { id: 2, priority: 0 },
  { id: 3, priority: 1 }
];

// 按优先级排序（数字越小优先级越高）
messages.sort((a, b) => a.priority - b.priority);

console.log(messages);
// [{ id: 2, priority: 0 }, { id: 3, priority: 1 }, { id: 1, priority: 2 }]
```

---

## 4. 日常生活类比

### 类比 1：医院急诊室

想象医院的急诊室：
- **Steering 消息** = 危重病人（最高优先级，立即处理）
- **User 消息** = 普通急诊病人（高优先级）
- **Tool results** = 检查结果（普通优先级）

护士会根据病情严重程度安排就诊顺序，而不是简单的先来先服务。

### 类比 2：餐厅点餐系统

想象餐厅的点餐系统：
- **消息队列** = 厨房的订单队列
- **入队** = 服务员提交订单
- **出队** = 厨师接单制作
- **优先级** = VIP 客户的订单优先处理

### 类比 3：机场安检

想象机场的安检队列：
- **普通队列** = 普通乘客
- **优先队列** = 头等舱、商务舱乘客
- **紧急通道** = Steering 消息（需要立即处理的紧急情况）

---

## 5. 消息队列的关键特性

### 5.1 优先级管理

```typescript
// 优先级顺序
const PRIORITY_ORDER = [
  MessagePriority.CRITICAL,  // 0 - Steering
  MessagePriority.HIGH,      // 1 - User
  MessagePriority.NORMAL,    // 2 - Tool results
  MessagePriority.LOW        // 3 - Background
];

// 根据消息类型自动分配优先级
function assignPriority(message: Message): MessagePriority {
  switch (message.type) {
    case MessageType.STEERING:
      return MessagePriority.CRITICAL;
    case MessageType.USER:
      return MessagePriority.HIGH;
    case MessageType.TOOL_RESULT:
      return MessagePriority.NORMAL;
    default:
      return MessagePriority.LOW;
  }
}
```

### 5.2 去重机制

```typescript
// 去重检查
class MessageQueue {
  private messageIds = new Set<string>();

  enqueue(message: Message): void {
    // 检查是否已存在
    if (this.messageIds.has(message.id)) {
      console.warn(`Duplicate message: ${message.id}`);
      return;
    }

    this.messageIds.add(message.id);
    // ... 添加到队列
  }

  markCompleted(messageId: string): void {
    this.messageIds.delete(messageId);
    // ... 其他清理逻辑
  }
}
```

### 5.3 状态跟踪

```typescript
// 消息状态管理
class MessageQueue {
  private statusMap = new Map<string, MessageStatus>();

  updateStatus(messageId: string, status: MessageStatus): void {
    this.statusMap.set(messageId, status);

    // 触发状态变化事件
    this.emit('status-change', { messageId, status });
  }

  getStatus(messageId: string): MessageStatus | undefined {
    return this.statusMap.get(messageId);
  }

  getMessagesByStatus(status: MessageStatus): Message[] {
    return this.getAllPending().filter(
      m => this.statusMap.get(m.id) === status
    );
  }
}
```

---

## 6. 小结

本文介绍了消息队列的核心架构：

### 核心要点
1. **消息类型**：User、Assistant、Tool Call、Tool Result、Steering、Follow-up
2. **优先级管理**：Steering > User > Tool results
3. **队列操作**：enqueue、dequeue、peek、cancel、clear
4. **关键特性**：优先级、去重、状态跟踪

### TypeScript/Node.js 类比
- Event Queue（事件队列）
- Promise Queue（Promise 队列）
- Array.sort()（数组排序）

### 日常生活类比
- 医院急诊室（优先级）
- 餐厅点餐系统（队列处理）
- 机场安检（多级队列）

### 下一步
- **消息处理流程**：如何处理队列中的消息
- **状态管理**：如何跟踪消息的生命周期
- **2025-2026 架构模式**：最新的消息队列设计模式

---

## 7. 消息处理流程

### 7.1 完整处理流程

```typescript
/**
 * 消息处理器
 * 负责从队列中取出消息并处理
 */
export class MessageProcessor {
  private queue: MessageQueue;
  private isProcessing: boolean = false;
  private currentMessage: Message | null = null;

  constructor(queue: MessageQueue) {
    this.queue = queue;
  }

  /**
   * 启动消息处理循环
   */
  async start(): Promise<void> {
    this.isProcessing = true;

    while (this.isProcessing) {
      // 1. 从队列中取出下一个消息
      const message = this.queue.dequeue();

      if (!message) {
        // 队列为空，等待新消息
        await this.waitForMessage();
        continue;
      }

      // 2. 处理消息
      this.currentMessage = message;
      try {
        await this.processMessage(message);
        this.queue.markCompleted(message.id);
      } catch (error) {
        console.error(`Failed to process message ${message.id}:`, error);
        this.queue.markFailed(message.id);
      } finally {
        this.currentMessage = null;
      }
    }
  }

  /**
   * 停止消息处理
   */
  stop(): void {
    this.isProcessing = false;
  }

  /**
   * 处理单个消息
   */
  private async processMessage(message: Message): Promise<void> {
    console.log(`Processing message: ${message.id} (${message.type})`);

    switch (message.type) {
      case MessageType.USER:
        await this.handleUserMessage(message as UserMessage);
        break;

      case MessageType.STEERING:
        await this.handleSteeringMessage(message as SteeringMessage);
        break;

      case MessageType.FOLLOW_UP:
        await this.handleFollowUpMessage(message as FollowUpMessage);
        break;

      case MessageType.TOOL_CALL:
        await this.handleToolCallMessage(message as ToolCallMessage);
        break;

      case MessageType.TOOL_RESULT:
        await this.handleToolResultMessage(message as ToolResultMessage);
        break;

      default:
        console.warn(`Unknown message type: ${message.type}`);
    }
  }

  /**
   * 处理用户消息
   */
  private async handleUserMessage(message: UserMessage): Promise<void> {
    // 1. 调用 LLM
    const response = await callLLM(message.content);

    // 2. 解析工具调用
    if (response.toolCalls) {
      for (const toolCall of response.toolCalls) {
        this.queue.enqueue({
          id: `tool-${Date.now()}`,
          type: MessageType.TOOL_CALL,
          priority: MessagePriority.NORMAL,
          status: MessageStatus.PENDING,
          content: '',
          timestamp: Date.now(),
          toolName: toolCall.name,
          toolArgs: toolCall.args
        } as ToolCallMessage);
      }
    }

    // 3. 返回助手消息
    this.queue.enqueue({
      id: `assistant-${Date.now()}`,
      type: MessageType.ASSISTANT,
      priority: MessagePriority.NORMAL,
      status: MessageStatus.PENDING,
      content: response.content,
      timestamp: Date.now()
    } as AssistantMessage);
  }

  /**
   * 处理 Steering 消息
   */
  private async handleSteeringMessage(message: SteeringMessage): Promise<void> {
    // 1. 中断当前处理
    if (this.currentMessage) {
      console.log(`Interrupting current message: ${this.currentMessage.id}`);
    }

    // 2. 清空工具调用队列
    const toolCalls = this.queue.getAllPending().filter(
      m => m.type === MessageType.TOOL_CALL
    );
    for (const toolCall of toolCalls) {
      this.queue.cancel(toolCall.id);
    }

    // 3. 处理新消息
    await this.handleUserMessage(message as any);
  }

  /**
   * 处理 Follow-up 消息
   */
  private async handleFollowUpMessage(message: FollowUpMessage): Promise<void> {
    // 1. 等待指定消息完成
    await this.waitForMessageCompletion(message.waitFor);

    // 2. 处理消息
    await this.handleUserMessage(message as any);
  }

  /**
   * 等待消息完成
   */
  private async waitForMessageCompletion(messageId: string): Promise<void> {
    while (this.queue.getProcessing().includes(messageId)) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  /**
   * 等待新消息
   */
  private async waitForMessage(): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 100));
  }
}
```

### 7.2 处理流程图

```
用户发送消息
    ↓
入队（根据类型分配优先级）
    ↓
消息处理器从队列取出消息
    ↓
根据消息类型分发处理
    ↓
┌─────────────┬─────────────┬─────────────┐
│ User        │ Steering    │ Follow-up   │
│ Message     │ Message     │ Message     │
└─────────────┴─────────────┴─────────────┘
    ↓              ↓              ↓
调用 LLM      中断当前      等待完成
    ↓              ↓              ↓
解析工具调用   清空队列      调用 LLM
    ↓              ↓              ↓
工具调用入队   处理新消息    返回响应
    ↓
标记为已完成
```

---

## 8. 状态管理

### 8.1 消息生命周期

```typescript
/**
 * 消息生命周期管理
 */
export class MessageLifecycle {
  private statusMap = new Map<string, MessageStatus>();
  private listeners = new Map<string, ((status: MessageStatus) => void)[]>();

  /**
   * 更新消息状态
   */
  updateStatus(messageId: string, status: MessageStatus): void {
    const oldStatus = this.statusMap.get(messageId);
    this.statusMap.set(messageId, status);

    // 触发状态变化监听器
    this.notifyListeners(messageId, status);

    console.log(`Message ${messageId}: ${oldStatus} → ${status}`);
  }

  /**
   * 获取消息状态
   */
  getStatus(messageId: string): MessageStatus | undefined {
    return this.statusMap.get(messageId);
  }

  /**
   * 监听状态变化
   */
  onStatusChange(
    messageId: string,
    callback: (status: MessageStatus) => void
  ): void {
    if (!this.listeners.has(messageId)) {
      this.listeners.set(messageId, []);
    }
    this.listeners.get(messageId)!.push(callback);
  }

  /**
   * 通知监听器
   */
  private notifyListeners(messageId: string, status: MessageStatus): void {
    const callbacks = this.listeners.get(messageId);
    if (callbacks) {
      for (const callback of callbacks) {
        callback(status);
      }
    }
  }
}
```

### 8.2 状态转换规则

```typescript
// 允许的状态转换
const ALLOWED_TRANSITIONS: Record<MessageStatus, MessageStatus[]> = {
  [MessageStatus.PENDING]: [
    MessageStatus.PROCESSING,
    MessageStatus.CANCELLED
  ],
  [MessageStatus.PROCESSING]: [
    MessageStatus.COMPLETED,
    MessageStatus.FAILED,
    MessageStatus.CANCELLED
  ],
  [MessageStatus.COMPLETED]: [],
  [MessageStatus.FAILED]: [],
  [MessageStatus.CANCELLED]: []
};

// 验证状态转换
function isValidTransition(
  from: MessageStatus,
  to: MessageStatus
): boolean {
  return ALLOWED_TRANSITIONS[from].includes(to);
}
```

---

## 9. 2025-2026 架构模式

### 9.1 Laddr Framework：消息队列 + 可观测性

> **2025-2026 最新实践**: Laddr 框架提供了内置消息队列、可观测性和水平扩展的微服务架构。

**核心特性**：
```typescript
// Laddr 风格的消息队列设计
interface LaddrMessageQueue {
  // 消息队列
  queue: PriorityQueue<Message>;

  // 可观测性
  metrics: {
    queueSize: number;
    processingTime: number;
    errorRate: number;
  };

  // 水平扩展
  workers: Worker[];

  // 分布式追踪
  tracing: DistributedTracing;
}
```

**引用来源**：
- Laddr Framework - Message queues with observability
- https://github.com/laddr/laddr

### 9.2 MassGen：多代理缩放系统

> **2025-2026 最新实践**: MassGen 提供了多代理并行处理和消息队列优化的完整方案。

**核心架构**：
```typescript
// MassGen 风格的并行处理
interface MassGenQueue {
  // 多个消息队列（每个 Agent 一个）
  queues: Map<string, MessageQueue>;

  // 负载均衡
  loadBalancer: LoadBalancer;

  // 并行处理
  async processInParallel(messages: Message[]): Promise<void> {
    const batches = this.loadBalancer.distribute(messages);
    await Promise.all(
      batches.map(batch => this.processBatch(batch))
    );
  }
}
```

**引用来源**：
- MassGen - Multi-agent scaling system
- https://github.com/massgen/massgen

### 9.3 midstream：实时 LLM 流平台

> **2025-2026 最新实践**: midstream 提供了实时 LLM 流处理和自主代理的完整平台。

**核心设计**：
```typescript
// midstream 风格的流式消息队列
interface MidstreamQueue {
  // 流式消息队列
  stream: ReadableStream<Message>;

  // 背压处理
  backpressure: BackpressureStrategy;

  // 实时处理
  async processStream(): Promise<void> {
    for await (const message of this.stream) {
      await this.process(message);
    }
  }
}
```

**引用来源**：
- midstream - Real-time LLM streaming platform
- https://github.com/midstream/midstream

### 9.4 agentjido/jido：会话树 + 消息队列

> **2025-2026 最新实践**: agentjido/jido #119 提出了会话树结构与消息队列结合的完整方案。

**核心架构**：
```typescript
// jido 风格的会话树 + 消息队列
interface JidoSessionQueue {
  // 会话树
  sessionTree: SessionTree;

  // 每个分支一个消息队列
  branchQueues: Map<string, MessageQueue>;

  // Steering 创建新分支
  steering(message: SteeringMessage): void {
    const newBranch = this.sessionTree.createBranch(message);
    this.branchQueues.set(newBranch.id, new MessageQueue());
  }

  // Follow-up 在当前分支追加
  followUp(message: FollowUpMessage): void {
    const currentBranch = this.sessionTree.getCurrentBranch();
    this.branchQueues.get(currentBranch.id)!.enqueue(message);
  }
}
```

**引用来源**：
- GitHub agentjido/jido #119 - Session Tree Structure + Agent Steering & Follow-Up Queues
- https://github.com/agentjido/jido/issues/119

---

## 10. 实际应用示例

### 10.1 pi-mono 中的实现

```typescript
// packages/pi-agent-core/src/message-queue.ts

export class AgentMessageQueue extends MessageQueue {
  private agent: Agent;

  constructor(agent: Agent) {
    super();
    this.agent = agent;
  }

  /**
   * 处理 Steering 消息
   */
  async handleSteering(message: SteeringMessage): Promise<void> {
    // 1. 中断当前 LLM 流
    this.agent.abortCurrentStream();

    // 2. 清空工具队列
    this.clearToolQueue();

    // 3. 创建新分支
    const newBranch = this.agent.session.createBranch(message);

    // 4. 处理消息
    await this.agent.processMessage(message);
  }

  /**
   * 清空工具队列
   */
  private clearToolQueue(): void {
    const toolCalls = this.getAllPending().filter(
      m => m.type === MessageType.TOOL_CALL
    );

    for (const toolCall of toolCalls) {
      this.cancel(toolCall.id);
      console.log(`Cancelled tool call: ${toolCall.id}`);
    }
  }
}
```

### 10.2 实际使用示例

```typescript
// 创建消息队列
const queue = new MessageQueue();
const processor = new MessageProcessor(queue);

// 启动处理器
processor.start();

// 场景 1：普通用户消息
queue.enqueue({
  id: 'msg-001',
  type: MessageType.USER,
  priority: MessagePriority.HIGH,
  status: MessageStatus.PENDING,
  content: '帮我重构这个函数',
  timestamp: Date.now()
});

// 场景 2：Steering 中断
setTimeout(() => {
  queue.enqueue({
    id: 'msg-002',
    type: MessageType.STEERING,
    priority: MessagePriority.CRITICAL,
    status: MessageStatus.PENDING,
    content: '等等，先修复那个 bug',
    timestamp: Date.now()
  });
}, 1000);

// 场景 3：Follow-up 追加
setTimeout(() => {
  queue.enqueue({
    id: 'msg-003',
    type: MessageType.FOLLOW_UP,
    priority: MessagePriority.HIGH,
    status: MessageStatus.PENDING,
    content: '记得添加单元测试',
    timestamp: Date.now(),
    waitFor: 'msg-002'
  });
}, 2000);
```

---

## 11. 最佳实践

### 11.1 队列大小限制

```typescript
// 设置合理的队列大小限制
const queue = new MessageQueue(1000); // 最多 1000 条消息

// 队列满时的处理策略
class MessageQueue {
  enqueue(message: Message): void {
    if (this.size() >= this.maxSize) {
      // 策略 1：拒绝新消息
      throw new Error('Queue is full');

      // 策略 2：移除最旧的低优先级消息
      // this.removeOldestLowPriority();

      // 策略 3：等待队列有空间
      // await this.waitForSpace();
    }

    // ... 添加消息
  }
}
```

### 11.2 优雅的错误处理

```typescript
// 错误处理和重试机制
class MessageProcessor {
  private async processMessage(message: Message): Promise<void> {
    const maxRetries = 3;
    let retries = 0;

    while (retries < maxRetries) {
      try {
        await this.doProcessMessage(message);
        return;
      } catch (error) {
        retries++;
        console.error(`Retry ${retries}/${maxRetries}:`, error);

        if (retries >= maxRetries) {
          this.queue.markFailed(message.id);
          throw error;
        }

        // 指数退避
        await new Promise(resolve =>
          setTimeout(resolve, Math.pow(2, retries) * 1000)
        );
      }
    }
  }
}
```

### 11.3 性能监控

```typescript
// 添加性能监控
class MessageQueue {
  private metrics = {
    enqueueCount: 0,
    dequeueCount: 0,
    processingTime: [] as number[],
    errorCount: 0
  };

  enqueue(message: Message): void {
    this.metrics.enqueueCount++;
    // ... 入队逻辑
  }

  dequeue(): Message | null {
    const startTime = Date.now();
    const message = this.doDequeue();

    if (message) {
      this.metrics.dequeueCount++;
      this.metrics.processingTime.push(Date.now() - startTime);
    }

    return message;
  }

  getMetrics() {
    return {
      ...this.metrics,
      avgProcessingTime:
        this.metrics.processingTime.reduce((a, b) => a + b, 0) /
        this.metrics.processingTime.length
    };
  }
}
```

---

## 12. 总结

### 12.1 核心要点

1. **消息类型**：User、Assistant、Tool Call、Tool Result、Steering、Follow-up
2. **优先级管理**：Steering (0) > User (1) > Tool results (2) > Background (3)
3. **队列操作**：enqueue、dequeue、peek、cancel、clear
4. **状态管理**：PENDING → PROCESSING → COMPLETED/FAILED/CANCELLED
5. **处理流程**：入队 → 出队 → 分发 → 处理 → 标记完成

### 12.2 TypeScript/Node.js 类比

- **Event Queue**：Node.js 事件队列
- **Promise Queue**：Promise 队列
- **Array.sort()**：数组排序（优先级）

### 12.3 日常生活类比

- **医院急诊室**：优先级管理
- **餐厅点餐系统**：队列处理
- **机场安检**：多级队列

### 12.4 2025-2026 最新实践

- **Laddr Framework**：消息队列 + 可观测性 + 水平扩展
- **MassGen**：多代理并行处理
- **midstream**：实时 LLM 流处理
- **agentjido/jido**：会话树 + 消息队列

### 12.5 学习检查

- [ ] 理解消息队列的数据结构设计
- [ ] 理解优先级管理机制
- [ ] 理解消息处理流程
- [ ] 理解状态管理和生命周期
- [ ] 了解 2025-2026 最新架构模式
- [ ] 能够设计和实现消息队列

### 12.6 下一步

- **03_核心概念_03_消息传递模式.md**：学习 one-at-a-time vs all 模式
- **03_核心概念_06_队列优化策略.md**：学习批处理和去重优化
- **07_实战代码_01_基础消息队列.md**：手写完整的消息队列实现

---

**版本**: v1.0
**最后更新**: 2026-02-19
**维护者**: Claude Code
