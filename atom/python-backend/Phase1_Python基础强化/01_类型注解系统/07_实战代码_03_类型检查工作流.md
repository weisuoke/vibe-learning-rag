# 实战代码3：类型检查工作流

完整的类型检查工作流集成和最佳实践。

---

## 概述

本文档展示如何将 mypy 类型检查集成到开发工作流中，实现自动化类型检查。

---

## 1. 开发环境配置

### 1.1 项目初始化

```bash
# 创建项目目录
mkdir my-fastapi-project
cd my-fastapi-project

# 初始化 Python 项目
uv init

# 安装依赖
uv add fastapi uvicorn[standard] pydantic python-dotenv
uv add --dev mypy pytest httpx

# 创建项目结构
mkdir -p app/{api,models,services,core}
touch app/__init__.py app/main.py
```

### 1.2 mypy 配置文件

```toml
# pyproject.toml
[project]
name = "my-fastapi-project"
version = "0.1.0"
requires-python = ">=3.13"

[tool.mypy]
python_version = "3.13"
plugins = ["pydantic.mypy"]

# 严格模式
strict = true
warn_return_any = true
warn_unused_configs = true
warn_redundant_casts = true
warn_unused_ignores = true

# 输出配置
show_error_codes = true
show_column_numbers = true
pretty = true
color_output = true

# 缓存
cache_dir = ".mypy_cache"
incremental = true

# API 模块：严格检查
[[tool.mypy.overrides]]
module = "app.api.*"
disallow_untyped_defs = true
disallow_any_generics = true

# 测试模块：宽松检查
[[tool.mypy.overrides]]
module = "tests.*"
disallow_untyped_defs = false

# Pydantic 插件配置
[tool.pydantic-mypy]
init_forbid_extra = true
init_typed = true
warn_required_dynamic_aliases = true
```

### 1.3 VS Code 配置

```json
// .vscode/settings.json
{
  "python.linting.enabled": true,
  "python.linting.mypyEnabled": true,
  "python.linting.mypyArgs": [
    "--config-file=pyproject.toml"
  ],
  "python.analysis.typeCheckingMode": "basic",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.organizeImports": true
  }
}
```

---

## 2. 本地开发工作流

### 2.1 Makefile 命令

```makefile
# Makefile
.PHONY: help
help:
	@echo "Available commands:"
	@echo "  make install     - Install dependencies"
	@echo "  make dev         - Run development server"
	@echo "  make typecheck   - Run mypy type checking"
	@echo "  make test        - Run tests"
	@echo "  make lint        - Run all checks"

.PHONY: install
install:
	uv sync

.PHONY: dev
dev:
	uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

.PHONY: typecheck
typecheck:
	@echo "Running mypy..."
	mypy app/

.PHONY: typecheck-report
typecheck-report:
	@echo "Generating mypy HTML report..."
	mypy --html-report ./mypy-report app/
	@echo "Report generated at mypy-report/index.html"

.PHONY: typecheck-strict
typecheck-strict:
	@echo "Running mypy in strict mode..."
	mypy --strict app/

.PHONY: test
test:
	@echo "Running tests..."
	pytest tests/ -v

.PHONY: test-cov
test-cov:
	@echo "Running tests with coverage..."
	pytest tests/ --cov=app --cov-report=html

.PHONY: lint
lint: typecheck test
	@echo "All checks passed!"

.PHONY: clean
clean:
	rm -rf .mypy_cache mypy-report htmlcov .pytest_cache
	find . -type d -name __pycache__ -exec rm -rf {} +
```

### 2.2 开发流程

```bash
# 1. 安装依赖
make install

# 2. 启动开发服务器
make dev

# 3. 编写代码（在另一个终端）
# app/api/users.py

# 4. 运行类型检查
make typecheck

# 5. 修复类型错误
# 根据 mypy 输出修复代码

# 6. 运行测试
make test

# 7. 提交代码
git add .
git commit -m "feat: add user API"
```

---

## 3. Pre-commit Hooks

### 3.1 安装配置

```yaml
# .pre-commit-config.yaml
repos:
  # Python 代码格式化
  - repo: https://github.com/psf/black
    rev: 24.1.1
    hooks:
      - id: black
        language_version: python3.13

  # 导入排序
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
        args: ["--profile", "black"]

  # mypy 类型检查
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.8.0
    hooks:
      - id: mypy
        additional_dependencies:
          - pydantic
          - types-requests
        args:
          - --config-file=pyproject.toml
        files: ^app/

  # 基础检查
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
      - id: check-merge-conflict
```

**安装和使用：**

```bash
# 安装 pre-commit
uv add --dev pre-commit

# 安装 hooks
pre-commit install

# 手动运行所有 hooks
pre-commit run --all-files

# 跳过 hooks（不推荐）
git commit --no-verify
```

### 3.2 提交流程

```bash
# 1. 修改代码
vim app/api/users.py

# 2. 添加到暂存区
git add app/api/users.py

# 3. 提交（自动运行 pre-commit hooks）
git commit -m "feat: add user API"

# Pre-commit 会自动运行：
# - black（代码格式化）
# - isort（导入排序）
# - mypy（类型检查）
# - 基础检查

# 4. 如果检查失败，修复后重新提交
# 修复代码...
git add app/api/users.py
git commit -m "feat: add user API"
```

---

## 4. CI/CD 集成

### 4.1 GitHub Actions

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  type-check:
    name: Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install uv
        run: pip install uv

      - name: Install dependencies
        run: uv sync

      - name: Run mypy
        run: uv run mypy app/

      - name: Generate mypy report
        if: failure()
        run: uv run mypy --html-report ./mypy-report app/

      - name: Upload mypy report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: mypy-report
          path: mypy-report/

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install uv
        run: pip install uv

      - name: Install dependencies
        run: uv sync

      - name: Run tests
        run: uv run pytest tests/ -v --cov=app

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install uv
        run: pip install uv

      - name: Install dependencies
        run: uv sync

      - name: Run black
        run: uv run black --check app/

      - name: Run isort
        run: uv run isort --check-only app/
```

### 4.2 GitLab CI

```yaml
# .gitlab-ci.yml
stages:
  - check
  - test

variables:
  PYTHON_VERSION: "3.13"

before_script:
  - pip install uv
  - uv sync

type-check:
  stage: check
  script:
    - uv run mypy app/
  artifacts:
    when: on_failure
    paths:
      - mypy-report/
    expire_in: 1 week

test:
  stage: test
  script:
    - uv run pytest tests/ -v --cov=app
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

lint:
  stage: check
  script:
    - uv run black --check app/
    - uv run isort --check-only app/
```

---

## 5. 渐进式类型化策略

### 5.1 第一阶段：基础类型注解

```python
# app/api/users.py
from fastapi import APIRouter

router = APIRouter()

# 第一步：添加基础类型注解
@router.get("/users/{user_id}")
async def get_user(user_id: int):  # 添加参数类型
    return {"user_id": user_id}

# mypy 配置：宽松模式
# [tool.mypy]
# disallow_untyped_defs = false
```

### 5.2 第二阶段：返回值类型

```python
# app/api/users.py
from fastapi import APIRouter

router = APIRouter()

# 第二步：添加返回值类型
@router.get("/users/{user_id}")
async def get_user(user_id: int) -> dict:  # 添加返回类型
    return {"user_id": user_id}

# mypy 配置：检查返回值
# [tool.mypy]
# warn_return_any = true
```

### 5.3 第三阶段：Pydantic 模型

```python
# app/models/user.py
from pydantic import BaseModel

class UserResponse(BaseModel):
    user_id: int
    name: str

# app/api/users.py
from fastapi import APIRouter
from app.models.user import UserResponse

router = APIRouter()

# 第三步：使用 Pydantic 模型
@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int) -> UserResponse:
    return UserResponse(user_id=user_id, name="Alice")

# mypy 配置：严格模式
# [tool.mypy]
# strict = true
```

### 5.4 第四阶段：完整类型化

```python
# app/models/user.py
from pydantic import BaseModel, Field
from typing import Optional

class UserResponse(BaseModel):
    user_id: int = Field(..., gt=0)
    name: str = Field(..., min_length=1)
    email: Optional[str] = None

# app/services/user_service.py
from typing import Optional
from app.models.user import UserResponse

class UserService:
    def get_user(self, user_id: int) -> Optional[UserResponse]:
        # 完整的类型注解
        if user_id <= 0:
            return None
        return UserResponse(user_id=user_id, name="Alice")

# app/api/users.py
from fastapi import APIRouter, HTTPException, Depends
from app.models.user import UserResponse
from app.services.user_service import UserService

router = APIRouter()

def get_user_service() -> UserService:
    return UserService()

@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    service: UserService = Depends(get_user_service)
) -> UserResponse:
    user = service.get_user(user_id)
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user
```

---

## 6. 常见问题处理

### 6.1 第三方库缺少类型定义

```bash
# 安装类型定义包
uv add --dev types-requests types-redis types-pyyaml

# 或在配置中忽略
# pyproject.toml
[[tool.mypy.overrides]]
module = "some_library"
ignore_missing_imports = true
```

### 6.2 动态代码类型检查

```python
from typing import Any, cast

# 方法1：使用 Any
def process_dynamic(data: Any) -> str:
    return str(data)

# 方法2：使用 cast
def process_dict(data: dict) -> str:
    value = cast(str, data.get("key"))
    return value.upper()

# 方法3：使用 type: ignore
result = some_dynamic_function()  # type: ignore
```

### 6.3 循环导入问题

```python
# app/models/user.py
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    # 只在类型检查时导入，避免循环导入
    from app.models.post import Post

class User:
    def get_posts(self) -> list["Post"]:
        # 使用字符串引用类型
        pass
```

---

## 7. 完整项目示例

### 7.1 项目结构

```
my-fastapi-project/
├── .github/
│   └── workflows/
│       └── ci.yml
├── .vscode/
│   └── settings.json
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── api/
│   │   ├── __init__.py
│   │   └── users.py
│   ├── models/
│   │   ├── __init__.py
│   │   └── user.py
│   ├── services/
│   │   ├── __init__.py
│   │   └── user_service.py
│   └── core/
│       ├── __init__.py
│       └── config.py
├── tests/
│   ├── __init__.py
│   └── test_users.py
├── .pre-commit-config.yaml
├── pyproject.toml
├── Makefile
└── README.md
```

### 7.2 完整代码示例

**app/models/user.py:**

```python
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=50)
    email: str = Field(..., pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")

class CreateUserRequest(UserBase):
    password: str = Field(..., min_length=8)

class UserResponse(UserBase):
    id: int
    created_at: datetime

    class Config:
        from_attributes = True
```

**app/services/user_service.py:**

```python
from typing import Optional, List
from app.models.user import CreateUserRequest, UserResponse
from datetime import datetime

class UserService:
    def __init__(self):
        self._users: dict[int, UserResponse] = {}
        self._next_id = 1

    def create_user(self, user: CreateUserRequest) -> UserResponse:
        new_user = UserResponse(
            id=self._next_id,
            name=user.name,
            email=user.email,
            created_at=datetime.now()
        )
        self._users[self._next_id] = new_user
        self._next_id += 1
        return new_user

    def get_user(self, user_id: int) -> Optional[UserResponse]:
        return self._users.get(user_id)

    def list_users(self) -> List[UserResponse]:
        return list(self._users.values())
```

**app/api/users.py:**

```python
from fastapi import APIRouter, HTTPException, Depends, status
from typing import List
from app.models.user import CreateUserRequest, UserResponse
from app.services.user_service import UserService

router = APIRouter(prefix="/users", tags=["users"])

def get_user_service() -> UserService:
    return UserService()

@router.post("", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(
    user: CreateUserRequest,
    service: UserService = Depends(get_user_service)
) -> UserResponse:
    return service.create_user(user)

@router.get("", response_model=List[UserResponse])
async def list_users(
    service: UserService = Depends(get_user_service)
) -> List[UserResponse]:
    return service.list_users()

@router.get("/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    service: UserService = Depends(get_user_service)
) -> UserResponse:
    user = service.get_user(user_id)
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user
```

**app/main.py:**

```python
from fastapi import FastAPI
from app.api import users

app = FastAPI(
    title="User Management API",
    version="1.0.0"
)

app.include_router(users.router)

@app.get("/")
async def root() -> dict[str, str]:
    return {"message": "Welcome to User Management API"}

@app.get("/health")
async def health() -> dict[str, str]:
    return {"status": "healthy"}
```

**tests/test_users.py:**

```python
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_create_user() -> None:
    response = client.post(
        "/users",
        json={
            "name": "Alice",
            "email": "alice@example.com",
            "password": "SecurePass123"
        }
    )
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Alice"
    assert data["email"] == "alice@example.com"
    assert "id" in data

def test_get_user() -> None:
    # 先创建用户
    create_response = client.post(
        "/users",
        json={
            "name": "Bob",
            "email": "bob@example.com",
            "password": "SecurePass123"
        }
    )
    user_id = create_response.json()["id"]

    # 获取用户
    response = client.get(f"/users/{user_id}")
    assert response.status_code == 200
    data = response.json()
    assert data["name"] == "Bob"

def test_get_nonexistent_user() -> None:
    response = client.get("/users/999")
    assert response.status_code == 404
```

### 7.3 运行工作流

```bash
# 1. 安装依赖
make install

# 2. 运行类型检查
make typecheck
# Success: no issues found in 4 source files

# 3. 运行测试
make test
# ===== 3 passed in 0.5s =====

# 4. 运行所有检查
make lint
# Running mypy...
# Success: no issues found in 4 source files
# Running tests...
# ===== 3 passed in 0.5s =====
# All checks passed!

# 5. 提交代码
git add .
git commit -m "feat: add user management API"
# Pre-commit hooks 自动运行并通过

# 6. 推送到远程
git push origin main
# GitHub Actions 自动运行 CI
```

---

## 8. 最佳实践总结

### 8.1 开发流程

```
编写代码 → 本地类型检查 → 运行测试 → Pre-commit hooks → 提交代码 → CI/CD 检查
```

### 8.2 配置建议

**新项目：**
- 从严格模式开始
- 所有函数都加类型注解
- 使用 Pydantic 模型
- 配置 pre-commit hooks
- 集成 CI/CD

**旧项目：**
- 渐进式添加类型注解
- 按模块配置严格程度
- 优先给公共 API 加类型
- 逐步收紧 mypy 配置

### 8.3 团队协作

1. **统一配置**：使用 pyproject.toml 统一 mypy 配置
2. **代码审查**：PR 中检查类型注解质量
3. **文档化**：在 README 中说明类型检查要求
4. **培训**：团队成员学习类型注解最佳实践

### 8.4 性能优化

```toml
# pyproject.toml
[tool.mypy]
# 使用缓存
cache_dir = ".mypy_cache"
incremental = true

# 并行检查（多核）
# mypy --parallel app/

# 只检查修改的文件
# mypy $(git diff --name-only --diff-filter=ACMR | grep '\.py$')
```

---

## 9. 故障排查

### 9.1 mypy 报错但代码能运行

**原因：** mypy 是静态检查，Python 运行时不检查类型。

**解决：** 修复类型错误，或使用 `# type: ignore` 忽略。

### 9.2 第三方库类型错误

**原因：** 库没有类型定义或类型定义不完整。

**解决：**
```bash
# 安装类型定义
uv add --dev types-<library>

# 或忽略
[[tool.mypy.overrides]]
module = "<library>"
ignore_missing_imports = true
```

### 9.3 mypy 太慢

**原因：** 项目太大或缓存失效。

**解决：**
```bash
# 清理缓存
rm -rf .mypy_cache

# 使用增量检查
[tool.mypy]
incremental = true

# 并行检查
mypy --parallel app/
```

### 9.4 CI 中 mypy 失败但本地通过

**原因：** 环境不一致或依赖版本不同。

**解决：**
```yaml
# .github/workflows/ci.yml
- name: Install dependencies
  run: uv sync --frozen  # 使用锁定的依赖版本
```

---

## 总结

### 工作流核心要素

1. **本地开发**：Makefile + VS Code 集成
2. **提交前检查**：Pre-commit hooks
3. **CI/CD**：GitHub Actions / GitLab CI
4. **渐进式**：从宽松到严格
5. **团队协作**：统一配置和规范

### 快速启动清单

- [ ] 配置 pyproject.toml
- [ ] 创建 Makefile
- [ ] 配置 VS Code
- [ ] 安装 pre-commit hooks
- [ ] 配置 CI/CD
- [ ] 编写测试
- [ ] 运行类型检查
- [ ] 提交代码

### 下一步

完成类型检查工作流配置后，可以：
- 在实际项目中应用
- 优化 mypy 配置
- 添加更多自动化检查
- 持续改进类型注解质量
