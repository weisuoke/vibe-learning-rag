# 实战代码：自定义验证器

> 完整可运行的自定义验证器示例

---

## 场景概述

本文提供3个自定义验证器场景，展示如何使用 `@validator` 和 `@root_validator` 实现复杂的业务规则验证。

---

## 场景1：密码强度验证器

### 需求

- 验证密码长度（8-50个字符）
- 验证密码包含大小写字母、数字、特殊字符
- 验证密码不包含用户名
- 验证密码不是常见弱密码

### 完整代码

```python
"""
场景1：密码强度验证器
演示复杂的字段验证逻辑
"""

from fastapi import FastAPI
from pydantic import BaseModel, Field, validator
import re

app = FastAPI(title="密码验证 API")

# 常见弱密码列表
WEAK_PASSWORDS = {
    "password", "12345678", "qwerty", "abc123", "password123",
    "admin123", "letmein", "welcome", "monkey", "dragon"
}

class PasswordChange(BaseModel):
    """密码修改请求"""

    username: str = Field(..., min_length=3, max_length=20)
    old_password: str
    new_password: str = Field(..., min_length=8, max_length=50)
    confirm_password: str

    @validator('new_password')
    def password_strength(cls, v, values):
        """验证密码强度"""

        # 1. 检查长度（Field 已验证，这里是双重保险）
        if len(v) < 8:
            raise ValueError('密码至少需要8个字符')

        # 2. 检查是否包含大写字母
        if not re.search(r'[A-Z]', v):
            raise ValueError('密码必须包含至少一个大写字母')

        # 3. 检查是否包含小写字母
        if not re.search(r'[a-z]', v):
            raise ValueError('密码必须包含至少一个小写字母')

        # 4. 检查是否包含数字
        if not re.search(r'\d', v):
            raise ValueError('密码必须包含至少一个数字')

        # 5. 检查是否包含特殊字符
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', v):
            raise ValueError('密码必须包含至少一个特殊字符 (!@#$%^&*等)')

        # 6. 检查是否包含用户名
        username = values.get('username', '').lower()
        if username and username in v.lower():
            raise ValueError('密码不能包含用户名')

        # 7. 检查是否是常见弱密码
        if v.lower() in WEAK_PASSWORDS:
            raise ValueError('密码过于简单，请使用更强的密码')

        # 8. 检查是否有连续重复字符（如 "aaa", "111"）
        if re.search(r'(.)\1{2,}', v):
            raise ValueError('密码不能包含3个或以上连续重复的字符')

        # 9. 检查是否有连续递增/递减数字（如 "123", "987"）
        for i in range(len(v) - 2):
            if v[i:i+3].isdigit():
                nums = [int(c) for c in v[i:i+3]]
                if nums[1] - nums[0] == 1 and nums[2] - nums[1] == 1:
                    raise ValueError('密码不能包含连续递增的数字（如123）')
                if nums[0] - nums[1] == 1 and nums[1] - nums[2] == 1:
                    raise ValueError('密码不能包含连续递减的数字（如987）')

        return v

    @validator('confirm_password')
    def passwords_match(cls, v, values):
        """验证两次密码输入一致"""
        new_password = values.get('new_password')
        if new_password and v != new_password:
            raise ValueError('两次输入的密码不一致')
        return v

@app.post("/change-password")
async def change_password(request: PasswordChange):
    """修改密码端点"""
    # 这里应该验证 old_password 是否正确
    # 简化示例，直接返回成功
    return {"message": "密码修改成功"}

if __name__ == "__main__":
    import uvicorn
    print("场景1：密码强度验证器")
    print("访问 http://localhost:8000/docs 测试")
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 场景2：日期范围验证器

### 需求

- 验证开始日期和结束日期格式
- 验证开始日期早于结束日期
- 验证日期范围不超过指定天数
- 验证日期不能是未来日期

### 完整代码

```python
"""
场景2：日期范围验证器
演示日期相关的验证逻辑
"""

from fastapi import FastAPI
from pydantic import BaseModel, Field, validator, root_validator
from datetime import datetime, timedelta
from typing import Optional

app = FastAPI(title="日期验证 API")

class DateRangeQuery(BaseModel):
    """日期范围查询请求"""

    start_date: str = Field(..., description="开始日期 (YYYY-MM-DD)")
    end_date: str = Field(..., description="结束日期 (YYYY-MM-DD)")
    max_days: Optional[int] = Field(default=90, ge=1, le=365, description="最大天数限制")
    allow_future: bool = Field(default=False, description="是否允许未来日期")

    @validator('start_date', 'end_date')
    def validate_date_format(cls, v):
        """验证日期格式"""
        try:
            date_obj = datetime.strptime(v, '%Y-%m-%d')
            return v
        except ValueError:
            raise ValueError('日期格式必须是 YYYY-MM-DD')

    @validator('end_date')
    def validate_future_date(cls, v, values):
        """验证是否允许未来日期"""
        allow_future = values.get('allow_future', False)
        if not allow_future:
            end_date = datetime.strptime(v, '%Y-%m-%d')
            today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
            if end_date > today:
                raise ValueError('结束日期不能是未来日期')
        return v

    @root_validator
    def validate_date_range(cls, values):
        """验证日期范围"""
        start_date_str = values.get('start_date')
        end_date_str = values.get('end_date')
        max_days = values.get('max_days', 90)

        if not start_date_str or not end_date_str:
            return values

        start_date = datetime.strptime(start_date_str, '%Y-%m-%d')
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d')

        # 1. 验证开始日期早于结束日期
        if start_date > end_date:
            raise ValueError('开始日期必须早于或等于结束日期')

        # 2. 验证日期范围不超过最大天数
        days_diff = (end_date - start_date).days
        if days_diff > max_days:
            raise ValueError(f'日期范围不能超过 {max_days} 天（当前: {days_diff} 天）')

        # 3. 添加计算字段
        values['days_count'] = days_diff + 1  # 包含开始和结束日期

        return values

@app.post("/query-by-date")
async def query_by_date(query: DateRangeQuery):
    """按日期范围查询"""
    return {
        "start_date": query.start_date,
        "end_date": query.end_date,
        "days_count": query.dict().get('days_count', 0)
    }

if __name__ == "__main__":
    import uvicorn
    print("场景2：日期范围验证器")
    print("访问 http://localhost:8000/docs 测试")
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 场景3：文件上传验证器

### 需求

- 验证文件类型（MIME type 和扩展名）
- 验证文件大小
- 验证文件名（不包含特殊字符）
- 验证图片尺寸（如果是图片）

### 完整代码

```python
"""
场景3：文件上传验证器
演示文件相关的验证逻辑
"""

from fastapi import FastAPI, UploadFile, File, HTTPException
from pydantic import BaseModel, Field, validator
from typing import List, Optional
import re

app = FastAPI(title="文件上传验证 API")

# 允许的文件类型
ALLOWED_MIME_TYPES = {
    'image/jpeg': ['.jpg', '.jpeg'],
    'image/png': ['.png'],
    'image/gif': ['.gif'],
    'application/pdf': ['.pdf'],
    'text/plain': ['.txt'],
    'text/markdown': ['.md']
}

class FileMetadata(BaseModel):
    """文件元数据"""

    filename: str = Field(..., min_length=1, max_length=255)
    content_type: str
    size_bytes: int = Field(..., gt=0)
    max_size_mb: int = Field(default=10, ge=1, le=100)

    @validator('filename')
    def validate_filename(cls, v):
        """验证文件名"""
        # 1. 不能包含路径分隔符
        if '/' in v or '\\' in v:
            raise ValueError('文件名不能包含路径分隔符')

        # 2. 不能包含特殊字符（只允许字母、数字、下划线、连字符、点）
        if not re.match(r'^[a-zA-Z0-9_.-]+$', v):
            raise ValueError('文件名只能包含字母、数字、下划线、连字符和点')

        # 3. 必须有扩展名
        if '.' not in v:
            raise ValueError('文件名必须包含扩展名')

        # 4. 扩展名不能为空
        ext = v.rsplit('.', 1)[-1]
        if not ext:
            raise ValueError('文件扩展名不能为空')

        return v

    @validator('content_type')
    def validate_content_type(cls, v, values):
        """验证文件类型"""
        filename = values.get('filename', '')

        # 1. 检查 MIME type 是否允许
        if v not in ALLOWED_MIME_TYPES:
            allowed = ', '.join(ALLOWED_MIME_TYPES.keys())
            raise ValueError(f'不支持的文件类型。允许的类型: {allowed}')

        # 2. 检查扩展名是否匹配 MIME type
        if filename:
            ext = '.' + filename.rsplit('.', 1)[-1].lower()
            allowed_exts = ALLOWED_MIME_TYPES[v]
            if ext not in allowed_exts:
                raise ValueError(
                    f'文件扩展名 {ext} 与 MIME type {v} 不匹配。'
                    f'期望的扩展名: {", ".join(allowed_exts)}'
                )

        return v

    @validator('size_bytes')
    def validate_file_size(cls, v, values):
        """验证文件大小"""
        max_size_mb = values.get('max_size_mb', 10)
        max_size_bytes = max_size_mb * 1024 * 1024

        if v > max_size_bytes:
            raise ValueError(
                f'文件大小超过限制。'
                f'最大: {max_size_mb}MB ({max_size_bytes} bytes)，'
                f'实际: {v / 1024 / 1024:.2f}MB ({v} bytes)'
            )

        return v

class ImageMetadata(FileMetadata):
    """图片元数据（扩展文件元数据）"""

    width: Optional[int] = Field(default=None, ge=1)
    height: Optional[int] = Field(default=None, ge=1)
    min_width: int = Field(default=100, ge=1)
    min_height: int = Field(default=100, ge=1)
    max_width: int = Field(default=4000, ge=1)
    max_height: int = Field(default=4000, ge=1)

    @validator('content_type')
    def validate_image_type(cls, v):
        """验证是图片类型"""
        if not v.startswith('image/'):
            raise ValueError('必须是图片类型')
        return v

    @validator('width')
    def validate_width(cls, v, values):
        """验证图片宽度"""
        if v is None:
            return v

        min_width = values.get('min_width', 100)
        max_width = values.get('max_width', 4000)

        if v < min_width:
            raise ValueError(f'图片宽度不能小于 {min_width}px（当前: {v}px）')
        if v > max_width:
            raise ValueError(f'图片宽度不能大于 {max_width}px（当前: {v}px）')

        return v

    @validator('height')
    def validate_height(cls, v, values):
        """验证图片高度"""
        if v is None:
            return v

        min_height = values.get('min_height', 100)
        max_height = values.get('max_height', 4000)

        if v < min_height:
            raise ValueError(f'图片高度不能小于 {min_height}px（当前: {v}px）')
        if v > max_height:
            raise ValueError(f'图片高度不能大于 {max_height}px（当前: {v}px）')

        return v

@app.post("/upload/file")
async def upload_file(metadata: FileMetadata):
    """上传文件（验证元数据）"""
    return {
        "message": "文件验证通过",
        "filename": metadata.filename,
        "size_mb": metadata.size_bytes / 1024 / 1024
    }

@app.post("/upload/image")
async def upload_image(metadata: ImageMetadata):
    """上传图片（验证元数据和尺寸）"""
    return {
        "message": "图片验证通过",
        "filename": metadata.filename,
        "size_mb": metadata.size_bytes / 1024 / 1024,
        "dimensions": f"{metadata.width}x{metadata.height}" if metadata.width and metadata.height else None
    }

if __name__ == "__main__":
    import uvicorn
    print("场景3：文件上传验证器")
    print("访问 http://localhost:8000/docs 测试")
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 场景4：AI Agent 工具参数验证

### 需求

- 验证工具名称是否存在
- 验证参数是否符合工具定义
- 验证参数类型和值范围
- 动态验证（根据工具类型验证不同的参数）

### 完整代码

```python
"""
场景4：AI Agent 工具参数验证
演示动态验证逻辑
"""

from fastapi import FastAPI
from pydantic import BaseModel, Field, validator, root_validator
from typing import Dict, Any, List
from enum import Enum

app = FastAPI(title="Agent 工具验证 API")

# 工具定义
TOOL_DEFINITIONS = {
    "search": {
        "required_params": ["query"],
        "optional_params": ["max_results"],
        "param_types": {
            "query": str,
            "max_results": int
        },
        "param_constraints": {
            "query": {"min_length": 1, "max_length": 200},
            "max_results": {"min": 1, "max": 100}
        }
    },
    "calculate": {
        "required_params": ["expression"],
        "optional_params": [],
        "param_types": {
            "expression": str
        },
        "param_constraints": {
            "expression": {"min_length": 1, "max_length": 500}
        }
    },
    "weather": {
        "required_params": ["location"],
        "optional_params": ["units"],
        "param_types": {
            "location": str,
            "units": str
        },
        "param_constraints": {
            "location": {"min_length": 1, "max_length": 100},
            "units": {"allowed_values": ["celsius", "fahrenheit"]}
        }
    }
}

class ToolCall(BaseModel):
    """工具调用请求"""

    tool_name: str = Field(..., min_length=1)
    parameters: Dict[str, Any] = Field(default_factory=dict)

    @validator('tool_name')
    def validate_tool_exists(cls, v):
        """验证工具是否存在"""
        if v not in TOOL_DEFINITIONS:
            available = ', '.join(TOOL_DEFINITIONS.keys())
            raise ValueError(f'工具 "{v}" 不存在。可用工具: {available}')
        return v

    @root_validator
    def validate_parameters(cls, values):
        """验证工具参数"""
        tool_name = values.get('tool_name')
        parameters = values.get('parameters', {})

        if not tool_name or tool_name not in TOOL_DEFINITIONS:
            return values

        tool_def = TOOL_DEFINITIONS[tool_name]

        # 1. 验证必需参数
        required_params = tool_def['required_params']
        for param in required_params:
            if param not in parameters:
                raise ValueError(f'工具 "{tool_name}" 缺少必需参数: {param}')

        # 2. 验证参数类型
        param_types = tool_def['param_types']
        for param, value in parameters.items():
            if param not in param_types:
                raise ValueError(f'工具 "{tool_name}" 不支持参数: {param}')

            expected_type = param_types[param]
            if not isinstance(value, expected_type):
                raise ValueError(
                    f'参数 "{param}" 类型错误。'
                    f'期望: {expected_type.__name__}，实际: {type(value).__name__}'
                )

        # 3. 验证参数约束
        param_constraints = tool_def.get('param_constraints', {})
        for param, value in parameters.items():
            if param not in param_constraints:
                continue

            constraints = param_constraints[param]

            # 字符串长度约束
            if isinstance(value, str):
                if 'min_length' in constraints and len(value) < constraints['min_length']:
                    raise ValueError(
                        f'参数 "{param}" 长度不能小于 {constraints["min_length"]}'
                    )
                if 'max_length' in constraints and len(value) > constraints['max_length']:
                    raise ValueError(
                        f'参数 "{param}" 长度不能大于 {constraints["max_length"]}'
                    )

            # 数字范围约束
            if isinstance(value, (int, float)):
                if 'min' in constraints and value < constraints['min']:
                    raise ValueError(
                        f'参数 "{param}" 不能小于 {constraints["min"]}'
                    )
                if 'max' in constraints and value > constraints['max']:
                    raise ValueError(
                        f'参数 "{param}" 不能大于 {constraints["max"]}'
                    )

            # 枚举值约束
            if 'allowed_values' in constraints:
                allowed = constraints['allowed_values']
                if value not in allowed:
                    raise ValueError(
                        f'参数 "{param}" 必须是以下值之一: {", ".join(allowed)}'
                    )

        return values

@app.post("/agent/tool/execute")
async def execute_tool(tool_call: ToolCall):
    """执行工具"""
    return {
        "message": "工具调用验证通过",
        "tool": tool_call.tool_name,
        "parameters": tool_call.parameters
    }

if __name__ == "__main__":
    import uvicorn
    print("场景4：AI Agent 工具参数验证")
    print("访问 http://localhost:8000/docs 测试")
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 核心要点

1. **@validator** - 单字段验证，可访问其他已验证字段
2. **@root_validator** - 多字段联合验证，可访问所有字段
3. **复杂逻辑** - 使用正则表达式、日期计算、动态验证
4. **清晰错误** - 提供详细的错误消息，帮助用户快速定位问题
5. **业务规则** - 将业务规则封装在验证器中，保持代码整洁

---

**版本：** v1.0
**最后更新：** 2026-02-11
