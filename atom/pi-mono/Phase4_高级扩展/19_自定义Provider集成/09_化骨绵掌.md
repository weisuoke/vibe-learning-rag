# 化骨绵掌

## 卡片1：Provider注册机制

**核心概念：**
pi-mono使用Map管理Provider注册，通过`pi.registerProvider()`动态注册。

**关键代码：**
```typescript
// packages/ai/src/api-registry.ts
const apiProviderRegistry = new Map<string, RegisteredApiProvider>();

export function registerApiProvider(provider: ApiProvider, sourceId?: string) {
  apiProviderRegistry.set(provider.api, {
    provider: {
      api: provider.api,
      stream: wrapStream(provider.api, provider.stream),
      streamSimple: wrapStreamSimple(provider.api, provider.streamSimple),
    },
    sourceId,
  });
}
```

**实际应用：**
- Extension通过`pi.registerProvider()`注册
- 运行时动态加载，无需修改源码
- sourceId用于Extension管理和卸载

**记忆要点：**
Map存储 → 动态注册 → Extension解耦

---

## 卡片2：models.json配置结构

**核心概念：**
声明式配置文件，支持Provider和Model定义。

**配置结构：**
```json
{
  "providers": {
    "provider-id": {
      "baseUrl": "https://api.example.com/v1",
      "apiKey": "API_KEY_ENV_VAR",
      "api": "openai-completions",
      "models": [
        {
          "id": "model-id",
          "name": "Model Name",
          "contextWindow": 128000,
          "maxTokens": 16384
        }
      ]
    }
  }
}
```

**配置优先级：**
1. 项目级（`.pi/agent/models.json`）
2. 用户级（`~/.pi/agent/models.json`）
3. 内置默认

**记忆要点：**
声明式 → 热重载 → 三级优先级

---

## 卡片3：OAuth认证流程

**核心概念：**
Device Code Flow适合CLI环境的OAuth认证。

**流程步骤：**
```
1. 请求设备代码 → device_code + user_code
2. 显示用户代码 → 用户访问URL输入代码
3. 轮询Token → authorization_pending → access_token
4. 存储凭证 → ~/.pi/agent/auth.json
```

**接口定义：**
```typescript
interface OAuthProviderInterface {
  login(callbacks: OAuthLoginCallbacks): Promise<OAuthCredentials>
  refreshToken(credentials: OAuthCredentials): Promise<OAuthCredentials>
  getApiKey(credentials: OAuthCredentials): string
}
```

**记忆要点：**
Device Code → 轮询 → 三个方法

---

## 卡片4：Token刷新策略

**核心概念：**
自动Token刷新，对用户透明。

**刷新时机：**
- Token即将过期（提前5分钟）
- 每次API调用前检查
- 自动调用`refreshToken()`

**实现逻辑：**
```typescript
async function getValidToken(credentials: OAuthCredentials): Promise<string> {
  const now = Date.now();
  const expiresIn = credentials.expires - now;

  if (expiresIn < 5 * 60 * 1000) {
    // Token即将过期，刷新
    const newCredentials = await refreshToken(credentials);
    await saveCredentials(newCredentials);
    return newCredentials.access;
  }

  return credentials.access;
}
```

**记忆要点：**
提前5分钟 → 自动刷新 → 透明处理

---

## 卡片5：API适配器模式

**核心概念：**
统一不同LLM API为AssistantMessageEventStream。

**适配器类型：**
- `openai-completions` - OpenAI兼容（最常用）
- `anthropic-messages` - Anthropic格式
- `google-generative-ai` - Google格式
- 自定义 - 实现streamSimple

**统一接口：**
```typescript
type AssistantMessageEventStream = AsyncIterator<AssistantMessageEvent>

type AssistantMessageEvent =
  | { type: "start", partial: AssistantMessage }
  | { type: "text_delta", delta: string, partial: AssistantMessage }
  | { type: "done", message: AssistantMessage }
```

**记忆要点：**
多种API → 统一事件流 → 核心解耦

---

## 卡片6：流式事件处理

**核心概念：**
统一的流式事件格式，支持文本、工具调用、推理。

**事件类型：**
```typescript
// 开始
{ type: "start", partial: output }

// 文本
{ type: "text_start", contentIndex, partial }
{ type: "text_delta", contentIndex, delta, partial }
{ type: "text_end", contentIndex, content, partial }

// 工具调用
{ type: "toolcall_start", contentIndex, partial }
{ type: "toolcall_delta", contentIndex, delta, partial }
{ type: "toolcall_end", contentIndex, toolCall, partial }

// 结束
{ type: "done", reason, message }
{ type: "error", reason, error }
```

**处理模式：**
```typescript
for await (const event of stream) {
  if (event.type === "text_delta") {
    process.stdout.write(event.delta);
  }
}
```

**记忆要点：**
统一事件 → 流式处理 → 实时反馈

---

## 卡片7：错误处理与重试

**核心概念：**
指数退避重试，优雅的错误处理。

**重试策略：**
```typescript
async function fetchWithRetry(fn: () => Promise<Response>, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fn();

      if (response.status === 429) {
        // Rate limit
        const delay = Math.pow(2, i) * 1000;
        await sleep(delay);
        continue;
      }

      return response;
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await sleep(Math.pow(2, i) * 1000);
    }
  }
}
```

**错误类型：**
- 网络错误 → 重试
- Rate limit → 指数退避
- Token过期 → 自动刷新
- 授权失败 → 提示重新登录

**记忆要点：**
指数退避 → 分类处理 → 用户友好

---

## 卡片8：Extension API使用

**核心概念：**
Extension是pi-mono的插件系统。

**Extension结构：**
```typescript
// index.ts
export default function(pi: ExtensionAPI) {
  // 注册Provider
  pi.registerProvider('my-provider', { ... });

  // 注册工具
  pi.registerTool({ ... });

  // 监听事件
  pi.onEvent('session:start', () => { ... });
}
```

**加载方式：**
```json
// ~/.pi/agent/settings.json
{
  "extensions": [
    "~/.pi/agent/extensions/my-extension",
    "/absolute/path/to/extension"
  ]
}
```

**记忆要点：**
插件化 → 动态加载 → 完全解耦

---

## 卡片9：测试与调试

**核心概念：**
完整的测试策略，确保Provider正常工作。

**测试层级：**
```typescript
// 1. 单元测试 - Mock API
test("streamSimple returns correct events", async () => {
  const mockResponse = createMockResponse();
  const stream = streamMyProvider(model, context);
  const events = await collectEvents(stream);
  expect(events).toMatchSnapshot();
});

// 2. 集成测试 - 真实API
test("Provider works with real API", async () => {
  const stream = streamMyProvider(model, context, {
    apiKey: process.env.TEST_API_KEY,
  });
  const message = await getFirstMessage(stream);
  expect(message.content).toBeDefined();
});

// 3. 端到端测试 - pi-coding-agent
test("Extension loads and works", async () => {
  const pi = await startPi({ extensions: ["./my-extension"] });
  const response = await pi.chat("Hello");
  expect(response).toContain("Hello");
});
```

**调试技巧：**
- 添加console.log
- 使用curl测试API
- 检查auth.json
- 查看pi日志

**记忆要点：**
三层测试 → Mock优先 → 日志调试

---

## 卡片10：生产环境部署

**核心概念：**
生产环境的安全性、性能和监控。

**安全检查清单：**
- [ ] API Key使用环境变量
- [ ] OAuth凭证加密存储
- [ ] HTTPS传输
- [ ] Token自动刷新
- [ ] 错误不泄露敏感信息

**性能优化：**
```typescript
// 1. 连接复用
const agent = new https.Agent({ keepAlive: true });

// 2. 请求超时
const controller = new AbortController();
setTimeout(() => controller.abort(), 30000);

// 3. 并发控制
const semaphore = new Semaphore(5); // 最多5个并发请求
```

**监控指标：**
- API调用成功率
- 平均响应时间
- Token刷新频率
- 错误类型分布
- 成本追踪

**记忆要点：**
安全第一 → 性能优化 → 监控完善
