# 核心概念3：一对一与自引用关系

> 进阶关系类型：一对一关系和自引用关系

---

## 概述

本文介绍两种进阶关系类型：

1. **一对一关系**：一个对象只能关联一个另一类对象，反之亦然
2. **自引用关系**：表引用自己，用于树形结构、关注系统等场景

---

## 第一部分：一对一关系

### 1.1 什么是一对一关系？

**一对一关系**表示一个对象只能关联一个另一类对象，且反向也是唯一的。

**典型场景：**
- 用户 ↔ 个人资料（一个用户只有一个个人资料）
- 用户 ↔ 设置（一个用户只有一个设置）
- 订单 ↔ 发票（一个订单只有一张发票）
- 员工 ↔ 工位（一个员工只有一个工位）

### 1.2 基本定义

```python
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(String)

    # 一对一关系：uselist=False
    profile = relationship(
        "Profile",
        uselist=False,  # 关键：返回单个对象而非列表
        back_populates="user"
    )

class Profile(Base):
    __tablename__ = 'profiles'
    id = Column(Integer, primary_key=True)
    bio = Column(String)
    avatar = Column(String)

    # 外键
    user_id = Column(Integer, ForeignKey('users.id'), unique=True)

    # 反向关系
    user = relationship("User", back_populates="profile")
```

**关键点：**
1. **uselist=False**：让 relationship 返回单个对象而非列表
2. **unique=True**：外键必须唯一，保证一对一
3. **外键可以在任意一方**：通常放在"从属"的一方

### 1.3 使用方式

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import Session

# 创建数据库
engine = create_engine("sqlite:///./test.db")
Base.metadata.create_all(engine)

# 创建会话
session = Session(engine)

# 创建用户和个人资料
user = User(username="alice")
profile = Profile(bio="Python开发者", avatar="avatar.jpg", user=user)

session.add(user)
session.commit()

# 访问关系
print(user.profile)       # Profile 对象（不是列表！）
print(user.profile.bio)   # "Python开发者"
print(profile.user)       # User 对象
print(profile.user.username)  # "alice"
```

### 1.4 一对一 vs 一对多

| 特性 | 一对一 | 一对多 |
|-----|-------|--------|
| uselist | `False` | `True`（默认） |
| 外键约束 | `unique=True` | 无 |
| 返回类型 | 单个对象 | 列表 |
| 访问方式 | `user.profile` | `user.conversations` |

```python
# 一对一
class User(Base):
    profile = relationship("Profile", uselist=False)  # 单个对象

user.profile  # Profile 对象

# 一对多
class User(Base):
    conversations = relationship("Conversation")  # 列表

user.conversations  # [Conversation, Conversation, ...]
```

### 1.5 级联操作

```python
class User(Base):
    profile = relationship(
        "Profile",
        uselist=False,
        back_populates="user",
        cascade="all, delete-orphan"  # 删除用户时删除个人资料
    )

# 删除用户
user = session.get(User, 1)
session.delete(user)
session.commit()  # 自动删除 profile
```

### 1.6 在 AI Agent 开发中的应用

```python
from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, JSON
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String, unique=True, nullable=False)
    email = Column(String, unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 一对一：用户设置
    settings = relationship(
        "UserSettings",
        uselist=False,
        back_populates="user",
        cascade="all, delete-orphan"
    )

class UserSettings(Base):
    __tablename__ = 'user_settings'

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), unique=True, nullable=False)

    # AI Agent 设置
    default_model = Column(String, default="gpt-4")
    temperature = Column(Float, default=0.7)
    max_tokens = Column(Integer, default=2000)
    system_prompt = Column(String)
    preferences = Column(JSON)  # 其他偏好设置

    # 反向关系
    user = relationship("User", back_populates="settings")

# 使用
user = User(username="alice", email="alice@example.com")
settings = UserSettings(
    user=user,
    default_model="gpt-4-turbo",
    temperature=0.8,
    system_prompt="你是一个友好的AI助手"
)

session.add(user)
session.commit()

# 访问设置
print(user.settings.default_model)  # "gpt-4-turbo"
print(user.settings.temperature)    # 0.8
```

---

## 第二部分：自引用关系

### 2.1 什么是自引用关系？

**自引用关系**是表引用自己，用于表示同类对象之间的关系。

**典型场景：**
- 用户关注系统（用户关注其他用户）
- 组织树形结构（部门包含子部门）
- 评论回复（评论回复其他评论）
- 任务依赖（任务依赖其他任务）

### 2.2 一对多自引用（树形结构）

```python
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

class Category(Base):
    __tablename__ = 'categories'

    id = Column(Integer, primary_key=True)
    name = Column(String)

    # 外键：指向父分类
    parent_id = Column(Integer, ForeignKey('categories.id'), nullable=True)

    # 关系：父分类
    parent = relationship(
        "Category",
        remote_side=[id],  # 关键：指定"远端"
        back_populates="children"
    )

    # 关系：子分类
    children = relationship(
        "Category",
        back_populates="parent"
    )
```

**关键点：**
1. **remote_side**：指定"远端"，告诉 SQLAlchemy 哪一边是"一"
2. **外键指向自己**：`ForeignKey('categories.id')`
3. **nullable=True**：根节点没有父节点

### 2.3 使用方式

```python
# 创建树形结构
root = Category(name="编程")
python = Category(name="Python", parent=root)
web = Category(name="Web开发", parent=python)
ai = Category(name="AI开发", parent=python)

session.add(root)
session.commit()

# 访问关系
print(root.children)  # [python]
print(python.parent)  # root
print(python.children)  # [web, ai]

# 递归遍历树
def print_tree(category, level=0):
    print("  " * level + category.name)
    for child in category.children:
        print_tree(child, level + 1)

print_tree(root)
# 输出：
# 编程
#   Python
#     Web开发
#     AI开发
```

### 2.4 多对多自引用（关注系统）

```python
from sqlalchemy import Table, Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

# 中间表：用户关注关系
user_followers = Table(
    'user_followers',
    Base.metadata,
    Column('follower_id', ForeignKey('users.id'), primary_key=True),
    Column('followed_id', ForeignKey('users.id'), primary_key=True)
)

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String, unique=True)

    # 关注的人（我关注了谁）
    following = relationship(
        "User",
        secondary=user_followers,
        primaryjoin=id == user_followers.c.follower_id,
        secondaryjoin=id == user_followers.c.followed_id,
        back_populates="followers"
    )

    # 粉丝（谁关注了我）
    followers = relationship(
        "User",
        secondary=user_followers,
        primaryjoin=id == user_followers.c.followed_id,
        secondaryjoin=id == user_followers.c.follower_id,
        back_populates="following"
    )
```

**关键点：**
1. **primaryjoin**：定义主表到中间表的连接条件
2. **secondaryjoin**：定义中间表到关联表的连接条件
3. **两个方向的关系**：following（我关注的）和 followers（关注我的）

### 2.5 使用方式

```python
# 创建用户
alice = User(username="alice")
bob = User(username="bob")
charlie = User(username="charlie")

# 建立关注关系
alice.following.append(bob)
alice.following.append(charlie)
bob.following.append(charlie)

session.add_all([alice, bob, charlie])
session.commit()

# 访问关系
print(f"{alice.username} 关注了: {[u.username for u in alice.following]}")
# alice 关注了: ['bob', 'charlie']

print(f"{charlie.username} 的粉丝: {[u.username for u in charlie.followers]}")
# charlie 的粉丝: ['alice', 'bob']

# 检查是否关注
def is_following(user, target):
    return target in user.following

print(is_following(alice, bob))  # True
print(is_following(bob, alice))  # False
```

### 2.6 在 AI Agent 开发中的应用

#### 场景1：组织树形结构

```python
from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

class Organization(Base):
    __tablename__ = 'organizations'

    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    description = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 外键：父组织
    parent_id = Column(Integer, ForeignKey('organizations.id'), nullable=True)

    # 关系：父组织
    parent = relationship(
        "Organization",
        remote_side=[id],
        back_populates="children"
    )

    # 关系：子组织
    children = relationship(
        "Organization",
        back_populates="parent",
        cascade="all, delete-orphan"
    )

    # 便捷方法：获取所有祖先
    def get_ancestors(self):
        ancestors = []
        current = self.parent
        while current:
            ancestors.append(current)
            current = current.parent
        return ancestors

    # 便捷方法：获取所有后代
    def get_descendants(self):
        descendants = []
        for child in self.children:
            descendants.append(child)
            descendants.extend(child.get_descendants())
        return descendants

# 使用
company = Organization(name="科技公司")
rd_dept = Organization(name="研发部", parent=company)
ai_team = Organization(name="AI团队", parent=rd_dept)
backend_team = Organization(name="后端团队", parent=rd_dept)

session.add(company)
session.commit()

# 查询
print(f"{ai_team.name} 的祖先: {[o.name for o in ai_team.get_ancestors()]}")
# AI团队 的祖先: ['研发部', '科技公司']

print(f"{company.name} 的后代: {[o.name for o in company.get_descendants()]}")
# 科技公司 的后代: ['研发部', 'AI团队', '后端团队']
```

#### 场景2：用户关注系统

```python
from datetime import datetime
from sqlalchemy import Table, Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship, DeclarativeBase

class Base(DeclarativeBase):
    pass

# 中间表（带额外字段）
class UserFollow(Base):
    __tablename__ = 'user_follows'

    follower_id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    followed_id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 关系
    follower = relationship("User", foreign_keys=[follower_id], back_populates="following_associations")
    followed = relationship("User", foreign_keys=[followed_id], back_populates="follower_associations")

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String, unique=True, nullable=False)

    # 关联到中间表
    following_associations = relationship(
        "UserFollow",
        foreign_keys="UserFollow.follower_id",
        back_populates="follower",
        cascade="all, delete-orphan"
    )

    follower_associations = relationship(
        "UserFollow",
        foreign_keys="UserFollow.followed_id",
        back_populates="followed",
        cascade="all, delete-orphan"
    )

    # 便捷访问
    @property
    def following(self):
        return [assoc.followed for assoc in self.following_associations]

    @property
    def followers(self):
        return [assoc.follower for assoc in self.follower_associations]

    # 便捷方法
    def follow(self, user):
        """关注用户"""
        if user not in self.following:
            assoc = UserFollow(follower=self, followed=user)
            self.following_associations.append(assoc)

    def unfollow(self, user):
        """取消关注"""
        for assoc in self.following_associations:
            if assoc.followed == user:
                self.following_associations.remove(assoc)
                break

    def is_following(self, user):
        """检查是否关注"""
        return user in self.following

    def is_followed_by(self, user):
        """检查是否被关注"""
        return user in self.followers

# 使用
alice = User(username="alice")
bob = User(username="bob")
charlie = User(username="charlie")

session.add_all([alice, bob, charlie])
session.commit()

# 关注
alice.follow(bob)
alice.follow(charlie)
bob.follow(charlie)

session.commit()

# 查询
print(f"{alice.username} 关注了: {[u.username for u in alice.following]}")
print(f"{charlie.username} 的粉丝: {[u.username for u in charlie.followers]}")
print(f"{alice.username} 是否关注 {bob.username}: {alice.is_following(bob)}")

# 查询关注时间
for assoc in alice.following_associations:
    print(f"{alice.username} 关注 {assoc.followed.username} 于 {assoc.created_at}")
```

---

## 3. 手写实现：理解自引用的本质

### 3.1 树形结构的实现

```python
import sqlite3

# 创建数据库
conn = sqlite3.connect(':memory:')
cursor = conn.cursor()

# 创建表
cursor.execute('''
    CREATE TABLE categories (
        id INTEGER PRIMARY KEY,
        name TEXT,
        parent_id INTEGER,
        FOREIGN KEY (parent_id) REFERENCES categories(id)
    )
''')

# 插入数据
cursor.execute("INSERT INTO categories (name, parent_id) VALUES ('编程', NULL)")
root_id = cursor.lastrowid

cursor.execute("INSERT INTO categories (name, parent_id) VALUES ('Python', ?)", (root_id,))
python_id = cursor.lastrowid

cursor.execute("INSERT INTO categories (name, parent_id) VALUES ('Web开发', ?)", (python_id,))
cursor.execute("INSERT INTO categories (name, parent_id) VALUES ('AI开发', ?)", (python_id,))

conn.commit()

# 查询子分类
cursor.execute("SELECT id, name FROM categories WHERE parent_id = ?", (python_id,))
children = cursor.fetchall()
print(f"Python 的子分类: {children}")

# 查询父分类
cursor.execute('''
    SELECT parent.id, parent.name
    FROM categories AS child
    JOIN categories AS parent ON child.parent_id = parent.id
    WHERE child.id = ?
''', (python_id,))
parent = cursor.fetchone()
print(f"Python 的父分类: {parent}")

# 递归查询所有后代（使用 CTE）
cursor.execute('''
    WITH RECURSIVE descendants AS (
        SELECT id, name, parent_id FROM categories WHERE id = ?
        UNION ALL
        SELECT c.id, c.name, c.parent_id
        FROM categories c
        JOIN descendants d ON c.parent_id = d.id
    )
    SELECT id, name FROM descendants WHERE id != ?
''', (root_id, root_id))
descendants = cursor.fetchall()
print(f"编程 的所有后代: {descendants}")
```

**输出：**
```
Python 的子分类: [(3, 'Web开发'), (4, 'AI开发')]
Python 的父分类: (1, '编程')
编程 的所有后代: [(2, 'Python'), (3, 'Web开发'), (4, 'AI开发')]
```

### 3.2 关注系统的实现

```python
# 创建表
cursor.execute('''
    CREATE TABLE users (
        id INTEGER PRIMARY KEY,
        username TEXT UNIQUE
    )
''')

cursor.execute('''
    CREATE TABLE user_follows (
        follower_id INTEGER,
        followed_id INTEGER,
        PRIMARY KEY (follower_id, followed_id),
        FOREIGN KEY (follower_id) REFERENCES users(id),
        FOREIGN KEY (followed_id) REFERENCES users(id)
    )
''')

# 插入用户
cursor.execute("INSERT INTO users (username) VALUES ('alice')")
alice_id = cursor.lastrowid

cursor.execute("INSERT INTO users (username) VALUES ('bob')")
bob_id = cursor.lastrowid

cursor.execute("INSERT INTO users (username) VALUES ('charlie')")
charlie_id = cursor.lastrowid

# 建立关注关系
cursor.execute("INSERT INTO user_follows (follower_id, followed_id) VALUES (?, ?)", (alice_id, bob_id))
cursor.execute("INSERT INTO user_follows (follower_id, followed_id) VALUES (?, ?)", (alice_id, charlie_id))
cursor.execute("INSERT INTO user_follows (follower_id, followed_id) VALUES (?, ?)", (bob_id, charlie_id))

conn.commit()

# 查询 alice 关注的人
cursor.execute('''
    SELECT users.username
    FROM users
    JOIN user_follows ON users.id = user_follows.followed_id
    WHERE user_follows.follower_id = ?
''', (alice_id,))
following = cursor.fetchall()
print(f"alice 关注了: {[u[0] for u in following]}")

# 查询 charlie 的粉丝
cursor.execute('''
    SELECT users.username
    FROM users
    JOIN user_follows ON users.id = user_follows.follower_id
    WHERE user_follows.followed_id = ?
''', (charlie_id,))
followers = cursor.fetchall()
print(f"charlie 的粉丝: {[u[0] for u in followers]}")
```

**输出：**
```
alice 关注了: ['bob', 'charlie']
charlie 的粉丝: ['alice', 'bob']
```

---

## 4. 最佳实践

### 4.1 一对一关系

```python
# ✅ 推荐配置
class User(Base):
    settings = relationship(
        "UserSettings",
        uselist=False,  # 必须
        back_populates="user",
        cascade="all, delete-orphan"
    )

class UserSettings(Base):
    user_id = Column(Integer, ForeignKey('users.id'), unique=True)  # unique 必须
    user = relationship("User", back_populates="settings")
```

### 4.2 树形结构

```python
# ✅ 推荐配置
class Category(Base):
    parent_id = Column(Integer, ForeignKey('categories.id'), nullable=True)

    parent = relationship(
        "Category",
        remote_side=[id],  # 必须指定
        back_populates="children"
    )

    children = relationship(
        "Category",
        back_populates="parent",
        cascade="all, delete-orphan"  # 删除父节点时删除子节点
    )
```

### 4.3 关注系统

```python
# ✅ 推荐配置（使用 Association Object）
class UserFollow(Base):
    follower_id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    followed_id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    follower = relationship("User", foreign_keys=[follower_id])
    followed = relationship("User", foreign_keys=[followed_id])

class User(Base):
    following_associations = relationship(
        "UserFollow",
        foreign_keys="UserFollow.follower_id",
        cascade="all, delete-orphan"
    )
```

---

## 5. 常见陷阱

### 陷阱1：一对一忘记 uselist=False

```python
# ❌ 错误：返回列表而非单个对象
class User(Base):
    profile = relationship("Profile")  # 缺少 uselist=False

user.profile  # [Profile] 而不是 Profile

# ✅ 正确
class User(Base):
    profile = relationship("Profile", uselist=False)

user.profile  # Profile 对象
```

### 陷阱2：一对一忘记 unique=True

```python
# ❌ 错误：没有唯一约束，可能创建多个 profile
class Profile(Base):
    user_id = Column(Integer, ForeignKey('users.id'))  # 缺少 unique=True

# ✅ 正确
class Profile(Base):
    user_id = Column(Integer, ForeignKey('users.id'), unique=True)
```

### 陷阱3：自引用忘记 remote_side

```python
# ❌ 错误：SQLAlchemy 不知道哪一边是"远端"
class Category(Base):
    parent = relationship("Category")  # 缺少 remote_side

# ✅ 正确
class Category(Base):
    parent = relationship("Category", remote_side=[id])
```

---

## 总结

### 一对一关系

**核心要点：**
1. **uselist=False**：返回单个对象
2. **unique=True**：外键唯一约束
3. **适用场景**：用户-设置、用户-个人资料

**记忆口诀：**
> 一对一要 uselist=False，外键必须 unique=True

### 自引用关系

**核心要点：**
1. **树形结构**：使用 remote_side 指定"远端"
2. **关注系统**：使用 primaryjoin 和 secondaryjoin
3. **适用场景**：组织树、用户关注、评论回复

**记忆口诀：**
> 自引用要 remote_side，关注系统用 primaryjoin
