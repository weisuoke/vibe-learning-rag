# 03_核心概念_01_BST基础性质

## 概念定义

**BST（Binary Search Tree，二叉搜索树）** 是一种特殊的二叉树，满足以下性质：
- 左子树所有节点的值 < 根节点的值
- 右子树所有节点的值 > 根节点的值
- 左右子树也都是BST（递归定义）

---

## 核心性质

### 性质1：有序性

**定义：** 对于BST中的任意节点N，左子树所有节点 < N < 右子树所有节点

```
        50
       /  \
      30   70
     / \   / \
   20  40 60 80

性质验证：
- 节点50：左子树{20,30,40} < 50 < 右子树{60,70,80} ✅
- 节点30：左子树{20} < 30 < 右子树{40} ✅
- 节点70：左子树{60} < 70 < 右子树{80} ✅
```

**数学表达：**
```
对于节点N：
∀x ∈ left_subtree(N): x.val < N.val
∀y ∈ right_subtree(N): y.val > N.val
```

---

### 性质2：中序遍历有序

**定理：** BST的中序遍历（左-根-右）得到有序序列

**证明：**
```
归纳法证明：

基础情况：
- 空树：中序遍历为空，有序 ✅
- 单节点：中序遍历为[节点值]，有序 ✅

归纳假设：
- 假设对于节点数 ≤ k的BST，中序遍历有序

归纳步骤：
- 考虑节点数为k+1的BST，根节点为N
- 左子树节点数 ≤ k，中序遍历有序（归纳假设）
- 右子树节点数 ≤ k，中序遍历有序（归纳假设）
- 中序遍历：左子树 + N + 右子树
- 因为左子树所有节点 < N < 右子树所有节点
- 所以整体有序 ✅

结论：对于任意BST，中序遍历有序 ∎
```

**代码验证：**
```python
def inorder(root):
    """中序遍历"""
    if not root:
        return []
    return inorder(root.left) + [root.val] + inorder(root.right)

# 示例
#       50
#      /  \
#    30    70
#   / \   / \
#  20 40 60 80

result = inorder(root)
print(result)  # [20, 30, 40, 50, 60, 70, 80] ✅ 有序
```

---

### 性质3：查找的二分性质

**定理：** 在BST中查找目标值，每次比较可以排除一半的搜索空间

**原理：**
```
查找target：
1. 如果target == root.val，找到
2. 如果target < root.val，只需在左子树查找（排除右子树）
3. 如果target > root.val，只需在右子树查找（排除左子树）
```

**时间复杂度：**
- 平衡BST：O(log n)
- 不平衡BST：O(n)（最坏情况退化为链表）

**代码实现：**
```python
def search(root, target):
    """查找目标值"""
    if not root or root.val == target:
        return root

    if target < root.val:
        return search(root.left, target)  # 往左找
    else:
        return search(root.right, target)  # 往右找
```

**示例：**
```
查找60：
        50
       /  \
      30   70
     / \   / \
   20  40 60 80

步骤：
1. 60 > 50，往右 → 70
2. 60 < 70，往左 → 60
3. 找到！

比较次数：3次（树高）
```

---

### 性质4：最小/最大值的位置

**定理：**
- BST的最小值在最左边的叶子节点
- BST的最大值在最右边的叶子节点

**证明：**
```
最小值：
- 根据BST性质，左子树所有节点 < 根节点
- 所以最小值一定在左子树
- 递归应用，最小值在最左边的节点

最大值：
- 根据BST性质，右子树所有节点 > 根节点
- 所以最大值一定在右子树
- 递归应用，最大值在最右边的节点
```

**代码实现：**
```python
def find_min(root):
    """找到最小值"""
    while root.left:
        root = root.left
    return root

def find_max(root):
    """找到最大值"""
    while root.right:
        root = root.right
    return root
```

**示例：**
```
        50
       /  \
      30   70
     / \   / \
   20  40 60 80

最小值：20（最左边）
最大值：80（最右边）
```

---

### 性质5：前驱与后继

**定义：**
- **前驱（Predecessor）**：小于当前节点的最大值
- **后继（Successor）**：大于当前节点的最小值

**查找规则：**

**前驱节点：**
1. 如果有左子树，前驱是左子树的最大值
2. 如果没有左子树，前驱是第一个"当前节点在其右子树中"的祖先

**后继节点：**
1. 如果有右子树，后继是右子树的最小值
2. 如果没有右子树，后继是第一个"当前节点在其左子树中"的祖先

**代码实现：**
```python
def find_predecessor(root, node):
    """找到前驱节点"""
    if node.left:
        # 情况1：有左子树，前驱是左子树最大值
        return find_max(node.left)

    # 情况2：没有左子树，向上找祖先
    predecessor = None
    current = root
    while current != node:
        if node.val > current.val:
            predecessor = current  # 记录可能的前驱
            current = current.right
        else:
            current = current.left
    return predecessor

def find_successor(root, node):
    """找到后继节点"""
    if node.right:
        # 情况1：有右子树，后继是右子树最小值
        return find_min(node.right)

    # 情况2：没有右子树，向上找祖先
    successor = None
    current = root
    while current != node:
        if node.val < current.val:
            successor = current  # 记录可能的后继
            current = current.left
        else:
            current = current.right
    return successor
```

**示例：**
```
        50
       /  \
      30   70
     / \   / \
   20  40 60 80

节点40的前驱：30（左子树没有，向上找，30是第一个"40在其右子树中"的祖先）
节点40的后继：50（右子树没有，向上找，50是第一个"40在其左子树中"的祖先）

节点50的前驱：40（左子树的最大值）
节点50的后继：60（右子树的最小值）
```

---

## BST的递归性质

### 递归定义

**BST的递归定义：**
```
一棵树是BST，当且仅当：
1. 空树是BST
2. 非空树满足：
   - 左子树是BST
   - 右子树是BST
   - 左子树所有节点 < 根 < 右子树所有节点
```

**验证BST的递归算法：**
```python
def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    """验证是否为BST"""
    if not root:
        return True

    # 检查当前节点是否在有效范围内
    if root.val <= min_val or root.val >= max_val:
        return False

    # 递归检查左右子树
    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))
```

**示例：**
```
        50
       /  \
      30   70
     / \   / \
   20  40 60 80

验证过程：
1. 检查50：-∞ < 50 < +∞ ✅
2. 检查30：-∞ < 30 < 50 ✅
3. 检查20：-∞ < 20 < 30 ✅
4. 检查40：30 < 40 < 50 ✅
5. 检查70：50 < 70 < +∞ ✅
6. 检查60：50 < 60 < 70 ✅
7. 检查80：70 < 80 < +∞ ✅

结论：是BST ✅
```

---

## BST的高度与平衡性

### 高度定义

**高度（Height）：** 从根节点到最远叶子节点的最长路径长度

```python
def height(root):
    """计算树高"""
    if not root:
        return 0
    return max(height(root.left), height(root.right)) + 1
```

### 高度与性能的关系

| BST类型 | 高度 | 查找时间 |
|---------|------|----------|
| 完全平衡 | log n | O(log n) |
| 近似平衡 | ~log n | O(log n) |
| 不平衡 | n | O(n) |

**示例：**
```
平衡BST（高度3）：
        50
       /  \
      30   70
     / \   / \
   20  40 60 80

查找80：3步

不平衡BST（高度5）：
    1
     \
      2
       \
        3
         \
          4
           \
            5

查找5：5步
```

---

## 在AI Agent中的应用

### 应用1：时间戳索引

```python
class TimestampIndex:
    """基于BST的时间戳索引"""
    def __init__(self):
        self.bst = BST()

    def add_event(self, timestamp, event):
        """添加事件"""
        self.bst.insert(timestamp, event)

    def get_events_in_range(self, start, end):
        """获取时间范围内的事件"""
        return self.bst.range_query(start, end)

    def get_latest_event(self):
        """获取最新事件"""
        return self.bst.find_max()  # 最大时间戳
```

### 应用2：有序数据维护

```python
class OrderedDataStore:
    """有序数据存储"""
    def __init__(self):
        self.bst = BST()

    def insert(self, key, value):
        """插入数据"""
        self.bst.insert(key, value)

    def get_sorted_data(self):
        """获取有序数据"""
        return self.bst.inorder()  # 中序遍历

    def get_predecessor(self, key):
        """获取前驱"""
        node = self.bst.search(key)
        return self.bst.find_predecessor(node)
```

---

## 常见误区

### 误区1：重复值的处理

**问题：** BST如何处理重复值？

**方案1：不允许重复**
```python
def insert(root, val):
    if not root:
        return TreeNode(val)
    if val < root.val:
        root.left = insert(root.left, val)
    elif val > root.val:
        root.right = insert(root.right, val)
    # val == root.val，不插入
    return root
```

**方案2：允许重复（放在右子树）**
```python
def insert(root, val):
    if not root:
        return TreeNode(val)
    if val <= root.val:  # 注意：<=
        root.left = insert(root.left, val)
    else:
        root.right = insert(root.right, val)
    return root
```

**方案3：节点存储计数**
```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.count = 1  # 重复次数
        self.left = None
        self.right = None

def insert(root, val):
    if not root:
        return TreeNode(val)
    if val == root.val:
        root.count += 1  # 增加计数
    elif val < root.val:
        root.left = insert(root.left, val)
    else:
        root.right = insert(root.right, val)
    return root
```

---

## 学习检查清单

- [ ] 能准确描述BST的定义和性质
- [ ] 理解为什么中序遍历是有序的
- [ ] 能解释查找的二分性质
- [ ] 知道如何找最小/最大值
- [ ] 理解前驱和后继的概念
- [ ] 能验证一棵树是否为BST
- [ ] 理解高度与性能的关系
- [ ] 知道如何处理重复值

---

## 性质总结

| 性质 | 描述 | 应用 |
|------|------|------|
| 有序性 | 左 < 根 < 右 | 查找、插入、删除 |
| 中序遍历 | 得到有序序列 | 排序、有序输出 |
| 二分性质 | 每次排除一半 | 高效查找 |
| 最小/最大 | 最左/最右节点 | 范围查询 |
| 前驱/后继 | 相邻节点 | 有序遍历 |
| 递归性质 | 子树也是BST | 递归算法 |

---

**记住：** BST的核心是有序性，所有性质都源于"左 < 根 < 右"这个简单定义。
