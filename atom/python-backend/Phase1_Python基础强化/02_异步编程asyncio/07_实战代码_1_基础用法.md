# 实战代码1：基础用法

> 完整可运行的 asyncio 基础示例

---

## 示例概述

本示例演示 asyncio 的基础用法，包括：
1. 定义和调用异步函数
2. 使用 await 等待异步操作
3. 运行异步主函数
4. 基础的并发执行

**适合场景：** 初学者入门，理解 async/await 的基本概念

---

## 完整代码

```python
"""
asyncio 基础用法示例
演示：async/await 的基本使用方法
"""

import asyncio
import time
from typing import List


# ===== 1. 定义异步函数 =====
print("=== 1. 定义异步函数 ===\n")


async def greet(name: str) -> str:
    """简单的异步函数"""
    print(f"Hello, {name}!")
    await asyncio.sleep(0.5)  # 模拟异步操作
    print(f"Goodbye, {name}!")
    return f"Greeted {name}"


async def example_1():
    """示例1：基本的异步函数调用"""
    print("示例1：基本的异步函数调用")

    # 调用异步函数（必须使用 await）
    result = await greet("Alice")
    print(f"返回值: {result}\n")


# ===== 2. 串行 vs 并发执行 =====
print("=== 2. 串行 vs 并发执行 ===\n")


async def fetch_data(source: str, delay: float) -> dict:
    """模拟从数据源获取数据"""
    print(f"开始从 {source} 获取数据...")
    await asyncio.sleep(delay)
    print(f"完成从 {source} 获取数据")
    return {"source": source, "data": f"Data from {source}"}


async def example_2_serial():
    """示例2a：串行执行（慢）"""
    print("示例2a：串行执行")
    start = time.time()

    # 串行执行：一个接一个
    result1 = await fetch_data("API-1", 1.0)
    result2 = await fetch_data("API-2", 1.0)
    result3 = await fetch_data("API-3", 1.0)

    elapsed = time.time() - start
    print(f"串行执行耗时: {elapsed:.2f}秒")
    print(f"结果: {[result1, result2, result3]}\n")


async def example_2_concurrent():
    """示例2b：并发执行（快）"""
    print("示例2b：并发执行")
    start = time.time()

    # 并发执行：同时启动
    results = await asyncio.gather(
        fetch_data("API-1", 1.0),
        fetch_data("API-2", 1.0),
        fetch_data("API-3", 1.0)
    )

    elapsed = time.time() - start
    print(f"并发执行耗时: {elapsed:.2f}秒")
    print(f"结果: {results}\n")


# ===== 3. 创建和管理任务 =====
print("=== 3. 创建和管理任务 ===\n")


async def background_task(task_id: int, duration: float) -> str:
    """后台任务"""
    print(f"任务 {task_id} 开始（需要 {duration}秒）")
    await asyncio.sleep(duration)
    print(f"任务 {task_id} 完成")
    return f"Task {task_id} result"


async def example_3():
    """示例3：创建后台任务"""
    print("示例3：创建后台任务")

    # 创建任务，不立即等待
    task1 = asyncio.create_task(background_task(1, 1.0))
    task2 = asyncio.create_task(background_task(2, 0.5))
    task3 = asyncio.create_task(background_task(3, 1.5))

    print("所有任务已创建，继续执行主函数...")
    await asyncio.sleep(0.2)
    print("主函数做了一些其他工作\n")

    # 等待所有任务完成
    results = await asyncio.gather(task1, task2, task3)
    print(f"所有任务完成，结果: {results}\n")


# ===== 4. 异步函数的返回值 =====
print("=== 4. 异步函数的返回值 ===\n")


async def calculate_sum(numbers: List[int]) -> int:
    """异步计算求和"""
    print(f"计算 {numbers} 的和...")
    await asyncio.sleep(0.1)  # 模拟异步操作
    result = sum(numbers)
    print(f"结果: {result}")
    return result


async def calculate_product(numbers: List[int]) -> int:
    """异步计算乘积"""
    print(f"计算 {numbers} 的乘积...")
    await asyncio.sleep(0.1)
    result = 1
    for n in numbers:
        result *= n
    print(f"结果: {result}")
    return result


async def example_4():
    """示例4：处理异步函数的返回值"""
    print("示例4：处理异步函数的返回值")

    numbers = [1, 2, 3, 4, 5]

    # 并发执行多个计算
    sum_result, product_result = await asyncio.gather(
        calculate_sum(numbers),
        calculate_product(numbers)
    )

    print(f"\n最终结果:")
    print(f"  和: {sum_result}")
    print(f"  积: {product_result}\n")


# ===== 5. 嵌套的异步调用 =====
print("=== 5. 嵌套的异步调用 ===\n")


async def level_3_operation() -> str:
    """第三层操作"""
    print("  Level 3: 执行中...")
    await asyncio.sleep(0.2)
    print("  Level 3: 完成")
    return "L3 result"


async def level_2_operation() -> str:
    """第二层操作"""
    print(" Level 2: 开始")
    result = await level_3_operation()
    print(f" Level 2: 收到 {result}")
    return "L2 result"


async def level_1_operation() -> str:
    """第一层操作"""
    print("Level 1: 开始")
    result = await level_2_operation()
    print(f"Level 1: 收到 {result}")
    return "L1 result"


async def example_5():
    """示例5：嵌套的异步调用"""
    print("示例5：嵌套的异步调用")

    result = await level_1_operation()
    print(f"最终结果: {result}\n")


# ===== 6. 使用 asyncio.sleep() =====
print("=== 6. 使用 asyncio.sleep() ===\n")


async def countdown(name: str, seconds: int):
    """倒计时"""
    print(f"{name}: 开始倒计时 {seconds} 秒")
    for i in range(seconds, 0, -1):
        print(f"{name}: {i}...")
        await asyncio.sleep(1)
    print(f"{name}: 完成!\n")


async def example_6():
    """示例6：多个倒计时并发执行"""
    print("示例6：多个倒计时并发执行")

    # 并发执行3个倒计时
    await asyncio.gather(
        countdown("Timer-A", 3),
        countdown("Timer-B", 2),
        countdown("Timer-C", 4)
    )


# ===== 7. 协程对象 vs 执行结果 =====
print("=== 7. 协程对象 vs 执行结果 ===\n")


async def get_value() -> int:
    """返回一个值"""
    await asyncio.sleep(0.1)
    return 42


async def example_7():
    """示例7：理解协程对象"""
    print("示例7：理解协程对象")

    # 调用异步函数返回协程对象（不执行）
    coro = get_value()
    print(f"协程对象: {coro}")
    print(f"类型: {type(coro)}")

    # 必须 await 才能执行并获取结果
    result = await coro
    print(f"执行结果: {result}")
    print(f"类型: {type(result)}\n")


# ===== 8. 实际应用：模拟 API 调用 =====
print("=== 8. 实际应用：模拟 API 调用 ===\n")


async def call_api(endpoint: str, params: dict) -> dict:
    """模拟 API 调用"""
    print(f"调用 API: {endpoint} with {params}")
    await asyncio.sleep(0.5)  # 模拟网络延迟

    # 模拟返回数据
    response = {
        "endpoint": endpoint,
        "params": params,
        "status": "success",
        "data": f"Response from {endpoint}"
    }

    print(f"API 响应: {endpoint}")
    return response


async def example_8():
    """示例8：并发调用多个 API"""
    print("示例8：并发调用多个 API")

    # 定义多个 API 调用
    api_calls = [
        call_api("/users", {"id": 1}),
        call_api("/posts", {"user_id": 1}),
        call_api("/comments", {"post_id": 1})
    ]

    # 并发执行所有 API 调用
    start = time.time()
    responses = await asyncio.gather(*api_calls)
    elapsed = time.time() - start

    print(f"\n所有 API 调用完成，耗时: {elapsed:.2f}秒")
    print(f"收到 {len(responses)} 个响应\n")


# ===== 9. 动态创建任务 =====
print("=== 9. 动态创建任务 ===\n")


async def process_item(item_id: int) -> str:
    """处理单个项目"""
    await asyncio.sleep(0.2)
    return f"Processed item {item_id}"


async def example_9():
    """示例9：动态创建任务列表"""
    print("示例9：动态创建任务列表")

    # 动态创建任务
    item_ids = range(1, 6)
    tasks = [process_item(item_id) for item_id in item_ids]

    print(f"创建了 {len(tasks)} 个任务")

    # 并发执行
    results = await asyncio.gather(*tasks)

    print(f"处理完成:")
    for result in results:
        print(f"  - {result}")
    print()


# ===== 10. 主函数 =====


async def main():
    """主函数：运行所有示例"""
    print("=" * 60)
    print("asyncio 基础用法示例")
    print("=" * 60)
    print()

    # 运行所有示例
    await example_1()
    await example_2_serial()
    await example_2_concurrent()
    await example_3()
    await example_4()
    await example_5()
    await example_6()
    await example_7()
    await example_8()
    await example_9()

    print("=" * 60)
    print("所有示例运行完成！")
    print("=" * 60)


# ===== 运行程序 =====

if __name__ == "__main__":
    # 使用 asyncio.run() 运行主函数
    asyncio.run(main())
```

---

## 运行输出示例

```
============================================================
asyncio 基础用法示例
============================================================

=== 1. 定义异步函数 ===

示例1：基本的异步函数调用
Hello, Alice!
Goodbye, Alice!
返回值: Greeted Alice

=== 2. 串行 vs 并发执行 ===

示例2a：串行执行
开始从 API-1 获取数据...
完成从 API-1 获取数据
开始从 API-2 获取数据...
完成从 API-2 获取数据
开始从 API-3 获取数据...
完成从 API-3 获取数据
串行执行耗时: 3.01秒
结果: [{'source': 'API-1', 'data': 'Data from API-1'}, ...]

示例2b：并发执行
开始从 API-1 获取数据...
开始从 API-2 获取数据...
开始从 API-3 获取数据...
完成从 API-1 获取数据
完成从 API-2 获取数据
完成从 API-3 获取数据
并发执行耗时: 1.00秒
结果: [{'source': 'API-1', 'data': 'Data from API-1'}, ...]

=== 3. 创建和管理任务 ===

示例3：创建后台任务
任务 1 开始（需要 1.0秒）
任务 2 开始（需要 0.5秒）
任务 3 开始（需要 1.5秒）
所有任务已创建，继续执行主函数...
主函数做了一些其他工作

任务 2 完成
任务 1 完成
任务 3 完成
所有任务完成，结果: ['Task 1 result', 'Task 2 result', 'Task 3 result']

...（其他示例输出）

============================================================
所有示例运行完成！
============================================================
```

---

## 关键知识点

### 1. async def 定义异步函数

```python
async def my_function():
    # 异步函数体
    await asyncio.sleep(1)
    return "result"
```

### 2. await 等待异步操作

```python
# 必须在 async def 函数内使用 await
result = await my_function()
```

### 3. asyncio.run() 运行主函数

```python
# 在同步代码中启动异步主函数
asyncio.run(main())
```

### 4. asyncio.gather() 并发执行

```python
# 同时执行多个异步操作
results = await asyncio.gather(
    task1(),
    task2(),
    task3()
)
```

### 5. asyncio.create_task() 创建后台任务

```python
# 创建任务，不立即等待
task = asyncio.create_task(my_function())
# 稍后等待
result = await task
```

---

## 性能对比

| 执行方式 | 3个任务（每个1秒） | 性能提升 |
|---------|------------------|---------|
| 串行执行 | 3.0秒 | 基准 |
| 并发执行 | 1.0秒 | 3倍 |

---

## 常见错误

### 错误1：忘记 await

```python
# ❌ 错误
async def bad():
    result = my_async_function()  # 返回协程对象，不执行
    print(result)  # <coroutine object ...>

# ✅ 正确
async def good():
    result = await my_async_function()
    print(result)  # 实际结果
```

### 错误2：在同步函数中使用 await

```python
# ❌ 错误
def bad():
    result = await my_async_function()  # SyntaxError

# ✅ 正确
async def good():
    result = await my_async_function()
```

### 错误3：串行执行而非并发

```python
# ❌ 效率低：串行执行
async def bad():
    r1 = await task1()  # 等待
    r2 = await task2()  # 等待
    r3 = await task3()  # 等待

# ✅ 效率高：并发执行
async def good():
    results = await asyncio.gather(
        task1(),
        task2(),
        task3()
    )
```

---

## 学习检查

完成本示例后，你应该能够：

- [ ] 使用 `async def` 定义异步函数
- [ ] 使用 `await` 等待异步操作
- [ ] 使用 `asyncio.run()` 运行异步主函数
- [ ] 使用 `asyncio.gather()` 并发执行多个任务
- [ ] 使用 `asyncio.create_task()` 创建后台任务
- [ ] 理解串行执行和并发执行的性能差异
- [ ] 避免常见的异步编程错误

---

## 下一步

- **继续学习**：阅读【实战代码2：并发请求】
- **修改代码**：尝试修改示例代码，添加自己的逻辑
- **实际应用**：在自己的项目中应用这些基础知识
