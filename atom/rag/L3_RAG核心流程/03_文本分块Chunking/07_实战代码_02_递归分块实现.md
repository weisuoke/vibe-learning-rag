# 实战代码2：递归字符分块实现

完整可运行的递归字符分块代码示例（LangChain 默认策略，2025-2026 推荐配置）。

---

## LangChain 实现（推荐）

```python
"""
递归字符分块 - LangChain 实现
NVIDIA 2025 推荐：chunk_size=512, overlap=77 (15%)
"""

from langchain.text_splitter import RecursiveCharacterTextSplitter

# NVIDIA 2025 推荐配置
splitter = RecursiveCharacterTextSplitter(
    chunk_size=512,
    chunk_overlap=77,  # 15% overlap
    separators=["\n\n", "\n", "。", ".", "！", "？", " ", ""],
    length_function=len,
)

text = """
Python 编程基础教程

第一章：变量与数据类型
Python 是一种动态类型语言。变量不需要声明类型。

第二章：控制流程
if 语句用于条件判断。for 循环用于遍历序列。
"""

chunks = splitter.split_text(text)

for i, chunk in enumerate(chunks):
    print(f"Chunk {i+1}: {chunk}")
```

---

## 查询类型自适应（NVIDIA 2025）

```python
"""
根据查询类型自适应调整块大小
研究来源: NVIDIA 2025 Chunking Benchmark
"""

from langchain.text_splitter import RecursiveCharacterTextSplitter
from typing import Literal

QueryType = Literal["factual", "analytical", "mixed"]

def create_adaptive_splitter(query_type: QueryType = "factual"):
    """
    创建查询类型自适应分块器（NVIDIA 2025）
    
    Args:
        query_type: 查询类型
            - factual: 事实查询（512 tokens）
            - analytical: 分析查询（1024 tokens）
            - mixed: 混合查询（768 tokens)
    """
    config = {
        "factual": {"chunk_size": 512, "overlap_ratio": 0.15},
        "analytical": {"chunk_size": 1024, "overlap_ratio": 0.15},
        "mixed": {"chunk_size": 768, "overlap_ratio": 0.15}
    }
    
    cfg = config[query_type]
    chunk_size = cfg["chunk_size"]
    chunk_overlap = int(chunk_size * cfg["overlap_ratio"])
    
    return RecursiveCharacterTextSplitter(
        chunk_size=chunk_size,
        chunk_overlap=chunk_overlap,
        separators=["\n\n", "\n", "。", ".", "！", "？", " ", ""]
    )

# 使用示例
factual_splitter = create_adaptive_splitter("factual")
analytical_splitter = create_adaptive_splitter("analytical")

text = "你的长文本..." * 100

factual_chunks = factual_splitter.split_text(text)
analytical_chunks = analytical_splitter.split_text(text)

print(f"事实查询分块数: {len(factual_chunks)}")
print(f"分析查询分块数: {len(analytical_chunks)}")
```

---

## 中文文档优化

```python
"""
中文文档专用配置
"""

from langchain.text_splitter import RecursiveCharacterTextSplitter

# 中文文档分块器
chinese_splitter = RecursiveCharacterTextSplitter(
    chunk_size=512,
    chunk_overlap=77,  # 15% NVIDIA 最优
    separators=[
        "\n\n",      # 段落（最优先）
        "\n",        # 换行
        "。",        # 句号
        "！",        # 感叹号
        "？",        # 问号
        "；",        # 分号
        "，",        # 逗号
        " ",         # 空格
        "",          # 字符（最后手段）
    ]
)

text = """
第一段内容，介绍了Python的基本概念。Python是一种简单易学的编程语言。

第二段内容，详细讲解了变量和数据类型。变量是存储数据的容器。
"""

chunks = chinese_splitter.split_text(text)

for i, chunk in enumerate(chunks):
    print(f"Chunk {i+1}: {chunk}")
```

---

## 与文档加载器配合

```python
"""
完整的文档处理流程：加载 + 分块
"""

from langchain.document_loaders import PyPDFLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter

# 1. 加载文档
loader = PyPDFLoader("document.pdf")
documents = loader.load()

# 2. 创建分块器（NVIDIA 2025 推荐）
splitter = RecursiveCharacterTextSplitter(
    chunk_size=512,
    chunk_overlap=77,
    separators=["\n\n", "\n", "。", ".", "！", "？", " ", ""]
)

# 3. 分块（保留元数据）
chunks = splitter.split_documents(documents)

# 4. 查看结果
for chunk in chunks[:3]:
    print(f"内容: {chunk.page_content[:100]}...")
    print(f"元数据: {chunk.metadata}")
    print(f"来源: {chunk.metadata.get('source', 'unknown')}")
    print(f"页码: {chunk.metadata.get('page', 'unknown')}")
    print("---")
```

---

## 核心研究来源

**NVIDIA 2025**: [Finding the Best Chunking Strategy](https://developer.nvidia.com/blog/finding-the-best-chunking-strategy-for-accurate-ai-responses)

---

**下一步：** [07_实战代码_03_语义分块实现](./07_实战代码_03_语义分块实现.md)
