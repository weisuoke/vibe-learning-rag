# 实战代码03：请求ID追踪

## 学习目标

实现完整的请求ID追踪系统，掌握在FastAPI中使用contextvars自动传递请求ID。

---

## 第一步：理解请求ID的作用

### 问题场景

**并发请求混淆：**

```
10:30:45.100 [INFO] request_start
10:30:45.150 [INFO] request_start
10:30:45.200 [INFO] rag_search
10:30:45.250 [INFO] llm_call
```

**问题：** 哪个日志属于哪个请求？

**解决：** 每个请求分配唯一ID

```
10:30:45.100 [INFO] request_start request_id=req_A
10:30:45.150 [INFO] request_start request_id=req_B
10:30:45.200 [INFO] rag_search request_id=req_A
10:30:45.250 [INFO] llm_call request_id=req_B
```

---

## 第二步：生成请求ID

### 示例1：UUID4方式（推荐）

```python
# examples/logging/19_generate_request_id.py
import uuid

# 方法1：UUID4（最常用）
request_id = str(uuid.uuid4())
print(f"UUID4: {request_id}")
# 输出：550e8400-e29b-41d4-a716-446655440000

# 方法2：短UUID（去掉连字符）
request_id = uuid.uuid4().hex
print(f"Short UUID: {request_id}")
# 输出：550e8400e29b41d4a716446655440000

# 方法3：带前缀的UUID
request_id = f"req_{uuid.uuid4()}"
print(f"Prefixed: {request_id}")
# 输出：req_550e8400-e29b-41d4-a716-446655440000
```

### 示例2：其他ID生成方式

```python
# examples/logging/20_other_id_generators.py
import secrets
import time

# 方法1：URL安全的随机字符串
request_id = secrets.token_urlsafe(16)
print(f"Token: {request_id}")
# 输出：Xq3jK9mN2pL5rT8w

# 方法2：带时间戳的ID
request_id = f"req_{int(time.time())}_{secrets.token_hex(4)}"
print(f"Timestamped: {request_id}")
# 输出：req_1705318245_a3b2c1d4

# 方法3：自增ID（需要数据库或Redis）
# 不推荐：分布式环境中难以保证唯一性
```

**推荐：** 使用UUID4，全局唯一，无需中心化协调

---

## 第三步：在中间件中生成请求ID

### 示例3：基础请求ID中间件

```python
# examples/logging/21_request_id_middleware.py
import uuid
from fastapi import FastAPI, Request
import structlog

structlog.configure(
    processors=[
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.dev.ConsoleRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_request_id(request: Request, call_next):
    # 生成请求ID
    request_id = str(uuid.uuid4())

    # 记录请求开始（手动传递request_id）
    logger.info("request_start",
        request_id=request_id,
        method=request.method,
        path=request.url.path
    )

    # 处理请求
    response = await call_next(request)

    # 记录请求结束（手动传递request_id）
    logger.info("request_end",
        request_id=request_id,
        status_code=response.status_code
    )

    return response

@app.get("/")
async def root():
    # 问题：这里无法访问request_id
    logger.info("processing_root")  # 缺少request_id
    return {"message": "Hello"}
```

**问题：** 需要手动传递request_id，路由中无法访问

---

## 第四步：使用contextvars自动传递

### 示例4：contextvars基础用法

```python
# examples/logging/22_contextvars_basic.py
from contextvars import ContextVar
import asyncio

# 定义上下文变量
request_id_var: ContextVar[str] = ContextVar("request_id")

async def handle_request(request_id: str):
    # 设置上下文变量
    request_id_var.set(request_id)

    # 调用子函数
    await process_data()

async def process_data():
    # 自动获取上下文变量
    request_id = request_id_var.get()
    print(f"Processing with request_id: {request_id}")

# 测试
async def main():
    await handle_request("req_123")
    await handle_request("req_456")

asyncio.run(main())
```

**输出：**
```
Processing with request_id: req_123
Processing with request_id: req_456
```

**优势：** 不需要手动传递参数

---

## 第五步：structlog集成contextvars

### 示例5：完整的请求ID追踪

```python
# examples/logging/23_structlog_contextvars.py
import uuid
from fastapi import FastAPI, Request
import structlog

# 配置structlog使用contextvars
structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,  # 关键：合并上下文变量
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.dev.ConsoleRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_request_id(request: Request, call_next):
    # 1. 生成请求ID
    request_id = str(uuid.uuid4())

    # 2. 绑定到上下文
    structlog.contextvars.bind_contextvars(request_id=request_id)

    # 3. 记录请求开始（自动包含request_id）
    logger.info("request_start",
        method=request.method,
        path=request.url.path
    )

    # 4. 处理请求
    response = await call_next(request)

    # 5. 记录请求结束（自动包含request_id）
    logger.info("request_end",
        status_code=response.status_code
    )

    # 6. 清理上下文
    structlog.contextvars.clear_contextvars()

    return response

@app.get("/")
async def root():
    # 自动包含request_id
    logger.info("processing_root")
    return {"message": "Hello"}

@app.get("/users/{user_id}")
async def get_user(user_id: str):
    # 自动包含request_id
    logger.info("get_user", user_id=user_id)
    return {"user_id": user_id}
```

**输出：**
```
2024-01-15 10:30:45 [info     ] request_start          request_id=req_abc method=GET path=/
2024-01-15 10:30:45 [info     ] processing_root        request_id=req_abc
2024-01-15 10:30:45 [info     ] request_end            request_id=req_abc status_code=200
```

**优势：** 所有日志自动包含request_id

---

## 第六步：在响应头中返回请求ID

### 示例6：返回请求ID给客户端

```python
# examples/logging/24_return_request_id.py
import uuid
from fastapi import FastAPI, Request
import structlog

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_request_id(request: Request, call_next):
    # 生成请求ID
    request_id = str(uuid.uuid4())

    # 绑定到上下文
    structlog.contextvars.bind_contextvars(request_id=request_id)

    logger.info("request_start",
        method=request.method,
        path=request.url.path
    )

    # 处理请求
    response = await call_next(request)

    logger.info("request_end",
        status_code=response.status_code
    )

    # 在响应头中返回请求ID
    response.headers["X-Request-ID"] = request_id

    # 清理上下文
    structlog.contextvars.clear_contextvars()

    return response

@app.get("/")
async def root():
    logger.info("processing_root")
    return {"message": "Hello"}
```

**测试：**
```bash
curl -i http://localhost:8000/

HTTP/1.1 200 OK
X-Request-ID: 550e8400-e29b-41d4-a716-446655440000
...
```

**用途：** 用户可以提供请求ID用于问题排查

---

## 第七步：支持客户端提供的请求ID

### 示例7：优先使用客户端请求ID

```python
# examples/logging/25_client_request_id.py
import uuid
from fastapi import FastAPI, Request
import structlog

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.dev.ConsoleRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_request_id(request: Request, call_next):
    # 1. 优先使用客户端提供的请求ID
    request_id = request.headers.get("X-Request-ID")

    # 2. 如果没有，生成新的
    if not request_id:
        request_id = str(uuid.uuid4())
        logger.debug("generated_request_id", request_id=request_id)
    else:
        logger.debug("using_client_request_id", request_id=request_id)

    # 3. 绑定到上下文
    structlog.contextvars.bind_contextvars(request_id=request_id)

    logger.info("request_start",
        method=request.method,
        path=request.url.path
    )

    response = await call_next(request)

    logger.info("request_end",
        status_code=response.status_code
    )

    # 4. 返回请求ID
    response.headers["X-Request-ID"] = request_id

    structlog.contextvars.clear_contextvars()

    return response

@app.get("/")
async def root():
    logger.info("processing_root")
    return {"message": "Hello"}
```

**测试：**
```bash
# 不提供请求ID（自动生成）
curl http://localhost:8000/

# 提供请求ID（使用客户端的）
curl -H "X-Request-ID: my-custom-id" http://localhost:8000/
```

**优势：** 支持端到端追踪

---

## 第八步：绑定更多上下文信息

### 示例8：绑定用户ID和会话ID

```python
# examples/logging/26_multiple_context.py
import uuid
from fastapi import FastAPI, Request
import structlog

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_context(request: Request, call_next):
    # 生成请求ID
    request_id = request.headers.get("X-Request-ID") or str(uuid.uuid4())

    # 从请求头中获取用户信息
    user_id = request.headers.get("X-User-ID")
    session_id = request.headers.get("X-Session-ID")

    # 绑定多个上下文变量
    context = {
        "request_id": request_id,
        "method": request.method,
        "path": request.url.path,
        "client_ip": request.client.host
    }

    # 可选字段
    if user_id:
        context["user_id"] = user_id
    if session_id:
        context["session_id"] = session_id

    structlog.contextvars.bind_contextvars(**context)

    logger.info("request_start")

    response = await call_next(request)

    logger.info("request_end", status_code=response.status_code)

    response.headers["X-Request-ID"] = request_id

    structlog.contextvars.clear_contextvars()

    return response

@app.get("/")
async def root():
    logger.info("processing_root")
    return {"message": "Hello"}

@app.get("/users/me")
async def get_current_user():
    logger.info("get_current_user")
    return {"user_id": "user_123"}
```

**测试：**
```bash
curl -H "X-User-ID: user_123" -H "X-Session-ID: session_456" http://localhost:8000/users/me
```

**输出：**
```json
{"level": "info", "event": "request_start", "request_id": "...", "user_id": "user_123", "session_id": "session_456", "method": "GET", "path": "/users/me", "client_ip": "127.0.0.1", "timestamp": "..."}
{"level": "info", "event": "get_current_user", "request_id": "...", "user_id": "user_123", "session_id": "session_456", "method": "GET", "path": "/users/me", "client_ip": "127.0.0.1", "timestamp": "..."}
{"level": "info", "event": "request_end", "request_id": "...", "user_id": "user_123", "session_id": "session_456", "method": "GET", "path": "/users/me", "client_ip": "127.0.0.1", "status_code": 200, "timestamp": "..."}
```

---

## 第九步：在后台任务中传递请求ID

### 示例9：后台任务的上下文传递

```python
# examples/logging/27_background_task_context.py
import uuid
from fastapi import FastAPI, Request, BackgroundTasks
import structlog
import asyncio

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.dev.ConsoleRenderer()
    ]
)

app = FastAPI()
logger = structlog.get_logger()

@app.middleware("http")
async def add_request_id(request: Request, call_next):
    request_id = str(uuid.uuid4())
    structlog.contextvars.bind_contextvars(request_id=request_id)

    logger.info("request_start", path=request.url.path)

    response = await call_next(request)

    logger.info("request_end", status_code=response.status_code)

    response.headers["X-Request-ID"] = request_id

    structlog.contextvars.clear_contextvars()

    return response

def save_to_database(data: dict, context: dict):
    """后台任务：保存到数据库"""
    # 恢复上下文
    structlog.contextvars.bind_contextvars(**context)

    logger.info("saving_to_database", data_size=len(str(data)))

    # 模拟数据库操作
    import time
    time.sleep(1)

    logger.info("saved_to_database")

    # 清理上下文
    structlog.contextvars.clear_contextvars()

@app.post("/users")
async def create_user(user: dict, background_tasks: BackgroundTasks):
    logger.info("create_user_start", user=user)

    # 获取当前上下文
    context = structlog.contextvars.get_contextvars()

    # 添加后台任务，传递上下文
    background_tasks.add_task(save_to_database, user, context)

    logger.info("create_user_end")

    return {"id": "user_123", **user}
```

**测试：**
```bash
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{"name": "John"}'
```

**输出：**
```
2024-01-15 10:30:45 [info     ] request_start          request_id=req_abc path=/users
2024-01-15 10:30:45 [info     ] create_user_start      request_id=req_abc user={'name': 'John'}
2024-01-15 10:30:45 [info     ] create_user_end        request_id=req_abc
2024-01-15 10:30:45 [info     ] request_end            request_id=req_abc status_code=200
2024-01-15 10:30:46 [info     ] saving_to_database     request_id=req_abc data_size=16
2024-01-15 10:30:47 [info     ] saved_to_database      request_id=req_abc
```

---

## 第十步：完整的请求ID追踪系统

### 示例10：生产级请求ID中间件

```python
# middleware/request_id.py
"""
请求ID追踪中间件

使用方法：
    from middleware.request_id import setup_request_id_middleware

    app = FastAPI()
    setup_request_id_middleware(app)
"""

import uuid
from fastapi import FastAPI, Request
import structlog
from typing import Optional, Callable

logger = structlog.get_logger()

class RequestIDConfig:
    """请求ID配置"""

    def __init__(
        self,
        header_name: str = "X-Request-ID",
        generate_if_missing: bool = True,
        return_in_response: bool = True,
        id_generator: Optional[Callable[[], str]] = None
    ):
        self.header_name = header_name
        self.generate_if_missing = generate_if_missing
        self.return_in_response = return_in_response
        self.id_generator = id_generator or (lambda: str(uuid.uuid4()))


async def request_id_middleware(
    request: Request,
    call_next,
    config: RequestIDConfig
):
    """请求ID中间件"""

    # 1. 获取或生成请求ID
    request_id = request.headers.get(config.header_name)

    if not request_id and config.generate_if_missing:
        request_id = config.id_generator()
        logger.debug("generated_request_id", request_id=request_id)
    elif request_id:
        logger.debug("using_client_request_id", request_id=request_id)

    # 2. 绑定到上下文
    if request_id:
        structlog.contextvars.bind_contextvars(request_id=request_id)

    # 3. 记录请求开始
    logger.info("request_start",
        method=request.method,
        path=request.url.path,
        client_ip=request.client.host
    )

    try:
        # 4. 处理请求
        response = await call_next(request)

        # 5. 记录请求结束
        logger.info("request_end",
            status_code=response.status_code
        )

        # 6. 在响应头中返回请求ID
        if request_id and config.return_in_response:
            response.headers[config.header_name] = request_id

        return response

    finally:
        # 7. 清理上下文
        structlog.contextvars.clear_contextvars()


def setup_request_id_middleware(
    app: FastAPI,
    config: Optional[RequestIDConfig] = None
):
    """
    为FastAPI应用添加请求ID中间件

    Args:
        app: FastAPI应用实例
        config: 请求ID配置，默认使用默认配置
    """
    if config is None:
        config = RequestIDConfig()

    @app.middleware("http")
    async def _request_id_middleware(request: Request, call_next):
        return await request_id_middleware(request, call_next, config)


# 使用示例
if __name__ == "__main__":
    from fastapi import FastAPI
    import structlog

    # 配置structlog
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,
            structlog.processors.add_log_level,
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.dev.ConsoleRenderer()
        ]
    )

    # 创建应用
    app = FastAPI()

    # 添加请求ID中间件
    setup_request_id_middleware(app)

    @app.get("/")
    async def root():
        logger.info("processing_root")
        return {"message": "Hello"}

    @app.get("/users/{user_id}")
    async def get_user(user_id: str):
        logger.info("get_user", user_id=user_id)
        return {"user_id": user_id}

    # 运行
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 第十一步：查询特定请求的所有日志

### 示例11：日志查询工具

```python
# tools/query_logs.py
"""
日志查询工具

使用方法：
    python tools/query_logs.py --request-id req_abc123
"""

import json
import argparse
from typing import List, Dict

def query_logs_by_request_id(log_file: str, request_id: str) -> List[Dict]:
    """查询特定请求的所有日志"""
    results = []

    with open(log_file, 'r') as f:
        for line in f:
            try:
                log = json.loads(line)
                if log.get("request_id") == request_id:
                    results.append(log)
            except json.JSONDecodeError:
                continue

    return results

def print_logs(logs: List[Dict]):
    """打印日志"""
    if not logs:
        print("No logs found")
        return

    print(f"Found {len(logs)} logs:\n")

    for i, log in enumerate(logs, 1):
        print(f"[{i}] {log.get('timestamp')} [{log.get('level')}] {log.get('event')}")

        # 打印其他字段
        for key, value in log.items():
            if key not in ['timestamp', 'level', 'event', 'request_id']:
                print(f"    {key}: {value}")

        print()

def main():
    parser = argparse.ArgumentParser(description="Query logs by request ID")
    parser.add_argument("--request-id", required=True, help="Request ID to query")
    parser.add_argument("--log-file", default="app.log", help="Log file path")

    args = parser.parse_args()

    logs = query_logs_by_request_id(args.log_file, args.request_id)
    print_logs(logs)

if __name__ == "__main__":
    main()
```

**使用：**
```bash
python tools/query_logs.py --request-id req_abc123
```

**输出：**
```
Found 5 logs:

[1] 2024-01-15T10:30:45Z [info] request_start
    method: GET
    path: /users/123
    client_ip: 127.0.0.1

[2] 2024-01-15T10:30:45Z [info] get_user
    user_id: 123

[3] 2024-01-15T10:30:46Z [info] rag_search
    query: user info
    results_count: 5

[4] 2024-01-15T10:30:47Z [info] llm_call
    model: gpt-4
    tokens: 150

[5] 2024-01-15T10:30:48Z [info] request_end
    status_code: 200
```

---

## 总结

### 核心要点

1. **请求ID生成**
   - 使用UUID4（推荐）
   - 支持客户端提供的ID
   - 在响应头中返回

2. **contextvars自动传递**
   - 异步安全
   - 无需手动传递参数
   - 自动包含在所有日志中

3. **后台任务**
   - 手动传递上下文
   - 恢复和清理上下文

4. **日志查询**
   - 通过请求ID查询所有相关日志
   - 快速定位问题

### 最佳实践

1. 始终使用请求ID
2. 优先使用客户端提供的ID
3. 在响应头中返回ID
4. 后台任务传递上下文
5. 提供日志查询工具

### 下一步

- 【实战代码04】：上下文变量传递
- 【实战代码05】：日志过滤与路由
