# 核心概念：数据透传与增强

> **理解 RunnablePassthrough 的两种核心模式**

---

## 概述

RunnablePassthrough 实现了两种核心的数据处理模式：
1. **数据透传（Passthrough）**：原样传递数据，不做任何修改
2. **数据增强（Enhancement）**：在原有数据基础上添加新信息

这两种模式解决了 LCEL 链中最常见的问题：**如何在数据流转过程中保持完整性**。

---

## 数据透传（Passthrough）

### 原理讲解

**定义**：数据透传是指将输入原样传递到输出，不做任何转换或修改。

**数学表达**：
```
f(x) = x  (identity function)
```

**在 LCEL 中的作用**：
```python
# 在并行链中保持原始输入
chain = {
    "original": RunnablePassthrough(),  # 透传
    "processed": some_runnable,         # 处理
}
```

---

### 为什么需要透传？

**问题场景**：并行处理后需要访问原始输入

```python
# 没有透传：原始输入丢失
chain = {
    "summary": summary_chain,
    "keywords": keyword_chain,
}
result = chain.invoke({"text": "..."})
# {"summary": "...", "keywords": [...]}
# 原始 text 丢失了

# 有透传：原始输入保留
chain = {
    "original": RunnablePassthrough(),
    "summary": summary_chain,
    "keywords": keyword_chain,
}
result = chain.invoke({"text": "..."})
# {"original": {"text": "..."}, "summary": "...", "keywords": [...]}
# 原始 text 保留了
```

---

### 手写实现

```python
from langchain_core.runnables import Runnable
from typing import Any

class SimplePassthrough(Runnable):
    """简单的透传实现"""

    def invoke(self, input: Any) -> Any:
        """同步透传：原样返回输入"""
        return input

    async def ainvoke(self, input: Any) -> Any:
        """异步透传：原样返回输入"""
        return input

# 测试
passthrough = SimplePassthrough()
result = passthrough.invoke("hello")
print(result)  # "hello"

result = passthrough.invoke({"key": "value"})
print(result)  # {"key": "value"}
```

---

### 透传的特性

**特性1：零开销**
```python
import time

passthrough = RunnablePassthrough()
large_data = {"data": "x" * 1000000}  # 1MB 数据

start = time.time()
for _ in range(1000):
    result = passthrough.invoke(large_data)
elapsed = time.time() - start

print(f"1000次透传耗时: {elapsed:.3f}秒")
# 预期: < 0.01秒（几乎零开销）
```

**特性2：不复制数据**
```python
passthrough = RunnablePassthrough()
original = {"key": "value"}
result = passthrough.invoke(original)

# result 和 original 是同一个对象
print(result is original)  # True
```

**特性3：支持任何类型**
```python
passthrough = RunnablePassthrough()

# 字符串
passthrough.invoke("hello")  # ✅

# 字典
passthrough.invoke({"key": "value"})  # ✅

# 列表
passthrough.invoke([1, 2, 3])  # ✅

# 数字
passthrough.invoke(42)  # ✅
```

---

### 2025-2026 应用场景

**场景1：多模型对比**
```python
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langchain_core.prompts import ChatPromptTemplate

# 保持原始问题 + 对比多个模型
comparison_chain = {
    "question": RunnablePassthrough(),  # 透传问题
    "gpt4": ChatPromptTemplate.from_template("{question}") | ChatOpenAI(model="gpt-4"),
    "claude": ChatPromptTemplate.from_template("{question}") | ChatAnthropic(model="claude-3-opus"),
}

result = comparison_chain.invoke({"question": "解释量子计算"})
# {
#     "question": {"question": "解释量子计算"},
#     "gpt4": AIMessage(...),
#     "claude": AIMessage(...)
# }
```

**场景2：调试和日志**
```python
# 在链中插入透传节点用于调试
debug_chain = (
    RunnablePassthrough()  # 透传，便于查看输入
    | some_runnable
    | RunnablePassthrough()  # 透传，便于查看输出
)
```

---

## 数据增强（Enhancement）

### 原理讲解

**定义**：数据增强是指在原有数据基础上添加新信息，而不修改原有数据。

**数学表达**：
```
f(x) = {x, g(x)}  (augmentation function)
```

**在 LCEL 中的实现**：
```python
# 使用 assign 方法实现数据增强
chain = RunnablePassthrough.assign(
    new_field=some_runnable
)

input = {"existing": "value"}
output = chain.invoke(input)
# {"existing": "value", "new_field": ...}
```

---

### 为什么需要增强？

**问题场景**：多步骤处理需要访问所有历史数据

```python
# 没有增强：历史数据丢失
chain = step1 | step2 | step3
# step3 只能访问 step2 的输出，无法访问 step1 的输出

# 有增强：历史数据保留
chain = (
    RunnablePassthrough.assign(result1=step1)
    | RunnablePassthrough.assign(result2=step2)
    | RunnablePassthrough.assign(result3=step3)
)
# step3 可以访问 result1, result2 和原始输入
```

---

### 手写实现

```python
from langchain_core.runnables import Runnable, RunnableLambda
from typing import Dict, Any

class SimpleEnhancement(Runnable):
    """简单的数据增强实现"""

    def __init__(self, **kwargs: Runnable):
        self.enhancements = kwargs

    def invoke(self, input: Dict[str, Any]) -> Dict[str, Any]:
        """同步增强：添加新字段"""
        # 1. 类型检查
        if not isinstance(input, dict):
            raise TypeError(f"Expected dict, got {type(input)}")

        # 2. 复制原始字典
        output = input.copy()

        # 3. 执行所有增强并添加结果
        for key, runnable in self.enhancements.items():
            output[key] = runnable.invoke(input)

        # 4. 返回增强后的字典
        return output

# 测试
from langchain_core.runnables import RunnableLambda

enhancement = SimpleEnhancement(
    double=RunnableLambda(lambda x: x["value"] * 2),
    square=RunnableLambda(lambda x: x["value"] ** 2)
)

result = enhancement.invoke({"value": 5})
print(result)
# {"value": 5, "double": 10, "square": 25}
```

---

### 增强的特性

**特性1：保留原始数据**
```python
chain = RunnablePassthrough.assign(
    new_field="value"
)

input = {"existing": "old"}
output = chain.invoke(input)
# {"existing": "old", "new_field": "value"}
# existing 字段保留
```

**特性2：支持链式增强**
```python
chain = (
    RunnablePassthrough.assign(field1=runnable1)
    | RunnablePassthrough.assign(field2=runnable2)
    | RunnablePassthrough.assign(field3=runnable3)
)

# 每一步都保留之前的所有字段
```

**特性3：只支持字典**
```python
chain = RunnablePassthrough.assign(
    new_field=some_runnable
)

# ✅ 字典输入
chain.invoke({"key": "value"})

# ❌ 非字典输入会报错
chain.invoke("string")  # TypeError
```

---

### 2025-2026 应用场景

**场景1：RAG 管道**
```python
from operator import itemgetter

# 逐步增强：问题 → 上下文 → 答案 → 评分
rag_chain = (
    # 增强1: 添加检索结果
    RunnablePassthrough.assign(
        context=itemgetter("question") | retriever
    )
    # 增强2: 添加答案
    | RunnablePassthrough.assign(
        answer=prompt | model
    )
    # 增强3: 添加评分
    | RunnablePassthrough.assign(
        score=evaluation_chain
    )
)

result = rag_chain.invoke({"question": "..."})
# {
#     "question": "...",  # 原始
#     "context": [...],   # 增强1
#     "answer": "...",    # 增强2
#     "score": 0.95       # 增强3
# }
```

**场景2：特征工程**
```python
# 在机器学习管道中逐步添加特征
feature_chain = (
    # 原始特征
    RunnablePassthrough.assign(
        text_length=RunnableLambda(lambda x: len(x["text"]))
    )
    # 添加词频特征
    | RunnablePassthrough.assign(
        word_count=RunnableLambda(lambda x: len(x["text"].split()))
    )
    # 添加情感特征
    | RunnablePassthrough.assign(
        sentiment=sentiment_analyzer
    )
)

result = feature_chain.invoke({"text": "..."})
# {
#     "text": "...",
#     "text_length": 100,
#     "word_count": 20,
#     "sentiment": "positive"
# }
```

---

## 透传 vs 增强

### 对比表

| 维度 | 透传 | 增强 |
|------|------|------|
| **输入类型** | 任何类型 | 必须是字典 |
| **输出类型** | 与输入相同 | 字典 |
| **数据修改** | 不修改 | 添加新字段 |
| **性能开销** | 零开销 | 需要执行 Runnable |
| **使用场景** | 保持原始输入 | 逐步构建数据 |
| **实现方式** | `RunnablePassthrough()` | `RunnablePassthrough.assign()` |

---

### 使用决策树

```
需要保持数据吗？
├─ 是 → 需要添加新字段吗？
│      ├─ 是 → 使用增强（assign）
│      └─ 否 → 使用透传（RunnablePassthrough）
└─ 否 → 使用其他 Runnable
```

---

### 组合使用

**模式1：透传 + 增强**
```python
# 并行处理 + 保持原始输入 + 添加新字段
chain = {
    "original": RunnablePassthrough(),  # 透传
    "summary": summary_chain,           # 并行处理
} | RunnablePassthrough.assign(         # 增强
    keywords=keyword_extractor
)
```

**模式2：链式增强 + 透传**
```python
# 多步骤增强 + 保持中间结果
chain = (
    RunnablePassthrough.assign(step1=runnable1)  # 增强
    | RunnablePassthrough.assign(step2=runnable2)  # 增强
    | {
        "all_data": RunnablePassthrough(),  # 透传所有数据
        "final": final_runnable,            # 最终处理
    }
)
```

---

## 累积增强模式

### 模式定义

累积增强模式是指通过链式 assign 逐步构建完整的数据上下文。

**特点**：
- 每一步都保留之前的所有数据
- 后续步骤可以访问所有历史数据
- 数据逐步累积，不会丢失

---

### 实现模式

```python
# 累积增强的标准模式
chain = (
    # 步骤1: 添加第一个字段
    RunnablePassthrough.assign(field1=runnable1)

    # 步骤2: 添加第二个字段（可以访问 field1）
    | RunnablePassthrough.assign(field2=runnable2)

    # 步骤3: 添加第三个字段（可以访问 field1 和 field2）
    | RunnablePassthrough.assign(field3=runnable3)
)

result = chain.invoke({"input": "..."})
# {
#     "input": "...",   # 原始输入
#     "field1": ...,    # 步骤1
#     "field2": ...,    # 步骤2
#     "field3": ...     # 步骤3
# }
```

---

### 应用场景

**场景1：多步骤分析**
```python
# 文本分析管道：逐步添加分析结果
analysis_chain = (
    # 步骤1: 基础统计
    RunnablePassthrough.assign(
        length=RunnableLambda(lambda x: len(x["text"])),
        word_count=RunnableLambda(lambda x: len(x["text"].split()))
    )
    # 步骤2: 语义分析（依赖步骤1）
    | RunnablePassthrough.assign(
        summary=summary_chain,
        keywords=keyword_chain
    )
    # 步骤3: 高级分析（依赖步骤1和2）
    | RunnablePassthrough.assign(
        quality_score=RunnableLambda(lambda x:
            0.9 if x["word_count"] > 100 else 0.5
        )
    )
)
```

**场景2：数据管道**
```python
# ETL 管道：提取 → 转换 → 加载
etl_chain = (
    # Extract: 提取数据
    RunnablePassthrough.assign(
        raw_data=data_extractor
    )
    # Transform: 转换数据
    | RunnablePassthrough.assign(
        cleaned_data=data_cleaner,
        enriched_data=data_enricher
    )
    # Load: 加载数据
    | RunnablePassthrough.assign(
        load_result=data_loader
    )
)
```

---

## 最佳实践

### 实践1：选择合适的模式

```python
# ✅ 正确：并行处理用透传
chain = {
    "original": RunnablePassthrough(),
    "processed": some_runnable,
}

# ✅ 正确：串行处理用增强
chain = RunnablePassthrough.assign(
    new_field=some_runnable
)

# ❌ 错误：混淆两种模式
chain = RunnablePassthrough.assign(
    original=RunnablePassthrough()  # 多余
)
```

---

### 实践2：避免过度增强

```python
# ❌ 不推荐：过度增强，数据字典过大
chain = (
    RunnablePassthrough.assign(field1=runnable1)
    | RunnablePassthrough.assign(field2=runnable2)
    | RunnablePassthrough.assign(field3=runnable3)
    | RunnablePassthrough.assign(field4=runnable4)
    | RunnablePassthrough.assign(field5=runnable5)
    # ... 太多步骤
)

# ✅ 推荐：只保留必要的字段
chain = (
    RunnablePassthrough.assign(field1=runnable1)
    | RunnablePassthrough.assign(field2=runnable2)
    | RunnableLambda(lambda x: {
        "input": x["input"],
        "field1": x["field1"],
        "field2": x["field2"]
        # 只保留必要字段
    })
)
```

---

### 实践3：合理使用透传

```python
# ✅ 正确：在需要时使用透传
chain = {
    "original": RunnablePassthrough(),  # 后续需要访问
    "processed": some_runnable,
}

# ❌ 错误：不需要时也使用透传
chain = {
    "original": RunnablePassthrough(),  # 后续不需要访问
    "processed": some_runnable,
}
# 应该简化为：
chain = some_runnable
```

---

## 性能考虑

### 透传的性能

**优势**：
- 零开销：不复制数据
- 不执行计算
- 支持任何类型

**适用场景**：
- 需要保持原始输入
- 数据量大
- 性能敏感

---

### 增强的性能

**开销**：
- 复制字典：O(n)，n 是字段数
- 执行 Runnable：取决于 Runnable 的复杂度
- 串行执行：总时间 = 所有 Runnable 的时间之和

**优化建议**：
```python
# ❌ 性能较差：多次复制字典
chain = (
    RunnablePassthrough.assign(field1=runnable1)
    | RunnablePassthrough.assign(field2=runnable2)
    | RunnablePassthrough.assign(field3=runnable3)
)

# ✅ 性能优化：合并独立操作
chain = RunnablePassthrough.assign(
    field1=runnable1,
    field2=runnable2,
    field3=runnable3
)
```

---

## 核心要点总结

1. **透传（Passthrough）**：
   - 原样返回输入，不做修改
   - 零开销，支持任何类型
   - 用于保持原始输入

2. **增强（Enhancement）**：
   - 在原有数据基础上添加新字段
   - 只支持字典，需要执行 Runnable
   - 用于逐步构建数据上下文

3. **累积增强模式**：
   - 通过链式 assign 逐步累积数据
   - 每一步都保留所有历史数据
   - 适合多步骤处理流程

4. **最佳实践**：
   - 选择合适的模式
   - 避免过度增强
   - 合理使用透传
   - 注意性能优化

---

## 参考资源

**官方文档（2025-2026）**：
- [RunnablePassthrough API Reference](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html)
- [LCEL Concepts](https://python.langchain.com/docs/concepts/lcel)

**2025-2026 最佳实践**：
- [Building Production-Ready AI Pipelines](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557)
- [Master LangChain in 2025](https://towardsai.net/p/machine-learning/master-langchain-in-2025-from-rag-to-tools-complete-guide)

---

**版本**: v1.0
**最后更新**: 2026-02-19
**适用**: LangChain 0.3+, Python 3.13+
