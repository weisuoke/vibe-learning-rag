# 实战代码场景2：关系映射场景

完整可运行的 AI Agent 数据模型，演示 SQLAlchemy ORM 的关系映射。

---

## 场景说明

**目标：** 实现 AI Agent 的完整数据模型，包含用户、对话、消息的多层关系。

**功能：**
- 用户 → 对话（一对多）
- 对话 → 消息（一对多）
- 对话 ← → 标签（多对多）
- 预加载优化（避免 N+1 查询）

**技术栈：**
- SQLAlchemy 2.0+
- PostgreSQL
- UUID 主键
- 关系映射

---

## 完整代码

```python
"""
SQLAlchemy ORM 关系映射示例
演示：AI Agent 数据模型的多层关系
"""

from sqlalchemy import create_engine, Column, String, Text, Boolean, DateTime, ForeignKey, Table
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import declarative_base, relationship, sessionmaker, Session, selectinload
from datetime import datetime
from typing import List, Optional
import uuid

# ===== 1. 数据库配置 =====

DATABASE_URL = "postgresql://user:password@localhost:5432/ai_agent_db"

engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(bind=engine, expire_on_commit=False)
Base = declarative_base()


# ===== 2. 定义关联表（多对多） =====

conversation_tag = Table(
    'conversation_tag',
    Base.metadata,
    Column('conversation_id', UUID(as_uuid=True), ForeignKey('conversations.id', ondelete='CASCADE')),
    Column('tag_id', UUID(as_uuid=True), ForeignKey('tags.id', ondelete='CASCADE'))
)


# ===== 3. 定义模型 =====

class User(Base):
    """用户模型"""
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(100), unique=True, nullable=False, index=True)
    username = Column(String(50), unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    # 一对多：用户 → 对话
    conversations = relationship(
        "Conversation",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="selectin"  # 默认预加载
    )

    def __repr__(self):
        return f"<User(id={self.id}, email={self.email})>"


class Conversation(Base):
    """对话模型"""
    __tablename__ = "conversations"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete='CASCADE'), nullable=False)
    title = Column(String(200), nullable=False)
    is_archived = Column(Boolean, default=False, index=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # 多对一：对话 → 用户
    user = relationship("User", back_populates="conversations")

    # 一对多：对话 → 消息
    messages = relationship(
        "Message",
        back_populates="conversation",
        cascade="all, delete-orphan",
        order_by="Message.created_at"
    )

    # 多对多：对话 ← → 标签
    tags = relationship(
        "Tag",
        secondary=conversation_tag,
        back_populates="conversations"
    )

    def __repr__(self):
        return f"<Conversation(id={self.id}, title={self.title})>"


class Message(Base):
    """消息模型"""
    __tablename__ = "messages"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    conversation_id = Column(UUID(as_uuid=True), ForeignKey("conversations.id", ondelete='CASCADE'), nullable=False)
    role = Column(String(20), nullable=False)  # user/assistant/system
    content = Column(Text, nullable=False)
    token_count = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)

    # 多对一：消息 → 对话
    conversation = relationship("Conversation", back_populates="messages")

    def __repr__(self):
        return f"<Message(id={self.id}, role={self.role})>"


class Tag(Base):
    """标签模型"""
    __tablename__ = "tags"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(50), unique=True, nullable=False, index=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    # 多对多：标签 ← → 对话
    conversations = relationship(
        "Conversation",
        secondary=conversation_tag,
        back_populates="tags"
    )

    def __repr__(self):
        return f"<Tag(id={self.id}, name={self.name})>"


# ===== 4. 初始化数据库 =====

def init_db():
    """创建所有表"""
    Base.metadata.create_all(engine)
    print("✅ 数据库表创建成功")


# ===== 5. 用户操作 =====

def create_user(db: Session, email: str, username: str) -> User:
    """创建用户"""
    user = User(email=email, username=username)
    db.add(user)
    db.commit()
    db.refresh(user)
    print(f"✅ 创建用户: {user}")
    return user


def get_user_with_conversations(db: Session, user_id: UUID) -> Optional[User]:
    """查询用户及其对话（预加载）"""
    user = db.query(User)\
        .options(selectinload(User.conversations))\
        .filter(User.id == user_id)\
        .first()
    return user


# ===== 6. 对话操作 =====

def create_conversation(
    db: Session,
    user_id: UUID,
    title: str,
    first_message: Optional[str] = None
) -> Conversation:
    """创建对话（可选第一条消息）"""
    conversation = Conversation(user_id=user_id, title=title)
    db.add(conversation)
    db.flush()  # 获取 conversation.id

    if first_message:
        message = Message(
            conversation_id=conversation.id,
            role="user",
            content=first_message
        )
        db.add(message)

    db.commit()
    db.refresh(conversation)
    print(f"✅ 创建对话: {conversation}")
    return conversation


def get_conversation_with_messages(db: Session, conversation_id: UUID) -> Optional[Conversation]:
    """查询对话及其消息（预加载）"""
    conversation = db.query(Conversation)\
        .options(selectinload(Conversation.messages))\
        .filter(Conversation.id == conversation_id)\
        .first()
    return conversation


def get_user_conversations(
    db: Session,
    user_id: UUID,
    skip: int = 0,
    limit: int = 10
) -> List[Conversation]:
    """查询用户的对话列表"""
    conversations = db.query(Conversation)\
        .filter(Conversation.user_id == user_id)\
        .filter(Conversation.is_archived == False)\
        .order_by(Conversation.created_at.desc())\
        .offset(skip)\
        .limit(limit)\
        .all()
    return conversations


# ===== 7. 消息操作 =====

def create_message(
    db: Session,
    conversation_id: UUID,
    role: str,
    content: str
) -> Message:
    """创建消息"""
    message = Message(
        conversation_id=conversation_id,
        role=role,
        content=content,
        token_count=len(content.split())  # 简单的 token 计数
    )
    db.add(message)
    db.commit()
    db.refresh(message)
    print(f"✅ 创建消息: {message}")
    return message


def get_conversation_messages(
    db: Session,
    conversation_id: UUID,
    limit: int = 50
) -> List[Message]:
    """查询对话的消息列表"""
    messages = db.query(Message)\
        .filter(Message.conversation_id == conversation_id)\
        .order_by(Message.created_at)\
        .limit(limit)\
        .all()
    return messages


# ===== 8. 标签操作 =====

def create_tag(db: Session, name: str) -> Tag:
    """创建标签"""
    tag = Tag(name=name)
    db.add(tag)
    db.commit()
    db.refresh(tag)
    print(f"✅ 创建标签: {tag}")
    return tag


def get_or_create_tag(db: Session, name: str) -> Tag:
    """获取或创建标签"""
    tag = db.query(Tag).filter(Tag.name == name).first()
    if not tag:
        tag = create_tag(db, name)
    return tag


def add_tags_to_conversation(
    db: Session,
    conversation_id: UUID,
    tag_names: List[str]
) -> Conversation:
    """为对话添加标签"""
    conversation = db.query(Conversation).filter(Conversation.id == conversation_id).first()
    if not conversation:
        return None

    for tag_name in tag_names:
        tag = get_or_create_tag(db, tag_name)
        if tag not in conversation.tags:
            conversation.tags.append(tag)

    db.commit()
    db.refresh(conversation)
    print(f"✅ 为对话添加标签: {tag_names}")
    return conversation


def get_conversations_by_tag(db: Session, tag_name: str) -> List[Conversation]:
    """根据标签查询对话"""
    tag = db.query(Tag).filter(Tag.name == tag_name).first()
    if not tag:
        return []

    return tag.conversations


# ===== 9. 复杂查询（多层关系） =====

def get_user_full_data(db: Session, user_id: UUID) -> Optional[User]:
    """查询用户的完整数据（用户 → 对话 → 消息）"""
    user = db.query(User)\
        .options(
            selectinload(User.conversations)
            .selectinload(Conversation.messages)
        )\
        .filter(User.id == user_id)\
        .first()
    return user


def get_conversation_full_data(db: Session, conversation_id: UUID) -> Optional[Conversation]:
    """查询对话的完整数据（对话 → 消息 + 标签）"""
    conversation = db.query(Conversation)\
        .options(
            selectinload(Conversation.messages),
            selectinload(Conversation.tags)
        )\
        .filter(Conversation.id == conversation_id)\
        .first()
    return conversation


# ===== 10. 级联删除演示 =====

def delete_user_cascade(db: Session, user_id: UUID) -> bool:
    """删除用户（级联删除所有对话和消息）"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        return False

    db.delete(user)  # 自动删除所有 conversations 和 messages
    db.commit()
    print(f"✅ 删除用户（级联）: {user_id}")
    return True


def delete_conversation_cascade(db: Session, conversation_id: UUID) -> bool:
    """删除对话（级联删除所有消息）"""
    conversation = db.query(Conversation).filter(Conversation.id == conversation_id).first()
    if not conversation:
        return False

    db.delete(conversation)  # 自动删除所有 messages
    db.commit()
    print(f"✅ 删除对话（级联）: {conversation_id}")
    return True


# ===== 11. 演示函数 =====

def demo_one_to_many():
    """演示一对多关系"""
    print("\n" + "="*50)
    print("演示：一对多关系（用户 → 对话 → 消息）")
    print("="*50 + "\n")

    with SessionLocal() as db:
        # 1. 创建用户
        print("--- 1. 创建用户 ---")
        user = create_user(db, "alice@example.com", "alice")

        # 2. 创建对话
        print("\n--- 2. 创建对话 ---")
        conv1 = create_conversation(db, user.id, "Python 学习", "如何学习 Python？")
        conv2 = create_conversation(db, user.id, "FastAPI 开发", "FastAPI 怎么用？")

        # 3. 添加消息
        print("\n--- 3. 添加消息 ---")
        create_message(db, conv1.id, "assistant", "推荐先学习 Python 基础...")
        create_message(db, conv1.id, "user", "有什么好的资源吗？")
        create_message(db, conv1.id, "assistant", "可以看官方文档...")

        # 4. 查询用户的所有对话
        print("\n--- 4. 查询用户的所有对话 ---")
        user = get_user_with_conversations(db, user.id)
        print(f"用户 {user.email} 的对话:")
        for conv in user.conversations:
            print(f"  - {conv.title} ({len(conv.messages)} 条消息)")

        # 5. 查询对话的所有消息
        print("\n--- 5. 查询对话的所有消息 ---")
        conv = get_conversation_with_messages(db, conv1.id)
        print(f"对话 '{conv.title}' 的消息:")
        for msg in conv.messages:
            print(f"  [{msg.role}]: {msg.content[:50]}...")


def demo_many_to_many():
    """演示多对多关系"""
    print("\n" + "="*50)
    print("演示：多对多关系（对话 ← → 标签）")
    print("="*50 + "\n")

    with SessionLocal() as db:
        # 1. 创建用户和对话
        print("--- 1. 创建用户和对话 ---")
        user = create_user(db, "bob@example.com", "bob")
        conv1 = create_conversation(db, user.id, "Python 基础")
        conv2 = create_conversation(db, user.id, "FastAPI 实战")
        conv3 = create_conversation(db, user.id, "数据库设计")

        # 2. 创建标签
        print("\n--- 2. 为对话添加标签 ---")
        add_tags_to_conversation(db, conv1.id, ["Python", "基础"])
        add_tags_to_conversation(db, conv2.id, ["Python", "FastAPI", "实战"])
        add_tags_to_conversation(db, conv3.id, ["数据库", "设计"])

        # 3. 查询对话的标签
        print("\n--- 3. 查询对话的标签 ---")
        conv = get_conversation_full_data(db, conv2.id)
        print(f"对话 '{conv.title}' 的标签:")
        for tag in conv.tags:
            print(f"  - {tag.name}")

        # 4. 根据标签查询对话
        print("\n--- 4. 根据标签查询对话 ---")
        conversations = get_conversations_by_tag(db, "Python")
        print(f"标签 'Python' 的对话:")
        for conv in conversations:
            print(f"  - {conv.title}")


def demo_eager_loading():
    """演示预加载（避免 N+1 查询）"""
    print("\n" + "="*50)
    print("演示：预加载优化（避免 N+1 查询）")
    print("="*50 + "\n")

    with SessionLocal() as db:
        # 1. 创建测试数据
        print("--- 1. 创建测试数据 ---")
        user = create_user(db, "charlie@example.com", "charlie")
        for i in range(3):
            conv = create_conversation(db, user.id, f"对话 {i+1}")
            for j in range(2):
                create_message(db, conv.id, "user", f"消息 {j+1}")

        # 2. 懒加载（N+1 查询）
        print("\n--- 2. 懒加载（N+1 查询） ---")
        print("查询用户...")
        user = db.query(User).filter(User.id == user.id).first()
        print("访问对话（触发查询）...")
        for conv in user.conversations:
            print(f"  对话: {conv.title}")
            print("  访问消息（触发查询）...")
            for msg in conv.messages:
                print(f"    - {msg.content}")

        # 3. 预加载（只需 2-3 次查询）
        print("\n--- 3. 预加载（只需 2-3 次查询） ---")
        print("查询用户（预加载对话和消息）...")
        user = get_user_full_data(db, user.id)
        print("访问对话（不触发查询）...")
        for conv in user.conversations:
            print(f"  对话: {conv.title}")
            print("  访问消息（不触发查询）...")
            for msg in conv.messages:
                print(f"    - {msg.content}")


def demo_cascade_delete():
    """演示级联删除"""
    print("\n" + "="*50)
    print("演示：级联删除")
    print("="*50 + "\n")

    with SessionLocal() as db:
        # 1. 创建测试数据
        print("--- 1. 创建测试数据 ---")
        user = create_user(db, "david@example.com", "david")
        conv = create_conversation(db, user.id, "测试对话", "测试消息")
        create_message(db, conv.id, "assistant", "回复消息")

        # 2. 查询数据
        print("\n--- 2. 查询数据 ---")
        user = get_user_full_data(db, user.id)
        print(f"用户: {user.email}")
        print(f"对话数: {len(user.conversations)}")
        print(f"消息数: {sum(len(c.messages) for c in user.conversations)}")

        # 3. 删除对话（级联删除消息）
        print("\n--- 3. 删除对话（级联删除消息） ---")
        delete_conversation_cascade(db, conv.id)

        # 4. 验证删除
        print("\n--- 4. 验证删除 ---")
        user = get_user_full_data(db, user.id)
        print(f"剩余对话数: {len(user.conversations)}")

        # 5. 删除用户（级联删除所有对话和消息）
        print("\n--- 5. 删除用户（级联删除所有对话和消息） ---")
        delete_user_cascade(db, user.id)


# ===== 12. 主函数 =====

def main():
    """主函数"""
    # 初始化数据库
    init_db()

    # 演示一对多关系
    demo_one_to_many()

    # 演示多对多关系
    demo_many_to_many()

    # 演示预加载
    demo_eager_loading()

    # 演示级联删除
    demo_cascade_delete()

    print("\n" + "="*50)
    print("✅ 所有演示完成")
    print("="*50)


if __name__ == "__main__":
    main()
```

---

## 运行输出示例

```
✅ 数据库表创建成功

==================================================
演示：一对多关系（用户 → 对话 → 消息）
==================================================

--- 1. 创建用户 ---
✅ 创建用户: <User(id=..., email=alice@example.com)>

--- 2. 创建对话 ---
✅ 创建对话: <Conversation(id=..., title=Python 学习)>
✅ 创建对话: <Conversation(id=..., title=FastAPI 开发)>

--- 3. 添加消息 ---
✅ 创建消息: <Message(id=..., role=assistant)>
✅ 创建消息: <Message(id=..., role=user)>
✅ 创建消息: <Message(id=..., role=assistant)>

--- 4. 查询用户的所有对话 ---
用户 alice@example.com 的对话:
  - Python 学习 (3 条消息)
  - FastAPI 开发 (1 条消息)

--- 5. 查询对话的所有消息 ---
对话 'Python 学习' 的消息:
  [user]: 如何学习 Python？
  [assistant]: 推荐先学习 Python 基础...
  [user]: 有什么好的资源吗？
  [assistant]: 可以看官方文档...

==================================================
演示：多对多关系（对话 ← → 标签）
==================================================

--- 1. 创建用户和对话 ---
✅ 创建用户: <User(id=..., email=bob@example.com)>
✅ 创建对话: <Conversation(id=..., title=Python 基础)>
✅ 创建对话: <Conversation(id=..., title=FastAPI 实战)>
✅ 创建对话: <Conversation(id=..., title=数据库设计)>

--- 2. 为对话添加标签 ---
✅ 创建标签: <Tag(id=..., name=Python)>
✅ 创建标签: <Tag(id=..., name=基础)>
✅ 为对话添加标签: ['Python', '基础']
✅ 创建标签: <Tag(id=..., name=FastAPI)>
✅ 创建标签: <Tag(id=..., name=实战)>
✅ 为对话添加标签: ['Python', 'FastAPI', '实战']

--- 3. 查询对话的标签 ---
对话 'FastAPI 实战' 的标签:
  - Python
  - FastAPI
  - 实战

--- 4. 根据标签查询对话 ---
标签 'Python' 的对话:
  - Python 基础
  - FastAPI 实战

==================================================
✅ 所有演示完成
==================================================
```

---

## 关键技术点

### 1. 一对多关系

```python
class User(Base):
    conversations = relationship(
        "Conversation",
        back_populates="user",
        cascade="all, delete-orphan"  # 级联删除
    )

class Conversation(Base):
    user_id = Column(UUID, ForeignKey("users.id"))
    user = relationship("User", back_populates="conversations")
```

### 2. 多对多关系

```python
# 关联表
conversation_tag = Table(
    'conversation_tag',
    Base.metadata,
    Column('conversation_id', UUID, ForeignKey('conversations.id')),
    Column('tag_id', UUID, ForeignKey('tags.id'))
)

class Conversation(Base):
    tags = relationship("Tag", secondary=conversation_tag)

class Tag(Base):
    conversations = relationship("Conversation", secondary=conversation_tag)
```

### 3. 预加载优化

```python
# 单层预加载
user = db.query(User)\
    .options(selectinload(User.conversations))\
    .first()

# 多层预加载
user = db.query(User)\
    .options(
        selectinload(User.conversations)
        .selectinload(Conversation.messages)
    )\
    .first()
```

### 4. 级联删除

```python
conversations = relationship(
    "Conversation",
    cascade="all, delete-orphan"  # 删除用户时自动删除对话
)

# 删除用户
db.delete(user)  # 自动删除所有 conversations 和 messages
db.commit()
```

---

## 最佳实践

1. **使用 UUID 主键**：更安全，不易被猜测
2. **添加索引**：为外键和常用查询字段添加索引
3. **使用预加载**：避免 N+1 查询问题
4. **级联删除**：自动清理关联数据
5. **back_populates**：双向关系更清晰
6. **order_by**：在 relationship 中指定排序

---

## 扩展练习

1. 添加用户资料（一对一关系）
2. 实现消息点赞功能（多对多关系）
3. 添加对话分享功能（多对多关系）
4. 实现软删除（添加 deleted_at 字段）
5. 优化查询性能（添加更多索引）

---

**记住：** 关系映射让你用对象属性访问关联数据，ORM 自动处理 JOIN 查询。
