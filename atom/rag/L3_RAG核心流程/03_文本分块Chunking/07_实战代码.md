# 实战代码

一个完整可运行的文本分块示例，展示三种分块策略在 RAG 开发中的实际应用。

---

````python
"""
文本分块（Chunking）实战示例
演示：三种分块策略的实现与对比

依赖安装：
pip install langchain langchain-text-splitters tiktoken
"""

from typing import List

# ===== 1. 准备示例文本 =====
print("=" * 60)
print("1. 准备示例文本")
print("=" * 60)

sample_text = """
# Python 编程入门指南

## 第一章：Python 简介

Python 是一种高级编程语言，由 Guido van Rossum 于 1991 年创建。它以简洁、易读的语法著称，被广泛应用于 Web 开发、数据分析、人工智能等领域。

Python 的设计哲学强调代码的可读性，使用缩进来定义代码块，而不是使用大括号。这使得 Python 代码看起来更加整洁。

## 第二章：变量与数据类型

在 Python 中，变量不需要声明类型。你可以直接赋值：

```python
name = "Alice"
age = 25
height = 1.65
is_student = True
```

Python 支持多种数据类型：
- 字符串（str）：用于存储文本
- 整数（int）：用于存储整数
- 浮点数（float）：用于存储小数
- 布尔值（bool）：True 或 False

## 第三章：控制流程

Python 使用 if-elif-else 语句进行条件判断：

```python
if age >= 18:
    print("成年人")
elif age >= 12:
    print("青少年")
else:
    print("儿童")
```

循环结构包括 for 循环和 while 循环，用于重复执行代码块。

## 第四章：函数

函数是组织代码的基本单元。使用 def 关键字定义函数：

```python
def greet(name):
    return f"Hello, {name}!"
```

函数可以接受参数，也可以返回值。良好的函数设计应该遵循单一职责原则。
"""

print(f"原文长度: {len(sample_text)} 字符")
print(f"原文预览: {sample_text[:100]}...")
print()


# ===== 2. 固定大小分块 =====
print("=" * 60)
print("2. 固定大小分块")
print("=" * 60)

def fixed_size_chunk(text: str, chunk_size: int = 300, overlap: int = 50) -> List[str]:
    """固定大小分块"""
    chunks = []
    start = 0
    while start < len(text):
        end = start + chunk_size
        chunk = text[start:end]
        chunks.append(chunk)
        start = end - overlap
    return chunks

fixed_chunks = fixed_size_chunk(sample_text, chunk_size=300, overlap=30)

print(f"分块数量: {len(fixed_chunks)}")
print(f"块大小范围: {min(len(c) for c in fixed_chunks)} - {max(len(c) for c in fixed_chunks)}")
print()
print("前3个块预览：")
for i, chunk in enumerate(fixed_chunks[:3]):
    print(f"\n--- Chunk {i+1} ({len(chunk)} chars) ---")
    print(chunk[:150] + "..." if len(chunk) > 150 else chunk)
print()


# ===== 3. 递归字符分块（LangChain） =====
print("=" * 60)
print("3. 递归字符分块（推荐）")
print("=" * 60)

from langchain_text_splitters import RecursiveCharacterTextSplitter

# 创建分块器
recursive_splitter = RecursiveCharacterTextSplitter(
    chunk_size=300,
    chunk_overlap=30,
    separators=["\n\n", "\n", "。", ".", " ", ""],
    length_function=len,
)

recursive_chunks = recursive_splitter.split_text(sample_text)

print(f"分块数量: {len(recursive_chunks)}")
print(f"块大小范围: {min(len(c) for c in recursive_chunks)} - {max(len(c) for c in recursive_chunks)}")
print()
print("前3个块预览：")
for i, chunk in enumerate(recursive_chunks[:3]):
    print(f"\n--- Chunk {i+1} ({len(chunk)} chars) ---")
    print(chunk[:150] + "..." if len(chunk) > 150 else chunk)
print()


# ===== 4. Markdown 标题分块 =====
print("=" * 60)
print("4. Markdown 标题分块")
print("=" * 60)

from langchain_text_splitters import MarkdownHeaderTextSplitter

# 定义要识别的标题层级
headers_to_split_on = [
    ("#", "h1"),
    ("##", "h2"),
    ("###", "h3"),
]

md_splitter = MarkdownHeaderTextSplitter(
    headers_to_split_on=headers_to_split_on,
    strip_headers=False,  # 保留标题
)

md_chunks = md_splitter.split_text(sample_text)

print(f"分块数量: {len(md_chunks)}")
print()
print("所有块预览：")
for i, chunk in enumerate(md_chunks):
    content = chunk.page_content
    metadata = chunk.metadata
    print(f"\n--- Chunk {i+1} ---")
    print(f"元数据: {metadata}")
    print(f"内容预览: {content[:100]}..." if len(content) > 100 else f"内容: {content}")
print()


# ===== 5. 分块效果对比 =====
print("=" * 60)
print("5. 分块效果对比")
print("=" * 60)

def analyze_chunks(chunks: List, name: str):
    """分析分块效果"""
    if hasattr(chunks[0], 'page_content'):
        sizes = [len(c.page_content) for c in chunks]
    else:
        sizes = [len(c) for c in chunks]

    print(f"\n{name}:")
    print(f"  - 块数量: {len(chunks)}")
    print(f"  - 平均大小: {sum(sizes) // len(sizes)} 字符")
    print(f"  - 最小块: {min(sizes)} 字符")
    print(f"  - 最大块: {max(sizes)} 字符")
    print(f"  - 总字符数: {sum(sizes)} (原文: {len(sample_text)})")

analyze_chunks(fixed_chunks, "固定大小分块")
analyze_chunks(recursive_chunks, "递归字符分块")
analyze_chunks(md_chunks, "Markdown 标题分块")
print()


# ===== 6. RAG 开发应用示例 =====
print("=" * 60)
print("6. RAG 开发应用：完整的文档处理流程")
print("=" * 60)

def process_document_for_rag(
    text: str,
    chunk_size: int = 500,
    chunk_overlap: int = 50
) -> List[dict]:
    """
    RAG 文档处理流程

    Args:
        text: 原始文档文本
        chunk_size: 块大小
        chunk_overlap: 重叠大小

    Returns:
        处理后的文档块列表，每个块包含内容和元数据
    """
    # 1. 创建分块器
    splitter = RecursiveCharacterTextSplitter(
        chunk_size=chunk_size,
        chunk_overlap=chunk_overlap,
        separators=["\n\n", "\n", "。", ".", "！", "？", " ", ""],
    )

    # 2. 分块
    chunks = splitter.split_text(text)

    # 3. 添加元数据
    processed_chunks = []
    for i, chunk in enumerate(chunks):
        processed_chunks.append({
            "id": f"chunk_{i}",
            "content": chunk,
            "metadata": {
                "chunk_index": i,
                "chunk_size": len(chunk),
                "total_chunks": len(chunks),
            }
        })

    return processed_chunks

# 处理文档
rag_chunks = process_document_for_rag(sample_text, chunk_size=400, chunk_overlap=40)

print(f"处理完成，共 {len(rag_chunks)} 个块")
print()
print("示例块结构：")
print(f"  ID: {rag_chunks[0]['id']}")
print(f"  内容长度: {len(rag_chunks[0]['content'])} 字符")
print(f"  元数据: {rag_chunks[0]['metadata']}")
print(f"  内容预览: {rag_chunks[0]['content'][:100]}...")
print()


# ===== 7. 验证分块质量 =====
print("=" * 60)
print("7. 验证分块质量")
print("=" * 60)

def validate_chunks(
    chunks: List[dict],
    min_size: int = 100,
    max_size: int = 600
) -> dict:
    """验证分块质量"""
    sizes = [len(c["content"]) for c in chunks]

    # 统计
    too_small = sum(1 for s in sizes if s < min_size)
    too_large = sum(1 for s in sizes if s > max_size)
    in_range = len(sizes) - too_small - too_large

    # 检查是否有空块
    empty_chunks = sum(1 for c in chunks if not c["content"].strip())

    return {
        "total_chunks": len(chunks),
        "avg_size": sum(sizes) // len(sizes),
        "min_size": min(sizes),
        "max_size": max(sizes),
        "too_small": too_small,
        "too_large": too_large,
        "in_range": in_range,
        "empty_chunks": empty_chunks,
        "quality_score": in_range / len(chunks) * 100,
    }

quality = validate_chunks(rag_chunks)

print("分块质量报告：")
print(f"  - 总块数: {quality['total_chunks']}")
print(f"  - 平均大小: {quality['avg_size']} 字符")
print(f"  - 大小范围: {quality['min_size']} - {quality['max_size']} 字符")
print(f"  - 过小的块: {quality['too_small']} 个")
print(f"  - 过大的块: {quality['too_large']} 个")
print(f"  - 合格的块: {quality['in_range']} 个")
print(f"  - 空块: {quality['empty_chunks']} 个")
print(f"  - 质量评分: {quality['quality_score']:.1f}%")
print()

print("=" * 60)
print("示例运行完成！")
print("=" * 60)
````

---

## 运行输出示例

```
============================================================
1. 准备示例文本
============================================================
原文长度: 1247 字符
原文预览:
# Python 编程入门指南

## 第一章：Python 简介

Python 是一种高级编程语言，由 Guido van Rossum 于 1991 年创建...

============================================================
2. 固定大小分块
============================================================
分块数量: 5
块大小范围: 167 - 300

前3个块预览：

--- Chunk 1 (300 chars) ---

# Python 编程入门指南

## 第一章：Python 简介

Python 是一种高级编程语言，由 Guido van Rossum 于 1991 年创建。它以简洁、易读的语法著称，被广泛应用于 Web 开发、数据分析、人工智能等领域。

Python 的设计哲学强调代码的可读性，使用缩进来定义代码块，而不是使用大括号。这使得 Pyth...

============================================================
3. 递归字符分块（推荐）
============================================================
分块数量: 6
块大小范围: 147 - 299

============================================================
5. 分块效果对比
============================================================

固定大小分块:
  - 块数量: 5
  - 平均大小: 273 字符
  - 最小块: 167 字符
  - 最大块: 300 字符

递归字符分块:
  - 块数量: 6
  - 平均大小: 227 字符
  - 最小块: 147 字符
  - 最大块: 299 字符

Markdown 标题分块:
  - 块数量: 5
  - 平均大小: 232 字符
  - 最小块: 147 字符
  - 最大块: 299 字符

============================================================
7. 验证分块质量
============================================================
分块质量报告：
  - 总块数: 4
  - 平均大小: 311 字符
  - 大小范围: 147 - 399 字符
  - 过小的块: 0 个
  - 过大的块: 0 个
  - 合格的块: 4 个
  - 空块: 0 个
  - 质量评分: 100.0%

============================================================
示例运行完成！
============================================================
```

---

## 关键代码说明

| 代码部分 | 作用 | 关键参数 |
|----------|------|----------|
| `fixed_size_chunk()` | 固定大小分块 | `chunk_size`, `overlap` |
| `RecursiveCharacterTextSplitter` | 递归字符分块 | `chunk_size`, `chunk_overlap`, `separators` |
| `MarkdownHeaderTextSplitter` | Markdown 标题分块 | `headers_to_split_on` |
| `process_document_for_rag()` | RAG 文档处理流程 | 返回带元数据的块 |
| `validate_chunks()` | 验证分块质量 | 检查大小分布和空块 |

---

**下一步：** [08_面试必问](./08_面试必问.md) - 如何在面试中展示分块知识
