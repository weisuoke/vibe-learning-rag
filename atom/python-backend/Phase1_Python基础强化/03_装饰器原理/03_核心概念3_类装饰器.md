# 核心概念3：类装饰器（基于类的装饰器）

> 理解如何使用类实现装饰器，掌握更灵活的装饰器模式

---

## 什么是类装饰器？

**类装饰器是使用类来实现装饰器功能，通过 `__init__` 和 `__call__` 方法实现函数包装，提供更好的状态管理和代码组织。**

---

## 为什么需要类装饰器？

```python
# 场景：我们需要一个计数器装饰器，记录函数被调用的次数

# ❌ 使用函数装饰器：需要使用可变对象（如列表）来存储状态
def count_calls(func):
    count = [0]  # 使用列表是因为闭包不能修改外部不可变变量

    def wrapper(*args, **kwargs):
        count[0] += 1
        print(f"{func.__name__} 被调用了 {count[0]} 次")
        return func(*args, **kwargs)
    return wrapper

# ✅ 使用类装饰器：状态管理更自然
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0  # 实例变量，自然地存储状态

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"{self.func.__name__} 被调用了 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def greet():
    print("Hello!")

greet()  # greet 被调用了 1 次
greet()  # greet 被调用了 2 次
```

**类装饰器的优势：**
1. **状态管理更自然**：使用实例变量而非闭包
2. **代码组织更清晰**：可以有多个方法
3. **可扩展性更好**：可以继承和重写
4. **调试更容易**：可以查看实例属性

---

## 类装饰器的基本结构

```python
class Decorator:
    def __init__(self, func):
        """
        初始化装饰器
        参数:
            func: 被装饰的函数
        """
        self.func = func

    def __call__(self, *args, **kwargs):
        """
        当装饰后的函数被调用时，这个方法会被执行
        """
        # 在原函数执行前做一些事情
        result = self.func(*args, **kwargs)
        # 在原函数执行后做一些事情
        return result

@Decorator
def my_function():
    pass

# 等价于：
# my_function = Decorator(my_function)
# 当调用 my_function() 时，实际调用的是 Decorator.__call__()
```

**关键点：**
- `__init__`：在装饰时调用（定义时）
- `__call__`：在函数调用时执行（运行时）

---

## 执行流程详解

```python
class LogDecorator:
    def __init__(self, func):
        print(f"[__init__] 装饰函数: {func.__name__}")
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f"[__call__] 调用 {self.func.__name__}")
        result = self.func(*args, **kwargs)
        print(f"[__call__] {self.func.__name__} 执行完毕")
        return result

@LogDecorator
def greet(name):
    print(f"  Hello, {name}!")
    return f"Greeted {name}"

# 定义时输出：
# [__init__] 装饰函数: greet

print("=" * 50)
result = greet("Alice")
# 调用时输出：
# [__call__] 调用 greet
#   Hello, Alice!
# [__call__] greet 执行完毕

print(f"返回值: {result}")
```

---

## 实战示例1：计数器装饰器

```python
from functools import wraps

class CountCalls:
    """记录函数调用次数的装饰器"""

    def __init__(self, func):
        wraps(func)(self)  # 保留原函数的元信息
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"[调用 #{self.count}] {self.func.__name__}")
        return self.func(*args, **kwargs)

    def reset(self):
        """重置计数器"""
        self.count = 0

@CountCalls
def process_data(data):
    return f"处理: {data}"

print(process_data("A"))  # [调用 #1] process_data
print(process_data("B"))  # [调用 #2] process_data
print(process_data("C"))  # [调用 #3] process_data

# 可以访问装饰器的方法和属性
print(f"总共调用了 {process_data.count} 次")  # 总共调用了 3 次
process_data.reset()
print(f"重置后: {process_data.count} 次")  # 重置后: 0 次
```

---

## 实战示例2：带参数的类装饰器

```python
from functools import wraps

class Retry:
    """重试装饰器：函数失败时自动重试"""

    def __init__(self, max_attempts=3, delay=1):
        """
        参数:
            max_attempts: 最大重试次数
            delay: 重试间隔（秒）
        """
        self.max_attempts = max_attempts
        self.delay = delay

    def __call__(self, func):
        """
        注意：带参数的类装饰器，__call__ 接收的是函数
        """
        @wraps(func)
        def wrapper(*args, **kwargs):
            import time

            for attempt in range(1, self.max_attempts + 1):
                try:
                    print(f"尝试 {attempt}/{self.max_attempts}: {func.__name__}")
                    result = func(*args, **kwargs)
                    print(f"成功！")
                    return result
                except Exception as e:
                    print(f"失败: {e}")
                    if attempt == self.max_attempts:
                        print(f"达到最大重试次数，放弃")
                        raise
                    print(f"等待 {self.delay} 秒后重试...")
                    time.sleep(self.delay)

        return wrapper

# 使用带参数的类装饰器
@Retry(max_attempts=3, delay=0.5)
def unstable_function():
    import random
    if random.random() < 0.7:
        raise Exception("随机失败")
    return "成功"

try:
    result = unstable_function()
    print(f"最终结果: {result}")
except Exception:
    print("函数最终失败")
```

**注意：带参数的类装饰器的结构不同：**

```python
# 不带参数的类装饰器
class Decorator:
    def __init__(self, func):  # 接收函数
        self.func = func

    def __call__(self, *args, **kwargs):  # 执行函数
        return self.func(*args, **kwargs)

@Decorator
def my_func():
    pass

# 等价于：my_func = Decorator(my_func)
```

```python
# 带参数的类装饰器
class Decorator:
    def __init__(self, param):  # 接收参数
        self.param = param

    def __call__(self, func):  # 接收函数，返回包装函数
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper

@Decorator(param="value")
def my_func():
    pass

# 等价于：my_func = Decorator(param="value")(my_func)
```

---

## 实战示例3：缓存装饰器（带统计信息）

```python
from functools import wraps
import time

class CacheWithStats:
    """带统计信息的缓存装饰器"""

    def __init__(self, func):
        wraps(func)(self)
        self.func = func
        self.cache = {}
        self.hits = 0  # 缓存命中次数
        self.misses = 0  # 缓存未命中次数

    def __call__(self, *args):
        if args in self.cache:
            self.hits += 1
            print(f"缓存命中: {args}")
            return self.cache[args]

        self.misses += 1
        print(f"缓存未命中: {args}")
        result = self.func(*args)
        self.cache[args] = result
        return result

    def stats(self):
        """返回缓存统计信息"""
        total = self.hits + self.misses
        hit_rate = self.hits / total * 100 if total > 0 else 0
        return {
            "hits": self.hits,
            "misses": self.misses,
            "total": total,
            "hit_rate": f"{hit_rate:.1f}%"
        }

    def clear(self):
        """清空缓存"""
        self.cache.clear()
        self.hits = 0
        self.misses = 0

@CacheWithStats
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(5))
print(fibonacci(5))  # 第二次调用，缓存命中
print(fibonacci(6))

# 查看统计信息
print(f"\n缓存统计: {fibonacci.stats()}")
# 输出：缓存统计: {'hits': 4, 'misses': 7, 'total': 11, 'hit_rate': '36.4%'}
```

---

## 实战示例4：限流装饰器（滑动窗口）

```python
from functools import wraps
import time
from collections import deque

class RateLimit:
    """限流装饰器：使用滑动窗口算法"""

    def __init__(self, max_calls, time_window):
        """
        参数:
            max_calls: 时间窗口内最大调用次数
            time_window: 时间窗口（秒）
        """
        self.max_calls = max_calls
        self.time_window = time_window

    def __call__(self, func):
        # 使用双端队列存储调用时间戳
        call_times = deque()

        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time.time()

            # 移除过期的调用记录
            while call_times and now - call_times[0] > self.time_window:
                call_times.popleft()

            # 检查是否超过限制
            if len(call_times) >= self.max_calls:
                oldest_call = call_times[0]
                wait_time = self.time_window - (now - oldest_call)
                raise Exception(
                    f"限流：{func.__name__} 在 {self.time_window} 秒内最多调用 "
                    f"{self.max_calls} 次，请等待 {wait_time:.1f} 秒"
                )

            # 记录本次调用
            call_times.append(now)

            # 执行函数
            return func(*args, **kwargs)

        return wrapper

@RateLimit(max_calls=3, time_window=5)
def send_request(url):
    print(f"发送请求到: {url}")
    return "响应数据"

# 测试限流
for i in range(5):
    try:
        send_request(f"https://api.example.com/data/{i}")
        time.sleep(1)
    except Exception as e:
        print(f"错误: {e}")
```

---

## 实战示例5：性能监控装饰器

```python
from functools import wraps
import time
from statistics import mean, median

class PerformanceMonitor:
    """性能监控装饰器：记录函数执行时间"""

    def __init__(self, func):
        wraps(func)(self)
        self.func = func
        self.execution_times = []

    def __call__(self, *args, **kwargs):
        start_time = time.time()
        result = self.func(*args, **kwargs)
        end_time = time.time()

        execution_time = end_time - start_time
        self.execution_times.append(execution_time)

        print(f"{self.func.__name__} 执行时间: {execution_time:.4f}秒")
        return result

    def report(self):
        """生成性能报告"""
        if not self.execution_times:
            return "没有执行记录"

        return {
            "调用次数": len(self.execution_times),
            "总时间": f"{sum(self.execution_times):.4f}秒",
            "平均时间": f"{mean(self.execution_times):.4f}秒",
            "中位数时间": f"{median(self.execution_times):.4f}秒",
            "最快": f"{min(self.execution_times):.4f}秒",
            "最慢": f"{max(self.execution_times):.4f}秒",
        }

@PerformanceMonitor
def process_data(n):
    time.sleep(0.1 * n)  # 模拟耗时操作
    return f"处理了 {n} 条数据"

# 多次调用
for i in range(1, 4):
    process_data(i)

# 查看性能报告
print("\n性能报告:")
for key, value in process_data.report().items():
    print(f"  {key}: {value}")
```

---

## 类装饰器 vs 函数装饰器

```python
# 函数装饰器：适合简单场景
def simple_log(func):
    def wrapper(*args, **kwargs):
        print(f"调用 {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

# 类装饰器：适合需要状态管理的场景
class StatefulLog:
    def __init__(self, func):
        self.func = func
        self.call_count = 0

    def __call__(self, *args, **kwargs):
        self.call_count += 1
        print(f"调用 {self.func.__name__} (第 {self.call_count} 次)")
        return self.func(*args, **kwargs)
```

**选择建议：**

| 场景 | 推荐 | 原因 |
|------|------|------|
| 简单包装（日志、计时） | 函数装饰器 | 代码更简洁 |
| 需要状态管理（计数、缓存） | 类装饰器 | 状态管理更自然 |
| 需要多个辅助方法 | 类装饰器 | 代码组织更清晰 |
| 需要继承和扩展 | 类装饰器 | 面向对象更灵活 |
| 性能敏感 | 函数装饰器 | 调用开销更小 |

---

## 类装饰器的继承

```python
from functools import wraps

class BaseDecorator:
    """基础装饰器类"""

    def __init__(self, func):
        wraps(func)(self)
        self.func = func

    def __call__(self, *args, **kwargs):
        self.before()
        result = self.func(*args, **kwargs)
        self.after()
        return result

    def before(self):
        """在函数执行前调用（子类可重写）"""
        pass

    def after(self):
        """在函数执行后调用（子类可重写）"""
        pass

class LogDecorator(BaseDecorator):
    """日志装饰器：继承自基础装饰器"""

    def before(self):
        print(f"[LOG] 开始执行 {self.func.__name__}")

    def after(self):
        print(f"[LOG] 执行完毕 {self.func.__name__}")

class TimingDecorator(BaseDecorator):
    """计时装饰器：继承自基础装饰器"""

    def before(self):
        import time
        self.start_time = time.time()

    def after(self):
        import time
        elapsed = time.time() - self.start_time
        print(f"[TIMING] {self.func.__name__} 耗时 {elapsed:.4f}秒")

@LogDecorator
def task1():
    print("  执行任务1")

@TimingDecorator
def task2():
    import time
    time.sleep(0.1)
    print("  执行任务2")

task1()
# 输出：
# [LOG] 开始执行 task1
#   执行任务1
# [LOG] 执行完毕 task1

task2()
# 输出：
#   执行任务2
# [TIMING] task2 耗时 0.1001秒
```

---

## 在 FastAPI 中的应用

虽然 FastAPI 主要使用函数装饰器，但类装饰器在某些场景下也很有用：

```python
from fastapi import FastAPI, Request
from functools import wraps
import time

app = FastAPI()

class RateLimitMiddleware:
    """API 限流装饰器"""

    def __init__(self, max_calls=10, time_window=60):
        self.max_calls = max_calls
        self.time_window = time_window
        self.call_records = {}

    def __call__(self, func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 获取客户端 IP（简化示例）
            client_ip = "127.0.0.1"

            # 检查限流
            now = time.time()
            if client_ip not in self.call_records:
                self.call_records[client_ip] = []

            # 清理过期记录
            self.call_records[client_ip] = [
                t for t in self.call_records[client_ip]
                if now - t < self.time_window
            ]

            # 检查是否超限
            if len(self.call_records[client_ip]) >= self.max_calls:
                raise Exception("请求过于频繁，请稍后再试")

            # 记录本次请求
            self.call_records[client_ip].append(now)

            # 执行函数
            return await func(*args, **kwargs)

        return wrapper

# 使用类装饰器
rate_limiter = RateLimitMiddleware(max_calls=5, time_window=60)

@app.get("/api/data")
@rate_limiter
async def get_data():
    return {"message": "数据"}
```

---

## 常见错误

### 错误1：忘记实现 `__call__` 方法

```python
# ❌ 错误
class BadDecorator:
    def __init__(self, func):
        self.func = func

    # 忘记实现 __call__！

@BadDecorator
def my_func():
    pass

# my_func()  # TypeError: 'BadDecorator' object is not callable
```

### 错误2：带参数的类装饰器结构错误

```python
# ❌ 错误：把参数和函数都放在 __init__
class BadDecorator:
    def __init__(self, func, param):  # 错误！
        self.func = func
        self.param = param

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)

# @BadDecorator(param="value")  # TypeError
# def my_func():
#     pass
```

```python
# ✅ 正确：参数在 __init__，函数在 __call__
class GoodDecorator:
    def __init__(self, param):
        self.param = param

    def __call__(self, func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper

@GoodDecorator(param="value")
def my_func():
    pass
```

### 错误3：忘记保留原函数元信息

```python
# ❌ 错误
class BadDecorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)

@BadDecorator
def my_function():
    """这是我的函数"""
    pass

print(my_function.__name__)  # BadDecorator（错误！）
print(my_function.__doc__)   # None（丢失了！）
```

```python
# ✅ 正确：使用 wraps
from functools import wraps

class GoodDecorator:
    def __init__(self, func):
        wraps(func)(self)  # 保留原函数元信息
        self.func = func

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)

@GoodDecorator
def my_function():
    """这是我的函数"""
    pass

print(my_function.__name__)  # my_function（正确！）
print(my_function.__doc__)   # 这是我的函数（保留了！）
```

---

## 总结

**类装饰器的核心要点：**

1. **基本结构**：`__init__` 接收函数，`__call__` 执行逻辑
2. **带参数**：`__init__` 接收参数，`__call__` 接收函数并返回包装函数
3. **状态管理**：使用实例变量存储状态
4. **元信息保留**：使用 `wraps(func)(self)` 保留原函数信息
5. **可扩展性**：可以继承和重写方法

**类装饰器 vs 函数装饰器：**
- **函数装饰器**：简单、轻量、性能好
- **类装饰器**：状态管理、代码组织、可扩展

**在 AI Agent 开发中的应用：**
- 性能监控（记录执行时间统计）
- 限流控制（管理请求频率）
- 缓存管理（带统计信息的缓存）
- 重试机制（记录重试次数和成功率）

**下一步学习：**
- 最小可用：20%核心知识解决80%问题
- 实战代码：完整的 FastAPI 应用示例
