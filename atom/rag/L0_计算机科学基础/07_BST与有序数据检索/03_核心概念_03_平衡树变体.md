# 03_核心概念_03_平衡树变体

## 概念定义

**平衡树（Balanced Tree）** 是通过特定规则维护树高度平衡的BST变体，保证所有操作的时间复杂度为O(log n)。主要变体包括：AVL树、红黑树、Treap、Splay树，以及2025年的学习增强BST。

---

## 为什么需要平衡树？

### 普通BST的问题

**最坏情况：有序插入导致退化为链表**

```python
# 按顺序插入：[1, 2, 3, 4, 5]
bst = BST()
for i in [1, 2, 3, 4, 5]:
    bst.insert(i)

# 结果：退化为链表
#     1
#      \
#       2
#        \
#         3
#          \
#           4
#            \
#             5

# 查找5需要5步 = O(n) ❌
```

**性能对比：**

| BST类型 | 高度 | 查找 | 插入 | 删除 |
|---------|------|------|------|------|
| 不平衡BST | O(n) | O(n) | O(n) | O(n) |
| 平衡BST | O(log n) | O(log n) | O(log n) | O(log n) |

---

## 变体1：AVL树（严格平衡）

### 定义

**AVL树：** 任意节点的左右子树高度差 ≤ 1

```
平衡因子（Balance Factor）= 左子树高度 - 右子树高度
AVL树要求：-1 ≤ BF ≤ 1
```

### 核心操作：旋转

**4种旋转情况：**

#### 1. LL情况（左子树的左子树太高）

**解决：右旋**

```
      y                x
     / \              / \
    x   T3    →      T1  y
   / \                  / \
  T1 T2                T2 T3

代码：
def rotate_right(y):
    x = y.left
    T2 = x.right
    x.right = y
    y.left = T2
    # 更新高度
    y.height = max(height(y.left), height(y.right)) + 1
    x.height = max(height(x.left), height(x.right)) + 1
    return x
```

#### 2. RR情况（右子树的右子树太高）

**解决：左旋**

```
    x                y
   / \              / \
  T1  y     →      x  T3
     / \          / \
    T2 T3        T1 T2

代码：
def rotate_left(x):
    y = x.right
    T2 = y.left
    y.left = x
    x.right = T2
    # 更新高度
    x.height = max(height(x.left), height(x.right)) + 1
    y.height = max(height(y.left), height(y.right)) + 1
    return y
```

#### 3. LR情况（左子树的右子树太高）

**解决：先左旋再右旋**

```
      y              y              z
     / \            / \            / \
    x   T4   →     z   T4   →     x   y
   / \            / \            / \ / \
  T1  z          x  T3          T1 T2 T3 T4
     / \        / \
    T2 T3      T1 T2
```

#### 4. RL情况（右子树的左子树太高）

**解决：先右旋再左旋**

```
    x              x              z
   / \            / \            / \
  T1  y    →     T1  z    →     x   y
     / \            / \        / \ / \
    z  T4          T2  y      T1 T2 T3 T4
   / \                / \
  T2 T3              T3 T4
```

### 完整AVL树实现

```python
class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1


class AVLTree:
    def height(self, node):
        """获取节点高度"""
        return node.height if node else 0

    def balance_factor(self, node):
        """计算平衡因子"""
        if not node:
            return 0
        return self.height(node.left) - self.height(node.right)

    def rotate_right(self, y):
        """右旋"""
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = max(self.height(y.left), self.height(y.right)) + 1
        x.height = max(self.height(x.left), self.height(x.right)) + 1
        return x

    def rotate_left(self, x):
        """左旋"""
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = max(self.height(x.left), self.height(x.right)) + 1
        y.height = max(self.height(y.left), self.height(y.right)) + 1
        return y

    def insert(self, root, val):
        """插入并平衡"""
        # 1. 标准BST插入
        if not root:
            return AVLNode(val)

        if val < root.val:
            root.left = self.insert(root.left, val)
        elif val > root.val:
            root.right = self.insert(root.right, val)
        else:
            return root  # 不允许重复值

        # 2. 更新高度
        root.height = max(self.height(root.left), self.height(root.right)) + 1

        # 3. 计算平衡因子
        bf = self.balance_factor(root)

        # 4. 根据平衡因子进行旋转
        # LL情况
        if bf > 1 and val < root.left.val:
            return self.rotate_right(root)

        # RR情况
        if bf < -1 and val > root.right.val:
            return self.rotate_left(root)

        # LR情况
        if bf > 1 and val > root.left.val:
            root.left = self.rotate_left(root.left)
            return self.rotate_right(root)

        # RL情况
        if bf < -1 and val < root.right.val:
            root.right = self.rotate_right(root.right)
            return self.rotate_left(root)

        return root
```

### AVL树的特点

| 特性 | 描述 |
|------|------|
| 平衡保证 | 严格平衡，高度差 ≤ 1 |
| 查找性能 | O(log n)，最优 |
| 插入性能 | O(log n)，但旋转频繁 |
| 删除性能 | O(log n)，但旋转频繁 |
| 实现复杂度 | 高，需要维护高度和平衡因子 |
| 适用场景 | 查找密集型应用 |

---

## 变体2：红黑树（近似平衡）

### 定义

**红黑树：** 通过节点颜色（红/黑）维护近似平衡的BST

**5条性质：**
1. 每个节点是红色或黑色
2. 根节点是黑色
3. 叶子节点（NIL）是黑色
4. 红色节点的子节点必须是黑色（不能有连续的红节点）
5. 从任意节点到其叶子节点的所有路径包含相同数量的黑色节点

### 核心思想

**黑高平衡：** 通过性质5保证树的近似平衡

```
最短路径：全黑节点
最长路径：红黑交替
最长路径 ≤ 2 × 最短路径
→ 高度 ≤ 2 log(n+1)
→ 操作仍是O(log n)
```

### 红黑树 vs AVL树

| 特性 | AVL树 | 红黑树 |
|------|-------|--------|
| 平衡程度 | 严格平衡 | 近似平衡 |
| 查找性能 | 更快 | 稍慢 |
| 插入性能 | 较慢（旋转多） | 更快 |
| 删除性能 | 较慢（旋转多） | 更快 |
| 实现复杂度 | 中等 | 高 |
| 工程应用 | 较少 | 广泛（C++ STL、Java TreeMap） |

### 简化实现（插入）

```python
class RBNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None
        self.color = 'RED'  # 新节点默认红色


class RedBlackTree:
    def __init__(self):
        self.NIL = RBNode(None)
        self.NIL.color = 'BLACK'
        self.root = self.NIL

    def insert(self, val):
        """插入节点"""
        new_node = RBNode(val)
        new_node.left = self.NIL
        new_node.right = self.NIL

        # 1. 标准BST插入
        parent = None
        current = self.root
        while current != self.NIL:
            parent = current
            if val < current.val:
                current = current.left
            else:
                current = current.right

        new_node.parent = parent
        if not parent:
            self.root = new_node
        elif val < parent.val:
            parent.left = new_node
        else:
            parent.right = new_node

        # 2. 修复红黑树性质
        self.fix_insert(new_node)

    def fix_insert(self, node):
        """修复插入后的红黑树性质"""
        while node.parent and node.parent.color == 'RED':
            if node.parent == node.parent.parent.left:
                uncle = node.parent.parent.right
                if uncle.color == 'RED':
                    # 情况1：叔叔是红色
                    node.parent.color = 'BLACK'
                    uncle.color = 'BLACK'
                    node.parent.parent.color = 'RED'
                    node = node.parent.parent
                else:
                    if node == node.parent.right:
                        # 情况2：叔叔是黑色，节点是右子节点
                        node = node.parent
                        self.rotate_left(node)
                    # 情况3：叔叔是黑色，节点是左子节点
                    node.parent.color = 'BLACK'
                    node.parent.parent.color = 'RED'
                    self.rotate_right(node.parent.parent)
            else:
                # 对称情况
                pass

        self.root.color = 'BLACK'
```

---

## 变体3：Treap（随机化平衡）

### 定义

**Treap = Tree + Heap**
- 按键值维护BST性质
- 按随机优先级维护堆性质

```python
class TreapNode:
    def __init__(self, val):
        self.val = val
        self.priority = random.random()  # 随机优先级
        self.left = None
        self.right = None
```

### 核心思想

**随机优先级保证期望平衡**

```
插入节点时：
1. 按BST性质找到位置
2. 按堆性质（优先级）旋转到正确位置

期望高度：O(log n)
期望操作时间：O(log n)
```

### 实现

```python
import random


class Treap:
    def __init__(self):
        self.root = None

    def rotate_right(self, y):
        """右旋"""
        x = y.left
        y.left = x.right
        x.right = y
        return x

    def rotate_left(self, x):
        """左旋"""
        y = x.right
        x.right = y.left
        y.left = x
        return y

    def insert(self, root, val):
        """插入节点"""
        if not root:
            return TreapNode(val)

        if val < root.val:
            root.left = self.insert(root.left, val)
            # 如果左子节点优先级更高，右旋
            if root.left.priority > root.priority:
                root = self.rotate_right(root)
        else:
            root.right = self.insert(root.right, val)
            # 如果右子节点优先级更高，左旋
            if root.right.priority > root.priority:
                root = self.rotate_left(root)

        return root
```

### Treap的优势

| 特性 | 描述 |
|------|------|
| 实现简单 | 只需左右旋，无需复杂的平衡逻辑 |
| 期望平衡 | 随机优先级保证期望O(log n) |
| 无最坏情况 | 随机化避免有序输入的退化 |
| 支持分裂合并 | 可以高效地分裂和合并树 |

---

## 变体4：学习增强Treap（ICML 2025）

### 核心突破

**传统Treap的局限：** 假设数据访问均匀分布

**学习增强的创新：** 使用ML预测访问频率，优化优先级

### 实现

```python
from collections import defaultdict
import numpy as np


class AccessPredictor:
    """ML模型预测访问频率"""
    def __init__(self):
        self.access_history = defaultdict(list)

    def record_access(self, key, timestamp):
        """记录访问"""
        self.access_history[key].append(timestamp)

    def predict_frequency(self, key):
        """预测访问频率"""
        if key not in self.access_history:
            return 0.5  # 默认中等频率

        # 简单模型：最近访问次数
        recent_accesses = len([t for t in self.access_history[key]
                               if time.time() - t < 3600])  # 最近1小时
        return min(1.0, recent_accesses / 10)  # 归一化到[0, 1]


class LearnedTreap:
    def __init__(self):
        self.root = None
        self.predictor = AccessPredictor()

    def insert(self, val):
        """插入节点（使用ML预测的优先级）"""
        # ML预测访问频率
        predicted_freq = self.predictor.predict_frequency(val)
        # 高频数据高优先级
        priority = predicted_freq

        node = TreapNode(val)
        node.priority = priority
        self.root = self._insert(self.root, node)

    def search(self, val):
        """查找并记录访问"""
        import time
        self.predictor.record_access(val, time.time())
        return self._search(self.root, val)
```

### 效果

**性能提升：**
- 热点数据自动靠近根节点
- 访问时间从O(log n)优化到O(1)
- 适应任意访问分布

**引用：** [Learning-Augmented BST (ICML 2025)](https://arxiv.org/abs/2211.09251)

---

## 变体5：Splay树（自适应）

### 定义

**Splay树：** 每次访问后将节点旋转到根，自适应优化

### 核心操作：Splay

```python
def splay(root, key):
    """将key旋转到根"""
    if not root or root.val == key:
        return root

    # key在左子树
    if key < root.val:
        if not root.left:
            return root

        # Zig-Zig（左-左）
        if key < root.left.val:
            root.left.left = splay(root.left.left, key)
            root = rotate_right(root)

        # Zig-Zag（左-右）
        elif key > root.left.val:
            root.left.right = splay(root.left.right, key)
            if root.left.right:
                root.left = rotate_left(root.left)

        return rotate_right(root) if root.left else root

    # key在右子树（对称）
    else:
        # ...
        pass
```

### Splay树的特点

| 特性 | 描述 |
|------|------|
| 自适应 | 频繁访问的节点自动靠近根 |
| 均摊O(log n) | 单次可能O(n)，但均摊O(log n) |
| 无需额外信息 | 不需要高度、颜色等额外字段 |
| 缓存友好 | 热点数据在根附近 |

---

## 平衡树对比总结

| 特性 | AVL树 | 红黑树 | Treap | 学习增强Treap | Splay树 |
|------|-------|--------|-------|--------------|---------|
| 平衡保证 | 严格 | 近似 | 期望 | 期望+学习 | 均摊 |
| 查找 | O(log n) | O(log n) | O(log n) | O(1)热点 | O(log n)均摊 |
| 插入 | O(log n) | O(log n) | O(log n) | O(log n) | O(log n)均摊 |
| 删除 | O(log n) | O(log n) | O(log n) | O(log n) | O(log n)均摊 |
| 实现复杂度 | 中 | 高 | 低 | 中 | 中 |
| 工程应用 | 少 | 广泛 | 中等 | 新兴 | 中等 |
| 适用场景 | 查找密集 | 通用 | 简单场景 | AI系统 | 局部性强 |

---

## 在AI Agent中的应用

### 应用1：对话历史索引（AVL树）

```python
class ConversationIndex:
    """对话历史的时间索引"""
    def __init__(self):
        self.avl = AVLTree()

    def add_message(self, timestamp, message):
        """添加消息（保证O(log n)）"""
        self.avl.insert(timestamp, message)

    def get_recent(self, hours=24):
        """获取最近N小时的消息"""
        now = time.time()
        start = now - hours * 3600
        return self.avl.range_query(start, now)
```

### 应用2：任务优先级队列（红黑树）

```python
class TaskScheduler:
    """任务调度器（使用红黑树）"""
    def __init__(self):
        self.rbtree = RedBlackTree()

    def add_task(self, priority, task):
        """添加任务"""
        self.rbtree.insert(priority, task)

    def get_next_task(self):
        """获取最高优先级任务"""
        return self.rbtree.delete_max()
```

### 应用3：学习增强检索（学习增强Treap）

```python
class SmartRetrieval:
    """智能检索系统"""
    def __init__(self):
        self.learned_treap = LearnedTreap()

    def add_document(self, doc_id, content):
        """添加文档"""
        self.learned_treap.insert(doc_id, content)

    def search(self, doc_id):
        """查找文档（记录访问）"""
        return self.learned_treap.search(doc_id)
        # 热点文档自动优化访问速度
```

---

## 学习检查清单

- [ ] 理解为什么需要平衡树
- [ ] 能手写AVL树的4种旋转
- [ ] 理解红黑树的5条性质
- [ ] 知道Treap的随机化原理
- [ ] 了解学习增强BST的最新进展
- [ ] 能根据场景选择合适的平衡树变体
- [ ] 知道各种平衡树在AI Agent中的应用

---

**记住：** 平衡树通过不同策略维护树高度，保证O(log n)性能。选择哪种变体取决于具体场景：查找密集用AVL，通用场景用红黑树，简单场景用Treap，AI系统用学习增强。
