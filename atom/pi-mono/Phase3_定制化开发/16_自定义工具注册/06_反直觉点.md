# 反直觉点

> **打破常见误区，建立正确认知**

自定义工具注册看似简单，但有很多反直觉的设计和行为。理解这些反直觉点，可以避免踩坑，写出更健壮的工具。

---

## 反直觉点 1：工具注册后不是立即可用

### 常见误区

很多开发者认为：

```typescript
export const myExtension: Extension = {
  async activate(context) {
    context.registerTool(myTool);
    console.log('Tool registered, ready to use!');
  }
};
```

**误以为**：注册完成后，LLM 立即就能调用这个工具。

### 真实情况

**工具注册后需要经过以下步骤才能被 LLM 使用：**

1. **Extension 加载完成**
   - 所有 Extension 的 `activate` 函数都执行完毕
   - 工具列表被收集和整理

2. **工具描述生成**
   - 将 Tool Definition 转换为 LLM 可理解的格式
   - 生成 JSON Schema 描述

3. **发送给 LLM**
   - 在下一次 LLM 调用时，将工具列表作为 `tools` 参数发送
   - LLM 才能"看到"这些工具

4. **用户可能需要 /reload**
   - 如果 Extension 是在会话中途添加的
   - 需要执行 `/reload` 重新加载 Extension

### 实际案例

```typescript
// ❌ 错误理解
export const myExtension: Extension = {
  async activate(context) {
    context.registerTool(myTool);

    // 这里立即调用工具会失败！
    // LLM 还没有收到工具列表
  }
};

// ✅ 正确理解
export const myExtension: Extension = {
  async activate(context) {
    // 1. 注册工具
    context.registerTool(myTool);

    // 2. 记录日志
    context.logger.info('Tool registered');

    // 3. 工具会在下一次 LLM 调用时可用
    // 4. 如果是新添加的 Extension，用户需要 /reload
  }
};
```

### 为什么这样设计？

**性能优化**：
- 避免每次注册工具都重新生成工具列表
- 批量处理所有工具，一次性发送给 LLM

**一致性保证**：
- 确保所有 Extension 都加载完成
- 避免工具列表不完整

### 如何验证工具已注册？

```typescript
export const myExtension: Extension = {
  async activate(context) {
    context.registerTool(myTool);

    // 方法 1: 查看日志
    context.logger.info('Tool registered:', myTool.name);

    // 方法 2: 在 CLI 中查看工具列表
    // 用户执行: /tools
  }
};
```

### 实战建议

1. **开发新 Extension 时**：
   - 注册工具后，执行 `/reload`
   - 执行 `/tools` 查看工具列表
   - 测试工具调用

2. **调试工具不生效时**：
   - 检查 Extension 是否加载（查看日志）
   - 检查工具名称是否唯一
   - 检查是否执行了 `/reload`

3. **生产环境**：
   - 在 Extension 加载时注册所有工具
   - 不要在运行时动态注册工具（性能问题）

---

## 反直觉点 2：Schema 不只是文档，它提供运行时验证

### 常见误区

很多开发者认为：

```typescript
parameters: Type.Object({
  name: Type.String({ description: 'User name' })
})
```

**误以为**：Schema 只是给 LLM 看的文档，不影响实际执行。

### 真实情况

**TypeBox Schema 提供三重作用：**

1. **LLM 理解**（静态）
   - 生成 JSON Schema 描述
   - LLM 根据 Schema 决定如何调用工具
   - description 字段帮助 LLM 理解参数含义

2. **运行时验证**（动态）
   - 在工具执行前，自动验证参数类型
   - 如果验证失败，工具不会被调用
   - 返回友好的错误信息给 LLM

3. **TypeScript 类型推导**（编译时）
   - 提供类型安全
   - IDE 自动补全
   - 编译时类型检查

### 实际案例

```typescript
// 定义 Schema
const params = Type.Object({
  age: Type.Number({ minimum: 0, maximum: 120 })
});

// 执行函数
const execute = async ({ age }: { age: number }) => {
  // ✅ 这里的 age 已经被验证过了
  // - 一定是 number 类型
  // - 一定在 0-120 范围内
  // - 不需要再次验证！

  return { content: `Age: ${age}` };
};
```

### 验证失败的情况

```typescript
// Schema 定义
parameters: Type.Object({
  count: Type.Number({ minimum: 1, maximum: 100 })
})

// LLM 调用工具时传入 count: 200
// 结果：
// 1. TypeBox 验证失败
// 2. 工具不会被调用
// 3. LLM 收到错误信息：
//    "Parameter 'count' must be between 1 and 100"
// 4. LLM 可能会重新调用，传入正确的参数
```

### 为什么这样设计？

**安全性**：
- 防止无效参数导致程序崩溃
- 防止恶意输入（如 SQL 注入）

**可靠性**：
- 确保工具执行时参数一定是有效的
- 减少 execute 函数中的验证代码

**用户体验**：
- LLM 收到清晰的错误信息
- 可以自动重试，传入正确的参数

### 实战建议

1. **充分利用 Schema 约束**：
   ```typescript
   // ✅ 好的做法
   Type.Object({
     email: Type.String({ format: 'email' }),
     age: Type.Number({ minimum: 0, maximum: 120 }),
     role: Type.Union([
       Type.Literal('admin'),
       Type.Literal('user')
     ])
   })

   // ❌ 不好的做法（缺少约束）
   Type.Object({
     email: Type.String(),  // 没有格式验证
     age: Type.Number(),    // 没有范围限制
     role: Type.String()    // 没有枚举限制
   })
   ```

2. **不要在 execute 中重复验证**：
   ```typescript
   // ❌ 不必要的验证
   const execute = async ({ age }) => {
     if (typeof age !== 'number') {
       return { content: 'Invalid age' };
     }
     if (age < 0 || age > 120) {
       return { content: 'Age out of range' };
     }
     // ...
   };

   // ✅ 信任 Schema 验证
   const execute = async ({ age }) => {
     // age 一定是有效的，直接使用
     return { content: `Age: ${age}` };
   };
   ```

3. **业务逻辑验证仍然需要**：
   ```typescript
   // Schema 验证：类型和格式
   parameters: Type.Object({
     userId: Type.String()
   })

   // 业务逻辑验证：用户是否存在
   const execute = async ({ userId }, context) => {
     const user = await db.findUser(userId);
     if (!user) {
       return { content: 'User not found' };
     }
     // ...
   };
   ```

### 常见陷阱

**陷阱 1：过度依赖 Schema**

```typescript
// ❌ Schema 无法验证业务逻辑
parameters: Type.Object({
  startDate: Type.String({ format: 'date' }),
  endDate: Type.String({ format: 'date' })
})

// ✅ 需要在 execute 中验证
const execute = async ({ startDate, endDate }) => {
  if (new Date(startDate) > new Date(endDate)) {
    return { content: 'Start date must be before end date' };
  }
  // ...
};
```

**陷阱 2：忽略 description**

```typescript
// ❌ 缺少 description，LLM 不知道如何使用
Type.Object({
  q: Type.String()
})

// ✅ 清晰的 description
Type.Object({
  q: Type.String({ description: 'Search query' })
})
```

---

## 反直觉点 3：execute 函数必须是 async，即使不需要异步操作

### 常见误区

很多开发者认为：

```typescript
// 简单的同步操作，不需要 async
const execute = ({ name }) => {
  return { content: `Hello, ${name}!` };
};
```

**误以为**：如果工具逻辑是同步的，就不需要声明为 async。

### 真实情况

**execute 函数必须是 async 函数，这是框架要求：**

```typescript
// ❌ 错误：同步函数
const execute = ({ name }) => {
  return { content: `Hello, ${name}!` };
};

// ✅ 正确：async 函数
const execute = async ({ name }) => {
  return { content: `Hello, ${name}!` };
};
```

### 为什么必须是 async？

**1. 统一接口**

所有工具都使用相同的接口，简化框架实现：

```typescript
// 框架内部实现
async function callTool(tool, params, context) {
  // 统一使用 await 调用
  const result = await tool.execute(params, context);
  return result;
}
```

如果允许同步函数，框架需要判断函数类型：

```typescript
// ❌ 复杂的实现
async function callTool(tool, params, context) {
  // 需要判断是否是 async 函数
  if (isAsyncFunction(tool.execute)) {
    return await tool.execute(params, context);
  } else {
    return tool.execute(params, context);
  }
}
```

**2. 支持 AbortSignal**

AbortSignal 是异步操作的标准取消机制：

```typescript
const execute = async (params, context) => {
  const { signal } = context;

  // 检查是否已取消
  if (signal.aborted) {
    return { content: 'Cancelled' };
  }

  // 传递 signal 给异步操作
  const data = await fetch(url, { signal });

  return { content: data };
};
```

如果是同步函数，无法支持取消操作。

**3. 支持 onUpdate 回调**

onUpdate 用于流式更新，必须在异步上下文中：

```typescript
const execute = async (params, context) => {
  const { onUpdate } = context;

  for (let i = 0; i <= 100; i += 10) {
    await sleep(1000);
    onUpdate?.({ content: `Progress: ${i}%` });
  }

  return { content: 'Complete!' };
};
```

**4. 未来扩展性**

即使当前逻辑是同步的，未来可能需要：
- 调用外部 API
- 读取文件
- 查询数据库
- 等待用户输入

使用 async 函数，无需修改接口。

### 实际案例

```typescript
// 场景 1：简单的字符串处理（同步逻辑）
const execute = async ({ text }) => {
  // 即使是同步操作，也要声明为 async
  const upper = text.toUpperCase();
  return { content: upper };
};

// 场景 2：文件读取（异步逻辑）
const execute = async ({ filePath }) => {
  const content = await fs.readFile(filePath, 'utf-8');
  return { content };
};

// 场景 3：混合逻辑（同步 + 异步）
const execute = async ({ url }, context) => {
  // 同步：参数处理
  const normalizedUrl = url.trim().toLowerCase();

  // 异步：网络请求
  const response = await fetch(normalizedUrl);
  const data = await response.text();

  // 同步：结果处理
  const summary = data.substring(0, 100);

  return { content: summary };
};
```

### 性能影响

**Q: async 函数会影响性能吗？**

**A: 几乎没有影响**

```typescript
// 同步函数
function syncFunc() {
  return 'result';
}

// async 函数（同步逻辑）
async function asyncFunc() {
  return 'result';
}

// 性能差异：
// - syncFunc: 直接返回值
// - asyncFunc: 返回 Promise，但立即 resolve
// - 差异：微秒级别，可以忽略
```

**实际测试**：

```typescript
// 测试 1: 同步函数
console.time('sync');
for (let i = 0; i < 1000000; i++) {
  syncFunc();
}
console.timeEnd('sync');
// 输出: sync: 5ms

// 测试 2: async 函数（同步逻辑）
console.time('async');
for (let i = 0; i < 1000000; i++) {
  await asyncFunc();
}
console.timeEnd('async');
// 输出: async: 8ms

// 结论：100万次调用，差异仅 3ms
```

### 实战建议

1. **始终使用 async**：
   ```typescript
   // ✅ 正确
   const execute = async (params, context) => {
     // ...
   };

   // ❌ 错误
   const execute = (params, context) => {
     // ...
   };
   ```

2. **不需要 await 也要声明 async**：
   ```typescript
   // ✅ 正确（即使没有 await）
   const execute = async ({ name }) => {
     return { content: `Hello, ${name}!` };
   };
   ```

3. **利用 async 的优势**：
   ```typescript
   const execute = async (params, context) => {
     // 可以使用 await
     const data = await fetchData();

     // 可以使用 try-catch
     try {
       // ...
     } catch (error) {
       return { content: `Error: ${error.message}` };
     }

     // 可以使用 AbortSignal
     if (context.signal.aborted) {
       return { content: 'Cancelled' };
     }

     return { content: data };
   };
   ```

### 常见陷阱

**陷阱 1：忘记 await**

```typescript
// ❌ 错误：忘记 await
const execute = async ({ url }) => {
  const response = fetch(url);  // 返回 Promise，不是数据
  return { content: response };  // 错误！
};

// ✅ 正确：使用 await
const execute = async ({ url }) => {
  const response = await fetch(url);
  const data = await response.text();
  return { content: data };
};
```

**陷阱 2：混用 Promise 和 async/await**

```typescript
// ❌ 不推荐：混用
const execute = async ({ url }) => {
  return fetch(url)
    .then(res => res.text())
    .then(data => ({ content: data }));
};

// ✅ 推荐：统一使用 async/await
const execute = async ({ url }) => {
  const res = await fetch(url);
  const data = await res.text();
  return { content: data };
};
```

---

## 总结：三大反直觉点

| 反直觉点 | 常见误区 | 真实情况 | 关键要点 |
|---------|---------|---------|---------|
| **工具注册时机** | 注册后立即可用 | 需要 Extension 加载完成 + LLM 下次调用 | 新 Extension 需要 /reload |
| **Schema 作用** | 只是文档 | 运行时验证 + LLM 理解 + 类型推导 | 充分利用约束，减少 execute 验证 |
| **async 要求** | 同步逻辑不需要 async | 必须是 async 函数 | 统一接口 + 支持取消 + 未来扩展 |

---

## 记忆技巧

1. **工具注册 ≠ 立即可用**
   - 类比：注册公司 ≠ 立即营业（需要审批、公示）

2. **Schema = 三重保护**
   - 类比：表单验证 = 前端验证 + 后端验证 + 数据库约束

3. **async 是必需的**
   - 类比：所有工具都用同一个接口（USB-C），即使有些设备不需要高速传输

---

## 实战检查清单

在注册自定义工具前，确保：

- [ ] 理解工具注册后需要 `/reload` 才能生效（新 Extension）
- [ ] 充分利用 TypeBox Schema 约束（format, minimum, maximum 等）
- [ ] 不在 execute 中重复验证 Schema 已验证的内容
- [ ] 所有 execute 函数都声明为 async
- [ ] 使用 try-catch 处理异步操作的错误
- [ ] 利用 AbortSignal 支持取消操作
- [ ] 使用 onUpdate 提供进度反馈（长时间操作）

理解这些反直觉点，你就能避免常见陷阱，写出更健壮的自定义工具！
