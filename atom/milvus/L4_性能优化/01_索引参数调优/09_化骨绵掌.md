# 化骨绵掌 - 10个2分钟知识卡片

## 卡片1：索引参数调优的本质

**一句话：** 索引参数调优就是控制"搜索多少"和"搜索多深"，在速度和召回率之间找平衡点。

**举例：**
```python
# 搜索少 = 快但可能漏
search_params = {"params": {"nprobe": 8}}  # 只搜索8个聚类

# 搜索多 = 慢但更准
search_params = {"params": {"nprobe": 64}}  # 搜索64个聚类
```

**应用：** 实时对话用小参数（nprobe=8-16），离线分析用大参数（nprobe=64-128）

---

## 卡片2：nlist 的经验公式

**一句话：** nlist = 2 * sqrt(N)，N 是向量总数，这是最常用的配置。

**举例：**
```python
import math

# 100万向量
nlist = int(2 * math.sqrt(1_000_000))  # 2000

# 1000万向量
nlist = int(2 * math.sqrt(10_000_000))  # 6324
```

**应用：** 创建 IVF 索引时，用这个公式计算 nlist，适用于 90% 的场景

---

## 卡片3：nprobe 的选择策略

**一句话：** nprobe = nlist * (1%-10%)，根据速度要求调整百分比。

**举例：**
```python
nlist = 2000

# 快速模式：1%
nprobe = max(8, nlist // 100)  # 20

# 平衡模式：5%
nprobe = max(16, nlist // 20)  # 100

# 精确模式：10%
nprobe = max(32, nlist // 10)  # 200
```

**应用：** 根据业务场景选择：实时对话用 1-2%，标准查询用 5%，深度查询用 10%

---

## 卡片4：HNSW 的 M 参数

**一句话：** M 是每个节点的连接数，M=16 是最常用的平衡配置。

**举例：**
```python
# M 越大，内存越大，召回率越高
index_params = {
    "index_type": "HNSW",
    "params": {
        "M": 8,   # 内存小，召回率低
        "M": 16,  # 平衡（推荐）
        "M": 32   # 内存大，召回率高
    }
}

# 内存占用估算
memory_mb = num_vectors * M * 4 / 1024 / 1024
```

**应用：** 内存充足用 M=16，内存受限用 M=8，需要高召回率用 M=32

---

## 卡片5：HNSW 的 ef 参数

**一句话：** ef 是搜索时的候选池大小，ef=128 是最常用的配置。

**举例：**
```python
# ef 越大，搜索越慢，召回率越高
search_params = {
    "params": {
        "ef": 64,   # 快速搜索
        "ef": 128,  # 平衡（推荐）
        "ef": 256   # 高召回率搜索
    }
}

# 延迟估算（线性关系）
latency_ms = (ef / 64) * base_latency
```

**应用：** 实时场景用 ef=64，标准场景用 ef=128，高召回率场景用 ef=256

---

## 卡片6：量化索引的选择

**一句话：** IVF_SQ8 内存减少 75%，召回率损失 < 2%，是性价比最高的选择。

**举例：**
```python
# 内存对比（100万向量，768维）
IVF_FLAT: 2.93GB, 召回率 98.5%
IVF_SQ8:  0.73GB, 召回率 96.8%  # 推荐
IVF_PQ:   0.06GB, 召回率 92.3%

# 选择逻辑
if memory_budget >= memory_flat:
    use "IVF_FLAT"
elif memory_budget >= memory_sq8:
    use "IVF_SQ8"  # 大多数场景
else:
    use "IVF_PQ"
```

**应用：** 优先考虑 IVF_SQ8，除非内存充足（用 IVF_FLAT）或极度受限（用 IVF_PQ）

---

## 卡片7：参数调优的三个误区

**一句话：** 参数不是越大越好，不是一次性配置，量化损失在可接受范围内。

**举例：**
```python
# 误区1：参数越大越好 ❌
nprobe = 128  # 可能过大，边际收益递减

# 正确：找最优点 ✅
nprobe = 32   # 满足延迟和召回率要求即可

# 误区2：一次性配置 ❌
# 数据从100万增长到1000万，不调整参数

# 正确：动态调整 ✅
nlist = int(2 * math.sqrt(current_num_vectors))

# 误区3：量化损失大 ❌
# 认为 IVF_SQ8 不能用于生产

# 正确：损失可接受 ✅
# IVF_SQ8 召回率 96.8%，仅比 IVF_FLAT 低 1.7%
```

**应用：** 避免这三个误区，理性选择参数

---

## 卡片8：IVF vs HNSW 的选择

**一句话：** IVF 适合大规模数据和内存受限，HNSW 适合高召回率和中等规模。

**举例：**
```python
# 选择决策树
if num_vectors > 1_000_000:
    # 大规模数据
    if memory_limited:
        use "IVF_SQ8" or "IVF_PQ"
    else:
        use "IVF_FLAT"
else:
    # 中等规模数据
    if need_high_recall (>95%):
        use "HNSW"
    else:
        use "IVF_FLAT"
```

**对比：**
| 维度 | IVF | HNSW |
|------|-----|------|
| 召回率 | 85-95% | 95-98% |
| 内存 | 小（可量化） | 大 |
| 速度 | 快 | 稳定 |
| 适用 | 大规模 | 高召回率 |

**应用：** 根据数据规模、内存预算和召回率要求选择

---

## 卡片9：性能监控的关键指标

**一句话：** 监控 P95 延迟、QPS 和内存占用，设置告警阈值。

**举例：**
```python
# 关键指标
metrics = {
    "p50_latency_ms": 45.2,   # 中位数延迟
    "p95_latency_ms": 62.1,   # 95分位延迟（重要）
    "p99_latency_ms": 85.3,   # 99分位延迟
    "qps": 22.1,              # 每秒查询数
    "memory_mb": 732.6        # 内存占用
}

# 告警阈值
alerts = {
    "p95_latency_ms": 200,    # P95 延迟超过 200ms
    "qps_drop_percent": 20,   # QPS 下降超过 20%
    "memory_increase": 50     # 内存增长超过 50%
}
```

**应用：** 建立监控体系，及时发现性能退化

---

## 卡片10：RAG 系统的参数配置

**一句话：** 不同 RAG 场景使用不同参数：实时对话用小参数，离线分析用大参数。

**举例：**
```python
# 实时对话（智能客服）
realtime_config = {
    "index_type": "IVF_SQ8",
    "nlist": 1000,
    "nprobe": 16,           # 快速响应
    "target_latency": "< 100ms"
}

# 标准查询（企业知识库）
standard_config = {
    "index_type": "HNSW",
    "M": 16,
    "ef": 128,              # 平衡配置
    "target_latency": "< 200ms"
}

# 深度查询（法律文档检索）
thorough_config = {
    "index_type": "HNSW",
    "M": 32,
    "ef": 256,              # 高召回率
    "target_latency": "< 500ms"
}
```

**应用：** 根据 RAG 场景的延迟要求和召回率要求选择配置

---

## 知识卡片总结

### 核心公式速查

```
1. nlist = 2 * sqrt(N)
2. nprobe = nlist * (1%-10%)
3. M = 8~32 (推荐 16)
4. ef = 64~256 (推荐 128)
5. 内存占用 = num_vectors * dim * bytes_per_value
   - IVF_FLAT: 4 bytes (float32)
   - IVF_SQ8:  1 byte  (int8)
   - IVF_PQ:   m bytes (m 个子向量)
```

### 决策树

```
需要调优？
  ↓
数据规模？
  ↓ < 100万
  HNSW (M=16, ef=128)
  ↓ > 100万
  内存充足？
    ↓ 是
    IVF_FLAT (nlist=2*sqrt(N), nprobe=nlist*5%)
    ↓ 否
    IVF_SQ8 (nlist=2*sqrt(N), nprobe=nlist*5%)
```

### 场景配置速查

| 场景 | 索引类型 | 参数配置 | 目标 |
|------|---------|---------|------|
| **实时对话** | IVF_SQ8 | nprobe=8-16 | 延迟 < 50ms |
| **标准查询** | HNSW | ef=128 | 延迟 < 100ms |
| **深度查询** | HNSW | ef=256 | 召回率 > 95% |
| **大规模推荐** | IVF_PQ | m=16, nprobe=8 | QPS > 1000 |

### 优化检查清单

```
□ 根据数据规模计算 nlist
□ 根据场景选择 nprobe/ef
□ 测试不同参数的性能
□ 建立性能监控
□ 设置告警阈值
□ 定期检查和调整
□ 考虑使用量化索引
□ 进行 A/B 测试验证
```

---

## 记忆口诀

```
索引调优记心间，
nlist 开方乘以二，
nprobe 百分一到十，
HNSW 十六最常见，
量化压缩 SQ8 先，
场景不同配置异，
监控告警不能少，
持续优化是关键。
```

---

## 快速上手三步法

### 第一步：选择索引类型

```python
# 根据数据规模和内存预算
if num_vectors < 1_000_000 and memory_ok:
    index_type = "HNSW"
elif memory_limited:
    index_type = "IVF_SQ8"
else:
    index_type = "IVF_FLAT"
```

### 第二步：计算初始参数

```python
import math

if index_type.startswith("IVF"):
    nlist = int(2 * math.sqrt(num_vectors))
    nprobe = max(16, nlist // 20)  # 5%
    params = {"nlist": nlist, "nprobe": nprobe}
else:  # HNSW
    params = {"M": 16, "efConstruction": 200, "ef": 128}
```

### 第三步：测试和调整

```python
# 测试性能
latency = test_search_performance(params)

# 根据结果调整
if latency > target_latency:
    # 减小搜索参数
    params["nprobe"] = params["nprobe"] // 2
elif recall < target_recall:
    # 增大搜索参数
    params["nprobe"] = params["nprobe"] * 2
```

---

**记住：索引参数调优不是一次性工作，而是持续优化的过程。从简单配置开始，根据实际性能逐步调整，最终找到最适合你的业务场景的配置。**
