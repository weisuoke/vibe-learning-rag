# 反直觉点

## 为什么需要了解反直觉点？

在学习新技术时,我们常常会基于已有经验做出假设。但这些假设有时是错误的,会导致困惑和错误。了解反直觉点可以帮助你:

1. **避免常见错误** - 提前知道哪些假设是错误的
2. **加深理解** - 理解为什么设计是这样的
3. **提高效率** - 不在错误的方向上浪费时间

---

## 反直觉点 1: 不是 `{{variable}}` 语法

### 直觉假设

**大多数开发者会认为:**

```markdown
---
description: Greet user
---
Hello, {{name}}!
```

这是因为:
- Handlebars/Mustache 使用 `{{variable}}`
- Jinja2 使用 `{{variable}}`
- Vue.js 使用 `{{variable}}`
- Angular 使用 `{{variable}}`

**这是最常见的模板语法!**

---

### 实际情况

**Pi-mono 使用 Bash 风格:**

```markdown
---
description: Greet user
---
Hello, $1!
```

**调用:**
```bash
/greet World
```

**输出:**
```
Hello, World!
```

---

### 为什么这样设计？

1. **命令行友好** - Pi 是 CLI 工具,Bash 风格更自然
2. **开发者熟悉** - 所有开发者都会 Shell 脚本
3. **位置参数** - 支持 `$1`, `$2`, `$@` 等灵活语法
4. **零学习成本** - 无需学习新语法

---

### 常见错误

```markdown
# ❌ 错误: 使用 Handlebars 语法
Hello, {{name}}!

# ❌ 错误: 使用 Jinja2 语法
Hello, {{ name }}!

# ❌ 错误: 使用 Python f-string 语法
Hello, {name}!

# ✅ 正确: 使用 Bash 风格
Hello, $1!
```

---

### 2025-2026 年的验证

根据 [Reddit: Markdown模板变量注入技术](https://www.reddit.com/r/Markdown/comments/1h8rklr/injecting_variables_into_md_template/) 的讨论,社区发现:

- **Bash 风格在 CLI 工具中更受欢迎**
- **位置参数比命名参数更灵活**
- **开发者更容易接受熟悉的语法**

---

## 反直觉点 2: 模板不需要注册

### 直觉假设

**大多数开发者会认为:**

```typescript
// 需要先注册模板
registerTemplate('greet', {
  path: '~/.pi/agent/prompts/greet.md',
  description: 'Greet user'
});

// 然后才能使用
useTemplate('greet', ['World']);
```

这是因为:
- Express 需要注册路由
- React 需要注册组件
- Webpack 需要注册 loader
- 大多数框架都需要注册机制

---

### 实际情况

**Pi-mono 不需要注册:**

```bash
# 1. 创建文件
cat > ~/.pi/agent/prompts/greet.md << 'EOF'
---
description: Greet user
---
Hello, $1!
EOF

# 2. 直接使用 (无需注册!)
pi
/greet World
```

**就这么简单!** 放文件就能用。

---

### 为什么这样设计？

1. **零配置** - 不需要配置文件
2. **约定优于配置** - 文件名即模板名
3. **文件系统即数据库** - 不需要额外的注册机制
4. **极简主义** - 减少不必要的复杂性

---

### 常见错误

```typescript
// ❌ 错误: 尝试注册模板
pi.registerTemplate('greet', { ... });

// ❌ 错误: 尝试导入模板
import greet from '~/.pi/agent/prompts/greet.md';

// ❌ 错误: 尝试配置模板
// .pi/config.json
{
  "templates": {
    "greet": "~/.pi/agent/prompts/greet.md"
  }
}

// ✅ 正确: 直接创建文件
cat > ~/.pi/agent/prompts/greet.md << 'EOF'
---
description: Greet user
---
Hello, $1!
EOF
```

---

## 反直觉点 3: 项目模板优先级高于全局模板

### 直觉假设

**大多数开发者会认为:**

```
全局配置 > 项目配置

理由:
- npm 的全局包优先级高
- Git 的全局配置优先级高
- 环境变量的全局设置优先级高
```

---

### 实际情况

**Pi-mono 的优先级:**

```
项目模板 > 全局模板

加载顺序:
1. ./.pi/prompts/template.md (项目级别) ← 优先
2. ~/.pi/agent/prompts/template.md (全局级别)
```

**示例:**

```bash
# 全局模板
cat > ~/.pi/agent/prompts/test.md << 'EOF'
---
description: Global test template
---
This is the global template.
EOF

# 项目模板 (同名)
cat > ./.pi/prompts/test.md << 'EOF'
---
description: Project test template
---
This is the project template.
EOF

# 使用模板
pi
/test

# 输出: "This is the project template." (项目模板优先!)
```

---

### 为什么这样设计？

1. **项目特定性** - 项目模板更具体,应该优先
2. **覆盖机制** - 允许项目覆盖全局默认值
3. **团队协作** - 项目模板可以统一团队标准
4. **符合直觉** - 更具体的配置应该优先

---

### 常见错误

```bash
# ❌ 错误假设: 全局模板优先
# 创建了项目模板,但期望使用全局模板
# 结果: 项目模板被使用

# ✅ 正确做法: 删除项目模板或重命名
rm ./.pi/prompts/test.md
# 或
mv ./.pi/prompts/test.md ./.pi/prompts/test-project.md
```

---

### 2025-2026 年的最佳实践

根据 [Reddit: 生产环境演化提示模板管理](https://www.reddit.com/r/PromptEngineering/comments/1nwynw5/how_do_you_manage_dozens_of_evolving_prompts_in/) 的讨论:

- **项目模板用于项目特定的提示词**
- **全局模板用于通用的提示词**
- **使用不同的命名避免冲突**

---

## 反直觉点 4: 模板不支持子目录

### 直觉假设

**大多数开发者会认为:**

```
~/.pi/agent/prompts/
├── code/
│   ├── review.md
│   └── refactor.md
├── docs/
│   ├── api.md
│   └── readme.md
└── team/
    ├── pr.md
    └── bug.md

调用:
/code/review
/docs/api
/team/pr
```

这是因为:
- 文件系统支持子目录
- 大多数工具支持嵌套结构
- 这样更有组织性

---

### 实际情况

**Pi-mono 不支持子目录:**

```
~/.pi/agent/prompts/
├── code-review.md
├── code-refactor.md
├── docs-api.md
├── docs-readme.md
├── team-pr.md
└── team-bug.md

调用:
/code-review
/docs-api
/team-pr
```

**所有模板必须在 `prompts/` 根目录下。**

---

### 为什么这样设计？

1. **简单性** - 避免路径解析的复杂性
2. **性能** - 不需要递归扫描目录
3. **明确性** - 所有模板在同一层级,易于管理
4. **极简主义** - 减少不必要的功能

---

### 解决方案: 命名约定

**使用前缀组织模板:**

```
命名约定: <category>-<action>-<target>.md

示例:
code-review-pr.md
code-refactor-legacy.md
docs-generate-api.md
docs-update-readme.md
team-analyze-bug.md
team-design-feature.md
```

**调用:**
```bash
/code-review-pr
/docs-generate-api
/team-analyze-bug
```

---

### 常见错误

```bash
# ❌ 错误: 创建子目录
mkdir -p ~/.pi/agent/prompts/code
cat > ~/.pi/agent/prompts/code/review.md << 'EOF'
...
EOF

# 调用失败!
/code/review  # 找不到模板

# ✅ 正确: 使用扁平结构 + 命名约定
cat > ~/.pi/agent/prompts/code-review.md << 'EOF'
...
EOF

# 调用成功!
/code-review
```

---

## 反直觉点 5: 模板内容会直接发送给 LLM

### 直觉假设

**大多数开发者会认为:**

```markdown
模板只是提供结构,不会直接发送给 LLM。
需要额外的处理步骤:
1. 解析模板
2. 提取关键信息
3. 构建 LLM 请求
4. 发送给 LLM
```

---

### 实际情况

**模板内容会直接发送给 LLM:**

```markdown
---
description: Review PR
---
You are given a GitHub PR URL: $1

Please review the PR and provide:
1. Summary of changes
2. Potential issues
3. Suggestions

# 调用: /pr https://github.com/user/repo/pull/123

# 实际发送给 LLM 的内容:
You are given a GitHub PR URL: https://github.com/user/repo/pull/123

Please review the PR and provide:
1. Summary of changes
2. Potential issues
3. Suggestions
```

**模板内容 = LLM 输入**

---

### 为什么这样设计？

1. **透明性** - 你看到的就是 LLM 看到的
2. **可控性** - 完全控制发送给 LLM 的内容
3. **简单性** - 没有隐藏的处理步骤
4. **调试友好** - 容易理解和调试

---

### 重要影响

**1. 模板质量直接影响 LLM 输出**

```markdown
# ❌ 糟糕的模板
Review this: $1

# ✅ 好的模板
You are an expert code reviewer. Please review the following PR:

**PR URL:** $1

Provide a structured review covering:
1. **Code Quality**: Readability, maintainability, best practices
2. **Potential Issues**: Bugs, edge cases, security concerns
3. **Suggestions**: Specific, actionable improvements

Be thorough but concise.
```

**2. 模板应该包含完整的上下文**

```markdown
# ❌ 缺少上下文
Analyze $1

# ✅ 包含上下文
You are analyzing a TypeScript codebase.

**File to analyze:** $1

Focus on:
- Type safety
- Error handling
- Performance
- Best practices

Provide specific recommendations.
```

---

### 常见错误

```markdown
# ❌ 错误: 假设 Pi 会添加额外的上下文
Review $1

# 期望 Pi 自动添加:
# - "You are a code reviewer"
# - "Focus on code quality"
# - "Provide actionable feedback"

# 实际: Pi 只发送模板内容,不添加任何额外内容

# ✅ 正确: 在模板中包含所有必要的上下文
You are an expert code reviewer.

Review the following code: $1

Focus on:
- Code quality and readability
- Potential bugs or issues
- Best practices

Provide specific, actionable feedback.
```

---

### 2025-2026 年的最佳实践

根据 [Anthropic: Effective context engineering for AI agents](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents) 的指南:

1. **明确角色** - 告诉 LLM 它是什么角色
2. **提供上下文** - 包含所有必要的背景信息
3. **清晰指令** - 明确要求 LLM 做什么
4. **结构化输出** - 指定期望的输出格式

---

## 反直觉点 6: 模板不支持条件逻辑

### 直觉假设

**大多数开发者会认为:**

```markdown
---
description: Greet user
---
{{#if morning}}
Good morning, $1!
{{else}}
Hello, $1!
{{/if}}
```

这是因为:
- Handlebars 支持条件逻辑
- Jinja2 支持条件逻辑
- 大多数模板引擎都支持

---

### 实际情况

**Pi-mono 不支持条件逻辑:**

```markdown
---
description: Greet user
---
Hello, $1!
```

**只支持简单的变量替换,不支持:**
- 条件语句 (`if/else`)
- 循环语句 (`for/while`)
- 函数调用
- 复杂表达式

---

### 为什么这样设计？

1. **简单性** - 避免模板语言的复杂性
2. **可读性** - 模板内容清晰易懂
3. **可维护性** - 不需要学习模板语法
4. **极简主义** - 只提供最核心的功能

---

### 解决方案: 创建多个模板

**不要:**
```markdown
# ❌ 尝试在一个模板中实现条件逻辑
{{#if type === 'bug'}}
Analyze bug: $1
{{else if type === 'feature'}}
Design feature: $1
{{/if}}
```

**而是:**
```bash
# ✅ 创建多个专门的模板

# bug.md
cat > ~/.pi/agent/prompts/bug.md << 'EOF'
---
description: Analyze bug
---
Analyze the following bug: $1
EOF

# feature.md
cat > ~/.pi/agent/prompts/feature.md << 'EOF'
---
description: Design feature
---
Design the following feature: $1
EOF

# 使用
/bug "Login fails"
/feature "Real-time notifications"
```

---

### 常见错误

```markdown
# ❌ 错误: 尝试使用条件逻辑
{{#if $1 === 'urgent'}}
URGENT: $2
{{else}}
Normal: $2
{{/if}}

# ❌ 错误: 尝试使用循环
{{#each files}}
- {{this}}
{{/each}}

# ❌ 错误: 尝试使用函数
{{uppercase $1}}

# ✅ 正确: 使用简单的变量替换
File: $1
Status: $2
```

---

## 反直觉点 7: 模板不会自动重载

### 直觉假设

**大多数开发者会认为:**

```
修改模板文件后,下次调用会自动使用新版本。

理由:
- Node.js 的 require() 会缓存模块
- 但文件修改后会自动重载
- 大多数开发工具都支持热重载
```

---

### 实际情况

**Pi-mono 会缓存模板:**

```bash
# 1. 创建模板
cat > ~/.pi/agent/prompts/test.md << 'EOF'
Version 1
EOF

# 2. 启动 pi 并使用模板
pi
/test
# 输出: "Version 1"

# 3. 修改模板 (在另一个终端)
cat > ~/.pi/agent/prompts/test.md << 'EOF'
Version 2
EOF

# 4. 再次使用模板 (在 pi 中)
/test
# 输出: "Version 1" (仍然是旧版本!)
```

---

### 为什么这样设计？

1. **性能** - 避免每次都读取文件
2. **一致性** - 同一会话中使用相同的模板版本
3. **简单性** - 不需要文件监听机制

---

### 解决方案: 重启 Pi

```bash
# 方法 1: 退出并重启 pi
exit
pi

# 方法 2: 使用 Ctrl+C 退出,然后重启
# (在 pi 中按 Ctrl+C)
pi

# 方法 3: 使用新的 pi 会话
# (在新终端中)
pi
```

---

### 常见错误

```bash
# ❌ 错误: 期望自动重载
# 1. 修改模板
vim ~/.pi/agent/prompts/test.md

# 2. 直接使用 (期望看到新版本)
/test
# 结果: 仍然是旧版本

# ✅ 正确: 重启 pi
exit
pi
/test
# 结果: 新版本
```

---

### 2025-2026 年的开发工作流

根据社区实践,推荐的开发工作流:

```bash
# 开发模式: 使用脚本快速测试
cat > test-template.sh << 'EOF'
#!/bin/bash
# 每次运行都启动新的 pi 会话
pi -c "/test $@"
EOF

chmod +x test-template.sh

# 使用
./test-template.sh arg1 arg2
```

---

## 反直觉点 8: YAML Frontmatter 是可选的

### 直觉假设

**大多数开发者会认为:**

```markdown
YAML frontmatter 是必需的,因为:
- Jekyll 需要 frontmatter
- Hugo 需要 frontmatter
- 大多数静态站点生成器都需要
```

---

### 实际情况

**YAML frontmatter 是可选的:**

```markdown
# 有 frontmatter (推荐)
---
description: Greet user
---
Hello, $1!

# 无 frontmatter (也可以)
Hello, $1!
```

**两者都可以工作!**

---

### 为什么这样设计？

1. **灵活性** - 简单模板不需要元数据
2. **渐进式** - 可以先创建简单模板,后续添加元数据
3. **兼容性** - 支持纯 Markdown 文件

---

### 何时使用 Frontmatter？

**推荐使用 frontmatter:**
- 模板需要描述
- 模板需要版本信息
- 模板需要作者信息
- 模板需要标签分类

**可以省略 frontmatter:**
- 个人使用的简单模板
- 临时测试模板
- 一次性模板

---

### 示例

```markdown
# 简单模板 (无 frontmatter)
cat > ~/.pi/agent/prompts/quick.md << 'EOF'
Quick test: $1
EOF

# 完整模板 (有 frontmatter)
cat > ~/.pi/agent/prompts/full.md << 'EOF'
---
description: Full template with metadata
author: team@example.com
version: 1.0.0
tags: [code-review, pr]
---
Detailed template content: $1
EOF
```

---

## 反直觉点 9: 参数不会自动转义

### 直觉假设

**大多数开发者会认为:**

```bash
/test "Hello <script>alert('XSS')</script>"

# 期望: 参数会被转义
# 输出: Hello &lt;script&gt;alert('XSS')&lt;/script&gt;
```

这是因为:
- Web 框架会自动转义 HTML
- 模板引擎会自动转义特殊字符
- 这是安全的最佳实践

---

### 实际情况

**参数不会自动转义:**

```bash
/test "Hello <script>alert('XSS')</script>"

# 实际输出: Hello <script>alert('XSS')</script>
# (原样输出,不转义)
```

---

### 为什么这样设计？

1. **透明性** - 你输入什么,就输出什么
2. **灵活性** - 允许传递任意内容
3. **简单性** - 不需要转义/反转义机制
4. **LLM 友好** - LLM 可以处理任意文本

---

### 安全考虑

**Pi-mono 的模板不是 Web 模板:**
- 不会在浏览器中渲染
- 不会执行 JavaScript
- 不会有 XSS 风险

**但仍需注意:**
- 不要在模板中执行用户输入的代码
- 不要在模板中构建 Shell 命令
- 不要在模板中构建 SQL 查询

---

### 常见错误

```markdown
# ❌ 错误: 假设参数会被转义
Review this code: $1
# 如果 $1 包含特殊字符,会原样输出

# ❌ 错误: 在模板中执行代码
Execute: eval($1)
# 危险! 不要这样做

# ✅ 正确: 将参数作为数据处理
Analyze the following code:
```
$1
```
```

---

## 反直觉点 10: 模板名称区分大小写

### 直觉假设

**大多数开发者会认为:**

```bash
# 文件名: Test.md
/test  # 应该可以工作
/Test  # 应该可以工作
/TEST  # 应该可以工作
```

这是因为:
- Windows 文件系统不区分大小写
- macOS 文件系统默认不区分大小写
- 大多数 CLI 工具不区分大小写

---

### 实际情况

**模板名称区分大小写:**

```bash
# 文件名: Test.md
/Test  # ✅ 可以工作
/test  # ❌ 找不到模板
/TEST  # ❌ 找不到模板
```

---

### 为什么这样设计？

1. **一致性** - 与 Linux 文件系统保持一致
2. **明确性** - 避免歧义
3. **可移植性** - 在所有平台上行为一致

---

### 最佳实践

**使用小写 + 连字符:**

```bash
# ✅ 推荐: 小写 + 连字符
code-review.md
team-pr.md
docs-api.md

# 调用
/code-review
/team-pr
/docs-api

# ❌ 不推荐: 大小写混合
CodeReview.md
TeamPR.md
DocsAPI.md
```

---

### 常见错误

```bash
# ❌ 错误: 文件名和调用不匹配
# 文件: CodeReview.md
/code-review  # 找不到!

# ✅ 正确: 保持一致
# 文件: code-review.md
/code-review  # 可以工作!
```

---

## 总结: 10 个反直觉点

| # | 反直觉点 | 直觉假设 | 实际情况 |
|---|---------|---------|---------|
| 1 | 变量语法 | `{{variable}}` | `$1`, `$@` |
| 2 | 注册机制 | 需要注册 | 放文件就能用 |
| 3 | 优先级 | 全局 > 项目 | 项目 > 全局 |
| 4 | 目录结构 | 支持子目录 | 只支持扁平结构 |
| 5 | 内容处理 | 模板只是结构 | 直接发送给 LLM |
| 6 | 条件逻辑 | 支持 if/else | 只支持变量替换 |
| 7 | 热重载 | 自动重载 | 需要重启 pi |
| 8 | Frontmatter | 必需 | 可选 |
| 9 | 参数转义 | 自动转义 | 不转义 |
| 10 | 大小写 | 不区分 | 区分大小写 |

---

## 记忆技巧

**记住这些反直觉点的关键:**

1. **Bash 风格** - Pi 是 CLI 工具,使用 Bash 语法
2. **极简主义** - 没有注册、没有条件、没有子目录
3. **文件系统** - 一切基于文件系统,简单直接
4. **透明性** - 你看到的就是 LLM 看到的
5. **项目优先** - 项目配置优先于全局配置

---

## 2025-2026 年的经验教训

根据社区的实践经验:

1. **[Reddit: LLM真实系统提示Markdown结构化](https://www.reddit.com/r/PromptEngineering/comments/1pseks9/for_people_building_real_systems_with_llms_how_do/)**
   - 将模板视为 Markdown 数据
   - 支持变量插值和版本控制
   - 避免过度复杂的模板语法

2. **[GitHub: Awesome AI System Prompts](https://github.com/dontriskit/awesome-ai-system-prompts)**
   - 使用简单的 Markdown 格式
   - 通过 Git 管理版本
   - 避免复杂的模板引擎

3. **[Twitter/X: 2026 AI项目工作流](https://x.com/Motion_Viz/status/2006373779669434790)**
   - 模板应该包含完整的上下文
   - 避免假设 AI 会自动添加信息
   - 明确指定期望的输出格式

---

## 避免这些错误

**最常见的 5 个错误:**

1. **使用 `{{variable}}` 语法** - 应该使用 `$1`
2. **期望自动重载** - 应该重启 pi
3. **创建子目录** - 应该使用扁平结构 + 命名约定
4. **假设会自动添加上下文** - 应该在模板中包含所有必要信息
5. **尝试使用条件逻辑** - 应该创建多个专门的模板

---

**版本:** v1.0
**最后更新:** 2026-02-20
**维护者:** Claude Code
