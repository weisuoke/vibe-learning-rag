# 核心概念 2: 索引创建

## 什么是索引？

**索引（Index）** 是一种数据结构，用于加速向量相似度检索。就像书籍的目录可以快速定位章节，向量索引可以快速找到相似的向量。

### 核心定义

```python
# 索引创建的本质
collection.create_index(
    field_name="embedding",      # 向量字段名
    index_params={
        "index_type": "HNSW",    # 索引类型
        "metric_type": "COSINE", # 相似度度量
        "params": {"M": 16, "efConstruction": 256}  # 索引参数
    }
)
```

**类比理解**:
- **前端类比**: 就像数据库的 B-Tree 索引，加速查询
- **日常类比**: 就像图书馆的索引卡片系统，快速找到相关书籍

---

## 为什么必须创建索引？

### Milvus 的特殊要求

**关键特性**: 在 Milvus 中，**没有索引就无法执行 search() 操作**！

```python
# ❌ 错误：没有索引就 search()
collection.insert(data)
collection.load()
results = collection.search(...)  # 报错！必须先创建索引
```

```python
# ✅ 正确：先创建索引再 search()
collection.insert(data)
collection.create_index(...)  # 必须创建索引
collection.load()
results = collection.search(...)  # 成功
```

### 为什么 Milvus 强制要求索引？

**设计理念**: Milvus 是为**大规模向量检索**设计的，性能优先。

1. **暴力搜索不可行**
   - 100 万个 384 维向量
   - 暴力计算相似度：100 万次计算
   - 耗时：数秒到数十秒

2. **索引加速检索**
   - 使用 HNSW 索引
   - 只需计算数百次
   - 耗时：毫秒级

3. **强制索引 = 性能保证**
   - 避免用户误用暴力搜索
   - 确保生产环境性能

### 性能差异对比

| 数据规模 | 无索引（暴力搜索） | HNSW 索引 | 性能提升 |
|---------|-------------------|-----------|---------|
| 10 万   | 500ms             | 5ms       | 100x    |
| 100 万  | 5s                | 10ms      | 500x    |
| 1000 万 | 50s               | 20ms      | 2500x   |

**结论**: 索引是向量检索的**必需品**，不是可选项！

---

## 索引类型选择

Milvus 支持多种索引类型，每种适合不同场景。

### 1. FLAT 索引

**特点**: 精确搜索，暴力计算所有向量的相似度。

```python
index_params = {
    "index_type": "FLAT",
    "metric_type": "COSINE",
    "params": {}  # 无需额外参数
}
collection.create_index("embedding", index_params)
```

**优点**:
- 100% 召回率（精确搜索）
- 实现简单

**缺点**:
- 速度慢（O(n) 复杂度）
- 不适合大规模数据

**适用场景**:
- 数据量 < 1 万
- 需要 100% 精确结果
- 原型验证

---

### 2. IVF_FLAT 索引

**特点**: 倒排文件索引，将向量空间划分为多个区域（聚类）。

```python
index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "COSINE",
    "params": {
        "nlist": 128  # 聚类数量
    }
}
collection.create_index("embedding", index_params)

# 检索时指定 nprobe（搜索多少个聚类）
search_params = {"metric_type": "COSINE", "params": {"nprobe": 10}}
```

**工作原理**:
1. 训练阶段：将向量聚类成 nlist 个簇
2. 检索阶段：只搜索最近的 nprobe 个簇

**优点**:
- 速度比 FLAT 快 10-100 倍
- 内存占用适中

**缺点**:
- 召回率略低于 FLAT（95-99%）
- 需要调参（nlist, nprobe）

**适用场景**:
- 数据量 1 万 - 100 万
- 平衡精度和速度
- 内存有限

**参数建议**:
- nlist = sqrt(n)，n 为数据量
- nprobe = 10-20（越大越精确，越慢）

---

### 3. HNSW 索引（推荐用于 RAG）

**特点**: 分层可导航小世界图，基于图结构的索引。

```python
index_params = {
    "index_type": "HNSW",
    "metric_type": "COSINE",
    "params": {
        "M": 16,              # 每个节点的最大连接数
        "efConstruction": 256 # 构建索引时的搜索深度
    }
}
collection.create_index("embedding", index_params)

# 检索时指定 ef（搜索深度）
search_params = {"metric_type": "COSINE", "params": {"ef": 64}}
```

**工作原理**:
1. 构建多层图结构
2. 从顶层开始搜索，逐层下降
3. 在底层找到最近邻

**优点**:
- 速度快（毫秒级）
- 召回率高（95-99%）
- 适合大规模数据

**缺点**:
- 内存占用较大
- 构建索引时间较长

**适用场景**:
- 数据量 > 10 万
- 需要高召回率
- **RAG 系统（强烈推荐）**

**参数建议**:
- M = 16（通用配置）
- efConstruction = 256（通用配置）
- ef = 64（检索时，越大越精确）

---

### 索引类型对比表

| 索引类型 | 速度 | 召回率 | 内存占用 | 适用数据量 | RAG 推荐 |
|---------|------|--------|---------|-----------|---------|
| FLAT | 慢 | 100% | 低 | < 1 万 | ❌ |
| IVF_FLAT | 中 | 95-99% | 中 | 1 万 - 100 万 | ⚠️ |
| HNSW | 快 | 95-99% | 高 | > 10 万 | ✅ |

**RAG 场景推荐**: **HNSW**
- 文档数量通常 > 1 万
- 需要毫秒级响应
- 召回率要求高

---

## 索引创建流程

### 完整代码示例

```python
from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType
import numpy as np

# 1. 连接 Milvus
connections.connect(host="localhost", port="19530")

# 2. 创建 Collection
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=384),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=2000),
]
schema = CollectionSchema(fields, description="RAG documents")
collection = Collection("rag_docs", schema)

# 3. 插入数据
num_entities = 10000
embeddings = np.random.rand(num_entities, 384).tolist()
texts = [f"文档 {i} 的内容..." for i in range(num_entities)]
data = [embeddings, texts]
collection.insert(data)
collection.flush()
print(f"插入 {num_entities} 条数据")

# 4. 创建 HNSW 索引
print("开始创建索引...")
index_params = {
    "index_type": "HNSW",
    "metric_type": "COSINE",
    "params": {
        "M": 16,
        "efConstruction": 256
    }
}
collection.create_index(
    field_name="embedding",
    index_params=index_params
)
print("索引创建完成")

# 5. 加载到内存（必须！）
print("加载 Collection 到内存...")
collection.load()
print("加载完成，可以开始检索")

# 6. 检索测试
query_vector = np.random.rand(384).tolist()
search_params = {"metric_type": "COSINE", "params": {"ef": 64}}
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param=search_params,
    limit=5,
    output_fields=["text"]
)

print(f"\n检索结果（Top 5）:")
for i, hit in enumerate(results[0]):
    print(f"{i+1}. ID: {hit.id}, 相似度: {hit.score:.4f}, 文本: {hit.entity.get('text')[:50]}...")
```

**输出示例**:
```
插入 10000 条数据
开始创建索引...
索引创建完成
加载 Collection 到内存...
加载完成，可以开始检索

检索结果（Top 5）:
1. ID: 4523, 相似度: 0.8234, 文本: 文档 4523 的内容...
2. ID: 7891, 相似度: 0.8102, 文本: 文档 7891 的内容...
3. ID: 2345, 相似度: 0.7998, 文本: 文档 2345 的内容...
4. ID: 9012, 相似度: 0.7876, 文本: 文档 9012 的内容...
5. ID: 5678, 相似度: 0.7765, 文本: 文档 5678 的内容...
```

---

## 索引参数调优

### HNSW 参数详解

#### 1. M 参数（每个节点的最大连接数）

```python
# M 参数对比
index_params_m8 = {"index_type": "HNSW", "metric_type": "COSINE", "params": {"M": 8, "efConstruction": 256}}
index_params_m16 = {"index_type": "HNSW", "metric_type": "COSINE", "params": {"M": 16, "efConstruction": 256}}
index_params_m32 = {"index_type": "HNSW", "metric_type": "COSINE", "params": {"M": 32, "efConstruction": 256}}
```

**M 参数影响**:

| M 值 | 召回率 | 检索速度 | 内存占用 | 构建时间 |
|------|--------|---------|---------|---------|
| 8    | 低     | 快      | 低      | 快      |
| 16   | 中     | 中      | 中      | 中      |
| 32   | 高     | 慢      | 高      | 慢      |

**选择建议**:
- M = 8: 内存受限场景
- M = 16: **通用推荐**（平衡性能）
- M = 32: 高精度要求场景

---

#### 2. efConstruction 参数（构建索引时的搜索深度）

```python
# efConstruction 参数对比
index_params_ef128 = {"index_type": "HNSW", "metric_type": "COSINE", "params": {"M": 16, "efConstruction": 128}}
index_params_ef256 = {"index_type": "HNSW", "metric_type": "COSINE", "params": {"M": 16, "efConstruction": 256}}
index_params_ef512 = {"index_type": "HNSW", "metric_type": "COSINE", "params": {"M": 16, "efConstruction": 512}}
```

**efConstruction 参数影响**:

| efConstruction | 召回率 | 构建时间 | 检索速度 |
|----------------|--------|---------|---------|
| 128            | 低     | 快      | 不影响  |
| 256            | 中     | 中      | 不影响  |
| 512            | 高     | 慢      | 不影响  |

**选择建议**:
- efConstruction = 128: 快速构建
- efConstruction = 256: **通用推荐**
- efConstruction = 512: 高精度要求

**注意**: efConstruction 只影响构建时间，不影响检索速度！

---

#### 3. ef 参数（检索时的搜索深度）

```python
# 检索时指定 ef 参数
search_params_ef32 = {"metric_type": "COSINE", "params": {"ef": 32}}
search_params_ef64 = {"metric_type": "COSINE", "params": {"ef": 64}}
search_params_ef128 = {"metric_type": "COSINE", "params": {"ef": 128}}

results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param=search_params_ef64,  # 使用 ef=64
    limit=10
)
```

**ef 参数影响**:

| ef 值 | 召回率 | 检索速度 |
|-------|--------|---------|
| 32    | 低     | 快      |
| 64    | 中     | 中      |
| 128   | 高     | 慢      |

**选择建议**:
- ef = 32: 速度优先
- ef = 64: **通用推荐**（平衡性能）
- ef = 128: 精度优先

**注意**: ef 必须 >= limit（返回结果数量）

---

### RAG 推荐配置

```python
# RAG 场景的最佳配置
index_params = {
    "index_type": "HNSW",
    "metric_type": "COSINE",  # 文本向量推荐 COSINE
    "params": {
        "M": 16,              # 平衡性能
        "efConstruction": 256 # 平衡构建时间和精度
    }
}

search_params = {
    "metric_type": "COSINE",
    "params": {"ef": 64}      # 平衡检索速度和精度
}
```

**为什么这样配置？**
1. **COSINE 度量**: 文本向量通常已归一化，COSINE 更合适
2. **M = 16**: 在内存和性能之间取得平衡
3. **efConstruction = 256**: 构建时间可接受，精度足够
4. **ef = 64**: 检索速度快（< 10ms），召回率高（> 95%）

---

## 索引创建的关键要点

### 1. 必须先插入数据再创建索引

```python
# ✅ 正确顺序
collection.insert(data)
collection.flush()
collection.create_index(...)

# ❌ 错误顺序
collection.create_index(...)  # 报错！没有数据
collection.insert(data)
```

### 2. 创建索引后必须 load()

```python
# ✅ 正确流程
collection.create_index(...)
collection.load()  # 必须加载到内存
results = collection.search(...)

# ❌ 错误流程
collection.create_index(...)
results = collection.search(...)  # 报错！未加载
```

### 3. 索引创建需要时间

```python
import time

# 大数据量索引创建需要时间
print("开始创建索引...")
start = time.time()
collection.create_index("embedding", index_params)
end = time.time()
print(f"索引创建耗时: {end - start:.2f} 秒")

# 示例输出：
# 100 万数据，HNSW 索引：约 30-60 秒
# 1000 万数据，HNSW 索引：约 5-10 分钟
```

### 4. 一个字段只能有一个索引

```python
# ❌ 错误：重复创建索引
collection.create_index("embedding", index_params_1)
collection.create_index("embedding", index_params_2)  # 报错！

# ✅ 正确：先删除旧索引
collection.drop_index()
collection.create_index("embedding", index_params_2)
```

---

## 在 RAG 中的应用

### RAG 索引创建最佳实践

```python
from pymilvus import connections, Collection
from sentence_transformers import SentenceTransformer
import time

# 1. 初始化
connections.connect(host="localhost", port="19530")
model = SentenceTransformer('all-MiniLM-L6-v2')
collection = Collection("rag_knowledge_base")

# 2. 批量插入文档
documents = [...]  # 大量文档
batch_size = 1000

print(f"开始插入 {len(documents)} 个文档...")
for i in range(0, len(documents), batch_size):
    batch = documents[i:i+batch_size]
    embeddings = model.encode(batch).tolist()
    collection.insert([embeddings, batch])
    print(f"已插入 {min(i+batch_size, len(documents))}/{len(documents)}")

collection.flush()
print("数据插入完成")

# 3. 创建 HNSW 索引（RAG 推荐）
print("开始创建索引...")
start = time.time()
index_params = {
    "index_type": "HNSW",
    "metric_type": "COSINE",
    "params": {"M": 16, "efConstruction": 256}
}
collection.create_index("embedding", index_params)
end = time.time()
print(f"索引创建完成，耗时: {end - start:.2f} 秒")

# 4. 加载到内存
print("加载 Collection 到内存...")
collection.load()
print("RAG 知识库准备完成，可以开始检索")
```

---

## 常见错误与解决方案

### 错误 1: 未创建索引就检索

```python
# 错误信息
# "index not exist"

# 解决方案：先创建索引
collection.create_index("embedding", index_params)
collection.load()
```

### 错误 2: 创建索引后未 load()

```python
# 错误信息
# "collection not loaded"

# 解决方案：创建索引后必须 load()
collection.create_index("embedding", index_params)
collection.load()  # 必须！
```

### 错误 3: ef < limit

```python
# 错误信息
# "ef should be larger than limit"

# 解决方案：确保 ef >= limit
search_params = {"metric_type": "COSINE", "params": {"ef": 64}}
results = collection.search(..., param=search_params, limit=10)  # ef=64 >= limit=10
```

---

## 总结

### 核心要点

1. **索引是必需的**: Milvus 强制要求创建索引才能检索
2. **HNSW 是 RAG 首选**: 速度快、召回率高、适合大规模数据
3. **推荐配置**: M=16, efConstruction=256, ef=64
4. **必须 load()**: 创建索引后必须加载到内存
5. **COSINE 度量**: 文本向量推荐使用 COSINE

### RAG 应用建议

- 使用 HNSW 索引
- COSINE 相似度度量
- 通用参数配置（M=16, efConstruction=256, ef=64）
- 批量插入后统一创建索引
- 定期监控索引性能

### 下一步

学习 **核心概念 3: 相似度检索**，了解如何使用索引执行高效的向量检索。
