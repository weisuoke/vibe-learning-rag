# 化骨绵掌 - 10个2分钟知识卡片

## 卡片1：pytest fixture 机制

**核心概念**：
fixture 是测试的前置准备和后置清理

**关键点**：
- 使用 `@pytest.fixture` 装饰器
- 通过参数名注入到测试函数
- 支持作用域：function、class、module、session
- 使用 `yield` 语法进行清理

**代码示例**：
```python
@pytest.fixture(scope="function")
def sample_user():
    user = User(username="test")
    yield user
    # 清理代码

def test_user(sample_user):
    assert sample_user.username == "test"
```

**AI Agent 应用**：
准备测试用的向量存储、LLM 实例、对话记忆

---

## 卡片2：参数化测试

**核心概念**：
使用一组参数批量运行同一个测试

**关键点**：
- 使用 `@pytest.mark.parametrize`
- 减少重复代码
- 自动生成多个测试用例
- 支持多参数组合

**代码示例**：
```python
@pytest.mark.parametrize("a,b,expected", [
    (2, 3, 5),
    (0, 0, 0),
    (-1, 1, 0),
])
def test_add(a, b, expected):
    assert add(a, b) == expected
```

**AI Agent 应用**：
测试不同的 chunk_size、k 值、temperature 参数

---

## 卡片3：Mock 与 Stub

**核心概念**：
Mock 模拟对象并验证交互，Stub 只提供返回值

**关键点**：
- Mock：验证方法调用和参数
- Stub：提供预定义返回值
- 使用 `unittest.mock.Mock`
- 使用 `patch` 替换真实对象

**代码示例**：
```python
from unittest.mock import Mock, patch

# Mock
mock_llm = Mock()
mock_llm.invoke.return_value = "回复"
mock_llm.invoke.assert_called_once()

# Patch
with patch("openai.chat.completions.create") as mock:
    mock.return_value = response
```

**AI Agent 应用**：
Mock OpenAI API、Embedding 服务、向量数据库

---

## 卡片4：数据库测试策略

**核心概念**：
使用测试数据库和事务回滚保证测试独立性

**关键点**：
- 使用内存数据库（SQLite）
- 每个测试在事务中运行
- 测试后自动回滚
- 使用 fixture 管理数据库会话

**代码示例**：
```python
@pytest.fixture
def db_session(engine):
    connection = engine.connect()
    transaction = connection.begin()
    session = Session(bind=connection)
    yield session
    transaction.rollback()
    connection.close()
```

**AI Agent 应用**：
测试对话历史存储、用户数据管理、RAG 文档索引

---

## 卡片5：FastAPI TestClient

**核心概念**：
模拟 HTTP 请求测试 API 端点

**关键点**：
- 不需要启动真实服务器
- 支持所有 HTTP 方法
- 可以覆盖依赖注入
- 测试请求验证和响应

**代码示例**：
```python
from fastapi.testclient import TestClient

client = TestClient(app)

def test_api():
    response = client.post("/api/users", json={
        "username": "alice"
    })
    assert response.status_code == 201
```

**AI Agent 应用**：
测试聊天端点、RAG 检索端点、流式输出端点

---

## 卡片6：异步测试

**核心概念**：
使用 pytest-asyncio 测试异步函数

**关键点**：
- 使用 `@pytest.mark.asyncio` 标记
- 使用 `async def` 定义测试
- 使用 `await` 调用异步函数
- 配置 `asyncio_mode = auto`

**代码示例**：
```python
@pytest.mark.asyncio
async def test_async_function():
    result = await fetch_data()
    assert result is not None

# 测试流式输出
@pytest.mark.asyncio
async def test_streaming():
    chunks = [chunk async for chunk in stream()]
    assert len(chunks) > 0
```

**AI Agent 应用**：
测试异步 LLM 调用、流式输出、并发检索

---

## 卡片7：测试覆盖率

**核心概念**：
衡量测试执行的代码比例

**关键点**：
- 使用 `pytest-cov` 生成报告
- 覆盖率 ≠ 测试质量
- 关注核心逻辑覆盖
- 合理目标：80-90%

**代码示例**：
```bash
# 生成覆盖率报告
pytest --cov=app --cov-report=html

# 设置最低覆盖率
pytest --cov=app --cov-fail-under=80
```

**配置**：
```ini
# pytest.ini
[pytest]
addopts = --cov=app --cov-report=term-missing
```

**AI Agent 应用**：
确保核心 RAG 逻辑、Agent 流程、工具函数都被测试

---

## 卡片8：测试 LLM 输出

**核心概念**：
测试结构和必要条件，而非具体内容

**关键点**：
- 不测试具体输出内容
- 测试输出结构和格式
- 测试关键信息存在
- 使用 temperature=0 提高确定性

**代码示例**：
```python
def test_llm_output():
    response = llm.invoke("什么是RAG?")

    # 测试结构
    assert isinstance(response, str)
    assert len(response) > 0

    # 测试关键信息
    keywords = ["RAG", "检索", "生成"]
    assert any(k in response for k in keywords)
```

**AI Agent 应用**：
测试 Agent 回复格式、流式输出完整性、上下文注入

---

## 卡片9：测试 RAG 检索

**核心概念**：
测试检索功能和相关性

**关键点**：
- 准备测试文档集
- 测试检索数量
- 测试相关性排序
- 测试边界条件

**代码示例**：
```python
def test_rag_retrieval(vector_store):
    # 测试检索
    results = vector_store.similarity_search(
        "什么是RAG?", k=3
    )

    assert len(results) == 3
    assert "RAG" in results[0].page_content

    # 测试相似度
    results_with_scores = vector_store.similarity_search_with_score(
        "RAG", k=5
    )
    scores = [score for _, score in results_with_scores]
    assert scores == sorted(scores, reverse=True)
```

**AI Agent 应用**：
测试向量检索、语义相似度、ReRank 重排序

---

## 卡片10：CI/CD 集成

**核心概念**：
自动化测试和持续集成

**关键点**：
- 每次提交运行测试
- PR 合并前运行完整测试
- 生成测试报告和覆盖率
- 使用标记分类测试

**GitHub Actions 示例**：
```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: 3.13
    - name: Install dependencies
      run: |
        pip install uv
        uv sync
    - name: Run tests
      run: |
        uv run pytest tests/ -v --cov=app
```

**AI Agent 应用**：
自动测试 Agent 端点、RAG 检索、流式输出

---

## 快速参考

### pytest 常用命令

```bash
# 运行所有测试
pytest

# 运行特定文件
pytest tests/test_user.py

# 运行特定测试
pytest tests/test_user.py::test_create_user

# 详细输出
pytest -v

# 显示 print
pytest -s

# 失败时停止
pytest -x

# 只运行失败的测试
pytest --lf

# 并行运行
pytest -n auto

# 生成覆盖率
pytest --cov=app --cov-report=html

# 运行标记的测试
pytest -m unit
pytest -m "not slow"
```

### fixture 作用域

| 作用域 | 创建时机 | 适用场景 |
|--------|----------|----------|
| function | 每个测试函数 | 测试数据 |
| class | 每个测试类 | 共享设置 |
| module | 每个测试模块 | 数据库连接 |
| session | 整个测试会话 | 全局配置 |

### 测试类型对比

| 类型 | 速度 | 隔离性 | 定位问题 | 比例 |
|------|------|--------|----------|------|
| 单元测试 | 快 | 高 | 精确 | 60% |
| 集成测试 | 中 | 中 | 中等 | 30% |
| E2E测试 | 慢 | 低 | 困难 | 10% |

### Mock vs Stub

| 特性 | Mock | Stub |
|------|------|------|
| 返回值 | ✓ | ✓ |
| 验证调用 | ✓ | ✗ |
| 验证参数 | ✓ | ✗ |
| 使用场景 | 验证交互 | 提供数据 |

### AI Agent 测试策略

| 组件 | 测试方法 | 示例 |
|------|----------|------|
| LLM 输出 | 测试结构和关键词 | `assert "RAG" in response` |
| RAG 检索 | 测试检索功能 | `assert len(results) == k` |
| 流式输出 | 收集 chunk 验证 | `chunks = [c async for c in stream()]` |
| 对话记忆 | 测试消息添加 | `assert len(history) == 2` |
| Agent 工具 | Mock 工具调用 | `mock_tool.assert_called_once()` |

---

## 学习路径

### 第1天：pytest 基础
- fixture 机制
- 参数化测试
- 异常测试

### 第2天：数据库测试
- 测试数据库配置
- 事务回滚
- Repository 测试

### 第3天：API 测试
- TestClient 使用
- 认证测试
- 异步测试

### 第4天：AI Agent 测试
- Mock LLM
- 测试 RAG 检索
- 测试流式输出

### 第5天：生产级实践
- 测试组织
- CI/CD 集成
- 性能测试

---

## 常见问题

**Q: 测试会拖慢开发速度吗？**
A: 短期看会，长期看大幅加速。生产环境 bug 修复成本是开发阶段的 10-100 倍。

**Q: 100%覆盖率就是好测试吗？**
A: 不是。覆盖率是量化指标，不代表质量。重要的是测试关键路径和边界条件。

**Q: 如何测试 LLM 的不确定性输出？**
A: 测试输出结构、关键信息、流程逻辑，而非具体内容。使用 temperature=0 提高确定性。

**Q: Mock 太多会让测试失去意义吗？**
A: 不会。Mock 是为了隔离测试目标，提高速度和稳定性。单元测试 Mock 所有依赖，集成测试少 Mock。

**Q: 如何组织测试代码？**
A: 按类型分目录（unit、integration、api、e2e），使用 fixture 复用代码，使用标记分类测试。

---

## 总结

### 核心要点

1. **pytest 基础**：fixture、参数化、异常测试
2. **数据库测试**：测试数据库、事务回滚
3. **API 测试**：TestClient、异步测试
4. **Mock 技巧**：隔离依赖、验证交互
5. **AI Agent 测试**：测试结构、Mock LLM、测试流式输出

### 最佳实践

- 保持测试简单和独立
- 使用描述性命名
- 测试关键路径和边界条件
- 集成 CI/CD 自动化
- 监控测试覆盖率和性能

### 持续学习

- 阅读 pytest 官方文档
- 学习测试驱动开发（TDD）
- 关注测试最佳实践
- 实践项目中应用测试

**记住**：测试是投资，不是成本。好的测试让你敢于重构和快速迭代。
