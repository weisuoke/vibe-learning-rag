# 实战代码 06：迁移自动化工具

> AST 分析、代码生成、测试的完整自动化工具

---

## 概述

本文提供完整的迁移自动化工具，包括 AST 分析、代码生成、测试生成等。

---

## 1. AST 代码扫描工具

```python
"""
AST 代码扫描工具
scanner.py
"""
import ast
import os
from typing import List, Dict
from pathlib import Path

class LegacyChainScanner(ast.NodeVisitor):
    """扫描传统 Chain 的 AST 访问器"""

    def __init__(self):
        self.legacy_chains = []
        self.current_file = None

    def visit_ImportFrom(self, node):
        """访问 import from 语句"""
        if node.module and 'langchain.chains' in node.module:
            for alias in node.names:
                if alias.name in ['LLMChain', 'SequentialChain', 'RouterChain', 'TransformChain']:
                    self.legacy_chains.append({
                        'type': alias.name,
                        'file': self.current_file,
                        'line': node.lineno
                    })
        self.generic_visit(node)

def scan_directory(directory: str) -> List[Dict]:
    """扫描目录中的所有 Python 文件"""
    scanner = LegacyChainScanner()
    results = []

    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith('.py'):
                filepath = os.path.join(root, file)
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        tree = ast.parse(f.read(), filename=filepath)
                        scanner.current_file = filepath
                        scanner.visit(tree)
                except Exception as e:
                    print(f"Error parsing {filepath}: {e}")

    return scanner.legacy_chains

# 使用示例
if __name__ == "__main__":
    results = scan_directory("./src")

    print("=== 扫描结果 ===")
    print(f"找到 {len(results)} 个传统 Chain")

    for item in results:
        print(f"{item['type']} in {item['file']}:{item['line']}")
```

---

## 2. 代码生成工具

```python
"""
LCEL 代码生成工具
generator.py
"""
from typing import Dict

class LCELCodeGenerator:
    """LCEL 代码生成器"""

    @staticmethod
    def generate_llmchain_migration(chain_name: str) -> str:
        """生成 LLMChain 迁移代码"""
        return f'''# 迁移 {chain_name}
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
prompt = ChatPromptTemplate.from_template("{{template}}")

# LCEL 版本
{chain_name} = prompt | llm | StrOutputParser()

# 使用
result = {chain_name}.invoke({{"input": "value"}})
'''

    @staticmethod
    def generate_sequential_migration(chain_name: str) -> str:
        """生成 SequentialChain 迁移代码"""
        return f'''# 迁移 {chain_name}
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

# 定义步骤
prompt1 = ChatPromptTemplate.from_template("{{template1}}")
chain1 = prompt1 | llm | StrOutputParser()

prompt2 = ChatPromptTemplate.from_template("{{template2}}")
chain2 = prompt2 | llm | StrOutputParser()

# LCEL 版本
{chain_name} = (
    {{"input": RunnablePassthrough()}}
    | RunnablePassthrough.assign(step1=chain1)
    | RunnablePassthrough.assign(step2=chain2)
)

# 使用
result = {chain_name}.invoke("input")
'''

    @staticmethod
    def generate_router_migration(chain_name: str) -> str:
        """生成 RouterChain 迁移代码"""
        return f'''# 迁移 {chain_name}
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnableBranch

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

# 定义分支
branch1_prompt = ChatPromptTemplate.from_template("{{template1}}")
branch1 = branch1_prompt | llm | StrOutputParser()

branch2_prompt = ChatPromptTemplate.from_template("{{template2}}")
branch2 = branch2_prompt | llm | StrOutputParser()

# 定义路由逻辑
def route_condition(input_dict):
    # TODO: 实现路由逻辑
    return True

# LCEL 版本
{chain_name} = RunnableBranch(
    (route_condition, branch1),
    branch2  # default
)

# 使用
result = {chain_name}.invoke({{"input": "value"}})
'''

# 使用示例
if __name__ == "__main__":
    generator = LCELCodeGenerator()

    # 生成 LLMChain 迁移代码
    code = generator.generate_llmchain_migration("my_chain")
    print(code)
```

---

## 3. 测试生成工具

```python
"""
测试生成工具
test_generator.py
"""
from typing import List

class TestGenerator:
    """测试代码生成器"""

    @staticmethod
    def generate_comparison_test(chain_name: str, test_inputs: List[str]) -> str:
        """生成对比测试代码"""
        inputs_str = ",\n        ".join([f'"{inp}"' for inp in test_inputs])

        return f'''import pytest
from dotenv import load_dotenv

load_dotenv()

def test_{chain_name}_migration():
    """测试 {chain_name} 迁移"""
    # 导入旧版本
    from old_code import {chain_name} as old_chain

    # 导入新版本
    from new_code import {chain_name} as new_chain

    # 测试输入
    test_inputs = [
        {inputs_str}
    ]

    for inp in test_inputs:
        # 旧版本结果
        old_result = old_chain.run(inp)

        # 新版本结果
        new_result = new_chain.invoke({{"input": inp}})

        # 对比
        assert old_result.strip() == new_result.strip(), \\
            f"Results differ for input: {{inp}}"

    print(f"✓ All {{len(test_inputs)}} tests passed")
'''

    @staticmethod
    def generate_performance_test(chain_name: str) -> str:
        """生成性能测试代码"""
        return f'''import time
import pytest
from dotenv import load_dotenv

load_dotenv()

def test_{chain_name}_performance():
    """测试 {chain_name} 性能"""
    from old_code import {chain_name} as old_chain
    from new_code import {chain_name} as new_chain

    test_input = "测试输入"

    # 测试旧版本
    start = time.time()
    old_result = old_chain.run(test_input)
    old_time = time.time() - start

    # 测试新版本
    start = time.time()
    new_result = new_chain.invoke({{"input": test_input}})
    new_time = time.time() - start

    # 验证性能提升
    speedup = old_time / new_time
    print(f"旧版本: {{old_time:.3f}}s")
    print(f"新版本: {{new_time:.3f}}s")
    print(f"加速比: {{speedup:.2f}}x")

    # 断言性能提升
    assert speedup >= 1.0, "新版本应该至少不慢于旧版本"
'''

# 使用示例
if __name__ == "__main__":
    generator = TestGenerator()

    # 生成对比测试
    test_code = generator.generate_comparison_test(
        "my_chain",
        ["输入1", "输入2", "输入3"]
    )
    print(test_code)
```

---

## 4. 完整迁移工具

```python
"""
完整迁移自动化工具
migration_tool.py
"""
import os
import ast
from pathlib import Path
from typing import List, Dict

class MigrationTool:
    """完整迁移工具"""

    def __init__(self, source_dir: str, output_dir: str):
        self.source_dir = source_dir
        self.output_dir = output_dir
        self.scanner = LegacyChainScanner()
        self.generator = LCELCodeGenerator()
        self.test_generator = TestGenerator()

    def scan(self) -> List[Dict]:
        """扫描代码库"""
        print("=== 步骤 1: 扫描代码库 ===")
        results = scan_directory(self.source_dir)
        print(f"找到 {len(results)} 个传统 Chain")
        return results

    def generate_migrations(self, scan_results: List[Dict]):
        """生成迁移代码"""
        print("\n=== 步骤 2: 生成迁移代码 ===")

        for item in scan_results:
            chain_type = item['type']
            file_path = item['file']

            # 生成迁移代码
            if chain_type == 'LLMChain':
                code = self.generator.generate_llmchain_migration(
                    f"migrated_{Path(file_path).stem}"
                )
            elif chain_type == 'SequentialChain':
                code = self.generator.generate_sequential_migration(
                    f"migrated_{Path(file_path).stem}"
                )
            elif chain_type == 'RouterChain':
                code = self.generator.generate_router_migration(
                    f"migrated_{Path(file_path).stem}"
                )
            else:
                continue

            # 保存迁移代码
            output_file = os.path.join(
                self.output_dir,
                f"migrated_{Path(file_path).stem}.py"
            )
            os.makedirs(os.path.dirname(output_file), exist_ok=True)

            with open(output_file, 'w') as f:
                f.write(code)

            print(f"✓ 生成迁移代码: {output_file}")

    def generate_tests(self, scan_results: List[Dict]):
        """生成测试代码"""
        print("\n=== 步骤 3: 生成测试代码 ===")

        for item in scan_results:
            chain_name = f"migrated_{Path(item['file']).stem}"

            # 生成对比测试
            test_code = self.test_generator.generate_comparison_test(
                chain_name,
                ["测试输入1", "测试输入2"]
            )

            # 保存测试代码
            test_file = os.path.join(
                self.output_dir,
                f"test_{chain_name}.py"
            )

            with open(test_file, 'w') as f:
                f.write(test_code)

            print(f"✓ 生成测试代码: {test_file}")

    def run(self):
        """运行完整迁移流程"""
        print("=" * 60)
        print("迁移自动化工具")
        print("=" * 60)

        # 1. 扫描
        scan_results = self.scan()

        # 2. 生成迁移代码
        self.generate_migrations(scan_results)

        # 3. 生成测试代码
        self.generate_tests(scan_results)

        print("\n" + "=" * 60)
        print("迁移完成！")
        print("=" * 60)
        print(f"迁移代码: {self.output_dir}")
        print("下一步:")
        print("1. 检查生成的代码")
        print("2. 运行测试: pytest")
        print("3. 手动调整代码")

# 使用示例
if __name__ == "__main__":
    tool = MigrationTool(
        source_dir="./src",
        output_dir="./migrated"
    )
    tool.run()
```

---

## 5. CLI 工具

```python
"""
命令行工具
cli.py
"""
import click
from migration_tool import MigrationTool

@click.group()
def cli():
    """LCEL 迁移工具"""
    pass

@cli.command()
@click.argument('source_dir')
def scan(source_dir):
    """扫描代码库中的传统 Chain"""
    from scanner import scan_directory

    results = scan_directory(source_dir)

    click.echo(f"找到 {len(results)} 个传统 Chain:")
    for item in results:
        click.echo(f"  {item['type']} in {item['file']}:{item['line']}")

@cli.command()
@click.argument('source_dir')
@click.argument('output_dir')
def migrate(source_dir, output_dir):
    """自动迁移代码"""
    tool = MigrationTool(source_dir, output_dir)
    tool.run()

@cli.command()
@click.argument('chain_name')
@click.option('--type', type=click.Choice(['llm', 'sequential', 'router']), required=True)
def generate(chain_name, type):
    """生成迁移代码模板"""
    from generator import LCELCodeGenerator

    generator = LCELCodeGenerator()

    if type == 'llm':
        code = generator.generate_llmchain_migration(chain_name)
    elif type == 'sequential':
        code = generator.generate_sequential_migration(chain_name)
    elif type == 'router':
        code = generator.generate_router_migration(chain_name)

    click.echo(code)

if __name__ == '__main__':
    cli()
```

```bash
# 使用示例

# 扫描代码库
python cli.py scan ./src

# 自动迁移
python cli.py migrate ./src ./migrated

# 生成迁移模板
python cli.py generate my_chain --type llm
```

---

## 6. 完整示例

```bash
# 安装依赖
pip install click

# 1. 扫描代码库
python cli.py scan ./src

# 输出:
# 找到 5 个传统 Chain:
#   LLMChain in ./src/chains.py:10
#   SequentialChain in ./src/workflow.py:25
#   ...

# 2. 自动迁移
python cli.py migrate ./src ./migrated

# 输出:
# === 步骤 1: 扫描代码库 ===
# 找到 5 个传统 Chain
#
# === 步骤 2: 生成迁移代码 ===
# ✓ 生成迁移代码: ./migrated/migrated_chains.py
# ✓ 生成迁移代码: ./migrated/migrated_workflow.py
#
# === 步骤 3: 生成测试代码 ===
# ✓ 生成测试代码: ./migrated/test_migrated_chains.py
# ✓ 生成测试代码: ./migrated/test_migrated_workflow.py
#
# 迁移完成！

# 3. 运行测试
cd migrated
pytest

# 4. 手动调整代码
# 检查生成的代码，根据实际情况调整
```

---

## 总结

### 自动化工具总结

| 工具 | 功能 | 输出 |
|------|------|------|
| Scanner | AST 扫描 | 传统 Chain 列表 |
| Generator | 代码生成 | LCEL 迁移代码 |
| TestGenerator | 测试生成 | 对比测试代码 |
| MigrationTool | 完整流程 | 迁移代码 + 测试 |
| CLI | 命令行接口 | 交互式工具 |

### 关键要点

1. **AST 分析**：准确识别传统 Chain
2. **代码生成**：自动生成 LCEL 代码
3. **测试生成**：自动生成对比测试
4. **CLI 工具**：提供友好的命令行接口

### 使用建议

1. **先扫描**：了解代码库中的传统 Chain
2. **再生成**：自动生成迁移代码
3. **后测试**：运行测试验证正确性
4. **手动调整**：根据实际情况调整代码

---

## 完成！

恭喜！你已经完成了 LCEL 与传统 Chain 对比的完整学习。

现在你可以：
- ✅ 理解 LCEL 和传统 Chain 的本质区别
- ✅ 掌握基础和复杂的迁移模式
- ✅ 进行性能基准测试
- ✅ 优化成本
- ✅ 部署到生产环境
- ✅ 使用自动化工具加速迁移

**下一步**：将所学知识应用到实际项目中！
