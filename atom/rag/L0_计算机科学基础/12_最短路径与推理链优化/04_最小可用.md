# 最小可用知识

> 掌握20%核心知识，解决80%问题

---

掌握以下内容，就能开始使用最短路径算法优化AI Agent推理链：

## 4.1 Dijkstra算法核心

**本质：** 贪心策略 + 松弛操作

```python
import heapq

def dijkstra(graph, start, end):
    """最短路径算法核心实现"""
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]
    visited = set()

    while pq:
        current_dist, u = heapq.heappop(pq)

        if u in visited:
            continue
        visited.add(u)

        if u == end:
            break

        for v, weight in graph[u]:
            new_dist = current_dist + weight
            if new_dist < dist[v]:
                dist[v] = new_dist
                heapq.heappush(pq, (new_dist, v))

    return dist[end]
```

**关键点：**
- 优先级队列：每次取距离最小的节点
- 松弛操作：更新邻居节点的距离
- 已访问集合：避免重复处理

---

## 4.2 推理链建模

**核心思想：** 推理过程 = 图遍历

```python
# 知识图谱表示
kg = {
    "《哈利·波特》": [("J.K.罗琳", 0.1)],  # (目标, 权重)
    "J.K.罗琳": [("尼尔·默里", 0.1)]
}

# 找推理路径
cost = dijkstra(kg, "《哈利·波特》", "尼尔·默里")
# 结果: 0.2 (两跳推理)
```

**在AI Agent中：**
- 节点 = 知识点/实体
- 边 = 推理步骤/关系
- 权重 = 推理代价/可信度

---

## 4.3 权重设计原则

**基本公式：**
```python
def edge_weight(relation):
    """边权重 = 基础代价 + 不确定性惩罚"""
    base_cost = {
        "直接关系": 0.1,
        "间接关系": 0.3,
        "推断关系": 0.5
    }[relation.type]

    uncertainty = (1 - relation.confidence) * 0.5

    return base_cost + uncertainty
```

**设计要点：**
- 可信度高 → 权重小
- 推理步骤少 → 权重小
- 证据充分 → 权重小

---

## 4.4 A*启发式加速

**核心公式：** f(n) = g(n) + h(n)

```python
def a_star(graph, start, goal, heuristic):
    """A*搜索：用启发式加速"""
    pq = [(heuristic(start, goal), 0, start)]
    g_score = {start: 0}

    while pq:
        _, current_g, current = heapq.heappop(pq)

        if current == goal:
            return current_g

        for neighbor, weight in graph[current]:
            new_g = current_g + weight

            if neighbor not in g_score or new_g < g_score[neighbor]:
                g_score[neighbor] = new_g
                f = new_g + heuristic(neighbor, goal)
                heapq.heappush(pq, (f, new_g, neighbor))

    return float('inf')

# 启发式函数：语义相似度
def heuristic(node, goal):
    similarity = semantic_similarity(node, goal)
    return (1 - similarity) * 10.0
```

**关键优势：**
- 目标导向：优先探索接近目标的节点
- 大幅减少搜索空间
- 保证最优性（如果h(n)可采纳）

---

## 4.5 LangGraph集成

**最小工作流：**

```python
from langgraph.graph import StateGraph, END

def create_reasoning_workflow():
    workflow = StateGraph(dict)

    # 节点1：找推理路径
    def find_path(state):
        path = dijkstra(kg, state["start"], state["goal"])
        return {"path": path}

    # 节点2：生成答案
    def generate(state):
        answer = llm.generate(
            question=state["question"],
            path=state["path"]
        )
        return {"answer": answer}

    workflow.add_node("find_path", find_path)
    workflow.add_node("generate", generate)

    workflow.set_entry_point("find_path")
    workflow.add_edge("find_path", "generate")
    workflow.add_edge("generate", END)

    return workflow.compile()

# 使用
app = create_reasoning_workflow()
result = app.invoke({
    "question": "谁是《哈利·波特》作者的丈夫？",
    "start": "《哈利·波特》",
    "goal": "尼尔·默里"
})
```

---

## 这些知识足以：

✅ **实现基础推理链优化**
- 在知识图谱中找最优推理路径
- 设计合理的权重函数
- 集成到AI Agent工作流

✅ **解决80%的实际问题**
- 多跳问答
- 知识图谱推理
- 简单的路径规划

✅ **为后续学习打基础**
- 理解更复杂的算法（K最短路径、双向搜索）
- 学习生产级优化（缓存、并行、监控）
- 掌握2025-2026年最新技术（iLLM-A*、StepChain）

---

## 快速上手检查清单

- [ ] 能手写Dijkstra算法（不看参考）
- [ ] 理解推理链 = 图遍历的建模思想
- [ ] 能设计简单的边权重函数
- [ ] 理解A*的f(n) = g(n) + h(n)公式
- [ ] 能用LangGraph构建基础推理工作流

---

## 下一步学习建议

**如果你想：**
- **提升算法理解** → 学习核心概念01-04（Dijkstra、A*、权重设计、问题分类）
- **了解最新突破** → 学习核心概念05-06（2025新算法、iLLM-A*）
- **应用到AI Agent** → 学习核心概念07-10（推理链、GraphRAG、多跳推理、生产系统）
- **动手实践** → 学习实战代码场景1-5

---

**记住：最短路径算法的核心是"贪心 + 松弛"，在AI Agent中用于找最优推理链。掌握这个核心，就能解决大部分问题。**
