# 基础单代理执行 - 研究案例汇总 (2025-2026)

**研究日期**: 2026-02-21
**目标**: 为"07_实战代码_01_基础单代理执行.md"收集最新实际案例

---

## Query 1: AI agent single execution pattern TypeScript 2025 2026

### 1. hatchet-dev/icepick
- **URL**: https://github.com/hatchet-dev/icepick
- **描述**: TypeScript库构建可扩展AI代理，支持持久单次执行自动检查点和大规模任务并行
- **关键特性**:
  - Durable execution with automatic checkpointing
  - Scalable AI agents
  - Fault tolerance
  - Large-scale task parallelization

### 2. universal-tool-calling-protocol/code-mode
- **URL**: https://github.com/universal-tool-calling-protocol/code-mode
- **描述**: TypeScript单次代码执行工具链，AI代理用一个请求替换多工具调用处理复杂链
- **关键特性**:
  - Single code execution replacing multiple tool calls
  - Complex workflow handling in single request
  - Token efficiency

### 3. Furisto/construct
- **URL**: https://github.com/Furisto/construct
- **描述**: 多代理助手代理编写代码实现单次执行循环条件和复杂数据处理，TypeScript SDK
- **关键特性**:
  - Multi-agent coding assistant
  - Single execution with loops and conditions
  - Complex data handling

### 4. orneryd/Mimir
- **URL**: https://github.com/orneryd/Mimir
- **描述**: AI代理单次沙箱TypeScript代码执行替代顺序工具调用，减少96% token消耗
- **关键特性**:
  - Sandbox execution
  - 96% token reduction
  - Replaces sequential tool calls

### 5. inngest/agent-kit
- **URL**: https://github.com/inngest/agent-kit
- **描述**: TypeScript构建多代理网络，支持确定性路由MCP工具和单次执行流控制
- **关键特性**:
  - Multi-agent network
  - Deterministic routing
  - MCP tools integration
  - Execution flow control

### 6. langchain-ai/deepagentsjs
- **URL**: https://github.com/langchain-ai/deepagentsjs
- **描述**: TypeScript通用深度AI代理实现，含规划工具子代理文件系统和详细提示模式
- **关键特性**:
  - Deep AI agent patterns
  - Planning tools
  - Sub-agents
  - File system integration

### 7. tom_doerr TypeScript执行计划框架
- **URL**: https://x.com/tom_doerr/status/1877142409252934112
- **描述**: TypeScript框架让AI代理代码思考生成AST执行计划，支持可靠单次调试执行
- **关键特性**:
  - Code-based thinking
  - AST execution plans
  - Reliable single execution
  - Debugging support

---

## Query 2: Sub-agent basic implementation examples real-world 2025

### 1. lst97/claude-code-sub-agents
- **URL**: https://github.com/lst97/claude-code-sub-agents
- **描述**: 33个专业化AI子代理集合，用于全栈开发工作流，包含真实多代理协调场景和资源指标
- **关键特性**:
  - 33 specialized sub-agents
  - Full-stack development workflows
  - Real-world multi-agent coordination
  - Resource metrics

### 2. webdevtodayjason/sub-agents
- **URL**: https://github.com/webdevtodayjason/sub-agents
- **描述**: 简单CLI工具管理Claude Code子代理，支持钩子与自定义斜杠命令的实际实现示例
- **关键特性**:
  - CLI tool for managing sub-agents
  - Hooks support
  - Custom slash commands
  - Practical implementation examples

### 3. zhsama/claude-sub-agent
- **URL**: https://github.com/zhsama/claude-sub-agent
- **描述**: 基于Claude Code子代理的多代理开发流水线，包含规格工作流和快速启动指南
- **关键特性**:
  - Multi-agent development pipeline
  - Specification workflows
  - Quick start guide

### 4. tomas-rampas/claude-sub-agent-delegation
- **URL**: https://gist.github.com/tomas-rampas/a79213bb4cf59722e45eab7aa45f155c
- **描述**: 基本子代理委托示例，创建计划、阅读、制作和安全代理的完整配置
- **关键特性**:
  - Basic sub-agent delegation
  - Planner, reader, maker, security agents
  - Complete configuration examples

### 5. Reddit: 100+ Claude Code Sub-agents Collection
- **URL**: https://www.reddit.com/r/ClaudeAI/comments/1mi59yk/we_prepared_a_collection_of_claude_code_subagents/
- **描述**: 生产级100+专业子代理，覆盖前端后端DevOps等真实开发任务示例
- **关键特性**:
  - 100+ production-grade sub-agents
  - Frontend, backend, DevOps coverage
  - Real development task examples

### 6. Reddit: Multi-agent Claude Code Commands
- **URL**: https://www.reddit.com/r/ClaudeAI/comments/1lf5gwp/sub_agent_multiagent_claude_code_commands_for/
- **描述**: 编排多个专业子代理处理复杂软件工程任务的命令集合与实现示例
- **关键特性**:
  - Multi-agent orchestration commands
  - Complex software engineering tasks
  - Implementation examples

### 7. Reddit: Custom Sub-agent Building
- **URL**: https://www.reddit.com/r/ClaudeAI/comments/1m8r9ra/sub_agents_are_a_game_changer_here_is_how_i_made/
- **关键特性**:
  - Game-changing sub-agent approach
  - Custom building for project pain points
  - Step-by-step code examples

### 8. Reddit: Multi-agent Orchestration System
- **URL**: https://www.reddit.com/r/ClaudeAI/comments/1l11fo2/how_i_built_a_multiagent_orchestration_system/
- **描述**: 使用Claude Code构建多代理系统的真实案例，包括健康合规检查器实现
- **关键特性**:
  - Real-world multi-agent system
  - Health compliance checker
  - Implementation details

---

## Query 3: Agent orchestration single task execution best practices 2026

### 1. Camunda: Guardrails and Best Practices for Agentic Orchestration
- **URL**: https://camunda.com/blog/2026/01/guardrails-and-best-practices-for-agentic-orchestration/
- **描述**: 2026代理编排护栏与最佳实践，分离确定性逻辑与动态AI任务
- **关键特性**:
  - Guardrails for agent orchestration
  - Separation of deterministic logic and dynamic AI tasks
  - Best practices for 2026

### 2. Gumloop: How to orchestrate AI agents (practical guide for 2026)
- **URL**: https://www.gumloop.com/blog/how-to-orchestrate-ai-agents
- **描述**: 2026实用指南，每个AI代理专注单一任务减少幻觉
- **关键特性**:
  - Single-responsibility agents
  - Hallucination reduction
  - Practical orchestration guide

### 3. Forbes: Agent Orchestration Best Practices And Pitfalls
- **URL**: https://www.forbes.com/councils/forbestechcouncil/2025/12/16/agent-orchestration-best-practices-and-pitfalls/
- **描述**: 代理编排架构选择与子代理任务分配实施指南
- **关键特性**:
  - Architecture choices
  - Sub-agent task allocation
  - Common pitfalls

### 4. Redis: Top AI Agent Orchestration Platforms in 2026
- **URL**: https://redis.io/blog/ai-agent-orchestration-platforms/
- **描述**: 2026顶级平台比较，任务分解与专家代理执行模式
- **关键特性**:
  - Platform comparison
  - Task decomposition
  - Expert agent execution patterns

### 5. Deloitte: Unlocking exponential value with AI agent orchestration
- **URL**: https://www.deloitte.com/us/en/insights/industry/technology/technology-media-and-telecom-predictions/2026/ai-agent-orchestration.html
- **描述**: 2026多代理编排策略，提升单一复杂任务执行价值
- **关键特性**:
  - Multi-agent orchestration strategies
  - Complex task execution
  - Value optimization

### 6. arXiv: A Practical Guide for Designing Agentic AI Workflows
- **URL**: https://arxiv.org/abs/2512.08769
- **描述**: 代理工作流工程指南，单工具单责任代理最佳实践
- **关键特性**:
  - Workflow engineering guide
  - Single-tool single-responsibility agents
  - Best practices

### 7. OneReach: Best Practices for AI Agent Implementations (Enterprise Guide 2026)
- **URL**: https://onereach.ai/blog/best-practices-for-ai-agent-implementations/
- **描述**: 2026企业AI代理实施，生命周期与多代理任务编排
- **关键特性**:
  - Enterprise implementation guide
  - Lifecycle management
  - Multi-agent task orchestration

---

## 关键发现总结

### 技术趋势 (2025-2026)
1. **单次执行优化**: 从多次工具调用转向单次代码执行，显著减少token消耗（如Mimir的96%减少）
2. **持久化执行**: 支持自动检查点和容错的持久化执行模式（如Icepick）
3. **沙箱安全**: 安全沙箱中执行TypeScript代码成为标准实践
4. **单一责任原则**: 每个代理专注单一任务，减少幻觉和提高可维护性

### 实际应用模式
1. **Claude Code生态**: 大量实际项目使用Claude Code的sub-agent系统（33-100+专业代理）
2. **工作流编排**: Scout → Planner → Worker等链式工作流成为主流
3. **MCP集成**: 与Model Context Protocol工具的深度集成
4. **确定性路由**: 支持确定性路由和执行流控制

### 最佳实践
1. **分离关注点**: 确定性逻辑与动态AI任务分离
2. **专家代理**: 使用专业化代理而非通用代理
3. **任务分解**: 复杂任务分解为单一责任的子任务
4. **护栏机制**: 实施guardrails确保可靠执行

---

## 详细内容抓取

### 1. lst97/claude-code-sub-agents - 详细分析

**来源**: [GitHub - lst97/claude-code-sub-agents](https://github.com/lst97/claude-code-sub-agents)

**核心特性**:
- 33个专业化AI子代理集合，覆盖全栈开发工作流
- 智能自动委托：Claude Code根据任务上下文自动选择最优代理
- 多代理编排：无缝协调多个代理处理复杂工作流
- 质量保证：所有领域内置审查和验证模式
- 性能优化：代理设计注重高效任务完成和资源利用

**代理分类**:
1. **Development** (14个代理)
   - Frontend & UI: frontend-developer, ui-designer, ux-designer, react-pro, nextjs-pro
   - Backend & Architecture: backend-architect, full-stack-developer
   - Language Specialists: python-pro, golang-pro, typescript-pro
   - Platform & Mobile: mobile-developer, electron-pro
   - Developer Experience: dx-optimizer, legacy-modernizer

2. **Infrastructure** (5个代理)
   - cloud-architect, deployment-engineer, devops-incident-responder, incident-responder, performance-engineer

3. **Quality & Testing** (5个代理)
   - code-reviewer, architect-reviewer, qa-expert, test-automator, debugger

4. **Data & AI** (8个代理)
   - Data: data-engineer, data-scientist, database-optimizer, postgres-pro, graphql-architect
   - AI/ML: ai-engineer, ml-engineer, prompt-engineer

5. **Security** (1个代理)
   - security-auditor

6. **Meta-Orchestration** (1个代理)
   - agent-organizer: 主编排器，分析项目需求，组装最优代理团队，管理协作工作流

**使用模式**:
- **自动调用**: Claude Code智能分析请求并自动委托给最合适的子代理
- **显式调用**: `"Use the code-reviewer to check my recent changes"`
- **混合方式**: `"Use backend-architect to design a REST API, then handle the implementation automatically"`

**代理通信协议**:
```json
{
  "requesting_agent": "frontend-developer",
  "request_type": "get_task_briefing",
  "payload": {
    "query": "Initial briefing required for UI component development..."
  }
}
```

**实际案例**:
- **Example 1**: ExportStep组件实现
  - 4步工作流：agent-organizer → frontend-developer → code-reviewer → test-automator
  - 总token: 详细记录每个代理的token消耗
  - 实时进度追踪和流式更新

- **Example 2**: 复杂工作区管理系统
  - 5阶段实现：设计 → 实现 → 测试 → 优化 → 部署
  - 多代理团队协作
  - 完整的IndexedDB持久化和Discord风格UI

**关键发现**:
- 单一责任原则：每个代理专注特定领域
- 确定性路由：支持确定性路由和执行流控制
- MCP集成：与Model Context Protocol工具深度集成
- 生产就绪：100+生产级专业子代理

---

### 2. Camunda Blog - 代理编排最佳实践

**来源**: [Guardrails and Best Practices for Agentic Orchestration](https://camunda.com/blog/2026/01/guardrails-and-best-practices-for-agentic-orchestration/)

**核心理念**: 不要用黑盒AI替代治理，而是将智能与控制相结合——在编排流程中使用代理编排

**关键术语**:
- **Process orchestration**: 使用BPMN等标准协调系统、人员和决策的端到端工作流
- **Agentic orchestration**: AI代理、工具和交接的特定协调，包括升级、计时器和人工审批等约束
- **Enterprise agentic automation (EAA)**: 流程编排与代理编排的结合，代理作为任务嵌入受治理的有状态流程中

**确定性流程 vs 动态流程**:
- **确定性流程**: 预期输入产生无歧义或随机性的顺序步骤，行为可预测、可重复
- **动态流程**: 路径可在运行时根据上下文、事件、数据或人员/AI代理的决策而改变

**10大最佳实践**:

1. **从流程目标开始，然后设计代理**
   - 明确业务目标（如5分钟内完成客户入职）
   - 使用BPMN和DMN捕获确定性逻辑和决策

2. **分离确定性逻辑与动态逻辑**
   - 确定性行为建模为经典BPMN流程步骤和DMN决策
   - 为动态、推理密集型任务保留AI代理
   - 适合代理的场景：混乱无序输入、服务调用间独特数据结构、多系统集成、不可预测的任务后续流程、循环任务激活

3. **保持目标精准、结果可预测**
   - 定义代理的具体目标，而非整个流程
   - 将代理视为"有大脑的流程步骤"
   - 缩小目标范围可节省成本、减少幻觉、提高准确性

4. **明确代理适合做什么、不适合做什么**
   - 应该做：选择工具执行顺序、解释工具结果、重新语境化现有数据
   - 不应该做：创建未经验证的全新业务数据、做最终确定性计算或决策

5. **尽快离开代理**
   - 代理完成目标后立即返回确定性流程
   - 提供更强治理和可解释性
   - 降低成本（代理使用通常是流程中最昂贵的部分）

6. **使用系统提示作为护栏**
   - 明确代理目标与系统提示目标的区别
   - 系统提示应包含：代理目标声明、允许的工具和行为定义、失败模式和安全约束说明
   - 避免：过度详细指导、"不惜一切代价"等不安全语言

7. **教会代理如何失败**
   - 设置明确的成功和失败条件
   - 在BPMN中显式建模失败路径、错误事件和人工介入任务
   - 失败应该是一等结果：可配置重试次数后停止、返回结构化"无法完成"结果、升级到其他代理或人工任务

8. **让代理成为更大流程的一部分（Agentic BPMN）**
   - 代理不应是主编排器，而是参与者
   - 将代理视为调用外部平台的服务任务或专用"代理子流程"
   - 使用BPMN元素作为工具：Call Activity用于复杂可重用流程、守门任务防止代理直接调用敏感操作

9. **选择和调优LLM**
   - 先建模流程和代理范围，再选择LLM
   - 从通用能力模型开始（如Claude Sonnet 4.x）
   - 缩小代理目标和循环可减少token使用
   - 使用RAG获取领域特定知识而非提示整个知识库

10. **配置用户提示**
    - 用户提示应作为动态的、每实例输入
    - 考虑代理响应格式以便下游组件使用
    - 使用代理内存进行短期推理，依赖Camunda的持久流程状态进行长期内存

**实际应用模式**:
- **版税和财务权益**: 代理收集跨混乱系统的信息，然后交给DMN和确定性流程计算
- **KYC和入职检查**: 代理编排数据收集和风险总结，最终决策保留在确定性KYC决策模型中
- **文档提取和总结**: 代理识别文档类型和提取段落，流程编排确保敏感信息被屏蔽
- **事件解决**: 代理尝试一级解决，无法安全解决时路由到人工专家

**护栏检查清单**:
- 范围：代理目标是否狭窄、明确定义并嵌入更大流程？
- 逻辑分离：确定性逻辑是否在BPMN/DMN中建模，代理仅专注动态推理？
- 提示：系统提示是否明确定义成功、失败、工具使用和禁止行为？
- 退出策略：是否在流程中显式建模成功、失败和升级路径？
- 工具：工具是否有文档、约束并包装在安全BPMN模式中？
- 状态和审计：长时间运行的代理是否由有状态流程执行和独立审计跟踪支持？
- 治理：是否为代理、提示和工具建立版本控制、迁移和监控？

---

### 3. hatchet-dev/icepick - 可扩展AI代理库

**来源**: [GitHub - hatchet-dev/icepick](https://github.com/hatchet-dev/icepick)

**核心定位**: TypeScript库，用于构建容错和可扩展的AI代理，不是框架

**核心特性**:
- **持久化执行**: 为代理创建自动检查点，轻松从故障中恢复或长时间等待外部事件而不消耗资源
- **代码优先**: 代理定义为代码，设计与业务逻辑集成
- **分布式**: 所有代理和工具跨机器群运行，Icepick优雅处理调度
- **可配置**: 简单配置重试、速率限制、并发控制等
- **可在任何地方运行**: 可在任何基于容器的平台运行（Hatchet、Railway、Fly.io、Kubernetes、AWS ECS、GCP Cloud Run）

**代码示例**:
```typescript
import { icepick } from "@hatchet-dev/icepick";
import z from "zod";

const MyAgentInput = z.object({
  message: z.string(),
});

const MyAgentOutput = z.object({
  message: z.string(),
});

export const myToolbox = icepick.toolbox({
  tools: [myTool1, myTool2],
});

export const myAgent = icepick.agent({
  name: "my-agent",
  executionTimeout: "15m",
  inputSchema: MyAgentInput,
  outputSchema: MyAgentOutput,
  description: "Description of what this agent does",
  fn: async (input, ctx) => {
    const result = await myToolbox.pickAndRun({
      prompt: input.message,
    });

    switch (result.name) {
      case "myTool1":
        return { message: `Result: ${result.output}` };
      case "myTool2":
        return { message: `Another result: ${result.output}` };
      default:
        return myToolbox.assertExhaustive(result);
    }
  },
});
```

**快速开始**:
```bash
pnpm i -g @hatchet-dev/icepick-cli
icepick create first-agent
```

**可扩展性**:
- 设计用于大规模吞吐量和并行性
- Hatchet运行的代理工作负载可为单次执行生成数十万个任务
- 每月运行数十亿个任务

**哲学**:
- 不是框架：代理和工具只是你编写的函数
- 可以选择或构建最佳的内存、知识、推理或集成
- 不对如何设计工具、调用LLM或实现代理内存施加约束
- 对代理的基础设施层有主见，但对实现细节无主见

**技术深度**:
- 基于Hatchet的持久任务队列构建
- 每个任务存储在数据库中，可轻松重放和从故障中恢复
- 代理应该是无状态reducer，无副作用
- 所有工作量应作为任务或工具调用调用

**执行历史示例**:
```
Event log:
-> Start search_documents
-> Finish search_documents
-> Start get_document
-> Finish get_document
-> Start extract_from_document...
```

机器崩溃后自动重放：
```
Event log:
-> Start search_documents (replayed)
-> Finish search_documents (replayed)
-> Start get_document (replayed)
-> Finish get_document (replayed)
-> Start extract_from_document (replayed)
-> (later) Finish extract_from_document
```

**vs Temporal对比**:
- 相似：持久执行、工作流内事件监听器、代码优先工作流定义、Cron作业、一次性调度、流控制、持久睡眠
- Icepick独有：全局速率限制、基于事件的触发、事件流、DAG支持、优先级队列、粘性分配/复杂路由逻辑

**最佳实践**:
1. 代理应该是无状态reducer，无副作用
2. 所有工作量应作为任务或工具调用调用
3. 将LLM调用视为库，拥有数据查找：应用不应允许无约束的代理工具调用进行数据查找

**灵感来源**:
- [12-factor agents](https://github.com/humanlayer/12-factor-agents) - 为什么Icepick倡导拥有控制流、上下文窗口和提示
- Anthropic的[Building Effective Agents](https://www.anthropic.com/engineering/building-effective-agents) - 确保Anthropic文章中记录的每个模式都与Icepick兼容

---

## 综合分析与关键洞察

### 技术趋势 (2025-2026)

1. **持久化执行成为标准**
   - Icepick的自动检查点机制
   - 容错和可恢复性是核心特性
   - 长时间运行的代理需要持久化支持

2. **代码优先 vs 框架**
   - Icepick明确定位为"不是框架"
   - 代理和工具只是函数，易于集成现有代码库
   - 灵活性优于约定

3. **确定性与动态的平衡**
   - Camunda强调分离确定性逻辑和动态逻辑
   - BPMN/DMN用于确定性流程，AI代理用于动态推理
   - 护栏和治理是企业级应用的关键

4. **单一责任原则**
   - lst97的33个专业化代理，每个专注特定领域
   - Camunda建议缩小代理目标范围
   - 专家代理优于通用代理

5. **编排模式成熟**
   - 多代理协作成为主流
   - Scout → Planner → Worker等链式工作流
   - Meta-orchestrator（agent-organizer）管理复杂工作流

### 实际应用模式

1. **自动委托 + 显式调用**
   - Claude Code的智能自动委托
   - 支持显式调用特定代理
   - 混合方式提供最大灵活性

2. **流式更新和实时进度**
   - lst97案例展示实时token消耗追踪
   - 流式更新提供更好的用户体验
   - 透明度和可观察性

3. **MCP集成**
   - sequential-thinking、context7、magic、playwright等MCP服务器
   - 增强多步骤推理和工具能力
   - 标准化工具接口

4. **生产就绪考虑**
   - 版本控制、迁移、监控
   - 审计跟踪和合规性
   - 成本控制和性能优化

### 最佳实践总结

1. **设计原则**
   - 从流程目标开始，而非从代理开始
   - 分离确定性和动态逻辑
   - 保持代理目标精准和范围狭窄

2. **实现原则**
   - 代理应该是无状态reducer
   - 尽快离开代理，返回确定性流程
   - 教会代理如何失败

3. **治理原则**
   - 使用系统提示作为护栏
   - 显式建模失败路径和升级策略
   - 版本控制和审计跟踪

4. **性能原则**
   - 缩小代理循环减少token消耗
   - 使用RAG而非提示整个知识库
   - 全局速率限制和并发控制

---

## 下一步行动

1. **生成第一个实战代码文件**: 基于以上研究内容生成 `07_实战代码_01_基础单代理执行.md`

2. **确保"有理有据"**: 所有技术点和最佳实践都引用实际案例和来源

3. **代码示例**: 提供完整的TypeScript代码示例，基于pi-mono的ExtensionAPI
