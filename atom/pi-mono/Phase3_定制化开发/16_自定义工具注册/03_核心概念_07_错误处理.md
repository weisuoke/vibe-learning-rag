# 核心概念 07：错误处理

> **健壮性保障 - 三层错误处理机制**

## 概述

错误处理是工具开发的关键环节。Pi-mono 提供三层错误处理机制：Schema 验证错误(自动)、业务逻辑错误(手动)、取消操作(AbortSignal)。理解这三层机制,可以编写出健壮可靠的工具。

---

## 三层错误处理

### 第一层：Schema 验证错误(自动)

**处理者**: TypeBox + 框架

**触发时机**: 工具执行前

**处理方式**: 自动验证参数,验证失败时工具不会被调用

**示例**:
```typescript
parameters: Type.Object({
  age: Type.Number({ minimum: 0, maximum: 120 })
})

// LLM 传入 age: 200
// 结果: TypeBox 验证失败,工具不会被调用
// LLM 收到错误信息: "Parameter 'age' must be between 0 and 120"
```

### 第二层：业务逻辑错误(手动)

**处理者**: execute 函数

**触发时机**: 工具执行中

**处理方式**: 使用 try-catch 捕获错误,返回友好的错误信息

**示例**:
```typescript
const execute = async ({ userId }, context) => {
  try {
    const user = await db.findUser(userId);
    if (!user) {
      return { content: 'Error: User not found' };
    }
    return { content: JSON.stringify(user) };
  } catch (error) {
    context.logger.error('Database error:', error);
    return { content: `Error: ${error.message}` };
  }
};
```

### 第三层：取消操作(AbortSignal)

**处理者**: execute 函数 + AbortSignal

**触发时机**: 用户取消操作

**处理方式**: 检查 signal.aborted,传递 signal 给异步操作

**示例**:
```typescript
const execute = async (params, context) => {
  const { signal } = context;
  
  try {
    const data = await fetch(url, { signal });
    
    if (signal.aborted) {
      return { content: 'Operation cancelled' };
    }
    
    return { content: data };
  } catch (error) {
    if (error.name === 'AbortError') {
      return { content: 'Cancelled by user' };
    }
    return { content: `Error: ${error.message}` };
  }
};
```

---

## 最佳实践

### 1. 充分利用 Schema 验证

```typescript
// ✅ 好的做法: 使用 Schema 约束
parameters: Type.Object({
  email: Type.String({ format: 'email' }),
  age: Type.Number({ minimum: 0, maximum: 120 }),
  role: Type.Union([
    Type.Literal('admin'),
    Type.Literal('user')
  ])
})

// ❌ 不好的做法: 缺少约束,需要在 execute 中验证
parameters: Type.Object({
  email: Type.String(),
  age: Type.Number(),
  role: Type.String()
})
```

### 2. 不要重复验证 Schema 已验证的内容

```typescript
// ❌ 不必要的验证
const execute = async ({ age }) => {
  if (typeof age !== 'number') {
    return { content: 'Invalid age' };
  }
  if (age < 0 || age > 120) {
    return { content: 'Age out of range' };
  }
  // ...
};

// ✅ 信任 Schema 验证
const execute = async ({ age }) => {
  // age 一定是有效的,直接使用
  return { content: `Age: ${age}` };
};
```

### 3. 业务逻辑验证仍然需要

```typescript
// Schema 验证: 类型和格式
parameters: Type.Object({
  startDate: Type.String({ format: 'date' }),
  endDate: Type.String({ format: 'date' })
})

// 业务逻辑验证: 日期关系
const execute = async ({ startDate, endDate }) => {
  if (new Date(startDate) > new Date(endDate)) {
    return { content: 'Error: Start date must be before end date' };
  }
  // ...
};
```

### 4. 友好的错误信息

```typescript
// ✅ 好的做法
return { content: 'Error: File not found. Please check the file path.' };

// ❌ 不好的做法
return { content: 'Error: ENOENT' };
```

### 5. 使用 metadata 标记错误

```typescript
return {
  content: 'Error: ...',
  metadata: {
    error: true,
    errorType: 'NotFound',
    errorCode: 404
  }
};
```

---

## 总结

**三层错误处理**:
1. **Schema 验证**: 自动,类型和格式
2. **业务逻辑**: 手动,业务规则
3. **取消操作**: AbortSignal,用户取消

**最佳实践**:
- 充分利用 Schema 验证
- 不要重复验证
- 业务逻辑验证仍然需要
- 友好的错误信息
- 使用 metadata 标记错误

理解三层错误处理机制,你就能编写出健壮可靠的工具!
