# 实战代码 03：API 包装器

> **将 REST API 包装为 MCP 工具，实现认证、限流和错误处理**

---

## 概述

API 包装器是 MCP 服务器的常见应用场景，将第三方 REST API 包装为 MCP 工具，让 AI 能够安全地调用外部服务。本文实现一个完整的 GitHub API 包装器。

```
API 包装器核心：
├─ 认证管理 → Token + OAuth
├─ 请求封装 → fetch + 参数验证
├─ 限流控制 → Rate limiting
└─ 错误处理 → 重试 + 降级
```

**本质**：API 包装器是 MCP 服务器与第三方 API 之间的适配层，通过标准化的工具接口让 AI 能够安全、高效地访问外部服务。

---

## GitHub API 包装器实现

### 项目初始化

```bash
# 创建项目
mkdir github-mcp-server
cd github-mcp-server

# 初始化并安装依赖
npm init -y
npm install @modelcontextprotocol/sdk dotenv
npm install -D typescript @types/node

# 创建目录结构
mkdir src
touch src/github-api.ts src/server.ts
```

### API 客户端封装

创建 `src/github-api.ts`:

```typescript
import dotenv from 'dotenv';

dotenv.config();

export interface GitHubRepo {
  id: number;
  name: string;
  full_name: string;
  description: string | null;
  html_url: string;
  stargazers_count: number;
  forks_count: number;
  language: string | null;
}

export interface GitHubIssue {
  id: number;
  number: number;
  title: string;
  state: string;
  html_url: string;
  created_at: string;
  updated_at: string;
}

export class GitHubAPIClient {
  private baseURL = 'https://api.github.com';
  private token: string;
  private requestCount = 0;
  private lastResetTime = Date.now();
  private readonly maxRequestsPerHour = 5000;

  constructor(token?: string) {
    this.token = token || process.env.GITHUB_TOKEN || '';
    if (!this.token) {
      console.error('Warning: No GitHub token provided. Rate limits will be lower.');
    }
  }

  /**
   * 通用 HTTP 请求方法
   */
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    // 检查限流
    await this.checkRateLimit();

    const url = `${this.baseURL}${endpoint}`;
    const headers: HeadersInit = {
      'Accept': 'application/vnd.github.v3+json',
      'User-Agent': 'MCP-GitHub-Server',
      ...options.headers,
    };

    if (this.token) {
      headers['Authorization'] = `Bearer ${this.token}`;
    }

    try {
      const response = await fetch(url, {
        ...options,
        headers,
      });

      // 更新限流计数
      this.requestCount++;

      // 检查响应状态
      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        throw new Error(
          `GitHub API error: ${response.status} ${response.statusText} - ${JSON.stringify(error)}`
        );
      }

      return await response.json() as T;
    } catch (error) {
      console.error(`Request failed for ${endpoint}:`, error);
      throw error;
    }
  }

  /**
   * 限流检查
   */
  private async checkRateLimit(): Promise<void> {
    const now = Date.now();
    const hourInMs = 60 * 60 * 1000;

    // 每小时重置计数
    if (now - this.lastResetTime > hourInMs) {
      this.requestCount = 0;
      this.lastResetTime = now;
    }

    // 检查是否超过限制
    if (this.requestCount >= this.maxRequestsPerHour) {
      const waitTime = hourInMs - (now - this.lastResetTime);
      console.error(`Rate limit exceeded. Waiting ${waitTime}ms...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
      this.requestCount = 0;
      this.lastResetTime = Date.now();
    }
  }

  /**
   * 搜索仓库
   */
  async searchRepositories(
    query: string,
    limit: number = 10
  ): Promise<GitHubRepo[]> {
    const data = await this.request<{ items: GitHubRepo[] }>(
      `/search/repositories?q=${encodeURIComponent(query)}&per_page=${limit}&sort=stars&order=desc`
    );
    return data.items;
  }

  /**
   * 获取仓库信息
   */
  async getRepository(owner: string, repo: string): Promise<GitHubRepo> {
    return await this.request<GitHubRepo>(`/repos/${owner}/${repo}`);
  }

  /**
   * 获取仓库 Issues
   */
  async getIssues(
    owner: string,
    repo: string,
    state: 'open' | 'closed' | 'all' = 'open',
    limit: number = 10
  ): Promise<GitHubIssue[]> {
    return await this.request<GitHubIssue[]>(
      `/repos/${owner}/${repo}/issues?state=${state}&per_page=${limit}`
    );
  }

  /**
   * 创建 Issue
   */
  async createIssue(
    owner: string,
    repo: string,
    title: string,
    body?: string
  ): Promise<GitHubIssue> {
    return await this.request<GitHubIssue>(
      `/repos/${owner}/${repo}/issues`,
      {
        method: 'POST',
        body: JSON.stringify({ title, body }),
      }
    );
  }

  /**
   * 获取用户信息
   */
  async getUser(username: string): Promise<any> {
    return await this.request<any>(`/users/${username}`);
  }

  /**
   * 获取限流状态
   */
  async getRateLimitStatus(): Promise<any> {
    return await this.request<any>('/rate_limit');
  }
}
```

### MCP 服务器实现

创建 `src/server.ts`:

```typescript
#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { GitHubAPIClient } from './github-api.js';

// 创建服务器实例
const server = new Server({
  name: 'github-mcp-server',
  version: '1.0.0',
}, {
  capabilities: {
    tools: {},
  },
});

// 创建 GitHub API 客户端
const github = new GitHubAPIClient();

// 注册工具列表
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: 'search_repositories',
      description: 'Search GitHub repositories by query',
      inputSchema: {
        type: 'object',
        properties: {
          query: {
            type: 'string',
            description: 'Search query (e.g., "language:typescript stars:>1000")',
          },
          limit: {
            type: 'number',
            description: 'Maximum number of results (default: 10)',
            default: 10,
          },
        },
        required: ['query'],
      },
    },
    {
      name: 'get_repository',
      description: 'Get detailed information about a repository',
      inputSchema: {
        type: 'object',
        properties: {
          owner: {
            type: 'string',
            description: 'Repository owner (username or organization)',
          },
          repo: {
            type: 'string',
            description: 'Repository name',
          },
        },
        required: ['owner', 'repo'],
      },
    },
    {
      name: 'get_issues',
      description: 'Get issues from a repository',
      inputSchema: {
        type: 'object',
        properties: {
          owner: {
            type: 'string',
            description: 'Repository owner',
          },
          repo: {
            type: 'string',
            description: 'Repository name',
          },
          state: {
            type: 'string',
            description: 'Issue state',
            enum: ['open', 'closed', 'all'],
            default: 'open',
          },
          limit: {
            type: 'number',
            description: 'Maximum number of issues',
            default: 10,
          },
        },
        required: ['owner', 'repo'],
      },
    },
    {
      name: 'create_issue',
      description: 'Create a new issue in a repository',
      inputSchema: {
        type: 'object',
        properties: {
          owner: {
            type: 'string',
            description: 'Repository owner',
          },
          repo: {
            type: 'string',
            description: 'Repository name',
          },
          title: {
            type: 'string',
            description: 'Issue title',
          },
          body: {
            type: 'string',
            description: 'Issue body (optional)',
          },
        },
        required: ['owner', 'repo', 'title'],
      },
    },
    {
      name: 'get_rate_limit',
      description: 'Get current GitHub API rate limit status',
      inputSchema: {
        type: 'object',
        properties: {},
        required: [],
      },
    },
  ],
}));

// 注册工具执行处理器
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'search_repositories': {
        const { query, limit = 10 } = args as any;
        const repos = await github.searchRepositories(query, limit);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(repos, null, 2),
            },
          ],
        };
      }

      case 'get_repository': {
        const { owner, repo } = args as any;
        const repository = await github.getRepository(owner, repo);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(repository, null, 2),
            },
          ],
        };
      }

      case 'get_issues': {
        const { owner, repo, state = 'open', limit = 10 } = args as any;
        const issues = await github.getIssues(owner, repo, state, limit);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(issues, null, 2),
            },
          ],
        };
      }

      case 'create_issue': {
        const { owner, repo, title, body } = args as any;
        const issue = await github.createIssue(owner, repo, title, body);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(issue, null, 2),
            },
          ],
        };
      }

      case 'get_rate_limit': {
        const status = await github.getRateLimitStatus();
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(status, null, 2),
            },
          ],
        };
      }

      default:
        return {
          content: [
            {
              type: 'text',
              text: `Unknown tool: ${name}`,
            },
          ],
          isError: true,
        };
    }
  } catch (error) {
    console.error(`Error executing tool ${name}:`, error);
    return {
      content: [
        {
          type: 'text',
          text: `Error: ${error instanceof Error ? error.message : String(error)}`,
        },
      ],
      isError: true,
    };
  }
});

// 启动服务器
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('GitHub MCP Server running on stdio');
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
```

### 环境配置

创建 `.env`:

```bash
# GitHub Personal Access Token
GITHUB_TOKEN=ghp_your_token_here
```

---

## 高级特性

### 重试机制

```typescript
/**
 * 带重试的请求方法
 */
private async requestWithRetry<T>(
  endpoint: string,
  options: RequestInit = {},
  maxRetries: number = 3
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await this.request<T>(endpoint, options);
    } catch (error) {
      lastError = error as Error;
      console.error(`Attempt ${attempt + 1} failed:`, error);

      // 指数退避
      if (attempt < maxRetries - 1) {
        const delay = Math.pow(2, attempt) * 1000;
        console.error(`Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError;
}
```

### 响应缓存

```typescript
export class CachedGitHubAPIClient extends GitHubAPIClient {
  private cache = new Map<string, { data: any; timestamp: number }>();
  private readonly cacheTTL = 5 * 60 * 1000; // 5 分钟

  async searchRepositories(query: string, limit: number = 10): Promise<GitHubRepo[]> {
    const cacheKey = `search:${query}:${limit}`;
    const cached = this.cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      console.error('Cache hit:', cacheKey);
      return cached.data;
    }

    const data = await super.searchRepositories(query, limit);
    this.cache.set(cacheKey, { data, timestamp: Date.now() });
    return data;
  }
}
```

### 批量请求

```typescript
/**
 * 批量获取仓库信息
 */
async getRepositoriesBatch(
  repos: Array<{ owner: string; repo: string }>
): Promise<GitHubRepo[]> {
  const promises = repos.map(({ owner, repo }) =>
    this.getRepository(owner, repo).catch(error => {
      console.error(`Failed to fetch ${owner}/${repo}:`, error);
      return null;
    })
  );

  const results = await Promise.all(promises);
  return results.filter((repo): repo is GitHubRepo => repo !== null);
}
```

---

## 测试与部署

### 本地测试

```bash
# 构建项目
npm run build

# 设置环境变量
export GITHUB_TOKEN=ghp_your_token_here

# 启动服务器
npm start
```

### Claude Desktop 配置

```json
{
  "mcpServers": {
    "github": {
      "command": "node",
      "args": [
        "/absolute/path/to/github-mcp-server/dist/server.js"
      ],
      "env": {
        "GITHUB_TOKEN": "ghp_your_token_here"
      }
    }
  }
}
```

### 测试查询

在 Claude Desktop 中测试：

```
1. "Search for TypeScript repositories with more than 10000 stars"
2. "Get information about the microsoft/typescript repository"
3. "Show me open issues in facebook/react"
4. "What's my current GitHub API rate limit?"
```

---

## 最佳实践

### 认证管理

```typescript
// ✅ 使用环境变量
const token = process.env.GITHUB_TOKEN;

// ✅ 支持多种认证方式
class GitHubAPIClient {
  constructor(auth?: { token?: string; username?: string; password?: string }) {
    if (auth?.token) {
      this.headers['Authorization'] = `Bearer ${auth.token}`;
    } else if (auth?.username && auth?.password) {
      const encoded = Buffer.from(`${auth.username}:${auth.password}`).toString('base64');
      this.headers['Authorization'] = `Basic ${encoded}`;
    }
  }
}
```

### 限流控制

```typescript
// ✅ 客户端限流
private requestQueue: Array<() => Promise<any>> = [];
private activeRequests = 0;
private readonly maxConcurrent = 10;

async enqueueRequest<T>(fn: () => Promise<T>): Promise<T> {
  while (this.activeRequests >= this.maxConcurrent) {
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  this.activeRequests++;
  try {
    return await fn();
  } finally {
    this.activeRequests--;
  }
}
```

### 错误处理

```typescript
// ✅ 详细的错误信息
catch (error) {
  if (error instanceof Error) {
    if (error.message.includes('404')) {
      return {
        content: [{
          type: 'text',
          text: 'Repository not found. Please check the owner and repo name.'
        }],
        isError: true
      };
    } else if (error.message.includes('403')) {
      return {
        content: [{
          type: 'text',
          text: 'Rate limit exceeded or insufficient permissions.'
        }],
        isError: true
      };
    }
  }

  return {
    content: [{
      type: 'text',
      text: `Unexpected error: ${error}`
    }],
    isError: true
  };
}
```

---

## 总结

### 核心要点

1. **API 封装**：统一的 request 方法处理所有 HTTP 请求
2. **认证管理**：支持 Token 和 Basic Auth
3. **限流控制**：客户端限流 + 服务端限流检查
4. **错误处理**：重试机制 + 详细错误信息
5. **响应缓存**：减少 API 调用次数

### 关键约束

- ✅ 使用环境变量存储敏感信息
- ✅ 实现客户端限流控制
- ✅ 添加重试机制处理临时错误
- ✅ 缓存频繁访问的数据
- ✅ 提供详细的错误信息

### 下一步

- 阅读 [07_实战代码_04_高级Server特性](./07_实战代码_04_高级Server特性.md) 学习高级特性
- 阅读 [07_实战代码_05_基础Extension开发](./07_实战代码_05_基础Extension开发.md) 学习扩展开发

---

**参考资源**：
- [GitHub REST API Documentation](https://docs.github.com/en/rest)
- [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
