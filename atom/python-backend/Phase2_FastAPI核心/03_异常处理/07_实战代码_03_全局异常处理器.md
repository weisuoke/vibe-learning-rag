# 实战代码3：全局异常处理器

> 完整可运行的全局异常处理器示例，统一错误响应格式

---

## 示例概述

本示例演示：
1. 使用全局异常中间件统一处理所有异常
2. 自动添加 request_id 追踪每个请求
3. 记录详细的错误日志
4. 根据环境返回不同的错误信息（开发/生产）

---

## 完整代码

```python
"""
FastAPI 全局异常处理器示例
演示：如何使用中间件实现统一的错误处理架构
"""

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from sqlalchemy.exc import SQLAlchemyError
from pydantic import BaseModel
from datetime import datetime
from typing import Optional
import logging
import uuid
import time
import traceback

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ===== 配置 =====
class Settings:
    DEBUG = True  # 开发环境设置为 True，生产环境设置为 False
    LOG_LEVEL = "INFO"

settings = Settings()

# ===== 全局异常处理中间件 =====

class GlobalErrorHandlingMiddleware(BaseHTTPMiddleware):
    """
    全局异常处理中间件
    功能：
    1. 为每个请求添加 request_id
    2. 记录请求日志
    3. 捕获所有异常并统一处理
    4. 根据环境返回不同的错误信息
    """

    async def dispatch(self, request: Request, call_next):
        # 1. 生成请求 ID
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        # 2. 记录请求开始
        start_time = time.time()
        logger.info(
            f"请求开始: {request.method} {request.url.path}",
            extra={
                "request_id": request_id,
                "method": request.method,
                "path": request.url.path,
                "client_ip": request.client.host
            }
        )

        try:
            # 3. 执行请求处理
            response = await call_next(request)

            # 4. 记录请求成功
            duration = time.time() - start_time
            logger.info(
                f"请求成功: {request.method} {request.url.path} "
                f"[{response.status_code}] {duration:.3f}s",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "status_code": response.status_code,
                    "duration": duration
                }
            )

            # 5. 添加响应头
            response.headers["X-Request-ID"] = request_id
            response.headers["X-Response-Time"] = f"{duration:.3f}s"
            return response

        except HTTPException as exc:
            # 6. 处理 HTTPException
            duration = time.time() - start_time
            logger.warning(
                f"HTTP 异常: {request.method} {request.url.path} "
                f"[{exc.status_code}] {exc.detail}",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "status_code": exc.status_code,
                    "duration": duration
                }
            )

            return self._create_error_response(
                status_code=exc.status_code,
                error=exc.detail,
                code="HTTP_ERROR",
                request_id=request_id,
                request=request
            )

        except SQLAlchemyError as exc:
            # 7. 处理数据库异常
            duration = time.time() - start_time
            logger.error(
                f"数据库异常: {request.method} {request.url.path} - {exc}",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "duration": duration,
                    "exception_type": type(exc).__name__
                },
                exc_info=True
            )

            return self._create_error_response(
                status_code=500,
                error="数据库操作失败，请稍后重试",
                code="DATABASE_ERROR",
                request_id=request_id,
                request=request,
                exception=exc
            )

        except ValueError as exc:
            # 8. 处理参数错误
            duration = time.time() - start_time
            logger.warning(
                f"参数错误: {request.method} {request.url.path} - {exc}",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "duration": duration
                }
            )

            return self._create_error_response(
                status_code=400,
                error=str(exc),
                code="VALIDATION_ERROR",
                request_id=request_id,
                request=request
            )

        except Exception as exc:
            # 9. 处理所有其他异常
            duration = time.time() - start_time
            logger.error(
                f"未处理的异常: {request.method} {request.url.path} - {exc}",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "duration": duration,
                    "exception_type": type(exc).__name__
                },
                exc_info=True
            )

            return self._create_error_response(
                status_code=500,
                error="服务器内部错误",
                code="INTERNAL_ERROR",
                request_id=request_id,
                request=request,
                exception=exc
            )

    def _create_error_response(
        self,
        status_code: int,
        error: str,
        code: str,
        request_id: str,
        request: Request,
        exception: Exception = None
    ):
        """创建统一的错误响应"""
        # 基础响应内容
        content = {
            "success": False,
            "error": error,
            "code": code,
            "request_id": request_id,
            "timestamp": datetime.utcnow().isoformat(),
            "path": request.url.path,
            "method": request.method
        }

        # 开发环境：添加详细错误信息
        if settings.DEBUG and exception:
            content["debug"] = {
                "exception_type": type(exception).__name__,
                "exception_message": str(exception),
                "traceback": traceback.format_exc()
            }

        return JSONResponse(
            status_code=status_code,
            content=content,
            headers={"X-Request-ID": request_id}
        )


# ===== 创建 FastAPI 应用 =====
app = FastAPI(title="全局异常处理器示例")

# 注册全局异常处理中间件
app.add_middleware(GlobalErrorHandlingMiddleware)

# ===== 模拟数据库 =====
users_db = {
    1: {"id": 1, "name": "Alice", "email": "alice@example.com"},
    2: {"id": 2, "name": "Bob", "email": "bob@example.com"},
}

# ===== Pydantic 模型 =====
class UserCreate(BaseModel):
    name: str
    email: str

# ===== 路由示例 =====

@app.get("/")
async def root():
    """API 根路径"""
    return {
        "message": "FastAPI 全局异常处理器示例",
        "endpoints": {
            "users": "/users",
            "error": "/error/*"
        }
    }

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    """获取用户信息（会抛出 HTTPException）"""
    logger.info(f"获取用户: {user_id}")

    user = users_db.get(user_id)
    if not user:
        raise HTTPException(
            status_code=404,
            detail=f"用户 {user_id} 不存在"
        )

    return user

@app.post("/users")
async def create_user(user: UserCreate):
    """创建用户（会抛出 ValueError）"""
    logger.info(f"创建用户: {user.email}")

    # 检查邮箱是否已存在
    for existing_user in users_db.values():
        if existing_user["email"] == user.email:
            raise ValueError(f"邮箱 {user.email} 已被注册")

    # 创建新用户
    new_id = max(users_db.keys()) + 1
    new_user = {
        "id": new_id,
        "name": user.name,
        "email": user.email
    }
    users_db[new_id] = new_user

    return {"message": "用户创建成功", "user": new_user}

@app.get("/error/division")
async def division_error(a: int, b: int):
    """模拟除零错误（会抛出 ZeroDivisionError）"""
    logger.info(f"计算 {a} / {b}")
    result = a / b
    return {"result": result}

@app.get("/error/exception")
async def general_exception():
    """模拟一般异常（会抛出 Exception）"""
    logger.info("模拟一般异常")
    raise Exception("这是一个模拟的异常")

@app.get("/error/database")
async def database_error():
    """模拟数据库异常（会抛出 SQLAlchemyError）"""
    logger.info("模拟数据库异常")
    from sqlalchemy.exc import OperationalError
    raise OperationalError("数据库连接失败", None, None)

@app.get("/health")
async def health_check():
    """健康检查端点（不会抛出异常）"""
    return {
        "status": "ok",
        "timestamp": datetime.utcnow().isoformat()
    }


if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("FastAPI 全局异常处理器示例")
    print("=" * 50)
    print(f"\n环境: {'开发' if settings.DEBUG else '生产'}")
    print("启动服务器...")
    print("访问 http://localhost:8000/docs 查看 API 文档\n")

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 运行示例

### 1. 运行服务器

```bash
python examples/fastapi_global_error_handler.py
```

---

### 2. 测试各种异常场景

#### 场景1：HTTPException

```bash
curl http://localhost:8000/users/999
```

**响应（开发环境）：**
```json
{
  "success": false,
  "error": "用户 999 不存在",
  "code": "HTTP_ERROR",
  "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "timestamp": "2026-02-11T09:30:00.000Z",
  "path": "/users/999",
  "method": "GET"
}
```

---

#### 场景2：ValueError

```bash
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Alice2",
    "email": "alice@example.com"
  }'
```

**响应：**
```json
{
  "success": false,
  "error": "邮箱 alice@example.com 已被注册",
  "code": "VALIDATION_ERROR",
  "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "timestamp": "2026-02-11T09:30:00.000Z",
  "path": "/users",
  "method": "POST"
}
```

---

#### 场景3：ZeroDivisionError

```bash
curl "http://localhost:8000/error/division?a=10&b=0"
```

**响应（开发环境）：**
```json
{
  "success": false,
  "error": "服务器内部错误",
  "code": "INTERNAL_ERROR",
  "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "timestamp": "2026-02-11T09:30:00.000Z",
  "path": "/error/division",
  "method": "GET",
  "debug": {
    "exception_type": "ZeroDivisionError",
    "exception_message": "division by zero",
    "traceback": "Traceback (most recent call last):\n  ..."
  }
}
```

**响应（生产环境）：**
```json
{
  "success": false,
  "error": "服务器内部错误",
  "code": "INTERNAL_ERROR",
  "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "timestamp": "2026-02-11T09:30:00.000Z",
  "path": "/error/division",
  "method": "GET"
}
```

---

#### 场景4：数据库异常

```bash
curl http://localhost:8000/error/database
```

**响应：**
```json
{
  "success": false,
  "error": "数据库操作失败，请稍后重试",
  "code": "DATABASE_ERROR",
  "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "timestamp": "2026-02-11T09:30:00.000Z",
  "path": "/error/database",
  "method": "GET"
}
```

---

## 关键知识点

### 1. 全局异常中间件的结构

```python
class GlobalErrorHandlingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # 1. 请求前处理（添加 request_id）
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        try:
            # 2. 执行请求
            response = await call_next(request)

            # 3. 请求后处理（添加响应头）
            response.headers["X-Request-ID"] = request_id
            return response

        except Exception as exc:
            # 4. 异常处理
            return self._create_error_response(...)
```

---

### 2. 区分不同类型的异常

```python
try:
    response = await call_next(request)
    return response

except HTTPException as exc:
    # 处理 HTTPException
    return self._create_error_response(status_code=exc.status_code, ...)

except SQLAlchemyError as exc:
    # 处理数据库异常
    return self._create_error_response(status_code=500, code="DATABASE_ERROR", ...)

except ValueError as exc:
    # 处理参数错误
    return self._create_error_response(status_code=400, code="VALIDATION_ERROR", ...)

except Exception as exc:
    # 处理所有其他异常
    return self._create_error_response(status_code=500, code="INTERNAL_ERROR", ...)
```

---

### 3. 统一的错误响应格式

```python
{
  "success": false,
  "error": "错误信息",
  "code": "错误码",
  "request_id": "请求 ID",
  "timestamp": "时间戳",
  "path": "请求路径",
  "method": "请求方法",
  "debug": {  // 仅开发环境
    "exception_type": "异常类型",
    "exception_message": "异常消息",
    "traceback": "堆栈跟踪"
  }
}
```

---

### 4. 根据环境返回不同的错误信息

```python
# 开发环境：返回详细错误
if settings.DEBUG and exception:
    content["debug"] = {
        "exception_type": type(exception).__name__,
        "exception_message": str(exception),
        "traceback": traceback.format_exc()
    }

# 生产环境：只返回通用错误
else:
    content["error"] = "服务器内部错误"
```

---

### 5. 记录详细的日志

```python
logger.error(
    f"未处理的异常: {request.method} {request.url.path} - {exc}",
    extra={
        "request_id": request_id,
        "method": request.method,
        "path": request.url.path,
        "duration": duration,
        "exception_type": type(exc).__name__
    },
    exc_info=True  # 包含完整的堆栈跟踪
)
```

---

### 6. 添加响应头

```python
response.headers["X-Request-ID"] = request_id
response.headers["X-Response-Time"] = f"{duration:.3f}s"
```

---

## 最佳实践

### 1. 为每个请求添加 request_id

```python
# ✅ 好：自动添加 request_id
request_id = str(uuid.uuid4())
request.state.request_id = request_id

# 在日志中使用
logger.info(f"请求开始", extra={"request_id": request_id})

# 在响应中返回
response.headers["X-Request-ID"] = request_id
```

---

### 2. 记录请求时长

```python
# ✅ 好：记录请求时长
start_time = time.time()
response = await call_next(request)
duration = time.time() - start_time

logger.info(f"请求成功 {duration:.3f}s")
response.headers["X-Response-Time"] = f"{duration:.3f}s"
```

---

### 3. 根据环境返回不同的错误信息

```python
# ✅ 好：生产环境不暴露详细错误
if settings.DEBUG:
    content["debug"] = {
        "exception_type": type(exception).__name__,
        "traceback": traceback.format_exc()
    }

# ❌ 差：生产环境也返回详细错误
content["debug"] = {
    "exception_type": type(exception).__name__,
    "traceback": traceback.format_exc()
}
```

---

### 4. 记录详细的日志

```python
# ✅ 好：记录详细日志
logger.error(
    f"异常: {exc}",
    extra={
        "request_id": request_id,
        "path": request.url.path,
        "method": request.method
    },
    exc_info=True  # 包含堆栈跟踪
)

# ❌ 差：只记录简单日志
logger.error(f"异常: {exc}")
```

---

### 5. 区分不同类型的异常

```python
# ✅ 好：区分不同类型的异常
except HTTPException as exc:
    # 处理 HTTPException
    ...
except SQLAlchemyError as exc:
    # 处理数据库异常
    ...
except Exception as exc:
    # 处理其他异常
    ...

# ❌ 差：所有异常都一样处理
except Exception as exc:
    # 所有异常都返回 500
    ...
```

---

## 小结

全局异常处理中间件的核心价值：

1. **统一处理**：所有异常都经过中间件，统一处理
2. **request_id**：自动添加 request_id，便于追踪
3. **详细日志**：记录所有请求和异常的详细信息
4. **环境区分**：开发环境返回详细错误，生产环境返回通用错误
5. **响应头**：自动添加 X-Request-ID、X-Response-Time 等响应头

**下一步：** 学习如何在 AI Agent 开发中应用异常处理。
