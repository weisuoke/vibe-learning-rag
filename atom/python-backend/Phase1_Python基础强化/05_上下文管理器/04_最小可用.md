# 最小可用

掌握以下内容，就能开始使用上下文管理器：

---

## 4.1 使用 `with` 语句管理文件

**核心：** `with` 语句自动关闭文件，无需手动调用 `close()`

```python
# ✅ 推荐：使用 with 语句
with open("data.txt", "r") as f:
    content = f.read()
    print(content)
# 文件自动关闭

# ❌ 不推荐：手动关闭
f = open("data.txt", "r")
content = f.read()
f.close()  # 容易忘记，且异常时不会执行
```

**实际应用：** 在 AI Agent 后端读取配置文件、日志文件

```python
# 读取 AI Agent 的配置文件
with open("config.json", "r") as f:
    config = json.load(f)
    api_key = config["openai_api_key"]
```

---

## 4.2 理解 `__enter__` 和 `__exit__` 协议

**核心：** 任何实现了这两个方法的对象都可以用 `with` 语句

```python
class DatabaseConnection:
    def __enter__(self):
        """进入 with 块时调用，返回值赋给 as 后的变量"""
        print("Connecting to database...")
        self.conn = create_connection()
        return self.conn

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出 with 块时调用，无论是否异常"""
        print("Closing database connection...")
        self.conn.close()
        return False  # False 表示不抑制异常

# 使用
with DatabaseConnection() as conn:
    conn.execute("SELECT * FROM users")
# 连接自动关闭
```

**关键点：**
- `__enter__` 的返回值 → `as` 后的变量
- `__exit__` 总是会执行（类似 `finally`）
- `__exit__` 返回 `True` 可以抑制异常

**实际应用：** FastAPI 中的数据库会话管理

---

## 4.3 使用 `@contextmanager` 装饰器快速创建

**核心：** 用生成器函数 + `@contextmanager` 装饰器，无需写类

```python
from contextlib import contextmanager

@contextmanager
def timer():
    """计时器上下文管理器"""
    import time
    start = time.time()
    yield  # yield 前是 __enter__，yield 后是 __exit__
    end = time.time()
    print(f"Execution time: {end - start:.2f}s")

# 使用
with timer():
    # 执行耗时操作
    result = expensive_computation()
# 自动打印执行时间
```

**模式：**
```python
@contextmanager
def my_context():
    # 1. 资源获取（__enter__）
    resource = acquire_resource()

    try:
        yield resource  # 2. 提供给 with 块使用
    finally:
        # 3. 资源释放（__exit__）
        release_resource(resource)
```

**实际应用：** 临时修改配置、性能监控、日志上下文

```python
@contextmanager
def temp_config(key, value):
    """临时修改配置"""
    old_value = config[key]
    config[key] = value
    try:
        yield
    finally:
        config[key] = old_value  # 恢复原值

# 使用
with temp_config("debug", True):
    # 在这个范围内 debug=True
    run_tests()
# debug 自动恢复为原值
```

---

## 4.4 处理异常情况

**核心：** `__exit__` 方法接收异常信息，可以选择抑制或传播

```python
class ErrorHandler:
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            print("No exception occurred")
            return False

        if exc_type is ValueError:
            print(f"Caught ValueError: {exc_val}")
            return True  # 抑制 ValueError

        # 其他异常不抑制
        return False

# 使用
with ErrorHandler():
    raise ValueError("This will be suppressed")
# 程序继续执行

with ErrorHandler():
    raise TypeError("This will propagate")
# 程序崩溃
```

**`__exit__` 参数说明：**
- `exc_type`: 异常类型（如 `ValueError`）
- `exc_val`: 异常实例（异常对象）
- `exc_tb`: 异常追踪信息（traceback）
- 返回 `True`: 抑制异常（不向外传播）
- 返回 `False`: 传播异常（正常抛出）

**实际应用：** 数据库事务管理

```python
@contextmanager
def transaction(db):
    """数据库事务上下文管理器"""
    try:
        yield db
        db.commit()  # 成功则提交
    except Exception as e:
        db.rollback()  # 失败则回滚
        raise  # 重新抛出异常

# 使用
with transaction(db):
    db.execute("INSERT INTO users ...")
    db.execute("UPDATE accounts ...")
# 自动提交或回滚
```

---

## 4.5 嵌套使用多个上下文管理器

**核心：** 可以嵌套或在一行中使用多个上下文管理器

```python
# 方式1：嵌套写法
with open("input.txt") as infile:
    with open("output.txt", "w") as outfile:
        outfile.write(infile.read())

# 方式2：一行写法（Python 3.1+）
with open("input.txt") as infile, open("output.txt", "w") as outfile:
    outfile.write(infile.read())
```

**实际应用：** 同时管理多个资源

```python
# FastAPI 中同时使用数据库和缓存
with get_db() as db, get_redis() as cache:
    # 先查缓存
    cached = cache.get(f"user:{user_id}")
    if cached:
        return cached

    # 缓存未命中，查数据库
    user = db.query(User).filter(User.id == user_id).first()
    cache.set(f"user:{user_id}", user)
    return user
```

---

## 这些知识足以：

- ✅ 使用 `with` 语句管理文件、数据库连接等资源
- ✅ 理解上下文管理器的工作原理（`__enter__` 和 `__exit__`）
- ✅ 使用 `@contextmanager` 快速创建自定义上下文管理器
- ✅ 处理上下文管理器中的异常情况
- ✅ 在 FastAPI 项目中管理数据库会话
- ✅ 为后续学习 SQLAlchemy Session 管理打基础

---

## 快速参考卡

```python
# 1. 使用内置上下文管理器
with open("file.txt") as f:
    data = f.read()

# 2. 自定义类实现
class MyContext:
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        return False

# 3. 使用 @contextmanager
from contextlib import contextmanager

@contextmanager
def my_context():
    # setup
    yield resource
    # cleanup

# 4. 异常处理
def __exit__(self, exc_type, exc_val, exc_tb):
    if exc_type is ValueError:
        return True  # 抑制异常
    return False  # 传播异常

# 5. 多个上下文管理器
with ctx1() as a, ctx2() as b:
    pass
```

---

**版本：** v1.0
**最后更新：** 2026-02-11
