# 化骨绵掌

> 10个2分钟知识卡片，系统掌握后台任务

---

## 卡片1：直觉理解

**一句话：** 后台任务就是"先给用户回复，再慢慢做事"。

**举例：**
```python
# 没有后台任务：用户等5秒
@app.post("/register")
async def register(email: str):
    create_user(email)        # 0.1秒
    send_email(email)         # 4.9秒 ← 用户在等
    return {"status": "ok"}   # 5秒后返回

# 有后台任务：用户等0.1秒
@app.post("/register")
async def register(email: str, bg: BackgroundTasks):
    create_user(email)                    # 0.1秒
    bg.add_task(send_email, email)        # 立即返回
    return {"status": "ok"}               # 0.1秒返回
```

**应用：** 在 AI Agent 中，用户上传文档后立即确认，文档解析在后台进行。

---

## 卡片2：形式化定义

**一句话：** BackgroundTasks 是 FastAPI 提供的进程内后台任务执行器，在 HTTP 响应返回后按顺序执行添加的任务。

**精确表述：**
```python
class BackgroundTasks:
    def add_task(
        self,
        func: Callable,      # 任务函数
        *args: Any,          # 位置参数
        **kwargs: Any        # 关键字参数
    ) -> None:
        """添加任务到队列，响应返回后执行"""
```

**关键特性：**
- 进程内执行（无需额外服务）
- 顺序执行（非并发）
- 与请求生命周期绑定
- 支持同步和异步函数

**应用：** 理解这些特性帮助你选择合适的使用场景。

---

## 卡片3：add_task 方法

**一句话：** `add_task()` 是添加后台任务的唯一方法，支持传递任意参数。

**用法：**
```python
# 基础用法
background_tasks.add_task(func)

# 传递位置参数
background_tasks.add_task(func, arg1, arg2)

# 传递关键字参数
background_tasks.add_task(func, arg1, key=value)

# 混合参数
background_tasks.add_task(
    send_email,
    "user@example.com",           # 位置参数
    subject="欢迎",                # 关键字参数
    body="感谢注册"
)
```

**注意：** 参数在任务执行时才传递，不是添加时。

**应用：** 灵活传递参数，适应不同任务需求。

---

## 卡片4：执行时机和生命周期

**一句话：** 后台任务在响应返回后、连接关闭前执行。

**生命周期：**
```
1. 请求到达
   ↓
2. 路由函数执行
   ↓
3. add_task() 添加任务到队列
   ↓
4. 返回响应（用户收到）
   ↓
5. 执行后台任务（顺序执行）
   ↓
6. 关闭连接
```

**时间线：**
```python
@app.post("/action")
async def action(bg: BackgroundTasks):
    print("1. 路由函数开始")
    bg.add_task(task1)
    bg.add_task(task2)
    print("2. 返回响应")
    return {"status": "ok"}
    # 3. task1 执行
    # 4. task2 执行
    # 5. 连接关闭
```

**应用：** 理解执行时机，避免依赖请求上下文。

---

## 卡片5：编程实现

**一句话：** 通过依赖注入获取 BackgroundTasks，添加任务函数。

**完整示例：**
```python
from fastapi import FastAPI, BackgroundTasks
import time

app = FastAPI()

# 定义任务函数
def write_log(message: str):
    time.sleep(2)  # 模拟耗时操作
    with open("log.txt", "a") as f:
        f.write(f"{message}\n")

# 在路由中使用
@app.post("/action")
async def do_action(
    action_name: str,
    background_tasks: BackgroundTasks  # 依赖注入
):
    # 添加后台任务
    background_tasks.add_task(write_log, f"执行了 {action_name}")

    # 立即返回
    return {"message": "操作成功"}
```

**应用：** 这是最基础的使用模式，适用于90%的场景。

---

## 卡片6：BackgroundTasks vs Celery

**一句话：** BackgroundTasks 简单但功能有限，Celery 复杂但功能强大。

**对比：**

| 特性 | BackgroundTasks | Celery |
|------|----------------|--------|
| 部署 | 无需额外服务 | 需要 Redis/RabbitMQ + Worker |
| 任务持久化 | ❌ 无 | ✅ 持久化到消息队列 |
| 重试机制 | ❌ 无 | ✅ 自动重试 |
| 定时任务 | ❌ 无 | ✅ 支持 |
| 分布式 | ❌ 单进程 | ✅ 多 Worker |
| 适用场景 | < 30秒的简单任务 | 长时间、关键任务 |

**选择标准：**
```python
if 任务时间 < 30秒 and 失败可接受:
    使用 BackgroundTasks
else:
    使用 Celery
```

**应用：** 根据场景选择合适的工具。

---

## 卡片7：异步后台任务

**一句话：** 后台任务可以是异步函数，适合 I/O 密集型操作。

**同步 vs 异步：**
```python
# 同步任务（阻塞）
def sync_task():
    time.sleep(5)  # 阻塞5秒
    print("完成")

# 异步任务（不阻塞）
async def async_task():
    await asyncio.sleep(5)  # 不阻塞
    print("完成")

@app.post("/task")
async def create_task(bg: BackgroundTasks):
    # 两种都可以
    bg.add_task(sync_task)
    bg.add_task(async_task)
    return {"status": "ok"}
```

**何时用异步：**
- ✅ 网络请求（调用外部 API）
- ✅ 数据库查询
- ✅ 文件 I/O
- ❌ CPU 密集型计算（用同步）

**应用：** 异步任务提高并发性能，不阻塞事件循环。

---

## 卡片8：错误处理和监控

**一句话：** 后台任务失败不会影响响应，必须主动添加错误处理。

**错误处理模式：**
```python
import logging
from functools import wraps

logger = logging.getLogger(__name__)

def safe_task(func):
    """装饰器：为任务添加错误处理"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            if asyncio.iscoroutinefunction(func):
                return await func(*args, **kwargs)
            else:
                return func(*args, **kwargs)
        except Exception as e:
            logger.error(f"任务失败: {func.__name__}, 错误: {e}")
            # 可选：记录到数据库，稍后重试
    return wrapper

@safe_task
async def send_email(email: str):
    # 任务逻辑
    pass
```

**监控指标：**
- 任务执行时间
- 成功率/失败率
- 失败原因

**应用：** 生产环境必须有错误处理和监控。

---

## 卡片9：在 AI Agent 中的使用

**一句话：** AI Agent 中用后台任务处理文档解析、Embedding 生成、日志记录等耗时操作。

**典型场景：**

**场景1：文档上传处理**
```python
@app.post("/upload")
async def upload(file: UploadFile, bg: BackgroundTasks):
    # 快速保存文件
    file_path = await save_file(file)

    # 后台处理
    async def process():
        text = extract_text(file_path)
        embedding = await generate_embedding(text)
        await store_to_vectordb(embedding)

    bg.add_task(process)
    return {"message": "上传成功，正在处理"}
```

**场景2：对话日志记录**
```python
@app.post("/chat")
async def chat(message: str, bg: BackgroundTasks):
    response = await generate_response(message)

    # 后台记录日志
    bg.add_task(log_conversation, message, response)

    return {"response": response}
```

**应用：** 提升用户体验，快速响应 + 后台处理。

---

## 卡片10：总结与延伸

**一句话：** BackgroundTasks 是 FastAPI 的轻量级后台任务方案，适合简单场景，复杂场景需要 Celery。

**核心要点：**
1. **本质**：响应后执行的函数调用
2. **优势**：简单、无需额外服务
3. **限制**：无持久化、无重试、顺序执行
4. **适用**：< 30秒、失败可接受的任务
5. **注意**：错误处理、资源管理、执行时机

**延伸学习：**
- → **Celery**：分布式任务队列（Phase5）
- → **流式响应**：实时输出 AI 生成内容
- → **WebSocket**：双向实时通信
- → **APScheduler**：定时任务调度

**实战建议：**
1. 从 BackgroundTasks 开始，满足大部分需求
2. 遇到长时间任务时，再引入 Celery
3. 生产环境必须有错误处理和监控
4. 任务应该自包含，不依赖请求上下文

**记住：** 后台任务是优化用户体验的工具，不是万能的异步方案。

---

**版本：** v1.0
**最后更新：** 2026-02-11
