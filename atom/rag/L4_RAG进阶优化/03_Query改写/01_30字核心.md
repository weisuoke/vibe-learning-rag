# 30字核心

**Query改写是在检索前优化用户查询的技术集合，通过HyDE、Multi-Query、Query Expansion等6大策略弥合查询-文档语义鸿沟,2025-2026年已成为RAG系统召回率提升的核心优化手段，平均提升20-35%检索准确率。**

---

## 为什么这句话能概括Query改写？

### 1. "检索前优化" - 明确位置

Query改写发生在RAG流程的**最前端**：

```
用户Query → Query改写 → 检索(BM25/向量) → ReRank → LLM生成
    ↑
  优化起点
```

**为什么在检索前改写？**
- 用户查询往往简短、模糊、表达不精确
- 直接检索会导致语义鸿沟（semantic gap）
- 改写后的查询更接近文档的表达方式
- 一次改写，多次检索受益

**对比其他优化位置：**
| 优化位置 | 技术 | 作用 |
|---------|------|------|
| **检索前** | **Query改写** | **优化输入** |
| 检索中 | 混合检索 | 优化检索策略 |
| 检索后 | ReRank | 优化排序 |

### 2. "6大策略" - 技术全景

Query改写不是单一技术，而是**技术集合**：

#### 策略1：HyDE (Hypothetical Document Embeddings)
**原理：** 生成假设性文档，用文档检索文档

```python
# 用户查询
query = "Python异步编程怎么用？"

# HyDE生成假设文档
hypothetical_doc = """
Python异步编程使用asyncio库实现。
通过async/await关键字定义协程函数。
使用asyncio.run()运行异步任务。
适用于I/O密集型场景，提升并发性能。
"""

# 用假设文档的embedding检索
results = vector_search(embed(hypothetical_doc))
```

**适用场景：** 用户查询与文档表达方式差异大

#### 策略2：Multi-Query (多查询生成)
**原理：** 生成3-5个查询变体，扩大召回范围

```python
# 原始查询
query = "RAG系统如何优化？"

# 生成多个变体
variants = [
    "如何提升RAG检索准确率？",
    "RAG系统性能优化方法有哪些？",
    "检索增强生成的优化策略",
    "RAG召回率和精度如何改进？"
]

# 分别检索后融合
results = fusion([search(q) for q in variants])
```

**适用场景：** 通用场景，2026年生产级标配

#### 策略3：Query Expansion (查询扩展)
**原理：** 添加同义词、相关词、领域术语

```python
# 原始查询
query = "Python异步"

# 扩展后
expanded = "Python异步 OR asyncio OR 协程 OR coroutine OR async/await"
```

**适用场景：** 关键词检索（BM25）场景

#### 策略4：Query Decomposition (查询分解)
**原理：** 将复杂查询拆分为多个子查询

```python
# 复杂查询
query = "对比Python和JavaScript的异步编程模型，并说明各自适用场景"

# 分解为子查询
sub_queries = [
    "Python异步编程模型是什么？",
    "JavaScript异步编程模型是什么？",
    "Python异步适用场景",
    "JavaScript异步适用场景"
]

# 迭代检索和推理
```

**适用场景：** 多跳问题、对比分析

#### 策略5：Keyword Enrichment (关键词增强)
**原理：** LLM提取并增强关键词

```python
# 原始查询
query = "怎么让API更快？"

# LLM提取关键词
keywords = ["API", "性能优化", "响应时间", "缓存", "异步", "并发"]

# 增强查询
enriched = "API性能优化 响应时间 缓存策略 异步处理 并发优化"
```

**适用场景：** 模糊查询、口语化查询

#### 策略6：Pseudo-Answer Generation (伪答案生成)
**原理：** 生成假设性答案用于检索

```python
# 原始查询
query = "FastAPI如何处理异步？"

# 生成伪答案
pseudo_answer = """
FastAPI原生支持异步处理。
使用async def定义异步路由。
支持异步数据库操作。
性能优于同步框架。
"""

# 用伪答案检索
results = search(pseudo_answer)
```

**适用场景：** 问答场景，类似HyDE但更短

### 3. "弥合语义鸿沟" - 核心价值

**什么是语义鸿沟？**

用户查询和文档之间的表达差异：

| 用户查询 | 文档表达 | 语义鸿沟 |
|---------|---------|---------|
| "怎么让代码跑得快？" | "性能优化策略" | ✅ 大 |
| "Python异步编程" | "asyncio协程实现" | ✅ 中 |
| "FastAPI异步路由" | "FastAPI async def" | ❌ 小 |

**Query改写如何弥合？**

```
用户思维 → Query改写 → 文档思维
  ↓           ↓           ↓
口语化     标准化表达    技术术语
模糊       精确         结构化
简短       丰富         完整
```

### 4. "2025-2026年核心优化手段" - 生产标准

**2026年生产级RAG标配：**

| 技术 | 采用率 | 代表产品 |
|------|--------|---------|
| Multi-Query | 85% | LangChain, LlamaIndex |
| HyDE | 60% | Haystack, LangChain |
| Query Expansion | 70% | Elasticsearch, OpenSearch |
| Query Decomposition | 45% | NVIDIA RAG Blueprint |

**为什么成为标配？**
- 成本低：主要是LLM调用，$0.01-0.05/1K queries
- 效果显著：20-35%准确率提升
- 易于集成：框架原生支持
- 无需重建索引：不影响现有系统

### 5. "20-35%准确率提升" - 量化效果

**2025-2026年实测数据：**

| 研究来源 | 技术 | 提升幅度 | 测试场景 |
|---------|------|---------|---------|
| Elastic Labs (2026.01) | Query Expansion | +25% | 企业搜索 |
| Stack AI (2025.09) | Multi-Query | +30% | 通用RAG |
| LangChain | HyDE | +20-35% | 文档问答 |
| NVIDIA | Query Decomposition | +28% | 多跳推理 |

**为什么提升显著？**
- 召回率提升：从单一查询到多角度覆盖
- 语义匹配改善：从用户语言到文档语言
- 边界case覆盖：处理模糊、复杂查询

---

## RAG开发中的体现

### 场景1：文档问答系统

**问题：** 用户问"怎么加速API？"，文档中是"API性能优化策略"

**直接检索：**
```python
query = "怎么加速API？"
results = vector_search(query)  # 可能检索不到
```

**Query改写后：**
```python
# Multi-Query生成变体
variants = [
    "API性能优化方法",
    "如何提升API响应速度",
    "API加速策略",
    "接口性能调优"
]

# 召回率大幅提升
results = fusion([search(q) for q in variants])
```

### 场景2：技术知识库

**问题：** 用户查询简短，文档详细

**HyDE改写：**
```python
query = "FastAPI异步"

# 生成假设文档
hyde_doc = """
FastAPI支持异步编程，使用async def定义异步路由。
可以与asyncio、aiohttp等异步库集成。
异步处理提升I/O密集型应用性能。
支持异步数据库操作和异步依赖注入。
"""

# 用假设文档检索，匹配度更高
results = search(hyde_doc)
```

### 场景3：复杂查询

**问题：** "对比Python和Go的并发模型，并说明各自优缺点"

**Query Decomposition：**
```python
# 分解为子查询
sub_queries = [
    "Python并发模型是什么？",
    "Go并发模型是什么？",
    "Python并发优缺点",
    "Go并发优缺点"
]

# 迭代检索和推理
answers = []
for q in sub_queries:
    docs = search(q)
    answer = llm.generate(q, docs)
    answers.append(answer)

# 综合答案
final_answer = llm.synthesize(answers)
```

---

## 前端开发类比

**Query改写 = 搜索框的智能补全和纠错**

```javascript
// 用户输入
const userInput = "怎么让代码快";

// Query改写（前端类比）
const rewritten = {
  // Multi-Query：生成多个搜索词
  variants: [
    "代码性能优化",
    "代码执行速度提升",
    "代码加速方法"
  ],

  // Query Expansion：添加相关词
  expanded: "代码快 OR 性能优化 OR 执行速度 OR 加速",

  // Keyword Enrichment：提取关键词
  keywords: ["代码", "性能", "优化", "速度", "加速"]
};

// 用改写后的查询搜索
const results = search(rewritten);
```

**对应关系：**
- Multi-Query = 搜索建议列表
- Query Expansion = 自动添加相关搜索词
- HyDE = 根据输入生成完整搜索描述
- Query Decomposition = 将复杂搜索拆分为多个简单搜索

---

## 日常生活类比

**Query改写 = 问路时的表达优化**

**场景：** 你想去"那个卖好吃面包的店"

**直接问（原始查询）：**
- "那个卖好吃面包的店在哪？" ❌ 信息不足

**Query改写后：**

1. **Multi-Query（多角度问）：**
   - "附近有哪些面包店？"
   - "评价好的烘焙店在哪？"
   - "网红面包店怎么走？"

2. **Query Expansion（添加细节）：**
   - "面包店 OR 烘焙店 OR bakery，好吃的，附近"

3. **HyDE（描述理想答案）：**
   - "我要找一家面包店，店里有法棍、可颂，环境干净，评价4.5分以上"

4. **Query Decomposition（拆分问题）：**
   - 先问："附近有哪些面包店？"
   - 再问："哪家评价最好？"
   - 最后问："怎么走？"

**结果：** 通过改写，找到目标的概率大大提升

---

## 一句话记忆

**"Query改写是RAG的翻译官：把用户的口语化查询翻译成文档能理解的标准表达，通过6大策略（HyDE、Multi-Query、扩展、分解、增强、伪答案）弥合语义鸿沟，让检索召回率提升20-35%。"**

---

## 参考资料

### 核心研究（2025-2026）

- [Query Rewriting Strategies with LLMs](https://www.elastic.co/search-labs/blog/query-rewriting-with-llms) - Elastic Labs, 2026.01
- [Advanced RAG Techniques](https://www.stack-ai.com/blog/advanced-rag-techniques) - Stack AI, 2025.09
- [HyDE: Precise Zero-Shot Dense Retrieval](https://arxiv.org/abs/2212.10496) - Original Paper, 2022
- [Multi-Query Retriever](https://python.langchain.com/docs/modules/data_connection/retrievers/MultiQueryRetriever) - LangChain
- [Query Decomposition for RAG](https://developer.nvidia.com/blog/build-an-agentic-rag-pipeline-with-llama-3-1-and-nvidia-nemo-retriever/) - NVIDIA, 2025

### 技术指南

- [Haystack Query Expansion](https://haystack.deepset.ai/tutorials/query-expansion) - Deepset
- [UniRAG: Universal RAG Framework](https://arxiv.org/abs/2406.07520) - Research Paper, 2024
- [Question Decomposition Improves RAG](https://arxiv.org/abs/2409.12365) - Research Paper, 2024

---

**版本：** v1.0 (2026年标准)
**最后更新：** 2026-02-16
**适用场景：** RAG开发、信息检索、查询优化
