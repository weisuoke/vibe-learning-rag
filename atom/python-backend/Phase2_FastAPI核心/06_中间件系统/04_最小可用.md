# 最小可用

掌握以下内容，就能开始使用 FastAPI 中间件：

---

## 4.1 装饰器中间件（最简单）

**一句话：** 用 `@app.middleware("http")` 装饰器定义中间件函数

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def my_middleware(request: Request, call_next):
    # 请求前的处理
    print(f"Request: {request.method} {request.url.path}")

    # 调用下一个中间件或路由处理函数
    response = await call_next(request)

    # 响应后的处理
    print(f"Response: {response.status_code}")

    return response
```

**关键点：**
- 必须是 `async` 函数
- 接收 `request` 和 `call_next` 两个参数
- 必须调用 `await call_next(request)` 继续处理
- 必须返回 `response`

---

## 4.2 添加响应头

**一句话：** 在中间件中修改响应头

```python
@app.middleware("http")
async def add_custom_header(request: Request, call_next):
    response = await call_next(request)

    # 添加自定义响应头
    response.headers["X-Custom-Header"] = "MyValue"
    response.headers["X-Process-Time"] = "0.123"

    return response
```

**实际应用：**
- 添加 CORS 头
- 添加安全头（X-Frame-Options、X-Content-Type-Options）
- 添加性能监控头（请求耗时）

---

## 4.3 内置 CORS 中间件

**一句话：** 使用 FastAPI 内置的 CORS 中间件处理跨域

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# 添加 CORS 中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # 允许的前端域名
    allow_credentials=True,                    # 允许携带 Cookie
    allow_methods=["*"],                       # 允许所有 HTTP 方法
    allow_headers=["*"],                       # 允许所有请求头
)
```

**实际应用：**
- 前端（React/Vue）调用后端 API
- 移动端 WebView 调用 API
- 第三方网站集成你的 API

---

## 4.4 访问请求状态

**一句话：** 使用 `request.state` 在中间件和路由之间传递数据

```python
@app.middleware("http")
async def add_user_info(request: Request, call_next):
    # 在中间件中设置状态
    request.state.user_id = "user_123"
    request.state.request_id = "req_456"

    response = await call_next(request)
    return response

@app.get("/users/me")
async def get_current_user(request: Request):
    # 在路由中读取状态
    user_id = request.state.user_id
    request_id = request.state.request_id

    return {
        "user_id": user_id,
        "request_id": request_id
    }
```

**实际应用：**
- 认证中间件设置 `request.state.user`，路由直接使用
- 日志中间件设置 `request.state.request_id`，用于追踪请求
- 限流中间件设置 `request.state.rate_limit_remaining`

---

## 4.5 提前返回响应

**一句话：** 在中间件中直接返回响应，不调用 `call_next()`

```python
from fastapi.responses import JSONResponse

@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 检查认证
    token = request.headers.get("authorization")

    if not token:
        # 提前返回 401 响应，不继续处理
        return JSONResponse(
            {"error": "Missing authorization header"},
            status_code=401
        )

    # 认证通过，继续处理
    response = await call_next(request)
    return response
```

**实际应用：**
- 认证失败直接返回 401
- 限流超限直接返回 429
- 维护模式直接返回 503

---

## 这些知识足以：

- ✅ 添加请求日志中间件
- ✅ 配置 CORS 跨域
- ✅ 实现简单的认证拦截
- ✅ 在中间件和路由之间传递数据
- ✅ 为后续学习高级中间件打基础

---

## 快速上手示例

```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import time

app = FastAPI()

# 1. CORS 中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# 2. 日志中间件
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    print(f"→ {request.method} {request.url.path}")

    response = await call_next(request)

    duration = time.time() - start_time
    print(f"← {response.status_code} ({duration:.3f}s)")

    return response

# 3. 认证中间件
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 只对 /api/ 路径进行认证
    if request.url.path.startswith("/api/"):
        token = request.headers.get("authorization")

        if not token:
            return JSONResponse(
                {"error": "Unauthorized"},
                status_code=401
            )

        # 简单验证（实际应该验证 JWT）
        if token != "Bearer secret-token":
            return JSONResponse(
                {"error": "Invalid token"},
                status_code=401
            )

        # 设置用户信息
        request.state.user_id = "user_123"

    response = await call_next(request)
    return response

# 业务路由
@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/api/users/me")
async def get_current_user(request: Request):
    return {
        "user_id": request.state.user_id,
        "name": "Alice"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 1. 访问公开端点（不需要认证）
curl http://localhost:8000/
# 输出：{"message":"Hello World"}

# 2. 访问受保护端点（没有 token）
curl http://localhost:8000/api/users/me
# 输出：{"error":"Unauthorized"}

# 3. 访问受保护端点（有 token）
curl -H "Authorization: Bearer secret-token" http://localhost:8000/api/users/me
# 输出：{"user_id":"user_123","name":"Alice"}

# 4. 查看服务器日志
# → GET /
# ← 200 (0.001s)
# → GET /api/users/me
# ← 401 (0.000s)
# → GET /api/users/me
# ← 200 (0.001s)
```

---

## 下一步学习

掌握了最小可用知识后，可以继续学习：

1. **核心概念**：深入理解中间件的执行流程和洋葱模型
2. **内置中间件**：学习 FastAPI 提供的其他内置中间件
3. **自定义中间件类**：使用类而不是函数定义中间件
4. **实战场景**：限流、错误处理、性能监控等高级应用

---

**记住：** 中间件的核心就是 `request → call_next() → response`，理解了这个流程，就能灵活运用中间件解决各种问题。
