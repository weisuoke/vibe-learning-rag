# 核心概念3：持久化存储（数据库与Redis）

## 一句话定义

**持久化存储是将对话记忆保存到数据库或缓存系统，实现跨会话、跨服务器的记忆共享和持久化。**

---

## 为什么需要持久化存储？

前面介绍的 ConversationBufferMemory 和 ConversationBufferWindowMemory 都是**基于内存**的，存在以下问题：

1. **服务重启丢失** - 应用重启后，所有对话历史消失
2. **无法跨服务器共享** - 分布式部署时，不同服务器无法共享记忆
3. **无法长期保存** - 无法实现长期的用户画像和偏好记忆

**持久化存储解决这些问题。**

---

## 两种主流方案

### 方案1：PostgreSQL（关系型数据库）

**适用场景：**
- ✅ 需要复杂查询（按时间、用户、关键词查询）
- ✅ 需要长期存储（用户画像、历史分析）
- ✅ 数据一致性要求高

**优点：**
- 持久化可靠
- 支持复杂查询
- 数据结构化

**缺点：**
- 读写速度较慢
- 需要额外的数据库服务

### 方案2：Redis（内存缓存）

**适用场景：**
- ✅ 需要高性能读写
- ✅ 分布式部署
- ✅ 短期记忆（如会话期间）

**优点：**
- 读写速度快
- 支持分布式
- 自动过期

**缺点：**
- 内存成本高
- 数据可能丢失（如果未配置持久化）

---

## 方案1：PostgreSQL 持久化

### 数据库表设计

```sql
-- 对话历史表
CREATE TABLE conversation_history (
    id SERIAL PRIMARY KEY,
    session_id VARCHAR(255) NOT NULL,  -- 会话ID（用户ID）
    role VARCHAR(50) NOT NULL,         -- 'user' 或 'assistant'
    content TEXT NOT NULL,             -- 消息内容
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_session_id (session_id),
    INDEX idx_created_at (created_at)
);
```

### SQLAlchemy 模型定义

```python
from sqlalchemy import Column, Integer, String, Text, DateTime, Index
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class ConversationMessage(Base):
    __tablename__ = "conversation_history"

    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(String(255), nullable=False, index=True)
    role = Column(String(50), nullable=False)  # 'user' or 'assistant'
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, index=True)

    def __repr__(self):
        return f"<Message(session={self.session_id}, role={self.role})>"
```

### 自定义 PostgreSQL 记忆类

```python
from langchain.schema import BaseChatMessageHistory, BaseMessage
from langchain.schema.messages import HumanMessage, AIMessage
from sqlalchemy.orm import Session
from typing import List

class PostgreSQLChatMessageHistory(BaseChatMessageHistory):
    """基于 PostgreSQL 的对话历史存储"""

    def __init__(self, session_id: str, db_session: Session):
        self.session_id = session_id
        self.db_session = db_session

    @property
    def messages(self) -> List[BaseMessage]:
        """获取所有消息"""
        # 从数据库查询
        db_messages = (
            self.db_session.query(ConversationMessage)
            .filter(ConversationMessage.session_id == self.session_id)
            .order_by(ConversationMessage.created_at)
            .all()
        )

        # 转换为 LangChain 消息对象
        messages = []
        for msg in db_messages:
            if msg.role == "user":
                messages.append(HumanMessage(content=msg.content))
            elif msg.role == "assistant":
                messages.append(AIMessage(content=msg.content))

        return messages

    def add_user_message(self, message: str) -> None:
        """添加用户消息"""
        msg = ConversationMessage(
            session_id=self.session_id,
            role="user",
            content=message
        )
        self.db_session.add(msg)
        self.db_session.commit()

    def add_ai_message(self, message: str) -> None:
        """添加 AI 消息"""
        msg = ConversationMessage(
            session_id=self.session_id,
            role="assistant",
            content=message
        )
        self.db_session.add(msg)
        self.db_session.commit()

    def clear(self) -> None:
        """清空历史"""
        self.db_session.query(ConversationMessage).filter(
            ConversationMessage.session_id == self.session_id
        ).delete()
        self.db_session.commit()
```

### 在 FastAPI 中使用

```python
from fastapi import FastAPI, Depends
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from pydantic import BaseModel
from langchain.memory import ConversationBufferMemory
from langchain_openai import ChatOpenAI
from langchain.chains import ConversationChain

# 数据库配置
DATABASE_URL = "postgresql://user:password@localhost:5432/dbname"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

app = FastAPI()

# 依赖注入：获取数据库会话
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

class ChatRequest(BaseModel):
    user_id: str
    message: str

@app.post("/chat")
async def chat(request: ChatRequest, db: Session = Depends(get_db)):
    # 1. 创建 PostgreSQL 记忆
    chat_history = PostgreSQLChatMessageHistory(
        session_id=request.user_id,
        db_session=db
    )

    # 2. 创建 LangChain 记忆
    memory = ConversationBufferMemory(
        chat_memory=chat_history,
        return_messages=True
    )

    # 3. 创建对话链
    llm = ChatOpenAI(temperature=0.7)
    conversation = ConversationChain(llm=llm, memory=memory)

    # 4. 生成回复
    response = conversation.predict(input=request.message)

    return {"response": response}

@app.get("/history/{user_id}")
async def get_history(user_id: str, db: Session = Depends(get_db)):
    """获取用户的对话历史"""
    messages = (
        db.query(ConversationMessage)
        .filter(ConversationMessage.session_id == user_id)
        .order_by(ConversationMessage.created_at)
        .all()
    )

    return {
        "user_id": user_id,
        "messages": [
            {"role": msg.role, "content": msg.content, "created_at": msg.created_at}
            for msg in messages
        ]
    }
```

---

## 方案2：Redis 持久化

### Redis 数据结构设计

```
# 使用 Redis List 存储对话历史
Key: conversation:{session_id}
Value: [
    '{"role": "user", "content": "你好"}',
    '{"role": "assistant", "content": "你好！"}',
    ...
]

# 设置过期时间（如30分钟）
EXPIRE conversation:{session_id} 1800
```

### 自定义 Redis 记忆类

```python
import json
import redis
from langchain.schema import BaseChatMessageHistory, BaseMessage
from langchain.schema.messages import HumanMessage, AIMessage
from typing import List

class RedisChatMessageHistory(BaseChatMessageHistory):
    """基于 Redis 的对话历史存储"""

    def __init__(
        self,
        session_id: str,
        redis_client: redis.Redis,
        ttl: int = 1800  # 过期时间（秒）
    ):
        self.session_id = session_id
        self.redis_client = redis_client
        self.ttl = ttl
        self.key = f"conversation:{session_id}"

    @property
    def messages(self) -> List[BaseMessage]:
        """获取所有消息"""
        # 从 Redis 获取
        raw_messages = self.redis_client.lrange(self.key, 0, -1)

        # 转换为 LangChain 消息对象
        messages = []
        for raw_msg in raw_messages:
            msg_dict = json.loads(raw_msg)
            if msg_dict["role"] == "user":
                messages.append(HumanMessage(content=msg_dict["content"]))
            elif msg_dict["role"] == "assistant":
                messages.append(AIMessage(content=msg_dict["content"]))

        return messages

    def add_user_message(self, message: str) -> None:
        """添加用户消息"""
        msg_dict = {"role": "user", "content": message}
        self.redis_client.rpush(self.key, json.dumps(msg_dict))
        # 更新过期时间
        self.redis_client.expire(self.key, self.ttl)

    def add_ai_message(self, message: str) -> None:
        """添加 AI 消息"""
        msg_dict = {"role": "assistant", "content": message}
        self.redis_client.rpush(self.key, json.dumps(msg_dict))
        # 更新过期时间
        self.redis_client.expire(self.key, self.ttl)

    def clear(self) -> None:
        """清空历史"""
        self.redis_client.delete(self.key)
```

### 在 FastAPI 中使用

```python
from fastapi import FastAPI
from pydantic import BaseModel
import redis
from langchain.memory import ConversationBufferMemory
from langchain_openai import ChatOpenAI
from langchain.chains import ConversationChain

app = FastAPI()

# Redis 连接
redis_client = redis.Redis(
    host='localhost',
    port=6379,
    db=0,
    decode_responses=False  # 保持字节格式
)

class ChatRequest(BaseModel):
    user_id: str
    message: str

@app.post("/chat")
async def chat(request: ChatRequest):
    # 1. 创建 Redis 记忆
    chat_history = RedisChatMessageHistory(
        session_id=request.user_id,
        redis_client=redis_client,
        ttl=1800  # 30分钟过期
    )

    # 2. 创建 LangChain 记忆
    memory = ConversationBufferMemory(
        chat_memory=chat_history,
        return_messages=True
    )

    # 3. 创建对话链
    llm = ChatOpenAI(temperature=0.7)
    conversation = ConversationChain(llm=llm, memory=memory)

    # 4. 生成回复
    response = conversation.predict(input=request.message)

    return {"response": response}

@app.get("/history/{user_id}")
async def get_history(user_id: str):
    """获取用户的对话历史"""
    key = f"conversation:{user_id}"
    raw_messages = redis_client.lrange(key, 0, -1)

    messages = [json.loads(msg) for msg in raw_messages]

    return {
        "user_id": user_id,
        "messages": messages,
        "ttl": redis_client.ttl(key)  # 剩余过期时间
    }
```

---

## 混合方案：Redis + PostgreSQL

**最佳实践：结合两者优势**

- **Redis**：存储短期记忆（会话期间）
- **PostgreSQL**：存储长期记忆（用户画像、历史分析）

```python
class HybridMemory:
    """混合记忆：Redis（短期） + PostgreSQL（长期）"""

    def __init__(self, session_id: str, redis_client: redis.Redis, db_session: Session):
        self.session_id = session_id
        self.redis_memory = RedisChatMessageHistory(session_id, redis_client)
        self.db_memory = PostgreSQLChatMessageHistory(session_id, db_session)

    def add_user_message(self, message: str):
        # 同时写入 Redis 和 PostgreSQL
        self.redis_memory.add_user_message(message)
        self.db_memory.add_user_message(message)

    def add_ai_message(self, message: str):
        self.redis_memory.add_ai_message(message)
        self.db_memory.add_ai_message(message)

    @property
    def messages(self):
        # 优先从 Redis 读取（快）
        redis_messages = self.redis_memory.messages
        if redis_messages:
            return redis_messages

        # Redis 没有，从 PostgreSQL 读取（慢但可靠）
        return self.db_memory.messages
```

---

## 总结

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **PostgreSQL** | 持久化可靠、支持复杂查询 | 读写慢 | 长期存储、数据分析 |
| **Redis** | 读写快、支持分布式 | 内存成本高 | 短期记忆、高并发 |
| **混合方案** | 兼顾性能和可靠性 | 实现复杂 | 生产环境推荐 |

**推荐：**
- 开发测试：内存记忆
- 单机生产：PostgreSQL
- 分布式生产：Redis + PostgreSQL
