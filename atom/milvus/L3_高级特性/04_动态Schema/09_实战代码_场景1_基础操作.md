# 实战代码 - 场景1：基础操作

> 完整的动态Schema基础操作流程

---

## 场景描述

本场景演示动态Schema的完整基础操作流程：
1. 创建启用动态Schema的Collection
2. 插入包含动态字段的数据
3. 查询动态字段数据
4. 更新动态字段数据
5. 删除动态字段数据

---

## 完整代码

```python
from pymilvus import connections, Collection, CollectionSchema, FieldSchema, DataType, utility
import numpy as np

class DynamicSchemaBasicDemo:
    """动态Schema基础操作演示"""

    def __init__(self, collection_name="dynamic_basic_demo"):
        self.collection_name = collection_name
        self.collection = None

    def setup(self):
        """初始化：连接Milvus并创建Collection"""
        print("=" * 60)
        print("步骤1：连接Milvus")
        print("=" * 60)

        # 连接Milvus
        connections.connect(
            alias="default",
            host="localhost",
            port="19530"
        )
        print("✅ 已连接到Milvus")

        # 删除已存在的Collection
        if utility.has_collection(self.collection_name):
            utility.drop_collection(self.collection_name)
            print(f"✅ 已删除旧Collection: {self.collection_name}")

        print("\n" + "=" * 60)
        print("步骤2：创建启用动态Schema的Collection")
        print("=" * 60)

        # 定义固定字段
        fields = [
            FieldSchema(
                name="id",
                dtype=DataType.INT64,
                is_primary=True,
                auto_id=True,
                description="主键ID"
            ),
            FieldSchema(
                name="embedding",
                dtype=DataType.FLOAT_VECTOR,
                dim=128,
                description="向量字段"
            ),
            FieldSchema(
                name="text",
                dtype=DataType.VARCHAR,
                max_length=1000,
                description="文本内容"
            )
        ]

        # 创建Schema并启用动态字段
        schema = CollectionSchema(
            fields=fields,
            description="动态Schema基础演示Collection",
            enable_dynamic_field=True  # 关键：启用动态字段
        )

        # 创建Collection
        self.collection = Collection(
            name=self.collection_name,
            schema=schema
        )

        print(f"✅ 已创建Collection: {self.collection_name}")
        print(f"   - 固定字段: id, embedding, text")
        print(f"   - 动态字段: 已启用")

    def insert_data(self):
        """插入包含动态字段的数据"""
        print("\n" + "=" * 60)
        print("步骤3：插入包含动态字段的数据")
        print("=" * 60)

        # 准备数据（包含不同的动态字段）
        data = [
            {
                "text": "Introduction to vector databases",
                "embedding": np.random.rand(128).tolist(),
                # 动态字段
                "author": "Alice",
                "category": "database",
                "priority": 5,
                "tags": ["vector", "database"]
            },
            {
                "text": "Machine learning basics",
                "embedding": np.random.rand(128).tolist(),
                # 不同的动态字段
                "author": "Bob",
                "category": "AI",
                "difficulty": "beginner",
                "rating": 4.5
            },
            {
                "text": "RAG system architecture",
                "embedding": np.random.rand(128).tolist(),
                # 又不同的动态字段
                "author": "Carol",
                "category": "AI",
                "priority": 8,
                "is_public": True,
                "views": 1000
            }
        ]

        # 插入数据
        result = self.collection.insert(data)
        self.collection.flush()

        print(f"✅ 已插入 {len(data)} 条数据")
        print(f"   - 生成的ID: {result.primary_keys}")

        # 显示每条数据的动态字段
        for i, doc in enumerate(data):
            dynamic_fields = {k: v for k, v in doc.items() if k not in ["text", "embedding"]}
            print(f"   - 文档{i+1}的动态字段: {list(dynamic_fields.keys())}")

        return result.primary_keys

    def create_index_and_load(self):
        """创建索引并加载Collection"""
        print("\n" + "=" * 60)
        print("步骤4：创建索引并加载Collection")
        print("=" * 60)

        # 创建向量索引
        index_params = {
            "index_type": "IVF_FLAT",
            "metric_type": "L2",
            "params": {"nlist": 128}
        }

        self.collection.create_index(
            field_name="embedding",
            index_params=index_params
        )
        print("✅ 已创建向量索引")

        # 加载Collection
        self.collection.load()
        print("✅ 已加载Collection到内存")

    def query_all_fields(self):
        """查询所有字段（包括动态字段）"""
        print("\n" + "=" * 60)
        print("步骤5：查询所有字段（包括动态字段）")
        print("=" * 60)

        # 查询所有数据
        results = self.collection.query(
            expr="id > 0",
            output_fields=["*"],  # * 表示所有字段
            limit=10
        )

        print(f"✅ 查询到 {len(results)} 条数据\n")

        # 显示查询结果
        for i, result in enumerate(results, 1):
            print(f"文档 {i}:")
            print(f"  ID: {result['id']}")
            print(f"  Text: {result['text'][:50]}...")

            # 显示动态字段
            dynamic_fields = {k: v for k, v in result.items() if k not in ["id", "text", "embedding"]}
            for field_name, field_value in dynamic_fields.items():
                print(f"  {field_name}: {field_value}")
            print()

    def query_by_dynamic_field(self):
        """按动态字段查询"""
        print("\n" + "=" * 60)
        print("步骤6：按动态字段查询")
        print("=" * 60)

        # 查询author为Alice的数据
        results = self.collection.query(
            expr='author == "Alice"',
            output_fields=["text", "author", "category", "priority"]
        )

        print(f'✅ 查询条件: author == "Alice"')
        print(f"   找到 {len(results)} 条数据\n")

        for result in results:
            print(f"  Text: {result['text']}")
            print(f"  Author: {result.get('author', 'N/A')}")
            print(f"  Category: {result.get('category', 'N/A')}")
            print(f"  Priority: {result.get('priority', 'N/A')}")
            print()

        # 查询priority > 5的数据
        results = self.collection.query(
            expr='priority > 5',
            output_fields=["text", "author", "priority"]
        )

        print(f'✅ 查询条件: priority > 5')
        print(f"   找到 {len(results)} 条数据\n")

        for result in results:
            print(f"  Text: {result['text']}")
            print(f"  Author: {result.get('author', 'N/A')}")
            print(f"  Priority: {result.get('priority', 'N/A')}")
            print()

    def vector_search_with_filter(self):
        """向量检索 + 动态字段过滤"""
        print("\n" + "=" * 60)
        print("步骤7：向量检索 + 动态字段过滤")
        print("=" * 60)

        # 生成查询向量
        query_vector = np.random.rand(128).tolist()

        # 向量检索 + 动态字段过滤
        search_params = {"metric_type": "L2", "params": {"nprobe": 10}}

        results = self.collection.search(
            data=[query_vector],
            anns_field="embedding",
            param=search_params,
            limit=5,
            expr='category == "AI"',  # 动态字段过滤
            output_fields=["text", "author", "category"]
        )

        print(f'✅ 检索条件: category == "AI"')
        print(f"   返回Top-{len(results[0])}结果\n")

        for i, hit in enumerate(results[0], 1):
            print(f"结果 {i}:")
            print(f"  ID: {hit.id}")
            print(f"  Distance: {hit.distance:.4f}")
            print(f"  Text: {hit.entity.get('text')[:50]}...")
            print(f"  Author: {hit.entity.get('author')}")
            print(f"  Category: {hit.entity.get('category')}")
            print()

    def update_data(self, doc_id):
        """更新数据（先删除再插入）"""
        print("\n" + "=" * 60)
        print("步骤8：更新数据")
        print("=" * 60)

        # 查询原始数据
        results = self.collection.query(
            expr=f"id == {doc_id}",
            output_fields=["*"]
        )

        if not results:
            print(f"❌ 未找到ID为{doc_id}的数据")
            return

        print(f"✅ 找到ID为{doc_id}的数据")
        original_data = results[0]
        print(f"   原始数据: {original_data}")

        # 更新数据
        updates = {
            "priority": 10,
            "tags": ["updated", "important"],
            "updated_at": "2024-01-01"
        }

        updated_data = {**original_data, **updates}

        # 删除原始数据
        self.collection.delete(expr=f"id == {doc_id}")

        # 插入更新后的数据
        self.collection.insert([updated_data])
        self.collection.flush()

        print(f"✅ 已更新数据")
        print(f"   更新字段: {list(updates.keys())}")

        # 验证更新
        results = self.collection.query(
            expr=f"id == {doc_id}",
            output_fields=["*"]
        )

        if results:
            print(f"   更新后数据: {results[0]}")

    def delete_data(self):
        """删除数据"""
        print("\n" + "=" * 60)
        print("步骤9：删除数据")
        print("=" * 60)

        # 按动态字段删除
        results = self.collection.query(
            expr='author == "Bob"',
            output_fields=["id", "text", "author"]
        )

        if results:
            print(f'✅ 找到author == "Bob"的数据:')
            for result in results:
                print(f"   ID: {result['id']}, Text: {result['text']}")

            # 删除数据
            self.collection.delete(expr='author == "Bob"')
            self.collection.flush()

            print(f"✅ 已删除 {len(results)} 条数据")

            # 验证删除
            results_after = self.collection.query(
                expr='author == "Bob"',
                output_fields=["*"]
            )
            print(f"   删除后剩余: {len(results_after)} 条")

    def cleanup(self):
        """清理资源"""
        print("\n" + "=" * 60)
        print("步骤10：清理资源")
        print("=" * 60)

        # 释放Collection
        self.collection.release()
        print("✅ 已释放Collection")

        # 删除Collection（可选）
        # utility.drop_collection(self.collection_name)
        # print(f"✅ 已删除Collection: {self.collection_name}")

        # 断开连接
        connections.disconnect("default")
        print("✅ 已断开Milvus连接")

    def run(self):
        """运行完整演示"""
        try:
            # 1. 初始化
            self.setup()

            # 2. 插入数据
            ids = self.insert_data()

            # 3. 创建索引并加载
            self.create_index_and_load()

            # 4. 查询所有字段
            self.query_all_fields()

            # 5. 按动态字段查询
            self.query_by_dynamic_field()

            # 6. 向量检索 + 动态字段过滤
            self.vector_search_with_filter()

            # 7. 更新数据
            if ids:
                self.update_data(ids[0])

            # 8. 删除数据
            self.delete_data()

            # 9. 清理资源
            self.cleanup()

            print("\n" + "=" * 60)
            print("✅ 演示完成！")
            print("=" * 60)

        except Exception as e:
            print(f"\n❌ 发生错误: {e}")
            import traceback
            traceback.print_exc()


if __name__ == "__main__":
    demo = DynamicSchemaBasicDemo()
    demo.run()
```

---

## 运行结果

```
============================================================
步骤1：连接Milvus
============================================================
✅ 已连接到Milvus
✅ 已删除旧Collection: dynamic_basic_demo

============================================================
步骤2：创建启用动态Schema的Collection
============================================================
✅ 已创建Collection: dynamic_basic_demo
   - 固定字段: id, embedding, text
   - 动态字段: 已启用

============================================================
步骤3：插入包含动态字段的数据
============================================================
✅ 已插入 3 条数据
   - 生成的ID: [448121835767234560, 448121835767234561, 448121835767234562]
   - 文档1的动态字段: ['author', 'category', 'priority', 'tags']
   - 文档2的动态字段: ['author', 'category', 'difficulty', 'rating']
   - 文档3的动态字段: ['author', 'category', 'priority', 'is_public', 'views']

============================================================
步骤4：创建索引并加载Collection
============================================================
✅ 已创建向量索引
✅ 已加载Collection到内存

============================================================
步骤5：查询所有字段（包括动态字段）
============================================================
✅ 查询到 3 条数据

文档 1:
  ID: 448121835767234560
  Text: Introduction to vector databases...
  author: Alice
  category: database
  priority: 5
  tags: ['vector', 'database']

文档 2:
  ID: 448121835767234561
  Text: Machine learning basics...
  author: Bob
  category: AI
  difficulty: beginner
  rating: 4.5

文档 3:
  ID: 448121835767234562
  Text: RAG system architecture...
  author: Carol
  category: AI
  priority: 8
  is_public: True
  views: 1000

============================================================
步骤6：按动态字段查询
============================================================
✅ 查询条件: author == "Alice"
   找到 1 条数据

  Text: Introduction to vector databases
  Author: Alice
  Category: database
  Priority: 5

✅ 查询条件: priority > 5
   找到 1 条数据

  Text: RAG system architecture
  Author: Carol
  Priority: 8

============================================================
步骤7：向量检索 + 动态字段过滤
============================================================
✅ 检索条件: category == "AI"
   返回Top-2结果

结果 1:
  ID: 448121835767234561
  Distance: 12.3456
  Text: Machine learning basics...
  Author: Bob
  Category: AI

结果 2:
  ID: 448121835767234562
  Distance: 15.6789
  Text: RAG system architecture...
  Author: Carol
  Category: AI

============================================================
步骤8：更新数据
============================================================
✅ 找到ID为448121835767234560的数据
   原始数据: {'id': 448121835767234560, 'text': '...', 'author': 'Alice', ...}
✅ 已更新数据
   更新字段: ['priority', 'tags', 'updated_at']
   更新后数据: {'id': 448121835767234560, 'priority': 10, 'tags': ['updated', 'important'], ...}

============================================================
步骤9：删除数据
============================================================
✅ 找到author == "Bob"的数据:
   ID: 448121835767234561, Text: Machine learning basics
✅ 已删除 1 条数据
   删除后剩余: 0 条

============================================================
步骤10：清理资源
============================================================
✅ 已释放Collection
✅ 已断开Milvus连接

============================================================
✅ 演示完成！
============================================================
```

---

## 核心要点

1. **启用动态Schema**: `enable_dynamic_field=True`
2. **插入动态字段**: 自动识别，无需预定义
3. **查询动态字段**: `output_fields=["*"]`
4. **过滤动态字段**: 支持等值、范围、逻辑查询
5. **更新数据**: 先删除再插入
6. **删除数据**: 支持按动态字段删除

---

## 扩展练习

1. 尝试插入更多类型的动态字段（JSON、数组等）
2. 实现批量更新动态字段的功能
3. 添加动态字段类型验证
4. 实现动态字段的统计分析

---

**记住**: 动态Schema提供灵活性，但要注意类型一致性和性能优化。
