# 基础 Trie 实现

## 完整可运行代码

```python
"""
基础 Trie 数据结构实现
演示：插入、查找、前缀匹配、删除操作
"""

class TrieNode:
    """Trie 节点"""
    def __init__(self):
        self.children = {}      # 字符 -> 子节点
        self.is_end = False     # 是否是单词结尾
        self.value = None       # 可选：存储关联值


class Trie:
    """Trie 数据结构"""

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str, value=None):
        """
        插入单词
        时间复杂度：O(m)，m 是单词长度
        """
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
        node.value = value

    def search(self, word: str) -> bool:
        """
        精确查找单词
        时间复杂度：O(m)
        """
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

    def starts_with(self, prefix: str) -> bool:
        """
        前缀查找
        时间复杂度：O(m)
        """
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

    def get_words_with_prefix(self, prefix: str) -> list:
        """
        获取所有以 prefix 开头的单词
        时间复杂度：O(m + k)，k 是结果数量
        """
        node = self.root
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]

        results = []
        self._dfs(node, prefix, results)
        return results

    def _dfs(self, node, path, results):
        """DFS 遍历子树"""
        if node.is_end:
            results.append(path)

        for char, child in node.children.items():
            self._dfs(child, path + char, results)

    def delete(self, word: str) -> bool:
        """
        删除单词
        时间复杂度：O(m)
        """
        def _delete(node, word, index):
            if index == len(word):
                if not node.is_end:
                    return False
                node.is_end = False
                return len(node.children) == 0

            char = word[index]
            if char not in node.children:
                return False

            child = node.children[char]
            should_delete = _delete(child, word, index + 1)

            if should_delete:
                del node.children[char]
                return not node.is_end and len(node.children) == 0

            return False

        return _delete(self.root, word, 0)

    def _get_node(self, word: str):
        """获取单词对应的节点（内部方法）"""
        node = self.root
        for char in word:
            if char not in node.children:
                return None
            node = node.children[char]
        return node if node.is_end else None


# ===== 测试代码 =====
if __name__ == "__main__":
    print("=" * 50)
    print("基础 Trie 实现测试")
    print("=" * 50)

    trie = Trie()

    # ===== 1. 插入测试 =====
    print("\n【1. 插入测试】")
    words = ["cat", "car", "card", "dog", "door"]
    for word in words:
        trie.insert(word)
    print(f"插入单词: {words}")

    # ===== 2. 精确查找测试 =====
    print("\n【2. 精确查找测试】")
    test_words = ["cat", "ca", "dog", "door", "apple"]
    for word in test_words:
        result = trie.search(word)
        print(f"search('{word}'): {result}")

    # ===== 3. 前缀查找测试 =====
    print("\n【3. 前缀查找测试】")
    test_prefixes = ["ca", "do", "d", "x"]
    for prefix in test_prefixes:
        result = trie.starts_with(prefix)
        print(f"starts_with('{prefix}'): {result}")

    # ===== 4. 前缀补全测试 =====
    print("\n【4. 前缀补全测试】")
    test_prefixes = ["ca", "do", "d"]
    for prefix in test_prefixes:
        matches = trie.get_words_with_prefix(prefix)
        print(f"get_words_with_prefix('{prefix}'): {matches}")

    # ===== 5. 删除测试 =====
    print("\n【5. 删除测试】")
    print("删除 'card'")
    trie.delete("card")
    print(f"search('card'): {trie.search('card')}")
    print(f"search('car'): {trie.search('car')}")
    print(f"get_words_with_prefix('ca'): {trie.get_words_with_prefix('ca')}")

    print("\n删除 'car'")
    trie.delete("car")
    print(f"search('car'): {trie.search('car')}")
    print(f"search('cat'): {trie.search('cat')}")
    print(f"get_words_with_prefix('ca'): {trie.get_words_with_prefix('ca')}")

    # ===== 6. 带值的插入测试 =====
    print("\n【6. 带值的插入测试】")
    trie2 = Trie()
    trie2.insert("python", value={"type": "language", "year": 1991})
    trie2.insert("pytorch", value={"type": "framework", "year": 2016})
    trie2.insert("pandas", value={"type": "library", "year": 2008})

    print("插入带值的单词:")
    for word in ["python", "pytorch", "pandas"]:
        node = trie2._get_node(word)
        if node:
            print(f"  {word}: {node.value}")

    # ===== 7. 性能测试 =====
    print("\n【7. 性能测试】")
    import time

    # 插入性能
    trie3 = Trie()
    start = time.time()
    for i in range(10000):
        trie3.insert(f"word{i}")
    insert_time = time.time() - start
    print(f"插入 10,000 个单词: {insert_time:.3f}s")

    # 查找性能
    start = time.time()
    for i in range(10000):
        trie3.search(f"word{i}")
    search_time = time.time() - start
    print(f"查找 10,000 个单词: {search_time:.3f}s")

    # 前缀查询性能
    start = time.time()
    for i in range(100):
        trie3.get_words_with_prefix(f"word{i}")
    prefix_time = time.time() - start
    print(f"前缀查询 100 次: {prefix_time:.3f}s")

    print("\n" + "=" * 50)
    print("测试完成")
    print("=" * 50)
```

## 预期输出

```
==================================================
基础 Trie 实现测试
==================================================

【1. 插入测试】
插入单词: ['cat', 'car', 'card', 'dog', 'door']

【2. 精确查找测试】
search('cat'): True
search('ca'): False
search('dog'): True
search('door'): True
search('apple'): False

【3. 前缀查找测试】
starts_with('ca'): True
starts_with('do'): True
starts_with('d'): True
starts_with('x'): False

【4. 前缀补全测试】
get_words_with_prefix('ca'): ['cat', 'car', 'card']
get_words_with_prefix('do'): ['dog', 'door']
get_words_with_prefix('d'): ['dog', 'door']

【5. 删除测试】
删除 'card'
search('card'): False
search('car'): True
get_words_with_prefix('ca'): ['cat', 'car']

删除 'car'
search('car'): False
search('cat'): True
get_words_with_prefix('ca'): ['cat']

【6. 带值的插入测试】
插入带值的单词:
  python: {'type': 'language', 'year': 1991}
  pytorch: {'type': 'framework', 'year': 2016}
  pandas: {'type': 'library', 'year': 2008}

【7. 性能测试】
插入 10,000 个单词: 0.015s
查找 10,000 个单词: 0.012s
前缀查询 100 次: 0.008s

==================================================
测试完成
==================================================
```

## 代码说明

### 核心功能

1. **插入（insert）**
   - 逐字符遍历，不存在则创建节点
   - 支持存储关联值

2. **查找（search）**
   - 精确匹配，必须检查 `is_end`

3. **前缀查找（starts_with）**
   - 只检查前缀是否存在，不检查 `is_end`

4. **前缀补全（get_words_with_prefix）**
   - DFS 遍历子树，收集所有单词

5. **删除（delete）**
   - 递归回溯，只删除不再使用的节点

### 时间复杂度

- 插入：O(m)
- 查找：O(m)
- 前缀查找：O(m)
- 前缀补全：O(m + k)
- 删除：O(m)

其中 m 是单词长度，k 是结果数量。

### 空间复杂度

- 最坏情况：O(ALPHABET_SIZE × n × m)
- 实际情况：取决于前缀共享程度

---

**版本**: v1.0
**最后更新**: 2026-02-14
**运行环境**: Python 3.9+
