# 核心概念 1：类型注解基础

## 一句话定义

**类型注解是在 Python 代码中添加类型信息的语法，让类型检查器在编写时发现类型错误，而不影响运行时性能。**

---

## 为什么需要类型注解？

Python 是动态类型语言，变量类型在运行时才确定：

```python
# 动态类型的问题
def greet(name):
    return f"Hello, {name.upper()}"

greet("Alice")  # ✅ 正常工作
greet(123)      # ❌ 运行时才报错：AttributeError: 'int' object has no attribute 'upper'
```

**问题**：错误要到运行时才发现，成本高（可能已经部署到生产环境）。

**解决方案**：类型注解 + 类型检查器（mypy/pyright）在编写时发现错误：

```python
def greet(name: str) -> str:
    return f"Hello, {name.upper()}"

greet("Alice")  # ✅ 类型检查通过
greet(123)      # ❌ 类型检查器立即报错：Argument of type "int" cannot be assigned to parameter "name" of type "str"
```

---

## 基础类型注解语法

### 1. 变量类型注解

```python
# 基础类型
name: str = "Alice"
age: int = 30
height: float = 1.75
is_student: bool = True

# 容器类型（Python 3.9+）
numbers: list[int] = [1, 2, 3]
scores: dict[str, float] = {"math": 95.5, "english": 88.0}
coordinates: tuple[int, int] = (10, 20)
unique_ids: set[str] = {"id1", "id2"}

# 旧版本语法（Python 3.8 及以下）
from typing import List, Dict, Tuple, Set
numbers: List[int] = [1, 2, 3]
scores: Dict[str, float] = {"math": 95.5}
```

**2025-2026 最佳实践**：
- ✅ Python 3.9+ 使用内置类型（`list[int]` 而非 `List[int]`）
- ✅ Python 3.10+ 使用 `|` 联合类型（`str | int` 而非 `Union[str, int]`）

### 2. 函数类型注解

```python
# 基础函数注解
def add(a: int, b: int) -> int:
    return a + b

# 无返回值
def log_message(message: str) -> None:
    print(message)

# 可选参数（Python 3.10+）
def greet(name: str, title: str | None = None) -> str:
    if title:
        return f"Hello, {title} {name}"
    return f"Hello, {name}"

# 旧版本语法
from typing import Optional
def greet(name: str, title: Optional[str] = None) -> str:
    ...
```

### 3. 类类型注解

```python
class User:
    # 类属性注解
    name: str
    age: int
    email: str | None  # 可选字段

    def __init__(self, name: str, age: int, email: str | None = None):
        self.name = name
        self.age = age
        self.email = email

    def get_info(self) -> str:
        return f"{self.name} ({self.age})"

    def update_email(self, email: str) -> None:
        self.email = email
```

---

## 常用类型注解

### 1. Optional 和 Union

```python
from typing import Optional

# Optional[T] 等价于 T | None
def find_user(user_id: int) -> Optional[str]:
    # 可能返回 str，也可能返回 None
    if user_id > 0:
        return f"User {user_id}"
    return None

# Python 3.10+ 推荐写法
def find_user(user_id: int) -> str | None:
    ...

# Union 表示多种类型之一
from typing import Union
def process(value: Union[int, str, float]) -> str:
    return str(value)

# Python 3.10+ 推荐写法
def process(value: int | str | float) -> str:
    return str(value)
```

### 2. List、Dict、Tuple、Set

```python
from typing import List, Dict, Tuple, Set

# 列表：所有元素同类型
def sum_numbers(numbers: list[int]) -> int:
    return sum(numbers)

# 字典：键值类型
def count_words(text: str) -> dict[str, int]:
    words = text.split()
    return {word: words.count(word) for word in set(words)}

# 元组：固定长度和类型
def get_coordinates() -> tuple[int, int]:
    return (10, 20)

# 元组：可变长度
def get_scores() -> tuple[float, ...]:
    return (95.5, 88.0, 92.3)

# 集合
def get_unique_tags() -> set[str]:
    return {"python", "typing", "langchain"}
```

### 3. Callable（函数类型）

```python
from typing import Callable

# Callable[[参数类型...], 返回类型]
def apply_operation(x: int, y: int, op: Callable[[int, int], int]) -> int:
    return op(x, y)

# 使用示例
def add(a: int, b: int) -> int:
    return a + b

result = apply_operation(5, 3, add)  # 8
result = apply_operation(5, 3, lambda a, b: a * b)  # 15
```

### 4. Any（任意类型）

```python
from typing import Any

# Any 表示任意类型（失去类型检查）
def process_data(data: Any) -> Any:
    # 类型检查器不会检查 data 的操作
    return data.some_method()  # 不会报错，即使 some_method 不存在

# ⚠️ 尽量避免使用 Any，它会让类型检查失效
```

---

## 类型别名（Type Alias）

```python
# 简化复杂类型
UserId = int
UserName = str
UserData = dict[str, str | int]

def get_user(user_id: UserId) -> UserData:
    return {"name": "Alice", "age": 30}

# 复杂类型别名
from typing import Callable
Transform = Callable[[str], str]

def apply_transform(text: str, transform: Transform) -> str:
    return transform(text)

# Python 3.12+ 新语法
type UserId = int
type Transform = Callable[[str], str]
```

---

## 在 LangChain 中的应用

### 1. Runnable 输入输出类型

```python
from langchain_core.runnables import Runnable, RunnableLambda

# 定义类型安全的 Runnable
def process_text(text: str) -> str:
    return text.upper()

# RunnableLambda 自动推断类型为 Runnable[str, str]
runnable: Runnable[str, str] = RunnableLambda(process_text)

# 类型检查器会验证输入输出类型
result: str = runnable.invoke("hello")  # ✅ 类型正确
result: int = runnable.invoke("hello")  # ❌ 类型错误：Cannot assign str to int
```

### 2. ChatModel 消息类型

```python
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langchain_openai import ChatOpenAI

# 消息列表类型注解
messages: list[BaseMessage] = [
    HumanMessage(content="Hello"),
    AIMessage(content="Hi there!")
]

# ChatModel 的类型签名
model: ChatOpenAI = ChatOpenAI(model="gpt-4")
response: AIMessage = model.invoke(messages)
```

### 3. PromptTemplate 类型

```python
from langchain_core.prompts import PromptTemplate, ChatPromptTemplate

# PromptTemplate 输入类型
template: PromptTemplate = PromptTemplate.from_template(
    "Tell me a joke about {topic}"
)

# 输入必须是 dict[str, Any]
prompt_value = template.invoke({"topic": "programming"})  # ✅
prompt_value = template.invoke("programming")  # ❌ 类型错误
```

### 4. OutputParser 类型

```python
from langchain_core.output_parsers import StrOutputParser, JsonOutputParser
from pydantic import BaseModel

# StrOutputParser: Runnable[str | BaseMessage, str]
str_parser: StrOutputParser = StrOutputParser()
output: str = str_parser.invoke("Hello")

# JsonOutputParser: Runnable[str | BaseMessage, dict]
class User(BaseModel):
    name: str
    age: int

json_parser: JsonOutputParser = JsonOutputParser(pydantic_object=User)
output: dict = json_parser.invoke('{"name": "Alice", "age": 30}')
```

---

## 2025-2026 最佳实践

### 1. 使用现代语法

```python
# ❌ 旧语法（Python 3.8）
from typing import List, Dict, Optional, Union
def process(items: List[str], config: Optional[Dict[str, Union[int, str]]]) -> List[str]:
    ...

# ✅ 新语法（Python 3.10+）
def process(items: list[str], config: dict[str, int | str] | None) -> list[str]:
    ...
```

### 2. 渐进式类型注解

```python
# 不需要一次性给所有代码加类型注解
# 优先给公共 API 和关键函数加注解

# ✅ 公共 API 必须有类型注解
def public_api(input: str) -> dict[str, Any]:
    result = _internal_helper(input)  # 内部函数可以暂时不加
    return result

# 内部函数可以逐步添加
def _internal_helper(input):
    ...
```

### 3. 避免过度注解

```python
# ❌ 过度注解（显而易见的类型）
x: int = 42
name: str = "Alice"
items: list[int] = [1, 2, 3]

# ✅ 只在需要时注解（类型不明显或需要文档）
x = 42  # 类型显而易见
name = "Alice"
items = [1, 2, 3]

# ✅ 函数签名必须注解
def process(data: dict[str, Any]) -> list[str]:
    result = []  # 局部变量类型可推断，不需要注解
    for key, value in data.items():
        result.append(str(value))
    return result
```

### 4. 使用类型检查器

```bash
# mypy 检查
uv run mypy src/

# pyright 检查（更快）
uv run pyright src/

# 配置 mypy
# mypy.ini
[mypy]
python_version = 3.13
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
```

---

## 常见陷阱

### 1. 运行时类型检查

```python
# ❌ 类型注解不会在运行时检查
def add(a: int, b: int) -> int:
    return a + b

result = add("hello", "world")  # 运行时不会报错！返回 "helloworld"

# ✅ 需要显式运行时检查
def add(a: int, b: int) -> int:
    if not isinstance(a, int) or not isinstance(b, int):
        raise TypeError("Arguments must be integers")
    return a + b
```

### 2. 可变默认参数

```python
# ❌ 可变默认参数陷阱
def append_to(item: str, target: list[str] = []) -> list[str]:
    target.append(item)
    return target

list1 = append_to("a")  # ["a"]
list2 = append_to("b")  # ["a", "b"] ⚠️ 共享同一个列表！

# ✅ 使用 None 作为默认值
def append_to(item: str, target: list[str] | None = None) -> list[str]:
    if target is None:
        target = []
    target.append(item)
    return target
```

### 3. 循环导入

```python
# ❌ 循环导入导致类型注解失败
# a.py
from b import B
class A:
    def get_b(self) -> B:
        ...

# b.py
from a import A
class B:
    def get_a(self) -> A:
        ...

# ✅ 使用字符串注解（Python 3.7+）
# a.py
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from b import B

class A:
    def get_b(self) -> "B":
        ...

# ✅ 使用 from __future__ import annotations（Python 3.10+）
from __future__ import annotations
from b import B

class A:
    def get_b(self) -> B:  # 自动变成字符串注解
        ...
```

---

## 实战示例：类型安全的 LangChain 组件

```python
from typing import Any
from langchain_core.runnables import Runnable, RunnableLambda
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langchain_openai import ChatOpenAI

# 1. 定义类型安全的转换函数
def format_message(text: str) -> list[BaseMessage]:
    """将文本转换为消息列表"""
    return [HumanMessage(content=text)]

def extract_content(message: AIMessage) -> str:
    """从 AI 消息中提取内容"""
    return message.content

# 2. 构建类型安全的 LCEL 链
model: ChatOpenAI = ChatOpenAI(model="gpt-4o-mini")

# 每个组件的类型都是明确的
formatter: Runnable[str, list[BaseMessage]] = RunnableLambda(format_message)
extractor: Runnable[AIMessage, str] = RunnableLambda(extract_content)

# 组合成完整的链
chain: Runnable[str, str] = formatter | model | extractor

# 3. 类型检查器会验证整个链的类型
result: str = chain.invoke("Tell me a joke")  # ✅ 类型正确
result: int = chain.invoke("Tell me a joke")  # ❌ 类型错误
```

---

## 学习检查清单

- [ ] 理解类型注解的作用（编译时检查，不影响运行时）
- [ ] 掌握基础类型注解语法（变量、函数、类）
- [ ] 熟悉常用类型（Optional, Union, List, Dict, Callable）
- [ ] 了解类型别名的使用
- [ ] 知道如何在 LangChain 中使用类型注解
- [ ] 掌握 2025-2026 最佳实践（现代语法、渐进式注解）
- [ ] 避免常见陷阱（运行时检查、可变默认参数、循环导入）

---

## 下一步学习

- **核心概念 2**：TypeVar 与泛型 - 学习如何创建泛型函数和类
- **核心概念 4**：Runnable 泛型设计 - 深入理解 LangChain 的类型系统
- **核心概念 9**：mypy 与 pyright - 学习使用类型检查工具

---

## 参考资源

1. [Python typing 官方文档](https://docs.python.org/3/library/typing.html) - Python 3.13
2. [PEP 484 – Type Hints](https://peps.python.org/pep-0484/) - 类型注解规范
3. [PEP 585 – Type Hinting Generics In Standard Collections](https://peps.python.org/pep-0585/) - Python 3.9+ 内置泛型
4. [PEP 604 – Allow writing union types as X | Y](https://peps.python.org/pep-0604/) - Python 3.10+ 联合类型
5. [Real Python - Python Type Checking Guide](https://realpython.com/python-type-checking/) - 实用教程
6. [LangChain Runnables 文档](https://reference.langchain.com/python/langchain_core/runnables) - LangChain 类型系统
