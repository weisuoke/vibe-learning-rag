# æ ¸å¿ƒæ¦‚å¿µ4ï¼šè¯­ä¹‰ç¼“å­˜ä¸ç›¸ä¼¼åº¦åŒ¹é…

## æ¦‚è¿°

è¯­ä¹‰ç¼“å­˜é€šè¿‡ç†è§£é—®é¢˜çš„è¯­ä¹‰ï¼ŒåŒ¹é…è¡¨è¾¾æ–¹å¼ä¸åŒä½†å«ä¹‰ç›¸åŒçš„é—®é¢˜ï¼Œæ˜¾è‘—æå‡ç¼“å­˜å‘½ä¸­ç‡ã€‚

---

## 1. è¯­ä¹‰ç¼“å­˜åŸç†

### æ ¸å¿ƒæ€æƒ³

```python
# ç²¾ç¡®ç¼“å­˜ï¼šåªèƒ½åŒ¹é…å®Œå…¨ç›¸åŒçš„é—®é¢˜
"What is Python?" âœ“ å‘½ä¸­
"Pythonæ˜¯ä»€ä¹ˆï¼Ÿ" âœ— æœªå‘½ä¸­ï¼ˆè¡¨è¾¾ä¸åŒï¼‰

# è¯­ä¹‰ç¼“å­˜ï¼šå¯ä»¥åŒ¹é…è¯­ä¹‰ç›¸åŒçš„é—®é¢˜
"What is Python?" âœ“ å‘½ä¸­
"Pythonæ˜¯ä»€ä¹ˆï¼Ÿ" âœ“ å‘½ä¸­ï¼ˆè¯­ä¹‰ç›¸åŒï¼Œç›¸ä¼¼åº¦>0.9ï¼‰
"è¯·ä»‹ç»Python" âœ“ å‘½ä¸­ï¼ˆè¯­ä¹‰ç›¸åŒï¼Œç›¸ä¼¼åº¦>0.9ï¼‰
```

### å·¥ä½œæµç¨‹

```
1. ç”¨æˆ·æé—® â†’ 2. è½¬æ¢ä¸ºEmbeddingå‘é‡ â†’ 3. è®¡ç®—ä¸ç¼“å­˜çš„ç›¸ä¼¼åº¦
   â†“                                              â†“
   "Pythonæ˜¯ä»€ä¹ˆï¼Ÿ"                               ç›¸ä¼¼åº¦>0.9ï¼Ÿ
                                                  â†“
                                            æ˜¯ï¼šè¿”å›ç¼“å­˜
                                            å¦ï¼šè°ƒç”¨LLMå¹¶ç¼“å­˜
```

---

## 2. ç›¸ä¼¼åº¦è®¡ç®—æ–¹æ³•

### ä½™å¼¦ç›¸ä¼¼åº¦ï¼ˆæ¨èï¼‰

```python
import numpy as np

def cosine_similarity(a: List[float], b: List[float]) -> float:
    """è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦"""
    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

# ç¤ºä¾‹
vec1 = [0.1, 0.2, 0.3]
vec2 = [0.15, 0.25, 0.35]
similarity = cosine_similarity(vec1, vec2)
print(f"ç›¸ä¼¼åº¦: {similarity:.3f}")  # 0.999
```

### æ¬§æ°è·ç¦»

```python
def euclidean_distance(a: List[float], b: List[float]) -> float:
    """è®¡ç®—æ¬§æ°è·ç¦»ï¼ˆè¶Šå°è¶Šç›¸ä¼¼ï¼‰"""
    return np.linalg.norm(np.array(a) - np.array(b))

# è½¬æ¢ä¸ºç›¸ä¼¼åº¦ï¼ˆ0-1ï¼‰
def euclidean_similarity(a: List[float], b: List[float]) -> float:
    distance = euclidean_distance(a, b)
    return 1 / (1 + distance)
```

### ç‚¹ç§¯ç›¸ä¼¼åº¦

```python
def dot_product_similarity(a: List[float], b: List[float]) -> float:
    """è®¡ç®—ç‚¹ç§¯ç›¸ä¼¼åº¦"""
    return np.dot(a, b)
```

### å¯¹æ¯”

| æ–¹æ³• | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| ä½™å¼¦ç›¸ä¼¼åº¦ | ä¸å—å‘é‡é•¿åº¦å½±å“ | è®¡ç®—ç¨æ…¢ | æ–‡æœ¬è¯­ä¹‰åŒ¹é…ï¼ˆæ¨èï¼‰ |
| æ¬§æ°è·ç¦» | è®¡ç®—å¿« | å—å‘é‡é•¿åº¦å½±å“ | å›¾åƒç›¸ä¼¼åº¦ |
| ç‚¹ç§¯ | æœ€å¿« | å—å‘é‡é•¿åº¦å½±å“ | å·²å½’ä¸€åŒ–çš„å‘é‡ |

---

## 3. å®Œæ•´å®ç°

```python
import hashlib
import json
from typing import List, Optional, Dict
import numpy as np
import redis
from openai import OpenAI

class SemanticCache:
    """è¯­ä¹‰ç¼“å­˜"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.openai_client = OpenAI()
        self.cache_hash_key = "semantic_cache"

    def _get_embedding(self, text: str) -> List[float]:
        """è·å–Embeddingï¼ˆå¸¦ç¼“å­˜ï¼‰"""
        cache_key = f"emb:{hashlib.md5(text.encode()).hexdigest()}"
        cached = self.redis.get(cache_key)
        if cached:
            return json.loads(cached)

        response = self.openai_client.embeddings.create(
            model="text-embedding-3-small",
            input=text
        )
        embedding = response.data[0].embedding
        self.redis.setex(cache_key, 86400, json.dumps(embedding))
        return embedding

    def _cosine_similarity(self, a: List[float], b: List[float]) -> float:
        """è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦"""
        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

    def add(self, query: str, response: str, ttl: int = 3600):
        """æ·»åŠ è¯­ä¹‰ç¼“å­˜"""
        query_embedding = self._get_embedding(query)

        cache_data = {
            "query": query,
            "response": response,
            "embedding": query_embedding,
            "timestamp": time.time()
        }

        cache_id = hashlib.md5(query.encode()).hexdigest()
        self.redis.hset(
            self.cache_hash_key,
            cache_id,
            json.dumps(cache_data)
        )
        self.redis.expire(self.cache_hash_key, ttl)

    def lookup(
        self,
        query: str,
        threshold: float = 0.9
    ) -> Optional[Dict]:
        """æŸ¥è¯¢è¯­ä¹‰ç¼“å­˜"""
        query_embedding = self._get_embedding(query)
        cached_items = self.redis.hgetall(self.cache_hash_key)

        best_match = None
        best_score = 0.0

        for cache_id, cache_data_json in cached_items.items():
            cache_data = json.loads(cache_data_json)
            cached_embedding = cache_data["embedding"]

            similarity = self._cosine_similarity(
                query_embedding,
                cached_embedding
            )

            if similarity > best_score:
                best_score = similarity
                best_match = {
                    "response": cache_data["response"],
                    "similarity": similarity,
                    "original_query": cache_data["query"]
                }

        if best_score >= threshold:
            print(f"âœ… è¯­ä¹‰ç¼“å­˜å‘½ä¸­ï¼Œç›¸ä¼¼åº¦={best_score:.3f}")
            return best_match

        print(f"âŒ æœªå‘½ä¸­ï¼Œæœ€é«˜ç›¸ä¼¼åº¦={best_score:.3f}")
        return None
```

---

## 4. é˜ˆå€¼é€‰æ‹©

### ä¸åŒé˜ˆå€¼çš„æ•ˆæœ

```python
# æµ‹è¯•ä¸åŒé˜ˆå€¼
test_cases = [
    ("What is Python?", "Pythonæ˜¯ä»€ä¹ˆï¼Ÿ", 0.95),
    ("What is Python?", "è¯·ä»‹ç»Python", 0.88),
    ("What is Python?", "Pythonçš„å†å²", 0.75),
    ("What is Python?", "JavaScriptæ˜¯ä»€ä¹ˆï¼Ÿ", 0.60),
]

for query1, query2, expected_sim in test_cases:
    emb1 = get_embedding(query1)
    emb2 = get_embedding(query2)
    sim = cosine_similarity(emb1, emb2)
    print(f"{query1} vs {query2}: {sim:.3f}")
```

### æ¨èé˜ˆå€¼

| é˜ˆå€¼ | æ•ˆæœ | é€‚ç”¨åœºæ™¯ |
|------|------|---------|
| 0.95+ | éå¸¸ä¸¥æ ¼ï¼Œå‡ ä¹ç­‰åŒäºç²¾ç¡®åŒ¹é… | é‡‘èã€åŒ»ç–—ç­‰é«˜å‡†ç¡®åº¦åœºæ™¯ |
| 0.90-0.95 | ä¸¥æ ¼ï¼ŒåªåŒ¹é…è¯­ä¹‰éå¸¸æ¥è¿‘çš„é—®é¢˜ | é€šç”¨é—®ç­”ï¼ˆæ¨èï¼‰ |
| 0.85-0.90 | å®½æ¾ï¼Œå¯èƒ½åŒ¹é…ç›¸å…³ä½†ä¸å®Œå…¨ç›¸åŒçš„é—®é¢˜ | æ¢ç´¢æ€§é—®ç­” |
| <0.85 | è¿‡äºå®½æ¾ï¼Œå¯èƒ½è¯¯åŒ¹é… | ä¸æ¨è |

---

## 5. ä¼˜åŒ–ç­–ç•¥

### ç­–ç•¥1ï¼šå‘é‡ç´¢å¼•ï¼ˆFAISSï¼‰

```python
import faiss
import numpy as np

class FAISSSemanticCache:
    """ä½¿ç”¨FAISSåŠ é€Ÿå‘é‡æ£€ç´¢"""

    def __init__(self, dimension: int = 1536):
        self.dimension = dimension
        self.index = faiss.IndexFlatIP(dimension)  # å†…ç§¯ç´¢å¼•
        self.cache_data = []

    def add(self, query: str, response: str, embedding: List[float]):
        """æ·»åŠ ç¼“å­˜"""
        # å½’ä¸€åŒ–å‘é‡ï¼ˆç”¨äºä½™å¼¦ç›¸ä¼¼åº¦ï¼‰
        embedding_np = np.array([embedding], dtype=np.float32)
        faiss.normalize_L2(embedding_np)

        # æ·»åŠ åˆ°ç´¢å¼•
        self.index.add(embedding_np)

        # å­˜å‚¨æ•°æ®
        self.cache_data.append({
            "query": query,
            "response": response
        })

    def lookup(
        self,
        query_embedding: List[float],
        threshold: float = 0.9,
        top_k: int = 1
    ) -> Optional[Dict]:
        """æŸ¥è¯¢ç¼“å­˜"""
        # å½’ä¸€åŒ–æŸ¥è¯¢å‘é‡
        query_np = np.array([query_embedding], dtype=np.float32)
        faiss.normalize_L2(query_np)

        # æœç´¢æœ€ç›¸ä¼¼çš„å‘é‡
        similarities, indices = self.index.search(query_np, top_k)

        if similarities[0][0] >= threshold:
            idx = indices[0][0]
            return {
                "response": self.cache_data[idx]["response"],
                "similarity": float(similarities[0][0]),
                "original_query": self.cache_data[idx]["query"]
            }

        return None
```

### ç­–ç•¥2ï¼šåˆ†å±‚æ£€ç´¢

```python
class TieredSemanticCache:
    """åˆ†å±‚è¯­ä¹‰ç¼“å­˜"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.hot_cache = {}  # çƒ­ç‚¹ç¼“å­˜ï¼ˆå†…å­˜ï¼‰
        self.max_hot_size = 100

    def lookup(self, query: str, threshold: float = 0.9):
        """åˆ†å±‚æŸ¥è¯¢"""
        query_embedding = self._get_embedding(query)

        # 1. å…ˆæŸ¥çƒ­ç‚¹ç¼“å­˜ï¼ˆå†…å­˜ï¼‰
        for cached_query, cache_data in self.hot_cache.items():
            similarity = self._cosine_similarity(
                query_embedding,
                cache_data["embedding"]
            )
            if similarity >= threshold:
                print(f"ğŸ”¥ çƒ­ç‚¹ç¼“å­˜å‘½ä¸­")
                return cache_data["response"]

        # 2. å†æŸ¥Redisç¼“å­˜
        result = self._lookup_redis(query_embedding, threshold)
        if result:
            # æå‡åˆ°çƒ­ç‚¹ç¼“å­˜
            self._add_to_hot_cache(query, result)

        return result
```

---

## 6. æ··åˆç­–ç•¥

```python
class HybridCache:
    """æ··åˆç¼“å­˜ï¼šç²¾ç¡® + è¯­ä¹‰"""

    def __init__(self, redis_client: redis.Redis):
        self.exact_cache = ExactLLMCache(redis_client)
        self.semantic_cache = SemanticCache(redis_client)

    async def get_or_generate(
        self,
        prompt: str,
        llm_func,
        semantic_threshold: float = 0.9
    ) -> str:
        """æ··åˆæŸ¥è¯¢"""
        # 1. å…ˆå°è¯•ç²¾ç¡®ç¼“å­˜ï¼ˆæœ€å¿«ï¼‰
        exact_result = self.exact_cache.get_cached_response(prompt)
        if exact_result:
            print("âœ… ç²¾ç¡®ç¼“å­˜å‘½ä¸­")
            return exact_result

        # 2. å†å°è¯•è¯­ä¹‰ç¼“å­˜
        semantic_result = self.semantic_cache.lookup(
            prompt,
            threshold=semantic_threshold
        )
        if semantic_result:
            print(f"âœ… è¯­ä¹‰ç¼“å­˜å‘½ä¸­ï¼Œç›¸ä¼¼åº¦={semantic_result['similarity']:.3f}")
            # å°†è¯­ä¹‰ç¼“å­˜ç»“æœä¹Ÿå­˜å…¥ç²¾ç¡®ç¼“å­˜
            self.exact_cache.set_cached_response(
                prompt,
                semantic_result["response"]
            )
            return semantic_result["response"]

        # 3. è°ƒç”¨LLM
        print("ğŸ¤– è°ƒç”¨LLM API")
        response = await llm_func(prompt)

        # 4. åŒæ—¶ç¼“å­˜åˆ°ç²¾ç¡®å’Œè¯­ä¹‰ç¼“å­˜
        self.exact_cache.set_cached_response(prompt, response)
        self.semantic_cache.add(prompt, response)

        return response
```

---

## æ€»ç»“

1. **è¯­ä¹‰ç¼“å­˜**ï¼šé€šè¿‡Embeddingå’Œç›¸ä¼¼åº¦åŒ¹é…ï¼Œæå‡å‘½ä¸­ç‡
2. **ä½™å¼¦ç›¸ä¼¼åº¦**ï¼šæœ€é€‚åˆæ–‡æœ¬è¯­ä¹‰åŒ¹é…
3. **é˜ˆå€¼é€‰æ‹©**ï¼šæ¨è0.90-0.95ï¼Œå¹³è¡¡å‡†ç¡®åº¦å’Œå‘½ä¸­ç‡
4. **ä¼˜åŒ–ç­–ç•¥**ï¼šFAISSåŠ é€Ÿã€åˆ†å±‚æ£€ç´¢ã€æ··åˆç­–ç•¥
5. **æ··åˆç¼“å­˜**ï¼šç²¾ç¡®ç¼“å­˜ + è¯­ä¹‰ç¼“å­˜ï¼Œå…¼é¡¾é€Ÿåº¦å’Œå‘½ä¸­ç‡

**è®°ä½ï¼š** è¯­ä¹‰ç¼“å­˜é€‚åˆå¼€æ”¾å¼é—®ç­”ï¼Œä½†éœ€è¦æƒè¡¡è®¡ç®—æˆæœ¬å’Œå‘½ä¸­ç‡æå‡ã€‚
