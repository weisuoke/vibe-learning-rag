# 核心概念2：滑动窗口算法

> 精确的限流算法，解决固定窗口的边界问题

---

## 概述

**滑动窗口算法**（Sliding Window）通过记录每个请求的时间戳，统计最近N秒内的请求数，实现精确限流。

**核心思想：**
```
记录所有请求的时间戳
统计最近N秒内的请求数
移除过期的请求记录
精确控制，无窗口边界问题
```

---

## 算法原理

### 基本概念

**滑动窗口 = 请求时间戳列表 + 过期清理 + 计数检查**

```
时间轴（窗口大小60秒）：
现在是 1:00:30

滑动窗口：[1:00:30 - 60秒, 1:00:30] = [0:59:30, 1:00:30]

请求记录：
[0:59:35, 0:59:40, 0:59:50, 1:00:10, 1:00:20, 1:00:30]
   ↑                                              ↑
 最早的请求                                    最新的请求

过期清理：
移除 < 0:59:30 的请求
```

**工作流程：**
1. 请求到达
2. 移除过期的请求（时间戳 < now - window）
3. 检查剩余请求数是否 < 限制
4. 如果是，添加当前请求时间戳，允许请求
5. 否则，拒绝请求

---

### 可视化

```
限制：每60秒最多10个请求

时间轴：
0:59:30 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1:00:30
        ↑                                                           ↑
      窗口开始                                                    窗口结束
                                                                  (当前时间)

请求记录：
0:59:35 ●
0:59:40     ●
0:59:50           ●
1:00:10                     ●
1:00:20                           ●
1:00:30                                 ●

窗口滑动（1秒后，现在是 1:00:31）：
0:59:31 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1:00:31
        ↑                                                           ↑
      窗口开始                                                    窗口结束
      (0:59:35 被移除)

请求记录：
0:59:40 ●
0:59:50     ●
1:00:10           ●
1:00:20                 ●
1:00:30                       ●
1:00:31                             ●
```

---

## 手写实现

### 版本1：滑动日志（Sliding Log）

```python
import time
from typing import List

class SlidingWindowLimiter:
    """
    滑动窗口限流器（滑动日志实现）

    原理：记录所有请求时间戳，统计最近N秒内的请求数
    """

    def __init__(self, limit: int, window: int):
        """
        Args:
            limit: 窗口内最多允许的请求数
            window: 窗口大小（秒）
        """
        self.limit = limit
        self.window = window
        self.requests: List[float] = []  # 存储请求时间戳

    def acquire(self) -> bool:
        """
        尝试获取一个请求配额

        Returns:
            True: 允许请求
            False: 拒绝请求
        """
        now = time.time()

        # 移除过期请求（时间戳 < now - window）
        self.requests = [t for t in self.requests if now - t < self.window]

        # 检查是否超过限制
        if len(self.requests) < self.limit:
            self.requests.append(now)
            return True

        return False

    def get_status(self) -> dict:
        """获取当前状态"""
        now = time.time()
        # 清理过期请求
        self.requests = [t for t in self.requests if now - t < self.window]

        return {
            "count": len(self.requests),
            "limit": self.limit,
            "oldest_request": min(self.requests) if self.requests else None,
            "newest_request": max(self.requests) if self.requests else None
        }


# 使用示例
if __name__ == "__main__":
    # 每10秒最多5个请求
    limiter = SlidingWindowLimiter(limit=5, window=10)

    # 模拟请求
    for i in range(10):
        if limiter.acquire():
            print(f"请求{i}: ✅ 通过")
        else:
            print(f"请求{i}: ❌ 被限流")

        status = limiter.get_status()
        print(f"  状态: {status['count']}/{status['limit']}")

        time.sleep(1)
```

---

### 版本2：滑动计数器（Sliding Window Counter）

滑动日志的问题是内存占用大（每个请求都要存储）。滑动计数器优化了这一点。

**原理：** 将窗口分成多个小格子，只存储每个格子的计数。

```python
import time
from collections import defaultdict

class SlidingWindowCounterLimiter:
    """
    滑动窗口计数器限流器

    原理：将窗口分成多个小格子，只存储每个格子的计数
    空间复杂度：O(k)，k 是格子数
    """

    def __init__(self, limit: int, window: int, granularity: int = 10):
        """
        Args:
            limit: 窗口内最多允许的请求数
            window: 窗口大小（秒）
            granularity: 格子数（窗口被分成多少个小格子）
        """
        self.limit = limit
        self.window = window
        self.granularity = granularity
        self.slot_size = window / granularity  # 每个格子的大小
        self.slots = defaultdict(int)  # {slot_id: count}

    def _get_slot_id(self, timestamp: float) -> int:
        """获取时间戳对应的格子ID"""
        return int(timestamp / self.slot_size)

    def acquire(self) -> bool:
        """尝试获取一个请求配额"""
        now = time.time()
        current_slot = self._get_slot_id(now)

        # 移除过期格子
        expired_slot = self._get_slot_id(now - self.window)
        self.slots = {
            slot: count
            for slot, count in self.slots.items()
            if slot > expired_slot
        }

        # 统计当前窗口内的请求数
        total_count = sum(self.slots.values())

        # 检查是否超过限制
        if total_count < self.limit:
            self.slots[current_slot] += 1
            return True

        return False

    def get_status(self) -> dict:
        """获取当前状态"""
        now = time.time()
        expired_slot = self._get_slot_id(now - self.window)

        # 清理过期格子
        self.slots = {
            slot: count
            for slot, count in self.slots.items()
            if slot > expired_slot
        }

        return {
            "count": sum(self.slots.values()),
            "limit": self.limit,
            "active_slots": len(self.slots)
        }


# 使用示例
if __name__ == "__main__":
    # 每10秒最多5个请求，分成10个格子
    limiter = SlidingWindowCounterLimiter(limit=5, window=10, granularity=10)

    for i in range(10):
        if limiter.acquire():
            print(f"请求{i}: ✅ 通过")
        else:
            print(f"请求{i}: ❌ 被限流")

        status = limiter.get_status()
        print(f"  状态: {status['count']}/{status['limit']}, "
              f"活跃格子: {status['active_slots']}")

        time.sleep(1)
```

---

### 版本3：Redis Sorted Set 实现

```python
import redis
import time

class RedisSlidingWindowLimiter:
    """
    基于 Redis Sorted Set 的滑动窗口限流器

    使用 Sorted Set 存储请求时间戳，score 是时间戳
    """

    def __init__(self, redis_client: redis.Redis, key: str, limit: int, window: int):
        self.redis = redis_client
        self.key = key
        self.limit = limit
        self.window = window

    def acquire(self) -> bool:
        """尝试获取一个请求配额"""
        now = time.time()
        window_start = now - self.window

        # Lua 脚本保证原子性
        lua_script = """
        local key = KEYS[1]
        local now = tonumber(ARGV[1])
        local window_start = tonumber(ARGV[2])
        local limit = tonumber(ARGV[3])

        -- 移除过期请求
        redis.call('ZREMRANGEBYSCORE', key, '-inf', window_start)

        -- 统计当前窗口内的请求数
        local count = redis.call('ZCARD', key)

        -- 检查是否超过限制
        if count < limit then
            -- 添加当前请求
            redis.call('ZADD', key, now, now)
            -- 设置过期时间
            redis.call('EXPIRE', key, math.ceil(ARGV[4]))
            return 1
        end

        return 0
        """

        result = self.redis.eval(
            lua_script,
            1,  # 1个key
            self.key,
            now,
            window_start,
            self.limit,
            self.window
        )

        return result == 1

    def get_status(self) -> dict:
        """获取当前状态"""
        now = time.time()
        window_start = now - self.window

        # 移除过期请求
        self.redis.zremrangebyscore(self.key, '-inf', window_start)

        # 统计当前窗口内的请求数
        count = self.redis.zcard(self.key)

        return {
            "count": count,
            "limit": self.limit
        }


# 使用示例
if __name__ == "__main__":
    redis_client = redis.Redis(host='localhost', port=6379, db=0)

    limiter = RedisSlidingWindowLimiter(
        redis_client=redis_client,
        key="user:123:rate_limit",
        limit=5,
        window=10
    )

    for i in range(10):
        if limiter.acquire():
            print(f"请求{i}: ✅ 通过")
        else:
            print(f"请求{i}: ❌ 被限流")

        status = limiter.get_status()
        print(f"  状态: {status['count']}/{status['limit']}")

        time.sleep(1)
```

---

## 解决窗口边界问题

### 对比：固定窗口 vs 滑动窗口

```python
def test_boundary_comparison():
    """对比固定窗口和滑动窗口的边界问题"""
    from fixed_window import FixedWindowLimiter

    fixed = FixedWindowLimiter(limit=10, window=60)
    sliding = SlidingWindowLimiter(limit=10, window=60)

    print("=== 窗口边界对比 ===\n")

    # 在第59秒发送10个请求
    print("第59秒：发送10个请求")
    for i in range(10):
        fixed.acquire()
        sliding.acquire()

    print(f"固定窗口: {fixed.get_status()['count']}/10")
    print(f"滑动窗口: {sliding.get_status()['count']}/10")

    # 等待1秒
    time.sleep(1)

    # 在第1秒又发送10个请求
    print("\n第1秒：发送10个请求")
    fixed_allowed = sum(1 for _ in range(10) if fixed.acquire())
    sliding_allowed = sum(1 for _ in range(10) if sliding.acquire())

    print(f"固定窗口: 允许 {fixed_allowed} 个请求 ❌")
    print(f"滑动窗口: 允许 {sliding_allowed} 个请求 ✅")

    print(f"\n固定窗口: {fixed.get_status()['count']}/10")
    print(f"滑动窗口: {sliding.get_status()['count']}/10")


if __name__ == "__main__":
    test_boundary_comparison()
```

**输出：**
```
=== 窗口边界对比 ===

第59秒：发送10个请求
固定窗口: 10/10
滑动窗口: 10/10

第1秒：发送10个请求
固定窗口: 允许 10 个请求 ❌
滑动窗口: 允许 0 个请求 ✅

固定窗口: 10/10
滑动窗口: 10/10
```

---

## 优缺点分析

### 优点

1. **精确控制**
   - 无窗口边界问题
   - 任意时刻的请求数都不会超过限制

2. **灵活性高**
   - 可以查询任意时间段的请求数
   - 可以实现复杂的限流策略

3. **适合细粒度限流**
   - 每秒、每分钟的限流
   - 对外 API 的限流

---

### 缺点

1. **内存占用大**
   - 滑动日志：O(n)，n 是窗口内的请求数
   - 滑动计数器：O(k)，k 是格子数
   - Redis Sorted Set：O(n)

2. **性能较低**
   - 每次请求都要清理过期记录
   - 时间复杂度：O(n) 或 O(log n)

3. **实现复杂**
   - 需要维护请求记录
   - 需要定期清理过期数据

---

## 性能优化

### 优化1：延迟清理

不在每次请求时清理，而是定期清理。

```python
import time
import threading

class OptimizedSlidingWindowLimiter:
    """优化的滑动窗口限流器：延迟清理"""

    def __init__(self, limit: int, window: int, cleanup_interval: int = 10):
        self.limit = limit
        self.window = window
        self.requests = []
        self.lock = threading.Lock()

        # 启动后台清理线程
        self.cleanup_thread = threading.Thread(
            target=self._cleanup_loop,
            args=(cleanup_interval,),
            daemon=True
        )
        self.cleanup_thread.start()

    def _cleanup_loop(self, interval: int):
        """后台清理线程"""
        while True:
            time.sleep(interval)
            with self.lock:
                now = time.time()
                self.requests = [t for t in self.requests if now - t < self.window]

    def acquire(self) -> bool:
        """尝试获取一个请求配额"""
        with self.lock:
            now = time.time()

            # 快速检查（不清理）
            # 只移除明显过期的请求（超过2倍窗口）
            if self.requests and now - self.requests[0] > self.window * 2:
                self.requests = [t for t in self.requests if now - t < self.window]

            # 统计最近窗口内的请求数
            count = sum(1 for t in self.requests if now - t < self.window)

            if count < self.limit:
                self.requests.append(now)
                return True

            return False
```

---

### 优化2：分段统计

将窗口分成多个段，只统计每段的计数。

```python
class SegmentedSlidingWindowLimiter:
    """分段滑动窗口限流器"""

    def __init__(self, limit: int, window: int, segments: int = 10):
        self.limit = limit
        self.window = window
        self.segments = segments
        self.segment_size = window / segments
        self.counts = {}  # {segment_id: count}

    def _get_segment_id(self, timestamp: float) -> int:
        """获取时间戳对应的段ID"""
        return int(timestamp / self.segment_size)

    def acquire(self) -> bool:
        """尝试获取一个请求配额"""
        now = time.time()
        current_segment = self._get_segment_id(now)
        window_start_segment = self._get_segment_id(now - self.window)

        # 清理过期段
        self.counts = {
            seg: count
            for seg, count in self.counts.items()
            if seg > window_start_segment
        }

        # 统计当前窗口内的请求数
        total = sum(self.counts.values())

        if total < self.limit:
            self.counts[current_segment] = self.counts.get(current_segment, 0) + 1
            return True

        return False
```

---

## 在 AI Agent 开发中的应用

### 场景1：精确的 API 限流

```python
from fastapi import FastAPI, Depends, HTTPException

app = FastAPI()
redis_client = redis.Redis()


def get_rate_limiter(user_id: str):
    """获取用户的限流器"""
    return RedisSlidingWindowLimiter(
        redis_client=redis_client,
        key=f"user:{user_id}:rate_limit",
        limit=60,  # 每分钟60个请求
        window=60
    )


@app.post("/chat")
async def chat(
    message: str,
    user_id: str,
    limiter: RedisSlidingWindowLimiter = Depends(get_rate_limiter)
):
    # 精确限流检查
    if not limiter.acquire():
        status = limiter.get_status()
        raise HTTPException(
            status_code=429,
            detail={
                "error": "Rate limit exceeded",
                "current": status["count"],
                "limit": status["limit"],
                "retry_after": 60
            }
        )

    # 调用 LLM
    response = await llm.chat(message)
    return {"response": response}
```

---

### 场景2：多时间窗口限流

```python
class MultiWindowLimiter:
    """多时间窗口限流器"""

    def __init__(self, redis_client: redis.Redis, user_id: str):
        self.limiters = {
            "second": RedisSlidingWindowLimiter(
                redis_client, f"user:{user_id}:second", limit=10, window=1
            ),
            "minute": RedisSlidingWindowLimiter(
                redis_client, f"user:{user_id}:minute", limit=60, window=60
            ),
            "hour": RedisSlidingWindowLimiter(
                redis_client, f"user:{user_id}:hour", limit=1000, window=3600
            ),
        }

    def acquire(self) -> bool:
        """检查所有时间窗口"""
        for name, limiter in self.limiters.items():
            if not limiter.acquire():
                return False
        return True


@app.post("/chat")
async def chat(message: str, user_id: str):
    limiter = MultiWindowLimiter(redis_client, user_id)

    if not limiter.acquire():
        raise HTTPException(status_code=429, detail="Rate limit exceeded")

    response = await llm.chat(message)
    return {"response": response}
```

---

## 性能分析

### 时间复杂度

- **滑动日志**: O(n)，n 是窗口内的请求数
- **滑动计数器**: O(k)，k 是格子数
- **Redis Sorted Set**: O(log n)

### 空间复杂度

- **滑动日志**: O(n)
- **滑动计数器**: O(k)
- **Redis Sorted Set**: O(n)

### 性能对比

```python
def benchmark():
    """性能测试"""
    import time

    # 滑动日志
    limiter1 = SlidingWindowLimiter(limit=10000, window=60)
    start = time.time()
    for _ in range(10000):
        limiter1.acquire()
    print(f"滑动日志: {time.time() - start:.3f}秒")

    # 滑动计数器
    limiter2 = SlidingWindowCounterLimiter(limit=10000, window=60, granularity=60)
    start = time.time()
    for _ in range(10000):
        limiter2.acquire()
    print(f"滑动计数器: {time.time() - start:.3f}秒")
```

**输出：**
```
滑动日志: 2.5秒
滑动计数器: 0.1秒
```

---

## 总结

### 核心要点

1. **滑动窗口解决了固定窗口的边界问题**
   - 精确控制，无窗口边界流量突刺
   - 适合细粒度限流

2. **两种实现方式**
   - 滑动日志：精确但内存占用大
   - 滑动计数器：近似但内存占用小

3. **Redis Sorted Set 是最佳实现**
   - 支持分布式
   - 性能好（O(log n)）
   - 实现简单

4. **适合对外 API 和精确限流场景**
   - 金融交易、支付接口
   - 需要精确控制的场景

---

### 学习检查清单

- [ ] 理解滑动窗口的原理（请求时间戳列表 + 过期清理）
- [ ] 能手写滑动日志实现
- [ ] 理解滑动计数器的优化原理
- [ ] 能用 Redis Sorted Set 实现分布式滑动窗口
- [ ] 理解滑动窗口如何解决固定窗口的边界问题
- [ ] 知道滑动窗口的适用场景和性能特点

---

**记住：** 滑动窗口是最精确的限流算法，但内存占用大。在需要精确控制的场景下使用，如对外 API、金融交易。在 AI Agent 开发中，可以用于精确的 LLM API 调用限流。
