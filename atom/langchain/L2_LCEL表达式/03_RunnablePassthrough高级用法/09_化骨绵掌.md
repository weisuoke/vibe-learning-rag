# 化骨绵掌

> **10张知识卡片，随时复习 RunnablePassthrough 核心要点**

---

## 什么是化骨绵掌？

"化骨绵掌"是一种快速复习方法：
- ✅ 每张卡片聚焦一个核心概念
- ✅ 正面是问题，背面是答案
- ✅ 适合碎片时间快速复习
- ✅ 帮助建立长期记忆

**使用方法**：
1. 先看问题，尝试回答
2. 再看答案，检查理解
3. 重复复习，直到熟练

---

## 卡片1：核心定义

### 正面：什么是 RunnablePassthrough？

<details>
<summary>点击查看答案</summary>

### 背面：

**RunnablePassthrough 是 LCEL 的数据透传原语，用于保持上下文和数据增强。**

**两种核心用法**：
1. **直接透传**：`RunnablePassthrough()` - 原样返回输入
2. **assign 方法**：`RunnablePassthrough.assign()` - 添加新字段

**核心价值**：
- 解决数据在链式传递中丢失的问题
- 实现累积增强模式
- RAG 管道的关键组件

**记忆口诀**：
"透传保上下文，assign 添新字段，RAG 链不可缺"

</details>

---

## 卡片2：assign 方法原理

### 正面：assign 方法的实现原理是什么？

<details>
<summary>点击查看答案</summary>

### 背面：

**三步实现**：

```python
def assign(input_dict, **kwargs):
    # 1. 复制原始字典（保证不可变性）
    output = input_dict.copy()

    # 2. 执行所有 Runnable 并添加结果
    for key, runnable in kwargs.items():
        output[key] = runnable.invoke(input_dict)  # 传入原始字典

    # 3. 返回扩展后的字典
    return output
```

**关键设计**：
- 复制字典：避免修改原始数据
- 传入原始字典：每个 Runnable 都接收完整的原始数据
- 返回新字典：符合不可变性原则

**为什么传入原始字典？**
- 保证数据一致性
- 支持独立的 Runnable
- 避免依赖关系混乱

</details>

---

## 卡片3：RAG 标准模式

### 正面：RAG 管道中如何使用 RunnablePassthrough？

<details>
<summary>点击查看答案</summary>

### 背面：

**标准模式**：

```python
from operator import itemgetter

rag_chain = (
    # 步骤1: 保持问题 + 检索上下文
    RunnablePassthrough.assign(
        context=itemgetter("question") | retriever
    )
    # 步骤2: 生成答案
    | RunnablePassthrough.assign(
        answer=prompt | model
    )
)

result = rag_chain.invoke({"question": "..."})
# {
#     "question": "...",  # 保留
#     "context": [...],   # 检索结果
#     "answer": "..."     # 生成答案
# }
```

**为什么必须这样？**
- Prompt 需要同时访问问题和上下文
- Retriever 只返回文档，不返回问题
- 必须保持问题才能生成正确的 prompt

**2025-2026 最佳实践**：
这是 RAG 管道的标准模式，被广泛应用于生产环境。

</details>

---

## 卡片4：链式 assign

### 正面：链式 assign 和单个 assign 有什么区别？

<details>
<summary>点击查看答案</summary>

### 背面：

**单个 assign**：
```python
chain = RunnablePassthrough.assign(
    field1=runnable1,
    field2=runnable2,  # 接收原始输入，不能访问 field1
)
```
- 所有 Runnable 接收相同的原始输入
- 无法访问其他字段的结果
- 适合独立的计算

**链式 assign**：
```python
chain = (
    RunnablePassthrough.assign(field1=runnable1)
    | RunnablePassthrough.assign(field2=runnable2)  # 可以访问 field1
)
```
- 后续 assign 可以访问前面的结果
- 明确表达依赖关系
- 适合多步骤累积

**使用场景**：
- 单个 assign：多个独立的分析任务
- 链式 assign：RAG 管道（检索 → 答案 → 评分）

</details>

---

## 卡片5：itemgetter 用法

### 正面：itemgetter 在 RunnablePassthrough 中的作用是什么？

<details>
<summary>点击查看答案</summary>

### 背面：

**作用**：从字典中提取指定字段的值

**问题场景**：
```python
# ❌ 错误：retriever 期望字符串，收到字典
chain = RunnablePassthrough.assign(
    context=retriever  # 报错
)
chain.invoke({"question": "..."})
```

**解决方案**：
```python
from operator import itemgetter

# ✅ 正确：使用 itemgetter 提取字段
chain = RunnablePassthrough.assign(
    context=itemgetter("question") | retriever
)
chain.invoke({"question": "..."})
```

**工作原理**：
```python
# itemgetter("question") 等价于：
RunnableLambda(lambda x: x["question"])
```

**通用模式**：
```python
# 提取字段 → 传递给 Runnable
itemgetter("field_name") | some_runnable
```

</details>

---

## 卡片6：并行处理模式

### 正面：如何在并行处理后保持原始输入？

<details>
<summary>点击查看答案</summary>

### 背面：

**模式**：使用 RunnablePassthrough() 作为并行分支之一

```python
chain = {
    "original": RunnablePassthrough(),  # 保持原始输入
    "summary": summary_chain,           # 并行任务1
    "keywords": keyword_chain,          # 并行任务2
    "sentiment": sentiment_chain,       # 并行任务3
}

result = chain.invoke({"text": "..."})
# {
#     "original": {"text": "..."},  # 原始输入
#     "summary": "...",
#     "keywords": [...],
#     "sentiment": "positive"
# }
```

**为什么需要？**
- 后续步骤可能需要访问原始输入
- 便于对比和验证
- 提供完整的数据上下文

**实际应用**：
- 多模型对比：保留原始问题，对比不同模型的答案
- 多任务分析：保留原始文本，展示不同维度的分析结果

</details>

---

## 卡片7：常见误区

### 正面：RunnablePassthrough 的三大常见误区是什么？

<details>
<summary>点击查看答案</summary>

### 背面：

**误区1：assign 会覆盖已有字段**
- ❌ 错误：认为 assign 会覆盖
- ✅ 正确：assign 不应该覆盖，使用不同键名

**误区2：assign 中的 Runnable 接收累积输入**
- ❌ 错误：认为 field2 可以访问 field1
- ✅ 正确：所有 Runnable 接收相同的原始输入

**误区3：RunnablePassthrough() 什么都不做**
- ❌ 错误：认为是多余的占位符
- ✅ 正确：有明确语义，保持原始输入

**记忆技巧**：
- assign = 添加，不是修改
- 单个 assign = 独立计算
- 直接透传 = 保持数据

</details>

---

## 卡片8：性能特性

### 正面：assign 中的 Runnable 是串行还是并行执行？

<details>
<summary>点击查看答案</summary>

### 背面：

**串行执行**，这是一个常见的误区。

```python
chain = RunnablePassthrough.assign(
    field1=expensive_operation1,  # 2秒
    field2=expensive_operation2,  # 2秒
)
# 总时间 = 2 + 2 = 4秒（串行）
```

**为什么串行？**
- assign 的语义是"逐步添加字段"
- 为未来的依赖关系优化留下空间
- 简化实现和调试

**如何并行？**
使用 RunnableParallel：
```python
parallel_chain = RunnableParallel(
    field1=expensive_operation1,
    field2=expensive_operation2,
)
# 总时间 = max(2, 2) = 2秒（并行）
```

**2025-2026 最佳实践**：
独立操作应使用 RunnableParallel 以降低延迟。

</details>

---

## 卡片9：错误处理

### 正面：如何在 assign 中处理异常？

<details>
<summary>点击查看答案</summary>

### 背面：

**问题**：assign 中的 Runnable 抛出异常会导致整个链失败

**解决方案**：在 Runnable 内部捕获异常

```python
def safe_operation(x):
    try:
        return some_operation(x)
    except Exception as e:
        return {"error": str(e), "success": False}

chain = RunnablePassthrough.assign(
    result=RunnableLambda(safe_operation)
)

result = chain.invoke({"input": "test"})
# {
#     "input": "test",
#     "result": {"error": "...", "success": False}
# }
```

**2025-2026 最佳实践**：
- 使用 try-except 块处理异常
- 实现指数退避重试机制
- 使用自定义错误处理器提升生产可靠性

**生产环境模式**：
```python
def robust_operation(x, max_retries=3):
    for attempt in range(max_retries):
        try:
            return some_operation(x)
        except Exception as e:
            if attempt == max_retries - 1:
                return {"error": str(e), "success": False}
            time.sleep(2 ** attempt)  # 指数退避
```

</details>

---

## 卡片10：设计原则

### 正面：RunnablePassthrough 体现了哪些设计原则？

<details>
<summary>点击查看答案</summary>

### 背面：

**1. 组合优于继承**
```python
# 通过组合简单组件构建复杂系统
rag_chain = (
    RunnablePassthrough.assign(context=retriever)
    | prompt
    | model
)
```

**2. 声明式优于命令式**
```python
# 声明式：描述"做什么"
chain = RunnablePassthrough.assign(context=retriever)

# 命令式：描述"怎么做"
context = retriever.invoke(question)
result = {"question": question, "context": context}
```

**3. 不可变性**
```python
# assign 不修改原始数据，返回新字典
output = input_dict.copy()
```

**4. 最小惊讶原则**
```python
# 行为符合直觉预期
chain = RunnablePassthrough.assign(new_field=runnable)
# 期望：保留原始数据 + 添加新字段
# 实际：完全符合预期
```

**核心理念**：
简单、可组合、可预测

</details>

---

## 快速复习清单

### 核心概念（必须掌握）

- [ ] RunnablePassthrough 的两种用法
- [ ] assign 方法的实现原理
- [ ] RAG 管道的标准模式
- [ ] 链式 assign 和单个 assign 的区别
- [ ] itemgetter 的作用和用法

### 实战技巧（提升效率）

- [ ] 如何在并行处理后保持原始输入
- [ ] 如何处理 retriever 类型不匹配
- [ ] 如何在 assign 中处理异常
- [ ] 如何优化性能（串行 vs 并行）

### 常见误区（避免踩坑）

- [ ] assign 不会覆盖已有字段
- [ ] assign 中的 Runnable 接收原始输入
- [ ] RunnablePassthrough() 不是多余的
- [ ] assign 中的 Runnable 是串行执行

### 设计原则（深度理解）

- [ ] 组合优于继承
- [ ] 声明式优于命令式
- [ ] 不可变性
- [ ] 最小惊讶原则

---

## 记忆技巧

### 口诀记忆

**核心口诀**：
"透传保上下文，assign 添新字段，RAG 链不可缺"

**使用场景**：
- 透传：并行处理保持原始输入
- assign：逐步构建数据上下文
- RAG：检索增强生成的标准模式

### 类比记忆

| 概念 | 类比 |
|------|------|
| RunnablePassthrough | 传话筒（不改变内容） |
| assign 方法 | 添加便签（不覆盖原文） |
| 链式 assign | 接力赛（逐步累积） |
| itemgetter | 提取器（从字典中取值） |

### 对比记忆

| 对比项 | 直接透传 | assign 方法 |
|--------|---------|------------|
| 输入类型 | 任何类型 | 必须是字典 |
| 输出 | 原样返回 | 扩展字典 |
| 使用场景 | 保持原始输入 | 添加新字段 |
| 性能 | 零开销 | 需要执行 Runnable |

---

## 复习策略

### 第一遍：理解概念
- 阅读每张卡片的正面和背面
- 理解核心概念和原理
- 尝试用自己的话解释

### 第二遍：记忆要点
- 只看正面，尝试回答
- 检查答案，标记不熟悉的卡片
- 重点复习标记的卡片

### 第三遍：实战应用
- 尝试写出代码示例
- 解释使用场景
- 对比不同的实现方式

### 第四遍：深度理解
- 理解设计原理
- 思考为什么这样设计
- 联系实际项目经验

---

## 进阶学习

掌握这10张卡片后，你可以：

1. **深入核心概念** → 学习 assign 方法原理、数据透传与增强、上下文保持机制
2. **实战代码** → 学习更复杂的 RAG 场景、复杂链构建、生产环境最佳实践
3. **第一性原理** → 理解为什么需要数据透传和上下文保持
4. **面试准备** → 学习常见面试问题和出彩回答

---

## 参考资源

**官方文档（2025-2026）**：
- [RunnablePassthrough API Reference](https://reference.langchain.com/v0.3/python/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html)
- [LCEL Concepts](https://python.langchain.com/docs/concepts/lcel)

**2025-2026 最佳实践**：
- [LangChain Best Practices](https://www.swarnendu.de/blog/langchain-best-practices)
- [Building Production-Ready AI Pipelines](https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557)
- [Master LangChain in 2025](https://towardsai.net/p/machine-learning/master-langchain-in-2025-from-rag-to-tools-complete-guide)

---

**版本**: v1.0
**最后更新**: 2026-02-19
**适用**: LangChain 0.3+, Python 3.13+
