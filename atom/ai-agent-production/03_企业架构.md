# 企业级架构模式

**知识点数**: 12个 | **学习时长**: 2周 | **优先级**: P0

---

## 概览

**为什么重要**:
> "Think workflows, not just agents" — r/Agentic_AI_For_Devs

企业需要的是可控的混合工作流，而非完全自治的Agent。

**学习路径**: 架构模式（6个）→ 分布式系统（4个）→ 微服务集成（2个）

---

## L1_架构模式（6个知识点）

### 01_混合工作流设计

**核心概念**: 确定性流程 + Agent决策，平衡可控性和灵活性。

**设计原则**:
- 关键路径用确定性流程
- 非关键决策用Agent
- 明确回退机制

**实战代码**:
```python
from enum import Enum
from typing import Literal

class WorkflowState(Enum):
    VALIDATE = "validate"
    PROCESS = "process"
    REVIEW = "review"
    COMPLETE = "complete"

class HybridWorkflow:
    def __init__(self):
        self.state = WorkflowState.VALIDATE

    def execute(self, input_data: dict):
        # 确定性验证
        if not self.validate(input_data):
            return {"error": "Validation failed"}

        # Agent决策处理
        result = self.agent_process(input_data)

        # 确定性审核
        if self.needs_review(result):
            result = self.human_review(result)

        return result
```

---

### 02_事件驱动架构

**核心概念**: 解耦系统组件，异步通信。

**实战代码**:
```python
from typing import Callable
import asyncio

class EventBus:
    def __init__(self):
        self.handlers: dict[str, list[Callable]] = {}

    def subscribe(self, event: str, handler: Callable):
        if event not in self.handlers:
            self.handlers[event] = []
        self.handlers[event].append(handler)

    async def publish(self, event: str, data: dict):
        if event in self.handlers:
            tasks = [handler(data) for handler in self.handlers[event]]
            await asyncio.gather(*tasks)

# 使用
bus = EventBus()

@bus.subscribe("agent.completed")
async def log_completion(data):
    logger.info(f"Agent completed: {data}")

@bus.subscribe("agent.completed")
async def update_metrics(data):
    metrics.increment("agent.completions")
```

---

### 03_状态机模式

**核心概念**: 管理复杂流程的状态转换。

**实战代码**:
```python
from enum import Enum
from typing import Optional

class State(Enum):
    IDLE = "idle"
    PROCESSING = "processing"
    WAITING = "waiting"
    COMPLETED = "completed"
    FAILED = "failed"

class StateMachine:
    def __init__(self):
        self.state = State.IDLE
        self.transitions = {
            State.IDLE: [State.PROCESSING],
            State.PROCESSING: [State.WAITING, State.COMPLETED, State.FAILED],
            State.WAITING: [State.PROCESSING, State.FAILED],
            State.COMPLETED: [],
            State.FAILED: [State.IDLE]
        }

    def transition(self, new_state: State) -> bool:
        if new_state in self.transitions[self.state]:
            self.state = new_state
            return True
        return False
```

---

### 04_CQRS模式

**核心概念**: 命令与查询分离，读写分离。

**实战代码**:
```python
# 命令（写操作）
class CreateAgentCommand:
    def __init__(self, agent_id: str, config: dict):
        self.agent_id = agent_id
        self.config = config

class CommandHandler:
    def handle(self, command: CreateAgentCommand):
        # 写入数据库
        db.agents.insert(command.agent_id, command.config)
        # 发布事件
        event_bus.publish("agent.created", {"id": command.agent_id})

# 查询（读操作）
class AgentQuery:
    def get_agent(self, agent_id: str):
        # 从读模型查询
        return read_db.agents.find_one({"id": agent_id})
```

---

### 05_Saga模式

**核心概念**: 分布式事务，补偿机制。

**实战代码**:
```python
class Saga:
    def __init__(self):
        self.steps = []
        self.compensations = []

    def add_step(self, action: Callable, compensation: Callable):
        self.steps.append(action)
        self.compensations.append(compensation)

    async def execute(self):
        executed = []
        try:
            for step in self.steps:
                await step()
                executed.append(step)
        except Exception as e:
            # 回滚已执行的步骤
            for i in range(len(executed) - 1, -1, -1):
                await self.compensations[i]()
            raise e
```

---

### 06_断路器模式

**核心概念**: 故障检测，熔断机制，提升系统韧性。

**实战代码**:
```python
from enum import Enum
import time

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreaker:
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.last_failure_time = None

    async def call(self, func: Callable):
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitState.HALF_OPEN
            else:
                raise Exception("Circuit breaker is OPEN")

        try:
            result = await func()
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise e

    def on_success(self):
        self.failure_count = 0
        self.state = CircuitState.CLOSED

    def on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN
```

---

## L2_分布式系统（4个知识点）

### 01_幂等性设计

**核心概念**: 确保操作可重试，避免重复执行。

**实战代码**:
```python
import hashlib

class IdempotencyManager:
    def __init__(self):
        self.processed = set()

    def is_processed(self, request_id: str) -> bool:
        return request_id in self.processed

    def mark_processed(self, request_id: str):
        self.processed.add(request_id)

    def generate_id(self, data: dict) -> str:
        # 基于请求内容生成唯一ID
        content = str(sorted(data.items()))
        return hashlib.sha256(content.encode()).hexdigest()

# 使用
@app.post("/agent/run")
async def run_agent(request: Request):
    request_id = idempotency.generate_id(request.dict())

    if idempotency.is_processed(request_id):
        return {"status": "already_processed"}

    result = await agent.run(request.query)
    idempotency.mark_processed(request_id)
    return result
```

---

### 02_分布式追踪

**核心概念**: 跨服务追踪，性能分析。

**实战代码**:
```python
from opentelemetry import trace
from opentelemetry.propagate import inject, extract

tracer = trace.get_tracer(__name__)

# 服务A
async def service_a(query: str):
    with tracer.start_as_current_span("service_a") as span:
        headers = {}
        inject(headers)  # 注入追踪上下文

        # 调用服务B
        response = await http_client.post(
            "http://service-b/process",
            json={"query": query},
            headers=headers
        )
        return response

# 服务B
async def service_b(request: Request):
    ctx = extract(request.headers)  # 提取追踪上下文
    with tracer.start_as_current_span("service_b", context=ctx):
        result = await process(request.query)
        return result
```

---

### 03_服务发现

**核心概念**: 动态服务注册和发现。

**实战代码**:
```python
import consul

class ServiceRegistry:
    def __init__(self):
        self.consul = consul.Consul()

    def register(self, service_name: str, host: str, port: int):
        self.consul.agent.service.register(
            name=service_name,
            service_id=f"{service_name}-{host}-{port}",
            address=host,
            port=port,
            check=consul.Check.http(f"http://{host}:{port}/health", interval="10s")
        )

    def discover(self, service_name: str):
        _, services = self.consul.health.service(service_name, passing=True)
        return [{"host": s["Service"]["Address"], "port": s["Service"]["Port"]} for s in services]
```

---

### 04_配置管理

**核心概念**: 集中配置，动态更新。

**实战代码**:
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    model: str = "gpt-4"
    temperature: float = 0.7
    max_tokens: int = 1000

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

settings = Settings()

# 动态更新
def update_settings(new_settings: dict):
    for key, value in new_settings.items():
        setattr(settings, key, value)
```

---

## L3_微服务集成（2个知识点）

### 01_API网关

**核心概念**: 统一入口，路由、认证、限流。

**实战代码**:
```python
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# 路由规则
ROUTES = {
    "/agent": "http://agent-service:8000",
    "/rag": "http://rag-service:8001"
}

@app.middleware("http")
async def route_request(request: Request, call_next):
    path = request.url.path

    for prefix, target in ROUTES.items():
        if path.startswith(prefix):
            # 转发请求
            response = await http_client.request(
                method=request.method,
                url=f"{target}{path}",
                headers=request.headers,
                content=await request.body()
            )
            return response

    return await call_next(request)
```

---

### 02_服务网格

**核心概念**: 流量管理、安全通信、可观测性。

**Istio配置**:
```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: agent-service
spec:
  hosts:
  - agent-service
  http:
  - match:
    - headers:
        version:
          exact: v2
    route:
    - destination:
        host: agent-service
        subset: v2
  - route:
    - destination:
        host: agent-service
        subset: v1
      weight: 90
    - destination:
        host: agent-service
        subset: v2
      weight: 10
```

---

## 核心20%（3个知识点）

1. ⭐⭐⭐ **混合工作流设计**
2. ⭐⭐⭐ **事件驱动架构**
3. ⭐⭐⭐ **幂等性设计**

---

## 实战项目

### 项目: 企业级Agent系统

**架构设计**:
- API网关（统一入口）
- Agent服务（核心逻辑）
- RAG服务（知识检索）
- 事件总线（异步通信）
- 配置中心（动态配置）

**技术栈**:
- FastAPI + Kubernetes
- Redis（事件总线）
- Consul（服务发现）
- Istio（服务网格）

---

## 学习资源

- [微服务架构模式](https://microservices.io/patterns/)
- [分布式系统原理](https://www.distributed-systems.net/)

---

## 常见误区

1. ❌ "微服务一定更好" → ✅ 根据规模选择
2. ❌ "事件驱动解决所有问题" → ✅ 增加复杂度
3. ❌ "架构越复杂越好" → ✅ 简单优先

---

**版本**: v1.0 | **最后更新**: 2026-02-12
