# 第一性原理

> 从底层逻辑理解 Context Files 的设计哲学

---

## 核心问题

**为什么需要 Context Files？**

从第一性原理出发，我们需要回答一个根本问题：**AI Agent 如何理解一个项目？**

---

## 推理链条

### 第一层：AI 的认知局限

**问题：** AI 模型是通用的，它不知道你的项目是什么。

```
AI 的默认状态：
- 知道通用的编程知识（TypeScript、React、Node.js）
- 不知道你的项目结构（目录在哪、文件怎么组织）
- 不知道你的团队规范（代码风格、提交规范）
- 不知道你的工作流程（如何构建、如何测试）
```

**类比：** 就像一个新员工，有专业技能但不了解公司。

### 第二层：传统解决方案的问题

**方案 1：每次对话都重复说明**

```
用户：帮我添加一个组件
AI：好的，放在哪个目录？
用户：src/components/
AI：使用什么框架？
用户：React
AI：TypeScript 还是 JavaScript？
用户：TypeScript
...（每次都要重复）
```

**问题：** 效率低下，重复劳动。

**方案 2：在系统提示词中硬编码**

```
系统提示词：
你是一个 TypeScript + React 开发助手
项目结构是 src/components/、src/utils/
使用 pnpm 管理依赖
...
```

**问题：**
- 不同项目需要不同的提示词
- 无法版本控制和团队共享
- 修改需要重启 AI

### 第三层：Context Files 的设计理念

**核心思想：** 将项目知识外部化为配置文件，让 AI 在启动时自动加载。

```
Context Files = 项目的"元数据"
- AGENTS.md：项目知识（规范、流程、约定）
- settings.json：运行配置（模型、UI、资源）
- SYSTEM.md：AI 行为（风格、准则、约束）
```

**优势：**
1. **一次配置，持续生效** - 不需要每次对话都说明
2. **版本控制** - 可以提交到 Git，团队共享
3. **热重载** - 修改后通过 /reload 立即生效
4. **分层管理** - 全局 + 项目级，灵活覆盖

---

## 设计原则

### 原则 1：约定优于配置（Convention over Configuration）

**理念：** 提供合理的默认值，只在需要时才配置。

```bash
# 最小配置（只需要 AGENTS.md）
echo "# 项目规范\n- TypeScript + React" > AGENTS.md

# Pi Agent 自动使用默认配置
# - 默认模型：claude-sonnet-4
# - 默认主题：系统主题
# - 默认行为：通用开发助手
```

**类比：** 就像 Next.js 的文件路由，约定 pages/ 目录就是路由，不需要额外配置。

### 原则 2：渐进式披露（Progressive Disclosure）

**理念：** 从通用到特定，逐层添加上下文。

```
全局 AGENTS.md：
- 个人工作习惯（所有项目通用）

项目根 AGENTS.md：
- 项目通用规范（所有子包通用）

子目录 AGENTS.md：
- 特定模块规范（只在当前模块生效）
```

**为什么累加而不是覆盖？**
- 避免重复（子目录不需要重复父目录的规则）
- 支持 mono-repo（根目录通用 + 子包特定）
- 符合人类认知（从通用到特定）

**来源：** Twitter @badlogicgames 的 progressive disclosure 最佳实践

### 原则 3：关注点分离（Separation of Concerns）

**理念：** 不同类型的配置放在不同文件。

```
AGENTS.md：
- 关注"项目是什么"
- 内容：规范、流程、约定

settings.json：
- 关注"如何运行"
- 内容：模型、UI、资源

SYSTEM.md：
- 关注"AI 是谁"
- 内容：风格、准则、约束
```

**为什么分离？**
- 职责清晰，易于维护
- 不同文件有不同的生命周期（AGENTS.md 频繁修改，settings.json 相对稳定）
- 支持不同的共享策略（AGENTS.md 提交 Git，settings.json 个人定制）

### 原则 4：配置即代码（Configuration as Code）

**理念：** 配置文件是纯文本，可以版本控制、代码审查、自动化。

```bash
# 配置文件可以版本控制
git add AGENTS.md
git commit -m "docs: update project conventions"

# 配置文件可以代码审查
git diff AGENTS.md

# 配置文件可以自动化
cat > AGENTS.md << 'EOF'
# 项目规范
- TypeScript + React
EOF
```

**类比：** 就像 Terraform 的 Infrastructure as Code，配置即代码。

---

## 底层机制

### 机制 1：启动时加载

```
Pi Agent 启动流程：
1. 搜索所有层级的 AGENTS.md
2. 按顺序合并内容
3. 加载 settings.json（全局 + 项目级）
4. 加载 SYSTEM.md / APPEND_SYSTEM.md
5. 将所有配置注入到 AI 的上下文中
6. 开始对话
```

**为什么启动时加载？**
- 确保 AI 从第一句对话就理解项目
- 避免对话中途切换上下文的混乱
- 支持热重载（/reload 重新加载）

### 机制 2：配置合并策略

**AGENTS.md：累加（Concatenate）**
```
全局内容 + 父目录内容 + 当前目录内容
```

**settings.json：智能合并（Smart Merge）**
```
对象：深度合并
数组：完全替换
```

**SYSTEM.md：替换或追加**
```
SYSTEM.md：完全替换
APPEND_SYSTEM.md：追加到默认提示词
```

**为什么不同文件有不同策略？**
- AGENTS.md 是知识累积（越多越好）
- settings.json 是配置覆盖（项目优先）
- SYSTEM.md 是行为定义（明确替换或追加）

---

## 设计权衡

### 权衡 1：灵活性 vs 复杂性

**选择：** 提供三个文件，而不是一个"超级配置文件"。

**理由：**
- 关注点分离，易于理解
- 不同文件有不同的共享策略
- 支持渐进式学习（先学 AGENTS.md，再学 settings.json）

### 权衡 2：自动化 vs 可控性

**选择：** 启动时自动加载，但支持手动 /reload。

**理由：**
- 自动化：减少用户负担
- 可控性：支持调试和热重载

### 权衡 3：全局 vs 项目级

**选择：** 同时支持全局和项目级配置。

**理由：**
- 全局：个人工作习惯（所有项目通用）
- 项目级：项目特定需求（团队共享）

---

## 实际应用

### 场景 1：个人项目

```bash
# 只需要一个 AGENTS.md
echo "# 项目规范\n- TypeScript + React" > AGENTS.md
```

**理由：** 个人项目不需要复杂配置，最小可用即可。

### 场景 2：团队协作

```bash
# AGENTS.md 提交到 Git
git add AGENTS.md
git commit -m "docs: add project conventions"

# settings.json 个人定制（不提交）
echo ".pi/settings.json" >> .gitignore
```

**理由：** 团队共享规范，个人定制配置。

### 场景 3：Mono-repo

```bash
# 根目录：通用规范
/monorepo/AGENTS.md

# 子包：特定规范
/monorepo/packages/frontend/AGENTS.md
/monorepo/packages/backend/AGENTS.md
```

**理由：** 渐进式披露，避免重复。

---

## 总结

**Context Files 的第一性原理：**

1. **问题本质** - AI 需要理解项目上下文
2. **解决方案** - 将项目知识外部化为配置文件
3. **设计原则** - 约定优于配置、渐进式披露、关注点分离、配置即代码
4. **底层机制** - 启动时加载、智能合并、热重载
5. **设计权衡** - 灵活性、自动化、分层管理

**一句话总结：** Context Files 是 Pi Agent 的"项目大脑"，通过配置文件让 AI 理解项目，从而提供更精准的开发辅助。
