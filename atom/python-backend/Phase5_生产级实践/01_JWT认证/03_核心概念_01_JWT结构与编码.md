# JWT认证 - 核心概念01：JWT结构与编码

## 概述

JWT（JSON Web Token）由三部分组成，每部分都有特定的作用和编码方式。理解这三部分的结构和编码原理，是掌握 JWT 的基础。

---

## JWT 的三部分结构

### 完整示例

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjMsImV4cCI6MTcwOTI4MDAwMH0.5K8v7J9mN2pQ3rT6wX8yZ1aB4cD7eF0gH
│                                      │                                        │
│         Header (Base64URL)          │      Payload (Base64URL)               │    Signature (Base64URL)
│                                      │                                        │
└─────────────────────────────────────┴────────────────────────────────────────┴──────────────────────────────
```

**三部分用点号（`.`）分隔：**
- `Header.Payload.Signature`

---

## 第一部分：Header（头部）

### 作用

Header 描述 JWT 的元信息：
- Token 类型（通常是 "JWT"）
- 签名算法（如 "HS256"、"RS256"）

### 结构

```json
{
  "alg": "HS256",  // 签名算法
  "typ": "JWT"     // Token 类型
}
```

### 常见签名算法

| 算法 | 类型 | 说明 |
|------|------|------|
| HS256 | 对称加密 | HMAC + SHA256，服务端用同一个密钥签名和验证 |
| HS384 | 对称加密 | HMAC + SHA384 |
| HS512 | 对称加密 | HMAC + SHA512 |
| RS256 | 非对称加密 | RSA + SHA256，私钥签名，公钥验证 |
| RS384 | 非对称加密 | RSA + SHA384 |
| RS512 | 非对称加密 | RSA + SHA512 |
| ES256 | 非对称加密 | ECDSA + SHA256 |

**推荐：**
- 单体应用：HS256（简单，性能好）
- 微服务：RS256（公钥可以公开分发）

### 编码过程

```python
import json
import base64

# 1. 创建 Header 字典
header = {
    "alg": "HS256",
    "typ": "JWT"
}

# 2. 转换为 JSON 字符串
header_json = json.dumps(header, separators=(',', ':'))
print(f"Header JSON: {header_json}")
# {"alg":"HS256","typ":"JWT"}

# 3. Base64URL 编码
header_bytes = header_json.encode('utf-8')
header_b64 = base64.urlsafe_b64encode(header_bytes).decode('utf-8')

# 4. 去掉末尾的 = 填充
header_encoded = header_b64.rstrip('=')
print(f"Header Encoded: {header_encoded}")
# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

### 解码过程

```python
# 1. 添加 = 填充（Base64 要求长度是 4 的倍数）
def add_padding(encoded: str) -> str:
    padding = 4 - len(encoded) % 4
    if padding != 4:
        encoded += '=' * padding
    return encoded

header_encoded = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
header_padded = add_padding(header_encoded)

# 2. Base64URL 解码
header_bytes = base64.urlsafe_b64decode(header_padded)

# 3. 转换为字符串
header_json = header_bytes.decode('utf-8')
print(f"Header JSON: {header_json}")
# {"alg":"HS256","typ":"JWT"}

# 4. 解析 JSON
header = json.loads(header_json)
print(f"Header: {header}")
# {'alg': 'HS256', 'typ': 'JWT'}
```

---

## 第二部分：Payload（载荷）

### 作用

Payload 存储实际的用户信息和声明（Claims）。

### 标准字段（Registered Claims）

JWT 规范定义了一些标准字段：

| 字段 | 全称 | 说明 | 示例 |
|------|------|------|------|
| iss | Issuer | 签发者 | "https://api.example.com" |
| sub | Subject | 主题（通常是用户 ID） | "user123" |
| aud | Audience | 接收方 | "https://app.example.com" |
| exp | Expiration Time | 过期时间（Unix 时间戳） | 1709280000 |
| nbf | Not Before | 生效时间 | 1709276400 |
| iat | Issued At | 签发时间 | 1709276400 |
| jti | JWT ID | JWT 唯一标识符 | "abc123" |

### 自定义字段（Private Claims）

可以添加任何自定义字段：

```json
{
  "user_id": 123,
  "username": "alice",
  "role": "admin",
  "permissions": ["read", "write"],
  "exp": 1709280000
}
```

**注意：**
- ✅ 可以存：用户 ID、用户名、角色、权限
- ❌ 不能存：密码、信用卡号、敏感信息（Payload 是明文）

### 编码过程

```python
from datetime import datetime, timedelta

# 1. 创建 Payload
payload = {
    "user_id": 123,
    "username": "alice",
    "role": "admin",
    "iat": int(datetime.utcnow().timestamp()),
    "exp": int((datetime.utcnow() + timedelta(minutes=15)).timestamp())
}

# 2. 转换为 JSON
payload_json = json.dumps(payload, separators=(',', ':'))
print(f"Payload JSON: {payload_json}")

# 3. Base64URL 编码
payload_bytes = payload_json.encode('utf-8')
payload_b64 = base64.urlsafe_b64encode(payload_bytes).decode('utf-8')
payload_encoded = payload_b64.rstrip('=')
print(f"Payload Encoded: {payload_encoded}")
```

### 解码过程

```python
# 解码 Payload（与 Header 相同）
payload_padded = add_padding(payload_encoded)
payload_bytes = base64.urlsafe_b64decode(payload_padded)
payload_json = payload_bytes.decode('utf-8')
payload = json.loads(payload_json)

print(f"Payload: {payload}")
# {'user_id': 123, 'username': 'alice', 'role': 'admin', ...}

# 检查过期时间
if payload['exp'] < int(datetime.utcnow().timestamp()):
    print("Token 已过期")
else:
    print("Token 有效")
```

---

## 第三部分：Signature（签名）

### 作用

Signature 确保 Token 未被篡改：
- 使用密钥对 Header + Payload 进行签名
- 验证时重新计算签名，对比是否一致

### 签名算法：HMAC-SHA256

```python
import hmac
import hashlib

# 1. 准备消息（Header + Payload）
message = f"{header_encoded}.{payload_encoded}"

# 2. 密钥
secret_key = "your-secret-key-keep-it-safe"

# 3. 生成签名
signature = hmac.new(
    secret_key.encode('utf-8'),
    message.encode('utf-8'),
    hashlib.sha256
).digest()

# 4. Base64URL 编码
signature_b64 = base64.urlsafe_b64encode(signature).decode('utf-8')
signature_encoded = signature_b64.rstrip('=')

print(f"Signature: {signature_encoded}")
```

### 验证签名

```python
def verify_signature(header_encoded: str, payload_encoded: str,
                     signature_encoded: str, secret_key: str) -> bool:
    """验证签名是否正确"""
    # 1. 重新计算签名
    message = f"{header_encoded}.{payload_encoded}"
    expected_signature = hmac.new(
        secret_key.encode('utf-8'),
        message.encode('utf-8'),
        hashlib.sha256
    ).digest()
    expected_signature_b64 = base64.urlsafe_b64encode(expected_signature).decode('utf-8')
    expected_signature_encoded = expected_signature_b64.rstrip('=')

    # 2. 对比签名（使用恒定时间比较，防止时序攻击）
    return hmac.compare_digest(signature_encoded, expected_signature_encoded)


# 测试
is_valid = verify_signature(header_encoded, payload_encoded, signature_encoded, secret_key)
print(f"签名有效: {is_valid}")  # True

# 测试篡改
tampered_payload = payload_encoded + "x"  # 篡改 Payload
is_valid = verify_signature(header_encoded, tampered_payload, signature_encoded, secret_key)
print(f"篡改后签名有效: {is_valid}")  # False
```

---

## Base64URL 编码详解

### 为什么需要 Base64URL？

**问题：** 标准 Base64 编码包含 `+`、`/`、`=` 字符，在 URL 中有特殊含义。

**解决：** Base64URL 将这些字符替换：
- `+` → `-`
- `/` → `_`
- `=` → 去掉（填充）

### 手写 Base64URL 编码器

```python
def base64url_encode(data: bytes) -> str:
    """Base64URL 编码"""
    # 1. 标准 Base64 编码
    b64 = base64.urlsafe_b64encode(data).decode('utf-8')

    # 2. 去掉末尾的 = 填充
    return b64.rstrip('=')


def base64url_decode(encoded: str) -> bytes:
    """Base64URL 解码"""
    # 1. 添加 = 填充
    padding = 4 - len(encoded) % 4
    if padding != 4:
        encoded += '=' * padding

    # 2. 标准 Base64 解码
    return base64.urlsafe_b64decode(encoded)


# 测试
data = b"Hello, JWT!"
encoded = base64url_encode(data)
print(f"Encoded: {encoded}")  # SGVsbG8sIEpXVCE

decoded = base64url_decode(encoded)
print(f"Decoded: {decoded.decode('utf-8')}")  # Hello, JWT!
```

---

## 手写 JWT 编码器

将以上知识整合，手写一个完整的 JWT 编码器：

```python
"""
手写 JWT 编码器
演示：从零实现 JWT 的生成和验证
"""

import json
import base64
import hmac
import hashlib
from datetime import datetime, timedelta
from typing import Dict, Any, Optional


class SimpleJWT:
    """简化的 JWT 实现"""

    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm

    def _base64url_encode(self, data: bytes) -> str:
        """Base64URL 编码"""
        return base64.urlsafe_b64encode(data).decode('utf-8').rstrip('=')

    def _base64url_decode(self, encoded: str) -> bytes:
        """Base64URL 解码"""
        padding = 4 - len(encoded) % 4
        if padding != 4:
            encoded += '=' * padding
        return base64.urlsafe_b64decode(encoded)

    def _create_signature(self, message: str) -> str:
        """创建签名"""
        signature = hmac.new(
            self.secret_key.encode('utf-8'),
            message.encode('utf-8'),
            hashlib.sha256
        ).digest()
        return self._base64url_encode(signature)

    def encode(self, payload: Dict[str, Any],
               expires_delta: Optional[timedelta] = None) -> str:
        """
        生成 JWT

        Args:
            payload: 要编码的数据
            expires_delta: 过期时间（从现在开始）

        Returns:
            JWT 字符串
        """
        # 1. 创建 Header
        header = {
            "alg": self.algorithm,
            "typ": "JWT"
        }
        header_encoded = self._base64url_encode(
            json.dumps(header, separators=(',', ':')).encode('utf-8')
        )

        # 2. 添加标准字段到 Payload
        payload = payload.copy()
        now = datetime.utcnow()
        payload['iat'] = int(now.timestamp())

        if expires_delta:
            payload['exp'] = int((now + expires_delta).timestamp())

        payload_encoded = self._base64url_encode(
            json.dumps(payload, separators=(',', ':')).encode('utf-8')
        )

        # 3. 创建签名
        message = f"{header_encoded}.{payload_encoded}"
        signature_encoded = self._create_signature(message)

        # 4. 组合成完整的 JWT
        return f"{message}.{signature_encoded}"

    def decode(self, token: str) -> Dict[str, Any]:
        """
        验证并解码 JWT

        Args:
            token: JWT 字符串

        Returns:
            Payload 数据

        Raises:
            ValueError: Token 无效或已过期
        """
        # 1. 分割 Token
        parts = token.split('.')
        if len(parts) != 3:
            raise ValueError("无效的 JWT 格式")

        header_encoded, payload_encoded, signature_encoded = parts

        # 2. 验证签名
        message = f"{header_encoded}.{payload_encoded}"
        expected_signature = self._create_signature(message)

        if not hmac.compare_digest(signature_encoded, expected_signature):
            raise ValueError("签名验证失败")

        # 3. 解码 Payload
        payload_json = self._base64url_decode(payload_encoded).decode('utf-8')
        payload = json.loads(payload_json)

        # 4. 检查过期时间
        if 'exp' in payload:
            if payload['exp'] < int(datetime.utcnow().timestamp()):
                raise ValueError("Token 已过期")

        return payload


# ===== 使用示例 =====

# 1. 创建 JWT 编码器
jwt_encoder = SimpleJWT(secret_key="your-secret-key")

# 2. 生成 Token
payload = {
    "user_id": 123,
    "username": "alice",
    "role": "admin"
}
token = jwt_encoder.encode(payload, expires_delta=timedelta(minutes=15))
print(f"生成的 Token:\n{token}\n")

# 3. 验证并解码 Token
try:
    decoded_payload = jwt_encoder.decode(token)
    print(f"解码的 Payload: {decoded_payload}")
except ValueError as e:
    print(f"验证失败: {e}")

# 4. 测试篡改
print("\n测试篡改:")
tampered_token = token[:-5] + "xxxxx"  # 修改签名
try:
    jwt_encoder.decode(tampered_token)
except ValueError as e:
    print(f"篡改检测成功: {e}")

# 5. 测试过期
print("\n测试过期:")
expired_token = jwt_encoder.encode(
    payload,
    expires_delta=timedelta(seconds=-1)  # 已经过期
)
try:
    jwt_encoder.decode(expired_token)
except ValueError as e:
    print(f"过期检测成功: {e}")
```

**运行输出：**
```
生成的 Token:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjMsInVzZXJuYW1lIjoiYWxpY2UiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE3MDkyNzY0MDAsImV4cCI6MTcwOTI3NzMwMH0.5K8v7J9mN2pQ3rT6wX8yZ1aB4cD7eF0gH

解码的 Payload: {'user_id': 123, 'username': 'alice', 'role': 'admin', 'iat': 1709276400, 'exp': 1709277300}

测试篡改:
篡改检测成功: 签名验证失败

测试过期:
过期检测成功: Token 已过期
```

---

## 与 python-jose 对比

### 手写实现 vs 库实现

```python
from jose import jwt as jose_jwt

# ===== 使用 python-jose =====
payload = {"user_id": 123, "username": "alice"}
secret_key = "your-secret-key"

# 生成
token_jose = jose_jwt.encode(payload, secret_key, algorithm="HS256")

# 验证
payload_jose = jose_jwt.decode(token_jose, secret_key, algorithms=["HS256"])


# ===== 使用手写实现 =====
jwt_encoder = SimpleJWT(secret_key)

# 生成
token_simple = jwt_encoder.encode(payload)

# 验证
payload_simple = jwt_encoder.decode(token_simple)


# ===== 对比 =====
print(f"python-jose Token: {token_jose}")
print(f"手写实现 Token: {token_simple}")
print(f"Payload 相同: {payload_jose == payload_simple}")
```

**为什么生产环境用库而不是手写？**

1. **安全性**：库经过大量测试和安全审计
2. **功能完整**：支持多种算法（RS256、ES256 等）
3. **性能优化**：使用 C 扩展加速
4. **错误处理**：完善的异常处理
5. **标准兼容**：完全符合 JWT 规范

**手写实现的价值：**
- 理解 JWT 的工作原理
- 面试时展示深度理解
- 调试和排查问题

---

## 在 AI Agent API 中的应用

### 场景：生成用户 Token

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()
jwt_encoder = SimpleJWT(secret_key="your-secret-key")


class LoginRequest(BaseModel):
    email: str
    password: str


@app.post("/login")
async def login(request: LoginRequest):
    """登录端点：生成 JWT"""
    # 1. 验证用户（简化）
    if request.email != "alice@example.com" or request.password != "password123":
        raise HTTPException(401, "用户名或密码错误")

    # 2. 生成 JWT
    payload = {
        "user_id": 123,
        "username": "alice",
        "email": request.email,
        "role": "user"
    }
    token = jwt_encoder.encode(payload, expires_delta=timedelta(minutes=15))

    return {
        "access_token": token,
        "token_type": "bearer"
    }
```

### 场景：验证 Token

```python
from fastapi import Depends, Header

async def get_current_user(authorization: str = Header()) -> dict:
    """依赖函数：验证 Token"""
    # 1. 检查格式
    if not authorization.startswith("Bearer "):
        raise HTTPException(401, "无效的认证格式")

    # 2. 提取 Token
    token = authorization.replace("Bearer ", "")

    # 3. 验证 Token
    try:
        payload = jwt_encoder.decode(token)
        return payload
    except ValueError as e:
        raise HTTPException(401, str(e))


@app.get("/profile")
async def get_profile(current_user: dict = Depends(get_current_user)):
    """受保护端点"""
    return {
        "user_id": current_user["user_id"],
        "username": current_user["username"],
        "email": current_user["email"]
    }
```

---

## 总结

**JWT 的三部分：**
1. **Header**：描述 Token 类型和算法
2. **Payload**：存储用户信息和声明
3. **Signature**：签名，防止篡改

**编码过程：**
1. Header 和 Payload 转 JSON
2. Base64URL 编码
3. 用密钥对 Header + Payload 签名
4. 组合成 `Header.Payload.Signature`

**关键点：**
- Base64URL 不是加密，只是编码
- Payload 不能存敏感信息
- 签名确保 Token 未被篡改
- 手写实现帮助理解原理，生产环境用库

通过手写实现，你应该对 JWT 的结构和编码有了深入的理解！
