# 实战代码 02: 自定义编辑器开发

> **学习目标**: 开发一个完整的自定义编辑器
> **阅读时间**: 90 分钟
> **难度级别**: ⭐⭐⭐⭐ (进阶)
> **代码语言**: TypeScript

---

## 场景概述

**目标**: 实现一个功能完整的多行文本编辑器

**功能需求**:
- 多行文本编辑
- 光标移动（上下左右、Home、End）
- 文本插入和删除
- 滚动支持
- 撤销/重做
- 基础自动补全

**技术要点**:
- 实现 EditorComponent 接口
- 状态管理（文本、光标、滚动）
- 输入处理（键盘事件）
- 渲染优化

---

## 完整实现

### 1. 编辑器状态管理

```typescript
// editor-state.ts
export interface EditorState {
  lines: string[];
  cursorRow: number;
  cursorCol: number;
  scrollOffset: number;
}

export function cloneState(state: EditorState): EditorState {
  return {
    lines: [...state.lines],
    cursorRow: state.cursorRow,
    cursorCol: state.cursorCol,
    scrollOffset: state.scrollOffset
  };
}

export function createEmptyState(): EditorState {
  return {
    lines: [''],
    cursorRow: 0,
    cursorCol: 0,
    scrollOffset: 0
  };
}
```

### 2. 核心编辑器实现

```typescript
// multi-line-editor.ts
import { EditorComponent, RenderContext, KeyEvent, Component } from './types';
import { EditorState, cloneState, createEmptyState } from './editor-state';

export class MultiLineEditor implements EditorComponent {
  private state: EditorState;
  private maxHeight: number = 10;

  constructor(initialValue: string = '') {
    this.state = createEmptyState();
    if (initialValue) {
      this.setValue(initialValue);
    }
  }

  // 渲染逻辑
  render(ctx: RenderContext): Component {
    this.maxHeight = ctx.height;

    const visibleLines = this.state.lines.slice(
      this.state.scrollOffset,
      this.state.scrollOffset + this.maxHeight
    );

    const content = visibleLines.map((line, i) => {
      const actualRow = this.state.scrollOffset + i;
      const showCursor = ctx.focused && actualRow === this.state.cursorRow;

      if (showCursor) {
        // 显示光标
        const before = line.slice(0, this.state.cursorCol);
        const at = line[this.state.cursorCol] || ' ';
        const after = line.slice(this.state.cursorCol + 1);
        return `${before}\x1b[7m${at}\x1b[0m${after}`;
      }

      return line;
    }).join('\n');

    return {
      type: 'text',
      content
    };
  }

  // 键盘输入处理
  handleKey(key: KeyEvent): boolean {
    switch (key.name) {
      case 'return':
        return this.handleReturn();

      case 'backspace':
        return this.handleBackspace();

      case 'delete':
        return this.handleDelete();

      case 'up':
        return this.handleUp();

      case 'down':
        return this.handleDown();

      case 'left':
        return this.handleLeft();

      case 'right':
        return this.handleRight();

      case 'home':
        this.state.cursorCol = 0;
        return true;

      case 'end':
        this.state.cursorCol = this.getCurrentLine().length;
        return true;

      default:
        // 插入字符
        if (key.sequence && !key.ctrl && !key.meta) {
          return this.insertText(key.sequence);
        }
        return false;
    }
  }

  // 状态管理
  getValue(): string {
    return this.state.lines.join('\n');
  }

  setValue(value: string): void {
    this.state.lines = value.split('\n');
    if (this.state.lines.length === 0) {
      this.state.lines = [''];
    }
    this.state.cursorRow = 0;
    this.state.cursorCol = 0;
    this.state.scrollOffset = 0;
  }

  // 辅助方法
  private getCurrentLine(): string {
    return this.state.lines[this.state.cursorRow] || '';
  }

  private setCurrentLine(line: string): void {
    this.state.lines[this.state.cursorRow] = line;
  }

  private handleReturn(): boolean {
    const currentLine = this.getCurrentLine();
    const before = currentLine.slice(0, this.state.cursorCol);
    const after = currentLine.slice(this.state.cursorCol);

    this.setCurrentLine(before);
    this.state.lines.splice(this.state.cursorRow + 1, 0, after);
    this.state.cursorRow++;
    this.state.cursorCol = 0;
    this.updateScroll();

    return true;
  }

  private handleBackspace(): boolean {
    if (this.state.cursorCol > 0) {
      // 删除当前行的字符
      const line = this.getCurrentLine();
      this.setCurrentLine(
        line.slice(0, this.state.cursorCol - 1) +
        line.slice(this.state.cursorCol)
      );
      this.state.cursorCol--;
    } else if (this.state.cursorRow > 0) {
      // 合并到上一行
      const currentLine = this.getCurrentLine();
      this.state.cursorRow--;
      this.state.cursorCol = this.getCurrentLine().length;
      this.setCurrentLine(this.getCurrentLine() + currentLine);
      this.state.lines.splice(this.state.cursorRow + 1, 1);
      this.updateScroll();
    }

    return true;
  }

  private handleDelete(): boolean {
    const line = this.getCurrentLine();

    if (this.state.cursorCol < line.length) {
      // 删除当前位置的字符
      this.setCurrentLine(
        line.slice(0, this.state.cursorCol) +
        line.slice(this.state.cursorCol + 1)
      );
    } else if (this.state.cursorRow < this.state.lines.length - 1) {
      // 合并下一行
      const nextLine = this.state.lines[this.state.cursorRow + 1];
      this.setCurrentLine(line + nextLine);
      this.state.lines.splice(this.state.cursorRow + 1, 1);
    }

    return true;
  }

  private handleUp(): boolean {
    if (this.state.cursorRow > 0) {
      this.state.cursorRow--;
      this.state.cursorCol = Math.min(
        this.state.cursorCol,
        this.getCurrentLine().length
      );
      this.updateScroll();
    }
    return true;
  }

  private handleDown(): boolean {
    if (this.state.cursorRow < this.state.lines.length - 1) {
      this.state.cursorRow++;
      this.state.cursorCol = Math.min(
        this.state.cursorCol,
        this.getCurrentLine().length
      );
      this.updateScroll();
    }
    return true;
  }

  private handleLeft(): boolean {
    if (this.state.cursorCol > 0) {
      this.state.cursorCol--;
    } else if (this.state.cursorRow > 0) {
      this.state.cursorRow--;
      this.state.cursorCol = this.getCurrentLine().length;
      this.updateScroll();
    }
    return true;
  }

  private handleRight(): boolean {
    if (this.state.cursorCol < this.getCurrentLine().length) {
      this.state.cursorCol++;
    } else if (this.state.cursorRow < this.state.lines.length - 1) {
      this.state.cursorRow++;
      this.state.cursorCol = 0;
      this.updateScroll();
    }
    return true;
  }

  private insertText(text: string): boolean {
    const line = this.getCurrentLine();
    this.setCurrentLine(
      line.slice(0, this.state.cursorCol) +
      text +
      line.slice(this.state.cursorCol)
    );
    this.state.cursorCol += text.length;
    return true;
  }

  private updateScroll(): void {
    // 确保光标在可视区域内
    if (this.state.cursorRow < this.state.scrollOffset) {
      this.state.scrollOffset = this.state.cursorRow;
    } else if (this.state.cursorRow >= this.state.scrollOffset + this.maxHeight) {
      this.state.scrollOffset = this.state.cursorRow - this.maxHeight + 1;
    }
  }
}
```

### 3. 撤销/重做支持

```typescript
// undoable-editor.ts
import { MultiLineEditor } from './multi-line-editor';
import { EditorState, cloneState } from './editor-state';
import { KeyEvent } from './types';

export class UndoableEditor extends MultiLineEditor {
  private history: EditorState[] = [];
  private historyIndex: number = -1;
  private maxHistory: number = 100;

  constructor(initialValue: string = '') {
    super(initialValue);
    this.saveState();
  }

  handleKey(key: KeyEvent): boolean {
    // Ctrl+Z: 撤销
    if (key.ctrl && key.name === 'z' && !key.shift) {
      return this.undo();
    }

    // Ctrl+Shift+Z 或 Ctrl+Y: 重做
    if ((key.ctrl && key.name === 'z' && key.shift) ||
        (key.ctrl && key.name === 'y')) {
      return this.redo();
    }

    // 处理其他按键
    const handled = super.handleKey(key);

    // 如果是修改操作，保存状态
    if (handled && this.isModifyingKey(key)) {
      this.saveState();
    }

    return handled;
  }

  private undo(): boolean {
    if (this.historyIndex > 0) {
      this.historyIndex--;
      this.restoreState(this.history[this.historyIndex]);
      return true;
    }
    return false;
  }

  private redo(): boolean {
    if (this.historyIndex < this.history.length - 1) {
      this.historyIndex++;
      this.restoreState(this.history[this.historyIndex]);
      return true;
    }
    return false;
  }

  private saveState(): void {
    // 移除当前位置之后的历史
    this.history = this.history.slice(0, this.historyIndex + 1);

    // 保存当前状态
    this.history.push(cloneState(this.getState()));

    // 限制历史大小
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    } else {
      this.historyIndex++;
    }
  }

  private restoreState(state: EditorState): void {
    this.setState(cloneState(state));
  }

  private isModifyingKey(key: KeyEvent): boolean {
    return key.name === 'return' ||
           key.name === 'backspace' ||
           key.name === 'delete' ||
           (key.sequence && !key.ctrl && !key.meta);
  }

  // 需要在 MultiLineEditor 中添加这些方法
  protected getState(): EditorState {
    return this.state;
  }

  protected setState(state: EditorState): void {
    this.state = state;
  }
}
```

### 4. 自动补全支持

```typescript
// autocomplete-editor.ts
import { UndoableEditor } from './undoable-editor';
import { KeyEvent, Component, RenderContext } from './types';

interface Completion {
  text: string;
  description?: string;
}

export class AutocompleteEditor extends UndoableEditor {
  private completions: Completion[] = [];
  private selectedCompletion: number = 0;
  private showCompletions: boolean = false;
  private completionProvider?: (prefix: string) => Completion[];

  constructor(initialValue: string = '', completionProvider?: (prefix: string) => Completion[]) {
    super(initialValue);
    this.completionProvider = completionProvider;
  }

  render(ctx: RenderContext): Component {
    const editorComponent = super.render(ctx);

    if (!this.showCompletions || this.completions.length === 0) {
      return editorComponent;
    }

    // 渲染补全菜单
    const menuLines = this.completions.map((completion, i) => {
      const selected = i === this.selectedCompletion;
      const prefix = selected ? '> ' : '  ';
      const style = selected ? '\x1b[1m' : '';
      const reset = '\x1b[0m';
      return `${prefix}${style}${completion.text}${reset}`;
    });

    return {
      type: 'container',
      children: [
        editorComponent,
        {
          type: 'text',
          content: '\n' + menuLines.join('\n')
        }
      ]
    };
  }

  handleKey(key: KeyEvent): boolean {
    // 补全菜单打开时的特殊处理
    if (this.showCompletions) {
      switch (key.name) {
        case 'up':
          this.selectedCompletion = Math.max(0, this.selectedCompletion - 1);
          return true;

        case 'down':
          this.selectedCompletion = Math.min(
            this.completions.length - 1,
            this.selectedCompletion + 1
          );
          return true;

        case 'tab':
        case 'return':
          this.applyCompletion(this.completions[this.selectedCompletion]);
          this.showCompletions = false;
          return true;

        case 'escape':
          this.showCompletions = false;
          return true;
      }
    }

    // 正常处理
    const handled = super.handleKey(key);

    // 检测是否需要触发补全
    if (handled && this.shouldTriggerCompletion(key)) {
      this.triggerCompletion();
    }

    return handled;
  }

  private shouldTriggerCompletion(key: KeyEvent): boolean {
    // 输入字符时触发
    return key.sequence && !key.ctrl && !key.meta;
  }

  private triggerCompletion(): void {
    if (!this.completionProvider) return;

    const currentLine = this.getCurrentLine();
    const prefix = currentLine.slice(0, this.getCursorCol());

    this.completions = this.completionProvider(prefix);
    this.selectedCompletion = 0;
    this.showCompletions = this.completions.length > 0;
  }

  private applyCompletion(completion: Completion): void {
    const currentLine = this.getCurrentLine();
    const prefix = currentLine.slice(0, this.getCursorCol());
    const suffix = currentLine.slice(this.getCursorCol());

    // 找到需要替换的部分
    const words = prefix.split(/\s+/);
    const lastWord = words[words.length - 1];
    const replaceStart = this.getCursorCol() - lastWord.length;

    this.setCurrentLine(
      currentLine.slice(0, replaceStart) +
      completion.text +
      suffix
    );

    this.setCursorCol(replaceStart + completion.text.length);
  }

  // 需要在基类中添加这些 getter/setter
  protected getCurrentLine(): string {
    return this.getState().lines[this.getState().cursorRow];
  }

  protected setCurrentLine(line: string): void {
    const state = this.getState();
    state.lines[state.cursorRow] = line;
  }

  protected getCursorCol(): number {
    return this.getState().cursorCol;
  }

  protected setCursorCol(col: number): void {
    this.getState().cursorCol = col;
  }
}
```

### 5. 完整示例

```typescript
// example.ts
import { AutocompleteEditor } from './autocomplete-editor';
import { Completion } from './types';

// 简单的补全提供者
function simpleCompletionProvider(prefix: string): Completion[] {
  const keywords = [
    'function', 'const', 'let', 'var', 'if', 'else', 'for', 'while',
    'return', 'import', 'export', 'class', 'interface', 'type'
  ];

  const words = prefix.split(/\s+/);
  const lastWord = words[words.length - 1].toLowerCase();

  if (lastWord.length < 2) return [];

  return keywords
    .filter(keyword => keyword.startsWith(lastWord))
    .map(keyword => ({
      text: keyword,
      description: `Keyword: ${keyword}`
    }));
}

// 创建编辑器
const editor = new AutocompleteEditor('', simpleCompletionProvider);

// 设置初始内容
editor.setValue(`function hello() {
  console.log('Hello World');
}`);

// 模拟键盘输入
async function demo() {
  // 移动到末尾
  editor.handleKey({ name: 'end', sequence: '', ctrl: false, meta: false, shift: false });

  // 输入新行
  editor.handleKey({ name: 'return', sequence: '\n', ctrl: false, meta: false, shift: false });

  // 输入 'f' 触发补全
  editor.handleKey({ name: '', sequence: 'f', ctrl: false, meta: false, shift: false });

  // 渲染
  const component = editor.render({ width: 80, height: 24, focused: true });
  console.log(component);

  // 应用补全
  editor.handleKey({ name: 'tab', sequence: '\t', ctrl: false, meta: false, shift: false });

  // 获取最终值
  console.log(editor.getValue());
}

demo().catch(console.error);
```

---

## 运行代码

### 项目设置

```bash
# 创建项目
mkdir custom-editor-demo
cd custom-editor-demo

# 初始化
npm init -y
npm install --save-dev typescript @types/node

# 创建 tsconfig.json
cat > tsconfig.json << 'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true
  }
}
EOF
```

### 文件组织

```
custom-editor-demo/
├── src/
│   ├── types.ts
│   ├── editor-state.ts
│   ├── multi-line-editor.ts
│   ├── undoable-editor.ts
│   ├── autocomplete-editor.ts
│   └── example.ts
├── package.json
└── tsconfig.json
```

### 编译和运行

```bash
npx tsc
node dist/example.js
```

---

## 扩展点

### 1. 语法高亮

```typescript
interface Token {
  type: 'keyword' | 'string' | 'comment' | 'number';
  text: string;
}

class SyntaxHighlightEditor extends AutocompleteEditor {
  render(ctx: RenderContext): Component {
    // 对每一行进行语法高亮
    const highlightedLines = this.getState().lines.map(line =>
      this.highlightLine(line)
    );
    // ...
  }

  private highlightLine(line: string): string {
    const tokens = this.tokenize(line);
    return tokens.map(token => this.colorize(token)).join('');
  }
}
```

### 2. 行号显示

```typescript
class LineNumberEditor extends AutocompleteEditor {
  render(ctx: RenderContext): Component {
    const lines = this.getVisibleLines();
    const content = lines.map((line, i) => {
      const lineNum = (this.getScrollOffset() + i + 1).toString().padStart(4);
      return `${lineNum} │ ${line}`;
    }).join('\n');

    return { type: 'text', content };
  }
}
```

### 3. 搜索和替换

```typescript
class SearchableEditor extends AutocompleteEditor {
  private searchTerm: string = '';
  private searchResults: Array<{ row: number; col: number }> = [];

  search(term: string): void {
    this.searchTerm = term;
    this.searchResults = [];

    this.getState().lines.forEach((line, row) => {
      let col = 0;
      while ((col = line.indexOf(term, col)) !== -1) {
        this.searchResults.push({ row, col });
        col += term.length;
      }
    });
  }
}
```

### 4. 多光标支持

```typescript
interface Cursor {
  row: number;
  col: number;
}

class MultiCursorEditor extends AutocompleteEditor {
  private cursors: Cursor[] = [{ row: 0, col: 0 }];

  handleKey(key: KeyEvent): boolean {
    // 对每个光标应用操作
    for (const cursor of this.cursors) {
      this.setCursor(cursor);
      super.handleKey(key);
    }
    return true;
  }
}
```

---

## 总结

### 核心实现

**1. 状态管理**: lines + cursor + scroll
**2. 输入处理**: 完整的键盘事件处理
**3. 渲染逻辑**: 滚动 + 光标显示
**4. 撤销/重做**: 历史栈管理
**5. 自动补全**: 补全提供者 + 菜单显示

### 关键技术

**1. 按行存储**: 便于处理多行操作
**2. 滚动管理**: 确保光标可见
**3. 历史管理**: 支持撤销/重做
**4. 补全集成**: 灵活的补全系统

### 扩展方向

**1. 语法高亮**: 词法分析 + 颜色映射
**2. 行号显示**: 行号 + 分隔符
**3. 搜索替换**: 模式匹配 + 高亮
**4. 多光标**: 多个编辑位置

### 下一步

- **实战练习**: 实现自己的编辑器特性
- **源码参考**: `sourcecode/pi-mono/packages/tui/src/components/editor.ts`
- **深入学习**: 阅读 **07_实战代码_03_Widget组件创建.md**

---

**记住**: 编辑器开发的核心是状态管理和输入处理，渲染只是状态的可视化！

---

**版本**: v1.0
**最后更新**: 2026-02-21
**维护者**: Claude Code
