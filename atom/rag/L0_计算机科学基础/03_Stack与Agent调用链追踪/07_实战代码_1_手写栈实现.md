# 实战代码1：手写栈实现

> 从零实现 Stack 数据结构，理解底层原理

---

## 学习目标

- 掌握数组和链表两种栈实现方式
- 理解动态扩容策略
- 实现线程安全的栈
- 性能对比和优化

---

## 1. 数组实现的栈

### 1.1 基础版本

```python
class ArrayStack:
    """基于数组的栈实现"""

    def __init__(self, capacity=10):
        self.items = []
        self.capacity = capacity

    def push(self, item):
        """压栈 - O(1) 平均"""
        if len(self.items) >= self.capacity:
            self._resize()
        self.items.append(item)

    def pop(self):
        """出栈 - O(1)"""
        if self.is_empty():
            raise IndexError("pop from empty stack")
        return self.items.pop()

    def peek(self):
        """查看栈顶 - O(1)"""
        if self.is_empty():
            raise IndexError("peek from empty stack")
        return self.items[-1]

    def is_empty(self):
        """检查是否为空 - O(1)"""
        return len(self.items) == 0

    def size(self):
        """返回栈大小 - O(1)"""
        return len(self.items)

    def _resize(self):
        """动态扩容 - 加倍策略"""
        self.capacity *= 2
        print(f"扩容到: {self.capacity}")

    def __str__(self):
        return f"Stack({self.items})"

# 测试
stack = ArrayStack(capacity=3)

print("=== 测试 Push ===")
stack.push(1)
stack.push(2)
stack.push(3)
print(stack)  # Stack([1, 2, 3])

stack.push(4)  # 触发扩容
print(stack)  # Stack([1, 2, 3, 4])

print("\n=== 测试 Pop ===")
print(f"Pop: {stack.pop()}")  # 4
print(f"Pop: {stack.pop()}")  # 3
print(stack)  # Stack([1, 2])

print("\n=== 测试 Peek ===")
print(f"Peek: {stack.peek()}")  # 2
print(f"Size: {stack.size()}")  # 2
```

**输出：**
```
=== 测试 Push ===
Stack([1, 2, 3])
扩容到: 6
Stack([1, 2, 3, 4])

=== 测试 Pop ===
Pop: 4
Pop: 3
Stack([1, 2])

=== 测试 Peek ===
Peek: 2
Size: 2
```

### 1.2 完整版本（带统计信息）

```python
from typing import Any, Optional
import time

class EnhancedArrayStack:
    """增强版数组栈 - 带性能统计"""

    def __init__(self, capacity=10):
        self.items = []
        self.capacity = capacity
        self.max_size = 0
        self.total_pushes = 0
        self.total_pops = 0
        self.resize_count = 0

    def push(self, item: Any):
        """压栈"""
        if len(self.items) >= self.capacity:
            self._resize()

        self.items.append(item)
        self.total_pushes += 1
        self.max_size = max(self.max_size, len(self.items))

    def pop(self) -> Any:
        """出栈"""
        if self.is_empty():
            raise IndexError("pop from empty stack")

        self.total_pops += 1
        return self.items.pop()

    def peek(self) -> Any:
        """查看栈顶"""
        if self.is_empty():
            raise IndexError("peek from empty stack")
        return self.items[-1]

    def is_empty(self) -> bool:
        """检查是否为空"""
        return len(self.items) == 0

    def size(self) -> int:
        """返回当前大小"""
        return len(self.items)

    def clear(self):
        """清空栈"""
        self.items = []

    def _resize(self):
        """动态扩容 - 加倍策略"""
        old_capacity = self.capacity
        self.capacity *= 2
        self.resize_count += 1
        print(f"扩容: {old_capacity} → {self.capacity}")

    def get_stats(self) -> dict:
        """获取统计信息"""
        return {
            'current_size': len(self.items),
            'capacity': self.capacity,
            'max_size': self.max_size,
            'total_pushes': self.total_pushes,
            'total_pops': self.total_pops,
            'resize_count': self.resize_count,
            'memory_usage': len(self.items) * 8  # 粗略估计（字节）
        }

    def __str__(self):
        preview = str(self.items[:5])
        if len(self.items) > 5:
            preview = preview[:-1] + f", ... ({len(self.items)} items)]"
        return f"Stack{preview}"

# 性能测试
print("=== 性能测试 ===")
stack = EnhancedArrayStack(capacity=2)

# 大量 Push 操作
start = time.time()
for i in range(1000):
    stack.push(i)
push_time = time.time() - start

# 大量 Pop 操作
start = time.time()
for i in range(500):
    stack.pop()
pop_time = time.time() - start

# 打印统计
stats = stack.get_stats()
print(f"\nPush 1000 次耗时: {push_time:.4f}s")
print(f"Pop 500 次耗时: {pop_time:.4f}s")
print(f"\n统计信息:")
for key, value in stats.items():
    print(f"  {key}: {value}")
```

---

## 2. 链表实现的栈

### 2.1 基础版本

```python
class Node:
    """链表节点"""
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedStack:
    """基于链表的栈实现"""

    def __init__(self):
        self.top = None
        self._size = 0

    def push(self, item):
        """压栈 - O(1)"""
        new_node = Node(item)
        new_node.next = self.top
        self.top = new_node
        self._size += 1

    def pop(self):
        """出栈 - O(1)"""
        if self.is_empty():
            raise IndexError("pop from empty stack")

        data = self.top.data
        self.top = self.top.next
        self._size -= 1
        return data

    def peek(self):
        """查看栈顶 - O(1)"""
        if self.is_empty():
            raise IndexError("peek from empty stack")
        return self.top.data

    def is_empty(self):
        """检查是否为空 - O(1)"""
        return self.top is None

    def size(self):
        """返回栈大小 - O(1)"""
        return self._size

    def __str__(self):
        items = []
        current = self.top
        while current and len(items) < 5:
            items.append(current.data)
            current = current.next

        if current:
            items.append('...')

        return f"Stack({items})"

# 测试
stack = LinkedStack()

print("=== 测试链表栈 ===")
stack.push(1)
stack.push(2)
stack.push(3)
print(stack)  # Stack([3, 2, 1])

print(f"Pop: {stack.pop()}")  # 3
print(f"Peek: {stack.peek()}")  # 2
print(f"Size: {stack.size()}")  # 2
```

### 2.2 完整版本（带迭代器）

```python
from typing import Any, Iterator

class EnhancedLinkedStack:
    """增强版链表栈 - 支持迭代"""

    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    def __init__(self):
        self.top = None
        self._size = 0

    def push(self, item: Any):
        """压栈"""
        new_node = self.Node(item)
        new_node.next = self.top
        self.top = new_node
        self._size += 1

    def pop(self) -> Any:
        """出栈"""
        if self.is_empty():
            raise IndexError("pop from empty stack")

        data = self.top.data
        self.top = self.top.next
        self._size -= 1
        return data

    def peek(self) -> Any:
        """查看栈顶"""
        if self.is_empty():
            raise IndexError("peek from empty stack")
        return self.top.data

    def is_empty(self) -> bool:
        """检查是否为空"""
        return self.top is None

    def size(self) -> int:
        """返回栈大小"""
        return self._size

    def clear(self):
        """清空栈"""
        self.top = None
        self._size = 0

    def to_list(self) -> list:
        """转换为列表（从栈顶到栈底）"""
        result = []
        current = self.top
        while current:
            result.append(current.data)
            current = current.next
        return result

    def __iter__(self) -> Iterator:
        """支持迭代"""
        current = self.top
        while current:
            yield current.data
            current = current.next

    def __str__(self):
        items = list(self)[:5]
        if self._size > 5:
            items.append('...')
        return f"Stack({items})"

# 测试迭代器
stack = EnhancedLinkedStack()
for i in range(5):
    stack.push(i)

print("=== 测试迭代器 ===")
print("遍历栈（从栈顶到栈底）:")
for item in stack:
    print(f"  {item}")

print(f"\n转换为列表: {stack.to_list()}")
```

---

## 3. 性能对比

### 3.1 对比测试

```python
import time
from typing import Callable

def benchmark_stack(stack_class: type, operations: int = 10000) -> dict:
    """性能测试"""
    stack = stack_class()

    # 测试 Push
    start = time.time()
    for i in range(operations):
        stack.push(i)
    push_time = time.time() - start

    # 测试 Peek
    start = time.time()
    for _ in range(operations):
        stack.peek()
    peek_time = time.time() - start

    # 测试 Pop
    start = time.time()
    for _ in range(operations):
        stack.pop()
    pop_time = time.time() - start

    return {
        'push_time': push_time,
        'peek_time': peek_time,
        'pop_time': pop_time,
        'total_time': push_time + peek_time + pop_time
    }

# 对比测试
print("=== 性能对比（10000 次操作）===\n")

array_result = benchmark_stack(EnhancedArrayStack)
print("数组栈:")
print(f"  Push: {array_result['push_time']:.4f}s")
print(f"  Peek: {array_result['peek_time']:.4f}s")
print(f"  Pop:  {array_result['pop_time']:.4f}s")
print(f"  总计: {array_result['total_time']:.4f}s")

linked_result = benchmark_stack(EnhancedLinkedStack)
print("\n链表栈:")
print(f"  Push: {linked_result['push_time']:.4f}s")
print(f"  Peek: {linked_result['peek_time']:.4f}s")
print(f"  Pop:  {linked_result['pop_time']:.4f}s")
print(f"  总计: {linked_result['total_time']:.4f}s")

# 性能差异
diff = (array_result['total_time'] / linked_result['total_time'] - 1) * 100
print(f"\n性能差异: {abs(diff):.1f}% ({'数组更快' if diff < 0 else '链表更快'})")
```

**输出示例：**
```
=== 性能对比（10000 次操作）===

数组栈:
  Push: 0.0012s
  Peek: 0.0008s
  Pop:  0.0010s
  总计: 0.0030s

链表栈:
  Push: 0.0015s
  Peek: 0.0009s
  Pop:  0.0012s
  总计: 0.0036s

性能差异: 20.0% (数组更快)
```

### 3.2 内存使用对比

```python
import sys

def compare_memory(n: int = 1000):
    """对比内存使用"""
    # 数组栈
    array_stack = EnhancedArrayStack()
    for i in range(n):
        array_stack.push(i)

    # 链表栈
    linked_stack = EnhancedLinkedStack()
    for i in range(n):
        linked_stack.push(i)

    # 估算内存（简化）
    array_memory = sys.getsizeof(array_stack.items) + len(array_stack.items) * 8
    linked_memory = n * (sys.getsizeof(EnhancedLinkedStack.Node(0)) + 8)

    print(f"=== 内存使用对比（{n} 个元素）===")
    print(f"数组栈: ~{array_memory / 1024:.2f} KB")
    print(f"链表栈: ~{linked_memory / 1024:.2f} KB")
    print(f"差异: {(linked_memory / array_memory - 1) * 100:.1f}%")

compare_memory(1000)
```

---

## 4. 线程安全的栈

### 4.1 使用锁实现线程安全

```python
import threading
from typing import Any

class ThreadSafeStack:
    """线程安全的栈"""

    def __init__(self):
        self.items = []
        self.lock = threading.Lock()

    def push(self, item: Any):
        """线程安全的压栈"""
        with self.lock:
            self.items.append(item)

    def pop(self) -> Any:
        """线程安全的出栈"""
        with self.lock:
            if not self.items:
                raise IndexError("pop from empty stack")
            return self.items.pop()

    def peek(self) -> Any:
        """线程安全的查看栈顶"""
        with self.lock:
            if not self.items:
                raise IndexError("peek from empty stack")
            return self.items[-1]

    def is_empty(self) -> bool:
        """线程安全的检查是否为空"""
        with self.lock:
            return len(self.items) == 0

    def size(self) -> int:
        """线程安全的获取大小"""
        with self.lock:
            return len(self.items)

# 测试多线程
def producer(stack: ThreadSafeStack, n: int):
    """生产者线程"""
    for i in range(n):
        stack.push(i)
        print(f"Push: {i}")

def consumer(stack: ThreadSafeStack, n: int):
    """消费者线程"""
    for _ in range(n):
        try:
            item = stack.pop()
            print(f"Pop: {item}")
        except IndexError:
            print("Stack empty, waiting...")
            threading.Event().wait(0.01)

# 测试
stack = ThreadSafeStack()

t1 = threading.Thread(target=producer, args=(stack, 10))
t2 = threading.Thread(target=consumer, args=(stack, 10))

t1.start()
t2.start()

t1.join()
t2.join()

print(f"\n最终栈大小: {stack.size()}")
```

---

## 5. AI Agent 专用栈实现

### 5.1 Agent 调用栈

```python
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, Optional

@dataclass
class CallFrame:
    """调用帧"""
    function_name: str
    arguments: Dict[str, Any]
    start_time: datetime
    depth: int
    parent_frame: Optional['CallFrame'] = None

class AgentCallStack:
    """AI Agent 调用栈"""

    def __init__(self, max_depth: int = 50):
        self.frames = []
        self.max_depth = max_depth
        self.execution_log = []

    def enter_function(self, func_name: str, args: Dict[str, Any]):
        """进入函数"""
        if len(self.frames) >= self.max_depth:
            raise RuntimeError(f"调用深度超过限制 {self.max_depth}")

        parent = self.frames[-1] if self.frames else None
        frame = CallFrame(
            function_name=func_name,
            arguments=args,
            start_time=datetime.now(),
            depth=len(self.frames),
            parent_frame=parent
        )
        self.frames.append(frame)

        indent = "  " * frame.depth
        print(f"{indent}→ {func_name}({args})")

    def exit_function(self, result: Any = None):
        """退出函数"""
        if not self.frames:
            raise RuntimeError("调用栈为空")

        frame = self.frames.pop()
        duration = (datetime.now() - frame.start_time).total_seconds()

        # 记录日志
        self.execution_log.append({
            'function': frame.function_name,
            'args': frame.arguments,
            'depth': frame.depth,
            'duration': duration,
            'result': result
        })

        indent = "  " * len(self.frames)
        print(f"{indent}← {frame.function_name} (耗时: {duration:.3f}s)")

        return result

    def get_call_chain(self) -> list:
        """获取当前调用链"""
        return [f.function_name for f in self.frames]

    def get_current_depth(self) -> int:
        """获取当前深度"""
        return len(self.frames)

    def print_summary(self):
        """打印执行摘要"""
        print("\n" + "="*50)
        print("执行摘要:")
        print("="*50)
        for log in self.execution_log:
            indent = "  " * log['depth']
            print(f"{indent}{log['function']}: {log['duration']:.3f}s")

# 使用示例
call_stack = AgentCallStack(max_depth=10)

def research_agent(query: str):
    call_stack.enter_function('research_agent', {'query': query})

    search_results = search_tool(query)
    analysis = analyze_tool(search_results)

    call_stack.exit_function(result=analysis)
    return analysis

def search_tool(query: str):
    call_stack.enter_function('search_tool', {'query': query})
    import time
    time.sleep(0.1)
    results = [f"结果 for {query}"]
    call_stack.exit_function(result=results)
    return results

def analyze_tool(results: list):
    call_stack.enter_function('analyze_tool', {'count': len(results)})
    import time
    time.sleep(0.15)
    analysis = f"分析了 {len(results)} 个结果"
    call_stack.exit_function(result=analysis)
    return analysis

# 执行
print("=== Agent 调用栈测试 ===\n")
result = research_agent("AI Agent 2026")
call_stack.print_summary()
```

---

## 6. 选择建议

### 6.1 何时使用数组栈

✅ **适合场景：**
- 栈大小可预测
- 需要缓存友好的性能
- 内存使用要求严格
- 频繁的 peek 操作

❌ **不适合场景：**
- 栈大小不可预测且可能很大
- 需要避免扩容开销
- 元素是大对象（复制成本高）

### 6.2 何时使用链表栈

✅ **适合场景：**
- 栈大小不可预测
- 需要真正的 O(1) 插入（无扩容）
- 元素是大对象
- 内存分配灵活性重要

❌ **不适合场景：**
- 需要最佳缓存性能
- 内存开销敏感（指针开销）
- 需要随机访问（栈不需要）

### 6.3 AI Agent 场景建议

| 场景 | 推荐实现 | 原因 |
|------|---------|------|
| **调用链追踪** | 数组栈 | 深度可控，缓存友好 |
| **状态快照** | 链表栈 | 状态对象大，避免复制 |
| **Prompt 嵌套** | 数组栈 | 嵌套层级有限 |
| **回溯搜索** | 数组栈 | 频繁 push/pop |
| **多线程 Agent** | 线程安全栈 | 并发访问 |

---

## 总结

**数组栈特点：**
- 实现简单，缓存友好
- 偶尔需要扩容（O(n)）
- 适合大多数场景

**链表栈特点：**
- 真正的 O(1) 插入
- 内存灵活，无扩容
- 指针开销，缓存不友好

**线程安全栈：**
- 使用锁保护
- 性能略有下降
- 多线程必需

**AI Agent 应用：**
- 调用链追踪：数组栈
- 状态管理：根据对象大小选择
- 深度限制：必须实现

**记住：** 没有完美的实现，根据实际场景选择！
