# 自定义Tool - 双重类比

> 用前端开发和日常生活的类比理解自定义Tool

---

## 类比1：@tool装饰器 = Express路由装饰器

### 前端类比：Express路由装饰器

在Express中，你用装饰器定义API路由：

```typescript
// Express + TypeScript装饰器
@Get('/weather/:city')
async getWeather(@Param('city') city: string): Promise<WeatherResponse> {
    const data = await weatherService.fetch(city);
    return { weather: data.weather, temp: data.temp };
}
```

**关键要素：**
- `@Get()`：告诉框架这是一个GET路由
- 路径参数：`/weather/:city`
- 参数提取：`@Param('city')`
- 返回值：自动序列化为JSON

### Python自定义Tool

在LangChain中，你用装饰器定义Tool：

```python
from langchain.tools import tool

@tool
async def get_weather(city: str) -> str:
    """获取指定城市的天气信息

    Args:
        city: 城市名称，如'北京'
    """
    data = await weather_service.fetch(city)
    return f"{city}的天气：{data['weather']}，温度{data['temp']}°C"
```

**关键要素：**
- `@tool`：告诉LangChain这是一个Tool
- 函数名：`get_weather` → Tool名称
- 参数：`city: str` → Tool参数
- 文档字符串：LLM用来理解Tool功能
- 返回值：必须是字符串（LLM只能理解文本）

### 相似性

| Express路由 | LangChain Tool | 说明 |
|------------|----------------|------|
| `@Get()` | `@tool` | 声明这是一个可调用的端点/工具 |
| 路径 `/weather/:city` | 函数名 `get_weather` | 标识符，用于调用 |
| `@Param('city')` | 参数 `city: str` | 提取输入参数 |
| 返回JSON | 返回字符串 | 返回结果给调用者 |
| API文档 | 文档字符串 | 说明功能和用法 |

### 日常生活类比：餐厅菜单

**餐厅菜单就是Tool列表：**

```
菜单（Tool列表）
├── 宫保鸡丁（get_weather）
│   └── 说明：川菜，辣味，主料鸡肉（Tool描述）
│   └── 配料：鸡肉、花生、辣椒（参数）
│   └── 价格：38元（返回值）
│
├── 红烧肉（query_database）
│   └── 说明：浓油赤酱，肥而不腻（Tool描述）
│   └── 配料：五花肉、冰糖、酱油（参数）
│   └── 价格：48元（返回值）
```

**点菜过程 = Agent调用Tool：**
1. 顾客（用户）："我想吃辣的"
2. 服务员（LLM）：查看菜单，找到"宫保鸡丁"（选择Tool）
3. 服务员问："要几份？"（提取参数）
4. 厨师（Tool执行）：做菜
5. 上菜（返回结果）

---

## 类比2：参数验证 = express-validator

### 前端类比：express-validator

在Express中，你用validator验证请求参数：

```typescript
import { body, validationResult } from 'express-validator';

app.post('/search',
    // 验证规则
    body('keyword')
        .isString()
        .isLength({ min: 1, max: 100 })
        .withMessage('关键词长度必须在1-100之间'),
    body('limit')
        .isInt({ min: 1, max: 50 })
        .withMessage('limit必须在1-50之间'),

    // 处理函数
    async (req, res) => {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ errors: errors.array() });
        }

        const { keyword, limit } = req.body;
        const results = await searchService.search(keyword, limit);
        res.json(results);
    }
);
```

### Python自定义Tool

在LangChain中，你用Pydantic验证Tool参数：

```python
from langchain.tools import tool
from pydantic import BaseModel, Field

class SearchInput(BaseModel):
    """搜索参数"""
    keyword: str = Field(
        description="搜索关键词",
        min_length=1,
        max_length=100
    )
    limit: int = Field(
        default=10,
        description="返回数量",
        ge=1,  # 大于等于1
        le=50  # 小于等于50
    )

@tool(args_schema=SearchInput)
def search_products(keyword: str, limit: int = 10) -> str:
    """搜索产品数据库"""
    results = search_service.search(keyword, limit)
    return "\n".join(results)
```

### 相似性

| express-validator | Pydantic | 说明 |
|------------------|----------|------|
| `body('keyword')` | `keyword: str` | 定义参数 |
| `.isString()` | `: str` | 类型验证 |
| `.isLength({ min: 1, max: 100 })` | `min_length=1, max_length=100` | 长度限制 |
| `.isInt({ min: 1, max: 50 })` | `ge=1, le=50` | 数值范围 |
| `.withMessage()` | `description=` | 错误提示 |
| `validationResult(req)` | Pydantic自动验证 | 执行验证 |

### 日常生活类比：门卫检查证件

**门卫（参数验证）检查访客（参数）：**

```
访客来访（Tool调用）
    ↓
门卫检查（Pydantic验证）
    ├── 检查证件类型（类型验证）
    │   ✅ 身份证 → 通过
    │   ❌ 学生证 → 拒绝
    │
    ├── 检查证件有效期（范围验证）
    │   ✅ 2024-12-31 → 通过
    │   ❌ 2020-01-01 → 拒绝（过期）
    │
    └── 检查访问权限（业务验证）
        ✅ 有预约 → 通过
        ❌ 无预约 → 拒绝
    ↓
放行进入（执行Tool）
```

**为什么需要门卫？**
- 防止无效访客（无效参数）
- 防止危险访客（恶意输入）
- 记录访客信息（日志）

---

## 类比3：Tool描述 = API文档

### 前端类比：Swagger/OpenAPI文档

在Express中，你用Swagger生成API文档：

```typescript
/**
 * @swagger
 * /api/orders/{orderId}:
 *   get:
 *     summary: 获取订单详情
 *     description: 根据订单ID查询订单的完整信息，包括订单状态、商品列表、总金额、收货地址
 *     parameters:
 *       - in: path
 *         name: orderId
 *         required: true
 *         schema:
 *           type: string
 *         description: 订单ID，格式为ORD-XXXXXX
 *     responses:
 *       200:
 *         description: 订单详细信息
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Order'
 */
@Get('/api/orders/:orderId')
async getOrderDetails(@Param('orderId') orderId: string) {
    return await orderService.getDetails(orderId);
}
```

### Python自定义Tool

在LangChain中，你用文档字符串描述Tool：

```python
from langchain.tools import tool

@tool
def get_order_details(order_id: str) -> str:
    """获取订单详细信息

    根据订单ID查询订单的完整信息，包括：
    - 订单状态（待支付、已支付、已发货、已完成）
    - 商品列表
    - 总金额
    - 收货地址

    适用场景：
    - 用户询问"我的订单XXX怎么样了？"
    - 用户询问"订单XXX的物流信息"
    - 客服需要查看订单详情

    Args:
        order_id: 订单ID，格式为ORD-XXXXXX

    Returns:
        订单详细信息的文本描述
    """
    return order_service.get_details(order_id)
```

### 相似性

| Swagger文档 | Tool文档字符串 | 说明 |
|------------|----------------|------|
| `summary` | 第一行 | 简短描述 |
| `description` | 详细说明 | 功能详情 |
| `parameters` | `Args:` | 参数说明 |
| `responses` | `Returns:` | 返回值说明 |
| 示例场景 | `适用场景:` | 何时使用 |

**关键区别：**
- **Swagger文档**：给前端开发者看，说明如何调用API
- **Tool文档**：给LLM看，说明何时调用Tool

### 日常生活类比：工具说明书

**工具箱里的工具都有说明书：**

```
电钻（Tool）
├── 名称：手持电钻（Tool名称）
├── 用途：在墙上打孔（Tool描述）
├── 适用场景：
│   - 挂画框
│   - 安装空调
│   - 固定家具
├── 使用方法：
│   1. 选择钻头（参数1）
│   2. 调整转速（参数2）
│   3. 对准位置
│   4. 按下开关
└── 注意事项：
    - 戴护目镜
    - 避开电线
```

**LLM选择Tool = 工人选择工具：**

```
任务："墙上挂画"
    ↓
工人查看工具箱（可用Tools）
    ├── 电钻："在墙上打孔" ✅ 匹配！
    ├── 锤子："敲打钉子" ❌ 不够精确
    └── 螺丝刀："拧螺丝" ❌ 不适用
    ↓
选择电钻（调用Tool）
```

---

## 类比4：异步Tool = Promise/async-await

### 前端类比：异步API调用

在前端中，你用async/await处理异步操作：

```typescript
// 同步操作（阻塞）
function fetchWeatherSync(city: string): WeatherData {
    const response = httpClient.get(`/api/weather?city=${city}`);
    // 等待响应... 阻塞其他操作
    return response.data;
}

// 异步操作（非阻塞）
async function fetchWeatherAsync(city: string): Promise<WeatherData> {
    const response = await httpClient.get(`/api/weather?city=${city}`);
    // 等待时可以处理其他任务
    return response.data;
}

// 并发调用多个API
async function fetchMultipleCities() {
    const results = await Promise.all([
        fetchWeatherAsync('北京'),
        fetchWeatherAsync('上海'),
        fetchWeatherAsync('广州')
    ]);
    return results;
}
```

### Python自定义Tool

在LangChain中，你用async/await创建异步Tool：

```python
import httpx
from langchain.tools import tool

# 同步Tool（阻塞）
@tool
def fetch_weather_sync(city: str) -> str:
    """获取天气（同步）"""
    response = httpx.get(f"https://api.weather.com/v1/current?city={city}")
    # 等待响应... 阻塞其他操作
    return response.text

# 异步Tool（非阻塞）
@tool
async def fetch_weather_async(city: str) -> str:
    """获取天气（异步）"""
    async with httpx.AsyncClient() as client:
        response = await client.get(f"https://api.weather.com/v1/current?city={city}")
        # 等待时可以处理其他任务
        return response.text

# Agent可以并发调用多个异步Tool
# LangChain会自动处理并发
```

### 相似性

| JavaScript | Python | 说明 |
|-----------|--------|------|
| `async function` | `async def` | 定义异步函数 |
| `await fetch()` | `await client.get()` | 等待异步操作 |
| `Promise.all()` | `asyncio.gather()` | 并发执行 |
| `try/catch` | `try/except` | 错误处理 |
| `finally` | `finally` | 清理资源 |

### 日常生活类比：点餐等待

**同步操作（阻塞）= 站在柜台等：**

```
你点餐："一份汉堡"
    ↓
站在柜台等待（阻塞）
    ├── 厨师做汉堡...
    ├── 你什么都不能做
    └── 后面的人也要等
    ↓
拿到汉堡
```

**异步操作（非阻塞）= 拿号等待：**

```
你点餐："一份汉堡"
    ↓
拿号离开（非阻塞）
    ├── 厨师做汉堡...
    ├── 你可以找座位、玩手机
    └── 后面的人可以继续点餐
    ↓
叫号时拿汉堡
```

**并发操作 = 同时点多份：**

```
你点餐："3份汉堡"
    ↓
拿3个号（并发）
    ├── 厨师1做汉堡1
    ├── 厨师2做汉堡2
    └── 厨师3做汉堡3
    ↓
同时拿到3份汉堡（比依次等快3倍）
```

---

## 类比5：资源管理 = 连接池

### 前端类比：HTTP Keep-Alive

在前端中，你复用HTTP连接：

```typescript
// 不复用连接（每次都建立新连接）
async function fetchDataBad() {
    for (let i = 0; i < 100; i++) {
        const client = new HttpClient();  // 新建连接
        await client.get('/api/data');
        client.close();  // 关闭连接
    }
    // 慢！每次都要TCP握手
}

// 复用连接（连接池）
const httpClient = new HttpClient({
    keepAlive: true,
    maxSockets: 10  // 连接池大小
});

async function fetchDataGood() {
    for (let i = 0; i < 100; i++) {
        await httpClient.get('/api/data');  // 复用连接
    }
    // 快！复用TCP连接
}
```

### Python自定义Tool

在LangChain中，你用连接池管理资源：

```python
import httpx
from langchain.tools import tool

# 不复用连接（每次都建立新连接）
@tool
async def fetch_data_bad(url: str) -> str:
    """获取数据（不复用连接）"""
    async with httpx.AsyncClient() as client:  # 每次新建
        response = await client.get(url)
        return response.text
    # 慢！每次都要TCP握手

# 复用连接（连接池）
# 在模块级别创建客户端
http_client = httpx.AsyncClient(
    limits=httpx.Limits(max_connections=10)  # 连接池大小
)

@tool
async def fetch_data_good(url: str) -> str:
    """获取数据（复用连接）"""
    response = await http_client.get(url)  # 复用连接
    return response.text
    # 快！复用TCP连接
```

### 相似性

| 前端 | Python | 说明 |
|-----|--------|------|
| `new HttpClient()` | `httpx.AsyncClient()` | 创建客户端 |
| `keepAlive: true` | 默认行为 | 保持连接 |
| `maxSockets: 10` | `max_connections=10` | 连接池大小 |
| `client.close()` | `await client.aclose()` | 关闭连接 |

### 日常生活类比：图书馆借书证

**不复用连接 = 每次都办新借书证：**

```
借书流程（不复用）
    ↓
1. 去图书馆
2. 办理借书证（建立连接）
3. 借书
4. 注销借书证（关闭连接）
5. 离开
    ↓
下次借书：重复1-5步
    ↓
慢！每次都要办证
```

**复用连接 = 保留借书证：**

```
借书流程（复用）
    ↓
1. 去图书馆
2. 办理借书证（建立连接）
3. 借书
4. 保留借书证（保持连接）
5. 离开
    ↓
下次借书：直接用借书证借书
    ↓
快！不用重复办证
```

**连接池 = 借书证数量限制：**

```
图书馆规定：
- 每人最多办10张借书证（max_connections=10）
- 超过10张需要等待（排队）
- 用完归还给池子（复用）
```

---

## 类比总结表

| Python后端概念 | 前端/Express类比 | 日常生活类比 | 核心相似性 |
|---------------|-----------------|-------------|-----------|
| **@tool装饰器** | Express路由装饰器 | 餐厅菜单 | 声明可调用的端点 |
| **Tool描述** | Swagger API文档 | 工具说明书 | 说明功能和用法 |
| **参数验证** | express-validator | 门卫检查证件 | 验证输入合法性 |
| **异步Tool** | Promise/async-await | 点餐拿号等待 | 非阻塞操作 |
| **资源管理** | HTTP Keep-Alive | 图书馆借书证 | 复用连接 |
| **Tool调用** | API调用 | 点菜下单 | 请求-响应模式 |
| **Tool返回值** | API响应 | 上菜 | 返回结果 |
| **Tool列表** | API路由表 | 菜单 | 可用功能清单 |
| **LLM选择Tool** | 前端路由匹配 | 服务员推荐菜品 | 根据需求选择 |
| **Tool执行** | 后端处理逻辑 | 厨师做菜 | 实际执行任务 |

---

## 关键洞察

### 1. Tool = API端点

**本质相同：**
- 都是可调用的函数
- 都有输入参数
- 都有返回值
- 都需要文档说明

**关键区别：**
- **API端点**：前端开发者调用（人类）
- **Tool**：LLM调用（AI）

### 2. 描述决定一切

**API文档 vs Tool描述：**

| 对象 | API文档 | Tool描述 |
|-----|---------|---------|
| **读者** | 前端开发者（人类） | LLM（AI） |
| **目的** | 说明如何调用 | 说明何时调用 |
| **重点** | 参数格式、返回值结构 | 功能说明、适用场景 |
| **格式** | Swagger/OpenAPI | 文档字符串 |

**为什么Tool描述更重要？**
- 前端开发者可以看代码、问同事
- LLM只能看描述，无法"理解"代码

### 3. 异步是必需的

**为什么Tool要异步？**

```
同步Tool（阻塞）
    用户问："北京和上海的天气"
        ↓
    调用get_weather("北京")  ← 等待3秒
        ↓
    调用get_weather("上海")  ← 等待3秒
        ↓
    总耗时：6秒

异步Tool（非阻塞）
    用户问："北京和上海的天气"
        ↓
    并发调用：
        get_weather("北京")  ← 等待3秒
        get_weather("上海")  ← 等待3秒
        ↓
    总耗时：3秒（快一倍！）
```

### 4. 资源管理是关键

**为什么需要连接池？**

```
不复用连接：
    100次API调用 = 100次TCP握手 = 慢

复用连接：
    100次API调用 = 1次TCP握手 = 快
```

**类比：**
- 不复用 = 每次打电话都要重新拨号
- 复用 = 保持通话，直接说话

---

## 实践建议

### 1. 像写API文档一样写Tool描述

```python
# ❌ 差的描述
@tool
def get_data(id: str) -> str:
    """获取数据"""
    pass

# ✅ 好的描述
@tool
def get_order_details(order_id: str) -> str:
    """获取订单详细信息

    根据订单ID查询订单的完整信息，包括订单状态、商品列表、总金额、收货地址。

    适用场景：
    - 用户询问"我的订单XXX怎么样了？"
    - 客服需要查看订单详情

    Args:
        order_id: 订单ID，格式为ORD-XXXXXX

    Returns:
        订单详细信息的文本描述
    """
    pass
```

### 2. 像验证API参数一样验证Tool参数

```python
# ❌ 没有验证
@tool
def search(keyword: str, limit: int) -> str:
    """搜索"""
    pass

# ✅ 有验证
from pydantic import BaseModel, Field

class SearchInput(BaseModel):
    keyword: str = Field(min_length=1, max_length=100)
    limit: int = Field(ge=1, le=50, default=10)

@tool(args_schema=SearchInput)
def search(keyword: str, limit: int = 10) -> str:
    """搜索产品"""
    pass
```

### 3. 像管理HTTP连接一样管理Tool资源

```python
# ❌ 每次都创建新连接
@tool
async def fetch_data(url: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.text

# ✅ 复用连接
http_client = httpx.AsyncClient()

@tool
async def fetch_data(url: str) -> str:
    response = await http_client.get(url)
    return response.text
```

---

**记住：** Tool就是给LLM调用的API，用你熟悉的前端开发经验来理解和设计Tool！
