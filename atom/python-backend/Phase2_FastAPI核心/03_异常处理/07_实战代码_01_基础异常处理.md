# 实战代码1：基础异常处理

> 完整可运行的 FastAPI 异常处理基础示例

---

## 示例概述

本示例演示：
1. 使用 HTTPException 抛出标准错误
2. 处理常见的 HTTP 状态码（400、401、404、500）
3. 自定义错误响应格式
4. 基础的日志记录

---

## 完整代码

```python
"""
FastAPI 异常处理基础示例
演示：HTTPException 的基本用法和常见错误场景
"""

from fastapi import FastAPI, HTTPException, Header, Query
from pydantic import BaseModel, EmailStr, validator
from typing import Optional
from datetime import datetime
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = FastAPI(title="异常处理基础示例")

# ===== 模拟数据库 =====
users_db = {
    1: {"id": 1, "name": "Alice", "email": "alice@example.com", "role": "user"},
    2: {"id": 2, "name": "Bob", "email": "bob@example.com", "role": "admin"},
    3: {"id": 3, "name": "Charlie", "email": "charlie@example.com", "role": "user"}
}

posts_db = {
    1: {"id": 1, "title": "FastAPI 入门", "author_id": 1, "content": "FastAPI 是一个现代的 Web 框架"},
    2: {"id": 2, "title": "Python 异步编程", "author_id": 2, "content": "async/await 的使用"},
}

# ===== Pydantic 模型 =====
class UserCreate(BaseModel):
    name: str
    email: EmailStr
    role: str = "user"

    @validator('role')
    def validate_role(cls, v):
        if v not in ['user', 'admin']:
            raise ValueError('角色必须是 user 或 admin')
        return v

class PostCreate(BaseModel):
    title: str
    author_id: int
    content: str

    @validator('title')
    def validate_title(cls, v):
        if len(v) < 5:
            raise ValueError('标题至少需要 5 个字符')
        return v

# ===== 场景1：资源不存在（404） =====
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    """
    获取用户信息
    错误场景：用户不存在 → 404
    """
    logger.info(f"获取用户: {user_id}")

    user = users_db.get(user_id)
    if not user:
        logger.warning(f"用户 {user_id} 不存在")
        raise HTTPException(
            status_code=404,
            detail=f"用户 {user_id} 不存在"
        )

    logger.info(f"成功获取用户: {user['name']}")
    return user

@app.get("/posts/{post_id}")
async def get_post(post_id: int):
    """
    获取文章信息
    错误场景：文章不存在 → 404
    """
    logger.info(f"获取文章: {post_id}")

    post = posts_db.get(post_id)
    if not post:
        logger.warning(f"文章 {post_id} 不存在")
        raise HTTPException(
            status_code=404,
            detail=f"文章 {post_id} 不存在"
        )

    logger.info(f"成功获取文章: {post['title']}")
    return post

# ===== 场景2：未授权（401） =====
@app.get("/admin/users")
async def list_users(authorization: Optional[str] = Header(None)):
    """
    管理员查看用户列表
    错误场景：
    - 未提供 Token → 401
    - Token 格式错误 → 401
    - Token 无效 → 401
    """
    logger.info("管理员查看用户列表")

    # 检查是否提供了 Token
    if not authorization:
        logger.warning("未提供认证信息")
        raise HTTPException(
            status_code=401,
            detail="未提供认证信息，请在 Header 中添加 Authorization",
            headers={"WWW-Authenticate": "Bearer"}
        )

    # 检查 Token 格式
    if not authorization.startswith("Bearer "):
        logger.warning("认证格式错误")
        raise HTTPException(
            status_code=401,
            detail="认证格式错误，应为 'Bearer <token>'",
            headers={"WWW-Authenticate": "Bearer"}
        )

    # 提取 Token
    token = authorization.replace("Bearer ", "")

    # 验证 Token（简化版，实际应该用 JWT）
    if token != "secret-admin-token":
        logger.warning(f"Token 无效: {token}")
        raise HTTPException(
            status_code=401,
            detail="Token 无效或已过期",
            headers={"WWW-Authenticate": "Bearer"}
        )

    logger.info("认证成功，返回用户列表")
    return {"users": list(users_db.values())}

# ===== 场景3：权限不足（403） =====
@app.delete("/users/{user_id}")
async def delete_user(
    user_id: int,
    authorization: Optional[str] = Header(None)
):
    """
    删除用户
    错误场景：
    - 未认证 → 401
    - 非管理员 → 403
    - 用户不存在 → 404
    """
    logger.info(f"删除用户: {user_id}")

    # 检查认证
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(
            status_code=401,
            detail="未提供认证信息"
        )

    token = authorization.replace("Bearer ", "")

    # 简化的用户认证（实际应该从 Token 解析用户信息）
    current_user = None
    if token == "secret-admin-token":
        current_user = {"id": 2, "role": "admin"}
    elif token == "secret-user-token":
        current_user = {"id": 1, "role": "user"}
    else:
        raise HTTPException(status_code=401, detail="Token 无效")

    # 检查权限
    if current_user["role"] != "admin":
        logger.warning(f"用户 {current_user['id']} 权限不足")
        raise HTTPException(
            status_code=403,
            detail="权限不足，仅管理员可以删除用户"
        )

    # 检查用户是否存在
    if user_id not in users_db:
        raise HTTPException(
            status_code=404,
            detail=f"用户 {user_id} 不存在"
        )

    # 删除用户
    deleted_user = users_db.pop(user_id)
    logger.info(f"成功删除用户: {deleted_user['name']}")

    return {"message": f"用户 {deleted_user['name']} 已删除"}

# ===== 场景4：请求参数错误（400） =====
@app.post("/users")
async def create_user(user: UserCreate):
    """
    创建用户
    错误场景：
    - 邮箱已存在 → 400
    - 数据验证失败 → 422（Pydantic 自动处理）
    """
    logger.info(f"创建用户: {user.email}")

    # 检查邮箱是否已存在
    for existing_user in users_db.values():
        if existing_user["email"] == user.email:
            logger.warning(f"邮箱 {user.email} 已存在")
            raise HTTPException(
                status_code=400,
                detail=f"邮箱 {user.email} 已被注册"
            )

    # 创建新用户
    new_id = max(users_db.keys()) + 1
    new_user = {
        "id": new_id,
        "name": user.name,
        "email": user.email,
        "role": user.role
    }
    users_db[new_id] = new_user

    logger.info(f"成功创建用户: {new_user['name']}")
    return {"message": "用户创建成功", "user": new_user}

@app.post("/posts")
async def create_post(post: PostCreate):
    """
    创建文章
    错误场景：
    - 作者不存在 → 400
    - 标题过短 → 422（Pydantic 自动处理）
    """
    logger.info(f"创建文章: {post.title}")

    # 检查作者是否存在
    if post.author_id not in users_db:
        logger.warning(f"作者 {post.author_id} 不存在")
        raise HTTPException(
            status_code=400,
            detail=f"作者 {post.author_id} 不存在"
        )

    # 创建新文章
    new_id = max(posts_db.keys()) + 1
    new_post = {
        "id": new_id,
        "title": post.title,
        "author_id": post.author_id,
        "content": post.content,
        "created_at": datetime.utcnow().isoformat()
    }
    posts_db[new_id] = new_post

    logger.info(f"成功创建文章: {new_post['title']}")
    return {"message": "文章创建成功", "post": new_post}

# ===== 场景5：查询参数验证（400） =====
@app.get("/users")
async def search_users(
    role: Optional[str] = Query(None, description="用户角色"),
    limit: int = Query(10, ge=1, le=100, description="返回数量")
):
    """
    搜索用户
    错误场景：
    - 角色参数无效 → 400
    - limit 超出范围 → 422（FastAPI 自动处理）
    """
    logger.info(f"搜索用户: role={role}, limit={limit}")

    # 验证角色参数
    if role and role not in ['user', 'admin']:
        logger.warning(f"无效的角色参数: {role}")
        raise HTTPException(
            status_code=400,
            detail=f"无效的角色参数: {role}，必须是 'user' 或 'admin'"
        )

    # 过滤用户
    users = list(users_db.values())
    if role:
        users = [u for u in users if u["role"] == role]

    # 限制返回数量
    users = users[:limit]

    logger.info(f"找到 {len(users)} 个用户")
    return {"users": users, "total": len(users)}

# ===== 场景6：模拟服务器错误（500） =====
@app.get("/error/server")
async def simulate_server_error():
    """
    模拟服务器内部错误
    错误场景：未捕获的异常 → 500
    """
    logger.error("模拟服务器错误")

    # 故意抛出一个未捕获的异常
    raise Exception("这是一个模拟的服务器错误")

@app.get("/error/division")
async def simulate_division_error(a: int, b: int):
    """
    模拟除零错误
    错误场景：除零 → 500
    """
    logger.info(f"计算 {a} / {b}")

    # 故意不检查 b 是否为 0
    result = a / b

    return {"result": result}

# ===== 场景7：详细的错误信息 =====
@app.get("/users/{user_id}/posts")
async def get_user_posts(user_id: int):
    """
    获取用户的文章列表
    错误场景：用户不存在 → 404（带详细信息）
    """
    logger.info(f"获取用户 {user_id} 的文章")

    # 检查用户是否存在
    user = users_db.get(user_id)
    if not user:
        logger.warning(f"用户 {user_id} 不存在")
        raise HTTPException(
            status_code=404,
            detail={
                "error": "用户不存在",
                "message": f"未找到 ID 为 {user_id} 的用户",
                "suggestion": "请检查用户 ID 是否正确",
                "available_users": list(users_db.keys())
            }
        )

    # 获取用户的文章
    user_posts = [p for p in posts_db.values() if p["author_id"] == user_id]

    logger.info(f"找到 {len(user_posts)} 篇文章")
    return {
        "user": user,
        "posts": user_posts,
        "total": len(user_posts)
    }

# ===== 健康检查端点 =====
@app.get("/health")
async def health_check():
    """健康检查端点（不会抛出异常）"""
    return {
        "status": "ok",
        "timestamp": datetime.utcnow().isoformat(),
        "users_count": len(users_db),
        "posts_count": len(posts_db)
    }

# ===== 根路径 =====
@app.get("/")
async def root():
    """API 根路径"""
    return {
        "message": "FastAPI 异常处理基础示例",
        "endpoints": {
            "users": "/users",
            "posts": "/posts",
            "admin": "/admin/users",
            "health": "/health"
        }
    }


if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("FastAPI 异常处理基础示例")
    print("=" * 50)
    print("\n启动服务器...")
    print("访问 http://localhost:8000/docs 查看 API 文档\n")

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 运行示例

### 1. 安装依赖

```bash
# 确保已安装 FastAPI 和 Uvicorn
uv add fastapi uvicorn[standard] pydantic[email]
```

---

### 2. 运行服务器

```bash
# 方式1：直接运行
python examples/fastapi_error_handling_basic.py

# 方式2：使用 uvicorn
uvicorn examples.fastapi_error_handling_basic:app --reload
```

---

### 3. 测试各种错误场景

#### 场景1：资源不存在（404）

```bash
# 存在的用户
curl http://localhost:8000/users/1
# 响应: {"id": 1, "name": "Alice", ...}

# 不存在的用户
curl http://localhost:8000/users/999
# 响应: {"detail": "用户 999 不存在"}
# 状态码: 404
```

---

#### 场景2：未授权（401）

```bash
# 未提供 Token
curl http://localhost:8000/admin/users
# 响应: {"detail": "未提供认证信息，请在 Header 中添加 Authorization"}
# 状态码: 401

# Token 格式错误
curl -H "Authorization: InvalidToken" http://localhost:8000/admin/users
# 响应: {"detail": "认证格式错误，应为 'Bearer <token>'"}
# 状态码: 401

# Token 无效
curl -H "Authorization: Bearer wrong-token" http://localhost:8000/admin/users
# 响应: {"detail": "Token 无效或已过期"}
# 状态码: 401

# 正确的 Token
curl -H "Authorization: Bearer secret-admin-token" http://localhost:8000/admin/users
# 响应: {"users": [...]}
# 状态码: 200
```

---

#### 场景3：权限不足（403）

```bash
# 管理员删除用户（成功）
curl -X DELETE \
  -H "Authorization: Bearer secret-admin-token" \
  http://localhost:8000/users/3
# 响应: {"message": "用户 Charlie 已删除"}
# 状态码: 200

# 普通用户删除用户（失败）
curl -X DELETE \
  -H "Authorization: Bearer secret-user-token" \
  http://localhost:8000/users/2
# 响应: {"detail": "权限不足，仅管理员可以删除用户"}
# 状态码: 403
```

---

#### 场景4：请求参数错误（400）

```bash
# 创建用户（邮箱已存在）
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Alice2",
    "email": "alice@example.com",
    "role": "user"
  }'
# 响应: {"detail": "邮箱 alice@example.com 已被注册"}
# 状态码: 400

# 创建用户（角色无效）
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "David",
    "email": "david@example.com",
    "role": "superuser"
  }'
# 响应: {"detail": [{"loc": ["body", "role"], "msg": "角色必须是 user 或 admin", ...}]}
# 状态码: 422（Pydantic 验证错误）

# 创建文章（作者不存在）
curl -X POST http://localhost:8000/posts \
  -H "Content-Type: application/json" \
  -d '{
    "title": "新文章标题",
    "author_id": 999,
    "content": "文章内容"
  }'
# 响应: {"detail": "作者 999 不存在"}
# 状态码: 400
```

---

#### 场景5：查询参数验证（400）

```bash
# 搜索用户（角色无效）
curl "http://localhost:8000/users?role=superuser"
# 响应: {"detail": "无效的角色参数: superuser，必须是 'user' 或 'admin'"}
# 状态码: 400

# 搜索用户（limit 超出范围）
curl "http://localhost:8000/users?limit=200"
# 响应: {"detail": [{"loc": ["query", "limit"], "msg": "ensure this value is less than or equal to 100", ...}]}
# 状态码: 422（FastAPI 验证错误）

# 搜索用户（正确）
curl "http://localhost:8000/users?role=admin&limit=10"
# 响应: {"users": [...], "total": 1}
# 状态码: 200
```

---

#### 场景6：服务器错误（500）

```bash
# 模拟服务器错误
curl http://localhost:8000/error/server
# 响应: {"detail": "Internal Server Error"}
# 状态码: 500

# 模拟除零错误
curl "http://localhost:8000/error/division?a=10&b=0"
# 响应: {"detail": "Internal Server Error"}
# 状态码: 500
```

---

#### 场景7：详细的错误信息

```bash
# 获取不存在用户的文章
curl http://localhost:8000/users/999/posts
# 响应:
# {
#   "detail": {
#     "error": "用户不存在",
#     "message": "未找到 ID 为 999 的用户",
#     "suggestion": "请检查用户 ID 是否正确",
#     "available_users": [1, 2, 3]
#   }
# }
# 状态码: 404
```

---

## 关键知识点

### 1. HTTPException 的基本用法

```python
raise HTTPException(
    status_code=404,  # HTTP 状态码
    detail="错误信息"  # 错误详情（可以是字符串或字典）
)
```

---

### 2. 添加自定义响应头

```python
raise HTTPException(
    status_code=401,
    detail="未授权",
    headers={"WWW-Authenticate": "Bearer"}  # 自定义响应头
)
```

---

### 3. 详细的错误信息

```python
raise HTTPException(
    status_code=404,
    detail={
        "error": "用户不存在",
        "message": "详细说明",
        "suggestion": "建议操作",
        "available_users": [1, 2, 3]
    }
)
```

---

### 4. 常用的 HTTP 状态码

| 状态码 | 使用场景 | 示例 |
|--------|----------|------|
| 400 | 请求参数错误 | 邮箱已存在、作者不存在 |
| 401 | 未认证 | 未提供 Token、Token 无效 |
| 403 | 权限不足 | 非管理员尝试删除用户 |
| 404 | 资源不存在 | 用户不存在、文章不存在 |
| 422 | 数据验证失败 | Pydantic 验证失败 |
| 500 | 服务器内部错误 | 未捕获的异常 |

---

### 5. Pydantic 自动验证

```python
class UserCreate(BaseModel):
    name: str
    email: EmailStr  # 自动验证邮箱格式
    role: str = "user"

    @validator('role')
    def validate_role(cls, v):
        if v not in ['user', 'admin']:
            raise ValueError('角色必须是 user 或 admin')
        return v
```

**验证失败会自动返回 422 错误：**
```json
{
  "detail": [
    {
      "loc": ["body", "role"],
      "msg": "角色必须是 user 或 admin",
      "type": "value_error"
    }
  ]
}
```

---

### 6. 日志记录

```python
import logging

logger = logging.getLogger(__name__)

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    logger.info(f"获取用户: {user_id}")  # 记录正常操作

    user = users_db.get(user_id)
    if not user:
        logger.warning(f"用户 {user_id} 不存在")  # 记录警告
        raise HTTPException(status_code=404, detail="用户不存在")

    logger.info(f"成功获取用户: {user['name']}")  # 记录成功
    return user
```

---

## 最佳实践

### 1. 使用明确的状态码

```python
# ✅ 好：状态码明确
raise HTTPException(status_code=404, detail="用户不存在")  # 资源不存在
raise HTTPException(status_code=401, detail="未授权")      # 未认证
raise HTTPException(status_code=403, detail="权限不足")    # 权限不足

# ❌ 差：都用 400
raise HTTPException(status_code=400, detail="用户不存在")  # 应该是 404
raise HTTPException(status_code=400, detail="未授权")      # 应该是 401
```

---

### 2. 提供有用的错误信息

```python
# ✅ 好：错误信息清晰
raise HTTPException(
    status_code=404,
    detail=f"用户 {user_id} 不存在，请检查用户 ID 是否正确"
)

# ❌ 差：错误信息模糊
raise HTTPException(status_code=404, detail="Not found")
```

---

### 3. 记录日志

```python
# ✅ 好：记录详细日志
logger.warning(f"用户 {user_id} 不存在")
raise HTTPException(status_code=404, detail="用户不存在")

# ❌ 差：不记录日志
raise HTTPException(status_code=404, detail="用户不存在")
```

---

### 4. 使用 Pydantic 验证

```python
# ✅ 好：用 Pydantic 自动验证
class UserCreate(BaseModel):
    name: str
    email: EmailStr
    role: str

    @validator('role')
    def validate_role(cls, v):
        if v not in ['user', 'admin']:
            raise ValueError('角色必须是 user 或 admin')
        return v

# ❌ 差：手动验证
@app.post("/users")
async def create_user(name: str, email: str, role: str):
    if role not in ['user', 'admin']:
        raise HTTPException(status_code=400, detail="角色无效")
    # ...
```

---

## 小结

本示例演示了 FastAPI 异常处理的基础用法：

1. **HTTPException**：快速抛出 HTTP 错误
2. **常见状态码**：400、401、403、404、500
3. **详细错误信息**：使用字典提供更多上下文
4. **日志记录**：记录所有错误和警告
5. **Pydantic 验证**：自动验证请求数据

**下一步：** 学习如何创建自定义异常类，实现更精细的错误处理。
