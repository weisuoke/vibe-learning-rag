# 最小可用

掌握以下内容，就能在 RAG 项目中实现混合检索：

---

## 4.1 快速搭建 BM25 检索

```python
"""
最小可用的 BM25 检索
依赖：pip install rank-bm25 jieba
"""
from rank_bm25 import BM25Okapi
import jieba

class SimpleBM25:
    def __init__(self, documents: list[str]):
        # 分词
        self.documents = documents
        self.tokenized_docs = [list(jieba.cut(doc)) for doc in documents]
        # 创建索引
        self.bm25 = BM25Okapi(self.tokenized_docs)

    def search(self, query: str, top_k: int = 5) -> list[tuple[str, float]]:
        """搜索并返回 (文档, 分数) 列表"""
        tokenized_query = list(jieba.cut(query))
        scores = self.bm25.get_scores(tokenized_query)

        # 排序
        doc_scores = list(zip(self.documents, scores))
        doc_scores.sort(key=lambda x: x[1], reverse=True)

        return doc_scores[:top_k]

# 使用示例
docs = [
    "Python 异步编程使用 asyncio",
    "JavaScript Promise 和 async/await",
    "Python 多线程编程指南",
]

bm25 = SimpleBM25(docs)
results = bm25.search("Python 异步", top_k=2)
for doc, score in results:
    print(f"{score:.2f}: {doc}")
```

---

## 4.2 快速搭建向量检索

```python
"""
最小可用的向量检索
依赖：pip install chromadb
"""
import chromadb

class SimpleVectorSearch:
    def __init__(self, collection_name: str = "docs"):
        self.client = chromadb.Client()
        self.collection = self.client.create_collection(collection_name)

    def add_documents(self, documents: list[str], ids: list[str] = None):
        """添加文档（自动生成 Embedding）"""
        if ids is None:
            ids = [f"doc_{i}" for i in range(len(documents))]
        self.collection.add(documents=documents, ids=ids)

    def search(self, query: str, top_k: int = 5) -> list[tuple[str, float]]:
        """搜索并返回 (文档, 距离) 列表"""
        results = self.collection.query(
            query_texts=[query],
            n_results=top_k
        )

        docs = results['documents'][0]
        distances = results['distances'][0]

        return list(zip(docs, distances))

# 使用示例
vector_search = SimpleVectorSearch()
vector_search.add_documents([
    "Python 异步编程使用 asyncio",
    "JavaScript Promise 和 async/await",
    "Python 多线程编程指南",
])

results = vector_search.search("如何写异步代码", top_k=2)
for doc, dist in results:
    print(f"{dist:.3f}: {doc}")
```

---

## 4.3 RRF 融合（最简实现）

```python
"""
最小可用的 RRF 融合
"""
def rrf_fusion(
    results_list: list[list[str]],
    k: int = 60
) -> list[str]:
    """
    倒数排名融合

    参数：
    - results_list: 多个检索结果列表，每个列表是文档ID的排序
    - k: 平滑参数

    返回：融合后的文档ID列表
    """
    scores = {}

    for results in results_list:
        for rank, doc_id in enumerate(results, 1):
            if doc_id not in scores:
                scores[doc_id] = 0
            scores[doc_id] += 1 / (k + rank)

    # 按分数排序，返回文档ID
    sorted_docs = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    return [doc_id for doc_id, _ in sorted_docs]

# 使用示例
bm25_results = ["doc1", "doc3", "doc2"]
vector_results = ["doc2", "doc1", "doc4"]

fused = rrf_fusion([bm25_results, vector_results])
print(fused)  # ['doc1', 'doc2', 'doc3', 'doc4']
```

---

## 4.4 完整的混合检索类

```python
"""
最小可用的混合检索
整合 BM25 + 向量检索 + RRF 融合
"""
from rank_bm25 import BM25Okapi
import chromadb
import jieba

class HybridSearch:
    def __init__(self, documents: list[str]):
        self.documents = documents
        self.doc_ids = [f"doc_{i}" for i in range(len(documents))]

        # 初始化 BM25
        tokenized = [list(jieba.cut(doc)) for doc in documents]
        self.bm25 = BM25Okapi(tokenized)

        # 初始化向量检索
        self.chroma = chromadb.Client()
        self.collection = self.chroma.create_collection("hybrid")
        self.collection.add(documents=documents, ids=self.doc_ids)

    def search(self, query: str, top_k: int = 5) -> list[str]:
        """混合检索"""
        # BM25 检索
        tokenized_query = list(jieba.cut(query))
        bm25_scores = self.bm25.get_scores(tokenized_query)
        bm25_ranking = sorted(
            range(len(bm25_scores)),
            key=lambda i: bm25_scores[i],
            reverse=True
        )
        bm25_results = [self.doc_ids[i] for i in bm25_ranking[:top_k*2]]

        # 向量检索
        vector_results = self.collection.query(
            query_texts=[query],
            n_results=top_k*2
        )
        vector_doc_ids = vector_results['ids'][0]

        # RRF 融合
        fused_ids = self._rrf_fusion([bm25_results, vector_doc_ids])

        # 返回文档内容
        id_to_doc = dict(zip(self.doc_ids, self.documents))
        return [id_to_doc[doc_id] for doc_id in fused_ids[:top_k]]

    def _rrf_fusion(self, results_list: list[list[str]], k: int = 60) -> list[str]:
        scores = {}
        for results in results_list:
            for rank, doc_id in enumerate(results, 1):
                scores[doc_id] = scores.get(doc_id, 0) + 1 / (k + rank)
        return [doc_id for doc_id, _ in sorted(scores.items(), key=lambda x: x[1], reverse=True)]

# 使用示例
documents = [
    "Python asyncio 异步编程入门教程",
    "JavaScript 的 Promise 和 async/await 详解",
    "Python 多线程与多进程的区别",
    "如何优化 Python 代码的执行速度",
    "异步 IO 模型的原理和实现",
]

hybrid = HybridSearch(documents)

# 测试不同类型的查询
print("=== 精确术语查询 ===")
results = hybrid.search("Python asyncio", top_k=3)
for r in results:
    print(f"  - {r}")

print("\n=== 语义查询 ===")
results = hybrid.search("怎么让代码跑得更快", top_k=3)
for r in results:
    print(f"  - {r}")
```

---

## 4.5 使用 LangChain 的混合检索

```python
"""
使用 LangChain 实现混合检索（更简洁）
依赖：pip install langchain langchain-community chromadb rank-bm25
"""
from langchain_community.retrievers import BM25Retriever
from langchain_community.vectorstores import Chroma
from langchain.retrievers import EnsembleRetriever
from langchain_openai import OpenAIEmbeddings

# 准备文档
documents = [
    "Python asyncio 异步编程入门教程",
    "JavaScript 的 Promise 和 async/await 详解",
    "Python 多线程与多进程的区别",
    "如何优化 Python 代码的执行速度",
]

# 创建 BM25 检索器
bm25_retriever = BM25Retriever.from_texts(documents)
bm25_retriever.k = 4

# 创建向量检索器
vectorstore = Chroma.from_texts(documents, OpenAIEmbeddings())
vector_retriever = vectorstore.as_retriever(search_kwargs={"k": 4})

# 创建混合检索器（EnsembleRetriever 内部使用 RRF）
hybrid_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_retriever],
    weights=[0.5, 0.5]  # 权重
)

# 使用
results = hybrid_retriever.invoke("Python 异步编程")
for doc in results:
    print(doc.page_content)
```

---

## 这些知识足以：

- ✅ 在 RAG 项目中实现混合检索
- ✅ 理解 BM25 和向量检索的互补性
- ✅ 使用 RRF 融合多个检索结果
- ✅ 使用 LangChain 快速搭建混合检索
- ✅ 为后续学习 ReRank 打下基础

---

## 快速参考卡

| 任务 | 代码 |
|------|------|
| BM25 检索 | `BM25Okapi(tokenized_docs).get_scores(query)` |
| 向量检索 | `collection.query(query_texts=[query])` |
| RRF 融合 | `score += 1 / (k + rank)` |
| LangChain 混合 | `EnsembleRetriever(retrievers=[...])` |

---

**下一步：** [05_双重类比](./05_双重类比.md) - 用前端和日常生活类比理解混合检索
