# 核心概念 3：自定义中间件开发

本文详细讲解如何开发自定义中间件，包括装饰器方式和类方式，以及常见的中间件模式。

---

## 1. 自定义中间件的两种方式

### 1.1 装饰器方式（简单场景）

使用 `@app.middleware("http")` 装饰器定义中间件函数。

**适用场景：**
- 简单的中间件逻辑
- 不需要初始化参数
- 不需要维护状态

**基本结构：**

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def my_middleware(request: Request, call_next):
    # 请求前处理
    print("Before request")

    # 调用下一个中间件或路由
    response = await call_next(request)

    # 响应后处理
    print("After request")

    return response
```

### 1.2 类方式（复杂场景）

继承 `BaseHTTPMiddleware` 类，实现 `dispatch` 方法。

**适用场景：**
- 需要初始化参数
- 需要维护状态
- 复杂的中间件逻辑

**基本结构：**

```python
from fastapi import FastAPI, Request
from starlette.middleware.base import BaseHTTPMiddleware

app = FastAPI()

class MyMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, custom_param: str):
        super().__init__(app)
        self.custom_param = custom_param

    async def dispatch(self, request: Request, call_next):
        # 请求前处理
        print(f"Custom param: {self.custom_param}")

        # 调用下一个中间件或路由
        response = await call_next(request)

        # 响应后处理
        print("After request")

        return response

# 注册中间件
app.add_middleware(MyMiddleware, custom_param="value")
```

---

## 2. 装饰器方式详解

### 2.1 基本示例

```python
from fastapi import FastAPI, Request
import time

app = FastAPI()

@app.middleware("http")
async def timing_middleware(request: Request, call_next):
    # 记录开始时间
    start_time = time.time()

    # 调用下一个中间件或路由
    response = await call_next(request)

    # 计算耗时
    duration = time.time() - start_time

    # 添加响应头
    response.headers["X-Process-Time"] = f"{duration:.3f}"

    return response

@app.get("/test")
async def test():
    return {"message": "ok"}

# 访问 /test，响应头会包含 X-Process-Time
```

### 2.2 访问请求信息

```python
@app.middleware("http")
async def inspect_request(request: Request, call_next):
    # 请求方法
    print(f"Method: {request.method}")

    # 请求路径
    print(f"Path: {request.url.path}")

    # 查询参数
    print(f"Query params: {dict(request.query_params)}")

    # 请求头
    print(f"Headers: {dict(request.headers)}")

    # 客户端信息
    print(f"Client: {request.client.host}:{request.client.port}")

    response = await call_next(request)
    return response
```

### 2.3 修改响应

```python
from fastapi.responses import JSONResponse

@app.middleware("http")
async def modify_response(request: Request, call_next):
    response = await call_next(request)

    # 添加响应头
    response.headers["X-Custom-Header"] = "MyValue"
    response.headers["X-Server"] = "FastAPI"

    # 修改状态码（不推荐）
    # response.status_code = 201

    return response
```

### 2.4 提前返回

```python
@app.middleware("http")
async def maintenance_mode(request: Request, call_next):
    # 检查维护模式
    if os.getenv("MAINTENANCE_MODE") == "true":
        # 提前返回，不调用 call_next
        return JSONResponse(
            {"error": "Service under maintenance"},
            status_code=503
        )

    # 正常处理
    response = await call_next(request)
    return response
```

### 2.5 异常处理

```python
@app.middleware("http")
async def error_handler(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except Exception as e:
        # 捕获异常，返回友好错误
        print(f"Error: {e}")
        return JSONResponse(
            {"error": "Internal server error"},
            status_code=500
        )
```

---

## 3. 类方式详解

### 3.1 基本示例

```python
from starlette.middleware.base import BaseHTTPMiddleware

class TimingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        duration = time.time() - start_time
        response.headers["X-Process-Time"] = f"{duration:.3f}"
        return response

# 注册
app.add_middleware(TimingMiddleware)
```

### 3.2 带初始化参数

```python
class LoggingMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, log_level: str = "INFO"):
        super().__init__(app)
        self.log_level = log_level

    async def dispatch(self, request: Request, call_next):
        if self.log_level == "DEBUG":
            print(f"[DEBUG] {request.method} {request.url.path}")
        elif self.log_level == "INFO":
            print(f"[INFO] {request.method} {request.url.path}")

        response = await call_next(request)
        return response

# 注册时传递参数
app.add_middleware(LoggingMiddleware, log_level="DEBUG")
```

### 3.3 维护状态

```python
class RequestCounterMiddleware(BaseHTTPMiddleware):
    def __init__(self, app):
        super().__init__(app)
        self.request_count = 0  # 实例变量

    async def dispatch(self, request: Request, call_next):
        self.request_count += 1
        print(f"Total requests: {self.request_count}")

        response = await call_next(request)
        response.headers["X-Request-Count"] = str(self.request_count)

        return response

app.add_middleware(RequestCounterMiddleware)
```

### 3.4 复杂逻辑

```python
class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, max_requests: int = 10, window: int = 60):
        super().__init__(app)
        self.max_requests = max_requests
        self.window = window
        self.requests = {}  # {client_ip: [timestamps]}

    async def dispatch(self, request: Request, call_next):
        client_ip = request.client.host
        now = time.time()

        # 初始化客户端记录
        if client_ip not in self.requests:
            self.requests[client_ip] = []

        # 清理过期记录
        self.requests[client_ip] = [
            t for t in self.requests[client_ip]
            if now - t < self.window
        ]

        # 检查限流
        if len(self.requests[client_ip]) >= self.max_requests:
            return JSONResponse(
                {"error": f"Rate limit exceeded. Max {self.max_requests} requests per {self.window} seconds."},
                status_code=429
            )

        # 记录本次请求
        self.requests[client_ip].append(now)

        response = await call_next(request)
        response.headers["X-Rate-Limit-Remaining"] = str(
            self.max_requests - len(self.requests[client_ip])
        )

        return response

# 注册时配置参数
app.add_middleware(RateLimitMiddleware, max_requests=10, window=60)
```

---

## 4. 常见中间件模式

### 4.1 请求日志中间件

```python
import time
from datetime import datetime

@app.middleware("http")
async def log_requests(request: Request, call_next):
    # 生成请求 ID
    request_id = str(uuid.uuid4())
    request.state.request_id = request_id

    # 记录请求开始
    start_time = time.time()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    print(f"[{timestamp}] [{request_id}] → {request.method} {request.url.path}")

    # 处理请求
    response = await call_next(request)

    # 记录请求结束
    duration = time.time() - start_time
    print(f"[{timestamp}] [{request_id}] ← {response.status_code} ({duration:.3f}s)")

    # 添加请求 ID 到响应头
    response.headers["X-Request-ID"] = request_id

    return response
```

### 4.2 认证中间件

```python
import jwt
from fastapi.responses import JSONResponse

SECRET_KEY = "your-secret-key"

@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 公开路径不需要认证
    public_paths = ["/", "/docs", "/openapi.json", "/login", "/register"]
    if request.url.path in public_paths:
        return await call_next(request)

    # 获取 token
    authorization = request.headers.get("authorization", "")
    if not authorization.startswith("Bearer "):
        return JSONResponse(
            {"error": "Missing or invalid authorization header"},
            status_code=401
        )

    token = authorization.replace("Bearer ", "")

    # 验证 token
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        request.state.user_id = payload["user_id"]
        request.state.user_email = payload["email"]
    except jwt.ExpiredSignatureError:
        return JSONResponse(
            {"error": "Token expired"},
            status_code=401
        )
    except jwt.InvalidTokenError:
        return JSONResponse(
            {"error": "Invalid token"},
            status_code=401
        )

    # 继续处理
    response = await call_next(request)
    return response
```

### 4.3 限流中间件

```python
import time
from collections import defaultdict

class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, max_requests: int = 10, window: int = 60):
        super().__init__(app)
        self.max_requests = max_requests
        self.window = window
        self.requests = defaultdict(list)

    async def dispatch(self, request: Request, call_next):
        # 获取客户端标识（IP 或用户 ID）
        client_id = request.client.host
        if hasattr(request.state, "user_id"):
            client_id = request.state.user_id

        now = time.time()

        # 清理过期记录
        self.requests[client_id] = [
            t for t in self.requests[client_id]
            if now - t < self.window
        ]

        # 检查限流
        if len(self.requests[client_id]) >= self.max_requests:
            retry_after = int(self.window - (now - self.requests[client_id][0]))
            return JSONResponse(
                {
                    "error": "Rate limit exceeded",
                    "retry_after": retry_after
                },
                status_code=429,
                headers={"Retry-After": str(retry_after)}
            )

        # 记录本次请求
        self.requests[client_id].append(now)

        # 处理请求
        response = await call_next(request)

        # 添加限流信息到响应头
        response.headers["X-Rate-Limit-Limit"] = str(self.max_requests)
        response.headers["X-Rate-Limit-Remaining"] = str(
            self.max_requests - len(self.requests[client_id])
        )
        response.headers["X-Rate-Limit-Reset"] = str(
            int(self.requests[client_id][0] + self.window)
        )

        return response
```

### 4.4 错误处理中间件

```python
import traceback

@app.middleware("http")
async def error_handler_middleware(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except HTTPException as e:
        # FastAPI 的 HTTPException
        return JSONResponse(
            {"error": e.detail},
            status_code=e.status_code
        )
    except ValueError as e:
        # 值错误
        return JSONResponse(
            {"error": f"Invalid value: {str(e)}"},
            status_code=400
        )
    except Exception as e:
        # 其他异常
        print(f"Unexpected error: {e}")
        print(traceback.format_exc())

        return JSONResponse(
            {"error": "Internal server error"},
            status_code=500
        )
```

### 4.5 CORS 中间件（手写版）

```python
@app.middleware("http")
async def cors_middleware(request: Request, call_next):
    # 允许的源
    allowed_origins = ["http://localhost:3000", "https://example.com"]

    origin = request.headers.get("origin")

    # 处理 OPTIONS 预检请求
    if request.method == "OPTIONS":
        response = Response()
        if origin in allowed_origins:
            response.headers["Access-Control-Allow-Origin"] = origin
            response.headers["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS"
            response.headers["Access-Control-Allow-Headers"] = "Content-Type, Authorization"
            response.headers["Access-Control-Max-Age"] = "600"
        return response

    # 处理实际请求
    response = await call_next(request)

    # 添加 CORS 头
    if origin in allowed_origins:
        response.headers["Access-Control-Allow-Origin"] = origin
        response.headers["Access-Control-Allow-Credentials"] = "true"

    return response
```

---

## 5. 中间件开发最佳实践

### 5.1 性能优化

**原则1：避免阻塞操作**

```python
# ❌ 错误：同步 I/O 操作
@app.middleware("http")
async def bad_middleware(request: Request, call_next):
    # 同步数据库查询（阻塞）
    user = db.query(User).filter(User.id == 1).first()

    response = await call_next(request)
    return response

# ✅ 正确：异步 I/O 操作
@app.middleware("http")
async def good_middleware(request: Request, call_next):
    # 异步数据库查询（不阻塞）
    async with async_session() as session:
        result = await session.execute(select(User).filter(User.id == 1))
        user = result.scalar_one_or_none()

    response = await call_next(request)
    return response
```

**原则2：避免重复计算**

```python
# ❌ 错误：每次请求都重新计算
@app.middleware("http")
async def bad_middleware(request: Request, call_next):
    # 每次都重新编译正则表达式
    import re
    pattern = re.compile(r"^/api/")
    if pattern.match(request.url.path):
        # ...

    response = await call_next(request)
    return response

# ✅ 正确：预先计算
import re

# 在模块级别编译正则表达式
API_PATH_PATTERN = re.compile(r"^/api/")

@app.middleware("http")
async def good_middleware(request: Request, call_next):
    if API_PATH_PATTERN.match(request.url.path):
        # ...

    response = await call_next(request)
    return response
```

### 5.2 错误处理

**原则1：捕获异常，避免中断**

```python
@app.middleware("http")
async def safe_middleware(request: Request, call_next):
    try:
        # 可能出错的操作
        request.state.user_id = get_user_id_from_token(request)
    except Exception as e:
        # 记录错误，但不中断请求
        print(f"Error in middleware: {e}")
        request.state.user_id = None

    response = await call_next(request)
    return response
```

**原则2：提供友好的错误信息**

```python
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    token = request.headers.get("authorization")

    if not token:
        return JSONResponse(
            {
                "error": "Missing authorization header",
                "message": "Please provide a valid JWT token in the Authorization header",
                "example": "Authorization: Bearer <your-token>"
            },
            status_code=401
        )

    response = await call_next(request)
    return response
```

### 5.3 可配置性

**原则1：使用环境变量**

```python
import os

class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app):
        super().__init__(app)
        # 从环境变量读取配置
        self.max_requests = int(os.getenv("RATE_LIMIT_MAX_REQUESTS", "10"))
        self.window = int(os.getenv("RATE_LIMIT_WINDOW", "60"))
        self.requests = defaultdict(list)

    async def dispatch(self, request: Request, call_next):
        # ...
```

**原则2：使用配置类**

```python
from pydantic import BaseSettings

class MiddlewareSettings(BaseSettings):
    rate_limit_max_requests: int = 10
    rate_limit_window: int = 60
    log_level: str = "INFO"

    class Config:
        env_file = ".env"

settings = MiddlewareSettings()

class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app):
        super().__init__(app)
        self.max_requests = settings.rate_limit_max_requests
        self.window = settings.rate_limit_window
        self.requests = defaultdict(list)

    async def dispatch(self, request: Request, call_next):
        # ...
```

### 5.4 测试友好

**原则1：提供测试模式**

```python
class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, enabled: bool = True):
        super().__init__(app)
        self.enabled = enabled
        self.max_requests = 10
        self.window = 60
        self.requests = defaultdict(list)

    async def dispatch(self, request: Request, call_next):
        # 测试模式下跳过限流
        if not self.enabled:
            return await call_next(request)

        # 正常限流逻辑
        # ...

# 生产环境
app.add_middleware(RateLimitMiddleware, enabled=True)

# 测试环境
app.add_middleware(RateLimitMiddleware, enabled=False)
```

**原则2：使用依赖注入**

```python
# 将中间件逻辑提取为函数，方便测试
def check_rate_limit(client_id: str, requests: dict, max_requests: int, window: int) -> bool:
    now = time.time()

    # 清理过期记录
    requests[client_id] = [
        t for t in requests[client_id]
        if now - t < window
    ]

    # 检查限流
    if len(requests[client_id]) >= max_requests:
        return False

    # 记录本次请求
    requests[client_id].append(now)
    return True

class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app):
        super().__init__(app)
        self.max_requests = 10
        self.window = 60
        self.requests = defaultdict(list)

    async def dispatch(self, request: Request, call_next):
        client_id = request.client.host

        # 调用可测试的函数
        if not check_rate_limit(client_id, self.requests, self.max_requests, self.window):
            return JSONResponse({"error": "Rate limit exceeded"}, status_code=429)

        response = await call_next(request)
        return response

# 测试
def test_check_rate_limit():
    requests = defaultdict(list)
    assert check_rate_limit("client1", requests, 10, 60) == True
    # ...
```

---

## 6. 在 AI Agent 后端中的应用

### 6.1 完整的中间件栈

```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import time
import uuid
from collections import defaultdict

app = FastAPI()

# 1. CORS 中间件（内置）
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 2. 请求日志中间件
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    request_id = str(uuid.uuid4())
    request.state.request_id = request_id

    start_time = time.time()
    print(f"[{request_id}] → {request.method} {request.url.path}")

    response = await call_next(request)

    duration = time.time() - start_time
    print(f"[{request_id}] ← {response.status_code} ({duration:.3f}s)")

    response.headers["X-Request-ID"] = request_id
    return response

# 3. 认证中间件
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    public_paths = ["/", "/docs", "/openapi.json", "/login"]
    if request.url.path in public_paths:
        return await call_next(request)

    token = request.headers.get("authorization", "").replace("Bearer ", "")
    if not token:
        return JSONResponse({"error": "Unauthorized"}, status_code=401)

    # 验证 token（简化版）
    request.state.user_id = "user_123"

    response = await call_next(request)
    return response

# 4. 限流中间件（类方式）
class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app):
        super().__init__(app)
        self.max_requests = 10
        self.window = 60
        self.requests = defaultdict(list)

    async def dispatch(self, request: Request, call_next):
        user_id = getattr(request.state, "user_id", None)
        if not user_id:
            return await call_next(request)

        now = time.time()

        # 清理过期记录
        self.requests[user_id] = [
            t for t in self.requests[user_id]
            if now - t < self.window
        ]

        # 检查限流
        if len(self.requests[user_id]) >= self.max_requests:
            return JSONResponse(
                {"error": "Rate limit exceeded"},
                status_code=429
            )

        # 记录本次请求
        self.requests[user_id].append(now)

        response = await call_next(request)
        response.headers["X-Rate-Limit-Remaining"] = str(
            self.max_requests - len(self.requests[user_id])
        )

        return response

app.add_middleware(RateLimitMiddleware)

# 5. 错误处理中间件
@app.middleware("http")
async def error_handler_middleware(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except Exception as e:
        print(f"Error: {e}")
        return JSONResponse(
            {"error": "Internal server error"},
            status_code=500
        )

# 业务路由
@app.post("/api/agent/chat")
async def chat(request: Request, message: str):
    user_id = request.state.user_id
    request_id = request.state.request_id

    # 调用 LLM API
    response = f"Echo: {message}"

    return {
        "request_id": request_id,
        "user_id": user_id,
        "response": response
    }
```

### 6.2 中间件的执行顺序

```
请求流程：
客户端
  ↓
CORS 中间件（处理跨域）
  ↓
日志中间件（记录请求）
  ↓
认证中间件（验证 token）
  ↓
限流中间件（检查限流）
  ↓
错误处理中间件（捕获异常）
  ↓
路由处理（业务逻辑）
  ↓
错误处理中间件（返回）
  ↓
限流中间件（添加限流信息）
  ↓
认证中间件（返回）
  ↓
日志中间件（记录响应）
  ↓
CORS 中间件（添加 CORS 头）
  ↓
客户端
```

---

## 总结

**自定义中间件开发的核心要点：**

1. **两种方式**：装饰器（简单）vs 类（复杂）
2. **常见模式**：日志、认证、限流、错误处理、CORS
3. **最佳实践**：性能优化、错误处理、可配置性、测试友好
4. **AI Agent 应用**：完整的中间件栈保护 LLM API

**选择原则：**
- 简单逻辑 → 装饰器方式
- 需要参数或状态 → 类方式
- 需要复杂配置 → 类方式 + 配置类

**下一步学习：**
- 实战代码：各种场景的中间件实现
- 生产环境优化：性能、安全、监控
