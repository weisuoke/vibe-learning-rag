# å®æˆ˜ä»£ç 5ï¼šç¼“å­˜å¤±æ•ˆç­–ç•¥

## å®Œæ•´å¯è¿è¡Œç¤ºä¾‹

```python
"""
ç¼“å­˜å¤±æ•ˆç­–ç•¥å®æˆ˜
æ¼”ç¤ºï¼šTTLã€ä¸»åŠ¨å¤±æ•ˆã€å¤šå±‚é˜²æŠ¤
"""

import redis
import asyncio
import random
import time
from typing import Optional

redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

# ===== 1. TTLç­–ç•¥ =====
print("=== TTLç­–ç•¥ ===\n")

# åŠ¨æ€TTL
def set_with_dynamic_ttl(key: str, value: str, base_ttl: int, access_count: int):
    """æ ¹æ®è®¿é—®é¢‘ç‡åŠ¨æ€è°ƒæ•´TTL"""
    if access_count > 100:
        ttl = base_ttl * 2
    elif access_count > 50:
        ttl = base_ttl * 1.5
    else:
        ttl = base_ttl

    redis_client.setex(key, int(ttl), value)
    print(f"è®¾ç½®ç¼“å­˜ï¼Œè®¿é—®æ¬¡æ•°={access_count}, TTL={int(ttl)}ç§’")

# æµ‹è¯•
set_with_dynamic_ttl("key1", "value1", 3600, 10)   # ä½é¢‘
set_with_dynamic_ttl("key2", "value2", 3600, 60)   # ä¸­é¢‘
set_with_dynamic_ttl("key3", "value3", 3600, 150)  # é«˜é¢‘

# éšæœºTTLé˜²é›ªå´©
def set_with_random_ttl(key: str, value: str, base_ttl: int):
    """éšæœºTTLé˜²æ­¢ç¼“å­˜é›ªå´©"""
    random_ttl = base_ttl + random.randint(-base_ttl//10, base_ttl//10)
    redis_client.setex(key, random_ttl, value)
    print(f"è®¾ç½®ç¼“å­˜ï¼ŒåŸºç¡€TTL={base_ttl}, å®é™…TTL={random_ttl}ç§’")

# æµ‹è¯•
for i in range(5):
    set_with_random_ttl(f"item:{i}", f"value{i}", 3600)

# ===== 2. ä¸»åŠ¨å¤±æ•ˆ =====
print("\n=== ä¸»åŠ¨å¤±æ•ˆ ===\n")

class CacheInvalidator:
    """ç¼“å­˜å¤±æ•ˆç®¡ç†å™¨"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    def invalidate_by_pattern(self, pattern: str):
        """æŒ‰æ¨¡å¼å¤±æ•ˆ"""
        keys = self.redis.keys(pattern)
        if keys:
            self.redis.delete(*keys)
            print(f"âœ… åˆ é™¤{len(keys)}ä¸ªç¼“å­˜")

    def invalidate_by_tag(self, tag: str):
        """æŒ‰æ ‡ç­¾å¤±æ•ˆ"""
        cache_keys = self.redis.smembers(f"tag:{tag}")
        if cache_keys:
            self.redis.delete(*cache_keys)
            self.redis.delete(f"tag:{tag}")
            print(f"âœ… åˆ é™¤æ ‡ç­¾'{tag}'ä¸‹çš„{len(cache_keys)}ä¸ªç¼“å­˜")

# æµ‹è¯•
invalidator = CacheInvalidator(redis_client)
invalidator.invalidate_by_pattern("item:*")

# ===== 3. ç¼“å­˜ç©¿é€é˜²æŠ¤ =====
print("\n=== ç¼“å­˜ç©¿é€é˜²æŠ¤ ===\n")

# ç©ºå€¼ç¼“å­˜
async def get_with_null_cache(key: str, fetch_func) -> Optional[str]:
    """ç©ºå€¼ç¼“å­˜é˜²ç©¿é€"""
    cached = redis_client.get(key)

    if cached == "NULL":
        print("ğŸ›¡ï¸ ç©ºå€¼ç¼“å­˜æ‹¦æˆª")
        return None
    if cached:
        print("âœ… ç¼“å­˜å‘½ä¸­")
        return cached

    # æŸ¥è¯¢æ•°æ®
    data = await fetch_func()

    if data:
        redis_client.setex(key, 3600, data)
    else:
        redis_client.setex(key, 60, "NULL")  # ç©ºå€¼ç¼“å­˜60ç§’
        print("ğŸ’¾ è®¾ç½®ç©ºå€¼ç¼“å­˜")

    return data

# ===== 4. ç¼“å­˜å‡»ç©¿é˜²æŠ¤ =====
print("\n=== ç¼“å­˜å‡»ç©¿é˜²æŠ¤ ===\n")

locks = {}

async def get_with_mutex(key: str, fetch_func):
    """äº’æ–¥é”é˜²å‡»ç©¿"""
    cached = redis_client.get(key)
    if cached:
        return cached

    if key not in locks:
        locks[key] = asyncio.Lock()

    async with locks[key]:
        # åŒé‡æ£€æŸ¥
        cached = redis_client.get(key)
        if cached:
            return cached

        print("ğŸ”’ è·å–é”ï¼ŒæŸ¥è¯¢æ•°æ®")
        data = await fetch_func()
        redis_client.setex(key, 3600, data)
        return data

# ===== 5. å¤šå±‚é˜²æŠ¤ =====
print("\n=== å¤šå±‚é˜²æŠ¤ ===\n")

class CacheProtection:
    """å¤šå±‚ç¼“å­˜é˜²æŠ¤"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.locks = {}

    async def get_protected(
        self,
        key: str,
        fetch_func,
        ttl: int = 3600
    ):
        """å¤šå±‚é˜²æŠ¤è·å–"""
        # 1. æŸ¥è¯¢ç¼“å­˜
        cached = self.redis.get(key)
        if cached == "NULL":
            return None
        if cached:
            return cached

        # 2. äº’æ–¥é”
        if key not in self.locks:
            self.locks[key] = asyncio.Lock()

        async with self.locks[key]:
            cached = self.redis.get(key)
            if cached:
                return cached if cached != "NULL" else None

            # 3. æŸ¥è¯¢æ•°æ®
            data = await fetch_func()

            # 4. éšæœºTTL + ç©ºå€¼ç¼“å­˜
            if data:
                random_ttl = ttl + random.randint(-ttl//10, ttl//10)
                self.redis.setex(key, random_ttl, data)
            else:
                self.redis.setex(key, 60, "NULL")

            return data

# æµ‹è¯•
protection = CacheProtection(redis_client)

async def test_protection():
    async def fetch_data():
        await asyncio.sleep(0.1)
        return "data"

    result = await protection.get_protected("test_key", fetch_data)
    print(f"ç»“æœ: {result}")

asyncio.run(test_protection())

# ===== 6. æ¸…ç† =====
print("\n=== æ¸…ç†æµ‹è¯•æ•°æ® ===")
redis_client.flushdb()
print("âœ… å·²æ¸…ç†æ‰€æœ‰æµ‹è¯•æ•°æ®")
```

## å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] å®ç°åŠ¨æ€TTLç­–ç•¥
- [ ] å®ç°éšæœºTTLé˜²é›ªå´©
- [ ] å®ç°ä¸»åŠ¨å¤±æ•ˆï¼ˆæŒ‰æ¨¡å¼ã€æŒ‰æ ‡ç­¾ï¼‰
- [ ] å®ç°ç©ºå€¼ç¼“å­˜é˜²ç©¿é€
- [ ] å®ç°äº’æ–¥é”é˜²å‡»ç©¿
- [ ] å®ç°å¤šå±‚é˜²æŠ¤ç­–ç•¥
