# 第一性原理

## 从根本问题出发

### 问题 1：为什么需要 Skills 技能包系统？

**根本问题：** AI Agent 能力的模块化和复用问题。

在 AI Agent 开发中，我们会遇到以下场景：

1. **重复编写相似的提示词**
   ```typescript
   // 场景 1：代码审查（项目 A）
   const prompt1 = `You are an expert code reviewer. Analyze this code for:
   1. Bugs and logic errors
   2. Security vulnerabilities
   3. Performance issues
   4. Code style problems`;

   // 场景 2：代码审查（项目 B）
   const prompt2 = `You are an expert code reviewer. Analyze this code for:
   1. Bugs and logic errors
   2. Security vulnerabilities
   3. Performance issues
   4. Code style problems`;

   // 场景 3：代码审查（项目 C）
   const prompt3 = `You are an expert code reviewer...`;
   ```

   **问题：**
   - 每个项目都要重新编写
   - 容易出现不一致
   - 改进无法同步到所有项目
   - 最佳实践难以传播

2. **Agent 能力难以组织和管理**
   ```typescript
   // 所有能力混在一起
   const systemPrompt = `
   You are an AI assistant that can:
   - Review code for quality and security
   - Generate unit tests
   - Debug issues
   - Refactor code
   - Write documentation
   - Analyze performance
   - ...（100+ 行提示词）
   `;

   // 问题：
   // - 提示词过长，超过 context window
   // - 能力混杂，难以维护
   // - 无法按需加载
   // - 无法独立测试
   ```

3. **团队协作的挑战**
   ```typescript
   // 开发者 A 的代码审查提示词
   const promptA = `Focus on security and performance`;

   // 开发者 B 的代码审查提示词
   const promptB = `Focus on code style and maintainability`;

   // 开发者 C 的代码审查提示词
   const promptC = `Focus on test coverage and documentation`;

   // 问题：
   // - 每个人都有自己的版本
   // - 无法统一标准
   // - 新人不知道用哪个
   // - 最佳实践无法积累
   ```

4. **能力复用的困难**
   ```typescript
   // 想在多个 Agent 中复用代码审查能力
   const agent1 = new Agent({
     systemPrompt: `${codeReviewPrompt}\n${otherCapabilities}`
   });

   const agent2 = new Agent({
     systemPrompt: `${codeReviewPrompt}\n${differentCapabilities}`
   });

   // 问题：
   // - 需要手动复制粘贴
   // - 更新时需要同步多处
   // - 容易出现版本不一致
   ```

**第一性原理推导：**

从这些问题出发，我们需要一个系统来：
1. **模块化封装** - 将 Agent 能力封装为独立单元
2. **标准化格式** - 统一能力的定义和调用方式
3. **易于复用** - 一次编写，多处使用
4. **版本控制** - 追踪历史和管理更新
5. **团队协作** - 共享最佳实践

这就是 Skills 技能包系统存在的根本原因。

---

### 问题 2：为什么选择 SKILL.md 文件格式？

**根本问题：** 如何以最简单的方式定义和存储 Agent 能力？

**选项分析：**

1. **TypeScript/JavaScript 代码**
   ```typescript
   export const codeReviewSkill = {
     name: 'code-review',
     description: 'Review code for quality',
     execute: async (code: string) => {
       // 实现逻辑
     }
   };
   ```
   - ✅ 类型安全
   - ✅ 可以包含逻辑
   - ❌ 需要编译
   - ❌ 不易于非开发者编辑
   - ❌ 与 LLM 的提示词本质不符

2. **JSON 配置文件**
   ```json
   {
     "name": "code-review",
     "description": "Review code",
     "prompt": "You are an expert code reviewer..."
   }
   ```
   - ✅ 结构化
   - ✅ 易于解析
   - ❌ 不适合长文本（需要转义）
   - ❌ 不支持富文本格式
   - ❌ 不易于人类阅读和编辑

3. **YAML 文件**
   ```yaml
   name: code-review
   description: Review code
   prompt: |
     You are an expert code reviewer.
     Check for bugs, security issues, and performance problems.
   ```
   - ✅ 结构化
   - ✅ 支持多行文本
   - ❌ 缩进敏感，容易出错
   - ❌ 不支持富文本格式（代码块、列表等）

4. **Markdown + YAML frontmatter**
   ```markdown
   ---
   name: code-review
   description: Review code for quality and security
   ---

   You are an expert code reviewer with 10+ years of experience.

   ## Review Checklist

   1. **Security**
      - SQL injection
      - XSS vulnerabilities
      - Authentication issues

   2. **Performance**
      - Algorithm complexity
      - Database queries
      - Memory leaks

   ```typescript
   // Example of good code
   function validateInput(input: string): boolean {
     return /^[a-zA-Z0-9]+$/.test(input);
   }
   ```
   ```
   - ✅ 结构化（YAML frontmatter）
   - ✅ 支持富文本（Markdown）
   - ✅ 易于阅读和编辑
   - ✅ 支持代码块、列表、表格等
   - ✅ 开发者熟悉（Git commit、Jekyll、Hugo）
   - ✅ 版本控制友好（纯文本，Git diff 清晰）

**第一性原理推导：**

Markdown + YAML frontmatter 是最优选择，因为：
1. **人类可读** - Markdown 是最易读的标记语言
2. **机器可解析** - YAML frontmatter 提供结构化元数据
3. **开发者熟悉** - 无需学习新格式
4. **工具支持** - 所有编辑器都支持 Markdown
5. **版本控制友好** - 纯文本，Git diff 清晰
6. **符合本质** - Skills 是提示词，Markdown 是最适合提示词的格式

---

### 问题 3：为什么选择文件系统加载而非数据库或 API？

**根本问题：** 如何以最简单的方式存储和加载技能？

**选项分析：**

1. **数据库存储**
   ```typescript
   // 需要数据库连接
   const db = await connectToDatabase();
   const skill = await db.skills.findOne({ name: 'code-review' });
   ```
   - ✅ 结构化查询
   - ✅ 支持复杂过滤
   - ❌ 需要数据库服务
   - ❌ 需要额外配置
   - ❌ 不易于版本控制
   - ❌ 不易于团队协作（需要同步数据库）

2. **API 服务**
   ```typescript
   // 需要 API 服务
   const skill = await fetch('https://api.example.com/skills/code-review');
   ```
   - ✅ 集中管理
   - ✅ 支持权限控制
   - ❌ 需要网络连接
   - ❌ 需要额外服务
   - ❌ 增加复杂度
   - ❌ 不适合本地开发

3. **代码中定义**
   ```typescript
   // 硬编码在代码中
   const skills = {
     'code-review': {
       name: 'code-review',
       description: 'Review code',
       prompt: '...'
     }
   };
   ```
   - ✅ 简单
   - ✅ 无需外部依赖
   - ❌ 需要重新编译
   - ❌ 不易于非开发者编辑
   - ❌ 难以动态更新

4. **文件系统**
   ```
   ~/.pi/agent/skills/
   ├── code-review/
   │   └── SKILL.md
   ├── test-generation/
   │   └── SKILL.md
   └── debugging/
       └── SKILL.md
   ```
   - ✅ 零配置（放文件就能用）
   - ✅ 零依赖（不需要数据库或服务）
   - ✅ 易于编辑（任何文本编辑器）
   - ✅ 易于版本控制（Git）
   - ✅ 易于团队协作（Git 工作流）
   - ✅ 支持多源加载（全局 + 项目）
   - ✅ 符合 Unix 哲学（一切皆文件）

**第一性原理推导：**

文件系统是最优选择，因为：
1. **极简主义** - 零配置，零依赖
2. **开发者友好** - 符合开发者的工作流
3. **版本控制友好** - Git 原生支持
4. **团队协作友好** - Git 工作流
5. **符合 Unix 哲学** - 一切皆文件

---

### 问题 4：为什么选择启动时加载而非动态加载？

**根本问题：** 何时加载技能最合适？

**选项分析：**

1. **动态加载（按需加载）**
   ```typescript
   // 使用时才加载
   async function useSkill(name: string) {
     const skill = await loadSkill(name);
     return skill;
   }
   ```
   - ✅ 节省内存（只加载需要的）
   - ✅ 支持热更新
   - ❌ 运行时 I/O 开销
   - ❌ 需要文件监听机制
   - ❌ 需要缓存管理
   - ❌ 增加复杂度

2. **启动时加载（一次性加载）**
   ```typescript
   // 启动时加载所有技能
   const skills = loadSkillsFromDir('~/.pi/agent/skills');

   // 运行时直接使用
   function useSkill(name: string) {
     return skills.find(s => s.name === name);
   }
   ```
   - ✅ 零运行时 I/O 开销
   - ✅ 简单（无需文件监听）
   - ✅ 一致性（会话期间技能列表稳定）
   - ❌ 需要重启才能加载新技能
   - ❌ 占用内存（但技能文件很小）

**第一性原理推导：**

启动时加载是最优选择，因为：
1. **简单性** - 避免文件监听和热重载的复杂性
2. **性能** - 技能文件很小（几 KB），全量加载开销小
3. **一致性** - 确保会话期间技能列表稳定
4. **符合使用场景** - Agent 会话通常较短，重启成本低

**来自源码的证据（skills.ts:146-230）：**

```typescript
export function loadSkillsFromDir(options: LoadSkillsFromDirOptions): LoadSkillsResult {
  const { dir, source } = options;
  return loadSkillsFromDirInternal(dir, source, true);
}

function loadSkillsFromDirInternal(
  dir: string,
  source: string,
  includeRootFiles: boolean,
  ignoreMatcher?: IgnoreMatcher,
  rootDir?: string,
): LoadSkillsResult {
  const skills: Skill[] = [];
  const diagnostics: ResourceDiagnostic[] = [];

  // 同步读取目录（启动时一次性加载）
  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    if (entry.isDirectory()) {
      // 递归扫描子目录
      const subResult = loadSkillsFromDirInternal(fullPath, source, false, ig, root);
      skills.push(...subResult.skills);
    } else if (entry.name === "SKILL.md") {
      // 加载技能文件
      const result = loadSkillFromFile(fullPath, source);
      if (result.skill) {
        skills.push(result.skill);
      }
    }
  }

  return { skills, diagnostics };
}
```

**关键点：**
- 使用 `readdirSync`（同步读取）
- 递归扫描所有子目录
- 一次性加载所有技能
- 返回技能数组（存储在内存中）

---

### 问题 5：为什么选择文本展开而非函数调用？

**根本问题：** 如何执行技能？

**选项分析：**

1. **函数调用（代码执行）**
   ```typescript
   // 技能是函数
   const codeReviewSkill = async (code: string) => {
     // 执行代码逻辑
     const issues = analyzeCode(code);
     return formatReport(issues);
   };

   // 调用技能
   const result = await codeReviewSkill(code);
   ```
   - ✅ 确定性执行
   - ✅ 类型安全
   - ✅ 性能高（毫秒级）
   - ❌ 需要编写代码
   - ❌ 难以适应不同场景
   - ❌ 无法利用 LLM 的理解能力

2. **文本展开（提示词注入）**
   ```typescript
   // 技能是提示词
   const codeReviewSkill = `
   You are an expert code reviewer.
   Analyze the code and provide feedback.
   `;

   // 调用技能 = 展开提示词
   const expandedPrompt = `
   <skill name="code-review">
   ${codeReviewSkill}
   </skill>

   ${userCode}
   `;

   // 发送给 LLM
   const result = await llm.generate(expandedPrompt);
   ```
   - ✅ 灵活（LLM 可以理解和适应）
   - ✅ 无需编写代码
   - ✅ 可以处理复杂的自然语言任务
   - ❌ 非确定性（LLM 生成）
   - ❌ 性能较低（秒级）
   - ❌ 依赖 LLM 能力

**第一性原理推导：**

文本展开是最优选择，因为：
1. **符合本质** - Skills 是提示词，不是代码
2. **利用 LLM 优势** - 自然语言理解、创意生成、灵活推理
3. **简单性** - 无需编写复杂的代码逻辑
4. **适应性** - 可以处理各种不同的场景

**来自源码的证据（agent-session.ts:883-907）：**

```typescript
private _expandSkillCommand(text: string): string {
  if (!text.startsWith("/skill:")) return text;

  const spaceIndex = text.indexOf(" ");
  const skillName = spaceIndex === -1 ? text.slice(7) : text.slice(7, spaceIndex);
  const args = spaceIndex === -1 ? "" : text.slice(spaceIndex + 1).trim();

  const skill = this.resourceLoader.getSkills().skills.find((s) => s.name === skillName);
  if (!skill) return text;

  // 关键：读取文件内容（不是执行代码）
  const content = readFileSync(skill.filePath, 'utf-8');
  const body = stripFrontmatter(content).trim();

  // 关键：展开为 XML 块（不是函数调用）
  const skillBlock = `<skill name="${skill.name}" location="${skill.filePath}">
References are relative to ${skill.baseDir}.

${body}
</skill>`;

  // 关键：拼接参数（不是传递参数）
  return args ? `${skillBlock}\n\n${args}` : skillBlock;
}
```

**关键点：**
- 没有 `eval()` 或 `Function()` 调用
- 没有代码编译或执行
- 只是文本读取和字符串拼接
- 最终注入到 LLM 的上下文中

---

## 推理链：从问题到解决方案

### 推理步骤 1：识别核心问题

**问题：** AI Agent 能力的模块化、复用、协作。

**分析：**
- Agent 能力是 AI 应用的核心
- 好的能力需要反复迭代
- 团队需要共享最佳实践
- 能力需要版本控制和管理

**结论：** 需要一个技能包系统。

---

### 推理步骤 2：确定设计约束

**约束 1：极简主义**
- Pi-mono 的核心理念是极简
- 不能引入复杂的依赖
- 不能增加学习成本

**约束 2：开发者友好**
- 目标用户是开发者
- 应该使用开发者熟悉的工具和格式
- 应该符合开发者的工作流

**约束 3：符合本质**
- Skills 是提示词，不是代码
- 应该利用 LLM 的优势
- 应该适应 LLM 的特性

---

### 推理步骤 3：选择技术方案

**格式选择：** Markdown + YAML frontmatter
- 理由：人类可读 + 机器可解析 + 开发者熟悉 + 符合提示词本质

**存储方式：** 文件系统
- 理由：零配置 + 零依赖 + 版本控制友好 + 团队协作友好

**加载时机：** 启动时加载
- 理由：简单 + 性能 + 一致性

**执行方式：** 文本展开
- 理由：符合本质 + 利用 LLM 优势 + 简单 + 适应性

---

### 推理步骤 4：验证设计

**验证 1：是否解决了核心问题？**
- ✅ 模块化：每个技能独立封装
- ✅ 复用性：一次编写，多次使用
- ✅ 协作性：Git 版本控制，团队共享
- ✅ 管理性：文件系统组织，易于维护

**验证 2：是否符合设计约束？**
- ✅ 极简主义：零依赖，零配置
- ✅ 开发者友好：熟悉的格式和工具
- ✅ 符合本质：提示词格式，LLM 执行

**验证 3：是否有更好的方案？**
- 考虑了代码、JSON、YAML、数据库、API 等方案
- Markdown + 文件系统方案在极简性、易用性、协作性上最优
- 没有发现更好的方案

---

## 核心洞察

### 洞察 1：极简主义的力量

**Pi-mono 的 Skills 没有发明任何新东西，而是巧妙地组合了已有的标准：**

- Markdown（1994 年）
- YAML（2001 年）
- 文件系统（1960 年代）
- Git（2005 年）

**这就是极简主义的力量：不是创造新的复杂性，而是消除不必要的复杂性。**

---

### 洞察 2：约束即自由

**通过选择简单的技术方案，Pi-mono 获得了更大的自由：**

1. **零依赖** - 不需要数据库、不需要服务、不需要框架
2. **零配置** - 放文件就能用
3. **零学习成本** - 开发者已经会了
4. **无限扩展** - 可以用任何文本编辑器、任何版本控制系统、任何协作工具

**这就是"约束即自由"的体现：通过限制选择，获得更大的灵活性。**

---

### 洞察 3：工具应该适应人，而不是人适应工具

**Pi-mono 的设计哲学：**

- 使用开发者已经熟悉的格式（Markdown、YAML）
- 使用开发者已经使用的工具（文本编辑器、Git）
- 使用开发者已经习惯的工作流（文件系统、命令行）

**这就是"工具适应人"的体现：不是让开发者学习新的工具，而是让工具适应开发者的习惯。**

---

### 洞察 4：提示词是一等公民

**传统软件开发：**
```
代码是一等公民，提示词是配置
```

**AI 时代软件开发：**
```
提示词是一等公民，代码是工具
```

**Pi-mono 的 Skills 体现了这个转变：**
- Skills 是提示词，不是代码
- 提示词有自己的格式（Markdown）
- 提示词有自己的版本控制（Git）
- 提示词有自己的模块系统（Skills）

**这就是"提示词是一等公民"的体现：提示词不再是附属品，而是核心资产。**

---

## 2025-2026 年的验证

### 行业趋势验证

根据 2025-2026 年的实际应用，Pi-mono 的设计选择得到了广泛验证：

1. **[Skills are the New Unit of AI Software Development](https://www.accessnewswire.com/newsroom/en/computers-technology-and-internet/skills-are-the-new-unit-of-ai-software-development-1138920)**
   - Skills 成为 AI 软件开发的新单元
   - 传统单元：函数 → 类 → 模块 → 包
   - AI 时代单元：Skills → Agent → System
   - 证明了 Skills 作为模块化单元的价值

2. **[Anthropic Makes Agent Skills an Open Standard](https://medium.com/lab7ai-insights/anthropic-makes-agent-skills-an-open-standard-for-modular-ai-agent-capabilities-781c697b4d3b)**
   - Anthropic 推动 SKILL.md 成为开放标准
   - Vercel、Google、OpenAI 等公司采用
   - 证明了 Markdown + YAML frontmatter 格式的正确性

3. **[Vercel Releases Agent Skills](https://www.marktechpost.com/2026/01/18/vercel-releases-agent-skills)**
   - Vercel 发布 Agent Skills 市场
   - 300+ 开源技能库（VoltAgent/awesome-agent-skills）
   - 证明了文件系统分发的可行性

4. **[Building Modular Agentic AI Systems](https://mayursurani.medium.com/building-modular-agentic-ai-systems)**
   - 从单体 Agent 到可组合 Agent
   - Skills 作为能力模块
   - 证明了模块化架构的价值

### 社区实践验证

1. **[anthropics/skills](https://github.com/anthropics/skills)** - 官方仓库
   - 使用 SKILL.md 格式
   - 使用 Git 版本控制
   - 使用文件系统组织

2. **[vercel-labs/agent-skills](https://github.com/vercel-labs/agent-skills)** - Vercel 技能库
   - 100+ AI 编码助手技能
   - 使用相同的格式和组织方式

3. **[VoltAgent/awesome-agent-skills](https://github.com/VoltAgent/awesome-agent-skills)** - 社区技能库
   - 300+ Claude Code 兼容技能
   - 证明了跨工具兼容性

---

## 总结

**Pi-mono 的 Skills 技能包系统是第一性原理思维的完美体现：**

1. **从根本问题出发** - Agent 能力的模块化、复用、协作
2. **识别核心约束** - 极简主义、开发者友好、符合本质
3. **选择最优方案** - Markdown + 文件系统 + 启动时加载 + 文本展开
4. **验证设计** - 解决问题、符合约束、无更好方案
5. **持续验证** - 2025-2026 年的实践证明了设计的正确性

**这不是技术创新，而是工程智慧：用最简单的方式解决最核心的问题。**

**核心设计原则：**
1. **极简主义** - 零依赖，零配置
2. **约束即自由** - 通过限制选择，获得更大灵活性
3. **工具适应人** - 使用开发者熟悉的工具和格式
4. **提示词是一等公民** - 提示词不是配置，是核心资产

**这就是 Skills 技能包系统的第一性原理。**

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
