# 实战代码 04: 结构化输出

> **本文目标**: 掌握使用 Pydantic 实现结构化输出的方法

---

## 概述

结构化输出让 LLM 的返回结果类型安全、易于处理。本文展示如何使用 Pydantic 和 LangChain 实现结构化输出。

---

## 1. 基础结构化输出

### 1.1 使用 with_structured_output

```python
"""
示例1: 基础结构化输出
演示：使用 with_structured_output 方法
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage
from pydantic import BaseModel, Field

load_dotenv()

# ===== 1. 定义输出结构 =====
class Person(BaseModel):
    """人物信息"""
    name: str = Field(description="姓名")
    age: int = Field(description="年龄")
    occupation: str = Field(description="职业")

# ===== 2. 创建结构化模型 =====
model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(Person)

# ===== 3. 调用模型 =====
print("=== 结构化输出示例 ===\n")

response = structured_model.invoke([
    HumanMessage(content="张三，30岁，软件工程师")
])

print(f"类型: {type(response)}")
print(f"姓名: {response.name}")
print(f"年龄: {response.age}")
print(f"职业: {response.occupation}")

# ===== 4. 类型安全 =====
print(f"\n年龄类型: {type(response.age)}")  # <class 'int'>
print(f"年龄+5: {response.age + 5}")  # 35
```

### 1.2 复杂结构

```python
"""
示例2: 复杂结构化输出
演示：嵌套结构和列表
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage
from pydantic import BaseModel, Field
from typing import List

load_dotenv()

# ===== 1. 定义复杂结构 =====
class Skill(BaseModel):
    """技能"""
    name: str = Field(description="技能名称")
    level: str = Field(description="熟练程度：初级/中级/高级")

class Developer(BaseModel):
    """开发者信息"""
    name: str = Field(description="姓名")
    age: int = Field(description="年龄")
    skills: List[Skill] = Field(description="技能列表")
    years_of_experience: int = Field(description="工作年限")

# ===== 2. 创建结构化模型 =====
model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(Developer)

# ===== 3. 调用模型 =====
print("=== 复杂结构化输出 ===\n")

response = structured_model.invoke([
    HumanMessage(content="""
    李四，28岁，有5年工作经验。
    擅长Python（高级）、JavaScript（中级）、Go（初级）
    """)
])

print(f"姓名: {response.name}")
print(f"年龄: {response.age}")
print(f"工作年限: {response.years_of_experience}")
print(f"\n技能列表:")
for skill in response.skills:
    print(f"  - {skill.name}: {skill.level}")
```

---

## 2. 与模板组合

### 2.1 结构化输出 + 模板

```python
"""
示例3: 结构化输出与模板组合
演示：使用模板引导结构化输出
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
from typing import List

load_dotenv()

# ===== 1. 定义输出结构 =====
class Analysis(BaseModel):
    """代码分析结果"""
    summary: str = Field(description="代码功能总结")
    complexity: str = Field(description="复杂度：低/中/高")
    issues: List[str] = Field(description="发现的问题列表")
    suggestions: List[str] = Field(description="改进建议列表")

# ===== 2. 创建模板 =====
template = ChatPromptTemplate.from_messages([
    ("system", "你是代码分析专家，分析代码并给出结构化结果"),
    ("human", "请分析以下代码：\n\n{code}")
])

# ===== 3. 创建链 =====
model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(Analysis)
chain = template | structured_model

# ===== 4. 使用 =====
code = """
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
"""

print("=== 代码分析 ===\n")
result = chain.invoke({"code": code})

print(f"总结: {result.summary}")
print(f"复杂度: {result.complexity}")
print(f"\n问题:")
for issue in result.issues:
    print(f"  - {issue}")
print(f"\n建议:")
for suggestion in result.suggestions:
    print(f"  - {suggestion}")
```

---

## 3. 实用场景

### 3.1 情感分析

```python
"""
示例4: 情感分析
演示：结构化的情感分析结果
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
from typing import List

load_dotenv()

# ===== 1. 定义输出结构 =====
class SentimentAnalysis(BaseModel):
    """情感分析结果"""
    sentiment: str = Field(description="情感：正面/负面/中性")
    confidence: float = Field(description="置信度：0-1之间")
    keywords: List[str] = Field(description="关键词列表")
    explanation: str = Field(description="分析说明")

# ===== 2. 创建链 =====
template = ChatPromptTemplate.from_messages([
    ("system", "你是情感分析专家"),
    ("human", "分析以下文本的情感：{text}")
])

model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(SentimentAnalysis)
chain = template | structured_model

# ===== 3. 测试 =====
texts = [
    "这个产品非常好用，强烈推荐！",
    "质量一般，价格偏贵",
    "还可以，符合预期"
]

print("=== 情感分析 ===\n")
for text in texts:
    result = chain.invoke({"text": text})
    print(f"文本: {text}")
    print(f"情感: {result.sentiment} (置信度: {result.confidence:.2f})")
    print(f"关键词: {', '.join(result.keywords)}")
    print(f"说明: {result.explanation}\n")
```

### 3.2 信息提取

```python
"""
示例5: 信息提取
演示：从文本中提取结构化信息
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
from typing import Optional

load_dotenv()

# ===== 1. 定义输出结构 =====
class ContactInfo(BaseModel):
    """联系信息"""
    name: str = Field(description="姓名")
    email: Optional[str] = Field(description="邮箱", default=None)
    phone: Optional[str] = Field(description="电话", default=None)
    company: Optional[str] = Field(description="公司", default=None)
    position: Optional[str] = Field(description="职位", default=None)

# ===== 2. 创建链 =====
template = ChatPromptTemplate.from_messages([
    ("system", "从文本中提取联系信息"),
    ("human", "{text}")
])

model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(ContactInfo)
chain = template | structured_model

# ===== 3. 测试 =====
texts = [
    "我是王五，在ABC公司担任技术总监，邮箱是wangwu@abc.com",
    "赵六，电话13800138000",
    "联系人：孙七，XYZ科技产品经理，手机15900159000，邮箱sunqi@xyz.com"
]

print("=== 信息提取 ===\n")
for text in texts:
    result = chain.invoke({"text": text})
    print(f"原文: {text}")
    print(f"姓名: {result.name}")
    if result.email:
        print(f"邮箱: {result.email}")
    if result.phone:
        print(f"电话: {result.phone}")
    if result.company:
        print(f"公司: {result.company}")
    if result.position:
        print(f"职位: {result.position}")
    print()
```

### 3.3 问答系统

```python
"""
示例6: 结构化问答
演示：返回结构化的问答结果
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
from typing import List

load_dotenv()

# ===== 1. 定义输出结构 =====
class Answer(BaseModel):
    """问答结果"""
    answer: str = Field(description="答案")
    confidence: float = Field(description="置信度：0-1")
    sources: List[str] = Field(description="信息来源")
    related_questions: List[str] = Field(description="相关问题")

# ===== 2. 创建链 =====
template = ChatPromptTemplate.from_messages([
    ("system", "你是专业的问答助手，提供结构化答案"),
    ("human", "上下文：{context}\n\n问题：{question}")
])

model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(Answer)
chain = template | structured_model

# ===== 3. 使用 =====
context = """
Python是一种高级编程语言，由Guido van Rossum于1991年创建。
它以简洁的语法和强大的功能而闻名，广泛应用于Web开发、数据科学、人工智能等领域。
Python拥有丰富的第三方库生态系统，如NumPy、Pandas、Django等。
"""

question = "Python是什么时候创建的？"

print("=== 结构化问答 ===\n")
result = chain.invoke({
    "context": context,
    "question": question
})

print(f"问题: {question}")
print(f"答案: {result.answer}")
print(f"置信度: {result.confidence:.2f}")
print(f"\n信息来源:")
for source in result.sources:
    print(f"  - {source}")
print(f"\n相关问题:")
for q in result.related_questions:
    print(f"  - {q}")
```

---

## 4. 数据验证

### 4.1 使用 Pydantic 验证器

```python
"""
示例7: 数据验证
演示：使用 Pydantic 验证器确保数据质量
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage
from pydantic import BaseModel, Field, validator, ValidationError

load_dotenv()

# ===== 1. 定义带验证的结构 =====
class Product(BaseModel):
    """产品信息"""
    name: str = Field(description="产品名称")
    price: float = Field(description="价格")
    rating: float = Field(description="评分：1-5")
    stock: int = Field(description="库存数量")

    @validator('price')
    def validate_price(cls, v):
        if v <= 0:
            raise ValueError("价格必须大于0")
        return v

    @validator('rating')
    def validate_rating(cls, v):
        if not 1 <= v <= 5:
            raise ValueError("评分必须在1-5之间")
        return v

    @validator('stock')
    def validate_stock(cls, v):
        if v < 0:
            raise ValueError("库存不能为负数")
        return v

# ===== 2. 创建结构化模型 =====
model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(Product)

# ===== 3. 测试验证 =====
print("=== 数据验证 ===\n")

# 有效数据
print("--- 有效数据 ---")
try:
    result = structured_model.invoke([
        HumanMessage(content="iPhone 15，价格5999元，评分4.5，库存100")
    ])
    print(f"✅ 成功: {result.name}, ¥{result.price}, {result.rating}星")
except ValidationError as e:
    print(f"❌ 验证失败: {e}")

# 无效数据（如果模型返回无效数据）
print("\n--- 测试边界 ---")
print("模型通常会返回有效数据，因为它理解约束")
```

---

## 5. 批量处理

### 5.1 批量结构化输出

```python
"""
示例8: 批量结构化输出
演示：批量处理并返回结构化结果
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
from typing import List

load_dotenv()

# ===== 1. 定义输出结构 =====
class Classification(BaseModel):
    """分类结果"""
    text: str = Field(description="原文")
    category: str = Field(description="类别")
    confidence: float = Field(description="置信度")

# ===== 2. 创建链 =====
template = ChatPromptTemplate.from_messages([
    ("system", "将文本分类为：技术/商业/娱乐/体育"),
    ("human", "{text}")
])

model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(Classification)
chain = template | structured_model

# ===== 3. 批量处理 =====
texts = [
    "Python 3.12 发布了新特性",
    "股市今日大涨",
    "新电影票房破纪录",
    "NBA总决赛精彩对决"
]

print("=== 批量分类 ===\n")

inputs = [{"text": t} for t in texts]
results = chain.batch(inputs)

for result in results:
    print(f"文本: {result.text}")
    print(f"类别: {result.category} (置信度: {result.confidence:.2f})\n")
```

---

## 6. 完整应用示例

### 6.1 智能简历解析器

```python
"""
示例9: 智能简历解析器
演示：完整的结构化输出应用
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import date

load_dotenv()

# ===== 1. 定义复杂结构 =====
class Education(BaseModel):
    """教育经历"""
    school: str = Field(description="学校名称")
    degree: str = Field(description="学位")
    major: str = Field(description="专业")
    start_year: int = Field(description="开始年份")
    end_year: Optional[int] = Field(description="结束年份", default=None)

class WorkExperience(BaseModel):
    """工作经历"""
    company: str = Field(description="公司名称")
    position: str = Field(description="职位")
    start_year: int = Field(description="开始年份")
    end_year: Optional[int] = Field(description="结束年份", default=None)
    responsibilities: List[str] = Field(description="工作职责")

class Resume(BaseModel):
    """简历"""
    name: str = Field(description="姓名")
    email: Optional[str] = Field(description="邮箱", default=None)
    phone: Optional[str] = Field(description="电话", default=None)
    summary: str = Field(description="个人简介")
    skills: List[str] = Field(description="技能列表")
    education: List[Education] = Field(description="教育经历")
    work_experience: List[WorkExperience] = Field(description="工作经历")

# ===== 2. 创建链 =====
template = ChatPromptTemplate.from_messages([
    ("system", "你是专业的简历解析专家，从文本中提取结构化信息"),
    ("human", "{resume_text}")
])

model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(Resume)
chain = template | structured_model

# ===== 3. 测试 =====
resume_text = """
张伟
邮箱：zhangwei@example.com
电话：13800138000

个人简介：
5年经验的全栈工程师，擅长Python和JavaScript，有丰富的Web开发经验。

技能：
- Python, Django, Flask
- JavaScript, React, Vue
- MySQL, PostgreSQL
- Docker, Kubernetes

教育经历：
2015-2019 清华大学 计算机科学与技术 本科

工作经历：
2019-2021 ABC科技有限公司 初级工程师
- 负责公司官网开发和维护
- 参与后端API设计和实现

2021-至今 XYZ互联网公司 高级工程师
- 带领团队开发电商平台
- 负责系统架构设计
- 优化系统性能，提升响应速度50%
"""

print("=== 智能简历解析 ===\n")
result = chain.invoke({"resume_text": resume_text})

print(f"姓名: {result.name}")
print(f"邮箱: {result.email}")
print(f"电话: {result.phone}")
print(f"\n简介: {result.summary}")

print(f"\n技能:")
for skill in result.skills:
    print(f"  - {skill}")

print(f"\n教育经历:")
for edu in result.education:
    end = edu.end_year or "至今"
    print(f"  {edu.start_year}-{end}: {edu.school} - {edu.degree} - {edu.major}")

print(f"\n工作经历:")
for work in result.work_experience:
    end = work.end_year or "至今"
    print(f"  {work.start_year}-{end}: {work.company} - {work.position}")
    for resp in work.responsibilities:
        print(f"    - {resp}")
```

---

## 7. 错误处理

### 7.1 处理解析失败

```python
"""
示例10: 错误处理
演示：处理结构化输出失败的情况
"""
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage
from pydantic import BaseModel, Field, ValidationError

load_dotenv()

# ===== 1. 定义输出结构 =====
class StrictData(BaseModel):
    """严格的数据结构"""
    number: int = Field(description="必须是整数")
    email: str = Field(description="必须是邮箱格式")

# ===== 2. 创建结构化模型 =====
model = ChatOpenAI(model="gpt-4o-mini")
structured_model = model.with_structured_output(StrictData)

# ===== 3. 安全调用 =====
def safe_structured_invoke(model, message, max_retries=3):
    """安全的结构化调用"""
    for attempt in range(max_retries):
        try:
            result = model.invoke([HumanMessage(content=message)])
            return result, None
        except ValidationError as e:
            print(f"尝试 {attempt + 1}/{max_retries} 失败: {e}")
            if attempt == max_retries - 1:
                return None, e
        except Exception as e:
            print(f"其他错误: {e}")
            return None, e

    return None, Exception("达到最大重试次数")

# ===== 4. 测试 =====
print("=== 错误处理 ===\n")

# 测试1: 有效数据
print("--- 测试1: 有效数据 ---")
result, error = safe_structured_invoke(
    structured_model,
    "数字是42，邮箱是test@example.com"
)
if result:
    print(f"✅ 成功: number={result.number}, email={result.email}")
else:
    print(f"❌ 失败: {error}")

# 测试2: 模糊数据（模型通常能处理）
print("\n--- 测试2: 模糊数据 ---")
result, error = safe_structured_invoke(
    structured_model,
    "数字大概是四十二，邮箱是test at example dot com"
)
if result:
    print(f"✅ 成功: number={result.number}, email={result.email}")
else:
    print(f"❌ 失败: {error}")
```

---

## 8. 最佳实践

### 8.1 推荐做法

```python
"""
最佳实践示例
"""
from pydantic import BaseModel, Field
from typing import List, Optional

# ✅ 1. 清晰的字段描述
class GoodModel(BaseModel):
    name: str = Field(description="用户姓名")
    age: int = Field(description="年龄，必须大于0")
    email: Optional[str] = Field(description="邮箱地址，可选", default=None)

# ✅ 2. 使用验证器
from pydantic import validator

class ValidatedModel(BaseModel):
    score: float = Field(description="分数")

    @validator('score')
    def validate_score(cls, v):
        if not 0 <= v <= 100:
            raise ValueError("分数必须在0-100之间")
        return v

# ✅ 3. 合理的默认值
class DefaultModel(BaseModel):
    required_field: str = Field(description="必填字段")
    optional_field: Optional[str] = Field(description="可选字段", default=None)
    default_field: int = Field(description="有默认值的字段", default=0)

# ✅ 4. 嵌套结构
class Address(BaseModel):
    city: str
    street: str

class Person(BaseModel):
    name: str
    address: Address  # 嵌套结构
```

### 8.2 避免的做法

```python
# ❌ 1. 缺少字段描述
class BadModel1(BaseModel):
    name: str  # 没有描述
    age: int

# ❌ 2. 过于复杂的结构
class BadModel2(BaseModel):
    data: dict  # 太模糊，应该定义具体结构

# ❌ 3. 不合理的必填字段
class BadModel3(BaseModel):
    optional_data: str  # 应该是 Optional[str]

# ❌ 4. 缺少验证
class BadModel4(BaseModel):
    percentage: float  # 应该验证范围0-100
```

---

## 检查清单

完成本节实战后，你应该能够：

- [ ] 使用 with_structured_output 创建结构化模型
- [ ] 定义复杂的 Pydantic 模型
- [ ] 结合模板使用结构化输出
- [ ] 实现情感分析、信息提取等应用
- [ ] 使用 Pydantic 验证器
- [ ] 批量处理结构化输出
- [ ] 构建完整的结构化应用
- [ ] 处理解析错误
- [ ] 应用最佳实践

---

**下一步**: 阅读 `07_实战代码_05_流式对话.md` 学习流式输出的实现
