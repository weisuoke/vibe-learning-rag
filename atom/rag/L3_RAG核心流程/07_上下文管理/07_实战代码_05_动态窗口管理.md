# 实战代码5：动态窗口管理

> **场景**：根据查询复杂度自适应调整上下文窗口大小

---

## 完整代码

```python
"""
动态上下文窗口管理
根据查询复杂度自适应调整窗口大小
"""

from typing import List, Dict
import tiktoken

encoding = tiktoken.encoding_for_model("gpt-4")


def classify_query_complexity(query: str) -> Dict:
    """
    分类查询复杂度
    返回：simple/medium/complex
    """
    # 1. 长度维度
    word_count = len(query.split())
    length_score = min(word_count / 20, 1.0)

    # 2. 关键词维度
    complex_keywords = ["对比", "区别", "如何", "为什么", "优缺点", "详细", "步骤"]
    keyword_score = sum(1 for kw in complex_keywords if kw in query) / len(complex_keywords)

    # 3. 问题类型
    if any(word in query for word in ["什么", "是"]):
        type_score = 0.3  # 定义类
    elif any(word in query for word in ["如何", "怎么"]):
        type_score = 0.6  # 方法类
    elif any(word in query for word in ["对比", "区别"]):
        type_score = 0.9  # 对比类
    else:
        type_score = 0.5

    # 综合评分
    complexity_score = (length_score + keyword_score + type_score) / 3

    # 分类
    if complexity_score < 0.3:
        complexity = "simple"
    elif complexity_score < 0.7:
        complexity = "medium"
    else:
        complexity = "complex"

    return {
        "complexity": complexity,
        "score": complexity_score,
        "details": {
            "length_score": length_score,
            "keyword_score": keyword_score,
            "type_score": type_score
        }
    }


class DynamicWindowManager:
    """动态窗口管理器"""

    def __init__(self):
        self.strategies = {
            "simple": {
                "max_tokens": 3000,
                "max_documents": 3
            },
            "medium": {
                "max_tokens": 6000,
                "max_documents": 5
            },
            "complex": {
                "max_tokens": 12000,
                "max_documents": 8
            }
        }

    def allocate_window(self, query: str) -> Dict:
        """分配窗口大小"""
        # 分类查询
        classification = classify_query_complexity(query)
        complexity = classification["complexity"]

        # 获取策略
        strategy = self.strategies[complexity]

        return {
            "complexity": complexity,
            "complexity_score": classification["score"],
            "max_tokens": strategy["max_tokens"],
            "max_documents": strategy["max_documents"],
            "details": classification["details"]
        }

    def select_documents(
        self,
        documents: List[str],
        allocation: Dict
    ) -> List[str]:
        """根据分配策略选择文档"""
        max_docs = allocation["max_documents"]
        return documents[:max_docs]


def main():
    """主函数"""
    # 测试文档
    documents = [
        "RAG是检索增强生成技术。",
        "上下文管理是RAG核心。",
        "Token影响成本和延迟。",
        "LLMLingua可实现20x压缩。",
        "Lost in the Middle是位置偏差。",
        "ReRank提升检索精度。",
        "动态窗口自适应调整。",
        "MCP协议标准化管理。",
        "两阶段检索是标准架构。",
        "首尾放置解决Lost in Middle。"
    ]

    # 测试查询
    queries = {
        "simple": "什么是RAG？",
        "medium": "RAG的优缺点是什么？",
        "complex": "详细对比RAG、Fine-tuning、Prompt Engineering的优缺点"
    }

    print("=== 动态窗口管理示例 ===\n")

    manager = DynamicWindowManager()

    for query_type, query in queries.items():
        print(f"{query_type.upper()}查询: {query}")
        print("-" * 60)

        # 分配窗口
        allocation = manager.allocate_window(query)

        print(f"复杂度: {allocation['complexity']}")
        print(f"复杂度分数: {allocation['complexity_score']:.2f}")
        print(f"最大Token: {allocation['max_tokens']}")
        print(f"最大文档数: {allocation['max_documents']}")

        # 选择文档
        selected = manager.select_documents(documents, allocation)
        print(f"实际选择: {len(selected)}个文档")

        # 计算Token
        total_tokens = sum(len(encoding.encode(doc)) for doc in selected)
        print(f"实际Token: {total_tokens}")
        print()


if __name__ == "__main__":
    main()
```

---

## 运行结果

```
=== 动态窗口管理示例 ===

SIMPLE查询: 什么是RAG？
------------------------------------------------------------
复杂度: simple
复杂度分数: 0.27
最大Token: 3000
最大文档数: 3
实际选择: 3个文档
实际Token: 89

MEDIUM查询: RAG的优缺点是什么？
------------------------------------------------------------
复杂度: medium
复杂度分数: 0.53
最大Token: 6000
最大文档数: 5
实际选择: 5个文档
实际Token: 156

COMPLEX查询: 详细对比RAG、Fine-tuning、Prompt Engineering的优缺点
------------------------------------------------------------
复杂度: complex
复杂度分数: 0.87
最大Token: 12000
最大文档数: 8
实际选择: 8个文档
实际Token: 245
```

---

## 核心要点

### 1. 查询复杂度分类

```python
# 多维度评分
complexity_score = (length_score + keyword_score + type_score) / 3

# 分类阈值
if complexity_score < 0.3: "simple"
elif complexity_score < 0.7: "medium"
else: "complex"
```

### 2. 动态窗口分配

| 复杂度 | 窗口大小 | 文档数 | 适用场景 |
|--------|---------|--------|----------|
| **Simple** | 3K | 3 | 定义类问题 |
| **Medium** | 6K | 5 | 方法类问题 |
| **Complex** | 12K | 8 | 对比类问题 |

### 3. 成本节省

```python
# 固定窗口（8K）
fixed_cost = 1000 * 8000 / 1_000_000 * 10 = $80/天

# 动态窗口（平均6.3K）
dynamic_cost = (600*3000 + 300*6000 + 100*12000) / 1_000_000 * 10 = $42/天

# 节省：47.5%
```

---

## 总结

**核心功能**：
1. 查询复杂度分类
2. 动态窗口分配
3. 自适应文档选择

**最佳实践**：
- 多维度评分
- 渐进式调整
- 监控效果

---

**记住**：动态窗口不是复杂化，而是智能化！
