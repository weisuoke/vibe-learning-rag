# 自定义Tool - 最小可用

> 掌握20%核心知识，快速创建自定义Tool

---

## 核心理念

**最小可用原则：** 掌握以下3个核心知识点，就能开始为 Agent 创建自定义Tool：

1. **@tool装饰器** - 最简单的Tool定义方式（80%场景适用）
2. **参数Schema** - 用Pydantic定义参数类型和验证规则
3. **Tool描述** - 让LLM理解何时调用这个Tool

---

## 1. @tool装饰器（最推荐）

### 1.1 最简单的Tool

```python
from langchain.tools import tool

@tool
def get_current_time() -> str:
    """获取当前时间"""
    from datetime import datetime
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
```

**关键要素：**
- `@tool` 装饰器：将普通函数转换为Tool
- 函数名：`get_current_time` → LLM看到的Tool名称
- 文档字符串：`"""获取当前时间"""` → LLM用来理解Tool功能
- 返回值：必须是字符串（LLM只能理解文本）

### 1.2 带参数的Tool

```python
from langchain.tools import tool

@tool
def calculate_sum(a: int, b: int) -> str:
    """计算两个数的和

    Args:
        a: 第一个数字
        b: 第二个数字
    """
    result = a + b
    return f"{a} + {b} = {result}"
```

**关键要素：**
- 类型注解：`a: int, b: int` → LLM知道参数类型
- 参数说明：在文档字符串中描述每个参数
- 返回字符串：即使计算结果是数字，也要转换为字符串

### 1.3 异步Tool

```python
import httpx
from langchain.tools import tool

@tool
async def fetch_weather(city: str) -> str:
    """获取指定城市的天气信息

    Args:
        city: 城市名称，如'北京'、'上海'
    """
    async with httpx.AsyncClient() as client:
        # 调用天气API（示例）
        response = await client.get(
            f"https://api.weather.com/v1/current",
            params={"city": city}
        )
        data = response.json()
        return f"{city}的天气：{data['weather']}，温度{data['temp']}°C"
```

**关键要素：**
- `async def`：定义异步Tool
- `await`：等待异步操作完成
- 资源管理：使用`async with`自动关闭连接

---

## 2. 参数Schema（Pydantic）

### 2.1 为什么需要Schema？

**问题：** 简单的类型注解不够精确

```python
@tool
def search_products(keyword: str, max_results: int) -> str:
    """搜索产品"""
    pass
```

**局限性：**
- ❌ `keyword`可以是空字符串吗？
- ❌ `max_results`可以是负数吗？
- ❌ `max_results`的合理范围是多少？

### 2.2 使用Pydantic定义Schema

```python
from langchain.tools import tool
from pydantic import BaseModel, Field

class SearchInput(BaseModel):
    """搜索产品的输入参数"""
    keyword: str = Field(
        description="搜索关键词，不能为空",
        min_length=1,
        max_length=100
    )
    max_results: int = Field(
        default=10,
        description="返回的最大结果数",
        ge=1,  # 大于等于1
        le=50  # 小于等于50
    )

@tool(args_schema=SearchInput)
def search_products(keyword: str, max_results: int = 10) -> str:
    """搜索产品数据库

    根据关键词搜索产品，返回匹配的产品列表
    """
    # 实际搜索逻辑
    results = [
        f"产品{i}: 包含'{keyword}'的产品"
        for i in range(1, min(max_results, 5) + 1)
    ]
    return "\n".join(results)
```

**关键要素：**
- `BaseModel`：定义参数结构
- `Field`：定义参数的详细规则
  - `description`：参数说明（LLM会看到）
  - `min_length`/`max_length`：字符串长度限制
  - `ge`/`le`：数字范围限制（greater/less than or equal）
  - `default`：默认值
- `args_schema=SearchInput`：将Schema绑定到Tool

### 2.3 复杂参数类型

```python
from typing import List, Optional
from pydantic import BaseModel, Field
from langchain.tools import tool

class OrderQuery(BaseModel):
    """订单查询参数"""
    user_id: int = Field(description="用户ID")
    status: Optional[str] = Field(
        default=None,
        description="订单状态：pending, paid, shipped, completed"
    )
    start_date: Optional[str] = Field(
        default=None,
        description="开始日期，格式：YYYY-MM-DD"
    )
    limit: int = Field(default=10, ge=1, le=100, description="返回数量")

@tool(args_schema=OrderQuery)
def query_orders(
    user_id: int,
    status: Optional[str] = None,
    start_date: Optional[str] = None,
    limit: int = 10
) -> str:
    """查询用户订单

    根据用户ID和可选的筛选条件查询订单列表
    """
    # 构建查询条件
    conditions = [f"用户ID={user_id}"]
    if status:
        conditions.append(f"状态={status}")
    if start_date:
        conditions.append(f"日期>={start_date}")

    # 模拟查询结果
    return f"查询条件：{', '.join(conditions)}\n找到{limit}条订单"
```

**关键要素：**
- `Optional[str]`：可选参数
- 多个筛选条件：灵活组合
- 默认值：让Tool更易用

---

## 3. Tool描述（关键！）

### 3.1 为什么描述很重要？

**LLM如何选择Tool：**

```
用户问题："北京今天天气怎么样？"
         ↓
LLM分析：需要获取天气信息
         ↓
查看可用Tools：
  - get_weather: "获取指定城市的天气信息"  ✅ 匹配！
  - get_time: "获取当前时间"              ❌ 不匹配
  - search_news: "搜索新闻"               ❌ 不匹配
         ↓
调用：get_weather(city="北京")
```

**描述决定了LLM是否会调用你的Tool！**

### 3.2 好的描述 vs 差的描述

#### ❌ 差的描述

```python
@tool
def get_data(id: str) -> str:
    """获取数据"""  # 太模糊！
    pass
```

**问题：**
- 什么数据？
- 什么时候用？
- 参数是什么？

#### ✅ 好的描述

```python
@tool
def get_order_details(order_id: str) -> str:
    """获取订单详细信息

    根据订单ID查询订单的完整信息，包括：
    - 订单状态（待支付、已支付、已发货、已完成）
    - 商品列表
    - 总金额
    - 收货地址

    适用场景：
    - 用户询问"我的订单XXX怎么样了？"
    - 用户询问"订单XXX的物流信息"
    - 客服需要查看订单详情

    Args:
        order_id: 订单ID，格式为ORD-XXXXXX

    Returns:
        订单详细信息的文本描述
    """
    pass
```

**优点：**
- ✅ 明确说明功能
- ✅ 列出返回的信息
- ✅ 说明适用场景
- ✅ 描述参数格式
- ✅ 说明返回值

### 3.3 描述模板

```python
@tool
def tool_name(param1: type1, param2: type2) -> str:
    """[一句话功能描述]

    [详细功能说明，包括：]
    - [返回什么信息1]
    - [返回什么信息2]

    适用场景：
    - [场景1]
    - [场景2]

    Args:
        param1: [参数1说明，包括格式、范围]
        param2: [参数2说明]

    Returns:
        [返回值说明]

    注意事项：
    - [注意事项1]
    - [注意事项2]
    """
    pass
```

---

## 4. 快速上手：3个实用示例

### 示例1：API调用Tool

```python
import httpx
from langchain.tools import tool
from pydantic import BaseModel, Field

class NewsInput(BaseModel):
    topic: str = Field(description="新闻主题，如'科技'、'体育'")
    limit: int = Field(default=5, ge=1, le=20, description="返回新闻数量")

@tool(args_schema=NewsInput)
async def fetch_latest_news(topic: str, limit: int = 5) -> str:
    """获取最新新闻

    根据主题获取最新的新闻标题和摘要

    适用场景：
    - 用户询问"最近有什么科技新闻？"
    - 用户询问"今天的体育新闻"

    Args:
        topic: 新闻主题
        limit: 返回数量

    Returns:
        新闻列表，每条包含标题和摘要
    """
    # 模拟API调用
    async with httpx.AsyncClient() as client:
        # 实际应该调用真实的新闻API
        # response = await client.get(f"https://api.news.com/search?q={topic}")
        pass

    # 模拟返回结果
    news_list = [
        f"新闻{i}：关于{topic}的最新报道"
        for i in range(1, limit + 1)
    ]
    return "\n".join(news_list)
```

### 示例2：数据库查询Tool

```python
from langchain.tools import tool
from pydantic import BaseModel, Field

class UserInput(BaseModel):
    user_id: int = Field(description="用户ID")

@tool(args_schema=UserInput)
def get_user_info(user_id: int) -> str:
    """获取用户信息

    根据用户ID查询用户的基本信息和统计数据

    返回信息包括：
    - 用户名
    - 注册时间
    - 订单总数
    - 消费总额

    适用场景：
    - 客服查询用户信息
    - 用户询问"我的账户信息"

    Args:
        user_id: 用户ID

    Returns:
        用户信息的文本描述
    """
    # 模拟数据库查询
    # 实际应该使用 asyncpg 或 SQLAlchemy
    user_data = {
        "username": f"user_{user_id}",
        "register_date": "2024-01-01",
        "order_count": 15,
        "total_spent": 3580.50
    }

    return f"""用户信息：
用户名：{user_data['username']}
注册时间：{user_data['register_date']}
订单总数：{user_data['order_count']}
消费总额：¥{user_data['total_spent']}
"""
```

### 示例3：计算Tool

```python
from langchain.tools import tool
from pydantic import BaseModel, Field

class CalcInput(BaseModel):
    expression: str = Field(
        description="数学表达式，如'2 + 3 * 4'",
        max_length=200
    )

@tool(args_schema=CalcInput)
def calculate(expression: str) -> str:
    """计算数学表达式

    安全地计算数学表达式的结果

    支持的运算：
    - 加减乘除：+, -, *, /
    - 括号：()
    - 幂运算：**

    适用场景：
    - 用户询问"125 * 48等于多少？"
    - 用户询问"计算一下(100 + 50) * 2"

    Args:
        expression: 数学表达式

    Returns:
        计算结果

    注意：不支持eval()，使用安全的解析器
    """
    try:
        # 使用安全的表达式求值（不用eval）
        # 实际应该使用 ast.literal_eval 或专门的数学解析库
        import ast
        import operator

        # 支持的运算符
        operators = {
            ast.Add: operator.add,
            ast.Sub: operator.sub,
            ast.Mult: operator.mul,
            ast.Div: operator.truediv,
            ast.Pow: operator.pow,
        }

        def eval_expr(node):
            if isinstance(node, ast.Num):
                return node.n
            elif isinstance(node, ast.BinOp):
                return operators[type(node.op)](
                    eval_expr(node.left),
                    eval_expr(node.right)
                )
            elif isinstance(node, ast.UnaryOp):
                return operators[type(node.op)](eval_expr(node.operand))
            else:
                raise ValueError("不支持的运算")

        tree = ast.parse(expression, mode='eval')
        result = eval_expr(tree.body)
        return f"{expression} = {result}"

    except Exception as e:
        return f"计算错误：{str(e)}"
```

---

## 5. 将Tool集成到Agent

### 5.1 创建Agent并使用Tool

```python
from langchain_openai import ChatOpenAI
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain.prompts import ChatPromptTemplate

# 1. 定义Tools
tools = [
    get_current_time,
    fetch_weather,
    search_products,
    calculate
]

# 2. 创建LLM
llm = ChatOpenAI(model="gpt-4", temperature=0)

# 3. 创建Prompt
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个智能助手，可以使用工具来回答用户问题。"),
    ("human", "{input}"),
    ("placeholder", "{agent_scratchpad}"),
])

# 4. 创建Agent
agent = create_tool_calling_agent(llm, tools, prompt)

# 5. 创建执行器
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,  # 显示执行过程
    max_iterations=5  # 最大迭代次数
)

# 6. 使用Agent
result = agent_executor.invoke({
    "input": "北京今天天气怎么样？现在几点了？"
})
print(result["output"])
```

**执行流程：**
```
用户问题："北京今天天气怎么样？现在几点了？"
    ↓
LLM分析：需要两个工具
    ↓
调用1：fetch_weather(city="北京")
    → 返回："北京的天气：晴天，温度25°C"
    ↓
调用2：get_current_time()
    → 返回："2024-03-15 14:30:00"
    ↓
LLM整合：生成最终回答
    ↓
输出："北京今天天气晴朗，温度25°C。现在时间是2024年3月15日14点30分。"
```

### 5.2 在FastAPI中使用

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class QueryRequest(BaseModel):
    question: str

@app.post("/ask")
async def ask_agent(request: QueryRequest):
    """Agent问答端点"""
    result = await agent_executor.ainvoke({
        "input": request.question
    })
    return {"answer": result["output"]}
```

---

## 6. 这些知识足以做什么？

掌握以上内容后，你可以：

### ✅ 能做的事情

1. **创建基础Tool**
   - API调用Tool（天气、新闻、股票）
   - 数据库查询Tool（用户、订单、产品）
   - 计算Tool（数学、数据转换）
   - 文件操作Tool（读取、搜索）

2. **定义参数验证**
   - 使用Pydantic定义Schema
   - 设置参数类型、范围、默认值
   - 处理可选参数

3. **编写清晰描述**
   - 让LLM理解Tool功能
   - 说明适用场景
   - 描述参数和返回值

4. **集成到Agent**
   - 创建Tool列表
   - 配置Agent执行器
   - 在FastAPI中使用

### ⚠️ 还不能做的事情（需要进阶学习）

1. **复杂资源管理**
   - 数据库连接池
   - HTTP客户端复用
   - 超时和重试策略

2. **高级错误处理**
   - Tool调用失败的优雅降级
   - 错误信息的格式化
   - 日志记录和监控

3. **性能优化**
   - 缓存Tool结果
   - 并发调用多个Tool
   - 限流和熔断

4. **生产级实践**
   - 单元测试
   - 性能监控
   - 安全性考虑

---

## 7. 下一步学习建议

### 立即实践

1. **创建你的第一个Tool**
   ```python
   @tool
   def my_first_tool(param: str) -> str:
       """你的Tool描述"""
       return f"处理结果：{param}"
   ```

2. **测试Tool**
   ```python
   result = my_first_tool.invoke({"param": "测试"})
   print(result)
   ```

3. **集成到Agent**
   ```python
   tools = [my_first_tool]
   agent_executor = AgentExecutor(agent=agent, tools=tools)
   ```

### 深入学习

- **核心概念** - 学习4种Tool定义方式的详细对比
- **实战代码** - 查看8个完整的生产级示例
- **反直觉点** - 避免常见误区
- **化骨绵掌** - 10个进阶知识卡片

---

## 快速参考卡

### @tool装饰器

```python
from langchain.tools import tool

@tool
def tool_name(param: type) -> str:
    """Tool描述"""
    return "结果"
```

### 带Schema的Tool

```python
from pydantic import BaseModel, Field

class Input(BaseModel):
    param: str = Field(description="参数说明")

@tool(args_schema=Input)
def tool_name(param: str) -> str:
    """Tool描述"""
    return "结果"
```

### 异步Tool

```python
@tool
async def tool_name(param: str) -> str:
    """Tool描述"""
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.text
```

### 集成到Agent

```python
tools = [tool1, tool2, tool3]
agent = create_tool_calling_agent(llm, tools, prompt)
agent_executor = AgentExecutor(agent=agent, tools=tools)
```

---

**记住：** 好的Tool = 清晰的描述 + 严格的参数验证 + 可靠的执行逻辑
