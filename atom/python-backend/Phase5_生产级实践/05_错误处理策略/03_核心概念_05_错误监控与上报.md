# 核心概念5：错误监控与上报

**错误监控与上报是通过结构化日志、错误上下文收集、Request ID 追踪等手段，实现错误的可观测性和快速定位。**

---

## 为什么需要错误监控？

**问题：** 生产环境出现错误，但无法快速定位问题原因

```python
# ❌ 没有错误监控
@app.post("/chat")
async def chat(message: str):
    try:
        response = await call_llm(message)
        return {"response": response}
    except Exception as e:
        print(f"Error: {e}")  # 只打印错误消息
        raise HTTPException(status_code=500, detail="服务器错误")

# 生产环境出现错误：
# - 什么时候发生的？
# - 哪个用户遇到的？
# - 输入是什么？
# - 完整的堆栈追踪在哪里？
# - 无法回答这些问题 → 无法快速定位和修复
```

**解决方案：** 错误监控

```python
# ✅ 有错误监控
import structlog
import uuid

logger = structlog.get_logger()

@app.post("/chat")
async def chat(message: str, request: Request):
    request_id = str(uuid.uuid4())

    try:
        response = await call_llm(message)
        return {"response": response}
    except Exception as e:
        # 记录详细错误日志
        logger.error(
            "chat_error",
            request_id=request_id,
            user_id=request.state.user_id,
            message_length=len(message),
            error_type=type(e).__name__,
            error_message=str(e),
            stack_trace=traceback.format_exc()
        )
        raise HTTPException(
            status_code=500,
            detail={"error": "服务器错误", "request_id": request_id}
        )

# 生产环境出现错误：
# - 时间：2026-02-12T08:00:00Z
# - 用户：user_123
# - 输入长度：1500 字符
# - 错误类型：TimeoutError
# - 堆栈追踪：完整的调用链
# - Request ID：abc-123（用户可以提供给客服）
```

---

## 结构化日志

### 什么是结构化日志？

**传统日志**：纯文本，难以解析和查询
```python
print("User user_123 failed to chat: TimeoutError")
```

**结构化日志**：JSON 格式，易于解析和查询
```python
logger.error("chat_error", user_id="user_123", error="TimeoutError")
# 输出：{"event": "chat_error", "user_id": "user_123", "error": "TimeoutError"}
```

---

### 使用 structlog

**安装：**
```bash
uv add structlog
```

**配置：**
```python
import structlog

# 配置 structlog
structlog.configure(
    processors=[
        structlog.stdlib.add_log_level,
        structlog.stdlib.add_logger_name,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.JSONRenderer()
    ],
    wrapper_class=structlog.stdlib.BoundLogger,
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()
```

**使用：**
```python
# 记录信息日志
logger.info("user_login", user_id="user_123", ip="192.168.1.1")

# 记录错误日志
logger.error(
    "llm_timeout",
    user_id="user_123",
    prompt_length=1500,
    timeout=30,
    error_type="TimeoutError"
)

# 输出：
# {
#   "event": "llm_timeout",
#   "level": "error",
#   "timestamp": "2026-02-12T08:00:00Z",
#   "user_id": "user_123",
#   "prompt_length": 1500,
#   "timeout": 30,
#   "error_type": "TimeoutError"
# }
```

---

## Request ID 追踪

### 什么是 Request ID？

**Request ID**：唯一标识一个请求的 ID，用于追踪请求的完整生命周期

**作用：**
- 关联同一个请求的所有日志
- 用户可以提供 Request ID 给客服
- 分布式追踪（跨服务）

---

### 实现 Request ID 中间件

```python
import uuid
from fastapi import FastAPI, Request
from starlette.middleware.base import BaseHTTPMiddleware

class RequestIDMiddleware(BaseHTTPMiddleware):
    """Request ID 中间件"""
    async def dispatch(self, request: Request, call_next):
        # 生成或获取 Request ID
        request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))

        # 存储到 request.state
        request.state.request_id = request_id

        # 调用下一个中间件
        response = await call_next(request)

        # 添加到响应头
        response.headers["X-Request-ID"] = request_id

        return response

# 注册中间件
app = FastAPI()
app.add_middleware(RequestIDMiddleware)
```

---

### 在日志中使用 Request ID

```python
@app.post("/chat")
async def chat(message: str, request: Request):
    request_id = request.state.request_id

    logger.info(
        "chat_start",
        request_id=request_id,
        message_length=len(message)
    )

    try:
        response = await call_llm(message)

        logger.info(
            "chat_success",
            request_id=request_id,
            response_length=len(response)
        )

        return {"response": response, "request_id": request_id}
    except Exception as e:
        logger.error(
            "chat_error",
            request_id=request_id,
            error_type=type(e).__name__,
            error_message=str(e)
        )
        raise HTTPException(
            status_code=500,
            detail={"error": "服务器错误", "request_id": request_id}
        )
```

---

## 错误上下文收集

### 收集哪些上下文？

**请求上下文：**
- Request ID
- 用户 ID
- IP 地址
- User-Agent
- 请求路径
- 请求方法

**错误上下文：**
- 错误类型
- 错误消息
- 堆栈追踪
- 发生时间

**业务上下文：**
- 输入参数
- 中间结果
- 依赖服务状态

---

### 实现错误上下文收集

```python
import traceback
from datetime import datetime

@app.exception_handler(Exception)
async def global_error_handler(request: Request, exc: Exception):
    """全局异常处理器（收集错误上下文）"""
    request_id = getattr(request.state, "request_id", str(uuid.uuid4()))

    # 收集错误上下文
    error_context = {
        # 请求上下文
        "request_id": request_id,
        "timestamp": datetime.utcnow().isoformat(),
        "path": request.url.path,
        "method": request.method,
        "user_id": getattr(request.state, "user_id", None),
        "ip": request.client.host,
        "user_agent": request.headers.get("User-Agent"),

        # 错误上下文
        "error_type": type(exc).__name__,
        "error_message": str(exc),
        "stack_trace": traceback.format_exc(),

        # 业务上下文
        "query_params": dict(request.query_params),
        "path_params": request.path_params,
    }

    # 记录错误日志
    logger.error("unhandled_exception", **error_context)

    # 返回错误响应
    return JSONResponse(
        status_code=500,
        content={
            "error": "服务器内部错误",
            "error_code": "INTERNAL_ERROR",
            "request_id": request_id
        }
    )
```

---

## 错误监控集成（Sentry）

### 什么是 Sentry？

**Sentry**：错误监控和性能监控平台

**功能：**
- 自动捕获错误
- 错误分组和去重
- 错误趋势分析
- 告警通知
- 性能监控

---

### 集成 Sentry

**安装：**
```bash
uv add sentry-sdk[fastapi]
```

**配置：**
```python
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration

sentry_sdk.init(
    dsn="your-sentry-dsn",
    integrations=[FastApiIntegration()],
    environment="production",
    traces_sample_rate=0.1,  # 10% 的请求采样
)

app = FastAPI()
```

**使用：**
```python
@app.post("/chat")
async def chat(message: str, request: Request):
    try:
        response = await call_llm(message)
        return {"response": response}
    except Exception as e:
        # 自动上报到 Sentry
        sentry_sdk.capture_exception(e)

        # 添加自定义上下文
        sentry_sdk.set_context("chat", {
            "message_length": len(message),
            "user_id": request.state.user_id
        })

        raise
```

---

## 在 AI Agent API 中的应用

### 完整示例

```python
"""
完整的错误监控示例
包含：结构化日志、Request ID、错误上下文、Sentry 集成
"""

import uuid
import traceback
from datetime import datetime
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
import structlog
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration

# ===== 1. 配置 structlog =====
structlog.configure(
    processors=[
        structlog.stdlib.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.format_exc_info,
        structlog.processors.JSONRenderer()
    ],
    logger_factory=structlog.stdlib.LoggerFactory(),
)

logger = structlog.get_logger()

# ===== 2. 配置 Sentry =====
sentry_sdk.init(
    dsn="your-sentry-dsn",
    integrations=[FastApiIntegration()],
    environment="production",
)

# ===== 3. Request ID 中间件 =====
class RequestIDMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
        request.state.request_id = request_id

        logger.info(
            "request_start",
            request_id=request_id,
            path=request.url.path,
            method=request.method
        )

        response = await call_next(request)
        response.headers["X-Request-ID"] = request_id

        logger.info(
            "request_end",
            request_id=request_id,
            status_code=response.status_code
        )

        return response

# ===== 4. FastAPI 应用 =====
app = FastAPI()
app.add_middleware(RequestIDMiddleware)

# ===== 5. 全局异常处理器 =====
@app.exception_handler(Exception)
async def global_error_handler(request: Request, exc: Exception):
    request_id = getattr(request.state, "request_id", str(uuid.uuid4()))

    # 收集错误上下文
    error_context = {
        "request_id": request_id,
        "timestamp": datetime.utcnow().isoformat(),
        "path": request.url.path,
        "method": request.method,
        "error_type": type(exc).__name__,
        "error_message": str(exc),
        "stack_trace": traceback.format_exc(),
    }

    # 记录错误日志
    logger.error("unhandled_exception", **error_context)

    # 上报到 Sentry
    sentry_sdk.capture_exception(exc)

    return JSONResponse(
        status_code=500,
        content={
            "error": "服务器内部错误",
            "request_id": request_id
        }
    )

# ===== 6. API 端点 =====
@app.post("/chat")
async def chat(message: str, request: Request):
    request_id = request.state.request_id

    logger.info(
        "chat_start",
        request_id=request_id,
        message_length=len(message)
    )

    try:
        response = await call_llm(message)

        logger.info(
            "chat_success",
            request_id=request_id,
            response_length=len(response)
        )

        return {"response": response, "request_id": request_id}
    except Exception as e:
        logger.error(
            "chat_error",
            request_id=request_id,
            error_type=type(e).__name__,
            error_message=str(e)
        )
        raise
```

---

## 总结

**错误监控的核心价值：**
1. **快速定位**：通过 Request ID 和错误上下文快速定位问题
2. **趋势分析**：通过错误统计分析系统健康状况
3. **告警通知**：错误率突然升高时立即通知开发者

**核心技术：**
- **结构化日志**：structlog（JSON 格式）
- **Request ID**：追踪请求生命周期
- **错误上下文**：收集请求、错误、业务上下文
- **Sentry 集成**：错误监控和告警

**最佳实践：**
- 所有错误都记录详细日志
- 使用 Request ID 关联日志
- 收集完整的错误上下文
- 集成 Sentry 进行错误监控
- 环境感知：开发环境显示详细错误，生产环境隐藏

**在 AI Agent API 中的应用：**
- LLM 调用错误监控
- 数据库操作错误监控
- 向量检索错误监控
- 用户行为追踪
