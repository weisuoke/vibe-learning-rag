# 核心概念03: 优先级队列

## 核心目标

**深入理解优先级队列的概念、实现方式、操作接口,以及在RAG和AI Agent中的应用。**

---

## 1. 优先级队列的定义

### 1.1 抽象数据类型(ADT)

**定义:** 优先级队列是一种抽象数据类型,支持以下操作:
- **insert(item, priority)**: 插入元素及其优先级
- **extract_min/max()**: 删除并返回优先级最高的元素
- **peek()**: 查看优先级最高的元素(不删除)
- **is_empty()**: 检查队列是否为空

**与普通队列的区别:**

```python
# 普通队列(FIFO)
queue = []
queue.append(1)  # 入队
queue.append(2)
queue.append(3)
print(queue.pop(0))  # 1 - 先进先出

# 优先级队列
pq = []
heapq.heappush(pq, (2, "task2"))  # (优先级, 任务)
heapq.heappush(pq, (1, "task1"))
heapq.heappush(pq, (3, "task3"))
print(heapq.heappop(pq))  # (1, "task1") - 优先级最高
```

### 1.2 应用场景

**场景1: 任务调度**
- 操作系统进程调度
- Web服务器请求处理
- AI Agent任务管理

**场景2: 图算法**
- Dijkstra最短路径
- Prim最小生成树
- A*搜索算法

**场景3: 数据处理**
- Top-K问题
- 中位数维护
- 事件驱动模拟

**场景4: AI/ML**
- Beam search
- RAG文档检索
- 强化学习优先级经验回放

---

## 2. 实现方式对比

### 2.1 五种实现方式

| 实现方式 | Insert | Extract-min | Peek | 适用场景 |
|----------|--------|-------------|------|----------|
| 无序数组 | O(1) | O(n) | O(n) | 插入频繁,提取少 |
| 有序数组 | O(n) | O(1) | O(1) | 静态数据 |
| 无序链表 | O(1) | O(n) | O(n) | 插入频繁,提取少 |
| 有序链表 | O(n) | O(1) | O(1) | 小规模数据 |
| **Heap** | **O(log n)** | **O(log n)** | **O(1)** | **通用最优** ✅ |

### 2.2 为什么Heap是最优选择?

**平衡性分析:**

```
场景1: 插入和提取频率相当
- 无序数组: O(1) + O(n) = O(n)
- 有序数组: O(n) + O(1) = O(n)
- Heap: O(log n) + O(log n) = O(log n) ✅ 最优

场景2: 频繁查看最小值
- 所有实现都支持O(1) peek
- Heap额外提供O(log n)的insert和extract

场景3: 动态数据
- 数组需要移动元素,O(n)
- Heap只需调整O(log n)个节点 ✅
```

**空间效率:**

```python
# Heap: 数组存储,紧凑
heap = [5, 10, 15, 20, 25]  # 5个元素,5个位置

# 链表: 需要额外指针
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None  # 额外8字节指针
```

---

## 3. Python实现

### 3.1 使用heapq模块(推荐)

```python
import heapq

class PriorityQueue:
    """
    基于heapq的优先级队列

    特点:
    - Min-heap实现(数字越小优先级越高)
    - 线程不安全
    - 适合单线程场景
    """

    def __init__(self):
        self.heap = []
        self.counter = 0  # 用于保证FIFO(相同优先级)

    def push(self, item, priority):
        """
        插入元素

        Args:
            item: 元素
            priority: 优先级(数字越小优先级越高)

        时间复杂度: O(log n)
        """
        # 使用counter保证相同优先级时FIFO
        heapq.heappush(self.heap, (priority, self.counter, item))
        self.counter += 1

    def pop(self):
        """
        删除并返回优先级最高的元素

        Returns:
            优先级最高的元素

        时间复杂度: O(log n)
        """
        if not self.heap:
            raise IndexError("pop from empty priority queue")

        priority, _, item = heapq.heappop(self.heap)
        return item

    def peek(self):
        """
        查看优先级最高的元素(不删除)

        Returns:
            优先级最高的元素

        时间复杂度: O(1)
        """
        if not self.heap:
            raise IndexError("peek from empty priority queue")

        priority, _, item = self.heap[0]
        return item

    def is_empty(self):
        """检查队列是否为空"""
        return len(self.heap) == 0

    def __len__(self):
        return len(self.heap)

# 使用示例
pq = PriorityQueue()
pq.push("task1", priority=2)
pq.push("task2", priority=1)
pq.push("task3", priority=3)

while not pq.is_empty():
    print(pq.pop())

# 输出:
# task2 (优先级1)
# task1 (优先级2)
# task3 (优先级3)
```

### 3.2 使用queue.PriorityQueue(线程安全)

```python
from queue import PriorityQueue
import threading

class ThreadSafePriorityQueue:
    """
    基于queue.PriorityQueue的线程安全优先级队列

    特点:
    - 内部使用heapq实现
    - 线程安全(带锁)
    - 适合多线程场景
    - 支持阻塞操作
    """

    def __init__(self, maxsize=0):
        """
        Args:
            maxsize: 最大队列大小(0表示无限)
        """
        self.pq = PriorityQueue(maxsize=maxsize)
        self.counter = 0
        self.lock = threading.Lock()

    def push(self, item, priority, block=True, timeout=None):
        """
        插入元素

        Args:
            item: 元素
            priority: 优先级
            block: 是否阻塞(队列满时)
            timeout: 超时时间

        时间复杂度: O(log n)
        """
        with self.lock:
            count = self.counter
            self.counter += 1

        self.pq.put((priority, count, item), block=block, timeout=timeout)

    def pop(self, block=True, timeout=None):
        """
        删除并返回优先级最高的元素

        Args:
            block: 是否阻塞(队列空时)
            timeout: 超时时间

        Returns:
            优先级最高的元素

        时间复杂度: O(log n)
        """
        priority, _, item = self.pq.get(block=block, timeout=timeout)
        return item

    def is_empty(self):
        """检查队列是否为空"""
        return self.pq.empty()

    def size(self):
        """返回队列大小"""
        return self.pq.qsize()

# 使用示例:多线程任务处理
pq = ThreadSafePriorityQueue()

def producer():
    """生产者:提交任务"""
    for i in range(10):
        pq.push(f"task{i}", priority=i % 3)

def consumer():
    """消费者:处理任务"""
    while not pq.is_empty():
        task = pq.pop()
        print(f"Processing {task}")

# 启动多个生产者和消费者
threads = []
threads.append(threading.Thread(target=producer))
threads.append(threading.Thread(target=consumer))

for t in threads:
    t.start()
for t in threads:
    t.join()
```

### 3.3 自定义优先级比较

```python
import heapq
from dataclasses import dataclass, field
from typing import Any

@dataclass(order=True)
class PrioritizedItem:
    """
    带优先级的元素

    使用dataclass的order=True自动生成比较方法
    """
    priority: int
    item: Any = field(compare=False)  # 不参与比较

# 使用示例
pq = []
heapq.heappush(pq, PrioritizedItem(2, "task2"))
heapq.heappush(pq, PrioritizedItem(1, "task1"))
heapq.heappush(pq, PrioritizedItem(3, "task3"))

while pq:
    item = heapq.heappop(pq)
    print(f"{item.item} (priority={item.priority})")

# 输出:
# task1 (priority=1)
# task2 (priority=2)
# task3 (priority=3)
```

---

## 4. 高级特性

### 4.1 动态优先级调整

**问题:** Heap不支持直接修改元素优先级。

**解决方案1: Lazy Deletion + 版本号**

```python
class DynamicPriorityQueue:
    """
    支持动态优先级调整的优先级队列

    策略:使用版本号标记过期元素
    """

    def __init__(self):
        self.heap = []
        self.versions = {}  # item_id -> version
        self.counter = 0

    def push(self, item_id, priority):
        """插入或更新元素"""
        # 更新版本号
        if item_id not in self.versions:
            self.versions[item_id] = 0
        else:
            self.versions[item_id] += 1

        version = self.versions[item_id]

        # 插入新版本
        heapq.heappush(
            self.heap,
            (priority, self.counter, version, item_id)
        )
        self.counter += 1

    def pop(self):
        """删除并返回优先级最高的元素"""
        while self.heap:
            priority, _, version, item_id = heapq.heappop(self.heap)

            # 检查版本是否有效
            if version == self.versions[item_id]:
                return item_id

        raise IndexError("pop from empty priority queue")

    def update_priority(self, item_id, new_priority):
        """更新元素优先级"""
        self.push(item_id, new_priority)

# 使用示例
pq = DynamicPriorityQueue()
pq.push("task1", priority=2)
pq.push("task2", priority=1)

# 更新task1的优先级
pq.update_priority("task1", priority=0)

print(pq.pop())  # task1 (新优先级0)
print(pq.pop())  # task2 (优先级1)
```

**解决方案2: 重建Heap**

```python
def update_priority_rebuild(heap, item_id, new_priority):
    """
    通过重建heap更新优先级

    时间复杂度: O(n)
    适用场景: 更新不频繁
    """
    # 移除旧元素
    heap = [(p, i) for p, i in heap if i != item_id]

    # 添加新元素
    heap.append((new_priority, item_id))

    # 重建heap
    heapq.heapify(heap)

    return heap
```

### 4.2 Aging机制(防止饥饿)

```python
import time
import heapq

class AgingPriorityQueue:
    """
    带Aging机制的优先级队列

    特点:等待时间越长,优先级越高
    """

    def __init__(self, age_interval=10):
        """
        Args:
            age_interval: Aging间隔(秒)
        """
        self.heap = []
        self.age_interval = age_interval
        self.counter = 0

    def push(self, item, priority):
        """插入元素"""
        timestamp = time.time()
        heapq.heappush(
            self.heap,
            (priority, timestamp, self.counter, item)
        )
        self.counter += 1

    def pop(self):
        """删除并返回优先级最高的元素"""
        if not self.heap:
            raise IndexError("pop from empty priority queue")

        priority, timestamp, _, item = heapq.heappop(self.heap)
        return item

    def apply_aging(self):
        """
        应用Aging机制

        规则:每等待age_interval秒,优先级提升1级
        """
        current_time = time.time()
        aged_heap = []

        while self.heap:
            priority, timestamp, counter, item = heapq.heappop(self.heap)

            # 计算等待时间
            wait_time = current_time - timestamp

            # 计算优先级提升
            age_boost = int(wait_time / self.age_interval)
            new_priority = max(0, priority - age_boost)

            aged_heap.append((new_priority, timestamp, counter, item))

        # 重建heap
        self.heap = aged_heap
        heapq.heapify(self.heap)

# 使用示例
pq = AgingPriorityQueue(age_interval=10)
pq.push("low_priority_task", priority=3)
time.sleep(30)  # 等待30秒
pq.apply_aging()  # 优先级从3提升到0
```

### 4.3 多级优先级

```python
from enum import IntEnum
import heapq

class Priority(IntEnum):
    """多级优先级定义"""
    URGENT = 0
    HIGH = 1
    NORMAL = 2
    LOW = 3
    IDLE = 4

class MultiLevelPriorityQueue:
    """
    多级优先级队列

    特点:
    - 支持多个优先级级别
    - 相同优先级内FIFO
    - 支持优先级继承
    """

    def __init__(self):
        self.heap = []
        self.counter = 0

    def push(self, item, priority: Priority):
        """插入元素"""
        heapq.heappush(
            self.heap,
            (priority.value, self.counter, item)
        )
        self.counter += 1

    def pop(self):
        """删除并返回优先级最高的元素"""
        if not self.heap:
            raise IndexError("pop from empty priority queue")

        priority, _, item = heapq.heappop(self.heap)
        return item

    def promote(self, levels=1):
        """
        提升所有任务的优先级

        Args:
            levels: 提升级别数
        """
        promoted_heap = []

        while self.heap:
            priority, counter, item = heapq.heappop(self.heap)
            new_priority = max(0, priority - levels)
            promoted_heap.append((new_priority, counter, item))

        self.heap = promoted_heap
        heapq.heapify(self.heap)

# 使用示例
pq = MultiLevelPriorityQueue()
pq.push("user_query", Priority.URGENT)
pq.push("tool_call", Priority.HIGH)
pq.push("memory_update", Priority.NORMAL)
pq.push("logging", Priority.LOW)

while pq.heap:
    print(pq.pop())

# 输出:
# user_query
# tool_call
# memory_update
# logging
```

---

## 5. RAG应用场景

### 5.1 Top-K文档检索

```python
import heapq

class RAGRetriever:
    """
    RAG文档检索器

    使用优先级队列维护Top-K文档
    """

    def __init__(self, k=10):
        self.k = k
        self.heap = []  # Min-heap

    def add_document(self, doc_id, score):
        """
        添加文档

        Args:
            doc_id: 文档ID
            score: 相似度分数
        """
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, (score, doc_id))
        elif score > self.heap[0][0]:
            heapq.heapreplace(self.heap, (score, doc_id))

    def get_top_k(self):
        """返回Top-K文档(按分数降序)"""
        return sorted(self.heap, reverse=True)

    def retrieve(self, query_emb, doc_embs):
        """
        检索Top-K文档

        Args:
            query_emb: 查询向量
            doc_embs: [(doc_id, embedding), ...]

        Returns:
            Top-K文档列表
        """
        for doc_id, doc_emb in doc_embs:
            score = cosine_similarity(query_emb, doc_emb)
            self.add_document(doc_id, score)

        return self.get_top_k()

def cosine_similarity(a, b):
    """计算余弦相似度"""
    import numpy as np
    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))
```

### 5.2 AI Agent任务调度

```python
import heapq
from enum import IntEnum
from typing import Callable

class AgentPriority(IntEnum):
    USER_QUERY = 0
    TOOL_CALL = 1
    MEMORY_UPDATE = 2
    LOGGING = 3

class AgentTaskScheduler:
    """
    AI Agent任务调度器

    特点:
    - 多级优先级
    - FIFO(相同优先级)
    - Aging机制
    """

    def __init__(self):
        self.task_queue = []
        self.counter = 0

    def submit_task(self, priority: AgentPriority, task_id: str, action: Callable):
        """提交任务"""
        heapq.heappush(
            self.task_queue,
            (priority.value, self.counter, task_id, action)
        )
        self.counter += 1

    def execute_next(self):
        """执行下一个任务"""
        if not self.task_queue:
            return None

        priority, _, task_id, action = heapq.heappop(self.task_queue)
        print(f"Executing {task_id} (priority={priority})")
        return action()

    def execute_all(self):
        """执行所有任务"""
        while self.task_queue:
            self.execute_next()

# 使用示例
scheduler = AgentTaskScheduler()

scheduler.submit_task(
    AgentPriority.MEMORY_UPDATE,
    "update_memory",
    lambda: "Memory updated"
)

scheduler.submit_task(
    AgentPriority.USER_QUERY,
    "process_query",
    lambda: "Query processed"
)

scheduler.submit_task(
    AgentPriority.TOOL_CALL,
    "call_tool",
    lambda: "Tool executed"
)

scheduler.execute_all()

# 输出:
# Executing process_query (priority=0)
# Executing call_tool (priority=1)
# Executing update_memory (priority=2)
```

---

## 6. 性能优化

### 6.1 批量操作

```python
import heapq

def batch_push(heap, items):
    """
    批量插入

    优化:使用heapify而非逐个heappush
    """
    # 方法1:逐个插入 O(n log n)
    for item in items:
        heapq.heappush(heap, item)

    # 方法2:批量插入 O(n)
    heap.extend(items)
    heapq.heapify(heap)
```

### 6.2 减少比较次数

```python
# 使用元组的字典序比较
# 避免自定义__lt__方法

# ❌ 慢:自定义比较
class Task:
    def __init__(self, priority, name):
        self.priority = priority
        self.name = name

    def __lt__(self, other):
        return self.priority < other.priority

# ✅ 快:使用元组
task = (priority, counter, name)
```

### 6.3 内存优化

```python
# 使用__slots__减少内存占用
class Task:
    __slots__ = ['priority', 'name']

    def __init__(self, priority, name):
        self.priority = priority
        self.name = name
```

---

## 7. 常见陷阱

### 陷阱1: 忘记保证FIFO

```python
# ❌ 错误:相同优先级时顺序不确定
pq = []
heapq.heappush(pq, (1, "task1"))
heapq.heappush(pq, (1, "task2"))
heapq.heappush(pq, (1, "task3"))

# ✅ 正确:使用counter保证FIFO
pq = []
counter = 0
heapq.heappush(pq, (1, counter, "task1")); counter += 1
heapq.heappush(pq, (1, counter, "task2")); counter += 1
heapq.heappush(pq, (1, counter, "task3")); counter += 1
```

### 陷阱2: 线程安全问题

```python
# ❌ 错误:多线程使用heapq(不安全)
import heapq
import threading

pq = []

def producer():
    heapq.heappush(pq, 1)  # 竞态条件!

# ✅ 正确:使用queue.PriorityQueue
from queue import PriorityQueue

pq = PriorityQueue()

def producer():
    pq.put(1)  # 线程安全
```

### 陷阱3: 优先级方向混淆

```python
# ❌ 错误:期望数字越大优先级越高
pq = []
heapq.heappush(pq, (10, "high"))
heapq.heappush(pq, (1, "low"))
print(heapq.heappop(pq))  # (1, "low") - 数字小的先出!

# ✅ 正确:使用负值或明确定义
pq = []
heapq.heappush(pq, (-10, "high"))  # 负值
heapq.heappush(pq, (-1, "low"))
print(heapq.heappop(pq))  # (-10, "high")
```

---

## 8. 一句话总结

**优先级队列是支持按优先级访问元素的抽象数据类型,Heap是其最优实现(O(log n)插入删除,O(1)查看最值),Python提供heapq(单线程)和queue.PriorityQueue(多线程)两种实现,广泛应用于任务调度、图算法、RAG检索和AI Agent管理。**
