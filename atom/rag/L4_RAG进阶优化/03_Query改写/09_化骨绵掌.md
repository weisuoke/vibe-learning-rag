# 化骨绵掌

把 Query改写 拆成 10 个 2 分钟能看完的知识卡片，适合碎片化学习。

---

## 卡片1：Query改写是什么？

**一句话：** Query改写是将用户的原始查询转换为更适合检索的形式。

**举例：**
```
用户说: "代码跑不动了"
改写后: "程序运行错误 异常处理 调试方法"
```

**为什么需要？**
- 用户表达往往口语化、不完整
- 文档使用专业术语、完整句子
- 改写是"翻译官"，弥补两者的差距

**应用：** 在 RAG 系统中，Query改写放在检索之前，提升检索效果。

---

## 卡片2：语义鸿沟问题

**一句话：** 用户表达和文档表达之间存在"语义鸿沟"，这是 Query改写要解决的核心问题。

**三种鸿沟：**

| 类型 | 用户说 | 文档写 |
|------|-------|-------|
| 词汇差异 | "跑不动" | "运行异常" |
| 抽象层次 | "太慢" | "性能优化" |
| 完整度 | "咋异步" | "asyncio 异步编程" |

**应用：** 理解鸿沟类型，才能选择正确的改写策略。

---

## 卡片3：HyDE 核心思想

**一句话：** HyDE 让 LLM 先生成假设答案，用答案的 Embedding 去检索。

**核心洞察：** 用答案找答案，比用问题找答案更准确。

```python
# 传统：用问题检索
results = search(question)  # 问题和答案向量距离远

# HyDE：用假设答案检索
假设答案 = llm.generate(question)
results = search(假设答案)  # 答案和答案向量距离近
```

**类比：** 以图搜图——用参考图片找相似图片，比用文字描述更准确。

**应用：** 适合开放性问题，如"如何优化性能"、"最佳实践是什么"。

---

## 卡片4：HyDE 实现要点

**一句话：** HyDE 的假设答案要简洁聚焦，100 字左右最佳。

**代码模板：**
```python
def hyde(query: str) -> str:
    prompt = f"请简要回答（80-120字）：{query}"
    return llm.generate(prompt, temperature=0.5, max_tokens=150)
```

**注意事项：**
- ❌ 假设答案太长会引入噪音
- ❌ 对事实性问题可能生成错误信息
- ✅ 适合概念性、开放性问题

**应用：** 在 RAG 中，对"如何"、"怎么"类问题使用 HyDE。

---

## 卡片5：Multi-Query 核心思想

**一句话：** Multi-Query 生成原始查询的多个变体，并行检索后合并结果。

**举例：**
```
原始: "Python 性能优化"
变体1: "如何提升 Python 代码运行速度"
变体2: "Python 程序优化技巧"
变体3: "Python profiling 性能分析"
```

**为什么有效？**
- 不同表达方式可能匹配到不同文档
- 扩大搜索范围，提高召回率

**应用：** 适合模糊查询、多义查询，如"数据库优化"、"代码重构"。

---

## 卡片6：Multi-Query 实现要点

**一句话：** Multi-Query 要保留原始查询，变体要有多样性。

**代码模板：**
```python
def multi_query(query: str, n: int = 3) -> list[str]:
    prompt = f"将以下查询改写成 {n} 个不同版本：{query}"
    variants = llm.generate(prompt, temperature=0.8)  # 高温度增加多样性
    return [query] + variants[:n]  # 保留原始查询
```

**结果处理：**
```python
all_results = []
for q in queries:
    results = search(q)
    all_results.extend(results)
# 去重 + 融合排序
final = dedupe_and_rank(all_results)
```

**应用：** 多个检索可以并行执行，提高效率。

---

## 卡片7：Query Decomposition 核心思想

**一句话：** Query Decomposition 将复杂问题拆解为多个简单子问题。

**举例：**
```
复杂问题: "比较 Redis 和 Memcached 的优缺点"
    ↓
子问题1: "Redis 的主要优点是什么？"
子问题2: "Redis 的主要缺点是什么？"
子问题3: "Memcached 的主要优点是什么？"
子问题4: "Memcached 的主要缺点是什么？"
```

**为什么有效？**
- 复杂问题难以一次检索到完整答案
- 子问题更聚焦，检索更精准
- 综合子问题的答案，得到完整回答

**应用：** 适合比较类、多维度分析类问题。

---

## 卡片8：智能路由策略

**一句话：** 不是所有查询都需要改写，要根据查询类型选择策略。

**决策规则：**

| 查询特征 | 策略 |
|---------|------|
| 包含版本号、错误码 | 不改写 |
| 包含"比较"、"对比" | Decomposition |
| 包含"如何"、"怎么" | HyDE |
| 其他模糊查询 | Multi-Query |

**代码示例：**
```python
def classify(query):
    if has_version_or_error(query): return "exact"
    if has_compare_keywords(query): return "complex"
    if has_how_keywords(query): return "open"
    return "fuzzy"
```

**应用：** 实现智能路由，自动选择最佳改写策略。

---

## 卡片9：Query改写 vs ReRank

**一句话：** Query改写提高召回率，ReRank 提高准确率，两者互补。

**对比：**

| 维度 | Query改写 | ReRank |
|------|----------|--------|
| 位置 | 检索前 | 检索后 |
| 目标 | 找到更多相关文档 | 精选最相关文档 |
| 方法 | LLM 改写 | Cross-Encoder |

**类比：**
- Query改写 = 撒大网捕鱼
- ReRank = 挑选最好的鱼

**应用：** 两者配合使用，先扩大召回，再精细筛选。

---

## 卡片10：Query改写最佳实践

**一句话：** Query改写是锦上添花，基础检索系统要先做好。

**优化优先级：**
```
1. 基础检索系统（分块、Embedding、索引）
2. 检索策略（混合检索、ReRank）
3. Query改写（HyDE、Multi-Query）← 最后
```

**实践建议：**
- ✅ 精确查询不改写
- ✅ 假设答案要简洁
- ✅ 实现智能路由
- ✅ 监控改写延迟
- ❌ 不要过度依赖改写

**应用：** 在 RAG 系统优化中，Query改写是最后一步优化。

---

## 知识卡片总览

| 卡片 | 主题 | 核心要点 |
|------|------|---------|
| 1 | Query改写是什么 | 翻译官，弥补语义鸿沟 |
| 2 | 语义鸿沟问题 | 词汇、抽象、完整度三种差异 |
| 3 | HyDE 核心思想 | 用答案找答案 |
| 4 | HyDE 实现要点 | 简洁聚焦，100字最佳 |
| 5 | Multi-Query 核心思想 | 多变体并行检索 |
| 6 | Multi-Query 实现要点 | 保留原始，高温度多样性 |
| 7 | Query Decomposition | 拆解复杂问题 |
| 8 | 智能路由策略 | 根据查询类型选策略 |
| 9 | Query改写 vs ReRank | 召回率 vs 准确率 |
| 10 | 最佳实践 | 锦上添花，基础先行 |

---

**下一步：** [10_一句话总结](./10_一句话总结.md) - 用一句话总结 Query改写
