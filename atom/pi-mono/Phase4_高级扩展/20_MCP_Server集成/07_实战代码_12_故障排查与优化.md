# 实战代码 12：故障排查与优化

> **调试 MCP 集成问题，优化性能和可靠性**

---

## 概述

故障排查与优化是保证 MCP 集成稳定运行的关键。本文介绍调试技巧、性能优化策略和常见问题的解决方案。

```
故障排查与优化核心：
├─ 调试技巧 → MCP Inspector + 日志分析
├─ 性能优化 → 缓存 + 连接池 + 懒加载
├─ 常见问题 → 连接失败 + 超时 + 权限错误
└─ 监控告警 → 健康检查 + 指标收集
```

**本质**：故障排查与优化是通过系统化的方法识别和解决问题，提升 MCP 集成的性能和可靠性。

---

## 调试技巧

### MCP Inspector

```bash
# 安装 MCP Inspector
npm install -g @modelcontextprotocol/inspector

# 启动 Inspector 连接到服务器
npx @modelcontextprotocol/inspector \
  npx -y @modelcontextprotocol/server-filesystem /path/to/dir

# 使用 Docker 运行的服务器
npx @modelcontextprotocol/inspector \
  docker run -i --rm mcp/postgres
```

**Inspector 功能**：
- 查看服务器提供的工具列表
- 测试工具调用和参数
- 查看请求/响应消息
- 调试 JSON-RPC 通信

### 日志分析

```typescript
import type { ExtensionAPI } from '@mariozechner/pi-coding-agent';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';

export class DebugLogger {
  private logFile: string;

  constructor(logFile: string = '/tmp/mcp-debug.log') {
    this.logFile = logFile;
  }

  /**
   * 记录客户端事件
   */
  logClientEvent(event: string, data: any): void {
    const entry = {
      timestamp: new Date().toISOString(),
      type: 'client',
      event,
      data,
    };
    this.writeLog(entry);
  }

  /**
   * 记录服务器响应
   */
  logServerResponse(serverId: string, method: string, response: any): void {
    const entry = {
      timestamp: new Date().toISOString(),
      type: 'server',
      serverId,
      method,
      response,
    };
    this.writeLog(entry);
  }

  /**
   * 记录错误
   */
  logError(context: string, error: any): void {
    const entry = {
      timestamp: new Date().toISOString(),
      type: 'error',
      context,
      error: {
        message: error.message,
        stack: error.stack,
        code: error.code,
      },
    };
    this.writeLog(entry);
  }

  private writeLog(entry: any): void {
    const fs = require('fs');
    fs.appendFileSync(this.logFile, JSON.stringify(entry) + '\n');
  }
}

// 使用示例
const logger = new DebugLogger();

export default function (pi: ExtensionAPI) {
  let client: Client | null = null;

  pi.on('session_start', async (_event, ctx) => {
    logger.logClientEvent('session_start', { timestamp: Date.now() });

    try {
      client = new Client({
        name: 'debug-client',
        version: '1.0.0',
      });

      // 记录连接尝试
      logger.logClientEvent('connecting', { server: 'filesystem' });

      // ... 连接逻辑

      logger.logClientEvent('connected', { server: 'filesystem' });
    } catch (error) {
      logger.logError('session_start', error);
      throw error;
    }
  });
}
```

### 请求追踪

```typescript
export class RequestTracer {
  private traces = new Map<string, any>();

  /**
   * 开始追踪请求
   */
  startTrace(requestId: string, method: string, params: any): void {
    this.traces.set(requestId, {
      method,
      params,
      startTime: Date.now(),
      status: 'pending',
    });
  }

  /**
   * 结束追踪
   */
  endTrace(requestId: string, result: any): void {
    const trace = this.traces.get(requestId);
    if (trace) {
      trace.endTime = Date.now();
      trace.duration = trace.endTime - trace.startTime;
      trace.status = 'completed';
      trace.result = result;
    }
  }

  /**
   * 记录错误
   */
  traceError(requestId: string, error: any): void {
    const trace = this.traces.get(requestId);
    if (trace) {
      trace.endTime = Date.now();
      trace.duration = trace.endTime - trace.startTime;
      trace.status = 'error';
      trace.error = error;
    }
  }

  /**
   * 获取追踪信息
   */
  getTrace(requestId: string): any {
    return this.traces.get(requestId);
  }

  /**
   * 获取慢请求
   */
  getSlowRequests(threshold: number = 1000): any[] {
    return Array.from(this.traces.values())
      .filter(trace => trace.duration > threshold)
      .sort((a, b) => b.duration - a.duration);
  }
}
```

---

## 性能优化

### 缓存策略

```typescript
export class SmartCache {
  private cache = new Map<string, {
    data: any;
    timestamp: number;
    hits: number;
  }>();
  private readonly ttl: number;
  private readonly maxSize: number;

  constructor(ttl: number = 300000, maxSize: number = 1000) {
    this.ttl = ttl;
    this.maxSize = maxSize;
  }

  /**
   * 获取缓存（带统计）
   */
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) {
      return null;
    }

    // 检查过期
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    // 增加命中计数
    entry.hits++;
    return entry.data as T;
  }

  /**
   * 设置缓存（带 LRU 淘汰）
   */
  set(key: string, data: any): void {
    // 检查大小限制
    if (this.cache.size >= this.maxSize) {
      this.evictLRU();
    }

    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      hits: 0,
    });
  }

  /**
   * LRU 淘汰策略
   */
  private evictLRU(): void {
    let lruKey: string | null = null;
    let lruHits = Infinity;

    for (const [key, entry] of this.cache.entries()) {
      if (entry.hits < lruHits) {
        lruHits = entry.hits;
        lruKey = key;
      }
    }

    if (lruKey) {
      this.cache.delete(lruKey);
    }
  }

  /**
   * 获取缓存统计
   */
  getStats(): any {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      entries: Array.from(this.cache.entries()).map(([key, entry]) => ({
        key,
        age: Date.now() - entry.timestamp,
        hits: entry.hits,
      })),
    };
  }
}
```

### 连接池优化

```typescript
export class OptimizedConnectionPool {
  private connections: any[] = [];
  private available: any[] = [];
  private waiting: Array<(conn: any) => void> = [];
  private readonly minConnections: number;
  private readonly maxConnections: number;
  private readonly idleTimeout: number;

  constructor(
    minConnections: number = 2,
    maxConnections: number = 10,
    idleTimeout: number = 60000
  ) {
    this.minConnections = minConnections;
    this.maxConnections = maxConnections;
    this.idleTimeout = idleTimeout;
  }

  /**
   * 初始化最小连接数
   */
  async initialize(): Promise<void> {
    for (let i = 0; i < this.minConnections; i++) {
      const conn = await this.createConnection();
      this.connections.push(conn);
      this.available.push(conn);
    }

    // 启动空闲连接清理
    this.startIdleCleanup();
  }

  /**
   * 获取连接（带超时）
   */
  async acquire(timeout: number = 5000): Promise<any> {
    // 如果有可用连接，直接返回
    if (this.available.length > 0) {
      return this.available.pop();
    }

    // 如果未达到最大连接数，创建新连接
    if (this.connections.length < this.maxConnections) {
      const conn = await this.createConnection();
      this.connections.push(conn);
      return conn;
    }

    // 等待可用连接
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        const index = this.waiting.indexOf(resolve);
        if (index > -1) {
          this.waiting.splice(index, 1);
        }
        reject(new Error('Connection acquire timeout'));
      }, timeout);

      this.waiting.push((conn) => {
        clearTimeout(timer);
        resolve(conn);
      });
    });
  }

  /**
   * 释放连接
   */
  release(connection: any): void {
    // 如果有等待的请求，直接分配
    if (this.waiting.length > 0) {
      const resolve = this.waiting.shift()!;
      resolve(connection);
      return;
    }

    // 否则放回可用池
    this.available.push(connection);
  }

  /**
   * 清理空闲连接
   */
  private startIdleCleanup(): void {
    setInterval(() => {
      const now = Date.now();
      const excess = this.available.length - this.minConnections;

      if (excess > 0) {
        for (let i = 0; i < excess; i++) {
          const conn = this.available.pop();
          if (conn) {
            this.closeConnection(conn);
            const index = this.connections.indexOf(conn);
            if (index > -1) {
              this.connections.splice(index, 1);
            }
          }
        }
      }
    }, this.idleTimeout);
  }

  private async createConnection(): Promise<any> {
    // 创建连接逻辑
    return {};
  }

  private async closeConnection(connection: any): Promise<void> {
    // 关闭连接逻辑
  }
}
```

### 懒加载优化

```typescript
export class LazyServerLoader {
  private servers = new Map<string, {
    client: Client | null;
    config: any;
    loaded: boolean;
  }>();

  /**
   * 注册服务器（不立即加载）
   */
  registerServer(id: string, config: any): void {
    this.servers.set(id, {
      client: null,
      config,
      loaded: false,
    });
  }

  /**
   * 按需加载服务器
   */
  async loadServer(id: string): Promise<Client> {
    const server = this.servers.get(id);
    if (!server) {
      throw new Error(`Server not found: ${id}`);
    }

    // 如果已加载，直接返回
    if (server.loaded && server.client) {
      return server.client;
    }

    // 加载服务器
    const client = new Client({
      name: `${id}-client`,
      version: '1.0.0',
    });

    const transport = new StdioClientTransport({
      command: server.config.command,
      args: server.config.args,
      env: server.config.env,
    });

    await client.connect(transport);

    server.client = client;
    server.loaded = true;

    return client;
  }

  /**
   * 卸载服务器
   */
  async unloadServer(id: string): Promise<void> {
    const server = this.servers.get(id);
    if (server && server.client) {
      await server.client.close();
      server.client = null;
      server.loaded = false;
    }
  }
}
```

---

## 常见问题

### 连接失败

**问题**：无法连接到 MCP 服务器

**原因**：
1. 服务器命令路径错误
2. 环境变量未设置
3. 端口被占用
4. 权限不足

**解决方案**：

```typescript
async function diagnoseConnection(config: any): Promise<void> {
  console.log('Diagnosing connection...');

  // 1. 检查命令是否存在
  try {
    const { execSync } = require('child_process');
    execSync(`which ${config.command}`);
    console.log('✓ Command found:', config.command);
  } catch (error) {
    console.error('✗ Command not found:', config.command);
    console.error('  Try: npm install -g', config.args[1]);
    return;
  }

  // 2. 检查环境变量
  for (const [key, value] of Object.entries(config.env || {})) {
    if (!process.env[key]) {
      console.error(`✗ Environment variable not set: ${key}`);
      console.error(`  Set it in .env: ${key}=${value}`);
    } else {
      console.log(`✓ Environment variable set: ${key}`);
    }
  }

  // 3. 尝试连接
  try {
    const client = new Client({ name: 'test', version: '1.0.0' });
    const transport = new StdioClientTransport({
      command: config.command,
      args: config.args,
      env: config.env,
    });

    await client.connect(transport);
    console.log('✓ Connection successful');

    const tools = await client.listTools();
    console.log(`✓ Server provides ${tools.tools.length} tools`);

    await client.close();
  } catch (error) {
    console.error('✗ Connection failed:', error);
  }
}
```

### 超时问题

**问题**：工具调用超时

**原因**：
1. 服务器响应慢
2. 网络延迟
3. 超时设置过短

**解决方案**：

```typescript
export class TimeoutManager {
  /**
   * 带超时的工具调用
   */
  async callToolWithTimeout(
    client: Client,
    toolName: string,
    args: any,
    timeout: number = 30000
  ): Promise<any> {
    return Promise.race([
      client.callTool({ name: toolName, arguments: args }),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Tool call timeout')), timeout)
      ),
    ]);
  }

  /**
   * 带重试的工具调用
   */
  async callToolWithRetry(
    client: Client,
    toolName: string,
    args: any,
    maxRetries: number = 3,
    timeout: number = 30000
  ): Promise<any> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await this.callToolWithTimeout(client, toolName, args, timeout);
      } catch (error) {
        lastError = error as Error;
        console.error(`Attempt ${attempt + 1} failed:`, error);

        if (attempt < maxRetries - 1) {
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }
}
```

### 权限错误

**问题**：文件或目录访问被拒绝

**原因**：
1. 文件权限不足
2. 目录不存在
3. 路径配置错误

**解决方案**：

```typescript
async function checkPermissions(path: string): Promise<void> {
  const fs = require('fs').promises;

  try {
    // 检查路径是否存在
    await fs.access(path);
    console.log('✓ Path exists:', path);

    // 检查读权限
    await fs.access(path, fs.constants.R_OK);
    console.log('✓ Read permission granted');

    // 检查写权限
    try {
      await fs.access(path, fs.constants.W_OK);
      console.log('✓ Write permission granted');
    } catch (error) {
      console.warn('⚠ Write permission denied');
      console.warn('  Run: chmod +w', path);
    }
  } catch (error) {
    console.error('✗ Path does not exist or no permission:', path);
    console.error('  Check path and permissions');
  }
}
```

### 内存泄漏

**问题**：内存使用持续增长

**原因**：
1. 连接未关闭
2. 缓存无限增长
3. 事件监听器未移除

**解决方案**：

```typescript
export class ResourceManager {
  private resources = new Set<any>();

  /**
   * 注册资源
   */
  register(resource: any): void {
    this.resources.add(resource);
  }

  /**
   * 清理所有资源
   */
  async cleanup(): Promise<void> {
    for (const resource of this.resources) {
      try {
        if (resource.close) {
          await resource.close();
        } else if (resource.disconnect) {
          await resource.disconnect();
        }
      } catch (error) {
        console.error('Cleanup error:', error);
      }
    }
    this.resources.clear();
  }
}

// 使用示例
const resourceManager = new ResourceManager();

process.on('SIGINT', async () => {
  await resourceManager.cleanup();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  await resourceManager.cleanup();
  process.exit(0);
});
```

---

## 监控告警

### 健康检查

```typescript
export class HealthMonitor {
  private checks = new Map<string, () => Promise<boolean>>();

  /**
   * 注册健康检查
   */
  registerCheck(name: string, check: () => Promise<boolean>): void {
    this.checks.set(name, check);
  }

  /**
   * 执行所有检查
   */
  async runChecks(): Promise<Map<string, boolean>> {
    const results = new Map<string, boolean>();

    for (const [name, check] of this.checks.entries()) {
      try {
        const result = await check();
        results.set(name, result);
      } catch (error) {
        console.error(`Health check failed: ${name}`, error);
        results.set(name, false);
      }
    }

    return results;
  }

  /**
   * 获取健康状态
   */
  async getHealthStatus(): Promise<{
    healthy: boolean;
    checks: Record<string, boolean>;
  }> {
    const results = await this.runChecks();
    const checks: Record<string, boolean> = {};

    for (const [name, result] of results.entries()) {
      checks[name] = result;
    }

    const healthy = Array.from(results.values()).every(r => r);

    return { healthy, checks };
  }
}

// 使用示例
const monitor = new HealthMonitor();

monitor.registerCheck('filesystem', async () => {
  const client = clients.get('filesystem');
  if (!client) return false;

  try {
    await client.listTools();
    return true;
  } catch (error) {
    return false;
  }
});

// 定期检查
setInterval(async () => {
  const status = await monitor.getHealthStatus();
  if (!status.healthy) {
    console.error('Health check failed:', status.checks);
  }
}, 60000);
```

---

## 总结

### 核心要点

1. **调试技巧**：MCP Inspector + 日志分析 + 请求追踪
2. **性能优化**：智能缓存 + 连接池 + 懒加载
3. **常见问题**：连接失败 + 超时 + 权限错误 + 内存泄漏
4. **监控告警**：健康检查 + 指标收集
5. **最佳实践**：资源管理 + 优雅关闭

### 关键约束

- ✅ 使用 MCP Inspector 调试
- ✅ 实现完整的日志系统
- ✅ 添加超时和重试机制
- ✅ 定期健康检查
- ✅ 优雅的资源清理

---

**参考资源**：
- [MCP Inspector](https://github.com/modelcontextprotocol/inspector)
- [MCP Servers Repository](https://github.com/modelcontextprotocol/servers)
- [The Best MCP Servers for Developers in 2026](https://www.builder.io/blog/best-mcp-servers-2026)
