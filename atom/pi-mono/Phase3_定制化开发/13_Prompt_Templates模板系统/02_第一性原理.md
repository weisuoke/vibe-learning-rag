# 第一性原理

## 从根本问题出发

### 问题 1：为什么需要 Prompt Templates？

**根本问题：** 提示词的重复性和维护性问题。

在 AI Agent 开发中，我们会遇到以下场景：

1. **重复编写相似的提示词**
   ```typescript
   // 场景 1：代码审查
   const prompt1 = `请审查这个 PR: ${prUrl}，分析代码质量、潜在问题和改进建议`;

   // 场景 2：代码审查（另一个项目）
   const prompt2 = `请审查这个 PR: ${prUrl}，分析代码质量、潜在问题和改进建议`;

   // 场景 3：代码审查（团队成员）
   const prompt3 = `请审查这个 PR: ${prUrl}，分析代码质量、潜在问题和改进建议`;
   ```

   **问题：**
   - 每次都要重新编写
   - 容易出现不一致
   - 难以维护和更新
   - 无法共享最佳实践

2. **提示词的版本控制困难**
   ```typescript
   // 硬编码在代码中
   const prompt = `请审查这个 PR...`;

   // 如果要修改提示词，需要：
   // 1. 修改代码
   // 2. 重新部署
   // 3. 无法追踪历史版本
   // 4. 无法回滚到之前的版本
   ```

3. **团队协作的挑战**
   ```typescript
   // 开发者 A 的提示词
   const promptA = `请审查这个 PR，关注性能问题`;

   // 开发者 B 的提示词
   const promptB = `请审查这个 PR，关注安全问题`;

   // 开发者 C 的提示词
   const promptC = `请审查这个 PR，关注代码风格`;

   // 问题：
   // - 每个人都有自己的版本
   // - 无法统一标准
   // - 新人不知道用哪个
   // - 最佳实践无法传播
   ```

**第一性原理推导：**

从这些问题出发，我们需要一个系统来：
1. **复用提示词** - 避免重复编写
2. **版本控制** - 追踪历史和回滚
3. **团队协作** - 共享最佳实践
4. **易于维护** - 集中管理和更新

这就是 Prompt Templates 存在的根本原因。

---

### 问题 2：为什么选择 Markdown + YAML frontmatter？

**根本问题：** 提示词的格式和元数据管理。

**选项分析：**

1. **纯文本文件**
   ```
   请审查这个 PR: $1
   ```
   - ✅ 简单
   - ❌ 无法存储元数据（描述、作者、版本等）
   - ❌ 无法结构化

2. **JSON 文件**
   ```json
   {
     "description": "Review PRs",
     "content": "请审查这个 PR: $1"
   }
   ```
   - ✅ 结构化
   - ✅ 可以存储元数据
   - ❌ 不适合长文本（需要转义换行符）
   - ❌ 不易于人类阅读和编辑

3. **YAML 文件**
   ```yaml
   description: Review PRs
   content: |
     请审查这个 PR: $1
   ```
   - ✅ 结构化
   - ✅ 可以存储元数据
   - ✅ 支持多行文本
   - ❌ 缩进敏感，容易出错

4. **Markdown + YAML frontmatter**
   ```markdown
   ---
   description: Review PRs
   ---
   请审查这个 PR: $1
   ```
   - ✅ 结构化（frontmatter）
   - ✅ 可以存储元数据
   - ✅ 支持多行文本
   - ✅ Markdown 格式，易于阅读和编辑
   - ✅ 支持富文本格式（代码块、列表等）
   - ✅ 开发者熟悉（Git commit、Jekyll、Hugo）

**第一性原理推导：**

Markdown + YAML frontmatter 是最优选择，因为：
1. **人类可读** - Markdown 是最易读的标记语言
2. **机器可解析** - YAML frontmatter 提供结构化元数据
3. **开发者熟悉** - 无需学习新格式
4. **工具支持** - 所有编辑器都支持 Markdown
5. **版本控制友好** - 纯文本，Git diff 清晰

---

### 问题 3：为什么选择 Bash 风格变量替换？

**根本问题：** 变量插值的语法选择。

**选项分析：**

1. **Handlebars/Mustache 风格：`{{variable}}`**
   ```markdown
   请审查这个 PR: {{prUrl}}
   ```
   - ✅ 清晰易读
   - ❌ 需要学习新语法
   - ❌ 不支持位置参数
   - ❌ 不支持参数切片

2. **Python 风格：`{variable}` 或 `f"{variable}"`**
   ```markdown
   请审查这个 PR: {prUrl}
   ```
   - ✅ 简洁
   - ❌ 需要命名参数
   - ❌ 不支持位置参数
   - ❌ 不支持参数切片

3. **Bash 风格：`$1`, `$@`, `${@:N}`**
   ```markdown
   请审查这个 PR: $1
   所有 PR: $@
   从第 2 个开始: ${@:2}
   ```
   - ✅ 开发者熟悉（Shell 脚本）
   - ✅ 支持位置参数
   - ✅ 支持所有参数 (`$@`)
   - ✅ 支持参数切片 (`${@:N:L}`)
   - ✅ 无需命名参数
   - ✅ 适合命令行调用

**第一性原理推导：**

Bash 风格是最优选择，因为：
1. **开发者熟悉** - 所有开发者都会 Shell 脚本
2. **命令行友好** - 适合 CLI 工具的调用方式
3. **灵活性** - 支持位置参数、所有参数、参数切片
4. **零学习成本** - 无需学习新语法
5. **符合 Unix 哲学** - 简单、可组合

---

### 问题 4：为什么选择文件系统加载？

**根本问题：** 模板的存储和加载机制。

**选项分析：**

1. **数据库存储**
   ```typescript
   const template = await db.templates.findOne({ name: 'pr' });
   ```
   - ✅ 结构化查询
   - ❌ 需要数据库
   - ❌ 需要额外配置
   - ❌ 不易于版本控制
   - ❌ 不易于团队协作

2. **API 服务**
   ```typescript
   const template = await fetch('/api/templates/pr');
   ```
   - ✅ 集中管理
   - ❌ 需要网络连接
   - ❌ 需要额外服务
   - ❌ 增加复杂度
   - ❌ 不适合本地开发

3. **代码中定义**
   ```typescript
   const templates = {
     pr: 'Please review this PR: $1'
   };
   ```
   - ✅ 简单
   - ❌ 需要重新编译
   - ❌ 不易于非开发者编辑
   - ❌ 难以动态更新

4. **文件系统**
   ```
   ~/.pi/agent/prompts/pr.md
   ./.pi/prompts/pr.md
   ```
   - ✅ 零配置
   - ✅ 易于编辑（任何文本编辑器）
   - ✅ 易于版本控制（Git）
   - ✅ 易于团队协作（Git）
   - ✅ 支持多源加载（全局 + 项目）
   - ✅ 无需额外依赖

**第一性原理推导：**

文件系统是最优选择，因为：
1. **零配置** - 放文件就能用
2. **零依赖** - 不需要数据库或服务
3. **版本控制友好** - Git 原生支持
4. **团队协作友好** - Git 工作流
5. **易于编辑** - 任何文本编辑器
6. **符合 Unix 哲学** - 一切皆文件

---

### 问题 5：为什么选择 `/template-name args` 调用方式？

**根本问题：** 模板的调用接口设计。

**选项分析：**

1. **编程 API**
   ```typescript
   await agent.useTemplate('pr', { prUrl: 'https://...' });
   ```
   - ✅ 类型安全
   - ❌ 需要编程
   - ❌ 不适合交互式使用
   - ❌ 增加学习成本

2. **配置文件**
   ```json
   {
     "template": "pr",
     "args": ["https://..."]
   }
   ```
   - ✅ 结构化
   - ❌ 需要编辑配置文件
   - ❌ 不适合交互式使用
   - ❌ 繁琐

3. **命令行风格**
   ```bash
   /pr https://github.com/user/repo/pull/123
   ```
   - ✅ 简洁
   - ✅ 适合交互式使用
   - ✅ 符合 CLI 工具习惯
   - ✅ 易于记忆
   - ✅ 支持参数传递

**第一性原理推导：**

命令行风格是最优选择，因为：
1. **简洁** - 一行命令完成调用
2. **交互式友好** - 适合 CLI 工具
3. **符合习惯** - 类似 Shell 命令
4. **易于记忆** - `/` 前缀表示模板
5. **灵活** - 支持任意数量的参数

---

## 推理链：从问题到解决方案

### 推理步骤 1：识别核心问题

**问题：** 提示词的重复性、维护性、协作性。

**分析：**
- 提示词是 AI Agent 的核心
- 好的提示词需要反复迭代
- 团队需要共享最佳实践
- 提示词需要版本控制

**结论：** 需要一个模板系统。

---

### 推理步骤 2：确定设计约束

**约束 1：极简主义**
- Pi-mono 的核心理念是极简
- 不能引入复杂的依赖
- 不能增加学习成本

**约束 2：开发者友好**
- 目标用户是开发者
- 应该使用开发者熟悉的工具和格式
- 应该符合开发者的工作流

**约束 3：可扩展性**
- 应该支持个人和团队使用
- 应该支持全局和项目级别
- 应该支持自定义扩展

---

### 推理步骤 3：选择技术方案

**格式选择：** Markdown + YAML frontmatter
- 理由：人类可读 + 机器可解析 + 开发者熟悉

**变量语法：** Bash 风格
- 理由：开发者熟悉 + 命令行友好 + 灵活性

**存储方式：** 文件系统
- 理由：零配置 + 版本控制友好 + 团队协作友好

**调用方式：** 命令行风格
- 理由：简洁 + 交互式友好 + 符合习惯

---

### 推理步骤 4：验证设计

**验证 1：是否解决了核心问题？**
- ✅ 复用性：模板可以多次使用
- ✅ 维护性：集中管理，易于更新
- ✅ 协作性：Git 版本控制，团队共享

**验证 2：是否符合设计约束？**
- ✅ 极简主义：零依赖，零配置
- ✅ 开发者友好：熟悉的格式和语法
- ✅ 可扩展性：支持全局和项目级别

**验证 3：是否有更好的方案？**
- 考虑了数据库、API、代码定义等方案
- 文件系统方案在极简性、易用性、协作性上最优
- 没有发现更好的方案

---

## 核心洞察

### 洞察 1：极简主义的力量

**Pi-mono 的 Prompt Templates 没有发明任何新东西，而是巧妙地组合了已有的标准：**

- Markdown（1994 年）
- YAML（2001 年）
- Bash 变量替换（1979 年）
- 文件系统（1960 年代）

**这就是极简主义的力量：不是创造新的复杂性，而是消除不必要的复杂性。**

---

### 洞察 2：约束即自由

**通过选择简单的技术方案，Pi-mono 获得了更大的自由：**

1. **零依赖** - 不需要数据库、不需要服务、不需要框架
2. **零配置** - 放文件就能用
3. **零学习成本** - 开发者已经会了
4. **无限扩展** - 可以用任何文本编辑器、任何版本控制系统、任何协作工具

**这就是"约束即自由"的体现：通过限制选择，获得更大的灵活性。**

---

### 洞察 3：工具应该适应人，而不是人适应工具

**Pi-mono 的设计哲学：**

- 使用开发者已经熟悉的格式（Markdown、YAML、Bash）
- 使用开发者已经使用的工具（文本编辑器、Git）
- 使用开发者已经习惯的工作流（文件系统、命令行）

**这就是"工具适应人"的体现：不是让开发者学习新的工具，而是让工具适应开发者的习惯。**

---

## 2025-2026 年的验证

### 行业趋势验证

根据 2025-2026 年的实际应用，Pi-mono 的设计选择得到了广泛验证：

1. **[Awesome AI System Prompts](https://github.com/dontriskit/awesome-ai-system-prompts)**
   - 所有提示都以 Markdown 格式存储
   - 使用 Git 进行版本控制
   - 证明了 Markdown + Git 的可行性

2. **[Reddit: LLM 真实系统提示 Markdown 结构化](https://www.reddit.com/r/PromptEngineering/comments/1pseks9/for_people_building_real_systems_with_llms_how_do/)**
   - 社区推荐将复杂提示视为 Markdown 数据
   - 支持变量插值、版本控制和可重用模板迭代
   - 证明了 Markdown 模板的实用性

3. **[Twitter/X: 2026 AI 项目工作流与提示模板](https://x.com/Motion_Viz/status/2006373779669434790)**
   - 完整 AI 工作流包括 Claude Code 系统提示模板
   - 证明了模板系统在实际项目中的价值

### 社区实践验证

1. **[Reddit: 大型代理提示存储与模板变量](https://www.reddit.com/r/PromptEngineering/comments/1n3ybtu/how_are_you_storing_and_managing_larger_prompts/)**
   - 推荐使用 Markdown 模板 + 变量插值
   - 强调版本控制和模块化设计
   - 证明了文件系统存储的优势

2. **[Reddit: 生产环境演化提示模板管理](https://www.reddit.com/r/PromptEngineering/comments/1nwynw5/how_do_you_manage_dozens_of_evolving_prompts_in/)**
   - 在 Markdown 代码块中管理提示模板
   - 通过变量参数实现数十个可重用提示维护
   - 证明了模板系统的可扩展性

---

## 总结

**Pi-mono 的 Prompt Templates 是第一性原理思维的完美体现：**

1. **从根本问题出发** - 提示词的重复性、维护性、协作性
2. **识别核心约束** - 极简主义、开发者友好、可扩展性
3. **选择最优方案** - Markdown + YAML + Bash + 文件系统
4. **验证设计** - 解决问题、符合约束、无更好方案
5. **持续验证** - 2025-2026 年的实践证明了设计的正确性

**这不是技术创新，而是工程智慧：用最简单的方式解决最核心的问题。**

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
