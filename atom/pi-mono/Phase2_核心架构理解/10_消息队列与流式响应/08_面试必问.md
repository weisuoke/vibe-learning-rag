# 面试必问

## 问题 1："解释一下消息队列在 AI Agent 中的作用"

### 普通回答（❌ 不出彩）：

"消息队列用来管理消息，按顺序处理用户输入和工具调用。"

### 出彩回答（✅ 推荐）：

> **消息队列在 AI Agent 中有三层作用：**
>
> **1. 异步协调层**：AI Agent 需要处理多个异步消息源（用户输入、LLM 响应、工具调用结果），消息队列作为中间层统一管理，解决了异步消息的协调问题。
>
> **2. 优先级控制层**：不是所有消息都同等重要。Steering 消息（用户中断）需要最高优先级立即处理，User 消息次之，Tool results 最后。优先级队列确保重要消息优先处理。
>
> **3. 性能优化层**：通过批处理机制，独立的工具调用可以并行执行，显著提升性能。例如，3 个独立的文件读取操作可以从顺序执行的 3 秒减少到并行执行的 1 秒。
>
> **与传统 Web 服务器的区别**：Web 服务器的请求队列主要解决并发问题，而 AI Agent 的消息队列还需要支持中断（Steering）、追问（Follow-up）和批处理优化，是更复杂的异步消息管理系统。
>
> **在实际工作中的应用**：在 pi-mono 中，消息队列配合流式响应，实现了用户按 Enter 键立即中断当前响应，按 Alt+Enter 键追加消息等待完成的交互模式，这是 2025-2026 多轮对话 Agent 的标准设计模式。

### 为什么这个回答出彩？

1. ✅ **多层次解释**：从异步协调、优先级控制、性能优化三个层面解释
2. ✅ **具体例子**：给出了批处理的性能提升数据（3s → 1s）
3. ✅ **对比说明**：与传统 Web 服务器对比，突出 AI Agent 的特殊性
4. ✅ **实际应用**：联系 pi-mono 的实际实现和 2025-2026 标准
5. ✅ **展示深度**：不仅说"是什么"，还说"为什么"和"怎么用"

---

## 问题 2："流式响应和非流式响应有什么区别？为什么 AI Agent 需要流式响应？"

### 普通回答（❌ 不出彩）：

"流式响应是逐字显示，非流式响应是一次性显示。流式响应用户体验更好。"

### 出彩回答（✅ 推荐）：

> **流式响应和非流式响应的核心区别在于数据传输和用户感知：**
>
> **1. 技术层面**：
> - **非流式**：等待 LLM 生成完整响应（10-30 秒）→ 一次性返回 → 用户看到结果
> - **流式**：LLM 边生成边传输 → 用户立即看到第一个字 → 逐字显示
>
> **2. 用户感知层面**：
> - **非流式**：用户感知延迟 = 总生成时间（30 秒）
> - **流式**：用户感知延迟 = 0 秒（立即开始显示）
> - 即使总时间相同，流式响应让用户感觉更快
>
> **3. AI Agent 需要流式响应的三个原因**：
>
> **原因 1：降低感知延迟**
> LLM 生成长文本可能需要 30 秒，非流式响应让用户焦虑等待，流式响应立即开始显示，用户感觉更快。
>
> **原因 2：可中断性**
> 流式响应允许用户在生成过程中中断（Steering message）。如果 Agent 走错方向，用户可以立即按 Enter 键中断，而不需要等待完整响应生成完毕。
>
> **原因 3：资源优化**
> 流式响应边生成边传输，不需要在内存中缓存完整响应，减少内存占用。对于生成长文本（如代码、文档）的场景，这一点尤为重要。
>
> **实现方式**：通过 SSE (Server-Sent Events) 或 WebSocket 实现。SSE 适合单向流式传输（Agent → User），WebSocket 适合双向实时交互（Web UI）。
>
> **2025-2026 标准**：根据 MCP 可恢复流提案，流式响应还支持断点恢复，允许连接断开后从断点继续，这对长运行任务尤为重要。

### 为什么这个回答出彩？

1. ✅ **多层次解释**：从技术、用户感知、实际需求三个层面解释
2. ✅ **量化数据**：给出了具体的时间数据（30 秒 vs 0 秒感知延迟）
3. ✅ **三个原因**：系统性地解释为什么 AI Agent 需要流式响应
4. ✅ **实现细节**：提到了 SSE 和 WebSocket 的选择
5. ✅ **前沿知识**：引用 2025-2026 MCP 可恢复流提案，展示对最新技术的了解

---

**版本**: v1.0
**最后更新**: 2026-02-19
**维护者**: Claude Code
