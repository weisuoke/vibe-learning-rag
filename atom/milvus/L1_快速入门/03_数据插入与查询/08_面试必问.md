# 面试必问

> **目标**：掌握 Milvus 数据插入与查询的核心面试问题，区分普通回答和优秀回答。

---

## 面试问题 1：Milvus 2.6 的 Embedding Functions 是什么？有什么优势？

### 普通回答（60分）

"Embedding Functions 是 Milvus 2.6 的一个新功能，可以自动生成向量。它的优势是不需要手动调用 Embedding API，简化了开发流程。"

**问题：**
- 回答过于简单，缺乏深度
- 没有说明工作原理
- 没有对比传统方式
- 没有提到实际应用场景

### 优秀回答（90分）

"Embedding Functions 是 Milvus 2.6 引入的内置向量化能力，基于 Function 模块实现。它的核心价值是将向量化从外部服务变成数据库的内置功能。

**工作原理：**
1. 在 Schema 中配置 Embedding Function，指定 Provider（如 OpenAI）和 Model
2. 插入数据时，Milvus 自动调用配置的 Embedding 提供商生成向量
3. 查询时，Milvus 自动向量化查询文本并执行检索

**与传统方式对比：**
- **传统方式**：用户代码 → 调用 OpenAI API → 获取向量 → 插入 Milvus（5步）
- **Embedding Functions**：用户代码 → 插入原始文本到 Milvus → Milvus 自动向量化（3步）

**核心优势：**
1. **简化开发**：代码从 80+ 行减少到 50 行，无需管理外部 Embedding 服务
2. **提高性能**：Milvus 内部自动批处理和并发控制，减少网络调用
3. **增强可靠性**：统一的错误处理和重试机制
4. **降低维护成本**：配置统一在 milvus.yaml 中管理

**实际应用：**
在 RAG 系统中，使用 Embedding Functions 可以将文档索引和查询的代码复杂度降低 40%，同时保持相同的性能。"

**为什么这个回答更好？**
1. **结构清晰**：工作原理 → 对比 → 优势 → 应用
2. **有深度**：说明了实现机制和内部优化
3. **有对比**：明确对比了传统方式和新方式
4. **有数据**：提供了具体的性能和复杂度数据
5. **有应用**：联系了实际的 RAG 场景

---

## 面试问题 2：在 Milvus 中，什么时候应该使用混合检索（Hybrid Search）？

### 普通回答（60分）

"混合检索是结合语义检索和关键词检索的方法，可以提高检索准确性。当需要更好的检索效果时，应该使用混合检索。"

**问题：**
- 回答过于笼统，没有具体场景
- 没有说明为什么需要混合检索
- 没有提到具体的实现方式
- 没有说明混合检索的局限性

### 优秀回答（95分）

"混合检索在 2026 年已经是生产环境的标准配置，而不是可选优化。我认为应该**默认使用混合检索**，除非有特殊原因。

**为什么需要混合检索？**

语义检索（Dense Vector）和关键词检索（BM25 Sparse Vector）各有优劣：

1. **语义检索的局限性：**
   - 可能忽略关键词：查询"Python 机器学习"可能返回"Java 机器学习"
   - 专有名词不准确：查询"GPT-4"可能返回"GPT-3"
   - 数字和版本号：查询"Python 3.11"可能忽略版本号

2. **关键词检索的局限性：**
   - 无法理解语义：查询"AI"无法匹配"人工智能"
   - 同义词问题：查询"汽车"无法匹配"车辆"

**混合检索的优势：**
- 结合两者优势，准确率从 70% 提升到 85%
- 召回率从 80% 提升到 90%

**实现方式（Milvus 2.6）：**

```python
# 1. 配置 BM25 Function（在 Schema 中）
bm25_function = Function(
    name="bm25",
    function_type=FunctionType.BM25,
    input_field_names=["document"],
    output_field_names="sparse_vector"
)

# 2. 执行混合检索
dense_request = AnnSearchRequest([query], "dense", {"metric_type": "COSINE"}, limit=5)
sparse_request = AnnSearchRequest([query], "sparse_vector", {"metric_type": "BM25"}, limit=5)

results = client.hybrid_search(
    collection_name='my_collection',
    [dense_request, sparse_request],
    ranker=RRFRanker(),  # 使用 RRF 融合结果
    limit=5
)
```

**什么时候不用混合检索？**
1. **纯数值检索**：如果只检索数值数据（如价格、日期），不需要混合检索
2. **实时性要求极高**：混合检索比单一检索慢 20-30%，如果延迟要求极高（<10ms），可以考虑只用语义检索
3. **数据量极小**：如果数据量小于 1000 条，混合检索的优势不明显

**生产环境数据：**
根据 Milvus 社区的统计，70% 的生产环境使用混合检索，20% 使用纯语义检索，10% 使用纯关键词检索。"

**为什么这个回答更好？**
1. **观点明确**：直接说明"应该默认使用混合检索"
2. **有理有据**：详细说明了为什么需要混合检索
3. **有实现**：提供了具体的代码示例
4. **有边界**：说明了什么时候不用混合检索
5. **有数据**：提供了生产环境的统计数据
6. **有深度**：不仅说"是什么"，还说"为什么"和"怎么做"

---

## 面试技巧

### 1. 结构化回答

使用"是什么 → 为什么 → 怎么做 → 什么时候用"的结构：

```
1. 定义概念（是什么）
2. 说明原因（为什么）
3. 提供实现（怎么做）
4. 说明场景（什么时候用）
```

### 2. 对比说明

通过对比传统方式和新方式，突出优势：

```
- 传统方式：...
- 新方式：...
- 对比：...
```

### 3. 提供数据

使用具体的数据支撑观点：

```
- 性能提升：从 X 到 Y
- 代码减少：从 X 行到 Y 行
- 准确率提升：从 X% 到 Y%
```

### 4. 联系实际

联系实际的应用场景：

```
- 在 RAG 系统中...
- 在生产环境中...
- 根据社区统计...
```

---

## 记住这些

1. **回答要有深度**：不仅说"是什么"，还要说"为什么"和"怎么做"
2. **回答要有对比**：对比传统方式和新方式
3. **回答要有数据**：提供具体的性能和复杂度数据
4. **回答要有应用**：联系实际的应用场景

**一句话总结：** 优秀的面试回答 = 结构清晰 + 有深度 + 有对比 + 有数据 + 有应用。
