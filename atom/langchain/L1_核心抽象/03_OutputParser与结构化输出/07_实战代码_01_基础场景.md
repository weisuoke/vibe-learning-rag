# 实战代码 1：基础场景

完整可运行的 Python 代码示例，展示 OutputParser 的基础使用场景。

---

## 环境准备

```python
# 安装依赖（如果还没安装）
# uv add langchain langchain-openai python-dotenv

# 导入必需的库
import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate
from langchain.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field
from typing import List, Optional

# 加载环境变量
load_dotenv()
```

---

## 场景 1：with_structured_output() 基础用法（2025+ 推荐）

```python
"""
场景：从文本中提取人物信息
方法：使用 with_structured_output()（现代方法）
"""

print("=== 场景 1：with_structured_output() 基础用法 ===\n")

# 1. 定义 Pydantic 模型
class Person(BaseModel):
    name: str = Field(description="人名")
    age: int = Field(description="年龄", ge=0, le=150)
    email: str = Field(description="邮箱地址")

# 2. 创建支持结构化输出的 LLM
llm = ChatOpenAI(model="gpt-4o", temperature=0)
structured_llm = llm.with_structured_output(Person)

# 3. 测试不同的输入
test_texts = [
    "Alice is 25 years old, her email is alice@example.com",
    "提取信息：Bob，30岁，邮箱 bob@test.com",
    "Charlie (35) - charlie@company.org"
]

for text in test_texts:
    print(f"输入: {text}")
    result = structured_llm.invoke(text)
    print(f"输出: {result}")
    print(f"类型: {type(result)}")
    print(f"访问字段: name={result.name}, age={result.age}, email={result.email}")
    print()

# 预期输出：
# 输入: Alice is 25 years old, her email is alice@example.com
# 输出: Person(name='Alice', age=25, email='alice@example.com')
# 类型: <class '__main__.Person'>
# 访问字段: name=Alice, age=25, email=alice@example.com
```

---

## 场景 2：PydanticOutputParser 兼容方案

```python
"""
场景：使用传统 PydanticOutputParser（兼容旧模型）
方法：手动注入格式指令
"""

print("=== 场景 2：PydanticOutputParser 兼容方案 ===\n")

# 1. 创建解析器
parser = PydanticOutputParser(pydantic_object=Person)

# 2. 获取格式指令
format_instructions = parser.get_format_instructions()
print(f"格式指令长度: {len(format_instructions)} 字符\n")

# 3. 创建 Prompt（注入格式指令）
prompt = PromptTemplate(
    template="提取人物信息：{text}\n\n{format_instructions}",
    input_variables=["text"],
    partial_variables={"format_instructions": format_instructions}
)

# 4. 构建链
llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
chain = prompt | llm | parser

# 5. 测试
text = "David is 40 years old, email: david@example.com"
print(f"输入: {text}")
result = chain.invoke({"text": text})
print(f"输出: {result}")
print(f"类型: {type(result)}")
print()

# 预期输出：
# 输入: David is 40 years old, email: david@example.com
# 输出: Person(name='David', age=40, email='david@example.com')
# 类型: <class '__main__.Person'>
```

---

## 场景 3：JsonOutputParser 简单解析

```python
"""
场景：简单 JSON 解析（无验证）
方法：JsonOutputParser
"""

print("=== 场景 3：JsonOutputParser 简单解析 ===\n")

from langchain.output_parsers import JsonOutputParser

# 1. 创建解析器（无需 Pydantic 模型）
json_parser = JsonOutputParser()

# 2. 创建 Prompt
prompt = PromptTemplate(
    template="从以下文本提取信息并返回 JSON：{text}",
    input_variables=["text"]
)

# 3. 构建链
chain = prompt | llm | json_parser

# 4. 测试
text = "北京今天晴天，温度 15 度，湿度 60%"
print(f"输入: {text}")
result = chain.invoke({"text": text})
print(f"输出: {result}")
print(f"类型: {type(result)}")  # dict
print()

# 预期输出：
# 输入: 北京今天晴天，温度 15 度，湿度 60%
# 输出: {'city': '北京', 'weather': '晴天', 'temperature': 15, 'humidity': 60}
# 类型: <class 'dict'>
```

---

## 场景 4：批量处理

```python
"""
场景：批量提取多个人物信息
方法：使用 batch() 方法
"""

print("=== 场景 4：批量处理 ===\n")

# 使用 with_structured_output 进行批量处理
structured_llm = llm.with_structured_output(Person)

# 批量输入
texts = [
    "Alice, 25, alice@example.com",
    "Bob, 30, bob@test.com",
    "Charlie, 35, charlie@company.org",
    "David, 40, david@example.com"
]

print(f"批量处理 {len(texts)} 条数据...\n")

# 批量调用
results = structured_llm.batch(texts)

# 输出结果
for i, (text, result) in enumerate(zip(texts, results), 1):
    print(f"{i}. 输入: {text}")
    print(f"   输出: {result}")
    print()

# 预期输出：
# 批量处理 4 条数据...
#
# 1. 输入: Alice, 25, alice@example.com
#    输出: Person(name='Alice', age=25, email='alice@example.com')
#
# 2. 输入: Bob, 30, bob@test.com
#    输出: Person(name='Bob', age=30, email='bob@test.com')
# ...
```

---

## 场景 5：字段约束验证

```python
"""
场景：验证字段约束
方法：Pydantic Field 约束
"""

print("=== 场景 5：字段约束验证 ===\n")

from pydantic import ValidationError

class ValidatedPerson(BaseModel):
    name: str = Field(description="人名", min_length=1)
    age: int = Field(description="年龄", ge=0, le=150)
    email: str = Field(description="邮箱", pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")

structured_llm = llm.with_structured_output(ValidatedPerson)

# 测试有效输入
print("测试 1：有效输入")
try:
    result = structured_llm.invoke("Alice, 25, alice@example.com")
    print(f"✅ 成功: {result}\n")
except ValidationError as e:
    print(f"❌ 验证失败: {e}\n")

# 测试无效输入（LLM 通常会修正，但如果返回无效数据会被捕获）
print("测试 2：边界情况（LLM 会尝试修正）")
try:
    result = structured_llm.invoke("提取：年龄 -5 的人")
    print(f"✅ LLM 修正后: {result}\n")
except ValidationError as e:
    print(f"❌ 验证失败: {e}\n")

# 预期输出：
# 测试 1：有效输入
# ✅ 成功: ValidatedPerson(name='Alice', age=25, email='alice@example.com')
#
# 测试 2：边界情况（LLM 会尝试修正）
# ✅ LLM 修正后: ValidatedPerson(name='Unknown', age=0, email='unknown@example.com')
```

---

## 场景 6：可选字段处理

```python
"""
场景：处理可选字段
方法：Optional 类型
"""

print("=== 场景 6：可选字段处理 ===\n")

class PersonWithOptional(BaseModel):
    name: str = Field(description="人名")
    age: int = Field(description="年龄")
    email: Optional[str] = Field(None, description="邮箱（可选）")
    phone: Optional[str] = Field(None, description="电话（可选）")

structured_llm = llm.with_structured_output(PersonWithOptional)

# 测试不同的输入（有些缺少可选字段）
test_cases = [
    "Alice, 25, alice@example.com, 13800138000",  # 全部字段
    "Bob, 30, bob@test.com",  # 缺少电话
    "Charlie, 35",  # 只有必填字段
]

for text in test_cases:
    print(f"输入: {text}")
    result = structured_llm.invoke(text)
    print(f"输出: {result}")
    print(f"  - email: {result.email}")
    print(f"  - phone: {result.phone}")
    print()

# 预期输出：
# 输入: Alice, 25, alice@example.com, 13800138000
# 输出: PersonWithOptional(name='Alice', age=25, email='alice@example.com', phone='13800138000')
#   - email: alice@example.com
#   - phone: 13800138000
#
# 输入: Bob, 30, bob@test.com
# 输出: PersonWithOptional(name='Bob', age=30, email='bob@test.com', phone=None)
#   - email: bob@test.com
#   - phone: None
```

---

## 场景 7：列表字段

```python
"""
场景：提取列表类型的字段
方法：List 类型
"""

print("=== 场景 7：列表字段 ===\n")

class PersonWithSkills(BaseModel):
    name: str = Field(description="人名")
    age: int = Field(description="年龄")
    skills: List[str] = Field(description="技能列表")

structured_llm = llm.with_structured_output(PersonWithSkills)

# 测试
text = "Alice, 25 years old, skills: Python, JavaScript, SQL, Docker"
print(f"输入: {text}")
result = structured_llm.invoke(text)
print(f"输出: {result}")
print(f"技能数量: {len(result.skills)}")
print(f"技能列表: {', '.join(result.skills)}")
print()

# 预期输出：
# 输入: Alice, 25 years old, skills: Python, JavaScript, SQL, Docker
# 输出: PersonWithSkills(name='Alice', age=25, skills=['Python', 'JavaScript', 'SQL', 'Docker'])
# 技能数量: 4
# 技能列表: Python, JavaScript, SQL, Docker
```

---

## 完整运行示例

```python
"""
完整示例：整合所有场景
"""

def main():
    """运行所有基础场景"""
    print("=" * 60)
    print("OutputParser 基础场景演示")
    print("=" * 60)
    print()

    # 场景 1-7 的代码...
    # （在实际运行时，将上面所有场景的代码整合到这里）

    print("=" * 60)
    print("所有场景演示完成！")
    print("=" * 60)

if __name__ == "__main__":
    main()
```

---

## 运行说明

### 1. 环境配置

```bash
# 安装依赖
uv add langchain langchain-openai python-dotenv

# 配置 API Key
echo "OPENAI_API_KEY=your_key_here" > .env
```

### 2. 运行代码

```bash
# 运行完整示例
python examples/outputparser_basic.py

# 或者在 Python REPL 中逐个运行场景
python
>>> from examples.outputparser_basic import *
>>> # 运行场景 1
```

### 3. 预期输出

所有场景都应该成功运行并输出结构化的 Pydantic 对象。

---

## 关键要点

1. **with_structured_output()**：2025+ 推荐方法，最简单
2. **PydanticOutputParser**：兼容旧模型，需要格式指令
3. **JsonOutputParser**：简单场景，无验证
4. **批量处理**：使用 `batch()` 方法提高效率
5. **字段约束**：使用 Field 参数进行验证
6. **可选字段**：使用 Optional 类型
7. **列表字段**：使用 List 类型

---

**记住**：所有代码都是可运行的，复制粘贴即可使用！
