# JWT认证 - 实战代码04：依赖注入保护路由

## 概述

本章使用FastAPI的依赖注入系统保护路由，实现优雅的认证和权限控制。

---

## FastAPI依赖注入基础

### 什么是依赖注入？

**依赖注入（Dependency Injection）**：将依赖关系从外部注入到函数中，而不是在函数内部创建。

**类比Express中间件：**
```javascript
// Express中间件
app.get('/protected', authMiddleware, (req, res) => {
  // req.user 由中间件注入
  res.json({ user: req.user });
});

// FastAPI依赖注入
@app.get("/protected")
async def protected(current_user: dict = Depends(get_current_user)):
    # current_user 由依赖函数注入
    return {"user": current_user}
```

---

## 创建认证依赖

### 基础认证依赖

```python
"""
基础认证依赖
演示：从请求头中提取并验证Token
"""

from fastapi import Depends, HTTPException, Header
from jose import jwt, JWTError
import os

SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"


async def get_current_user(authorization: str = Header()) -> dict:
    """
    认证依赖：验证Token并返回用户信息

    Args:
        authorization: Authorization请求头

    Returns:
        用户信息字典

    Raises:
        HTTPException: Token无效或已过期
    """
    # 1. 检查格式
    if not authorization.startswith("Bearer "):
        raise HTTPException(
            status_code=401,
            detail="无效的认证格式",
            headers={"WWW-Authenticate": "Bearer"}
        )

    # 2. 提取Token
    token = authorization.replace("Bearer ", "")

    # 3. 验证Token
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=401,
            detail="Token已过期",
            headers={"WWW-Authenticate": "Bearer"}
        )

    except JWTError:
        raise HTTPException(
            status_code=401,
            detail="无效的Token",
            headers={"WWW-Authenticate": "Bearer"}
        )


# 使用示例
from fastapi import FastAPI

app = FastAPI()


@app.get("/protected")
async def protected_route(current_user: dict = Depends(get_current_user)):
    """受保护的路由"""
    return {
        "message": f"欢迎，用户 {current_user['user_id']}",
        "user": current_user
    }
```

---

## 使用HTTPBearer

### 更优雅的方式

```python
"""
使用HTTPBearer
演示：FastAPI内置的Bearer Token支持
"""

from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()


async def get_current_user_v2(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """
    认证依赖（使用HTTPBearer）

    Args:
        credentials: Bearer Token凭证

    Returns:
        用户信息
    """
    try:
        payload = jwt.decode(
            credentials.credentials,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )
        return payload

    except jwt.ExpiredSignatureError:
        raise HTTPException(401, "Token已过期")

    except JWTError:
        raise HTTPException(401, "无效的Token")


@app.get("/protected-v2")
async def protected_route_v2(current_user: dict = Depends(get_current_user_v2)):
    """受保护的路由（使用HTTPBearer）"""
    return {"user": current_user}
```

**优势：**
- 自动生成OpenAPI文档中的认证UI
- 自动处理Authorization头格式
- 更符合FastAPI规范

---

## 可选认证

### 允许匿名访问

```python
"""
可选认证
演示：路由可以匿名访问，但登录用户有额外功能
"""

from typing import Optional


async def get_current_user_optional(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(
        HTTPBearer(auto_error=False)  # 不自动抛出错误
    )
) -> Optional[dict]:
    """
    可选认证依赖

    Args:
        credentials: Bearer Token凭证（可选）

    Returns:
        用户信息或None
    """
    if not credentials:
        return None

    try:
        payload = jwt.decode(
            credentials.credentials,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )
        return payload

    except JWTError:
        return None


@app.get("/optional-auth")
async def optional_auth_route(
    current_user: Optional[dict] = Depends(get_current_user_optional)
):
    """可选认证的路由"""
    if current_user:
        return {
            "message": f"欢迎回来，{current_user['username']}",
            "is_authenticated": True
        }
    else:
        return {
            "message": "欢迎访客",
            "is_authenticated": False
        }
```

---

## 依赖链

### 组合多个依赖

```python
"""
依赖链
演示：一个依赖可以依赖另一个依赖
"""

from sqlalchemy.orm import Session


async def get_db() -> Generator[Session, None, None]:
    """数据库会话依赖"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


async def get_current_user_from_db(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)  # 依赖数据库会话
) -> User:
    """
    从数据库获取当前用户

    Args:
        credentials: Token凭证
        db: 数据库会话（依赖注入）

    Returns:
        User对象
    """
    # 1. 验证Token
    try:
        payload = jwt.decode(
            credentials.credentials,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )
    except JWTError:
        raise HTTPException(401, "无效的Token")

    # 2. 从数据库查询用户
    user_id = payload.get("user_id")
    user = db.query(User).filter(User.id == user_id).first()

    if not user:
        raise HTTPException(404, "用户不存在")

    if not user.is_active:
        raise HTTPException(403, "账号已被禁用")

    return user


@app.get("/profile")
async def get_profile(current_user: User = Depends(get_current_user_from_db)):
    """获取用户资料（从数据库）"""
    return {
        "id": current_user.id,
        "email": current_user.email,
        "username": current_user.username,
        "created_at": current_user.created_at
    }
```

---

## 全局依赖

### 保护整个路由组

```python
"""
全局依赖
演示：为路由组添加统一的认证
"""

from fastapi import APIRouter

# 创建需要认证的路由组
protected_router = APIRouter(
    prefix="/api",
    dependencies=[Depends(get_current_user)]  # 全局依赖
)


@protected_router.get("/data")
async def get_data():
    """自动需要认证（继承路由组的依赖）"""
    return {"data": "sensitive data"}


@protected_router.post("/action")
async def perform_action():
    """自动需要认证"""
    return {"message": "action performed"}


# 如果需要访问用户信息，仍然可以注入
@protected_router.get("/user-data")
async def get_user_data(current_user: dict = Depends(get_current_user)):
    """需要认证，并访问用户信息"""
    return {"user_id": current_user["user_id"], "data": "user-specific data"}


# 注册路由组
app.include_router(protected_router)
```

---

## 完整示例

### 完整的依赖注入系统

```python
"""
完整的依赖注入认证系统
演示：多层依赖 + 可选认证 + 全局保护
"""

from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from jose import jwt, JWTError
from typing import Optional, Generator
import os

app = FastAPI()
security = HTTPBearer()

# 配置
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"


# ===== 基础依赖 =====

def get_db() -> Generator[Session, None, None]:
    """数据库会话依赖"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# ===== 认证依赖 =====

async def verify_token(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """验证Token并返回Payload"""
    try:
        payload = jwt.decode(
            credentials.credentials,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )
        return payload

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token已过期",
            headers={"WWW-Authenticate": "Bearer"}
        )

    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的Token",
            headers={"WWW-Authenticate": "Bearer"}
        )


async def get_current_user(
    payload: dict = Depends(verify_token),
    db: Session = Depends(get_db)
) -> User:
    """获取当前用户（必需认证）"""
    user_id = payload.get("user_id")

    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(404, "用户不存在")

    if not user.is_active:
        raise HTTPException(403, "账号已被禁用")

    return user


async def get_current_user_optional(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(
        HTTPBearer(auto_error=False)
    ),
    db: Session = Depends(get_db)
) -> Optional[User]:
    """获取当前用户（可选认证）"""
    if not credentials:
        return None

    try:
        payload = jwt.decode(
            credentials.credentials,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )

        user_id = payload.get("user_id")
        user = db.query(User).filter(User.id == user_id).first()

        if user and user.is_active:
            return user

    except JWTError:
        pass

    return None


# ===== 公开路由 =====

@app.get("/public")
async def public_route():
    """公开路由：无需认证"""
    return {"message": "这是公开内容"}


# ===== 可选认证路由 =====

@app.get("/optional")
async def optional_route(current_user: Optional[User] = Depends(get_current_user_optional)):
    """可选认证路由"""
    if current_user:
        return {
            "message": f"欢迎，{current_user.username}",
            "is_authenticated": True,
            "user_id": current_user.id
        }
    else:
        return {
            "message": "欢迎访客",
            "is_authenticated": False
        }


# ===== 必需认证路由 =====

@app.get("/protected")
async def protected_route(current_user: User = Depends(get_current_user)):
    """必需认证路由"""
    return {
        "message": f"欢迎，{current_user.username}",
        "user": {
            "id": current_user.id,
            "email": current_user.email,
            "username": current_user.username
        }
    }


# ===== 路由组（全局认证）=====

api_router = APIRouter(
    prefix="/api",
    tags=["API"],
    dependencies=[Depends(get_current_user)]  # 所有路由都需要认证
)


@api_router.get("/data")
async def get_data():
    """自动需要认证"""
    return {"data": "sensitive data"}


@api_router.get("/user-data")
async def get_user_data(current_user: User = Depends(get_current_user)):
    """需要认证，并访问用户信息"""
    return {
        "user_id": current_user.id,
        "data": f"Data for {current_user.username}"
    }


app.include_router(api_router)
```

---

## 测试依赖注入

### 测试脚本

```bash
#!/bin/bash

# 1. 测试公开路由（无需Token）
echo "=== 测试公开路由 ==="
curl -X GET "http://localhost:8000/public"

# 2. 测试可选认证路由（无Token）
echo -e "\n=== 测试可选认证（无Token）==="
curl -X GET "http://localhost:8000/optional"

# 3. 登录获取Token
echo -e "\n=== 登录获取Token ==="
TOKEN=$(curl -s -X POST "http://localhost:8000/login" \
  -H "Content-Type: application/json" \
  -d '{"email": "alice@example.com", "password": "SecurePass123!"}' \
  | jq -r '.access_token')

echo "Token: ${TOKEN:0:50}..."

# 4. 测试可选认证路由（有Token）
echo -e "\n=== 测试可选认证（有Token）==="
curl -X GET "http://localhost:8000/optional" \
  -H "Authorization: Bearer $TOKEN"

# 5. 测试必需认证路由（有Token）
echo -e "\n=== 测试必需认证 ==="
curl -X GET "http://localhost:8000/protected" \
  -H "Authorization: Bearer $TOKEN"

# 6. 测试必需认证路由（无Token，应该失败）
echo -e "\n=== 测试必需认证（无Token）==="
curl -X GET "http://localhost:8000/protected"

# 7. 测试路由组（有Token）
echo -e "\n=== 测试路由组 ==="
curl -X GET "http://localhost:8000/api/data" \
  -H "Authorization: Bearer $TOKEN"

# 8. 测试路由组（无Token，应该失败）
echo -e "\n=== 测试路由组（无Token）==="
curl -X GET "http://localhost:8000/api/data"
```

---

## 在AI Agent API中的应用

### AI Agent路由保护

```python
"""
AI Agent API路由保护
演示：保护AI Agent端点
"""

from fastapi import APIRouter

# AI Agent路由组（需要认证）
agent_router = APIRouter(
    prefix="/agent",
    tags=["AI Agent"],
    dependencies=[Depends(get_current_user)]
)


@agent_router.post("/chat")
async def chat(
    message: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """AI Agent对话端点"""
    # 1. 加载对话历史
    conversation = await load_conversation(db, current_user.id)

    # 2. 调用AI Agent
    response = await agent.run(message, conversation)

    # 3. 保存对话历史
    await save_message(db, current_user.id, message, response)

    return {
        "user_id": current_user.id,
        "message": message,
        "response": response
    }


@agent_router.get("/history")
async def get_history(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取对话历史"""
    conversations = await load_all_conversations(db, current_user.id)

    return {
        "user_id": current_user.id,
        "conversations": conversations
    }


@agent_router.delete("/history/{conversation_id}")
async def delete_conversation(
    conversation_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """删除对话历史"""
    # 检查对话是否属于当前用户
    conversation = db.query(Conversation).filter(
        Conversation.id == conversation_id,
        Conversation.user_id == current_user.id
    ).first()

    if not conversation:
        raise HTTPException(404, "对话不存在")

    db.delete(conversation)
    db.commit()

    return {"message": "对话已删除"}


app.include_router(agent_router)
```

---

## 依赖注入的优势

### 对比传统方式

**传统方式（手动验证）：**
```python
@app.get("/protected")
async def protected_route(authorization: str = Header()):
    # 每个路由都要重复这些代码
    if not authorization.startswith("Bearer "):
        raise HTTPException(401, "无效的认证格式")

    token = authorization.replace("Bearer ", "")

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except JWTError:
        raise HTTPException(401, "无效的Token")

    user_id = payload.get("user_id")
    # ... 业务逻辑
```

**依赖注入方式：**
```python
@app.get("/protected")
async def protected_route(current_user: User = Depends(get_current_user)):
    # 认证逻辑在依赖中，路由只关注业务逻辑
    # ... 业务逻辑
```

**优势：**
1. **代码复用**：认证逻辑只写一次
2. **关注分离**：路由只关注业务逻辑
3. **易于测试**：可以mock依赖
4. **类型安全**：IDE自动补全
5. **自动文档**：OpenAPI自动生成认证UI

---

## 依赖注入测试

### 测试中mock依赖

```python
"""
测试依赖注入
演示：在测试中mock认证依赖
"""

from fastapi.testclient import TestClient


def override_get_current_user():
    """Mock的认证依赖"""
    return User(
        id=999,
        email="test@example.com",
        username="testuser",
        is_active=True
    )


# 覆盖依赖
app.dependency_overrides[get_current_user] = override_get_current_user

# 创建测试客户端
client = TestClient(app)


def test_protected_route():
    """测试受保护的路由"""
    response = client.get("/protected")

    assert response.status_code == 200
    assert response.json()["user"]["id"] == 999
    assert response.json()["user"]["username"] == "testuser"


def test_agent_chat():
    """测试AI Agent对话"""
    response = client.post(
        "/agent/chat",
        params={"message": "你好"}
    )

    assert response.status_code == 200
    assert "response" in response.json()


# 清理
app.dependency_overrides.clear()
```

---

## 总结

**本章学习了：**
1. FastAPI依赖注入基础
2. 创建认证依赖
3. 使用HTTPBearer
4. 可选认证
5. 依赖链
6. 全局依赖
7. 在AI Agent API中应用
8. 依赖注入测试

**关键点：**
- 依赖注入实现代码复用
- HTTPBearer自动处理Bearer Token
- 可选认证使用auto_error=False
- 依赖可以依赖其他依赖
- 路由组可以设置全局依赖
- 测试中可以mock依赖

**下一步：**
- 学习RBAC权限控制
- 学习手写JWT实现
- 学习生产级最佳实践
