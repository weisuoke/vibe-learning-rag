# 化骨绵掌：10 个 2 分钟知识卡片

> 将 Agent Core 运行时机制拆解为 10 个独立完整的知识卡片，每个 2 分钟内可看完

---

## 卡片 1：Agent Core 的直觉理解

**一句话：** Agent Core 就是一个"会思考的循环"，不断调用 LLM 决策、执行工具、检查结果，直到任务完成。

**举例：**
```typescript
// 就像一个智能助手
while (任务未完成) {
  决策 = 问 LLM("下一步该做什么？");
  if (决策 === "调用工具") {
    结果 = 执行工具();
    告诉 LLM(结果);
  } else {
    break; // 任务完成
  }
}
```

**类比：**
- **TypeScript**：Express 中间件链，每个环节处理后传递给下一个
- **日常生活**：流水线工人，看任务 → 拿工具 → 操作 → 检查 → 继续

**应用：** 理解这个直觉后，你就能理解为什么 Agent 不需要预设流程，而是由 LLM 动态决策每一步。

---

## 卡片 2：形式化定义

**一句话：** Agent Core = 有状态的异步生成器循环 + 工具注册表 + 事件流

**精确表述：**
```typescript
interface AgentCore {
  // 核心循环
  run(userMessage: string): AsyncGenerator<Event>;

  // 工具注册
  registerTool(name: string, tool: Tool): void;

  // 状态管理
  context: Message[];
  session: Session;

  // 事件流
  on(event: string, handler: Function): void;
}
```

**三个核心组件：**
1. **循环引擎**：`while (true)` + LLM 调用 + 工具执行
2. **工具系统**：Map<name, Tool> + TypeBox 验证
3. **状态管理**：JSONL 追加日志 + parentId 树形结构

**应用：** 这个形式化定义是实现自定义 Agent 的蓝图。

---

## 卡片 3：关键概念 - Loop Until Done

**一句话：** Pi-mono 的核心哲学："循环会一直运行，直到 LLM 不再请求工具调用"，无需 max-steps 限制。

**为什么这样设计？**
- 前沿模型（Claude Opus 4、GPT-4）理解"任务完成"的语义
- 模型会在任务完成时自然停止工具调用
- 人为限制反而破坏了 Agent 的自主性

**对比：**
```typescript
// ❌ LangChain 方式
const agent = new Agent({ maxIterations: 10 });

// ✅ Pi-mono 方式
const agent = new Agent(); // 无限制，信任模型
```

**实际数据：** Pi-mono 在生产环境运行数千次任务，无一次无限循环[^1]

**应用：** 设计 Agent 时，不要预设循环次数，让模型自己决定何时停止。

---

## 卡片 4：关键概念 - 4 个工具的极简哲学

**一句话：** Pi-mono 只提供 4 个核心工具（read/write/edit/bash），通过组合实现无限能力。

**为什么 4 个够用？**
1. **前沿模型理解上下文**：知道 `bash` 可以执行 `git commit`、`npm install` 等
2. **组合能力**：read + edit = 修改文件，bash + read = 运行并检查
3. **Token 效率**：4 个工具 × 100 tokens = 400 tokens（vs 50 个工具 = 5000 tokens）

**实际案例：**
```typescript
// 任务：Git 提交
// 不需要专门的 git_commit 工具
bash('git add . && git commit -m "feat: add feature"')

// 任务：安装依赖
// 不需要专门的 install_package 工具
bash('npm install express')
```

**应用：** 设计自定义 Agent 时，优先用 4 个核心工具，只在确实需要时才添加新工具。

---

## 卡片 5：编程实现 - 异步生成器模式

**一句话：** Agent Core 使用 `async function*` 实现流式输出，每次 yield 一个事件。

**核心代码：**
```typescript
async function* agentLoop(userMessage: string) {
  const context = [{ role: 'user', content: userMessage }];

  while (true) {
    // 1. 调用 LLM
    const response = await llm.chat(context);
    yield { type: 'assistant', content: response.content };

    // 2. 检测工具调用
    if (!response.toolCalls) break;

    // 3. 执行工具
    for (const call of response.toolCalls) {
      yield { type: 'tool_call', call };
      const result = await executeTool(call);
      yield { type: 'tool_result', result };
      context.push({ role: 'tool', content: result.output });
    }
  }
}
```

**为什么用生成器？**
- **流式输出**：UI 可以实时显示进度
- **暂停恢复**：可以在任意点暂停和恢复
- **内存效率**：不需要一次性加载所有结果

**应用：** 实现自定义 Agent 时，使用生成器模式可以提供更好的用户体验。

---

## 卡片 6：对比区分 - Pi-mono vs LangChain

**一句话：** Pi-mono 追求极简核心，LangChain 追求功能完备。

**核心差异对比：**

| 维度 | Pi-mono | LangChain |
|------|---------|-----------|
| **设计理念** | 极简核心 + 可扩展 | 功能完备工具箱 |
| **工具数量** | 4 个核心工具 | 50+ 预置工具 |
| **循环控制** | loop until done | maxIterations 限制 |
| **学习曲线** | 平缓（30 行核心） | 陡峭（多层抽象） |
| **扩展方式** | 工具注册 | 继承 + 配置 |
| **状态管理** | JSONL 追加日志 | 内存 + 可选持久化 |

**选择建议：**
- **Pi-mono**：适合理解 Agent 本质、构建定制化 Agent、追求极简设计
- **LangChain**：适合快速原型、需要大量预置工具、企业级应用

**应用：** 理解两者差异后，可以根据项目需求选择合适的框架。

---

## 卡片 7：进阶理解 - 工具验证与自我纠正

**一句话：** Pi-mono 将验证失败作为反馈返回给 LLM，让模型自我纠正，而不是抛出异常。

**自我纠正流程：**
```typescript
// 循环 1：参数错误
LLM: read({ file: 'hello.ts' })  // ❌ 参数名错误
Tool: { output: "Error: Missing required property 'path'" }

// 循环 2：LLM 看到错误，自我纠正
LLM: read({ path: 'hello.ts' })  // ✅ 参数正确
Tool: { output: "File content: console.log('hello')" }
```

**为什么这样设计？**
- LLM 能理解错误信息（不像传统程序）
- 错误是宝贵的学习信号（不应该被隐藏）
- 80% 的验证错误在下一轮被自动纠正[^2]

**对比传统异常处理：**
```typescript
// ❌ 抛异常：任务中断
throw new Error('Invalid parameters');

// ✅ 返回错误：任务继续
return { output: 'Error: Invalid parameters' };
```

**应用：** 实现自定义工具时，所有错误都返回给 LLM，不要抛异常。

---

## 卡片 8：高级应用 - JSONL 状态管理

**一句话：** Pi-mono 使用 JSONL（JSON Lines）格式实现追加日志 + 树形分支 + 跨 Provider 可移植。

**JSONL 格式示例：**
```jsonl
{"id":"msg-1","type":"user","content":"创建 hello.ts"}
{"id":"msg-2","type":"assistant","content":"我来创建文件"}
{"id":"msg-3","type":"tool","name":"write","params":{...}}
{"id":"msg-4","type":"tool_result","output":"File created"}
{"id":"msg-5","parentId":"msg-2","type":"user","content":"改成 TypeScript"}
```

**三大优势：**
1. **追加写入 O(1)**：不需要重写整个文件
2. **树形分支**：通过 `parentId` 实现分支，单文件存储多个分支
3. **跨 Provider**：统一格式，可在 Anthropic、OpenAI、Google 之间迁移

**对比 JSON：**
```typescript
// JSON：每次更新需要重写整个文件
const data = JSON.parse(fs.readFileSync('session.json'));
data.messages.push(newMessage);
fs.writeFileSync('session.json', JSON.stringify(data)); // O(n)

// JSONL：直接追加一行
fs.appendFileSync('session.jsonl', JSON.stringify(newMessage) + '\n'); // O(1)
```

**应用：** 需要追加日志、保留完整历史、支持分支时，优先使用 JSONL。

---

## 卡片 9：在 AI Agent 开发中的应用

**一句话：** Agent Core 是构建任何 AI Agent 的基础，理解它就能构建自定义 Agent。

**实际应用场景：**

**1. Coding Agent（Pi-mono 本身）**
```typescript
const codingAgent = new Agent({
  tools: ['read', 'write', 'edit', 'bash'],
  systemPrompt: 'You are a coding assistant...'
});
// 自动完成：读取代码 → 修改 → 运行测试 → 提交
```

**2. 数据分析 Agent**
```typescript
const dataAgent = new Agent({
  tools: [...coreTools, 'query_db', 'plot_chart'],
  systemPrompt: 'You are a data analyst...'
});
// 自动完成：查询数据 → 分析 → 生成图表 → 写报告
```

**3. Slack Bot Agent**
```typescript
const slackAgent = new Agent({
  tools: [...coreTools, 'send_message', 'read_channel'],
  systemPrompt: 'You are a Slack assistant...'
});
// 自动完成：监听消息 → 理解意图 → 执行操作 → 回复
```

**4. 代码审查 Agent**
```typescript
const reviewAgent = new Agent({
  tools: ['read', 'bash', 'write'],  // 仅 3 个工具！
  systemPrompt: 'You are a code reviewer...'
});
// 自动完成：读取代码 → 运行测试 → 生成报告
```

**设计原则：**
- 从核心任务出发，推导最小工具集
- 优先使用 4 个核心工具
- 信任循环机制，无需预设流程
- 错误返回给 LLM，不抛异常

**应用：** 任何需要"LLM + 工具 + 循环"的场景都可以用 Agent Core 实现。

---

## 卡片 10：总结与延伸

**一句话：** Agent Core 是"LLM + 循环 + 工具"的最小实现，体现了极简设计、信任模型、反馈驱动的哲学。

**核心要点回顾：**

1. **执行循环**：loop until done，信任模型自主终止
2. **工具系统**：4 个核心工具，组合能力 > 工具数量
3. **状态管理**：JSONL 追加日志，树形分支，跨 Provider
4. **错误处理**：返回错误给 LLM，自我纠正，80% 自动修复
5. **事件流**：异步生成器，流式输出，output vs details 分离

**与其他概念的联系：**

```
Agent Core（本知识点）
├── 依赖：Pi AI 统一 LLM API（知识点 07）
├── 扩展：工具调用与状态管理（知识点 09）
├── 应用：消息队列与流式响应（知识点 10）
└── 优化：Compaction 压缩机制（知识点 12）
```

**延伸学习：**

1. **深入源码**：阅读 `packages/pi-agent-core/src/agent.ts`
2. **实战练习**：实现一个简单的 Agent（如 TODO 管理 Agent）
3. **框架对比**：对比 LangChain、LlamaIndex、AutoGPT 的设计
4. **高级扩展**：学习 Sub-Agents、MCP 集成、Plan Mode

**哲学思考：**

Agent Core 的设计体现了三个深层哲学：
1. **信任智能**：前沿模型已经足够智能，无需过度限制
2. **极简设计**：少即是多，简单的系统更可靠
3. **反馈驱动**：错误是学习信号，不是失败标志

**最后一句话：**
**理解 Agent Core 的本质，就是理解 AI Agent 的本质：一个能够自主调用工具、根据反馈调整策略、直到任务完成的智能循环。**

---

## 10 个卡片的学习路径

**建议学习顺序：**

```
第 1 天：卡片 1-3（直觉理解 + 形式化定义 + Loop Until Done）
第 2 天：卡片 4-5（4 个工具 + 异步生成器）
第 3 天：卡片 6-7（框架对比 + 自我纠正）
第 4 天：卡片 8-9（JSONL 状态 + 实际应用）
第 5 天：卡片 10（总结 + 延伸）
```

**快速复习（5 分钟）：**
1. Agent Core = LLM + 循环 + 工具
2. Loop until done（无 max-steps）
3. 4 个工具足够（组合能力）
4. 错误是反馈（自我纠正）
5. JSONL 追加日志（O(1) 性能）

**深度理解检验：**
- [ ] 能用 30 行 TypeScript 实现一个最小 Agent Core
- [ ] 能解释为什么不需要 max-steps
- [ ] 能设计一个自定义 Agent 的工具集
- [ ] 能实现工具验证与自我纠正机制
- [ ] 能用 JSONL 实现 Session 分支管理

**如果你能完成这些检验，说明你已经真正掌握了 Agent Core 运行时机制！**

---

## 知识卡片速查表

| 卡片 | 主题 | 核心概念 | 时长 |
|------|------|---------|------|
| 1 | 直觉理解 | 会思考的循环 | 2 分钟 |
| 2 | 形式化定义 | 循环 + 工具 + 状态 | 2 分钟 |
| 3 | Loop Until Done | 信任模型自主终止 | 2 分钟 |
| 4 | 4 个工具 | 组合能力 > 数量 | 2 分钟 |
| 5 | 异步生成器 | 流式输出 | 2 分钟 |
| 6 | 框架对比 | Pi-mono vs LangChain | 2 分钟 |
| 7 | 自我纠正 | 错误是反馈 | 2 分钟 |
| 8 | JSONL 状态 | 追加日志 + 分支 | 2 分钟 |
| 9 | 实际应用 | 4 种 Agent 场景 | 2 分钟 |
| 10 | 总结延伸 | 哲学 + 学习路径 | 2 分钟 |

**总学习时长：20 分钟**

---

[^1]: Pi-mono production data: Zero infinite loops in thousands of tasks (2025-2026)
[^2]: Pi-mono internal metrics: 80% validation errors self-corrected in next iteration
