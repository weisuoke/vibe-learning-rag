# 实战代码3：熔断器实现

**场景：** 手写熔断器，实现三状态状态机和服务降级

---

## 完整代码

```python
"""
熔断器实现
支持：三状态状态机、失败率监控、自动恢复、降级策略
"""

import time
from enum import Enum
from typing import Callable, TypeVar, Awaitable, Optional
import structlog

T = TypeVar('T')
logger = structlog.get_logger()

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreakerOpenError(Exception):
    pass

class CircuitBreaker:
    def __init__(
        self,
        name: str,
        failure_threshold: float = 0.5,
        timeout: int = 30,
        min_calls: int = 5,
        fallback: Optional[Callable] = None
    ):
        self.name = name
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.min_calls = min_calls
        self.fallback = fallback

        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None

    async def call(self, func: Callable[..., Awaitable[T]], *args, **kwargs) -> T:
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitState.HALF_OPEN
                logger.info("circuit_breaker_half_open", name=self.name)
            else:
                if self.fallback:
                    return await self.fallback(*args, **kwargs)
                raise CircuitBreakerOpenError(f"{self.name} 服务暂时不可用")

        try:
            result = await func(*args, **kwargs)
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise

    def on_success(self):
        self.success_count += 1
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.CLOSED
            self.failure_count = 0
            self.success_count = 0
            logger.info("circuit_breaker_closed", name=self.name)

    def on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.OPEN
            logger.warning("circuit_breaker_reopened", name=self.name)
            return

        total = self.failure_count + self.success_count
        if total >= self.min_calls:
            failure_rate = self.failure_count / total
            if failure_rate > self.failure_threshold:
                self.state = CircuitState.OPEN
                logger.error("circuit_breaker_opened", name=self.name, failure_rate=failure_rate)

# ===== 使用示例 =====
import asyncio
from openai import AsyncOpenAI

client = AsyncOpenAI()

async def fallback_response(prompt: str):
    """降级响应"""
    return "抱歉，AI 服务暂时不可用，请稍后重试"

llm_breaker = CircuitBreaker(
    name="LLM",
    failure_threshold=0.5,
    timeout=30,
    fallback=fallback_response
)

async def call_llm(prompt: str) -> str:
    async def _call():
        response = await client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}]
        )
        return response.choices[0].message.content

    return await llm_breaker.call(_call)

# ===== 测试 =====
async def main():
    # 模拟多次调用
    for i in range(10):
        try:
            response = await call_llm(f"测试 {i}")
            print(f"请求 {i}: 成功")
        except Exception as e:
            print(f"请求 {i}: 失败 - {type(e).__name__}")
        await asyncio.sleep(0.5)

if __name__ == "__main__":
    asyncio.run(main())
```

---

## 运行输出

```bash
python circuit_breaker.py

# 输出：
请求 0: 成功
请求 1: 成功
请求 2: 失败 - TimeoutError
请求 3: 失败 - TimeoutError
请求 4: 失败 - TimeoutError
# 熔断器打开（失败率 60%）
请求 5: 失败 - CircuitBreakerOpenError（返回降级响应）
请求 6: 失败 - CircuitBreakerOpenError（返回降级响应）
# 30秒后，熔断器进入半开状态
请求 7: 成功
# 熔断器恢复正常
请求 8: 成功
请求 9: 成功
```
