# 核心概念1：迁移文件的生成与结构

**迁移文件是 Alembic 的核心，每个迁移文件都是一个 Python 脚本，包含 upgrade 和 downgrade 函数，定义了数据库 schema 的正向和反向变更。**

---

## 1.1 迁移文件的生成方式

### 自动生成（autogenerate）

**最常用的方式，通过对比 SQLAlchemy 模型和数据库 schema 自动生成迁移脚本。**

```bash
# 自动生成迁移脚本
alembic revision --autogenerate -m "add avatar to users"

# 输出：
# Generating /path/to/alembic/versions/abc123_add_avatar_to_users.py ... done
```

**工作原理：**
1. 连接数据库，读取当前 schema
2. 读取 SQLAlchemy 模型定义（从 `env.py` 的 `target_metadata`）
3. 对比差异，生成 `op.*` 操作
4. 创建迁移文件

**优点：**
- ✅ 快速生成，减少手写错误
- ✅ 自动处理大部分常见变更
- ✅ 生成的代码格式统一

**缺点：**
- ❌ 无法检测重命名（会识别为删除+创建）
- ❌ 无法检测约束变更
- ❌ 无法生成数据迁移逻辑

### 手动创建（manual）

**创建空白迁移文件，手动编写迁移逻辑。**

```bash
# 创建空白迁移脚本
alembic revision -m "custom data migration"

# 输出：
# Generating /path/to/alembic/versions/def456_custom_data_migration.py ... done
```

**适用场景：**
- 数据迁移（修改现有数据）
- 复杂的 schema 变更（autogenerate 无法处理）
- 执行原生 SQL
- 创建触发器、存储过程、视图

**示例：**
```python
# versions/def456_custom_data_migration.py
def upgrade():
    # 手动编写迁移逻辑
    op.execute("""
        UPDATE users
        SET status = 'active'
        WHERE last_login > NOW() - INTERVAL '30 days'
    """)

def downgrade():
    # 手动编写回滚逻辑
    op.execute("""
        UPDATE users
        SET status = 'inactive'
        WHERE status = 'active'
    """)
```

---

## 1.2 迁移文件的结构

### 完整的迁移文件示例

```python
"""add avatar to users

Revision ID: abc123def456
Revises: 9876543210ab
Create Date: 2026-02-11 14:30:00.123456

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'abc123def456'
down_revision = '9876543210ab'
branch_labels = None
depends_on = None

def upgrade():
    """正向迁移：应用变更"""
    # 添加新字段
    op.add_column('users', sa.Column('avatar', sa.String(length=255), nullable=True))

    # 创建索引
    op.create_index(op.f('ix_users_avatar'), 'users', ['avatar'], unique=False)

def downgrade():
    """反向迁移：撤销变更"""
    # 删除索引
    op.drop_index(op.f('ix_users_avatar'), table_name='users')

    # 删除字段
    op.drop_column('users', 'avatar')
```

### 文件结构详解

#### 1. 文档字符串（Docstring）

```python
"""add avatar to users

Revision ID: abc123def456
Revises: 9876543210ab
Create Date: 2026-02-11 14:30:00.123456

"""
```

- **第一行**：迁移描述（来自 `-m` 参数）
- **Revision ID**：当前迁移的唯一标识符（自动生成）
- **Revises**：父迁移的 ID（版本链的上一个节点）
- **Create Date**：创建时间戳

#### 2. 导入语句

```python
from alembic import op
import sqlalchemy as sa
```

- `op`：Alembic 的操作对象，提供所有迁移操作（`add_column`、`create_table` 等）
- `sa`：SQLAlchemy 的别名，用于定义列类型

**可选导入：**
```python
from sqlalchemy.dialects import postgresql  # PostgreSQL 特定类型
from sqlalchemy import text  # 执行原生 SQL
from sqlalchemy.orm import Session  # 使用 ORM
```

#### 3. 版本标识符

```python
revision = 'abc123def456'
down_revision = '9876543210ab'
branch_labels = None
depends_on = None
```

- **revision**：当前迁移的唯一 ID（16位随机字符串）
- **down_revision**：父迁移的 ID（形成版本链）
  - `None`：表示这是第一个迁移
  - 单个 ID：线性版本链
  - 元组：多个父迁移（分支合并）
- **branch_labels**：分支标签（用于多分支管理，通常为 `None`）
- **depends_on**：依赖的其他迁移（通常为 `None`）

#### 4. upgrade() 函数

```python
def upgrade():
    """正向迁移：应用变更"""
    op.add_column('users', sa.Column('avatar', sa.String(length=255), nullable=True))
    op.create_index(op.f('ix_users_avatar'), 'users', ['avatar'], unique=False)
```

- **作用**：定义如何将数据库从 `down_revision` 版本升级到 `revision` 版本
- **执行时机**：运行 `alembic upgrade` 时
- **操作顺序**：从上到下依次执行

#### 5. downgrade() 函数

```python
def downgrade():
    """反向迁移：撤销变更"""
    op.drop_index(op.f('ix_users_avatar'), table_name='users')
    op.drop_column('users', 'avatar')
```

- **作用**：定义如何将数据库从 `revision` 版本回滚到 `down_revision` 版本
- **执行时机**：运行 `alembic downgrade` 时
- **操作顺序**：通常是 `upgrade()` 的反向操作

---

## 1.3 常用的 op.* 操作

### 表操作

```python
# 创建表
op.create_table(
    'users',
    sa.Column('id', sa.Integer(), primary_key=True),
    sa.Column('email', sa.String(length=255), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'))
)

# 删除表
op.drop_table('users')

# 重命名表
op.rename_table('old_users', 'new_users')
```

### 列操作

```python
# 添加列
op.add_column('users', sa.Column('avatar', sa.String(length=255), nullable=True))

# 删除列
op.drop_column('users', 'avatar')

# 修改列（重命名）
op.alter_column('users', 'username', new_column_name='name')

# 修改列（类型）
op.alter_column('users', 'age',
    existing_type=sa.String(),
    type_=sa.Integer(),
    existing_nullable=True
)

# 修改列（可空性）
op.alter_column('users', 'email',
    existing_type=sa.String(),
    nullable=False
)
```

### 索引操作

```python
# 创建索引
op.create_index('ix_users_email', 'users', ['email'], unique=True)

# 创建复合索引
op.create_index('ix_users_name_email', 'users', ['name', 'email'])

# 删除索引
op.drop_index('ix_users_email', table_name='users')

# PostgreSQL 特定：创建并发索引（不锁表）
op.create_index('ix_users_email', 'users', ['email'],
    postgresql_concurrently=True)
```

### 约束操作

```python
# 创建外键
op.create_foreign_key(
    'fk_posts_user_id',  # 约束名
    'posts',             # 源表
    'users',             # 目标表
    ['user_id'],         # 源列
    ['id']               # 目标列
)

# 删除外键
op.drop_constraint('fk_posts_user_id', 'posts', type_='foreignkey')

# 创建唯一约束
op.create_unique_constraint('uq_users_email', 'users', ['email'])

# 删除唯一约束
op.drop_constraint('uq_users_email', 'users', type_='unique')

# 创建检查约束
op.create_check_constraint(
    'ck_users_age_positive',
    'users',
    'age > 0'
)
```

### 执行原生 SQL

```python
# 执行单条 SQL
op.execute("UPDATE users SET status = 'active' WHERE last_login > NOW() - INTERVAL '30 days'")

# 执行多条 SQL
op.execute("""
    CREATE OR REPLACE FUNCTION update_modified_column()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = now();
        RETURN NEW;
    END;
    $$ language 'plpgsql';
""")

# 使用 SQLAlchemy text
from sqlalchemy import text
op.execute(text("ALTER TABLE users ADD CONSTRAINT ..."))
```

---

## 1.4 迁移文件的命名规范

### 自动生成的文件名

```
abc123def456_add_avatar_to_users.py
│         │  └─ 描述（来自 -m 参数）
│         └─ 分隔符
└─ 版本号（16位随机字符串）
```

**命名规则：**
- 版本号：16位随机字符串（确保唯一性）
- 描述：小写字母，单词用下划线分隔
- 文件名：`{revision}_{description}.py`

**示例：**
```
abc123def456_create_users_table.py
def456789abc_add_avatar_to_users.py
789abcdef012_remove_old_field.py
```

### 描述的最佳实践

**好的描述：**
- ✅ `create_users_table`：清晰说明创建了什么
- ✅ `add_avatar_to_users`：说明添加了什么字段到哪个表
- ✅ `remove_deprecated_fields`：说明删除了什么
- ✅ `migrate_user_data`：说明数据迁移的目的

**不好的描述：**
- ❌ `update`：太模糊
- ❌ `fix`：没有说明修复了什么
- ❌ `changes`：没有说明变更内容
- ❌ `migration`：废话（所有文件都是迁移）

---

## 1.5 迁移文件的存放位置

### 默认目录结构

```
project/
├── alembic/
│   ├── versions/              # 迁移文件存放目录
│   │   ├── abc123_create_users.py
│   │   ├── def456_add_avatar.py
│   │   └── ghi789_add_posts.py
│   ├── env.py                 # 环境配置
│   ├── script.py.mako         # 迁移脚本模板
│   └── README
├── alembic.ini                # Alembic 配置文件
└── app/
    └── models/
        └── user.py
```

### 自定义迁移文件位置

**修改 alembic.ini：**
```ini
[alembic]
# 修改迁移文件存放目录
script_location = alembic
version_locations = alembic/versions

# 或者使用多个目录
version_locations = alembic/versions, alembic/versions_archive
```

---

## 1.6 在 AI Agent 后端开发中的应用

### 场景1：添加对话历史表

```python
# 1. 定义模型
# app/models/conversation.py
class Conversation(Base):
    __tablename__ = "conversations"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    title = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)

# 2. 生成迁移
alembic revision --autogenerate -m "create conversations table"

# 3. 生成的迁移文件
# versions/abc123_create_conversations_table.py
def upgrade():
    op.create_table('conversations',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('user_id', sa.Integer(), nullable=True),
        sa.Column('title', sa.String(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=True),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
        sa.PrimaryKeyConstraint('id')
    )

def downgrade():
    op.drop_table('conversations')
```

### 场景2：添加向量存储字段

```python
# 1. 定义模型（使用 pgvector）
from pgvector.sqlalchemy import Vector

class Document(Base):
    __tablename__ = "documents"
    id = Column(Integer, primary_key=True)
    content = Column(Text)
    embedding = Column(Vector(1536))  # OpenAI embedding 维度

# 2. 手动创建迁移（autogenerate 无法识别 Vector 类型）
alembic revision -m "add embedding to documents"

# 3. 手动编写迁移脚本
# versions/def456_add_embedding_to_documents.py
def upgrade():
    # 1. 启用 pgvector 扩展
    op.execute("CREATE EXTENSION IF NOT EXISTS vector")

    # 2. 添加向量字段
    op.add_column('documents',
        sa.Column('embedding', Vector(1536), nullable=True))

    # 3. 创建向量索引（加速相似度搜索）
    op.execute("""
        CREATE INDEX idx_documents_embedding
        ON documents
        USING ivfflat (embedding vector_cosine_ops)
        WITH (lists = 100)
    """)

def downgrade():
    op.drop_index('idx_documents_embedding', table_name='documents')
    op.drop_column('documents', 'embedding')
```

### 场景3：数据迁移（重构字段）

```python
# 场景：将 first_name 和 last_name 合并为 full_name

# versions/ghi789_merge_name_fields.py
def upgrade():
    # 1. 添加新字段
    op.add_column('users', sa.Column('full_name', sa.String(), nullable=True))

    # 2. 迁移数据
    op.execute("""
        UPDATE users
        SET full_name = first_name || ' ' || last_name
        WHERE full_name IS NULL
    """)

    # 3. 设置为非空
    op.alter_column('users', 'full_name', nullable=False)

    # 4. 删除旧字段
    op.drop_column('users', 'first_name')
    op.drop_column('users', 'last_name')

def downgrade():
    # 反向操作
    op.add_column('users', sa.Column('first_name', sa.String(), nullable=True))
    op.add_column('users', sa.Column('last_name', sa.String(), nullable=True))

    # 拆分数据（简化处理）
    op.execute("""
        UPDATE users
        SET first_name = split_part(full_name, ' ', 1),
            last_name = split_part(full_name, ' ', 2)
    """)

    op.drop_column('users', 'full_name')
```

---

## 总结

**迁移文件的核心要点：**

1. **生成方式**：autogenerate（快速）vs 手动创建（灵活）
2. **文件结构**：版本标识符 + upgrade() + downgrade()
3. **op.* 操作**：表、列、索引、约束、原生 SQL
4. **命名规范**：`{revision}_{description}.py`
5. **存放位置**：`alembic/versions/`

**在 AI Agent 后端开发中：**
- 用 autogenerate 处理简单的 schema 变更
- 用手动创建处理复杂的数据迁移
- 用原生 SQL 处理数据库特定功能（如 pgvector）

**记住：**
> 迁移文件是数据库变更的"源代码"，应该像对待代码一样对待它们：版本控制、代码审查、测试验证。
