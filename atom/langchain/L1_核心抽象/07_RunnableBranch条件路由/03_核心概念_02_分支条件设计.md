# 核心概念2：分支条件设计

深入理解如何设计高效、可维护的分支条件。

---

## 2.1 Lambda 函数作为条件

### 基础语法

```python
# 最简单的 lambda 条件
condition = lambda x: "urgent" in x

# 带类型提示的 lambda（Python 3.10+）
from typing import Callable

condition: Callable[[str], bool] = lambda x: "urgent" in x
```

### Lambda 的优势

1. **简洁**：一行代码表达条件
2. **内联**：直接写在 RunnableBranch 中
3. **闭包**：可以捕获外部变量

```python
# 闭包示例
keywords = ["urgent", "emergency", "critical"]

branch = RunnableBranch(
    (lambda x: any(kw in x.lower() for kw in keywords), urgent_handler),
    default_handler
)
```

### Lambda 的限制

1. **单表达式**：只能包含一个表达式
2. **无语句**：不能使用 if/for/while 语句
3. **调试困难**：没有函数名，难以追踪

```python
# ❌ 错误：lambda 不能包含语句
condition = lambda x: (
    result = process(x)  # SyntaxError
    return result > 0
)

# ✅ 正确：使用表达式
condition = lambda x: process(x) > 0
```

### 何时使用 Lambda

**适合**：
- 简单的条件判断
- 一行可以表达的逻辑
- 不需要复杂的错误处理

**不适合**：
- 需要多步计算
- 需要错误处理
- 需要详细日志

---

## 2.2 Runnable 作为条件

### 为什么需要 Runnable 条件？

Lambda 函数的限制：
- 无法使用 LLM 做语义判断
- 无法调用外部 API
- 无法做复杂的预处理

**Runnable 条件**解决了这些问题。

### 使用 LLM 作为条件

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.runnables import RunnableLambda, RunnableBranch

# 1. 创建 LLM 分类器
classifier_prompt = ChatPromptTemplate.from_template(
    """Classify the following message as 'urgent' or 'normal'.
    Only respond with one word: urgent or normal.

    Message: {text}

    Classification:"""
)

classifier = (
    classifier_prompt
    | ChatOpenAI(model="gpt-4o-mini", temperature=0)
    | RunnableLambda(lambda x: "urgent" in x.content.lower())
)

# 2. 使用 LLM 条件
branch = RunnableBranch(
    (classifier, urgent_handler),
    normal_handler
)

# 3. 执行
result = branch.invoke({"text": "HELP! System is down!"})
```

### 使用外部 API 作为条件

```python
import requests
from langchain_core.runnables import RunnableLambda

# 1. 创建 API 调用条件
def check_user_premium(x):
    """检查用户是否是高级会员"""
    user_id = x.get("user_id")
    response = requests.get(f"https://api.example.com/users/{user_id}")
    data = response.json()
    return data.get("is_premium", False)

api_condition = RunnableLambda(check_user_premium)

# 2. 使用 API 条件
branch = RunnableBranch(
    (api_condition, premium_handler),
    standard_handler
)
```

### 使用数据库查询作为条件

```python
from langchain_core.runnables import RunnableLambda

# 1. 创建数据库查询条件
def check_user_history(x):
    """检查用户历史记录"""
    user_id = x.get("user_id")
    # 假设有一个数据库连接
    query = "SELECT COUNT(*) FROM orders WHERE user_id = ? AND status = 'completed'"
    count = db.execute(query, (user_id,)).fetchone()[0]
    return count > 10  # 超过10个订单的老用户

db_condition = RunnableLambda(check_user_history)

# 2. 使用数据库条件
branch = RunnableBranch(
    (db_condition, vip_handler),
    new_user_handler
)
```

### Runnable 条件的最佳实践

#### 实践1：缓存结果

```python
from functools import lru_cache

# ❌ 不好：每次都调用 API
def check_premium(x):
    return requests.get(f"https://api.example.com/users/{x['user_id']}").json()["is_premium"]

# ✅ 好：缓存结果
@lru_cache(maxsize=1000)
def check_premium_cached(user_id: str) -> bool:
    return requests.get(f"https://api.example.com/users/{user_id}").json()["is_premium"]

condition = RunnableLambda(lambda x: check_premium_cached(x["user_id"]))
```

#### 实践2：错误处理

```python
def safe_api_condition(x):
    """带错误处理的 API 条件"""
    try:
        user_id = x.get("user_id")
        response = requests.get(
            f"https://api.example.com/users/{user_id}",
            timeout=2  # 设置超时
        )
        response.raise_for_status()
        return response.json().get("is_premium", False)
    except requests.RequestException as e:
        # 记录错误
        logger.error(f"API call failed: {e}")
        # 返回默认值
        return False

condition = RunnableLambda(safe_api_condition)
```

#### 实践3：超时控制

```python
from concurrent.futures import ThreadPoolExecutor, TimeoutError
import time

def slow_condition(x):
    """可能很慢的条件"""
    time.sleep(5)  # 模拟慢操作
    return True

def timeout_wrapper(func, timeout=2):
    """为条件函数添加超时"""
    def wrapper(x):
        with ThreadPoolExecutor(max_workers=1) as executor:
            future = executor.submit(func, x)
            try:
                return future.result(timeout=timeout)
            except TimeoutError:
                logger.warning(f"Condition timeout after {timeout}s")
                return False  # 超时返回 False
    return wrapper

# 使用
condition = RunnableLambda(timeout_wrapper(slow_condition, timeout=2))
```

---

## 2.3 复杂条件组合

### AND 组合

```python
# 方式1：lambda 中使用 and
condition = lambda x: (
    "urgent" in x.lower() and
    x.get("priority") == "high" and
    len(x["text"]) > 10
)

# 方式2：多个条件函数组合
def is_urgent(x):
    return "urgent" in x.lower()

def is_high_priority(x):
    return x.get("priority") == "high"

def is_long_text(x):
    return len(x["text"]) > 10

condition = lambda x: is_urgent(x) and is_high_priority(x) and is_long_text(x)

# 方式3：使用 all()
conditions = [is_urgent, is_high_priority, is_long_text]
condition = lambda x: all(cond(x) for cond in conditions)
```

### OR 组合

```python
# 方式1：lambda 中使用 or
condition = lambda x: (
    "urgent" in x.lower() or
    x.get("priority") == "high" or
    x.get("user_role") == "vip"
)

# 方式2：使用 any()
conditions = [
    lambda x: "urgent" in x.lower(),
    lambda x: x.get("priority") == "high",
    lambda x: x.get("user_role") == "vip"
]
condition = lambda x: any(cond(x) for cond in conditions)
```

### NOT 组合

```python
# 方式1：使用 not
condition = lambda x: not ("spam" in x.lower())

# 方式2：反转条件
def is_spam(x):
    return "spam" in x.lower()

condition = lambda x: not is_spam(x)
```

### 复杂组合

```python
# (A AND B) OR (C AND D)
condition = lambda x: (
    (is_urgent(x) and is_high_priority(x)) or
    (is_vip(x) and is_long_text(x))
)

# NOT (A OR B)
condition = lambda x: not (is_spam(x) or is_offensive(x))

# (A OR B) AND (C OR D)
condition = lambda x: (
    (is_urgent(x) or is_high_priority(x)) and
    (is_vip(x) or is_premium(x))
)
```

### 条件组合的最佳实践

#### 实践1：提取命名函数

```python
# ❌ 不好：复杂的内联条件
condition = lambda x: (
    ("urgent" in x.lower() or x.get("priority") == "high") and
    (x.get("user_role") in ["admin", "vip"]) and
    (len(x["text"]) > 10 and len(x["text"]) < 1000)
)

# ✅ 好：提取命名函数
def is_urgent_or_high_priority(x):
    return "urgent" in x.lower() or x.get("priority") == "high"

def is_privileged_user(x):
    return x.get("user_role") in ["admin", "vip"]

def is_valid_length(x):
    return 10 < len(x["text"]) < 1000

condition = lambda x: (
    is_urgent_or_high_priority(x) and
    is_privileged_user(x) and
    is_valid_length(x)
)
```

#### 实践2：短路评估

```python
# ✅ 利用短路评估优化性能
# 把最快的条件放在前面
condition = lambda x: (
    len(x["text"]) > 10 and  # 快速检查
    "urgent" in x.lower() and  # 中等速度
    expensive_check(x)  # 慢速检查（只在前面都为 True 时执行）
)
```

#### 实践3：条件工厂

```python
def create_keyword_condition(*keywords):
    """创建关键词匹配条件"""
    return lambda x: any(kw in x.lower() for kw in keywords)

def create_threshold_condition(field, threshold, operator=">"):
    """创建阈值条件"""
    ops = {
        ">": lambda a, b: a > b,
        "<": lambda a, b: a < b,
        ">=": lambda a, b: a >= b,
        "<=": lambda a, b: a <= b,
        "==": lambda a, b: a == b,
    }
    return lambda x: ops[operator](x.get(field, 0), threshold)

# 使用
urgent_condition = create_keyword_condition("urgent", "emergency", "critical")
high_score_condition = create_threshold_condition("score", 0.8, ">=")

branch = RunnableBranch(
    (urgent_condition, urgent_handler),
    (high_score_condition, high_confidence_handler),
    default_handler
)
```

---

## 2.4 条件评估顺序

### 为什么顺序重要？

RunnableBranch 是**顺序评估**的：
- 从上到下检查条件
- 第一个返回 True 的分支执行
- 后续条件不再评估

**顺序决定了优先级**。

### 错误的顺序

```python
# ❌ 错误：通用条件在前
branch = RunnableBranch(
    (lambda x: x > 0, positive_handler),      # 太通用
    (lambda x: x > 100, very_large_handler),  # 永远不会执行！
    (lambda x: x > 50, large_handler),        # 永远不会执行！
    negative_handler
)

# 输入 150
result = branch.invoke(150)
# 结果：positive_handler（错误！应该是 very_large_handler）
```

### 正确的顺序

```python
# ✅ 正确：从具体到通用
branch = RunnableBranch(
    (lambda x: x > 100, very_large_handler),  # 最具体
    (lambda x: x > 50, large_handler),        # 较具体
    (lambda x: x > 0, positive_handler),      # 较通用
    negative_handler                           # 默认
)

# 输入 150
result = branch.invoke(150)
# 结果：very_large_handler（正确！）
```

### 顺序设计原则

#### 原则1：从具体到通用

```python
# ✅ 正确顺序
branch = RunnableBranch(
    # 1. 最具体：同时满足多个条件
    (lambda x: "urgent" in x and x["priority"] == "high", urgent_high_handler),
    # 2. 较具体：满足一个强条件
    (lambda x: "urgent" in x, urgent_handler),
    # 3. 较通用：满足一个弱条件
    (lambda x: x["priority"] == "high", high_priority_handler),
    # 4. 默认：兜底
    default_handler
)
```

#### 原则2：从高优先级到低优先级

```python
# ✅ 按业务优先级排序
branch = RunnableBranch(
    # 1. 最高优先级：VIP 用户
    (lambda x: x["user_role"] == "vip", vip_handler),
    # 2. 高优先级：付费用户
    (lambda x: x["user_role"] == "premium", premium_handler),
    # 3. 普通优先级：注册用户
    (lambda x: x["user_role"] == "user", user_handler),
    # 4. 最低优先级：游客
    guest_handler
)
```

#### 原则3：从快到慢（性能优化）

```python
# ✅ 快速条件在前
branch = RunnableBranch(
    # 1. 最快：简单字段检查
    (lambda x: x.get("cached") == True, cached_handler),
    # 2. 较快：字符串匹配
    (lambda x: "urgent" in x["text"], urgent_handler),
    # 3. 较慢：正则表达式
    (lambda x: re.match(pattern, x["text"]), regex_handler),
    # 4. 最慢：LLM 调用
    (llm_classifier, llm_handler),
    default_handler
)
```

### 顺序优化示例

#### 示例1：意图识别

```python
# ❌ 不好的顺序
branch = RunnableBranch(
    (lambda x: len(x) > 0, general_handler),  # 太通用，会匹配所有
    (lambda x: "code" in x, code_handler),    # 永远不会执行
    (lambda x: "math" in x, math_handler),    # 永远不会执行
    default_handler
)

# ✅ 好的顺序
branch = RunnableBranch(
    (lambda x: "code" in x, code_handler),    # 具体意图
    (lambda x: "math" in x, math_handler),    # 具体意图
    (lambda x: len(x) > 0, general_handler),  # 通用处理
    default_handler
)
```

#### 示例2：多条件优先级

```python
# 业务需求：
# 1. VIP 用户的紧急请求 → 最高优先级
# 2. 所有紧急请求 → 高优先级
# 3. VIP 用户的普通请求 → 中优先级
# 4. 普通用户的普通请求 → 低优先级

branch = RunnableBranch(
    # 1. 最具体：VIP + 紧急
    (lambda x: x["is_vip"] and x["is_urgent"], vip_urgent_handler),
    # 2. 较具体：紧急（包括非 VIP）
    (lambda x: x["is_urgent"], urgent_handler),
    # 3. 较具体：VIP（非紧急）
    (lambda x: x["is_vip"], vip_handler),
    # 4. 默认：普通用户普通请求
    normal_handler
)
```

---

## 2.5 条件设计最佳实践

### 实践1：保持条件纯净

```python
# ❌ 不好：条件有副作用
def condition_with_side_effect(x):
    logger.info(f"Checking: {x}")  # 副作用
    db.increment_counter("checks")  # 副作用
    return x > 0

# ✅ 好：纯函数条件
def pure_condition(x):
    return x > 0

# 如果需要日志，在分支中处理
def handler_with_logging(x):
    logger.info(f"Handling: {x}")
    return process(x)
```

### 实践2：避免条件中的复杂计算

```python
# ❌ 不好：条件中做复杂计算
condition = lambda x: expensive_computation(x) > threshold

# ✅ 好：预先计算，条件只做判断
preprocessor = RunnableLambda(lambda x: {
    **x,
    "computed_value": expensive_computation(x)
})

condition = lambda x: x["computed_value"] > threshold

chain = preprocessor | RunnableBranch(
    (condition, handler),
    default_handler
)
```

### 实践3：使用类型提示

```python
from typing import Callable, Dict, Any

# ✅ 好：明确类型
def create_condition(threshold: float) -> Callable[[Dict[str, Any]], bool]:
    """创建阈值条件"""
    return lambda x: x.get("score", 0) > threshold

# 使用
high_score_condition = create_condition(0.8)
medium_score_condition = create_condition(0.5)
```

### 实践4：条件可测试

```python
# ✅ 好：可测试的条件
def is_urgent(x: Dict[str, Any]) -> bool:
    """检查是否紧急"""
    return "urgent" in x.get("text", "").lower()

# 单元测试
def test_is_urgent():
    assert is_urgent({"text": "URGENT: help"}) == True
    assert is_urgent({"text": "normal message"}) == False
    assert is_urgent({}) == False  # 边界情况
```

### 实践5：条件文档化

```python
def is_high_value_customer(x: Dict[str, Any]) -> bool:
    """
    判断是否是高价值客户

    高价值客户定义：
    - 总消费金额 > $1000
    - 或者是 VIP 会员
    - 且没有未解决的投诉

    Args:
        x: 包含 total_spent, is_vip, has_complaints 字段的字典

    Returns:
        bool: True 如果是高价值客户
    """
    return (
        (x.get("total_spent", 0) > 1000 or x.get("is_vip", False)) and
        not x.get("has_complaints", False)
    )
```

---

## 2.6 常见条件模式

### 模式1：白名单/黑名单

```python
# 白名单
whitelist = ["admin", "moderator", "vip"]
condition = lambda x: x.get("role") in whitelist

# 黑名单
blacklist = ["banned", "suspended"]
condition = lambda x: x.get("role") not in blacklist
```

### 模式2：范围检查

```python
# 数值范围
condition = lambda x: 0 < x["score"] < 1

# 长度范围
condition = lambda x: 10 <= len(x["text"]) <= 1000

# 时间范围
from datetime import datetime, timedelta
condition = lambda x: (
    datetime.now() - x["created_at"] < timedelta(hours=24)
)
```

### 模式3：模式匹配

```python
import re

# 邮箱
email_pattern = re.compile(r'^[\w\.-]+@[\w\.-]+\.\w+$')
condition = lambda x: bool(email_pattern.match(x["email"]))

# URL
url_pattern = re.compile(r'^https?://')
condition = lambda x: bool(url_pattern.match(x["url"]))

# 电话号码
phone_pattern = re.compile(r'^\+?1?\d{9,15}$')
condition = lambda x: bool(phone_pattern.match(x["phone"]))
```

### 模式4：多字段组合

```python
# 用户资格检查
def is_eligible_for_promotion(x):
    return (
        x.get("is_active", False) and
        x.get("email_verified", False) and
        x.get("account_age_days", 0) > 30 and
        x.get("total_orders", 0) > 5
    )
```

### 模式5：动态阈值

```python
# 根据时间动态调整阈值
from datetime import datetime

def get_threshold():
    """工作时间使用高阈值，非工作时间使用低阈值"""
    hour = datetime.now().hour
    return 0.8 if 9 <= hour <= 17 else 0.5

condition = lambda x: x["score"] > get_threshold()
```

---

## 2.7 条件性能优化

### 优化1：缓存条件结果

```python
from functools import lru_cache

# ❌ 不好：每次都计算
def expensive_condition(x):
    return expensive_computation(x) > threshold

# ✅ 好：缓存结果
@lru_cache(maxsize=1000)
def expensive_computation_cached(key: str):
    return expensive_computation(key)

condition = lambda x: expensive_computation_cached(x["key"]) > threshold
```

### 优化2：预计算

```python
# ❌ 不好：在条件中重复计算
branch = RunnableBranch(
    (lambda x: len(x["text"]) > 1000, long_handler),
    (lambda x: len(x["text"]) > 100, medium_handler),
    (lambda x: len(x["text"]) > 0, short_handler),
    default_handler
)

# ✅ 好：预计算长度
preprocessor = RunnableLambda(lambda x: {
    **x,
    "text_length": len(x["text"])
})

branch = RunnableBranch(
    (lambda x: x["text_length"] > 1000, long_handler),
    (lambda x: x["text_length"] > 100, medium_handler),
    (lambda x: x["text_length"] > 0, short_handler),
    default_handler
)

chain = preprocessor | branch
```

### 优化3：短路评估

```python
# ✅ 利用短路评估
# 把快速条件放在前面
condition = lambda x: (
    x.get("cached") == True or  # 快速检查缓存
    (x.get("score", 0) > 0.8 and expensive_check(x))  # 慢速检查
)
```

### 优化4：批量条件评估

```python
# 如果需要批量处理，可以优化条件评估
def batch_condition(inputs):
    """批量评估条件"""
    # 一次性获取所有需要的数据
    user_ids = [x["user_id"] for x in inputs]
    premium_status = batch_check_premium(user_ids)  # 批量 API 调用

    # 返回每个输入的条件结果
    return [premium_status[x["user_id"]] for x in inputs]
```

---

## 2.8 小结

**分支条件设计的关键要点**：

1. **Lambda vs Runnable**：
   - Lambda：简单条件
   - Runnable：复杂条件（LLM、API、数据库）

2. **条件组合**：
   - AND：所有条件都满足
   - OR：任一条件满足
   - NOT：条件不满足

3. **评估顺序**：
   - 从具体到通用
   - 从高优先级到低优先级
   - 从快到慢

4. **最佳实践**：
   - 保持条件纯净（无副作用）
   - 避免复杂计算（预先计算）
   - 使用类型提示
   - 条件可测试
   - 条件文档化

5. **性能优化**：
   - 缓存结果
   - 预计算
   - 短路评估
   - 批量处理

**下一步**：学习路由执行流程（核心概念3）。
