# 实战代码2：数据模型定义

完整的 Pydantic 数据模型定义最佳实践。

---

## 概述

本文档展示如何使用 Pydantic 定义类型安全、自动验证的数据模型。

---

## 1. 基础模型定义

### 1.1 简单模型

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str
    age: int

# 使用
user = User(id=1, name="Alice", email="alice@example.com", age=25)
print(user.name)  # Alice
print(user.model_dump())  # 转换为字典
```

### 1.2 带默认值的模型

```python
from pydantic import BaseModel
from typing import Optional

class User(BaseModel):
    id: int
    name: str
    email: str
    age: Optional[int] = None  # 可选字段
    is_active: bool = True  # 默认值
    role: str = "user"  # 默认值

# 使用
user1 = User(id=1, name="Alice", email="alice@example.com")
print(user1.age)  # None
print(user1.is_active)  # True

user2 = User(id=2, name="Bob", email="bob@example.com", age=30, role="admin")
```

### 1.3 Field 验证器

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    id: int = Field(..., gt=0, description="用户ID，必须大于0")
    name: str = Field(..., min_length=1, max_length=50)
    email: str = Field(..., pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")
    age: int = Field(..., ge=0, le=150)
    score: float = Field(0.0, ge=0.0, le=100.0)

# 使用
user = User(
    id=1,
    name="Alice",
    email="alice@example.com",
    age=25,
    score=95.5
)

# 验证失败示例
try:
    bad_user = User(
        id=-1,  # ❌ 必须大于0
        name="",  # ❌ 长度必须 >= 1
        email="invalid",  # ❌ 邮箱格式错误
        age=200  # ❌ 年龄超出范围
    )
except ValueError as e:
    print(e)
```

---

## 2. 自定义验证器

### 2.1 字段验证器

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    name: str
    email: str
    password: str

    @field_validator('email')
    @classmethod
    def validate_email(cls, v: str) -> str:
        """验证邮箱格式"""
        if '@' not in v:
            raise ValueError('Invalid email format')
        return v.lower()  # 转换为小写

    @field_validator('password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        """验证密码强度"""
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters')
        if not any(c.isupper() for c in v):
            raise ValueError('Password must contain uppercase letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain digit')
        return v

# 使用
user = User(
    name="Alice",
    email="ALICE@EXAMPLE.COM",  # 自动转小写
    password="SecurePass123"
)
print(user.email)  # alice@example.com
```

### 2.2 模型验证器

```python
from pydantic import BaseModel, model_validator

class DateRange(BaseModel):
    start_date: str
    end_date: str

    @model_validator(mode='after')
    def validate_date_range(self):
        """验证日期范围"""
        if self.start_date > self.end_date:
            raise ValueError('start_date must be before end_date')
        return self

# 使用
date_range = DateRange(start_date="2024-01-01", end_date="2024-12-31")

try:
    bad_range = DateRange(start_date="2024-12-31", end_date="2024-01-01")
except ValueError as e:
    print(e)  # start_date must be before end_date
```

### 2.3 多字段验证

```python
from pydantic import BaseModel, model_validator

class PaymentRequest(BaseModel):
    amount: float
    currency: str
    payment_method: str
    card_number: str | None = None

    @model_validator(mode='after')
    def validate_payment(self):
        """验证支付信息"""
        if self.payment_method == "card" and self.card_number is None:
            raise ValueError('card_number required for card payment')
        if self.amount <= 0:
            raise ValueError('amount must be positive')
        return self

# 使用
payment = PaymentRequest(
    amount=100.0,
    currency="USD",
    payment_method="card",
    card_number="1234-5678-9012-3456"
)
```

---

## 3. 嵌套模型

### 3.1 基础嵌套

```python
from pydantic import BaseModel
from typing import List

class Address(BaseModel):
    street: str
    city: str
    country: str
    postal_code: str

class User(BaseModel):
    id: int
    name: str
    email: str
    address: Address  # 嵌套模型

# 使用
user = User(
    id=1,
    name="Alice",
    email="alice@example.com",
    address=Address(
        street="123 Main St",
        city="New York",
        country="USA",
        postal_code="10001"
    )
)

print(user.address.city)  # New York
```

### 3.2 列表嵌套

```python
from pydantic import BaseModel
from typing import List

class Tag(BaseModel):
    name: str
    color: str

class Article(BaseModel):
    title: str
    content: str
    tags: List[Tag]  # 标签列表

# 使用
article = Article(
    title="Python Type Hints",
    content="...",
    tags=[
        Tag(name="python", color="blue"),
        Tag(name="typing", color="green")
    ]
)

for tag in article.tags:
    print(f"{tag.name}: {tag.color}")
```

### 3.3 可选嵌套

```python
from pydantic import BaseModel
from typing import Optional, List

class Profile(BaseModel):
    bio: str
    avatar_url: str

class SocialLinks(BaseModel):
    twitter: Optional[str] = None
    github: Optional[str] = None
    linkedin: Optional[str] = None

class User(BaseModel):
    id: int
    name: str
    email: str
    profile: Optional[Profile] = None  # 可选
    social_links: Optional[SocialLinks] = None  # 可选

# 使用
user1 = User(id=1, name="Alice", email="alice@example.com")
# profile 和 social_links 都是 None

user2 = User(
    id=2,
    name="Bob",
    email="bob@example.com",
    profile=Profile(bio="Developer", avatar_url="https://..."),
    social_links=SocialLinks(github="https://github.com/bob")
)
```

---

## 4. 模型继承

### 4.1 基础继承

```python
from pydantic import BaseModel, Field
from datetime import datetime

class TimestampMixin(BaseModel):
    """时间戳混入"""
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)

class User(TimestampMixin):
    """用户模型（继承时间戳）"""
    id: int
    name: str
    email: str

class Article(TimestampMixin):
    """文章模型（继承时间戳）"""
    id: int
    title: str
    content: str

# 使用
user = User(id=1, name="Alice", email="alice@example.com")
print(user.created_at)  # 自动生成

article = Article(id=1, title="Hello", content="World")
print(article.created_at)  # 自动生成
```

### 4.2 请求/响应模型继承

```python
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    """用户基础模型"""
    name: str = Field(..., min_length=1, max_length=50)
    email: str = Field(..., pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")
    age: Optional[int] = Field(None, ge=0, le=150)

class CreateUserRequest(UserBase):
    """创建用户请求（继承基础字段 + 密码）"""
    password: str = Field(..., min_length=8)

class UpdateUserRequest(BaseModel):
    """更新用户请求（所有字段可选）"""
    name: Optional[str] = Field(None, min_length=1, max_length=50)
    email: Optional[str] = None
    age: Optional[int] = Field(None, ge=0, le=150)

class UserResponse(UserBase):
    """用户响应（继承基础字段 + ID 和时间戳）"""
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # 允许从 ORM 对象创建

# 使用
create_req = CreateUserRequest(
    name="Alice",
    email="alice@example.com",
    age=25,
    password="SecurePass123"
)

update_req = UpdateUserRequest(name="Alice Smith")  # 只更新名字

response = UserResponse(
    id=1,
    name="Alice",
    email="alice@example.com",
    age=25,
    created_at=datetime.now(),
    updated_at=datetime.now()
)
```

---

## 5. 配置选项

### 5.1 Config 类

```python
from pydantic import BaseModel, ConfigDict

class User(BaseModel):
    model_config = ConfigDict(
        # 允许从 ORM 对象创建
        from_attributes=True,
        # 验证赋值
        validate_assignment=True,
        # 使用枚举值
        use_enum_values=True,
        # 严格模式
        strict=False,
        # 额外字段处理
        extra='forbid'  # 'allow', 'ignore', 'forbid'
    )

    id: int
    name: str
    email: str

# 使用
user = User(id=1, name="Alice", email="alice@example.com")

# 验证赋值
user.name = "Bob"  # 自动验证

# 禁止额外字段
try:
    bad_user = User(
        id=1,
        name="Alice",
        email="alice@example.com",
        extra_field="value"  # ❌ 不允许额外字段
    )
except ValueError as e:
    print(e)
```

### 5.2 JSON Schema 配置

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    model_config = ConfigDict(
        json_schema_extra={
            "examples": [
                {
                    "id": 1,
                    "name": "Alice",
                    "email": "alice@example.com"
                }
            ]
        }
    )

    id: int = Field(..., description="用户ID")
    name: str = Field(..., description="用户名")
    email: str = Field(..., description="邮箱地址")

# 获取 JSON Schema
print(User.model_json_schema())
```

---

## 6. 类型转换

### 6.1 自动类型转换

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    age: int
    is_active: bool

# Pydantic 自动转换类型
user = User(
    id="123",  # str -> int
    name="Alice",
    age="25",  # str -> int
    is_active="true"  # str -> bool
)

print(user.id)  # 123 (int)
print(user.age)  # 25 (int)
print(user.is_active)  # True (bool)
```

### 6.2 自定义类型转换

```python
from pydantic import BaseModel, field_validator
from datetime import datetime

class Event(BaseModel):
    name: str
    timestamp: datetime

    @field_validator('timestamp', mode='before')
    @classmethod
    def parse_timestamp(cls, v):
        """自定义时间戳解析"""
        if isinstance(v, str):
            return datetime.fromisoformat(v)
        if isinstance(v, int):
            return datetime.fromtimestamp(v)
        return v

# 使用
event1 = Event(name="Meeting", timestamp="2024-01-01T10:00:00")
event2 = Event(name="Call", timestamp=1704096000)
event3 = Event(name="Event", timestamp=datetime.now())
```

---

## 7. AI Agent 数据模型

### 7.1 聊天消息模型

```python
from pydantic import BaseModel, Field
from typing import List, Literal, Optional

class Message(BaseModel):
    """聊天消息"""
    role: Literal["user", "assistant", "system"]
    content: str = Field(..., min_length=1)
    name: Optional[str] = None

class ChatRequest(BaseModel):
    """聊天请求"""
    messages: List[Message] = Field(..., min_items=1)
    model: Literal["gpt-4", "gpt-3.5-turbo", "claude-3"] = "gpt-4"
    temperature: float = Field(0.7, ge=0, le=2)
    max_tokens: int = Field(1000, ge=1, le=4000)
    stream: bool = False

    @model_validator(mode='after')
    def validate_messages(self):
        """验证消息列表"""
        if not self.messages:
            raise ValueError('messages cannot be empty')
        if self.messages[0].role == "assistant":
            raise ValueError('first message must be from user or system')
        return self

class ChatResponse(BaseModel):
    """聊天响应"""
    message: str
    tokens_used: int
    model: str
    finish_reason: Literal["stop", "length", "error"]

# 使用
request = ChatRequest(
    messages=[
        Message(role="system", content="You are a helpful assistant"),
        Message(role="user", content="Hello!")
    ],
    model="gpt-4",
    temperature=0.7
)

response = ChatResponse(
    message="Hi! How can I help you?",
    tokens_used=15,
    model="gpt-4",
    finish_reason="stop"
)
```

### 7.2 工具调用模型

```python
from pydantic import BaseModel, Field
from typing import List, Dict, Any, Literal

class ToolParameter(BaseModel):
    """工具参数定义"""
    name: str
    type: Literal["string", "number", "boolean", "object", "array"]
    description: str
    required: bool = True

class ToolDefinition(BaseModel):
    """工具定义"""
    name: str = Field(..., pattern=r"^[a-z_]+$")
    description: str
    parameters: List[ToolParameter]

class ToolCall(BaseModel):
    """工具调用"""
    tool_name: str
    parameters: Dict[str, Any]

class AgentRequest(BaseModel):
    """Agent 请求"""
    prompt: str = Field(..., min_length=1)
    tools: List[ToolDefinition]
    max_iterations: int = Field(5, ge=1, le=10)

class AgentResponse(BaseModel):
    """Agent 响应"""
    message: str
    tool_calls: List[ToolCall]
    final_answer: str
    iterations_used: int

# 使用
request = AgentRequest(
    prompt="Search for Python tutorials",
    tools=[
        ToolDefinition(
            name="search",
            description="Search the web",
            parameters=[
                ToolParameter(
                    name="query",
                    type="string",
                    description="Search query"
                )
            ]
        )
    ]
)

response = AgentResponse(
    message="Searching...",
    tool_calls=[
        ToolCall(
            tool_name="search",
            parameters={"query": "Python tutorials"}
        )
    ],
    final_answer="Found 10 tutorials",
    iterations_used=2
)
```

### 7.3 RAG 数据模型

```python
from pydantic import BaseModel, Field
from typing import List, Optional

class Document(BaseModel):
    """文档"""
    id: str
    content: str
    metadata: dict[str, str] = {}

class QueryRequest(BaseModel):
    """查询请求"""
    query: str = Field(..., min_length=1)
    top_k: int = Field(5, ge=1, le=20)
    filters: Optional[dict[str, str]] = None

class SearchResult(BaseModel):
    """搜索结果"""
    document: Document
    score: float = Field(..., ge=0, le=1)
    rank: int

class RAGResponse(BaseModel):
    """RAG 响应"""
    answer: str
    sources: List[SearchResult]
    confidence: float = Field(..., ge=0, le=1)

# 使用
query = QueryRequest(
    query="What is Python?",
    top_k=3,
    filters={"category": "programming"}
)

response = RAGResponse(
    answer="Python is a programming language...",
    sources=[
        SearchResult(
            document=Document(
                id="doc1",
                content="Python is...",
                metadata={"source": "wikipedia"}
            ),
            score=0.95,
            rank=1
        )
    ],
    confidence=0.9
)
```

---

## 8. 实战示例：完整的用户管理系统

```python
from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import Optional, List
from datetime import datetime
from enum import Enum

# 枚举类型
class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

class UserStatus(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    BANNED = "banned"

# 基础模型
class UserBase(BaseModel):
    """用户基础信息"""
    name: str = Field(..., min_length=1, max_length=50)
    email: str = Field(..., pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")
    age: Optional[int] = Field(None, ge=0, le=150)

    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()

# 创建请求
class CreateUserRequest(UserBase):
    """创建用户请求"""
    password: str = Field(..., min_length=8)
    role: UserRole = UserRole.USER

    @field_validator('password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        if not any(c.isupper() for c in v):
            raise ValueError('Password must contain uppercase')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain digit')
        return v

# 更新请求
class UpdateUserRequest(BaseModel):
    """更新用户请求"""
    name: Optional[str] = Field(None, min_length=1, max_length=50)
    email: Optional[str] = None
    age: Optional[int] = Field(None, ge=0, le=150)
    role: Optional[UserRole] = None
    status: Optional[UserStatus] = None

# 响应模型
class UserResponse(UserBase):
    """用户响应"""
    model_config = ConfigDict(from_attributes=True)

    id: int
    role: UserRole
    status: UserStatus
    created_at: datetime
    updated_at: datetime
    last_login: Optional[datetime] = None

# 列表响应
class UserListResponse(BaseModel):
    """用户列表响应"""
    total: int
    page: int
    page_size: int
    users: List[UserResponse]

# 使用示例
if __name__ == "__main__":
    # 创建用户
    create_req = CreateUserRequest(
        name="Alice",
        email="ALICE@EXAMPLE.COM",
        age=25,
        password="SecurePass123",
        role=UserRole.ADMIN
    )
    print(create_req.email)  # alice@example.com（自动转小写）

    # 更新用户
    update_req = UpdateUserRequest(
        name="Alice Smith",
        status=UserStatus.ACTIVE
    )

    # 用户响应
    user = UserResponse(
        id=1,
        name="Alice",
        email="alice@example.com",
        age=25,
        role=UserRole.ADMIN,
        status=UserStatus.ACTIVE,
        created_at=datetime.now(),
        updated_at=datetime.now()
    )

    # 列表响应
    user_list = UserListResponse(
        total=100,
        page=1,
        page_size=10,
        users=[user]
    )

    # 序列化
    print(user.model_dump_json(indent=2))
```

---

## 总结

### Pydantic 最佳实践

1. **使用 Field 验证**：添加约束和描述
2. **自定义验证器**：复杂验证逻辑
3. **模型继承**：复用公共字段
4. **嵌套模型**：组织复杂数据结构
5. **Config 配置**：控制模型行为
6. **类型转换**：自动或自定义转换
7. **枚举类型**：限定可选值
8. **文档化**：添加描述和示例

### 常用模式

```python
# 基础模型
class Base(BaseModel):
    pass

# 创建请求（+ 密码等敏感字段）
class CreateRequest(Base):
    password: str

# 更新请求（所有字段可选）
class UpdateRequest(BaseModel):
    field: Optional[str] = None

# 响应模型（+ ID 和时间戳）
class Response(Base):
    id: int
    created_at: datetime
```

### 下一步

学习完数据模型定义后，继续学习：
- 类型检查工作流集成
- FastAPI 完整项目实战
- 生产环境最佳实践
