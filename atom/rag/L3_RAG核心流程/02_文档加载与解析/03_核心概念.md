# 核心概念

> Document 对象、Loader 架构、5种核心格式解析 —— 文档加载的三大支柱

---

## 概述

文档加载与解析的核心就是三个概念：

| 概念 | 一句话解释 | 解决什么问题 |
|-----|----------|-------------|
| **Document 对象** | 统一的文档数据结构 | 不同格式输出统一格式 |
| **Loader 架构** | 加载器的设计模式 | 如何组织和扩展解析能力 |
| **5种格式解析** | PDF/Word/HTML/MD/TXT | 掌握最常用格式的解析策略 |

---

## 核心概念1：Document 对象

### 一句话定义

**Document 是 RAG 系统中表示文档的统一数据结构，包含文本内容和元数据两部分。**

### 为什么需要统一的数据结构？

```
没有统一结构（混乱）:
PDF 解析器返回 → {"text": "...", "pages": [...]}
Word 解析器返回 → {"content": "...", "paragraphs": [...]}
HTML 解析器返回 → {"body": "...", "title": "..."}

后续处理需要针对每种格式写不同的代码！

有统一结构（清晰）:
PDF 解析器返回 → Document(page_content="...", metadata={...})
Word 解析器返回 → Document(page_content="...", metadata={...})
HTML 解析器返回 → Document(page_content="...", metadata={...})

后续处理只需要处理一种格式！
```

### Document 对象结构

```python
from dataclasses import dataclass
from typing import Dict, Any

@dataclass
class Document:
    """RAG 系统中的统一文档对象"""

    # 核心字段：文本内容
    page_content: str

    # 元数据字段：来源信息
    metadata: Dict[str, Any]

# 实际使用示例
doc = Document(
    page_content="第一章 退款政策\n客户可在购买后7天内申请退款...",
    metadata={
        "source": "policy.pdf",      # 来源文件
        "page": 1,                    # 页码
        "total_pages": 10,            # 总页数
        "file_type": "pdf",           # 文件类型
        "created_at": "2024-01-15",   # 创建时间
        "author": "HR部门"            # 作者
    }
)
```

### 元数据的作用

```python
# 1. 答案溯源：告诉用户答案来自哪里
print(f"答案来源：{doc.metadata['source']} 第{doc.metadata['page']}页")
# 输出：答案来源：policy.pdf 第1页

# 2. 过滤检索：只搜索特定来源
results = vector_store.search(
    query="退款政策",
    filter={"source": "policy.pdf"}  # 只搜索这个文件
)

# 3. 权限控制：根据来源控制访问
if doc.metadata.get("department") == "HR":
    # 只有 HR 部门可以访问
    pass
```

### 前端类比

```javascript
// Document 对象 ≈ 前端的标准化 API 响应格式

// 不同 API 返回不同格式（混乱）
const userApi = { data: { name: "张三" } }
const orderApi = { result: { orderId: "123" } }

// 统一响应格式（清晰）
const response = {
  data: { ... },      // ≈ page_content
  meta: {             // ≈ metadata
    source: "user-api",
    timestamp: "2024-01-15"
  }
}
```

---

## 核心概念2：Loader 架构

### 一句话定义

**Loader 是负责加载特定格式文档的组件，遵循统一接口，输出标准 Document 对象。**

### Loader 的设计模式

```
┌─────────────────────────────────────────────────────────────┐
│                      BaseLoader（基类）                       │
│                                                             │
│  定义统一接口：                                               │
│  - load() → List[Document]                                  │
│  - lazy_load() → Iterator[Document]                         │
└─────────────────────────────────────────────────────────────┘
                              ↑
          ┌───────────────────┼───────────────────┐
          │                   │                   │
    ┌─────┴─────┐      ┌─────┴─────┐      ┌─────┴─────┐
    │ PDFLoader │      │ DocxLoader│      │ HTMLLoader│
    │           │      │           │      │           │
    │ 解析 PDF  │      │ 解析 Word │      │ 解析 HTML │
    └───────────┘      └───────────┘      └───────────┘
```

### Loader 接口定义

```python
from abc import ABC, abstractmethod
from typing import List, Iterator

class BaseLoader(ABC):
    """所有 Loader 的基类"""

    @abstractmethod
    def load(self) -> List[Document]:
        """加载文档，返回 Document 列表"""
        pass

    def lazy_load(self) -> Iterator[Document]:
        """惰性加载，适合大文件"""
        # 默认实现：直接调用 load()
        return iter(self.load())

# 具体实现示例
class TextLoader(BaseLoader):
    def __init__(self, file_path: str):
        self.file_path = file_path

    def load(self) -> List[Document]:
        with open(self.file_path, 'r', encoding='utf-8') as f:
            text = f.read()

        return [Document(
            page_content=text,
            metadata={"source": self.file_path}
        )]
```

### 为什么用这种架构？

| 优点 | 解释 |
|-----|------|
| **统一接口** | 所有 Loader 用法一致，学一个会全部 |
| **易于扩展** | 新增格式只需实现新 Loader |
| **可替换** | 同一格式可以有多个 Loader 实现 |
| **惰性加载** | 大文件可以流式处理，节省内存 |

### 前端类比

```javascript
// Loader 架构 ≈ 前端的数据获取层

// 统一接口
class BaseDataSource {
  async fetch() { throw new Error('Not implemented') }
}

// 不同实现
class RestApiSource extends BaseDataSource {
  async fetch() { return axios.get(this.url) }
}

class GraphQLSource extends BaseDataSource {
  async fetch() { return apolloClient.query(this.query) }
}

// 使用时不关心具体实现
const data = await dataSource.fetch()
```

---

## 核心概念3：5种核心格式解析

### 格式难度对比

```
解析难度排行：

PDF     ████████████████████  ⭐⭐⭐ 最难
Word    ████████████          ⭐⭐   中等
HTML    ████████              ⭐⭐   中等
Markdown ████                 ⭐     简单
TXT     ██                    ⭐     最简单
```

### 格式1：PDF 解析

**为什么 PDF 最难？**

```
PDF 的设计目标：精确还原打印效果
PDF 的存储方式：
- 文本被拆分成独立的"绘制指令"
- 每个字符有独立的坐标位置
- 没有"段落"、"表格"的概念

例如 "Hello World" 在 PDF 中可能是：
BT
/F1 12 Tf
100 700 Td
(H) Tj
110 700 Td
(e) Tj
120 700 Td
(l) Tj
...
ET

解析器需要：重组这些字符 → 识别段落 → 处理表格
```

**常用 PDF 解析库对比：**

| 库 | 优点 | 缺点 | 适用场景 |
|---|------|------|---------|
| `pypdf` | 轻量、纯 Python | 复杂布局效果差 | 简单文本 PDF |
| `pdfplumber` | 表格提取好 | 速度较慢 | 含表格的 PDF |
| `unstructured` | 效果最好 | 依赖多、较重 | 复杂布局 PDF |
| `PyMuPDF` | 速度快 | 需要系统依赖 | 大量 PDF 处理 |

```python
# pypdf 示例
from pypdf import PdfReader

def load_pdf_pypdf(file_path: str) -> List[Document]:
    reader = PdfReader(file_path)
    documents = []

    for i, page in enumerate(reader.pages):
        text = page.extract_text()
        documents.append(Document(
            page_content=text,
            metadata={
                "source": file_path,
                "page": i + 1,
                "total_pages": len(reader.pages)
            }
        ))

    return documents
```

### 格式2：Word (.docx) 解析

**Word 文件的本质：**

```
.docx 文件 = ZIP 压缩包
├── [Content_Types].xml
├── _rels/
├── docProps/
└── word/
    ├── document.xml    ← 主要内容在这里
    ├── styles.xml
    └── ...

document.xml 结构：
<w:document>
  <w:body>
    <w:p>  ← 段落
      <w:r>  ← 文本运行
        <w:t>这是文本内容</w:t>
      </w:r>
    </w:p>
  </w:body>
</w:document>
```

```python
# python-docx 示例
from docx import Document as DocxDocument

def load_docx(file_path: str) -> List[Document]:
    doc = DocxDocument(file_path)

    # 提取所有段落文本
    paragraphs = [para.text for para in doc.paragraphs if para.text.strip()]
    full_text = "\n\n".join(paragraphs)

    return [Document(
        page_content=full_text,
        metadata={
            "source": file_path,
            "file_type": "docx",
            "paragraph_count": len(paragraphs)
        }
    )]
```

### 格式3：HTML 解析

**HTML 解析的关键：去除标签，保留结构**

```html
<!-- 原始 HTML -->
<html>
<head><title>公司政策</title></head>
<body>
  <nav>导航栏（不需要）</nav>
  <main>
    <h1>退款政策</h1>
    <p>客户可在7天内申请退款。</p>
  </main>
  <footer>页脚（不需要）</footer>
</body>
</html>

<!-- 期望提取 -->
退款政策
客户可在7天内申请退款。
```

```python
# BeautifulSoup 示例
from bs4 import BeautifulSoup

def load_html(file_path: str) -> List[Document]:
    with open(file_path, 'r', encoding='utf-8') as f:
        html_content = f.read()

    soup = BeautifulSoup(html_content, 'html.parser')

    # 移除不需要的标签
    for tag in soup(['script', 'style', 'nav', 'footer', 'header']):
        tag.decompose()

    # 提取文本
    text = soup.get_text(separator='\n', strip=True)

    # 提取标题作为元数据
    title = soup.title.string if soup.title else ""

    return [Document(
        page_content=text,
        metadata={
            "source": file_path,
            "title": title,
            "file_type": "html"
        }
    )]
```

### 格式4：Markdown 解析

**Markdown 解析的选择：保留还是去除格式？**

```markdown
# 原始 Markdown
## 退款政策

客户可在 **7天内** 申请退款。

- 条件1：未使用
- 条件2：有发票

# 选择1：保留格式（推荐用于技术文档）
## 退款政策
客户可在 **7天内** 申请退款。
- 条件1：未使用
- 条件2：有发票

# 选择2：去除格式（推荐用于语义检索）
退款政策
客户可在 7天内 申请退款。
条件1：未使用
条件2：有发票
```

```python
# 简单 Markdown 加载（保留格式）
def load_markdown(file_path: str) -> List[Document]:
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # 提取标题（第一个 # 开头的行）
    lines = content.split('\n')
    title = ""
    for line in lines:
        if line.startswith('# '):
            title = line[2:].strip()
            break

    return [Document(
        page_content=content,
        metadata={
            "source": file_path,
            "title": title,
            "file_type": "markdown"
        }
    )]
```

### 格式5：TXT 纯文本

**最简单的格式，但要注意编码问题**

```python
def load_txt(file_path: str, encoding: str = 'utf-8') -> List[Document]:
    """
    加载纯文本文件

    注意：编码问题是最常见的坑
    - 中文文件可能是 GBK/GB2312
    - 日文文件可能是 Shift-JIS
    - 建议使用 chardet 自动检测
    """
    try:
        with open(file_path, 'r', encoding=encoding) as f:
            content = f.read()
    except UnicodeDecodeError:
        # 尝试其他编码
        import chardet
        with open(file_path, 'rb') as f:
            raw = f.read()
        detected = chardet.detect(raw)
        content = raw.decode(detected['encoding'])

    return [Document(
        page_content=content,
        metadata={
            "source": file_path,
            "file_type": "txt"
        }
    )]
```

---

## 5种格式速查表

| 格式 | 推荐库 | 核心难点 | 解析策略 |
|-----|-------|---------|---------|
| PDF | `pypdf` / `pdfplumber` | 布局重组、表格提取 | 按页解析，保留页码 |
| Word | `python-docx` | 样式处理、嵌入对象 | 提取段落，忽略样式 |
| HTML | `beautifulsoup4` | 去除噪音标签 | 移除 script/style/nav |
| Markdown | 直接读取 | 是否保留格式 | 通常保留原格式 |
| TXT | 内置 `open()` | 编码检测 | 自动检测编码 |

---

## 检查清单

学完本节，你应该能回答：

- [ ] Document 对象包含哪两个核心字段？
- [ ] 为什么需要统一的 Loader 接口？
- [ ] PDF 为什么是最难解析的格式？
- [ ] 解析 HTML 时应该移除哪些标签？
- [ ] 处理 TXT 文件时最常见的问题是什么？

---

**下一步：** [04_最小可用](./04_最小可用.md) - 掌握20%核心知识，解决80%问题
