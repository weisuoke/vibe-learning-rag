# 实战代码：基础信号处理实现

> 完整可运行的信号处理代码示例

---

## 代码说明

本示例演示如何在 FastAPI 应用中实现基础的信号处理，包括：
- 注册 SIGTERM 和 SIGINT 信号处理器
- 使用 asyncio.Event 通知协程
- 实现简单的优雅关闭流程

**运行环境：**
- Python 3.13+
- FastAPI
- Uvicorn

---

## 完整代码

```python
"""
基础信号处理实现
演示：注册信号处理器、捕获信号、执行优雅关闭

运行方式：
    python 07_实战代码_01_基础信号处理实现.py

测试方式：
    1. 启动应用
    2. 在另一个终端发送请求：curl http://localhost:8000/
    3. 发送 SIGTERM 信号：kill -SIGTERM <pid>
    4. 观察优雅关闭流程
"""

import signal
import asyncio
import sys
import os
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
import uvicorn

# ===== 1. 全局状态 =====
app = FastAPI(title="基础信号处理示例")

# 关闭事件
shutdown_event = asyncio.Event()

# 请求状态
accepting_requests = True
active_requests = 0

# ===== 2. 信号处理器 =====
def signal_handler(signum, frame):
    """
    信号处理器函数

    参数：
        signum: 信号编号（15=SIGTERM, 2=SIGINT）
        frame: 当前栈帧对象
    """
    # 获取信号名称
    signal_name = signal.Signals(signum).name

    print(f"\n{'='*60}")
    print(f"收到信号: {signal_name} ({signum})")
    print(f"进程 PID: {os.getpid()}")
    print(f"当前位置: {frame.f_code.co_filename}:{frame.f_lineno}")
    print(f"{'='*60}\n")

    # 设置关闭事件，通知所有等待的协程
    shutdown_event.set()

# 注册信号处理器
signal.signal(signal.SIGTERM, signal_handler)  # Docker/K8s 发送的信号
signal.signal(signal.SIGINT, signal_handler)   # Ctrl+C 发送的信号

print(f"信号处理器已注册")
print(f"  - SIGTERM (15): 优雅终止")
print(f"  - SIGINT (2): 中断（Ctrl+C）")

# ===== 3. 请求排空中间件 =====
@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    """
    请求排空中间件

    功能：
    1. 检查是否正在关闭
    2. 跟踪活跃请求数
    3. 拒绝新请求（如果正在关闭）
    """
    global active_requests

    # 检查是否正在关闭
    if not accepting_requests:
        return JSONResponse(
            status_code=503,
            content={
                "error": "Server is shutting down",
                "message": "Please retry in a few seconds"
            },
            headers={"Retry-After": "10"}
        )

    # 记录活跃请求数
    active_requests += 1
    print(f"[请求开始] 活跃请求数: {active_requests}")

    try:
        # 处理请求
        response = await call_next(request)
        return response

    finally:
        # 请求完成，计数器-1
        active_requests -= 1
        print(f"[请求完成] 活跃请求数: {active_requests}")

# ===== 4. 示例路由 =====
@app.get("/")
async def root():
    """根路由"""
    return {
        "message": "Hello World",
        "status": "running",
        "active_requests": active_requests
    }

@app.get("/fast")
async def fast_endpoint():
    """快速端点（1秒）"""
    await asyncio.sleep(1)
    return {"message": "Fast response", "duration": "1s"}

@app.get("/slow")
async def slow_endpoint():
    """慢速端点（5秒）"""
    print("[慢速端点] 开始处理...")

    # 模拟长时间处理，每秒检查一次关闭信号
    for i in range(5):
        if shutdown_event.is_set():
            print(f"[慢速端点] 检测到关闭信号，在第 {i} 秒中断")
            raise HTTPException(
                status_code=503,
                detail="Request interrupted due to server shutdown"
            )

        await asyncio.sleep(1)
        print(f"[慢速端点] 处理中... {i+1}/5")

    print("[慢速端点] 处理完成")
    return {"message": "Slow response", "duration": "5s"}

@app.get("/status")
async def get_status():
    """获取服务器状态"""
    return {
        "accepting_requests": accepting_requests,
        "active_requests": active_requests,
        "shutdown_requested": shutdown_event.is_set()
    }

# ===== 5. 优雅关闭逻辑 =====
async def wait_for_requests(timeout: int = 30):
    """
    等待所有请求完成

    参数：
        timeout: 最大等待时间（秒）
    """
    global accepting_requests

    # 停止接收新请求
    accepting_requests = False
    print(f"\n[请求排空] 停止接收新请求")
    print(f"[请求排空] 当前活跃请求数: {active_requests}")

    # 等待现有请求完成
    start_time = asyncio.get_event_loop().time()

    while active_requests > 0:
        # 检查超时
        elapsed = asyncio.get_event_loop().time() - start_time
        if elapsed > timeout:
            print(f"\n[请求排空] 超时（{timeout}秒）")
            print(f"[请求排空] 还有 {active_requests} 个请求未完成")
            break

        # 显示进度
        if int(elapsed) % 5 == 0 and elapsed > 0:
            print(f"[请求排空] 等待中... 剩余 {active_requests} 个请求 ({elapsed:.1f}s)")

        await asyncio.sleep(0.1)

    if active_requests == 0:
        print(f"\n[请求排空] ✓ 所有请求已完成")
    else:
        print(f"\n[请求排空] ✗ 还有 {active_requests} 个请求未完成")

async def cleanup_resources():
    """
    清理资源

    在实际应用中，这里应该：
    - 关闭数据库连接池
    - 关闭 Redis 连接
    - 关闭其他外部连接
    """
    print(f"\n[资源清理] 开始清理资源...")

    # 模拟资源清理
    await asyncio.sleep(1)

    print(f"[资源清理] ✓ 资源清理完成")

async def graceful_shutdown():
    """
    优雅关闭主流程

    流程：
    1. 等待请求完成
    2. 清理资源
    3. 退出进程
    """
    print(f"\n{'='*60}")
    print(f"开始优雅关闭")
    print(f"{'='*60}")

    # 1. 等待请求完成
    await wait_for_requests(timeout=30)

    # 2. 清理资源
    await cleanup_resources()

    # 3. 退出
    print(f"\n{'='*60}")
    print(f"优雅关闭完成")
    print(f"{'='*60}\n")

    sys.exit(0)

# ===== 6. 关闭监听器 =====
async def shutdown_monitor():
    """
    监听关闭信号

    等待 shutdown_event 被设置，然后执行优雅关闭
    """
    # 等待关闭信号
    await shutdown_event.wait()

    # 执行优雅关闭
    await graceful_shutdown()

# ===== 7. 生命周期事件 =====
@app.on_event("startup")
async def startup_event():
    """应用启动时"""
    print(f"\n{'='*60}")
    print(f"应用启动")
    print(f"进程 PID: {os.getpid()}")
    print(f"{'='*60}\n")

    # 启动关闭监听器
    asyncio.create_task(shutdown_monitor())

    print(f"提示：")
    print(f"  - 访问 http://localhost:8000/ 测试快速请求")
    print(f"  - 访问 http://localhost:8000/slow 测试慢速请求")
    print(f"  - 按 Ctrl+C 或发送 SIGTERM 信号测试优雅关闭")
    print(f"  - 发送信号命令: kill -SIGTERM {os.getpid()}")
    print()

@app.on_event("shutdown")
async def shutdown_event():
    """应用关闭时"""
    print(f"\n[FastAPI] shutdown 事件触发")

# ===== 8. 主函数 =====
def main():
    """主函数"""
    print(f"{'='*60}")
    print(f"基础信号处理示例")
    print(f"{'='*60}\n")

    # 运行应用
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info"
    )

if __name__ == "__main__":
    main()
```

---

## 运行示例

### 1. 启动应用

```bash
python 07_实战代码_01_基础信号处理实现.py
```

**预期输出：**
```
============================================================
基础信号处理示例
============================================================

信号处理器已注册
  - SIGTERM (15): 优雅终止
  - SIGINT (2): 中断（Ctrl+C）

============================================================
应用启动
进程 PID: 12345
============================================================

提示：
  - 访问 http://localhost:8000/ 测试快速请求
  - 访问 http://localhost:8000/slow 测试慢速请求
  - 按 Ctrl+C 或发送 SIGTERM 信号测试优雅关闭
  - 发送信号命令: kill -SIGTERM 12345

INFO:     Started server process [12345]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
```

### 2. 测试快速请求

```bash
# 在另一个终端
curl http://localhost:8000/
```

**预期输出：**
```json
{
  "message": "Hello World",
  "status": "running",
  "active_requests": 1
}
```

**服务器日志：**
```
[请求开始] 活跃请求数: 1
INFO:     127.0.0.1:54321 - "GET / HTTP/1.1" 200 OK
[请求完成] 活跃请求数: 0
```

### 3. 测试慢速请求

```bash
curl http://localhost:8000/slow
```

**预期输出：**
```json
{
  "message": "Slow response",
  "duration": "5s"
}
```

**服务器日志：**
```
[请求开始] 活跃请求数: 1
[慢速端点] 开始处理...
[慢速端点] 处理中... 1/5
[慢速端点] 处理中... 2/5
[慢速端点] 处理中... 3/5
[慢速端点] 处理中... 4/5
[慢速端点] 处理中... 5/5
[慢速端点] 处理完成
INFO:     127.0.0.1:54322 - "GET /slow HTTP/1.1" 200 OK
[请求完成] 活跃请求数: 0
```

### 4. 测试优雅关闭（方式1：Ctrl+C）

在服务器终端按 `Ctrl+C`：

**预期输出：**
```
^C
============================================================
收到信号: SIGINT (2)
进程 PID: 12345
当前位置: /path/to/file.py:45
============================================================

============================================================
开始优雅关闭
============================================================

[请求排空] 停止接收新请求
[请求排空] 当前活跃请求数: 0

[请求排空] ✓ 所有请求已完成

[资源清理] 开始清理资源...
[资源清理] ✓ 资源清理完成

============================================================
优雅关闭完成
============================================================
```

### 5. 测试优雅关闭（方式2：SIGTERM）

```bash
# 获取进程 PID
ps aux | grep python

# 发送 SIGTERM 信号
kill -SIGTERM 12345
```

**预期输出：** 同上

### 6. 测试优雅关闭（有活跃请求）

```bash
# 终端1：启动应用
python 07_实战代码_01_基础信号处理实现.py

# 终端2：发送慢速请求
curl http://localhost:8000/slow &

# 终端3：立即发送 SIGTERM
kill -SIGTERM <pid>
```

**预期输出：**
```
[请求开始] 活跃请求数: 1
[慢速端点] 开始处理...
[慢速端点] 处理中... 1/5

============================================================
收到信号: SIGTERM (15)
进程 PID: 12345
当前位置: /path/to/file.py:45
============================================================

============================================================
开始优雅关闭
============================================================

[请求排空] 停止接收新请求
[请求排空] 当前活跃请求数: 1

[慢速端点] 检测到关闭信号，在第 2 秒中断
INFO:     127.0.0.1:54323 - "GET /slow HTTP/1.1" 503 Service Unavailable
[请求完成] 活跃请求数: 0

[请求排空] ✓ 所有请求已完成

[资源清理] 开始清理资源...
[资源清理] ✓ 资源清理完成

============================================================
优雅关闭完成
============================================================
```

---

## 代码解析

### 1. 信号处理器

```python
def signal_handler(signum, frame):
    """信号处理器"""
    signal_name = signal.Signals(signum).name
    print(f"收到信号: {signal_name} ({signum})")
    shutdown_event.set()  # 设置事件，通知协程
```

**关键点：**
- 信号处理器必须是同步函数
- 只设置事件，不执行耗时操作
- 通过 `asyncio.Event` 与协程通信

### 2. 请求排空中间件

```python
@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    global active_requests

    if not accepting_requests:
        return JSONResponse(status_code=503, ...)

    active_requests += 1
    try:
        return await call_next(request)
    finally:
        active_requests -= 1
```

**关键点：**
- 检查 `accepting_requests` 标志
- 使用 `try-finally` 确保计数器正确更新
- 返回 503 状态码和 Retry-After 头

### 3. 关闭信号检测

```python
async def slow_endpoint():
    for i in range(5):
        if shutdown_event.is_set():
            raise HTTPException(503, "Request interrupted")
        await asyncio.sleep(1)
```

**关键点：**
- 在长时间操作中定期检查 `shutdown_event`
- 检测到信号后立即中断
- 返回 503 状态码

### 4. 优雅关闭流程

```python
async def graceful_shutdown():
    # 1. 等待请求完成
    await wait_for_requests(timeout=30)

    # 2. 清理资源
    await cleanup_resources()

    # 3. 退出
    sys.exit(0)
```

**关键点：**
- 按顺序执行各个步骤
- 设置超时避免无限等待
- 使用 `sys.exit(0)` 正常退出

---

## 扩展练习

### 练习1：添加超时控制

修改 `wait_for_requests` 函数，添加超时后的强制退出：

```python
async def wait_for_requests(timeout: int = 30):
    accepting_requests = False

    try:
        await asyncio.wait_for(
            wait_until_no_requests(),
            timeout=timeout
        )
    except asyncio.TimeoutError:
        print(f"超时，强制退出")
        os._exit(1)

async def wait_until_no_requests():
    while active_requests > 0:
        await asyncio.sleep(0.1)
```

### 练习2：添加后台任务

添加后台任务并在关闭时取消：

```python
background_tasks = set()

async def background_worker():
    try:
        while not shutdown_event.is_set():
            print("后台任务运行中...")
            await asyncio.sleep(1)
    except asyncio.CancelledError:
        print("后台任务被取消")
        raise

@app.on_event("startup")
async def startup_event():
    task = asyncio.create_task(background_worker())
    background_tasks.add(task)
    asyncio.create_task(shutdown_monitor())

async def graceful_shutdown():
    # 取消后台任务
    for task in background_tasks:
        task.cancel()
    await asyncio.gather(*background_tasks, return_exceptions=True)

    # 等待请求完成
    await wait_for_requests()

    # 清理资源
    await cleanup_resources()

    sys.exit(0)
```

### 练习3：添加数据库连接

添加数据库连接并在关闭时清理：

```python
from sqlalchemy.ext.asyncio import create_async_engine

db_engine = None

@app.on_event("startup")
async def startup_event():
    global db_engine
    db_engine = create_async_engine(
        "postgresql+asyncpg://user:pass@localhost/db"
    )
    asyncio.create_task(shutdown_monitor())

async def cleanup_resources():
    print("清理资源...")

    if db_engine:
        await db_engine.dispose()
        print("数据库连接池已关闭")
```

---

## 总结

本示例演示了：

1. **信号处理器注册**：捕获 SIGTERM 和 SIGINT 信号
2. **请求排空**：停止接收新请求，等待现有请求完成
3. **关闭信号检测**：在长时间操作中检测关闭信号
4. **优雅关闭流程**：按顺序执行请求排空和资源清理

**关键要点：**
- 信号处理器必须是同步函数，只设置事件
- 使用 `asyncio.Event` 在信号处理器和协程之间通信
- 在长时间操作中定期检查关闭信号
- 设置超时避免无限等待

**下一步：** 学习如何使用 FastAPI 的 lifespan 上下文管理器。
