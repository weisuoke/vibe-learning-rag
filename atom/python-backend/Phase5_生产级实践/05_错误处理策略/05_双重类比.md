# 错误处理策略 - 双重类比

## 类比1：异常分层 = 医院分诊系统

**前端类比：** Error Boundary 的层级设计

在 React 中，你可以在不同层级设置 Error Boundary：
```typescript
// 顶层 Error Boundary：捕获所有错误
<AppErrorBoundary>
  <App />
</AppErrorBoundary>

// 组件级 Error Boundary：捕获特定组件错误
<ComponentErrorBoundary>
  <UserProfile />
</ComponentErrorBoundary>
```

**日常生活类比：** 医院分诊系统

- **轻症**（业务异常）：挂号、排队、看门诊 → 返回 422，用户可以修正
- **重症**（系统异常）：直接进急诊室 → 返回 500，需要开发者介入
- **不同科室**（异常分类）：内科、外科、儿科 → 不同的异常处理器

**Python 后端代码：**
```python
# 异常分层
class AppError(Exception):
    """应用基础异常（医院）"""
    pass

class BusinessError(AppError):
    """业务异常（门诊）"""
    pass

class SystemError(AppError):
    """系统异常（急诊）"""
    pass

# 具体异常（不同科室）
class TextTooLongError(BusinessError):
    """文本过长（内科）"""
    pass

class LLMTimeoutError(SystemError):
    """LLM 超时（急诊）"""
    pass

class DatabaseError(SystemError):
    """数据库错误（急诊）"""
    pass

# 异常处理器（分诊台）
@app.exception_handler(BusinessError)
async def business_error_handler(request, exc):
    # 门诊：返回 422，用户可以修正
    return JSONResponse(status_code=422, content={"error": exc.message})

@app.exception_handler(SystemError)
async def system_error_handler(request, exc):
    # 急诊：返回 500，记录日志，通知开发者
    logger.error("system_error", error=exc)
    return JSONResponse(status_code=500, content={"error": "服务暂时不可用"})
```

---

## 类比2：重试机制 = 打电话遇到占线

**前端类比：** Axios 的重试拦截器

```typescript
// Axios 重试拦截器
axios.interceptors.response.use(
  response => response,
  async error => {
    const config = error.config;
    if (!config || !config.retry) return Promise.reject(error);

    config.retryCount = config.retryCount || 0;

    if (config.retryCount >= config.retry) {
      return Promise.reject(error);
    }

    config.retryCount += 1;

    // 指数退避：1s, 2s, 4s
    const delay = Math.pow(2, config.retryCount) * 1000;
    await new Promise(resolve => setTimeout(resolve, delay));

    return axios(config);
  }
);
```

**日常生活类比：** 打电话遇到占线

- **第1次**：占线 → 等 1 分钟再打
- **第2次**：还是占线 → 等 2 分钟再打
- **第3次**：还是占线 → 等 4 分钟再打
- **第4次**：放弃，发短信

**为什么是指数退避？**
- 线性退避（1s, 1s, 1s）：可能服务还没恢复
- 指数退避（1s, 2s, 4s）：给服务更多恢复时间
- 随机退避（1-3s, 2-6s, 4-12s）：避免"惊群效应"（所有客户端同时重试）

**Python 后端代码：**
```python
import asyncio
from typing import TypeVar, Callable

T = TypeVar('T')

async def retry_with_exponential_backoff(
    func: Callable[..., T],
    max_attempts: int = 3,
    initial_delay: float = 1.0,
    max_delay: float = 10.0,
    *args,
    **kwargs
) -> T:
    """重试装饰器（指数退避）"""
    for attempt in range(max_attempts):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            if attempt == max_attempts - 1:
                raise

            # 指数退避：1s, 2s, 4s, 8s, ...
            delay = min(initial_delay * (2 ** attempt), max_delay)
            print(f"重试 {attempt + 1}/{max_attempts}，等待 {delay}s")
            await asyncio.sleep(delay)

# 使用示例
async def call_llm(prompt: str):
    return await retry_with_exponential_backoff(
        _call_llm_internal,
        max_attempts=3,
        initial_delay=1.0,
        prompt=prompt
    )
```

---

## 类比3：熔断器 = 电路保险丝

**前端类比：** Service Worker 的降级策略

```typescript
// Service Worker 降级策略
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .catch(() => {
        // 网络失败 → 返回缓存
        return caches.match(event.request);
      })
      .catch(() => {
        // 缓存也没有 → 返回离线页面
        return caches.match('/offline.html');
      })
  );
});
```

**日常生活类比：** 电路保险丝

- **正常状态**（Closed）：电路正常工作
- **短路**（失败率高）：保险丝熔断 → 切断电路
- **熔断状态**（Open）：电路断开，不再尝试
- **等待恢复**（Half-Open）：尝试恢复电路
- **恢复成功**（Closed）：电路恢复正常

**为什么需要熔断器？**
- **防止雪崩**：一个服务故障 → 大量重试 → 加剧负载 → 整个系统崩溃
- **快速失败**：服务已经挂了，不要再浪费资源重试
- **自动恢复**：服务恢复后，自动重新启用

**Python 后端代码：**
```python
import time
from enum import Enum

class CircuitState(Enum):
    CLOSED = "closed"      # 正常
    OPEN = "open"          # 熔断
    HALF_OPEN = "half_open"  # 半开

class CircuitBreaker:
    """熔断器"""
    def __init__(
        self,
        failure_threshold: float = 0.5,  # 失败率阈值
        timeout: int = 30,               # 熔断超时（秒）
        min_calls: int = 5               # 最小调用次数
    ):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.min_calls = min_calls

        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None

    async def call(self, func, *args, **kwargs):
        """调用函数（带熔断保护）"""
        # 熔断状态：检查是否可以恢复
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitState.HALF_OPEN
                print("熔断器进入半开状态，尝试恢复")
            else:
                raise CircuitBreakerOpenError("服务暂时不可用（熔断中）")

        try:
            result = await func(*args, **kwargs)
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise

    def on_success(self):
        """成功回调"""
        self.success_count += 1

        # 半开状态 → 成功 → 关闭状态
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.CLOSED
            self.failure_count = 0
            self.success_count = 0
            print("熔断器恢复正常")

    def on_failure(self):
        """失败回调"""
        self.failure_count += 1
        self.last_failure_time = time.time()

        # 半开状态 → 失败 → 打开状态
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.OPEN
            print("熔断器重新打开")
            return

        # 关闭状态 → 失败率过高 → 打开状态
        total = self.failure_count + self.success_count
        if total >= self.min_calls:
            failure_rate = self.failure_count / total
            if failure_rate > self.failure_threshold:
                self.state = CircuitState.OPEN
                print(f"熔断器打开（失败率 {failure_rate:.2%}）")

# 使用示例
llm_breaker = CircuitBreaker(failure_threshold=0.5, timeout=30)

async def call_llm_with_breaker(prompt: str):
    return await llm_breaker.call(_call_llm_internal, prompt)
```

---

## 类比4：超时控制 = 餐厅等位

**前端类比：** Promise.race 实现超时

```typescript
// Promise 超时控制
function withTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {
  return Promise.race([
    promise,
    new Promise<T>((_, reject) =>
      setTimeout(() => reject(new Error('Timeout')), timeout)
    )
  ]);
}

// 使用示例
try {
  const response = await withTimeout(
    fetch('/api/chat'),
    5000  // 5秒超时
  );
} catch (error) {
  if (error.message === 'Timeout') {
    console.error('请求超时');
  }
}
```

**日常生活类比：** 餐厅等位

- **设置超时**：告诉服务员"最多等 30 分钟"
- **超时前到位**：正常用餐
- **超时未到位**：放弃等位，去其他餐厅

**为什么需要超时控制？**
- **防止资源泄漏**：请求一直挂着，占用连接
- **用户体验**：与其无限等待，不如快速失败
- **级联超时**：上游超时 30s，下游应该更短（如 25s）

**Python 后端代码：**
```python
import asyncio

async def call_with_timeout(
    func,
    timeout: float,
    *args,
    **kwargs
):
    """带超时的函数调用"""
    try:
        async with asyncio.timeout(timeout):
            return await func(*args, **kwargs)
    except asyncio.TimeoutError:
        raise TimeoutError(f"操作超时（{timeout}s）")

# 使用示例
@app.post("/chat")
async def chat(message: str):
    try:
        # LLM 调用超时：30s
        response = await call_with_timeout(
            call_llm,
            timeout=30.0,
            prompt=message
        )
        return {"response": response}
    except TimeoutError:
        raise HTTPException(
            status_code=504,
            detail="LLM 服务响应超时，请稍后重试"
        )
```

---

## 类比5：错误监控 = 行车记录仪

**前端类比：** Sentry 错误追踪

```typescript
// Sentry 初始化
Sentry.init({
  dsn: "your-dsn",
  environment: "production",
  beforeSend(event, hint) {
    // 添加自定义上下文
    event.contexts = {
      ...event.contexts,
      user: { id: userId, email: userEmail },
      request: { url: window.location.href }
    };
    return event;
  }
});

// 捕获错误
try {
  await fetchData();
} catch (error) {
  Sentry.captureException(error, {
    tags: { feature: 'data-fetch' },
    extra: { userId, timestamp: Date.now() }
  });
}
```

**日常生活类比：** 行车记录仪

- **正常行驶**：不记录（或只记录关键信息）
- **发生事故**：自动记录（时间、地点、速度、视频）
- **事后分析**：回放视频，找出事故原因

**为什么需要错误监控？**
- **快速定位**：知道错误发生在哪里、什么时候、什么条件下
- **趋势分析**：错误是偶发的还是频繁的？
- **告警通知**：错误率突然升高 → 立即通知开发者

**Python 后端代码：**
```python
import structlog
import traceback
from datetime import datetime

logger = structlog.get_logger()

@app.exception_handler(Exception)
async def global_error_handler(request: Request, exc: Exception):
    """全局异常处理器（带监控）"""
    # 生成 Request ID
    request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))

    # 记录详细错误日志
    logger.error(
        "unhandled_exception",
        request_id=request_id,
        timestamp=datetime.utcnow().isoformat(),
        error_type=type(exc).__name__,
        error_message=str(exc),
        path=request.url.path,
        method=request.method,
        user_id=getattr(request.state, "user_id", None),
        stack_trace=traceback.format_exc()
    )

    # 可选：上报到 Sentry
    # sentry_sdk.capture_exception(exc)

    return JSONResponse(
        status_code=500,
        content={
            "error": "服务器内部错误",
            "error_code": "INTERNAL_ERROR",
            "request_id": request_id  # 返回给用户，方便追踪
        }
    )
```

---

## 类比总结表

| 错误处理概念 | 前端类比 | 日常生活类比 | 核心价值 |
|------------|---------|-------------|---------|
| **异常分层** | Error Boundary 层级 | 医院分诊系统 | 不同错误不同处理 |
| **重试机制** | Axios 重试拦截器 | 打电话遇到占线 | 自动恢复临时故障 |
| **熔断器** | Service Worker 降级 | 电路保险丝 | 防止雪崩效应 |
| **超时控制** | Promise.race | 餐厅等位 | 防止资源泄漏 |
| **错误监控** | Sentry 错误追踪 | 行车记录仪 | 快速定位问题 |

---

## 综合类比：错误处理策略 = 城市应急系统

**前端类比：** 完整的前端错误处理体系

```typescript
// 1. 异常分层（分诊）
class AppError extends Error {}
class NetworkError extends AppError {}
class ValidationError extends AppError {}

// 2. 重试机制（自动恢复）
const retryFetch = async (url, options, maxRetries = 3) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fetch(url, options);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await sleep(2 ** i * 1000);
    }
  }
};

// 3. 熔断器（防止雪崩）
const circuitBreaker = new CircuitBreaker(apiCall, {
  failureThreshold: 0.5,
  timeout: 30000
});

// 4. 超时控制（资源保护）
const withTimeout = (promise, timeout) =>
  Promise.race([promise, timeoutPromise(timeout)]);

// 5. 错误监控（可观测性）
Sentry.init({ dsn: "..." });
```

**日常生活类比：** 城市应急系统

- **异常分层**：110（警察）、119（消防）、120（急救）
- **重试机制**：打 120 占线 → 自动重拨
- **熔断器**：医院爆满 → 分流到其他医院
- **超时控制**：救护车 30 分钟内必须到达
- **错误监控**：应急指挥中心实时监控

**Python 后端完整示例：**
```python
"""
完整的错误处理策略（城市应急系统）
"""

import asyncio
import time
from enum import Enum
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import structlog

# ===== 1. 异常分层（分诊系统）=====
class AppError(Exception):
    def __init__(self, message: str, error_code: str = None):
        self.message = message
        self.error_code = error_code
        super().__init__(message)

class BusinessError(AppError):
    """业务异常（110）"""
    pass

class SystemError(AppError):
    """系统异常（119）"""
    pass

# ===== 2. 重试机制（自动重拨）=====
async def retry_with_backoff(func, max_attempts=3, *args, **kwargs):
    for attempt in range(max_attempts):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            if attempt == max_attempts - 1:
                raise
            await asyncio.sleep(2 ** attempt)

# ===== 3. 熔断器（医院分流）=====
class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreaker:
    def __init__(self, failure_threshold=0.5, timeout=30):
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.last_failure_time = None

    async def call(self, func, *args, **kwargs):
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitState.HALF_OPEN
            else:
                raise SystemError("服务暂时不可用（熔断中）")

        try:
            result = await func(*args, **kwargs)
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise

    def on_success(self):
        self.success_count += 1
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.CLOSED

    def on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()
        total = self.failure_count + self.success_count
        if total > 0 and self.failure_count / total > self.failure_threshold:
            self.state = CircuitState.OPEN

# ===== 4. 超时控制（30分钟到达）=====
async def call_with_timeout(func, timeout, *args, **kwargs):
    try:
        async with asyncio.timeout(timeout):
            return await func(*args, **kwargs)
    except asyncio.TimeoutError:
        raise SystemError(f"操作超时（{timeout}s）")

# ===== 5. 错误监控（应急指挥中心）=====
logger = structlog.get_logger()

app = FastAPI()

@app.exception_handler(Exception)
async def global_error_handler(request: Request, exc: Exception):
    logger.error(
        "error_occurred",
        error_type=type(exc).__name__,
        error_message=str(exc),
        path=request.url.path
    )
    return JSONResponse(
        status_code=500,
        content={"error": "服务器内部错误"}
    )

# ===== 6. 综合使用 =====
llm_breaker = CircuitBreaker()

async def call_llm_safe(prompt: str):
    """安全的 LLM 调用（集成所有策略）"""
    return await call_with_timeout(
        llm_breaker.call,
        timeout=30.0,
        func=retry_with_backoff,
        max_attempts=3,
        func=_call_llm_internal,
        prompt=prompt
    )
```

---

## 总结

**错误处理策略的本质：**
- **异常分层** = 医院分诊 = Error Boundary
- **重试机制** = 打电话重拨 = Axios 重试
- **熔断器** = 电路保险丝 = Service Worker 降级
- **超时控制** = 餐厅等位 = Promise.race
- **错误监控** = 行车记录仪 = Sentry

**综合类比：**
- **前端**：完整的错误处理体系（分层、重试、降级、超时、监控）
- **日常生活**：城市应急系统（110、119、120、分流、指挥中心）

**核心价值：**
- 不同错误不同处理（分诊）
- 自动恢复临时故障（重拨）
- 防止雪崩效应（保险丝）
- 防止资源泄漏（等位超时）
- 快速定位问题（记录仪）
