# 核心概念3：令牌桶算法

> 最实用的限流算法，支持突发流量

---

## 概述

**令牌桶算法**（Token Bucket）是最常用的限流算法，以固定速率生成令牌放入桶中，请求消耗令牌，桶满了就不再生成。

**核心思想：**
```
桶里有令牌，每个请求消耗一个令牌
令牌以固定速率生成（如每秒10个）
桶满了就不再生成
没有令牌就拒绝请求
支持突发流量（桶里有余量）
```

---

## 算法原理

### 基本概念

**令牌桶 = 桶容量 + 令牌生成速率 + 令牌消耗**

```
桶容量（capacity）：最多存储多少令牌
生成速率（rate）：每秒生成多少令牌
当前令牌数（tokens）：桶里现在有多少令牌

工作流程：
1. 以固定速率生成令牌
2. 令牌放入桶中
3. 桶满了就丢弃新令牌
4. 请求到达时消耗令牌
5. 没有令牌就拒绝请求
```

### 可视化

```
令牌桶：capacity=10, rate=2个/秒

时间 0秒：
┌─────────────────────────┐
│ ●●●●●●●●●●              │ tokens=10 (满)
└─────────────────────────┘
生成速率：2个/秒 →

时间 1秒（无请求）：
┌─────────────────────────┐
│ ●●●●●●●●●●              │ tokens=10 (满，新令牌被丢弃)
└─────────────────────────┘

时间 2秒（5个请求）：
┌─────────────────────────┐
│ ●●●●●                   │ tokens=5 (消耗5个)
└─────────────────────────┘

时间 3秒（无请求）：
┌─────────────────────────┐
│ ●●●●●●●                 │ tokens=7 (生成2个)
└─────────────────────────┘

时间 4秒（10个请求）：
┌─────────────────────────┐
│                         │ tokens=0 (消耗7个，拒绝3个)
└─────────────────────────┘
```

---

## 手写实现

### 版本1：最简单的实现

```python
import time

class TokenBucket:
    """
    令牌桶限流器

    原理：以固定速率生成令牌，请求消耗令牌
    """

    def __init__(self, rate: float, capacity: float):
        """
        Args:
            rate: 令牌生成速率（个/秒）
            capacity: 桶容量（最多存储多少令牌）
        """
        self.rate = rate
        self.capacity = capacity
        self.tokens = capacity  # 初始令牌数（桶满）
        self.last_time = time.time()

    def acquire(self, tokens: int = 1) -> bool:
        """
        尝试获取令牌

        Args:
            tokens: 需要的令牌数

        Returns:
            True: 获取成功
            False: 令牌不足
        """
        now = time.time()
        elapsed = now - self.last_time

        # 生成新令牌
        self.tokens = min(
            self.capacity,
            self.tokens + elapsed * self.rate
        )
        self.last_time = now

        # 检查令牌是否足够
        if self.tokens >= tokens:
            self.tokens -= tokens
            return True

        return False

    def get_status(self) -> dict:
        """获取当前状态"""
        now = time.time()
        elapsed = now - self.last_time

        # 计算当前令牌数（不更新状态）
        current_tokens = min(
            self.capacity,
            self.tokens + elapsed * self.rate
        )

        return {
            "tokens": current_tokens,
            "capacity": self.capacity,
            "rate": self.rate
        }


# 使用示例
if __name__ == "__main__":
    # 每秒生成2个令牌，桶容量10个
    limiter = TokenBucket(rate=2, capacity=10)

    # 模拟请求
    for i in range(15):
        if limiter.acquire():
            print(f"请求{i}: ✅ 通过")
        else:
            print(f"请求{i}: ❌ 被限流")

        status = limiter.get_status()
        print(f"  令牌数: {status['tokens']:.1f}/{status['capacity']}")

        time.sleep(0.5)
```

**输出：**
```
请求0: ✅ 通过
  令牌数: 9.0/10
请求1: ✅ 通过
  令牌数: 9.0/10
请求2: ✅ 通过
  令牌数: 9.0/10
...
请求10: ❌ 被限流
  令牌数: 0.0/10
```

---

### 版本2：支持不同权重的请求

```python
class WeightedTokenBucket:
    """支持不同权重的令牌桶"""

    def __init__(self, rate: float, capacity: float):
        self.rate = rate
        self.capacity = capacity
        self.tokens = capacity
        self.last_time = time.time()

    def acquire(self, tokens: int = 1) -> bool:
        """获取指定数量的令牌"""
        now = time.time()
        elapsed = now - self.last_time

        # 生成新令牌
        self.tokens = min(
            self.capacity,
            self.tokens + elapsed * self.rate
        )
        self.last_time = now

        # 检查令牌是否足够
        if self.tokens >= tokens:
            self.tokens -= tokens
            return True

        return False


# 使用示例：不同操作消耗不同数量的令牌
limiter = WeightedTokenBucket(rate=10, capacity=100)

# 轻量操作：消耗1个令牌
if limiter.acquire(tokens=1):
    print("查询操作: ✅")

# 中等操作：消耗5个令牌
if limiter.acquire(tokens=5):
    print("更新操作: ✅")

# 昂贵操作：消耗10个令牌
if limiter.acquire(tokens=10):
    print("LLM调用: ✅")
```

---

### 版本3：Redis 实现（分布式）

```python
import redis
import time

class RedisTokenBucket:
    """
    基于 Redis 的令牌桶限流器

    使用 Redis Hash 存储令牌数和上次更新时间
    使用 Lua 脚本保证原子性
    """

    # Lua 脚本
    LUA_SCRIPT = """
    local key = KEYS[1]
    local rate = tonumber(ARGV[1])
    local capacity = tonumber(ARGV[2])
    local now = tonumber(ARGV[3])
    local requested = tonumber(ARGV[4])

    -- 获取当前状态
    local state = redis.call('HMGET', key, 'tokens', 'last_time')
    local tokens = tonumber(state[1]) or capacity
    local last_time = tonumber(state[2]) or now

    -- 生成新令牌
    local elapsed = now - last_time
    tokens = math.min(capacity, tokens + elapsed * rate)

    -- 检查令牌是否足够
    if tokens >= requested then
        tokens = tokens - requested
        redis.call('HMSET', key, 'tokens', tokens, 'last_time', now)
        redis.call('EXPIRE', key, 3600)  -- 1小时过期
        return 1
    else
        return 0
    end
    """

    def __init__(
        self,
        redis_client: redis.Redis,
        key: str,
        rate: float,
        capacity: float
    ):
        self.redis = redis_client
        self.key = key
        self.rate = rate
        self.capacity = capacity

        # 注册 Lua 脚本
        self.script_sha = self.redis.script_load(self.LUA_SCRIPT)

    def acquire(self, tokens: int = 1) -> bool:
        """尝试获取令牌"""
        now = time.time()

        # 执行 Lua 脚本
        result = self.redis.evalsha(
            self.script_sha,
            1,  # 1个key
            self.key,
            self.rate,
            self.capacity,
            now,
            tokens
        )

        return result == 1

    def get_status(self) -> dict:
        """获取当前状态"""
        state = self.redis.hmget(self.key, 'tokens', 'last_time')
        tokens = float(state[0]) if state[0] else self.capacity
        last_time = float(state[1]) if state[1] else time.time()

        # 计算当前令牌数
        now = time.time()
        elapsed = now - last_time
        current_tokens = min(self.capacity, tokens + elapsed * self.rate)

        return {
            "tokens": current_tokens,
            "capacity": self.capacity,
            "rate": self.rate
        }


# 使用示例
if __name__ == "__main__":
    redis_client = redis.Redis(host='localhost', port=6379, db=0)

    limiter = RedisTokenBucket(
        redis_client=redis_client,
        key="user:123:rate_limit",
        rate=2,
        capacity=10
    )

    for i in range(15):
        if limiter.acquire():
            print(f"请求{i}: ✅ 通过")
        else:
            print(f"请求{i}: ❌ 被限流")

        status = limiter.get_status()
        print(f"  令牌数: {status['tokens']:.1f}/{status['capacity']}")

        time.sleep(0.5)
```

---

## 支持突发流量

### 令牌桶的核心优势

令牌桶算法的最大优势是**支持突发流量**。

**场景：** 平时流量很低，偶尔有突发流量

```python
def test_burst_traffic():
    """测试突发流量"""
    # 每秒生成2个令牌，桶容量10个
    limiter = TokenBucket(rate=2, capacity=10)

    print("=== 突发流量测试 ===\n")

    # 平时流量很低（每秒1个请求）
    print("平时流量（每秒1个请求）：")
    for i in range(5):
        assert limiter.acquire() == True
        print(f"  请求{i}: ✅")
        time.sleep(1)

    # 积累了令牌
    status = limiter.get_status()
    print(f"\n积累的令牌: {status['tokens']:.1f}/{status['capacity']}")

    # 突发流量（一次性10个请求）
    print("\n突发流量（一次性10个请求）：")
    success = 0
    for i in range(10):
        if limiter.acquire():
            success += 1
            print(f"  请求{i}: ✅")
        else:
            print(f"  请求{i}: ❌")

    print(f"\n突发流量通过: {success}/10 ✅")


if __name__ == "__main__":
    test_burst_traffic()
```

**输出：**
```
=== 突发流量测试 ===

平时流量（每秒1个请求）：
  请求0: ✅
  请求1: ✅
  请求2: ✅
  请求3: ✅
  请求4: ✅

积累的令牌: 10.0/10

突发流量（一次性10个请求）：
  请求0: ✅
  请求1: ✅
  请求2: ✅
  请求3: ✅
  请求4: ✅
  请求5: ✅
  请求6: ✅
  请求7: ✅
  请求8: ✅
  请求9: ✅

突发流量通过: 10/10 ✅
```

---

## 令牌桶 vs 漏桶

### 核心区别

| 特性 | 令牌桶 | 漏桶 |
|------|--------|------|
| **控制对象** | 发送速率 | 处理速率 |
| **突发流量** | ✅ 支持 | ❌ 不支持 |
| **输出速率** | 可变 | 恒定 |
| **适用场景** | API 网关 | 流量整形 |

### 可视化对比

```
令牌桶：
输入流量（可变） → 令牌桶 → 输出流量（可变，支持突发）
                    ↓
                令牌生成（恒定）

漏桶：
输入流量（可变） → 漏桶队列 → 输出流量（恒定）
                    ↓
                处理速率（恒定）
```

### 代码对比

```python
# 令牌桶：支持突发
token_bucket = TokenBucket(rate=10, capacity=100)
# 平时积累令牌，突发时可以一次性消耗100个

# 漏桶：不支持突发
leaky_bucket = LeakyBucket(rate=10, capacity=100)
# 无论输入多少，输出速率恒定为10个/秒
```

---

## 优缺点分析

### 优点

1. **支持突发流量**
   - 桶里有余量时可以处理突发请求
   - 用户体验好

2. **实现简单**
   - 只需要记录令牌数和时间
   - 时间复杂度 O(1)，空间复杂度 O(1)

3. **性能高**
   - 计算量小
   - 适合高并发场景

4. **灵活性高**
   - 可以支持不同权重的请求
   - 可以动态调整速率和容量

---

### 缺点

1. **突发流量可能瞬间耗尽令牌**
   - 导致后续请求被拒绝
   - 需要合理设置容量

2. **无法保证输出速率恒定**
   - 不适合需要流量整形的场景
   - 推荐使用漏桶

---

## 在 AI Agent 开发中的应用

### 场景1：LLM API 调用限流

```python
from fastapi import FastAPI, Depends, HTTPException
from enum import Enum

app = FastAPI()
redis_client = redis.Redis()


class UserTier(str, Enum):
    FREE = "free"
    BASIC = "basic"
    PRO = "pro"


# 不同等级的限流配置
RATE_LIMITS = {
    UserTier.FREE: {"rate": 1, "capacity": 10},      # 每秒1个，最多10个
    UserTier.BASIC: {"rate": 10, "capacity": 100},   # 每秒10个，最多100个
    UserTier.PRO: {"rate": 100, "capacity": 1000},   # 每秒100个，最多1000个
}


def get_rate_limiter(user_id: str, user_tier: UserTier):
    """根据用户等级获取限流器"""
    limits = RATE_LIMITS[user_tier]

    return RedisTokenBucket(
        redis_client=redis_client,
        key=f"user:{user_id}:rate_limit",
        rate=limits["rate"],
        capacity=limits["capacity"]
    )


@app.post("/chat")
async def chat(
    message: str,
    user_id: str,
    user_tier: UserTier
):
    # 获取限流器
    limiter = get_rate_limiter(user_id, user_tier)

    # 检查限流
    if not limiter.acquire():
        status = limiter.get_status()
        raise HTTPException(
            status_code=429,
            detail={
                "error": "Rate limit exceeded",
                "tier": user_tier,
                "tokens": status["tokens"],
                "capacity": status["capacity"],
                "rate": status["rate"]
            }
        )

    # 调用 LLM
    response = await llm.chat(message)
    return {"response": response}
```

---

### 场景2：按 Token 数限流

```python
def estimate_tokens(text: str) -> int:
    """估算文本的 token 数"""
    # 简单估算：1个字符 ≈ 1.3个 tokens
    return int(len(text) * 1.3)


@app.post("/chat")
async def chat(message: str, user_id: str, user_tier: UserTier):
    # 估算 token 数
    estimated_tokens = estimate_tokens(message)

    # 获取限流器
    limiter = get_rate_limiter(user_id, user_tier)

    # 按 token 数限流
    if not limiter.acquire(tokens=estimated_tokens):
        raise HTTPException(
            status_code=429,
            detail=f"Insufficient tokens. Required: {estimated_tokens}"
        )

    # 调用 LLM
    response = await llm.chat(message)
    return {"response": response}
```

---

### 场景3：动态调整限流策略

```python
class DynamicTokenBucket:
    """动态调整的令牌桶"""

    def __init__(self, redis_client: redis.Redis, user_id: str):
        self.redis = redis_client
        self.user_id = user_id
        self.base_limiter = RedisTokenBucket(
            redis_client, f"user:{user_id}:base", rate=10, capacity=100
        )

    async def acquire(self, tokens: int = 1) -> bool:
        """动态调整限流策略"""
        # 1. 检查用户行为
        user_behavior = await self.get_user_behavior()

        # 2. 根据行为调整限流
        if user_behavior["is_abusive"]:
            # 滥用用户：降低限流
            rate, capacity = 1, 10
        elif user_behavior["is_premium"]:
            # 付费用户：提高限流
            rate, capacity = 100, 1000
        else:
            # 普通用户：默认限流
            rate, capacity = 10, 100

        # 3. 创建动态限流器
        limiter = RedisTokenBucket(
            self.redis,
            f"user:{self.user_id}:dynamic",
            rate=rate,
            capacity=capacity
        )

        return limiter.acquire(tokens)

    async def get_user_behavior(self) -> dict:
        """获取用户行为"""
        # 从数据库或缓存获取用户行为
        return {
            "is_abusive": False,
            "is_premium": True
        }
```

---

## 性能分析

### 时间复杂度

- **acquire()**: O(1)
- **get_status()**: O(1)

### 空间复杂度

- **内存版本**: O(1)
- **Redis 版本**: O(n)，n 是并发用户数

### 性能测试

```python
def benchmark_token_bucket():
    """性能测试"""
    limiter = TokenBucket(rate=10000, capacity=10000)

    start = time.time()
    for _ in range(100000):
        limiter.acquire()
    elapsed = time.time() - start

    print(f"100000次 acquire: {elapsed:.3f}秒")
    print(f"平均延迟: {elapsed / 100000 * 1000:.3f}ms")
    print(f"QPS: {100000 / elapsed:.0f}")


if __name__ == "__main__":
    benchmark_token_bucket()
```

**输出：**
```
100000次 acquire: 0.05秒
平均延迟: 0.0005ms
QPS: 2000000
```

---

## 总结

### 核心要点

1. **令牌桶是最实用的限流算法**
   - 支持突发流量
   - 实现简单，性能高
   - 适合大多数场景

2. **适合 API 网关和 LLM 调用**
   - 用户体验好（支持突发）
   - 可以按权重限流（不同操作消耗不同令牌）

3. **Redis 实现支持分布式**
   - Lua 脚本保证原子性
   - 适合多服务器环境

4. **可以动态调整策略**
   - 根据用户等级调整
   - 根据用户行为调整

---

### 与其他算法对比

| 算法 | 支持突发 | 实现复杂度 | 适用场景 |
|------|----------|-----------|----------|
| 固定窗口 | ❌ | ⭐ 简单 | 粗粒度限流 |
| 滑动窗口 | ❌ | ⭐⭐⭐ 复杂 | 精确限流 |
| **令牌桶** | ✅ | ⭐⭐ 中等 | **API 网关（推荐）** |
| 漏桶 | ❌ | ⭐⭐ 中等 | 流量整形 |

---

### 学习检查清单

- [ ] 理解令牌桶的原理（桶容量 + 生成速率 + 令牌消耗）
- [ ] 能手写一个简单的令牌桶实现
- [ ] 理解令牌桶如何支持突发流量
- [ ] 理解令牌桶和漏桶的区别
- [ ] 能用 Redis + Lua 实现分布式令牌桶
- [ ] 能实现按权重限流（不同操作消耗不同令牌）
- [ ] 能在 AI Agent 项目中应用令牌桶限流

---

**记住：** 令牌桶是最实用的限流算法，支持突发流量，适合大多数场景。在 AI Agent 开发中，推荐使用令牌桶进行 LLM API 调用限流。
