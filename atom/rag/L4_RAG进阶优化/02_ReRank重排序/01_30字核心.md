# 30字核心

**ReRank 是对初检结果进行二次精排的技术，通过 Cross-Encoder 深度交互提升 RAG 检索质量。**

---

## 拆解理解

| 关键词 | 含义 |
|-------|------|
| **ReRank（重排序）** | 对已检索的候选结果重新排序，筛选出最相关的 Top-K |
| **初检结果** | 向量检索（Bi-Encoder）返回的候选文档，通常 50-100 条 |
| **二次精排** | 用更精确但更慢的模型，对候选结果进行细粒度排序 |
| **Cross-Encoder** | 将 Query 和 Document 拼接后一起编码，捕捉深度交互 |
| **深度交互** | Query 和 Document 的每个 Token 都能相互 Attention |

---

## 为什么这句话重要？

理解这句话，你就理解了：

1. **ReRank 是检索的"精修"环节** → 向量检索是"粗筛"，ReRank 是"精选"
2. **Cross-Encoder 是核心技术** → 与 Embedding 的 Bi-Encoder 形成互补
3. **质量 vs 速度的权衡** → ReRank 更准但更慢，所以只对候选结果使用

---

## ReRank 的一句话公式

```
ReRank = 候选召回 + Cross-Encoder 精排 + Top-K 截断
```

用前端的话说：

```
ReRank = 搜索结果列表 + 相关性重新打分 + 只展示最相关的几条
```

---

## 在 RAG 系统中的位置

```
┌─────────────────────────────────────────────────────────────┐
│                      在线查询阶段                             │
│                                                             │
│  用户Query      向量检索        ★ReRank★        LLM生成      │
│  ┌─────┐       ┌─────┐        ┌─────┐        ┌─────┐       │
│  │     │       │Top50│        │Top5 │        │     │       │
│  │  Q  │  ──→  │候选 │   ──→  │精排 │   ──→  │ 回答 │       │
│  │     │       │文档 │        │结果 │        │     │       │
│  └─────┘       └─────┘        └─────┘        └─────┘       │
│                                  ↑                          │
│                               你在这里                        │
└─────────────────────────────────────────────────────────────┘
```

---

## ReRank vs 直接向量检索

| 对比项 | 向量检索（Bi-Encoder） | ReRank（Cross-Encoder） |
|--------|----------------------|------------------------|
| 编码方式 | Query 和 Doc 分别编码 | Query 和 Doc 拼接后一起编码 |
| 交互深度 | 无交互，只比较向量 | 深度交互，Token 级 Attention |
| 速度 | 快（毫秒级） | 慢（需逐个计算） |
| 精度 | 较高（~90%） | 更高（~95%+） |
| 适用场景 | 大规模召回 | 小规模精排 |

---

**记住这句话：** ReRank = 粗筛后的精选，用 Cross-Encoder 的深度交互换取更高的检索精度。

---

**下一步：** [02_第一性原理](./02_第一性原理.md) - 从根本理解为什么需要 ReRank
