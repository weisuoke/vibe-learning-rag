# 实战代码 - 场景4：索引选型决策

**场景描述：** 综合对比与选型 - 提供完整的索引选型工具和对比实验

**实际案例：** 根据实际需求选择最优索引类型

---

## 场景概述

本场景提供：
1. **索引选型决策树** - 自动化选型工具
2. **三种索引对比实验** - 性能基准测试
3. **可视化对比** - 直观的性能对比
4. **RAG 场景选型建议** - 实际应用指导

---

## 完整代码示例

```python
"""
场景4：索引选型决策 - 综合对比与选型
提供完整的索引选型工具和对比实验

环境要求：
- pymilvus
- numpy
"""

import time
import numpy as np
import math
from pymilvus import (
    connections,
    Collection,
    FieldSchema,
    CollectionSchema,
    DataType,
    utility
)
from typing import Dict, List, Tuple

# ===== 1. 索引选型决策树 =====
print("=" * 60)
print("场景4：索引选型决策 - 综合对比与选型")
print("=" * 60)

def choose_index_type(
    num_vectors: int,
    qps_requirement: int = None,
    recall_requirement: float = 0.95,
    memory_budget_gb: float = None,
    frequent_insert: bool = False
) -> Dict:
    """
    根据实际需求选择索引类型

    参数：
    - num_vectors: 向量数量
    - qps_requirement: QPS 要求（可选）
    - recall_requirement: 召回率要求 (0-1)
    - memory_budget_gb: 内存预算 GB（可选）
    - frequent_insert: 是否频繁增量插入

    返回：推荐的索引类型和参数
    """
    # 计算向量数据大小（假设768维）
    dim = 768
    vector_size_gb = num_vectors * dim * 4 / (1024**3)

    # 决策逻辑
    if num_vectors < 10000:
        return {
            "index_type": "FLAT",
            "reason": "数据规模小（< 1万），FLAT 最简单高效",
            "params": {},
            "expected_recall": 1.0,
            "expected_latency_ms": 2 + num_vectors / 5000,
            "memory_gb": vector_size_gb
        }

    elif num_vectors < 100000:
        # 中等规模：FLAT 或 IVF_FLAT
        if recall_requirement >= 0.98:
            return {
                "index_type": "FLAT",
                "reason": "召回率要求高（>= 98%），使用 FLAT 保证精度",
                "params": {},
                "expected_recall": 1.0,
                "expected_latency_ms": 10 + num_vectors / 2000,
                "memory_gb": vector_size_gb
            }
        else:
            nlist = int(3 * math.sqrt(num_vectors))
            nlist = 2 ** int(math.log2(nlist))  # 调整到2的幂
            return {
                "index_type": "IVF_FLAT",
                "reason": "中等规模（1万-10万），IVF_FLAT 平衡性能",
                "params": {
                    "nlist": nlist,
                    "nprobe": 32 if recall_requirement >= 0.95 else 16
                },
                "expected_recall": 0.96 if recall_requirement >= 0.95 else 0.94,
                "expected_latency_ms": 30,
                "memory_gb": vector_size_gb * 1.1
            }

    else:
        # 大规模：IVF_FLAT 或 HNSW
        hnsw_memory = vector_size_gb * 1.7
        ivf_memory = vector_size_gb * 1.1

        # 检查内存预算
        if memory_budget_gb and hnsw_memory > memory_budget_gb:
            nlist = int(3 * math.sqrt(num_vectors))
            nlist = 2 ** int(math.log2(nlist))
            return {
                "index_type": "IVF_FLAT",
                "reason": f"内存受限（预算{memory_budget_gb}GB < HNSW需要{hnsw_memory:.1f}GB）",
                "params": {
                    "nlist": nlist,
                    "nprobe": 64 if recall_requirement >= 0.95 else 32
                },
                "expected_recall": 0.96,
                "expected_latency_ms": 50,
                "memory_gb": ivf_memory
            }

        # 检查是否频繁插入
        if frequent_insert:
            return {
                "index_type": "HNSW",
                "reason": "需要频繁增量插入，HNSW 支持动态插入",
                "params": {
                    "M": 16,
                    "efConstruction": 200,
                    "ef": 128 if recall_requirement >= 0.95 else 64
                },
                "expected_recall": 0.93,
                "expected_latency_ms": 12,
                "memory_gb": hnsw_memory
            }

        # 检查 QPS 要求
        if qps_requirement and qps_requirement > 500:
            return {
                "index_type": "HNSW",
                "reason": f"高 QPS 要求（{qps_requirement} > 500），HNSW 性能最优",
                "params": {
                    "M": 16,
                    "efConstruction": 200,
                    "ef": 128 if recall_requirement >= 0.95 else 64
                },
                "expected_recall": 0.93,
                "expected_latency_ms": 12,
                "memory_gb": hnsw_memory
            }

        # 默认：根据召回率要求选择
        if recall_requirement >= 0.96:
            nlist = int(3 * math.sqrt(num_vectors))
            nlist = 2 ** int(math.log2(nlist))
            return {
                "index_type": "IVF_FLAT",
                "reason": "高召回率要求（>= 96%），IVF_FLAT 更可靠",
                "params": {
                    "nlist": nlist,
                    "nprobe": 64
                },
                "expected_recall": 0.97,
                "expected_latency_ms": 50,
                "memory_gb": ivf_memory
            }
        else:
            return {
                "index_type": "HNSW",
                "reason": "大规模数据，HNSW 综合性能最优",
                "params": {
                    "M": 16,
                    "efConstruction": 200,
                    "ef": 64
                },
                "expected_recall": 0.92,
                "expected_latency_ms": 12,
                "memory_gb": hnsw_memory
            }

# ===== 2. 测试索引选型工具 =====
print("\n步骤1：索引选型工具演示")
print("-" * 60)

test_cases = [
    {
        "name": "个人笔记应用",
        "num_vectors": 500,
        "recall_requirement": 1.0
    },
    {
        "name": "小型企业知识库",
        "num_vectors": 5000,
        "recall_requirement": 0.95
    },
    {
        "name": "中型企业知识库",
        "num_vectors": 50000,
        "recall_requirement": 0.95
    },
    {
        "name": "大型知识库（内存受限）",
        "num_vectors": 500000,
        "recall_requirement": 0.95,
        "memory_budget_gb": 5
    },
    {
        "name": "大型知识库（高QPS）",
        "num_vectors": 500000,
        "qps_requirement": 1000,
        "recall_requirement": 0.93
    },
    {
        "name": "实时新闻推荐",
        "num_vectors": 1000000,
        "frequent_insert": True,
        "recall_requirement": 0.90
    }
]

print("测试不同场景的索引选型：\n")

for case in test_cases:
    print(f"场景：{case['name']}")
    print(f"  向量数量：{case['num_vectors']:,}")

    recommendation = choose_index_type(**case)

    print(f"  ✅ 推荐索引：{recommendation['index_type']}")
    print(f"  理由：{recommendation['reason']}")
    print(f"  参数：{recommendation['params']}")
    print(f"  预期召回率：{recommendation['expected_recall']:.1%}")
    print(f"  预期延迟：{recommendation['expected_latency_ms']:.1f}ms")
    print(f"  内存占用：{recommendation['memory_gb']:.2f}GB")
    print()

# ===== 3. 三种索引对比实验 =====
print("\n步骤2：三种索引对比实验")
print("-" * 60)

connections.connect(alias="default", host="localhost", port="19530")

# 创建测试数据
num_docs = 10000  # 使用1万向量进行对比
dim = 768

print(f"生成 {num_docs} 个测试向量...")
doc_ids = list(range(num_docs))
titles = [f"文档_{i:05d}" for i in range(num_docs)]
embeddings = np.random.rand(num_docs, dim).tolist()

# 定义 Schema
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="doc_id", dtype=DataType.INT64),
    FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=200),
    FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=dim)
]
schema = CollectionSchema(fields, description="索引对比测试")

# 测试三种索引
index_configs = [
    {
        "name": "FLAT",
        "index_params": {
            "index_type": "FLAT",
            "metric_type": "L2",
            "params": {}
        },
        "search_params": {"metric_type": "L2", "params": {}}
    },
    {
        "name": "IVF_FLAT",
        "index_params": {
            "index_type": "IVF_FLAT",
            "metric_type": "L2",
            "params": {"nlist": 128}
        },
        "search_params": {"metric_type": "L2", "params": {"nprobe": 16}}
    },
    {
        "name": "HNSW",
        "index_params": {
            "index_type": "HNSW",
            "metric_type": "L2",
            "params": {"M": 16, "efConstruction": 200}
        },
        "search_params": {"metric_type": "L2", "params": {"ef": 64}}
    }
]

comparison_results = {}

for config in index_configs:
    print(f"\n测试 {config['name']} 索引...")

    collection_name = f"test_{config['name'].lower()}"

    # 删除旧 Collection
    if utility.has_collection(collection_name):
        utility.drop_collection(collection_name)

    # 创建 Collection
    collection = Collection(collection_name, schema)

    # 插入数据
    insert_start = time.time()
    collection.insert([doc_ids, titles, embeddings])
    collection.flush()
    insert_time = time.time() - insert_start

    # 创建索引
    index_start = time.time()
    collection.create_index("embedding", config["index_params"])
    index_time = time.time() - index_start

    # 加载 Collection
    load_start = time.time()
    collection.load()
    load_time = time.time() - load_start

    # 性能测试
    test_queries = np.random.rand(50, dim).tolist()
    latencies = []

    for query in test_queries:
        start = time.time()
        collection.search(
            data=[query],
            anns_field="embedding",
            param=config["search_params"],
            limit=10
        )
        latencies.append((time.time() - start) * 1000)

    # 计算召回率（使用 FLAT 作为 ground truth）
    if config['name'] == 'FLAT':
        ground_truth_results = []
        for query in test_queries[:10]:
            results = collection.search(
                data=[query],
                anns_field="embedding",
                param=config["search_params"],
                limit=10
            )
            ground_truth_results.append(set([hit.id for hit in results[0]]))
        recall = 1.0
    else:
        recalls = []
        for i, query in enumerate(test_queries[:10]):
            results = collection.search(
                data=[query],
                anns_field="embedding",
                param=config["search_params"],
                limit=10
            )
            result_ids = set([hit.id for hit in results[0]])
            recall_i = len(result_ids & ground_truth_results[i]) / len(ground_truth_results[i])
            recalls.append(recall_i)
        recall = np.mean(recalls)

    # 计算内存占用
    vector_size_mb = num_docs * dim * 4 / (1024**2)
    if config['name'] == 'FLAT':
        memory_mb = vector_size_mb
    elif config['name'] == 'IVF_FLAT':
        memory_mb = vector_size_mb * 1.1
    else:  # HNSW
        memory_mb = vector_size_mb * 1.7

    # 保存结果
    comparison_results[config['name']] = {
        "insert_time": insert_time,
        "index_time": index_time,
        "load_time": load_time,
        "avg_latency": np.mean(latencies),
        "p50_latency": np.percentile(latencies, 50),
        "p95_latency": np.percentile(latencies, 95),
        "p99_latency": np.percentile(latencies, 99),
        "recall": recall,
        "memory_mb": memory_mb,
        "qps": 1000 / np.mean(latencies)
    }

    print(f"  插入时间：{insert_time:.2f}秒")
    print(f"  索引构建：{index_time:.2f}秒")
    print(f"  加载时间：{load_time:.2f}秒")
    print(f"  平均延迟：{np.mean(latencies):.2f}ms")
    print(f"  P95延迟：{np.percentile(latencies, 95):.2f}ms")
    print(f"  召回率：{recall:.2%}")
    print(f"  内存占用：{memory_mb:.1f}MB")

    # 清理
    collection.release()
    utility.drop_collection(collection_name)

# ===== 4. 可视化对比 =====
print("\n步骤3：性能对比总结")
print("=" * 60)

print(f"\n{'指标':<20} {'FLAT':<15} {'IVF_FLAT':<15} {'HNSW':<15}")
print("-" * 65)

metrics = [
    ("索引构建时间", "index_time", "秒"),
    ("平均查询延迟", "avg_latency", "ms"),
    ("P95 延迟", "p95_latency", "ms"),
    ("P99 延迟", "p99_latency", "ms"),
    ("召回率", "recall", "%"),
    ("QPS", "qps", "查询/秒"),
    ("内存占用", "memory_mb", "MB")
]

for metric_name, metric_key, unit in metrics:
    flat_val = comparison_results['FLAT'][metric_key]
    ivf_val = comparison_results['IVF_FLAT'][metric_key]
    hnsw_val = comparison_results['HNSW'][metric_key]

    if unit == "%":
        print(f"{metric_name:<20} {flat_val:>12.1%} {ivf_val:>12.1%} {hnsw_val:>12.1%}")
    elif unit == "秒":
        print(f"{metric_name:<20} {flat_val:>12.2f}s {ivf_val:>12.2f}s {hnsw_val:>12.2f}s")
    elif unit == "ms":
        print(f"{metric_name:<20} {flat_val:>12.1f}ms {ivf_val:>12.1f}ms {hnsw_val:>12.1f}ms")
    elif unit == "查询/秒":
        print(f"{metric_name:<20} {flat_val:>14.0f} {ivf_val:>14.0f} {hnsw_val:>14.0f}")
    else:
        print(f"{metric_name:<20} {flat_val:>12.1f}{unit} {ivf_val:>12.1f}{unit} {hnsw_val:>12.1f}{unit}")

# ===== 5. RAG 场景选型建议 =====
print("\n步骤4：RAG 场景选型建议")
print("=" * 60)

rag_scenarios = [
    {
        "scenario": "个人知识库",
        "description": "< 1000 篇文档，个人使用",
        "recommended": "FLAT",
        "reason": "数据量小，FLAT 最简单，100% 召回率"
    },
    {
        "scenario": "小团队知识库",
        "description": "1000-5000 篇文档，10-50 人使用",
        "recommended": "FLAT 或 IVF_FLAT",
        "reason": "FLAT 足够快；如需更低延迟可用 IVF_FLAT"
    },
    {
        "scenario": "企业知识库",
        "description": "1万-10万篇文档，100+ 人使用",
        "recommended": "IVF_FLAT",
        "reason": "平衡召回率（96%+）和延迟（< 50ms）"
    },
    {
        "scenario": "大型知识库",
        "description": "> 10万篇文档，高并发",
        "recommended": "HNSW",
        "reason": "低延迟（< 15ms），支持高 QPS"
    },
    {
        "scenario": "实时内容推荐",
        "description": "频繁更新，实时插入",
        "recommended": "HNSW",
        "reason": "支持增量插入，无需重建索引"
    },
    {
        "scenario": "医疗/法律检索",
        "description": "高精度要求，召回率 > 98%",
        "recommended": "FLAT 或 IVF_FLAT (nprobe=64)",
        "reason": "保证高召回率，不能漏掉关键信息"
    }
]

print("\nRAG 应用场景索引选型指南：\n")

for scenario in rag_scenarios:
    print(f"场景：{scenario['scenario']}")
    print(f"  描述：{scenario['description']}")
    print(f"  ✅ 推荐：{scenario['recommended']}")
    print(f"  理由：{scenario['reason']}")
    print()

# ===== 6. 实用工具函数 =====
print("\n步骤5：实用工具函数")
print("=" * 60)

def auto_tune_ivf_params(num_vectors: int, target_recall: float = 0.95) -> Dict:
    """自动计算 IVF_FLAT 最优参数"""
    nlist = int(3 * math.sqrt(num_vectors))
    nlist = 2 ** int(math.log2(nlist))

    if target_recall >= 0.98:
        nprobe = int(nlist * 0.1)
    elif target_recall >= 0.95:
        nprobe = int(nlist * 0.05)
    else:
        nprobe = int(nlist * 0.02)

    nprobe = max(8, min(nprobe, nlist // 2))

    return {
        "nlist": nlist,
        "nprobe": nprobe,
        "expected_recall": target_recall
    }

def auto_tune_hnsw_params(target_recall: float = 0.93) -> Dict:
    """自动计算 HNSW 最优参数"""
    M = 16  # 平衡性能和内存
    efConstruction = 200  # 标准构建质量

    if target_recall >= 0.95:
        ef = 128
    elif target_recall >= 0.90:
        ef = 64
    else:
        ef = 32

    return {
        "M": M,
        "efConstruction": efConstruction,
        "ef": ef,
        "expected_recall": target_recall
    }

print("自动参数调优工具：\n")

# 示例1：IVF_FLAT 参数
print("示例1：50万向量，目标召回率 95%")
ivf_params = auto_tune_ivf_params(500000, target_recall=0.95)
print(f"  IVF_FLAT 参数：{ivf_params}")

# 示例2：HNSW 参数
print("\n示例2：100万向量，目标召回率 93%")
hnsw_params = auto_tune_hnsw_params(target_recall=0.93)
print(f"  HNSW 参数：{hnsw_params}")

# ===== 7. 总结 =====
print("\n" + "=" * 60)
print("总结")
print("=" * 60)

print("""
索引选型决策要点：

1. 数据规模优先：
   - < 1万：FLAT
   - 1万-10万：IVF_FLAT
   - > 10万：HNSW

2. 召回率要求：
   - > 98%：FLAT 或 IVF_FLAT (nprobe 调大)
   - 95-98%：IVF_FLAT
   - 90-95%：HNSW

3. 延迟要求：
   - < 10ms：HNSW
   - < 50ms：IVF_FLAT
   - 可接受更高：FLAT

4. 内存预算：
   - 受限：IVF_FLAT
   - 充足：HNSW

5. 增量插入：
   - 频繁插入：HNSW
   - 批量更新：IVF_FLAT

快速决策流程：
1. 先看数据规模（最重要）
2. 再看召回率要求
3. 考虑内存和延迟约束
4. 评估是否需要增量插入

工具使用：
- 使用 choose_index_type() 自动选型
- 使用 auto_tune_*_params() 自动调参
- 参考对比实验结果做决策
""")

# 清理
connections.disconnect("default")
print("\n✅ 场景4 完成！")
```

---

## 关键要点

### 1. 索引选型决策树

```
数据规模 < 1万？
  ├─ 是 → FLAT
  └─ 否 → 数据规模 < 10万？
           ├─ 是 → 召回率 > 98%？
           │        ├─ 是 → FLAT
           │        └─ 否 → IVF_FLAT
           └─ 否 → 内存受限？
                    ├─ 是 → IVF_FLAT
                    └─ 否 → 频繁插入？
                             ├─ 是 → HNSW
                             └─ 否 → QPS > 500？
                                      ├─ 是 → HNSW
                                      └─ 否 → 召回率 > 96%？
                                               ├─ 是 → IVF_FLAT
                                               └─ 否 → HNSW
```

### 2. 性能对比总结

| 指标 | FLAT | IVF_FLAT | HNSW | 最优 |
|------|------|----------|------|------|
| 查询延迟 | 中 | 中 | 低 | HNSW |
| 召回率 | 100% | 95-98% | 90-95% | FLAT |
| 内存占用 | 低 | 中 | 高 | FLAT |
| 构建速度 | 快 | 慢 | 快 | FLAT/HNSW |
| 增量插入 | 支持 | 需重建 | 支持 | FLAT/HNSW |
| 参数调优 | 无需 | 简单 | 复杂 | FLAT |

### 3. RAG 场景推荐

| 场景 | 文档数 | 推荐索引 | 关键参数 |
|------|--------|---------|---------|
| 个人笔记 | < 1K | FLAT | 无 |
| 小团队 | 1K-5K | FLAT/IVF | nlist=128 |
| 企业知识库 | 1万-10万 | IVF_FLAT | nlist=1024, nprobe=32 |
| 大型知识库 | > 10万 | HNSW | M=16, ef=64 |
| 实时推荐 | 任意 | HNSW | 支持增量 |
| 高精度检索 | 任意 | FLAT/IVF | 高召回率 |

### 4. 自动调优建议

**IVF_FLAT：**
```python
nlist = 3 * sqrt(num_vectors)
nprobe = nlist * (0.02 ~ 0.1)  # 根据召回率要求
```

**HNSW：**
```python
M = 16  # 固定值
efConstruction = 200  # 固定值
ef = 32 ~ 128  # 根据召回率要求
```

---

**完成！** 现在你已经掌握了如何根据实际需求选择最优的索引类型。

**下一步学习：**
- [02_第一性原理.md](./02_第一性原理.md) - 深入理解索引的本质
- [03_核心概念_FLAT索引.md](./03_核心概念_FLAT索引.md) - FLAT 索引详解
