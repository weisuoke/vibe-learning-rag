# 核心概念05：可配置字段系统

> **本节目标**: 掌握configurable_fields()方法，实现运行时动态配置

---

## 一、可配置字段概述

### 1.1 什么是可配置字段？

可配置字段允许在运行时动态修改Runnable的属性值，无需重新创建对象。

```python
from langchain_openai import ChatOpenAI
from langchain_core.runnables import ConfigurableField

# 定义可配置字段
llm = ChatOpenAI(temperature=0.5).configurable_fields(
    temperature=ConfigurableField(
        id="llm_temperature",
        name="LLM Temperature",
        description="The temperature of the LLM"
    )
)

# 运行时配置
result = llm.invoke(
    "Hello",
    config={"configurable": {"llm_temperature": 0.9}}
)
# 使用temperature=0.9，而不是默认的0.5
```

### 1.2 为什么需要可配置字段？

**没有可配置字段**：
```python
# 需要创建多个LLM实例
llm_creative = ChatOpenAI(temperature=0.9)
llm_precise = ChatOpenAI(temperature=0.1)

# 需要维护多个链
chain_creative = prompt | llm_creative | parser
chain_precise = prompt | llm_precise | parser
```

**有可配置字段**：
```python
# 只需一个LLM实例
llm = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="temp")
)

# 运行时切换
result_creative = llm.invoke(input, config={"configurable": {"temp": 0.9}})
result_precise = llm.invoke(input, config={"configurable": {"temp": 0.1}})
```

---

## 二、configurable_fields()方法

### 2.1 方法签名

```python
def configurable_fields(
    self,
    **kwargs: ConfigurableField
) -> RunnableConfigurableFields:
    """
    使字段可配置

    参数:
        **kwargs: 字段名到ConfigurableField的映射

    返回:
        RunnableConfigurableFields实例
    """
```

### 2.2 基本用法

```python
from langchain_openai import ChatOpenAI
from langchain_core.runnables import ConfigurableField

# 单个可配置字段
llm = ChatOpenAI(temperature=0.5).configurable_fields(
    temperature=ConfigurableField(
        id="temp",
        name="Temperature",
        description="LLM temperature"
    )
)

# 运行时配置
result = llm.invoke(
    "Hello",
    config={"configurable": {"temp": 0.9}}
)
```

### 2.3 多个可配置字段

```python
# 多个字段同时可配置
llm = ChatOpenAI(
    temperature=0.5,
    max_tokens=500
).configurable_fields(
    temperature=ConfigurableField(
        id="temp",
        name="Temperature"
    ),
    max_tokens=ConfigurableField(
        id="max_tokens",
        name="Max Tokens"
    )
)

# 运行时配置多个字段
result = llm.invoke(
    "Hello",
    config={
        "configurable": {
            "temp": 0.9,
            "max_tokens": 1000
        }
    }
)
```

---

## 三、ConfigurableField类

### 3.1 类定义

```python
from typing import Optional, Any
from pydantic import BaseModel

class ConfigurableField(BaseModel):
    """
    可配置字段定义

    属性:
        id: 字段唯一标识符
        name: 字段显示名称
        description: 字段描述
        annotation: 字段类型注解（可选）
    """
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    annotation: Optional[Any] = None
```

### 3.2 字段属性详解

**id（必需）**：
- 字段的唯一标识符
- 用于在config.configurable中引用
- 必须在整个链中唯一

```python
ConfigurableField(
    id="llm_temperature"  # 必须唯一
)
```

**name（可选）**：
- 字段的显示名称
- 用于UI或文档

```python
ConfigurableField(
    id="temp",
    name="LLM Temperature"  # 用户友好的名称
)
```

**description（可选）**：
- 字段的详细描述
- 解释字段的用途和影响

```python
ConfigurableField(
    id="temp",
    name="Temperature",
    description="Controls randomness. Higher values make output more random."
)
```

**annotation（可选）**：
- 字段的类型注解
- 用于类型检查和验证

```python
ConfigurableField(
    id="temp",
    name="Temperature",
    annotation=float  # 类型注解
)
```

---

## 四、运行时字段覆盖

### 4.1 基本覆盖

```python
# 定义可配置字段
llm = ChatOpenAI(temperature=0.5).configurable_fields(
    temperature=ConfigurableField(id="temp")
)

# 运行时覆盖
result = llm.invoke(
    "Hello",
    config={"configurable": {"temp": 0.9}}
)
# 使用0.9，忽略默认的0.5
```

### 4.2 部分覆盖

```python
# 多个可配置字段
llm = ChatOpenAI(
    temperature=0.5,
    max_tokens=500,
    model="gpt-4"
).configurable_fields(
    temperature=ConfigurableField(id="temp"),
    max_tokens=ConfigurableField(id="tokens"),
    model=ConfigurableField(id="model")
)

# 只覆盖temperature
result = llm.invoke(
    "Hello",
    config={"configurable": {"temp": 0.9}}
)
# temperature=0.9, max_tokens=500, model="gpt-4"
```

### 4.3 默认值处理

```python
# 如果不提供configurable，使用默认值
llm = ChatOpenAI(temperature=0.5).configurable_fields(
    temperature=ConfigurableField(id="temp")
)

# 不提供configurable
result = llm.invoke("Hello")
# 使用默认的temperature=0.5
```

---

## 五、实际应用场景

### 5.1 A/B测试

```python
# 定义可配置LLM
llm = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="temp"),
    model=ConfigurableField(id="model")
)

chain = prompt | llm | parser

# 测试不同配置
config_a = {"configurable": {"temp": 0.3, "model": "gpt-4"}}
config_b = {"configurable": {"temp": 0.9, "model": "gpt-3.5-turbo"}}

result_a = chain.invoke(input, config=config_a)
result_b = chain.invoke(input, config=config_b)

# 比较结果
```

### 5.2 用户偏好

```python
# 根据用户偏好配置
user_preferences = {
    "alice": {"temp": 0.7, "max_tokens": 500},
    "bob": {"temp": 0.3, "max_tokens": 200}
}

def get_config_for_user(user_id: str):
    prefs = user_preferences.get(user_id, {})
    return {"configurable": prefs}

# 使用
result = chain.invoke(
    input,
    config=get_config_for_user("alice")
)
```

### 5.3 任务复杂度适配

```python
def get_config_for_complexity(complexity: str):
    """根据任务复杂度返回配置"""
    if complexity == "high":
        return {
            "configurable": {
                "model": "gpt-4",
                "temp": 0.3,
                "max_tokens": 2000
            }
        }
    elif complexity == "medium":
        return {
            "configurable": {
                "model": "gpt-3.5-turbo",
                "temp": 0.5,
                "max_tokens": 1000
            }
        }
    else:  # low
        return {
            "configurable": {
                "model": "gpt-3.5-turbo",
                "temp": 0.7,
                "max_tokens": 500
            }
        }

# 使用
result = chain.invoke(
    input,
    config=get_config_for_complexity("high")
)
```

---

## 六、Retriever可配置字段

### 6.1 配置检索参数

```python
from langchain_community.vectorstores import Chroma
from langchain_core.runnables import ConfigurableField

# 创建retriever
vectorstore = Chroma(...)
retriever = vectorstore.as_retriever(
    search_kwargs={"k": 5}
).configurable_fields(
    search_kwargs=ConfigurableField(
        id="search_kwargs",
        name="Search Parameters"
    )
)

# 运行时调整检索数量
docs = retriever.invoke(
    "query",
    config={
        "configurable": {
            "search_kwargs": {"k": 10, "score_threshold": 0.8}
        }
    }
)
```

### 6.2 RAG应用中的使用

```python
# RAG链
rag_chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
    | llm
    | parser
)

# 运行时配置retriever和llm
result = rag_chain.invoke(
    "What is AI?",
    config={
        "configurable": {
            "search_kwargs": {"k": 10},
            "temp": 0.3
        }
    }
)
```

---

## 七、字段ID唯一性

### 7.1 为什么ID必须唯一？

```python
# ❌ 错误：ID冲突
llm1 = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="temp")
)
llm2 = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="temp")  # 相同ID
)

chain = llm1 | llm2

# 运行时配置会影响两个LLM
result = chain.invoke(
    input,
    config={"configurable": {"temp": 0.9}}
)
# llm1和llm2都使用0.9
```

### 7.2 使用唯一ID

```python
# ✓ 正确：使用唯一ID
llm1 = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="llm1_temp")
)
llm2 = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="llm2_temp")
)

chain = llm1 | llm2

# 分别配置
result = chain.invoke(
    input,
    config={
        "configurable": {
            "llm1_temp": 0.9,
            "llm2_temp": 0.3
        }
    }
)
```

### 7.3 命名约定

```python
# 推荐的命名约定
# 格式：<组件类型>_<实例名>_<字段名>

llm_creative = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="llm_creative_temp")
)

llm_precise = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="llm_precise_temp")
)

retriever = vectorstore.as_retriever().configurable_fields(
    search_kwargs=ConfigurableField(id="retriever_search_kwargs")
)
```

---

## 八、类型安全

### 8.1 使用annotation

```python
from typing import Literal

llm = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(
        id="temp",
        annotation=float  # 类型注解
    ),
    model=ConfigurableField(
        id="model",
        annotation=Literal["gpt-4", "gpt-3.5-turbo"]  # 限制选项
    )
)

# 类型检查（如果使用mypy）
config = {
    "configurable": {
        "temp": 0.9,  # float ✓
        "model": "gpt-4"  # Literal ✓
    }
}
```

### 8.2 运行时验证

```python
def validate_config(config: dict):
    """验证configurable字段"""
    configurable = config.get("configurable", {})

    if "temp" in configurable:
        temp = configurable["temp"]
        assert isinstance(temp, (int, float)), "temp must be numeric"
        assert 0 <= temp <= 2, "temp must be between 0 and 2"

    if "max_tokens" in configurable:
        tokens = configurable["max_tokens"]
        assert isinstance(tokens, int), "max_tokens must be int"
        assert tokens > 0, "max_tokens must be positive"

    return config

# 使用
config = {"configurable": {"temp": 0.9, "max_tokens": 500}}
validated_config = validate_config(config)
result = chain.invoke(input, config=validated_config)
```

---

## 九、2025-2026新特性

根据研究材料（temp/06_configurable_fields_advanced.md）：

### 9.1 init_chat_model集成

```python
from langchain.chat_models import init_chat_model

# 2025新特性：init_chat_model支持configurable_fields
model = init_chat_model(
    model="gpt-4",
    configurable_fields=["temperature", "max_tokens", "model_name"]
)

# 运行时切换模型
result = model.invoke(
    "Hello",
    config={"configurable": {"model_name": "gpt-3.5-turbo"}}
)
```

### 9.2 运行时超参数调优

```python
# 2026 demo：Streamlit中动态调整
import streamlit as st

llm = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="temp")
)

# UI滑块
temp = st.slider("Temperature", 0.0, 2.0, 0.7)

# 使用用户选择的值
result = llm.invoke(
    user_input,
    config={"configurable": {"temp": temp}}
)
```

---

## 十、常见陷阱

### 10.1 字段ID冲突

```python
# ❌ 陷阱：嵌套链中的ID冲突
sub_chain = llm.configurable_fields(
    temperature=ConfigurableField(id="temp")
)
main_chain = (prompt | sub_chain).configurable_fields(
    # 错误：不能再次配置相同字段
)
```

### 10.2 忘记提供configurable

```python
# ❌ 陷阱：定义了可配置字段但忘记使用
llm = ChatOpenAI(temperature=0.5).configurable_fields(
    temperature=ConfigurableField(id="temp")
)

result = llm.invoke("Hello")  # 使用默认值0.5
# 忘记提供config={"configurable": {"temp": 0.9}}
```

### 10.3 类型不匹配

```python
# ❌ 陷阱：提供错误类型的值
llm = ChatOpenAI().configurable_fields(
    temperature=ConfigurableField(id="temp", annotation=float)
)

result = llm.invoke(
    "Hello",
    config={"configurable": {"temp": "0.9"}}  # 字符串而不是float
)
# 可能导致运行时错误
```

---

## 十一、最佳实践

### 11.1 配置工厂模式

```python
def create_configurable_llm():
    """创建可配置LLM的工厂函数"""
    return ChatOpenAI(
        temperature=0.5,
        max_tokens=500
    ).configurable_fields(
        temperature=ConfigurableField(
            id="llm_temperature",
            name="Temperature",
            description="Controls randomness",
            annotation=float
        ),
        max_tokens=ConfigurableField(
            id="llm_max_tokens",
            name="Max Tokens",
            description="Maximum tokens to generate",
            annotation=int
        )
    )

# 使用
llm = create_configurable_llm()
```

### 11.2 配置验证

```python
from pydantic import BaseModel, Field

class LLMConfig(BaseModel):
    """LLM配置模型"""
    temperature: float = Field(ge=0, le=2)
    max_tokens: int = Field(gt=0, le=4000)

def get_validated_config(temp: float, tokens: int):
    """返回验证过的配置"""
    config_model = LLMConfig(temperature=temp, max_tokens=tokens)
    return {
        "configurable": {
            "llm_temperature": config_model.temperature,
            "llm_max_tokens": config_model.max_tokens
        }
    }
```

### 11.3 文档化

```python
def create_rag_chain():
    """
    创建RAG链

    可配置字段:
        - retriever_k: 检索文档数量 (int, 默认5)
        - llm_temperature: LLM温度 (float, 默认0.5)
        - llm_max_tokens: 最大token数 (int, 默认500)

    示例:
        config = {
            "configurable": {
                "retriever_k": 10,
                "llm_temperature": 0.7
            }
        }
        result = chain.invoke(query, config=config)
    """
    # 实现...
```

---

## 十二、下一步

- 可配置替代: [核心概念06 - 可配置替代方案](./03_核心概念_06_可配置替代方案.md)
- Callbacks配置: [核心概念07 - Callbacks配置与传递](./03_核心概念_07_Callbacks配置与传递.md)
- 实战练习: [实战代码03 - 动态字段配置](./07_实战代码_03_动态字段配置.md)
