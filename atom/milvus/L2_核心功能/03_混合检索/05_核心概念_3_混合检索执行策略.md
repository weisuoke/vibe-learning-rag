# 核心概念3：混合检索执行策略

## 一句话定义

**混合检索执行策略是 Milvus 决定向量检索与标量过滤执行顺序的优化机制，通过分析数据分布和过滤选择性，自动选择 Filter-then-Search 或 Search-then-Filter 策略，实现性能最优化。**

---

## 1. 执行策略的本质

### 1.1 为什么需要执行策略？

**核心问题**：向量检索和标量过滤，谁先执行？

```python
# 混合检索请求
results = collection.search(
    data=[query_vector],        # 向量检索
    anns_field="embedding",
    limit=10,
    expr="tenant_id == 'A'"     # 标量过滤
)

# 问题：Milvus 内部如何执行？
# 策略1：先过滤 tenant_id，再向量检索？
# 策略2：先向量检索，再过滤 tenant_id？
```

**答案**：取决于数据特征和查询模式，不同策略性能差异可达 10-100 倍。

---

### 1.2 两种执行策略

#### 策略1：Filter-then-Search（先过滤后检索）

```
执行流程：
1. 标量过滤：根据 expr 筛选数据
2. 向量检索：在过滤后的数据中检索
3. 返回结果

示例：
总数据：100万条
   ↓ 标量过滤（tenant_id == 'A'）
过滤后：1万条（过滤掉99%）
   ↓ 向量检索
Top-10 结果
```

**适用场景**：

- ✅ 过滤选择性高（过滤掉大量数据）
- ✅ 过滤字段有索引
- ✅ 向量计算成本高

**性能特点**：

- 向量计算量：小（只在过滤后的数据中计算）
- 过滤成本：中（需要扫描或使用索引）
- 总体性能：高（当过滤选择性 > 90%）

---

#### 策略2：Search-then-Filter（先检索后过滤）

```
执行流程：
1. 向量检索：在全部数据中检索 Top-K
2. 标量过滤：在 Top-K 结果中过滤
3. 返回结果

示例：
总数据：100万条
   ↓ 向量检索
Top-100 结果
   ↓ 标量过滤（age > 18）
Top-10 结果（过滤掉10%）
```

**适用场景**：

- ✅ 过滤选择性低（过滤掉少量数据）
- ✅ 向量索引效率高
- ✅ Top-K 较小

**性能特点**：

- 向量计算量：大（在全部数据中计算）
- 过滤成本：小（只过滤 Top-K 结果）
- 总体性能：高（当过滤选择性 < 50%）

---

## 2. 性能对比分析

### 2.1 数学模型

#### Filter-then-Search 成本

```
总成本 = 过滤成本 + 向量检索成本

过滤成本 = N × C_filter
向量检索成本 = (N × selectivity) × D × C_vector

其中：
- N：总数据量
- selectivity：过滤选择性（过滤后剩余比例）
- D：向量维度
- C_filter：单次过滤成本（很小）
- C_vector：单次向量计算成本（较大）

示例（N=100万，selectivity=1%，D=768）：
过滤成本 = 100万 × 0.001 = 1,000
向量检索成本 = (100万 × 0.01) × 768 × 1 = 7,680,000
总成本 ≈ 7,681,000
```

---

#### Search-then-Filter 成本

```
总成本 = 向量检索成本 + 过滤成本

向量检索成本 = N × D × C_vector
过滤成本 = K × C_filter

其中：
- K：Top-K 大小

示例（N=100万，K=100，D=768）：
向量检索成本 = 100万 × 768 × 1 = 768,000,000
过滤成本 = 100 × 0.001 = 0.1
总成本 ≈ 768,000,000
```

---

### 2.2 性能对比表

**场景1：高选择性过滤（过滤掉99%数据）**

| 策略 | 过滤成本 | 向量成本 | 总成本 | 相对性能 |
|------|---------|---------|--------|---------|
| Filter-then-Search | 1,000 | 7,680,000 | 7,681,000 | **100x 快** |
| Search-then-Filter | 0.1 | 768,000,000 | 768,000,000 | 1x |

**结论**：高选择性过滤时，Filter-then-Search 快 100 倍。

---

**场景2：低选择性过滤（过滤掉10%数据）**

| 策略 | 过滤成本 | 向量成本 | 总成本 | 相对性能 |
|------|---------|---------|--------|---------|
| Filter-then-Search | 1,000 | 691,200,000 | 691,201,000 | 1.1x |
| Search-then-Filter | 0.1 | 768,000,000 | 768,000,000 | 1x |

**结论**：低选择性过滤时，两种策略性能接近。

---

**场景3：极低选择性过滤（过滤掉1%数据）**

| 策略 | 过滤成本 | 向量成本 | 总成本 | 相对性能 |
|------|---------|---------|--------|---------|
| Filter-then-Search | 1,000 | 760,320,000 | 760,321,000 | 1x |
| Search-then-Filter | 0.1 | 768,000,000 | 768,000,000 | **1.01x 快** |

**结论**：极低选择性过滤时，Search-then-Filter 略快。

---

### 2.3 决策阈值

**经验规则**：

```
if 过滤选择性 > 90%:
    使用 Filter-then-Search  # 过滤掉大量数据
elif 过滤选择性 < 50%:
    使用 Search-then-Filter  # 过滤掉少量数据
else:
    根据具体情况决策  # 50%-90% 之间
```

**示例**：

```python
# 高选择性（99%）：Filter-then-Search
expr = "tenant_id == 'A'"  # 100万条 → 1万条

# 中选择性（80%）：Filter-then-Search
expr = "year >= 2020"  # 100万条 → 20万条

# 低选择性（10%）：Search-then-Filter
expr = "age > 18"  # 100万条 → 90万条

# 极低选择性（1%）：Search-then-Filter
expr = "is_premium == true"  # 100万条 → 99万条
```

---

## 3. Milvus 自动优化机制

### 3.1 优化器工作流程

```
用户查询
   ↓
1. 解析查询
   - 提取向量：query_vector
   - 提取表达式：expr
   ↓
2. 统计信息收集
   - 数据总量：N
   - 过滤字段分布：统计信息
   - 索引类型：是否有标量索引
   ↓
3. 选择性估算
   - 估算过滤后数据量：N × selectivity
   - 计算两种策略的成本
   ↓
4. 策略选择
   - 选择成本最低的策略
   ↓
5. 执行查询
   - 按选定策略执行
   ↓
6. 返回结果
```

---

### 3.2 选择性估算方法

#### 方法1：基于统计信息

```python
# Milvus 维护字段的统计信息
statistics = {
    "tenant_id": {
        "distinct_values": 100,  # 100个不同的租户
        "total_rows": 1000000,   # 100万条数据
        "distribution": {
            "A": 10000,  # 租户A有1万条
            "B": 20000,  # 租户B有2万条
            ...
        }
    }
}

# 估算选择性
expr = "tenant_id == 'A'"
selectivity = 10000 / 1000000 = 0.01  # 1%
```

---

#### 方法2：基于采样

```python
# 如果没有统计信息，Milvus 可能采样估算
sample_size = 10000  # 采样1万条
sample_match = 100   # 采样中有100条匹配

selectivity = sample_match / sample_size = 0.01  # 1%
```

---

### 3.3 成本模型

```python
# Milvus 内部成本模型（简化版）

def estimate_cost(strategy, N, selectivity, D, K):
    if strategy == "Filter-then-Search":
        filter_cost = N * 0.001  # 过滤成本（假设）
        search_cost = (N * selectivity) * D * 1  # 向量检索成本
        return filter_cost + search_cost

    elif strategy == "Search-then-Filter":
        search_cost = N * D * 1  # 向量检索成本
        filter_cost = K * 0.001  # 过滤成本
        return search_cost + filter_cost

# 选择成本最低的策略
cost_fts = estimate_cost("Filter-then-Search", N, selectivity, D, K)
cost_stf = estimate_cost("Search-then-Filter", N, selectivity, D, K)

if cost_fts < cost_stf:
    strategy = "Filter-then-Search"
else:
    strategy = "Search-then-Filter"
```

---

### 3.4 动态调整

**Milvus 会根据实际执行情况动态调整**：

```python
# 第一次查询：使用估算的选择性
query_1 = search(expr="tenant_id == 'A'")
# Milvus 估算：selectivity = 1%
# 选择：Filter-then-Search

# 执行后，Milvus 记录实际选择性
actual_selectivity = 0.5%  # 实际只有0.5%

# 第二次相同查询：使用实际选择性
query_2 = search(expr="tenant_id == 'A'")
# Milvus 使用：selectivity = 0.5%（更准确）
# 选择：Filter-then-Search（更优）
```

---

## 4. 影响策略选择的因素

### 4.1 过滤选择性

**最关键因素**

```python
# 高选择性（过滤掉99%）
expr = "tenant_id == 'A'"
# → Filter-then-Search

# 低选择性（过滤掉10%）
expr = "age > 18"
# → Search-then-Filter
```

---

### 4.2 标量索引

**有索引 vs 无索引**

```python
# 有索引：过滤成本低
collection.create_index(field_name="tenant_id")
# → 倾向 Filter-then-Search

# 无索引：过滤成本高（全表扫描）
# → 倾向 Search-then-Filter（除非选择性极高）
```

---

### 4.3 向量索引类型

**不同索引的检索成本**

```python
# HNSW：检索快，倾向 Search-then-Filter
index_params = {"index_type": "HNSW"}

# IVF_FLAT：检索中等，根据选择性决策
index_params = {"index_type": "IVF_FLAT"}

# FLAT：检索慢（暴力搜索），倾向 Filter-then-Search
index_params = {"index_type": "FLAT"}
```

---

### 4.4 数据量

**数据量影响成本**

```python
# 小数据量（< 10万）：两种策略差异不大
N = 100000
# → 任意策略

# 大数据量（> 100万）：策略选择很重要
N = 10000000
# → 根据选择性仔细选择
```

---

### 4.5 Top-K 大小

**Top-K 影响 Search-then-Filter 成本**

```python
# 小 Top-K（< 100）：Search-then-Filter 过滤成本低
limit = 10
# → 倾向 Search-then-Filter

# 大 Top-K（> 1000）：Search-then-Filter 过滤成本高
limit = 10000
# → 倾向 Filter-then-Search
```

---

## 5. 复杂场景的策略

### 5.1 多条件过滤

```python
# 场景：多个过滤条件
expr = "tenant_id == 'A' and year == 2024 and category == 'tech'"

# Milvus 策略：
# 1. 分析每个条件的选择性
#    - tenant_id == 'A': 1%（高选择性）
#    - year == 2024: 20%（中选择性）
#    - category == 'tech': 30%（低选择性）
#
# 2. 选择最高选择性的条件先过滤
#    - 先过滤 tenant_id（1万条）
#    - 再过滤 year（2000条）
#    - 最后过滤 category（600条）
#
# 3. 在过滤后的数据中向量检索
```

**优化原则**：高选择性条件优先

---

### 5.2 OR 条件

```python
# 场景：OR 条件
expr = "city == 'Beijing' or city == 'Shanghai'"

# Milvus 策略：
# 1. 估算 OR 条件的总选择性
#    - Beijing: 10%
#    - Shanghai: 15%
#    - 总选择性: 25%
#
# 2. 根据总选择性选择策略
#    - 25% < 50% → Search-then-Filter
```

---

### 5.3 范围查询

```python
# 场景：范围查询
expr = "price >= 100 and price <= 1000"

# Milvus 策略：
# 1. 估算范围内的数据量
#    - 假设价格均匀分布
#    - 范围选择性 = (1000 - 100) / (max_price - min_price)
#
# 2. 根据选择性选择策略
```

---

### 5.4 分区 + 标量过滤

```python
# 场景：分区 + 标量过滤
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    partition_names=["2024_Q1"],  # 分区过滤（粗粒度）
    expr="status == 'approved'"    # 标量过滤（细粒度）
)

# Milvus 策略：
# 1. 先应用分区过滤（100万 → 10万）
# 2. 再应用标量过滤（10万 → 5万）
# 3. 最后向量检索（在5万条中检索）
#
# 性能：比纯标量过滤快 20 倍
```

---

## 6. 实战示例

### 6.1 高选择性场景：多租户

```python
from pymilvus import connections, Collection
import time

connections.connect("default", host="localhost", port="19530")
collection = Collection("documents")
collection.load()

# 场景：租户A查询（100万条数据，租户A有1万条）
query_vector = embed("Python 教程")

# 测试：Filter-then-Search（Milvus 自动选择）
start = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"ef": 64}},
    limit=10,
    expr="tenant_id == 'A'"  # 高选择性（1%）
)
time_fts = time.time() - start

print(f"Filter-then-Search: {time_fts:.4f}s")
# 预期：~0.01s（只在1万条中检索）

# 对比：如果强制 Search-then-Filter（模拟）
start = time.time()
results_all = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"ef": 64}},
    limit=1000  # 先检索1000条
)
# 手动过滤
results_filtered = [r for r in results_all[0] if r.entity.get('tenant_id') == 'A'][:10]
time_stf = time.time() - start

print(f"Search-then-Filter: {time_stf:.4f}s")
# 预期：~1s（在100万条中检索）

print(f"性能提升: {time_stf / time_fts:.2f}x")
# 预期：~100x
```

---

### 6.2 低选择性场景：年龄过滤

```python
# 场景：年龄过滤（100万条数据，90万条满足 age > 18）

# 测试：Search-then-Filter（Milvus 自动选择）
start = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"ef": 64}},
    limit=10,
    expr="age > 18"  # 低选择性（90%）
)
time_stf = time.time() - start

print(f"Search-then-Filter: {time_stf:.4f}s")
# 预期：~0.1s（先检索，后过滤少量数据）

# 对比：如果强制 Filter-then-Search（模拟）
# （需要先过滤90万条，成本高）
print(f"Filter-then-Search 会更慢（需要过滤90万条）")
```

---

### 6.3 复杂条件场景

```python
# 场景：多条件过滤
expr = """
    tenant_id == 'A' and
    year == 2024 and
    category in ['tech', 'ai', 'ml'] and
    rating >= 4.0
"""

# Milvus 自动优化：
# 1. 分析选择性：
#    - tenant_id == 'A': 1%（最高）
#    - year == 2024: 20%
#    - category in [...]: 30%
#    - rating >= 4.0: 50%
#
# 2. 执行顺序：
#    - 先过滤 tenant_id（100万 → 1万）
#    - 再过滤 year（1万 → 2000）
#    - 再过滤 category（2000 → 600）
#    - 再过滤 rating（600 → 300）
#    - 最后向量检索（在300条中检索）

start = time.time()
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    param={"metric_type": "L2", "params": {"ef": 64}},
    limit=10,
    expr=expr
)
time_optimized = time.time() - start

print(f"优化后: {time_optimized:.4f}s")
# 预期：~0.005s（只在300条中检索）
```

---

## 7. 性能调优建议

### 7.1 为高选择性字段创建索引

```python
# 为租户ID创建索引（高选择性）
collection.create_index(
    field_name="tenant_id",
    index_name="tenant_id_index"
)

# 效果：Filter-then-Search 性能提升 10-100 倍
```

---

### 7.2 高选择性条件前置

```python
# ❌ 低效（低选择性在前）
expr = "age > 18 and tenant_id == 'A'"

# ✅ 高效（高选择性在前）
expr = "tenant_id == 'A' and age > 18"

# 原因：Milvus 可能短路求值
```

---

### 7.3 使用分区减少数据量

```python
# ❌ 低效（在全部数据中过滤）
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    expr="year == 2024 and quarter == 'Q1'"
)

# ✅ 高效（先用分区过滤，再用标量过滤）
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10,
    partition_names=["2024_Q1"],  # 分区过滤
    expr="status == 'approved'"    # 标量过滤
)
```

---

### 7.4 控制 Top-K 大小

```python
# ❌ 低效（Top-K 过大）
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=10000,  # 过大
    expr="age > 18"
)

# ✅ 高效（合理的 Top-K）
results = collection.search(
    data=[query_vector],
    anns_field="embedding",
    limit=100,  # 合理（10-100）
    expr="age > 18"
)
```

---

## 8. 关键要点总结

### 核心概念

1. **执行策略 = 决定向量检索与标量过滤的执行顺序**
2. **Filter-then-Search = 先过滤后检索（适合高选择性）**
3. **Search-then-Filter = 先检索后过滤（适合低选择性）**
4. **Milvus 自动优化 = 根据数据分布和选择性自动选择最优策略**

### 决策规则

- 过滤选择性 > 90% → Filter-then-Search
- 过滤选择性 < 50% → Search-then-Filter
- 50%-90% → 根据具体情况

### 性能优化

1. 为高选择性字段创建索引
2. 高选择性条件前置
3. 使用分区 + 标量过滤组合
4. 控制 Top-K 大小

### 在混合检索中的作用

- 执行策略：优化性能，减少计算量
- 自动优化：无需手动调优，Milvus 自动选择
- 性能提升：10-100 倍（高选择性场景）

---

**下一步**：学习 [06_最小可用.md](./06_最小可用.md)
