# 最小可用

掌握以下内容，就能开始使用 Milvus 的数据一致性与持久化机制：

## 4.1 理解一致性级别的选择

**核心概念：** Milvus 提供 4 种一致性级别，根据业务需求选择合适的级别

```python
from pymilvus import Collection, connections

connections.connect("default", host="localhost", port="19530")
collection = Collection("my_collection")

# Strong：强一致性（最新数据，性能最低）
results = collection.search(
    data=[[0.1, 0.2, ...]],
    anns_field="vector",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=5,
    consistency_level="Strong"  # 适用于实时性要求高的场景
)

# Bounded：有界一致性（平衡性能和一致性）
results = collection.search(
    data=[[0.1, 0.2, ...]],
    anns_field="vector",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=5,
    consistency_level="Bounded"  # 默认选择，适用于大多数场景
)

# Eventually：最终一致性（性能最高，数据可能稍旧）
results = collection.search(
    data=[[0.1, 0.2, ...]],
    anns_field="vector",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=5,
    consistency_level="Eventually"  # 适用于对实时性要求不高的场景
)

# Session：会话一致性（保证同一会话内的一致性）
results = collection.search(
    data=[[0.1, 0.2, ...]],
    anns_field="vector",
    param={"metric_type": "L2", "params": {"nprobe": 10}},
    limit=5,
    consistency_level="Session"  # 适用于单用户会话场景
)
```

**在 RAG 中的应用：**
- **实时客服系统**：使用 Strong，确保看到最新的知识库更新
- **历史文档检索**：使用 Eventually，性能优先
- **用户个人知识库**：使用 Session，保证用户自己的操作一致

**选择标准：**
| 一致性级别 | 性能 | 实时性 | 适用场景 |
|-----------|------|--------|---------|
| Strong | 低 | 最高 | 实时系统、金融交易 |
| Bounded | 中 | 高 | 通用场景（推荐） |
| Session | 中 | 中 | 单用户会话 |
| Eventually | 高 | 低 | 历史数据、批量查询 |

---

## 4.2 理解 WAL 的作用

**核心概念：** WAL (Write-Ahead Log) 确保数据不丢失，即使系统崩溃也能恢复

```python
from pymilvus import Collection, connections

connections.connect("default", host="localhost", port="19530")
collection = Collection("my_collection")

# 插入数据时，Milvus 自动使用 WAL
# 1. 先写入 WAL（顺序写，速度快）
# 2. 再写入内存（异步）
# 3. 最后刷新到磁盘（异步）
collection.insert([
    {"id": 1, "vector": [0.1, 0.2, 0.3], "text": "文档1"},
    {"id": 2, "vector": [0.4, 0.5, 0.6], "text": "文档2"},
])

# 即使在这里系统崩溃，数据也不会丢失
# 因为 WAL 已经记录了操作

# 重启后，Milvus 自动从 WAL 恢复数据
```

**WAL 的工作流程：**
```
用户插入数据
    ↓
写入 WAL（持久化到磁盘）
    ↓
写入内存（快速响应用户）
    ↓
异步刷新到存储引擎
    ↓
完成
```

**在 RAG 中的价值：**
- 用户上传大量文档到知识库，即使系统崩溃也不会丢失
- 保证数据的持久化，避免重复导入

**关键点：**
- WAL 是自动的，用户无需手动配置
- WAL 文件存储在 Milvus 的数据目录中
- 定期清理旧的 WAL 文件（已刷新到存储的数据）

---

## 4.3 理解 Compaction 的作用

**核心概念：** Compaction 定期合并和清理数据，优化存储空间和查询性能

```python
from pymilvus import Collection, connections, utility

connections.connect("default", host="localhost", port="19530")
collection = Collection("my_collection")

# 场景：删除大量过期数据
collection.delete(expr="id in [1, 2, 3, 4, 5]")

# 此时数据只是标记为删除，并未真正删除
# 存储空间仍然被占用

# 手动触发 Compaction（通常是自动的）
utility.do_compact(collection_name="my_collection")

# Compaction 会：
# 1. 合并小 Segment 为大 Segment
# 2. 删除标记为删除的数据
# 3. 重建索引
# 4. 优化存储布局

# 查询 Compaction 状态
state = utility.get_compaction_state(compaction_id=1)
print(f"Compaction 状态: {state}")
```

**Compaction 的触发条件：**
- 自动触发：Milvus 定期检查并自动运行 Compaction
- 手动触发：用户调用 `do_compact()` 手动触发
- 触发条件：
  - 小 Segment 数量超过阈值
  - 删除数据比例超过阈值
  - 存储碎片化严重

**在 RAG 中的价值：**
```python
# 场景：知识库每天更新，删除过时文档
# 一个月后：
# - 存储空间：100GB（实际数据 60GB + 已删除数据 40GB）
# - 查询性能：下降 30%（需要扫描无效数据）

# Compaction 运行后：
# - 存储空间：60GB（回收 40GB）
# - 查询性能：提升 30%（不再扫描无效数据）
```

**关键点：**
- Compaction 是后台运行的，不影响正常查询
- 大规模 Compaction 可能消耗较多资源
- 建议在业务低峰期运行

---

## 4.4 理解 Segment 的作用

**核心概念：** Segment 是 Milvus 存储数据的基本单位，管理数据版本和生命周期

```python
from pymilvus import Collection, connections, utility

connections.connect("default", host="localhost", port="19530")
collection = Collection("my_collection")

# 查看 Collection 的 Segment 信息
segments = utility.get_query_segment_info("my_collection")
for segment in segments:
    print(f"Segment ID: {segment.segmentID}")
    print(f"  行数: {segment.num_rows}")
    print(f"  状态: {segment.state}")
    print(f"  索引名: {segment.index_name}")
    print()

# Segment 的类型：
# 1. Growing Segment：正在写入的 Segment（内存中）
# 2. Sealed Segment：已封闭的 Segment（不再写入）
# 3. Flushed Segment：已刷新到磁盘的 Segment
```

**Segment 的生命周期：**
```
插入数据
    ↓
Growing Segment（内存，可写）
    ↓
达到大小阈值或时间阈值
    ↓
Sealed Segment（内存，只读）
    ↓
刷新到磁盘
    ↓
Flushed Segment（磁盘，持久化）
    ↓
Compaction 合并
    ↓
优化后的 Segment
```

**在 RAG 中的价值：**
- **版本管理**：支持时间旅行查询（查询历史版本）
- **并发控制**：多个 Segment 可以并行查询
- **增量更新**：新数据写入新 Segment，不影响旧数据

**关键点：**
- Segment 大小通常为 512MB（可配置）
- 小 Segment 过多会影响查询性能
- Compaction 会合并小 Segment

---

## 4.5 实战：配置合适的一致性级别

**场景：** 根据不同的 RAG 应用场景选择合适的一致性级别

```python
from pymilvus import Collection, connections

connections.connect("default", host="localhost", port="19530")

# 场景1：实时客服系统（Strong 一致性）
def realtime_customer_service(query_embedding):
    collection = Collection("customer_service_kb")
    results = collection.search(
        data=[query_embedding],
        anns_field="vector",
        param={"metric_type": "L2", "params": {"nprobe": 10}},
        limit=5,
        consistency_level="Strong"  # 必须看到最新的知识库更新
    )
    return results

# 场景2：历史文档检索（Eventually 一致性）
def historical_document_search(query_embedding):
    collection = Collection("historical_docs")
    results = collection.search(
        data=[query_embedding],
        anns_field="vector",
        param={"metric_type": "L2", "params": {"nprobe": 10}},
        limit=10,
        consistency_level="Eventually"  # 性能优先，数据稍旧也可接受
    )
    return results

# 场景3：用户个人知识库（Session 一致性）
def personal_knowledge_base(query_embedding, user_id):
    collection = Collection(f"user_{user_id}_kb")
    results = collection.search(
        data=[query_embedding],
        anns_field="vector",
        param={"metric_type": "L2", "params": {"nprobe": 10}},
        limit=5,
        consistency_level="Session"  # 保证用户自己的操作一致
    )
    return results

# 场景4：通用知识库（Bounded 一致性，推荐）
def general_knowledge_base(query_embedding):
    collection = Collection("general_kb")
    results = collection.search(
        data=[query_embedding],
        anns_field="vector",
        param={"metric_type": "L2", "params": {"nprobe": 10}},
        limit=5,
        consistency_level="Bounded"  # 平衡性能和一致性
    )
    return results
```

---

## 这些知识足以：

- ✅ **选择合适的一致性级别**：根据业务需求权衡性能和实时性
- ✅ **理解 WAL 的作用**：知道数据如何持久化，不会丢失
- ✅ **理解 Compaction 的作用**：知道如何优化存储空间和查询性能
- ✅ **理解 Segment 的作用**：知道数据如何组织和管理
- ✅ **在 RAG 中应用**：根据不同场景配置合适的一致性级别

---

## 快速决策树

```
需要选择一致性级别？
    ↓
是否需要实时看到最新数据？
    ↓ 是
    Strong（牺牲性能）
    ↓ 否
是否可以接受稍旧的数据？
    ↓ 是
    Eventually（最高性能）
    ↓ 否
是否是单用户会话？
    ↓ 是
    Session（会话一致）
    ↓ 否
    Bounded（推荐，平衡性能和一致性）
```

---

## 常见问题

**Q1：一致性级别可以动态修改吗？**
A：可以！每次查询都可以指定不同的一致性级别。

**Q2：WAL 会占用多少磁盘空间？**
A：通常很小（几百 MB），Milvus 会定期清理已刷新的 WAL。

**Q3：Compaction 会影响查询吗？**
A：不会！Compaction 是后台运行的，不影响正常查询。

**Q4：如何查看 Segment 信息？**
A：使用 `utility.get_query_segment_info()` 查看。

**Q5：为什么我的查询性能下降了？**
A：可能是 Segment 过多或存储碎片化，运行 Compaction 可以优化。
