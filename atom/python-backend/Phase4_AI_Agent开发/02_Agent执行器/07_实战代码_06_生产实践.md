# Agent执行器 - 实战代码6：生产实践

> 生产环境的优化和最佳实践

---

## 学习目标

- Agent 状态持久化
- 执行日志记录
- 性能监控和优化
- 错误处理和降级

---

## 示例1：状态持久化

```python
"""
Agent 状态持久化
保存和恢复 Agent 的执行状态
"""

import json
from datetime import datetime

class AgentStateManager:
    """Agent 状态管理器"""

    def __init__(self, db_pool):
        self.db_pool = db_pool

    async def save_state(self, session_id: str, state: dict):
        """保存 Agent 状态"""
        async with self.db_pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO agent_states (session_id, state, created_at)
                VALUES ($1, $2, $3)
                ON CONFLICT (session_id)
                DO UPDATE SET state = $2, updated_at = $3
                """,
                session_id,
                json.dumps(state),
                datetime.now()
            )

    async def load_state(self, session_id: str) -> dict:
        """加载 Agent 状态"""
        async with self.db_pool.acquire() as conn:
            row = await conn.fetchrow(
                "SELECT state FROM agent_states WHERE session_id = $1",
                session_id
            )
            return json.loads(row['state']) if row else {}
```

---

## 示例2：执行日志

```python
"""
执行日志记录
记录 Agent 的完整执行过程
"""

import logging
import structlog

# 配置结构化日志
structlog.configure(
    processors=[
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)

logger = structlog.get_logger()

async def run_agent_with_logging(question: str):
    """运行 Agent，记录详细日志"""

    # 记录开始
    logger.info("agent_start", question=question)

    try:
        result = await executor.ainvoke({"input": question})

        # 记录成功
        logger.info(
            "agent_success",
            question=question,
            answer=result["output"],
            iterations=len(result.get('intermediate_steps', []))
        )

        return result["output"]

    except Exception as e:
        # 记录失败
        logger.error(
            "agent_failed",
            question=question,
            error=str(e)
        )
        raise
```

---

## 示例3：性能监控

```python
"""
性能监控
监控 Agent 的性能指标
"""

from prometheus_client import Counter, Histogram
import time

# 定义指标
agent_requests = Counter('agent_requests_total', 'Total agent requests')
agent_errors = Counter('agent_errors_total', 'Total agent errors')
agent_duration = Histogram('agent_duration_seconds', 'Agent execution duration')
agent_iterations = Histogram('agent_iterations', 'Agent iteration count')

async def run_agent_with_metrics(question: str):
    """运行 Agent，记录性能指标"""

    agent_requests.inc()
    start_time = time.time()

    try:
        result = await executor.ainvoke({"input": question})

        # 记录指标
        duration = time.time() - start_time
        iterations = len(result.get('intermediate_steps', []))

        agent_duration.observe(duration)
        agent_iterations.observe(iterations)

        return result["output"]

    except Exception as e:
        agent_errors.inc()
        raise
```

---

## 示例4：缓存优化

```python
"""
缓存优化
缓存常见问题的答案
"""

import redis
import hashlib
import json

redis_client = redis.Redis(host='localhost', port=6379, db=0)

async def run_agent_with_cache(question: str, ttl: int = 3600):
    """运行 Agent，使用缓存"""

    # 生成缓存键
    cache_key = f"agent:{hashlib.md5(question.encode()).hexdigest()}"

    # 检查缓存
    cached = redis_client.get(cache_key)
    if cached:
        logger.info("cache_hit", question=question)
        return json.loads(cached)

    # 执行 Agent
    result = await executor.ainvoke({"input": question})
    answer = result["output"]

    # 保存到缓存
    redis_client.setex(cache_key, ttl, json.dumps(answer))

    return answer
```

---

## 示例5：降级策略

```python
"""
降级策略
Agent 失败时的降级处理
"""

async def run_agent_with_fallback(question: str):
    """运行 Agent，失败时降级"""

    try:
        # 尝试运行 Agent
        result = await asyncio.wait_for(
            executor.ainvoke({"input": question}),
            timeout=30.0
        )
        return result["output"]

    except asyncio.TimeoutError:
        # 超时降级：使用简单的 LLM 调用
        logger.warning("agent_timeout_fallback", question=question)
        response = await llm.ainvoke(question)
        return response.content

    except Exception as e:
        # 错误降级：返回默认回复
        logger.error("agent_error_fallback", question=question, error=str(e))
        return "抱歉，我暂时无法回答这个问题，请稍后重试。"
```

---

## 完整生产实现

```python
"""
完整的生产级 Agent 实现
包含所有最佳实践
"""

from fastapi import FastAPI, HTTPException, BackgroundTasks
from pydantic import BaseModel
import asyncio
import logging
import time
from typing import Optional

app = FastAPI()
logger = logging.getLogger(__name__)

# 创建 Agent（全局变量）
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=10,
    early_stopping_method="generate",
    handle_parsing_errors=True,
    return_intermediate_steps=True,
    verbose=False,
)

class Question(BaseModel):
    question: str
    session_id: Optional[str] = None
    timeout: float = 30.0

class Answer(BaseModel):
    answer: str
    iterations: int
    duration: float
    cached: bool = False

@app.post("/agent", response_model=Answer)
async def run_agent(question: Question):
    """运行 Agent（生产级实现）"""

    start_time = time.time()

    try:
        # 1. 检查缓存
        cache_key = f"agent:{question.question}"
        cached = await redis_client.get(cache_key)
        if cached:
            logger.info("cache_hit", question=question.question)
            return Answer(
                answer=cached,
                iterations=0,
                duration=time.time() - start_time,
                cached=True
            )

        # 2. 运行 Agent（带超时）
        result = await asyncio.wait_for(
            executor.ainvoke({"input": question.question}),
            timeout=question.timeout
        )

        # 3. 记录指标
        duration = time.time() - start_time
        iterations = len(result.get('intermediate_steps', []))

        logger.info(
            "agent_success",
            question=question.question,
            iterations=iterations,
            duration=duration
        )

        # 4. 保存到缓存
        await redis_client.setex(cache_key, 3600, result["output"])

        # 5. 告警
        if iterations >= 10:
            logger.warning("max_iterations_reached", question=question.question)

        if duration > 10:
            logger.warning("slow_response", duration=duration)

        # 6. 返回结果
        return Answer(
            answer=result["output"],
            iterations=iterations,
            duration=duration
        )

    except asyncio.TimeoutError:
        # 超时降级
        logger.warning("agent_timeout", question=question.question)
        response = await llm.ainvoke(question.question)
        return Answer(
            answer=response.content,
            iterations=0,
            duration=time.time() - start_time
        )

    except Exception as e:
        # 错误处理
        logger.error("agent_error", question=question.question, error=str(e))
        raise HTTPException(status_code=500, detail="执行失败")

@app.get("/health")
async def health():
    """健康检查"""
    return {"status": "ok", "timestamp": time.time()}

@app.get("/metrics")
async def metrics():
    """性能指标"""
    return {
        "total_requests": agent_requests._value.get(),
        "total_errors": agent_errors._value.get(),
    }
```

---

## 最佳实践总结

### 1. 状态管理
- 持久化 Agent 状态
- 支持会话恢复

### 2. 日志记录
- 使用结构化日志
- 记录完整执行过程

### 3. 性能监控
- 监控关键指标
- 设置告警阈值

### 4. 缓存优化
- 缓存常见问题
- 设置合理的 TTL

### 5. 降级策略
- 超时降级
- 错误降级

### 6. 错误处理
- 完善的异常捕获
- 友好的错误提示

---

## 学习检查清单

- [ ] 实现状态持久化
- [ ] 配置结构化日志
- [ ] 添加性能监控
- [ ] 实现缓存机制
- [ ] 设计降级策略
- [ ] 完善错误处理

---

**版本：** v1.0
**最后更新：** 2026-02-12
