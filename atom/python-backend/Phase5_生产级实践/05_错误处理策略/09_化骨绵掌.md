# 错误处理策略 - 化骨绵掌

## 卡片1：错误处理的本质

**一句话：** 错误处理是预测、分类、响应和记录错误的系统化方法

**举例：**
```python
# 预测：知道哪里可能出错
try:
    response = await call_llm(prompt)  # LLM 可能超时
except Timeout:
    # 分类：临时性错误，可重试
    # 响应：重试 3 次
    # 记录：记录错误日志
    logger.error("llm_timeout")
```

**应用：** AI Agent API 中的 LLM 调用、数据库操作、向量检索都需要错误处理

---

## 卡片2：异常分层的价值

**一句话：** 不同类型的错误需要不同的处理方式

**举例：**
- 业务异常（422）：用户输入过长 → 返回错误，提示缩短
- 系统异常（500）：数据库连接失败 → 重试，记录日志
- 外部服务异常（503）：LLM 超时 → 重试，熔断，降级

**应用：** 通过异常分层，可以针对性地处理不同类型的错误

---

## 卡片3：重试机制的核心

**一句话：** 临时性错误应该自动重试，永久性错误不应该重试

**举例：**
```python
# 可重试：网络抖动、Rate Limit、服务过载
@retry(stop=stop_after_attempt(3))
async def call_llm(prompt):
    return await openai.chat.completions.create(...)

# 不可重试：参数错误、认证失败
if len(prompt) > 2000:
    raise ValidationError("文本过长")  # 不重试
```

**应用：** LLM 调用、数据库操作、向量检索的临时性错误

---

## 卡片4：指数退避算法

**一句话：** 每次重试的等待时间呈指数增长，给服务更多恢复时间

**举例：**
```python
delay = initial_delay * (2 ** attempt)
# 第1次：1s
# 第2次：2s
# 第3次：4s
# 总等待：7s
```

**应用：** 防止重试过快加剧服务负载，提高恢复成功率

---

## 卡片5：熔断器的三状态

**一句话：** Closed（正常）→ Open（熔断）→ Half-Open（测试）→ Closed（恢复）

**举例：**
```
失败率 > 50% → 打开熔断器
等待 30 秒 → 进入半开状态
测试请求成功 → 关闭熔断器
```

**应用：** 防止对故障服务的持续调用，保护系统稳定性

---

## 卡片6：服务降级策略

**一句话：** 当依赖服务不可用时，返回降级响应（缓存、默认值、简化版本）

**举例：**
```python
async def fallback_response(prompt):
    # 1. 尝试返回缓存
    cached = redis.get(f"llm:{prompt}")
    if cached:
        return cached

    # 2. 返回默认响应
    return "抱歉，AI 服务暂时不可用"
```

**应用：** LLM 服务熔断时，返回缓存或默认响应，保障用户体验

---

## 卡片7：超时控制的必要性

**一句话：** 所有外部调用都应该设置超时，防止请求无限等待

**举例：**
```python
async with asyncio.timeout(30):  # 30秒超时
    response = await call_llm(prompt)
```

**应用：** LLM 调用（30s）、数据库查询（5s）、向量检索（10s）

---

## 卡片8：级联超时原则

**一句话：** 上游超时应该比下游超时更长，留出处理时间

**举例：**
```
API 端点（35s）
  ↓
LLM 调用（30s）
  ↓
OpenAI API（25s）
```

**应用：** 多层服务调用时，确保每层都有足够的处理时间

---

## 卡片9：结构化日志的价值

**一句话：** JSON 格式日志易于解析和查询，方便问题定位

**举例：**
```python
logger.error("llm_timeout",
    request_id="abc-123",
    user_id="user_456",
    timeout=30
)
# 输出：{"event": "llm_timeout", "request_id": "abc-123", ...}
```

**应用：** 生产环境错误追踪、性能分析、用户行为分析

---

## 卡片10：Request ID 追踪

**一句话：** 唯一标识一个请求，关联同一请求的所有日志

**举例：**
```python
request_id = str(uuid.uuid4())
logger.info("request_start", request_id=request_id)
logger.info("llm_call", request_id=request_id)
logger.info("request_end", request_id=request_id)
```

**应用：** 分布式系统中追踪请求完整生命周期，快速定位问题
