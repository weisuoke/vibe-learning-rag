# 实战代码：响应模型实战

> 完整可运行的响应模型示例，从数据过滤到复杂响应

---

## 场景1：数据过滤和安全

**目标：** 使用 response_model 自动过滤敏感信息

```python
"""
数据过滤和安全示例
演示：使用 response_model 自动过滤敏感字段
"""

from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime

app = FastAPI()

# ===== 数据库模型（包含所有字段）=====

class UserInDB(BaseModel):
    id: int
    username: str
    email: EmailStr
    full_name: str
    hashed_password: str  # 敏感信息
    is_active: bool
    is_admin: bool
    created_at: datetime
    last_login: Optional[datetime] = None
    api_key: str  # 敏感信息

# ===== 响应模型（只包含安全字段）=====

class UserPublicResponse(BaseModel):
    """公开的用户信息（最少字段）"""
    id: int
    username: str

class UserResponse(BaseModel):
    """标准用户信息（不包含敏感字段）"""
    id: int
    username: str
    email: EmailStr
    full_name: str
    is_active: bool
    created_at: datetime

class UserDetailResponse(BaseModel):
    """详细用户信息（包含更多字段，但仍不包含敏感信息）"""
    id: int
    username: str
    email: EmailStr
    full_name: str
    is_active: bool
    is_admin: bool
    created_at: datetime
    last_login: Optional[datetime]

# ===== 模拟数据库 =====

fake_users_db = {
    1: UserInDB(
        id=1,
        username="alice",
        email="alice@example.com",
        full_name="Alice Smith",
        hashed_password="$2b$12$hashed_password_here",
        is_active=True,
        is_admin=False,
        created_at=datetime(2026, 1, 1),
        last_login=datetime(2026, 2, 10),
        api_key="sk-1234567890abcdef"
    ),
    2: UserInDB(
        id=2,
        username="bob",
        email="bob@example.com",
        full_name="Bob Johnson",
        hashed_password="$2b$12$another_hashed_password",
        is_active=True,
        is_admin=True,
        created_at=datetime(2026, 1, 15),
        last_login=None,
        api_key="sk-abcdef1234567890"
    )
}

# ===== 路由 =====

@app.get("/users/{user_id}/public", response_model=UserPublicResponse)
async def get_user_public(user_id: int):
    """
    获取用户公开信息（最少字段）
    - 只返回 id 和 username
    - 适用于公开展示
    """
    if user_id not in fake_users_db:
        raise HTTPException(status_code=404, detail="用户不存在")

    user = fake_users_db[user_id]
    # 返回完整的 UserInDB 对象
    # FastAPI 自动过滤，只返回 UserPublicResponse 定义的字段
    return user

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    """
    获取用户标准信息
    - 不包含敏感字段（password, api_key）
    - 适用于用户列表展示
    """
    if user_id not in fake_users_db:
        raise HTTPException(status_code=404, detail="用户不存在")

    user = fake_users_db[user_id]
    return user

@app.get("/users/{user_id}/detail", response_model=UserDetailResponse)
async def get_user_detail(user_id: int):
    """
    获取用户详细信息
    - 包含更多字段，但仍不包含敏感信息
    - 适用于用户详情页
    """
    if user_id not in fake_users_db:
        raise HTTPException(status_code=404, detail="用户不存在")

    user = fake_users_db[user_id]
    return user

@app.get("/users/{user_id}/unsafe")
async def get_user_unsafe(user_id: int):
    """
    ❌ 不安全的接口（没有使用 response_model）
    - 会泄露所有字段，包括敏感信息
    - 仅用于演示，生产环境禁止使用
    """
    if user_id not in fake_users_db:
        raise HTTPException(status_code=404, detail="用户不存在")

    user = fake_users_db[user_id]
    return user.model_dump()  # 返回所有字段，包括 password 和 api_key

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 公开信息（只有 id 和 username）
curl http://localhost:8000/users/1/public

# 标准信息（不包含敏感字段）
curl http://localhost:8000/users/1

# 详细信息（更多字段，但仍安全）
curl http://localhost:8000/users/1/detail

# ❌ 不安全的接口（会泄露敏感信息）
curl http://localhost:8000/users/1/unsafe
```

---

## 场景2：动态响应模型

**目标：** 根据不同条件返回不同的响应模型

```python
"""
动态响应模型示例
演示：根据用户权限返回不同的响应
"""

from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel
from typing import Union
from enum import Enum

app = FastAPI()

# ===== 数据模型 =====

class UserRole(str, Enum):
    guest = "guest"
    user = "user"
    admin = "admin"

class ItemBase(BaseModel):
    id: int
    name: str
    price: float

class ItemPublic(ItemBase):
    """公开信息"""
    pass

class ItemUser(ItemBase):
    """用户可见信息"""
    description: str
    in_stock: bool

class ItemAdmin(ItemBase):
    """管理员可见信息"""
    description: str
    in_stock: bool
    cost: float  # 成本价（只有管理员可见）
    supplier: str  # 供应商（只有管理员可见）

# ===== 模拟数据 =====

fake_item = {
    "id": 1,
    "name": "Laptop",
    "price": 999.99,
    "description": "High-end laptop",
    "in_stock": True,
    "cost": 700.00,
    "supplier": "TechCorp"
}

# ===== 依赖：获取当前用户角色 =====

def get_current_user_role(role: str = "guest") -> UserRole:
    """模拟获取当前用户角色"""
    return UserRole(role)

# ===== 路由 =====

@app.get("/items/{item_id}", response_model=Union[ItemPublic, ItemUser, ItemAdmin])
async def get_item(
    item_id: int,
    role: UserRole = Depends(get_current_user_role)
):
    """
    根据用户角色返回不同的商品信息
    - guest: 只返回基本信息
    - user: 返回详细信息
    - admin: 返回所有信息（包括成本和供应商）
    """
    if role == UserRole.guest:
        return ItemPublic(**fake_item)
    elif role == UserRole.user:
        return ItemUser(**fake_item)
    elif role == UserRole.admin:
        return ItemAdmin(**fake_item)

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 游客（只有基本信息）
curl "http://localhost:8000/items/1?role=guest"

# 用户（详细信息）
curl "http://localhost:8000/items/1?role=user"

# 管理员（所有信息）
curl "http://localhost:8000/items/1?role=admin"
```

---

## 场景3：嵌套响应模型

**目标：** 处理复杂的嵌套数据结构

```python
"""
嵌套响应模型示例
演示：处理复杂的嵌套数据结构
"""

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl
from typing import List, Optional
from datetime import datetime

app = FastAPI()

# ===== 嵌套数据模型 =====

class Author(BaseModel):
    id: int
    username: str
    avatar_url: Optional[HttpUrl] = None

class Tag(BaseModel):
    id: int
    name: str
    color: str

class Comment(BaseModel):
    id: int
    content: str
    author: Author
    created_at: datetime

class Post(BaseModel):
    id: int
    title: str
    content: str
    author: Author
    tags: List[Tag]
    comments: List[Comment]
    created_at: datetime
    updated_at: datetime
    views: int
    likes: int

# ===== 模拟数据 =====

fake_post = {
    "id": 1,
    "title": "FastAPI 入门教程",
    "content": "这是一篇关于 FastAPI 的教程...",
    "author": {
        "id": 1,
        "username": "alice",
        "avatar_url": "https://example.com/avatar.jpg"
    },
    "tags": [
        {"id": 1, "name": "Python", "color": "blue"},
        {"id": 2, "name": "FastAPI", "color": "green"},
        {"id": 3, "name": "Web开发", "color": "orange"}
    ],
    "comments": [
        {
            "id": 1,
            "content": "很好的教程！",
            "author": {
                "id": 2,
                "username": "bob",
                "avatar_url": None
            },
            "created_at": datetime(2026, 2, 10, 10, 0, 0)
        },
        {
            "id": 2,
            "content": "学到了很多",
            "author": {
                "id": 3,
                "username": "charlie",
                "avatar_url": "https://example.com/charlie.jpg"
            },
            "created_at": datetime(2026, 2, 10, 11, 0, 0)
        }
    ],
    "created_at": datetime(2026, 2, 1, 9, 0, 0),
    "updated_at": datetime(2026, 2, 10, 12, 0, 0),
    "views": 1234,
    "likes": 56
}

# ===== 路由 =====

@app.get("/posts/{post_id}", response_model=Post)
async def get_post(post_id: int):
    """获取文章详情（包含嵌套的作者、标签、评论）"""
    return fake_post

# ===== 简化响应模型 =====

class PostSummary(BaseModel):
    """文章摘要（用于列表展示）"""
    id: int
    title: str
    author: Author
    tags: List[Tag]
    created_at: datetime
    views: int
    likes: int

@app.get("/posts", response_model=List[PostSummary])
async def list_posts():
    """获取文章列表（简化版，不包含内容和评论）"""
    return [fake_post]

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 获取文章详情（完整嵌套结构）
curl http://localhost:8000/posts/1

# 获取文章列表（简化版）
curl http://localhost:8000/posts
```

---

## 场景4：分页响应

**目标：** 实现通用的分页响应模型

```python
"""
分页响应示例
演示：实现通用的分页响应模型
"""

from fastapi import FastAPI, Query
from pydantic import BaseModel
from typing import List, Generic, TypeVar
from datetime import datetime

app = FastAPI()

# ===== 通用分页响应模型 =====

T = TypeVar('T')

class PaginationMeta(BaseModel):
    """分页元数据"""
    page: int
    page_size: int
    total: int
    total_pages: int
    has_next: bool
    has_prev: bool

class PaginatedResponse(BaseModel, Generic[T]):
    """通用分页响应"""
    items: List[T]
    meta: PaginationMeta

# ===== 数据模型 =====

class User(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime

class Post(BaseModel):
    id: int
    title: str
    author_id: int
    created_at: datetime

# ===== 模拟数据 =====

fake_users = [
    User(id=i, username=f"user{i}", email=f"user{i}@example.com", created_at=datetime(2026, 1, i))
    for i in range(1, 51)  # 50 个用户
]

fake_posts = [
    Post(id=i, title=f"Post {i}", author_id=(i % 10) + 1, created_at=datetime(2026, 1, i))
    for i in range(1, 101)  # 100 篇文章
]

# ===== 辅助函数 =====

def paginate(items: List[T], page: int, page_size: int) -> PaginatedResponse[T]:
    """通用分页函数"""
    total = len(items)
    total_pages = (total + page_size - 1) // page_size

    start = (page - 1) * page_size
    end = start + page_size
    paginated_items = items[start:end]

    meta = PaginationMeta(
        page=page,
        page_size=page_size,
        total=total,
        total_pages=total_pages,
        has_next=page < total_pages,
        has_prev=page > 1
    )

    return PaginatedResponse(items=paginated_items, meta=meta)

# ===== 路由 =====

@app.get("/users", response_model=PaginatedResponse[User])
async def list_users(
    page: int = Query(1, ge=1),
    page_size: int = Query(10, ge=1, le=100)
):
    """获取用户列表（分页）"""
    return paginate(fake_users, page, page_size)

@app.get("/posts", response_model=PaginatedResponse[Post])
async def list_posts(
    page: int = Query(1, ge=1),
    page_size: int = Query(10, ge=1, le=100)
):
    """获取文章列表（分页）"""
    return paginate(fake_posts, page, page_size)

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 第1页，每页10条
curl "http://localhost:8000/users?page=1&page_size=10"

# 第2页，每页20条
curl "http://localhost:8000/users?page=2&page_size=20"

# 文章列表
curl "http://localhost:8000/posts?page=1&page_size=5"
```

---

## 场景5：错误响应模型

**目标：** 统一的错误响应格式

```python
"""
错误响应模型示例
演示：统一的错误响应格式
"""

from fastapi import FastAPI, HTTPException, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel, Field
from typing import Optional, List, Any
from datetime import datetime

app = FastAPI()

# ===== 错误响应模型 =====

class ErrorDetail(BaseModel):
    """错误详情"""
    field: Optional[str] = None
    message: str
    type: str

class ErrorResponse(BaseModel):
    """统一错误响应"""
    error: str = Field(..., description="错误类型")
    message: str = Field(..., description="错误消息")
    details: Optional[List[ErrorDetail]] = Field(None, description="详细错误信息")
    timestamp: datetime = Field(default_factory=datetime.now)
    path: str = Field(..., description="请求路径")

# ===== 自定义异常处理器 =====

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """处理 HTTPException"""
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            error=f"HTTP_{exc.status_code}",
            message=exc.detail,
            path=request.url.path
        ).model_dump()
    )

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """处理验证错误"""
    details = [
        ErrorDetail(
            field=".".join(str(loc) for loc in error["loc"]),
            message=error["msg"],
            type=error["type"]
        )
        for error in exc.errors()
    ]

    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content=ErrorResponse(
            error="VALIDATION_ERROR",
            message="请求数据验证失败",
            details=details,
            path=request.url.path
        ).model_dump()
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """处理未捕获的异常"""
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content=ErrorResponse(
            error="INTERNAL_SERVER_ERROR",
            message="服务器内部错误",
            path=request.url.path
        ).model_dump()
    )

# ===== 数据模型 =====

class CreateUserRequest(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: str = Field(..., regex=r"^[\w\.-]+@[\w\.-]+\.\w+$")
    age: int = Field(..., ge=0, le=150)

# ===== 路由 =====

@app.post("/users")
async def create_user(user: CreateUserRequest):
    """创建用户"""
    # 模拟业务逻辑错误
    if user.username == "admin":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="用户名 'admin' 已被保留"
        )

    return {"message": "用户创建成功", "user": user}

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    """获取用户"""
    if user_id < 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="无效的用户ID"
        )

    if user_id > 100:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"用户 {user_id} 不存在"
        )

    return {"id": user_id, "username": f"user{user_id}"}

@app.get("/error")
async def trigger_error():
    """触发未捕获的异常"""
    raise ValueError("这是一个未捕获的异常")

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 验证错误（422）
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{"username": "ab", "email": "invalid", "age": 200}'

# 业务逻辑错误（400）
curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "email": "admin@example.com", "age": 25}'

# 资源不存在（404）
curl http://localhost:8000/users/999

# 服务器错误（500）
curl http://localhost:8000/error
```

---

## 场景6：AI Agent 响应模型

**目标：** AI Agent 后端的实际响应模型

```python
"""
AI Agent 响应模型示例
演示：AI Agent 后端的实际应用
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional, Literal
from datetime import datetime
from enum import Enum

app = FastAPI()

# ===== 数据模型 =====

class MessageRole(str, Enum):
    user = "user"
    assistant = "assistant"
    system = "system"

class Message(BaseModel):
    role: MessageRole
    content: str
    timestamp: datetime = Field(default_factory=datetime.now)

class ChatRequest(BaseModel):
    message: str = Field(..., min_length=1, max_length=2000)
    conversation_id: Optional[str] = None
    stream: bool = False

class ChatResponse(BaseModel):
    reply: str
    conversation_id: str
    message_id: str
    model: str
    tokens_used: int
    created_at: datetime = Field(default_factory=datetime.now)

class ConversationSummary(BaseModel):
    id: str
    title: str
    message_count: int
    created_at: datetime
    updated_at: datetime

class ConversationDetail(BaseModel):
    id: str
    title: str
    messages: List[Message]
    created_at: datetime
    updated_at: datetime

class SearchResult(BaseModel):
    id: int
    title: str
    content: str
    score: float
    source: str

class SearchResponse(BaseModel):
    query: str
    results: List[SearchResult]
    total: int
    took_ms: int

# ===== 模拟数据 =====

fake_conversations = {
    "conv-1": {
        "id": "conv-1",
        "title": "FastAPI 学习",
        "messages": [
            Message(role=MessageRole.user, content="什么是 FastAPI？"),
            Message(role=MessageRole.assistant, content="FastAPI 是一个现代、快速的 Web 框架...")
        ],
        "created_at": datetime(2026, 2, 1),
        "updated_at": datetime(2026, 2, 10)
    }
}

# ===== 路由 =====

@app.post("/chat", response_model=ChatResponse)
async def chat(request: ChatRequest):
    """对话接口"""
    # 模拟 LLM 调用
    reply = f"这是对 '{request.message}' 的回复"

    return ChatResponse(
        reply=reply,
        conversation_id=request.conversation_id or "conv-new",
        message_id="msg-123",
        model="gpt-4",
        tokens_used=150
    )

@app.get("/conversations", response_model=List[ConversationSummary])
async def list_conversations():
    """获取对话列表"""
    return [
        ConversationSummary(
            id=conv["id"],
            title=conv["title"],
            message_count=len(conv["messages"]),
            created_at=conv["created_at"],
            updated_at=conv["updated_at"]
        )
        for conv in fake_conversations.values()
    ]

@app.get("/conversations/{conversation_id}", response_model=ConversationDetail)
async def get_conversation(conversation_id: str):
    """获取对话详情"""
    if conversation_id not in fake_conversations:
        raise HTTPException(status_code=404, detail="对话不存在")

    conv = fake_conversations[conversation_id]
    return ConversationDetail(**conv)

@app.get("/search", response_model=SearchResponse)
async def search(q: str, limit: int = 10):
    """搜索文档"""
    import time
    start_time = time.time()

    # 模拟向量搜索
    results = [
        SearchResult(
            id=1,
            title="FastAPI 入门",
            content="FastAPI 是一个现代、快速的 Web 框架...",
            score=0.95,
            source="docs/fastapi-intro.md"
        )
    ]

    took_ms = int((time.time() - start_time) * 1000)

    return SearchResponse(
        query=q,
        results=results,
        total=len(results),
        took_ms=took_ms
    )

# ===== 运行服务器 =====

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试：**

```bash
# 对话
curl -X POST http://localhost:8000/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "什么是依赖注入？", "conversation_id": "conv-1"}'

# 对话列表
curl http://localhost:8000/conversations

# 对话详情
curl http://localhost:8000/conversations/conv-1

# 搜索
curl "http://localhost:8000/search?q=FastAPI&limit=5"
```

---

## 总结

### 学到的技能

1. **数据过滤** - 使用 response_model 自动过滤敏感字段
2. **动态响应** - 根据条件返回不同的响应模型
3. **嵌套模型** - 处理复杂的嵌套数据结构
4. **分页响应** - 实现通用的分页响应模型
5. **错误响应** - 统一的错误响应格式
6. **AI Agent** - 实际应用中的响应模型设计

### 关键要点

- response_model 是安全的第一道防线
- 不同场景使用不同的响应模型
- 嵌套模型让数据结构更清晰
- 分页响应使用泛型提高复用性
- 统一错误格式提升用户体验

---

**记住：** 响应模型不仅是数据格式定义，更是安全和用户体验的保障！
