# 化骨绵掌

10个知识卡片，每个2分钟，覆盖检索器设计的所有核心概念。

---

## 卡片1：检索器是什么？

**一句话：** 检索器是 RAG 系统的"搜索引擎"，负责从知识库中找到与用户问题最相关的内容。

**类比：**
```
用户问题 → 检索器 → 相关文档
    ↓         ↓         ↓
搜索关键词 → 搜索引擎 → 搜索结果
```

**应用：** 没有检索器，RAG 就无法工作。检索质量直接决定最终答案质量。

---

## 卡片2：向量检索器

**一句话：** 向量检索器通过计算语义相似度，找到"意思相近"的文档，即使用词不同也能匹配。

**举例：**
```
查询："如何请假"
匹配："年假申请流程"（语义相近，虽然词不同）
```

**代码：**
```python
retriever = vectorstore.as_retriever(search_kwargs={"k": 5})
results = retriever.invoke("如何请假")
```

**应用：** 适合自然语言问答、语义搜索、跨语言检索。

---

## 卡片3：关键词检索器（BM25）

**一句话：** BM25 检索器通过词频统计，找到包含相同关键词的文档，精确匹配优先。

**举例：**
```
查询："ERR_CONNECTION_REFUSED"
匹配：必须包含 "ERR_CONNECTION_REFUSED" 这个词
```

**代码：**
```python
from langchain_community.retrievers import BM25Retriever
bm25 = BM25Retriever.from_documents(documents, k=5)
results = bm25.invoke("ERR_CONNECTION_REFUSED")
```

**应用：** 适合代码搜索、错误码查询、专有名词检索。

---

## 卡片4：混合检索器

**一句话：** 混合检索器结合向量检索和关键词检索，兼顾语义理解和精确匹配。

**原理：**
```
查询 → 向量检索（Top-10）→ ┐
                          ├→ 分数融合 → Top-K 结果
查询 → BM25检索（Top-10）→ ┘
```

**代码：**
```python
from langchain.retrievers import EnsembleRetriever
hybrid = EnsembleRetriever(
    retrievers=[vector_retriever, bm25_retriever],
    weights=[0.5, 0.5]
)
```

**应用：** 生产环境首选，覆盖各种查询类型。

---

## 卡片5：Top-K 参数

**一句话：** Top-K 决定返回多少个结果，太少可能漏掉答案，太多会引入噪声和增加成本。

**选择指南：**
```
简单问答 → K = 3-5
复杂问答 → K = 5-10
总结报告 → K = 10-15
```

**代码：**
```python
retriever = vectorstore.as_retriever(search_kwargs={"k": 5})
```

**应用：** 从 K=5 开始，根据效果调整。

---

## 卡片6：相似度阈值

**一句话：** 相似度阈值过滤掉相关性不够的结果，避免返回"勉强相关"的内容。

**举例：**
```
阈值 = 0.7
结果A（相似度 0.85）→ ✅ 返回
结果B（相似度 0.65）→ ❌ 过滤掉
```

**代码：**
```python
retriever = vectorstore.as_retriever(
    search_type="similarity_score_threshold",
    search_kwargs={"score_threshold": 0.7}
)
```

**应用：** 当知识库可能没有相关内容时，设置阈值避免返回无关结果。

---

## 卡片7：MMR 多样性

**一句话：** MMR（最大边际相关性）在保证相关性的同时，增加结果多样性，避免返回重复内容。

**对比：**
```
普通检索：返回5篇"Python asyncio 教程"（内容重复）
MMR检索：返回 asyncio教程 + 多线程 + 协程原理 + 对比分析（多样化）
```

**代码：**
```python
retriever = vectorstore.as_retriever(
    search_type="mmr",
    search_kwargs={"k": 5, "lambda_mult": 0.5}
)
```

**应用：** 当检索结果重复度高时使用。

---

## 卡片8：元数据过滤

**一句话：** 元数据过滤允许在检索时按条件筛选，如只搜索特定时间、来源或类型的文档。

**举例：**
```
只搜索 2024 年的 HR 文档：
filter = {"year": 2024, "department": "HR"}
```

**代码：**
```python
results = vectorstore.similarity_search(
    query,
    k=5,
    filter={"type": "policy", "year": 2024}
)
```

**应用：** 多租户系统、权限控制、时效性过滤。

---

## 卡片9：检索器 vs 向量存储

**一句话：** 向量存储是"仓库"（存数据），检索器是"搜索员"（查数据），两者配合工作。

**对比：**
```
向量存储                    检索器
─────────────────────────────────────
存储向量                    查询向量
建立索引                    执行搜索
持久化数据                  返回结果
关注存储效率                关注检索质量
```

**关系：**
```python
# 向量存储
vectorstore = Chroma.from_documents(documents, embeddings)

# 从向量存储创建检索器
retriever = vectorstore.as_retriever()
```

**应用：** 理解两者区别，才能正确设计 RAG 系统。

---

## 卡片10：检索器选型决策树

**一句话：** 根据场景选择合适的检索器，没有"最好"的检索器，只有"最合适"的。

**决策树：**
```
开始
  │
  ├─ 需要精确匹配关键词？
  │    ├─ 是 → BM25 检索器
  │    └─ 否 ↓
  │
  ├─ 需要语义理解？
  │    ├─ 是 → 向量检索器
  │    └─ 否 ↓
  │
  ├─ 两者都需要？
  │    └─ 是 → 混合检索器（推荐）
  │
  ├─ 结果重复度高？
  │    └─ 是 → 加上 MMR
  │
  └─ 需要质量保证？
       └─ 是 → 加上相似度阈值
```

**应用：** 生产环境从混合检索开始，根据评估结果优化。

---

## 知识卡片总览

| 卡片 | 核心概念 | 一句话总结 |
|------|----------|------------|
| 1 | 检索器定义 | RAG 的搜索引擎 |
| 2 | 向量检索 | 语义相似匹配 |
| 3 | BM25 检索 | 关键词精确匹配 |
| 4 | 混合检索 | 两者优势结合 |
| 5 | Top-K | 返回数量控制 |
| 6 | 相似度阈值 | 质量过滤 |
| 7 | MMR | 多样性控制 |
| 8 | 元数据过滤 | 条件筛选 |
| 9 | 检索器 vs 存储 | 查询 vs 存储 |
| 10 | 选型决策 | 场景匹配 |

---

## 学习检查清单

- [ ] 能解释向量检索和关键词检索的区别
- [ ] 能说出混合检索的优势
- [ ] 能根据场景选择合适的 Top-K 值
- [ ] 理解相似度阈值的作用
- [ ] 知道什么时候使用 MMR
- [ ] 能区分检索器和向量存储的职责

---

**下一步：** [10_一句话总结](./10_一句话总结.md) - 检索器设计的完整定义
