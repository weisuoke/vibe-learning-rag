# 实战代码7：生产级健康检查系统

> 完整的健康检查框架设计和实现

---

## 概述

本文提供一个生产级的健康检查系统，包括：
- 完整的健康检查框架
- 多层次健康检查（浅层/深层）
- 异步健康检查实现
- 健康状态缓存与更新
- 依赖服务注册与管理
- 健康检查中间件
- 指标暴露（Prometheus）
- 完整的 AI Agent API 健康检查系统

---

## 完整代码

```python
"""
生产级健康检查系统
演示：完整的健康检查框架设计和实现
"""

from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import Dict, Optional, Callable, Any, List
from enum import Enum
from datetime import datetime, timedelta
import asyncio
import time
import structlog

# ===== 1. 健康状态枚举 =====

class HealthStatus(str, Enum):
    """健康状态"""
    HEALTHY = "healthy"      # 所有依赖正常
    DEGRADED = "degraded"    # 部分依赖失败，但核心功能可用
    UNHEALTHY = "unhealthy"  # 核心依赖失败，不可用

class DependencyType(str, Enum):
    """依赖类型"""
    CRITICAL = "critical"    # 核心依赖，失败导致服务不可用
    OPTIONAL = "optional"    # 可选依赖，失败导致服务降级

# ===== 2. 响应模型 =====

class DependencyHealth(BaseModel):
    """依赖健康状态"""
    healthy: bool
    duration_ms: int
    last_check: str
    error: Optional[str] = None
    metadata: Optional[Dict] = None

class HealthCheckResponse(BaseModel):
    """健康检查响应"""
    status: HealthStatus
    timestamp: str
    version: str
    uptime_seconds: float
    dependencies: Dict[str, DependencyHealth]
    message: Optional[str] = None

# ===== 3. 依赖检查器基类 =====

class DependencyChecker:
    """依赖检查器基类"""

    def __init__(
        self,
        name: str,
        dependency_type: DependencyType,
        cache_ttl: int = 30
    ):
        self.name = name
        self.dependency_type = dependency_type
        self.cache_ttl = cache_ttl
        self.cache = {
            "last_check": datetime.min,
            "result": None
        }

    async def check(self) -> DependencyHealth:
        """
        执行健康检查

        Returns:
            DependencyHealth: 健康检查结果
        """
        raise NotImplementedError

    async def check_with_cache(self) -> DependencyHealth:
        """
        执行健康检查（带缓存）

        Returns:
            DependencyHealth: 健康检查结果
        """
        now = datetime.now()

        # 检查缓存
        if self.cache["result"] and (now - self.cache["last_check"]).total_seconds() < self.cache_ttl:
            return self.cache["result"]

        # 执行检查
        result = await self.check()

        # 更新缓存
        self.cache = {
            "last_check": now,
            "result": result
        }

        return result

# ===== 4. 具体的依赖检查器 =====

class DatabaseChecker(DependencyChecker):
    """数据库检查器"""

    def __init__(self, db_engine):
        super().__init__("database", DependencyType.CRITICAL, cache_ttl=30)
        self.db = db_engine

    async def check(self) -> DependencyHealth:
        """检查数据库连接"""
        start_time = time.time()

        try:
            from sqlalchemy import text
            from sqlalchemy.ext.asyncio import AsyncSession

            async with AsyncSession(self.db) as session:
                await asyncio.wait_for(
                    session.execute(text("SELECT 1")),
                    timeout=3.0
                )

            duration_ms = int((time.time() - start_time) * 1000)

            # 获取连接池状态
            pool = self.db.pool
            metadata = {
                "pool_size": pool.size(),
                "checked_out": pool.checkedout(),
                "checked_in": pool.checkedin()
            }

            return DependencyHealth(
                healthy=True,
                duration_ms=duration_ms,
                last_check=datetime.now().isoformat(),
                metadata=metadata
            )

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            return DependencyHealth(
                healthy=False,
                duration_ms=duration_ms,
                last_check=datetime.now().isoformat(),
                error=str(e)
            )

class RedisChecker(DependencyChecker):
    """Redis 检查器"""

    def __init__(self, redis_client):
        super().__init__("redis", DependencyType.OPTIONAL, cache_ttl=60)
        self.redis = redis_client

    async def check(self) -> DependencyHealth:
        """检查 Redis 连接"""
        start_time = time.time()

        try:
            await asyncio.wait_for(
                self.redis.ping(),
                timeout=3.0
            )

            duration_ms = int((time.time() - start_time) * 1000)

            # 获取 Redis 信息
            info = await self.redis.info()
            metadata = {
                "connected_clients": info.get("connected_clients", 0),
                "used_memory_human": info.get("used_memory_human", "unknown")
            }

            return DependencyHealth(
                healthy=True,
                duration_ms=duration_ms,
                last_check=datetime.now().isoformat(),
                metadata=metadata
            )

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            return DependencyHealth(
                healthy=False,
                duration_ms=duration_ms,
                last_check=datetime.now().isoformat(),
                error=str(e)
            )

class LLMAPIChecker(DependencyChecker):
    """LLM API 检查器"""

    def __init__(self, llm_client):
        super().__init__("llm_api", DependencyType.OPTIONAL, cache_ttl=300)
        self.llm = llm_client

    async def check(self) -> DependencyHealth:
        """检查 LLM API 可用性"""
        start_time = time.time()

        try:
            # 发送最小请求
            response = await asyncio.wait_for(
                self.llm.chat.completions.create(
                    model="gpt-3.5-turbo",
                    messages=[{"role": "user", "content": "hi"}],
                    max_tokens=1
                ),
                timeout=10.0
            )

            duration_ms = int((time.time() - start_time) * 1000)

            metadata = {
                "model": response.model
            }

            return DependencyHealth(
                healthy=True,
                duration_ms=duration_ms,
                last_check=datetime.now().isoformat(),
                metadata=metadata
            )

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            return DependencyHealth(
                healthy=False,
                duration_ms=duration_ms,
                last_check=datetime.now().isoformat(),
                error=str(e)
            )

# ===== 5. 健康检查管理器 =====

class HealthCheckManager:
    """健康检查管理器"""

    def __init__(self, app_version: str):
        self.app_version = app_version
        self.start_time = time.time()
        self.checkers: Dict[str, DependencyChecker] = {}
        self.logger = structlog.get_logger()

    def register(self, checker: DependencyChecker):
        """
        注册依赖检查器

        Args:
            checker: 依赖检查器实例
        """
        self.checkers[checker.name] = checker
        self.logger.info(
            "Dependency checker registered",
            name=checker.name,
            type=checker.dependency_type.value,
            cache_ttl=checker.cache_ttl
        )

    async def check_all(self) -> HealthCheckResponse:
        """
        检查所有依赖

        Returns:
            HealthCheckResponse: 健康检查响应
        """
        # 并发检查所有依赖
        tasks = {
            name: checker.check_with_cache()
            for name, checker in self.checkers.items()
        }

        results = await asyncio.gather(
            *tasks.values(),
            return_exceptions=True
        )

        # 解析结果
        dependencies = {}
        critical_failed = False
        optional_failed = []

        for name, result in zip(tasks.keys(), results):
            if isinstance(result, Exception):
                # 检查失败
                dependencies[name] = DependencyHealth(
                    healthy=False,
                    duration_ms=0,
                    last_check=datetime.now().isoformat(),
                    error=str(result)
                )

                if self.checkers[name].dependency_type == DependencyType.CRITICAL:
                    critical_failed = True
            else:
                dependencies[name] = result

                if not result.healthy:
                    if self.checkers[name].dependency_type == DependencyType.CRITICAL:
                        critical_failed = True
                    else:
                        optional_failed.append(name)

        # 判断整体状态
        if critical_failed:
            status = HealthStatus.UNHEALTHY
            message = "Critical dependencies are unhealthy"
        elif optional_failed:
            status = HealthStatus.DEGRADED
            message = f"Running in degraded mode: {', '.join(optional_failed)} unavailable"
        else:
            status = HealthStatus.HEALTHY
            message = "All dependencies are healthy"

        # 计算运行时间
        uptime = time.time() - self.start_time

        return HealthCheckResponse(
            status=status,
            timestamp=datetime.now().isoformat(),
            version=self.app_version,
            uptime_seconds=uptime,
            dependencies=dependencies,
            message=message
        )

    async def check_liveness(self) -> Dict:
        """
        Liveness 检查（简单快速）

        Returns:
            Dict: 健康状态
        """
        return {
            "status": "healthy",
            "timestamp": datetime.now().isoformat()
        }

    async def check_readiness(self) -> HealthCheckResponse:
        """
        Readiness 检查（检查依赖）

        Returns:
            HealthCheckResponse: 健康检查响应
        """
        return await self.check_all()

# ===== 6. 健康检查中间件 =====

class HealthCheckMiddleware:
    """健康检查中间件"""

    def __init__(self, app: FastAPI, manager: HealthCheckManager):
        self.app = app
        self.manager = manager

    async def __call__(self, request: Request, call_next):
        """
        中间件处理

        Args:
            request: 请求对象
            call_next: 下一个中间件

        Returns:
            响应对象
        """
        # 如果是健康检查端点，直接处理
        if request.url.path in ["/health", "/ready"]:
            return await call_next(request)

        # 检查服务是否健康
        health = await self.manager.check_all()

        if health.status == HealthStatus.UNHEALTHY:
            # 服务不健康，返回 503
            return JSONResponse(
                status_code=503,
                content={
                    "error": "Service unavailable",
                    "message": health.message
                }
            )

        # 服务健康或降级，继续处理请求
        return await call_next(request)

# ===== 7. Prometheus 指标集成 =====

from prometheus_client import Counter, Histogram, Gauge, generate_latest, CONTENT_TYPE_LATEST
from starlette.responses import Response

# 定义指标
health_check_total = Counter(
    'health_check_total',
    'Total health check requests',
    ['endpoint', 'status']
)

health_check_duration_seconds = Histogram(
    'health_check_duration_seconds',
    'Health check duration',
    ['endpoint'],
    buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 5.0]
)

dependency_health_status = Gauge(
    'dependency_health_status',
    'Dependency health status',
    ['dependency']
)

class PrometheusHealthCheckManager(HealthCheckManager):
    """带 Prometheus 指标的健康检查管理器"""

    async def check_all(self) -> HealthCheckResponse:
        """检查所有依赖（带指标）"""
        start_time = time.time()

        try:
            result = await super().check_all()

            # 更新指标
            for name, dep in result.dependencies.items():
                dependency_health_status.labels(dependency=name).set(
                    1 if dep.healthy else 0
                )

            # 记录成功
            health_check_total.labels(
                endpoint='ready',
                status=result.status.value
            ).inc()

            return result

        finally:
            # 记录响应时间
            duration = time.time() - start_time
            health_check_duration_seconds.labels(endpoint='ready').observe(duration)

# ===== 8. FastAPI 应用 =====

app = FastAPI(
    title="AI Agent API",
    version="1.0.0"
)

# 配置日志
structlog.configure(
    processors=[
        structlog.stdlib.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)

# 创建健康检查管理器
health_manager = PrometheusHealthCheckManager(app_version="1.0.0")

# 注册依赖检查器（示例）
# health_manager.register(DatabaseChecker(engine))
# health_manager.register(RedisChecker(redis_client))
# health_manager.register(LLMAPIChecker(openai_client))

# ===== 9. 健康检查端点 =====

@app.get("/health")
async def health():
    """Liveness 检查"""
    start_time = time.time()

    try:
        result = await health_manager.check_liveness()
        health_check_total.labels(endpoint='health', status='success').inc()
        return result

    finally:
        duration = time.time() - start_time
        health_check_duration_seconds.labels(endpoint='health').observe(duration)

@app.get("/ready", response_model=HealthCheckResponse)
async def ready():
    """Readiness 检查"""
    result = await health_manager.check_readiness()

    if result.status == HealthStatus.UNHEALTHY:
        raise HTTPException(503, detail=result.dict())

    return result

@app.get("/metrics")
async def metrics():
    """Prometheus 指标端点"""
    return Response(
        content=generate_latest(),
        media_type=CONTENT_TYPE_LATEST
    )

# ===== 10. 启动和关闭事件 =====

@app.on_event("startup")
async def startup():
    """应用启动"""
    logger = structlog.get_logger()
    logger.info("Application starting", version=health_manager.app_version)

    # 执行初始健康检查
    try:
        result = await health_manager.check_all()
        logger.info(
            "Initial health check completed",
            status=result.status.value,
            message=result.message
        )
    except Exception as e:
        logger.error("Initial health check failed", error=str(e))

@app.on_event("shutdown")
async def shutdown():
    """应用关闭"""
    logger = structlog.get_logger()
    logger.info("Application shutting down")

# ===== 11. 运行说明 =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("生产级健康检查系统")
    print("=" * 50)
    print()
    print("特性：")
    print("  ✅ 多层次健康检查（Liveness/Readiness）")
    print("  ✅ 依赖服务注册与管理")
    print("  ✅ 健康状态缓存")
    print("  ✅ 三态模型（健康/降级/不健康）")
    print("  ✅ Prometheus 指标集成")
    print("  ✅ 结构化日志")
    print()
    print("端点：")
    print("  /health  - Liveness 检查")
    print("  /ready   - Readiness 检查")
    print("  /metrics - Prometheus 指标")
    print()
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 使用示例

### 1. 注册依赖检查器

```python
from sqlalchemy.ext.asyncio import create_async_engine
import redis.asyncio as redis
from openai import AsyncOpenAI

# 创建依赖客户端
engine = create_async_engine("postgresql+asyncpg://...")
redis_client = redis.from_url("redis://localhost:6379")
openai_client = AsyncOpenAI(api_key="...")

# 注册检查器
health_manager.register(DatabaseChecker(engine))
health_manager.register(RedisChecker(redis_client))
health_manager.register(LLMAPIChecker(openai_client))
```

### 2. 测试健康检查

```bash
# Liveness 检查
curl http://localhost:8000/health

# Readiness 检查
curl http://localhost:8000/ready

# Prometheus 指标
curl http://localhost:8000/metrics
```

### 3. 输出示例

**Readiness 检查（健康）：**

```json
{
  "status": "healthy",
  "timestamp": "2026-02-13T01:00:00.000Z",
  "version": "1.0.0",
  "uptime_seconds": 123.45,
  "dependencies": {
    "database": {
      "healthy": true,
      "duration_ms": 45,
      "last_check": "2026-02-13T01:00:00.000Z",
      "error": null,
      "metadata": {
        "pool_size": 10,
        "checked_out": 2,
        "checked_in": 8
      }
    },
    "redis": {
      "healthy": true,
      "duration_ms": 3,
      "last_check": "2026-02-13T01:00:00.000Z",
      "error": null,
      "metadata": {
        "connected_clients": 5,
        "used_memory_human": "1.23M"
      }
    },
    "llm_api": {
      "healthy": true,
      "duration_ms": 1500,
      "last_check": "2026-02-13T01:00:00.000Z",
      "error": null,
      "metadata": {
        "model": "gpt-3.5-turbo-0125"
      }
    }
  },
  "message": "All dependencies are healthy"
}
```

**Readiness 检查（降级）：**

```json
{
  "status": "degraded",
  "timestamp": "2026-02-13T01:00:00.000Z",
  "version": "1.0.0",
  "uptime_seconds": 123.45,
  "dependencies": {
    "database": {
      "healthy": true,
      "duration_ms": 45,
      "last_check": "2026-02-13T01:00:00.000Z"
    },
    "redis": {
      "healthy": false,
      "duration_ms": 3000,
      "last_check": "2026-02-13T01:00:00.000Z",
      "error": "Connection timeout"
    },
    "llm_api": {
      "healthy": true,
      "duration_ms": 1500,
      "last_check": "2026-02-13T01:00:00.000Z"
    }
  },
  "message": "Running in degraded mode: redis unavailable"
}
```

---

## 关键特性

### 1. 依赖检查器基类

**优点：**
- 统一的接口
- 自动缓存管理
- 易于扩展

### 2. 依赖类型

- **CRITICAL**：核心依赖，失败导致服务不可用
- **OPTIONAL**：可选依赖，失败导致服务降级

### 3. 三态模型

- **HEALTHY**：所有依赖正常
- **DEGRADED**：部分依赖失败，但核心功能可用
- **UNHEALTHY**：核心依赖失败，不可用

### 4. 缓存策略

- 数据库：30秒
- Redis：60秒
- LLM API：300秒（5分钟）

### 5. Prometheus 集成

**指标：**
- `health_check_total`：健康检查总次数
- `health_check_duration_seconds`：健康检查响应时间
- `dependency_health_status`：依赖健康状态

---

## 扩展示例

### 自定义依赖检查器

```python
class VectorDBChecker(DependencyChecker):
    """向量数据库检查器"""

    def __init__(self, db_engine):
        super().__init__("vector_db", DependencyType.OPTIONAL, cache_ttl=60)
        self.db = db_engine

    async def check(self) -> DependencyHealth:
        """检查向量数据库"""
        start_time = time.time()

        try:
            from sqlalchemy import text
            from sqlalchemy.ext.asyncio import AsyncSession

            async with AsyncSession(self.db) as session:
                # 检查 pgvector 扩展
                result = await session.execute(text("""
                    SELECT EXISTS (
                        SELECT FROM pg_extension
                        WHERE extname = 'vector'
                    )
                """))
                extension_installed = result.scalar()

                if not extension_installed:
                    raise Exception("pgvector extension not installed")

            duration_ms = int((time.time() - start_time) * 1000)

            return DependencyHealth(
                healthy=True,
                duration_ms=duration_ms,
                last_check=datetime.now().isoformat(),
                metadata={"extension_installed": True}
            )

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            return DependencyHealth(
                healthy=False,
                duration_ms=duration_ms,
                last_check=datetime.now().isoformat(),
                error=str(e)
            )

# 注册
health_manager.register(VectorDBChecker(engine))
```

---

## 总结

生产级健康检查系统的关键：

1. **框架设计**：统一的依赖检查器接口
2. **依赖管理**：区分核心和可选依赖
3. **三态模型**：健康、降级、不健康
4. **缓存策略**：不同依赖使用不同的缓存时间
5. **并发检查**：使用 asyncio.gather 并发检查
6. **指标集成**：暴露 Prometheus 指标
7. **结构化日志**：记录健康检查事件

在 AI Agent 后端中，生产级的健康检查系统可以实现自动化的故障检测、降级运行和监控告警，提高系统的可用性和可靠性。
