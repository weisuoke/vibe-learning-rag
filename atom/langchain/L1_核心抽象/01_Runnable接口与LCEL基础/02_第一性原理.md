# 第一性原理

> 从组合性推导 Runnable 协议的设计

---

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题，而非依赖类比和经验。

在物理学中，第一性原理是指从最基本的物理定律推导复杂现象。在软件设计中，第一性原理是指从最基本的需求和约束推导系统架构。

---

## Runnable 的第一性原理

### 1. 最基础的定义

**Runnable = 可组合的计算单元**

仅此而已！没有更基础的了。

一个 Runnable 就是：
- 接收输入
- 执行计算
- 产生输出
- **可以与其他 Runnable 组合**

```python
# 最基础的 Runnable
Input → [Runnable] → Output

# 组合后的 Runnable
Input → [Runnable1] → [Runnable2] → [Runnable3] → Output
```

### 2. 为什么需要 Runnable？

**核心问题：如何构建复杂的 AI 应用？**

AI 应用的本质是**多步骤的数据转换**：

```
用户输入
  ↓ 预处理
清洗后的数据
  ↓ 检索
相关文档
  ↓ 生成提示词
提示词
  ↓ LLM 调用
AI 响应
  ↓ 后处理
最终输出
```

**问题**：
- 如何让每个步骤独立开发和测试？
- 如何灵活组合不同的步骤？
- 如何复用已有的步骤？
- 如何监控和调试整个流程？

**答案**：需要一个**统一的抽象**来表示"可执行的步骤"。

### 3. Runnable 的三层价值

#### 价值 1：组合性（Composability）

**定义**：小的 Runnable 可以组合成大的 Runnable。

**为什么重要**：
- **模块化**：每个 Runnable 专注一件事
- **复用**：同一个 Runnable 可用于多个场景
- **灵活**：随时调整组合方式

**示例**：

```python
# 小的 Runnable
preprocess = RunnableLambda(lambda x: x.strip().lower())
translate = prompt | llm
postprocess = RunnableLambda(lambda x: x.upper())

# 组合成大的 Runnable
pipeline = preprocess | translate | postprocess

# 复用：换一个后处理
pipeline_v2 = preprocess | translate | different_postprocess
```

**类比**：
- **Unix 哲学**：小工具通过管道组合
- **函数式编程**：函数组合 `f(g(h(x)))`
- **乐高积木**：小块拼成大作品

#### 价值 2：可观测性（Observability）

**定义**：统一接口便于监控和调试。

**为什么重要**：
- **追踪**：知道每个步骤的输入输出
- **性能**：测量每个步骤的耗时
- **调试**：快速定位问题所在
- **优化**：识别瓶颈

**示例**：

```python
from langchain_core.callbacks import StdOutCallbackHandler

# 统一的监控接口
config = RunnableConfig(callbacks=[StdOutCallbackHandler()])

# 所有 Runnable 都支持
result = chain.invoke(input, config=config)

# 输出：
# > Entering chain...
# > Step 1: preprocess
# > Step 2: llm
# > Step 3: postprocess
# > Finished chain.
```

**类比**：
- **HTTP 中间件**：统一的请求/响应拦截
- **AOP（面向切面编程）**：统一的横切关注点
- **日志系统**：统一的日志接口

#### 价值 3：可测试性（Testability）

**定义**：标准化的输入输出便于单元测试。

**为什么重要**：
- **隔离**：独立测试每个 Runnable
- **模拟**：轻松 mock 依赖
- **回归**：确保修改不破坏功能
- **质量**：提高代码可靠性

**示例**：

```python
import pytest

def test_preprocess():
    """测试预处理 Runnable"""
    preprocess = RunnableLambda(lambda x: x.strip().lower())

    # 测试用例
    assert preprocess.invoke("  HELLO  ") == "hello"
    assert preprocess.invoke("World") == "world"

def test_pipeline():
    """测试完整管道"""
    # Mock LLM
    mock_llm = RunnableLambda(lambda x: "mocked response")

    # 构建测试管道
    pipeline = preprocess | mock_llm | postprocess

    # 测试
    result = pipeline.invoke("  input  ")
    assert result == "MOCKED RESPONSE"
```

**类比**：
- **单元测试**：测试独立的函数
- **集成测试**：测试组合的系统
- **契约测试**：测试接口契约

### 4. 从第一性原理推导 AI Agent 开发

**推理链：**

```
1. AI 应用 = 多步骤数据转换
   ↓
2. 需要统一抽象表示"可执行步骤"
   ↓
3. 这个抽象必须支持组合（小步骤 → 大流程）
   ↓
4. 定义 Runnable 协议：invoke/batch/stream
   ↓
5. 所有组件实现 Runnable 协议
   ↓
6. 使用 LCEL 管道操作符组合
   ↓
7. 构建复杂的 AI Agent 应用
```

**具体推导**：

**步骤 1**：AI 应用需要多个步骤
```python
# 问题：如何表示一个步骤？
step1(input) → output1
step2(output1) → output2
step3(output2) → final_output
```

**步骤 2**：定义统一接口
```python
# 解决：所有步骤都实现相同接口
class Runnable:
    def invoke(self, input): ...
```

**步骤 3**：支持组合
```python
# 解决：定义组合操作
class Runnable:
    def __or__(self, other):
        return ChainedRunnable(self, other)

# 使用
chain = step1 | step2 | step3
```

**步骤 4**：支持不同执行模式
```python
# 解决：添加 batch 和 stream
class Runnable:
    def invoke(self, input): ...
    def batch(self, inputs): ...
    def stream(self, input): ...
```

**步骤 5**：支持配置和监控
```python
# 解决：添加 config 参数
class Runnable:
    def invoke(self, input, config=None): ...
```

**步骤 6**：实现所有组件
```python
# LLM 是 Runnable
llm: Runnable[PromptValue, AIMessage]

# Prompt 是 Runnable
prompt: Runnable[dict, PromptValue]

# Parser 是 Runnable
parser: Runnable[AIMessage, str]

# 因此可以组合
chain: Runnable[dict, str] = prompt | llm | parser
```

**步骤 7**：构建复杂应用
```python
# RAG 应用
rag_chain = (
    {
        "context": retriever | format_docs,
        "question": RunnablePassthrough()
    }
    | prompt
    | llm
    | parser
)

# Agent 应用（需要 LangGraph）
agent = create_agent(
    tools=[tool1, tool2, tool3],  # 每个 tool 都是 Runnable
    llm=llm  # LLM 是 Runnable
)
```

### 5. 一句话总结第一性原理

**Runnable 是可组合的计算单元，通过统一接口实现组合性、可观测性和可测试性，从而构建复杂的 AI 应用。**

---

## 与其他设计模式的对比

### 对比 1: Runnable vs 继承

```python
# ❌ 继承方式
class BaseChain:
    def run(self, input): ...

class LLMChain(BaseChain):
    def run(self, input): ...

class SequentialChain(BaseChain):
    def run(self, input): ...

# 问题：
# 1. 强耦合：必须继承 BaseChain
# 2. 不灵活：难以组合不同类型的 Chain
# 3. 不统一：不同 Chain 有不同方法

# ✅ Runnable 方式（Protocol）
class Runnable(Protocol):
    def invoke(self, input): ...

# 优势：
# 1. 解耦：无需继承，只需实现方法
# 2. 灵活：任何对象都可以是 Runnable
# 3. 统一：所有 Runnable 有相同接口
```

### 对比 2: Runnable vs 中间件

```python
# Express.js 中间件
app.use(middleware1)
app.use(middleware2)
app.use(middleware3)

# Runnable 管道
chain = runnable1 | runnable2 | runnable3

# 相似点：
# 1. 都是组合模式
# 2. 都是数据流转
# 3. 都支持监控

# 不同点：
# 1. Runnable 更通用（不限于 HTTP）
# 2. Runnable 类型安全（泛型）
# 3. Runnable 支持多种执行模式（invoke/batch/stream）
```

### 对比 3: Runnable vs 函数组合

```python
# 函数组合
def compose(f, g):
    return lambda x: f(g(x))

result = compose(f3, compose(f2, f1))(input)

# Runnable 组合
chain = runnable1 | runnable2 | runnable3
result = chain.invoke(input)

# 相似点：
# 1. 都是组合模式
# 2. 都是数据流转

# Runnable 的优势：
# 1. 统一接口（invoke/batch/stream）
# 2. 配置传递（config）
# 3. 可观测性（callbacks）
# 4. 类型安全（泛型）
```

---

## 设计决策的权衡

### 决策 1: Protocol vs 继承

**选择**：使用 Protocol（鸭子类型）

**优势**：
- ✅ 解耦：无需继承
- ✅ 灵活：任何对象都可以是 Runnable
- ✅ 兼容：易于集成第三方库

**劣势**：
- ❌ 运行时检查：类型错误在运行时才发现
- ❌ IDE 支持：早期 IDE 支持不完善（2025+ 已改善）

**为什么这样选**：
灵活性和兼容性比运行时类型检查更重要。

### 决策 2: 三个方法 vs 一个方法

**选择**：invoke/batch/stream 三个方法

**优势**：
- ✅ 明确：每个方法有明确的语义
- ✅ 优化：每个方法可以独立优化
- ✅ 灵活：用户可以选择最合适的方法

**劣势**：
- ❌ 复杂：需要实现三个方法
- ❌ 冗余：batch 和 stream 可以基于 invoke 实现

**为什么这样选**：
性能优化和用户体验比实现简单性更重要。

### 决策 3: 管道操作符 vs 方法链

**选择**：管道操作符 `|`

**优势**：
- ✅ 直观：类似 Unix 管道
- ✅ 简洁：`a | b | c` vs `a.then(b).then(c)`
- ✅ 类型推断：更容易推断类型

**劣势**：
- ❌ 不熟悉：Python 开发者可能不习惯
- ❌ 运算符重载：需要理解 `__or__` 方法

**为什么这样选**：
可读性和简洁性比熟悉度更重要。

---

## 2025-2026 年的演进

### LangChain 1.0 的稳定性承诺

2025年10月，LangChain 1.0 发布，承诺 Runnable 协议到 2.0 无重大变更[^1]。

**意义**：
- ✅ 生产可用：企业可以放心采用
- ✅ 生态稳定：第三方库可以基于 Runnable 构建
- ✅ 学习投资：学习 Runnable 的知识不会过时

### 从 Chain 到 Runnable 的迁移

**历史**：
- **2023年前**：使用传统 Chain API
- **2023-2024年**：引入 LCEL 和 Runnable
- **2025年后**：Runnable 成为标准

**迁移路径**：
```python
# 旧代码（2023年前）
from langchain.chains import LLMChain
chain = LLMChain(llm=llm, prompt=prompt)
result = chain.run(input)

# 新代码（2025年后）
chain = prompt | llm | parser
result = chain.invoke(input)
```

### 企业级应用验证

**2025-2026 年数据**[^2]：
- **57%** 的企业已在生产环境部署 LangChain Agent
- **Klarna**: 8500 万用户，80% 查询解决时间缩短
- **Elastic**: 2 万客户，显著缩短警报响应时间

**结论**：Runnable 协议已经过大规模生产验证。

---

## 实践建议

### 1. 从第一性原理思考设计

**问题**：我需要添加一个新功能，应该如何设计？

**第一性原理思考**：
1. 这个功能的本质是什么？（数据转换）
2. 它需要与其他功能组合吗？（是）
3. 它需要独立测试吗？（是）
4. 它需要监控吗？（是）

**结论**：实现为 Runnable。

### 2. 优先组合而非继承

```python
# ❌ 不推荐：继承
class MySpecialChain(LLMChain):
    def run(self, input):
        # 自定义逻辑
        ...

# ✅ 推荐：组合
my_chain = preprocess | llm_chain | postprocess
```

### 3. 保持 Runnable 的单一职责

```python
# ❌ 不推荐：一个 Runnable 做太多事
class ComplexRunnable(Runnable):
    def invoke(self, input):
        # 预处理
        # 调用 LLM
        # 后处理
        # 保存结果
        # 发送通知
        ...

# ✅ 推荐：拆分成多个 Runnable
chain = (
    preprocess
    | llm
    | postprocess
    | save_result
    | send_notification
)
```

---

## 总结

### Runnable 的第一性原理

1. **最基础定义**：可组合的计算单元
2. **核心问题**：如何构建复杂的 AI 应用
3. **三层价值**：组合性、可观测性、可测试性
4. **推导路径**：从基本需求推导出 Runnable 协议
5. **设计决策**：Protocol、三方法、管道操作符

### 关键洞察

- **组合优于继承**：灵活性和解耦
- **统一优于多样**：一致的接口
- **声明优于命令**：LCEL 的哲学

### 实践原则

- 从第一性原理思考设计
- 优先组合而非继承
- 保持单一职责
- 利用类型系统

---

## 参考资料

[^1]: [LangChain 1.0 Release](https://blog.langchain.com/langchain-langgraph-1dot0) - LangChain Blog, 2025年10月
[^2]: [State of Agent Engineering 2026](https://www.langchain.com/state-of-agent-engineering) - LangChain, 2026

### 延伸阅读
- [Unix Philosophy](https://en.wikipedia.org/wiki/Unix_philosophy) - 组合性的经典案例
- [Functional Programming Principles](https://en.wikipedia.org/wiki/Functional_programming) - 函数组合
- [Protocol-Oriented Programming](https://developer.apple.com/videos/play/wwdc2015/408/) - Protocol 设计

---

**下一步**: 阅读 [05_双重类比.md](./05_双重类比.md) 通过类比加深理解
