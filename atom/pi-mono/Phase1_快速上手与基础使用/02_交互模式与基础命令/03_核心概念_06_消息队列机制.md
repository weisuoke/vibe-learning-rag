# 核心概念 06：消息队列机制

> 深入理解 Pi 的消息队列、Steering Message 和 Follow-up Message 机制

---

## 概念定义

**Pi 的消息队列机制通过异步队列管理用户消息、LLM 响应和工具调用，支持 Steering Message（中断当前响应）和 Follow-up Message（追加后续消息），实现灵活的对话流控制。**

---

## 消息队列架构

### 队列类型

```typescript
// 消息队列系统
class MessageQueueSystem {
  // 主消息队列
  private mainQueue: Message[] = [];

  // 工具调用队列
  private toolQueue: ToolCall[] = [];

  // 待处理响应队列
  private responseQueue: Response[] = [];

  // 当前处理状态
  private processing: boolean = false;

  // 中断标志
  private interrupted: boolean = false;
}
```

---

### 消息类型

```typescript
// 消息类型定义
type Message =
  | UserMessage
  | AssistantMessage
  | ToolCallMessage
  | ToolResultMessage
  | SteeringMessage
  | FollowUpMessage;

// 用户消息
interface UserMessage {
  type: 'user';
  id: string;
  content: string;
  timestamp: Date;
  parent?: string;  // 父消息 ID（用于分支）
}

// AI 响应消息
interface AssistantMessage {
  type: 'assistant';
  id: string;
  content: string;
  toolCalls?: ToolCall[];
  timestamp: Date;
  parent: string;
}

// 工具调用消息
interface ToolCallMessage {
  type: 'tool_call';
  id: string;
  name: string;
  args: any;
  timestamp: Date;
}

// 工具结果消息
interface ToolResultMessage {
  type: 'tool_result';
  id: string;
  toolCallId: string;
  result: any;
  timestamp: Date;
}

// Steering Message（中断消息）
interface SteeringMessage {
  type: 'steering';
  id: string;
  content: string;
  timestamp: Date;
  interruptTarget: string;  // 要中断的消息 ID
}

// Follow-up Message（追加消息）
interface FollowUpMessage {
  type: 'followup';
  id: string;
  content: string;
  timestamp: Date;
  followTarget: string;  // 追加到哪个消息
}
```

---

## 消息处理流程

### 基本流程

```typescript
// 消息处理器
class MessageProcessor {
  async processMessage(message: Message): Promise<void> {
    // 1. 添加到队列
    this.mainQueue.push(message);

    // 2. 如果正在处理，等待
    if (this.processing) {
      return;
    }

    // 3. 开始处理队列
    this.processing = true;

    while (this.mainQueue.length > 0) {
      const msg = this.mainQueue.shift()!;

      try {
        await this.handleMessage(msg);
      } catch (error) {
        console.error('Error processing message:', error);
      }

      // 检查是否被中断
      if (this.interrupted) {
        this.interrupted = false;
        break;
      }
    }

    this.processing = false;
  }

  private async handleMessage(message: Message): Promise<void> {
    switch (message.type) {
      case 'user':
        await this.handleUserMessage(message);
        break;

      case 'assistant':
        await this.handleAssistantMessage(message);
        break;

      case 'tool_call':
        await this.handleToolCall(message);
        break;

      case 'tool_result':
        await this.handleToolResult(message);
        break;

      case 'steering':
        await this.handleSteeringMessage(message);
        break;

      case 'followup':
        await this.handleFollowUpMessage(message);
        break;
    }
  }
}
```

---

### 用户消息处理

```typescript
// 处理用户消息
async function handleUserMessage(message: UserMessage): Promise<void> {
  // 1. 保存到 Session
  await session.addMessage(message);

  // 2. 构建 LLM 上下文
  const context = await buildLLMContext(message);

  // 3. 调用 LLM
  const stream = await llm.stream(context);

  // 4. 流式处理响应
  let assistantMessage = '';
  const toolCalls: ToolCall[] = [];

  for await (const chunk of stream) {
    // 检查是否被中断
    if (this.interrupted) {
      // 停止流式响应
      stream.cancel();
      return;
    }

    if (chunk.type === 'content') {
      // 文本内容
      assistantMessage += chunk.content;
      this.renderAssistantMessage(assistantMessage);
    } else if (chunk.type === 'tool_call') {
      // 工具调用
      toolCalls.push(chunk.toolCall);
    }
  }

  // 5. 保存 AI 响应
  const response: AssistantMessage = {
    type: 'assistant',
    id: generateId(),
    content: assistantMessage,
    toolCalls: toolCalls,
    timestamp: new Date(),
    parent: message.id
  };

  await session.addMessage(response);

  // 6. 处理工具调用
  if (toolCalls.length > 0) {
    for (const toolCall of toolCalls) {
      this.toolQueue.push(toolCall);
    }

    await this.processToolQueue();
  }
}
```

---

### 工具调用处理

```typescript
// 处理工具调用队列
async function processToolQueue(): Promise<void> {
  while (this.toolQueue.length > 0) {
    const toolCall = this.toolQueue.shift()!;

    // 1. 执行工具
    const result = await this.executeTool(toolCall);

    // 2. 保存工具结果
    const toolResult: ToolResultMessage = {
      type: 'tool_result',
      id: generateId(),
      toolCallId: toolCall.id,
      result: result,
      timestamp: new Date()
    };

    await session.addMessage(toolResult);

    // 3. 渲染工具输出
    this.renderToolResult(toolCall, result);
  }

  // 4. 所有工具执行完毕，继续 LLM 响应
  await this.continueAssistantResponse();
}

// 执行工具
async function executeTool(toolCall: ToolCall): Promise<any> {
  const tool = toolRegistry.get(toolCall.name);

  if (!tool) {
    throw new Error(`Tool not found: ${toolCall.name}`);
  }

  try {
    return await tool.execute(toolCall.args);
  } catch (error) {
    return {
      error: error.message,
      stack: error.stack
    };
  }
}

// 继续 AI 响应
async function continueAssistantResponse(): Promise<void> {
  // 1. 构建包含工具结果的上下文
  const context = await buildLLMContextWithToolResults();

  // 2. 继续 LLM 响应
  const stream = await llm.stream(context);

  // 3. 流式处理
  let assistantMessage = '';

  for await (const chunk of stream) {
    if (this.interrupted) {
      stream.cancel();
      return;
    }

    assistantMessage += chunk.content;
    this.renderAssistantMessage(assistantMessage);
  }

  // 4. 保存最终响应
  const response: AssistantMessage = {
    type: 'assistant',
    id: generateId(),
    content: assistantMessage,
    timestamp: new Date(),
    parent: this.getLastMessageId()
  };

  await session.addMessage(response);
}
```

---

## Steering Message（中断机制）

### 概念

**Steering Message 允许用户在 AI 响应过程中发送新消息，中断当前响应并开始新的对话。**

### 实现原理

```typescript
// Steering Message 处理
class SteeringMessageHandler {
  async handleSteeringMessage(message: SteeringMessage): Promise<void> {
    // 1. 设置中断标志
    this.interrupted = true;

    // 2. 取消当前 LLM 流
    if (this.currentStream) {
      this.currentStream.cancel();
    }

    // 3. 清空工具队列
    this.toolQueue = [];

    // 4. 保存 Steering Message
    await session.addMessage({
      type: 'user',
      id: message.id,
      content: message.content,
      timestamp: message.timestamp,
      parent: message.interruptTarget
    });

    // 5. 开始新的对话
    await this.handleUserMessage({
      type: 'user',
      id: message.id,
      content: message.content,
      timestamp: message.timestamp
    });
  }
}
```

### 使用场景

```typescript
// 场景 1：纠正 AI 的理解
// AI 正在生成长篇响应
AI: "让我详细解释 React Hooks 的工作原理..."
[正在生成中...]

// 用户发送 Steering Message
User: "等等，我想问的是 Vue 的 Composition API"

// AI 立即停止当前响应，开始新的回答
AI: "好的，让我解释 Vue 的 Composition API..."

// 场景 2：改变讨论方向
AI: "这是一个复杂的架构设计，需要考虑..."
[正在生成中...]

User: "先不讨论架构，帮我修复这个 bug"

AI: "好的，让我看看这个 bug..."

// 场景 3：紧急问题
AI: "让我继续解释数据库优化..."
[正在生成中...]

User: "停！我的生产环境出问题了，帮我看看"

AI: "明白，让我立即帮你排查生产问题..."
```

---

### 技术细节

```typescript
// Steering Message 检测
class SteeringDetector {
  detectSteering(userInput: string): boolean {
    // 1. 检查是否有正在进行的响应
    if (!this.currentStream) {
      return false;
    }

    // 2. 检查用户输入的紧急程度
    const urgentKeywords = [
      '等等', '停', '先不', '改成', '不对',
      'wait', 'stop', 'no', 'instead', 'actually'
    ];

    const isUrgent = urgentKeywords.some(keyword =>
      userInput.toLowerCase().includes(keyword)
    );

    // 3. 如果是紧急消息，触发 Steering
    return isUrgent;
  }

  async handleUserInput(input: string): Promise<void> {
    if (this.detectSteering(input)) {
      // 创建 Steering Message
      const steeringMessage: SteeringMessage = {
        type: 'steering',
        id: generateId(),
        content: input,
        timestamp: new Date(),
        interruptTarget: this.currentMessageId
      };

      await this.handleSteeringMessage(steeringMessage);
    } else {
      // 普通用户消息
      await this.handleUserMessage({
        type: 'user',
        id: generateId(),
        content: input,
        timestamp: new Date()
      });
    }
  }
}
```

---

## Follow-up Message（追加机制）

### 概念

**Follow-up Message 允许用户在 AI 响应完成后，追加额外的信息或问题，而不需要重新发送完整的上下文。**

### 实现原理

```typescript
// Follow-up Message 处理
class FollowUpMessageHandler {
  async handleFollowUpMessage(message: FollowUpMessage): Promise<void> {
    // 1. 保存 Follow-up Message
    await session.addMessage({
      type: 'user',
      id: message.id,
      content: message.content,
      timestamp: message.timestamp,
      parent: message.followTarget
    });

    // 2. 构建上下文（包含之前的对话）
    const context = await this.buildFollowUpContext(message);

    // 3. 调用 LLM
    const stream = await llm.stream(context);

    // 4. 流式处理响应
    let assistantMessage = '';

    for await (const chunk of stream) {
      assistantMessage += chunk.content;
      this.renderAssistantMessage(assistantMessage);
    }

    // 5. 保存响应
    const response: AssistantMessage = {
      type: 'assistant',
      id: generateId(),
      content: assistantMessage,
      timestamp: new Date(),
      parent: message.id
    };

    await session.addMessage(response);
  }

  private async buildFollowUpContext(message: FollowUpMessage): Promise<Message[]> {
    // 获取从根节点到当前消息的完整路径
    const path = await this.getMessagePath(message.followTarget);

    // 添加 Follow-up Message
    path.push({
      role: 'user',
      content: message.content
    });

    return path;
  }
}
```

### 使用场景

```typescript
// 场景 1：追加细节
User: "请帮我写一个 React 组件"
AI: [生成基础组件]

User: "再添加一个 loading 状态"
// Follow-up Message，AI 理解是在之前的组件基础上添加

// 场景 2：追加问题
User: "请解释 async/await"
AI: [详细解释]

User: "那 Promise.all 呢？"
// Follow-up Message，AI 理解是在同一主题下的追加问题

// 场景 3：逐步细化
User: "设计一个用户认证系统"
AI: [提供高层设计]

User: "详细说说 JWT 部分"
// Follow-up Message，AI 理解是要深入某个部分
```

---

## 消息队列优化

### 优化 1：批量处理

```typescript
// 批量处理工具调用
class BatchToolProcessor {
  async processBatch(toolCalls: ToolCall[]): Promise<ToolResult[]> {
    // 1. 分组：可并行执行的工具
    const parallelGroups = this.groupParallelTools(toolCalls);

    const results: ToolResult[] = [];

    // 2. 按组执行
    for (const group of parallelGroups) {
      // 并行执行同组工具
      const groupResults = await Promise.all(
        group.map(tc => this.executeTool(tc))
      );

      results.push(...groupResults);
    }

    return results;
  }

  private groupParallelTools(toolCalls: ToolCall[]): ToolCall[][] {
    // 分析工具依赖关系
    const groups: ToolCall[][] = [];
    const processed = new Set<string>();

    for (const toolCall of toolCalls) {
      if (processed.has(toolCall.id)) continue;

      // 找出所有可以与当前工具并行的工具
      const parallelTools = [toolCall];

      for (const other of toolCalls) {
        if (processed.has(other.id)) continue;
        if (other.id === toolCall.id) continue;

        // 检查是否有依赖关系
        if (!this.hasDependency(toolCall, other)) {
          parallelTools.push(other);
          processed.add(other.id);
        }
      }

      groups.push(parallelTools);
      processed.add(toolCall.id);
    }

    return groups;
  }

  private hasDependency(tool1: ToolCall, tool2: ToolCall): boolean {
    // 检查工具间是否有依赖
    // 例如：write 依赖 read 的结果
    if (tool1.name === 'read' && tool2.name === 'write') {
      // 检查 write 的内容是否依赖 read 的结果
      return tool2.args.content.includes('{{read_result}}');
    }

    return false;
  }
}
```

---

### 优化 2：优先级队列

```typescript
// 优先级消息队列
class PriorityMessageQueue {
  private highPriority: Message[] = [];
  private normalPriority: Message[] = [];
  private lowPriority: Message[] = [];

  enqueue(message: Message, priority: 'high' | 'normal' | 'low' = 'normal'): void {
    switch (priority) {
      case 'high':
        this.highPriority.push(message);
        break;
      case 'normal':
        this.normalPriority.push(message);
        break;
      case 'low':
        this.lowPriority.push(message);
        break;
    }
  }

  dequeue(): Message | undefined {
    // 优先处理高优先级消息
    if (this.highPriority.length > 0) {
      return this.highPriority.shift();
    }

    // 然后处理普通优先级
    if (this.normalPriority.length > 0) {
      return this.normalPriority.shift();
    }

    // 最后处理低优先级
    if (this.lowPriority.length > 0) {
      return this.lowPriority.shift();
    }

    return undefined;
  }

  getPriority(message: Message): 'high' | 'normal' | 'low' {
    // Steering Message 高优先级
    if (message.type === 'steering') {
      return 'high';
    }

    // 用户消息普通优先级
    if (message.type === 'user') {
      return 'normal';
    }

    // 工具结果低优先级
    if (message.type === 'tool_result') {
      return 'low';
    }

    return 'normal';
  }
}
```

---

### 优化 3：消息去重

```typescript
// 消息去重
class MessageDeduplicator {
  private recentMessages: Map<string, Message> = new Map();

  isDuplicate(message: Message): boolean {
    // 计算消息指纹
    const fingerprint = this.calculateFingerprint(message);

    // 检查是否重复
    if (this.recentMessages.has(fingerprint)) {
      const existing = this.recentMessages.get(fingerprint)!;

      // 检查时间间隔
      const timeDiff = message.timestamp.getTime() - existing.timestamp.getTime();

      // 5 秒内的重复消息
      if (timeDiff < 5000) {
        return true;
      }
    }

    // 保存消息指纹
    this.recentMessages.set(fingerprint, message);

    // 清理旧消息（保留最近 100 条）
    if (this.recentMessages.size > 100) {
      const oldest = Array.from(this.recentMessages.keys())[0];
      this.recentMessages.delete(oldest);
    }

    return false;
  }

  private calculateFingerprint(message: Message): string {
    // 基于消息内容和类型计算指纹
    return `${message.type}:${this.hashContent(message.content)}`;
  }

  private hashContent(content: string): string {
    // 简单的哈希函数
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
}
```

---

## 实际应用场景

### 场景 1：长时间工具调用

```typescript
// 场景：执行耗时的工具调用
User: "请分析这个大型项目的代码质量"

AI: "好的，让我分析..."
[Tool: read] src/file1.ts
[Tool: read] src/file2.ts
[Tool: read] src/file3.ts
// ... 100 个文件

// 用户可以在工具执行过程中发送 Steering Message
User: "等等，只分析 src/auth/ 目录"

// AI 立即停止当前工具调用，开始新的分析
AI: "好的，只分析 auth 目录..."
[Tool: read] src/auth/index.ts
[Tool: read] src/auth/login.ts
```

---

### 场景 2：多轮对话

```typescript
// 场景：逐步细化需求
User: "设计一个博客系统"
AI: [提供高层架构]

User: "详细说说数据库设计"  // Follow-up
AI: [详细数据库设计]

User: "User 表需要哪些字段？"  // Follow-up
AI: [User 表设计]

User: "添加一个 avatar 字段"  // Follow-up
AI: [更新 User 表设计]
```

---

### 场景 3：错误恢复

```typescript
// 场景：工具调用失败
User: "请读取 @config.json 并修改"

AI: "好的..."
[Tool: read] config.json
Error: File not found

// AI 自动恢复
AI: "文件不存在，让我创建一个默认配置..."
[Tool: write] config.json
```

---

## 快速参考

```typescript
// 消息队列机制
interface MessageQueueMechanism {
  // 消息类型
  messageTypes: [
    'user',           // 用户消息
    'assistant',      // AI 响应
    'tool_call',      // 工具调用
    'tool_result',    // 工具结果
    'steering',       // 中断消息
    'followup'        // 追加消息
  ];

  // 处理流程
  flow: {
    user: 'User → LLM → Assistant',
    toolCall: 'Assistant → Tool → Result → LLM',
    steering: 'User (interrupt) → Cancel → New LLM',
    followup: 'User (append) → LLM (with context)'
  };

  // 优化策略
  optimizations: {
    batch: '批量处理工具调用',
    priority: '优先级队列',
    dedup: '消息去重'
  };
}
```

---

**来源：**
- [Pi Coding Agent README](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/README.md) - 2026-02
- [Architecture 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/architecture.md) - 2026-02
- [Message Queue 实现](https://github.com/badlogic/pi-mono/tree/main/packages/pi-agent-core/src/queue) - 2026-02
