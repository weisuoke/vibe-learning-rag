# 核心概念01: 堆的基本性质

## 核心目标

**深入理解Heap的基本性质,包括完全二叉树结构、heap性质、数组表示、以及为什么这样设计。**

---

## 1. 完全二叉树结构

### 1.1 什么是完全二叉树?

**定义:** 除最后一层外,其他层都是满的,且最后一层的节点从左到右连续排列。

**可视化:**

```
完全二叉树 ✓:
       1
      / \
     2   3
    / \  /
   4  5 6

非完全二叉树 ✗:
       1
      / \
     2   3
    /     \
   4       6    ← 最后一层不连续
```

### 1.2 为什么选择完全二叉树?

**原因1: 高度保证**
```
n个节点的完全二叉树高度 = ⌊log₂ n⌋

证明:
- 高度h的完全二叉树最少有2^h个节点
- 最多有2^(h+1) - 1个节点
- 因此: 2^h ≤ n < 2^(h+1)
- 取对数: h ≤ log₂ n < h + 1
- 所以: h = ⌊log₂ n⌋ = O(log n)
```

**原因2: 数组紧凑存储**
```python
# 完全二叉树可以用数组紧凑存储,无空洞
arr = [1, 2, 3, 4, 5, 6]  # 6个元素,6个位置

# 非完全二叉树用数组存储会有空洞
arr = [1, 2, 3, 4, None, None, 6]  # 6个元素,7个位置
```

**原因3: 父子关系简单**
```python
# 通过索引直接计算,无需指针
parent(i) = (i - 1) // 2
left(i) = 2 * i + 1
right(i) = 2 * i + 2
```

### 1.3 完全二叉树的性质

**性质1: 节点数与高度关系**
```
高度h的完全二叉树:
- 最少节点: 2^h
- 最多节点: 2^(h+1) - 1

示例:
h=0: 1个节点
h=1: 2-3个节点
h=2: 4-7个节点
h=3: 8-15个节点
```

**性质2: 叶子节点数量**
```
n个节点的完全二叉树:
- 叶子节点数: ⌈n/2⌉
- 非叶子节点数: ⌊n/2⌋

证明:
- 最后一层最多有⌈n/2⌉个节点
- 其他层最多有⌊n/2⌋个节点
```

**性质3: 最后一个非叶子节点**
```python
# 索引为n//2 - 1
def last_non_leaf(n):
    return n // 2 - 1

# 示例
n = 7
print(last_non_leaf(n))  # 2

# 验证:
# 索引0,1,2是非叶子节点
# 索引3,4,5,6是叶子节点
```

---

## 2. Heap性质

### 2.1 Min-heap性质

**定义:** 对于任意节点i,有 heap[i] ≤ heap[left(i)] 且 heap[i] ≤ heap[right(i)]

**可视化:**

```
Min-heap示例:
       5
      / \
    10   15
   / \   /
  20 25 30

性质验证:
- 5 ≤ 10 ✓
- 5 ≤ 15 ✓
- 10 ≤ 20 ✓
- 10 ≤ 25 ✓
- 15 ≤ 30 ✓
```

**形式化表达:**

```
∀i ∈ [0, n), 如果2i+1 < n, 则 heap[i] ≤ heap[2i+1]
∀i ∈ [0, n), 如果2i+2 < n, 则 heap[i] ≤ heap[2i+2]
```

### 2.2 Max-heap性质

**定义:** 对于任意节点i,有 heap[i] ≥ heap[left(i)] 且 heap[i] ≥ heap[right(i)]

**可视化:**

```
Max-heap示例:
       30
      /  \
    25    20
   / \    /
  15 10  5

性质验证:
- 30 ≥ 25 ✓
- 30 ≥ 20 ✓
- 25 ≥ 15 ✓
- 25 ≥ 10 ✓
- 20 ≥ 5 ✓
```

### 2.3 半有序性

**关键洞察:** Heap只保证父子关系,不保证兄弟关系或全局顺序。

**示例:**

```python
# 合法的min-heap
heap = [5, 10, 15, 20, 25, 30, 35]

# 观察:
# - 10 和 15 无序 (兄弟节点)
# - 20 和 25 无序 (兄弟节点)
# - 30 和 35 无序 (兄弟节点)
# - 但所有父子关系都满足

# 这不是排序数组!
print(heap == sorted(heap))  # False
```

**为什么半有序就够了?**

```
优先级队列的需求:
1. 快速找到最小值 → heap[0]即可,O(1)
2. 快速插入 → 只需调整O(log n)个节点
3. 快速删除最小值 → 只需调整O(log n)个节点

不需要:
- 知道第2小、第3小是谁
- 知道所有元素的全局顺序
- 支持任意位置的查找

因此半有序性是最优的权衡!
```

---

## 3. 数组表示

### 3.1 索引关系

**核心公式:**

```python
def parent(i):
    """获取父节点索引"""
    return (i - 1) // 2

def left_child(i):
    """获取左子节点索引"""
    return 2 * i + 1

def right_child(i):
    """获取右子节点索引"""
    return 2 * i + 2
```

**推导过程:**

```
完全二叉树的层序遍历:
层0: 索引0
层1: 索引1, 2
层2: 索引3, 4, 5, 6
层3: 索引7, 8, 9, 10, 11, 12, 13, 14

观察规律:
- 节点i的左子节点: 2*i + 1
- 节点i的右子节点: 2*i + 2
- 节点i的父节点: (i-1) // 2

验证:
- 节点1的父节点: (1-1)//2 = 0 ✓
- 节点2的父节点: (2-1)//2 = 0 ✓
- 节点3的父节点: (3-1)//2 = 1 ✓
- 节点0的左子: 2*0+1 = 1 ✓
- 节点0的右子: 2*0+2 = 2 ✓
```

### 3.2 数组存储的优势

**优势1: 空间效率**

```python
# 数组存储
class HeapArray:
    def __init__(self):
        self.data = []  # 只存值

# 指针存储
class HeapNode:
    def __init__(self, val):
        self.val = val
        self.left = None   # 额外8字节
        self.right = None  # 额外8字节
        self.parent = None # 额外8字节

# 空间对比(n=1000):
# 数组: 1000个int = 4KB
# 指针: 1000个int + 3000个指针 = 4KB + 24KB = 28KB
```

**优势2: 缓存友好**

```python
# 数组: 连续内存,缓存命中率高
heap = [5, 10, 15, 20, 25]  # 连续存储

# 指针: 随机内存,缓存命中率低
# 节点可能分散在内存各处
```

**优势3: 访问效率**

```python
# 数组: O(1)计算索引
parent_idx = (i - 1) // 2

# 指针: O(1)跟随指针,但需要额外内存访问
parent_node = node.parent
```

### 3.3 边界检查

**重要:** 访问子节点前必须检查索引是否越界。

```python
def has_left_child(heap, i):
    """检查是否有左子节点"""
    return 2 * i + 1 < len(heap)

def has_right_child(heap, i):
    """检查是否有右子节点"""
    return 2 * i + 2 < len(heap)

def has_parent(i):
    """检查是否有父节点"""
    return i > 0

# 使用示例
def heapify_down(heap, i):
    n = len(heap)
    while has_left_child(heap, i):  # 检查边界
        left = 2 * i + 1
        right = 2 * i + 2
        smallest = i

        if heap[left] < heap[smallest]:
            smallest = left

        if has_right_child(heap, i) and heap[right] < heap[smallest]:
            smallest = right

        if smallest != i:
            heap[i], heap[smallest] = heap[smallest], heap[i]
            i = smallest
        else:
            break
```

---

## 4. 设计权衡

### 4.1 Heap vs BST

| 特性 | Heap | BST |
|------|------|-----|
| 结构 | 完全二叉树 | 可能不平衡 |
| 性质 | 父子关系 | 左<根<右 |
| 查找最小 | O(1) | O(log n)平均,O(n)最坏 |
| 插入 | O(log n) | O(log n)平均,O(n)最坏 |
| 删除最小 | O(log n) | O(log n)平均,O(n)最坏 |
| 查找任意 | O(n) | O(log n)平均,O(n)最坏 |
| 存储 | 数组 | 指针 |
| 缓存友好 | ✅ | ❌ |

**选择指南:**
- 只需要最小/最大值 → Heap
- 需要查找任意元素 → BST
- 需要范围查询 → BST
- 需要有序遍历 → BST

### 4.2 Heap vs 排序数组

| 特性 | Heap | 排序数组 |
|------|------|----------|
| 查找最小 | O(1) | O(1) |
| 插入 | O(log n) | O(n) |
| 删除最小 | O(log n) | O(n) |
| 建立 | O(n) | O(n log n) |
| 空间 | O(n) | O(n) |

**选择指南:**
- 频繁插入删除 → Heap
- 静态数据 → 排序数组
- 需要全局有序 → 排序数组

### 4.3 Heap vs 无序数组

| 特性 | Heap | 无序数组 |
|------|------|----------|
| 查找最小 | O(1) | O(n) |
| 插入 | O(log n) | O(1) |
| 删除最小 | O(log n) | O(n) |

**选择指南:**
- 频繁访问最小值 → Heap
- 只需插入 → 无序数组

---

## 5. 验证Heap性质

### 5.1 完整验证函数

```python
def is_valid_min_heap(heap):
    """
    验证数组是否满足min-heap性质

    检查:
    1. 所有父节点 ≤ 左子节点
    2. 所有父节点 ≤ 右子节点
    """
    n = len(heap)

    for i in range(n):
        left = 2 * i + 1
        right = 2 * i + 2

        # 检查左子节点
        if left < n and heap[i] > heap[left]:
            print(f"违反heap性质: heap[{i}]={heap[i]} > heap[{left}]={heap[left]}")
            return False

        # 检查右子节点
        if right < n and heap[i] > heap[right]:
            print(f"违反heap性质: heap[{i}]={heap[i]} > heap[{right}]={heap[right]}")
            return False

    return True

# 测试
heap1 = [5, 10, 15, 20, 25]
print(is_valid_min_heap(heap1))  # True

heap2 = [5, 3, 15, 20, 25]
print(is_valid_min_heap(heap2))  # False
# 输出: 违反heap性质: heap[0]=5 > heap[1]=3
```

### 5.2 可视化Heap结构

```python
def visualize_heap(heap):
    """
    打印heap的树形结构

    示例:
    [5, 10, 15, 20, 25, 30, 35]
    →
           5
         /   \
       10     15
      / \    /  \
     20 25  30  35
    """
    if not heap:
        print("Empty heap")
        return

    n = len(heap)
    height = 0
    temp = n
    while temp > 0:
        height += 1
        temp //= 2

    index = 0
    for level in range(height):
        level_size = 2 ** level
        indent = " " * (2 ** (height - level - 1) - 1)

        for _ in range(level_size):
            if index >= n:
                break
            print(f"{indent}{heap[index]:3}", end=" ")
            index += 1
        print()

# 测试
heap = [5, 10, 15, 20, 25, 30, 35]
visualize_heap(heap)
# 输出:
#        5
#      10  15
#     20 25 30 35
```

---

## 6. RAG应用场景

### 6.1 Top-K文档检索

**场景:** 从100万文档中找出相似度最高的10个。

**Heap性质应用:**

```python
import heapq

def rag_top_k_retrieval(query_emb, doc_embs, k=10):
    """
    使用min-heap维护Top-K文档

    Heap性质:
    - heap[0]是相似度最低的候选文档
    - 新文档相似度 > heap[0]时替换
    - 始终保持K个最相似文档
    """
    heap = []

    for doc_id, doc_emb in doc_embs:
        score = cosine_similarity(query_emb, doc_emb)

        if len(heap) < k:
            heapq.heappush(heap, (score, doc_id))
        elif score > heap[0][0]:
            heapq.heapreplace(heap, (score, doc_id))

    return sorted(heap, reverse=True)
```

**为什么用min-heap?**
- heap[0]是"入场门槛"
- 只有相似度超过门槛的文档才能进入Top-K
- 空间复杂度O(K),而非O(n)

### 6.2 AI Agent任务调度

**场景:** Agent需要处理不同优先级的任务。

**Heap性质应用:**

```python
import heapq
from enum import IntEnum

class Priority(IntEnum):
    URGENT = 0
    HIGH = 1
    NORMAL = 2
    LOW = 3

class AgentScheduler:
    def __init__(self):
        self.task_queue = []

    def submit(self, priority, task_id):
        """
        Heap性质:
        - heap[0]是优先级最高的任务
        - 数字越小优先级越高
        """
        heapq.heappush(self.task_queue, (priority, task_id))

    def execute_next(self):
        """
        Heap性质:
        - heappop返回优先级最高的任务
        - O(log n)时间复杂度
        """
        if not self.task_queue:
            return None

        priority, task_id = heapq.heappop(self.task_queue)
        return task_id
```

---

## 7. 常见误区

### 误区1: "Heap是排序数组"

```python
# ❌ 错误理解
heap = [5, 10, 15, 20, 25]
print(heap[2])  # 15 - 不是第3小的元素!

# ✅ 正确理解
# heap只保证heap[0]是最小值
# 其他元素只保证父子关系
```

### 误区2: "可以直接修改heap数组"

```python
# ❌ 错误做法
heap = [5, 10, 15]
heap[0] = 20  # 直接修改破坏heap性质

# ✅ 正确做法
heap = [5, 10, 15]
heapq.heappop(heap)  # 删除
heapq.heappush(heap, 20)  # 插入
```

### 误区3: "Heap支持快速查找任意元素"

```python
# ❌ 错误期望
# 在heap中查找值15需要O(n)时间

# ✅ 正确理解
# Heap只优化了"查找最小值"
# 查找任意元素需要遍历,O(n)
```

---

## 8. 一句话总结

**Heap的基本性质包括:完全二叉树结构保证O(log n)高度,heap性质(父≤子或父≥子)实现半有序,数组存储提供O(1)父子访问和缓存友好性,这三者结合使heap成为优先级队列的最优实现。**
