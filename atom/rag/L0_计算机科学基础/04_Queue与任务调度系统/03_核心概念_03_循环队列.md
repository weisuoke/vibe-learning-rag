# 核心概念：循环队列

## 概述

**循环队列使用固定大小数组和取模运算实现队列,通过空间复用避免数组移动,所有操作O(1)时间复杂度。**

---

## 定义与特性

### 核心定义

循环队列是一种特殊的队列实现,具有以下特性:
1. **固定大小**:数组长度固定,不动态扩容
2. **循环利用**:通过取模运算实现空间复用
3. **高效操作**:入队出队都是O(1)

### 关键概念

```python
class CircularQueue:
    def __init__(self, size):
        self.buffer = [None] * size
        self.head = 0  # 队首指针
        self.tail = 0  # 队尾指针
        self.size = size
        self.count = 0  # 当前元素数量

    # 关键:取模运算实现循环
    # next_index = (current_index + 1) % size
```

**为什么需要count?**
- 区分队列空和队列满
- 空:`count == 0`
- 满:`count == size`

---

## 实现方式

### 方式1:使用count计数

```python
class CircularQueue:
    """循环队列:使用count区分空满"""

    def __init__(self, size):
        self.buffer = [None] * size
        self.head = 0
        self.tail = 0
        self.size = size
        self.count = 0

    def enqueue(self, item):
        """入队:O(1)"""
        if self.is_full():
            raise Exception("队列已满")

        self.buffer[self.tail] = item
        self.tail = (self.tail + 1) % self.size
        self.count += 1

    def dequeue(self):
        """出队:O(1)"""
        if self.is_empty():
            raise Exception("队列为空")

        item = self.buffer[self.head]
        self.head = (self.head + 1) % self.size
        self.count -= 1
        return item

    def peek(self):
        """查看:O(1)"""
        if self.is_empty():
            raise Exception("队列为空")
        return self.buffer[self.head]

    def is_empty(self):
        """判空:O(1)"""
        return self.count == 0

    def is_full(self):
        """判满:O(1)"""
        return self.count == self.size

    def __len__(self):
        return self.count

# 测试
queue = CircularQueue(5)

# 入队
for i in range(5):
    queue.enqueue(i)

print(f"队列满:{queue.is_full()}")  # True

# 出队
print(queue.dequeue())  # 0
print(queue.dequeue())  # 1

# 再入队(循环利用空间)
queue.enqueue(5)
queue.enqueue(6)

print(f"队列满:{queue.is_full()}")  # True
```

### 方式2:预留一个空位

```python
class CircularQueueWithGap:
    """循环队列:预留一个空位区分空满"""

    def __init__(self, size):
        self.buffer = [None] * (size + 1)  # 多分配一个空间
        self.head = 0
        self.tail = 0
        self.size = size + 1

    def enqueue(self, item):
        """入队:O(1)"""
        if self.is_full():
            raise Exception("队列已满")

        self.buffer[self.tail] = item
        self.tail = (self.tail + 1) % self.size

    def dequeue(self):
        """出队:O(1)"""
        if self.is_empty():
            raise Exception("队列为空")

        item = self.buffer[self.head]
        self.head = (self.head + 1) % self.size
        return item

    def is_empty(self):
        """判空:head == tail"""
        return self.head == self.tail

    def is_full(self):
        """判满:(tail + 1) % size == head"""
        return (self.tail + 1) % self.size == self.head

    def __len__(self):
        return (self.tail - self.head + self.size) % self.size

# 测试
queue = CircularQueueWithGap(5)

for i in range(5):
    queue.enqueue(i)

print(f"队列满:{queue.is_full()}")  # True
```

**对比**:
- 方式1:需要额外的count变量
- 方式2:需要额外的空间,但判空判满更简单

### 方式3:动态扩容循环队列

```python
class DynamicCircularQueue:
    """动态扩容循环队列"""

    def __init__(self, initial_size=10):
        self.buffer = [None] * initial_size
        self.head = 0
        self.tail = 0
        self.size = initial_size
        self.count = 0

    def enqueue(self, item):
        """入队:满时自动扩容"""
        if self.is_full():
            self._resize(self.size * 2)

        self.buffer[self.tail] = item
        self.tail = (self.tail + 1) % self.size
        self.count += 1

    def dequeue(self):
        """出队:O(1)"""
        if self.is_empty():
            raise Exception("队列为空")

        item = self.buffer[self.head]
        self.head = (self.head + 1) % self.size
        self.count -= 1

        # 缩容:使用率低于25%时缩容
        if self.count > 0 and self.count < self.size // 4:
            self._resize(self.size // 2)

        return item

    def _resize(self, new_size):
        """扩容或缩容"""
        new_buffer = [None] * new_size

        # 复制元素到新数组
        for i in range(self.count):
            new_buffer[i] = self.buffer[(self.head + i) % self.size]

        self.buffer = new_buffer
        self.head = 0
        self.tail = self.count
        self.size = new_size

    def is_empty(self):
        return self.count == 0

    def is_full(self):
        return self.count == self.size

# 测试
queue = DynamicCircularQueue(initial_size=2)

# 自动扩容
for i in range(10):
    queue.enqueue(i)
    print(f"入队{i},容量:{queue.size}")

# 自动缩容
for i in range(8):
    queue.dequeue()
    print(f"出队,容量:{queue.size}")
```

---

## 图解循环队列

### 初始状态

```
数组:[_, _, _, _, _]
head: 0
tail: 0
count: 0
```

### 入队3个元素

```
数组:[0, 1, 2, _, _]
head: 0
tail: 3
count: 3
```

### 出队2个元素

```
数组:[_, _, 2, _, _]
head: 2
tail: 3
count: 1
```

### 再入队4个元素(循环)

```
数组:[3, 4, 2, _, _]  # 注意:3和4循环到数组开头
head: 2
tail: 2  # tail循环回到2
count: 5  # 队列满
```

### 关键:取模运算

```python
# 入队
tail = (tail + 1) % size
# 0 -> 1 -> 2 -> 3 -> 4 -> 0 -> 1 -> ...

# 出队
head = (head + 1) % size
# 0 -> 1 -> 2 -> 3 -> 4 -> 0 -> 1 -> ...
```

---

## AI Agent应用场景

### 场景1:流式响应缓冲

```python
import asyncio

class StreamBuffer:
    """LLM流式输出缓冲区"""

    def __init__(self, size=100):
        self.buffer = CircularQueue(size)
        self.lock = asyncio.Lock()

    async def push_token(self, token):
        """添加token"""
        async with self.lock:
            try:
                self.buffer.enqueue(token)
            except:
                # 队列满,丢弃最旧的token
                self.buffer.dequeue()
                self.buffer.enqueue(token)

    async def pop_token(self):
        """获取token"""
        async with self.lock:
            if not self.buffer.is_empty():
                return self.buffer.dequeue()
            return None

    async def get_recent_tokens(self, n=10):
        """获取最近n个token"""
        tokens = []
        async with self.lock:
            count = min(n, len(self.buffer))
            for _ in range(count):
                if not self.buffer.is_empty():
                    tokens.append(self.buffer.dequeue())
        return tokens

# 使用
async def main():
    buffer = StreamBuffer(size=50)

    # 模拟LLM流式输出
    async def llm_stream():
        for i in range(100):
            await buffer.push_token(f"token_{i}")
            await asyncio.sleep(0.01)

    # 模拟前端消费
    async def frontend_consume():
        while True:
            token = await buffer.pop_token()
            if token:
                print(f"前端显示:{token}")
            await asyncio.sleep(0.02)

    await asyncio.gather(
        llm_stream(),
        frontend_consume()
    )

asyncio.run(main())
```

### 场景2:日志缓冲区

```python
from datetime import datetime
from typing import List

class LogBuffer:
    """日志缓冲区:只保留最新N条日志"""

    def __init__(self, max_size=1000):
        self.buffer = CircularQueue(max_size)

    def log(self, level: str, message: str):
        """记录日志"""
        log_entry = {
            'timestamp': datetime.now(),
            'level': level,
            'message': message
        }

        try:
            self.buffer.enqueue(log_entry)
        except:
            # 队列满,丢弃最旧的日志
            self.buffer.dequeue()
            self.buffer.enqueue(log_entry)

    def get_recent_logs(self, n=100) -> List[dict]:
        """获取最近n条日志"""
        logs = []
        temp_queue = CircularQueue(self.buffer.size)

        # 复制日志到临时队列
        while not self.buffer.is_empty():
            log = self.buffer.dequeue()
            logs.append(log)
            temp_queue.enqueue(log)

        # 恢复原队列
        while not temp_queue.is_empty():
            self.buffer.enqueue(temp_queue.dequeue())

        return logs[-n:]

    def search_logs(self, keyword: str) -> List[dict]:
        """搜索日志"""
        results = []
        temp_queue = CircularQueue(self.buffer.size)

        while not self.buffer.is_empty():
            log = self.buffer.dequeue()
            if keyword in log['message']:
                results.append(log)
            temp_queue.enqueue(log)

        # 恢复原队列
        while not temp_queue.is_empty():
            self.buffer.enqueue(temp_queue.dequeue())

        return results

# 使用
log_buffer = LogBuffer(max_size=1000)

# 记录日志
log_buffer.log("INFO", "服务启动")
log_buffer.log("ERROR", "连接失败")
log_buffer.log("INFO", "重试连接")

# 获取最近日志
recent_logs = log_buffer.get_recent_logs(10)
for log in recent_logs:
    print(f"[{log['timestamp']}] {log['level']}: {log['message']}")

# 搜索日志
error_logs = log_buffer.search_logs("ERROR")
print(f"找到{len(error_logs)}条错误日志")
```

### 场景3:滑动窗口统计

```python
import time

class SlidingWindowCounter:
    """滑动窗口计数器"""

    def __init__(self, window_size=60):
        self.window_size = window_size
        self.buffer = CircularQueue(window_size)
        self.total = 0

    def add_event(self, value=1):
        """添加事件"""
        timestamp = time.time()

        # 移除过期事件
        self._remove_expired(timestamp)

        # 添加新事件
        try:
            self.buffer.enqueue((timestamp, value))
            self.total += value
        except:
            # 队列满,移除最旧的
            old_timestamp, old_value = self.buffer.dequeue()
            self.total -= old_value
            self.buffer.enqueue((timestamp, value))
            self.total += value

    def _remove_expired(self, current_time):
        """移除过期事件"""
        while not self.buffer.is_empty():
            timestamp, value = self.buffer.peek()
            if current_time - timestamp > self.window_size:
                self.buffer.dequeue()
                self.total -= value
            else:
                break

    def get_count(self):
        """获取窗口内事件总数"""
        self._remove_expired(time.time())
        return self.total

    def get_rate(self):
        """获取事件速率(每秒)"""
        return self.get_count() / self.window_size

# 使用:API请求速率统计
counter = SlidingWindowCounter(window_size=60)

# 模拟请求
for i in range(100):
    counter.add_event()
    time.sleep(0.1)

print(f"最近60秒请求数:{counter.get_count()}")
print(f"请求速率:{counter.get_rate():.2f}次/秒")
```

---

## 性能对比

### 时间复杂度

| 操作 | 普通队列(list) | 循环队列 |
|------|---------------|---------|
| 入队 | O(1) | O(1) |
| 出队 | O(n) | O(1) |
| 查看 | O(1) | O(1) |
| 判空 | O(1) | O(1) |
| 判满 | O(1) | O(1) |

### 空间复杂度

| 队列类型 | 空间复杂度 | 说明 |
|----------|-----------|------|
| 普通队列 | O(n) | 动态增长 |
| 循环队列 | O(k) | 固定大小k |

### 基准测试

```python
import time
from collections import deque

def benchmark_list_queue(n=10000):
    """普通列表队列"""
    queue = []
    start = time.time()

    for i in range(n):
        queue.append(i)

    for i in range(n):
        queue.pop(0)  # O(n)操作

    return time.time() - start

def benchmark_circular_queue(n=10000):
    """循环队列"""
    queue = CircularQueue(n)
    start = time.time()

    for i in range(n):
        queue.enqueue(i)

    for i in range(n):
        queue.dequeue()

    return time.time() - start

def benchmark_deque(n=10000):
    """deque队列"""
    queue = deque()
    start = time.time()

    for i in range(n):
        queue.append(i)

    for i in range(n):
        queue.popleft()

    return time.time() - start

# 运行测试
print(f"列表队列:{benchmark_list_queue():.4f}秒")
print(f"循环队列:{benchmark_circular_queue():.4f}秒")
print(f"deque队列:{benchmark_deque():.4f}秒")
```

**结果**(10000个元素):
```
列表队列:0.8234秒  # O(n²)
循环队列:0.0015秒  # O(n)
deque队列:0.0012秒  # O(n)
```

---

## 常见问题

### Q1:如何区分队列空和队列满?

**A**:三种方法

```python
# 方法1:使用count计数
class Method1:
    def __init__(self, size):
        self.count = 0
        self.size = size

    def is_empty(self):
        return self.count == 0

    def is_full(self):
        return self.count == self.size

# 方法2:预留一个空位
class Method2:
    def __init__(self, size):
        self.head = 0
        self.tail = 0
        self.size = size + 1

    def is_empty(self):
        return self.head == self.tail

    def is_full(self):
        return (self.tail + 1) % self.size == self.head

# 方法3:使用标志位
class Method3:
    def __init__(self, size):
        self.head = 0
        self.tail = 0
        self.size = size
        self.is_full_flag = False

    def is_empty(self):
        return self.head == self.tail and not self.is_full_flag

    def is_full(self):
        return self.head == self.tail and self.is_full_flag
```

### Q2:循环队列满时如何处理?

**A**:三种策略

```python
class FullQueueStrategy:
    """队列满时的处理策略"""

    def __init__(self, size, strategy='reject'):
        self.queue = CircularQueue(size)
        self.strategy = strategy

    def enqueue(self, item):
        if self.queue.is_full():
            if self.strategy == 'reject':
                # 策略1:拒绝新元素
                raise Exception("队列已满")

            elif self.strategy == 'overwrite':
                # 策略2:覆盖最旧元素
                self.queue.dequeue()
                self.queue.enqueue(item)

            elif self.strategy == 'expand':
                # 策略3:动态扩容
                self._expand()
                self.queue.enqueue(item)
        else:
            self.queue.enqueue(item)

    def _expand(self):
        """扩容"""
        new_size = self.queue.size * 2
        new_queue = CircularQueue(new_size)

        while not self.queue.is_empty():
            new_queue.enqueue(self.queue.dequeue())

        self.queue = new_queue
```

### Q3:如何实现线程安全的循环队列?

**A**:使用锁

```python
import threading

class ThreadSafeCircularQueue:
    """线程安全循环队列"""

    def __init__(self, size):
        self.queue = CircularQueue(size)
        self.lock = threading.Lock()
        self.not_empty = threading.Condition(self.lock)
        self.not_full = threading.Condition(self.lock)

    def enqueue(self, item, block=True, timeout=None):
        """入队"""
        with self.not_full:
            if not block:
                if self.queue.is_full():
                    raise Exception("队列已满")
            elif timeout is None:
                while self.queue.is_full():
                    self.not_full.wait()
            else:
                while self.queue.is_full():
                    if not self.not_full.wait(timeout):
                        raise Exception("超时")

            self.queue.enqueue(item)
            self.not_empty.notify()

    def dequeue(self, block=True, timeout=None):
        """出队"""
        with self.not_empty:
            if not block:
                if self.queue.is_empty():
                    raise Exception("队列为空")
            elif timeout is None:
                while self.queue.is_empty():
                    self.not_empty.wait()
            else:
                while self.queue.is_empty():
                    if not self.not_empty.wait(timeout):
                        raise Exception("超时")

            item = self.queue.dequeue()
            self.not_full.notify()
            return item
```

---

## 最佳实践

### 1.选择合适的大小

```python
# 根据使用场景选择大小
log_buffer = CircularQueue(1000)  # 日志缓冲
token_buffer = CircularQueue(100)  # Token缓冲
request_buffer = CircularQueue(10000)  # 请求缓冲
```

### 2.处理队列满的情况

```python
# 明确队列满时的策略
class SmartCircularQueue:
    def __init__(self, size, on_full='overwrite'):
        self.queue = CircularQueue(size)
        self.on_full = on_full

    def enqueue(self, item):
        if self.queue.is_full():
            if self.on_full == 'overwrite':
                self.queue.dequeue()  # 丢弃最旧
            elif self.on_full == 'reject':
                return False  # 拒绝新元素
            elif self.on_full == 'block':
                # 阻塞等待(需要配合线程)
                pass

        self.queue.enqueue(item)
        return True
```

### 3.监控队列使用率

```python
class MonitoredCircularQueue:
    """带监控的循环队列"""

    def __init__(self, size):
        self.queue = CircularQueue(size)
        self.enqueue_count = 0
        self.dequeue_count = 0
        self.overflow_count = 0

    def enqueue(self, item):
        self.enqueue_count += 1

        if self.queue.is_full():
            self.overflow_count += 1
            self.queue.dequeue()

        self.queue.enqueue(item)

    def dequeue(self):
        self.dequeue_count += 1
        return self.queue.dequeue()

    def get_metrics(self):
        return {
            'size': self.queue.size,
            'count': len(self.queue),
            'usage': len(self.queue) / self.queue.size,
            'enqueue_count': self.enqueue_count,
            'dequeue_count': self.dequeue_count,
            'overflow_count': self.overflow_count
        }
```

### 4.优雅处理边界情况

```python
class RobustCircularQueue:
    """健壮的循环队列"""

    def __init__(self, size):
        if size <= 0:
            raise ValueError("队列大小必须大于0")
        self.queue = CircularQueue(size)

    def enqueue(self, item):
        """入队:返回是否成功"""
        try:
            self.queue.enqueue(item)
            return True
        except:
            return False

    def dequeue(self):
        """出队:返回None而非抛出异常"""
        try:
            return self.queue.dequeue()
        except:
            return None

    def safe_peek(self):
        """安全查看"""
        try:
            return self.queue.peek()
        except:
            return None
```

---

## 总结

### 核心要点

1. **固定大小**:空间可控,适合缓冲场景
2. **取模运算**:实现循环利用
3. **O(1)操作**:所有操作都是常数时间
4. **队列满处理**:覆盖、拒绝、扩容三种策略

### 适用场景

| 场景 | 原因 |
|------|------|
| 流式缓冲 | 只关心最新数据 |
| 日志缓冲 | 固定大小,自动淘汰 |
| 滑动窗口 | 固定时间窗口统计 |
| 生产消费 | 速度匹配,内存可控 |

### 选择指南

```
需要固定大小?
├─ 是 → 可以丢弃旧数据?
│   ├─ 是 → 循环队列(覆盖策略)
│   └─ 否 → 有界队列(拒绝策略)
└─ 否 → 需要动态扩容?
    ├─ 是 → 动态循环队列
    └─ 否 → 普通队列(deque)
```

### 记忆口诀

**"固定大小循环用,取模运算空间省,队列满时三策略,覆盖拒绝或扩容"**

---

**关键洞察**:循环队列是用空间换时间的典型案例。在AI Agent开发中,循环队列特别适合流式响应缓冲、日志管理、滑动窗口统计等场景,因为这些场景只关心最新数据,可以接受丢弃旧数据。
