# 核心概念 03：执行模式详解

## 概述

**Sub-Agents 支持三种执行模式：Single（单代理）、Parallel（并行）、Chain（链式），满足不同的任务协作需求。**

---

## 1. Single Mode（单代理模式）

### 1.1 基本概念

**最简单的执行模式，委托单个任务给一个专用代理。**

```typescript
// 参数结构
{
  agent: "scout",
  task: "Find all authentication code",
  cwd: "/path/to/project"  // 可选
}
```

### 1.2 执行流程

```typescript
// 1. 用户请求
"Use scout to find authentication code"

// 2. 发现 agents
const agents = discoverAgents(ctx.cwd, agentScope);
const agent = agents.find(a => a.name === "scout");

// 3. 启动 Sub-Agent 进程
const proc = spawn('pi', [
  '--mode', 'json',
  '--model', agent.model,
  '--tools', agent.tools.join(','),
  '--no-session',
  `Task: Find all authentication code`
]);

// 4. 收集输出
proc.stdout.on('data', handleOutput);

// 5. 返回结果
return {
  content: [{ type: "text", text: finalOutput }],
  details: { mode: "single", results: [result] }
};
```

### 1.3 适用场景

| 场景 | 示例 |
|------|------|
| **快速侦查** | "Use scout to find error handling code" |
| **计划生成** | "Use planner to create refactoring plan" |
| **代码审查** | "Use reviewer to check this PR" |
| **单一任务** | 任何明确的单一任务 |

### 1.4 性能特征

```typescript
// 时间成本
启动开销: ~500ms - 1s
执行时间: 取决于任务复杂度
总时间: 启动 + 执行

// 资源成本
内存: ~50-100MB（单个进程）
API 调用: 1 个 agent 的 LLM 费用
```

---

## 2. Parallel Mode（并行模式）

### 2.1 基本概念

**同时执行多个独立任务，提高效率。**

```typescript
// 参数结构
{
  tasks: [
    { agent: "scout", task: "Find frontend code" },
    { agent: "scout", task: "Find backend code" },
    { agent: "scout", task: "Find database code" }
  ]
}
```

### 2.2 执行流程

```typescript
// 1. 验证任务数量
if (tasks.length > MAX_PARALLEL_TASKS) {
  return error("Too many tasks");
}

// 2. 并发执行（最多 4 个并发）
const results = await mapWithConcurrencyLimit(
  tasks,
  MAX_CONCURRENCY,  // 4
  async (task, index) => {
    return await runSingleAgent(...);
  }
);

// 3. 汇总结果
const summaries = results.map(r => {
  return `[${r.agent}] ${r.exitCode === 0 ? "completed" : "failed"}`;
});
```

### 2.3 并发控制

**限制**：
- 最多 8 个任务
- 最多 4 个并发执行
- 任务必须独立（无依赖）

```typescript
// 并发执行示例
任务1 ┐
任务2 ├→ 前 4 个并发
任务3 │
任务4 ┘
任务5 ┐
任务6 ├→ 后 4 个并发
任务7 │
任务8 ┘
```

### 2.4 适用场景

| 场景 | 示例 |
|------|------|
| **信息收集** | 并行搜索多个模块 |
| **多维度分析** | 同时分析前端、后端、数据库 |
| **独立任务** | 无依赖关系的任务 |

### 2.5 性能对比

```typescript
// 场景：3 个独立任务，每个 10 秒
Single Mode: 10 + 10 + 10 = 30 秒
Parallel Mode: max(10, 10, 10) + 启动开销 ≈ 12 秒

// 场景：3 个独立任务，每个 2 秒
Single Mode: 2 + 2 + 2 = 6 秒
Parallel Mode: max(2, 2, 2) + 启动开销 ≈ 5 秒
// 收益不明显
```

**何时使用 Parallel**：
- ✅ 任务数量 > 2
- ✅ 每个任务 > 5 秒
- ✅ 任务完全独立
- ❌ 短任务（开销大于收益）
- ❌ 有依赖关系（用 Chain）

---

## 3. Chain Mode（链式模式）

### 3.1 基本概念

**顺序执行多个任务，后续任务可以使用前面任务的输出。**

```typescript
// 参数结构
{
  chain: [
    {
      agent: "scout",
      task: "Find authentication code"
    },
    {
      agent: "planner",
      task: "Based on {previous}, create refactoring plan"
    },
    {
      agent: "worker",
      task: "Implement the plan: {previous}"
    }
  ]
}
```

### 3.2 执行流程

```typescript
// 1. 顺序执行
let previousOutput = "";

for (let i = 0; i < chain.length; i++) {
  const step = chain[i];

  // 2. 替换 {previous} 占位符
  const taskWithContext = step.task.replace(
    /\{previous\}/g,
    previousOutput
  );

  // 3. 执行当前步骤
  const result = await runSingleAgent(
    ctx.cwd,
    agents,
    step.agent,
    taskWithContext,
    step.cwd,
    i + 1,  // step number
    signal,
    onUpdate,
    makeDetails("chain")
  );

  // 4. 检查错误
  if (result.exitCode !== 0 || result.stopReason === "error") {
    return {
      content: [{
        type: "text",
        text: `Chain stopped at step ${i + 1}: ${errorMsg}`
      }],
      isError: true
    };
  }

  // 5. 提取输出作为下一步的输入
  previousOutput = getFinalOutput(result.messages);
}
```

### 3.3 {previous} 占位符

**关键特性**：
- `{previous}` 会被替换为上一步的最终文本输出
- **不包括**：工具调用、中间思考、完整上下文
- **只包括**：Assistant 的最后一条文本消息

```typescript
// Step 1: Scout 输出
"Found authentication code:
- File: src/auth.ts (lines 10-50)
- Functions: login(), verify(), refresh()
- Technology: JWT tokens"

// Step 2: Planner 接收的任务
"Based on Found authentication code:
- File: src/auth.ts (lines 10-50)
- Functions: login(), verify(), refresh()
- Technology: JWT tokens, create refactoring plan"
```

### 3.4 错误处理

**失败策略**：任何步骤失败，整个链停止。

```typescript
// 场景：3 步链，第 2 步失败
Step 1: Scout ✓ 成功
Step 2: Planner ✗ 失败（LLM 错误）
Step 3: Worker ⊘ 未执行

// 返回
{
  content: "Chain stopped at step 2 (planner): API rate limit",
  details: {
    mode: "chain",
    results: [step1Result, step2Result]  // 只有前 2 步
  },
  isError: true
}
```

### 3.5 适用场景

| 场景 | Chain 示例 |
|------|-----------|
| **侦查 → 计划 → 实现** | Scout → Planner → Worker |
| **实现 → 审查 → 修复** | Worker → Reviewer → Worker |
| **分析 → 设计 → 验证** | Analyzer → Designer → Validator |

### 3.6 最佳实践

**1. 输出格式设计**

```markdown
<!-- ✅ 好的输出：结构化、包含必要信息 -->
Step 1 (Scout) 输出：
"Authentication code found:
- File: src/auth.ts (lines 10-50)
- Functions: login(), verify(), refresh()
- Dependencies: jsonwebtoken, bcrypt
- Database: users table"

<!-- ❌ 不好的输出：太简略 -->
Step 1 (Scout) 输出：
"Found auth code"
```

**2. 任务描述清晰**

```typescript
// ✅ 好的任务描述
{
  agent: "planner",
  task: "Based on {previous}, create a detailed refactoring plan. " +
        "Include: 1) Files to modify, 2) New functions needed, " +
        "3) Migration steps, 4) Testing strategy."
}

// ❌ 不好的任务描述
{
  agent: "planner",
  task: "Create plan based on {previous}"
}
```

---

## 4. 模式对比

### 4.1 特性对比表

| 维度 | Single | Parallel | Chain |
|------|--------|----------|-------|
| **任务数量** | 1 | 2-8 | 2+ |
| **执行方式** | 单个 | 并发 | 顺序 |
| **任务依赖** | 无 | 无 | 有 |
| **上下文传递** | 无 | 无 | 有（{previous}） |
| **失败处理** | 直接返回 | 继续其他任务 | 停止整个链 |
| **适用场景** | 单一任务 | 独立任务 | 依赖任务 |
| **性能** | 基准 | 快（长任务） | 慢（顺序） |

### 4.2 选择决策树

```
任务数量 = 1？
  ├─ 是 → Single Mode
  └─ 否 → 任务之间有依赖？
      ├─ 是 → Chain Mode
      └─ 否 → 任务执行时间 > 5秒？
          ├─ 是 → Parallel Mode
          └─ 否 → Single Mode（逐个执行）
```

### 4.3 实际案例

**案例 1：代码重构**

```typescript
// 需求：重构认证系统
// 分析：侦查 → 计划 → 实现（有依赖）
// 选择：Chain Mode

{
  chain: [
    { agent: "scout", task: "Find all authentication code" },
    { agent: "planner", task: "Create refactoring plan for {previous}" },
    { agent: "worker", task: "Implement: {previous}" }
  ]
}
```

**案例 2：技术栈分析**

```typescript
// 需求：分析项目技术栈
// 分析：前端、后端、数据库（独立）
// 选择：Parallel Mode

{
  tasks: [
    { agent: "scout", task: "Analyze frontend tech stack" },
    { agent: "scout", task: "Analyze backend tech stack" },
    { agent: "scout", task: "Analyze database tech stack" }
  ]
}
```

**案例 3：快速侦查**

```typescript
// 需求：找到错误处理代码
// 分析：单一明确任务
// 选择：Single Mode

{
  agent: "scout",
  task: "Find all error handling code"
}
```

---

## 5. 2025-2026 业界模式对比

根据最新研究，业界主流执行模式：

[Source: The 2026 Guide to Agentic Workflow Architectures](https://www.stack-ai.com/blog/the-2026-guide-to-agentic-workflow-architectures)

| 模式 | 业界实现 | Pi-mono 对应 |
|------|---------|-------------|
| **Sequential Pipeline** | LangChain, CrewAI | Chain Mode |
| **Parallel Execution** | AutoGPT, BabyAGI | Parallel Mode |
| **Hierarchical** | Microsoft Agent Framework | 未实现 |
| **Event-Driven** | Confluent, Kafka | 未实现 |
| **Loop/Iterative** | ReAct, Reflexion | 未实现 |

[Source: Parallel Agent Processing](https://www.kore.ai/ai-insights/parallel-agent-processing)

**Pi-mono 的定位**：
- ✅ 覆盖核心模式（Sequential, Parallel）
- ✅ 简单易用（3 种模式）
- ⚠️ 未来可扩展（Hierarchical, Event-Driven）

---

## 6. 高级用法

### 6.1 混合模式（未来）

```typescript
// 概念：Chain 中嵌套 Parallel
{
  chain: [
    { agent: "scout", task: "Find code" },
    {
      // Parallel 步骤
      parallel: [
        { agent: "analyzer1", task: "Analyze frontend: {previous}" },
        { agent: "analyzer2", task: "Analyze backend: {previous}" }
      ]
    },
    { agent: "planner", task: "Create plan based on analyses" }
  ]
}
```

### 6.2 条件执行（未来）

```typescript
// 概念：根据结果选择下一步
{
  chain: [
    { agent: "scout", task: "Find auth code" },
    {
      condition: "if {previous} contains 'JWT'",
      then: { agent: "jwt-expert", task: "Analyze JWT implementation" },
      else: { agent: "oauth-expert", task: "Analyze OAuth implementation" }
    }
  ]
}
```

### 6.3 循环执行（未来）

```typescript
// 概念：重复执行直到满足条件
{
  loop: {
    agent: "optimizer",
    task: "Optimize code",
    until: "performance > 90%",
    maxIterations: 5
  }
}
```

---

## 7. 性能优化

### 7.1 Parallel Mode 优化

**1. 任务分组**

```typescript
// ❌ 不好：8 个小任务
{ tasks: [task1, task2, ..., task8] }
// 启动开销：8 * 1s = 8s

// ✅ 好：合并为 2 个大任务
{ tasks: [
  { agent: "scout", task: "Find A, B, C, D" },
  { agent: "scout", task: "Find E, F, G, H" }
]}
// 启动开销：2 * 1s = 2s
```

**2. 并发控制**

```typescript
// 当前：固定 4 个并发
MAX_CONCURRENCY = 4;

// 未来：动态调整
const concurrency = Math.min(
  tasks.length,
  availableMemory / 100MB,
  apiRateLimit
);
```

### 7.2 Chain Mode 优化

**1. 减少步骤**

```typescript
// ❌ 不好：过多步骤
{ chain: [step1, step2, step3, step4, step5] }
// 总时间：5 * 平均时间

// ✅ 好：合并步骤
{ chain: [
  { agent: "scout", task: "Find and analyze code" },
  { agent: "worker", task: "Implement based on {previous}" }
]}
// 总时间：2 * 平均时间
```

**2. 输出压缩**

```typescript
// ✅ 好：压缩输出
"Found 10 files. Key files:
- src/auth.ts: login(), verify()
- src/token.ts: generate(), validate()"

// ❌ 不好：冗长输出
"Found 10 files:
1. src/auth.ts (500 lines)
   - function login() { ... }
   - function verify() { ... }
   ..."
```

---

## 8. 故障排查

### 8.1 Parallel Mode 问题

**问题 1：任务未并行执行**

```typescript
// 原因：任务数量 < 2
{ tasks: [task1] }  // 只有 1 个任务

// 解决：至少 2 个任务
{ tasks: [task1, task2] }
```

**问题 2：部分任务失败**

```typescript
// Parallel Mode：部分失败不影响其他任务
结果：
- Task 1: ✓ 成功
- Task 2: ✗ 失败
- Task 3: ✓ 成功

// 返回：所有结果（包括失败的）
```

### 8.2 Chain Mode 问题

**问题 1：{previous} 为空**

```typescript
// 原因：上一步没有文本输出
Step 1 输出：（只有工具调用，没有文本）

// 解决：确保每步都有文本输出
Step 1 输出："Found 5 files: ..."
```

**问题 2：链中断**

```typescript
// 原因：某步失败
Step 2: ✗ LLM API 错误

// 解决：
1. 检查 API 配额
2. 重试失败的步骤
3. 简化任务描述
```

---

## 9. 总结

### 核心要点

1. **三种模式**：Single（单一）、Parallel（并行）、Chain（链式）
2. **选择原则**：根据任务依赖关系和执行时间选择
3. **性能权衡**：Parallel 有开销，短任务不适合
4. **Chain 关键**：`{previous}` 只传递文本输出
5. **业界对齐**：符合 2025-2026 主流模式

### 关键洞察

- **Single = 基础**：最简单、最可靠
- **Parallel = 效率**：长任务、独立任务
- **Chain = 协作**：依赖任务、上下文传递
- **未来演进**：混合模式、条件执行、循环执行

### 学习路径

1. ✅ 掌握三种执行模式的基本概念
2. ✅ 理解模式选择的决策逻辑
3. ✅ 了解性能特征和优化策略
4. → 深入学习进程隔离与上下文管理
5. → 探索代理间通信协议

---

**参考资源**：
- [The 2026 Guide to Agentic Workflow Architectures](https://www.stack-ai.com/blog/the-2026-guide-to-agentic-workflow-architectures)
- [Parallel Agent Processing](https://www.kore.ai/ai-insights/parallel-agent-processing)
- [Azure AI Agent Orchestration Patterns](https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns)
