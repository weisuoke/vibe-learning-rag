# 核心概念 04：路径重建技术

## 一句话定义

**路径重建是通过记录节点的父节点或前驱信息，在遍历完成后反向追溯构建从起点到终点的完整路径的技术。**

---

## 核心思想

**问题：** 遍历算法（BFS/DFS）可以找到目标节点，但如何知道是通过哪条路径到达的？

**解决方案：** 在遍历过程中记录每个节点是从哪个节点访问来的（父节点），遍历结束后反向追溯。

**类比：** 就像在迷宫中留下面包屑，找到出口后沿着面包屑原路返回。

---

## 基本技术

### 1. 父节点记录法（最常用）

```python
from collections import deque
from typing import Dict, List, Optional

def bfs_find_path(graph: Dict[str, List[str]], start: str, target: str) -> List[str]:
    """
    BFS 查找最短路径（父节点记录法）

    返回:
        从 start 到 target 的最短路径，如果不存在返回 []
    """
    if start == target:
        return [start]

    # 1. 初始化
    visited = {start}
    queue = deque([start])
    parent = {start: None}  # 记录每个节点的父节点

    # 2. BFS 搜索
    while queue:
        node = queue.popleft()

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = node  # 记录父节点
                queue.append(neighbor)

                # 3. 找到目标，重建路径
                if neighbor == target:
                    return reconstruct_path(parent, start, target)

    return []  # 未找到路径

def reconstruct_path(parent: Dict[str, Optional[str]], start: str, target: str) -> List[str]:
    """
    从父节点字典重建路径

    原理：从目标节点反向追溯到起点，然后反转
    """
    path = []
    current = target

    # 反向追溯
    while current is not None:
        path.append(current)
        current = parent[current]

    # 反转得到正向路径
    return path[::-1]
```

**关键点：**
1. **parent 字典**：`{节点: 父节点}`，记录访问关系
2. **反向追溯**：从目标节点开始，沿着父节点链回到起点
3. **反转路径**：追溯得到的是反向路径，需要反转

**可视化：**
```
图结构：
A → B → D
A → C → D

BFS 遍历：
访问 A：parent = {A: None}
访问 B：parent = {A: None, B: A}
访问 C：parent = {A: None, B: A, C: A}
访问 D（从 B）：parent = {A: None, B: A, C: A, D: B}

重建路径（从 D 到 A）：
D → parent[D] = B
B → parent[B] = A
A → parent[A] = None

反向路径：[D, B, A]
正向路径：[A, B, D]
```

---

### 2. 路径列表法（DFS 常用）

```python
def dfs_find_path(graph: Dict[str, List[str]], start: str, target: str) -> List[str]:
    """
    DFS 查找路径（路径列表法）

    返回:
        从 start 到 target 的一条路径（不保证最短）
    """
    def dfs_helper(node: str, target: str, visited: set, path: List[str]) -> bool:
        """
        递归辅助函数

        返回:
            是否找到目标节点
        """
        # 1. 添加当前节点到路径
        visited.add(node)
        path.append(node)

        # 2. 找到目标
        if node == target:
            return True

        # 3. 递归探索邻居
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs_helper(neighbor, target, visited, path):
                    return True  # 找到路径，停止搜索

        # 4. 回溯：移除当前节点
        path.pop()
        return False

    visited = set()
    path = []

    if dfs_helper(start, target, visited, path):
        return path
    return []
```

**关键点：**
1. **path 列表**：在递归过程中维护当前路径
2. **回溯机制**：如果当前路径不通，移除节点并尝试其他路径
3. **找到即停**：找到第一条路径就返回（不保证最短）

**回溯过程：**
```
图结构：
A → B → D（死胡同）
A → C → E（目标）

DFS 搜索：
1. path = [A]
2. path = [A, B]
3. path = [A, B, D]（死胡同）
4. 回溯：path = [A, B]
5. 回溯：path = [A]
6. path = [A, C]
7. path = [A, C, E]（找到目标）

最终路径：[A, C, E]
```

---

### 3. 距离记录法（带权重）

```python
def bfs_with_distance(graph: Dict[str, List[str]], start: str) -> Dict[str, int]:
    """
    BFS 记录每个节点到起点的距离

    返回:
        {节点: 距离} 字典
    """
    distance = {start: 0}
    queue = deque([start])

    while queue:
        node = queue.popleft()
        current_dist = distance[node]

        for neighbor in graph.get(node, []):
            if neighbor not in distance:
                distance[neighbor] = current_dist + 1
                queue.append(neighbor)

    return distance

def reconstruct_shortest_path(graph: Dict[str, List[str]], start: str, target: str) -> List[str]:
    """
    使用距离信息重建最短路径

    原理：从目标节点开始，每次选择距离减1的邻居
    """
    # 1. 计算所有节点的距离
    distance = bfs_with_distance(graph, start)

    if target not in distance:
        return []  # 不可达

    # 2. 从目标节点反向重建路径
    path = [target]
    current = target

    while current != start:
        # 找到距离减1的邻居
        for neighbor in graph.get(current, []):
            if neighbor in distance and distance[neighbor] == distance[current] - 1:
                path.append(neighbor)
                current = neighbor
                break

    return path[::-1]  # 反转
```

**优势：**
- 不需要额外的 parent 字典
- 可以用于有权重的图（Dijkstra 算法）

---

## 高级技术

### 1. 找所有路径（DFS 回溯）

```python
def find_all_paths(graph: Dict[str, List[str]], start: str, target: str) -> List[List[str]]:
    """
    找到从 start 到 target 的所有路径

    使用 DFS + 回溯
    """
    all_paths = []

    def dfs(node: str, path: List[str], visited: set):
        # 1. 添加当前节点
        path.append(node)
        visited.add(node)

        # 2. 找到目标，记录路径
        if node == target:
            all_paths.append(path[:])  # 复制路径
        else:
            # 3. 继续探索
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    dfs(neighbor, path, visited)

        # 4. 回溯
        path.pop()
        visited.remove(node)

    dfs(start, [], set())
    return all_paths
```

**示例：**
```python
graph = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': ['D'],
    'D': []
}

paths = find_all_paths(graph, 'A', 'D')
# 结果：[['A', 'B', 'D'], ['A', 'C', 'D']]
```

---

### 2. 找 K 条最短路径

```python
import heapq
from typing import List, Tuple

def find_k_shortest_paths(graph: Dict[str, List[str]], start: str, target: str, k: int) -> List[List[str]]:
    """
    找到 K 条最短路径

    使用优先队列（堆）+ BFS
    """
    # 优先队列：(路径长度, 路径)
    heap = [(0, [start])]
    shortest_paths = []

    while heap and len(shortest_paths) < k:
        length, path = heapq.heappop(heap)
        current = path[-1]

        # 找到目标
        if current == target:
            shortest_paths.append(path)
            continue

        # 扩展邻居
        for neighbor in graph.get(current, []):
            if neighbor not in path:  # 避免环
                new_path = path + [neighbor]
                heapq.heappush(heap, (length + 1, new_path))

    return shortest_paths
```

**应用场景：**
- 路由算法：找多条备用路径
- 推荐系统：提供多个选项
- RAG 系统：提供多条推理链

---

### 3. 双向路径重建

```python
def bidirectional_path(graph: Dict[str, List[str]], start: str, target: str) -> List[str]:
    """
    双向 BFS 查找最短路径

    优势：搜索空间减半
    """
    if start == target:
        return [start]

    # 前向搜索
    forward_parent = {start: None}
    forward_queue = deque([start])

    # 后向搜索
    backward_parent = {target: None}
    backward_queue = deque([target])

    while forward_queue and backward_queue:
        # 前向扩展
        if forward_queue:
            node = forward_queue.popleft()
            for neighbor in graph.get(node, []):
                if neighbor in backward_parent:
                    # 相遇！重建路径
                    return reconstruct_bidirectional_path(
                        forward_parent, backward_parent, node, neighbor
                    )
                if neighbor not in forward_parent:
                    forward_parent[neighbor] = node
                    forward_queue.append(neighbor)

        # 后向扩展
        if backward_queue:
            node = backward_queue.popleft()
            for neighbor in graph.get(node, []):
                if neighbor in forward_parent:
                    # 相遇！重建路径
                    return reconstruct_bidirectional_path(
                        forward_parent, backward_parent, neighbor, node
                    )
                if neighbor not in backward_parent:
                    backward_parent[neighbor] = node
                    backward_queue.append(neighbor)

    return []

def reconstruct_bidirectional_path(
    forward_parent: Dict[str, Optional[str]],
    backward_parent: Dict[str, Optional[str]],
    meet_forward: str,
    meet_backward: str
) -> List[str]:
    """
    重建双向搜索的路径

    原理：
    - 从相遇点向前追溯到起点
    - 从相遇点向后追溯到终点
    - 拼接两段路径
    """
    # 前半段路径（起点 → 相遇点）
    forward_path = []
    current = meet_forward
    while current is not None:
        forward_path.append(current)
        current = forward_parent[current]
    forward_path.reverse()

    # 后半段路径（相遇点 → 终点）
    backward_path = []
    current = meet_backward
    while current is not None:
        backward_path.append(current)
        current = backward_parent[current]

    # 拼接（去掉重复的相遇点）
    return forward_path + backward_path
```

---

## 在 RAG 中的应用

### 应用1：多跳推理路径重建

**场景：** 在知识图谱中找到从查询实体到答案实体的推理路径

```python
def multi_hop_reasoning_path(kg, query_entity: str, answer_entity: str) -> List[str]:
    """
    多跳推理路径重建

    应用：Multi-hop QA 系统
    """
    # BFS 查找最短推理路径
    visited = {query_entity}
    queue = deque([query_entity])
    parent = {query_entity: None}

    while queue:
        entity = queue.popleft()

        for neighbor in kg.get_neighbors(entity):
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = entity
                queue.append(neighbor)

                if neighbor == answer_entity:
                    # 重建推理路径
                    path = []
                    current = answer_entity
                    while current is not None:
                        path.append(current)
                        current = parent[current]
                    return path[::-1]

    return []

# 示例
# 查询："Einstein 的理论如何影响 GPS？"
# 推理路径：Einstein → 相对论 → 时空弯曲 → GPS技术
```

**来源：** KG2RAG (NAACL 2025) - https://arxiv.org/abs/2502.06864

---

### 应用2：证据链追溯

**场景：** 在 RAG 系统中追溯答案的证据来源

```python
def trace_evidence_chain(kg, answer_entity: str, source_docs: List[str]) -> List[List[str]]:
    """
    追溯答案的证据链

    应用：可解释 RAG 系统
    """
    evidence_chains = []

    for doc in source_docs:
        # 从答案实体反向追溯到源文档
        path = bfs_find_path(kg, doc, answer_entity)
        if path:
            evidence_chains.append(path)

    return evidence_chains

# 示例
# 答案："相对论影响了 GPS 技术"
# 证据链1：[文档A] → Einstein → 相对论 → GPS技术
# 证据链2：[文档B] → 时空弯曲 → GPS技术
```

---

### 应用3：推理链可视化

**场景：** 可视化多跳推理的路径

```python
def visualize_reasoning_path(kg, path: List[str]) -> str:
    """
    可视化推理路径

    应用：向用户展示推理过程
    """
    visualization = []

    for i in range(len(path) - 1):
        entity1 = path[i]
        entity2 = path[i + 1]

        # 获取两个实体之间的关系
        relation = kg.get_relation(entity1, entity2)

        visualization.append(f"{entity1} --[{relation}]--> {entity2}")

    return "\n".join(visualization)

# 示例输出：
# Einstein --[developed]--> 相对论
# 相对论 --[predicts]--> 时空弯曲
# 时空弯曲 --[affects]--> GPS技术
```

---

## 优化技巧

### 技巧1：路径压缩

**问题：** 路径太长，包含冗余节点

**解决方案：** 只保留关键节点

```python
def compress_path(kg, path: List[str], importance_threshold: float = 0.5) -> List[str]:
    """
    压缩路径，只保留重要节点

    原理：根据节点的重要性得分过滤
    """
    compressed = [path[0]]  # 保留起点

    for i in range(1, len(path) - 1):
        node = path[i]
        importance = kg.get_node_importance(node)

        if importance >= importance_threshold:
            compressed.append(node)

    compressed.append(path[-1])  # 保留终点
    return compressed
```

---

### 技巧2：路径去重

**问题：** 多条路径包含相同的子路径

**解决方案：** 识别并合并相同的子路径

```python
def deduplicate_paths(paths: List[List[str]]) -> List[List[str]]:
    """
    去除重复的路径

    原理：使用路径的字符串表示作为键
    """
    unique_paths = {}

    for path in paths:
        path_key = " -> ".join(path)
        if path_key not in unique_paths:
            unique_paths[path_key] = path

    return list(unique_paths.values())
```

---

### 技巧3：路径评分

**问题：** 如何选择最好的路径？

**解决方案：** 根据多个维度评分

```python
def score_path(kg, path: List[str]) -> float:
    """
    评估路径质量

    考虑因素：
    - 路径长度（越短越好）
    - 节点重要性（越重要越好）
    - 关系强度（越强越好）
    """
    # 1. 长度惩罚
    length_score = 1.0 / len(path)

    # 2. 节点重要性
    importance_score = sum(kg.get_node_importance(node) for node in path) / len(path)

    # 3. 关系强度
    relation_score = 0
    for i in range(len(path) - 1):
        relation_score += kg.get_relation_strength(path[i], path[i + 1])
    relation_score /= (len(path) - 1)

    # 综合得分
    return 0.3 * length_score + 0.4 * importance_score + 0.3 * relation_score

def select_best_path(kg, paths: List[List[str]]) -> List[str]:
    """选择得分最高的路径"""
    if not paths:
        return []

    best_path = max(paths, key=lambda p: score_path(kg, p))
    return best_path
```

---

## 常见问题

### 问题1：如何处理环？

**解决方案：** 使用 visited 集合避免重复访问

```python
def find_path_no_cycle(graph, start, target):
    """避免环的路径查找"""
    visited = {start}
    queue = deque([start])
    parent = {start: None}

    while queue:
        node = queue.popleft()

        for neighbor in graph[node]:
            if neighbor not in visited:  # 避免环
                visited.add(neighbor)
                parent[neighbor] = node
                queue.append(neighbor)

                if neighbor == target:
                    return reconstruct_path(parent, start, target)

    return []
```

---

### 问题2：如何找最短路径？

**解决方案：** 使用 BFS（保证最短）

```python
# ✅ BFS 保证最短路径
def shortest_path_bfs(graph, start, target):
    """BFS 找最短路径"""
    # ... BFS 实现 ...

# ❌ DFS 不保证最短路径
def path_dfs(graph, start, target):
    """DFS 找路径（不保证最短）"""
    # ... DFS 实现 ...
```

---

### 问题3：如何处理断开的图？

**解决方案：** 检查目标节点是否可达

```python
def find_path_safe(graph, start, target):
    """安全的路径查找（处理不可达情况）"""
    if start == target:
        return [start]

    visited = {start}
    queue = deque([start])
    parent = {start: None}

    while queue:
        node = queue.popleft()

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = node
                queue.append(neighbor)

                if neighbor == target:
                    return reconstruct_path(parent, start, target)

    # 目标不可达
    return []
```

---

## 性能对比

| 方法 | 空间复杂度 | 时间复杂度 | 优势 | 劣势 |
|------|-----------|-----------|------|------|
| 父节点记录 | O(V) | O(V + E) | 简单高效 | 需要额外空间 |
| 路径列表 | O(h) | O(V + E) | 空间效率高 | 只适合 DFS |
| 距离记录 | O(V) | O(V + E) | 可扩展到有权图 | 重建路径稍复杂 |
| 双向搜索 | O(V) | O(b^(d/2)) | 搜索空间减半 | 实现复杂 |

---

## 学习检查

理解了路径重建技术后，你应该能回答：

- [ ] 什么是父节点记录法？（记录每个节点的父节点，反向追溯）
- [ ] 如何重建路径？（从目标节点反向追溯到起点，然后反转）
- [ ] BFS 和 DFS 的路径重建有什么区别？（BFS 用父节点，DFS 用路径列表）
- [ ] 如何找所有路径？（DFS + 回溯）
- [ ] 路径重建在 RAG 中的应用？（多跳推理、证据链追溯）

---

## 下一步

学完路径重建技术后，建议继续学习：
1. `03_核心概念_05_图遍历优化.md` - 学习优化技巧
2. `03_核心概念_07_多跳推理路径.md` - 深入理解多跳推理
3. `07_实战代码_场景3_多跳推理系统.md` - 实践多跳推理

---

**版本：** v1.0
**最后更新：** 2026-02-14
**参考文献：**
- KG2RAG (NAACL 2025): https://arxiv.org/abs/2502.06864
