# 核心概念1：函数装饰器（基础装饰器模式）

> 理解最基础的装饰器形式，掌握闭包和高阶函数的应用

---

## 什么是函数装饰器？

**函数装饰器是接收函数作为参数，返回新函数的函数，是装饰器的最基础形式。**

---

## 基础结构

```python
def decorator(func):
    """装饰器函数"""
    def wrapper(*args, **kwargs):
        """包装函数（闭包）"""
        # 在原函数执行前做一些事情
        result = func(*args, **kwargs)
        # 在原函数执行后做一些事情
        return result
    return wrapper

@decorator
def my_function():
    pass

# 等价于：
# my_function = decorator(my_function)
```

**三个关键组成部分：**
1. **装饰器函数**（`decorator`）：接收函数作为参数
2. **包装函数**（`wrapper`）：实际被调用的函数，包装了原函数
3. **原函数**（`func`）：被装饰的函数

---

## 执行流程详解

```python
def log_decorator(func):
    print(f"[定义时] 装饰器执行，装饰函数: {func.__name__}")

    def wrapper(*args, **kwargs):
        print(f"[调用前] 准备调用 {func.__name__}")
        result = func(*args, **kwargs)
        print(f"[调用后] {func.__name__} 执行完毕")
        return result

    return wrapper

@log_decorator
def greet(name):
    print(f"Hello, {name}!")
    return f"Greeted {name}"

# 输出：[定义时] 装饰器执行，装饰函数: greet
# 注意：这是在函数定义时就执行了！

print("=" * 50)
result = greet("Alice")
# 输出：
# [调用前] 准备调用 greet
# Hello, Alice!
# [调用后] greet 执行完毕

print(f"返回值: {result}")
# 输出：返回值: Greeted Alice
```

**关键点：**
- **装饰器在定义时执行**（模块导入时）
- **wrapper 在调用时执行**（运行时）
- **原函数被 wrapper 包装**

---

## 为什么需要 `*args, **kwargs`？

```python
# ❌ 错误示例：不使用 *args, **kwargs
def bad_decorator(func):
    def wrapper():  # 没有参数
        return func()
    return wrapper

@bad_decorator
def add(a, b):
    return a + b

# add(1, 2)  # TypeError: wrapper() takes 0 positional arguments but 2 were given
```

```python
# ✅ 正确示例：使用 *args, **kwargs
def good_decorator(func):
    def wrapper(*args, **kwargs):  # 接收任意参数
        return func(*args, **kwargs)  # 传递给原函数
    return wrapper

@good_decorator
def add(a, b):
    return a + b

print(add(1, 2))  # 3 ✅
```

**`*args, **kwargs` 的作用：**
- `*args`：接收任意数量的位置参数
- `**kwargs`：接收任意数量的关键字参数
- 让装饰器可以装饰任何函数，无论参数是什么

---

## 闭包的作用

```python
def make_multiplier(factor):
    """装饰器工厂：根据 factor 创建不同的装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            return result * factor  # 访问外部变量 factor（闭包）
        return wrapper
    return decorator

@make_multiplier(2)
def get_price():
    return 100

print(get_price())  # 200

@make_multiplier(3)
def get_quantity():
    return 10

print(get_quantity())  # 30
```

**闭包的特点：**
- `wrapper` 可以访问 `decorator` 的变量（`func`）
- `decorator` 可以访问 `make_multiplier` 的变量（`factor`）
- 这就是闭包：内部函数可以访问外部函数的变量

---

## 实战示例1：计时装饰器

```python
import time
from functools import wraps

def timing(func):
    """计算函数执行时间的装饰器"""
    @wraps(func)  # 保留原函数的元信息
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} 执行时间: {end_time - start_time:.4f}秒")
        return result
    return wrapper

@timing
def slow_function():
    time.sleep(1)
    return "Done"

result = slow_function()
# 输出：slow_function 执行时间: 1.0012秒
print(result)  # Done
```

---

## 实战示例2：日志装饰器

```python
from functools import wraps
from datetime import datetime

def log(func):
    """记录函数调用的装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        # 记录调用信息
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] 调用 {func.__name__}")
        print(f"  参数: args={args}, kwargs={kwargs}")

        # 执行函数
        try:
            result = func(*args, **kwargs)
            print(f"  返回: {result}")
            return result
        except Exception as e:
            print(f"  异常: {e}")
            raise

    return wrapper

@log
def divide(a, b):
    return a / b

divide(10, 2)
# 输出：
# [2026-02-11 13:15:30] 调用 divide
#   参数: args=(10, 2), kwargs={}
#   返回: 5.0

divide(10, 0)
# 输出：
# [2026-02-11 13:15:31] 调用 divide
#   参数: args=(10, 0), kwargs={}
#   异常: division by zero
# ZeroDivisionError: division by zero
```

---

## 实战示例3：缓存装饰器

```python
from functools import wraps

def cache(func):
    """简单的缓存装饰器"""
    cached_results = {}  # 闭包变量：存储缓存

    @wraps(func)
    def wrapper(*args):
        if args in cached_results:
            print(f"缓存命中: {args}")
            return cached_results[args]

        print(f"计算结果: {args}")
        result = func(*args)
        cached_results[args] = result
        return result

    return wrapper

@cache
def fibonacci(n):
    """计算斐波那契数列"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(5))
# 输出：
# 计算结果: (5,)
# 计算结果: (4,)
# 计算结果: (3,)
# 计算结果: (2,)
# 计算结果: (1,)
# 计算结果: (0,)
# 缓存命中: (1,)
# 缓存命中: (2,)
# 缓存命中: (3,)
# 5

print(fibonacci(5))  # 第二次调用
# 输出：缓存命中: (5,)
# 5
```

---

## `functools.wraps` 的重要性

```python
from functools import wraps

# ❌ 不使用 @wraps
def bad_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@bad_decorator
def my_function():
    """这是我的函数"""
    pass

print(my_function.__name__)  # wrapper（错误！）
print(my_function.__doc__)   # None（丢失了文档字符串！）
```

```python
# ✅ 使用 @wraps
def good_decorator(func):
    @wraps(func)  # 保留原函数的元信息
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@good_decorator
def my_function():
    """这是我的函数"""
    pass

print(my_function.__name__)  # my_function（正确！）
print(my_function.__doc__)   # 这是我的函数（保留了！）
```

**`@wraps(func)` 的作用：**
- 保留原函数的 `__name__`
- 保留原函数的 `__doc__`
- 保留原函数的 `__module__`
- 保留原函数的 `__annotations__`

**为什么重要？**
- 调试时能看到正确的函数名
- 文档生成工具能获取正确的文档
- 类型检查工具能获取正确的类型注解

---

## 多个装饰器的执行顺序

```python
def decorator_a(func):
    print("A: 装饰器执行")
    def wrapper(*args, **kwargs):
        print("A: 调用前")
        result = func(*args, **kwargs)
        print("A: 调用后")
        return result
    return wrapper

def decorator_b(func):
    print("B: 装饰器执行")
    def wrapper(*args, **kwargs):
        print("B: 调用前")
        result = func(*args, **kwargs)
        print("B: 调用后")
        return result
    return wrapper

@decorator_a
@decorator_b
def my_function():
    print("函数执行")

# 定义时输出：
# B: 装饰器执行
# A: 装饰器执行

print("=" * 50)
my_function()
# 调用时输出：
# A: 调用前
# B: 调用前
# 函数执行
# B: 调用后
# A: 调用后
```

**执行顺序：**
- **定义时**：从下到上（B → A）
- **调用时**：从上到下（A → B → 函数 → B → A）

**等价于：**
```python
my_function = decorator_a(decorator_b(my_function))
```

---

## 在 FastAPI 中的应用

```python
from fastapi import FastAPI

app = FastAPI()

# FastAPI 的路由装饰器就是函数装饰器
@app.get("/users")
def get_users():
    return [{"id": 1, "name": "Alice"}]

# 等价于：
# def get_users():
#     return [{"id": 1, "name": "Alice"}]
# get_users = app.get("/users")(get_users)
```

**FastAPI 装饰器的简化实现：**

```python
class FastAPI:
    def __init__(self):
        self.routes = {}

    def get(self, path: str):
        """路由装饰器工厂"""
        def decorator(func):
            # 注册路由
            self.routes[path] = {"method": "GET", "handler": func}
            return func  # 返回原函数（不包装）
        return decorator

app = FastAPI()

@app.get("/users")
def get_users():
    return [{"id": 1, "name": "Alice"}]

# 装饰器执行后：
# app.routes = {"/users": {"method": "GET", "handler": get_users}}
```

---

## 常见错误

### 错误1：忘记返回 wrapper

```python
# ❌ 错误
def bad_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    # 忘记返回 wrapper！

@bad_decorator
def my_function():
    pass

# my_function()  # TypeError: 'NoneType' object is not callable
```

### 错误2：忘记调用原函数

```python
# ❌ 错误
def bad_decorator(func):
    def wrapper(*args, **kwargs):
        print("Before")
        # 忘记调用 func()！
        print("After")
    return wrapper

@bad_decorator
def get_value():
    return 42

result = get_value()
print(result)  # None（错误！应该是 42）
```

### 错误3：忘记返回结果

```python
# ❌ 错误
def bad_decorator(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        # 忘记返回 result！
    return wrapper

@bad_decorator
def add(a, b):
    return a + b

result = add(1, 2)
print(result)  # None（错误！应该是 3）
```

---

## 总结

**函数装饰器的核心要点：**

1. **本质**：高阶函数 + 闭包
2. **结构**：装饰器函数 → 包装函数 → 原函数
3. **执行时机**：定义时执行装饰器，调用时执行 wrapper
4. **参数传递**：使用 `*args, **kwargs` 接收任意参数
5. **元信息保留**：使用 `@wraps(func)` 保留原函数信息
6. **多装饰器**：定义时从下到上，调用时从上到下

**在 AI Agent 开发中的应用：**
- FastAPI 路由定义
- 日志记录
- 性能监控
- 错误处理
- 权限检查

**下一步学习：**
- 核心概念2：带参数的装饰器（装饰器工厂）
- 核心概念3：类装饰器（基于类的装饰器）
