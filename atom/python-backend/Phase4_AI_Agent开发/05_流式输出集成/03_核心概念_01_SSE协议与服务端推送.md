# 核心概念01: SSE协议与服务端推送

> 深入理解 Server-Sent Events 协议和服务端推送机制

---

## 概述

**SSE (Server-Sent Events)** 是 HTML5 标准的服务端推送协议,允许服务端主动向客户端推送数据。它是流式输出集成的基础协议。

**本节目标:**
- 理解 SSE 协议的格式和规范
- 对比 SSE、WebSocket、长轮询的区别
- 手写 SSE 服务器实现
- 掌握浏览器 EventSource API

---

## 1. SSE 协议详解

### 1.1 SSE 是什么?

**SSE = Server-Sent Events = 服务端发送事件**

```
客户端 ----HTTP请求----> 服务端
客户端 <---持续推送---- 服务端 (保持连接打开)
```

**核心特点:**
1. **基于 HTTP**: 不需要新协议,就是特殊的 HTTP 响应
2. **单向推送**: 只能服务端 → 客户端
3. **自动重连**: 浏览器自动处理重连
4. **文本格式**: 传输文本数据,不支持二进制

### 1.2 SSE 协议格式

**SSE 响应的 HTTP 头:**

```http
HTTP/1.1 200 OK
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
```

**关键点:**
- `Content-Type: text/event-stream` - 标识这是 SSE 响应
- `Cache-Control: no-cache` - 禁止缓存
- `Connection: keep-alive` - 保持连接打开

**SSE 消息格式:**

```
field: value\n
field: value\n
\n
```

**四种字段类型:**

1. **data** - 消息内容
```
data: Hello World\n\n
```

2. **event** - 事件类型
```
event: message\n
data: Hello\n\n
```

3. **id** - 事件ID (用于断点续传)
```
id: 123\n
data: Hello\n\n
```

4. **retry** - 重连间隔 (毫秒)
```
retry: 3000\n\n
```

**完整示例:**

```
id: 1\n
event: message\n
data: First message\n
\n
id: 2\n
event: message\n
data: Second message\n
\n
id: 3\n
event: error\n
data: {"error": "Something went wrong"}\n
\n
```

### 1.3 SSE 消息解析规则

**规则1: 每条消息以空行结束**

```
data: Message 1\n
\n              ← 空行,消息结束
data: Message 2\n
\n              ← 空行,消息结束
```

**规则2: 多行 data 会被合并**

```
data: Line 1\n
data: Line 2\n
data: Line 3\n
\n
```

浏览器接收到的是:
```
Line 1\nLine 2\nLine 3
```

**规则3: 注释行以冒号开头**

```
: This is a comment\n
data: Hello\n
\n
```

注释行会被忽略,常用于保持连接活跃(心跳)。

**规则4: 字段名和值之间可以有空格**

```
data: Hello\n      ← 正确
data:Hello\n       ← 也正确
data : Hello\n     ← 也正确
```

---

## 2. SSE vs WebSocket vs 长轮询

### 2.1 三种技术对比

| 特性 | SSE | WebSocket | 长轮询 |
|------|-----|-----------|--------|
| **协议** | HTTP | 独立协议(ws://) | HTTP |
| **通信方向** | 单向(服务端→客户端) | 双向(服务端↔客户端) | 单向(客户端→服务端) |
| **连接** | 长连接 | 长连接 | 短连接(每次请求) |
| **浏览器支持** | 原生 EventSource | 原生 WebSocket | 原生 fetch |
| **重连** | 自动 | 需要手动实现 | 需要手动实现 |
| **数据格式** | 文本 | 文本+二进制 | 任意 |
| **防火墙** | 友好(HTTP) | 可能被阻止 | 友好(HTTP) |
| **复杂度** | 低 | 中 | 低 |
| **适用场景** | AI流式输出、通知 | 聊天、游戏、协作 | 简单轮询 |

### 2.2 长轮询 (Long Polling)

**原理:**

```javascript
// 客户端发送请求,服务端有数据才返回
function longPoll() {
    fetch('/api/poll')
        .then(res => res.json())
        .then(data => {
            console.log(data);
            longPoll();  // 继续轮询
        });
}
```

**问题:**
- 每次都要重新建立连接
- 服务端压力大
- 延迟高

### 2.3 SSE (Server-Sent Events)

**原理:**

```javascript
// 建立一次连接,服务端持续推送
const eventSource = new EventSource('/api/stream');
eventSource.onmessage = (event) => {
    console.log(event.data);
};
```

**优势:**
- 连接保持打开,无需重复建立
- 自动重连
- 浏览器原生支持

### 2.4 WebSocket

**原理:**

```javascript
// 双向通信
const ws = new WebSocket('ws://localhost:8000');
ws.onmessage = (event) => {
    console.log(event.data);
};
ws.send('Hello');  // 客户端也可以发送
```

**优势:**
- 双向通信
- 更低延迟
- 支持二进制数据

**劣势:**
- 更复杂
- 需要手动实现重连
- 可能被防火墙阻止

### 2.5 选择建议

**使用 SSE 的场景:**
- ✅ AI 流式输出 (单向推送)
- ✅ 实时通知 (服务端推送)
- ✅ 日志流式显示
- ✅ 进度条更新

**使用 WebSocket 的场景:**
- ✅ 聊天应用 (双向通信)
- ✅ 多人游戏 (实时同步)
- ✅ 协作编辑 (实时同步)
- ✅ 需要二进制数据传输

**使用长轮询的场景:**
- ✅ 简单的状态查询
- ✅ 不支持 SSE/WebSocket 的环境
- ✅ 低频率更新

---

## 3. 手写 SSE 服务器

### 3.1 纯 Python 实现

```python
"""
手写 SSE 服务器 (不使用任何框架)
演示 SSE 协议的核心原理
"""

from http.server import BaseHTTPRequestHandler, HTTPServer
import time
import json

class SSEHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/stream':
            self.send_sse_stream()
        else:
            self.send_response(404)
            self.end_headers()

    def send_sse_stream(self):
        """发送 SSE 流式响应"""
        # 1. 发送 SSE 响应头
        self.send_response(200)
        self.send_header('Content-Type', 'text/event-stream')
        self.send_header('Cache-Control', 'no-cache')
        self.send_header('Connection', 'keep-alive')
        self.send_header('Access-Control-Allow-Origin', '*')  # CORS
        self.end_headers()

        # 2. 发送 SSE 消息
        try:
            for i in range(10):
                # 构造 SSE 消息
                message = f"data: Message {i}\n\n"

                # 发送消息
                self.wfile.write(message.encode('utf-8'))
                self.wfile.flush()  # 立即发送,不缓存

                # 模拟延迟
                time.sleep(1)

            # 3. 发送完成事件
            self.wfile.write(b"event: done\ndata: Stream completed\n\n")
            self.wfile.flush()

        except BrokenPipeError:
            # 客户端断开连接
            print("Client disconnected")

# 启动服务器
if __name__ == '__main__':
    server = HTTPServer(('localhost', 8000), SSEHandler)
    print("SSE Server running on http://localhost:8000")
    server.serve_forever()
```

**测试:**

```bash
# 启动服务器
python sse_server.py

# 在浏览器中打开
# http://localhost:8000/stream

# 或使用 curl 测试
curl -N http://localhost:8000/stream
```

**输出:**
```
data: Message 0

data: Message 1

data: Message 2

...
```

### 3.2 FastAPI 实现

```python
"""
FastAPI 实现 SSE 服务器
使用 StreamingResponse 简化开发
"""

from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import asyncio
import json

app = FastAPI()

@app.get("/stream")
async def stream_endpoint():
    """基础 SSE 流式端点"""
    async def generate():
        for i in range(10):
            # SSE 格式: data: 内容\n\n
            yield f"data: Message {i}\n\n"
            await asyncio.sleep(1)

        # 发送完成事件
        yield f"event: done\ndata: Stream completed\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )

@app.get("/stream-json")
async def stream_json():
    """流式发送 JSON 数据"""
    async def generate():
        for i in range(10):
            data = {
                "id": i,
                "message": f"Message {i}",
                "timestamp": time.time()
            }
            # 将 JSON 转换为字符串
            yield f"data: {json.dumps(data)}\n\n"
            await asyncio.sleep(1)

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )

@app.get("/stream-events")
async def stream_events():
    """流式发送不同类型的事件"""
    async def generate():
        # 设置重连间隔
        yield "retry: 3000\n\n"

        # 发送不同类型的事件
        for i in range(5):
            # 普通消息
            yield f"id: {i}\nevent: message\ndata: Message {i}\n\n"
            await asyncio.sleep(1)

        # 发送警告事件
        yield f"event: warning\ndata: This is a warning\n\n"
        await asyncio.sleep(1)

        # 发送错误事件
        yield f"event: error\ndata: This is an error\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )

# 运行: uvicorn main:app --reload
```

### 3.3 带错误处理的实现

```python
"""
生产级 SSE 实现
包含错误处理、心跳、超时等
"""

from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import asyncio
import json
import time

app = FastAPI()

@app.get("/stream-robust")
async def stream_robust():
    """生产级 SSE 流式端点"""
    async def generate():
        try:
            # 1. 设置重连间隔
            yield "retry: 3000\n\n"

            # 2. 发送初始化事件
            yield f"event: init\ndata: {json.dumps({'status': 'connected'})}\n\n"

            # 3. 流式发送数据
            for i in range(100):
                # 模拟可能出错的操作
                if i == 50:
                    raise Exception("Simulated error")

                # 发送数据
                data = {
                    "id": i,
                    "message": f"Message {i}",
                    "timestamp": time.time()
                }
                yield f"id: {i}\ndata: {json.dumps(data)}\n\n"

                # 每10条消息发送一次心跳
                if i % 10 == 0:
                    yield ": heartbeat\n\n"

                await asyncio.sleep(0.5)

            # 4. 发送完成事件
            yield f"event: done\ndata: {json.dumps({'status': 'completed'})}\n\n"

        except Exception as e:
            # 5. 发送错误事件
            error_data = {
                "error": str(e),
                "timestamp": time.time()
            }
            yield f"event: error\ndata: {json.dumps(error_data)}\n\n"

        finally:
            # 6. 清理资源
            print("Stream closed")

    return StreamingResponse(
        generate(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no"  # 禁用 Nginx 缓冲
        }
    )
```

---

## 4. 浏览器 EventSource API

### 4.1 基础用法

```javascript
/**
 * EventSource 基础用法
 */

// 1. 创建 EventSource 连接
const eventSource = new EventSource('http://localhost:8000/stream');

// 2. 监听消息事件
eventSource.onmessage = (event) => {
    console.log('收到消息:', event.data);
};

// 3. 监听连接打开事件
eventSource.onopen = () => {
    console.log('连接已打开');
};

// 4. 监听错误事件
eventSource.onerror = (error) => {
    console.error('连接错误:', error);
    // EventSource 会自动重连
};

// 5. 手动关闭连接
// eventSource.close();
```

### 4.2 监听自定义事件

```javascript
/**
 * 监听自定义事件类型
 */

const eventSource = new EventSource('http://localhost:8000/stream-events');

// 监听 message 事件
eventSource.addEventListener('message', (event) => {
    console.log('Message:', event.data);
});

// 监听 warning 事件
eventSource.addEventListener('warning', (event) => {
    console.warn('Warning:', event.data);
});

// 监听 error 事件
eventSource.addEventListener('error', (event) => {
    console.error('Error:', event.data);
});

// 监听 done 事件
eventSource.addEventListener('done', (event) => {
    console.log('Done:', event.data);
    eventSource.close();  // 关闭连接
});
```

### 4.3 处理 JSON 数据

```javascript
/**
 * 处理 JSON 格式的 SSE 数据
 */

const eventSource = new EventSource('http://localhost:8000/stream-json');

eventSource.onmessage = (event) => {
    try {
        // 解析 JSON 数据
        const data = JSON.parse(event.data);
        console.log('ID:', data.id);
        console.log('Message:', data.message);
        console.log('Timestamp:', data.timestamp);
    } catch (error) {
        console.error('JSON 解析失败:', error);
    }
};
```

### 4.4 断点续传 (Last-Event-ID)

```javascript
/**
 * 使用 Last-Event-ID 实现断点续传
 */

const eventSource = new EventSource('http://localhost:8000/stream');

eventSource.onmessage = (event) => {
    console.log('ID:', event.lastEventId);  // 最后接收的事件 ID
    console.log('Data:', event.data);

    // 保存最后的事件 ID
    localStorage.setItem('lastEventId', event.lastEventId);
};

eventSource.onerror = () => {
    // 重连时,浏览器会自动发送 Last-Event-ID 请求头
    // 服务端可以从这个 ID 继续发送数据
    console.log('重连中...');
};
```

**服务端处理 Last-Event-ID:**

```python
from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse

app = FastAPI()

@app.get("/stream")
async def stream(request: Request):
    """支持断点续传的 SSE 端点"""
    # 获取客户端的 Last-Event-ID
    last_event_id = request.headers.get('Last-Event-ID', '0')
    start_id = int(last_event_id) + 1

    async def generate():
        # 从 start_id 开始发送数据
        for i in range(start_id, 100):
            yield f"id: {i}\ndata: Message {i}\n\n"
            await asyncio.sleep(1)

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

### 4.5 EventSource 的限制

**限制1: 只支持 GET 请求**

```javascript
// ❌ 无法发送 POST 请求
const eventSource = new EventSource('http://localhost:8000/stream', {
    method: 'POST',  // 不支持
    body: JSON.stringify({message: 'Hello'})  // 不支持
});

// ✅ 解决方案: 使用 URL 参数
const eventSource = new EventSource(
    'http://localhost:8000/stream?message=Hello'
);
```

**限制2: 无法自定义请求头**

```javascript
// ❌ 无法添加自定义请求头
const eventSource = new EventSource('http://localhost:8000/stream', {
    headers: {  // 不支持
        'Authorization': 'Bearer token'
    }
});

// ✅ 解决方案1: 使用 URL 参数传递 token
const eventSource = new EventSource(
    'http://localhost:8000/stream?token=your_token'
);

// ✅ 解决方案2: 使用 fetch + ReadableStream
const response = await fetch('http://localhost:8000/stream', {
    headers: {
        'Authorization': 'Bearer token'
    }
});

const reader = response.body.getReader();
const decoder = new TextDecoder();

while (true) {
    const {done, value} = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value);
    // 手动解析 SSE 格式
    const lines = chunk.split('\n');
    for (const line of lines) {
        if (line.startsWith('data: ')) {
            const data = line.slice(6);
            console.log(data);
        }
    }
}
```

**限制3: 同域限制 (需要 CORS)**

```python
# 服务端需要设置 CORS 头
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 允许所有域名
    allow_methods=["*"],
    allow_headers=["*"],
)
```

---

## 5. SSE 的高级特性

### 5.1 心跳机制

**为什么需要心跳?**
- 保持连接活跃
- 检测连接是否断开
- 避免代理服务器超时关闭连接

**实现心跳:**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import asyncio

app = FastAPI()

@app.get("/stream-heartbeat")
async def stream_heartbeat():
    """带心跳的 SSE 流式端点"""
    async def generate():
        last_heartbeat = time.time()

        for i in range(100):
            # 发送数据
            yield f"data: Message {i}\n\n"
            await asyncio.sleep(1)

            # 每30秒发送一次心跳
            if time.time() - last_heartbeat > 30:
                yield ": heartbeat\n\n"  # 注释行作为心跳
                last_heartbeat = time.time()

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

### 5.2 多行数据

**发送多行数据:**

```python
async def generate():
    # 多行 data 会被合并
    yield "data: Line 1\n"
    yield "data: Line 2\n"
    yield "data: Line 3\n"
    yield "\n"  # 空行结束消息
```

**客户端接收:**
```javascript
eventSource.onmessage = (event) => {
    console.log(event.data);  // "Line 1\nLine 2\nLine 3"
};
```

### 5.3 重连控制

**服务端设置重连间隔:**

```python
async def generate():
    # 设置重连间隔为 5 秒
    yield "retry: 5000\n\n"

    # 发送数据...
```

**客户端检测重连:**

```javascript
const eventSource = new EventSource('http://localhost:8000/stream');

let reconnectCount = 0;

eventSource.onerror = () => {
    reconnectCount++;
    console.log(`重连次数: ${reconnectCount}`);

    // 超过 5 次重连失败,停止重连
    if (reconnectCount > 5) {
        eventSource.close();
        console.log('停止重连');
    }
};

eventSource.onopen = () => {
    // 连接成功,重置重连计数
    reconnectCount = 0;
};
```

---

## 6. SSE 的常见问题

### 问题1: 浏览器连接数限制

**问题:** 浏览器对同一域名的 SSE 连接数有限制 (通常是 6 个)

**解决方案:**
1. 使用不同的子域名
2. 复用同一个 SSE 连接
3. 使用 HTTP/2 (连接数限制更高)

### 问题2: 代理服务器缓冲

**问题:** Nginx 等代理服务器可能缓冲 SSE 响应,导致延迟

**解决方案:**

```python
# FastAPI 响应头
return StreamingResponse(
    generate(),
    media_type="text/event-stream",
    headers={
        "X-Accel-Buffering": "no"  # 禁用 Nginx 缓冲
    }
)
```

```nginx
# Nginx 配置
location /stream {
    proxy_pass http://backend;
    proxy_buffering off;  # 禁用缓冲
    proxy_cache off;      # 禁用缓存
    proxy_set_header Connection '';
    proxy_http_version 1.1;
    chunked_transfer_encoding off;
}
```

### 问题3: 移动网络断线

**问题:** 移动网络不稳定,SSE 连接经常断开

**解决方案:**
1. 使用心跳检测连接状态
2. 使用 Last-Event-ID 实现断点续传
3. 客户端检测重连次数,避免无限重连

---

## 7. 实战示例

### 示例1: 实时日志流式显示

```python
"""
实时日志流式显示
"""

from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import asyncio

app = FastAPI()

@app.get("/logs")
async def stream_logs():
    """流式显示日志"""
    async def generate():
        # 模拟读取日志文件
        with open("/var/log/app.log") as f:
            # 跳到文件末尾
            f.seek(0, 2)

            while True:
                line = f.readline()
                if line:
                    # 发送日志行
                    yield f"data: {line}\n\n"
                else:
                    # 没有新日志,等待
                    await asyncio.sleep(0.1)

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

### 示例2: 进度条更新

```python
"""
进度条更新
"""

from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import asyncio
import json

app = FastAPI()

@app.get("/progress")
async def stream_progress():
    """流式更新进度"""
    async def generate():
        total = 100

        for i in range(total + 1):
            # 模拟耗时操作
            await asyncio.sleep(0.1)

            # 发送进度
            progress = {
                "current": i,
                "total": total,
                "percentage": i / total * 100,
                "message": f"Processing {i}/{total}"
            }
            yield f"data: {json.dumps(progress)}\n\n"

        # 发送完成事件
        yield f"event: done\ndata: {json.dumps({'status': 'completed'})}\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

**前端接收:**

```javascript
const eventSource = new EventSource('http://localhost:8000/progress');

eventSource.onmessage = (event) => {
    const progress = JSON.parse(event.data);
    console.log(`进度: ${progress.percentage}%`);

    // 更新进度条
    document.getElementById('progress-bar').style.width = `${progress.percentage}%`;
    document.getElementById('progress-text').textContent = progress.message;
};

eventSource.addEventListener('done', () => {
    console.log('任务完成');
    eventSource.close();
});
```

---

## 总结

**SSE 协议的核心要点:**

1. **协议格式**: `data: 内容\n\n`
2. **四种字段**: data、event、id、retry
3. **自动重连**: 浏览器自动处理
4. **断点续传**: 使用 Last-Event-ID

**SSE vs WebSocket:**
- SSE: 单向推送,简单稳定,适合 AI 流式输出
- WebSocket: 双向通信,复杂强大,适合聊天游戏

**实现要点:**
- 设置正确的响应头 (`text/event-stream`)
- 使用异步生成器 (`async def` + `yield`)
- 处理错误和重连
- 添加心跳保持连接

**下一步:**

理解了 SSE 协议后,可以学习:
- Python 异步生成器的实现原理
- FastAPI StreamingResponse 的使用
- LangChain 流式 API 的集成

---

**记住:** SSE 是流式输出集成的基础,理解 SSE 协议是掌握流式输出的第一步。
