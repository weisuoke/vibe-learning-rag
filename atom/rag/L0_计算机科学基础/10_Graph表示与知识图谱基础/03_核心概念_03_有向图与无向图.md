# 核心概念3：有向图与无向图

> 边的方向性决定了图的类型和应用场景

---

## 一句话定义

**有向图的边有方向(A→B ≠ B→A)，无向图的边无方向(A-B = B-A)，方向性决定了图在知识图谱、社交网络等场景中的不同应用。**

---

## 核心区别

### 有向图 (Directed Graph / Digraph)

```python
# 有向图：边有方向
directed_graph = {
    "A": ["B", "C"],  # A → B, A → C
    "B": ["C"],       # B → C
    "C": []           # C无出边
}

# A → B 存在，但 B → A 不存在
```

**特点：**
- 边有方向：A → B ≠ B → A
- 邻接矩阵不对称
- 有入度和出度的概念

### 无向图 (Undirected Graph)

```python
# 无向图：边无方向
undirected_graph = {
    "A": ["B", "C"],  # A - B, A - C
    "B": ["A", "C"],  # B - A, B - C
    "C": ["A", "B"]   # C - A, C - B
}

# A - B 等价于 B - A（双向）
```

**特点：**
- 边无方向：A - B = B - A
- 邻接矩阵对称
- 只有度数的概念（无入度出度之分）

---

## 完整实现

### 统一接口实现

```python
from collections import defaultdict
from typing import List, Set

class Graph:
    """支持有向图和无向图的统一实现"""

    def __init__(self, directed=True):
        """
        directed: True表示有向图，False表示无向图
        """
        self.graph = defaultdict(list)
        self.directed = directed

    def add_edge(self, u, v, weight=None):
        """添加边"""
        # 添加 u → v
        if weight is None:
            if v not in self.graph[u]:
                self.graph[u].append(v)
        else:
            if not any(n == v for n, _ in self.graph[u]):
                self.graph[u].append((v, weight))

        # 无向图：添加反向边 v → u
        if not self.directed:
            if weight is None:
                if u not in self.graph[v]:
                    self.graph[v].append(u)
            else:
                if not any(n == u for n, _ in self.graph[v]):
                    self.graph[v].append((u, weight))

    def get_neighbors(self, node):
        """获取邻居（出边）"""
        return self.graph.get(node, [])

    def has_edge(self, u, v):
        """检查边是否存在"""
        neighbors = self.graph.get(u, [])
        if not neighbors:
            return False

        if neighbors and isinstance(neighbors[0], tuple):
            return any(n == v for n, _ in neighbors)
        else:
            return v in neighbors

    def in_degree(self, node):
        """入度（有向图）"""
        if not self.directed:
            return self.degree(node)

        count = 0
        for neighbors in self.graph.values():
            if neighbors and isinstance(neighbors[0], tuple):
                count += sum(1 for n, _ in neighbors if n == node)
            else:
                count += neighbors.count(node)
        return count

    def out_degree(self, node):
        """出度（有向图）"""
        return len(self.graph.get(node, []))

    def degree(self, node):
        """度数（无向图）或出度（有向图）"""
        return self.out_degree(node)

# 使用示例
# 有向图
dg = Graph(directed=True)
dg.add_edge("A", "B")
dg.add_edge("B", "C")
print(f"A→B存在: {dg.has_edge('A', 'B')}")  # True
print(f"B→A存在: {dg.has_edge('B', 'A')}")  # False
print(f"B的入度: {dg.in_degree('B')}")      # 1
print(f"B的出度: {dg.out_degree('B')}")     # 1

# 无向图
ug = Graph(directed=False)
ug.add_edge("A", "B")
ug.add_edge("B", "C")
print(f"A-B存在: {ug.has_edge('A', 'B')}")  # True
print(f"B-A存在: {ug.has_edge('B', 'A')}")  # True（对称）
print(f"B的度数: {ug.degree('B')}")         # 2
```

---

## 邻接矩阵表示差异

### 有向图的邻接矩阵

```python
# 有向图：A → B, A → C, B → C
directed_matrix = [
    [0, 1, 1],  # A的行
    [0, 0, 1],  # B的行
    [0, 0, 0]   # C的行
]

# 矩阵不对称：matrix[i][j] ≠ matrix[j][i]
# matrix[0][1] = 1 (A→B存在)
# matrix[1][0] = 0 (B→A不存在)
```

### 无向图的邻接矩阵

```python
# 无向图：A - B, A - C, B - C
undirected_matrix = [
    [0, 1, 1],  # A的行
    [1, 0, 1],  # B的行
    [1, 1, 0]   # C的行
]

# 矩阵对称：matrix[i][j] = matrix[j][i]
# matrix[0][1] = matrix[1][0] = 1 (A-B双向)
```

**对称性检查：**

```python
def is_symmetric(matrix):
    """检查矩阵是否对称"""
    n = len(matrix)
    for i in range(n):
        for j in range(n):
            if matrix[i][j] != matrix[j][i]:
                return False
    return True

print(is_symmetric(directed_matrix))    # False
print(is_symmetric(undirected_matrix))  # True
```

---

## 度数概念

### 有向图：入度和出度

```python
class DirectedGraph:
    def in_degree(self, node):
        """入度：指向该节点的边数"""
        count = 0
        for neighbors in self.graph.values():
            count += neighbors.count(node)
        return count

    def out_degree(self, node):
        """出度：从该节点出发的边数"""
        return len(self.graph.get(node, []))

# 示例
dg = DirectedGraph()
dg.add_edge("A", "B")
dg.add_edge("A", "C")
dg.add_edge("B", "C")

print(f"C的入度: {dg.in_degree('C')}")   # 2 (A→C, B→C)
print(f"C的出度: {dg.out_degree('C')}")  # 0 (无出边)
print(f"A的入度: {dg.in_degree('A')}")   # 0 (无入边)
print(f"A的出度: {dg.out_degree('A')}")  # 2 (A→B, A→C)
```

### 无向图：度数

```python
class UndirectedGraph:
    def degree(self, node):
        """度数：连接该节点的边数"""
        return len(self.graph.get(node, []))

# 示例
ug = UndirectedGraph()
ug.add_edge("A", "B")
ug.add_edge("A", "C")
ug.add_edge("B", "C")

print(f"A的度数: {ug.degree('A')}")  # 2 (A-B, A-C)
print(f"B的度数: {ug.degree('B')}")  # 2 (B-A, B-C)
print(f"C的度数: {ug.degree('C')}")  # 2 (C-A, C-B)
```

---

## 在AI Agent中的应用

### 应用1：知识图谱（有向图）⭐⭐⭐⭐⭐

```python
# 知识图谱：关系有方向
kg = Graph(directed=True)

# 三元组：(主语, 谓语, 宾语)
kg.add_edge("张三", "阿里巴巴")  # 张三 → 工作于 → 阿里巴巴
kg.add_edge("阿里巴巴", "杭州")  # 阿里巴巴 → 位于 → 杭州
kg.add_edge("张三", "杭州")      # 张三 → 居住在 → 杭州

# 方向性很重要
print(kg.has_edge("张三", "阿里巴巴"))    # True（张三工作于阿里巴巴）
print(kg.has_edge("阿里巴巴", "张三"))    # False（阿里巴巴不"工作于"张三）

# 多跳推理
def find_path(kg, start, end):
    """BFS找路径"""
    from collections import deque
    queue = deque([(start, [start])])
    visited = {start}

    while queue:
        node, path = queue.popleft()
        if node == end:
            return path

        for neighbor in kg.get_neighbors(node):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    return None

path = find_path(kg, "张三", "杭州")
print(f"推理路径: {' → '.join(path)}")  # 张三 → 杭州 或 张三 → 阿里巴巴 → 杭州
```

### 应用2：社交网络（无向图）⭐⭐⭐⭐⭐

```python
# 社交网络：朋友关系对称
social = Graph(directed=False)

social.add_edge("Alice", "Bob")
social.add_edge("Bob", "Charlie")
social.add_edge("Alice", "Charlie")

# 朋友关系是双向的
print(social.has_edge("Alice", "Bob"))  # True
print(social.has_edge("Bob", "Alice"))  # True（对称）

# 共同朋友
def common_friends(g, user1, user2):
    friends1 = set(g.get_neighbors(user1))
    friends2 = set(g.get_neighbors(user2))
    return friends1 & friends2

print(f"共同朋友: {common_friends(social, 'Alice', 'Bob')}")  # {'Charlie'}

# 推荐朋友（朋友的朋友）
def recommend_friends(g, user):
    friends = set(g.get_neighbors(user))
    recommendations = set()

    for friend in friends:
        for friend_of_friend in g.get_neighbors(friend):
            if friend_of_friend != user and friend_of_friend not in friends:
                recommendations.add(friend_of_friend)

    return recommendations

print(f"推荐朋友: {recommend_friends(social, 'Alice')}")
```

### 应用3：依赖关系（有向无环图 DAG）

```python
# 任务依赖：有向无环图
tasks = Graph(directed=True)

tasks.add_edge("安装依赖", "编译代码")
tasks.add_edge("编译代码", "运行测试")
tasks.add_edge("运行测试", "部署")

# 拓扑排序：确定执行顺序
def topological_sort(g):
    """拓扑排序（Kahn算法）"""
    # 计算所有节点的入度
    in_degree = {}
    all_nodes = set(g.graph.keys())
    for neighbors in g.graph.values():
        all_nodes.update(neighbors)

    for node in all_nodes:
        in_degree[node] = g.in_degree(node)

    # 找入度为0的节点
    queue = [node for node, degree in in_degree.items() if degree == 0]
    result = []

    while queue:
        node = queue.pop(0)
        result.append(node)

        for neighbor in g.get_neighbors(node):
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    return result

execution_order = topological_sort(tasks)
print(f"执行顺序: {' → '.join(execution_order)}")
# 安装依赖 → 编译代码 → 运行测试 → 部署
```

---

## 转换：有向图 ↔ 无向图

### 有向图转无向图

```python
def to_undirected(directed_graph):
    """有向图转无向图"""
    undirected = Graph(directed=False)

    for node, neighbors in directed_graph.graph.items():
        for neighbor in neighbors:
            undirected.add_edge(node, neighbor)

    return undirected

# 示例
dg = Graph(directed=True)
dg.add_edge("A", "B")
dg.add_edge("B", "C")

ug = to_undirected(dg)
print(ug.has_edge("B", "A"))  # True（转换后变双向）
```

### 无向图转有向图

```python
def to_directed(undirected_graph):
    """无向图转有向图（保留所有边）"""
    directed = Graph(directed=True)

    for node, neighbors in undirected_graph.graph.items():
        for neighbor in neighbors:
            directed.add_edge(node, neighbor)

    return directed

# 注意：无向图的每条边在邻接表中存储两次
# 转换后会保留双向边
```

---

## 使用NetworkX

### 创建有向图和无向图

```python
import networkx as nx

# 有向图
DG = nx.DiGraph()
DG.add_edge("A", "B")
DG.add_edge("B", "C")

print(DG.has_edge("A", "B"))  # True
print(DG.has_edge("B", "A"))  # False

# 无向图
UG = nx.Graph()
UG.add_edge("A", "B")
UG.add_edge("B", "C")

print(UG.has_edge("A", "B"))  # True
print(UG.has_edge("B", "A"))  # True（对称）

# 转换
UG_from_DG = DG.to_undirected()  # 有向转无向
DG_from_UG = UG.to_directed()    # 无向转有向
```

### 度数查询

```python
# 有向图
print(f"B的入度: {DG.in_degree('B')}")   # 1
print(f"B的出度: {DG.out_degree('B')}")  # 1

# 无向图
print(f"B的度数: {UG.degree('B')}")      # 2
```

---

## 选择标准

### 何时使用有向图？

| 场景 | 原因 | 示例 |
|------|------|------|
| **知识图谱** | 关系有方向 | (张三, 工作于, 阿里巴巴) |
| **依赖关系** | 依赖有先后 | 任务A依赖任务B |
| **网页链接** | 链接有方向 | 页面A链接到页面B |
| **推荐系统** | 推荐有方向 | 用户A推荐商品B |
| **状态转移** | 转移有方向 | 状态A转移到状态B |

### 何时使用无向图？

| 场景 | 原因 | 示例 |
|------|------|------|
| **社交网络** | 朋友关系对称 | Alice和Bob是朋友 |
| **协同过滤** | 相似度对称 | 用户A和用户B相似 |
| **地图导航** | 道路双向 | 城市A和城市B互通 |
| **分子结构** | 化学键无向 | 原子A和原子B成键 |

---

## 实战练习

### 练习1：检测有向图中的环

```python
def has_cycle(g):
    """检测有向图是否有环（DFS）"""
    visited = set()
    rec_stack = set()

    def dfs(node):
        visited.add(node)
        rec_stack.add(node)

        for neighbor in g.get_neighbors(node):
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True  # 发现环

        rec_stack.remove(node)
        return False

    for node in g.graph.keys():
        if node not in visited:
            if dfs(node):
                return True
    return False
```

### 练习2：无向图的连通分量

```python
def connected_components(g):
    """找无向图的所有连通分量"""
    visited = set()
    components = []

    def dfs(node, component):
        visited.add(node)
        component.append(node)
        for neighbor in g.get_neighbors(node):
            if neighbor not in visited:
                dfs(neighbor, component)

    for node in g.graph.keys():
        if node not in visited:
            component = []
            dfs(node, component)
            components.append(component)

    return components
```

---

## 总结

**有向图 vs 无向图：**

| 特性 | 有向图 | 无向图 |
|------|--------|--------|
| **边的方向** | 有方向 | 无方向 |
| **对称性** | 不对称 | 对称 |
| **度数** | 入度+出度 | 度数 |
| **邻接矩阵** | 不对称 | 对称 |
| **应用场景** | 知识图谱、依赖关系 | 社交网络、协同过滤 |

**关键洞察：**
- 方向性决定了图的语义
- 知识图谱几乎都是有向图
- 社交网络通常是无向图
- 选择正确的图类型很重要

---

**下一步：** 学习 `03_核心概念_04_图的基本操作.md`
