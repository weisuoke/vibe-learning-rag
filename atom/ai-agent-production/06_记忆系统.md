# 记忆系统架构

**知识点数**: 6个 | **学习时长**: 1周 | **优先级**: P1

---

## 概览

**为什么重要**: "Don't skip memory" - 记忆系统是Agent能力的关键。

**核心内容**: 长期记忆存储 → 记忆检索优化 → 记忆压缩 → 多模态记忆 → 一致性维护 → 隐私保护

---

## 核心知识点

### 01_长期记忆存储

**核心概念**: 持久化对话历史和知识。

**实战代码**:
```python
from sqlalchemy import create_engine, Column, String, Text, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

Base = declarative_base()

class Memory(Base):
    __tablename__ = "memories"

    id = Column(String, primary_key=True)
    user_id = Column(String, index=True)
    content = Column(Text)
    memory_type = Column(String)  # conversation, fact, preference
    created_at = Column(DateTime, default=datetime.utcnow)
    metadata = Column(Text)  # JSON

class MemoryStore:
    def __init__(self, db_url: str):
        self.engine = create_engine(db_url)
        Base.metadata.create_all(self.engine)
        Session = sessionmaker(bind=self.engine)
        self.session = Session()

    def add_memory(self, user_id: str, content: str, memory_type: str):
        memory = Memory(
            id=str(uuid.uuid4()),
            user_id=user_id,
            content=content,
            memory_type=memory_type
        )
        self.session.add(memory)
        self.session.commit()

    def get_memories(self, user_id: str, limit: int = 10):
        return self.session.query(Memory)\
            .filter(Memory.user_id == user_id)\
            .order_by(Memory.created_at.desc())\
            .limit(limit)\
            .all()
```

---

### 02_记忆检索优化

**核心概念**: 快速检索相关记忆。

**实战代码**:
```python
from chromadb import Client
from sentence_transformers import SentenceTransformer

class SemanticMemoryRetriever:
    def __init__(self):
        self.client = Client()
        self.collection = self.client.create_collection("memories")
        self.encoder = SentenceTransformer('all-MiniLM-L6-v2')

    def add_memory(self, memory_id: str, content: str, metadata: dict):
        embedding = self.encoder.encode(content).tolist()
        self.collection.add(
            ids=[memory_id],
            embeddings=[embedding],
            documents=[content],
            metadatas=[metadata]
        )

    def retrieve(self, query: str, top_k: int = 5):
        query_embedding = self.encoder.encode(query).tolist()
        results = self.collection.query(
            query_embeddings=[query_embedding],
            n_results=top_k
        )
        return results

# 混合检索（向量 + 关键词）
class HybridMemoryRetriever:
    def __init__(self):
        self.semantic = SemanticMemoryRetriever()
        self.keyword_index = {}

    def retrieve(self, query: str, top_k: int = 5):
        # 语义检索
        semantic_results = self.semantic.retrieve(query, top_k)

        # 关键词检索
        keyword_results = self.keyword_search(query, top_k)

        # 合并和重排序
        return self.merge_results(semantic_results, keyword_results)
```

---

### 03_记忆压缩与总结

**核心概念**: 管理长对话，避免上下文溢出。

**实战代码**:
```python
class MemoryCompressor:
    def __init__(self, llm):
        self.llm = llm

    def summarize_conversation(self, messages: list[dict]) -> str:
        """总结对话历史"""
        conversation = "\n".join([
            f"{m['role']}: {m['content']}" for m in messages
        ])

        prompt = f"""Summarize the following conversation in 2-3 sentences:

{conversation}

Summary:"""

        return self.llm.complete(prompt)

    def compress_memories(self, memories: list[str], max_tokens: int = 500):
        """压缩多条记忆"""
        combined = "\n".join(memories)

        if self.count_tokens(combined) <= max_tokens:
            return combined

        prompt = f"""Compress the following information while preserving key facts:

{combined}

Compressed version (max {max_tokens} tokens):"""

        return self.llm.complete(prompt)

# 增量总结
class IncrementalSummarizer:
    def __init__(self):
        self.summary = ""
        self.buffer = []
        self.buffer_size = 10

    def add_message(self, message: dict):
        self.buffer.append(message)

        if len(self.buffer) >= self.buffer_size:
            new_summary = self.summarize_buffer()
            self.summary = self.merge_summaries(self.summary, new_summary)
            self.buffer = []

    def get_context(self) -> str:
        return f"{self.summary}\n\nRecent messages:\n{self.format_buffer()}"
```

---

### 04_多模态记忆

**核心概念**: 处理图像、音频等多种类型记忆。

**实战代码**:
```python
from PIL import Image
import clip
import torch

class MultimodalMemory:
    def __init__(self):
        self.device = "cuda" if torch.cuda.is_available() else "cpu"
        self.model, self.preprocess = clip.load("ViT-B/32", device=self.device)

    def encode_image(self, image_path: str):
        image = Image.open(image_path)
        image_input = self.preprocess(image).unsqueeze(0).to(self.device)

        with torch.no_grad():
            image_features = self.model.encode_image(image_input)

        return image_features.cpu().numpy()

    def encode_text(self, text: str):
        text_input = clip.tokenize([text]).to(self.device)

        with torch.no_grad():
            text_features = self.model.encode_text(text_input)

        return text_features.cpu().numpy()

    def search_images(self, query: str, image_embeddings: list):
        """用文本搜索图像"""
        query_embedding = self.encode_text(query)

        similarities = []
        for img_emb in image_embeddings:
            sim = cosine_similarity(query_embedding, img_emb)
            similarities.append(sim)

        return similarities
```

---

### 05_记忆一致性维护

**核心概念**: 确保记忆准确性，处理冲突。

**实战代码**:
```python
class MemoryConsistencyManager:
    def __init__(self, llm):
        self.llm = llm

    def detect_conflict(self, new_memory: str, existing_memories: list[str]) -> bool:
        """检测记忆冲突"""
        prompt = f"""Check if the new information conflicts with existing information:

New: {new_memory}

Existing:
{chr(10).join(existing_memories)}

Does the new information contradict any existing information? (yes/no)"""

        response = self.llm.complete(prompt).strip().lower()
        return response == "yes"

    def resolve_conflict(self, new_memory: str, conflicting_memory: str):
        """解决记忆冲突"""
        prompt = f"""Two pieces of information conflict:

1. {conflicting_memory}
2. {new_memory}

Which is more likely to be correct? Explain why."""

        return self.llm.complete(prompt)

    def update_memory(self, memory_id: str, new_content: str):
        """更新记忆并保留版本历史"""
        old_memory = self.get_memory(memory_id)

        # 保存版本历史
        self.save_version(memory_id, old_memory)

        # 更新记忆
        self.store.update(memory_id, new_content)
```

---

### 06_记忆隐私保护

**核心概念**: 保护用户隐私，安全存储敏感信息。

**实战代码**:
```python
from cryptography.fernet import Fernet
import hashlib

class SecureMemoryStore:
    def __init__(self, encryption_key: bytes):
        self.cipher = Fernet(encryption_key)

    def encrypt_memory(self, content: str) -> bytes:
        """加密记忆内容"""
        return self.cipher.encrypt(content.encode())

    def decrypt_memory(self, encrypted: bytes) -> str:
        """解密记忆内容"""
        return self.cipher.decrypt(encrypted).decode()

    def hash_user_id(self, user_id: str) -> str:
        """哈希用户ID"""
        return hashlib.sha256(user_id.encode()).hexdigest()

    def store_memory(self, user_id: str, content: str):
        """安全存储记忆"""
        hashed_user_id = self.hash_user_id(user_id)
        encrypted_content = self.encrypt_memory(content)

        db.insert({
            "user_id_hash": hashed_user_id,
            "content": encrypted_content,
            "created_at": datetime.utcnow()
        })

# 访问控制
class MemoryAccessControl:
    def __init__(self):
        self.permissions = {}

    def grant_access(self, user_id: str, memory_id: str):
        if user_id not in self.permissions:
            self.permissions[user_id] = set()
        self.permissions[user_id].add(memory_id)

    def check_access(self, user_id: str, memory_id: str) -> bool:
        return memory_id in self.permissions.get(user_id, set())

    def revoke_access(self, user_id: str, memory_id: str):
        if user_id in self.permissions:
            self.permissions[user_id].discard(memory_id)
```

---

## 核心20%（2个知识点）

1. ⭐⭐⭐ **长期记忆存储**
2. ⭐⭐⭐ **记忆检索优化**

---

## 实战项目

### 项目: 智能对话记忆系统

**功能**:
- 自动保存对话历史
- 语义检索相关记忆
- 自动总结长对话
- 检测和解决记忆冲突

**架构**:
```
用户输入 → 记忆检索 → Agent处理 → 记忆存储
              ↓
         相关上下文
```

**验收标准**:
- [ ] 能够持久化对话历史
- [ ] 语义检索准确率 > 80%
- [ ] 自动总结长对话
- [ ] 记忆加密存储

---

## 学习资源

- [LangChain Memory](https://python.langchain.com/docs/modules/memory/)
- [ChromaDB文档](https://docs.trychroma.com/)
- [CLIP模型](https://github.com/openai/CLIP)

---

## 常见误区

1. ❌ "记忆越多越好" → ✅ 需要压缩和总结
2. ❌ "只存储对话历史" → ✅ 还要存储事实和偏好
3. ❌ "记忆不需要加密" → ✅ 隐私保护很重要

---

**版本**: v1.0 | **最后更新**: 2026-02-12
