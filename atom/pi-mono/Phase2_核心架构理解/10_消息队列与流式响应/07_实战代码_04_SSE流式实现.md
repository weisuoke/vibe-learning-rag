# 实战代码 04：SSE 流式实现

> **目标**: 实现完整的 SSE (Server-Sent Events) 流式传输，包括服务端和客户端。

---

## 完整代码实现

### 服务端实现（Node.js + Express）

```typescript
/**
 * SSE 流式传输服务端实现
 * 演示：如何使用 Express 实现 SSE 流式传输
 */

import express, { Request, Response } from 'express';

// ===== 1. SSE Transport 类 =====

/**
 * SSE Transport
 * 封装 SSE 响应的发送逻辑
 */
export class SSETransport {
  private res: Response;
  private clientId: string;

  constructor(res: Response, clientId: string) {
    this.res = res;
    this.clientId = clientId;
    this.setupSSE();
  }

  /**
   * 设置 SSE 响应头
   */
  private setupSSE(): void {
    this.res.setHeader('Content-Type', 'text/event-stream');
    this.res.setHeader('Cache-Control', 'no-cache');
    this.res.setHeader('Connection', 'keep-alive');
    this.res.setHeader('X-Accel-Buffering', 'no'); // 禁用 Nginx 缓冲

    console.log(`SSE connection established for client ${this.clientId}`);
  }

  /**
   * 发送事件
   */
  sendEvent(event: string, data: any): void {
    this.res.write(`event: ${event}\n`);
    this.res.write(`data: ${JSON.stringify(data)}\n\n`);
  }

  /**
   * 发送数据（默认事件类型）
   */
  sendData(data: any): void {
    this.res.write(`data: ${JSON.stringify(data)}\n\n`);
  }

  /**
   * 发送注释（保持连接活跃）
   */
  sendComment(comment: string): void {
    this.res.write(`: ${comment}\n\n`);
  }

  /**
   * 关闭连接
   */
  close(): void {
    this.res.end();
    console.log(`SSE connection closed for client ${this.clientId}`);
  }
}

// ===== 2. SSE 服务器 =====

/**
 * SSE 服务器
 */
export class SSEServer {
  private app: express.Application;
  private clients: Map<string, SSETransport> = new Map();

  constructor() {
    this.app = express();
    this.setupRoutes();
  }

  /**
   * 设置路由
   */
  private setupRoutes(): void {
    // SSE 端点
    this.app.get('/api/stream', (req: Request, res: Response) => {
      const clientId = `client-${Date.now()}`;
      const transport = new SSETransport(res, clientId);

      // 保存客户端连接
      this.clients.set(clientId, transport);

      // 发送连接成功事件
      transport.sendEvent('connected', {
        clientId,
        message: 'Connected to SSE server'
      });

      // 处理客户端断开连接
      req.on('close', () => {
        this.clients.delete(clientId);
        console.log(`Client ${clientId} disconnected`);
      });
    });

    // 流式生成端点
    this.app.get('/api/generate', async (req: Request, res: Response) => {
      const prompt = req.query.prompt as string || 'Hello';
      const clientId = `client-${Date.now()}`;
      const transport = new SSETransport(res, clientId);

      try {
        await this.generateStream(transport, prompt);
      } catch (error) {
        transport.sendEvent('error', {
          message: error.message
        });
      } finally {
        transport.close();
      }
    });

    // 保持连接活跃（心跳）
    setInterval(() => {
      for (const [clientId, transport] of this.clients) {
        transport.sendComment('heartbeat');
      }
    }, 30000); // 每 30 秒发送一次心跳
  }

  /**
   * 生成流式响应
   */
  private async generateStream(
    transport: SSETransport,
    prompt: string
  ): Promise<void> {
    // 发送 start 事件
    transport.sendEvent('start', {
      prompt,
      timestamp: Date.now()
    });

    // 模拟 LLM 流式生成
    const response = `这是对 "${prompt}" 的响应。我会逐字生成内容，展示流式传输的效果。`;

    for (let i = 0; i < response.length; i++) {
      // 发送 delta 事件
      transport.sendEvent('delta', {
        content: response[i],
        index: i
      });

      // 模拟生成延迟
      await new Promise(resolve => setTimeout(resolve, 50));
    }

    // 发送 end 事件
    transport.sendEvent('end', {
      finishReason: 'stop',
      timestamp: Date.now()
    });
  }

  /**
   * 启动服务器
   */
  listen(port: number): void {
    this.app.listen(port, () => {
      console.log(`SSE server running on http://localhost:${port}`);
    });
  }

  /**
   * 广播消息给所有客户端
   */
  broadcast(event: string, data: any): void {
    for (const [clientId, transport] of this.clients) {
      transport.sendEvent(event, data);
    }
  }
}

// ===== 3. 启动服务器 =====

const server = new SSEServer();
server.listen(3000);
```

### 客户端实现

```typescript
/**
 * SSE 客户端实现
 * 演示：如何使用 EventSource 接收 SSE 流
 */

// ===== 1. SSE 客户端类 =====

/**
 * SSE 客户端
 */
export class SSEClient {
  private eventSource: EventSource | null = null;
  private url: string;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;

  constructor(url: string) {
    this.url = url;
  }

  /**
   * 连接到 SSE 服务器
   */
  connect(): void {
    console.log(`Connecting to ${this.url}...`);

    this.eventSource = new EventSource(this.url);

    // 监听连接打开
    this.eventSource.onopen = () => {
      console.log('SSE connection opened');
      this.reconnectAttempts = 0;
    };

    // 监听默认消息
    this.eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      console.log('Received message:', data);
    };

    // 监听错误
    this.eventSource.onerror = (error) => {
      console.error('SSE error:', error);

      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        this.reconnectAttempts++;
        console.log(`Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      } else {
        console.log('Max reconnect attempts reached');
        this.close();
      }
    };
  }

  /**
   * 监听特定事件
   */
  on(event: string, callback: (data: any) => void): void {
    if (!this.eventSource) {
      throw new Error('Not connected');
    }

    this.eventSource.addEventListener(event, (e: MessageEvent) => {
      const data = JSON.parse(e.data);
      callback(data);
    });
  }

  /**
   * 关闭连接
   */
  close(): void {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
      console.log('SSE connection closed');
    }
  }
}

// ===== 2. 使用示例 =====

/**
 * 示例 1：基础 SSE 连接
 */
function example1_BasicSSE() {
  console.log('=== 示例 1：基础 SSE 连接 ===\n');

  const client = new SSEClient('http://localhost:3000/api/stream');

  // 监听连接事件
  client.on('connected', (data) => {
    console.log('Connected:', data);
  });

  // 连接
  client.connect();

  // 10 秒后关闭
  setTimeout(() => {
    client.close();
  }, 10000);
}

/**
 * 示例 2：流式生成
 */
function example2_StreamingGeneration() {
  console.log('=== 示例 2：流式生成 ===\n');

  const client = new SSEClient('http://localhost:3000/api/generate?prompt=你好');

  let buffer = '';

  // 监听 start 事件
  client.on('start', (data) => {
    console.log('Generation started:', data);
  });

  // 监听 delta 事件
  client.on('delta', (data) => {
    buffer += data.content;
    process.stdout.write(data.content);
  });

  // 监听 end 事件
  client.on('end', (data) => {
    console.log('\n\nGeneration completed:', data);
    console.log('Full response:', buffer);
    client.close();
  });

  // 监听 error 事件
  client.on('error', (data) => {
    console.error('Error:', data);
    client.close();
  });

  // 连接
  client.connect();
}

/**
 * 示例 3：多个并发连接
 */
function example3_MultipleConcurrentConnections() {
  console.log('=== 示例 3：多个并发连接 ===\n');

  const clients: SSEClient[] = [];

  for (let i = 0; i < 3; i++) {
    const client = new SSEClient(`http://localhost:3000/api/generate?prompt=请求${i + 1}`);

    client.on('start', (data) => {
      console.log(`[Client ${i + 1}] Started`);
    });

    client.on('delta', (data) => {
      process.stdout.write(`[${i + 1}]`);
    });

    client.on('end', (data) => {
      console.log(`\n[Client ${i + 1}] Completed`);
      client.close();
    });

    client.connect();
    clients.push(client);
  }

  // 30 秒后关闭所有连接
  setTimeout(() => {
    clients.forEach(client => client.close());
  }, 30000);
}

/**
 * 示例 4：错误处理和重连
 */
function example4_ErrorHandlingAndReconnect() {
  console.log('=== 示例 4：错误处理和重连 ===\n');

  const client = new SSEClient('http://localhost:3000/api/stream');

  client.on('connected', (data) => {
    console.log('Connected:', data.clientId);
  });

  // 连接
  client.connect();

  // 模拟服务器断开（实际应用中由服务器触发）
  setTimeout(() => {
    console.log('Simulating server disconnect...');
    // EventSource 会自动尝试重连
  }, 5000);
}

// ===== 3. 浏览器端使用 =====

/**
 * 浏览器端 SSE 客户端
 * 可以直接在浏览器控制台中运行
 */
const browserExample = `
// 创建 EventSource
const eventSource = new EventSource('http://localhost:3000/api/generate?prompt=你好');

// 监听 start 事件
eventSource.addEventListener('start', (event) => {
  const data = JSON.parse(event.data);
  console.log('Start:', data);
});

// 监听 delta 事件
eventSource.addEventListener('delta', (event) => {
  const data = JSON.parse(event.data);
  document.body.innerHTML += data.content;
});

// 监听 end 事件
eventSource.addEventListener('end', (event) => {
  const data = JSON.parse(event.data);
  console.log('End:', data);
  eventSource.close();
});

// 监听错误
eventSource.onerror = (error) => {
  console.error('Error:', error);
  eventSource.close();
};
`;

console.log('Browser example:');
console.log(browserExample);
```

---

## 运行示例

### 启动服务器

```bash
# 安装依赖
npm install express @types/express

# 编译 TypeScript
tsc sse-server.ts

# 运行服务器
node sse-server.js
```

### 运行客户端

```bash
# 编译 TypeScript
tsc sse-client.ts

# 运行客户端
node sse-client.js
```

### 使用 curl 测试

```bash
# 测试 SSE 端点
curl -N http://localhost:3000/api/stream

# 测试流式生成
curl -N http://localhost:3000/api/generate?prompt=你好
```

---

## 核心要点

1. **SSE 响应头**：Content-Type: text/event-stream, Cache-Control: no-cache
2. **事件格式**：`event: <event-name>\ndata: <json-data>\n\n`
3. **自动重连**：EventSource 会自动重连（默认 3 秒）
4. **心跳机制**：定期发送注释保持连接活跃
5. **错误处理**：监听 onerror 事件，实现重连逻辑

---

## 关键实现细节

### 1. SSE 响应格式

```
event: start
data: {"message": "开始生成"}

event: delta
data: {"content": "你"}

event: delta
data: {"content": "好"}

event: end
data: {"finishReason": "stop"}
```

### 2. 保持连接活跃

```typescript
// 服务端：定期发送心跳
setInterval(() => {
  res.write(': heartbeat\n\n');
}, 30000);

// 客户端：EventSource 自动处理
```

### 3. 错误处理

```typescript
eventSource.onerror = (error) => {
  if (eventSource.readyState === EventSource.CONNECTING) {
    console.log('Reconnecting...');
  } else {
    console.error('Connection failed');
    eventSource.close();
  }
};
```

---

## 扩展练习

1. **添加认证**：使用 JWT 或 API key 认证 SSE 连接
2. **添加压缩**：使用 gzip 压缩 SSE 数据
3. **添加断点续传**：支持从断点继续接收数据
4. **添加多路复用**：一个连接支持多个流

---

**版本**: v1.0
**最后更新**: 2026-02-19
**维护者**: Claude Code
