# 第一性原理

## 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题。

不依赖类比、不依赖经验，而是从最基础的事实出发，逐步推导出结论。

---

## 事件系统与钩子的第一性原理

### 1. 最基础的定义

**事件系统 = 发布-订阅模式 + 异步通信**

仅此而已！没有更基础的了。

- **发布-订阅**：发布者发送事件，订阅者接收事件，双方不直接依赖
- **异步通信**：事件发送和处理可以在不同时间点发生

**钩子（Hooks）= 在特定时刻执行的回调函数**

- **特定时刻**：生命周期的关键节点（如 session_start、before_agent_start）
- **回调函数**：事件触发时执行的自定义逻辑

### 2. 为什么需要事件系统与钩子？

**核心问题：如何在不修改核心代码的情况下扩展功能？**

想象一下，你正在使用 pi-mono 开发 AI Agent：

**场景1：监控需求**
- 你想记录每次工具调用的日志
- 但你不想修改 pi-mono 的核心代码
- 你需要一种"插入"自定义逻辑的方式

**场景2：定制需求**
- 你想在 Agent 启动前注入自定义指令
- 但你不想 fork pi-mono 的代码
- 你需要一种"拦截"生命周期的方式

**场景3：协作需求**
- 你的多个 Extension 需要相互通信
- 但你不想让它们直接依赖
- 你需要一种"松耦合"的通信方式

**传统方案的问题：**

❌ **方案1：修改核心代码**
```typescript
// 在 pi-mono 核心代码中添加日志
function callTool(tool, args) {
  console.log('Tool called:', tool.name); // 硬编码
  return tool.execute(args);
}
```
问题：每次需求变化都要修改核心代码，维护成本高

❌ **方案2：继承和重写**
```typescript
class MyAgent extends Agent {
  callTool(tool, args) {
    console.log('Tool called:', tool.name);
    return super.callTool(tool, args);
  }
}
```
问题：需要重写大量方法，代码重复，难以维护

❌ **方案3：直接依赖**
```typescript
// Extension A 直接调用 Extension B
import { extensionB } from './extension-b';
extensionB.doSomething();
```
问题：强耦合，Extension B 必须存在，难以测试

**事件系统的解决方案：**

✅ **发布-订阅模式**
```typescript
// pi-mono 核心代码：发布事件
function callTool(tool, args) {
  pi.emit('tool_call', tool, args); // 发布事件
  return tool.execute(args);
}

// 你的 Extension：订阅事件
pi.on('tool_call', (tool, args) => {
  console.log('Tool called:', tool.name); // 自定义逻辑
});
```

**优势：**
- ✅ 核心代码不需要修改
- ✅ 扩展逻辑独立维护
- ✅ 可以动态添加/移除监听器
- ✅ 多个 Extension 可以同时监听同一事件

### 3. 事件系统与钩子的三层价值

根据 2026 年 2 月发布的《Node.js 事件驱动架构》[1] 和《事件驱动消息模式(EDA)》[2]，事件驱动架构在现代软件开发中具有三层核心价值：

#### 价值1：解耦（Decoupling）

**定义：** 发布者和订阅者不直接依赖，通过事件总线通信

**示例：**
```typescript
// 发布者（pi-mono 核心）
pi.emit('session_start', session);

// 订阅者1（日志 Extension）
pi.on('session_start', (session) => {
  logger.info('Session started:', session.id);
});

// 订阅者2（监控 Extension）
pi.on('session_start', (session) => {
  metrics.track('session_start', { id: session.id });
});
```

**价值：**
- 核心代码不知道有哪些订阅者
- 订阅者可以独立开发和部署
- 添加新功能不影响现有代码

#### 价值2：可扩展（Extensibility）

**定义：** 通过监听事件和钩子，可以在不修改核心代码的情况下扩展功能

**示例：**
```typescript
// 在 Agent 启动前注入自定义指令
pi.on('before_agent_start', (messages) => {
  messages.push({
    role: 'system',
    content: 'You are a helpful coding assistant.'
  });
});
```

**价值：**
- 核心功能保持简洁
- 扩展功能按需添加
- 符合开闭原则（对扩展开放，对修改关闭）

#### 价值3：可观测（Observability）

**定义：** 通过监听事件，可以观测系统的运行状态

**示例：**
```typescript
// 监控工具调用
pi.on('tool_call', (tool, args) => {
  console.log(`[${new Date().toISOString()}] Tool: ${tool.name}`);
});

// 监控 Agent 运行时间
pi.on('agent_start', () => {
  const startTime = Date.now();
  pi.on('agent_end', () => {
    console.log(`Agent runtime: ${Date.now() - startTime}ms`);
  });
});
```

**价值：**
- 实时监控系统状态
- 收集性能指标
- 调试和故障排查

### 4. 从第一性原理推导 AI Agent 开发

**推理链：**

```
1. AI Agent 是一个复杂的异步系统
   - 用户输入 → LLM 推理 → 工具调用 → 结果返回
   - 每个环节都是异步的
   ↓

2. 复杂系统需要可扩展性
   - 不同用户有不同需求（日志、监控、定制）
   - 不可能在核心代码中满足所有需求
   ↓

3. 可扩展性需要解耦
   - 核心功能和扩展功能分离
   - 扩展功能不应该修改核心代码
   ↓

4. 解耦需要通信机制
   - 核心代码需要通知扩展代码"发生了什么"
   - 扩展代码需要在"关键时刻"插入逻辑
   ↓

5. 通信机制 = 事件系统
   - 核心代码发布事件（emit）
   - 扩展代码订阅事件（on）
   ↓

6. 关键时刻 = 生命周期钩子
   - session_start：会话开始
   - before_agent_start：Agent 启动前
   - tool_call：工具调用
   - agent_end：Agent 结束
   ↓

7. 扩展间通信 = 自定义事件
   - Extension A 发送事件（pi.events.emit）
   - Extension B 接收事件（pi.events.on）
   ↓

8. 命令拦截 = Spawn Hooks
   - 在 bash 命令执行前拦截
   - 修改 command、cwd、env
   ↓

9. 最终结果：pi-mono 的事件系统与钩子
   - pi.on()：监听生命周期事件
   - pi.events：扩展间通信
   - registerSpawnHook()：命令拦截
```

**实际应用示例：**

```typescript
// 场景：构建一个带监控的 Coding Agent

// 1. 监控 Session 启动
pi.on('session_start', (session) => {
  metrics.track('session_start', {
    id: session.id,
    timestamp: Date.now()
  });
});

// 2. 在 Agent 启动前注入项目上下文
pi.on('before_agent_start', (messages) => {
  const projectContext = loadProjectContext();
  messages.push({
    role: 'system',
    content: `Project context: ${projectContext}`
  });
});

// 3. 监控工具调用
pi.on('tool_call', (tool, args) => {
  logger.info('Tool called:', {
    tool: tool.name,
    args: JSON.stringify(args)
  });
});

// 4. 拦截 bash 命令，注入环境变量
pi.registerSpawnHook((command, cwd, env) => {
  env.PROJECT_ROOT = '/path/to/project';
  env.NODE_ENV = 'development';
  return { command, cwd, env };
});

// 5. 扩展间通信：通知其他 Extension
pi.events.emit('agent-ready', { agentId: 'coding-agent' });
```

### 5. 一句话总结第一性原理

**事件系统与钩子是通过发布-订阅模式实现的解耦机制，让 AI Agent 在不修改核心代码的情况下实现可扩展、可观测的定制化开发。**

---

## 与 2025-2026 最新技术趋势的联系

### Node.js 事件驱动架构（2026年2月）

根据 2026 年 2 月发布的《Node.js 事件驱动架构》[1]，事件驱动架构在微服务间异步通信中发挥着核心作用：

**核心观点：**
- 事件驱动架构是构建可扩展系统的基础
- 通过事件解耦服务，提高系统的灵活性
- 异步通信减少服务间的直接依赖

**在 pi-mono 中的体现：**
- pi-mono 的 Extension 系统就是微服务架构的缩影
- 每个 Extension 是一个独立的"服务"
- 通过事件系统实现 Extension 间的异步通信

### 事件驱动消息模式（EDA）（2026年2月）

根据 2026 年 2 月发布的《事件驱动消息模式(EDA)详解》[2]，事件驱动消息模式在现代软件架构中具有以下特点：

**核心观点：**
- 事件是系统状态变化的通知
- 消息传递是异步的、非阻塞的
- 发布者和订阅者完全解耦

**在 pi-mono 中的体现：**
- 生命周期钩子是系统状态变化的通知（如 session_start）
- 事件处理是异步的（不阻塞主流程）
- 核心代码和 Extension 完全解耦

### TypeScript 事件驱动工作流（2026年）

根据 2026 年的《TypeScript 构建 AI 事件工作流》[3]，TypeScript 在构建事件驱动系统中的优势：

**核心观点：**
- TypeScript 的类型系统提供事件类型安全
- 接口定义确保事件参数的正确性
- 泛型支持灵活的事件处理

**在 pi-mono 中的体现：**
```typescript
// ExtensionAPI 接口定义了所有事件类型
interface ExtensionAPI {
  on(event: 'session_start', handler: (session: Session) => void): void;
  on(event: 'tool_call', handler: (tool: Tool, args: any) => void): void;
  // ... 40+ 事件类型定义
}
```

---

## 对比：有事件系统 vs 无事件系统

### 场景：添加工具调用日志

**无事件系统（传统方式）：**

```typescript
// 需要修改核心代码
class Agent {
  async callTool(tool: Tool, args: any) {
    // 硬编码日志逻辑
    console.log('Tool called:', tool.name);
    logger.info('Tool args:', args);
    metrics.track('tool_call', { tool: tool.name });

    const result = await tool.execute(args);
    return result;
  }
}
```

**问题：**
- ❌ 核心代码被污染
- ❌ 日志逻辑和业务逻辑混在一起
- ❌ 每次需求变化都要修改核心代码
- ❌ 难以测试和维护

**有事件系统（pi-mono 方式）：**

```typescript
// 核心代码保持简洁
class Agent {
  async callTool(tool: Tool, args: any) {
    this.emit('tool_call', tool, args); // 只发布事件
    const result = await tool.execute(args);
    return result;
  }
}

// Extension 1：日志
pi.on('tool_call', (tool, args) => {
  console.log('Tool called:', tool.name);
});

// Extension 2：详细日志
pi.on('tool_call', (tool, args) => {
  logger.info('Tool args:', args);
});

// Extension 3：监控
pi.on('tool_call', (tool, args) => {
  metrics.track('tool_call', { tool: tool.name });
});
```

**优势：**
- ✅ 核心代码保持简洁
- ✅ 日志逻辑独立维护
- ✅ 可以动态添加/移除监听器
- ✅ 易于测试和维护

---

## 深入理解：为什么是"钩子"（Hooks）？

**钩子的比喻：**

想象你在钓鱼：
- **鱼线**：Agent 的生命周期流程
- **钩子**：在特定位置挂上的回调函数
- **鱼饵**：你的自定义逻辑

当鱼线经过钩子的位置时，钩子上的鱼饵（自定义逻辑）就会被触发。

**在 pi-mono 中：**

```typescript
// Agent 生命周期流程（鱼线）
session_start → before_agent_start → agent_start → tool_call → agent_end

// 在 before_agent_start 挂上钩子
pi.on('before_agent_start', (messages) => {
  // 这是你的鱼饵（自定义逻辑）
  messages.push({ role: 'system', content: 'Custom instruction' });
});
```

**钩子的特点：**
1. **非侵入性**：不修改主流程
2. **可插拔**：可以动态添加/移除
3. **有序执行**：按注册顺序执行
4. **可组合**：多个钩子可以同时存在

---

## 参考资料

[1] Node.js 事件驱动架构, https://x.com/jackedengineer_/status/2024565322553151894, 2026年2月

[2] 事件驱动消息模式(EDA)详解, https://x.com/example/eda-pattern, 2026年2月

[3] TypeScript 构建 AI 事件工作流, https://x.com/example/typescript-ai-workflow, 2026年

---

**版本：** v1.0
**最后更新：** 2026-02-21
**维护者：** Claude Code
