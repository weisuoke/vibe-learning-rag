# 最小可用

> 掌握以下内容，就能开始使用装饰器解决80%的实际问题

---

## 核心知识清单

掌握以下5个核心知识点，就能在 FastAPI 项目中熟练使用装饰器：

---

### 4.1 基础装饰器结构（必须掌握）

**核心概念：** 装饰器 = 接收函数 + 返回包装函数

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # 保留原函数元信息
    def wrapper(*args, **kwargs):
        # 前置处理
        result = func(*args, **kwargs)
        # 后置处理
        return result
    return wrapper

@my_decorator
def my_function():
    pass
```

**记住这3点：**
1. 使用 `*args, **kwargs` 接收任意参数
2. 使用 `@wraps(func)` 保留原函数信息
3. 必须返回 `wrapper` 函数

**实际应用：** 日志记录、性能监控、错误处理

---

### 4.2 带参数的装饰器（FastAPI 必备）

**核心概念：** 装饰器工厂 = 接收参数 + 返回装饰器

```python
def decorator_with_params(param1, param2="default"):
    """装饰器工厂：根据参数创建装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 可以访问 param1, param2
            return func(*args, **kwargs)
        return wrapper
    return decorator

@decorator_with_params(param1="value")
def my_function():
    pass
```

**记住这3层结构：**
1. 第1层：接收参数（`param1, param2`）
2. 第2层：接收函数（`func`）
3. 第3层：执行逻辑（`wrapper`）

**实际应用：** FastAPI 路由定义、权限检查、限流控制

---

### 4.3 FastAPI 路由装饰器（核心应用）

**核心概念：** 路由装饰器 = 声明式 API 定义

```python
from fastapi import FastAPI

app = FastAPI()

# 基础路由
@app.get("/users")
def get_users():
    return [{"id": 1, "name": "Alice"}]

# 带参数的路由
@app.post("/users", status_code=201)
def create_user(name: str):
    return {"id": 2, "name": name}

# 路径参数
@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"id": user_id, "name": "Alice"}
```

**记住这3个要点：**
1. `@app.get(path)` 定义 GET 端点
2. `@app.post(path)` 定义 POST 端点
3. 路径参数用 `{param}` 表示

**实际应用：** 构建 RESTful API、AI Agent 接口

---

### 4.4 多个装饰器的组合（进阶必备）

**核心概念：** 装饰器可以叠加使用

```python
@decorator_a
@decorator_b
@decorator_c
def my_function():
    pass

# 等价于：
# my_function = decorator_a(decorator_b(decorator_c(my_function)))
```

**执行顺序：**
- **定义时**：从下到上（c → b → a）
- **调用时**：从上到下（a → b → c → 函数 → c → b → a）

```python
from fastapi import FastAPI, Depends

app = FastAPI()

def require_auth(token: str):
    if token != "valid":
        raise Exception("Unauthorized")
    return {"user_id": 1}

@app.get("/profile")
@require_auth  # 先检查权限
def get_profile(user: dict = Depends(require_auth)):
    return user
```

**实际应用：** 权限检查 + 日志记录 + 限流控制

---

### 4.5 常用装饰器模式（实战必备）

#### 模式1：日志装饰器

```python
from functools import wraps
from datetime import datetime

def log(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"[{datetime.now()}] 调用 {func.__name__}")
        result = func(*args, **kwargs)
        print(f"[{datetime.now()}] {func.__name__} 完成")
        return result
    return wrapper

@log
def process_data(data):
    return f"处理: {data}"
```

#### 模式2：计时装饰器

```python
import time
from functools import wraps

def timing(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        print(f"{func.__name__} 耗时: {elapsed:.4f}秒")
        return result
    return wrapper

@timing
def slow_function():
    time.sleep(1)
    return "Done"
```

#### 模式3：重试装饰器

```python
import time
from functools import wraps

def retry(max_attempts=3, delay=1):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts:
                        raise
                    print(f"重试 {attempt}/{max_attempts}")
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_attempts=3, delay=0.5)
def unstable_api_call():
    # 可能失败的 API 调用
    pass
```

#### 模式4：缓存装饰器

```python
from functools import wraps

def cache(func):
    cached = {}
    @wraps(func)
    def wrapper(*args):
        if args not in cached:
            cached[args] = func(*args)
        return cached[args]
    return wrapper

@cache
def expensive_computation(n):
    return n * n
```

#### 模式5：权限检查装饰器

```python
from functools import wraps

def require_permission(permission):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            user_permission = kwargs.get("user_permission", "guest")
            if user_permission != permission:
                raise PermissionError(f"需要 {permission} 权限")
            return func(*args, **kwargs)
        return wrapper
    return decorator

@require_permission("admin")
def delete_user(user_id, user_permission="guest"):
    return f"删除用户 {user_id}"
```

---

## 最小可用检查清单

掌握以下内容，你就可以开始使用装饰器了：

- [ ] 能写出基础装饰器结构（`def decorator(func): def wrapper(): ...`）
- [ ] 知道使用 `*args, **kwargs` 接收任意参数
- [ ] 知道使用 `@wraps(func)` 保留原函数信息
- [ ] 能写出带参数的装饰器（三层函数结构）
- [ ] 理解 FastAPI 路由装饰器的用法（`@app.get(path)`）
- [ ] 知道多个装饰器的执行顺序（定义时从下到上，调用时从上到下）
- [ ] 能使用常用装饰器模式（日志、计时、重试、缓存、权限）

---

## 这些知识足以

**在 AI Agent 开发中，你可以：**

1. **定义 API 端点**
   ```python
   @app.get("/chat")
   def chat_endpoint():
       return {"message": "Hello"}
   ```

2. **添加日志记录**
   ```python
   @log
   @app.post("/generate")
   def generate_text(prompt: str):
       return call_llm(prompt)
   ```

3. **实现权限检查**
   ```python
   @require_auth
   @app.delete("/users/{user_id}")
   def delete_user(user_id: int):
       return delete_user_from_db(user_id)
   ```

4. **添加性能监控**
   ```python
   @timing
   @app.post("/process")
   def process_data(data: dict):
       return process(data)
   ```

5. **实现重试机制**
   ```python
   @retry(max_attempts=3)
   def call_external_api():
       return requests.get("https://api.example.com")
   ```

---

## 快速参考卡

```python
# 1. 基础装饰器
def decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

# 2. 带参数的装饰器
def decorator(param):
    def inner(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    return inner

# 3. FastAPI 路由
@app.get("/path")
def handler():
    return {"data": "value"}

# 4. 多装饰器
@decorator_a
@decorator_b
def func():
    pass

# 5. 常用模式
@log          # 日志
@timing       # 计时
@retry(3)     # 重试
@cache        # 缓存
@require_auth # 权限
```

---

## 下一步学习

掌握了最小可用知识后，可以继续学习：

1. **双重类比** - 理解装饰器与前端概念的对应关系
2. **反直觉点** - 避免常见误区
3. **实战代码** - 完整的 FastAPI 应用示例
4. **化骨绵掌** - 深入理解装饰器的各个方面

---

## 实战练习建议

1. **练习1：手写基础装饰器**
   - 写一个日志装饰器
   - 写一个计时装饰器
   - 写一个计数装饰器

2. **练习2：手写带参数的装饰器**
   - 写一个可配置日志级别的装饰器
   - 写一个可配置重试次数的装饰器
   - 写一个可配置缓存过期时间的装饰器

3. **练习3：FastAPI 应用**
   - 创建一个简单的 FastAPI 应用
   - 使用路由装饰器定义 3 个端点
   - 为端点添加日志和计时装饰器

4. **练习4：组合装饰器**
   - 创建一个需要权限检查的端点
   - 添加日志记录
   - 添加性能监控
   - 添加错误处理

---

**记住：** 装饰器的本质是高阶函数，理解了这一点，就能灵活运用装饰器解决各种问题。
