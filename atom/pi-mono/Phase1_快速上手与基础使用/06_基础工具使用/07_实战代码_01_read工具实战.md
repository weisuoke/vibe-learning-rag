# read å·¥å…·å®æˆ˜

> å®Œæ•´çš„ TypeScript ç¤ºä¾‹å±•ç¤º read å·¥å…·çš„å®é™…åº”ç”¨åœºæ™¯

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› read å·¥å…·çš„å®Œæ•´å®æˆ˜ç¤ºä¾‹ï¼Œæ‰€æœ‰ä»£ç éƒ½å¯ä»¥ç›´æ¥è¿è¡Œã€‚

---

## åœºæ™¯ 1ï¼šä»£ç å®¡æŸ¥åŠ©æ‰‹

**ä»»åŠ¡ï¼š** æ„å»ºä¸€ä¸ªè‡ªåŠ¨ä»£ç å®¡æŸ¥å·¥å…·

```typescript
// code-reviewer.ts
import fs from 'fs'
import path from 'path'

interface CodeIssue {
  file: string
  line: number
  severity: 'error' | 'warning' | 'info'
  message: string
}

class CodeReviewer {
  private issues: CodeIssue[] = []

  /**
   * å®¡æŸ¥å•ä¸ªæ–‡ä»¶
   */
  async reviewFile(filePath: string): Promise<void> {
    console.log(`\n=== Reviewing ${filePath} ===`)

    // ä½¿ç”¨ read å·¥å…·è¯»å–æ–‡ä»¶
    const content = fs.readFileSync(filePath, 'utf-8')
    const lines = content.split('\n')

    // æ£€æŸ¥å¸¸è§é—®é¢˜
    this.checkConsoleLog(filePath, lines)
    this.checkTodoComments(filePath, lines)
    this.checkLongFunctions(filePath, lines)
    this.checkHardcodedValues(filePath, lines)
  }

  /**
   * æ£€æŸ¥ console.log
   */
  private checkConsoleLog(file: string, lines: string[]): void {
    lines.forEach((line, index) => {
      if (line.includes('console.log')) {
        this.issues.push({
          file,
          line: index + 1,
          severity: 'warning',
          message: 'Remove console.log before production'
        })
      }
    })
  }

  /**
   * æ£€æŸ¥ TODO æ³¨é‡Š
   */
  private checkTodoComments(file: string, lines: string[]): void {
    lines.forEach((line, index) => {
      if (line.includes('TODO') || line.includes('FIXME')) {
        this.issues.push({
          file,
          line: index + 1,
          severity: 'info',
          message: 'Unresolved TODO/FIXME comment'
        })
      }
    })
  }

  /**
   * æ£€æŸ¥è¿‡é•¿çš„å‡½æ•°
   */
  private checkLongFunctions(file: string, lines: string[]): void {
    let functionStart = -1
    let functionName = ''
    let braceCount = 0

    lines.forEach((line, index) => {
      // æ£€æµ‹å‡½æ•°å¼€å§‹
      const functionMatch = line.match(/function\s+(\w+)|(\w+)\s*\(.*\)\s*{|const\s+(\w+)\s*=\s*\(/)
      if (functionMatch && line.includes('{')) {
        functionStart = index
        functionName = functionMatch[1] || functionMatch[2] || functionMatch[3]
        braceCount = 1
      } else if (functionStart >= 0) {
        braceCount += (line.match(/{/g) || []).length
        braceCount -= (line.match(/}/g) || []).length

        // å‡½æ•°ç»“æŸ
        if (braceCount === 0) {
          const functionLength = index - functionStart + 1
          if (functionLength > 50) {
            this.issues.push({
              file,
              line: functionStart + 1,
              severity: 'warning',
              message: `Function '${functionName}' is too long (${functionLength} lines). Consider refactoring.`
            })
          }
          functionStart = -1
        }
      }
    })
  }

  /**
   * æ£€æŸ¥ç¡¬ç¼–ç å€¼
   */
  private checkHardcodedValues(file: string, lines: string[]): void {
    lines.forEach((line, index) => {
      // æ£€æŸ¥ç¡¬ç¼–ç çš„ URL
      if (line.match(/https?:\/\/[^\s"']+/) && !line.includes('//')) {
        this.issues.push({
          file,
          line: index + 1,
          severity: 'info',
          message: 'Consider moving hardcoded URL to config'
        })
      }

      // æ£€æŸ¥ç¡¬ç¼–ç çš„ç«¯å£
      if (line.match(/port\s*=\s*\d{4,5}/) && !line.includes('process.env')) {
        this.issues.push({
          file,
          line: index + 1,
          severity: 'info',
          message: 'Consider using environment variable for port'
        })
      }
    })
  }

  /**
   * ç”Ÿæˆå®¡æŸ¥æŠ¥å‘Š
   */
  generateReport(): string {
    if (this.issues.length === 0) {
      return 'âœ… No issues found!'
    }

    let report = `\nğŸ“‹ Code Review Report\n`
    report += `Found ${this.issues.length} issues:\n\n`

    // æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç»„
    const bySevert = {
      error: this.issues.filter(i => i.severity === 'error'),
      warning: this.issues.filter(i => i.severity === 'warning'),
      info: this.issues.filter(i => i.severity === 'info')
    }

    for (const [severity, issues] of Object.entries(bySeverity)) {
      if (issues.length > 0) {
        report += `\n${severity.toUpperCase()} (${issues.length}):\n`
        issues.forEach(issue => {
          report += `  ${issue.file}:${issue.line} - ${issue.message}\n`
        })
      }
    }

    return report
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const reviewer = new CodeReviewer()

  // å®¡æŸ¥å¤šä¸ªæ–‡ä»¶
  const files = [
    'src/app.ts',
    'src/utils.ts',
    'src/config.ts'
  ]

  for (const file of files) {
    if (fs.existsSync(file)) {
      await reviewer.reviewFile(file)
    }
  }

  // ç”ŸæˆæŠ¥å‘Š
  console.log(reviewer.generateReport())
}

main()
```

---

## åœºæ™¯ 2ï¼šé¡¹ç›®ç»“æ„åˆ†æå™¨

**ä»»åŠ¡ï¼š** åˆ†æé¡¹ç›®ç»“æ„å¹¶ç”Ÿæˆä¾èµ–å…³ç³»å›¾

```typescript
// project-analyzer.ts
import fs from 'fs'
import path from 'path'

interface FileInfo {
  path: string
  imports: string[]
  exports: string[]
  size: number
  lines: number
}

class ProjectAnalyzer {
  private files: Map<string, FileInfo> = new Map()

  /**
   * åˆ†æé¡¹ç›®
   */
  async analyzeProject(rootDir: string): Promise<void> {
    console.log(`\n=== Analyzing project: ${rootDir} ===\n`)

    // æŸ¥æ‰¾æ‰€æœ‰ TypeScript æ–‡ä»¶
    const tsFiles = this.findTSFiles(rootDir)
    console.log(`Found ${tsFiles.length} TypeScript files\n`)

    // åˆ†ææ¯ä¸ªæ–‡ä»¶
    for (const file of tsFiles) {
      await this.analyzeFile(file)
    }
  }

  /**
   * æŸ¥æ‰¾æ‰€æœ‰ TS æ–‡ä»¶
   */
  private findTSFiles(dir: string): string[] {
    const files: string[] = []

    const walk = (currentDir: string) => {
      const entries = fs.readdirSync(currentDir, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name)

        if (entry.isDirectory()) {
          // è·³è¿‡ node_modules å’Œ dist
          if (!['node_modules', 'dist', '.git'].includes(entry.name)) {
            walk(fullPath)
          }
        } else if (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx')) {
          files.push(fullPath)
        }
      }
    }

    walk(dir)
    return files
  }

  /**
   * åˆ†æå•ä¸ªæ–‡ä»¶
   */
  private async analyzeFile(filePath: string): Promise<void> {
    // ä½¿ç”¨ read å·¥å…·è¯»å–æ–‡ä»¶
    const content = fs.readFileSync(filePath, 'utf-8')
    const lines = content.split('\n')

    // æå– imports
    const imports = this.extractImports(lines)

    // æå– exports
    const exports = this.extractExports(lines)

    // å­˜å‚¨æ–‡ä»¶ä¿¡æ¯
    this.files.set(filePath, {
      path: filePath,
      imports,
      exports,
      size: Buffer.byteLength(content, 'utf-8'),
      lines: lines.length
    })
  }

  /**
   * æå– import è¯­å¥
   */
  private extractImports(lines: string[]): string[] {
    const imports: string[] = []

    for (const line of lines) {
      // import ... from '...'
      const match1 = line.match(/import\s+.*\s+from\s+['"](.+)['"]/)
      if (match1) {
        imports.push(match1[1])
        continue
      }

      // import '...'
      const match2 = line.match(/import\s+['"](.+)['"]/)
      if (match2) {
        imports.push(match2[1])
      }
    }

    return imports
  }

  /**
   * æå– export è¯­å¥
   */
  private extractExports(lines: string[]): string[] {
    const exports: string[] = []

    for (const line of lines) {
      // export function/class/const
      const match1 = line.match(/export\s+(function|class|const|let|var)\s+(\w+)/)
      if (match1) {
        exports.push(match1[2])
        continue
      }

      // export default
      if (line.includes('export default')) {
        exports.push('default')
      }
    }

    return exports
  }

  /**
   * ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Š
   */
  generateStats(): string {
    let report = '\nğŸ“Š Project Statistics\n\n'

    // æ€»ä½“ç»Ÿè®¡
    const totalFiles = this.files.size
    const totalLines = Array.from(this.files.values())
      .reduce((sum, f) => sum + f.lines, 0)
    const totalSize = Array.from(this.files.values())
      .reduce((sum, f) => sum + f.size, 0)

    report += `Total Files: ${totalFiles}\n`
    report += `Total Lines: ${totalLines.toLocaleString()}\n`
    report += `Total Size: ${(totalSize / 1024).toFixed(2)} KB\n\n`

    // æœ€å¤§çš„æ–‡ä»¶
    const largestFiles = Array.from(this.files.values())
      .sort((a, b) => b.lines - a.lines)
      .slice(0, 5)

    report += 'ğŸ“„ Largest Files:\n'
    largestFiles.forEach((file, index) => {
      const relativePath = path.relative(process.cwd(), file.path)
      report += `  ${index + 1}. ${relativePath} (${file.lines} lines)\n`
    })

    // æœ€å¤šä¾èµ–çš„æ–‡ä»¶
    const mostImports = Array.from(this.files.values())
      .sort((a, b) => b.imports.length - a.imports.length)
      .slice(0, 5)

    report += '\nğŸ“¦ Files with Most Imports:\n'
    mostImports.forEach((file, index) => {
      const relativePath = path.relative(process.cwd(), file.path)
      report += `  ${index + 1}. ${relativePath} (${file.imports.length} imports)\n`
    })

    return report
  }

  /**
   * ç”Ÿæˆä¾èµ–å…³ç³»å›¾ï¼ˆMermaid æ ¼å¼ï¼‰
   */
  generateDependencyGraph(): string {
    let graph = '```mermaid\ngraph TD\n'

    for (const [filePath, fileInfo] of this.files) {
      const fileName = path.basename(filePath, path.extname(filePath))

      for (const importPath of fileInfo.imports) {
        // åªæ˜¾ç¤ºæœ¬åœ°å¯¼å…¥
        if (importPath.startsWith('.')) {
          const importFileName = path.basename(importPath, path.extname(importPath))
          graph += `  ${fileName} --> ${importFileName}\n`
        }
      }
    }

    graph += '```\n'
    return graph
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const analyzer = new ProjectAnalyzer()

  // åˆ†æå½“å‰é¡¹ç›®
  await analyzer.analyzeProject('./src')

  // ç”ŸæˆæŠ¥å‘Š
  console.log(analyzer.generateStats())
  console.log('\nğŸ“ˆ Dependency Graph:')
  console.log(analyzer.generateDependencyGraph())
}

main()
```

---

## åœºæ™¯ 3ï¼šé…ç½®æ–‡ä»¶éªŒè¯å™¨

**ä»»åŠ¡ï¼š** éªŒè¯é…ç½®æ–‡ä»¶çš„æ­£ç¡®æ€§

```typescript
// config-validator.ts
import fs from 'fs'

interface ValidationResult {
  valid: boolean
  errors: string[]
  warnings: string[]
}

class ConfigValidator {
  /**
   * éªŒè¯ package.json
   */
  async validatePackageJson(filePath: string): Promise<ValidationResult> {
    console.log(`\n=== Validating ${filePath} ===\n`)

    const result: ValidationResult = {
      valid: true,
      errors: [],
      warnings: []
    }

    try {
      // ä½¿ç”¨ read å·¥å…·è¯»å–æ–‡ä»¶
      const content = fs.readFileSync(filePath, 'utf-8')
      const pkg = JSON.parse(content)

      // æ£€æŸ¥å¿…éœ€å­—æ®µ
      if (!pkg.name) {
        result.errors.push('Missing required field: name')
        result.valid = false
      }

      if (!pkg.version) {
        result.errors.push('Missing required field: version')
        result.valid = false
      }

      // æ£€æŸ¥ç‰ˆæœ¬æ ¼å¼
      if (pkg.version && !/^\d+\.\d+\.\d+/.test(pkg.version)) {
        result.warnings.push(`Invalid version format: ${pkg.version}`)
      }

      // æ£€æŸ¥è„šæœ¬
      if (!pkg.scripts) {
        result.warnings.push('No scripts defined')
      } else {
        if (!pkg.scripts.test) {
          result.warnings.push('No test script defined')
        }
        if (!pkg.scripts.build) {
          result.warnings.push('No build script defined')
        }
      }

      // æ£€æŸ¥ä¾èµ–
      if (pkg.dependencies) {
        for (const [dep, version] of Object.entries(pkg.dependencies)) {
          if (typeof version === 'string' && version.includes('*')) {
            result.warnings.push(`Wildcard version for ${dep}: ${version}`)
          }
        }
      }

    } catch (error) {
      result.errors.push(`Failed to parse JSON: ${error.message}`)
      result.valid = false
    }

    return result
  }

  /**
   * éªŒè¯ tsconfig.json
   */
  async validateTSConfig(filePath: string): Promise<ValidationResult> {
    console.log(`\n=== Validating ${filePath} ===\n`)

    const result: ValidationResult = {
      valid: true,
      errors: [],
      warnings: []
    }

    try {
      const content = fs.readFileSync(filePath, 'utf-8')
      const config = JSON.parse(content)

      // æ£€æŸ¥ compilerOptions
      if (!config.compilerOptions) {
        result.errors.push('Missing compilerOptions')
        result.valid = false
        return result
      }

      const opts = config.compilerOptions

      // æ¨èçš„ä¸¥æ ¼é€‰é¡¹
      if (!opts.strict) {
        result.warnings.push('Consider enabling strict mode')
      }

      if (!opts.noImplicitAny) {
        result.warnings.push('Consider enabling noImplicitAny')
      }

      if (!opts.strictNullChecks) {
        result.warnings.push('Consider enabling strictNullChecks')
      }

      // æ£€æŸ¥è¾“å‡ºç›®å½•
      if (!opts.outDir) {
        result.warnings.push('No outDir specified')
      }

      // æ£€æŸ¥æ¨¡å—ç³»ç»Ÿ
      if (!opts.module) {
        result.warnings.push('No module system specified')
      }

    } catch (error) {
      result.errors.push(`Failed to parse JSON: ${error.message}`)
      result.valid = false
    }

    return result
  }

  /**
   * æ‰“å°éªŒè¯ç»“æœ
   */
  printResult(fileName: string, result: ValidationResult): void {
    console.log(`\nğŸ“‹ Validation Result for ${fileName}:\n`)

    if (result.valid && result.errors.length === 0) {
      console.log('âœ… Valid')
    } else {
      console.log('âŒ Invalid')
    }

    if (result.errors.length > 0) {
      console.log('\nâŒ Errors:')
      result.errors.forEach(err => console.log(`  - ${err}`))
    }

    if (result.warnings.length > 0) {
      console.log('\nâš ï¸  Warnings:')
      result.warnings.forEach(warn => console.log(`  - ${warn}`))
    }

    console.log()
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const validator = new ConfigValidator()

  // éªŒè¯ package.json
  const pkgResult = await validator.validatePackageJson('package.json')
  validator.printResult('package.json', pkgResult)

  // éªŒè¯ tsconfig.json
  const tsResult = await validator.validateTSConfig('tsconfig.json')
  validator.printResult('tsconfig.json', tsResult)
}

main()
```

---

## åœºæ™¯ 4ï¼šæ–‡æ¡£ç”Ÿæˆå™¨

**ä»»åŠ¡ï¼š** ä»ä»£ç æ³¨é‡Šç”Ÿæˆ API æ–‡æ¡£

```typescript
// doc-generator.ts
import fs from 'fs'

interface FunctionDoc {
  name: string
  description: string
  params: Array<{ name: string; type: string; description: string }>
  returns: { type: string; description: string }
  example?: string
}

class DocGenerator {
  /**
   * ä»æ–‡ä»¶ç”Ÿæˆæ–‡æ¡£
   */
  async generateDocs(filePath: string): Promise<string> {
    console.log(`\n=== Generating docs for ${filePath} ===\n`)

    // ä½¿ç”¨ read å·¥å…·è¯»å–æ–‡ä»¶
    const content = fs.readFileSync(filePath, 'utf-8')
    const lines = content.split('\n')

    // æå–å‡½æ•°æ–‡æ¡£
    const functions = this.extractFunctions(lines)

    // ç”Ÿæˆ Markdown
    return this.generateMarkdown(filePath, functions)
  }

  /**
   * æå–å‡½æ•°åŠå…¶æ–‡æ¡£
   */
  private extractFunctions(lines: string[]): FunctionDoc[] {
    const functions: FunctionDoc[] = []
    let i = 0

    while (i < lines.length) {
      const line = lines[i]

      // æ£€æµ‹ JSDoc æ³¨é‡Šå¼€å§‹
      if (line.trim() === '/**') {
        const doc = this.parseJSDoc(lines, i)
        if (doc) {
          functions.push(doc)
        }
      }

      i++
    }

    return functions
  }

  /**
   * è§£æ JSDoc æ³¨é‡Š
   */
  private parseJSDoc(lines: string[], startIndex: number): FunctionDoc | null {
    let i = startIndex + 1
    const docLines: string[] = []

    // è¯»å–æ³¨é‡Šå†…å®¹
    while (i < lines.length && !lines[i].includes('*/')) {
      const line = lines[i].trim()
      if (line.startsWith('*')) {
        docLines.push(line.substring(1).trim())
      }
      i++
    }

    // è·³è¿‡æ³¨é‡Šç»“æŸç¬¦
    i++

    // æŸ¥æ‰¾å‡½æ•°å®šä¹‰
    while (i < lines.length && lines[i].trim() === '') {
      i++
    }

    if (i >= lines.length) return null

    const functionLine = lines[i]
    const functionMatch = functionLine.match(/(?:export\s+)?(?:async\s+)?function\s+(\w+)/)

    if (!functionMatch) return null

    const functionName = functionMatch[1]

    // è§£ææ–‡æ¡£å†…å®¹
    let description = ''
    const params: Array<{ name: string; type: string; description: string }> = []
    let returns = { type: 'void', description: '' }
    let example = ''

    let currentSection = 'description'

    for (const line of docLines) {
      if (line.startsWith('@param')) {
        currentSection = 'param'
        const match = line.match(/@param\s+{(\w+)}\s+(\w+)\s+-\s+(.+)/)
        if (match) {
          params.push({
            type: match[1],
            name: match[2],
            description: match[3]
          })
        }
      } else if (line.startsWith('@returns')) {
        currentSection = 'returns'
        const match = line.match(/@returns\s+{(\w+)}\s+(.+)/)
        if (match) {
          returns = {
            type: match[1],
            description: match[2]
          }
        }
      } else if (line.startsWith('@example')) {
        currentSection = 'example'
      } else if (currentSection === 'description' && line) {
        description += line + ' '
      } else if (currentSection === 'example' && line) {
        example += line + '\n'
      }
    }

    return {
      name: functionName,
      description: description.trim(),
      params,
      returns,
      example: example.trim() || undefined
    }
  }

  /**
   * ç”Ÿæˆ Markdown æ–‡æ¡£
   */
  private generateMarkdown(filePath: string, functions: FunctionDoc[]): string {
    let md = `# API Documentation\n\n`
    md += `> Generated from ${filePath}\n\n`
    md += `## Functions\n\n`

    for (const func of functions) {
      md += `### ${func.name}\n\n`
      md += `${func.description}\n\n`

      if (func.params.length > 0) {
        md += `**Parameters:**\n\n`
        for (const param of func.params) {
          md += `- \`${param.name}\` (\`${param.type}\`) - ${param.description}\n`
        }
        md += `\n`
      }

      md += `**Returns:** \`${func.returns.type}\`\n\n`
      if (func.returns.description) {
        md += `${func.returns.description}\n\n`
      }

      if (func.example) {
        md += `**Example:**\n\n`
        md += `\`\`\`typescript\n${func.example}\`\`\`\n\n`
      }

      md += `---\n\n`
    }

    return md
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const generator = new DocGenerator()

  // ç”Ÿæˆæ–‡æ¡£
  const docs = await generator.generateDocs('src/api.ts')

  // è¾“å‡ºåˆ°æ§åˆ¶å°
  console.log(docs)

  // æˆ–ä¿å­˜åˆ°æ–‡ä»¶
  fs.writeFileSync('docs/api.md', docs)
  console.log('\nâœ… Documentation generated: docs/api.md')
}

main()
```

---

## æœ€ä½³å®è·µæ€»ç»“

### 1. é”™è¯¯å¤„ç†

```typescript
// âœ… å¥½çš„åšæ³•
try {
  const content = fs.readFileSync(filePath, 'utf-8')
  // å¤„ç†å†…å®¹
} catch (error) {
  if (error.code === 'ENOENT') {
    console.error(`File not found: ${filePath}`)
  } else {
    console.error(`Error reading file: ${error.message}`)
  }
}
```

### 2. å¤§æ–‡ä»¶å¤„ç†

```typescript
// âœ… å¥½çš„åšæ³•ï¼šåˆ†æ‰¹è¯»å–
const content = fs.readFileSync(filePath, 'utf-8')
const lines = content.split('\n')

// åªå¤„ç†å‰ 1000 è¡Œ
const preview = lines.slice(0, 1000)
```

### 3. ç¼–ç å¤„ç†

```typescript
// âœ… å¥½çš„åšæ³•ï¼šæŒ‡å®šç¼–ç 
const content = fs.readFileSync(filePath, 'utf-8')
```

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2026-02-19
**ç»´æŠ¤è€…ï¼š** Claude Code
