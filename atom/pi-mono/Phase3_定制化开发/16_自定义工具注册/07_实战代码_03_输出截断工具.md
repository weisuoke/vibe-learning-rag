# 实战代码 03：输出截断工具

> **基于 pi-mono truncated-tool.ts 示例 + 2025-2026 性能优化最佳实践**

---

## 场景描述

实现一个支持输出截断的工具（以 ripgrep 为例），展示如何处理大量输出避免 LLM 上下文溢出。核心特性：

- **输出限制**：50KB 或 2000 行（先达到者为准）
- **完整输出保存**：截断时保存到临时文件
- **LLM 通知**：告知 LLM 输出被截断及完整文件位置
- **自定义渲染**：展示截断状态和统计信息

**2025-2026 行业趋势：**
- **AgentDiet 轨迹压缩**：减少工具输出 token 40%-60%（来源：[AgentDiet](https://arxiv.org/abs/2509.23586)）
- **结构化输出截断**：处理 max_tokens 导致的 JSON 截断（来源：[LLM Structured Output 2026](https://dev.to/pockit_tools/llm-structured-output-in-2026-stop-parsing-json-with-regex-and-do-it-right-34pk)）
- **上下文窗口管理**：6 种技术优化 LLM 上下文长度（来源：[Context Management](https://agenta.ai/blog/top-6-techniques-to-manage-context-length-in-llms)）
- **oh-my-pi 截断实现**：字节/行限制 + 流式处理（来源：[oh-my-pi Changelog](https://github.com/can1357/oh-my-pi/blob/main/packages/coding-agent/CHANGELOG.md)）

---

## 完整代码实现

```typescript
/**
 * 输出截断工具 - 基于 pi-mono truncated-tool.ts
 *
 * 核心特性：
 * 1. 使用内置截断工具（truncateHead/truncateTail）
 * 2. 截断时保存完整输出到临时文件
 * 3. 通知 LLM 截断信息和文件位置
 * 4. 自定义渲染展示截断状态
 *
 * 2025-2026 最佳实践：
 * - 默认限制：50KB 或 2000 行
 * - 头部截断（truncateHead）：适合搜索结果
 * - 尾部截断（truncateTail）：适合日志/命令输出
 * - 临时文件存储：让 LLM 可以按需读取完整输出
 *
 * 参考：
 * - pi-mono: packages/coding-agent/examples/extensions/truncated-tool.ts
 * - AgentDiet: https://arxiv.org/abs/2509.23586
 * - 上下文管理: https://agenta.ai/blog/top-6-techniques-to-manage-context-length-in-llms
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import {
  DEFAULT_MAX_BYTES,
  DEFAULT_MAX_LINES,
  formatSize,
  type TruncationResult,
  truncateHead,
} from "@mariozechner/pi-coding-agent";
import { Text } from "@mariozechner/pi-tui";
import { Type } from "@sinclair/typebox";
import { execSync } from "child_process";
import { mkdtempSync, writeFileSync } from "fs";
import { tmpdir } from "os";
import { join } from "path";

// ============================================================================
// Schema 定义
// ============================================================================

const RgParams = Type.Object({
  pattern: Type.String({ description: "Search pattern (regex)" }),
  path: Type.Optional(Type.String({
    description: "Directory to search (default: current directory)"
  })),
  glob: Type.Optional(Type.String({
    description: "File glob pattern, e.g. '*.ts'"
  })),
});

interface RgDetails {
  pattern: string;
  path?: string;
  glob?: string;
  matchCount: number;
  truncation?: TruncationResult;
  fullOutputPath?: string;
}

// ============================================================================
// 工具注册
// ============================================================================

export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "rg",
    label: "ripgrep",

    /**
     * 工具描述 - 明确告知 LLM 截断限制
     *
     * 2025-2026 最佳实践：
     * - 在描述中说明截断限制
     * - 让 LLM 知道完整输出会保存到文件
     * - 避免 LLM 因输出不完整而困惑
     */
    description: `Search file contents using ripgrep. Output is truncated to ${DEFAULT_MAX_LINES} lines or ${formatSize(DEFAULT_MAX_BYTES)} (whichever is hit first). If truncated, full output is saved to a temp file.`,

    parameters: RgParams,

    async execute(_toolCallId, params, _signal, _onUpdate, ctx) {
      const { pattern, path: searchPath, glob } = params;

      // ----------------------------------------------------------------------
      // 1. 构建 ripgrep 命令
      // ----------------------------------------------------------------------
      const args = ["rg", "--line-number", "--color=never"];
      if (glob) args.push("--glob", glob);
      args.push(pattern);
      args.push(searchPath || ".");

      // ----------------------------------------------------------------------
      // 2. 执行命令并捕获输出
      // ----------------------------------------------------------------------
      let output: string;
      try {
        output = execSync(args.join(" "), {
          cwd: ctx.cwd,
          encoding: "utf-8",
          maxBuffer: 100 * 1024 * 1024, // 100MB buffer 捕获完整输出
        });
      } catch (err: any) {
        // ripgrep 在无匹配时返回退出码 1
        if (err.status === 1) {
          return {
            content: [{ type: "text", text: "No matches found" }],
            details: {
              pattern,
              path: searchPath,
              glob,
              matchCount: 0
            } as RgDetails,
          };
        }
        throw new Error(`ripgrep failed: ${err.message}`);
      }

      if (!output.trim()) {
        return {
          content: [{ type: "text", text: "No matches found" }],
          details: {
            pattern,
            path: searchPath,
            glob,
            matchCount: 0
          } as RgDetails,
        };
      }

      // ----------------------------------------------------------------------
      // 3. 应用截断 - 使用内置工具
      // ----------------------------------------------------------------------
      /**
       * truncateHead vs truncateTail
       *
       * truncateHead：保留前 N 行/字节
       * - 适合：搜索结果、文件列表
       * - 原因：用户通常关心前几个匹配
       *
       * truncateTail：保留后 N 行/字节
       * - 适合：日志、命令输出
       * - 原因：最新的输出通常最重要
       *
       * 2025-2026 最佳实践：
       * - 默认限制：50KB (DEFAULT_MAX_BYTES)
       * - 默认行数：2000 (DEFAULT_MAX_LINES)
       * - 先达到者为准
       */
      const truncation = truncateHead(output, {
        maxLines: DEFAULT_MAX_LINES,
        maxBytes: DEFAULT_MAX_BYTES,
      });

      // ----------------------------------------------------------------------
      // 4. 统计匹配数
      // ----------------------------------------------------------------------
      const matchCount = output.split("\n").filter((line) => line.trim()).length;

      const details: RgDetails = {
        pattern,
        path: searchPath,
        glob,
        matchCount,
      };

      let resultText = truncation.content;

      // ----------------------------------------------------------------------
      // 5. 处理截断情况
      // ----------------------------------------------------------------------
      if (truncation.truncated) {
        /**
         * 保存完整输出到临时文件
         *
         * 为什么需要？
         * - LLM 可能需要完整输出进行分析
         * - 用户可以使用 read 工具读取完整文件
         * - 避免信息丢失
         *
         * 2025-2026 最佳实践：
         * - 使用系统临时目录
         * - 文件名包含工具名称（便于识别）
         * - 在 details 中记录文件路径
         */
        const tempDir = mkdtempSync(join(tmpdir(), "pi-rg-"));
        const tempFile = join(tempDir, "output.txt");
        writeFileSync(tempFile, output);

        details.truncation = truncation;
        details.fullOutputPath = tempFile;

        // 添加截断通知
        const truncatedLines = truncation.totalLines - truncation.outputLines;
        const truncatedBytes = truncation.totalBytes - truncation.outputBytes;

        resultText += `\n\n[Output truncated: showing ${truncation.outputLines} of ${truncation.totalLines} lines`;
        resultText += ` (${formatSize(truncation.outputBytes)} of ${formatSize(truncation.totalBytes)}).`;
        resultText += ` ${truncatedLines} lines (${formatSize(truncatedBytes)}) omitted.`;
        resultText += ` Full output saved to: ${tempFile}]`;
      }

      return {
        content: [{ type: "text", text: resultText }],
        details,
      };
    },

    // ========================================================================
    // 自定义渲染 - renderCall
    // ========================================================================
    /**
     * 渲染工具调用
     *
     * 显示：
     * - 工具名称（rg）
     * - 搜索模式
     * - 搜索路径（如果指定）
     * - glob 模式（如果指定）
     */
    renderCall(args, theme) {
      let text = theme.fg("toolTitle", theme.bold("rg "));
      text += theme.fg("accent", `"${args.pattern}"`);
      if (args.path) {
        text += theme.fg("muted", ` in ${args.path}`);
      }
      if (args.glob) {
        text += theme.fg("dim", ` --glob ${args.glob}`);
      }
      return new Text(text, 0, 0);
    },

    // ========================================================================
    // 自定义渲染 - renderResult
    // ========================================================================
    /**
     * 渲染工具结果
     *
     * 显示：
     * - 匹配数量
     * - 截断警告（如果被截断）
     * - 前 20 行匹配（展开模式）
     * - 完整输出文件路径（如果被截断）
     *
     * 2025-2026 最佳实践：
     * - 使用颜色区分状态（成功、警告）
     * - 展开模式显示更多细节
     * - 提供完整输出的访问路径
     */
    renderResult(result, { expanded, isPartial }, theme) {
      const details = result.details as RgDetails | undefined;

      // 处理流式/部分结果
      if (isPartial) {
        return new Text(theme.fg("warning", "Searching..."), 0, 0);
      }

      // 无匹配
      if (!details || details.matchCount === 0) {
        return new Text(theme.fg("dim", "No matches found"), 0, 0);
      }

      // 构建结果显示
      let text = theme.fg("success", `${details.matchCount} matches`);

      // 显示截断警告
      if (details.truncation?.truncated) {
        text += theme.fg("warning", " (truncated)");
      }

      // 展开模式：显示实际匹配内容
      if (expanded) {
        const content = result.content[0];
        if (content?.type === "text") {
          // 显示前 20 行
          const lines = content.text.split("\n").slice(0, 20);
          for (const line of lines) {
            text += `\n${theme.fg("dim", line)}`;
          }
          if (content.text.split("\n").length > 20) {
            text += `\n${theme.fg("muted", "... (use read tool to see full output)")}`;
          }
        }

        // 显示完整输出文件路径
        if (details.fullOutputPath) {
          text += `\n${theme.fg("dim", `Full output: ${details.fullOutputPath}`)}`;
        }
      }

      return new Text(text, 0, 0);
    },
  });
}
```

---

## 预期输出

### 场景 1：小输出（无截断）

**LLM 调用：**
```json
{
  "tool": "rg",
  "params": {
    "pattern": "function.*execute",
    "glob": "*.ts"
  }
}
```

**返回结果：**
```
src/tools/question.ts:43:    async execute(_toolCallId, params, _signal, _onUpdate, ctx) {
src/tools/todo.ts:144:    async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
src/tools/rg.ts:55:    async execute(_toolCallId, params, _signal, _onUpdate, ctx) {

3 matches
```

### 场景 2：大输出（被截断）

**LLM 调用：**
```json
{
  "tool": "rg",
  "params": {
    "pattern": "import",
    "path": "src"
  }
}
```

**返回结果：**
```
src/index.ts:1:import { ExtensionAPI } from "@mariozechner/pi-coding-agent";
src/index.ts:2:import { question } from "./tools/question";
... (1998 more lines)

[Output truncated: showing 2000 of 5432 lines (49.8 KB of 127.3 KB).
3432 lines (77.5 KB) omitted.
Full output saved to: /tmp/pi-rg-abc123/output.txt]

5432 matches (truncated)
```

**LLM 后续操作：**
```json
{
  "tool": "read",
  "params": {
    "file_path": "/tmp/pi-rg-abc123/output.txt",
    "offset": 2000,
    "limit": 100
  }
}
```

---

## 2025-2026 最佳实践

### 1. 截断策略选择

**truncateHead（头部截断）：**
```typescript
const truncation = truncateHead(output, {
  maxLines: DEFAULT_MAX_LINES,
  maxBytes: DEFAULT_MAX_BYTES,
});
```

**适用场景：**
- 搜索结果（前几个匹配最重要）
- 文件列表（按字母顺序）
- 目录树（顶层结构最重要）

**truncateTail（尾部截断）：**
```typescript
const truncation = truncateTail(output, {
  maxLines: DEFAULT_MAX_LINES,
  maxBytes: DEFAULT_MAX_BYTES,
});
```

**适用场景：**
- 日志输出（最新日志最重要）
- 命令执行结果（最后的输出最重要）
- 构建输出（错误通常在最后）

### 2. 默认限制值

**pi-mono 默认值：**
```typescript
DEFAULT_MAX_LINES = 2000;  // 2000 行
DEFAULT_MAX_BYTES = 50 * 1024;  // 50 KB
```

**为什么这些值？**
- **2000 行**：足够展示大部分搜索结果
- **50 KB**：约 10k tokens（LLM 上下文的合理部分）
- **先达到者为准**：避免极端情况（如单行超长）

**2025-2026 行业趋势：**
- **AgentDiet**：压缩工具输出 40%-60%（来源：[AgentDiet](https://arxiv.org/abs/2509.23586)）
- **动态限制**：根据上下文窗口使用情况调整
- **智能摘要**：使用 LLM 摘要长输出

### 3. 临时文件管理

**保存完整输出：**
```typescript
if (truncation.truncated) {
  const tempDir = mkdtempSync(join(tmpdir(), "pi-rg-"));
  const tempFile = join(tempDir, "output.txt");
  writeFileSync(tempFile, output);

  details.fullOutputPath = tempFile;
}
```

**为什么需要？**
- LLM 可以按需读取完整输出
- 用户可以手动查看完整结果
- 避免信息丢失

**清理策略：**
- 临时文件在系统重启时自动清理
- 可以实现自定义清理逻辑（如会话结束时）

### 4. 通知 LLM

**截断通知格式：**
```typescript
resultText += `\n\n[Output truncated: showing ${truncation.outputLines} of ${truncation.totalLines} lines`;
resultText += ` (${formatSize(truncation.outputBytes)} of ${formatSize(truncation.totalBytes)}).`;
resultText += ` ${truncatedLines} lines (${formatSize(truncatedBytes)}) omitted.`;
resultText += ` Full output saved to: ${tempFile}]`;
```

**为什么重要？**
- LLM 知道输出不完整
- LLM 可以决定是否需要读取完整输出
- 避免 LLM 基于不完整信息做出错误判断

### 5. 性能优化

**大 buffer 捕获完整输出：**
```typescript
execSync(command, {
  maxBuffer: 100 * 1024 * 1024, // 100MB
});
```

**为什么？**
- 确保捕获完整输出（即使很大）
- 在内存中处理（比临时文件快）
- 只在截断时才写入文件

**2025-2026 优化技术：**
- **流式处理**：边读边截断（来源：[oh-my-pi](https://github.com/can1357/oh-my-pi/blob/main/packages/coding-agent/CHANGELOG.md)）
- **压缩存储**：使用 gzip 压缩临时文件
- **增量读取**：支持分页读取大文件

---

## 扩展应用场景

### 1. 日志查看工具

```typescript
// 使用 truncateTail 保留最新日志
const truncation = truncateTail(logOutput, {
  maxLines: 1000,
  maxBytes: 50 * 1024,
});
```

### 2. 文件内容读取

```typescript
// 大文件自动截断
const truncation = truncateHead(fileContent, {
  maxLines: 500,
  maxBytes: 25 * 1024,
});

if (truncation.truncated) {
  resultText += `\n[File too large. Use read tool with offset/limit for specific sections]`;
}
```

### 3. 命令执行输出

```typescript
// 命令输出截断
const truncation = truncateTail(commandOutput, {
  maxLines: 100,
  maxBytes: 10 * 1024,
});
```

### 4. API 响应处理

```typescript
// API 响应截断
const responseText = JSON.stringify(apiResponse, null, 2);
const truncation = truncateHead(responseText, {
  maxLines: 200,
  maxBytes: 20 * 1024,
});
```

---

## 常见问题

### Q1: 为什么不直接限制命令输出？

**A:** 因为需要完整输出来：
- 统计准确的匹配数
- 保存到临时文件供后续访问
- 提供准确的截断统计信息

### Q2: 如何选择 truncateHead 还是 truncateTail？

**A:** 根据数据特性：
- **时间序列数据**（日志、事件）→ truncateTail
- **搜索结果**（相关性排序）→ truncateHead
- **文件列表**（字母顺序）→ truncateHead

### Q3: 临时文件会占用大量磁盘空间吗？

**A:** 不会，因为：
- 只在截断时才创建
- 使用系统临时目录（自动清理）
- 可以实现自定义清理策略

### Q4: LLM 如何知道输出被截断？

**A:** 通过：
- 工具描述中说明截断限制
- 返回内容中的截断通知
- details 中的 truncation 字段

---

## 参考资料

### Pi-mono 源码
- **truncated-tool.ts**：`sourcecode/pi-mono/packages/coding-agent/examples/extensions/truncated-tool.ts`
- **截断工具**：`sourcecode/pi-mono/packages/coding-agent/src/core/tools/truncation.ts`

### 2025-2026 行业标准
- **AgentDiet 轨迹压缩**：https://arxiv.org/abs/2509.23586
- **LLM 结构化输出截断**：https://dev.to/pockit_tools/llm-structured-output-in-2026-stop-parsing-json-with-regex-and-do-it-right-34pk
- **上下文管理技术**：https://agenta.ai/blog/top-6-techniques-to-manage-context-length-in-llms
- **oh-my-pi 实现**：https://github.com/can1357/oh-my-pi/blob/main/packages/coding-agent/CHANGELOG.md

### 相关文档
- **03_核心概念_03_Execute执行函数.md**：execute 函数详解
- **03_核心概念_08_性能优化.md**：性能优化最佳实践

---

**版本：** v1.0
**最后更新：** 2026-02-21
**作者：** Claude Code
**基于：** pi-mono truncated-tool.ts + 2025-2026 性能优化标准
