# 化骨绵掌 - 10个2分钟知识卡片

> **学习目标**：通过10个精炼的知识卡片，快速掌握条件执行与分支的核心要点。
> **使用方法**：每个卡片2分钟，总计20分钟快速复习。

---

## 卡片1: 直觉理解（是什么）

### 一句话定义

**条件执行与分支是根据运行时条件动态选择执行路径的机制。**

### 日常类比

就像红绿灯路口：
- **红灯** → 停车等待
- **黄灯** → 减速准备
- **绿灯** → 继续前进
- **红绿灯坏了** → 按默认规则（减速慢行）

### 核心价值

1. **智能路由**：根据输入特征选择最优处理路径
2. **成本优化**：简单任务用便宜的小模型，复杂任务用强大的大模型
3. **错误降级**：主模型失败时自动切换到备用模型

### 2分钟记忆

**条件执行让 AI 系统能够"思考"后再行动，根据不同场景选择最优策略。**

---

## 卡片2: 形式化定义

### 数学表示

```
f(x) = {
  h₁(x)  if c₁(x) = True
  h₂(x)  if c₂(x) = True
  ...
  hₙ(x)  otherwise (default)
}
```

其中：
- `x`：输入
- `cᵢ(x)`：第 i 个条件函数
- `hᵢ(x)`：第 i 个处理函数
- `hₙ(x)`：默认处理函数

### 执行流程

```
输入 x
  ↓
检查条件 c₁(x)
  ↓ True        ↓ False
执行 h₁(x)    检查条件 c₂(x)
              ↓ True        ↓ False
            执行 h₂(x)    ...
                          ↓
                        执行 hₙ(x) (默认)
```

### 关键特性

1. **顺序检查**：从上到下依次检查条件
2. **短路执行**：第一个满足的条件对应的处理函数会被执行
3. **默认兜底**：如果所有条件都不满足，执行默认处理

### 2分钟记忆

**条件执行是一个从上到下的条件检查过程，第一个满足的条件对应的处理函数会被执行。**

---

## 卡片3: RunnableBranch 核心

### 基本语法

```python
from langchain_core.runnables import RunnableBranch

branch = RunnableBranch(
    (条件函数1, 处理链1),  # 如果条件1为真，执行处理链1
    (条件函数2, 处理链2),  # 如果条件2为真，执行处理链2
    默认处理链              # 如果所有条件都不满足，执行默认处理链
)
```

### 完整示例

```python
from langchain_core.runnables import RunnableBranch
from langchain_openai import ChatOpenAI

# 定义模型
gpt4_mini = ChatOpenAI(model="gpt-4o-mini")
gpt4 = ChatOpenAI(model="gpt-4")

# 创建条件分支
branch = RunnableBranch(
    (lambda x: len(x["input"]) < 100, gpt4_mini),  # 简单问题
    gpt4  # 复杂问题（默认）
)

# 使用
result = branch.invoke({"input": "什么是Python?"})
```

### 关键点

1. **元组格式**：`(条件函数, 处理链)`
2. **条件函数**：接收输入，返回布尔值
3. **默认分支**：最后一个参数，不需要条件
4. **可组合**：可以与其他 Runnable 使用管道操作符组合

### 2分钟记忆

**RunnableBranch 接收多个 `(条件, 处理链)` 元组和一个默认处理链，根据条件动态选择执行路径。**

---

## 卡片4: 动态路由核心

### 什么是动态路由

**动态路由是根据输入特征在运行时动态选择处理模型或处理链的机制。**

### 三种路由策略

#### 1. 基于输入特征

```python
# 根据输入长度路由
branch = RunnableBranch(
    (lambda x: len(x["input"]) < 50, simple_handler),
    (lambda x: len(x["input"]) < 200, medium_handler),
    complex_handler
)
```

#### 2. 基于任务复杂度

```python
# 根据任务复杂度路由
def is_complex(x):
    return len(x["input"]) > 100 or "详细分析" in x["input"]

branch = RunnableBranch(
    (is_complex, gpt4),      # 复杂任务用大模型
    gpt4_mini                # 简单任务用小模型
)
```

#### 3. 基于业务规则

```python
# 根据用户等级路由
def is_premium(x):
    return x.get("user", {}).get("tier") == "premium"

branch = RunnableBranch(
    (is_premium, premium_chain),  # 高级用户
    standard_chain                # 普通用户
)
```

### 核心价值

- **成本优化**：降低 60-70% 的 LLM 调用成本
- **性能优化**：小模型响应更快，整体延迟降低 50%+
- **用户体验**：根据不同场景提供最优处理

### 2分钟记忆

**动态路由根据输入特征、任务复杂度或业务规则在运行时选择最优处理路径，实现成本和性能的双重优化。**

---

## 卡片5: 条件判断核心

### 条件函数的设计原则

#### 1. 快速执行（毫秒级）

```python
# ✅ 好：简单规则（~1ms）
def is_simple(x):
    return len(x["input"]) < 50

# ❌ 不好：调用 LLM（~1000ms）
def is_simple(x):
    result = llm.invoke(f"判断是否简单：{x['input']}")
    return "简单" in result.content
```

#### 2. 可测试性

```python
# ✅ 好：纯函数或依赖注入
class Router:
    def __init__(self, threshold):
        self.threshold = threshold

    def is_simple(self, x):
        return len(x["input"]) < self.threshold

# 测试
router = Router(threshold=50)
assert router.is_simple({"input": "hi"}) == True
```

#### 3. 可维护性

```python
# ✅ 好：清晰的命名和逻辑
def is_complex_query(x):
    """判断是否为复杂查询"""
    return (
        len(x["input"]) > 100 or
        "详细分析" in x["input"] or
        "深入探讨" in x["input"]
    )
```

### Lambda vs 命名函数

| 场景 | 推荐 | 示例 |
|------|------|------|
| 简单条件 | Lambda | `lambda x: len(x["input"]) < 50` |
| 复杂条件 | 命名函数 | `def is_complex(x): ...` |
| 需要复用 | 命名函数 | `def is_premium_user(x): ...` |
| 需要测试 | 命名函数 | `def should_use_gpt4(x): ...` |

### 2分钟记忆

**条件函数应该快速（毫秒级）、可测试、可维护。简单条件用 lambda，复杂条件用命名函数。**

---

## 卡片6: 编程实现

### 最小可用示例

```python
from langchain_core.runnables import RunnableBranch
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

# 1. 定义模型
gpt4_mini = ChatOpenAI(model="gpt-4o-mini", temperature=0)
gpt4 = ChatOpenAI(model="gpt-4", temperature=0)

# 2. 定义 prompt
prompt = ChatPromptTemplate.from_template("请回答：{question}")

# 3. 定义条件函数
def is_simple(x):
    return len(x["question"]) < 50

# 4. 创建条件分支
router = RunnableBranch(
    (is_simple, gpt4_mini),  # 简单问题用小模型
    gpt4                     # 复杂问题用大模型
)

# 5. 组合成完整的链
chain = prompt | router

# 6. 使用
result = chain.invoke({"question": "什么是Python?"})
print(result.content)
```

### 与管道操作符组合

```python
# 完整的处理链
chain = (
    prompt_template          # 1. 格式化 prompt
    | model_router           # 2. 根据条件选择模型
    | output_parser          # 3. 解析输出
)
```

### 多级路由

```python
# 第一级：根据用户类型路由
user_router = RunnableBranch(
    (lambda x: x["user"]["tier"] == "premium", premium_router),
    standard_router
)

# 第二级：根据任务复杂度路由
premium_router = RunnableBranch(
    (lambda x: len(x["input"]) < 100, gpt4_mini),
    gpt4
)
```

### 2分钟记忆

**RunnableBranch 可以像其他 Runnable 一样使用管道操作符组合，支持多级路由。**

---

## 卡片7: 对比区分（vs if-else）

### 核心区别

| 维度 | if-else | RunnableBranch |
|------|---------|----------------|
| **抽象层级** | 控制流 | 数据流 |
| **执行时机** | 编译时确定 | 运行时动态 |
| **可组合性** | 难以组合 | 无缝组合 |
| **可观测性** | 需要手动日志 | 自动 tracing |
| **错误处理** | 手动 try-catch | 支持 fallback |

### 何时使用 if-else

```python
# ✅ 适合用 if-else：简单的条件判断
def validate_input(user_input):
    if len(user_input) < 10:
        return "输入太短"
    elif len(user_input) > 1000:
        return "输入太长"
    else:
        return process(user_input)
```

**特点**：
- 条件简单明了
- 不需要与其他 Runnable 组合
- 代码更易读

### 何时使用 RunnableBranch

```python
# ✅ 适合用 RunnableBranch：需要与其他 Runnable 组合
chain = (
    prompt_template
    | RunnableBranch(
        (lambda x: len(x["input"]) < 100, gpt4_mini),
        gpt4
    )
    | output_parser
)
```

**特点**：
- 需要与其他 Runnable 组合
- 需要利用 LCEL 的特性（streaming、tracing）
- 条件逻辑是处理链的一部分

### 2分钟记忆

**简单条件用 if-else，需要组合时用 RunnableBranch。可读性优先。**

---

## 卡片8: 进阶理解（多级路由）

### 什么是多级路由

**多级路由是将路由逻辑分层，每一层根据不同的维度做路由决策。**

### 为什么需要多级路由

1. **降低复杂度**：避免单层路由的条件过多
2. **提高可维护性**：每一层关注一个维度
3. **更灵活**：可以根据不同层级的条件组合出更多路由策略

### 实现示例

```python
# 第一级：根据用户类型路由
user_type_router = RunnableBranch(
    (lambda x: x["user"]["tier"] == "premium", premium_router),
    (lambda x: x["user"]["tier"] == "standard", standard_router),
    guest_router
)

# 第二级：根据任务复杂度路由（高级用户）
premium_router = RunnableBranch(
    (lambda x: len(x["input"]) < 50, gpt4_mini),
    (lambda x: len(x["input"]) < 200, gpt4),
    claude_opus  # 复杂任务用最强模型
)

# 第二级：根据任务复杂度路由（普通用户）
standard_router = RunnableBranch(
    (lambda x: len(x["input"]) < 50, gpt4_mini),
    gpt4_mini  # 普通用户只能用小模型
)

# 第二级：游客路由
guest_router = gpt4_mini  # 游客只能用小模型
```

### 路由决策树

```
输入
  ↓
用户类型？
  ├─ Premium → 任务复杂度？
  │              ├─ 简单 → GPT-4o-mini
  │              ├─ 中等 → GPT-4
  │              └─ 复杂 → Claude Opus
  ├─ Standard → 任务复杂度？
  │              ├─ 简单 → GPT-4o-mini
  │              └─ 其他 → GPT-4o-mini
  └─ Guest → GPT-4o-mini
```

### 2分钟记忆

**多级路由将路由逻辑分层，每一层关注一个维度，降低复杂度，提高可维护性。**

---

## 卡片9: 在 AI Agent 中的使用

### AI Agent 中的典型应用

#### 1. 工具选择

```python
# 根据用户意图选择工具
tool_router = RunnableBranch(
    (lambda x: "搜索" in x["input"], search_tool),
    (lambda x: "计算" in x["input"], calculator_tool),
    (lambda x: "天气" in x["input"], weather_tool),
    chat_tool  # 默认：闲聊
)
```

#### 2. 多模型协作

```python
# 根据任务类型选择专家模型
expert_router = RunnableBranch(
    (lambda x: "代码" in x["task"], code_expert),      # 代码专家
    (lambda x: "数学" in x["task"], math_expert),      # 数学专家
    (lambda x: "写作" in x["task"], writing_expert),   # 写作专家
    general_expert  # 通用专家
)
```

#### 3. 错误处理与降级

```python
# 主模型失败时自动降级
chain = (
    prompt
    | primary_model.with_fallbacks([
        backup_model_1,  # 第一备用
        backup_model_2,  # 第二备用
        local_model      # 最终兜底
    ])
    | parser
)
```

#### 4. 自适应处理

```python
# 根据历史对话选择策略
adaptive_router = RunnableBranch(
    (lambda x: len(x["history"]) == 0, greeting_chain),     # 首次对话
    (lambda x: len(x["history"]) < 5, exploration_chain),   # 探索阶段
    deep_conversation_chain                                  # 深度对话
)
```

### 实际案例：智能客服系统

```python
# 智能客服路由系统
customer_service_router = RunnableBranch(
    # VIP 用户 + 复杂问题 → 高级客服
    (lambda x: x["user"]["tier"] == "VIP" and is_complex(x),
     senior_agent),

    # VIP 用户 + 简单问题 → AI 客服
    (lambda x: x["user"]["tier"] == "VIP" and is_simple(x),
     ai_service),

    # 付费用户 + 复杂问题 → 标准客服
    (lambda x: x["user"]["tier"] == "premium" and is_complex(x),
     standard_agent),

    # 简单问题 → AI 客服
    (lambda x: is_simple(x),
     ai_service),

    # 默认 → 排队等待
    queue_service
)
```

### 2分钟记忆

**在 AI Agent 中，条件执行用于工具选择、多模型协作、错误降级和自适应处理。**

---

## 卡片10: 总结与延伸

### 核心要点总结

#### 1. 三个核心概念

1. **RunnableBranch**：LCEL 的条件分支组件
2. **动态路由**：根据输入特征选择处理路径
3. **条件函数**：快速、可测试、可维护

#### 2. 三大应用价值

1. **成本优化**：降低 60-70% 的 LLM 调用成本
2. **性能优化**：降低 50%+ 的响应延迟
3. **可靠性保证**：通过错误降级提升系统可用性

#### 3. 三个设计原则

1. **简单优先**：简单条件用 if-else，需要组合时用 RunnableBranch
2. **快速执行**：条件函数应该在毫秒级完成
3. **默认兜底**：总是提供默认分支

### 延伸学习

#### 1. 高级路由策略

- **基于分类器的路由**：使用小模型作为分类器
- **基于强化学习的路由**：根据历史数据优化路由策略
- **基于成本的动态路由**：实时监控成本并调整路由

**参考资料**：
- A Survey on Routing Strategies for Resource Optimisation in Large Language Model-Based Systems (2025)
- https://arxiv.org/html/2502.00409v3

#### 2. 生产级实践

- **监控和可观测性**：使用 LangSmith 追踪路由决策
- **A/B 测试**：对比不同路由策略的效果
- **成本追踪**：实时监控每个分支的成本

**参考资料**：
- Building Production-Ready AI Pipelines with LangChain Runnables (2026)
- https://medium.com/@sajo02/building-production-ready-ai-pipelines-with-langchain-runnables-a-complete-lcel-guide-2f9b27f6d557

#### 3. 多模态路由

- **图像 + 文本**：根据输入类型选择多模态模型
- **语音 + 文本**：根据输入格式选择处理链
- **视频 + 文本**：根据内容类型选择分析模型

### 快速回顾检查清单

- [ ] 理解条件执行的核心概念
- [ ] 掌握 RunnableBranch 的基本用法
- [ ] 能够设计条件函数
- [ ] 理解动态路由的价值
- [ ] 知道何时用 if-else，何时用 RunnableBranch
- [ ] 能够实现多级路由
- [ ] 理解在 AI Agent 中的应用
- [ ] 掌握成本优化策略
- [ ] 理解错误降级机制
- [ ] 能够设计生产级路由系统

### 2分钟记忆

**条件执行与分支通过 RunnableBranch 实现运行时动态路由，是构建智能、高效、可靠的 AI 系统的关键机制。掌握它，你就能在保证质量的前提下大幅降低成本和延迟。**

---

## 使用建议

### 第一次学习

按顺序阅读所有10个卡片，每个卡片2分钟，总计20分钟。

### 快速复习

只看每个卡片的"2分钟记忆"部分，总计10分钟。

### 深度学习

结合其他文档深入学习：
- `03_核心概念_01_RunnableBranch.md`：深入理解 RunnableBranch
- `07_实战代码_02_多模型动态选择.md`：看完整的成本优化案例
- `08_面试必问.md`：准备面试

---

**恭喜你完成了化骨绵掌的学习！** 现在你已经掌握了条件执行与分支的核心要点。
