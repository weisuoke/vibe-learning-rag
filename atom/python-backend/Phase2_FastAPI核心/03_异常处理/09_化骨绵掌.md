# 化骨绵掌

> 10个2分钟知识卡片，快速掌握 FastAPI 异常处理

---

## 卡片1：异常处理的本质

**一句话：** 异常处理是将程序错误转换为用户可理解的信息，通过统一的机制提升用户体验、开发效率和系统可靠性。

**举例：**
```python
# 没有异常处理
user = db.get_user(user_id)
return user.name  # 如果 user 是 None，直接崩溃

# 有异常处理
user = db.get_user(user_id)
if not user:
    raise HTTPException(status_code=404, detail="用户不存在")
return user.name
```

**应用：** 在 AI Agent 开发中，LLM API 调用、数据库操作、文档解析都可能失败，异常处理确保这些错误能被友好地返回给用户。

---

## 卡片2：HTTPException 的特殊性

**一句话：** HTTPException 是 FastAPI 的特殊异常，会被自动捕获并转换为 HTTP 响应，不需要手动处理。

**举例：**
```python
# HTTPException 会被 FastAPI 自动处理
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    if user_id not in users_db:
        raise HTTPException(status_code=404, detail="用户不存在")
    return users_db[user_id]

# 不需要 try/except，FastAPI 会自动返回：
# {"detail": "用户不存在"}
# 状态码: 404
```

**应用：** 简单场景直接用 HTTPException，复杂业务用自定义异常类。

---

## 卡片3：自定义异常类的价值

**一句话：** 自定义异常类封装业务错误，携带上下文信息，通过异常处理器统一处理，代码更清晰易维护。

**举例：**
```python
# 自定义异常类
class UserNotFoundError(Exception):
    def __init__(self, user_id: int):
        self.user_id = user_id
        super().__init__(f"用户 {user_id} 不存在")

# 异常处理器
@app.exception_handler(UserNotFoundError)
async def handler(request: Request, exc: UserNotFoundError):
    return JSONResponse(
        status_code=404,
        content={"error": "用户不存在", "user_id": exc.user_id}
    )

# 使用
raise UserNotFoundError(user_id)  # 清晰直观
```

**应用：** 业务逻辑复杂时，用自定义异常类封装错误，统一处理。

---

## 卡片4：异常处理器的执行顺序

**一句话：** 异常处理器按异常继承关系执行（子类优先于父类），不是按注册顺序。

**举例：**
```python
# 即使 Exception 先注册
@app.exception_handler(Exception)
async def general_handler(request, exc):
    return JSONResponse(status_code=500, content={"error": "通用错误"})

@app.exception_handler(ValueError)
async def value_error_handler(request, exc):
    return JSONResponse(status_code=400, content={"error": "参数错误"})

# raise ValueError() 会被 value_error_handler 捕获
# 因为 ValueError 是 Exception 的子类
```

**应用：** 用父类处理器兜底（Exception），用子类处理器精细化处理（ValueError、SQLAlchemyError）。

---

## 卡片5：全局异常中间件的作用

**一句话：** 全局异常中间件在请求处理流程的最外层，统一添加 request_id、记录日志、根据环境返回不同的错误信息。

**举例：**
```python
class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        try:
            response = await call_next(request)
            response.headers["X-Request-ID"] = request_id
            return response
        except Exception as exc:
            logger.error(f"错误: {exc}")
            return JSONResponse(
                status_code=500,
                content={"error": "服务器错误", "request_id": request_id}
            )

app.add_middleware(ErrorHandlingMiddleware)
```

**应用：** 中间件处理横切关注点（request_id、日志），异常处理器处理具体异常。

---

## 卡片6：统一的错误响应格式

**一句话：** 统一的错误响应格式让前端更容易解析错误，包含 success、error、code、request_id、timestamp 等字段。

**举例：**
```python
def create_error_response(status_code: int, error: str, code: str, request_id: str):
    return JSONResponse(
        status_code=status_code,
        content={
            "success": False,
            "error": error,
            "code": code,
            "request_id": request_id,
            "timestamp": datetime.utcnow().isoformat()
        }
    )

# 所有异常处理器都使用这个函数
@app.exception_handler(UserNotFoundError)
async def handler(request: Request, exc: UserNotFoundError):
    return create_error_response(404, "用户不存在", "USER_NOT_FOUND", request.state.request_id)
```

**应用：** 前端可以统一解析错误，根据 code 字段做不同处理。

---

## 卡片7：环境区分的重要性

**一句话：** 开发环境返回详细错误信息（堆栈跟踪），生产环境只返回通用错误信息，避免泄露敏感信息。

**举例：**
```python
@app.exception_handler(Exception)
async def general_handler(request: Request, exc: Exception):
    logger.error(f"错误: {exc}", exc_info=True)  # 详细日志

    if settings.DEBUG:
        # 开发环境：返回详细错误
        return JSONResponse(
            status_code=500,
            content={
                "error": str(exc),
                "traceback": traceback.format_exc()
            }
        )
    else:
        # 生产环境：返回通用错误
        return JSONResponse(
            status_code=500,
            content={"error": "服务器内部错误"}
        )
```

**应用：** 生产环境不要暴露数据库结构、文件路径等敏感信息。

---

## 卡片8：LLM API 异常的分类处理

**一句话：** LLM API 异常分为可重试（超时）和不可重试（限流、余额不足），需要区分处理。

**举例：**
```python
async def call_llm_with_retry(prompt: str, max_retries: int = 3):
    for attempt in range(max_retries):
        try:
            return await llm.generate(prompt)
        except APITimeoutError:
            # 超时可以重试
            if attempt == max_retries - 1:
                raise
            await asyncio.sleep(2 ** attempt)  # 指数退避
        except RateLimitError:
            # 限流不重试，直接抛出
            raise

@app.exception_handler(RateLimitError)
async def rate_limit_handler(request: Request, exc: RateLimitError):
    return JSONResponse(
        status_code=429,
        content={"error": "请求过多", "retry_after": 60},
        headers={"Retry-After": "60"}
    )
```

**应用：** 超时用指数退避重试，限流返回 429 + Retry-After 响应头。

---

## 卡片9：流式响应的异常处理

**一句话：** 流式响应的异常可能在传输过程中发生，需要在流中发送错误信息，而不是返回错误响应。

**举例：**
```python
@app.post("/chat/stream")
async def chat_stream(message: str):
    async def generate():
        try:
            async for chunk in llm.generate_stream(message):
                yield f"data: {chunk}\n\n"
        except LLMRateLimitError as e:
            # 在流中发送错误信息
            error_data = {"error": e.message, "code": e.code}
            yield f"data: {json.dumps(error_data)}\n\n"

    return StreamingResponse(generate(), media_type="text/event-stream")
```

**应用：** 流式响应的异常处理需要在生成器内部捕获，发送错误数据。

---

## 卡片10：生产级异常处理架构

**一句话：** 生产级异常处理架构包含分层处理、统一格式、请求追踪、环境区分、异常分类五个要素。

**举例：**
```python
# 1. 全局中间件（最外层）
app.add_middleware(ErrorHandlingMiddleware)

# 2. 异常处理器（精细化处理）
@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request, exc):
    return create_error_response(404, "用户不存在", "USER_NOT_FOUND", request.state.request_id)

@app.exception_handler(SQLAlchemyError)
async def db_error_handler(request, exc):
    logger.error(f"数据库错误: {exc}")
    return create_error_response(500, "数据库错误", "DATABASE_ERROR", request.state.request_id)

# 3. 业务代码（抛出异常）
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = db.get_user(user_id)
    if not user:
        raise UserNotFoundError(user_id)
    return user
```

**应用：** 三层架构确保所有异常都能被处理，统一格式便于前端解析，request_id 便于追踪问题。

---

## 知识卡片总结

### 递进关系

```
卡片1：异常处理的本质
    ↓
卡片2：HTTPException 的特殊性
    ↓
卡片3：自定义异常类的价值
    ↓
卡片4：异常处理器的执行顺序
    ↓
卡片5：全局异常中间件的作用
    ↓
卡片6：统一的错误响应格式
    ↓
卡片7：环境区分的重要性
    ↓
卡片8：LLM API 异常的分类处理
    ↓
卡片9：流式响应的异常处理
    ↓
卡片10：生产级异常处理架构
```

---

### 核心要点速查

| 卡片 | 核心要点 | 关键词 |
|------|----------|--------|
| 1 | 异常处理的本质 | 用户体验、开发效率、系统可靠性 |
| 2 | HTTPException 的特殊性 | 自动处理、不需要 try/except |
| 3 | 自定义异常类的价值 | 封装业务错误、携带上下文 |
| 4 | 异常处理器的执行顺序 | 子类优先、不是注册顺序 |
| 5 | 全局异常中间件的作用 | request_id、日志、环境区分 |
| 6 | 统一的错误响应格式 | success、error、code、timestamp |
| 7 | 环境区分的重要性 | 开发详细、生产通用 |
| 8 | LLM API 异常的分类处理 | 超时重试、限流不重试 |
| 9 | 流式响应的异常处理 | 流中发送错误信息 |
| 10 | 生产级异常处理架构 | 三层架构、五个要素 |

---

### 学习路径建议

**第一遍（快速浏览）：**
- 每个卡片花 2 分钟阅读
- 理解核心概念和举例
- 总时间：20 分钟

**第二遍（深入理解）：**
- 每个卡片花 5 分钟
- 运行代码示例
- 思考实际应用
- 总时间：50 分钟

**第三遍（实战练习）：**
- 根据卡片内容实现一个完整的异常处理架构
- 测试各种异常场景
- 总时间：2 小时

---

### 常见问题速查

**Q1: HTTPException 和普通 Exception 有什么区别？**
→ 参考卡片2：HTTPException 会被 FastAPI 自动处理

**Q2: 什么时候用自定义异常类？**
→ 参考卡片3：业务逻辑复杂时，用自定义异常类封装错误

**Q3: 异常处理器的执行顺序是什么？**
→ 参考卡片4：子类优先于父类，不是按注册顺序

**Q4: 全局中间件和异常处理器有什么区别？**
→ 参考卡片5：中间件处理横切关注点，异常处理器处理具体异常

**Q5: 如何处理 LLM API 调用失败？**
→ 参考卡片8：区分可重试和不可重试的异常

**Q6: 如何在流式响应中处理异常？**
→ 参考卡片9：在流中发送错误信息

---

### 实战检查清单

完成学习后，检查你是否能做到：

- [ ] 使用 HTTPException 抛出标准 HTTP 错误
- [ ] 创建自定义异常类封装业务错误
- [ ] 注册异常处理器统一处理特定异常
- [ ] 实现全局异常中间件添加 request_id
- [ ] 设计统一的错误响应格式
- [ ] 根据环境返回不同的错误信息
- [ ] 处理 LLM API 调用失败（超时、限流）
- [ ] 实现重试机制（指数退避）
- [ ] 在流式响应中处理异常
- [ ] 构建生产级异常处理架构

---

### 记忆口诀

**异常处理三部曲：**
1. **抛异常**：HTTPException 或自定义异常类
2. **捕异常**：exception_handler 精细化处理
3. **统一处理**：全局中间件兜底 + 统一格式

**生产级五要素：**
1. **分层处理**：中间件 + 异常处理器 + 业务代码
2. **统一格式**：success、error、code、request_id、timestamp
3. **请求追踪**：request_id 贯穿整个请求生命周期
4. **环境区分**：开发详细、生产通用
5. **异常分类**：业务异常、系统异常、第三方异常

**LLM 异常处理：**
- **超时** → 重试（指数退避）
- **限流** → 不重试（返回 429）
- **余额不足** → 告警通知
- **模型不可用** → 降级处理

---

## 下一步学习

完成化骨绵掌后，你应该：

1. **实战练习**：实现一个完整的 FastAPI 异常处理架构
2. **阅读源码**：阅读 FastAPI 的异常处理源码，理解内部机制
3. **项目应用**：在实际项目中应用异常处理最佳实践
4. **持续优化**：根据实际情况优化异常处理架构

---

**记住：** 异常处理不是可选的，而是生产级应用的必备要素。从简单的 HTTPException 开始，逐步构建完整的异常处理架构。
