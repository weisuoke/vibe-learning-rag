# 自定义Tool - 实战代码02：数据库查询工具

> 完整可运行的数据库查询Tool示例，涵盖订单查询、用户信息查询等场景

---

## 概述

数据库查询是Tool的核心应用场景之一。本文提供完整的、可直接运行的代码示例。

**涵盖场景：**
1. 订单查询Tool
2. 用户信息查询Tool
3. 产品搜索Tool
4. 统计分析Tool

**技术要点：**
- 异步数据库驱动（asyncpg）
- 连接池管理
- SQL注入防护
- 结果格式化
- 错误处理

---

## 环境准备

### 1. 安装依赖

```bash
# 安装必需的库
uv add asyncpg langchain langchain-openai python-dotenv
```

### 2. 配置数据库

创建`.env`文件：

```bash
# 数据库配置
DATABASE_URL=postgresql://user:password@localhost:5432/dbname

# OpenAI API
OPENAI_API_KEY=your_openai_key_here
```

### 3. 创建测试数据库

```sql
-- 创建订单表
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    order_id VARCHAR(20) UNIQUE NOT NULL,
    user_id INTEGER NOT NULL,
    status VARCHAR(20) NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建产品表
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL,
    category VARCHAR(50)
);

-- 插入测试数据
INSERT INTO orders (order_id, user_id, status, total_amount) VALUES
('ORD-123456', 1, 'shipped', 299.99),
('ORD-123457', 1, 'completed', 199.99),
('ORD-123458', 2, 'pending', 399.99);

INSERT INTO users (username, email) VALUES
('alice', 'alice@example.com'),
('bob', 'bob@example.com');

INSERT INTO products (name, price, stock, category) VALUES
('iPhone 15', 999.99, 50, '电子产品'),
('MacBook Pro', 1999.99, 30, '电子产品'),
('AirPods', 199.99, 100, '配件');
```

---

## 示例1：订单查询Tool

### 完整代码

```python
"""
订单查询Tool示例
演示：查询订单详细信息
"""

import os
import asyncpg
from typing import Optional
from langchain.tools import tool
from pydantic import BaseModel, Field
from dotenv import load_dotenv

load_dotenv()

# 全局数据库连接池
db_pool = None

# ===== 1. 初始化数据库连接池 =====
async def init_db_pool():
    """初始化数据库连接池"""
    global db_pool
    if db_pool is None:
        database_url = os.getenv("DATABASE_URL")
        if not database_url:
            raise ValueError("未配置DATABASE_URL环境变量")

        db_pool = await asyncpg.create_pool(
            database_url,
            min_size=5,      # 最小连接数
            max_size=20,     # 最大连接数
            command_timeout=60  # 命令超时（秒）
        )
    return db_pool

# ===== 2. 定义参数Schema =====
class OrderInput(BaseModel):
    """订单查询参数"""
    order_id: str = Field(
        description="订单ID，格式为ORD-XXXXXX（ORD-后跟6位数字）",
        pattern=r'^ORD-\d{6}$'
    )

# ===== 3. 定义Tool =====
@tool(args_schema=OrderInput)
async def get_order_details(order_id: str) -> str:
    """获取订单详细信息

    根据订单ID查询订单的完整信息，包括：
    - 订单状态（pending待支付、paid已支付、shipped已发货、completed已完成）
    - 订单金额
    - 创建时间
    - 用户信息

    适用场景：
    - 用户询问"我的订单ORD-123456怎么样了？"
    - 用户询问"订单ORD-123456的状态"
    - 用户询问"订单ORD-123456什么时候到？"
    - 客服需要查看订单详情

    Args:
        order_id: 订单ID，格式为ORD-XXXXXX

    Returns:
        订单详细信息的文本描述

    注意事项：
    - 如果订单不存在，返回错误提示
    - 只能查询当前用户的订单（生产环境需要权限验证）
    """
    try:
        # 确保连接池已初始化
        pool = await init_db_pool()

        # 从连接池获取连接
        async with pool.acquire() as conn:
            # 查询订单信息
            row = await conn.fetchrow(
                """
                SELECT o.order_id, o.status, o.total_amount, o.created_at,
                       u.username, u.email
                FROM orders o
                JOIN users u ON o.user_id = u.id
                WHERE o.order_id = $1
                """,
                order_id
            )

            if not row:
                return f"错误：订单{order_id}不存在。建议：请检查订单号是否正确。"

            # 格式化订单状态
            status_map = {
                'pending': '待支付',
                'paid': '已支付',
                'shipped': '已发货',
                'completed': '已完成'
            }
            status_cn = status_map.get(row['status'], row['status'])

            # 格式化时间
            created_at = row['created_at'].strftime("%Y-%m-%d %H:%M:%S")

            # 返回格式化结果
            return f"""订单信息：
订单号：{row['order_id']}
状态：{status_cn}
金额：¥{row['total_amount']}
下单时间：{created_at}
用户：{row['username']} ({row['email']})
"""

    except asyncpg.PostgresError as e:
        return f"数据库错误：{str(e)}。建议：请稍后重试或联系技术支持。"

    except Exception as e:
        return f"查询失败：{str(e)}。建议：请联系技术支持。"

# ===== 4. 测试Tool =====
async def test_order_tool():
    """测试订单Tool"""
    print("=== 测试订单Tool ===\n")

    # 测试1：查询存在的订单
    print("测试1：查询存在的订单")
    result = await get_order_details.ainvoke({"order_id": "ORD-123456"})
    print(result)
    print()

    # 测试2：查询不存在的订单
    print("测试2：查询不存在的订单")
    result = await get_order_details.ainvoke({"order_id": "ORD-999999"})
    print(result)
    print()

# ===== 5. 清理资源 =====
async def cleanup():
    """清理数据库连接池"""
    global db_pool
    if db_pool:
        await db_pool.close()

if __name__ == "__main__":
    import asyncio

    async def main():
        try:
            await test_order_tool()
        finally:
            await cleanup()

    asyncio.run(main())
```

### 运行输出示例

```
=== 测试订单Tool ===

测试1：查询存在的订单
订单信息：
订单号：ORD-123456
状态：已发货
金额：¥299.99
下单时间：2024-03-15 10:30:00
用户：alice (alice@example.com)

测试2：查询不存在的订单
错误：订单ORD-999999不存在。建议：请检查订单号是否正确。
```

---

## 示例2：用户信息查询Tool

### 完整代码

```python
"""
用户信息查询Tool示例
演示：查询用户基本信息和统计数据
"""

import asyncpg
from langchain.tools import tool
from pydantic import BaseModel, Field

# ===== 1. 定义参数Schema =====
class UserInput(BaseModel):
    """用户查询参数"""
    user_id: int = Field(
        description="用户ID，正整数",
        gt=0
    )

# ===== 2. 定义Tool =====
@tool(args_schema=UserInput)
async def get_user_info(user_id: int) -> str:
    """获取用户信息

    根据用户ID查询用户的基本信息和统计数据，包括：
    - 用户名
    - 邮箱
    - 注册时间
    - 订单总数
    - 消费总额

    适用场景：
    - 客服查询用户信息
    - 用户询问"我的账户信息"
    - 用户询问"我一共下了多少单？"

    Args:
        user_id: 用户ID

    Returns:
        用户信息的文本描述

    注意事项：
    - 如果用户不存在，返回错误提示
    - 生产环境需要权限验证
    """
    try:
        pool = await init_db_pool()

        async with pool.acquire() as conn:
            # 查询用户基本信息
            user = await conn.fetchrow(
                """
                SELECT id, username, email, created_at
                FROM users
                WHERE id = $1
                """,
                user_id
            )

            if not user:
                return f"错误：用户ID {user_id} 不存在。建议：请检查用户ID是否正确。"

            # 查询订单统计
            stats = await conn.fetchrow(
                """
                SELECT COUNT(*) as order_count,
                       COALESCE(SUM(total_amount), 0) as total_spent
                FROM orders
                WHERE user_id = $1
                """,
                user_id
            )

            # 格式化时间
            created_at = user['created_at'].strftime("%Y-%m-%d")

            # 返回格式化结果
            return f"""用户信息：
用户ID：{user['id']}
用户名：{user['username']}
邮箱：{user['email']}
注册时间：{created_at}
订单总数：{stats['order_count']}
消费总额：¥{stats['total_spent']}
"""

    except asyncpg.PostgresError as e:
        return f"数据库错误：{str(e)}。建议：请稍后重试。"

    except Exception as e:
        return f"查询失败：{str(e)}。建议：请联系技术支持。"

# ===== 3. 测试Tool =====
async def test_user_tool():
    """测试用户Tool"""
    print("=== 测试用户Tool ===\n")

    # 测试1：查询存在的用户
    print("测试1：查询存在的用户")
    result = await get_user_info.ainvoke({"user_id": 1})
    print(result)
    print()

    # 测试2：查询不存在的用户
    print("测试2：查询不存在的用户")
    result = await get_user_info.ainvoke({"user_id": 999})
    print(result)
    print()

if __name__ == "__main__":
    import asyncio

    async def main():
        try:
            await test_user_tool()
        finally:
            await cleanup()

    asyncio.run(main())
```

---

## 示例3：产品搜索Tool

### 完整代码

```python
"""
产品搜索Tool示例
演示：根据关键词搜索产品
"""

import asyncpg
from typing import Optional
from langchain.tools import tool
from pydantic import BaseModel, Field

# ===== 1. 定义参数Schema =====
class ProductSearchInput(BaseModel):
    """产品搜索参数"""
    keyword: str = Field(
        description="搜索关键词，如'iPhone'、'笔记本'",
        min_length=1,
        max_length=100
    )
    category: Optional[str] = Field(
        default=None,
        description="产品类别筛选（可选），如'电子产品'、'配件'"
    )
    limit: int = Field(
        default=10,
        description="返回数量",
        ge=1,
        le=50
    )

# ===== 2. 定义Tool =====
@tool(args_schema=ProductSearchInput)
async def search_products(
    keyword: str,
    category: Optional[str] = None,
    limit: int = 10
) -> str:
    """搜索产品数据库

    根据关键词在产品名称中搜索匹配的产品，可按类别筛选。

    返回信息包括：
    - 产品名称
    - 产品价格
    - 库存状态
    - 产品类别

    适用场景：
    - 用户询问"有什么iPhone产品？"
    - 用户询问"搜索笔记本电脑"
    - 用户询问"电子产品类别有哪些？"

    Args:
        keyword: 搜索关键词
        category: 产品类别筛选（可选）
        limit: 返回的最大结果数

    Returns:
        产品列表的文本描述

    注意事项：
    - 关键词太短可能返回过多结果
    - 按价格排序
    """
    try:
        pool = await init_db_pool()

        async with pool.acquire() as conn:
            # 构建SQL查询
            if category:
                query = """
                    SELECT name, price, stock, category
                    FROM products
                    WHERE name ILIKE $1 AND category = $2
                    ORDER BY price DESC
                    LIMIT $3
                """
                rows = await conn.fetch(query, f"%{keyword}%", category, limit)
            else:
                query = """
                    SELECT name, price, stock, category
                    FROM products
                    WHERE name ILIKE $1
                    ORDER BY price DESC
                    LIMIT $2
                """
                rows = await conn.fetch(query, f"%{keyword}%", limit)

            if not rows:
                if category:
                    return f"未找到包含'{keyword}'且类别为'{category}'的产品。建议：尝试其他关键词或类别。"
                else:
                    return f"未找到包含'{keyword}'的产品。建议：尝试其他关键词。"

            # 格式化产品列表
            products = []
            for i, row in enumerate(rows, 1):
                stock_status = "有货" if row['stock'] > 0 else "缺货"
                products.append(f"""产品{i}：
名称：{row['name']}
价格：¥{row['price']}
库存：{row['stock']}（{stock_status}）
类别：{row['category']}
""")

            header = f"找到{len(rows)}个产品"
            if category:
                header += f"（类别：{category}）"
            header += "：\n\n"

            return header + "\n".join(products)

    except asyncpg.PostgresError as e:
        return f"数据库错误：{str(e)}。建议：请稍后重试。"

    except Exception as e:
        return f"搜索失败：{str(e)}。建议：请联系技术支持。"

# ===== 3. 测试Tool =====
async def test_product_tool():
    """测试产品Tool"""
    print("=== 测试产品Tool ===\n")

    # 测试1：搜索iPhone
    print("测试1：搜索iPhone")
    result = await search_products.ainvoke({"keyword": "iPhone", "limit": 5})
    print(result)
    print()

    # 测试2：搜索电子产品类别
    print("测试2：搜索电子产品类别")
    result = await search_products.ainvoke({
        "keyword": "",
        "category": "电子产品",
        "limit": 10
    })
    print(result)
    print()

if __name__ == "__main__":
    import asyncio

    async def main():
        try:
            await test_product_tool()
        finally:
            await cleanup()

    asyncio.run(main())
```

---

## 示例4：统计分析Tool

### 完整代码

```python
"""
统计分析Tool示例
演示：查询订单统计数据
"""

import asyncpg
from typing import Optional
from langchain.tools import tool
from pydantic import BaseModel, Field
from datetime import datetime, timedelta

# ===== 1. 定义参数Schema =====
class StatsInput(BaseModel):
    """统计查询参数"""
    days: int = Field(
        default=7,
        description="统计天数，默认7天",
        ge=1,
        le=365
    )

# ===== 2. 定义Tool =====
@tool(args_schema=StatsInput)
async def get_order_stats(days: int = 7) -> str:
    """获取订单统计数据

    查询指定天数内的订单统计信息，包括：
    - 订单总数
    - 订单总金额
    - 平均订单金额
    - 各状态订单数量

    适用场景：
    - 管理员查询"最近7天的订单统计"
    - 管理员询问"本月订单情况"
    - 数据分析需求

    Args:
        days: 统计天数，默认7天

    Returns:
        订单统计数据的文本描述

    注意事项：
    - 统计范围为最近N天
    - 需要管理员权限（生产环境）
    """
    try:
        pool = await init_db_pool()

        async with pool.acquire() as conn:
            # 计算起始日期
            start_date = datetime.now() - timedelta(days=days)

            # 查询总体统计
            total_stats = await conn.fetchrow(
                """
                SELECT COUNT(*) as order_count,
                       COALESCE(SUM(total_amount), 0) as total_amount,
                       COALESCE(AVG(total_amount), 0) as avg_amount
                FROM orders
                WHERE created_at >= $1
                """,
                start_date
            )

            # 查询各状态订单数
            status_stats = await conn.fetch(
                """
                SELECT status, COUNT(*) as count
                FROM orders
                WHERE created_at >= $1
                GROUP BY status
                ORDER BY count DESC
                """,
                start_date
            )

            # 格式化状态统计
            status_map = {
                'pending': '待支付',
                'paid': '已支付',
                'shipped': '已发货',
                'completed': '已完成'
            }

            status_lines = []
            for row in status_stats:
                status_cn = status_map.get(row['status'], row['status'])
                status_lines.append(f"  - {status_cn}：{row['count']}单")

            # 返回格式化结果
            return f"""最近{days}天订单统计：

总体数据：
- 订单总数：{total_stats['order_count']}单
- 订单总金额：¥{total_stats['total_amount']:.2f}
- 平均订单金额：¥{total_stats['avg_amount']:.2f}

各状态订单数：
{chr(10).join(status_lines)}
"""

    except asyncpg.PostgresError as e:
        return f"数据库错误：{str(e)}。建议：请稍后重试。"

    except Exception as e:
        return f"查询失败：{str(e)}。建议：请联系技术支持。"

# ===== 3. 测试Tool =====
async def test_stats_tool():
    """测试统计Tool"""
    print("=== 测试统计Tool ===\n")

    # 测试：查询最近7天统计
    print("测试：查询最近7天统计")
    result = await get_order_stats.ainvoke({"days": 7})
    print(result)
    print()

if __name__ == "__main__":
    import asyncio

    async def main():
        try:
            await test_stats_tool()
        finally:
            await cleanup()

    asyncio.run(main())
```

---

## 最佳实践总结

### 1. 连接池管理

```python
# ✅ 推荐：模块级别创建连接池
db_pool = None

async def init_db_pool():
    global db_pool
    if db_pool is None:
        db_pool = await asyncpg.create_pool(
            database_url,
            min_size=5,
            max_size=20
        )
    return db_pool

# 使用连接池
async with db_pool.acquire() as conn:
    result = await conn.fetch(query)
```

### 2. SQL注入防护

```python
# ❌ 危险：字符串拼接
query = f"SELECT * FROM orders WHERE order_id = '{order_id}'"

# ✅ 安全：参数化查询
query = "SELECT * FROM orders WHERE order_id = $1"
result = await conn.fetch(query, order_id)
```

### 3. 错误处理

```python
@tool
async def query_db(query: str) -> str:
    try:
        async with db_pool.acquire() as conn:
            result = await conn.fetch(query)
            return str(result)

    except asyncpg.PostgresError as e:
        return f"数据库错误：{str(e)}。建议：请稍后重试。"

    except Exception as e:
        return f"查询失败：{str(e)}。建议：请联系技术支持。"
```

### 4. 结果格式化

```python
# ✅ 友好的格式化
return f"""订单信息：
订单号：{order_id}
状态：{status}
金额：¥{amount}
"""

# ❌ 不友好的格式化
return str(row)  # {'order_id': 'ORD-123456', ...}
```

### 5. 资源清理

```python
# 应用关闭时清理连接池
async def cleanup():
    global db_pool
    if db_pool:
        await db_pool.close()
```

---

## 常见问题

### 1. 连接池大小设置

**问题：** 连接池应该设置多大？

**建议：**
- 小型应用：min_size=5, max_size=20
- 中型应用：min_size=10, max_size=50
- 大型应用：min_size=20, max_size=100

**经验法则：**
- max_size = 并发请求数 / 2
- min_size = max_size / 4

### 2. 查询超时

**问题：** 复杂查询可能超时怎么办？

**解决方案：**
```python
import asyncio

@tool
async def complex_query(param: str) -> str:
    try:
        # 设置10秒超时
        result = await asyncio.wait_for(
            conn.fetch(query, param),
            timeout=10.0
        )
        return str(result)
    except asyncio.TimeoutError:
        return "查询超时。建议：简化查询条件或稍后重试。"
```

### 3. 事务处理

**问题：** 如何在Tool中使用事务？

**解决方案：**
```python
@tool
async def update_order(order_id: str, status: str) -> str:
    async with db_pool.acquire() as conn:
        # 开启事务
        async with conn.transaction():
            # 更新订单状态
            await conn.execute(
                "UPDATE orders SET status = $1 WHERE order_id = $2",
                status, order_id
            )

            # 记录日志
            await conn.execute(
                "INSERT INTO order_logs (order_id, action) VALUES ($1, $2)",
                order_id, f"状态更新为{status}"
            )

            return f"订单{order_id}状态已更新为{status}"
```

### 4. 权限验证

**问题：** 如何确保用户只能查询自己的数据？

**解决方案：**
```python
@tool
async def get_my_orders(user_id: int) -> str:
    """查询当前用户的订单"""
    # 在生产环境中，user_id应该从认证token中获取
    # 而不是作为参数传入

    async with db_pool.acquire() as conn:
        rows = await conn.fetch(
            "SELECT * FROM orders WHERE user_id = $1",
            user_id  # 确保只查询当前用户的数据
        )
        return format_orders(rows)
```

---

## 总结

### 核心要点

1. **连接池管理**：模块级别创建，复用连接
2. **SQL注入防护**：使用参数化查询，不要字符串拼接
3. **错误处理**：捕获数据库异常，返回友好错误信息
4. **结果格式化**：返回易读的文本，不是原始数据
5. **资源清理**：应用关闭时清理连接池

### 快速参考

```python
# 1. 创建连接池
db_pool = await asyncpg.create_pool(
    database_url,
    min_size=5,
    max_size=20
)

# 2. 定义Tool
@tool
async def query_db(param: str) -> str:
    async with db_pool.acquire() as conn:
        result = await conn.fetch(
            "SELECT * FROM table WHERE col = $1",
            param  # 参数化查询
        )
        return format_result(result)

# 3. 清理资源
await db_pool.close()
```

---

**记住：** 数据库查询Tool的关键是连接池管理和SQL注入防护！
