# 核心概念 03：遍历策略对比

## 一句话定义

**BFS 和 DFS 是两种互补的遍历策略，选择取决于问题性质（最短路径 vs 路径探索）、图结构（宽浅 vs 窄深）、资源限制（内存 vs 时间）和查询意图（事实 vs 因果）。**

---

## 核心对比表

| 维度 | BFS（广度优先） | DFS（深度优先） |
|------|----------------|----------------|
| **数据结构** | 队列（FIFO） | 栈（LIFO）或递归 |
| **遍历顺序** | 层序（先近后远） | 深度优先（一条路走到底） |
| **时间复杂度** | O(V + E) | O(V + E) |
| **空间复杂度** | O(V) - 需要存储整层 | O(h) - 只需存储路径 |
| **最短路径** | ✅ 保证最短（无权图） | ❌ 不保证 |
| **完整性** | ✅ 找到所有可达节点 | ✅ 找到所有可达节点 |
| **内存效率** | ❌ 宽图消耗大 | ✅ 深图也高效 |
| **实现难度** | 简单（迭代） | 递归简单，迭代稍复杂 |
| **适用场景** | 最短路径、广度检索、层级关系 | 路径探索、深度推理、回溯问题 |
| **RAG 应用** | 邻域扩展、候选检索、广度覆盖 | 推理链构建、因果探索、深度连接 |

---

## 可视化对比

### 示例图结构

```
    A
   /|\
  B C D
 /| |
E F G
```

### BFS 遍历过程

```
步骤1：访问 A（层级0）
队列：[]
已访问：{A}

步骤2：扩展 A 的邻居
队列：[B, C, D]
已访问：{A}

步骤3：访问 B（层级1）
队列：[C, D]
已访问：{A, B}

步骤4：扩展 B 的邻居
队列：[C, D, E, F]
已访问：{A, B}

步骤5：访问 C（层级1）
队列：[D, E, F]
已访问：{A, B, C}

步骤6：扩展 C 的邻居
队列：[D, E, F, G]
已访问：{A, B, C}

步骤7-9：依次访问 D, E, F, G

最终顺序：A → B → C → D → E → F → G
层级结构：
  层级0: [A]
  层级1: [B, C, D]
  层级2: [E, F, G]
```

### DFS 遍历过程

```
步骤1：访问 A
栈：[]
已访问：{A}

步骤2：压入 A 的邻居（反向）
栈：[D, C, B]
已访问：{A}

步骤3：弹出 B，访问
栈：[D, C]
已访问：{A, B}

步骤4：压入 B 的邻居（反向）
栈：[D, C, F, E]
已访问：{A, B}

步骤5：弹出 E，访问
栈：[D, C, F]
已访问：{A, B, E}

步骤6：E 无邻居，弹出 F，访问
栈：[D, C]
已访问：{A, B, E, F}

步骤7：F 无邻居，弹出 C，访问
栈：[D]
已访问：{A, B, E, F, C}

步骤8：压入 C 的邻居
栈：[D, G]
已访问：{A, B, E, F, C}

步骤9-10：依次访问 G, D

最终顺序：A → B → E → F → C → G → D
深度优先：沿着 A→B→E 深入，回溯后继续
```

---

## 选择标准

### 标准1：问题性质

#### 最短路径问题 → BFS

**为什么？** BFS 层序遍历保证先找到的路径最短

```python
# 场景：社交网络中找最近的共同好友
def find_closest_common_friend(graph, user1, user2):
    """
    BFS 找最近的共同好友

    保证找到的是距离最近的
    """
    # 从 user1 开始 BFS
    visited1 = {user1: 0}
    queue1 = deque([(user1, 0)])

    # 从 user2 开始 BFS
    visited2 = {user2: 0}
    queue2 = deque([(user2, 0)])

    while queue1 or queue2:
        # 扩展 user1 的朋友圈
        if queue1:
            node, dist = queue1.popleft()
            for friend in graph[node]:
                if friend in visited2:
                    # 找到共同好友
                    return friend, dist + visited2[friend]
                if friend not in visited1:
                    visited1[friend] = dist + 1
                    queue1.append((friend, dist + 1))

        # 扩展 user2 的朋友圈
        if queue2:
            node, dist = queue2.popleft()
            for friend in graph[node]:
                if friend in visited1:
                    return friend, dist + visited1[friend]
                if friend not in visited2:
                    visited2[friend] = dist + 1
                    queue2.append((friend, dist + 1))

    return None, float('inf')
```

#### 路径探索问题 → DFS

**为什么？** DFS 自然地表达路径，回溯机制适合探索所有可能

```python
# 场景：找到所有从起点到终点的路径
def find_all_paths(graph, start, end):
    """
    DFS 找所有路径

    回溯机制自然地探索所有可能
    """
    all_paths = []

    def dfs(node, path, visited):
        path.append(node)
        visited.add(node)

        if node == end:
            all_paths.append(path[:])
        else:
            for neighbor in graph[node]:
                if neighbor not in visited:
                    dfs(neighbor, path, visited)

        # 回溯
        path.pop()
        visited.remove(node)

    dfs(start, [], set())
    return all_paths
```

---

### 标准2：图结构

#### 宽而浅的图 → DFS

**原因：** BFS 需要存储大量同层节点，内存消耗大

```python
# 示例：完全二叉树（宽而浅）
#       1
#      /|\
#     2 3 4
#    /|\ ...
#   5 6 7 ...

# BFS 空间：O(2^h) - 最后一层节点数
# DFS 空间：O(h) - 树高

# 高度10的完全二叉树：
# BFS 需要存储 2^9 = 512 个节点
# DFS 只需存储 10 个节点
```

#### 窄而深的图 → BFS

**原因：** DFS 递归深度可能爆栈

```python
# 示例：链状图（窄而深）
# 1 → 2 → 3 → ... → 10000

# BFS 空间：O(1) - 队列最多1个节点
# DFS 空间：O(10000) - 递归深度10000

# Python 默认递归深度限制：1000
# DFS 会栈溢出，BFS 不会
```

---

### 标准3：资源限制

#### 内存受限 → DFS

```python
# 场景：嵌入式系统，内存只有 1MB
# 需要遍历大规模图（100万节点）

# BFS：需要存储整层节点，可能超出内存
# DFS：只需存储当前路径，内存可控
```

#### 时间受限 → BFS

```python
# 场景：实时系统，需要快速找到最短路径
# 不能等待 DFS 探索所有路径

# BFS：保证第一次找到就是最短路径
# DFS：可能需要探索很多路径才找到最短的
```

---

### 标准4：查询意图（RAG 应用）

#### 事实查询 → BFS

**特点：** 答案在浅层，需要广度覆盖

```python
# 查询："Python 的创始人是谁？"
# 答案在 1-hop 内：Python → Guido van Rossum

def factual_query_bfs(kg, query, max_depth=2):
    """
    事实查询用 BFS（浅层广度检索）
    """
    entities = kg.extract_entities(query)
    expanded = set(entities)
    queue = deque([(e, 0) for e in entities])

    while queue:
        entity, depth = queue.popleft()

        if depth >= max_depth:
            continue

        for neighbor in kg.get_neighbors(entity):
            if neighbor not in expanded:
                expanded.add(neighbor)
                queue.append((neighbor, depth + 1))

    return expanded
```

**来源：** Agentic Graph RAG (2025) - https://pmc.ncbi.nlm.nih.gov/articles/PMC12748213

#### 因果查询 → DFS

**特点：** 需要深层推理链，沿着因果关系探索

```python
# 查询："为什么 Python 成为 AI 开发的首选语言？"
# 需要因果链：Python → 简洁语法 → 快速原型 → 科学计算社区 → AI 生态

def causal_query_dfs(kg, query, max_depth=5):
    """
    因果查询用 DFS（深层因果推理）
    """
    entities = kg.extract_entities(query)
    causal_relations = ['causes', 'leads_to', 'results_in']

    def dfs_causal(entity, depth, visited, path):
        if depth >= max_depth or entity in visited:
            return path

        visited.add(entity)
        path.append(entity)

        # 只沿着因果关系边探索
        for relation, neighbor in kg.get_neighbors_with_relation(entity):
            if relation in causal_relations and neighbor not in visited:
                return dfs_causal(neighbor, depth + 1, visited, path)

        return path

    causal_chains = []
    for entity in entities:
        chain = dfs_causal(entity, 0, set(), [])
        if len(chain) > 1:
            causal_chains.append(chain)

    return causal_chains
```

**来源：** Agentic Graph RAG (2025) - https://pmc.ncbi.nlm.nih.gov/articles/PMC12748213

---

## 混合策略（2025-2026 年突破）

### 策略1：KG2RAG（BFS 扩展 + DFS 组织）

**核心思想：** 结合 BFS 的广度覆盖和 DFS 的深度连接

```python
def kg2rag_hybrid(kg, query, m_hops=2, max_depth=3):
    """
    KG2RAG 混合策略

    步骤1：BFS 扩展 m-hop 邻域（广度覆盖）
    步骤2：DFS 组织连贯段落（深度连接）
    """
    # 步骤1：BFS 扩展
    entities = kg.extract_entities(query)
    expanded = bfs_expand(kg, entities, m_hops)

    # 步骤2：DFS 组织
    organized = dfs_organize(kg, expanded, max_depth)

    return organized

def bfs_expand(kg, seeds, m_hops):
    """BFS 扩展 m-hop 邻域"""
    expanded = set(seeds)
    queue = deque([(e, 0) for e in seeds])

    while queue:
        entity, depth = queue.popleft()
        if depth >= m_hops:
            continue

        for neighbor in kg.get_neighbors(entity):
            if neighbor not in expanded:
                expanded.add(neighbor)
                queue.append((neighbor, depth + 1))

    return expanded

def dfs_organize(kg, entities, max_depth):
    """DFS 组织连贯段落"""
    organized = []
    visited = set()

    def dfs_path(entity, path, depth):
        if depth >= max_depth or entity in visited:
            return

        visited.add(entity)
        path.append(entity)

        neighbors = kg.get_neighbors(entity)
        if not neighbors or depth == max_depth - 1:
            organized.append(path[:])
        else:
            for neighbor in neighbors:
                if neighbor not in visited:
                    dfs_path(neighbor, path, depth + 1)
                    break

        path.pop()

    for entity in entities:
        if entity not in visited:
            dfs_path(entity, [], 0)

    return organized
```

**优势：**
- BFS 保证不遗漏相关实体
- DFS 保证上下文连贯性
- 避免 lost-in-the-middle 问题

**来源：** KG2RAG (NAACL 2025) - https://arxiv.org/abs/2502.06864

---

### 策略2：ARK（自适应广度-深度）

**核心思想：** LLM 控制的动态策略选择

```python
def ark_adaptive(kg, query, llm, max_depth=3):
    """
    ARK 自适应策略

    步骤1：BFS 全局搜索（广度起步）
    步骤2：LLM 评估是否需要深度扩展
    步骤3：DFS 按需深入（深度扩展）
    """
    results = []

    # 步骤1：BFS 全局搜索
    candidates = kg.lexical_search(query, top_k=10)
    results.extend(candidates)

    # 步骤2-3：自适应深度扩展
    for depth in range(max_depth):
        decision = llm.evaluate_sufficiency(query, results)

        if decision == "sufficient":
            break
        elif decision == "expand":
            # DFS 深度扩展
            for candidate in candidates:
                neighbors = kg.get_neighbors(candidate)
                results.extend(neighbors)
                candidates = neighbors
        else:
            break

    return results
```

**优势：**
- 浅层查询快速返回（BFS）
- 深层查询按需扩展（DFS）
- LLM 智能决策，避免过度检索

**来源：** ARK (2026.01) - https://arxiv.org/abs/2601.13969

---

### 策略3：Agentic Graph RAG（查询分类驱动）

**核心思想：** 根据查询意图选择策略

```python
def agentic_graph_rag(kg, query, llm):
    """
    Agentic Graph RAG 策略

    根据查询意图选择遍历策略
    """
    # 分类查询意图
    intent = llm.classify_query(query)

    if intent == "factual":
        # 事实查询：BFS 浅层遍历
        return bfs_shallow(kg, query, max_depth=2)
    elif intent == "causal":
        # 因果查询：DFS 深层遍历
        return dfs_deep(kg, query, max_depth=5)
    elif intent == "exploratory":
        # 探索查询：混合策略
        return kg2rag_hybrid(kg, query)
    else:
        # 默认：自适应策略
        return ark_adaptive(kg, query, llm)
```

**优势：**
- 查询驱动，精准匹配策略
- 避免一刀切的固定策略
- 提高检索效率和质量

**来源：** Agentic Graph RAG (2025) - https://pmc.ncbi.nlm.nih.gov/articles/PMC12748213

---

## 实际应用场景对比

### 场景1：社交网络好友推荐

**需求：** 推荐最近的潜在好友

**选择：** BFS

**原因：**
- 需要最短路径（最近的共同好友）
- 需要广度覆盖（多个候选）
- 不需要深度探索

```python
def recommend_friends_bfs(social_graph, user, max_distance=3):
    """BFS 推荐好友"""
    recommendations = {}
    visited = {user: 0}
    queue = deque([(user, 0)])

    while queue:
        current, distance = queue.popleft()

        if distance >= max_distance:
            continue

        for friend in social_graph[current]:
            if friend not in visited:
                visited[friend] = distance + 1
                queue.append((friend, distance + 1))

                if distance + 1 not in recommendations:
                    recommendations[distance + 1] = []
                recommendations[distance + 1].append(friend)

    return recommendations
```

---

### 场景2：知识图谱推理链

**需求：** 构建从起点到终点的推理链

**选择：** DFS

**原因：**
- 需要完整路径（推理链）
- 需要深度探索（多跳推理）
- 回溯机制适合探索多条路径

```python
def build_reasoning_chain_dfs(kg, start, end, max_depth=5):
    """DFS 构建推理链"""
    all_chains = []

    def dfs(node, path, visited, depth):
        if depth > max_depth:
            return

        path.append(node)
        visited.add(node)

        if node == end:
            all_chains.append(path[:])
        else:
            for neighbor in kg.get_neighbors(node):
                if neighbor not in visited:
                    dfs(neighbor, path, visited, depth + 1)

        path.pop()
        visited.remove(node)

    dfs(start, [], set(), 0)
    return all_chains
```

---

### 场景3：文档问答系统

**需求：** 检索相关文档片段

**选择：** 混合策略（KG2RAG）

**原因：**
- 需要广度覆盖（BFS 扩展相关实体）
- 需要连贯性（DFS 组织段落）
- 避免碎片化

```python
def document_qa_hybrid(kg, query):
    """混合策略用于文档问答"""
    # BFS：扩展相关实体
    entities = kg.extract_entities(query)
    expanded = bfs_expand(kg, entities, m_hops=2)

    # DFS：组织连贯段落
    organized = dfs_organize(kg, expanded, max_depth=3)

    # 返回连贯的文档片段
    return organized
```

---

### 场景4：实时搜索建议

**需求：** 快速返回搜索建议

**选择：** BFS（限制深度）

**原因：**
- 需要快速响应（实时）
- 浅层检索足够（搜索建议）
- 广度覆盖（多个建议）

```python
def search_suggestions_bfs(kg, query, max_depth=1, top_k=10):
    """BFS 生成搜索建议"""
    entities = kg.extract_entities(query)
    suggestions = set(entities)
    queue = deque([(e, 0) for e in entities])

    while queue and len(suggestions) < top_k:
        entity, depth = queue.popleft()

        if depth >= max_depth:
            continue

        for neighbor in kg.get_neighbors(entity):
            if neighbor not in suggestions:
                suggestions.add(neighbor)
                queue.append((neighbor, depth + 1))

                if len(suggestions) >= top_k:
                    break

    return list(suggestions)[:top_k]
```

---

## 性能对比

### 时间复杂度对比

| 场景 | BFS | DFS |
|------|-----|-----|
| 遍历所有节点 | O(V + E) | O(V + E) |
| 找最短路径 | O(V + E) | O(V + E) × 路径数 |
| 找所有路径 | 不适用 | O(V + E) × 路径数 |
| 检测环 | O(V + E) | O(V + E) |

### 空间复杂度对比

| 图结构 | BFS | DFS |
|--------|-----|-----|
| 链状图（1→2→...→n） | O(1) | O(n) |
| 完全二叉树（高度h） | O(2^h) | O(h) |
| 星形图（中心+n个叶子） | O(n) | O(1) |
| 网格图（n×n） | O(n) | O(n) |

### 实际性能测试

```python
import time
from collections import deque

def benchmark_traversal(graph, start, method='bfs'):
    """性能测试"""
    start_time = time.time()

    if method == 'bfs':
        visited = {start}
        queue = deque([start])
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
    else:  # dfs
        visited = set()
        def dfs(node):
            visited.add(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    dfs(neighbor)
        dfs(start)

    end_time = time.time()
    return end_time - start_time, len(visited)

# 测试结果（10000个节点的图）：
# BFS: 0.023秒, 10000个节点
# DFS: 0.021秒, 10000个节点
# 结论：时间复杂度相同，实际性能相近
```

---

## 决策树

```
开始
  ↓
需要最短路径？
  ├─ 是 → BFS
  └─ 否 → 继续
      ↓
  需要所有路径？
      ├─ 是 → DFS
      └─ 否 → 继续
          ↓
      图是宽而浅的？
          ├─ 是 → DFS（节省内存）
          └─ 否 → 继续
              ↓
          图是窄而深的？
              ├─ 是 → BFS（避免栈溢出）
              └─ 否 → 继续
                  ↓
              RAG 应用？
                  ├─ 事实查询 → BFS
                  ├─ 因果查询 → DFS
                  ├─ 文档问答 → 混合（KG2RAG）
                  └─ 复杂查询 → 自适应（ARK）
```

---

## 常见误区

### 误区1：BFS 一定比 DFS 慢 ❌

**为什么错？** 时间复杂度都是 O(V + E)

**正确理解：** 遍历所有节点的时间相同，只是顺序不同

---

### 误区2：DFS 一定比 BFS 省内存 ❌

**为什么错？** 取决于图结构

**正确理解：**
- 宽而浅的图：DFS 省内存
- 窄而深的图：BFS 省内存

---

### 误区3：只能用一种策略 ❌

**为什么错？** 2025-2026 年的突破在于混合策略

**正确理解：** KG2RAG、ARK、Agentic Graph RAG 都使用混合策略

---

## 学习检查

理解了遍历策略对比后，你应该能回答：

- [ ] BFS 和 DFS 的时间复杂度是否相同？（是，都是 O(V + E)）
- [ ] 什么时候选择 BFS？（最短路径、广度检索、宽而浅的图）
- [ ] 什么时候选择 DFS？（路径探索、深度推理、窄而深的图）
- [ ] 什么是混合策略？（结合 BFS 和 DFS 的优点）
- [ ] 2025-2026 年的突破是什么？（自适应选择、查询驱动）

---

## 下一步

学完遍历策略对比后，建议继续学习：
1. `03_核心概念_04_路径重建技术.md` - 学习如何重建路径
2. `03_核心概念_05_图遍历优化.md` - 学习优化技巧
3. `03_核心概念_08_自适应BFS_DFS选择.md` - 深入理解 ARK 框架

---

**版本：** v1.0
**最后更新：** 2026-02-14
**参考文献：**
- KG2RAG (NAACL 2025): https://arxiv.org/abs/2502.06864
- ARK (2026.01): https://arxiv.org/abs/2601.13969
- Agentic Graph RAG (2025): https://pmc.ncbi.nlm.nih.gov/articles/PMC12748213
