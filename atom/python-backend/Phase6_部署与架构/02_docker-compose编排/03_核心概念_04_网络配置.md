# docker-compose编排 - 核心概念：网络配置

## 概述

**网络配置** 是容器间通信的基础。docker-compose 自动创建网络，使服务间可以通过服务名通信。理解网络配置对于构建复杂的微服务架构至关重要。

**本文涵盖：**
1. 默认网络行为
2. 自定义网络配置
3. 网络驱动类型
4. 服务发现机制
5. 端口映射策略
6. 网络隔离和安全

---

## 1. 默认网络行为

### 1.1 自动创建网络

```yaml
version: '3.8'

services:
  api:
    image: my-api
  db:
    image: postgres
```

**docker-compose 自动：**
1. 创建一个默认网络（名称：`<project>_default`）
2. 将所有服务连接到这个网络
3. 启用服务发现（通过服务名访问）

**查看网络：**
```bash
# 启动服务
docker-compose up -d

# 查看网络
docker network ls

# 输出示例
NETWORK ID     NAME                    DRIVER    SCOPE
abc123         myproject_default       bridge    local
```

### 1.2 服务间通信

```yaml
services:
  api:
    environment:
      # 通过服务名访问数据库
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
      # 通过服务名访问 Redis
      - REDIS_URL=redis://redis:6379

  db:
    image: postgres:14-alpine

  redis:
    image: redis:7-alpine
```

**Python 代码：**
```python
import psycopg2
import redis

# 通过服务名连接
conn = psycopg2.connect(
    host="db",      # 服务名
    port=5432,
    user="user",
    password="pass"
)

r = redis.Redis(host="redis", port=6379)
```

**前端类比：**
```javascript
// 在同一个 localhost 上通信
fetch('http://localhost:3000/api')  // 前端调用后端
```

### 1.3 DNS 解析

**docker-compose 内置 DNS 服务器：**
- 服务名 → IP 地址
- 自动更新（容器重启后 IP 可能变化）
- 支持别名（aliases）

**示例：**
```bash
# 在容器内查看 DNS 解析
docker-compose exec api nslookup db

# 输出
Server:    127.0.0.11
Address:   127.0.0.11:53

Name:      db
Address:   172.18.0.3
```

---

## 2. 自定义网络配置

### 2.1 定义多个网络

```yaml
version: '3.8'

services:
  api:
    networks:
      - frontend
      - backend

  db:
    networks:
      - backend

  nginx:
    networks:
      - frontend

networks:
  frontend:
  backend:
```

**网络拓扑：**
```
frontend 网络
├── api
└── nginx

backend 网络
├── api
└── db
```

**访问规则：**
- `api` 可以访问 `db` 和 `nginx`（在两个网络中）
- `nginx` 不能访问 `db`（不在同一网络）
- `db` 不能访问 `nginx`（不在同一网络）

### 2.2 网络别名

```yaml
services:
  api:
    networks:
      backend:
        aliases:
          - api-server
          - backend-api

  db:
    networks:
      backend:
        aliases:
          - database
          - postgres-db

networks:
  backend:
```

**访问方式：**
```python
# 可以通过服务名访问
conn = psycopg2.connect(host="db")

# 也可以通过别名访问
conn = psycopg2.connect(host="database")
conn = psycopg2.connect(host="postgres-db")
```

### 2.3 网络配置选项

```yaml
networks:
  frontend:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: br-frontend
    ipam:
      driver: default
      config:
        - subnet: 172.20.0.0/16
          gateway: 172.20.0.1

  backend:
    driver: bridge
    internal: true  # 内部网络（不能访问外网）
```

---

## 3. 网络驱动类型

### 3.1 bridge（桥接网络）- 默认

**特点：**
- 容器间可以通信
- 容器可以访问外网
- 主机可以通过端口映射访问容器

**适用场景：**
- 单机部署
- 开发环境
- 测试环境

```yaml
networks:
  default:
    driver: bridge
```

### 3.2 host（主机网络）

**特点：**
- 容器直接使用主机网络
- 无网络隔离
- 性能最好

**适用场景：**
- 需要高性能网络
- 需要访问主机网络服务

```yaml
services:
  api:
    network_mode: host  # 使用主机网络
```

**注意：**
- 不能使用端口映射（直接使用主机端口）
- 不能与其他网络配置同时使用

### 3.3 overlay（覆盖网络）

**特点：**
- 跨主机通信
- 用于 Docker Swarm

**适用场景：**
- 多机集群
- Docker Swarm 部署

```yaml
networks:
  overlay-net:
    driver: overlay
    attachable: true
```

### 3.4 none（无网络）

**特点：**
- 完全隔离
- 无网络访问

**适用场景：**
- 安全要求高的容器
- 不需要网络的任务

```yaml
services:
  isolated:
    network_mode: none
```

---

## 4. 服务发现机制

### 4.1 通过服务名访问

```yaml
services:
  api:
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb

  db:
    image: postgres:14-alpine
```

**工作原理：**
1. `api` 容器尝试连接 `db`
2. Docker 内置 DNS 解析 `db` → IP 地址
3. 建立连接

### 4.2 通过容器名访问

```yaml
services:
  api:
    container_name: my-api-container

  db:
    container_name: my-db-container
```

**访问：**
```python
# 通过容器名访问
conn = psycopg2.connect(host="my-db-container")
```

**注意：** 容器名必须唯一，不能启动多个实例。

### 4.3 通过网络别名访问

```yaml
services:
  db:
    networks:
      backend:
        aliases:
          - primary-db
          - master-db
```

**访问：**
```python
# 通过别名访问
conn = psycopg2.connect(host="primary-db")
conn = psycopg2.connect(host="master-db")
```

### 4.4 负载均衡

```yaml
services:
  api:
    image: my-api
    deploy:
      replicas: 3  # 启动3个实例

  nginx:
    image: nginx
    depends_on:
      - api
```

**工作原理：**
- Docker 内置 DNS 轮询（Round Robin）
- 请求 `api` 时自动分发到3个实例

---

## 5. 端口映射策略

### 5.1 基本端口映射

```yaml
services:
  api:
    ports:
      - "8000:8000"  # 主机端口:容器端口
```

**说明：**
- 主机的 8000 端口映射到容器的 8000 端口
- 外部可以通过 `http://localhost:8000` 访问

### 5.2 动态端口映射

```yaml
services:
  api:
    ports:
      - "8000"  # 只指定容器端口，主机端口随机分配
```

**查看映射：**
```bash
docker-compose ps

# 输出
NAME    PORTS
api     0.0.0.0:32768->8000/tcp
```

### 5.3 指定 IP 地址

```yaml
services:
  api:
    ports:
      - "127.0.0.1:8000:8000"  # 只允许本地访问
```

**说明：**
- 只有本地可以访问
- 外部网络无法访问

### 5.4 多端口映射

```yaml
services:
  api:
    ports:
      - "8000:8000"  # HTTP
      - "8443:443"   # HTTPS
      - "9090:9090"  # Metrics
```

### 5.5 expose（内部端口）

```yaml
services:
  api:
    expose:
      - "8000"  # 只在容器网络内部可访问

  nginx:
    ports:
      - "80:80"  # 暴露到主机
```

**区别：**
- `ports`：暴露到主机（外部可访问）
- `expose`：只在容器网络内部可访问（更安全）

---

## 6. 网络隔离和安全

### 6.1 网络隔离

```yaml
services:
  # 前端服务（公开）
  nginx:
    networks:
      - frontend
    ports:
      - "80:80"

  # API 服务（前端和后端）
  api:
    networks:
      - frontend
      - backend

  # 数据库（后端，不公开）
  db:
    networks:
      - backend
    # 不设置 ports（不暴露到主机）

networks:
  frontend:
  backend:
```

**安全策略：**
- `nginx` 只能访问 `api`
- `nginx` 不能访问 `db`
- `db` 不暴露到主机

### 6.2 内部网络

```yaml
networks:
  backend:
    internal: true  # 内部网络（不能访问外网）
```

**特点：**
- 容器间可以通信
- 容器不能访问外网
- 外网不能访问容器

**适用场景：**
- 数据库网络
- 敏感服务网络

### 6.3 防火墙规则

```yaml
services:
  api:
    networks:
      backend:
        ipv4_address: 172.20.0.10  # 固定 IP

networks:
  backend:
    ipam:
      config:
        - subnet: 172.20.0.0/16
```

**配合防火墙：**
```bash
# 只允许特定 IP 访问数据库
iptables -A INPUT -s 172.20.0.10 -p tcp --dport 5432 -j ACCEPT
iptables -A INPUT -p tcp --dport 5432 -j DROP
```

---

## 7. 在 AI Agent 开发中的应用

### 7.1 基础网络配置

```yaml
version: '3.8'

services:
  # API 服务
  api:
    build: .
    ports:
      - "8000:8000"  # 暴露到主机
    networks:
      - app-network
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/agent_db
      - REDIS_URL=redis://redis:6379

  # 数据库（不暴露）
  db:
    image: postgres:14-alpine
    networks:
      - app-network
    # 不设置 ports

  # Redis（不暴露）
  redis:
    image: redis:7-alpine
    networks:
      - app-network
    # 不设置 ports

networks:
  app-network:
    driver: bridge
```

### 7.2 多层网络架构

```yaml
version: '3.8'

services:
  # 反向代理（公开）
  nginx:
    image: nginx
    ports:
      - "80:80"
      - "443:443"
    networks:
      - frontend
    depends_on:
      - api

  # API 服务（前端和后端）
  api:
    build: .
    networks:
      - frontend
      - backend
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/agent_db
      - REDIS_URL=redis://redis:6379

  # 数据库（后端，内部）
  db:
    image: postgres:14-alpine
    networks:
      - backend

  # Redis（后端，内部）
  redis:
    image: redis:7-alpine
    networks:
      - backend

  # 向量数据库（后端，内部）
  chroma:
    image: chromadb/chroma
    networks:
      - backend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true  # 内部网络
```

**网络拓扑：**
```
外部用户
   ↓
nginx (frontend)
   ↓
api (frontend + backend)
   ↓
db, redis, chroma (backend, 内部)
```

### 7.3 开发环境网络配置

```yaml
version: '3.8'

services:
  api:
    networks:
      - app-network
    ports:
      - "8000:8000"

  db:
    networks:
      - app-network
    ports:
      - "5432:5432"  # 开发环境暴露（方便调试）

  redis:
    networks:
      - app-network
    ports:
      - "6379:6379"  # 开发环境暴露

  # 开发工具
  pgadmin:
    image: dpage/pgadmin4
    networks:
      - app-network
    ports:
      - "5050:80"

networks:
  app-network:
```

### 7.4 生产环境网络配置

```yaml
version: '3.8'

services:
  nginx:
    ports:
      - "80:80"
      - "443:443"
    networks:
      - frontend

  api:
    networks:
      - frontend
      - backend
    # 不暴露端口

  db:
    networks:
      - backend
    # 不暴露端口

  redis:
    networks:
      - backend
    # 不暴露端口

networks:
  frontend:
  backend:
    internal: true  # 内部网络
```

---

## 8. 常见问题

### Q1: 为什么容器间无法通信？

**A:** 检查是否在同一网络

```bash
# 查看容器网络
docker inspect <container_name> | grep NetworkMode

# 查看网络详情
docker network inspect <network_name>
```

**解决：**
```yaml
services:
  api:
    networks:
      - app-network

  db:
    networks:
      - app-network  # 确保在同一网络

networks:
  app-network:
```

### Q2: 如何访问主机服务？

**A:** 使用特殊主机名 `host.docker.internal`

```yaml
services:
  api:
    environment:
      - EXTERNAL_API=http://host.docker.internal:3000
```

**或者使用主机网络：**
```yaml
services:
  api:
    network_mode: host
```

### Q3: 如何固定容器 IP？

**A:** 使用自定义网络和 ipv4_address

```yaml
services:
  api:
    networks:
      app-network:
        ipv4_address: 172.20.0.10

networks:
  app-network:
    ipam:
      config:
        - subnet: 172.20.0.0/16
```

### Q4: 如何查看容器的 IP 地址？

**A:** 使用 docker inspect

```bash
# 查看容器 IP
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container_name>

# 或者使用 docker-compose
docker-compose exec api hostname -i
```

### Q5: 端口冲突怎么办？

**A:** 修改主机端口

```yaml
services:
  api:
    ports:
      - "8001:8000"  # 使用不同的主机端口
```

**或者使用动态端口：**
```yaml
services:
  api:
    ports:
      - "8000"  # 主机端口随机分配
```

---

## 9. 性能优化

### 9.1 网络性能

**使用 host 网络（最快）：**
```yaml
services:
  api:
    network_mode: host
```

**注意：** 失去网络隔离，不推荐生产环境。

### 9.2 DNS 缓存

**配置 DNS 选项：**
```yaml
services:
  api:
    dns:
      - 8.8.8.8
      - 8.8.4.4
    dns_search:
      - example.com
```

### 9.3 MTU 设置

```yaml
networks:
  app-network:
    driver: bridge
    driver_opts:
      com.docker.network.driver.mtu: 1450
```

---

## 10. 最佳实践

### 10.1 网络设计原则

1. **最小暴露原则**
   ```yaml
   # ✅ 推荐：只暴露必要的端口
   services:
     api:
       ports:
         - "8000:8000"
     db:
       # 不暴露端口

   # ❌ 不推荐：暴露所有端口
   services:
     db:
       ports:
         - "5432:5432"  # 不必要的暴露
   ```

2. **网络隔离**
   ```yaml
   # ✅ 推荐：使用多个网络隔离
   networks:
     frontend:
     backend:
       internal: true

   # ❌ 不推荐：所有服务在同一网络
   networks:
     default:
   ```

3. **服务发现**
   ```yaml
   # ✅ 推荐：使用服务名
   environment:
     - DATABASE_URL=postgresql://user:pass@db:5432/mydb

   # ❌ 不推荐：使用 IP 地址
   environment:
     - DATABASE_URL=postgresql://user:pass@172.20.0.3:5432/mydb
   ```

### 10.2 安全配置

```yaml
services:
  # 公开服务
  nginx:
    networks:
      - frontend
    ports:
      - "80:80"

  # 内部服务
  api:
    networks:
      - frontend
      - backend

  # 敏感服务
  db:
    networks:
      - backend
    # 不暴露端口

networks:
  frontend:
  backend:
    internal: true  # 内部网络
```

### 10.3 开发 vs 生产

**开发环境：**
```yaml
# docker-compose.dev.yml
services:
  db:
    ports:
      - "5432:5432"  # 暴露端口（方便调试）
```

**生产环境：**
```yaml
# docker-compose.prod.yml
services:
  db:
    # 不暴露端口（安全）
    networks:
      - backend

networks:
  backend:
    internal: true
```

---

## 11. 总结

**网络配置的核心要素：**
1. **默认网络**：自动创建，服务间通过服务名通信
2. **自定义网络**：多网络隔离，提高安全性
3. **网络驱动**：bridge（单机）、host（高性能）、overlay（多机）
4. **服务发现**：通过服务名、容器名、别名访问
5. **端口映射**：ports（暴露）、expose（内部）

**在 AI Agent 开发中：**
- 使用多层网络架构（frontend + backend）
- 只暴露必要的端口（API）
- 数据库和缓存不暴露
- 开发环境可以暴露更多端口（方便调试）
- 生产环境使用内部网络（安全）

**最佳实践：**
- ✅ 最小暴露原则
- ✅ 网络隔离
- ✅ 使用服务名访问
- ✅ 内部网络用于敏感服务
- ❌ 不要暴露不必要的端口
- ❌ 不要使用 IP 地址访问

---

**版本：** v1.0
**最后更新：** 2026-02-12
