# docker-compose编排 - 反直觉点

## 误区1：depends_on 会等待服务完全就绪 ❌

### 为什么错？

**错误理解：**
```yaml
services:
  api:
    depends_on:
      - db  # 以为会等待数据库完全就绪
```

**实际情况：**
- `depends_on` 只等待容器启动（容器进程开始运行）
- 不等待服务就绪（数据库可能还在初始化）
- API 可能在数据库就绪前就尝试连接，导致失败

**正确理解：**
```yaml
services:
  api:
    depends_on:
      db:
        condition: service_healthy  # 等待健康检查通过

  db:
    image: postgres:14-alpine
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
      timeout: 3s
      retries: 5
```

### 为什么人们容易这样错？

**心理原因：**
1. **直觉误导**："depends_on"字面意思是"依赖"，自然认为会等待完全就绪
2. **类比错误**：类比到编程中的依赖（如 import），以为会等待完全加载
3. **经验盲区**：本地开发时数据库启动很快，没遇到问题，以为没问题

**日常类比：**
```
错误理解：等朋友出门 = 等朋友完全准备好（化妆、换衣服）
实际情况：等朋友出门 = 等朋友开门走出来（可能还没化妆）
```

### 正确理解

**启动 vs 就绪：**

| 阶段 | 容器状态 | 服务状态 | depends_on | healthcheck |
|------|---------|---------|------------|-------------|
| 1 | 未启动 | 未启动 | ❌ 等待 | ❌ 未检查 |
| 2 | 启动中 | 未就绪 | ❌ 等待 | ❌ 未检查 |
| 3 | 已启动 | 未就绪 | ✅ 通过 | ❌ 检查失败 |
| 4 | 已启动 | 就绪 | ✅ 通过 | ✅ 检查通过 |

**代码示例：**

```yaml
# ❌ 错误：只等待启动
services:
  api:
    depends_on:
      - db
    command: python app.py  # 可能在数据库就绪前就运行

  db:
    image: postgres:14-alpine
```

**问题：**
```python
# app.py
import psycopg2

# 数据库可能还在初始化，连接失败
conn = psycopg2.connect(DATABASE_URL)  # ❌ 连接错误
```

```yaml
# ✅ 正确：等待就绪
services:
  api:
    depends_on:
      db:
        condition: service_healthy  # 等待健康检查通过
    command: python app.py

  db:
    image: postgres:14-alpine
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
      timeout: 3s
      retries: 5
```

**结果：**
```python
# app.py
import psycopg2

# 数据库已经就绪，连接成功
conn = psycopg2.connect(DATABASE_URL)  # ✅ 连接成功
```

---

## 误区2：volumes 和 bind mounts 是一回事 ❌

### 为什么错？

**错误理解：**
```yaml
services:
  db:
    volumes:
      - ./data:/var/lib/postgresql/data  # 以为这是最佳实践
```

**实际情况：**
- **volumes（命名卷）**：Docker 管理，跨平台兼容，性能好
- **bind mounts（绑定挂载）**：直接映射主机目录，平台相关，性能可能差

**正确理解：**

```yaml
# 数据库：用命名卷（推荐）
services:
  db:
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 命名卷

volumes:
  postgres_data:  # Docker 管理

# 开发代码：用绑定挂载（推荐）
services:
  api:
    volumes:
      - .:/app  # 绑定挂载
```

### 为什么人们容易这样错？

**心理原因：**
1. **可见性偏好**：绑定挂载可以直接看到文件，感觉更"可控"
2. **习惯迁移**：从传统开发习惯（直接操作文件）迁移过来
3. **文档误导**：很多教程为了简单，直接用绑定挂载

**日常类比：**
```
命名卷 = 银行保险箱（安全、专业管理、但看不到）
绑定挂载 = 家里的保险柜（可以随时打开看，但安全性取决于自己）
```

### 正确理解

**对比表：**

| 特性 | 命名卷（volumes） | 绑定挂载（bind mounts） |
|------|------------------|----------------------|
| **管理方式** | Docker 管理 | 用户管理 |
| **路径** | Docker 决定 | 用户指定 |
| **跨平台** | ✅ 完全兼容 | ❌ 路径可能不同 |
| **性能** | ✅ 优化过 | ⚠️ 取决于文件系统 |
| **备份** | ✅ 简单 | ⚠️ 需要手动 |
| **适用场景** | 数据库数据、生产环境 | 开发代码、配置文件 |

**代码示例：**

```yaml
# ❌ 错误：数据库用绑定挂载
services:
  db:
    volumes:
      - ./postgres_data:/var/lib/postgresql/data  # 绑定挂载

# 问题：
# 1. 跨平台兼容性差（Windows/Mac/Linux 路径不同）
# 2. 权限问题（容器内用户 vs 主机用户）
# 3. 性能问题（Mac/Windows 上性能差）
```

```yaml
# ✅ 正确：数据库用命名卷
services:
  db:
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 命名卷

volumes:
  postgres_data:  # Docker 管理

# 优势：
# 1. 跨平台兼容
# 2. 无权限问题
# 3. 性能优化
```

```yaml
# ✅ 正确：开发代码用绑定挂载
services:
  api:
    volumes:
      - .:/app  # 绑定挂载

# 优势：
# 1. 修改代码立即生效
# 2. 可以用本地编辑器
# 3. 方便调试
```

**实际应用：**

```yaml
# AI Agent 开发环境
services:
  api:
    volumes:
      - .:/app  # 代码：绑定挂载（热重载）
      - /app/node_modules  # 排除 node_modules

  db:
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 数据：命名卷（持久化）

  redis:
    volumes:
      - redis_data:/data  # 缓存：命名卷（持久化）

volumes:
  postgres_data:
  redis_data:
```

---

## 误区3：docker-compose 适合生产环境 ❌

### 为什么错？

**错误理解：**
```yaml
# 以为可以直接用于生产环境
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
  db:
    image: postgres:14-alpine
```

**实际情况：**
- docker-compose 主要用于**开发和测试**
- 生产环境需要**高可用、负载均衡、自动扩展**
- docker-compose 缺少这些功能

**正确理解：**

| 环境 | 推荐方案 | 原因 |
|------|---------|------|
| **开发** | docker-compose | 简单、快速、本地运行 |
| **测试** | docker-compose | 隔离、可重复、快速创建 |
| **小型生产** | docker-compose + 监控 | 单机部署、成本低 |
| **中大型生产** | Kubernetes / Docker Swarm | 高可用、自动扩展、负载均衡 |

### 为什么人们容易这样错？

**心理原因：**
1. **简单偏好**：docker-compose 简单易用，不想学习复杂的 K8s
2. **成本考虑**：小项目不想投入太多资源
3. **渐进误区**：从开发环境直接推到生产，没有重新评估

**日常类比：**
```
docker-compose = 家用轿车（适合日常通勤）
Kubernetes = 公交系统（适合大规模运输）

错误：用家用轿车运营公交线路
正确：根据规模选择合适的方案
```

### 正确理解

**docker-compose 的局限：**

1. **单机限制**
   ```yaml
   # docker-compose 只能在单机运行
   # 无法跨多台服务器部署
   ```

2. **无自动扩展**
   ```yaml
   # 无法根据负载自动增加容器数量
   services:
     api:
       replicas: 3  # 只是固定数量，不会自动调整
   ```

3. **无负载均衡**
   ```yaml
   # 多个容器需要手动配置负载均衡
   # 不像 K8s 自动提供 Service
   ```

4. **无自动恢复**
   ```yaml
   # 容器崩溃后需要手动重启
   # 或者依赖 restart: always（但不够智能）
   ```

5. **无滚动更新**
   ```yaml
   # 更新时需要停止所有容器
   # 会有短暂的服务中断
   ```

**代码示例：**

```yaml
# ❌ 错误：直接用于生产
# docker-compose.yml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    restart: always  # 只能在单机重启

  db:
    image: postgres:14-alpine
    restart: always

# 问题：
# 1. 单点故障（服务器挂了，整个服务不可用）
# 2. 无法扩展（流量增加时无法自动增加容器）
# 3. 无负载均衡（多个容器需要手动配置）
```

```yaml
# ✅ 正确：小型生产环境（单机）
# docker-compose.prod.yml
version: '3.8'

services:
  api:
    image: my-api:latest  # 使用构建好的镜像
    ports:
      - "8000:8000"
    restart: always
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: postgres:14-alpine
    restart: always
    volumes:
      - postgres_data:/var/lib/postgresql/data
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

  # 添加监控
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"

volumes:
  postgres_data:

# 配合：
# - 定期备份数据库
# - 监控告警
# - 日志收集
```

```yaml
# ✅ 正确：中大型生产环境（Kubernetes）
# kubernetes/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  replicas: 3  # 自动扩展
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: my-api:latest
        ports:
        - containerPort: 8000
        resources:
          limits:
            cpu: "1"
            memory: "1Gi"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10

---
apiVersion: v1
kind: Service
metadata:
  name: api
spec:
  selector:
    app: api
  ports:
  - port: 80
    targetPort: 8000
  type: LoadBalancer  # 自动负载均衡

# 优势：
# 1. 自动扩展（HPA）
# 2. 自动恢复（容器崩溃自动重启）
# 3. 滚动更新（零停机部署）
# 4. 负载均衡（自动分发流量）
# 5. 多机部署（高可用）
```

**决策树：**

```
生产环境选择
├── 单机部署？
│   ├── 是 → docker-compose + 监控
│   └── 否 → 继续
├── 需要自动扩展？
│   ├── 是 → Kubernetes
│   └── 否 → 继续
├── 需要高可用？
│   ├── 是 → Kubernetes / Docker Swarm
│   └── 否 → docker-compose + 监控
└── 预算有限？
    ├── 是 → docker-compose + 监控
    └── 否 → Kubernetes
```

---

## 总结：三大误区对比

| 误区 | 错误理解 | 正确理解 | 影响 |
|------|---------|---------|------|
| **depends_on** | 等待服务就绪 | 只等待容器启动 | 连接失败、启动错误 |
| **volumes** | 都是一样的 | 命名卷 vs 绑定挂载 | 性能问题、兼容性问题 |
| **生产环境** | 可以直接用 | 只适合小型单机 | 可用性问题、扩展性问题 |

---

## 避免误区的最佳实践

### 1. 依赖管理

```yaml
# ✅ 推荐
services:
  api:
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started

  db:
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
```

### 2. 数据持久化

```yaml
# ✅ 推荐
services:
  api:
    volumes:
      - .:/app  # 代码：绑定挂载

  db:
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 数据：命名卷

volumes:
  postgres_data:
```

### 3. 环境选择

```bash
# 开发环境
docker-compose up

# 测试环境
docker-compose -f docker-compose.test.yml up

# 小型生产（单机）
docker-compose -f docker-compose.prod.yml up -d

# 中大型生产
kubectl apply -f kubernetes/
```

---

## 在 AI Agent 开发中的应用

### 正确的配置

```yaml
version: '3.8'

services:
  # API 服务
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/agent_db
      - REDIS_URL=redis://redis:6379
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      db:
        condition: service_healthy  # ✅ 等待就绪
      redis:
        condition: service_started
    volumes:
      - .:/app  # ✅ 代码：绑定挂载
    restart: unless-stopped

  # 数据库
  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=agent_db
    volumes:
      - postgres_data:/var/lib/postgresql/data  # ✅ 数据：命名卷
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
      timeout: 3s
      retries: 5
    restart: unless-stopped

  # 缓存
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data  # ✅ 数据：命名卷
    restart: unless-stopped

volumes:
  postgres_data:  # ✅ Docker 管理
  redis_data:     # ✅ Docker 管理
```

**说明：**
1. ✅ 使用 `condition: service_healthy` 等待数据库就绪
2. ✅ 代码用绑定挂载（开发方便）
3. ✅ 数据用命名卷（安全可靠）
4. ✅ 明确这是开发/测试环境配置

---

**版本：** v1.0
**最后更新：** 2026-02-12
