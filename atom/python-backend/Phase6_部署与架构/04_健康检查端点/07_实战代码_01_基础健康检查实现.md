# å®æˆ˜ä»£ç 1ï¼šåŸºç¡€å¥åº·æ£€æŸ¥å®ç°

> FastAPI åŸºç¡€å¥åº·æ£€æŸ¥ç«¯ç‚¹çš„å®Œæ•´å®ç°

---

## æ¦‚è¿°

æœ¬æ–‡æä¾›ä¸€ä¸ªå®Œæ•´å¯è¿è¡Œçš„åŸºç¡€å¥åº·æ£€æŸ¥ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š
- /health ç«¯ç‚¹ï¼ˆLivenessï¼‰
- /ready ç«¯ç‚¹ï¼ˆReadinessï¼‰
- å“åº”æ ¼å¼è®¾è®¡
- ç‰ˆæœ¬ä¿¡æ¯ä¸å¯åŠ¨æ—¶é—´
- æ‰‹å†™ç®€å•å¥åº·æ£€æŸ¥å™¨

---

## å®Œæ•´ä»£ç 

```python
"""
åŸºç¡€å¥åº·æ£€æŸ¥å®ç°
æ¼”ç¤ºï¼šFastAPI å¥åº·æ£€æŸ¥ç«¯ç‚¹çš„åŸºç¡€å®ç°
"""

from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel
from datetime import datetime
from typing import Dict, Optional
import time
import sys

# ===== 1. åˆ›å»º FastAPI åº”ç”¨ =====

app = FastAPI(
    title="AI Agent API",
    description="AI Agent åç«¯ API",
    version="1.0.0"
)

# åº”ç”¨å¯åŠ¨æ—¶é—´
app.state.start_time = time.time()
app.state.version = "1.0.0"

# ===== 2. å“åº”æ¨¡å‹å®šä¹‰ =====

class HealthResponse(BaseModel):
    """å¥åº·æ£€æŸ¥å“åº”æ¨¡å‹"""
    status: str
    timestamp: str

class ReadyResponse(BaseModel):
    """å°±ç»ªæ£€æŸ¥å“åº”æ¨¡å‹"""
    status: str
    timestamp: str
    version: str
    uptime_seconds: float
    checks: Optional[Dict[str, bool]] = None

# ===== 3. Liveness ç«¯ç‚¹ï¼ˆæœ€ç®€å•ï¼‰ =====

@app.get(
    "/health",
    response_model=HealthResponse,
    tags=["Health"],
    summary="Liveness æ£€æŸ¥",
    description="æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜æ´»"
)
async def health():
    """
    Liveness Probe ç«¯ç‚¹

    åªè¦è¿›ç¨‹èƒ½å“åº”å°±è¿”å› 200
    ç”¨äº Kubernetes Liveness Probe
    """
    return HealthResponse(
        status="healthy",
        timestamp=datetime.utcnow().isoformat()
    )

# ===== 4. Readiness ç«¯ç‚¹ï¼ˆåŸºç¡€ç‰ˆï¼‰ =====

@app.get(
    "/ready",
    response_model=ReadyResponse,
    tags=["Health"],
    summary="Readiness æ£€æŸ¥",
    description="æ£€æŸ¥æœåŠ¡æ˜¯å¦å‡†å¤‡å¥½æ¥æ”¶æµé‡"
)
async def ready():
    """
    Readiness Probe ç«¯ç‚¹

    æ£€æŸ¥æœåŠ¡æ˜¯å¦å‡†å¤‡å¥½æ¥æ”¶æµé‡
    ç”¨äº Kubernetes Readiness Probe å’Œè´Ÿè½½å‡è¡¡å™¨
    """
    # è®¡ç®—è¿è¡Œæ—¶é—´
    uptime = time.time() - app.state.start_time

    return ReadyResponse(
        status="ready",
        timestamp=datetime.utcnow().isoformat(),
        version=app.state.version,
        uptime_seconds=uptime
    )

# ===== 5. å¸¦ä¾èµ–æ£€æŸ¥çš„ Readiness ç«¯ç‚¹ =====

# æ¨¡æ‹Ÿä¾èµ–æœåŠ¡æ£€æŸ¥å‡½æ•°
async def check_database() -> bool:
    """æ£€æŸ¥æ•°æ®åº“è¿æ¥ï¼ˆæ¨¡æ‹Ÿï¼‰"""
    # å®é™…é¡¹ç›®ä¸­æ›¿æ¢ä¸ºçœŸå®çš„æ•°æ®åº“æ£€æŸ¥
    # await db.execute("SELECT 1")
    return True

async def check_redis() -> bool:
    """æ£€æŸ¥ Redis è¿æ¥ï¼ˆæ¨¡æ‹Ÿï¼‰"""
    # å®é™…é¡¹ç›®ä¸­æ›¿æ¢ä¸ºçœŸå®çš„ Redis æ£€æŸ¥
    # await redis.ping()
    return True

@app.get(
    "/ready/detailed",
    response_model=ReadyResponse,
    tags=["Health"],
    summary="è¯¦ç»†çš„ Readiness æ£€æŸ¥",
    description="æ£€æŸ¥æœåŠ¡åŠå…¶ä¾èµ–æ˜¯å¦å‡†å¤‡å¥½"
)
async def ready_detailed():
    """
    è¯¦ç»†çš„ Readiness æ£€æŸ¥

    æ£€æŸ¥æœåŠ¡åŠå…¶æ‰€æœ‰ä¾èµ–æ˜¯å¦å‡†å¤‡å¥½
    """
    # æ£€æŸ¥ä¾èµ–æœåŠ¡
    checks = {
        "database": await check_database(),
        "redis": await check_redis(),
    }

    # è®¡ç®—è¿è¡Œæ—¶é—´
    uptime = time.time() - app.state.start_time

    # å¦‚æœä»»ä½•ä¾èµ–å¤±è´¥ï¼Œè¿”å› 503
    if not all(checks.values()):
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail={
                "status": "not_ready",
                "timestamp": datetime.utcnow().isoformat(),
                "version": app.state.version,
                "uptime_seconds": uptime,
                "checks": checks
            }
        )

    return ReadyResponse(
        status="ready",
        timestamp=datetime.utcnow().isoformat(),
        version=app.state.version,
        uptime_seconds=uptime,
        checks=checks
    )

# ===== 6. ç‰ˆæœ¬ä¿¡æ¯ç«¯ç‚¹ =====

class VersionResponse(BaseModel):
    """ç‰ˆæœ¬ä¿¡æ¯å“åº”æ¨¡å‹"""
    version: str
    python_version: str
    start_time: str
    uptime_seconds: float

@app.get(
    "/version",
    response_model=VersionResponse,
    tags=["Info"],
    summary="ç‰ˆæœ¬ä¿¡æ¯",
    description="è·å–åº”ç”¨ç‰ˆæœ¬å’Œè¿è¡Œä¿¡æ¯"
)
async def version():
    """
    ç‰ˆæœ¬ä¿¡æ¯ç«¯ç‚¹

    è¿”å›åº”ç”¨ç‰ˆæœ¬ã€Python ç‰ˆæœ¬ã€å¯åŠ¨æ—¶é—´ç­‰ä¿¡æ¯
    """
    uptime = time.time() - app.state.start_time
    start_time = datetime.fromtimestamp(app.state.start_time)

    return VersionResponse(
        version=app.state.version,
        python_version=f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
        start_time=start_time.isoformat(),
        uptime_seconds=uptime
    )

# ===== 7. æ ¹è·¯å¾„ï¼ˆæ¬¢è¿é¡µé¢ï¼‰ =====

@app.get(
    "/",
    tags=["Info"],
    summary="æ¬¢è¿é¡µé¢",
    description="API æ¬¢è¿é¡µé¢"
)
async def root():
    """
    æ ¹è·¯å¾„

    è¿”å› API æ¬¢è¿ä¿¡æ¯
    """
    return {
        "message": "Welcome to AI Agent API",
        "version": app.state.version,
        "docs": "/docs",
        "health": "/health",
        "ready": "/ready"
    }

# ===== 8. å¯åŠ¨å’Œå…³é—­äº‹ä»¶ =====

@app.on_event("startup")
async def startup_event():
    """åº”ç”¨å¯åŠ¨äº‹ä»¶"""
    print(f"ğŸš€ AI Agent API v{app.state.version} started")
    print(f"ğŸ“ Docs: http://localhost:8000/docs")
    print(f"â¤ï¸  Health: http://localhost:8000/health")
    print(f"âœ… Ready: http://localhost:8000/ready")

@app.on_event("shutdown")
async def shutdown_event():
    """åº”ç”¨å…³é—­äº‹ä»¶"""
    print("ğŸ‘‹ AI Agent API shutting down")

# ===== 9. è¿è¡Œè¯´æ˜ =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("åŸºç¡€å¥åº·æ£€æŸ¥å®ç°")
    print("=" * 50)
    print()
    print("å¯åŠ¨æœåŠ¡ï¼š")
    print("  uvicorn main:app --reload")
    print()
    print("æµ‹è¯•ç«¯ç‚¹ï¼š")
    print("  curl http://localhost:8000/health")
    print("  curl http://localhost:8000/ready")
    print("  curl http://localhost:8000/ready/detailed")
    print("  curl http://localhost:8000/version")
    print()
    print("=" * 50)

    # å¯åŠ¨æœåŠ¡
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info"
    )
```

---

## è¿è¡Œç¤ºä¾‹

### 1. å®‰è£…ä¾èµ–

```bash
# ä½¿ç”¨ uv å®‰è£…ä¾èµ–
uv add fastapi uvicorn[standard]
```

### 2. è¿è¡ŒæœåŠ¡

```bash
# æ–¹å¼1ï¼šç›´æ¥è¿è¡Œ
python main.py

# æ–¹å¼2ï¼šä½¿ç”¨ uvicorn
uvicorn main:app --reload
```

### 3. æµ‹è¯•ç«¯ç‚¹

**æµ‹è¯• /health ç«¯ç‚¹ï¼š**

```bash
curl http://localhost:8000/health
```

**è¾“å‡ºï¼š**

```json
{
  "status": "healthy",
  "timestamp": "2026-02-13T01:00:00.000000"
}
```

**æµ‹è¯• /ready ç«¯ç‚¹ï¼š**

```bash
curl http://localhost:8000/ready
```

**è¾“å‡ºï¼š**

```json
{
  "status": "ready",
  "timestamp": "2026-02-13T01:00:00.000000",
  "version": "1.0.0",
  "uptime_seconds": 123.45,
  "checks": null
}
```

**æµ‹è¯• /ready/detailed ç«¯ç‚¹ï¼š**

```bash
curl http://localhost:8000/ready/detailed
```

**è¾“å‡ºï¼š**

```json
{
  "status": "ready",
  "timestamp": "2026-02-13T01:00:00.000000",
  "version": "1.0.0",
  "uptime_seconds": 123.45,
  "checks": {
    "database": true,
    "redis": true
  }
}
```

**æµ‹è¯• /version ç«¯ç‚¹ï¼š**

```bash
curl http://localhost:8000/version
```

**è¾“å‡ºï¼š**

```json
{
  "version": "1.0.0",
  "python_version": "3.13.1",
  "start_time": "2026-02-13T01:00:00",
  "uptime_seconds": 123.45
}
```

---

## æ‰©å±•ç¤ºä¾‹ï¼šå¸¦ç¼“å­˜çš„å¥åº·æ£€æŸ¥

```python
"""
å¸¦ç¼“å­˜çš„å¥åº·æ£€æŸ¥å®ç°
é¿å…é¢‘ç¹æ£€æŸ¥å½±å“æ€§èƒ½
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from datetime import datetime
from typing import Dict
import time

app = FastAPI()

# ===== å¥åº·æ£€æŸ¥ç¼“å­˜ =====

class HealthCache:
    """å¥åº·æ£€æŸ¥ç¼“å­˜"""

    def __init__(self, ttl: int = 30):
        self.ttl = ttl  # ç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼‰
        self.last_check = 0
        self.checks = {}

    def is_expired(self) -> bool:
        """æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ"""
        return time.time() - self.last_check >= self.ttl

    def update(self, checks: Dict[str, bool]):
        """æ›´æ–°ç¼“å­˜"""
        self.last_check = time.time()
        self.checks = checks

    def get(self) -> Dict[str, bool]:
        """è·å–ç¼“å­˜"""
        return self.checks

# åˆ›å»ºç¼“å­˜å®ä¾‹
health_cache = HealthCache(ttl=30)

# ===== ä¾èµ–æ£€æŸ¥å‡½æ•° =====

async def check_database() -> bool:
    """æ£€æŸ¥æ•°æ®åº“è¿æ¥"""
    print("ğŸ” Checking database...")
    # æ¨¡æ‹Ÿæ•°æ®åº“æ£€æŸ¥
    await asyncio.sleep(0.05)  # æ¨¡æ‹Ÿ 50ms å»¶è¿Ÿ
    return True

async def check_redis() -> bool:
    """æ£€æŸ¥ Redis è¿æ¥"""
    print("ğŸ” Checking Redis...")
    # æ¨¡æ‹Ÿ Redis æ£€æŸ¥
    await asyncio.sleep(0.03)  # æ¨¡æ‹Ÿ 30ms å»¶è¿Ÿ
    return True

# ===== å¥åº·æ£€æŸ¥ç«¯ç‚¹ï¼ˆå¸¦ç¼“å­˜ï¼‰ =====

class ReadyResponse(BaseModel):
    status: str
    timestamp: str
    checks: Dict[str, bool]
    cached: bool

@app.get("/ready", response_model=ReadyResponse)
async def ready():
    """
    å°±ç»ªæ£€æŸ¥ï¼ˆå¸¦ç¼“å­˜ï¼‰

    ç¼“å­˜ 30 ç§’ï¼Œé¿å…é¢‘ç¹æ£€æŸ¥
    """
    # æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ
    if health_cache.is_expired():
        print("â° Cache expired, performing health check...")

        # æ‰§è¡Œå®é™…æ£€æŸ¥
        checks = {
            "database": await check_database(),
            "redis": await check_redis(),
        }

        # æ›´æ–°ç¼“å­˜
        health_cache.update(checks)
        cached = False
    else:
        print("âœ… Using cached health status")
        checks = health_cache.get()
        cached = True

    # åˆ¤æ–­æ•´ä½“çŠ¶æ€
    if not all(checks.values()):
        raise HTTPException(
            status_code=503,
            detail={
                "status": "not_ready",
                "checks": checks,
                "cached": cached
            }
        )

    return ReadyResponse(
        status="ready",
        timestamp=datetime.utcnow().isoformat(),
        checks=checks,
        cached=cached
    )

# ===== è¿è¡Œç¤ºä¾‹ =====

if __name__ == "__main__":
    import uvicorn
    import asyncio

    print("=" * 50)
    print("å¸¦ç¼“å­˜çš„å¥åº·æ£€æŸ¥å®ç°")
    print("=" * 50)
    print()
    print("æµ‹è¯•ç¼“å­˜æ•ˆæœï¼š")
    print("  ç¬¬ä¸€æ¬¡è¯·æ±‚ï¼šæ‰§è¡Œå®é™…æ£€æŸ¥ï¼ˆæ…¢ï¼‰")
    print("  åç»­è¯·æ±‚ï¼šä½¿ç”¨ç¼“å­˜ï¼ˆå¿«ï¼‰")
    print("  30 ç§’åï¼šç¼“å­˜è¿‡æœŸï¼Œé‡æ–°æ£€æŸ¥")
    print()
    print("æµ‹è¯•å‘½ä»¤ï¼š")
    print("  curl http://localhost:8000/ready")
    print()
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**æµ‹è¯•ç¼“å­˜æ•ˆæœï¼š**

```bash
# ç¬¬ä¸€æ¬¡è¯·æ±‚ï¼ˆæ‰§è¡Œå®é™…æ£€æŸ¥ï¼‰
curl http://localhost:8000/ready
# è¾“å‡º: {"status":"ready","timestamp":"...","checks":{...},"cached":false}

# ç«‹å³å†æ¬¡è¯·æ±‚ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
curl http://localhost:8000/ready
# è¾“å‡º: {"status":"ready","timestamp":"...","checks":{...},"cached":true}

# 30 ç§’åè¯·æ±‚ï¼ˆç¼“å­˜è¿‡æœŸï¼Œé‡æ–°æ£€æŸ¥ï¼‰
sleep 30
curl http://localhost:8000/ready
# è¾“å‡º: {"status":"ready","timestamp":"...","checks":{...},"cached":false}
```

---

## æ‰©å±•ç¤ºä¾‹ï¼šä¸‰æ€å¥åº·æ£€æŸ¥

```python
"""
ä¸‰æ€å¥åº·æ£€æŸ¥å®ç°
æ”¯æŒï¼šå¥åº·ã€é™çº§ã€ä¸å¥åº·
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from enum import Enum
from typing import Dict

app = FastAPI()

# ===== å¥åº·çŠ¶æ€æšä¸¾ =====

class HealthStatus(str, Enum):
    HEALTHY = "healthy"      # æ‰€æœ‰ä¾èµ–æ­£å¸¸
    DEGRADED = "degraded"    # éƒ¨åˆ†ä¾èµ–å¤±è´¥ï¼Œä½†æ ¸å¿ƒåŠŸèƒ½å¯ç”¨
    UNHEALTHY = "unhealthy"  # æ ¸å¿ƒä¾èµ–å¤±è´¥ï¼Œä¸å¯ç”¨

# ===== ä¾èµ–æ£€æŸ¥å‡½æ•° =====

async def check_database() -> bool:
    """æ£€æŸ¥æ•°æ®åº“ï¼ˆæ ¸å¿ƒä¾èµ–ï¼‰"""
    return True

async def check_redis() -> bool:
    """æ£€æŸ¥ Redisï¼ˆå¯é€‰ä¾èµ–ï¼‰"""
    return False  # æ¨¡æ‹Ÿ Redis å¤±è´¥

async def check_llm_api() -> bool:
    """æ£€æŸ¥ LLM APIï¼ˆå¯é€‰ä¾èµ–ï¼‰"""
    return True

# ===== ä¸‰æ€å¥åº·æ£€æŸ¥ç«¯ç‚¹ =====

class ReadyResponse(BaseModel):
    status: HealthStatus
    message: str
    checks: Dict[str, bool]

@app.get("/ready", response_model=ReadyResponse)
async def ready():
    """
    ä¸‰æ€å¥åº·æ£€æŸ¥

    - HEALTHY: æ‰€æœ‰ä¾èµ–æ­£å¸¸
    - DEGRADED: éƒ¨åˆ†ä¾èµ–å¤±è´¥ï¼Œä½†æ ¸å¿ƒåŠŸèƒ½å¯ç”¨
    - UNHEALTHY: æ ¸å¿ƒä¾èµ–å¤±è´¥ï¼Œä¸å¯ç”¨
    """
    # æ£€æŸ¥æ‰€æœ‰ä¾èµ–
    checks = {
        "database": await check_database(),      # æ ¸å¿ƒä¾èµ–
        "redis": await check_redis(),            # å¯é€‰ä¾èµ–
        "llm_api": await check_llm_api(),        # å¯é€‰ä¾èµ–
    }

    # åˆ¤æ–­æ•´ä½“çŠ¶æ€
    if checks["database"]:
        # æ•°æ®åº“æ­£å¸¸
        if checks["redis"] and checks["llm_api"]:
            # æ‰€æœ‰ä¾èµ–æ­£å¸¸
            return ReadyResponse(
                status=HealthStatus.HEALTHY,
                message="All dependencies are healthy",
                checks=checks
            )
        else:
            # éƒ¨åˆ†ä¾èµ–å¤±è´¥ï¼Œä½†å¯ç”¨
            failed = [k for k, v in checks.items() if not v]
            return ReadyResponse(
                status=HealthStatus.DEGRADED,
                message=f"Running in degraded mode: {', '.join(failed)} unavailable",
                checks=checks
            )
    else:
        # æ•°æ®åº“å¤±è´¥ï¼Œä¸å¯ç”¨
        raise HTTPException(
            status_code=503,
            detail={
                "status": HealthStatus.UNHEALTHY,
                "message": "Database unavailable",
                "checks": checks
            }
        )

# ===== è¿è¡Œç¤ºä¾‹ =====

if __name__ == "__main__":
    import uvicorn

    print("=" * 50)
    print("ä¸‰æ€å¥åº·æ£€æŸ¥å®ç°")
    print("=" * 50)
    print()
    print("å¥åº·çŠ¶æ€ï¼š")
    print("  HEALTHY: æ‰€æœ‰ä¾èµ–æ­£å¸¸")
    print("  DEGRADED: éƒ¨åˆ†ä¾èµ–å¤±è´¥ï¼Œä½†æ ¸å¿ƒåŠŸèƒ½å¯ç”¨")
    print("  UNHEALTHY: æ ¸å¿ƒä¾èµ–å¤±è´¥ï¼Œä¸å¯ç”¨")
    print()
    print("æµ‹è¯•å‘½ä»¤ï¼š")
    print("  curl http://localhost:8000/ready")
    print()
    print("=" * 50)

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**æµ‹è¯•è¾“å‡ºï¼š**

```json
{
  "status": "degraded",
  "message": "Running in degraded mode: redis unavailable",
  "checks": {
    "database": true,
    "redis": false,
    "llm_api": true
  }
}
```

---

## å…³é”®è¦ç‚¹

### 1. Liveness vs Readiness

- **Liveness (/health)**ï¼šåªæ£€æŸ¥è¿›ç¨‹æ˜¯å¦å“åº”
- **Readiness (/ready)**ï¼šæ£€æŸ¥æ˜¯å¦å‡†å¤‡å¥½æ¥æ”¶æµé‡

### 2. å“åº”æ ¼å¼

**ç®€å•æ ¼å¼ï¼ˆæ¨èï¼‰ï¼š**

```json
{
  "status": "healthy"
}
```

**è¯¦ç»†æ ¼å¼ï¼š**

```json
{
  "status": "ready",
  "timestamp": "2026-02-13T01:00:00Z",
  "version": "1.0.0",
  "uptime_seconds": 123.45,
  "checks": {
    "database": true,
    "redis": true
  }
}
```

### 3. HTTP çŠ¶æ€ç 

- **200 OK**ï¼šå¥åº·æˆ–é™çº§
- **503 Service Unavailable**ï¼šä¸å¥åº·

### 4. ç¼“å­˜ç­–ç•¥

- ç¼“å­˜å¥åº·æ£€æŸ¥ç»“æœï¼ˆ30-60ç§’ï¼‰
- é¿å…é¢‘ç¹æ£€æŸ¥å½±å“æ€§èƒ½
- å¹³æ»‘çŸ­æš‚æŠ–åŠ¨

### 5. ä¸‰æ€æ¨¡å‹

- **HEALTHY**ï¼šæ‰€æœ‰ä¾èµ–æ­£å¸¸
- **DEGRADED**ï¼šéƒ¨åˆ†ä¾èµ–å¤±è´¥ï¼Œä½†å¯ç”¨
- **UNHEALTHY**ï¼šæ ¸å¿ƒä¾èµ–å¤±è´¥ï¼Œä¸å¯ç”¨

---

## ä¸‹ä¸€æ­¥

å­¦ä¹ å®ŒåŸºç¡€å¥åº·æ£€æŸ¥åï¼Œå¯ä»¥ç»§ç»­å­¦ä¹ ï¼š

1. **æ•°æ®åº“è¿æ¥æ£€æŸ¥** - æ£€æŸ¥ PostgreSQL è¿æ¥æ± 
2. **Redis ç¼“å­˜æ£€æŸ¥** - æ£€æŸ¥ Redis è¿æ¥å’Œæ€§èƒ½
3. **å¤–éƒ¨ API æ£€æŸ¥** - æ£€æŸ¥ LLM API å¯ç”¨æ€§
4. **Kubernetes é›†æˆ** - é…ç½® Liveness å’Œ Readiness Probe
5. **ç”Ÿäº§çº§ç³»ç»Ÿ** - å®Œæ•´çš„å¥åº·æ£€æŸ¥æ¡†æ¶

---

## æ€»ç»“

åŸºç¡€å¥åº·æ£€æŸ¥å®ç°çš„å…³é”®ï¼š

1. **ç®€å•å¿«é€Ÿ**ï¼šLiveness åªæ£€æŸ¥è¿›ç¨‹å“åº”
2. **æ£€æŸ¥ä¾èµ–**ï¼šReadiness æ£€æŸ¥å…³é”®ä¾èµ–æœåŠ¡
3. **ä½¿ç”¨ç¼“å­˜**ï¼šé¿å…é¢‘ç¹æ£€æŸ¥å½±å“æ€§èƒ½
4. **æ ‡å‡†åŒ–å“åº”**ï¼šä½¿ç”¨ç»Ÿä¸€çš„å“åº”æ ¼å¼
5. **ä¸‰æ€æ¨¡å‹**ï¼šæ”¯æŒå¥åº·ã€é™çº§ã€ä¸å¥åº·ä¸‰ç§çŠ¶æ€

åœ¨ AI Agent åç«¯ä¸­ï¼ŒåŸºç¡€å¥åº·æ£€æŸ¥æ˜¯ç›‘æ§å’Œé«˜å¯ç”¨æ€§çš„åŸºç¡€ã€‚
