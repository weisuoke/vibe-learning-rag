# Extensions 扩展开发基础 - 实战代码 03：命令与快捷键扩展

> 通过 registerCommand 和 registerShortcut API 注册自定义命令和快捷键

---

## 1. 场景介绍

### 1.1 为什么需要命令与快捷键扩展？

在 AI Agent 开发中，用户经常需要执行特定的操作：

**场景 1：快速访问功能**
```
需求：快速查看所有可用命令
问题：需要记住所有命令名称
解决：注册 /commands 命令，列出所有命令
```

**场景 2：自定义工作流**
```
需求：一键部署应用并退出
问题：需要多个步骤（部署、确认、退出）
解决：注册 /deploy 命令，自动化整个流程
```

**场景 3：快捷键操作**
```
需求：快速保存会话快照
问题：需要输入完整命令
解决：注册 Ctrl+S 快捷键，一键保存
```

### 1.2 命令与快捷键的核心概念

**命令（Command）**：
```typescript
interface CommandDefinition {
  description: string;                    // 命令描述
  getArgumentCompletions?: (prefix: string) => CompletionItem[] | null;
  handler: CommandHandler;                // 命令处理函数
}

type CommandHandler = (
  args: string,                           // 命令参数
  ctx: CommandContext                     // 命令上下文
) => Promise<void>;
```

**快捷键（Shortcut）**：
```typescript
interface ShortcutDefinition {
  description: string;                    // 快捷键描述
  handler: ShortcutHandler;               // 快捷键处理函数
}

type ShortcutHandler = (
  ctx: ShortcutContext                    // 快捷键上下文
) => Promise<void>;
```

**KeyId 类型**：
```typescript
type KeyId =
  | "ctrl+a" | "ctrl+b" | ... | "ctrl+z"
  | "cmd+a" | "cmd+b" | ... | "cmd+z"
  | "alt+a" | "alt+b" | ... | "alt+z"
  | "shift+a" | "shift+b" | ... | "shift+z"
  | "f1" | "f2" | ... | "f12"
  | ...
```

### 1.3 技术要点

- **命令注册**：`pi.registerCommand(name, definition)`
- **快捷键注册**：`pi.registerShortcut(keyId, definition)`
- **参数自动补全**：`getArgumentCompletions` 提供参数建议
- **UI 交互**：`ctx.ui` 提供对话框、通知等
- **会话控制**：`ctx.shutdown()` 优雅退出

---

## 2. 完整实现

### 2.1 基础版本：列出所有命令

```typescript
/**
 * Commands Extension - 列出所有可用命令
 *
 * 功能：
 * - /commands: 列出所有命令
 * - /commands extension: 只列出扩展命令
 * - /commands skill: 只列出技能命令
 */

import type { ExtensionAPI, SlashCommandInfo } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  pi.registerCommand("commands", {
    description: "List available slash commands",

    // 参数自动补全
    getArgumentCompletions: (prefix) => {
      const sources = ["extension", "prompt", "skill"];
      const filtered = sources.filter((s) => s.startsWith(prefix));
      return filtered.length > 0
        ? filtered.map((s) => ({ value: s, label: s }))
        : null;
    },

    // 命令处理函数
    handler: async (args, ctx) => {
      // 获取所有命令
      const commands = pi.getCommands();
      const sourceFilter = args.trim() as "extension" | "prompt" | "skill" | "";

      // 按来源过滤
      const filtered = sourceFilter
        ? commands.filter((c) => c.source === sourceFilter)
        : commands;

      if (filtered.length === 0) {
        ctx.ui.notify(
          sourceFilter ? `No ${sourceFilter} commands found` : "No commands found",
          "info"
        );
        return;
      }

      // 格式化命令列表
      const formatCommand = (cmd: SlashCommandInfo): string => {
        const desc = cmd.description ? ` - ${cmd.description}` : "";
        return `/${cmd.name}${desc}`;
      };

      // 按来源分组
      const items: string[] = [];
      const sources: Array<{ key: "extension" | "prompt" | "skill"; label: string }> = [
        { key: "extension", label: "Extensions" },
        { key: "prompt", label: "Prompts" },
        { key: "skill", label: "Skills" },
      ];

      for (const { key, label } of sources) {
        const cmds = filtered.filter((c) => c.source === key);
        if (cmds.length > 0) {
          items.push(`--- ${label} ---`);
          items.push(...cmds.map(formatCommand));
        }
      }

      // 显示选择器
      const selected = await ctx.ui.select("Available Commands", items);

      // 如果用户选择了命令（不是标题），显示路径
      if (selected && !selected.startsWith("---")) {
        const cmdName = selected.split(" - ")[0].slice(1); // 移除前导 /
        const cmd = commands.find((c) => c.name === cmdName);
        if (cmd?.path) {
          const showPath = await ctx.ui.confirm(
            cmd.name,
            `View source path?\n${cmd.path}`
          );
          if (showPath) {
            ctx.ui.notify(cmd.path, "info");
          }
        }
      }
    },
  });
}
```

### 2.2 进阶版本：优雅退出命令

```typescript
/**
 * Shutdown Command Extension - 优雅退出
 *
 * 功能：
 * - /quit: 立即退出
 * - /deploy: 部署后退出
 * - finish_and_exit 工具：完成任务后退出
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { Type } from "@sinclair/typebox";

export default function (pi: ExtensionAPI) {
  // 1. 简单退出命令
  pi.registerCommand("quit", {
    description: "Exit pi cleanly",
    handler: async (_args, ctx) => {
      ctx.shutdown();
    },
  });

  // 2. 带确认的退出命令
  pi.registerCommand("exit", {
    description: "Exit pi with confirmation",
    handler: async (_args, ctx) => {
      const confirmed = await ctx.ui.confirm(
        "Exit",
        "Are you sure you want to exit?"
      );

      if (confirmed) {
        ctx.ui.notify("Goodbye!", "info");
        ctx.shutdown();
      }
    },
  });

  // 3. 完成任务后退出的工具
  pi.registerTool({
    name: "finish_and_exit",
    label: "Finish and Exit",
    description: "Complete a task and exit pi",
    parameters: Type.Object({}),

    async execute(_toolCallId, _params, _signal, _onUpdate, ctx) {
      // 执行清理工作...
      // 请求优雅关闭（延迟到 agent 空闲时）
      ctx.shutdown();

      // 这个返回会在关闭前发送给 LLM
      return {
        content: [
          { type: "text", text: "Shutdown requested. Exiting after this response." }
        ],
        details: {},
      };
    },
  });

  // 4. 部署后退出的工具
  pi.registerTool({
    name: "deploy_and_exit",
    label: "Deploy and Exit",
    description: "Deploy the application and exit pi",
    parameters: Type.Object({
      environment: Type.String({
        description: "Target environment (e.g., production, staging)"
      }),
    }),

    async execute(_toolCallId, params, signal, onUpdate, ctx) {
      const { environment } = params as { environment: string };

      onUpdate?.({
        content: [{ type: "text", text: `Deploying to ${environment}...` }],
        details: {},
      });

      // 模拟部署逻辑
      await new Promise((resolve) => setTimeout(resolve, 2000));

      // 部署成功，请求优雅关闭
      onUpdate?.({
        content: [{ type: "text", text: "Deployment complete, exiting..." }],
        details: {},
      });

      ctx.shutdown();

      return {
        content: [{ type: "text", text: "Done! Shutdown requested." }],
        details: { environment },
      };
    },
  });
}
```

### 2.3 高级版本：快捷键与命令组合

```typescript
/**
 * Shortcuts Extension - 快捷键与命令组合
 *
 * 功能：
 * - Ctrl+S: 保存会话快照
 * - Ctrl+L: 清空屏幕
 * - Ctrl+R: 重新加载扩展
 * - /snapshot: 手动保存快照
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { writeFileSync } from "fs";
import { join } from "path";
import { homedir } from "os";

export default function (pi: ExtensionAPI) {
  const snapshotDir = join(homedir(), ".pi", "snapshots");

  // 保存快照的共享逻辑
  async function saveSnapshot(ctx: any): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const filename = `snapshot-${timestamp}.json`;
    const filepath = join(snapshotDir, filename);

    // 获取会话数据
    const sessionData = {
      id: ctx.session.id,
      timestamp: new Date().toISOString(),
      messages: ctx.session.messages || [],
      metadata: ctx.session.metadata || {},
    };

    // 保存到文件
    writeFileSync(filepath, JSON.stringify(sessionData, null, 2));

    return filepath;
  }

  // 1. 注册快捷键：Ctrl+S 保存快照
  pi.registerShortcut("ctrl+s", {
    description: "Save session snapshot",
    handler: async (ctx) => {
      try {
        const filepath = await saveSnapshot(ctx);
        ctx.ui.notify(`Snapshot saved: ${filepath}`, "success");
      } catch (error: any) {
        ctx.ui.notify(`Failed to save snapshot: ${error.message}`, "error");
      }
    },
  });

  // 2. 注册快捷键：Ctrl+L 清空屏幕
  pi.registerShortcut("ctrl+l", {
    description: "Clear screen",
    handler: async (ctx) => {
      // 清空屏幕（通过 UI API）
      if (ctx.ui.clear) {
        ctx.ui.clear();
      } else {
        ctx.ui.notify("Screen cleared", "info");
      }
    },
  });

  // 3. 注册快捷键：Ctrl+R 重新加载扩展
  pi.registerShortcut("ctrl+r", {
    description: "Reload extensions",
    handler: async (ctx) => {
      ctx.ui.notify("Reloading extensions...", "info");
      // 触发重新加载（通过命令）
      // 注意：实际实现可能需要调用内部 API
    },
  });

  // 4. 注册命令：/snapshot 手动保存快照
  pi.registerCommand("snapshot", {
    description: "Save a session snapshot",
    handler: async (args, ctx) => {
      try {
        const filepath = await saveSnapshot(ctx);
        ctx.ui.notify(`Snapshot saved: ${filepath}`, "success");

        // 如果提供了参数，作为快照描述
        if (args.trim()) {
          const descFile = filepath.replace(".json", ".txt");
          writeFileSync(descFile, args.trim());
          ctx.ui.notify(`Description saved: ${descFile}`, "info");
        }
      } catch (error: any) {
        ctx.ui.notify(`Failed to save snapshot: ${error.message}`, "error");
      }
    },
  });

  // 5. 注册命令：/snapshots 列出所有快照
  pi.registerCommand("snapshots", {
    description: "List all saved snapshots",
    handler: async (_args, ctx) => {
      try {
        const { readdirSync } = await import("fs");
        const files = readdirSync(snapshotDir)
          .filter((f) => f.endsWith(".json"))
          .sort()
          .reverse();

        if (files.length === 0) {
          ctx.ui.notify("No snapshots found", "info");
          return;
        }

        const selected = await ctx.ui.select(
          "Saved Snapshots",
          files.map((f) => f.replace("snapshot-", "").replace(".json", ""))
        );

        if (selected) {
          const filepath = join(snapshotDir, `snapshot-${selected}.json`);
          ctx.ui.notify(`Snapshot path: ${filepath}`, "info");
        }
      } catch (error: any) {
        ctx.ui.notify(`Failed to list snapshots: ${error.message}`, "error");
      }
    },
  });
}
```

---

## 3. 代码解析

### 3.1 命令注册机制

```typescript
pi.registerCommand("command-name", {
  description: "命令描述",
  getArgumentCompletions: (prefix) => {
    // 返回参数补全建议
    return [
      { value: "option1", label: "Option 1" },
      { value: "option2", label: "Option 2" },
    ];
  },
  handler: async (args, ctx) => {
    // 处理命令
    // args: 命令参数（字符串）
    // ctx: 命令上下文
  },
});
```

**命令调用流程：**
```
用户输入 /command-name arg1 arg2
  ↓
触发 handler("arg1 arg2", ctx)
  ↓
执行命令逻辑
  ↓
返回结果（通过 ctx.ui）
```

### 3.2 参数自动补全

```typescript
getArgumentCompletions: (prefix) => {
  // prefix: 用户已输入的前缀
  // 返回: CompletionItem[] | null

  const options = ["production", "staging", "development"];
  const filtered = options.filter((opt) => opt.startsWith(prefix));

  if (filtered.length === 0) {
    return null; // 无补全建议
  }

  return filtered.map((opt) => ({
    value: opt,        // 补全值
    label: opt,        // 显示标签
  }));
}
```

**补全示例：**
```
用户输入: /deploy pr<TAB>
补全结果: /deploy production

用户输入: /deploy <TAB>
补全结果: production, staging, development
```

### 3.3 快捷键注册机制

```typescript
pi.registerShortcut("ctrl+s", {
  description: "快捷键描述",
  handler: async (ctx) => {
    // 处理快捷键
    // ctx: 快捷键上下文
  },
});
```

**支持的快捷键：**
```typescript
// 修饰键 + 字母
"ctrl+a" to "ctrl+z"
"cmd+a" to "cmd+z"   // macOS
"alt+a" to "alt+z"
"shift+a" to "shift+z"

// 功能键
"f1" to "f12"

// 特殊键
"escape", "enter", "tab", "backspace", "delete"
"up", "down", "left", "right"
"home", "end", "pageup", "pagedown"
```

### 3.4 命令上下文（CommandContext）

```typescript
interface CommandContext {
  session: Session;              // 会话对象
  hasUI: boolean;                // 是否有 UI 可用
  ui: ExtensionUIContext;        // UI 上下文
  shutdown: () => void;          // 优雅关闭
}

// UI 上下文
interface ExtensionUIContext {
  select: (title: string, items: string[]) => Promise<string | undefined>;
  confirm: (title: string, message: string) => Promise<boolean>;
  input: (prompt: string, defaultValue?: string) => Promise<string | undefined>;
  notify: (message: string, level?: "info" | "success" | "warning" | "error") => void;
  clear?: () => void;            // 清空屏幕（可选）
}
```

---

## 4. 变体与扩展

### 4.1 多步骤命令

```typescript
pi.registerCommand("setup", {
  description: "Interactive project setup",
  handler: async (_args, ctx) => {
    // 步骤 1：选择项目类型
    const projectType = await ctx.ui.select(
      "Select project type",
      ["Web App", "CLI Tool", "Library"]
    );

    if (!projectType) return;

    // 步骤 2：输入项目名称
    const projectName = await ctx.ui.input(
      "Enter project name",
      "my-project"
    );

    if (!projectName) return;

    // 步骤 3：选择包管理器
    const packageManager = await ctx.ui.select(
      "Select package manager",
      ["npm", "yarn", "pnpm"]
    );

    if (!packageManager) return;

    // 步骤 4：确认
    const confirmed = await ctx.ui.confirm(
      "Confirm Setup",
      `Create ${projectType} project "${projectName}" with ${packageManager}?`
    );

    if (confirmed) {
      ctx.ui.notify("Setting up project...", "info");
      // 执行设置逻辑...
      ctx.ui.notify("Project setup complete!", "success");
    }
  },
});
```

### 4.2 条件快捷键

```typescript
pi.registerShortcut("ctrl+d", {
  description: "Context-aware action",
  handler: async (ctx) => {
    // 根据当前状态执行不同操作
    const currentFile = ctx.session.metadata?.currentFile;

    if (currentFile) {
      // 如果有当前文件，显示文件信息
      ctx.ui.notify(`Current file: ${currentFile}`, "info");
    } else {
      // 否则，显示会话信息
      ctx.ui.notify(`Session ID: ${ctx.session.id}`, "info");
    }
  },
});
```

### 4.3 命令别名

```typescript
export default function (pi: ExtensionAPI) {
  const quitHandler = async (_args: string, ctx: any) => {
    ctx.shutdown();
  };

  // 注册多个别名
  pi.registerCommand("quit", {
    description: "Exit pi",
    handler: quitHandler,
  });

  pi.registerCommand("exit", {
    description: "Exit pi (alias for /quit)",
    handler: quitHandler,
  });

  pi.registerCommand("q", {
    description: "Exit pi (short alias)",
    handler: quitHandler,
  });
}
```

### 4.4 快捷键链

```typescript
export default function (pi: ExtensionAPI) {
  let lastKey: string | null = null;
  let lastKeyTime = 0;

  // Ctrl+K 后跟 Ctrl+S: 保存快照
  pi.registerShortcut("ctrl+k", {
    description: "Shortcut chain prefix",
    handler: async (ctx) => {
      lastKey = "ctrl+k";
      lastKeyTime = Date.now();
      ctx.ui.notify("Press Ctrl+S to save snapshot", "info");
    },
  });

  pi.registerShortcut("ctrl+s", {
    description: "Save snapshot (or part of chain)",
    handler: async (ctx) => {
      const now = Date.now();

      // 如果在 2 秒内按下 Ctrl+K，则执行链式操作
      if (lastKey === "ctrl+k" && now - lastKeyTime < 2000) {
        ctx.ui.notify("Saving snapshot (chain)...", "info");
        // 保存快照逻辑...
        lastKey = null;
      } else {
        // 否则，执行普通保存
        ctx.ui.notify("Saving...", "info");
        // 普通保存逻辑...
      }
    },
  });
}
```

---

## 5. 错误处理

### 5.1 UI 交互失败

```typescript
pi.registerCommand("interactive", {
  description: "Interactive command with error handling",
  handler: async (_args, ctx) => {
    try {
      const choice = await ctx.ui.select("Choose option", ["A", "B", "C"]);

      if (!choice) {
        ctx.ui.notify("No option selected", "warning");
        return;
      }

      ctx.ui.notify(`Selected: ${choice}`, "success");
    } catch (error: any) {
      // UI 交互失败（如用户取消、超时）
      console.error("UI interaction failed:", error);
      ctx.ui.notify("Operation cancelled", "error");
    }
  },
});
```

### 5.2 参数验证

```typescript
pi.registerCommand("deploy", {
  description: "Deploy to environment",
  getArgumentCompletions: (prefix) => {
    const envs = ["production", "staging", "development"];
    return envs
      .filter((e) => e.startsWith(prefix))
      .map((e) => ({ value: e, label: e }));
  },
  handler: async (args, ctx) => {
    const env = args.trim();

    // 验证参数
    if (!env) {
      ctx.ui.notify("Error: Environment not specified", "error");
      ctx.ui.notify("Usage: /deploy <environment>", "info");
      return;
    }

    const validEnvs = ["production", "staging", "development"];
    if (!validEnvs.includes(env)) {
      ctx.ui.notify(`Error: Invalid environment "${env}"`, "error");
      ctx.ui.notify(`Valid environments: ${validEnvs.join(", ")}`, "info");
      return;
    }

    // 执行部署
    ctx.ui.notify(`Deploying to ${env}...`, "info");
    // ...
  },
});
```

### 5.3 异步操作错误

```typescript
pi.registerCommand("fetch-data", {
  description: "Fetch data from API",
  handler: async (_args, ctx) => {
    try {
      ctx.ui.notify("Fetching data...", "info");

      const response = await fetch("https://api.example.com/data");

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      ctx.ui.notify(`Fetched ${data.length} items`, "success");
    } catch (error: any) {
      console.error("Fetch failed:", error);

      if (error.name === "AbortError") {
        ctx.ui.notify("Request cancelled", "warning");
      } else if (error.message.includes("network")) {
        ctx.ui.notify("Network error: Check your connection", "error");
      } else {
        ctx.ui.notify(`Error: ${error.message}`, "error");
      }
    }
  },
});
```

---

## 6. 最佳实践

### 6.1 命令命名

```typescript
// ✓ 好：清晰、简短、描述性
pi.registerCommand("deploy", { ... });
pi.registerCommand("snapshot", { ... });
pi.registerCommand("list-sessions", { ... });

// ✗ 差：模糊、冗长
pi.registerCommand("do-deployment", { ... });
pi.registerCommand("s", { ... });  // 太短
pi.registerCommand("list_all_available_sessions", { ... });  // 太长
```

### 6.2 描述清晰

```typescript
// ✓ 好：清晰的描述
pi.registerCommand("deploy", {
  description: "Deploy application to specified environment (production, staging, development)",
  // ...
});

// ✗ 差：模糊的描述
pi.registerCommand("deploy", {
  description: "Deploy",
  // ...
});
```

### 6.3 参数补全

```typescript
// ✓ 好：提供有用的补全
getArgumentCompletions: (prefix) => {
  const options = ["production", "staging", "development"];
  const filtered = options.filter((opt) => opt.startsWith(prefix));
  return filtered.length > 0
    ? filtered.map((opt) => ({ value: opt, label: `${opt} environment` }))
    : null;
}

// ✗ 差：无补全或无用的补全
getArgumentCompletions: (prefix) => null;
```

### 6.4 用户反馈

```typescript
// ✓ 好：提供清晰的反馈
handler: async (args, ctx) => {
  ctx.ui.notify("Starting deployment...", "info");
  await deploy(args);
  ctx.ui.notify("Deployment complete!", "success");
}

// ✗ 差：无反馈
handler: async (args, ctx) => {
  await deploy(args);
  // 用户不知道是否成功
}
```

### 6.5 快捷键冲突

```typescript
// ✓ 好：使用不常用的快捷键
pi.registerShortcut("ctrl+shift+s", { ... });  // 不太可能冲突

// ✗ 差：使用常用快捷键
pi.registerShortcut("ctrl+c", { ... });  // 冲突！（复制/中断）
pi.registerShortcut("ctrl+v", { ... });  // 冲突！（粘贴）
```

---

## 7. 总结

### 7.1 核心要点

1. **registerCommand**：注册自定义命令，支持参数补全
2. **registerShortcut**：注册快捷键，快速执行操作
3. **getArgumentCompletions**：提供参数自动补全
4. **CommandContext**：访问会话、UI、关闭等功能
5. **UI 交互**：select、confirm、input、notify

### 7.2 扩展方向

- **多步骤命令**：交互式工作流
- **条件快捷键**：根据上下文执行不同操作
- **命令别名**：多个名称指向同一命令
- **快捷键链**：组合快捷键实现复杂操作
- **命令组合**：命令调用其他命令

### 7.3 实际应用

命令与快捷键扩展适用于：
- **快速访问**：常用功能一键触达
- **工作流自动化**：多步骤操作自动化
- **会话管理**：保存、恢复、列出会话
- **开发工具**：部署、测试、构建
- **调试辅助**：日志查看、状态检查

---

**下一步：** 学习 [07_实战代码_04_UI定制扩展.md](./07_实战代码_04_UI定制扩展.md)，了解如何定制 UI 组件和交互。
