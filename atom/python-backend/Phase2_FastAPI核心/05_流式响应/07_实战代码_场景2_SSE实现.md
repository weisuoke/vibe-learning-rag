# 实战代码 - 场景2：Server-Sent Events (SSE) 实现

> 完整可运行的 SSE 协议实现示例

---

## 场景描述

实现完整的 Server-Sent Events (SSE) 协议，包括基础 SSE、自定义事件、消息 ID、断线重连等功能。

---

## 完整代码

```python
"""
场景2：Server-Sent Events (SSE) 实现
演示：SSE 协议的完整实现
"""

from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
import asyncio
import json
from typing import AsyncGenerator, Optional
from datetime import datetime

app = FastAPI(title="SSE 实现示例")

# 添加 CORS 支持（前端需要）
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ===== 1. 基础 SSE 实现 =====
print("=== 场景1：基础 SSE 实现 ===")

async def basic_sse() -> AsyncGenerator[str, None]:
    """基础 SSE 格式"""
    for i in range(10):
        # SSE 格式：data: 内容\n\n
        yield f"data: 消息 {i}\n\n"
        await asyncio.sleep(0.5)

@app.get("/sse/basic")
async def basic_sse_endpoint():
    """基础 SSE 端点"""
    return StreamingResponse(
        basic_sse(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no"  # 禁用 Nginx 缓冲
        }
    )

# ===== 2. JSON 格式的 SSE =====
print("=== 场景2：JSON 格式的 SSE ===")

async def json_sse() -> AsyncGenerator[str, None]:
    """JSON 格式的 SSE"""
    for i in range(5):
        data = {
            "id": i,
            "message": f"数据项 {i}",
            "timestamp": datetime.now().isoformat()
        }
        # SSE 格式：data: JSON字符串\n\n
        yield f"data: {json.dumps(data)}\n\n"
        await asyncio.sleep(0.5)

@app.get("/sse/json")
async def json_sse_endpoint():
    """JSON 格式的 SSE 端点"""
    return StreamingResponse(
        json_sse(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive"
        }
    )

# ===== 3. 自定义事件类型 =====
print("=== 场景3：自定义事件类型 ===")

async def custom_events_sse() -> AsyncGenerator[str, None]:
    """带自定义事件类型的 SSE"""
    # 发送 "start" 事件
    yield "event: start\n"
    yield "data: 开始处理\n\n"

    # 发送 "progress" 事件
    for i in range(5):
        yield "event: progress\n"
        yield f"data: {json.dumps({'progress': (i + 1) * 20, 'step': i + 1})}\n\n"
        await asyncio.sleep(0.5)

    # 发送 "complete" 事件
    yield "event: complete\n"
    yield "data: 处理完成\n\n"

@app.get("/sse/events")
async def custom_events_endpoint():
    """自定义事件类型的 SSE 端点"""
    return StreamingResponse(
        custom_events_sse(),
        media_type="text/event-stream"
    )

# ===== 4. 带消息 ID 的 SSE（支持断线重连） =====
print("=== 场景4：带消息 ID 的 SSE ===")

async def sse_with_id(start_id: int = 0) -> AsyncGenerator[str, None]:
    """带消息 ID 的 SSE（支持断线重连）"""
    # 设置重连时间（3秒）
    yield "retry: 3000\n\n"

    for i in range(start_id, 100):
        # 发送消息 ID
        yield f"id: {i}\n"
        yield f"data: 消息 {i}\n\n"
        await asyncio.sleep(0.1)

@app.get("/sse/reconnect")
async def sse_reconnect_endpoint(request: Request):
    """支持断线重连的 SSE 端点"""
    # 获取客户端提供的 Last-Event-ID
    last_event_id = request.headers.get("Last-Event-ID", "0")
    start_id = int(last_event_id) + 1 if last_event_id.isdigit() else 0

    print(f"客户端重连，从消息 {start_id} 开始")

    return StreamingResponse(
        sse_with_id(start_id),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive"
        }
    )

# ===== 5. 多字段 SSE 消息 =====
print("=== 场景5：多字段 SSE 消息 ===")

async def multifield_sse() -> AsyncGenerator[str, None]:
    """多字段 SSE 消息"""
    for i in range(5):
        # 多字段消息
        yield f"id: {i}\n"
        yield f"event: update\n"
        yield f"data: 第一行数据\n"
        yield f"data: 第二行数据\n"
        yield f"data: 第三行数据\n"
        yield "\n"  # 消息结束标记
        await asyncio.sleep(0.5)

@app.get("/sse/multifield")
async def multifield_sse_endpoint():
    """多字段 SSE 消息端点"""
    return StreamingResponse(
        multifield_sse(),
        media_type="text/event-stream"
    )

# ===== 6. 实时时钟（持续推送） =====
print("=== 场景6：实时时钟 ===")

async def clock_sse() -> AsyncGenerator[str, None]:
    """实时时钟 SSE"""
    try:
        while True:
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            yield f"data: {current_time}\n\n"
            await asyncio.sleep(1)
    except GeneratorExit:
        print("客户端断开连接，停止时钟")

@app.get("/sse/clock")
async def clock_sse_endpoint():
    """实时时钟 SSE 端点"""
    return StreamingResponse(
        clock_sse(),
        media_type="text/event-stream"
    )

# ===== 7. 心跳保活 =====
print("=== 场景7：心跳保活 ===")

async def heartbeat_sse() -> AsyncGenerator[str, None]:
    """带心跳的 SSE"""
    message_count = 0

    try:
        while True:
            # 每5秒发送一条消息
            if message_count < 10:
                yield f"data: 消息 {message_count}\n\n"
                message_count += 1
                await asyncio.sleep(5)
            else:
                # 消息发送完毕，只发送心跳
                yield ": heartbeat\n\n"  # 注释行（心跳）
                await asyncio.sleep(15)  # 每15秒发送一次心跳
    except GeneratorExit:
        print("客户端断开连接")

@app.get("/sse/heartbeat")
async def heartbeat_sse_endpoint():
    """带心跳的 SSE 端点"""
    return StreamingResponse(
        heartbeat_sse(),
        media_type="text/event-stream"
    )

# ===== 运行服务器 =====
if __name__ == "__main__":
    import uvicorn

    print("\n" + "="*50)
    print("启动 FastAPI 服务器")
    print("="*50)
    print("\n可用端点：")
    print("  GET  http://localhost:8000/sse/basic")
    print("  GET  http://localhost:8000/sse/json")
    print("  GET  http://localhost:8000/sse/events")
    print("  GET  http://localhost:8000/sse/reconnect")
    print("  GET  http://localhost:8000/sse/multifield")
    print("  GET  http://localhost:8000/sse/clock")
    print("  GET  http://localhost:8000/sse/heartbeat")
    print("\n使用 curl 测试：")
    print("  curl http://localhost:8000/sse/basic")
    print("  curl http://localhost:8000/sse/json")
    print("\n按 Ctrl+C 停止服务器")
    print("="*50 + "\n")

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 前端接收示例

### HTML + JavaScript 完整示例

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>SSE 示例</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .section { margin-bottom: 30px; border: 1px solid #ccc; padding: 15px; }
        .output { background: #f5f5f5; padding: 10px; min-height: 100px; max-height: 300px; overflow-y: auto; }
        button { margin: 5px; padding: 5px 15px; }
    </style>
</head>
<body>
    <h1>Server-Sent Events 示例</h1>

    <!-- 基础 SSE -->
    <div class="section">
        <h2>1. 基础 SSE</h2>
        <button onclick="startBasicSSE()">开始</button>
        <button onclick="stopBasicSSE()">停止</button>
        <div id="basic-output" class="output"></div>
    </div>

    <!-- JSON SSE -->
    <div class="section">
        <h2>2. JSON 格式 SSE</h2>
        <button onclick="startJSONSSE()">开始</button>
        <button onclick="stopJSONSSE()">停止</button>
        <div id="json-output" class="output"></div>
    </div>

    <!-- 自定义事件 -->
    <div class="section">
        <h2>3. 自定义事件类型</h2>
        <button onclick="startEventsSSE()">开始</button>
        <button onclick="stopEventsSSE()">停止</button>
        <div id="events-output" class="output"></div>
    </div>

    <!-- 断线重连 -->
    <div class="section">
        <h2>4. 断线重连（刷新页面测试）</h2>
        <button onclick="startReconnectSSE()">开始</button>
        <button onclick="stopReconnectSSE()">停止</button>
        <div id="reconnect-output" class="output"></div>
    </div>

    <!-- 实时时钟 -->
    <div class="section">
        <h2>5. 实时时钟</h2>
        <button onclick="startClockSSE()">开始</button>
        <button onclick="stopClockSSE()">停止</button>
        <div id="clock-output" class="output"></div>
    </div>

    <script>
        let basicEventSource = null;
        let jsonEventSource = null;
        let eventsEventSource = null;
        let reconnectEventSource = null;
        let clockEventSource = null;

        // 1. 基础 SSE
        function startBasicSSE() {
            if (basicEventSource) return;

            basicEventSource = new EventSource('http://localhost:8000/sse/basic');

            basicEventSource.onmessage = (event) => {
                appendOutput('basic-output', event.data);
            };

            basicEventSource.onerror = (error) => {
                console.error('基础 SSE 错误:', error);
                appendOutput('basic-output', '[错误: 连接失败]');
            };
        }

        function stopBasicSSE() {
            if (basicEventSource) {
                basicEventSource.close();
                basicEventSource = null;
                appendOutput('basic-output', '[已停止]');
            }
        }

        // 2. JSON SSE
        function startJSONSSE() {
            if (jsonEventSource) return;

            jsonEventSource = new EventSource('http://localhost:8000/sse/json');

            jsonEventSource.onmessage = (event) => {
                const data = JSON.parse(event.data);
                appendOutput('json-output', `ID: ${data.id}, 消息: ${data.message}, 时间: ${data.timestamp}`);
            };

            jsonEventSource.onerror = (error) => {
                console.error('JSON SSE 错误:', error);
            };
        }

        function stopJSONSSE() {
            if (jsonEventSource) {
                jsonEventSource.close();
                jsonEventSource = null;
                appendOutput('json-output', '[已停止]');
            }
        }

        // 3. 自定义事件
        function startEventsSSE() {
            if (eventsEventSource) return;

            eventsEventSource = new EventSource('http://localhost:8000/sse/events');

            eventsEventSource.addEventListener('start', (event) => {
                appendOutput('events-output', `[开始] ${event.data}`);
            });

            eventsEventSource.addEventListener('progress', (event) => {
                const data = JSON.parse(event.data);
                appendOutput('events-output', `[进度] ${data.progress}% (步骤 ${data.step})`);
            });

            eventsEventSource.addEventListener('complete', (event) => {
                appendOutput('events-output', `[完成] ${event.data}`);
                stopEventsSSE();
            });

            eventsEventSource.onerror = (error) => {
                console.error('事件 SSE 错误:', error);
            };
        }

        function stopEventsSSE() {
            if (eventsEventSource) {
                eventsEventSource.close();
                eventsEventSource = null;
            }
        }

        // 4. 断线重连
        function startReconnectSSE() {
            if (reconnectEventSource) return;

            reconnectEventSource = new EventSource('http://localhost:8000/sse/reconnect');

            reconnectEventSource.onmessage = (event) => {
                appendOutput('reconnect-output', `消息 ID: ${event.lastEventId}, 内容: ${event.data}`);
            };

            reconnectEventSource.onerror = (error) => {
                console.error('重连 SSE 错误:', error);
                appendOutput('reconnect-output', '[连接断开，3秒后自动重连...]');
            };
        }

        function stopReconnectSSE() {
            if (reconnectEventSource) {
                reconnectEventSource.close();
                reconnectEventSource = null;
                appendOutput('reconnect-output', '[已停止]');
            }
        }

        // 5. 实时时钟
        function startClockSSE() {
            if (clockEventSource) return;

            clockEventSource = new EventSource('http://localhost:8000/sse/clock');

            clockEventSource.onmessage = (event) => {
                document.getElementById('clock-output').innerHTML = `<strong>${event.data}</strong>`;
            };

            clockEventSource.onerror = (error) => {
                console.error('时钟 SSE 错误:', error);
            };
        }

        function stopClockSSE() {
            if (clockEventSource) {
                clockEventSource.close();
                clockEventSource = null;
                document.getElementById('clock-output').innerHTML = '[已停止]';
            }
        }

        // 辅助函数：追加输出
        function appendOutput(elementId, text) {
            const output = document.getElementById(elementId);
            output.innerHTML += text + '<br>';
            output.scrollTop = output.scrollHeight;
        }
    </script>
</body>
</html>
```

---

## 运行输出示例

### 测试1：基础 SSE

```bash
$ curl http://localhost:8000/sse/basic
data: 消息 0

data: 消息 1

data: 消息 2

data: 消息 3

...
```

### 测试2：JSON SSE

```bash
$ curl http://localhost:8000/sse/json
data: {"id": 0, "message": "数据项 0", "timestamp": "2026-02-11T10:30:00.123456"}

data: {"id": 1, "message": "数据项 1", "timestamp": "2026-02-11T10:30:00.623456"}

...
```

### 测试3：自定义事件

```bash
$ curl http://localhost:8000/sse/events
event: start
data: 开始处理

event: progress
data: {"progress": 20, "step": 1}

event: progress
data: {"progress": 40, "step": 2}

...

event: complete
data: 处理完成
```

### 测试4：断线重连

```bash
# 第一次连接
$ curl http://localhost:8000/sse/reconnect
retry: 3000

id: 0
data: 消息 0

id: 1
data: 消息 1

^C  # 断开连接

# 第二次连接（自动从上次断开处继续）
$ curl -H "Last-Event-ID: 1" http://localhost:8000/sse/reconnect
retry: 3000

id: 2
data: 消息 2

id: 3
data: 消息 3

...
```

---

## 关键知识点

### 1. SSE 消息格式

```
field: value\n
field: value\n
\n
```

**可用字段：**
- `data:` - 消息内容（必需）
- `event:` - 事件类型（可选，默认 "message"）
- `id:` - 消息 ID（可选，用于断线重连）
- `retry:` - 重连时间（毫秒，可选）
- `:` - 注释行（心跳，可选）

### 2. 多行数据

```
data: 第一行\n
data: 第二行\n
data: 第三行\n
\n
```

前端接收到的 `event.data` 为：
```
第一行
第二行
第三行
```

### 3. 自定义事件类型

```python
# 后端
yield "event: custom\n"
yield "data: 内容\n\n"
```

```javascript
// 前端
eventSource.addEventListener('custom', (event) => {
    console.log(event.data);
});
```

### 4. 断线重连机制

```python
# 后端设置重连时间
yield "retry: 3000\n\n"  # 3秒后重连

# 后端接收 Last-Event-ID
last_id = request.headers.get("Last-Event-ID")
```

```javascript
// 前端自动重连
const eventSource = new EventSource('/sse');
// 断开后自动重连，并发送 Last-Event-ID 头
```

### 5. 心跳保活

```python
# 发送注释行（心跳）
yield ": heartbeat\n\n"
```

**作用：**
- 保持连接活跃
- 防止代理服务器超时
- 客户端不会收到这条消息

---

## 常见问题

### Q1: SSE 和 WebSocket 的区别？

**A:**
| 特性 | SSE | WebSocket |
|------|-----|-----------|
| 通信方向 | 单向（服务器 → 客户端） | 双向 |
| 协议 | HTTP | WebSocket 协议 |
| 浏览器支持 | 原生支持（EventSource） | 原生支持（WebSocket） |
| 断线重连 | 自动重连 | 需要手动实现 |
| 适用场景 | 服务器推送、实时通知 | 实时聊天、游戏 |

### Q2: 如何处理 SSE 的跨域问题？

**A:** 添加 CORS 中间件：
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

### Q3: SSE 连接会超时吗？

**A:** 会！解决方案：
1. 定期发送心跳（注释行）
2. 设置合理的重连时间
3. 配置代理服务器（Nginx）的超时时间

### Q4: 如何在 SSE 中发送二进制数据？

**A:** SSE 只支持文本数据，二进制数据需要：
1. Base64 编码
2. 或使用 WebSocket

---

## 下一步

完成本场景后，继续学习：
- **场景3**：AI 流式输出集成
- **场景4**：大文件流式传输
- **场景5**：生产级流式响应系统
