# 实战代码 - 场景1：一致性级别选择与性能对比

## 场景描述

在 RAG 系统中，不同的业务场景对数据一致性的要求不同。本示例演示如何根据业务需求选择合适的一致性级别，并对比不同一致性级别的性能差异。

---

## 完整代码示例

```python
"""
场景1：一致性级别选择与性能对比
演示：
1. 不同一致性级别的使用场景
2. 性能对比测试
3. 在 RAG 系统中的实际应用
"""

import time
import numpy as np
from pymilvus import (
    connections,
    Collection,
    FieldSchema,
    CollectionSchema,
    DataType,
    utility
)

# ===== 1. 连接 Milvus =====
print("=== 连接 Milvus ===")
connections.connect(
    alias="default",
    host="localhost",
    port="19530"
)
print("连接成功！\n")

# ===== 2. 创建测试 Collection =====
print("=== 创建测试 Collection ===")

# 定义 Schema
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=False),
    FieldSchema(name="vector", dtype=DataType.FLOAT_VECTOR, dim=128),
    FieldSchema(name="text", dtype=DataType.VARCHAR, max_length=500),
    FieldSchema(name="timestamp", dtype=DataType.INT64),
]
schema = CollectionSchema(fields=fields, description="一致性级别测试")

# 创建 Collection
collection_name = "consistency_test"
if utility.has_collection(collection_name):
    utility.drop_collection(collection_name)

collection = Collection(name=collection_name, schema=schema)
print(f"Collection '{collection_name}' 创建成功！\n")

# ===== 3. 插入测试数据 =====
print("=== 插入测试数据 ===")

# 生成 10 万条测试数据
num_entities = 100000
entities = [
    list(range(num_entities)),  # id
    np.random.rand(num_entities, 128).tolist(),  # vector
    [f"文档 {i}" for i in range(num_entities)],  # text
    [int(time.time()) for _ in range(num_entities)],  # timestamp
]

# 批量插入
batch_size = 10000
for i in range(0, num_entities, batch_size):
    batch = [
        entities[0][i:i+batch_size],
        entities[1][i:i+batch_size],
        entities[2][i:i+batch_size],
        entities[3][i:i+batch_size],
    ]
    collection.insert(batch)
    print(f"已插入 {i+batch_size}/{num_entities} 条数据")

print("数据插入完成！\n")

# ===== 4. 创建索引 =====
print("=== 创建索引 ===")

index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "L2",
    "params": {"nlist": 128}
}

collection.create_index(field_name="vector", index_params=index_params)
print("索引创建完成！\n")

# ===== 5. 加载 Collection =====
print("=== 加载 Collection ===")
collection.load()
print("Collection 加载完成！\n")

# ===== 6. 性能对比测试 =====
print("=== 性能对比测试 ===\n")

# 准备查询向量
query_vector = np.random.rand(128).tolist()
search_params = {"metric_type": "L2", "params": {"nprobe": 10}}

# 测试函数
def benchmark_consistency_level(consistency_level, num_queries=100):
    """测试指定一致性级别的性能"""
    start_time = time.time()

    for _ in range(num_queries):
        results = collection.search(
            data=[query_vector],
            anns_field="vector",
            param=search_params,
            limit=10,
            consistency_level=consistency_level
        )

    end_time = time.time()
    total_time = end_time - start_time
    avg_time = total_time / num_queries

    return total_time, avg_time

# 测试各种一致性级别
consistency_levels = ["Strong", "Bounded", "Session", "Eventually"]
results = {}

for level in consistency_levels:
    print(f"测试 {level} 一致性...")
    total_time, avg_time = benchmark_consistency_level(level, num_queries=100)
    results[level] = {
        "total_time": total_time,
        "avg_time": avg_time
    }
    print(f"  总耗时: {total_time:.3f}s")
    print(f"  平均耗时: {avg_time:.4f}s")
    print()

# ===== 7. 性能对比分析 =====
print("=== 性能对比分析 ===\n")

# 以 Eventually 为基准
baseline = results["Eventually"]["avg_time"]

print("性能对比（以 Eventually 为基准）：")
for level in consistency_levels:
    avg_time = results[level]["avg_time"]
    ratio = avg_time / baseline
    print(f"  {level:12s}: {avg_time:.4f}s  ({ratio:.2f}x)")

print()

# ===== 8. RAG 应用场景示例 =====
print("=== RAG 应用场景示例 ===\n")

# 场景1：实时客服知识库（Strong 一致性）
def realtime_customer_service_search(query_text):
    """
    实时客服知识库查询
    要求：必须看到最新的知识库更新
    """
    print("场景1：实时客服知识库")
    print(f"  查询: {query_text}")

    # 使用 Strong 一致性
    start_time = time.time()
    results = collection.search(
        data=[query_vector],
        anns_field="vector",
        param=search_params,
        limit=5,
        consistency_level="Strong"  # 强一致性
    )
    end_time = time.time()

    print(f"  一致性级别: Strong")
    print(f"  查询耗时: {(end_time - start_time)*1000:.2f}ms")
    print(f"  返回结果: {len(results[0])} 条")
    print()

    return results

# 场景2：历史文档检索（Eventually 一致性）
def historical_document_search(query_text):
    """
    历史文档检索
    要求：性能优先，可以接受稍旧的数据
    """
    print("场景2：历史文档检索")
    print(f"  查询: {query_text}")

    # 使用 Eventually 一致性
    start_time = time.time()
    results = collection.search(
        data=[query_vector],
        anns_field="vector",
        param=search_params,
        limit=10,
        consistency_level="Eventually"  # 最终一致性
    )
    end_time = time.time()

    print(f"  一致性级别: Eventually")
    print(f"  查询耗时: {(end_time - start_time)*1000:.2f}ms")
    print(f"  返回结果: {len(results[0])} 条")
    print()

    return results

# 场景3：通用知识库（Bounded 一致性，推荐）
def general_knowledge_base_search(query_text):
    """
    通用知识库查询
    要求：平衡性能和一致性
    """
    print("场景3：通用知识库")
    print(f"  查询: {query_text}")

    # 使用 Bounded 一致性
    start_time = time.time()
    results = collection.search(
        data=[query_vector],
        anns_field="vector",
        param=search_params,
        limit=10,
        consistency_level="Bounded"  # 有界一致性
    )
    end_time = time.time()

    print(f"  一致性级别: Bounded")
    print(f"  查询耗时: {(end_time - start_time)*1000:.2f}ms")
    print(f"  返回结果: {len(results[0])} 条")
    print()

    return results

# 场景4：用户个人知识库（Session 一致性）
def personal_knowledge_base_search(query_text, user_id):
    """
    用户个人知识库查询
    要求：保证同一会话内的一致性
    """
    print("场景4：用户个人知识库")
    print(f"  用户ID: {user_id}")
    print(f"  查询: {query_text}")

    # 使用 Session 一致性
    start_time = time.time()
    results = collection.search(
        data=[query_vector],
        anns_field="vector",
        param=search_params,
        limit=5,
        consistency_level="Session"  # 会话一致性
    )
    end_time = time.time()

    print(f"  一致性级别: Session")
    print(f"  查询耗时: {(end_time - start_time)*1000:.2f}ms")
    print(f"  返回结果: {len(results[0])} 条")
    print()

    return results

# 执行各种场景
realtime_customer_service_search("如何重置密码？")
historical_document_search("2023年度报告")
general_knowledge_base_search("Python 教程")
personal_knowledge_base_search("我的笔记", user_id="user_123")

# ===== 9. 动态一致性级别选择 =====
print("=== 动态一致性级别选择 ===\n")

def smart_search(query_text, scenario_type):
    """
    根据场景类型自动选择一致性级别
    """
    # 一致性级别映射
    consistency_map = {
        "realtime": "Strong",      # 实时场景
        "general": "Bounded",      # 通用场景
        "historical": "Eventually", # 历史场景
        "personal": "Session"      # 个人场景
    }

    consistency_level = consistency_map.get(scenario_type, "Bounded")

    print(f"智能查询:")
    print(f"  场景类型: {scenario_type}")
    print(f"  自动选择一致性级别: {consistency_level}")

    start_time = time.time()
    results = collection.search(
        data=[query_vector],
        anns_field="vector",
        param=search_params,
        limit=10,
        consistency_level=consistency_level
    )
    end_time = time.time()

    print(f"  查询耗时: {(end_time - start_time)*1000:.2f}ms")
    print(f"  返回结果: {len(results[0])} 条")
    print()

    return results

# 测试智能查询
smart_search("紧急通知", scenario_type="realtime")
smart_search("技术文档", scenario_type="general")
smart_search("历史记录", scenario_type="historical")

# ===== 10. 清理资源 =====
print("=== 清理资源 ===")
collection.release()
utility.drop_collection(collection_name)
connections.disconnect("default")
print("清理完成！")
```

---

## 运行输出示例

```
=== 连接 Milvus ===
连接成功！

=== 创建测试 Collection ===
Collection 'consistency_test' 创建成功！

=== 插入测试数据 ===
已插入 10000/100000 条数据
已插入 20000/100000 条数据
...
已插入 100000/100000 条数据
数据插入完成！

=== 创建索引 ===
索引创建完成！

=== 加载 Collection ===
Collection 加载完成！

=== 性能对比测试 ===

测试 Strong 一致性...
  总耗时: 15.234s
  平均耗时: 0.1523s

测试 Bounded 一致性...
  总耗时: 8.567s
  平均耗时: 0.0857s

测试 Session 一致性...
  总耗时: 7.123s
  平均耗时: 0.0712s

测试 Eventually 一致性...
  总耗时: 3.456s
  平均耗时: 0.0346s

=== 性能对比分析 ===

性能对比（以 Eventually 为基准）：
  Strong      : 0.1523s  (4.40x)
  Bounded     : 0.0857s  (2.48x)
  Session     : 0.0712s  (2.06x)
  Eventually  : 0.0346s  (1.00x)

=== RAG 应用场景示例 ===

场景1：实时客服知识库
  查询: 如何重置密码？
  一致性级别: Strong
  查询耗时: 152.34ms
  返回结果: 5 条

场景2：历史文档检索
  查询: 2023年度报告
  一致性级别: Eventually
  查询耗时: 34.56ms
  返回结果: 10 条

场景3：通用知识库
  查询: Python 教程
  一致性级别: Bounded
  查询耗时: 85.67ms
  返回结果: 10 条

场景4：用户个人知识库
  用户ID: user_123
  查询: 我的笔记
  一致性级别: Session
  查询耗时: 71.23ms
  返回结果: 5 条

=== 动态一致性级别选择 ===

智能查询:
  场景类型: realtime
  自动选择一致性级别: Strong
  查询耗时: 152.34ms
  返回结果: 10 条

智能查询:
  场景类型: general
  自动选择一致性级别: Bounded
  查询耗时: 85.67ms
  返回结果: 10 条

智能查询:
  场景类型: historical
  自动选择一致性级别: Eventually
  查询耗时: 34.56ms
  返回结果: 10 条

=== 清理资源 ===
清理完成！
```

---

## 核心要点

1. **性能差异显著**：Strong 一致性比 Eventually 一致性慢 4-5 倍
2. **场景驱动选择**：根据业务需求选择合适的一致性级别
3. **Bounded 是最佳平衡**：大多数场景使用 Bounded 即可
4. **动态选择策略**：可以根据场景类型自动选择一致性级别
5. **实时场景用 Strong**：对实时性要求高的场景使用 Strong
6. **历史场景用 Eventually**：对实时性要求低的场景使用 Eventually

---

## 扩展练习

1. **测试不同数据量**：测试 10 万、100 万、1000 万条数据的性能差异
2. **测试不同索引类型**：测试 IVF_FLAT、IVF_SQ8、HNSW 的性能差异
3. **测试并发查询**：测试多线程并发查询的性能
4. **实现自适应策略**：根据查询延迟自动调整一致性级别
5. **监控一致性延迟**：监控不同一致性级别的实际延迟
