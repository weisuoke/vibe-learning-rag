# 最小可用

掌握以下内容，就能开始进行索引参数调优：

## 4.1 理解速度-召回率权衡

**核心概念：** 索引参数调优的本质是在检索速度和召回率之间找平衡点。

```python
from pymilvus import Collection, connections

# 连接到 Milvus
connections.connect("default", host="localhost", port="19530")

# 获取 collection
collection = Collection("my_collection")

# 快速但召回率低的配置
search_params_fast = {
    "metric_type": "L2",
    "params": {"nprobe": 10}  # 只搜索10个聚类
}

# 慢速但召回率高的配置
search_params_accurate = {
    "metric_type": "L2",
    "params": {"nprobe": 128}  # 搜索128个聚类
}

# 根据场景选择
results = collection.search(
    data=[[0.1, 0.2, ...]],
    anns_field="embedding",
    param=search_params_fast,  # 或 search_params_accurate
    limit=10
)
```

**在 RAG 中的应用：**
- 实时对话场景：优先速度，nprobe=10-20
- 离线分析场景：优先召回率，nprobe=64-128
- 混合场景：平衡配置，nprobe=32-64

---

## 4.2 掌握核心参数对照表

**必须记住的参数：**

| 索引类型 | 构建参数 | 搜索参数 | 影响 |
|---------|---------|---------|------|
| **IVF_FLAT** | nlist (聚类数) | nprobe (搜索聚类数) | nlist↑构建慢，nprobe↑搜索慢但准 |
| **IVF_SQ8** | nlist | nprobe | 同上 + 内存减少75% |
| **IVF_PQ** | nlist, m (子向量数) | nprobe | 同上 + 内存大幅减少 |
| **HNSW** | M (连接数), efConstruction | ef (搜索范围) | M↑内存↑质量↑，ef↑搜索慢但准 |

```python
# IVF 系列索引创建示例
index_params_ivf = {
    "index_type": "IVF_FLAT",
    "metric_type": "L2",
    "params": {
        "nlist": 1024  # 构建参数：聚类数
    }
}

# HNSW 索引创建示例
index_params_hnsw = {
    "index_type": "HNSW",
    "metric_type": "L2",
    "params": {
        "M": 16,              # 构建参数：每个节点的连接数
        "efConstruction": 200  # 构建参数：构建时的搜索范围
    }
}
```

---

## 4.3 使用经验公式快速配置

**IVF 系列经验公式：**

```python
import math

def calculate_ivf_params(num_vectors, target_speed="balanced"):
    """
    根据数据量计算 IVF 参数

    Args:
        num_vectors: 向量总数
        target_speed: "fast" | "balanced" | "accurate"
    """
    # nlist 经验公式：sqrt(N) 到 4*sqrt(N)
    nlist_min = int(math.sqrt(num_vectors))
    nlist_max = int(4 * math.sqrt(num_vectors))

    if target_speed == "fast":
        nlist = nlist_min
        nprobe = max(1, nlist // 100)  # 1% 的聚类
    elif target_speed == "balanced":
        nlist = int(2 * math.sqrt(num_vectors))
        nprobe = max(8, nlist // 20)   # 5% 的聚类
    else:  # accurate
        nlist = nlist_max
        nprobe = max(16, nlist // 10)  # 10% 的聚类

    return {
        "nlist": nlist,
        "nprobe": nprobe
    }

# 示例：100万向量的配置
params_1m = calculate_ivf_params(1_000_000, "balanced")
print(f"推荐配置: nlist={params_1m['nlist']}, nprobe={params_1m['nprobe']}")
# 输出: 推荐配置: nlist=2000, nprobe=100
```

**HNSW 经验公式：**

```python
def calculate_hnsw_params(target_speed="balanced"):
    """
    根据目标速度计算 HNSW 参数

    Args:
        target_speed: "fast" | "balanced" | "accurate"
    """
    if target_speed == "fast":
        return {
            "M": 8,
            "efConstruction": 100,
            "ef": 64  # 搜索参数
        }
    elif target_speed == "balanced":
        return {
            "M": 16,
            "efConstruction": 200,
            "ef": 128
        }
    else:  # accurate
        return {
            "M": 32,
            "efConstruction": 400,
            "ef": 256
        }

# 示例：平衡配置
params_hnsw = calculate_hnsw_params("balanced")
print(f"推荐配置: M={params_hnsw['M']}, efConstruction={params_hnsw['efConstruction']}")
# 输出: 推荐配置: M=16, efConstruction=200
```

---

## 4.4 实施基本调优流程

**三步调优法：**

```python
from pymilvus import Collection, utility
import time

def benchmark_search(collection, search_params, query_vectors, iterations=10):
    """
    基准测试搜索性能

    Returns:
        (avg_latency_ms, recall_rate)
    """
    latencies = []

    for _ in range(iterations):
        start = time.time()
        results = collection.search(
            data=query_vectors,
            anns_field="embedding",
            param=search_params,
            limit=10
        )
        latencies.append((time.time() - start) * 1000)

    avg_latency = sum(latencies) / len(latencies)
    return avg_latency

# 步骤1：建立基线
baseline_params = {
    "metric_type": "L2",
    "params": {"nprobe": 16}
}
baseline_latency = benchmark_search(collection, baseline_params, test_queries)
print(f"基线延迟: {baseline_latency:.2f}ms")

# 步骤2：测试不同配置
test_configs = [
    {"nprobe": 8},
    {"nprobe": 16},
    {"nprobe": 32},
    {"nprobe": 64}
]

for config in test_configs:
    params = {"metric_type": "L2", "params": config}
    latency = benchmark_search(collection, params, test_queries)
    print(f"nprobe={config['nprobe']}: {latency:.2f}ms")

# 步骤3：选择最佳配置
# 根据延迟要求和召回率要求选择
```

---

## 4.5 监控关键指标

**必须监控的指标：**

```python
def monitor_search_performance(collection, search_params, query_vectors):
    """
    监控搜索性能的关键指标
    """
    import time

    # 1. 延迟 (Latency)
    start = time.time()
    results = collection.search(
        data=query_vectors,
        anns_field="embedding",
        param=search_params,
        limit=10
    )
    latency_ms = (time.time() - start) * 1000

    # 2. QPS (Queries Per Second)
    num_queries = 100
    start = time.time()
    for _ in range(num_queries):
        collection.search(
            data=query_vectors[:1],
            anns_field="embedding",
            param=search_params,
            limit=10
        )
    duration = time.time() - start
    qps = num_queries / duration

    # 3. 内存使用
    stats = utility.get_query_segment_info(collection.name)
    memory_mb = sum(seg.mem_size for seg in stats) / 1024 / 1024

    print(f"""
性能指标:
- 延迟: {latency_ms:.2f}ms
- QPS: {qps:.2f}
- 内存: {memory_mb:.2f}MB
    """)

    return {
        "latency_ms": latency_ms,
        "qps": qps,
        "memory_mb": memory_mb
    }
```

---

## 这些知识足以：

- ✅ **理解参数调优的核心逻辑**：速度与召回率的权衡
- ✅ **快速配置常见索引**：使用经验公式计算参数
- ✅ **进行基础性能测试**：测量延迟和 QPS
- ✅ **在 RAG 系统中应用**：根据场景选择合适配置
- ✅ **为深入优化打基础**：建立性能基线和监控体系

---

## 快速参考卡

```
┌─────────────────────────────────────────────────────────┐
│ 索引参数调优速查表                                        │
├─────────────────────────────────────────────────────────┤
│ IVF 系列:                                                │
│   nlist  = sqrt(N) ~ 4*sqrt(N)  [N=向量总数]            │
│   nprobe = nlist * (1%~10%)     [速度↔召回率]           │
│                                                          │
│ HNSW:                                                    │
│   M              = 8~32         [连接数，影响内存]       │
│   efConstruction = 100~400      [构建质量]              │
│   ef             = 64~256       [搜索质量]              │
│                                                          │
│ 场景推荐:                                                │
│   实时对话  → IVF_FLAT, nprobe=10-20                    │
│   离线分析  → HNSW, M=32, ef=256                        │
│   大规模    → IVF_PQ, 量化压缩                          │
└─────────────────────────────────────────────────────────┘
```

---

## 下一步学习

掌握最小可用知识后，建议深入学习：

1. **核心概念** - 理解每个参数的数学原理
2. **实战代码** - 完整的调优实验和 A/B 测试
3. **化骨绵掌** - 高级调优技巧和生产经验
