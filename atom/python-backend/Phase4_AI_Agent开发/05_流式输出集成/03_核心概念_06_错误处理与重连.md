# 核心概念06: 错误处理与重连

> 深入理解流式输出中的错误处理和客户端重连机制

---

## 概述

**流式输出的错误处理** 比普通响应复杂,因为部分数据已经发送,无法撤回。需要特殊的错误处理策略和重连机制。

**本节目标:**
- 理解流式输出错误处理的挑战
- 掌握服务端错误处理策略
- 学习客户端重连机制
- 实现生产级的错误处理和重连

---

## 1. 流式输出错误处理的挑战

### 1.1 普通响应 vs 流式响应

**普通响应的错误处理:**

```python
@app.get("/normal")
async def normal():
    try:
        result = await some_operation()
        return {"data": result}
    except Exception as e:
        # 返回错误状态码
        raise HTTPException(status_code=500, detail=str(e))
```

**特点:**
- 错误发生在响应发送前
- 可以返回错误状态码
- 客户端简单处理 (检查状态码)

**流式响应的错误处理:**

```python
@app.get("/stream")
async def stream():
    async def generate():
        try:
            for i in range(10):
                if i == 5:
                    raise Exception("错误")
                yield f"data: {i}\n\n"
        except Exception as e:
            # ❌ 无法返回错误状态码 (响应头已发送)
            # ✅ 只能发送错误事件
            yield f"event: error\ndata: {str(e)}\n\n"

    return StreamingResponse(generate(), media_type="text/event-stream")
```

**特点:**
- 错误可能发生在流式传输中途
- 响应头已发送 (状态码 200)
- 部分数据已发送,无法撤回
- 需要通过 SSE 事件通知错误

### 1.2 核心挑战

**挑战1: 部分数据已发送**

```
客户端已收到: data: 0\n\ndata: 1\n\ndata: 2\n\n
服务端出错: Exception at i=5
客户端无法知道: 后续数据不完整
```

**挑战2: 无法返回错误状态码**

```
HTTP/1.1 200 OK
Content-Type: text/event-stream

data: 0\n\n
data: 1\n\n
[错误发生] ← 状态码已经是 200,无法改变
```

**挑战3: 客户端需要特殊处理**

```javascript
// 普通响应
if (response.status !== 200) {
    handleError();  // 简单
}

// 流式响应
eventSource.addEventListener('error', (event) => {
    // 需要区分: 网络错误 vs 业务错误
    // 需要处理: 部分数据已显示
});
```

---

## 2. 服务端错误处理策略

### 2.1 错误分类

```python
"""
错误分类和处理策略
"""

from enum import Enum

class ErrorType(Enum):
    VALIDATION = "validation"      # 参数验证错误
    BUSINESS = "business"          # 业务逻辑错误
    SYSTEM = "system"              # 系统错误
    TIMEOUT = "timeout"            # 超时错误
    RATE_LIMIT = "rate_limit"      # 限流错误

class ErrorSeverity(Enum):
    WARNING = "warning"    # 警告 (可继续)
    ERROR = "error"        # 错误 (中断流式)
    FATAL = "fatal"        # 致命错误 (需要重启)
```

### 2.2 完整的错误处理实现

```python
"""
生产级错误处理实现
"""

from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from langchain_openai import ChatOpenAI
import json
import traceback
import asyncio

app = FastAPI()
llm = ChatOpenAI()

@app.post("/chat-robust")
async def chat_robust(message: str):
    """生产级错误处理"""
    async def generate():
        try:
            # 1. 参数验证 (在流式开始前)
            if not message or len(message) > 1000:
                raise HTTPException(
                    status_code=400,
                    detail="Invalid message length"
                )

            # 2. 发送初始化事件
            yield f"event: init\ndata: {json.dumps({'status': 'started'})}\n\n"

            # 3. 流式生成
            token_count = 0
            try:
                async for chunk in llm.astream(message):
                    if chunk.content:
                        token_count += 1
                        yield f"data: {chunk.content}\n\n"

                        # 检查是否超时
                        if token_count > 1000:
                            raise TimeoutError("Generation timeout")

            except asyncio.TimeoutError:
                # 超时错误
                error_data = {
                    "type": ErrorType.TIMEOUT.value,
                    "severity": ErrorSeverity.ERROR.value,
                    "message": "Generation timeout",
                    "recoverable": True
                }
                yield f"event: error\ndata: {json.dumps(error_data)}\n\n"
                return

            except ValueError as e:
                # 业务错误
                error_data = {
                    "type": ErrorType.BUSINESS.value,
                    "severity": ErrorSeverity.ERROR.value,
                    "message": str(e),
                    "recoverable": True
                }
                yield f"event: error\ndata: {json.dumps(error_data)}\n\n"
                return

            except Exception as e:
                # 系统错误
                error_data = {
                    "type": ErrorType.SYSTEM.value,
                    "severity": ErrorSeverity.FATAL.value,
                    "message": str(e),
                    "traceback": traceback.format_exc(),
                    "recoverable": False
                }
                yield f"event: error\ndata: {json.dumps(error_data)}\n\n"
                return

            # 4. 发送完成事件
            yield f"event: done\ndata: {json.dumps({'token_count': token_count})}\n\n"

        except HTTPException:
            # 参数验证错误 (在流式开始前)
            raise

        except Exception as e:
            # 未预期的错误
            error_data = {
                "type": ErrorType.SYSTEM.value,
                "severity": ErrorSeverity.FATAL.value,
                "message": "Unexpected error",
                "detail": str(e)
            }
            yield f"event: error\ndata: {json.dumps(error_data)}\n\n"

        finally:
            # 清理资源
            print(f"Stream closed, tokens: {token_count}")

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

### 2.3 错误事件格式

```python
"""
标准化错误事件格式
"""

from pydantic import BaseModel
from typing import Optional

class ErrorEvent(BaseModel):
    type: str              # 错误类型
    severity: str          # 严重程度
    message: str           # 错误消息
    code: Optional[str]    # 错误代码
    recoverable: bool      # 是否可恢复
    traceback: Optional[str]  # 堆栈跟踪 (仅开发环境)

# 使用示例
error = ErrorEvent(
    type="business",
    severity="error",
    message="Invalid input",
    code="INVALID_INPUT",
    recoverable=True
)

yield f"event: error\ndata: {error.json()}\n\n"
```

---

## 3. 客户端错误处理

### 3.1 基础错误处理

```javascript
/**
 * 基础错误处理
 */

const eventSource = new EventSource('/chat-robust?message=Hello');

// 监听正常消息
eventSource.onmessage = (event) => {
    console.log('收到:', event.data);
    displayMessage(event.data);
};

// 监听错误事件
eventSource.addEventListener('error', (event) => {
    const errorData = JSON.parse(event.data);

    console.error('错误:', errorData);

    // 根据错误类型处理
    if (errorData.recoverable) {
        // 可恢复错误: 显示错误提示,保留已显示内容
        showError(errorData.message);
    } else {
        // 不可恢复错误: 清空内容,显示错误
        clearContent();
        showFatalError(errorData.message);
    }

    // 关闭连接
    eventSource.close();
});

// 监听连接错误 (网络问题)
eventSource.onerror = (error) => {
    console.error('连接错误:', error);

    // EventSource 会自动重连
    // 如果不想重连,手动关闭
    // eventSource.close();
};
```

### 3.2 完整的错误处理

```javascript
/**
 * 生产级错误处理
 */

class StreamingClient {
    constructor(url) {
        this.url = url;
        this.eventSource = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.currentMessage = '';
        this.hasError = false;
    }

    connect() {
        this.eventSource = new EventSource(this.url);

        // 监听初始化事件
        this.eventSource.addEventListener('init', (event) => {
            console.log('连接成功');
            this.reconnectAttempts = 0;  // 重置重连计数
        });

        // 监听正常消息
        this.eventSource.onmessage = (event) => {
            if (!this.hasError) {
                this.currentMessage += event.data;
                this.updateUI(this.currentMessage);
            }
        };

        // 监听业务错误
        this.eventSource.addEventListener('error', (event) => {
            const errorData = JSON.parse(event.data);
            this.hasError = true;

            console.error('业务错误:', errorData);

            // 显示错误提示
            this.showError(errorData);

            // 根据错误类型决定是否重连
            if (errorData.recoverable && this.reconnectAttempts < this.maxReconnectAttempts) {
                this.scheduleReconnect();
            } else {
                this.eventSource.close();
            }
        });

        // 监听连接错误 (网络问题)
        this.eventSource.onerror = (error) => {
            console.error('连接错误:', error);

            // 检查是否超过最大重连次数
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                console.error('超过最大重连次数');
                this.eventSource.close();
                this.showFatalError('连接失败,请刷新页面重试');
                return;
            }

            // EventSource 会自动重连
            this.reconnectAttempts++;
            console.log(`重连中... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
        });

        // 监听完成事件
        this.eventSource.addEventListener('done', (event) => {
            console.log('完成');
            this.eventSource.close();
        });
    }

    scheduleReconnect() {
        // 延迟重连 (指数退避)
        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
        console.log(`${delay}ms 后重连...`);

        setTimeout(() => {
            this.reconnectAttempts++;
            this.connect();
        }, delay);
    }

    updateUI(message) {
        document.getElementById('message').textContent = message;
    }

    showError(errorData) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error';
        errorDiv.textContent = `错误: ${errorData.message}`;
        document.getElementById('errors').appendChild(errorDiv);
    }

    showFatalError(message) {
        document.getElementById('content').innerHTML = `
            <div class="fatal-error">
                <h3>发生错误</h3>
                <p>${message}</p>
                <button onclick="location.reload()">刷新页面</button>
            </div>
        `;
    }

    close() {
        if (this.eventSource) {
            this.eventSource.close();
        }
    }
}

// 使用
const client = new StreamingClient('/chat-robust?message=Hello');
client.connect();
```

---

## 4. 重连机制

### 4.1 SSE 自动重连

**浏览器自动重连:**

```javascript
// EventSource 会自动重连
const eventSource = new EventSource('/stream');

eventSource.onerror = () => {
    console.log('连接中断,浏览器会自动重连...');
    // 浏览器会在 3 秒后自动重连 (默认)
};
```

**服务端设置重连间隔:**

```python
async def generate():
    # 设置重连间隔为 5 秒
    yield "retry: 5000\n\n"

    # 发送数据...
```

### 4.2 断点续传 (Last-Event-ID)

**服务端实现:**

```python
"""
支持断点续传的流式输出
"""

from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse

app = FastAPI()

# 存储每个会话的状态
sessions = {}

@app.get("/stream-resumable")
async def stream_resumable(request: Request, session_id: str):
    """支持断点续传的流式输出"""
    # 获取客户端的 Last-Event-ID
    last_event_id = request.headers.get('Last-Event-ID', '0')
    start_id = int(last_event_id) + 1

    async def generate():
        # 从 start_id 开始发送数据
        for i in range(start_id, 100):
            # 发送带 ID 的事件
            yield f"id: {i}\ndata: Message {i}\n\n"
            await asyncio.sleep(0.5)

            # 保存进度
            sessions[session_id] = i

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

**客户端接收:**

```javascript
/**
 * 断点续传示例
 */

const eventSource = new EventSource('/stream-resumable?session_id=123');

eventSource.onmessage = (event) => {
    console.log('ID:', event.lastEventId);  // 最后接收的事件 ID
    console.log('Data:', event.data);

    // 保存最后的事件 ID
    localStorage.setItem('lastEventId', event.lastEventId);
};

eventSource.onerror = () => {
    console.log('连接中断');
    // 重连时,浏览器会自动发送 Last-Event-ID 请求头
    // 服务端可以从这个 ID 继续发送数据
};
```

### 4.3 手动重连

```javascript
/**
 * 手动重连实现
 */

class ManualReconnectClient {
    constructor(url) {
        this.url = url;
        this.eventSource = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;  // 初始延迟 1 秒
    }

    connect() {
        this.eventSource = new EventSource(this.url);

        this.eventSource.onopen = () => {
            console.log('连接成功');
            // 重置重连参数
            this.reconnectAttempts = 0;
            this.reconnectDelay = 1000;
        };

        this.eventSource.onmessage = (event) => {
            console.log('收到:', event.data);
        };

        this.eventSource.onerror = () => {
            console.error('连接错误');
            this.eventSource.close();

            // 手动重连
            if (this.reconnectAttempts < this.maxReconnectAttempts) {
                this.scheduleReconnect();
            } else {
                console.error('超过最大重连次数');
            }
        };
    }

    scheduleReconnect() {
        this.reconnectAttempts++;

        // 指数退避
        const delay = Math.min(
            this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),
            30000  // 最大 30 秒
        );

        console.log(`${delay}ms 后重连... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

        setTimeout(() => {
            this.connect();
        }, delay);
    }

    close() {
        if (this.eventSource) {
            this.eventSource.close();
        }
    }
}
```

---

## 5. 超时处理

### 5.1 服务端超时

```python
"""
服务端超时处理
"""

import asyncio

@app.post("/stream-timeout")
async def stream_timeout(message: str):
    """带超时处理的流式输出"""
    async def generate():
        try:
            # 设置总超时时间
            async with asyncio.timeout(30):  # 30 秒超时
                async for chunk in llm.astream(message):
                    if chunk.content:
                        yield f"data: {chunk.content}\n\n"

        except asyncio.TimeoutError:
            # 发送超时错误
            error_data = {
                "type": "timeout",
                "message": "Generation timeout after 30 seconds"
            }
            yield f"event: error\ndata: {json.dumps(error_data)}\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

### 5.2 客户端超时

```javascript
/**
 * 客户端超时处理
 */

class TimeoutClient {
    constructor(url, timeout = 30000) {
        this.url = url;
        this.timeout = timeout;
        this.eventSource = null;
        this.timeoutId = null;
    }

    connect() {
        this.eventSource = new EventSource(this.url);

        // 设置超时定时器
        this.timeoutId = setTimeout(() => {
            console.error('客户端超时');
            this.eventSource.close();
            this.showError('请求超时,请重试');
        }, this.timeout);

        this.eventSource.onmessage = (event) => {
            // 收到消息,重置超时定时器
            clearTimeout(this.timeoutId);
            this.timeoutId = setTimeout(() => {
                console.error('客户端超时');
                this.eventSource.close();
                this.showError('响应超时');
            }, this.timeout);

            console.log('收到:', event.data);
        };

        this.eventSource.addEventListener('done', () => {
            // 完成,清除超时定时器
            clearTimeout(this.timeoutId);
            this.eventSource.close();
        });

        this.eventSource.onerror = () => {
            clearTimeout(this.timeoutId);
            this.eventSource.close();
        };
    }

    showError(message) {
        console.error(message);
    }

    close() {
        clearTimeout(this.timeoutId);
        if (this.eventSource) {
            this.eventSource.close();
        }
    }
}
```

---

## 6. 生产环境最佳实践

### 6.1 错误日志

```python
"""
错误日志记录
"""

import logging
import json

logger = logging.getLogger(__name__)

@app.post("/stream-logged")
async def stream_logged(message: str):
    """带日志记录的流式输出"""
    request_id = str(uuid.uuid4())

    async def generate():
        try:
            logger.info(f"[{request_id}] Stream started")

            async for chunk in llm.astream(message):
                if chunk.content:
                    yield f"data: {chunk.content}\n\n"

            logger.info(f"[{request_id}] Stream completed")

        except Exception as e:
            logger.error(f"[{request_id}] Stream error: {str(e)}", exc_info=True)

            error_data = {
                "request_id": request_id,
                "error": str(e)
            }
            yield f"event: error\ndata: {json.dumps(error_data)}\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream",
        headers={"X-Request-ID": request_id}
    )
```

### 6.2 监控和告警

```python
"""
监控和告警
"""

from prometheus_client import Counter, Histogram

# 定义指标
stream_errors = Counter('stream_errors_total', 'Total stream errors', ['error_type'])
stream_duration = Histogram('stream_duration_seconds', 'Stream duration')

@app.post("/stream-monitored")
async def stream_monitored(message: str):
    """带监控的流式输出"""
    async def generate():
        start_time = time.time()

        try:
            async for chunk in llm.astream(message):
                if chunk.content:
                    yield f"data: {chunk.content}\n\n"

            # 记录成功
            stream_duration.observe(time.time() - start_time)

        except asyncio.TimeoutError:
            stream_errors.labels(error_type='timeout').inc()
            yield f"event: error\ndata: Timeout\n\n"

        except Exception as e:
            stream_errors.labels(error_type='system').inc()
            yield f"event: error\ndata: {str(e)}\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

### 6.3 优雅降级

```python
"""
优雅降级策略
"""

@app.post("/stream-fallback")
async def stream_fallback(message: str, use_stream: bool = True):
    """带降级策略的端点"""
    if use_stream:
        # 尝试流式输出
        try:
            async def generate():
                async for chunk in llm.astream(message):
                    if chunk.content:
                        yield f"data: {chunk.content}\n\n"

            return StreamingResponse(
                generate(),
                media_type="text/event-stream"
            )

        except Exception as e:
            logger.error(f"Stream failed, fallback to normal: {e}")
            # 降级到普通响应
            use_stream = False

    if not use_stream:
        # 普通响应
        response = await llm.ainvoke(message)
        return {"response": response.content}
```

---

## 7. 测试错误处理

### 7.1 单元测试

```python
"""
错误处理单元测试
"""

import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_stream_error_handling():
    """测试流式输出错误处理"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        async with client.stream("POST", "/chat-robust?message=test") as response:
            # 检查响应头
            assert response.status_code == 200
            assert response.headers["content-type"] == "text/event-stream"

            # 读取流式响应
            events = []
            async for line in response.aiter_lines():
                if line.startswith("data:"):
                    events.append(line)
                elif line.startswith("event: error"):
                    # 检测到错误事件
                    assert True
                    break

            # 验证收到了部分数据
            assert len(events) > 0
```

### 7.2 集成测试

```python
"""
错误处理集成测试
"""

@pytest.mark.asyncio
async def test_stream_reconnect():
    """测试重连机制"""
    reconnect_count = 0

    async def connect():
        nonlocal reconnect_count
        reconnect_count += 1

        async with AsyncClient(app=app, base_url="http://test") as client:
            try:
                async with client.stream("POST", "/stream") as response:
                    async for line in response.aiter_lines():
                        if "error" in line:
                            raise Exception("Stream error")
            except Exception:
                if reconnect_count < 3:
                    await connect()  # 重连

    await connect()
    assert reconnect_count == 3  # 验证重连了 3 次
```

---

## 总结

**流式输出错误处理的核心要点:**

1. **错误分类**: 参数验证、业务错误、系统错误、超时错误
2. **服务端策略**: 使用 SSE 事件通知错误,记录日志,监控指标
3. **客户端策略**: 区分错误类型,保留已显示内容,实现重连
4. **重连机制**: SSE 自动重连,断点续传,指数退避

**最佳实践:**
- ✅ 标准化错误事件格式
- ✅ 记录详细的错误日志
- ✅ 实现监控和告警
- ✅ 提供优雅降级
- ✅ 测试错误处理逻辑

**下一步:**

理解了错误处理和重连后,可以学习:
- 实战代码示例
- 性能优化技巧
- 生产环境部署

---

**记住:** 流式输出的错误处理是生产环境的关键,必须认真对待。良好的错误处理可以大幅提升用户体验和系统稳定性。
