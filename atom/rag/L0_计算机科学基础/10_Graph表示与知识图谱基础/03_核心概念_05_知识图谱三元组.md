# 核心概念5：知识图谱三元组(SPO)

> (Subject, Predicate, Object) - 知识图谱的基本存储单元

---

## 一句话定义

**知识图谱三元组(SPO)是(主语, 谓语, 宾语)的结构化表示，是RAG系统存储实体关系、支持多跳推理的基础单元。**

---

## 核心原理

### 三元组结构

```python
# 三元组格式
triple = (Subject, Predicate, Object)
#         主语     谓语      宾语
#         实体1    关系      实体2

# 示例
("张三", "工作于", "阿里巴巴")
("阿里巴巴", "位于", "杭州")
("马云", "创立", "阿里巴巴")
```

**核心要素：**
- **Subject（主语）**：起始实体
- **Predicate（谓语）**：关系类型
- **Object（宾语）**：目标实体

---

## 完整实现

### 基础三元组存储

```python
from collections import defaultdict
from typing import List, Tuple, Set

class TripleStore:
    """三元组存储系统"""

    def __init__(self):
        # 多种索引加速查询
        self.spo = defaultdict(lambda: defaultdict(list))  # S,P -> [O]
        self.pos = defaultdict(lambda: defaultdict(list))  # P,O -> [S]
        self.osp = defaultdict(lambda: defaultdict(list))  # O,S -> [P]
        self.triples = []  # 原始三元组列表

    def add(self, subject, predicate, object):
        """添加三元组"""
        triple = (subject, predicate, object)

        # 避免重复
        if triple in self.triples:
            return

        # 存储原始三元组
        self.triples.append(triple)

        # 更新索引
        self.spo[subject][predicate].append(object)
        self.pos[predicate][object].append(subject)
        self.osp[object][subject].append(predicate)

    def query_spo(self, subject, predicate=None):
        """查询：给定S和P，返回O"""
        if predicate:
            return self.spo[subject][predicate]
        else:
            # 返回所有关系
            return dict(self.spo[subject])

    def query_pos(self, predicate, object):
        """查询：给定P和O，返回S"""
        return self.pos[predicate][object]

    def query_osp(self, object, subject):
        """查询：给定O和S，返回P"""
        return self.osp[object][subject]

    def get_all_relations(self, entity):
        """获取实体的所有关系"""
        relations = []

        # 作为主语的关系
        for pred, objs in self.spo[entity].items():
            for obj in objs:
                relations.append((entity, pred, obj))

        # 作为宾语的关系
        for obj_entity, preds in self.osp[entity].items():
            for pred in preds:
                relations.append((obj_entity, pred, entity))

        return relations

    def count(self):
        """三元组数量"""
        return len(self.triples)

# 使用示例
ts = TripleStore()
ts.add("张三", "工作于", "阿里巴巴")
ts.add("张三", "居住在", "杭州")
ts.add("阿里巴巴", "位于", "杭州")
ts.add("马云", "创立", "阿里巴巴")

# 查询
print(ts.query_spo("张三", "工作于"))  # ['阿里巴巴']
print(ts.query_spo("张三"))            # {'工作于': ['阿里巴巴'], '居住在': ['杭州']}
print(ts.query_pos("位于", "杭州"))    # ['阿里巴巴']
print(ts.get_all_relations("阿里巴巴"))
# [('张三', '工作于', '阿里巴巴'), ('马云', '创立', '阿里巴巴'), ('阿里巴巴', '位于', '杭州')]
```

### 使用NetworkX表示

```python
import networkx as nx

class KnowledgeGraph:
    """基于NetworkX的知识图谱"""

    def __init__(self):
        self.G = nx.MultiDiGraph()  # 多重有向图（支持多条边）

    def add_triple(self, subject, predicate, object):
        """添加三元组"""
        self.G.add_edge(subject, object, relation=predicate)

    def query(self, subject, predicate=None):
        """查询三元组"""
        if subject not in self.G:
            return []

        results = []
        for _, obj, data in self.G.out_edges(subject, data=True):
            if predicate is None or data['relation'] == predicate:
                results.append((subject, data['relation'], obj))

        return results

    def find_path(self, start, end, max_hops=3):
        """多跳路径查询"""
        try:
            paths = nx.all_simple_paths(self.G, start, end, cutoff=max_hops)
            return list(paths)
        except nx.NetworkXNoPath:
            return []

# 使用
kg = KnowledgeGraph()
kg.add_triple("张三", "工作于", "阿里巴巴")
kg.add_triple("阿里巴巴", "位于", "杭州")
kg.add_triple("马云", "创立", "阿里巴巴")

print(kg.query("张三"))  # [('张三', '工作于', '阿里巴巴')]
print(kg.find_path("张三", "杭州"))  # [['张三', '阿里巴巴', '杭州']]
```

---

## 在AI Agent中的应用

### 应用1：RAG结构化知识存储⭐⭐⭐⭐⭐

```python
class RAGKnowledgeBase:
    """RAG系统的知识库"""

    def __init__(self):
        self.triple_store = TripleStore()
        self.entity_descriptions = {}  # 实体描述

    def add_knowledge(self, subject, predicate, object, description=None):
        """添加知识"""
        self.triple_store.add(subject, predicate, object)

        # 存储实体描述
        if description:
            self.entity_descriptions[subject] = description

    def retrieve_context(self, query_entities):
        """检索相关上下文"""
        context = []

        for entity in query_entities:
            # 获取实体的所有关系
            relations = self.triple_store.get_all_relations(entity)
            context.extend(relations)

            # 获取实体描述
            if entity in self.entity_descriptions:
                context.append(f"{entity}: {self.entity_descriptions[entity]}")

        return context

    def answer_question(self, question, llm):
        """基于知识图谱回答问题"""
        # 1. 提取问题中的实体
        entities = self.extract_entities(question)

        # 2. 检索相关知识
        context = self.retrieve_context(entities)

        # 3. 生成答案
        prompt = f"""
        基于以下知识回答问题：
        知识：{context}
        问题：{question}
        """
        return llm.generate(prompt)

# 使用
rag_kb = RAGKnowledgeBase()
rag_kb.add_knowledge("张三", "工作于", "阿里巴巴", "张三是一名软件工程师")
rag_kb.add_knowledge("阿里巴巴", "位于", "杭州")

context = rag_kb.retrieve_context(["张三"])
print(context)
# [('张三', '工作于', '阿里巴巴'), '张三: 张三是一名软件工程师']
```

### 应用2：多跳推理⭐⭐⭐⭐⭐

```python
def multi_hop_reasoning(kg, question):
    """多跳推理回答问题"""

    # 示例：张三的老板的出生地在哪？
    # 推理链：张三 → 工作于 → 阿里巴巴 → 创始人 → 马云 → 出生于 → 杭州

    # 1. 解析问题，提取推理路径
    reasoning_path = [
        ("张三", "工作于"),
        ("阿里巴巴", "创始人"),
        ("马云", "出生于")
    ]

    # 2. 执行推理
    current_entity = "张三"
    for entity, relation in reasoning_path:
        results = kg.query_spo(current_entity, relation)
        if results:
            current_entity = results[0]
            print(f"{entity} {relation} {current_entity}")
        else:
            return None

    return current_entity

# 构建知识图谱
kg = TripleStore()
kg.add("张三", "工作于", "阿里巴巴")
kg.add("阿里巴巴", "创始人", "马云")
kg.add("马云", "出生于", "杭州")

answer = multi_hop_reasoning(kg, "张三的老板的出生地")
print(f"答案: {answer}")  # 杭州
```

### 应用3：知识图谱可视化

```python
import matplotlib.pyplot as plt
import networkx as nx

def visualize_kg(triple_store):
    """可视化知识图谱"""
    G = nx.DiGraph()

    # 添加边
    for s, p, o in triple_store.triples:
        G.add_edge(s, o, label=p)

    # 绘制
    pos = nx.spring_layout(G)
    plt.figure(figsize=(12, 8))

    # 绘制节点
    nx.draw_networkx_nodes(G, pos, node_size=3000, node_color='lightblue')

    # 绘制边
    nx.draw_networkx_edges(G, pos, edge_color='gray', arrows=True,
                           arrowsize=20, arrowstyle='->')

    # 绘制标签
    nx.draw_networkx_labels(G, pos, font_size=12)

    # 绘制边标签
    edge_labels = nx.get_edge_attributes(G, 'label')
    nx.draw_networkx_edge_labels(G, pos, edge_labels, font_size=10)

    plt.axis('off')
    plt.tight_layout()
    plt.savefig('knowledge_graph.png', dpi=300, bbox_inches='tight')
    plt.show()

# 使用
visualize_kg(ts)
```

---

## RDF标准格式

### RDF三元组

```python
# RDF (Resource Description Framework) 标准
# 使用URI标识资源

from rdflib import Graph, Literal, Namespace, URIRef
from rdflib.namespace import RDF, FOAF

# 创建RDF图
g = Graph()

# 定义命名空间
ex = Namespace("http://example.org/")

# 添加三元组
g.add((ex.张三, RDF.type, FOAF.Person))
g.add((ex.张三, FOAF.name, Literal("张三")))
g.add((ex.张三, ex.worksFor, ex.阿里巴巴))
g.add((ex.阿里巴巴, RDF.type, FOAF.Organization))
g.add((ex.阿里巴巴, ex.locatedIn, ex.杭州))

# 查询（SPARQL）
query = """
SELECT ?person ?company
WHERE {
    ?person ex:worksFor ?company .
}
"""

# 序列化为Turtle格式
print(g.serialize(format='turtle'))
```

---

## 三元组的扩展

### 带属性的三元组

```python
class AttributedTriple:
    """带属性的三元组"""

    def __init__(self, subject, predicate, object, **attributes):
        self.subject = subject
        self.predicate = predicate
        self.object = object
        self.attributes = attributes  # 时间戳、置信度等

    def __repr__(self):
        return f"({self.subject}, {self.predicate}, {self.object}, {self.attributes})"

# 使用
triple = AttributedTriple(
    "张三", "工作于", "阿里巴巴",
    timestamp="2024-01-01",
    confidence=0.95,
    source="官网"
)

print(triple)
# (张三, 工作于, 阿里巴巴, {'timestamp': '2024-01-01', 'confidence': 0.95, 'source': '官网'})
```

### 时序知识图谱

```python
class TemporalKnowledgeGraph:
    """时序知识图谱（支持时间维度）"""

    def __init__(self):
        self.triples = []

    def add(self, subject, predicate, object, start_time, end_time=None):
        """添加时序三元组"""
        self.triples.append({
            'subject': subject,
            'predicate': predicate,
            'object': object,
            'start_time': start_time,
            'end_time': end_time
        })

    def query_at_time(self, subject, predicate, time):
        """查询特定时间点的关系"""
        results = []
        for triple in self.triples:
            if (triple['subject'] == subject and
                triple['predicate'] == predicate and
                triple['start_time'] <= time and
                (triple['end_time'] is None or triple['end_time'] >= time)):
                results.append(triple['object'])
        return results

# 使用
tkg = TemporalKnowledgeGraph()
tkg.add("张三", "工作于", "阿里巴巴", "2020-01-01", "2023-12-31")
tkg.add("张三", "工作于", "腾讯", "2024-01-01", None)

print(tkg.query_at_time("张三", "工作于", "2022-06-01"))  # ['阿里巴巴']
print(tkg.query_at_time("张三", "工作于", "2024-06-01"))  # ['腾讯']
```

---

## 三元组提取

### 从文本提取三元组

```python
def extract_triples_with_llm(text, llm):
    """使用LLM提取三元组"""
    prompt = f"""
    从以下文本中提取知识三元组，格式为(主语, 谓语, 宾语)。

    文本：{text}

    要求：
    1. 提取所有实体和关系
    2. 每行一个三元组
    3. 格式：(主语, 谓语, 宾语)

    三元组：
    """

    response = llm.generate(prompt)
    return parse_triples(response)

def parse_triples(text):
    """解析LLM输出的三元组"""
    import re
    triples = []

    # 匹配 (主语, 谓语, 宾语) 格式
    pattern = r'\(([^,]+),\s*([^,]+),\s*([^)]+)\)'
    matches = re.findall(pattern, text)

    for match in matches:
        subject, predicate, object = match
        triples.append((subject.strip(), predicate.strip(), object.strip()))

    return triples

# 使用
text = "张三在阿里巴巴工作，阿里巴巴位于杭州。马云创立了阿里巴巴。"
# triples = extract_triples_with_llm(text, llm)
# print(triples)
# [('张三', '工作于', '阿里巴巴'), ('阿里巴巴', '位于', '杭州'), ('马云', '创立', '阿里巴巴')]
```

---

## 实战练习

### 练习1：实现SPARQL查询

```python
def sparql_query(triple_store, pattern):
    """
    简化版SPARQL查询
    pattern: (subject, predicate, object)
    使用 None 表示变量
    """
    # 示例：查询所有在杭州的实体
    # pattern = (None, "位于", "杭州")
    pass
```

### 练习2：三元组去重

```python
def deduplicate_triples(triples):
    """
    三元组去重和合并
    处理：
    1. 完全重复的三元组
    2. 同义关系（"工作于" vs "就职于"）
    3. 实体别名（"阿里巴巴" vs "Alibaba"）
    """
    pass
```

---

## 总结

**知识图谱三元组核心特点：**

1. **结构化**：(S, P, O)明确的语义结构
2. **可查询**：支持多种查询模式
3. **可推理**：支持多跳推理
4. **可扩展**：可添加属性、时间等维度

**在AI Agent中的应用：**
- RAG结构化知识存储
- 多跳推理和问答
- 知识图谱构建
- 关系发现和推荐

**关键洞察：**
- 三元组是知识图谱的原子单元
- 索引设计决定查询性能
- 时序和属性扩展增强表达能力
- LLM提取是构建知识图谱的关键

---

**下一步：** 学习 `03_核心概念_06_实体关系提取.md`
