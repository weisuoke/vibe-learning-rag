# 实战代码 - 场景2：知识图谱遍历

## 场景描述

**目标：** 使用Neo4j构建知识图谱，实现BFS/DFS遍历和Cypher查询

**学习重点：**
- Neo4j图数据库的使用
- Cypher查询语言
- 三元组的存储和检索
- 实体关系导航

---

## 环境准备

```bash
# 安装依赖
pip install neo4j

# 启动Neo4j（使用Docker）
docker run -d \
  --name neo4j \
  -p 7474:7474 -p 7687:7687 \
  -e NEO4J_AUTH=neo4j/password \
  neo4j:latest

# 访问Neo4j浏览器：http://localhost:7474
# 用户名：neo4j
# 密码：password
```

---

## 完整可运行代码

```python
"""
知识图谱遍历实战
演示：Neo4j + Python、BFS/DFS遍历、Cypher查询
"""

from neo4j import GraphDatabase
from collections import deque
from typing import List, Dict, Set, Tuple
import os

# ===== 1. Neo4j连接管理 =====

class Neo4jKG:
    """Neo4j知识图谱管理器"""
    def __init__(self, uri: str = "bolt://localhost:7687", user: str = "neo4j", password: str = "password"):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        """关闭连接"""
        self.driver.close()

    def clear_database(self):
        """清空数据库"""
        with self.driver.session() as session:
            session.run("MATCH (n) DETACH DELETE n")
            print("✅ 数据库已清空")

    # ===== 2. 数据写入 =====

    def add_triple(self, head: str, relation: str, tail: str):
        """添加三元组"""
        with self.driver.session() as session:
            query = """
            MERGE (h:Entity {name: $head})
            MERGE (t:Entity {name: $tail})
            MERGE (h)-[r:RELATION {type: $relation}]->(t)
            """
            session.run(query, head=head, relation=relation, tail=tail)

    def add_triples_batch(self, triples: List[Tuple[str, str, str]]):
        """批量添加三元组"""
        with self.driver.session() as session:
            for head, relation, tail in triples:
                self.add_triple(head, relation, tail)
        print(f"✅ 已添加{len(triples)}个三元组")

    # ===== 3. BFS遍历 =====

    def bfs_python(self, start: str, max_hops: int = 2) -> List[str]:
        """
        Python实现的BFS遍历

        返回：按BFS顺序访问的实体列表
        """
        visited = {start: 0}
        queue = deque([(start, 0)])
        result = []

        while queue:
            entity, depth = queue.popleft()
            result.append(entity)

            if depth >= max_hops:
                continue

            # 获取邻居
            neighbors = self.get_neighbors(entity)
            for neighbor in neighbors:
                if neighbor not in visited:
                    visited[neighbor] = depth + 1
                    queue.append((neighbor, depth + 1))

        return result

    def bfs_cypher(self, start: str, max_hops: int = 2) -> List[Tuple[str, int]]:
        """
        Cypher实现的BFS遍历

        返回：[(实体, 距离)]
        """
        with self.driver.session() as session:
            query = f"""
            MATCH path = (start:Entity {{name: $start}})-[*1..{max_hops}]-(neighbor:Entity)
            RETURN DISTINCT neighbor.name AS entity, length(path) AS distance
            ORDER BY distance, entity
            """
            result = session.run(query, start=start)
            return [(record["entity"], record["distance"]) for record in result]

    # ===== 4. DFS遍历 =====

    def dfs_python(self, start: str, max_depth: int = 3) -> List[List[str]]:
        """
        Python实现的DFS遍历（找所有路径）

        返回：所有路径列表
        """
        all_paths = []

        def dfs(entity: str, depth: int, visited: Set[str], path: List[str]):
            if depth > max_depth:
                return

            path.append(entity)
            visited.add(entity)

            neighbors = self.get_neighbors(entity)
            if not neighbors or depth == max_depth:
                all_paths.append(path[:])
            else:
                for neighbor in neighbors:
                    if neighbor not in visited:
                        dfs(neighbor, depth + 1, visited, path)

            path.pop()
            visited.remove(entity)

        dfs(start, 0, set(), [])
        return all_paths

    def dfs_cypher(self, start: str, max_depth: int = 3) -> List[List[str]]:
        """
        Cypher实现的DFS遍历（找所有路径）

        返回：所有路径列表
        """
        with self.driver.session() as session:
            query = f"""
            MATCH path = (start:Entity {{name: $start}})-[*1..{max_depth}]->(end:Entity)
            WHERE NOT (end)-->()
            RETURN [node in nodes(path) | node.name] AS path
            LIMIT 100
            """
            result = session.run(query, start=start)
            return [record["path"] for record in result]

    # ===== 5. 路径查找 =====

    def find_shortest_path(self, start: str, end: str) -> List[str]:
        """
        查找最短路径（Cypher）

        返回：最短路径
        """
        with self.driver.session() as session:
            query = """
            MATCH path = shortestPath((start:Entity {name: $start})-[*]-(end:Entity {name: $end}))
            RETURN [node in nodes(path) | node.name] AS path
            """
            result = session.run(query, start=start, end=end)
            record = result.single()
            return record["path"] if record else []

    def find_all_paths(self, start: str, end: str, max_length: int = 5) -> List[List[str]]:
        """
        查找所有路径（Cypher）

        返回：所有路径列表
        """
        with self.driver.session() as session:
            query = f"""
            MATCH path = (start:Entity {{name: $start}})-[*1..{max_length}]->(end:Entity {{name: $end}})
            RETURN [node in nodes(path) | node.name] AS path
            ORDER BY length(path)
            LIMIT 10
            """
            result = session.run(query, start=start, end=end)
            return [record["path"] for record in result]

    # ===== 6. 辅助方法 =====

    def get_neighbors(self, entity: str) -> List[str]:
        """获取实体的邻居"""
        with self.driver.session() as session:
            query = """
            MATCH (e:Entity {name: $entity})-[]-(neighbor:Entity)
            RETURN DISTINCT neighbor.name AS neighbor
            """
            result = session.run(query, entity=entity)
            return [record["neighbor"] for record in result]

    def get_neighbors_with_relation(self, entity: str) -> List[Tuple[str, str]]:
        """获取实体的邻居及关系"""
        with self.driver.session() as session:
            query = """
            MATCH (e:Entity {name: $entity})-[r:RELATION]->(neighbor:Entity)
            RETURN r.type AS relation, neighbor.name AS neighbor
            """
            result = session.run(query, entity=entity)
            return [(record["relation"], record["neighbor"]) for record in result]

    def get_all_entities(self) -> List[str]:
        """获取所有实体"""
        with self.driver.session() as session:
            query = "MATCH (e:Entity) RETURN e.name AS entity ORDER BY entity"
            result = session.run(query)
            return [record["entity"] for record in result]

    def get_statistics(self) -> Dict:
        """获取图统计信息"""
        with self.driver.session() as session:
            query = """
            MATCH (e:Entity)
            OPTIONAL MATCH ()-[r:RELATION]->()
            RETURN count(DISTINCT e) AS num_entities, count(r) AS num_relations
            """
            result = session.run(query)
            record = result.single()
            return {
                "num_entities": record["num_entities"],
                "num_relations": record["num_relations"]
            }


# ===== 7. 示例数据 =====

def create_example_kg() -> List[Tuple[str, str, str]]:
    """
    创建示例知识图谱

    主题：科学家和他们的贡献
    """
    triples = [
        # Einstein相关
        ("Einstein", "developed", "相对论"),
        ("Einstein", "developed", "光电效应理论"),
        ("Einstein", "won", "诺贝尔奖"),
        ("Einstein", "nationality", "德国"),
        ("相对论", "predicts", "时空弯曲"),
        ("相对论", "enables", "GPS技术"),
        ("时空弯曲", "confirmed_by", "引力波探测"),
        ("光电效应理论", "leads_to", "量子力学"),
        ("量子力学", "enables", "半导体技术"),

        # Newton相关
        ("Newton", "developed", "经典力学"),
        ("Newton", "developed", "万有引力定律"),
        ("Newton", "nationality", "英国"),
        ("经典力学", "describes", "宏观运动"),
        ("万有引力定律", "explains", "行星运动"),

        # 关联
        ("相对论", "extends", "经典力学"),
        ("量子力学", "complements", "相对论"),
    ]
    return triples


# ===== 8. 可视化输出 =====

def visualize_bfs(kg: Neo4jKG, start: str, max_hops: int = 2):
    """可视化BFS遍历"""
    print("\n" + "=" * 60)
    print(f"BFS遍历：起点={start}, 最大跳数={max_hops}")
    print("=" * 60)

    # Python实现
    print("\n【Python实现】")
    python_result = kg.bfs_python(start, max_hops)
    print(f"遍历顺序：{' → '.join(python_result)}")
    print(f"访问节点数：{len(python_result)}")

    # Cypher实现
    print("\n【Cypher实现】")
    cypher_result = kg.bfs_cypher(start, max_hops)
    print("按距离分组：")
    for distance in range(max_hops + 1):
        entities = [e for e, d in cypher_result if d == distance]
        if entities:
            print(f"  {distance}跳：{entities}")


def visualize_dfs(kg: Neo4jKG, start: str, max_depth: int = 3):
    """可视化DFS遍历"""
    print("\n" + "=" * 60)
    print(f"DFS遍历：起点={start}, 最大深度={max_depth}")
    print("=" * 60)

    # Python实现
    print("\n【Python实现】")
    python_paths = kg.dfs_python(start, max_depth)
    print(f"找到{len(python_paths)}条路径：")
    for i, path in enumerate(python_paths[:5], 1):  # 只显示前5条
        print(f"  路径{i}：{' → '.join(path)}")

    # Cypher实现
    print("\n【Cypher实现】")
    cypher_paths = kg.dfs_cypher(start, max_depth)
    print(f"找到{len(cypher_paths)}条路径：")
    for i, path in enumerate(cypher_paths[:5], 1):
        print(f"  路径{i}：{' → '.join(path)}")


def visualize_path_finding(kg: Neo4jKG, start: str, end: str):
    """可视化路径查找"""
    print("\n" + "=" * 60)
    print(f"路径查找：{start} → {end}")
    print("=" * 60)

    # 最短路径
    shortest = kg.find_shortest_path(start, end)
    if shortest:
        print(f"\n【最短路径】")
        print(f"路径：{' → '.join(shortest)}")
        print(f"长度：{len(shortest) - 1}跳")
    else:
        print(f"\n【最短路径】未找到")

    # 所有路径
    all_paths = kg.find_all_paths(start, end, max_length=5)
    if all_paths:
        print(f"\n【所有路径】（共{len(all_paths)}条）")
        for i, path in enumerate(all_paths, 1):
            print(f"  路径{i}：{' → '.join(path)} ({len(path) - 1}跳)")


# ===== 9. 主函数 =====

def main():
    """主函数"""
    print("知识图谱遍历实战\n")

    # 连接Neo4j
    kg = Neo4jKG()

    try:
        # 清空数据库
        kg.clear_database()

        # 创建示例知识图谱
        print("\n【创建知识图谱】")
        triples = create_example_kg()
        kg.add_triples_batch(triples)

        # 统计信息
        stats = kg.get_statistics()
        print(f"\n图统计信息：")
        print(f"  实体数：{stats['num_entities']}")
        print(f"  关系数：{stats['num_relations']}")

        # 示例1：BFS遍历
        visualize_bfs(kg, "Einstein", max_hops=2)

        # 示例2：DFS遍历
        visualize_dfs(kg, "Einstein", max_depth=3)

        # 示例3：路径查找
        visualize_path_finding(kg, "Einstein", "GPS技术")
        visualize_path_finding(kg, "Einstein", "半导体技术")

        # 示例4：关系感知遍历
        print("\n" + "=" * 60)
        print("关系感知遍历")
        print("=" * 60)
        neighbors = kg.get_neighbors_with_relation("Einstein")
        print(f"\nEinstein的邻居：")
        for relation, neighbor in neighbors:
            print(f"  --[{relation}]--> {neighbor}")

    finally:
        kg.close()


if __name__ == "__main__":
    main()
```

---

## 运行输出示例

```
知识图谱遍历实战

✅ 数据库已清空

【创建知识图谱】
✅ 已添加16个三元组

图统计信息：
  实体数：15
  关系数：16

============================================================
BFS遍历：起点=Einstein, 最大跳数=2
============================================================

【Python实现】
遍历顺序：Einstein → 相对论 → 光电效应理论 → 诺贝尔奖 → 德国 → 时空弯曲 → GPS技术 → 经典力学 → 量子力学
访问节点数：9

【Cypher实现】
按距离分组：
  1跳：['相对论', '光电效应理论', '诺贝尔奖', '德国']
  2跳：['时空弯曲', 'GPS技术', '经典力学', '量子力学', '半导体技术']

============================================================
DFS遍历：起点=Einstein, 最大深度=3
============================================================

【Python实现】
找到5条路径：
  路径1：Einstein → 相对论 → 时空弯曲 → 引力波探测
  路径2：Einstein → 相对论 → GPS技术
  路径3：Einstein → 相对论 → 经典力学 → 宏观运动
  路径4：Einstein → 光电效应理论 → 量子力学 → 半导体技术
  路径5：Einstein → 光电效应理论 → 量子力学 → 相对论

【Cypher实现】
找到5条路径：
  路径1：Einstein → 相对论 → 时空弯曲 → 引力波探测
  路径2：Einstein → 相对论 → GPS技术
  路径3：Einstein → 光电效应理论 → 量子力学 → 半导体技术
  路径4：Einstein → 相对论 → 经典力学 → 宏观运动
  路径5：Einstein → 光电效应理论 → 量子力学 → 相对论

============================================================
路径查找：Einstein → GPS技术
============================================================

【最短路径】
路径：Einstein → 相对论 → GPS技术
长度：2跳

【所有路径】（共1条）
  路径1：Einstein → 相对论 → GPS技术 (2跳)

============================================================
路径查找：Einstein → 半导体技术
============================================================

【最短路径】
路径：Einstein → 光电效应理论 → 量子力学 → 半导体技术
长度：3跳

【所有路径】（共1条）
  路径1：Einstein → 光电效应理论 → 量子力学 → 半导体技术 (3跳)

============================================================
关系感知遍历
============================================================

Einstein的邻居：
  --[developed]--> 相对论
  --[developed]--> 光电效应理论
  --[won]--> 诺贝尔奖
  --[nationality]--> 德国
```

---

## 代码说明

### 1. Neo4j连接

使用`neo4j`库连接Neo4j数据库，支持Bolt协议。

### 2. 三元组存储

使用Cypher的`MERGE`语句确保实体和关系的唯一性。

### 3. BFS实现

- **Python版本**：手动实现队列遍历
- **Cypher版本**：使用`MATCH path = ()-[*1..n]-()`模式

### 4. DFS实现

- **Python版本**：递归实现，找所有路径
- **Cypher版本**：使用`MATCH path = ()-[*1..n]->()`模式

### 5. 路径查找

使用Cypher的`shortestPath()`函数查找最短路径。

---

## Cypher查询语言速查

### 基本模式

```cypher
// 匹配节点
MATCH (e:Entity {name: "Einstein"})

// 匹配关系
MATCH (e1)-[r:RELATION]->(e2)

// 匹配路径
MATCH path = (e1)-[*1..3]->(e2)

// 最短路径
MATCH path = shortestPath((e1)-[*]-(e2))
```

### 常用操作

```cypher
// 创建节点
CREATE (e:Entity {name: "Einstein"})

// 创建关系
CREATE (e1)-[r:RELATION {type: "developed"}]->(e2)

// 合并（不存在则创建）
MERGE (e:Entity {name: "Einstein"})

// 删除
DELETE e

// 删除节点及关系
DETACH DELETE e
```

---

## 学习检查

运行代码后，你应该能回答：

- [ ] 如何在Neo4j中存储三元组？
- [ ] Cypher的路径匹配语法是什么？
- [ ] Python实现和Cypher实现的区别？
- [ ] 如何查找最短路径？
- [ ] 如何遍历特定类型的关系？

---

## 扩展练习

1. **添加属性**：为实体和关系添加更多属性（如时间、置信度）
2. **关系过滤**：只遍历特定类型的关系（如因果关系）
3. **子图提取**：提取以某个实体为中心的子图
4. **图算法**：使用Neo4j的图算法库（PageRank、社区检测）

---

**版本：** v1.0
**最后更新：** 2026-02-14
**运行环境：** Python 3.13+ + Neo4j 5.x
**依赖：** `pip install neo4j`
