# 核心概念 06：队列优化策略

> **核心价值**: 队列优化策略通过优先级管理、批处理和去重机制，显著提升 AI Agent 的性能和响应速度，是构建高性能 Agent 系统的关键技术。

---

## 概述

消息队列的性能直接影响 Agent 的响应速度和用户体验。主要的优化策略包括：

1. **优先级队列**：Steering > User > Tool results，确保重要消息优先处理
2. **批处理**：并行执行独立的工具调用，减少总执行时间
3. **去重机制**：避免重复处理相同消息，节省资源
4. **性能监控**：实时监控队列状态，及时发现瓶颈

---

## 1. 优先级队列

### 1.1 优先级定义

```typescript
// 消息优先级（数字越小优先级越高）
export enum MessagePriority {
  CRITICAL = 0,   // Steering message（最高优先级）
  HIGH = 1,       // User message
  NORMAL = 2,     // Tool results
  LOW = 3         // Background tasks
}

// 优先级映射
const PRIORITY_MAP: Record<MessageType, MessagePriority> = {
  [MessageType.STEERING]: MessagePriority.CRITICAL,
  [MessageType.USER]: MessagePriority.HIGH,
  [MessageType.TOOL_RESULT]: MessagePriority.NORMAL,
  [MessageType.ASSISTANT]: MessagePriority.LOW
};
```

### 1.2 优先级队列实现

```typescript
/**
 * 优先级队列（基于堆实现）
 */
export class PriorityQueue<T extends { priority: number }> {
  private heap: T[] = [];

  /**
   * 入队
   */
  enqueue(item: T): void {
    this.heap.push(item);
    this.bubbleUp(this.heap.length - 1);
  }

  /**
   * 出队（返回优先级最高的元素）
   */
  dequeue(): T | null {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop()!;

    const top = this.heap[0];
    this.heap[0] = this.heap.pop()!;
    this.bubbleDown(0);

    return top;
  }

  /**
   * 查看队首元素
   */
  peek(): T | null {
    return this.heap.length > 0 ? this.heap[0] : null;
  }

  /**
   * 上浮操作
   */
  private bubbleUp(index: number): void {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);

      if (this.heap[index].priority >= this.heap[parentIndex].priority) {
        break;
      }

      [this.heap[index], this.heap[parentIndex]] =
        [this.heap[parentIndex], this.heap[index]];

      index = parentIndex;
    }
  }

  /**
   * 下沉操作
   */
  private bubbleDown(index: number): void {
    while (true) {
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;
      let smallest = index;

      if (
        leftChild < this.heap.length &&
        this.heap[leftChild].priority < this.heap[smallest].priority
      ) {
        smallest = leftChild;
      }

      if (
        rightChild < this.heap.length &&
        this.heap[rightChild].priority < this.heap[smallest].priority
      ) {
        smallest = rightChild;
      }

      if (smallest === index) break;

      [this.heap[index], this.heap[smallest]] =
        [this.heap[smallest], this.heap[index]];

      index = smallest;
    }
  }

  /**
   * 获取队列大小
   */
  size(): number {
    return this.heap.length;
  }

  /**
   * 检查队列是否为空
   */
  isEmpty(): boolean {
    return this.heap.length === 0;
  }
}
```

### 1.3 使用示例

```typescript
// 创建优先级队列
const queue = new PriorityQueue<Message>();

// 添加不同优先级的消息
queue.enqueue({
  id: 'msg-1',
  type: MessageType.TOOL_RESULT,
  priority: MessagePriority.NORMAL,
  content: 'Tool result'
});

queue.enqueue({
  id: 'msg-2',
  type: MessageType.STEERING,
  priority: MessagePriority.CRITICAL,
  content: 'Stop!'
});

queue.enqueue({
  id: 'msg-3',
  type: MessageType.USER,
  priority: MessagePriority.HIGH,
  content: 'Hello'
});

// 出队（按优先级顺序）
console.log(queue.dequeue()?.type); // 'steering' (CRITICAL)
console.log(queue.dequeue()?.type); // 'user' (HIGH)
console.log(queue.dequeue()?.type); // 'tool-result' (NORMAL)
```

### 1.4 TypeScript/Node.js 类比

**类比：Array.sort() 优先级排序**

```typescript
// 优先级队列类似于数组排序
const messages = [
  { id: 1, priority: 2 },
  { id: 2, priority: 0 },
  { id: 3, priority: 1 }
];

// 按优先级排序
messages.sort((a, b) => a.priority - b.priority);

console.log(messages);
// [{ id: 2, priority: 0 }, { id: 3, priority: 1 }, { id: 1, priority: 2 }]
```

### 1.5 日常生活类比

**类比：医院急诊室**

想象医院的急诊室：
- **危重病人**（Steering）= 最高优先级，立即处理
- **急诊病人**（User）= 高优先级
- **普通病人**（Tool results）= 普通优先级
- **体检病人**（Background）= 低优先级

---

## 2. 批处理优化

### 2.1 依赖分析

```typescript
/**
 * 工具调用依赖分析
 */
export class DependencyAnalyzer {
  /**
   * 分析工具调用之间的依赖关系
   */
  analyzeDependencies(toolCalls: ToolCall[]): ToolCallGroup[] {
    const groups: ToolCallGroup[] = [];
    const processed = new Set<string>();

    for (const toolCall of toolCalls) {
      if (processed.has(toolCall.id)) continue;

      // 查找依赖此工具的其他工具
      const dependents = this.findDependents(toolCall, toolCalls);

      // 创建工具组
      const group: ToolCallGroup = {
        root: toolCall,
        dependents,
        canParallel: dependents.length === 0
      };

      groups.push(group);

      // 标记为已处理
      processed.add(toolCall.id);
      dependents.forEach(d => processed.add(d.id));
    }

    return groups;
  }

  /**
   * 查找依赖指定工具的其他工具
   */
  private findDependents(
    toolCall: ToolCall,
    allToolCalls: ToolCall[]
  ): ToolCall[] {
    return allToolCalls.filter(other => {
      if (other.id === toolCall.id) return false;

      // 检查是否依赖此工具的输出
      return this.dependsOn(other, toolCall);
    });
  }

  /**
   * 检查工具 A 是否依赖工具 B
   */
  private dependsOn(toolA: ToolCall, toolB: ToolCall): boolean {
    // 简单实现：检查参数中是否引用了工具 B 的输出
    const argsStr = JSON.stringify(toolA.args);
    return argsStr.includes(`$${toolB.id}`);
  }
}

// 工具调用组
interface ToolCallGroup {
  root: ToolCall;
  dependents: ToolCall[];
  canParallel: boolean;
}
```

### 2.2 批处理执行

```typescript
/**
 * 批处理执行器
 */
export class BatchExecutor {
  /**
   * 批量执行工具调用
   */
  async executeBatch(toolCalls: ToolCall[]): Promise<ToolResult[]> {
    // 1. 分析依赖关系
    const analyzer = new DependencyAnalyzer();
    const groups = analyzer.analyzeDependencies(toolCalls);

    // 2. 按组执行
    const results: ToolResult[] = [];

    for (const group of groups) {
      if (group.canParallel) {
        // 并行执行
        const groupResults = await Promise.all([
          this.executeTool(group.root),
          ...group.dependents.map(t => this.executeTool(t))
        ]);
        results.push(...groupResults);
      } else {
        // 顺序执行
        const rootResult = await this.executeTool(group.root);
        results.push(rootResult);

        for (const dependent of group.dependents) {
          const result = await this.executeTool(dependent, rootResult);
          results.push(result);
        }
      }
    }

    return results;
  }

  /**
   * 执行单个工具
   */
  private async executeTool(
    toolCall: ToolCall,
    context?: ToolResult
  ): Promise<ToolResult> {
    // 执行工具逻辑
    console.log(`执行工具: ${toolCall.name}`);

    return {
      toolCallId: toolCall.id,
      result: `Result of ${toolCall.name}`,
      timestamp: Date.now()
    };
  }
}
```

### 2.3 性能对比

```typescript
// 场景：执行 3 个独立的工具调用，每个耗时 1 秒

// 顺序执行
async function sequential() {
  await tool1(); // 1s
  await tool2(); // 1s
  await tool3(); // 1s
  // 总耗时: 3s
}

// 批处理（并行执行）
async function batch() {
  await Promise.all([
    tool1(), // 1s
    tool2(), // 1s
    tool3()  // 1s
  ]);
  // 总耗时: 1s
}

// 性能提升: 3s / 1s = 3x
```

### 2.4 TypeScript/Node.js 类比

**类比：Promise.all() 并行执行**

```typescript
// 批处理类似于 Promise.all()
const results = await Promise.all([
  fetchData1(),
  fetchData2(),
  fetchData3()
]);

// vs 顺序执行
const result1 = await fetchData1();
const result2 = await fetchData2();
const result3 = await fetchData3();
```

### 2.5 日常生活类比

**类比：餐厅厨房**

想象餐厅的厨房：
- **顺序执行** = 一个厨师做完一道菜再做下一道
- **批处理** = 多个厨师同时做不同的菜

---

## 3. 去重机制

### 3.1 去重策略

```typescript
/**
 * 消息去重器
 */
export class MessageDeduplicator {
  private processedIds = new Set<string>();
  private contentHashes = new Map<string, string>();

  /**
   * 检查消息是否重复
   */
  isDuplicate(message: Message): boolean {
    // 策略 1：基于 ID 去重
    if (this.processedIds.has(message.id)) {
      return true;
    }

    // 策略 2：基于内容哈希去重
    const contentHash = this.hashContent(message.content);
    if (this.contentHashes.has(contentHash)) {
      return true;
    }

    return false;
  }

  /**
   * 标记消息为已处理
   */
  markProcessed(message: Message): void {
    this.processedIds.add(message.id);

    const contentHash = this.hashContent(message.content);
    this.contentHashes.set(contentHash, message.id);
  }

  /**
   * 计算内容哈希
   */
  private hashContent(content: string): string {
    // 简单哈希实现（生产环境应使用更强的哈希算法）
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return hash.toString(36);
  }

  /**
   * 清理过期记录
   */
  cleanup(maxAge: number = 3600000): void {
    // 清理 1 小时前的记录
    // 实际实现需要记录时间戳
  }
}
```

### 3.2 使用示例

```typescript
// 创建去重器
const deduplicator = new MessageDeduplicator();

// 处理消息
function processMessage(message: Message): void {
  // 检查是否重复
  if (deduplicator.isDuplicate(message)) {
    console.log(`消息 ${message.id} 已处理，跳过`);
    return;
  }

  // 处理消息
  console.log(`处理消息: ${message.id}`);

  // 标记为已处理
  deduplicator.markProcessed(message);
}

// 测试
const msg1 = { id: 'msg-1', content: 'Hello' };
const msg2 = { id: 'msg-1', content: 'Hello' }; // 重复 ID

processMessage(msg1); // 处理
processMessage(msg2); // 跳过（重复）
```

### 3.3 TypeScript/Node.js 类比

**类比：Set 去重**

```typescript
// 去重类似于 Set
const ids = new Set<string>();

function addMessage(id: string): boolean {
  if (ids.has(id)) {
    return false; // 重复
  }
  ids.add(id);
  return true; // 新消息
}
```

### 3.4 日常生活类比

**类比：签到表**

想象会议签到表：
- **去重** = 检查签到表，避免重复签到
- **标记已处理** = 在签到表上打勾

---

## 4. 性能监控

### 4.1 性能指标

```typescript
/**
 * 队列性能监控
 */
export class QueueMetrics {
  private metrics = {
    enqueueCount: 0,
    dequeueCount: 0,
    processingTime: [] as number[],
    queueSize: [] as number[],
    errorCount: 0,
    duplicateCount: 0
  };

  /**
   * 记录入队
   */
  recordEnqueue(): void {
    this.metrics.enqueueCount++;
  }

  /**
   * 记录出队
   */
  recordDequeue(processingTime: number): void {
    this.metrics.dequeueCount++;
    this.metrics.processingTime.push(processingTime);
  }

  /**
   * 记录队列大小
   */
  recordQueueSize(size: number): void {
    this.metrics.queueSize.push(size);
  }

  /**
   * 记录错误
   */
  recordError(): void {
    this.metrics.errorCount++;
  }

  /**
   * 记录重复消息
   */
  recordDuplicate(): void {
    this.metrics.duplicateCount++;
  }

  /**
   * 获取性能报告
   */
  getReport(): PerformanceReport {
    return {
      totalEnqueued: this.metrics.enqueueCount,
      totalDequeued: this.metrics.dequeueCount,
      avgProcessingTime: this.average(this.metrics.processingTime),
      avgQueueSize: this.average(this.metrics.queueSize),
      maxQueueSize: Math.max(...this.metrics.queueSize),
      errorRate: this.metrics.errorCount / this.metrics.dequeueCount,
      duplicateRate: this.metrics.duplicateCount / this.metrics.enqueueCount
    };
  }

  /**
   * 计算平均值
   */
  private average(values: number[]): number {
    if (values.length === 0) return 0;
    return values.reduce((a, b) => a + b, 0) / values.length;
  }
}

// 性能报告
interface PerformanceReport {
  totalEnqueued: number;
  totalDequeued: number;
  avgProcessingTime: number;
  avgQueueSize: number;
  maxQueueSize: number;
  errorRate: number;
  duplicateRate: number;
}
```

### 4.2 实时监控

```typescript
/**
 * 实时监控器
 */
export class QueueMonitor {
  private metrics: QueueMetrics;
  private alertThresholds = {
    maxQueueSize: 100,
    maxProcessingTime: 5000,
    maxErrorRate: 0.1
  };

  constructor(metrics: QueueMetrics) {
    this.metrics = metrics;
  }

  /**
   * 检查性能指标
   */
  checkMetrics(): Alert[] {
    const report = this.metrics.getReport();
    const alerts: Alert[] = [];

    // 检查队列大小
    if (report.maxQueueSize > this.alertThresholds.maxQueueSize) {
      alerts.push({
        level: 'warning',
        message: `队列大小超过阈值: ${report.maxQueueSize}`
      });
    }

    // 检查处理时间
    if (report.avgProcessingTime > this.alertThresholds.maxProcessingTime) {
      alerts.push({
        level: 'warning',
        message: `平均处理时间过长: ${report.avgProcessingTime}ms`
      });
    }

    // 检查错误率
    if (report.errorRate > this.alertThresholds.maxErrorRate) {
      alerts.push({
        level: 'error',
        message: `错误率过高: ${(report.errorRate * 100).toFixed(2)}%`
      });
    }

    return alerts;
  }
}

// 告警
interface Alert {
  level: 'info' | 'warning' | 'error';
  message: string;
}
```

---

## 5. 综合优化示例

### 5.1 优化后的消息队列

```typescript
/**
 * 优化后的消息队列
 */
export class OptimizedMessageQueue {
  private queue: PriorityQueue<Message>;
  private deduplicator: MessageDeduplicator;
  private batchExecutor: BatchExecutor;
  private metrics: QueueMetrics;
  private monitor: QueueMonitor;

  constructor() {
    this.queue = new PriorityQueue();
    this.deduplicator = new MessageDeduplicator();
    this.batchExecutor = new BatchExecutor();
    this.metrics = new QueueMetrics();
    this.monitor = new QueueMonitor(this.metrics);
  }

  /**
   * 入队（带去重）
   */
  enqueue(message: Message): boolean {
    // 1. 去重检查
    if (this.deduplicator.isDuplicate(message)) {
      this.metrics.recordDuplicate();
      return false;
    }

    // 2. 入队
    this.queue.enqueue(message);
    this.metrics.recordEnqueue();
    this.metrics.recordQueueSize(this.queue.size());

    // 3. 标记已处理
    this.deduplicator.markProcessed(message);

    return true;
  }

  /**
   * 出队并处理
   */
  async dequeueAndProcess(): Promise<void> {
    const startTime = Date.now();

    // 1. 出队
    const message = this.queue.dequeue();
    if (!message) return;

    try {
      // 2. 处理消息
      await this.processMessage(message);

      // 3. 记录性能
      const processingTime = Date.now() - startTime;
      this.metrics.recordDequeue(processingTime);
    } catch (error) {
      this.metrics.recordError();
      throw error;
    }
  }

  /**
   * 批量处理工具调用
   */
  async processBatch(toolCalls: ToolCall[]): Promise<ToolResult[]> {
    return this.batchExecutor.executeBatch(toolCalls);
  }

  /**
   * 获取性能报告
   */
  getPerformanceReport(): PerformanceReport {
    return this.metrics.getReport();
  }

  /**
   * 检查告警
   */
  checkAlerts(): Alert[] {
    return this.monitor.checkMetrics();
  }

  /**
   * 处理消息
   */
  private async processMessage(message: Message): Promise<void> {
    console.log(`处理消息: ${message.id} (${message.type})`);
    // 实际处理逻辑
  }
}
```

### 5.2 使用示例

```typescript
// 创建优化后的队列
const queue = new OptimizedMessageQueue();

// 添加消息
queue.enqueue({
  id: 'msg-1',
  type: MessageType.USER,
  priority: MessagePriority.HIGH,
  content: 'Hello'
});

queue.enqueue({
  id: 'msg-1', // 重复 ID
  type: MessageType.USER,
  priority: MessagePriority.HIGH,
  content: 'Hello'
}); // 自动去重

// 处理消息
await queue.dequeueAndProcess();

// 批量处理工具调用
const toolCalls = [
  { id: 'tool-1', name: 'readFile', args: { path: 'file1.txt' } },
  { id: 'tool-2', name: 'readFile', args: { path: 'file2.txt' } },
  { id: 'tool-3', name: 'readFile', args: { path: 'file3.txt' } }
];

const results = await queue.processBatch(toolCalls);

// 获取性能报告
const report = queue.getPerformanceReport();
console.log('性能报告:', report);

// 检查告警
const alerts = queue.checkAlerts();
if (alerts.length > 0) {
  console.log('告警:', alerts);
}
```

---

## 6. 最佳实践

### 6.1 合理设置优先级

```typescript
// 推荐：根据消息类型自动分配优先级
function assignPriority(message: Message): MessagePriority {
  switch (message.type) {
    case MessageType.STEERING:
      return MessagePriority.CRITICAL;
    case MessageType.USER:
      return MessagePriority.HIGH;
    case MessageType.TOOL_RESULT:
      return MessagePriority.NORMAL;
    default:
      return MessagePriority.LOW;
  }
}
```

### 6.2 定期清理去重记录

```typescript
// 推荐：定期清理过期的去重记录
setInterval(() => {
  deduplicator.cleanup(3600000); // 清理 1 小时前的记录
}, 600000); // 每 10 分钟清理一次
```

### 6.3 监控性能指标

```typescript
// 推荐：定期检查性能指标
setInterval(() => {
  const alerts = monitor.checkMetrics();
  if (alerts.length > 0) {
    console.warn('性能告警:', alerts);
  }
}, 60000); // 每分钟检查一次
```

---

## 7. 总结

### 7.1 核心要点

1. **优先级队列**：Steering (0) > User (1) > Tool results (2) > Background (3)
2. **批处理**：并行执行独立工具，性能提升 2-3x
3. **去重机制**：基于 ID 和内容哈希去重，避免重复处理
4. **性能监控**：实时监控队列状态，及时发现瓶颈
5. **综合优化**：结合多种策略，构建高性能队列

### 7.2 TypeScript/Node.js 类比

- **优先级队列** = Array.sort() 优先级排序
- **批处理** = Promise.all() 并行执行
- **去重** = Set 去重

### 7.3 日常生活类比

- **优先级队列** = 医院急诊室（按病情轻重排序）
- **批处理** = 餐厅厨房（多个厨师同时做菜）
- **去重** = 会议签到表（避免重复签到）

### 7.4 性能提升

- **优先级队列**：确保重要消息优先处理
- **批处理**：性能提升 2-3x（独立工具并行执行）
- **去重**：节省 10-20% 资源（避免重复处理）
- **综合优化**：整体性能提升 3-5x

### 7.5 学习检查

- [ ] 理解优先级队列的实现原理
- [ ] 理解批处理的依赖分析和并行执行
- [ ] 理解去重机制的策略
- [ ] 理解性能监控的指标和告警
- [ ] 能够设计和实现优化后的消息队列

### 7.6 下一步

- **02_第一性原理.md**：深入理解消息队列的第一性原理
- **07_实战代码_01_基础消息队列.md**：手写完整的消息队列实现
- **07_实战代码_06_优先级队列.md**：手写优先级队列实现
- **07_实战代码_07_批处理优化.md**：手写批处理优化实现

---

**版本**: v1.0
**最后更新**: 2026-02-19
**维护者**: Claude Code
