# 最小可用

掌握以下内容，就能开始使用 LCEL 的错误处理与重试：

---

## 4.1 基础重试：with_retry()

**一句话：** 当操作失败时，自动重试指定次数

```python
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(model="gpt-4")

# 添加重试：最多重试 3 次
llm_with_retry = llm.with_retry(stop_after_attempt=3)

# 使用
response = llm_with_retry.invoke("你好")
```

**实际应用：**
- 处理 API 速率限制
- 处理临时网络故障
- 处理服务器短暂过载

**这个知识足以：** 让你的 AI 应用在面对临时故障时不会立即崩溃

---

## 4.2 指数退避：wait_exponential

**一句话：** 每次重试等待时间翻倍，避免频繁请求

```python
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(model="gpt-4")

# 指数退避重试
# 第1次失败：等待 1 秒
# 第2次失败：等待 2 秒
# 第3次失败：等待 4 秒
llm_with_retry = llm.with_retry(
    stop_after_attempt=3,
    wait_exponential_jitter=True  # 添加随机抖动
)
```

**为什么需要指数退避？**
- 避免"雪崩效应"（所有客户端同时重试）
- 给服务器恢复时间
- 符合大多数 API 的最佳实践

**实际应用：**
- OpenAI API 速率限制恢复
- 数据库连接池耗尽后的恢复
- 微服务间的容错通信

---

## 4.3 基础降级：with_fallbacks()

**一句话：** 当主方案失败时，自动切换到备选方案

```python
from langchain_openai import ChatOpenAI

# 主模型
primary_llm = ChatOpenAI(model="gpt-4")

# 备选模型（更便宜、更稳定）
fallback_llm = ChatOpenAI(model="gpt-3.5-turbo")

# 添加降级
llm_with_fallback = primary_llm.with_fallbacks([fallback_llm])

# 使用：GPT-4 失败时自动切换到 GPT-3.5
response = llm_with_fallback.invoke("你好")
```

**实际应用：**
- 主模型不可用时的备选方案
- 成本优化（先试便宜的，失败再用贵的）
- 多模型对比和 A/B 测试

**这个知识足以：** 让你的应用在主服务不可用时仍能提供服务

---

## 4.4 组合使用：重试 + 降级

**一句话：** 先重试主方案，失败后降级到备选方案

```python
from langchain_openai import ChatOpenAI

# 主模型 + 重试
primary_llm = ChatOpenAI(model="gpt-4").with_retry(stop_after_attempt=3)

# 备选模型 + 重试
fallback_llm = ChatOpenAI(model="gpt-3.5-turbo").with_retry(stop_after_attempt=2)

# 组合：先重试 GPT-4，失败后降级到 GPT-3.5
llm = primary_llm.with_fallbacks([fallback_llm])

# 执行流程：
# 1. 尝试 GPT-4（最多 3 次）
# 2. 如果仍失败，尝试 GPT-3.5（最多 2 次）
# 3. 如果仍失败，抛出异常
response = llm.invoke("你好")
```

**实际应用：**
- 生产级 AI 应用的标准配置
- 平衡可靠性和成本
- 多云部署的容错策略

---

## 4.5 异常类型过滤：retry_if_exception_type

**一句话：** 只对特定类型的错误进行重试

```python
from langchain_openai import ChatOpenAI
from openai import RateLimitError, APIError

llm = ChatOpenAI(model="gpt-4")

# 只对速率限制和 API 错误重试
llm_with_retry = llm.with_retry(
    stop_after_attempt=3,
    retry_if_exception_type=(RateLimitError, APIError)
)

# 其他错误（如 AuthenticationError）不会重试，直接抛出
```

**为什么需要过滤？**
- 有些错误重试无意义（如 API key 错误）
- 避免浪费时间和资源
- 快速失败，快速反馈

**常见的可重试错误：**
- `RateLimitError`：速率限制
- `APIError`：API 服务器错误
- `Timeout`：超时
- `ConnectionError`：网络连接错误

**常见的不可重试错误：**
- `AuthenticationError`：认证错误（API key 错误）
- `InvalidRequestError`：请求参数错误
- `NotFoundError`：资源不存在

---

## 快速参考：何时使用什么策略

### 使用重试（Retry）的场景

✅ **临时故障**
- 速率限制（Rate Limit）
- 网络超时（Timeout）
- 服务器临时过载（503）

✅ **可恢复的错误**
- 连接重置（Connection Reset）
- 读取超时（Read Timeout）
- 临时的 API 错误（5xx）

### 使用降级（Fallback）的场景

✅ **永久故障**
- 服务完全不可用
- API 版本不兼容
- 模型不支持某些功能

✅ **成本优化**
- 先试便宜的模型
- 失败再用贵的模型

✅ **多模型策略**
- A/B 测试
- 模型对比
- 多云部署

### 组合使用的场景

✅ **生产级应用**
- 需要高可用性
- 需要成本优化
- 需要多层防护

---

## 最小可用代码模板

### 模板1：基础重试

```python
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(model="gpt-4").with_retry(
    stop_after_attempt=3,
    wait_exponential_jitter=True
)
```

### 模板2：基础降级

```python
from langchain_openai import ChatOpenAI

primary = ChatOpenAI(model="gpt-4")
fallback = ChatOpenAI(model="gpt-3.5-turbo")

llm = primary.with_fallbacks([fallback])
```

### 模板3：生产级组合

```python
from langchain_openai import ChatOpenAI
from openai import RateLimitError, APIError

# 主模型 + 智能重试
primary = ChatOpenAI(model="gpt-4").with_retry(
    stop_after_attempt=3,
    wait_exponential_jitter=True,
    retry_if_exception_type=(RateLimitError, APIError)
)

# 备选模型 + 基础重试
fallback = ChatOpenAI(model="gpt-3.5-turbo").with_retry(
    stop_after_attempt=2
)

# 组合
llm = primary.with_fallbacks([fallback])
```

---

## 这些知识足以

掌握以上内容，你就能：

1. ✅ **处理 API 速率限制**
   - 自动重试，不需要手动处理

2. ✅ **构建可靠的 AI 应用**
   - 临时故障不会导致应用崩溃

3. ✅ **实现成本优化**
   - 先试便宜的模型，失败再用贵的

4. ✅ **为生产环境做准备**
   - 多层防护，高可用性

5. ✅ **为后续学习打基础**
   - 理解了基础，可以学习更高级的策略（断路器、自愈 Agent）

---

## 下一步学习

掌握了最小可用知识后，可以继续学习：

1. **高级重试策略**
   - 自定义重试条件
   - 重试回调和日志
   - 断路器模式

2. **多级降级**
   - 3 层以上的降级链
   - 动态降级策略
   - 成本感知的降级

3. **LangGraph 错误处理**
   - 节点级重试
   - 图级异常处理
   - 状态管理与错误

4. **生产级实践**
   - 监控和告警
   - 自愈 Agent
   - 综合案例

---

**记住：错误处理不是"锦上添花"，而是生产级应用的"必需品"。**
