# 实战代码：引用溯源

> 完整可运行的引用溯源示例，演示如何为 RAG 系统添加引用追踪功能

---

## 场景说明

**目标：** 构建一个完整的引用溯源系统，为每个生成的事实标注来源

**应用场景：**
- 学术问答系统
- 法律文档分析
- 医疗信息检索
- 任何需要可验证性的场景

**技术栈：**
- `openai`：LLM 生成
- `sentence-transformers`：语义相似度计算
- `re`：正则表达式提取引用

---

## 完整代码

```python
"""
引用溯源实战示例
演示：如何为 RAG 系统添加引用追踪功能
"""

from openai import OpenAI
from sentence_transformers import SentenceTransformer, util
import os
import re
from typing import List, Dict, Tuple
import json

# ===== 配置 =====
class Config:
    """配置类"""
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    OPENAI_BASE_URL = os.getenv("OPENAI_BASE_URL", "https://api.openai.com/v1")
    EMBEDDING_MODEL = "all-MiniLM-L6-v2"


# ===== 引用溯源系统 =====
class CitationSystem:
    """
    引用溯源系统
    支持 Prompt 工程和后处理两种方式
    """

    def __init__(self):
        """初始化引用系统"""
        print("[初始化] 引用溯源系统")
        self.client = OpenAI(
            api_key=Config.OPENAI_API_KEY,
            base_url=Config.OPENAI_BASE_URL
        )
        self.encoder = SentenceTransformer(Config.EMBEDDING_MODEL)
        print("[初始化] ✓ 系统初始化完成\n")

    def generate_with_citations_prompt(
        self,
        query: str,
        docs: List[Dict[str, str]],
        model: str = "gpt-4"
    ) -> str:
        """
        方法1：使用 Prompt 工程生成带引用的答案

        Args:
            query: 用户查询
            docs: 文档列表，每个文档包含 'content' 和 'title'
            model: LLM 模型

        Returns:
            带引用的答案
        """
        # 构建带编号的文档
        numbered_docs = ""
        for i, doc in enumerate(docs):
            numbered_docs += f"\n文档{i+1}：{doc['content']}\n"

        # 构建 Prompt
        prompt = f"""基于以下文档回答问题，并用 [1], [2] 等标注引用来源。

{numbered_docs}

问题：{query}

要求：
1. 每个事实性陈述都要标注来源，格式为 [数字]
2. 不要添加文档中没有的信息
3. 如果文档中没有答案，明确说明

示例：
问题：Python 3.9 什么时候发布？
文档1：Python 3.9 于 2020 年 10 月发布
答案：Python 3.9 于 2020 年 10 月发布 [1]

现在请回答："""

        # 调用 LLM
        response = self.client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )

        answer = response.choices[0].message.content

        # 添加来源详情
        answer += "\n\n来源详情：\n"
        for i, doc in enumerate(docs):
            title = doc.get('title', f'文档{i+1}')
            url = doc.get('url', '')
            answer += f"[{i+1}] {title}"
            if url:
                answer += f"\n     {url}"
            answer += "\n"

        return answer

    def add_citations_post_processing(
        self,
        answer: str,
        docs: List[Dict[str, str]],
        threshold: float = 0.5
    ) -> str:
        """
        方法2：后处理添加引用

        Args:
            answer: 生成的答案（无引用）
            docs: 文档列表
            threshold: 相似度阈值

        Returns:
            带引用的答案
        """
        # 1. 拆分句子
        sentences = [s.strip() + '。' for s in answer.split('。') if s.strip()]

        # 2. 编码句子和文档
        sentence_embeddings = self.encoder.encode(sentences)
        doc_embeddings = self.encoder.encode([doc['content'] for doc in docs])

        # 3. 为每个句子找到最匹配的文档
        cited_answer = ""
        for i, sentence in enumerate(sentences):
            # 计算相似度
            similarities = util.cos_sim(
                sentence_embeddings[i],
                doc_embeddings
            )[0].numpy()

            # 找到最相似的文档
            best_doc_idx = int(similarities.argmax())
            best_similarity = float(similarities[best_doc_idx])

            # 如果相似度超过阈值，添加引用
            if best_similarity >= threshold:
                cited_answer += f"{sentence} [{best_doc_idx + 1}]\n"
            else:
                cited_answer += f"{sentence}\n"

        # 4. 添加来源列表
        cited_answer += "\n来源：\n"
        for i, doc in enumerate(docs):
            title = doc.get('title', f'文档{i+1}')
            cited_answer += f"[{i + 1}] {title}\n"

        return cited_answer

    def extract_citations(self, answer: str) -> List[int]:
        """
        提取答案中的引用编号

        Args:
            answer: 带引用的答案

        Returns:
            引用编号列表
        """
        citations = re.findall(r'\[(\d+)\]', answer)
        return [int(c) for c in citations]

    def verify_citations(
        self,
        answer: str,
        docs: List[Dict[str, str]]
    ) -> Dict[str, any]:
        """
        验证引用的有效性

        Args:
            answer: 带引用的答案
            docs: 文档列表

        Returns:
            验证结果
        """
        citations = self.extract_citations(answer)

        # 检查引用是否有效
        invalid_citations = [c for c in citations if c > len(docs) or c < 1]

        # 检查是否有未使用的文档
        used_docs = set(citations)
        unused_docs = set(range(1, len(docs) + 1)) - used_docs

        # 检查引用覆盖率
        sentences = [s.strip() for s in answer.split('。') if s.strip()]
        sentences_with_citations = [s for s in sentences if re.search(r'\[\d+\]', s)]
        citation_coverage = len(sentences_with_citations) / len(sentences) if sentences else 0

        return {
            "valid": len(invalid_citations) == 0,
            "invalid_citations": invalid_citations,
            "unused_docs": list(unused_docs),
            "citation_count": len(set(citations)),
            "citation_coverage": citation_coverage,
            "total_sentences": len(sentences),
            "cited_sentences": len(sentences_with_citations)
        }

    def verify_citation_consistency(
        self,
        answer: str,
        docs: List[Dict[str, str]]
    ) -> List[Dict[str, any]]:
        """
        验证引用内容的一致性

        Args:
            answer: 带引用的答案
            docs: 文档列表

        Returns:
            每个引用的一致性验证结果
        """
        from sentence_transformers import CrossEncoder

        # 加载 NLI 模型
        nli_model = CrossEncoder('cross-encoder/nli-deberta-v3-base')

        # 提取每个引用对应的句子
        sentences_with_citations = re.findall(r'([^。]+\[(\d+)\])', answer)

        results = []
        for sentence_with_citation, citation_num in sentences_with_citations:
            citation_num = int(citation_num)

            # 移除引用标记
            sentence = re.sub(r'\[\d+\]', '', sentence_with_citation).strip()

            # 获取引用的文档
            if 1 <= citation_num <= len(docs):
                cited_doc = docs[citation_num - 1]['content']

                # 使用 NLI 检查一致性
                scores = nli_model.predict([(cited_doc, sentence)])
                entailment_score = float(scores[0][2])

                results.append({
                    'sentence': sentence,
                    'citation': citation_num,
                    'cited_doc': cited_doc,
                    'entailment_score': entailment_score,
                    'is_consistent': entailment_score >= 0.7
                })

        return results


# ===== 完整的 RAG 系统（带引用）=====
class RAGWithCitations:
    """
    带引用的 RAG 系统
    """

    def __init__(self):
        """初始化 RAG 系统"""
        self.citation_system = CitationSystem()

    def process(
        self,
        query: str,
        docs: List[Dict[str, str]],
        method: str = "prompt"
    ) -> Dict[str, any]:
        """
        处理查询并生成带引用的答案

        Args:
            query: 用户查询
            docs: 文档列表
            method: 引用方法 ('prompt' 或 'post_processing')

        Returns:
            包含答案和验证结果的字典
        """
        print(f"[查询] {query}")
        print(f"[检索] 找到 {len(docs)} 个文档")
        print(f"[方法] 使用 {method} 方法\n")

        # 生成带引用的答案
        if method == "prompt":
            print("[生成] 使用 Prompt 工程生成带引用的答案...")
            answer = self.citation_system.generate_with_citations_prompt(query, docs)
        else:
            print("[生成] 先生成答案，再后处理添加引用...")
            # 先生成无引用的答案
            plain_answer = self.citation_system.client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": f"基于以下文档回答问题：\n\n{docs}\n\n问题：{query}"}],
                temperature=0.3
            ).choices[0].message.content

            # 后处理添加引用
            answer = self.citation_system.add_citations_post_processing(plain_answer, docs)

        print("[生成] ✓ 答案生成完成\n")

        # 验证引用
        print("[验证] 正在验证引用...")
        verification = self.citation_system.verify_citations(answer, docs)
        print(f"[验证] ✓ 引用验证完成\n")

        # 验证引用一致性
        print("[验证] 正在验证引用内容的一致性...")
        consistency_results = self.citation_system.verify_citation_consistency(answer, docs)
        print(f"[验证] ✓ 一致性验证完成\n")

        return {
            'query': query,
            'answer': answer,
            'verification': verification,
            'consistency_results': consistency_results,
            'method': method
        }


# ===== 测试用例 =====
def test_case_1_prompt_method():
    """
    测试用例1：使用 Prompt 工程方法
    """
    print("=" * 60)
    print("测试用例1：Prompt 工程方法")
    print("=" * 60 + "\n")

    docs = [
        {
            "content": "Python 3.9 于 2020 年 10 月 5 日正式发布。",
            "title": "Python 3.9 发布公告",
            "url": "https://www.python.org/downloads/release/python-390/"
        },
        {
            "content": "Python 3.9 新增了字典合并运算符 |，可以方便地合并两个字典。",
            "title": "PEP 584 - 字典合并运算符",
            "url": "https://peps.python.org/pep-0584/"
        },
        {
            "content": "Python 3.9 改进了类型提示功能，支持使用内置集合类型作为泛型。",
            "title": "PEP 585 - 类型提示泛型",
            "url": "https://peps.python.org/pep-0585/"
        }
    ]

    query = "Python 3.9 有什么新特性？"

    rag = RAGWithCitations()
    result = rag.process(query, docs, method="prompt")

    print_result(result)


def test_case_2_post_processing():
    """
    测试用例2：使用后处理方法
    """
    print("\n" + "=" * 60)
    print("测试用例2：后处理方法")
    print("=" * 60 + "\n")

    docs = [
        {
            "content": "Python 3.9 于 2020 年 10 月 5 日发布。",
            "title": "Python 官方文档"
        },
        {
            "content": "Python 3.9 新增了字典合并运算符。",
            "title": "新特性说明"
        }
    ]

    query = "Python 3.9 什么时候发布？有什么新特性？"

    rag = RAGWithCitations()
    result = rag.process(query, docs, method="post_processing")

    print_result(result)


def test_case_3_citation_verification():
    """
    测试用例3：引用验证
    """
    print("\n" + "=" * 60)
    print("测试用例3：引用验证")
    print("=" * 60 + "\n")

    citation_system = CitationSystem()

    # 模拟一个带引用的答案
    answer = """
Python 3.9 于 2020 年 10 月发布 [1]。
新增了字典合并运算符 [2]。
改进了类型提示功能 [3]。
这是一个重要的版本更新 [5]。
"""

    docs = [
        {"content": "Python 3.9 于 2020 年 10 月发布", "title": "文档1"},
        {"content": "新增了字典合并运算符", "title": "文档2"},
        {"content": "改进了类型提示功能", "title": "文档3"}
    ]

    print(f"[答案]\n{answer}\n")

    # 验证引用
    verification = citation_system.verify_citations(answer, docs)

    print("[验证结果]")
    print(f"  引用有效: {verification['valid']}")
    print(f"  引用数量: {verification['citation_count']}")
    print(f"  引用覆盖率: {verification['citation_coverage']:.0%}")
    print(f"  总句子数: {verification['total_sentences']}")
    print(f"  已引用句子数: {verification['cited_sentences']}")

    if verification['invalid_citations']:
        print(f"  ✗ 无效引用: {verification['invalid_citations']}")

    if verification['unused_docs']:
        print(f"  ⚠ 未使用的文档: {verification['unused_docs']}")


# ===== 工具函数 =====
def print_result(result: Dict[str, any]):
    """
    打印结果

    Args:
        result: 处理结果
    """
    print("[最终结果]")
    print("=" * 60)
    print(f"方法: {result['method']}")
    print(f"\n答案:\n{result['answer']}")

    print(f"\n引用验证:")
    v = result['verification']
    print(f"  引用有效: {v['valid']}")
    print(f"  引用数量: {v['citation_count']}")
    print(f"  引用覆盖率: {v['citation_coverage']:.0%}")

    if v['invalid_citations']:
        print(f"  ✗ 无效引用: {v['invalid_citations']}")

    if v['unused_docs']:
        print(f"  ⚠ 未使用的文档: {v['unused_docs']}")

    print(f"\n引用一致性:")
    for i, cr in enumerate(result['consistency_results'], 1):
        status = "✓" if cr['is_consistent'] else "✗"
        print(f"  {status} 引用[{cr['citation']}]: {cr['sentence'][:50]}...")
        print(f"     一致性分数: {cr['entailment_score']:.2f}")

    print("=" * 60)


# ===== 主函数 =====
def main():
    """
    主函数：运行所有测试用例
    """
    print("\n" + "=" * 60)
    print("引用溯源实战示例")
    print("=" * 60 + "\n")

    # 检查环境变量
    if not Config.OPENAI_API_KEY:
        print("错误：未设置 OPENAI_API_KEY 环境变量")
        print("请运行：export OPENAI_API_KEY='your-api-key'")
        return

    try:
        # 测试用例1：Prompt 工程方法
        test_case_1_prompt_method()

        # 测试用例2：后处理方法
        # test_case_2_post_processing()

        # 测试用例3：引用验证
        test_case_3_citation_verification()

    except Exception as e:
        print(f"\n[错误] {str(e)}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
```

---

## 运行说明

### 1. 安装依赖

```bash
pip install openai sentence-transformers
```

### 2. 设置环境变量

```bash
export OPENAI_API_KEY='your-api-key-here'
```

### 3. 运行代码

```bash
python 10_实战代码_引用溯源.py
```

---

## 预期输出

```
============================================================
引用溯源实战示例
============================================================

[初始化] 引用溯源系统
[初始化] ✓ 系统初始化完成

============================================================
测试用例1：Prompt 工程方法
============================================================

[查询] Python 3.9 有什么新特性？
[检索] 找到 3 个文档
[方法] 使用 prompt 方法

[生成] 使用 Prompt 工程生成带引用的答案...
[生成] ✓ 答案生成完成

[验证] 正在验证引用...
[验证] ✓ 引用验证完成

[验证] 正在验证引用内容的一致性...
[验证] ✓ 一致性验证完成

[最终结果]
============================================================
方法: prompt

答案:
Python 3.9 于 2020 年 10 月 5 日正式发布 [1]。主要新特性包括：新增了字典合并运算符 | [2]，可以方便地合并两个字典；改进了类型提示功能 [3]，支持使用内置集合类型作为泛型。

来源详情：
[1] Python 3.9 发布公告
     https://www.python.org/downloads/release/python-390/
[2] PEP 584 - 字典合并运算符
     https://peps.python.org/pep-0584/
[3] PEP 585 - 类型提示泛型
     https://peps.python.org/pep-0585/

引用验证:
  引用有效: True
  引用数量: 3
  引用覆盖率: 100%

引用一致性:
  ✓ 引用[1]: Python 3.9 于 2020 年 10 月 5 日正式发布
     一致性分数: 0.92
  ✓ 引用[2]: 新增了字典合并运算符 |，可以方便地合并两个字典
     一致性分数: 0.88
  ✓ 引用[3]: 改进了类型提示功能，支持使用内置集合类型作为泛型
     一致性分数: 0.95
============================================================

============================================================
测试用例3：引用验证
============================================================

[答案]

Python 3.9 于 2020 年 10 月发布 [1]。
新增了字典合并运算符 [2]。
改进了类型提示功能 [3]。
这是一个重要的版本更新 [5]。


[验证结果]
  引用有效: False
  引用数量: 4
  引用覆盖率: 100%
  总句子数: 4
  已引用句子数: 4
  ✗ 无效引用: [5]
```

---

## 代码说明

### 核心组件

#### 1. CitationSystem

**功能：** 引用溯源的核心系统

**关键方法：**
- `generate_with_citations_prompt()`: 使用 Prompt 工程生成带引用的答案
- `add_citations_post_processing()`: 后处理添加引用
- `extract_citations()`: 提取引用编号
- `verify_citations()`: 验证引用有效性
- `verify_citation_consistency()`: 验证引用内容一致性

#### 2. RAGWithCitations

**功能：** 完整的 RAG 系统，集成引用功能

**流程：**
1. 生成带引用的答案
2. 验证引用有效性
3. 验证引用内容一致性

### 两种引用方法对比

| 方法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **Prompt 工程** | 简单易实现，LLM 理解上下文 | LLM 可能遗漏引用 | 一般问答系统 |
| **后处理** | 引用更准确，可控性强 | 需要额外计算 | 高精度要求场景 |

### 引用验证指标

| 指标 | 说明 | 目标值 |
|------|------|--------|
| `valid` | 引用是否有效 | True |
| `citation_count` | 引用数量 | > 0 |
| `citation_coverage` | 引用覆盖率 | > 80% |
| `entailment_score` | 一致性分数 | > 0.7 |

---

## 扩展建议

### 1. 交互式引用展示

```python
def format_interactive_citations(answer: str, docs: List[Dict]):
    """生成可交互的引用"""
    # 将 [1] 转换为可点击的链接
    for i, doc in enumerate(docs):
        url = doc.get('url', '#')
        answer = answer.replace(
            f'[{i+1}]',
            f'<a href="{url}" target="_blank">[{i+1}]</a>'
        )
    return answer
```

### 2. 引用悬停预览

```python
def add_citation_tooltips(answer: str, docs: List[Dict]):
    """添加引用悬停提示"""
    for i, doc in enumerate(docs):
        preview = doc['content'][:100] + "..."
        answer = answer.replace(
            f'[{i+1}]',
            f'<span title="{preview}">[{i+1}]</span>'
        )
    return answer
```

### 3. 学术引用格式

```python
def format_academic_citation(doc: Dict, style: str = "APA"):
    """格式化为学术引用"""
    if style == "APA":
        return f"{doc['author']} ({doc['year']}). {doc['title']}. {doc['journal']}."
    elif style == "MLA":
        return f"{doc['author']}. \"{doc['title']}.\" {doc['journal']}, {doc['year']}."
```

---

## 总结

**本示例展示了：**

1. ✅ Prompt 工程方法生成引用
2. ✅ 后处理方法添加引用
3. ✅ 引用有效性验证
4. ✅ 引用内容一致性验证
5. ✅ 完整的引用溯源流程

**关键要点：**

- 引用提升可信度和可验证性
- Prompt 工程简单但可能不准确
- 后处理方法更准确但需要额外计算
- 必须验证引用的有效性和一致性

**下一步：**

- 学习多策略缓解
- 构建端到端 RAG 系统
- 集成到生产环境
