# docker-compose编排 - 化骨绵掌

## 概述

本文将 docker-compose 的核心知识拆分成 10 个 2 分钟知识卡片，每个卡片独立完整，可以快速学习和复习。

---

## 卡片1：docker-compose 的本质

**一句话：** docker-compose 是声明式的多容器编排工具，通过 YAML 配置文件定义服务、网络、数据卷。

**核心概念：**
```yaml
version: '3.8'
services:    # 定义服务（容器）
  api:
    image: my-api
volumes:     # 定义数据卷
  data:
networks:    # 定义网络
  app-net:
```

**应用：** 在 AI Agent 开发中，用于一键启动 API + 数据库 + 缓存的完整开发环境。

---

## 卡片2：服务间通信

**一句话：** 容器间通过服务名通信，docker-compose 自动创建网络和 DNS 解析。

**示例：**
```yaml
services:
  api:
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
      # 通过服务名 "db" 访问数据库

  db:
    image: postgres
```

**Python 代码：**
```python
# 通过服务名连接
conn = psycopg2.connect(host="db", port=5432)
```

**应用：** 不需要知道容器的 IP 地址，直接用服务名访问。

---

## 卡片3：depends_on 的局限

**一句话：** depends_on 只等待容器启动，不等待服务就绪，需要配合 healthcheck 使用。

**错误用法：**
```yaml
services:
  api:
    depends_on:
      - db  # 只等待容器启动，数据库可能还在初始化
```

**正确用法：**
```yaml
services:
  api:
    depends_on:
      db:
        condition: service_healthy  # 等待健康检查通过

  db:
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
```

**应用：** 确保数据库完全就绪后再启动 API，避免连接失败。

---

## 卡片4：数据持久化策略

**一句话：** 命名卷用于数据库数据（Docker 管理），绑定挂载用于开发代码（热重载）。

**对比：**
```yaml
services:
  # 数据库：命名卷（持久化）
  db:
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # API：绑定挂载（热重载）
  api:
    volumes:
      - .:/app

volumes:
  postgres_data:
```

**选择标准：**
- 数据库数据 → 命名卷（跨平台、性能好）
- 开发代码 → 绑定挂载（修改立即生效）

**应用：** 数据库数据不丢失，代码修改自动重启。

---

## 卡片5：环境变量管理

**一句话：** 使用 .env 文件管理环境变量，不同环境用不同的 .env 文件。

**配置：**
```yaml
# docker-compose.yml
services:
  api:
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - DEBUG=${DEBUG:-false}  # 默认值
```

**.env 文件：**
```bash
DATABASE_URL=postgresql://user:pass@db:5432/mydb
DEBUG=true
```

**最佳实践：**
- ✅ 提供 .env.example 模板
- ✅ 不提交 .env 到 Git
- ✅ 敏感信息用环境变量

**应用：** 开发/测试/生产环境使用不同的配置。

---

## 卡片6：健康检查配置

**一句话：** 健康检查确保服务真正就绪，而不只是容器启动。

**常用健康检查：**
```yaml
# PostgreSQL
db:
  healthcheck:
    test: ["CMD", "pg_isready", "-U", "user"]
    interval: 5s
    timeout: 3s
    retries: 5

# Redis
redis:
  healthcheck:
    test: ["CMD", "redis-cli", "ping"]
    interval: 5s

# FastAPI
api:
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
    interval: 30s
    start_period: 30s
```

**应用：** 配合 depends_on 确保启动顺序正确。

---

## 卡片7：多环境配置

**一句话：** 基础配置 + 环境覆盖，使用多个 YAML 文件管理不同环境。

**文件结构：**
```
docker-compose.yml          # 基础配置
docker-compose.dev.yml      # 开发环境覆盖
docker-compose.prod.yml     # 生产环境覆盖
```

**使用：**
```bash
# 开发环境
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up

# 生产环境
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

**应用：** 配置复用，环境隔离。

---

## 卡片8：网络隔离

**一句话：** 使用多个网络隔离服务，提高安全性。

**配置：**
```yaml
services:
  nginx:
    networks:
      - frontend  # 公开网络

  api:
    networks:
      - frontend
      - backend   # 内部网络

  db:
    networks:
      - backend   # 只在内部网络

networks:
  frontend:
  backend:
    internal: true  # 不能访问外网
```

**访问规则：**
- nginx 可以访问 api
- nginx 不能访问 db
- api 可以访问 db

**应用：** 数据库不暴露到外网，提高安全性。

---

## 卡片9：资源限制

**一句话：** 限制容器的 CPU 和内存使用，防止单个容器占用过多资源。

**配置：**
```yaml
services:
  api:
    deploy:
      resources:
        limits:
          cpus: '1'        # 最多1个CPU核心
          memory: 1G       # 最多1GB内存
        reservations:
          cpus: '0.5'      # 保证0.5个CPU核心
          memory: 512M     # 保证512MB内存
```

**或使用旧版语法：**
```yaml
services:
  api:
    cpus: 1.0
    mem_limit: 1g
```

**应用：** 生产环境防止资源耗尽。

---

## 卡片10：日志管理

**一句话：** 配置日志轮转，防止日志文件占满磁盘。

**配置：**
```yaml
services:
  api:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"    # 单个文件最大10MB
        max-file: "3"      # 最多保留3个文件
        compress: "true"   # 压缩旧日志
```

**查看日志：**
```bash
# 查看所有日志
docker-compose logs

# 实时查看
docker-compose logs -f api

# 查看最近100行
docker-compose logs --tail=100 api
```

**应用：** 防止日志占满磁盘，方便调试。

---

## 快速参考

### 常用命令

```bash
# 启动服务
docker-compose up              # 前台运行
docker-compose up -d           # 后台运行
docker-compose up --build      # 重建镜像

# 停止服务
docker-compose down            # 停止并删除容器
docker-compose down -v         # 停止并删除数据卷（数据会丢失！）

# 查看状态
docker-compose ps              # 查看运行中的服务
docker-compose logs            # 查看日志
docker-compose logs -f api     # 实时查看特定服务日志

# 重启服务
docker-compose restart         # 重启所有服务
docker-compose restart api     # 重启特定服务

# 执行命令
docker-compose exec api bash   # 进入容器
docker-compose run api pytest  # 运行一次性命令

# 扩展服务
docker-compose up --scale api=3  # 启动3个API实例
```

### 配置速查

```yaml
version: '3.8'

services:
  api:
    # 镜像来源
    image: my-api:latest        # 使用现有镜像
    build: .                    # 构建镜像

    # 端口映射
    ports:
      - "8000:8000"             # 主机:容器

    # 环境变量
    environment:
      - DEBUG=true
    env_file:
      - .env

    # 依赖关系
    depends_on:
      db:
        condition: service_healthy

    # 数据卷
    volumes:
      - .:/app                  # 绑定挂载
      - data:/data              # 命名卷

    # 网络
    networks:
      - app-network

    # 健康检查
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s

    # 重启策略
    restart: unless-stopped

    # 资源限制
    cpus: 1.0
    mem_limit: 1g

    # 日志配置
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

volumes:
  data:

networks:
  app-network:
```

### 健康检查速查

```yaml
# PostgreSQL
healthcheck:
  test: ["CMD", "pg_isready", "-U", "user"]
  interval: 5s

# MySQL
healthcheck:
  test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
  interval: 5s

# Redis
healthcheck:
  test: ["CMD", "redis-cli", "ping"]
  interval: 5s

# HTTP 服务
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
  interval: 30s
  start_period: 30s
```

### 环境对比速查

| 特性 | 开发环境 | 测试环境 | 生产环境 |
|------|---------|---------|---------|
| **代码挂载** | ✅ 热重载 | ✅ 测试用 | ❌ 使用镜像 |
| **端口暴露** | ✅ 全部暴露 | ❌ 不暴露 | ❌ 只暴露必要端口 |
| **调试模式** | ✅ DEBUG=true | ❌ DEBUG=false | ❌ DEBUG=false |
| **日志级别** | debug | info | warning |
| **重启策略** | no | on-failure | always |
| **资源限制** | ❌ 无限制 | ⚠️ 适度限制 | ✅ 严格限制 |

---

## 常见错误速查

### 错误1：API 连接数据库失败

**原因：** depends_on 只等待容器启动，不等待服务就绪

**解决：**
```yaml
services:
  api:
    depends_on:
      db:
        condition: service_healthy  # 添加健康检查条件

  db:
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 5s
```

### 错误2：代码修改后未生效

**原因：** 未挂载代码目录或未启用热重载

**解决：**
```yaml
services:
  api:
    volumes:
      - .:/app  # 挂载代码目录
    command: uvicorn app.main:app --reload  # 启用热重载
```

### 错误3：数据丢失

**原因：** 使用了 `docker-compose down -v`

**解决：**
```bash
# 停止服务但保留数据卷
docker-compose down

# 不要使用 -v 参数
# docker-compose down -v  # ❌ 会删除数据卷
```

### 错误4：端口被占用

**原因：** 主机端口已被其他进程占用

**解决：**
```bash
# 方法1：停止占用端口的进程
lsof -ti:8000 | xargs kill -9

# 方法2：修改端口
# docker-compose.yml
ports:
  - "8001:8000"  # 使用不同的主机端口
```

### 错误5：健康检查一直失败

**原因：** 超时时间太短或启动宽限期不够

**解决：**
```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
  interval: 10s
  timeout: 5s      # 增加超时时间
  start_period: 30s  # 增加启动宽限期
```

---

## 最佳实践速查

### ✅ 推荐做法

1. **使用健康检查 + 条件等待**
   ```yaml
   depends_on:
     db:
       condition: service_healthy
   ```

2. **数据库用命名卷，代码用绑定挂载**
   ```yaml
   db:
     volumes:
       - postgres_data:/var/lib/postgresql/data
   api:
     volumes:
       - .:/app
   ```

3. **环境变量用 .env 文件**
   ```yaml
   environment:
     - DATABASE_URL=${DATABASE_URL}
   ```

4. **生产环境限制资源**
   ```yaml
   deploy:
     resources:
       limits:
         cpus: '1'
         memory: 1G
   ```

5. **配置日志轮转**
   ```yaml
   logging:
     driver: "json-file"
     options:
       max-size: "10m"
       max-file: "3"
   ```

### ❌ 不推荐做法

1. **只用 depends_on 不用 healthcheck**
2. **数据库用绑定挂载**
3. **硬编码敏感信息**
4. **生产环境不限制资源**
5. **不配置日志管理**

---

## 学习路径

### 初学者（1-2小时）

1. 阅读：00_概览.md
2. 阅读：01_30字核心.md
3. 实战：07_实战代码_01_基础开发环境.md
4. 复习：本文（化骨绵掌）

### 进阶学习（4-6小时）

1. 阅读：02_第一性原理.md
2. 阅读：04_最小可用.md
3. 阅读：核心概念系列（03_核心概念_*.md）
4. 实战：07_实战代码_02_完整开发环境.md
5. 实战：07_实战代码_03_多环境配置.md

### 生产实践（8-10小时）

1. 阅读：06_反直觉点.md
2. 阅读：08_面试必问.md
3. 实战：07_实战代码_04_生产级配置.md
4. 实践：部署实际项目

---

## 总结

**docker-compose 的核心价值：**
1. **简化操作**：一键启动多个容器
2. **环境一致**：配置即文档
3. **团队协作**：快速上手

**在 AI Agent 开发中：**
- 本地开发：API + 数据库 + 缓存一键启动
- 测试环境：隔离和可重复
- 团队协作：环境完全一致

**记住：** docker-compose 是为了解决多容器应用的实际问题，不是为了炫技。

---

**版本：** v1.0
**最后更新：** 2026-02-12
**预计复习时间：** 20-30 分钟
