# 核心概念 01：交互界面架构

> 深入理解 Pi 交互界面的三层架构设计

---

## 概念定义

**Pi 的交互界面采用三层架构：状态栏（Status Bar）、对话区（Conversation Area）、编辑器（Editor），通过 pi-tui 自定义渲染引擎实现高效的终端 UI。**

---

## 第一性原理

### 为什么需要三层架构？

**核心问题：如何在终端中实现高效的 AI 对话界面？**

```typescript
// 问题拆解
interface TerminalUIRequirements {
  // 需求 1：显示系统状态
  status: {
    currentModel: string;
    sessionName: string;
    tokenUsage: number;
  };

  // 需求 2：显示对话历史
  conversation: {
    messages: Message[];
    toolCalls: ToolCall[];
    scrollable: boolean;
  };

  // 需求 3：接收用户输入
  input: {
    multiline: boolean;
    fileReference: boolean;
    commandExecution: boolean;
  };
}

// 解决方案：三层架构
interface ThreeLayerArchitecture {
  statusBar: StatusBarLayer;      // 顶部：系统状态
  conversationArea: ConversationLayer;  // 中间：对话历史
  editor: EditorLayer;             // 底部：用户输入
}
```

---

## 架构详解

### 层 1：状态栏（Status Bar）

**定义：** 顶部固定区域，显示系统关键信息。

**TypeScript 实现：**
```typescript
interface StatusBar {
  // 核心信息
  model: {
    name: string;           // 当前模型名称
    provider: string;       // Provider（anthropic/openai/...）
    contextWindow: number;  // 上下文窗口大小
  };

  session: {
    name: string;           // Session 名称
    messageCount: number;   // 消息数量
    branchCount: number;    // 分支数量
  };

  tokens: {
    input: number;          // 输入 tokens
    output: number;         // 输出 tokens
    total: number;          // 总 tokens
    cost: number;           // 估算成本
  };

  // 渲染方法
  render(): string {
    return `${this.model.name} | ${this.session.name} | ${this.tokens.total}K tokens`;
  }
}
```

**实际渲染示例：**
```
┌─────────────────────────────────────────────────────────┐
│ claude-opus-4 | my-project | 1.2K tokens | $0.05       │
└─────────────────────────────────────────────────────────┘
```

**设计考量：**
```typescript
// 1. 固定高度：1 行
const STATUS_BAR_HEIGHT = 1;

// 2. 实时更新：每次 LLM 响应后更新
async function updateStatusBar(response: LLMResponse) {
  statusBar.tokens.input += response.usage.input_tokens;
  statusBar.tokens.output += response.usage.output_tokens;
  statusBar.tokens.total = statusBar.tokens.input + statusBar.tokens.output;
  statusBar.render();
}

// 3. 颜色编码：不同状态不同颜色
const colors = {
  model: chalk.blue,
  session: chalk.green,
  tokens: chalk.yellow,
  cost: chalk.red
};
```

---

### 层 2：对话区（Conversation Area）

**定义：** 中间可滚动区域，显示完整的对话历史和工具调用。

**TypeScript 实现：**
```typescript
interface ConversationArea {
  // 消息列表
  messages: Array<{
    role: 'user' | 'assistant' | 'system';
    content: string;
    timestamp: Date;
    toolCalls?: ToolCall[];
  }>;

  // 滚动状态
  scroll: {
    position: number;       // 当前滚动位置
    maxPosition: number;    // 最大滚动位置
    autoScroll: boolean;    // 自动滚动到底部
  };

  // 折叠状态
  collapsed: {
    toolOutputs: Set<string>;  // 折叠的工具输出 ID
    thinkingBlocks: Set<string>;  // 折叠的思考块 ID
  };

  // 渲染方法
  render(): string[] {
    const lines: string[] = [];

    for (const message of this.messages) {
      // 渲染用户消息
      if (message.role === 'user') {
        lines.push(chalk.cyan(`You: ${message.content}`));
      }

      // 渲染 AI 响应
      if (message.role === 'assistant') {
        lines.push(chalk.green(`AI: ${message.content}`));

        // 渲染工具调用
        if (message.toolCalls) {
          for (const toolCall of message.toolCalls) {
            const isCollapsed = this.collapsed.toolOutputs.has(toolCall.id);
            if (isCollapsed) {
              lines.push(chalk.gray(`[Tool: ${toolCall.name}] (collapsed)`));
            } else {
              lines.push(chalk.yellow(`[Tool: ${toolCall.name}]`));
              lines.push(chalk.gray(toolCall.result));
            }
          }
        }
      }
    }

    return lines;
  }
}
```

**实际渲染示例：**
```
┌─────────────────────────────────────────────────────────┐
│ You: 请帮我修复 @auth.ts 的 bug                          │
│                                                         │
│ AI: 让我先读取文件内容                                   │
│ [Tool: read] src/auth.ts                                │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ export function authenticate(token: string) {       │ │
│ │   if (!token) return false;                         │ │
│ │   // ... 文件内容 ...                                │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ AI: 我发现了问题，第 42 行的逻辑有误...                  │
│ [Tool: edit] src/auth.ts                                │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ - if (token.length < 10) return false;              │ │
│ │ + if (token.length < 32) return false;              │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ AI: 已修复，token 长度检查现在是 32 字符                 │
└─────────────────────────────────────────────────────────┘
```

**设计考量：**
```typescript
// 1. 动态高度：根据终端大小自动调整
const CONVERSATION_HEIGHT = terminalHeight - STATUS_BAR_HEIGHT - EDITOR_HEIGHT;

// 2. 虚拟滚动：只渲染可见区域
function renderVisibleMessages() {
  const visibleStart = scroll.position;
  const visibleEnd = scroll.position + CONVERSATION_HEIGHT;
  return messages.slice(visibleStart, visibleEnd);
}

// 3. 折叠功能：节省屏幕空间
function toggleToolOutput(toolCallId: string) {
  if (collapsed.toolOutputs.has(toolCallId)) {
    collapsed.toolOutputs.delete(toolCallId);
  } else {
    collapsed.toolOutputs.add(toolCallId);
  }
  render();
}

// 4. 流式渲染：实时显示 LLM 响应
async function streamResponse(response: AsyncIterable<string>) {
  let currentMessage = '';
  for await (const chunk of response) {
    currentMessage += chunk;
    render();  // 实时更新显示
  }
}
```

---

### 层 3：编辑器（Editor）

**定义：** 底部输入区域，支持多行输入、文件引用、命令执行。

**TypeScript 实现：**
```typescript
interface Editor {
  // 输入状态
  input: {
    content: string;        // 当前输入内容
    cursor: {
      line: number;         // 光标行号
      column: number;       // 光标列号
    };
    selection?: {
      start: { line: number; column: number };
      end: { line: number; column: number };
    };
  };

  // 补全状态
  completion: {
    active: boolean;
    suggestions: string[];
    selectedIndex: number;
  };

  // 功能
  features: {
    multiline: boolean;     // 多行输入
    fileReference: boolean; // @文件引用
    commandExecution: boolean;  // !命令执行
    tabCompletion: boolean; // Tab 补全
  };

  // 渲染方法
  render(): string[] {
    const lines: string[] = [];

    // 渲染提示符
    lines.push(chalk.bold('> '));

    // 渲染输入内容
    const inputLines = this.input.content.split('\n');
    for (let i = 0; i < inputLines.length; i++) {
      const line = inputLines[i];

      // 高亮 @文件引用
      const highlighted = line.replace(/@(\S+)/g, (match) => {
        return chalk.blue(match);
      });

      // 高亮 !命令
      const withCommand = highlighted.replace(/^!(!?)(\S+)/g, (match, double, cmd) => {
        return chalk.yellow(match);
      });

      lines.push(withCommand);
    }

    // 渲染补全建议
    if (this.completion.active) {
      lines.push('');
      lines.push(chalk.gray('Suggestions:'));
      for (let i = 0; i < this.completion.suggestions.length; i++) {
        const suggestion = this.completion.suggestions[i];
        if (i === this.completion.selectedIndex) {
          lines.push(chalk.bgBlue(` ${suggestion} `));
        } else {
          lines.push(chalk.gray(`  ${suggestion}`));
        }
      }
    }

    return lines;
  }

  // 处理输入
  async handleInput(key: string) {
    switch (key) {
      case 'enter':
        if (this.features.multiline && !isShiftPressed()) {
          // 换行
          this.input.content += '\n';
        } else {
          // 提交
          await this.submit();
        }
        break;

      case 'tab':
        // Tab 补全
        await this.triggerCompletion();
        break;

      case '@':
        // 文件引用
        await this.triggerFileReference();
        break;

      case '!':
        // 命令执行
        this.handleCommandPrefix();
        break;

      default:
        // 普通字符
        this.input.content += key;
        break;
    }

    this.render();
  }
}
```

**实际渲染示例：**
```
┌─────────────────────────────────────────────────────────┐
│ > 请帮我审查 @src/auth.ts 和 @src/api.ts                 │
│   这两个文件的代码质量                                    │
│                                                         │
│ Suggestions:                                            │
│   src/auth.ts                                           │
│   src/api.ts                                            │
│   src/api/users.ts                                      │
└─────────────────────────────────────────────────────────┘
```

**设计考量：**
```typescript
// 1. 动态高度：根据输入内容自动调整
const EDITOR_MIN_HEIGHT = 3;
const EDITOR_MAX_HEIGHT = 10;
const editorHeight = Math.min(
  Math.max(inputLines.length + 1, EDITOR_MIN_HEIGHT),
  EDITOR_MAX_HEIGHT
);

// 2. 文件引用补全
async function triggerFileReference() {
  const cursorPosition = this.input.cursor;
  const textBeforeCursor = this.getTextBeforeCursor();

  // 提取 @ 后的文本
  const match = textBeforeCursor.match(/@(\S*)$/);
  if (match) {
    const query = match[1];

    // 模糊搜索文件
    const files = await glob(`**/*${query}*`);

    // 显示补全建议
    this.completion.active = true;
    this.completion.suggestions = files;
    this.completion.selectedIndex = 0;
  }
}

// 3. 命令执行
async function handleCommandPrefix() {
  const textBeforeCursor = this.getTextBeforeCursor();

  if (textBeforeCursor.endsWith('!')) {
    // 单个 !：执行并发送输出
    this.commandMode = 'send';
  } else if (textBeforeCursor.endsWith('!!')) {
    // 双个 !!：只执行不发送
    this.commandMode = 'silent';
  }
}

// 4. 多行输入
function handleMultilineInput(key: string) {
  if (key === 'enter') {
    if (isShiftPressed() || isCtrlPressed()) {
      // Shift+Enter 或 Ctrl+Enter：换行
      this.input.content += '\n';
    } else {
      // Enter：提交
      this.submit();
    }
  }
}
```

---

## 渲染引擎：pi-tui

### 核心设计

**pi-tui 是一个自定义的终端 UI 渲染引擎，不依赖 React 或 Ink。**

```typescript
// pi-tui 核心架构
class PiTUI {
  private layers: Layer[] = [];
  private terminal: Terminal;

  // 添加层
  addLayer(layer: Layer) {
    this.layers.push(layer);
  }

  // 渲染所有层
  render() {
    // 1. 清空终端
    this.terminal.clear();

    // 2. 计算每层的高度
    const heights = this.calculateLayerHeights();

    // 3. 渲染每层
    let currentY = 0;
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.layers[i];
      const height = heights[i];

      // 渲染层内容
      const content = layer.render();

      // 写入终端
      this.terminal.moveCursor(0, currentY);
      this.terminal.write(content);

      currentY += height;
    }

    // 4. 刷新终端
    this.terminal.flush();
  }

  // 计算层高度
  private calculateLayerHeights(): number[] {
    const terminalHeight = this.terminal.rows;

    return [
      1,  // 状态栏：固定 1 行
      terminalHeight - 1 - this.getEditorHeight(),  // 对话区：动态
      this.getEditorHeight()  // 编辑器：动态
    ];
  }

  // 处理输入
  async handleInput(key: string) {
    // 将输入传递给编辑器层
    const editorLayer = this.layers[2] as EditorLayer;
    await editorLayer.handleInput(key);

    // 重新渲染
    this.render();
  }
}
```

---

### 差分渲染（Diff Rendering）

**为了提高性能，pi-tui 使用差分渲染，只更新变化的部分。**

```typescript
class DiffRenderer {
  private previousContent: string[][] = [];

  render(newContent: string[][]) {
    // 1. 计算差异
    const diff = this.calculateDiff(this.previousContent, newContent);

    // 2. 只更新变化的行
    for (const change of diff) {
      if (change.type === 'add' || change.type === 'modify') {
        this.terminal.moveCursor(0, change.line);
        this.terminal.clearLine();
        this.terminal.write(change.content);
      } else if (change.type === 'delete') {
        this.terminal.moveCursor(0, change.line);
        this.terminal.clearLine();
      }
    }

    // 3. 保存当前内容
    this.previousContent = newContent;
  }

  private calculateDiff(oldContent: string[][], newContent: string[][]): Change[] {
    const changes: Change[] = [];

    // 简单的逐行比较
    for (let i = 0; i < Math.max(oldContent.length, newContent.length); i++) {
      const oldLine = oldContent[i];
      const newLine = newContent[i];

      if (!oldLine && newLine) {
        changes.push({ type: 'add', line: i, content: newLine });
      } else if (oldLine && !newLine) {
        changes.push({ type: 'delete', line: i });
      } else if (oldLine !== newLine) {
        changes.push({ type: 'modify', line: i, content: newLine });
      }
    }

    return changes;
  }
}
```

---

## 与其他终端 UI 框架的对比

| 维度 | pi-tui | Ink (React for CLI) | Blessed | Charm (Go) |
|------|--------|---------------------|---------|------------|
| **依赖** | 无 | React | 无 | Go 运行时 |
| **复杂度** | 低 | 中 | 高 | 中 |
| **性能** | 高 | 中 | 中 | 高 |
| **学习曲线** | 平缓 | 陡峭（需要学 React）| 陡峭 | 中等 |
| **定制性** | 高 | 中 | 高 | 中 |
| **流式渲染** | 原生支持 | 需要额外处理 | 支持 | 支持 |

---

## 实际应用场景

### 场景 1：实时显示 LLM 响应

```typescript
// 流式渲染 LLM 响应
async function streamLLMResponse(prompt: string) {
  const stream = await llm.stream(prompt);

  let currentMessage = '';
  for await (const chunk of stream) {
    currentMessage += chunk;

    // 更新对话区
    conversationArea.updateLastMessage(currentMessage);

    // 重新渲染
    piTUI.render();
  }
}
```

---

### 场景 2：折叠长工具输出

```typescript
// 用户按 Ctrl+O 折叠工具输出
function handleCtrlO() {
  const lastToolCall = conversationArea.getLastToolCall();

  if (lastToolCall) {
    conversationArea.toggleToolOutput(lastToolCall.id);
    piTUI.render();
  }
}
```

---

### 场景 3：文件引用补全

```typescript
// 用户输入 @auth 并按 Tab
async function handleTabCompletion() {
  const textBeforeCursor = editor.getTextBeforeCursor();
  const match = textBeforeCursor.match(/@(\S*)$/);

  if (match) {
    const query = match[1];
    const files = await glob(`**/*${query}*`);

    // 显示补全建议
    editor.showCompletions(files);
    piTUI.render();
  }
}
```

---

## 性能优化

### 优化 1：虚拟滚动

```typescript
// 只渲染可见的消息
function renderVisibleMessages() {
  const visibleHeight = terminalHeight - STATUS_BAR_HEIGHT - EDITOR_HEIGHT;
  const visibleStart = scroll.position;
  const visibleEnd = scroll.position + visibleHeight;

  return messages.slice(visibleStart, visibleEnd);
}
```

---

### 优化 2：差分渲染

```typescript
// 只更新变化的行
function renderDiff(oldContent: string[], newContent: string[]) {
  for (let i = 0; i < newContent.length; i++) {
    if (oldContent[i] !== newContent[i]) {
      terminal.moveCursor(0, i);
      terminal.clearLine();
      terminal.write(newContent[i]);
    }
  }
}
```

---

### 优化 3：节流渲染

```typescript
// 限制渲染频率
const throttledRender = throttle(() => {
  piTUI.render();
}, 16);  // 60 FPS

// 流式响应时使用节流渲染
for await (const chunk of stream) {
  currentMessage += chunk;
  throttledRender();
}
```

---

## 快速参考

```typescript
// Pi 交互界面三层架构
interface PiInterface {
  // 层 1：状态栏（1 行）
  statusBar: {
    model: string;
    session: string;
    tokens: number;
  };

  // 层 2：对话区（动态高度）
  conversationArea: {
    messages: Message[];
    scroll: ScrollState;
    collapsed: Set<string>;
  };

  // 层 3：编辑器（动态高度）
  editor: {
    input: string;
    cursor: CursorPosition;
    completion: CompletionState;
  };
}

// 渲染引擎
class PiTUI {
  render(): void;
  handleInput(key: string): Promise<void>;
}
```

---

**来源：**
- [Pi Coding Agent README](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/README.md) - 2026-02
- [Pi-TUI 源码](https://github.com/badlogic/pi-mono/tree/main/packages/pi-tui) - 2026-02
- [Architecture 文档](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/architecture.md) - 2026-02
