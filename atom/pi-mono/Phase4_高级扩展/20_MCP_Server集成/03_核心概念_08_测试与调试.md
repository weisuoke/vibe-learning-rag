# 核心概念 08：测试与调试

> **深入理解 MCP Server 的测试策略、调试工具和性能优化**

---

## 概述

MCP Server 的测试与调试是确保服务器可靠性和性能的关键环节，需要系统化的测试策略和专业的调试工具。

```
测试与调试核心：
├─ 测试策略 → 单元测试、集成测试、端到端测试
├─ MCP Inspector → 可视化测试和调试工具
├─ 调试技术 → 日志记录、错误追踪、性能分析
└─ 最佳实践 → 开发工作流、边界测试、持续集成
```

**本质**：测试与调试是 MCP Server 开发的质量保证体系，通过系统化的测试策略和专业工具，确保服务器在各种场景下的正确性和稳定性。

[Source: MCP Inspector - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/inspector)

---

## 测试策略

### 单元测试

**工具注册测试**：

```typescript
import { describe, it, expect } from "vitest";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

describe("Tool Registration", () => {
  it("should register tool with correct schema", () => {
    const server = new McpServer({
      name: "test-server",
      version: "1.0.0"
    });

    server.registerTool(
      "get_weather",
      {
        title: "Get Weather",
        description: "Get weather for a location",
        inputSchema: z.object({
          location: z.string().describe("City name")
        })
      },
      async ({ location }) => {
        return {
          content: [
            {
              type: "text",
              text: `Weather for ${location}`
            }
          ]
        };
      }
    );

    // 验证工具已注册
    const tools = server.listTools();
    expect(tools).toHaveLength(1);
    expect(tools[0].name).toBe("get_weather");
  });
});
```

**参数验证测试**：

```typescript
describe("Parameter Validation", () => {
  it("should validate required parameters", async () => {
    const UserSearchSchema = z.object({
      query: z.string().min(2).max(200),
      limit: z.number().int().min(1).max(100).default(20)
    }).strict();

    // 测试有效输入
    const validInput = { query: "test", limit: 10 };
    expect(() => UserSearchSchema.parse(validInput)).not.toThrow();

    // 测试无效输入
    const invalidInput = { query: "t", limit: 10 }; // query 太短
    expect(() => UserSearchSchema.parse(invalidInput)).toThrow();
  });

  it("should apply default values", () => {
    const schema = z.object({
      limit: z.number().default(20)
    });

    const result = schema.parse({});
    expect(result.limit).toBe(20);
  });
});
```

### 集成测试

**服务器生命周期测试**：

```typescript
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

describe("Server Lifecycle", () => {
  it("should initialize and connect successfully", async () => {
    const server = new McpServer({
      name: "test-server",
      version: "1.0.0"
    });

    // 注册测试工具
    server.registerTool(
      "test_tool",
      {
        title: "Test Tool",
        description: "A test tool",
        inputSchema: z.object({})
      },
      async () => {
        return {
          content: [{ type: "text", text: "success" }]
        };
      }
    );

    // 模拟传输层
    const transport = new StdioServerTransport();

    // 连接服务器
    await server.connect(transport);

    // 验证服务器状态
    expect(server.isConnected()).toBe(true);
  });
});
```

**工具执行测试**：

```typescript
describe("Tool Execution", () => {
  it("should execute tool and return correct result", async () => {
    const server = new McpServer({
      name: "test-server",
      version: "1.0.0"
    });

    let executionCount = 0;

    server.registerTool(
      "counter",
      {
        title: "Counter",
        description: "Increment counter",
        inputSchema: z.object({})
      },
      async () => {
        executionCount++;
        return {
          content: [
            {
              type: "text",
              text: `Count: ${executionCount}`
            }
          ]
        };
      }
    );

    // 执行工具
    const result = await server.callTool("counter", {});

    expect(result.content[0].text).toBe("Count: 1");
    expect(executionCount).toBe(1);
  });

  it("should handle tool execution errors", async () => {
    const server = new McpServer({
      name: "test-server",
      version: "1.0.0"
    });

    server.registerTool(
      "failing_tool",
      {
        title: "Failing Tool",
        description: "A tool that fails",
        inputSchema: z.object({})
      },
      async () => {
        throw new Error("Tool execution failed");
      }
    );

    // 验证错误处理
    await expect(server.callTool("failing_tool", {})).rejects.toThrow(
      "Tool execution failed"
    );
  });
});
```

### 端到端测试

**完整工作流测试**：

```typescript
import { spawn } from "child_process";

describe("E2E Server Tests", () => {
  it("should handle complete request-response cycle", async () => {
    // 启动服务器进程
    const serverProcess = spawn("node", ["build/index.js"]);

    // 等待服务器启动
    await new Promise(resolve => setTimeout(resolve, 1000));

    // 发送初始化请求
    const initRequest = {
      jsonrpc: "2.0",
      id: 1,
      method: "initialize",
      params: {
        protocolVersion: "2025-03-26",
        capabilities: {},
        clientInfo: {
          name: "test-client",
          version: "1.0.0"
        }
      }
    };

    serverProcess.stdin.write(JSON.stringify(initRequest) + "\n");

    // 读取响应
    let response = "";
    serverProcess.stdout.on("data", (data) => {
      response += data.toString();
    });

    // 等待响应
    await new Promise(resolve => setTimeout(resolve, 500));

    // 验证响应
    const parsedResponse = JSON.parse(response);
    expect(parsedResponse.result.protocolVersion).toBe("2025-03-26");

    // 清理
    serverProcess.kill();
  });
});
```

[Source: Testing MCP Servers with MCP Inspector](https://mydeveloperplanet.com/2025/12/01/testing-mcp-servers-with-mcp-inspector/)

---

## MCP Inspector 使用

### 安装与启动

**快速启动**：

```bash
# 直接运行（无需安装）
npx @modelcontextprotocol/inspector

# 测试本地服务器
npx @modelcontextprotocol/inspector node build/index.js

# 测试 npm 包
npx -y @modelcontextprotocol/inspector npx @modelcontextprotocol/server-filesystem /Users/username/Desktop

# 测试 Python 服务器
npx @modelcontextprotocol/inspector uv --directory path/to/server run package-name args...
```

**启动输出**：

```
Starting MCP inspector...
Proxy server listening on 127.0.0.1:6277
Session token: 237c12e3d35a5ec7de779c3d5af92d2e747ebf41a01d883d16974f07113781fc

Open inspector with token pre-filled:
   http://localhost:6274/?MCP_PROXY_AUTH_TOKEN=237c12e3d35a5ec7de779c3d5af92d2e747ebf41a01d883d16974f07113781fc

MCP Inspector is up and running at http://127.0.0.1:6274
```

**关键特性**：

- **端口**：客户端 UI (6274)、代理服务器 (6277)
- **认证**：默认启用 Bearer Token 认证
- **自动打开**：浏览器自动打开并预填 Token

[Source: MCP Inspector - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/inspector)

### 功能概览

**Server Connection Pane（服务器连接面板）**：

- 选择传输类型（stdio、SSE、Streamable HTTP）
- 自定义命令行参数和环境变量
- 连接/断开服务器

**Resources Tab（资源标签页）**：

- 列出所有可用资源
- 显示资源元数据（MIME 类型、描述）
- 检查资源内容
- 测试订阅功能

**Prompts Tab（提示标签页）**：

- 显示可用提示模板
- 显示提示参数和描述
- 使用自定义参数测试提示
- 预览生成的消息

**Tools Tab（工具标签页）**：

- 列出可用工具
- 显示工具 Schema 和描述
- 使用自定义输入测试工具
- 显示工具执行结果

**Notifications Pane（通知面板）**：

- 显示服务器记录的所有日志
- 显示从服务器接收的通知

[Source: MCP Inspector - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/inspector)

### 测试工作流

**开发工作流**：

1. **启动开发**
   - 使用服务器启动 Inspector
   - 验证基本连接
   - 检查能力协商

2. **迭代测试**
   - 修改服务器代码
   - 重新构建服务器
   - 重新连接 Inspector
   - 测试受影响的功能
   - 监控消息

3. **测试边界情况**
   - 无效输入
   - 缺失提示参数
   - 并发操作
   - 验证错误处理和错误响应

**实际测试示例**：

```bash
# 1. 启动 Inspector 连接到本地服务器
npx @modelcontextprotocol/inspector node build/index.js

# 2. 在浏览器中打开 http://localhost:6274

# 3. 连接服务器
#    - Transport Type: stdio
#    - Command: node
#    - Arguments: build/index.js

# 4. 测试工具
#    - 导航到 Tools 标签页
#    - 点击 "List Tools" 查看可用工具
#    - 选择工具并填写参数
#    - 点击 "Run Tool" 执行

# 5. 查看结果
#    - 在右侧面板查看工具执行结果
#    - 在 Notifications 面板查看日志
```

[Source: Testing MCP Servers with MCP Inspector](https://mydeveloperplanet.com/2025/12/01/testing-mcp-servers-with-mcp-inspector/)

---

## 调试技术

### 日志记录

**stdio 服务器日志约束**：

```typescript
// ❌ 错误：写入 stdout 会破坏 JSON-RPC 消息
console.log("Processing request");

// ✅ 正确：使用 stderr
console.error("Processing request");

// ✅ 正确：使用日志库
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: "error.log", level: "error" }),
    new winston.transports.File({ filename: "combined.log" })
  ]
});

logger.info("Processing request", { toolName: "get_weather" });
```

**结构化日志**：

```typescript
interface LogContext {
  requestId: string;
  toolName?: string;
  userId?: string;
  timestamp: string;
}

class StructuredLogger {
  private context: LogContext;

  constructor(requestId: string) {
    this.context = {
      requestId,
      timestamp: new Date().toISOString()
    };
  }

  info(message: string, meta?: Record<string, any>) {
    console.error(JSON.stringify({
      level: "info",
      message,
      ...this.context,
      ...meta
    }));
  }

  error(message: string, error: Error, meta?: Record<string, any>) {
    console.error(JSON.stringify({
      level: "error",
      message,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      ...this.context,
      ...meta
    }));
  }
}

// 使用示例
const logger = new StructuredLogger("req-123");
logger.info("Tool execution started", { toolName: "get_weather" });
```

### 错误追踪

**错误上下文捕获**：

```typescript
class ToolExecutionError extends Error {
  constructor(
    message: string,
    public toolName: string,
    public input: any,
    public cause?: Error
  ) {
    super(message);
    this.name = "ToolExecutionError";
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      toolName: this.toolName,
      input: this.input,
      cause: this.cause ? {
        name: this.cause.name,
        message: this.cause.message,
        stack: this.cause.stack
      } : undefined
    };
  }
}

// 使用示例
server.registerTool(
  "fetch_data",
  {
    title: "Fetch Data",
    description: "Fetch data from API",
    inputSchema: z.object({
      url: z.string().url()
    })
  },
  async ({ url }) => {
    try {
      const response = await fetch(url);
      const data = await response.json();

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(data)
          }
        ]
      };
    } catch (error) {
      const toolError = new ToolExecutionError(
        "Failed to fetch data",
        "fetch_data",
        { url },
        error as Error
      );

      logger.error("Tool execution failed", toolError);

      return {
        content: [
          {
            type: "text",
            text: `Error: ${toolError.message}\nURL: ${url}\nCause: ${error.message}`
          }
        ],
        isError: true
      };
    }
  }
);
```

### 性能分析

**执行时间追踪**：

```typescript
class PerformanceTracker {
  private metrics = new Map<string, number[]>();

  async track<T>(
    operation: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const start = performance.now();

    try {
      const result = await fn();
      const duration = performance.now() - start;

      this.recordMetric(operation, duration);

      if (duration > 1000) {
        logger.warn("Slow operation detected", {
          operation,
          duration: `${duration.toFixed(2)}ms`
        });
      }

      return result;
    } catch (error) {
      const duration = performance.now() - start;
      this.recordMetric(operation, duration);
      throw error;
    }
  }

  private recordMetric(operation: string, duration: number) {
    if (!this.metrics.has(operation)) {
      this.metrics.set(operation, []);
    }
    this.metrics.get(operation)!.push(duration);
  }

  getStats(operation: string) {
    const durations = this.metrics.get(operation) || [];
    if (durations.length === 0) return null;

    const sorted = [...durations].sort((a, b) => a - b);
    return {
      count: durations.length,
      avg: durations.reduce((a, b) => a + b, 0) / durations.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    };
  }
}

// 使用示例
const tracker = new PerformanceTracker();

server.registerTool(
  "search_database",
  {
    title: "Search Database",
    description: "Search database for records",
    inputSchema: z.object({
      query: z.string()
    })
  },
  async ({ query }) => {
    const results = await tracker.track(
      "database_search",
      async () => {
        return await database.search(query);
      }
    );

    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(results)
        }
      ]
    };
  }
);

// 定期输出性能统计
setInterval(() => {
  const stats = tracker.getStats("database_search");
  if (stats) {
    logger.info("Performance stats", {
      operation: "database_search",
      ...stats
    });
  }
}, 60000); // 每分钟
```

---

## 最佳实践

### 测试覆盖率

**关键测试点**：

1. **工具注册**：验证所有工具正确注册
2. **参数验证**：测试有效和无效输入
3. **错误处理**：验证错误场景的处理
4. **边界条件**：测试极端值和边界情况
5. **并发处理**：测试多个并发请求

### 调试检查清单

**开发阶段**：

- [ ] 使用 MCP Inspector 测试所有工具
- [ ] 验证工具 Schema 定义正确
- [ ] 测试所有错误路径
- [ ] 检查日志输出（不写入 stdout）
- [ ] 验证性能指标

**部署前**：

- [ ] 运行完整测试套件
- [ ] 检查内存泄漏
- [ ] 验证错误恢复机制
- [ ] 测试超时处理
- [ ] 审查安全配置

### 持续集成

**CI 配置示例**：

```yaml
# .github/workflows/test.yml
name: Test MCP Server

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit

      - name: Run integration tests
        run: npm run test:integration

      - name: Build server
        run: npm run build

      - name: Test with MCP Inspector
        run: |
          npx @modelcontextprotocol/inspector node build/index.js --cli --method tools/list
```

---

## 总结

### 核心要点

1. **测试策略**：单元测试、集成测试、端到端测试三层覆盖
2. **MCP Inspector**：可视化测试工具，支持交互式调试
3. **日志记录**：stdio 服务器使用 stderr，结构化日志
4. **错误追踪**：捕获完整上下文，便于问题定位
5. **性能分析**：追踪执行时间，识别性能瓶颈

### 关键约束

- ✅ stdio 服务器不能写入 stdout
- ✅ 使用 MCP Inspector 进行交互式测试
- ✅ 实现结构化日志记录
- ✅ 追踪性能指标
- ✅ 测试所有错误路径

### 下一步

- 阅读 [03_核心概念_09_Extension_API详解](./03_核心概念_09_Extension_API详解.md) 了解扩展 API
- 阅读 [07_实战代码_01_简单MCP_Server](./07_实战代码_01_简单MCP_Server.md) 查看完整实现

---

**参考资源**：
- [Source: MCP Inspector - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/inspector)
- [Source: Testing MCP Servers with MCP Inspector](https://mydeveloperplanet.com/2025/12/01/testing-mcp-servers-with-mcp-inspector/)
- [Source: GitHub - modelcontextprotocol/inspector](https://github.com/modelcontextprotocol/inspector)
