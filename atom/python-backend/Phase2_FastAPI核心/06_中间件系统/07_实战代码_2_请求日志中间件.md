# 实战代码 2：请求日志中间件

本文提供完整的请求日志中间件实现，包括基础日志、结构化日志和生产级日志。

---

## 1. 基础请求日志

### 1.1 简单日志中间件

```python
"""
基础请求日志中间件
演示：记录每个请求的基本信息
"""

from fastapi import FastAPI, Request
import time
from datetime import datetime

app = FastAPI()

@app.middleware("http")
async def log_requests(request: Request, call_next):
    # 记录请求开始
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] → {request.method} {request.url.path}")

    # 处理请求
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time

    # 记录请求结束
    print(f"[{timestamp}] ← {response.status_code} ({duration:.3f}s)")

    return response

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/slow")
async def slow_endpoint():
    import asyncio
    await asyncio.sleep(0.5)
    return {"message": "Slow response"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```
[2026-02-11 10:30:15] → GET /
[2026-02-11 10:30:15] ← 200 (0.001s)

[2026-02-11 10:30:20] → GET /slow
[2026-02-11 10:30:20] ← 200 (0.502s)
```

---

## 2. 带请求 ID 的日志

### 2.1 请求追踪中间件

```python
"""
带请求 ID 的日志中间件
演示：为每个请求生成唯一 ID，便于追踪
"""

from fastapi import FastAPI, Request
import time
import uuid
from datetime import datetime

app = FastAPI()

@app.middleware("http")
async def log_with_request_id(request: Request, call_next):
    # 生成请求 ID
    request_id = str(uuid.uuid4())[:8]  # 使用前 8 位
    request.state.request_id = request_id

    # 记录请求开始
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] [{request_id}] → {request.method} {request.url.path}")

    # 处理请求
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time

    # 记录请求结束
    print(f"[{timestamp}] [{request_id}] ← {response.status_code} ({duration:.3f}s)")

    # 添加请求 ID 到响应头
    response.headers["X-Request-ID"] = request_id

    return response

@app.get("/")
async def root(request: Request):
    request_id = request.state.request_id
    return {"message": "Hello World", "request_id": request_id}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```
[2026-02-11 10:30:15] [a1b2c3d4] → GET /
[2026-02-11 10:30:15] [a1b2c3d4] ← 200 (0.001s)

[2026-02-11 10:30:20] [e5f6g7h8] → GET /
[2026-02-11 10:30:20] [e5f6g7h8] ← 200 (0.001s)
```

---

## 3. 详细日志（包含查询参数和请求头）

### 3.1 详细日志中间件

```python
"""
详细日志中间件
演示：记录请求的详细信息
"""

from fastapi import FastAPI, Request
import time
import uuid
from datetime import datetime

app = FastAPI()

@app.middleware("http")
async def detailed_log(request: Request, call_next):
    # 生成请求 ID
    request_id = str(uuid.uuid4())[:8]
    request.state.request_id = request_id

    # 记录请求详情
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"\n{'='*60}")
    print(f"[{timestamp}] [{request_id}] Request Start")
    print(f"Method: {request.method}")
    print(f"Path: {request.url.path}")
    print(f"Query Params: {dict(request.query_params)}")
    print(f"Client: {request.client.host}")
    print(f"User-Agent: {request.headers.get('user-agent', 'N/A')}")

    # 处理请求
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time

    # 记录响应详情
    print(f"Status: {response.status_code}")
    print(f"Duration: {duration:.3f}s")
    print(f"[{timestamp}] [{request_id}] Request End")
    print(f"{'='*60}\n")

    response.headers["X-Request-ID"] = request_id

    return response

@app.get("/users")
async def get_users(page: int = 1, limit: int = 10):
    return {"page": page, "limit": limit}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```
============================================================
[2026-02-11 10:30:15] [a1b2c3d4] Request Start
Method: GET
Path: /users
Query Params: {'page': '2', 'limit': '20'}
Client: 127.0.0.1
User-Agent: curl/7.64.1
Status: 200
Duration: 0.001s
[2026-02-11 10:30:15] [a1b2c3d4] Request End
============================================================
```

---

## 4. 结构化日志（JSON 格式）

### 4.1 JSON 日志中间件

```python
"""
结构化日志中间件
演示：输出 JSON 格式的日志，便于日志分析工具处理
"""

from fastapi import FastAPI, Request
import time
import uuid
import json
from datetime import datetime

app = FastAPI()

@app.middleware("http")
async def json_log(request: Request, call_next):
    # 生成请求 ID
    request_id = str(uuid.uuid4())

    # 处理请求
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time

    # 构建日志对象
    log_data = {
        "timestamp": datetime.now().isoformat(),
        "request_id": request_id,
        "method": request.method,
        "path": request.url.path,
        "query_params": dict(request.query_params),
        "client_ip": request.client.host,
        "user_agent": request.headers.get("user-agent"),
        "status_code": response.status_code,
        "duration_ms": round(duration * 1000, 2),
    }

    # 输出 JSON 日志
    print(json.dumps(log_data))

    response.headers["X-Request-ID"] = request_id

    return response

@app.get("/")
async def root():
    return {"message": "Hello World"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```json
{"timestamp": "2026-02-11T10:30:15.123456", "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890", "method": "GET", "path": "/", "query_params": {}, "client_ip": "127.0.0.1", "user_agent": "curl/7.64.1", "status_code": 200, "duration_ms": 1.23}
```

---

## 5. 慢请求告警

### 5.1 慢请求监控中间件

```python
"""
慢请求告警中间件
演示：记录超过阈值的慢请求
"""

from fastapi import FastAPI, Request
import time
import uuid
from datetime import datetime

app = FastAPI()

# 慢请求阈值（秒）
SLOW_REQUEST_THRESHOLD = 0.5

@app.middleware("http")
async def slow_request_alert(request: Request, call_next):
    request_id = str(uuid.uuid4())[:8]
    request.state.request_id = request_id

    # 处理请求
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time

    # 检查是否为慢请求
    if duration > SLOW_REQUEST_THRESHOLD:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"⚠️  SLOW REQUEST ALERT")
        print(f"[{timestamp}] [{request_id}]")
        print(f"Method: {request.method}")
        print(f"Path: {request.url.path}")
        print(f"Duration: {duration:.3f}s (threshold: {SLOW_REQUEST_THRESHOLD}s)")
        print(f"Client: {request.client.host}")
        print()

    response.headers["X-Request-ID"] = request_id
    response.headers["X-Process-Time"] = f"{duration:.3f}"

    return response

@app.get("/fast")
async def fast_endpoint():
    return {"message": "Fast response"}

@app.get("/slow")
async def slow_endpoint():
    import asyncio
    await asyncio.sleep(1)  # 模拟慢请求
    return {"message": "Slow response"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```
# 访问 /fast - 无输出（快速请求）

# 访问 /slow - 触发告警
⚠️  SLOW REQUEST ALERT
[2026-02-11 10:30:15] [a1b2c3d4]
Method: GET
Path: /slow
Duration: 1.002s (threshold: 0.5s)
Client: 127.0.0.1
```

---

## 6. 按路径分类的日志

### 6.1 路径分类日志中间件

```python
"""
按路径分类的日志中间件
演示：不同路径使用不同的日志级别
"""

from fastapi import FastAPI, Request
import time
import uuid
from datetime import datetime

app = FastAPI()

# 日志配置
LOG_CONFIG = {
    "/api/": "INFO",      # API 路径记录详细日志
    "/health": "NONE",    # 健康检查不记录日志
    "/metrics": "NONE",   # 指标端点不记录日志
}

def get_log_level(path: str) -> str:
    """根据路径获取日志级别"""
    for prefix, level in LOG_CONFIG.items():
        if path.startswith(prefix):
            return level
    return "INFO"  # 默认级别

@app.middleware("http")
async def path_based_log(request: Request, call_next):
    log_level = get_log_level(request.url.path)

    # 不记录日志的路径
    if log_level == "NONE":
        return await call_next(request)

    # 记录日志
    request_id = str(uuid.uuid4())[:8]
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    print(f"[{timestamp}] [{request_id}] → {request.method} {request.url.path}")

    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time

    print(f"[{timestamp}] [{request_id}] ← {response.status_code} ({duration:.3f}s)")

    return response

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/api/users")
async def get_users():
    return {"users": []}

@app.get("/health")
async def health_check():
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```
# 访问 / - 记录日志
[2026-02-11 10:30:15] [a1b2c3d4] → GET /
[2026-02-11 10:30:15] [a1b2c3d4] ← 200 (0.001s)

# 访问 /api/users - 记录日志
[2026-02-11 10:30:20] [e5f6g7h8] → GET /api/users
[2026-02-11 10:30:20] [e5f6g7h8] ← 200 (0.001s)

# 访问 /health - 不记录日志（无输出）
```

---

## 7. 生产级日志中间件（完整版）

### 7.1 完整的生产级日志中间件

```python
"""
生产级日志中间件
演示：完整的日志功能，包括请求 ID、慢请求告警、错误日志等
"""

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import time
import uuid
import json
from datetime import datetime
from typing import Optional

app = FastAPI()

class LoggingMiddleware:
    """生产级日志中间件"""

    def __init__(
        self,
        app,
        slow_threshold: float = 1.0,
        log_format: str = "json",  # "json" or "text"
        exclude_paths: Optional[list] = None,
    ):
        self.app = app
        self.slow_threshold = slow_threshold
        self.log_format = log_format
        self.exclude_paths = exclude_paths or ["/health", "/metrics"]

    async def __call__(self, request: Request, call_next):
        # 跳过不需要记录的路径
        if request.url.path in self.exclude_paths:
            return await call_next(request)

        # 生成请求 ID
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        # 记录请求开始
        start_time = time.time()
        timestamp = datetime.now()

        try:
            # 处理请求
            response = await call_next(request)
            duration = time.time() - start_time

            # 记录成功日志
            self._log_request(
                request=request,
                request_id=request_id,
                timestamp=timestamp,
                status_code=response.status_code,
                duration=duration,
                error=None,
            )

            # 慢请求告警
            if duration > self.slow_threshold:
                self._log_slow_request(
                    request=request,
                    request_id=request_id,
                    duration=duration,
                )

            # 添加响应头
            response.headers["X-Request-ID"] = request_id
            response.headers["X-Process-Time"] = f"{duration:.3f}"

            return response

        except Exception as e:
            # 记录错误日志
            duration = time.time() - start_time
            self._log_request(
                request=request,
                request_id=request_id,
                timestamp=timestamp,
                status_code=500,
                duration=duration,
                error=str(e),
            )

            # 返回错误响应
            return JSONResponse(
                {"error": "Internal server error", "request_id": request_id},
                status_code=500,
                headers={"X-Request-ID": request_id},
            )

    def _log_request(
        self,
        request: Request,
        request_id: str,
        timestamp: datetime,
        status_code: int,
        duration: float,
        error: Optional[str],
    ):
        """记录请求日志"""
        if self.log_format == "json":
            log_data = {
                "timestamp": timestamp.isoformat(),
                "request_id": request_id,
                "method": request.method,
                "path": request.url.path,
                "query_params": dict(request.query_params),
                "client_ip": request.client.host,
                "user_agent": request.headers.get("user-agent"),
                "status_code": status_code,
                "duration_ms": round(duration * 1000, 2),
                "error": error,
            }
            print(json.dumps(log_data))
        else:
            # 文本格式
            timestamp_str = timestamp.strftime("%Y-%m-%d %H:%M:%S")
            status_emoji = "✅" if status_code < 400 else "❌"
            print(
                f"[{timestamp_str}] [{request_id}] {status_emoji} "
                f"{request.method} {request.url.path} - "
                f"{status_code} ({duration:.3f}s)"
            )
            if error:
                print(f"  Error: {error}")

    def _log_slow_request(self, request: Request, request_id: str, duration: float):
        """记录慢请求告警"""
        print(f"\n⚠️  SLOW REQUEST ALERT")
        print(f"Request ID: {request_id}")
        print(f"Method: {request.method}")
        print(f"Path: {request.url.path}")
        print(f"Duration: {duration:.3f}s (threshold: {self.slow_threshold}s)")
        print(f"Client: {request.client.host}\n")

# 使用中间件
from starlette.middleware.base import BaseHTTPMiddleware

app.add_middleware(
    BaseHTTPMiddleware,
    dispatch=LoggingMiddleware(
        app,
        slow_threshold=0.5,
        log_format="text",  # 或 "json"
        exclude_paths=["/health", "/metrics"],
    ),
)

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/slow")
async def slow_endpoint():
    import asyncio
    await asyncio.sleep(1)
    return {"message": "Slow response"}

@app.get("/error")
async def error_endpoint():
    raise ValueError("Something went wrong")

@app.get("/health")
async def health_check():
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出（文本格式）：**

```
# 正常请求
[2026-02-11 10:30:15] [a1b2c3d4] ✅ GET / - 200 (0.001s)

# 慢请求
[2026-02-11 10:30:20] [e5f6g7h8] ✅ GET /slow - 200 (1.002s)

⚠️  SLOW REQUEST ALERT
Request ID: e5f6g7h8
Method: GET
Path: /slow
Duration: 1.002s (threshold: 0.5s)
Client: 127.0.0.1

# 错误请求
[2026-02-11 10:30:25] [i9j0k1l2] ❌ GET /error - 500 (0.001s)
  Error: Something went wrong

# 健康检查（不记录日志）
```

**运行输出（JSON 格式）：**

```json
{"timestamp": "2026-02-11T10:30:15.123456", "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890", "method": "GET", "path": "/", "query_params": {}, "client_ip": "127.0.0.1", "user_agent": "curl/7.64.1", "status_code": 200, "duration_ms": 1.23, "error": null}
```

---

## 8. 在 AI Agent 后端中的应用

### 8.1 AI Agent 日志中间件

```python
"""
AI Agent 后端日志中间件
演示：记录 LLM API 调用的详细信息
"""

from fastapi import FastAPI, Request
import time
import uuid
import json
from datetime import datetime

app = FastAPI()

@app.middleware("http")
async def ai_agent_log(request: Request, call_next):
    request_id = str(uuid.uuid4())[:8]
    request.state.request_id = request_id

    # 记录请求开始
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"\n{'='*60}")
    print(f"[{timestamp}] [{request_id}] AI Agent Request")
    print(f"Path: {request.url.path}")
    print(f"Client: {request.client.host}")

    # 如果是 Agent 请求，记录用户 ID
    if hasattr(request.state, "user_id"):
        print(f"User ID: {request.state.user_id}")

    # 处理请求
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time

    # 记录响应
    print(f"Status: {response.status_code}")
    print(f"Duration: {duration:.3f}s")

    # 如果是 Agent 响应，记录 token 使用情况（从响应头读取）
    if "X-Token-Usage" in response.headers:
        print(f"Token Usage: {response.headers['X-Token-Usage']}")

    print(f"{'='*60}\n")

    response.headers["X-Request-ID"] = request_id

    return response

@app.post("/api/agent/chat")
async def chat(request: Request, message: str):
    # 模拟 LLM API 调用
    import asyncio
    await asyncio.sleep(0.5)

    # 模拟 token 使用情况
    token_usage = {"prompt_tokens": 100, "completion_tokens": 50, "total_tokens": 150}

    response = JSONResponse({
        "request_id": request.state.request_id,
        "response": f"Echo: {message}",
        "token_usage": token_usage,
    })

    # 添加 token 使用情况到响应头
    response.headers["X-Token-Usage"] = json.dumps(token_usage)

    return response

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**运行输出：**

```
============================================================
[2026-02-11 10:30:15] [a1b2c3d4] AI Agent Request
Path: /api/agent/chat
Client: 127.0.0.1
User ID: user_123
Status: 200
Duration: 0.502s
Token Usage: {"prompt_tokens": 100, "completion_tokens": 50, "total_tokens": 150}
============================================================
```

---

## 总结

**请求日志中间件的核心要点：**

1. **基础日志**：记录请求方法、路径、状态码、耗时
2. **请求 ID**：为每个请求生成唯一 ID，便于追踪
3. **详细日志**：记录查询参数、请求头、客户端信息
4. **结构化日志**：输出 JSON 格式，便于日志分析工具处理
5. **慢请求告警**：监控超过阈值的慢请求
6. **路径分类**：不同路径使用不同的日志级别
7. **生产级日志**：完整的日志功能，包括错误处理、慢请求告警等

**最佳实践：**
- 使用请求 ID 追踪请求
- 使用结构化日志（JSON）便于分析
- 排除健康检查等高频端点
- 记录慢请求和错误请求
- 在 AI Agent 后端中记录 token 使用情况

**下一步学习：**
- 实战代码 3：认证中间件
- 实战代码 4：限流中间件
- 实战代码 5：错误处理中间件
