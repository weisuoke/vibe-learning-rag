# 化骨绵掌

10个2分钟知识卡片，快速掌握混合检索核心知识。

---

## 卡片1：什么是混合检索？

**一句话：** 混合检索是同时使用关键词检索（BM25）和语义检索（向量），然后融合结果的策略。

**核心公式：**
```
混合检索 = BM25 + 向量检索 + 分数融合
```

**为什么需要？**
- BM25 擅长精确匹配（代码、版本号、专有名词）
- 向量检索擅长语义理解（同义词、意图）
- 单一方法都有盲区，混合才能覆盖更多场景

**应用：** RAG 系统的检索阶段，提升召回率 10-20%。

---

## 卡片2：BM25 的工作原理

**一句话：** BM25 通过统计查询词在文档中的出现频率来评估相关性。

**核心思想：**
```
1. 词频（TF）：词出现越多，越相关
2. 逆文档频率（IDF）：词越稀有，越有区分度
3. 长度归一化：长文档不应该因为词多而占优势
```

**代码：**
```python
from rank_bm25 import BM25Okapi
bm25 = BM25Okapi(tokenized_docs)
scores = bm25.get_scores(tokenized_query)
```

**应用：** 精确术语查询、代码搜索、错误信息匹配。

---

## 卡片3：向量检索的工作原理

**一句话：** 向量检索通过计算文本 Embedding 之间的相似度来找到语义相关的文档。

**核心流程：**
```
Query → Embedding → 向量 → 计算相似度 → 返回 Top-K
```

**代码：**
```python
# ChromaDB 自动处理 Embedding
results = collection.query(query_texts=["查询"], n_results=5)
```

**优势：**
- 理解同义词："快速" ≈ "高效"
- 理解意图："代码跑得慢" → "性能优化"

**应用：** 自然语言问答、模糊查询、意图理解。

---

## 卡片4：BM25 vs 向量检索

**一句话：** BM25 看词，向量看意思，各有擅长场景。

**对比表：**

| 查询类型 | BM25 | 向量 |
|----------|------|------|
| "Python 3.12" | ⭐⭐⭐ | ⭐ |
| "TypeError: NoneType" | ⭐⭐⭐ | ⭐ |
| "如何让代码更快" | ⭐ | ⭐⭐⭐ |
| "程序老出问题" | ⭐ | ⭐⭐⭐ |

**结论：** 不是谁更好，而是各有擅长。混合检索取长补短。

---

## 卡片5：RRF 融合算法

**一句话：** RRF（倒数排名融合）只用排名信息，避免了分数不可比的问题。

**公式：**
```
RRF_score(d) = Σ 1 / (k + rank(d))

k = 60（默认值）
```

**代码：**
```python
def rrf(results_list, k=60):
    scores = {}
    for results in results_list:
        for rank, doc_id in enumerate(results, 1):
            scores[doc_id] = scores.get(doc_id, 0) + 1/(k+rank)
    return sorted(scores.items(), key=lambda x: x[1], reverse=True)
```

**应用：** 业界最常用的融合方法，简单有效。

---

## 卡片6：为什么不能直接合并分数？

**一句话：** BM25 和向量检索的分数尺度不同，直接相加会导致一方主导。

**问题示例：**
```
BM25 分数：[15.2, 12.8, 8.5]  范围 [0, +∞)
向量相似度：[0.92, 0.85, 0.78]  范围 [-1, 1]

直接相加：
doc1: 15.2 + 0.85 = 16.05  ← BM25 主导
doc2: 12.8 + 0.92 = 13.72
```

**解决方案：**
1. RRF：只用排名，不用分数
2. 归一化：先把分数映射到 [0, 1]

**应用：** 选择合适的融合策略是混合检索成功的关键。

---

## 卡片7：权重调优方法

**一句话：** 最优权重取决于业务场景，需要通过实验确定。

**场景参考：**
```
技术文档：BM25 60% + 向量 40%（精确术语多）
客服对话：BM25 30% + 向量 70%（自然语言多）
通用场景：BM25 45% + 向量 55%（起点）
```

**调优方法：**
```python
# 网格搜索最优权重
for bm25_w in [0.1, 0.2, ..., 0.9]:
    vector_w = 1 - bm25_w
    recall = evaluate(bm25_w, vector_w)
    if recall > best_recall:
        best_weights = (bm25_w, vector_w)
```

**应用：** 50:50 是起点，数据驱动调优是终点。

---

## 卡片8：召回率 vs 准确率

**一句话：** 混合检索主要提升召回率，准确率交给后续的 ReRank。

**定义：**
```
召回率 = 找到的相关文档数 / 所有相关文档数
准确率 = 找到的相关文档数 / 返回的文档数
```

**RAG 检索策略：**
```
混合检索（高召回）→ ReRank（高准确）→ LLM 生成

第一阶段：宁可多召回，不可漏掉
第二阶段：精细排序，提升准确率
```

**应用：** 混合检索多召回一些（如 Top-20），ReRank 后取 Top-5。

---

## 卡片9：LangChain 中的混合检索

**一句话：** LangChain 的 EnsembleRetriever 内置了混合检索功能。

**代码：**
```python
from langchain.retrievers import EnsembleRetriever
from langchain_community.retrievers import BM25Retriever

# 创建两个检索器
bm25 = BM25Retriever.from_texts(docs)
vector = vectorstore.as_retriever()

# 混合检索器
hybrid = EnsembleRetriever(
    retrievers=[bm25, vector],
    weights=[0.5, 0.5]
)

# 使用
results = hybrid.invoke("查询")
```

**应用：** 快速搭建混合检索，适合原型开发。

---

## 卡片10：混合检索最佳实践

**一句话：** 生产环境的混合检索需要考虑性能、评估和监控。

**最佳实践清单：**

| 方面 | 建议 |
|------|------|
| 召回数量 | 每个检索器召回 2x Top-K |
| 融合策略 | 优先使用 RRF |
| 权重设置 | 基于评估数据调优 |
| 性能优化 | BM25 和向量检索并行执行 |
| 监控指标 | 召回率、延迟、各检索器贡献度 |

**代码模板：**
```python
class ProductionHybridSearch:
    def search(self, query, top_k=5):
        # 并行检索
        bm25_future = executor.submit(self.bm25.search, query, top_k*2)
        vector_future = executor.submit(self.vector.search, query, top_k*2)

        # 融合
        return rrf([bm25_future.result(), vector_future.result()])[:top_k]
```

**应用：** 从原型到生产的完整路径。

---

## 知识卡片总结

| 卡片 | 核心知识 |
|------|----------|
| 1 | 混合检索 = BM25 + 向量 + 融合 |
| 2 | BM25 基于词频统计，擅长精确匹配 |
| 3 | 向量检索基于语义相似，擅长意图理解 |
| 4 | 两种方法各有擅长，互补使用 |
| 5 | RRF 是最简单有效的融合算法 |
| 6 | 分数不可比，不能直接相加 |
| 7 | 权重需要根据场景调优 |
| 8 | 混合检索重召回，ReRank 重准确 |
| 9 | LangChain EnsembleRetriever 快速实现 |
| 10 | 生产环境需要并行、评估、监控 |

---

**下一步：** [10_一句话总结](./10_一句话总结.md) - 最终总结
