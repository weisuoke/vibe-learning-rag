# 化骨绵掌：10个2分钟知识卡片

将 RunnableBranch 拆分成10个独立的知识卡片，每个2分钟内可看完。

---

## 卡片1：直觉理解

**一句话**：RunnableBranch 是 LangChain 中的 if-elif-else，让 AI 工作流能根据条件动态选择执行路径。

**举例**：
```python
# 就像红绿灯路口
branch = RunnableBranch(
    (lambda x: "红灯", 停车),
    (lambda x: "黄灯", 减速),
    (lambda x: "绿灯", 通过),
    谨慎通过  # 灯坏了的默认处理
)
```

**应用**：在 AI Agent 中，根据用户查询类型（代码问题、数学问题、通用问题）路由到不同的专家处理器。

---

## 卡片2：形式化定义

**一句话**：RunnableBranch 是一个 Runnable，接受条件-分支对列表和默认分支，顺序评估条件，执行第一个匹配的分支。

**结构**：
```python
RunnableBranch(
    (condition1: Callable[[Input], bool], branch1: Runnable[Input, Output]),
    (condition2: Callable[[Input], bool], branch2: Runnable[Input, Output]),
    ...
    default_branch: Runnable[Input, Output]
)
```

**关键特性**：
- 顺序评估（从上到下）
- 第一匹配（只执行一个分支）
- 必须有默认分支

**应用**：构建可组合、可追踪的条件路由系统。

---

## 卡片3：条件函数设计

**一句话**：条件函数返回布尔值，可以是 lambda 函数或 Runnable，决定是否执行对应分支。

**两种形式**：
```python
# 1. Lambda 函数（简单条件）
condition = lambda x: "urgent" in x.lower()

# 2. Runnable（复杂条件，如 LLM 分类）
condition = (
    ChatPromptTemplate.from_template("Is urgent? {text}")
    | ChatOpenAI()
    | RunnableLambda(lambda x: "yes" in x.content.lower())
)
```

**设计原则**：
- 快速执行（避免复杂计算）
- 无副作用（纯函数）
- 返回布尔值

**应用**：使用 LLM 做语义分类，实现智能路由。

---

## 卡片4：顺序评估机制

**一句话**：条件从上到下顺序评估，第一个返回 True 的分支执行，后续条件不再评估。

**执行流程**：
```
输入 → 评估条件1 → True? → 执行分支1 → 返回
              ↓ False
         评估条件2 → True? → 执行分支2 → 返回
              ↓ False
         评估条件3 → True? → 执行分支3 → 返回
              ↓ False
         执行默认分支 → 返回
```

**关键点**：
- 条件顺序 = 优先级
- 从具体到通用排序
- 第一匹配就停止

**应用**：把最常见的情况放在前面，优化性能。

---

## 卡片5：默认分支的作用

**一句话**：默认分支是兜底处理，所有条件都不匹配时执行，必须提供。

**三种策略**：
```python
# 1. 通用处理
default = general_handler

# 2. 错误处理
default = RunnableLambda(lambda x: {"error": "No match"})

# 3. 日志 + 兜底
def logged_default(x):
    logger.warning(f"No match: {x}")
    return fallback_response(x)
```

**为什么必须**：
- 保证所有输入都有处理方式
- 避免未处理情况导致错误
- 提供明确的兜底行为

**应用**：在生产环境中，默认分支记录日志并返回友好错误。

---

## 卡片6：与 if-else 的区别

**一句话**：RunnableBranch 是声明式、可组合、可追踪的，if-else 是命令式、不可组合、黑盒的。

**对比**：
| 特性 | RunnableBranch | if-else |
|------|----------------|---------|
| **组合性** | ✅ 可用 `\|` 组合 | ❌ 无法组合 |
| **可观测性** | ✅ LangSmith 追踪 | ❌ 黑盒 |
| **异步支持** | ✅ ainvoke/astream | ⚠️ 需手动处理 |
| **类型安全** | ✅ 泛型约束 | ❌ 无约束 |

**何时用 RunnableBranch**：
- 需要与 LCEL 组合
- 需要追踪执行路径
- 需要异步和流式

**应用**：在 AI Agent 中，RunnableBranch 让路由逻辑可追踪、可调试。

---

## 卡片7：与其他路由方式对比

**一句话**：RunnableBranch（条件路由）、RouterRunnable（键值路由）、RunnableLambda（自定义路由）、Agent（智能路由）各有适用场景。

**选择标准**：
```
需要智能推理？ → Agent
需要复杂逻辑？ → RunnableLambda
固定路由表？ → RouterRunnable
简单条件路由？ → RunnableBranch
```

**RunnableBranch 适合**：
- 条件判断简单清晰
- 分支数量有限（< 10）
- 强调声明式风格

**2025-2026 趋势**：
- 新项目：优先 RunnableLambda（更灵活）
- 简单场景：RunnableBranch（仍好用）
- 不强制迁移

**应用**：根据实际需求选择，不盲目追新。

---

## 卡片8：LCEL 组合

**一句话**：RunnableBranch 是 Runnable，可以用管道操作符 `|` 与其他 Runnable 无缝组合。

**组合模式**：
```python
# 预处理 → 路由 → 后处理
chain = (
    preprocessor           # 数据清洗
    | RunnableBranch(...)  # 条件路由
    | postprocessor        # 结果格式化
)

# 分类 → 路由
chain = (
    classifier             # LLM 分类
    | RunnableBranch(...)  # 根据分类路由
)

# 嵌套路由
main_router = RunnableBranch(
    (condition1, sub_router1),  # 子路由也是 RunnableBranch
    (condition2, sub_router2),
    default_router
)
```

**优势**：
- 声明式数据流
- 配置自动传递
- 可追踪整个链

**应用**：构建复杂的 AI 工作流，每个环节都可追踪。

---

## 卡片9：性能优化技巧

**一句话**：通过条件顺序优化、缓存、预计算、并行评估提升 RunnableBranch 性能。

**4个优化技巧**：
```python
# 1. 条件顺序：常见情况在前
branch = RunnableBranch(
    (fast_common_condition, handler1),  # 快速 + 常见
    (slow_rare_condition, handler2),    # 慢速 + 罕见
    default_handler
)

# 2. 缓存条件结果
@lru_cache(maxsize=1000)
def expensive_check(key):
    return expensive_computation(key)

# 3. 预计算
preprocessor = RunnableLambda(lambda x: {
    **x,
    "computed": expensive_computation(x)
})
condition = lambda x: x["computed"] > threshold

# 4. 并行评估独立条件
parallel_conditions = RunnableParallel(
    cond1=check1,
    cond2=check2,
    cond3=check3
)
```

**应用**：在高并发场景中，优化可显著降低延迟。

---

## 卡片10：生产环境最佳实践

**一句话**：生产环境需要完善的错误处理、监控日志、配置管理、安全控制。

**生产检查清单**：
```python
# 1. 错误处理
def safe_handler(x):
    try:
        return handler.invoke(x)
    except Exception as e:
        logger.error(f"Failed: {e}")
        return fallback_response(x)

# 2. 监控日志
config = RunnableConfig(
    callbacks=[LangSmithHandler()],
    tags=["production", "user-123"]
)

# 3. 配置管理
router = create_router(
    high_priority_model=os.getenv("HIGH_PRIORITY_MODEL"),
    normal_priority_model=os.getenv("NORMAL_PRIORITY_MODEL")
)

# 4. 安全控制
risk_router = RunnableBranch(
    (lambda x: assess_risk(x) > 0.5, reject_handler),
    safe_handler
)
```

**关键指标**：
- 延迟（P50, P95, P99）
- 成功率
- 错误率
- 每个分支的使用频率

**应用**：确保 AI 系统稳定可靠地运行。

---

## 学习路径建议

### 快速入门（30分钟）
1. 卡片1：直觉理解
2. 卡片2：形式化定义
3. 卡片4：顺序评估机制
4. 卡片5：默认分支的作用

### 深入理解（1小时）
5. 卡片3：条件函数设计
6. 卡片6：与 if-else 的区别
7. 卡片7：与其他路由方式对比
8. 卡片8：LCEL 组合

### 实战应用（2小时）
9. 卡片9：性能优化技巧
10. 卡片10：生产环境最佳实践

---

## 知识卡片索引

| 卡片 | 主题 | 关键词 | 难度 |
|------|------|--------|------|
| 1 | 直觉理解 | 是什么、类比 | ⭐ |
| 2 | 形式化定义 | 结构、特性 | ⭐⭐ |
| 3 | 条件函数设计 | Lambda、Runnable | ⭐⭐ |
| 4 | 顺序评估机制 | 执行流程、优先级 | ⭐⭐ |
| 5 | 默认分支 | 兜底、策略 | ⭐ |
| 6 | vs if-else | 对比、优势 | ⭐⭐ |
| 7 | vs 其他路由 | 选择标准、趋势 | ⭐⭐⭐ |
| 8 | LCEL 组合 | 管道、组合模式 | ⭐⭐⭐ |
| 9 | 性能优化 | 缓存、并行 | ⭐⭐⭐ |
| 10 | 生产实践 | 监控、安全 | ⭐⭐⭐⭐ |

---

## 碎片化学习建议

**每天2分钟**：
- 第1天：卡片1（直觉理解）
- 第2天：卡片2（形式化定义）
- 第3天：卡片3（条件函数）
- ...
- 第10天：卡片10（生产实践）

**周末复习**：
- 重新阅读所有卡片
- 尝试实现一个完整示例
- 总结学习心得

**实战练习**：
- 用 RunnableBranch 实现意图识别
- 用 RunnableBranch 实现多模型路由
- 用 RunnableBranch 实现风险评估

---

**记住**：知识卡片是碎片化学习的工具，每个卡片独立完整，可以随时查阅和复习！
