# 最小可用知识

> 掌握20%核心知识，解决80%的Graph和知识图谱问题

---

## 核心理念

**最小可用知识**：只学习最常用、最基础的知识，快速上手实战。

**目标**：用最少的时间掌握Graph的核心概念，能够：
- 手写基本的Graph类
- 理解邻接表和邻接矩阵的区别
- 使用NetworkX构建知识图谱
- 理解GraphRAG的基本原理

---

## 4.1 Graph的两种表示方法

### 邻接表（最常用）⭐⭐⭐⭐⭐

**定义**：用字典存储每个节点的邻居列表

```python
# 邻接表表示
graph = {
    "A": ["B", "C"],      # A连接到B和C
    "B": ["C"],           # B连接到C
    "C": []               # C没有出边
}
```

**何时使用**：
- ✅ 稀疏图（边数远小于V²）
- ✅ 大规模图（节点数>1000）
- ✅ 知识图谱（实际应用中99%的情况）

**空间复杂度**：O(V + E)

### 邻接矩阵（了解即可）⭐⭐

**定义**：用二维数组表示边的存在

```python
# 邻接矩阵表示（3个节点）
matrix = [
    [0, 1, 1],  # A连接到B和C
    [0, 0, 1],  # B连接到C
    [0, 0, 0]   # C没有出边
]
```

**何时使用**：
- ✅ 密集图（边数接近V²）
- ✅ 需要O(1)查询边是否存在
- ✅ 小规模图（节点数<100）

**空间复杂度**：O(V²)

**选择标准**：
```python
# 简单判断
if 边数 < 节点数²/2:
    使用邻接表  # 大多数情况
else:
    使用邻接矩阵
```

---

## 4.2 手写基本Graph类

**最小可用实现**：

```python
class Graph:
    """基于邻接表的Graph实现"""

    def __init__(self, directed=False):
        """
        directed: True表示有向图，False表示无向图
        """
        self.graph = {}
        self.directed = directed

    def add_node(self, node):
        """添加节点"""
        if node not in self.graph:
            self.graph[node] = []

    def add_edge(self, u, v):
        """添加边：u -> v"""
        # 确保节点存在
        self.add_node(u)
        self.add_node(v)

        # 添加边
        if v not in self.graph[u]:
            self.graph[u].append(v)

        # 无向图需要添加反向边
        if not self.directed and u not in self.graph[v]:
            self.graph[v].append(u)

    def get_neighbors(self, node):
        """获取节点的邻居"""
        return self.graph.get(node, [])

    def has_edge(self, u, v):
        """检查边是否存在"""
        return v in self.graph.get(u, [])

# 使用示例
g = Graph(directed=True)
g.add_edge("A", "B")
g.add_edge("A", "C")
g.add_edge("B", "C")

print(g.get_neighbors("A"))  # ["B", "C"]
print(g.has_edge("A", "B"))  # True
```

**这个实现足以：**
- ✅ 构建基本的图结构
- ✅ 支持有向图和无向图
- ✅ 进行基本的查询操作
- ✅ 作为学习和面试的基础

---

## 4.3 知识图谱三元组(SPO)

**定义**：知识图谱的基本单元

```python
# 三元组格式：(Subject, Predicate, Object)
triple = ("张三", "工作于", "阿里巴巴")
#         主语    谓语      宾语
```

**核心概念**：
- **Subject（主语）**：实体1
- **Predicate（谓语）**：关系
- **Object（宾语）**：实体2

**存储方式**：

```python
# 方式1：列表存储
knowledge_graph = [
    ("张三", "工作于", "阿里巴巴"),
    ("张三", "居住在", "杭州"),
    ("阿里巴巴", "位于", "杭州")
]

# 方式2：转换为Graph（推荐）
def triples_to_graph(triples):
    graph = {}
    for s, p, o in triples:
        key = (s, p)  # 用(主语, 关系)作为键
        if key not in graph:
            graph[key] = []
        graph[key].append(o)
    return graph

kg = triples_to_graph(knowledge_graph)
# 查询：张三工作于哪里？
print(kg[("张三", "工作于")])  # ["阿里巴巴"]
```

**实际应用**：
- RAG系统的结构化知识存储
- 多跳推理的基础单元
- 知识问答的核心数据

---

## 4.4 使用NetworkX（最快上手）

**安装**：
```bash
uv add networkx
```

**基本使用**：

```python
import networkx as nx

# 1. 创建图
G = nx.DiGraph()  # 有向图（知识图谱常用）
# G = nx.Graph()  # 无向图（社交网络常用）

# 2. 添加节点和边
G.add_node("张三")
G.add_node("阿里巴巴")
G.add_edge("张三", "阿里巴巴", relation="工作于")

# 3. 批量添加三元组
triples = [
    ("张三", "阿里巴巴", {"relation": "工作于"}),
    ("张三", "杭州", {"relation": "居住在"}),
    ("阿里巴巴", "杭州", {"relation": "位于"})
]
G.add_edges_from(triples)

# 4. 查询
print(list(G.neighbors("张三")))  # ["阿里巴巴", "杭州"]
print(G["张三"]["阿里巴巴"])      # {"relation": "工作于"}

# 5. 路径查询
if nx.has_path(G, "张三", "杭州"):
    path = nx.shortest_path(G, "张三", "杭州")
    print(path)  # ["张三", "杭州"] 或 ["张三", "阿里巴巴", "杭州"]
```

**这些操作足以：**
- ✅ 构建知识图谱
- ✅ 进行基本查询
- ✅ 实现多跳推理
- ✅ 可视化图结构

---

## 4.5 GraphRAG核心流程（理解即可）

**5步核心流程**：

```python
# 伪代码展示核心流程
class SimpleGraphRAG:
    def __init__(self, llm):
        self.llm = llm
        self.graph = nx.DiGraph()

    # 步骤1：提取实体关系
    def extract_triples(self, text):
        prompt = f"从以下文本中提取(主语, 关系, 宾语)三元组：\n{text}"
        response = self.llm.generate(prompt)
        return parse_triples(response)

    # 步骤2：构建知识图谱
    def build_graph(self, documents):
        for doc in documents:
            triples = self.extract_triples(doc)
            for s, p, o in triples:
                self.graph.add_edge(s, o, relation=p)

    # 步骤3：检索相关实体
    def retrieve(self, query):
        # 提取查询中的实体
        entities = self.extract_entities(query)

        # 获取实体的邻居（局部检索）
        context = []
        for entity in entities:
            neighbors = list(self.graph.neighbors(entity))
            context.extend(neighbors)

        return context

    # 步骤4：生成答案
    def generate(self, query, context):
        prompt = f"基于以下知识：{context}\n回答问题：{query}"
        return self.llm.generate(prompt)

    # 步骤5：完整查询
    def query(self, question):
        context = self.retrieve(question)
        answer = self.generate(question, context)
        return answer
```

**核心理解**：
1. **提取**：从文本中提取结构化知识（三元组）
2. **构建**：将三元组组织成图
3. **检索**：基于图结构检索相关知识
4. **生成**：将检索结果注入LLM生成答案
5. **优势**：结构化知识 + 多跳推理 + 减少幻觉

---

## 这些知识足以做什么？

### ✅ 能做的事

1. **构建简单知识图谱**
   - 手写Graph类或使用NetworkX
   - 存储实体关系
   - 进行基本查询

2. **理解GraphRAG原理**
   - 知道为什么需要GraphRAG
   - 理解核心流程
   - 能解释给别人听

3. **实现基础应用**
   - 文档知识图谱
   - 简单的多跳问答
   - 关系可视化

4. **通过面试**
   - 回答Graph基础问题
   - 解释邻接表vs邻接矩阵
   - 讨论知识图谱应用

### ❌ 暂时做不了的事

1. **生产级GraphRAG系统**
   - 需要学习社区检测
   - 需要学习混合检索策略
   - 需要学习评估和优化

2. **大规模图处理**
   - 需要学习图数据库（Neo4j）
   - 需要学习分布式图计算
   - 需要学习性能优化

3. **图神经网络**
   - 需要学习GNN原理
   - 需要学习PyTorch Geometric
   - 需要学习图表示学习

**但这些都可以在掌握基础后逐步学习！**

---

## 快速检查清单

掌握以下内容，就算完成最小可用知识学习：

- [ ] 能解释邻接表和邻接矩阵的区别
- [ ] 能手写基本的Graph类（邻接表实现）
- [ ] 理解知识图谱三元组(SPO)结构
- [ ] 能使用NetworkX创建和查询图
- [ ] 理解GraphRAG的5步核心流程
- [ ] 能解释为什么GraphRAG比传统RAG更好

---

## 下一步学习建议

### 如果想深入理解原理
→ 学习 `03_核心概念` 的8个详细概念

### 如果想快速实战
→ 学习 `07_实战代码` 的4个场景

### 如果想准备面试
→ 学习 `08_面试必问` 的高频问题

### 如果想系统掌握
→ 按顺序学习所有10个维度

---

**记住：** 最小可用知识不是终点，而是快速上手的起点！掌握这些后，根据实际需求深入学习。
