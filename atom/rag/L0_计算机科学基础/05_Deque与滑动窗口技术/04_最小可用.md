# 最小可用知识

> 掌握以下内容，就能开始使用 Deque 和滑动窗口技术解决 80% 的实际问题

---

## 核心理念：20% 知识解决 80% 问题

本文档聚焦于**最常用、最实用**的知识点，让你快速上手：

1. **Deque 的 4 个核心操作**
2. **固定大小窗口的自动淘汰机制**
3. **AI Agent 对话历史管理模式**
4. **滑动窗口的双指针技巧**
5. **5 分钟快速实践**

---

## 4.1 Deque 的 4 个核心操作

### 为什么只需要 4 个操作？

**80% 的场景只需要这 4 个方法：**

```python
from collections import deque

d = deque([1, 2, 3])

# 1. 右端添加 - 最常用
d.append(4)        # [1, 2, 3, 4]

# 2. 左端删除 - 滑动窗口核心
d.popleft()        # [2, 3, 4]

# 3. 左端添加 - 反向滑动
d.appendleft(0)    # [0, 2, 3, 4]

# 4. 右端删除 - 栈操作
d.pop()            # [0, 2, 3]
```

### 操作时间复杂度

| 操作 | 时间复杂度 | 使用场景 |
|------|-----------|---------|
| `append(x)` | O(1) | 队尾入队、窗口右移 |
| `popleft()` | O(1) | 队首出队、窗口左移 |
| `appendleft(x)` | O(1) | 队首入队、反向遍历 |
| `pop()` | O(1) | 队尾出队、栈操作 |

### 实际应用示例

```python
from collections import deque

# 场景1：FIFO 队列
queue = deque()
queue.append("任务1")    # 入队
queue.append("任务2")
task = queue.popleft()  # 出队："任务1"

# 场景2：滑动窗口
window = deque()
for item in [1, 2, 3, 4, 5]:
    window.append(item)      # 添加新元素
    if len(window) > 3:
        window.popleft()     # 移除旧元素
    print(list(window))
# 输出：[1], [1,2], [1,2,3], [2,3,4], [3,4,5]

# 场景3：双端栈
stack = deque()
stack.append(1)        # 压栈
stack.appendleft(0)    # 从另一端压栈
print(stack.pop())     # 1
print(stack.popleft()) # 0
```

---

## 4.2 固定大小窗口：maxlen 参数

### 核心特性：自动淘汰

**这是 AI Agent 开发最重要的特性！**

```python
from collections import deque

# 创建固定大小的 deque
memory = deque(maxlen=3)

memory.append(1)  # [1]
memory.append(2)  # [1, 2]
memory.append(3)  # [1, 2, 3]
memory.append(4)  # [2, 3, 4]  ← 自动移除最左边的 1

print(memory)  # deque([2, 3, 4], maxlen=3)
```

### 为什么这个特性重要？

**传统方案的问题：**
```python
# ❌ 使用列表：需要手动管理大小
messages = []
messages.append(new_msg)
if len(messages) > max_size:
    messages.pop(0)  # O(n) 时间复杂度！
```

**Deque 的优势：**
```python
# ✅ 使用 deque：自动管理，O(1) 时间复杂度
messages = deque(maxlen=max_size)
messages.append(new_msg)  # 自动淘汰，无需手动检查
```

### AI Agent 核心应用：对话历史管理

```python
from collections import deque
from typing import Dict, List

class ConversationMemory:
    """AI Agent 对话记忆管理器"""

    def __init__(self, max_turns: int = 10):
        # 保留最近 max_turns 轮对话
        # 每轮包含 user + assistant 两条消息
        self.messages = deque(maxlen=max_turns * 2)

    def add_user_message(self, content: str):
        """添加用户消息"""
        self.messages.append({
            "role": "user",
            "content": content
        })

    def add_assistant_message(self, content: str):
        """添加助手消息"""
        self.messages.append({
            "role": "assistant",
            "content": content
        })

    def get_context(self) -> List[Dict]:
        """获取当前上下文"""
        return list(self.messages)

# 使用示例
memory = ConversationMemory(max_turns=3)

# 第1轮对话
memory.add_user_message("你好")
memory.add_assistant_message("你好！有什么可以帮你的？")

# 第2轮对话
memory.add_user_message("今天天气怎么样？")
memory.add_assistant_message("今天天气晴朗。")

# 第3轮对话
memory.add_user_message("推荐一部电影")
memory.add_assistant_message("推荐《肖申克的救赎》。")

# 第4轮对话 - 自动淘汰第1轮
memory.add_user_message("谢谢")
memory.add_assistant_message("不客气！")

# 此时只保留最近3轮对话（6条消息）
print(f"当前消息数: {len(memory.get_context())}")  # 6
```

**2025-2026 实际应用：**

**OpenAI Agents SDK (2026):**
```python
from openai import OpenAI
from collections import deque

class TrimmingSession:
    """OpenAI Agents SDK 风格的会话管理"""
    def __init__(self, max_turns: int = 10):
        self.messages = deque(maxlen=max_turns * 2)
        self.client = OpenAI()

    def chat(self, user_message: str) -> str:
        # 添加用户消息
        self.messages.append({"role": "user", "content": user_message})

        # 调用 LLM
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=list(self.messages)
        )

        # 添加助手消息
        assistant_message = response.choices[0].message.content
        self.messages.append({"role": "assistant", "content": assistant_message})

        return assistant_message
```

**来源**: [OpenAI Agents SDK - Session Memory](https://developers.openai.com/cookbook/examples/agents_sdk/session_memory)
**时间**: 2026
**关键点**: 使用 `deque(maxlen=N)` 实现自动淘汰的对话历史

---

## 4.3 滑动窗口：双指针技巧

### 核心模式：固定大小窗口

**问题：** 给定数组和窗口大小 k，求每个窗口的某个属性（和、最大值等）

**解决方案：** 使用 deque 维护窗口

```python
from collections import deque

def sliding_window_sum(arr: list, k: int) -> list:
    """计算每个大小为 k 的窗口的和"""
    if not arr or k <= 0 or k > len(arr):
        return []

    window = deque()
    result = []
    window_sum = 0

    for i, num in enumerate(arr):
        # 添加新元素
        window.append(num)
        window_sum += num

        # 窗口大小达到 k
        if len(window) == k:
            result.append(window_sum)
            # 移除最左边的元素
            removed = window.popleft()
            window_sum -= removed

    return result

# 测试
arr = [1, 2, 3, 4, 5, 6]
k = 3
print(sliding_window_sum(arr, k))  # [6, 9, 12, 15]
# 解释：[1,2,3]=6, [2,3,4]=9, [3,4,5]=12, [4,5,6]=15
```

### 核心模式：可变大小窗口

**问题：** 找到满足某个条件的最长/最短子数组

**解决方案：** 双指针 + 动态调整窗口

```python
def longest_substring_without_repeating(s: str) -> int:
    """最长无重复字符子串"""
    seen = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        # 如果字符重复，收缩左边界
        while s[right] in seen:
            seen.remove(s[left])
            left += 1

        # 添加当前字符
        seen.add(s[right])

        # 更新最大长度
        max_length = max(max_length, right - left + 1)

    return max_length

# 测试
print(longest_substring_without_repeating("abcabcbb"))  # 3 ("abc")
print(longest_substring_without_repeating("bbbbb"))     # 1 ("b")
print(longest_substring_without_repeating("pwwkew"))    # 3 ("wke")
```

### 何时使用 deque vs 双指针？

| 场景 | 使用方案 | 原因 |
|------|---------|------|
| **固定大小窗口** + **需要维护窗口内元素** | deque | 需要访问窗口内所有元素 |
| **固定大小窗口** + **只需要窗口边界** | 双指针 | 不需要存储元素，更节省空间 |
| **可变大小窗口** | 双指针 | 窗口大小动态变化 |
| **需要维护单调性** | deque（单调队列） | 需要快速获取最值 |

---

## 4.4 AI Agent Token 窗口管理

### 核心问题：LLM Context Window 限制

```
GPT-4:     8K / 32K / 128K tokens
Claude 3:  200K tokens
Gemini:    1M tokens

实际对话可能无限长 → 必须管理 token 窗口
```

### 简单方案：固定消息数量

```python
from collections import deque

class SimpleTokenManager:
    """简单的 Token 窗口管理器"""

    def __init__(self, max_messages: int = 20):
        self.messages = deque(maxlen=max_messages)

    def add_message(self, role: str, content: str):
        self.messages.append({"role": role, "content": content})

    def get_messages(self) -> list:
        return list(self.messages)

# 使用示例
manager = SimpleTokenManager(max_messages=10)

for i in range(15):
    manager.add_message("user", f"消息 {i}")
    manager.add_message("assistant", f"回复 {i}")

# 只保留最近 10 条消息
print(f"当前消息数: {len(manager.get_messages())}")  # 10
```

### 进阶方案：基于 Token 计数

```python
from collections import deque
import tiktoken

class TokenWindowManager:
    """基于 Token 计数的窗口管理器"""

    def __init__(self, max_tokens: int = 4096, model: str = "gpt-4"):
        self.max_tokens = max_tokens
        self.messages = deque()
        self.encoding = tiktoken.encoding_for_model(model)

    def count_tokens(self, text: str) -> int:
        """计算文本的 token 数量"""
        return len(self.encoding.encode(text))

    def get_total_tokens(self) -> int:
        """计算当前所有消息的 token 总数"""
        total = 0
        for msg in self.messages:
            total += self.count_tokens(msg["content"])
        return total

    def add_message(self, role: str, content: str):
        """添加消息，自动淘汰超出窗口的消息"""
        # 添加新消息
        self.messages.append({"role": role, "content": content})

        # 移除旧消息直到满足 token 限制
        while self.get_total_tokens() > self.max_tokens and len(self.messages) > 1:
            self.messages.popleft()

    def get_messages(self) -> list:
        return list(self.messages)

# 使用示例
manager = TokenWindowManager(max_tokens=100)

manager.add_message("user", "这是一个很长的消息" * 10)
manager.add_message("assistant", "这是回复" * 5)
manager.add_message("user", "继续对话")

print(f"当前 token 数: {manager.get_total_tokens()}")
print(f"消息数量: {len(manager.get_messages())}")
```

**2025-2026 最佳实践：**

**来源**: [Context Length Optimization Guide 2025](https://local-ai-zone.github.io/guides/context-length-optimization-ultimate-guide-2025.html)
**时间**: 2025
**关键点**: 使用滑动窗口 + Token 计数优化上下文管理

---

## 4.5 五分钟快速实践

### 练习1：实现简单的对话历史管理器（2分钟）

```python
from collections import deque

# TODO: 创建一个保留最近 5 轮对话的管理器
memory = deque(maxlen=10)  # 5轮 × 2条消息

# TODO: 添加 3 轮对话
memory.append({"role": "user", "content": "你好"})
memory.append({"role": "assistant", "content": "你好！"})

memory.append({"role": "user", "content": "天气如何？"})
memory.append({"role": "assistant", "content": "天气晴朗。"})

memory.append({"role": "user", "content": "推荐电影"})
memory.append({"role": "assistant", "content": "推荐《肖申克的救赎》。"})

# TODO: 打印当前消息数
print(f"消息数: {len(memory)}")  # 6

# TODO: 添加更多对话，观察自动淘汰
for i in range(5):
    memory.append({"role": "user", "content": f"消息 {i}"})
    memory.append({"role": "assistant", "content": f"回复 {i}"})

print(f"最终消息数: {len(memory)}")  # 10（自动淘汰了旧消息）
```

### 练习2：计算滑动窗口的平均值（2分钟）

```python
from collections import deque

def sliding_window_average(arr: list, k: int) -> list:
    """计算每个大小为 k 的窗口的平均值"""
    # TODO: 实现滑动窗口平均值
    window = deque()
    result = []
    window_sum = 0

    for num in arr:
        window.append(num)
        window_sum += num

        if len(window) == k:
            result.append(window_sum / k)
            removed = window.popleft()
            window_sum -= removed

    return result

# 测试
arr = [1, 2, 3, 4, 5, 6]
k = 3
print(sliding_window_average(arr, k))  # [2.0, 3.0, 4.0, 5.0]
```

### 练习3：实现 API 限流器（1分钟）

```python
from collections import deque
import time

class RateLimiter:
    """简单的滑动窗口限流器"""

    def __init__(self, max_requests: int, window_seconds: int):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests = deque()

    def allow_request(self) -> bool:
        """检查是否允许请求"""
        now = time.time()

        # 移除窗口外的请求
        while self.requests and self.requests[0] < now - self.window_seconds:
            self.requests.popleft()

        # 检查是否超过限制
        if len(self.requests) < self.max_requests:
            self.requests.append(now)
            return True
        return False

# 测试：每秒最多 3 个请求
limiter = RateLimiter(max_requests=3, window_seconds=1)

for i in range(5):
    if limiter.allow_request():
        print(f"请求 {i}: 允许")
    else:
        print(f"请求 {i}: 拒绝（超过限流）")
```

---

## 这些知识足以做什么？

### ✅ 可以完成的任务

1. **AI Agent 开发**
   - 实现对话历史管理
   - 管理 LLM 上下文窗口
   - 实现流式输出缓冲

2. **算法问题**
   - 解决固定大小滑动窗口问题
   - 实现简单的 FIFO 队列
   - 处理双端操作场景

3. **实时系统**
   - 实现日志缓冲
   - 实现 API 限流器
   - 实现性能监控（滑动窗口统计）

### ⚠️ 还不能完成的任务

1. **复杂算法**
   - 滑动窗口最大值（需要单调队列）
   - LRU 缓存（需要 OrderedDict 或 deque+HashMap）
   - 复杂的双指针问题

2. **生产级实现**
   - 线程安全的 deque 操作
   - 语义压缩的上下文管理
   - 分布式限流

**解决方案：** 继续学习后续文档
- **03_核心概念_02_单调队列原理.md** - 学习单调队列
- **03_核心概念_04_LRU缓存实现.md** - 学习 LRU 缓存
- **07_实战代码_05_上下文窗口优化.md** - 学习生产级实现

---

## 常见错误与修复

### 错误1：忘记 deque 不支持索引切片

```python
from collections import deque

d = deque([1, 2, 3, 4, 5])

# ❌ 错误：deque 不支持切片
# result = d[1:3]  # TypeError

# ✅ 正确：转换为列表
result = list(d)[1:3]  # [2, 3]

# ✅ 或者使用 itertools
from itertools import islice
result = list(islice(d, 1, 3))  # [2, 3]
```

### 错误2：混淆 append 和 appendleft

```python
from collections import deque

d = deque([1, 2, 3])

# ❌ 错误：想在左边添加，却用了 append
d.append(0)  # [1, 2, 3, 0]  ← 添加到右边了

# ✅ 正确：使用 appendleft
d = deque([1, 2, 3])
d.appendleft(0)  # [0, 1, 2, 3]  ← 添加到左边
```

### 错误3：maxlen 设置后无法修改

```python
from collections import deque

# ❌ 错误：创建后无法修改 maxlen
d = deque(maxlen=3)
# d.maxlen = 5  # AttributeError: attribute 'maxlen' of 'collections.deque' objects is not writable

# ✅ 正确：重新创建 deque
d = deque(d, maxlen=5)
```

### 错误4：忘记 popleft() 会抛出异常

```python
from collections import deque

d = deque()

# ❌ 错误：空 deque 调用 popleft() 会抛出异常
# d.popleft()  # IndexError: pop from an empty deque

# ✅ 正确：先检查是否为空
if d:
    d.popleft()

# ✅ 或者使用 try-except
try:
    d.popleft()
except IndexError:
    print("deque 为空")
```

---

## 快速参考卡

### Deque 核心操作

```python
from collections import deque

# 创建
d = deque([1, 2, 3])           # 普通 deque
d = deque([1, 2, 3], maxlen=5) # 固定大小

# 添加
d.append(x)        # 右端添加
d.appendleft(x)    # 左端添加

# 删除
d.pop()            # 右端删除并返回
d.popleft()        # 左端删除并返回

# 查询
len(d)             # 长度
d[0]               # 访问元素（支持索引，不支持切片）
x in d             # 检查元素是否存在

# 转换
list(d)            # 转换为列表
```

### 滑动窗口模板

```python
from collections import deque

# 固定大小窗口
def fixed_window(arr, k):
    window = deque()
    result = []

    for item in arr:
        window.append(item)
        if len(window) == k:
            # 处理窗口
            result.append(process(window))
            window.popleft()

    return result

# 可变大小窗口
def variable_window(arr):
    left = 0
    result = []

    for right in range(len(arr)):
        # 扩展窗口
        while condition:
            # 收缩窗口
            left += 1
        # 处理窗口
        result.append(process(arr[left:right+1]))

    return result
```

### AI Agent 记忆管理模板

```python
from collections import deque

class ConversationMemory:
    def __init__(self, max_turns: int = 10):
        self.messages = deque(maxlen=max_turns * 2)

    def add_message(self, role: str, content: str):
        self.messages.append({"role": role, "content": content})

    def get_context(self) -> list:
        return list(self.messages)
```

---

## 下一步学习路径

### 如果你想深入理解原理
→ **02_第一性原理.md** - 理解为什么需要双端操作

### 如果你想学习更多算法
→ **03_核心概念_02_单调队列原理.md** - 学习单调队列
→ **08_面试必问.md** - 学习经典面试题

### 如果你想应用到 AI Agent
→ **03_核心概念_05_AI_Agent短期记忆.md** - AI Agent 记忆系统
→ **07_实战代码_04_AI_Agent记忆管理.md** - 完整代码示例

### 如果你想生产级实现
→ **07_实战代码_05_上下文窗口优化.md** - Token 窗口优化
→ **07_实战代码_06_生产级实践.md** - 线程安全、错误处理

---

## 学习检查清单

完成以下任务，确保掌握最小可用知识：

- [ ] 能够使用 `append()`, `appendleft()`, `pop()`, `popleft()` 四个操作
- [ ] 理解 `maxlen` 参数的自动淘汰机制
- [ ] 能够实现简单的对话历史管理器
- [ ] 能够计算固定大小滑动窗口的和/平均值
- [ ] 能够使用双指针解决可变大小窗口问题
- [ ] 理解何时使用 deque vs 双指针
- [ ] 能够实现简单的 API 限流器
- [ ] 知道 deque 的常见错误和修复方法

---

## 总结

**最小可用知识的核心：**

1. **4 个操作**：`append()`, `appendleft()`, `pop()`, `popleft()`
2. **1 个参数**：`maxlen` 实现自动淘汰
3. **2 个模式**：固定窗口（deque）+ 可变窗口（双指针）
4. **3 个应用**：对话管理 + Token 窗口 + 限流器

**记住：** 掌握这些知识，你已经可以解决 80% 的实际问题了！

---

**版本**: v1.0
**最后更新**: 2026-02-13
**适用于**: Python 3.13+, AI Agent 开发, RAG 系统
