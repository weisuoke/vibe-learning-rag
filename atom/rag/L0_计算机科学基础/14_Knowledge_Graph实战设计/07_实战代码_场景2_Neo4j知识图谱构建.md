# 实战代码 场景2：Neo4j知识图谱构建

## 场景描述

从提取的三元组构建完整的Neo4j知识图谱，包括批量导入、索引创建、查询优化。

**目标**：
- 连接Neo4j数据库
- 批量导入三元组
- 创建索引
- 实现基本查询
- 图可视化

**技术栈**：
- Python 3.13+
- neo4j-driver
- OpenAI API

---

## 完整代码

```python
"""
Neo4j知识图谱构建

功能：
1. 连接Neo4j数据库
2. 批量导入三元组
3. 创建索引
4. 基本查询
5. 统计分析
"""

from neo4j import GraphDatabase
from typing import List, Dict, Optional
from dataclasses import dataclass
import time


@dataclass
class Triple:
    """三元组"""
    subject: str
    subject_type: str
    predicate: str
    object: str
    object_type: str


class Neo4jKnowledgeGraph:
    """Neo4j知识图谱"""

    def __init__(self, uri: str, user: str, password: str):
        """初始化连接"""
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
        self._test_connection()

    def _test_connection(self):
        """测试连接"""
        try:
            with self.driver.session() as session:
                result = session.run("RETURN 1 AS test")
                result.single()
                print("✓ Neo4j连接成功")
        except Exception as e:
            print(f"✗ Neo4j连接失败: {e}")
            raise

    def close(self):
        """关闭连接"""
        self.driver.close()

    def clear_database(self):
        """清空数据库（谨慎使用）"""
        with self.driver.session() as session:
            session.run("MATCH (n) DETACH DELETE n")
            print("✓ 数据库已清空")

    def create_indexes(self):
        """创建索引"""
        with self.driver.session() as session:
            # 实体名称索引
            session.run("""
                CREATE INDEX entity_name IF NOT EXISTS
                FOR (e:Entity) ON (e.name)
            """)

            # 实体类型索引
            session.run("""
                CREATE INDEX entity_type IF NOT EXISTS
                FOR (e:Entity) ON (e.type)
            """)

            print("✓ 索引创建完成")

    def batch_import_triples(
        self,
        triples: List[Triple],
        batch_size: int = 1000
    ):
        """批量导入三元组"""
        total = len(triples)
        print(f"开始导入 {total} 个三元组...")

        start_time = time.time()

        with self.driver.session() as session:
            for i in range(0, total, batch_size):
                batch = triples[i:i + batch_size]

                # 转换为字典列表
                batch_data = [
                    {
                        "subject": t.subject,
                        "subject_type": t.subject_type,
                        "predicate": t.predicate,
                        "object": t.object,
                        "object_type": t.object_type
                    }
                    for t in batch
                ]

                # 批量导入
                session.run("""
                    UNWIND $batch AS triple
                    MERGE (s:Entity {name: triple.subject})
                    ON CREATE SET s.type = triple.subject_type,
                                  s.created = timestamp()
                    ON MATCH SET s.updated = timestamp()

                    MERGE (o:Entity {name: triple.object})
                    ON CREATE SET o.type = triple.object_type,
                                  o.created = timestamp()
                    ON MATCH SET o.updated = timestamp()

                    MERGE (s)-[r:RELATION {type: triple.predicate}]->(o)
                    ON CREATE SET r.created = timestamp()
                    ON MATCH SET r.updated = timestamp()
                """, batch=batch_data)

                progress = min(i + batch_size, total)
                print(f"  进度: {progress}/{total} ({progress*100//total}%)")

        elapsed = time.time() - start_time
        print(f"✓ 导入完成，耗时 {elapsed:.2f}秒")

    def query_entity(self, entity_name: str) -> Dict:
        """查询实体信息"""
        with self.driver.session() as session:
            # 查询实体属性
            result = session.run("""
                MATCH (e:Entity {name: $name})
                RETURN e.name AS name, e.type AS type
            """, name=entity_name)

            entity_info = result.single()
            if not entity_info:
                return None

            # 查询出边（实体指向其他实体）
            result = session.run("""
                MATCH (e:Entity {name: $name})-[r:RELATION]->(target)
                RETURN type(r) AS relation_type,
                       r.type AS relation,
                       target.name AS target_name,
                       target.type AS target_type
            """, name=entity_name)

            outgoing = [
                {
                    "relation": record["relation"],
                    "target": record["target_name"],
                    "target_type": record["target_type"]
                }
                for record in result
            ]

            # 查询入边（其他实体指向该实体）
            result = session.run("""
                MATCH (source)-[r:RELATION]->(e:Entity {name: $name})
                RETURN type(r) AS relation_type,
                       r.type AS relation,
                       source.name AS source_name,
                       source.type AS source_type
            """, name=entity_name)

            incoming = [
                {
                    "relation": record["relation"],
                    "source": record["source_name"],
                    "source_type": record["source_type"]
                }
                for record in result
            ]

            return {
                "name": entity_info["name"],
                "type": entity_info["type"],
                "outgoing_relations": outgoing,
                "incoming_relations": incoming
            }

    def find_path(
        self,
        start_entity: str,
        end_entity: str,
        max_hops: int = 5
    ) -> List[List[str]]:
        """查找两个实体之间的路径"""
        with self.driver.session() as session:
            result = session.run("""
                MATCH path = shortestPath(
                    (start:Entity {name: $start})
                    -[*1..$max_hops]-(end:Entity {name: $end})
                )
                RETURN path
                LIMIT 10
            """, start=start_entity, end=end_entity, max_hops=max_hops)

            paths = []
            for record in result:
                path = record["path"]
                path_nodes = [node["name"] for node in path.nodes]
                paths.append(path_nodes)

            return paths

    def get_statistics(self) -> Dict:
        """获取图谱统计信息"""
        with self.driver.session() as session:
            # 节点数量
            result = session.run("MATCH (n:Entity) RETURN count(n) AS count")
            node_count = result.single()["count"]

            # 关系数量
            result = session.run("MATCH ()-[r:RELATION]->() RETURN count(r) AS count")
            relation_count = result.single()["count"]

            # 实体类型分布
            result = session.run("""
                MATCH (n:Entity)
                RETURN n.type AS type, count(n) AS count
                ORDER BY count DESC
            """)
            entity_types = {
                record["type"]: record["count"]
                for record in result
            }

            # 关系类型分布
            result = session.run("""
                MATCH ()-[r:RELATION]->()
                RETURN r.type AS type, count(r) AS count
                ORDER BY count DESC
            """)
            relation_types = {
                record["type"]: record["count"]
                for record in result
            }

            # 度数最高的节点
            result = session.run("""
                MATCH (n:Entity)-[r]-()
                RETURN n.name AS name, n.type AS type, count(r) AS degree
                ORDER BY degree DESC
                LIMIT 10
            """)
            top_nodes = [
                {
                    "name": record["name"],
                    "type": record["type"],
                    "degree": record["degree"]
                }
                for record in result
            ]

            return {
                "node_count": node_count,
                "relation_count": relation_count,
                "entity_types": entity_types,
                "relation_types": relation_types,
                "top_nodes": top_nodes
            }

    def export_to_cypher(self, output_file: str):
        """导出为Cypher脚本"""
        with self.driver.session() as session:
            # 导出节点
            result = session.run("""
                MATCH (n:Entity)
                RETURN n.name AS name, n.type AS type
            """)

            with open(output_file, 'w', encoding='utf-8') as f:
                f.write("// 创建节点\n")
                for record in result:
                    name = record["name"].replace("'", "\\'")
                    entity_type = record["type"]
                    f.write(f"MERGE (:{entity_type} {{name: '{name}'}});\n")

                # 导出关系
                result = session.run("""
                    MATCH (s:Entity)-[r:RELATION]->(o:Entity)
                    RETURN s.name AS subject, r.type AS predicate, o.name AS object
                """)

                f.write("\n// 创建关系\n")
                for record in result:
                    subject = record["subject"].replace("'", "\\'")
                    predicate = record["predicate"]
                    obj = record["object"].replace("'", "\\'")
                    f.write(
                        f"MATCH (s:Entity {{name: '{subject}'}}), "
                        f"(o:Entity {{name: '{obj}'}}) "
                        f"MERGE (s)-[:{predicate}]->(o);\n"
                    )

        print(f"✓ 导出完成: {output_file}")


def main():
    """主函数"""
    print("=== Neo4j知识图谱构建 ===\n")

    # 1. 连接Neo4j
    print("1. 连接Neo4j")
    print("-" * 50)
    kg = Neo4jKnowledgeGraph(
        uri="bolt://localhost:7687",
        user="neo4j",
        password="password"
    )

    # 2. 清空数据库（可选）
    print("\n2. 清空数据库")
    print("-" * 50)
    kg.clear_database()

    # 3. 创建索引
    print("\n3. 创建索引")
    print("-" * 50)
    kg.create_indexes()

    # 4. 准备测试数据
    print("\n4. 准备测试数据")
    print("-" * 50)
    triples = [
        Triple("张三", "Person", "WORKS_AT", "阿里巴巴", "Company"),
        Triple("张三", "Person", "POSITION", "高级工程师", "Position"),
        Triple("张三", "Person", "USES", "Python", "Technology"),
        Triple("张三", "Person", "USES", "机器学习", "Technology"),
        Triple("阿里巴巴", "Company", "LOCATED_IN", "杭州", "City"),
        Triple("阿里巴巴", "Company", "INDUSTRY", "电商", "Industry"),
        Triple("李四", "Person", "WORKS_AT", "阿里巴巴", "Company"),
        Triple("李四", "Person", "COLLEAGUE", "张三", "Person"),
        Triple("李四", "Person", "KNOWS", "张三", "Person"),
        Triple("杭州", "City", "PART_OF", "浙江省", "Province"),
    ]
    print(f"准备了 {len(triples)} 个三元组")

    # 5. 批量导入
    print("\n5. 批量导入三元组")
    print("-" * 50)
    kg.batch_import_triples(triples, batch_size=5)

    # 6. 查询实体
    print("\n6. 查询实体信息")
    print("-" * 50)
    entity_info = kg.query_entity("张三")
    if entity_info:
        print(f"\n实体: {entity_info['name']} ({entity_info['type']})")
        print(f"\n出边关系 ({len(entity_info['outgoing_relations'])}个):")
        for rel in entity_info['outgoing_relations']:
            print(f"  - {rel['relation']} → {rel['target']} ({rel['target_type']})")

        print(f"\n入边关系 ({len(entity_info['incoming_relations'])}个):")
        for rel in entity_info['incoming_relations']:
            print(f"  - {rel['source']} ({rel['source_type']}) → {rel['relation']}")

    # 7. 查找路径
    print("\n7. 查找路径")
    print("-" * 50)
    paths = kg.find_path("张三", "浙江省", max_hops=5)
    if paths:
        print(f"找到 {len(paths)} 条路径:")
        for i, path in enumerate(paths, 1):
            print(f"  路径{i}: {' → '.join(path)}")
    else:
        print("未找到路径")

    # 8. 统计信息
    print("\n8. 图谱统计")
    print("-" * 50)
    stats = kg.get_statistics()
    print(f"节点数量: {stats['node_count']}")
    print(f"关系数量: {stats['relation_count']}")

    print(f"\n实体类型分布:")
    for entity_type, count in stats['entity_types'].items():
        print(f"  {entity_type}: {count}")

    print(f"\n关系类型分布:")
    for relation_type, count in stats['relation_types'].items():
        print(f"  {relation_type}: {count}")

    print(f"\n度数最高的节点:")
    for node in stats['top_nodes'][:5]:
        print(f"  {node['name']} ({node['type']}): {node['degree']}个连接")

    # 9. 导出Cypher脚本
    print("\n9. 导出Cypher脚本")
    print("-" * 50)
    kg.export_to_cypher("knowledge_graph.cypher")

    # 10. 关闭连接
    kg.close()
    print("\n✓ 完成")


if __name__ == "__main__":
    main()
```

---

## 运行示例

```bash
# 1. 启动Neo4j（使用Docker）
docker run -d \
  --name neo4j \
  -p 7474:7474 -p 7687:7687 \
  -e NEO4J_AUTH=neo4j/password \
  neo4j:latest

# 2. 运行脚本
python examples/kg/02_neo4j_builder.py
```

**预期输出**：
```
=== Neo4j知识图谱构建 ===

1. 连接Neo4j
--------------------------------------------------
✓ Neo4j连接成功

2. 清空数据库
--------------------------------------------------
✓ 数据库已清空

3. 创建索引
--------------------------------------------------
✓ 索引创建完成

4. 准备测试数据
--------------------------------------------------
准备了 10 个三元组

5. 批量导入三元组
--------------------------------------------------
开始导入 10 个三元组...
  进度: 5/10 (50%)
  进度: 10/10 (100%)
✓ 导入完成，耗时 0.15秒

6. 查询实体信息
--------------------------------------------------

实体: 张三 (Person)

出边关系 (4个):
  - WORKS_AT → 阿里巴巴 (Company)
  - POSITION → 高级工程师 (Position)
  - USES → Python (Technology)
  - USES → 机器学习 (Technology)

入边关系 (2个):
  - 李四 (Person) → COLLEAGUE
  - 李四 (Person) → KNOWS

7. 查找路径
--------------------------------------------------
找到 1 条路径:
  路径1: 张三 → 阿里巴巴 → 杭州 → 浙江省

8. 图谱统计
--------------------------------------------------
节点数量: 10
关系数量: 10

实体类型分布:
  Person: 2
  Company: 1
  Technology: 2
  City: 1
  Province: 1
  Position: 1
  Industry: 1

关系类型分布:
  USES: 2
  WORKS_AT: 2
  KNOWS: 1
  COLLEAGUE: 1
  LOCATED_IN: 1
  INDUSTRY: 1
  POSITION: 1
  PART_OF: 1

度数最高的节点:
  张三 (Person): 6个连接
  阿里巴巴 (Company): 4个连接
  李四 (Person): 3个连接
  杭州 (City): 2个连接
  Python (Technology): 1个连接

9. 导出Cypher脚本
--------------------------------------------------
✓ 导出完成: knowledge_graph.cypher

✓ 完成
```

---

## 可视化

访问 http://localhost:7474 打开Neo4j Browser，执行以下查询：

```cypher
// 查看所有节点和关系
MATCH (n)-[r]->(m)
RETURN n, r, m

// 查看张三的关系网络
MATCH path = (p:Entity {name: '张三'})-[*1..2]-(related)
RETURN path

// 查看公司员工
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
RETURN p, c
```

---

## 扩展功能

### 1. 添加向量索引

```python
def create_vector_index(self):
    """创建向量索引"""
    with self.driver.session() as session:
        session.run("""
            CREATE VECTOR INDEX entity_embedding IF NOT EXISTS
            FOR (e:Entity) ON (e.embedding)
            OPTIONS {
              indexConfig: {
                `vector.dimensions`: 1536,
                `vector.similarity_function`: 'cosine'
              }
            }
        """)
```

### 2. 添加全文索引

```python
def create_fulltext_index(self):
    """创建全文索引"""
    with self.driver.session() as session:
        session.run("""
            CREATE FULLTEXT INDEX entity_fulltext IF NOT EXISTS
            FOR (e:Entity) ON EACH [e.name, e.description]
        """)
```

### 3. 图算法

```python
def find_communities(self):
    """社区发现"""
    with self.driver.session() as session:
        result = session.run("""
            CALL gds.louvain.stream('myGraph')
            YIELD nodeId, communityId
            RETURN gds.util.asNode(nodeId).name AS name, communityId
            ORDER BY communityId
        """)
        return list(result)
```

---

## 总结

本示例实现了完整的Neo4j知识图谱构建流程，包括：
- 数据库连接和测试
- 批量导入优化
- 索引创建
- 实体查询
- 路径查找
- 统计分析
- 数据导出

**适用场景**：
- 企业知识图谱
- 文档知识库
- 关系网络分析

**下一步**：
- 集成向量检索
- 实现GraphRAG
- 添加时序支持

---

**版本**：v1.0
**最后更新**：2026-02-14
**维护者**：Claude Code
