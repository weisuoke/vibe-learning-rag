# 核心概念 02：压缩策略与切点算法

> **核心概念**：Compaction 如何选择压缩点并生成高质量的结构化摘要

---

## 概述

**压缩策略与切点算法**是 Compaction 的第二个核心概念，它解决了"如何压缩"的问题。

**核心问题：**
- 从哪里开始压缩？（Cut Point）
- 如何确保消息完整性？
- 如何生成高质量摘要？
- 如何追踪文件操作？

---

## 1. 切点查找算法（findCutPoint）

### 1.1 向后查找算法

**核心思想：从后往前找，保留最近的消息**

```typescript
function findCutPoint(
  messages: Message[],
  keepRecentTokens: number
): number {
  let tokens = 0;

  // 从后往前遍历
  for (let i = messages.length - 1; i >= 0; i--) {
    tokens += estimateTokens(messages[i]);

    // 达到保留阈值
    if (tokens >= keepRecentTokens) {
      // 找到有效切点
      return findValidCutPoint(messages, i);
    }
  }

  return 0; // 全部保留
}
```

**为什么从后往前？**
- 最近的消息最重要
- 确保保留足够的最近上下文
- 避免切断正在进行的对话

### 1.2 有效切点规则

**可以作为切点的消息类型：**
```typescript
const validCutPointRoles = [
  'user',           // 用户消息
  'assistant',      // Agent 响应
  'bashExecution',  // Bash 命令执行结果
  'custom',         // 自定义消息
];
```

**不能作为切点的消息类型：**
```typescript
const invalidCutPointRoles = [
  'tool',           // ❌ 工具调用结果
  'tool_result',    // ❌ 工具返回值
];
```

**为什么 tool 消息不能作为切点？**
```typescript
// 错误示例：在 tool 消息处切断
[
  { role: 'assistant', tool_calls: [...] },  // 调用工具
  { role: 'tool', content: '...' },          // ← 切点（错误！）
  { role: 'assistant', content: '...' },     // 基于工具结果的响应
]

// 问题：
// 1. 工具调用和结果被分离
// 2. Agent 的响应失去了上下文
// 3. 违反了消息的完整性

// 正确示例：在 assistant 消息处切断
[
  { role: 'assistant', tool_calls: [...] },
  { role: 'tool', content: '...' },
  { role: 'assistant', content: '...' },     // ← 切点（正确）
]
```

### 1.3 查找有效切点

```typescript
function findValidCutPoint(
  messages: Message[],
  startIndex: number
): number {
  // 从 startIndex 向前查找有效切点
  for (let i = startIndex; i >= 0; i--) {
    const message = messages[i];

    // 检查是否是有效切点
    if (validCutPointRoles.includes(message.role)) {
      return i;
    }
  }

  return 0; // 找不到有效切点，从头开始
}
```

---

## 2. 分割回合处理（Split Turn）

### 2.1 什么是 Split Turn？

**场景：单条消息太长，无法完整保留**

```typescript
// 问题：最后一条 assistant 消息有 25K tokens
const messages = [
  // ... 旧消息（150K tokens）
  {
    role: 'assistant',
    content: '...',  // 25K tokens
    usage: { input_tokens: 175000, output_tokens: 25000 }
  },
];

// keepRecentTokens = 20K
// 但最后一条消息就有 25K tokens
// 无法完整保留！
```

**解决方案：Split Turn**
```typescript
// 标记为 split turn
const isSplitTurn = outputTokens > keepRecentTokens;

if (isSplitTurn) {
  // 只保留消息的后半部分
  const splitMessage = splitMessageContent(message, keepRecentTokens);

  // 添加前缀说明
  const turnPrefixMessages = [
    {
      role: 'system',
      content: '[Previous turn was split due to length]'
    }
  ];
}
```

### 2.2 Split Turn 的实现

```typescript
function handleSplitTurn(
  message: Message,
  keepRecentTokens: number
): { isSplitTurn: boolean; turnPrefixMessages: Message[] } {
  const outputTokens = message.usage?.output_tokens || 0;

  if (outputTokens <= keepRecentTokens) {
    return { isSplitTurn: false, turnPrefixMessages: [] };
  }

  // 计算需要保留的内容
  const keepRatio = keepRecentTokens / outputTokens;
  const contentLength = message.content.length;
  const keepLength = Math.floor(contentLength * keepRatio);

  // 截取后半部分
  message.content = message.content.slice(-keepLength);

  // 添加前缀说明
  const turnPrefixMessages = [
    {
      role: 'system',
      content: `[Note: Previous assistant response was ${outputTokens} tokens, only keeping last ${keepRecentTokens} tokens]`
    }
  ];

  return { isSplitTurn: true, turnPrefixMessages };
}
```

---

## 3. 摘要生成

### 3.1 结构化摘要格式

**Pi-mono 的摘要格式：**
```markdown
## Summary

[高层次概述：1-2 段话总结对话的核心内容]

## Key Points

- [关键决策 1]
- [关键决策 2]
- [重要技术细节]
- [待解决的问题]

## Files

- Read: file1.ts, file2.ts, file3.ts
- Modified: file4.ts, file5.ts
```

### 3.2 摘要生成提示词

```typescript
const summaryPrompt = `
Please summarize the following conversation in a structured format.

## Instructions

1. **Summary**: Provide a high-level overview (1-2 paragraphs)
2. **Key Points**: List important decisions, actions, and technical details
3. **Files**: List all files that were read or modified

## Format

Use the following markdown format:

## Summary
[Your summary here]

## Key Points
- [Point 1]
- [Point 2]

## Files
- Read: [file list]
- Modified: [file list]

## Conversation to Summarize

${conversationText}
`;
```

### 3.3 迭代摘要更新

**问题：多次压缩后，如何保留之前的摘要？**

```typescript
// 第一次压缩
const summary1 = await llm.summarize(messages1);
// "实现了用户登录功能"

// 第二次压缩（包含第一次的摘要）
const messages2 = [
  { role: 'summary', content: summary1 },
  // ... 新消息
];

const summary2 = await llm.summarize(messages2);
// "实现了用户登录和注册功能"（包含了之前的内容）
```

**实现：**
```typescript
async function generateSummary(
  messages: Message[],
  previousSummary?: string
): Promise<string> {
  let conversationText = '';

  // 如果有之前的摘要，包含进来
  if (previousSummary) {
    conversationText += `## Previous Summary\n\n${previousSummary}\n\n`;
  }

  // 添加要压缩的消息
  conversationText += `## Recent Conversation\n\n`;
  for (const message of messages) {
    conversationText += `**${message.role}**: ${message.content}\n\n`;
  }

  // 生成新摘要
  const summary = await llm.chat([
    { role: 'user', content: summaryPrompt + conversationText }
  ]);

  return summary.content;
}
```

---

## 4. 文件操作追踪

### 4.1 为什么需要文件追踪？

**问题：压缩后，Agent 不知道哪些文件被操作过**

```typescript
// 压缩前
user: "请读取 auth.ts"
assistant: "已读取 auth.ts，内容是..."
user: "请修改 routes.ts"
assistant: "已修改 routes.ts"

// 压缩后（没有文件追踪）
summary: "实现了认证功能"
// 问题：不知道哪些文件被操作过

// 压缩后（有文件追踪）
summary: "实现了认证功能\n\nFiles:\n- Read: auth.ts\n- Modified: routes.ts"
// ✅ 清楚记录文件操作
```

### 4.2 文件提取算法

```typescript
function extractFiles(messages: Message[]): {
  read: string[];
  modified: string[];
} {
  const readFiles = new Set<string>();
  const modifiedFiles = new Set<string>();

  for (const message of messages) {
    // 从工具调用中提取文件
    if (message.tool_calls) {
      for (const toolCall of message.tool_calls) {
        if (toolCall.function.name === 'read_file') {
          const args = JSON.parse(toolCall.function.arguments);
          readFiles.add(args.file_path);
        }

        if (toolCall.function.name === 'write_file' ||
            toolCall.function.name === 'edit_file') {
          const args = JSON.parse(toolCall.function.arguments);
          modifiedFiles.add(args.file_path);
        }
      }
    }

    // 从消息内容中提取文件（正则匹配）
    const filePattern = /(?:read|modified|edited|created)\s+([a-zA-Z0-9_\-./]+\.[a-z]+)/gi;
    const matches = message.content.matchAll(filePattern);
    for (const match of matches) {
      const file = match[1];
      if (match[0].includes('read')) {
        readFiles.add(file);
      } else {
        modifiedFiles.add(file);
      }
    }
  }

  return {
    read: Array.from(readFiles),
    modified: Array.from(modifiedFiles),
  };
}
```

### 4.3 累积文件追踪

**关键：跨压缩累积文件列表**

```typescript
function accumulateFiles(
  currentFiles: { read: string[]; modified: string[] },
  previousSummary?: string
): { read: string[]; modified: string[] } {
  // 从之前的摘要中提取文件
  const previousFiles = extractFilesFromSummary(previousSummary);

  // 合并文件列表
  return {
    read: [...new Set([...previousFiles.read, ...currentFiles.read])],
    modified: [...new Set([...previousFiles.modified, ...currentFiles.modified])],
  };
}

function extractFilesFromSummary(summary?: string): {
  read: string[];
  modified: string[];
} {
  if (!summary) {
    return { read: [], modified: [] };
  }

  // 解析摘要中的文件列表
  const readMatch = summary.match(/Read:\s*([^\n]+)/);
  const modifiedMatch = summary.match(/Modified:\s*([^\n]+)/);

  return {
    read: readMatch ? readMatch[1].split(',').map(f => f.trim()) : [],
    modified: modifiedMatch ? modifiedMatch[1].split(',').map(f => f.trim()) : [],
  };
}
```

---

## 5. 完整的压缩流程

```typescript
async function compactSession(session: Session): Promise<void> {
  const messages = session.messages;
  const config = session.config;

  // 1. 查找切点
  const cutPoint = findCutPoint(messages, config.keepRecentTokens);

  // 2. 分割消息
  const toCompress = messages.slice(0, cutPoint);
  const toKeep = messages.slice(cutPoint);

  // 3. 处理 Split Turn
  const lastMessage = toKeep[0];
  const { isSplitTurn, turnPrefixMessages } = handleSplitTurn(
    lastMessage,
    config.keepRecentTokens
  );

  // 4. 提取文件操作
  const currentFiles = extractFiles(toCompress);
  const previousSummary = findPreviousSummary(messages);
  const allFiles = accumulateFiles(currentFiles, previousSummary);

  // 5. 生成摘要
  const summary = await generateSummary(toCompress, previousSummary);

  // 6. 添加文件追踪到摘要
  const summaryWithFiles = `${summary}\n\n## Files\n- Read: ${allFiles.read.join(', ')}\n- Modified: ${allFiles.modified.join(', ')}`;

  // 7. 重组消息
  session.messages = [
    { role: 'summary', content: summaryWithFiles },
    ...turnPrefixMessages,
    ...toKeep,
  ];

  // 8. 保存到 JSONL
  await session.save();
}
```

---

## 6. 2025-2026 前沿技术

### 6.1 Checkpoint-based Summarization

> **2025-2026 Research**: 类似分布式系统的 WAL（Write-Ahead Log），在关键点创建检查点。
> ([Context Engineering Patterns](https://github.com/langchain-ai/context_engineering))

```typescript
// 在任务边界创建检查点
function shouldCreateCheckpoint(messages: Message[]): boolean {
  const lastMessage = messages[messages.length - 1];

  // 检测任务完成的信号
  const taskCompletionSignals = [
    '已完成',
    'done',
    'finished',
    '功能实现完毕',
  ];

  return taskCompletionSignals.some(signal =>
    lastMessage.content.includes(signal)
  );
}
```

### 6.2 SimpleMem: 30x 压缩

> **2025-2026 Research**: 通过多阶段语义管道实现 30x 压缩率。
> ([SimpleMem Paper](https://arxiv.org/abs/2501.xxxxx))

**核心思想：**
1. **第一阶段**：提取关键事实
2. **第二阶段**：组织成知识图谱
3. **第三阶段**：生成结构化摘要

### 6.3 Agent Cognitive Compressor (ACC)

> **2025-2026 Research**: 模式驱动的压缩，根据任务类型选择压缩策略。
> ([ACC Paper](https://arxiv.org/abs/2501.xxxxx))

```typescript
// 根据任务类型选择压缩策略
function getCompressionStrategy(taskType: string): CompressionStrategy {
  switch (taskType) {
    case 'coding':
      return {
        keepCodeBlocks: true,
        keepFileOperations: true,
        summarizeDiscussions: true,
      };
    case 'research':
      return {
        keepKeyFindings: true,
        keepReferences: true,
        summarizeDetails: true,
      };
    default:
      return defaultStrategy;
  }
}
```

---

## 总结

**压缩策略与切点算法的核心要点：**

1. **切点查找**：从后往前找，确保消息完整性
2. **有效切点**：user/assistant/bashExecution，不能是 tool
3. **Split Turn**：处理单条消息过长的情况
4. **结构化摘要**：Summary + Key Points + Files
5. **文件追踪**：累积跨压缩的文件操作
6. **迭代更新**：包含之前的摘要，避免信息丢失

---

**下一步学习：**
- **核心概念 03**：手动压缩与自定义指令（03_核心概念_03_手动压缩与自定义指令.md）
- **实战代码 02**：自定义压缩扩展（07_实战代码_02_自定义压缩扩展.md）

---

**版本：** v1.0
**最后更新：** 2026-02-20
**维护者：** Claude Code
