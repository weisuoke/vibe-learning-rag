# 第一性原理

> **核心问题：为什么 pi-mono 不提供内置 Plan Mode？**

---

## 第一性原理思考

### 什么是第一性原理？

第一性原理（First Principles Thinking）是一种从最基本的真理出发，逐步推导的思维方式。在软件设计中，它意味着：

1. **识别基本真理**：什么是不可再分的核心需求？
2. **质疑假设**：为什么我们认为需要这个功能？
3. **重新构建**：从基本真理出发，构建最优解决方案

### Pi-mono 的第一性原理

Mario Zechner（pi-mono 作者）在设计 pi-mono 时，从以下基本真理出发：

#### 真理 1：AI 代理的核心是 LLM + 工具

```
AI Agent = LLM + Tools + Orchestration
```

- **LLM**：语言模型，负责理解和生成
- **Tools**：工具集，负责执行操作
- **Orchestration**：编排逻辑，负责协调

**关键洞察：** 编排逻辑（Orchestration）是最容易过度设计的部分。

#### 真理 2：用户需求千差万别

不同用户对"规划"的需求完全不同：

- **快速原型开发者**：需要简单的文件式规划
- **团队协作者**：需要集成的扩展命令
- **企业用户**：需要复杂的状态管理和审批流程
- **研究者**：需要自定义的规划算法

**关键洞察：** 没有一种规划模式能满足所有用户。

#### 真理 3：可观察性是信任的基础

用户信任 AI 代理的前提是：

1. **看得见**：能看到代理在做什么
2. **可控制**：能随时干预和修改
3. **可理解**：能理解代理的决策过程

**关键洞察：** 黑盒编排破坏可观察性，降低用户信任。

---

## 为什么不提供内置 Plan Mode？

### 原因 1：避免黑盒编排（No Black-box Orchestration）

#### 什么是黑盒编排？

黑盒编排指的是：代理内部有复杂的规划逻辑，但用户看不到、控制不了。

**典型例子：**
```typescript
// 黑盒编排（用户看不到内部逻辑）
agent.plan(task) // 内部发生了什么？
  → 分析任务
  → 生成子任务
  → 评估依赖
  → 创建执行计划
  → 返回计划
```

**问题：**
1. 用户不知道代理如何规划
2. 用户无法干预规划过程
3. 用户无法定制规划逻辑
4. 调试困难，出错难以追踪

#### Pi-mono 的解决方案：文件优先

```typescript
// 文件优先（用户完全可见）
await api.tools.write('.pi/plan.md', `
# Implementation Plan

## Goal
${goal}

## Tasks
${tasks.map(t => `- ${t}`).join('\n')}

## Dependencies
${dependencies}
`);
```

**优势：**
1. 计划存储在文件中，用户可见
2. 用户可以直接编辑计划
3. 计划可以版本控制（git）
4. 调试简单，问题一目了然

### 原因 2：最大化可观察性（Observability First）

#### 可观察性的三个层次

| 层次 | 描述 | Pi-mono 实现 |
|------|------|-------------|
| **L1: 状态可见** | 能看到当前状态 | 文件存储，随时查看 |
| **L2: 历史可追溯** | 能看到历史变化 | Git 版本控制 |
| **L3: 决策可理解** | 能理解为什么这样做 | 计划文件包含推理过程 |

#### 内置 Plan Mode 的可观察性问题

```typescript
// 内置 Plan Mode（可观察性差）
const plan = await agent.createPlan(task);
// plan 对象在内存中，用户看不到
// 如果代理崩溃，计划丢失
// 无法用 git 追踪计划变化
```

#### Pi-mono 的文件式规划（可观察性好）

```typescript
// 文件式规划（可观察性好）
await api.tools.write('.pi/plan.md', planContent);
// 计划在文件中，用户随时查看
// 代理崩溃，计划仍然存在
// 可以用 git 追踪计划变化
```

### 原因 3：用户控制优先（User Control）

#### 控制权的重要性

AI 代理的核心问题：**谁控制工作流？**

- **代理控制**：代理决定何时规划、何时执行
- **用户控制**：用户决定何时规划、何时执行

**Pi-mono 的选择：** 用户控制优先。

#### 内置 Plan Mode 的控制权问题

```typescript
// 内置 Plan Mode（代理控制）
agent.execute(task); // 代理自动决定是否需要规划
// 用户无法控制规划时机
// 用户无法跳过规划直接执行
// 用户无法修改规划逻辑
```

#### Pi-mono 的扩展式规划（用户控制）

```typescript
// 扩展式规划（用户控制）
// 用户决定何时进入规划模式
> /plan

// 用户决定何时退出规划模式
> /execute

// 用户可以随时修改计划文件
```

### 原因 4：可组合性（Composability）

#### 可组合性的价值

可组合性指的是：不同功能可以自由组合，创造新的功能。

**例子：**
- **Plan Mode + Sub-agents**：规划阶段使用子代理
- **Plan Mode + MCP Server**：规划阶段调用外部服务
- **Plan Mode + Custom Tools**：规划阶段使用自定义工具

#### 内置 Plan Mode 的可组合性问题

```typescript
// 内置 Plan Mode（难以组合）
agent.plan(task); // 固定的规划逻辑
// 无法与其他扩展组合
// 无法定制规划流程
```

#### Pi-mono 的扩展式规划（易于组合）

```typescript
// 扩展式规划（易于组合）
api.registerCommand({
  name: 'plan',
  handler: async () => {
    // 可以调用其他扩展
    await api.extensions.subagent.create('planner');

    // 可以调用 MCP Server
    await api.mcp.call('planning-service', { task });

    // 可以使用自定义工具
    await api.tools.customPlan(task);
  }
});
```

### 原因 5：简单性（Simplicity）

#### 复杂性的来源

软件复杂性主要来自两个方面：

1. **本质复杂性**：问题本身的复杂性（无法避免）
2. **偶然复杂性**：实现方式带来的复杂性（可以避免）

**关键洞察：** 内置 Plan Mode 会引入大量偶然复杂性。

#### 内置 Plan Mode 的复杂性

```typescript
// 内置 Plan Mode 需要处理：
- 规划算法的选择
- 规划状态的管理
- 规划与执行的切换
- 规划失败的处理
- 规划的持久化
- 规划的版本控制
- 规划的审批流程
- 规划的可视化
- ...
```

**结果：** 核心代码变得臃肿，难以维护。

#### Pi-mono 的简单性

```typescript
// Pi-mono 核心只提供原语：
- write(path, content)  // 写文件
- read(path)            // 读文件
- setState(state)       // 设置状态
- getState()            // 获取状态
```

**结果：** 核心代码简单，复杂性在扩展中。

---

## Pi-mono 的设计哲学

### 哲学 1：提供原语，而非功能

**原语（Primitives）** vs. **功能（Features）**

| 原语 | 功能 |
|------|------|
| 基本操作 | 复杂功能 |
| 可组合 | 固定逻辑 |
| 灵活 | 受限 |
| 简单 | 复杂 |

**Pi-mono 的选择：** 提供原语，让用户构建功能。

**例子：**
```typescript
// Pi-mono 提供的原语
api.tools.write(path, content)
api.registerCommand(config)
api.setState(state)

// 用户构建的功能
function createPlanMode() {
  api.registerCommand({
    name: 'plan',
    handler: async () => {
      await api.setState({ mode: 'plan' });
      await api.tools.write('.pi/plan.md', '# Plan\n\n');
    }
  });
}
```

### 哲学 2：文件优先，状态可见

**文件 vs. 内存**

| 文件 | 内存 |
|------|------|
| 持久化 | 易失 |
| 可见 | 不可见 |
| 可编辑 | 难编辑 |
| 可版本控制 | 难追踪 |

**Pi-mono 的选择：** 文件优先。

**例子：**
```typescript
// 文件优先
await api.tools.write('.pi/plan.md', planContent);
// 用户可以：
// - 用编辑器打开查看
// - 用 git 追踪变化
// - 手动修改计划
// - 与团队分享
```

### 哲学 3：用户控制，代理辅助

**控制权分配**

| 决策 | 控制者 |
|------|--------|
| 何时规划 | 用户 |
| 如何规划 | 用户 |
| 何时执行 | 用户 |
| 如何执行 | 代理 |

**Pi-mono 的选择：** 用户控制工作流，代理辅助执行。

### 哲学 4：极简核心，丰富扩展

**核心 vs. 扩展**

| 核心 | 扩展 |
|------|------|
| 最小功能集 | 丰富功能 |
| 稳定 | 可变 |
| 通用 | 专用 |
| 必需 | 可选 |

**Pi-mono 的选择：** 核心极简，扩展丰富。

---

## 与其他工具的对比

### Pi-mono vs. Claude Code

| 方面 | Pi-mono | Claude Code |
|------|---------|-------------|
| **Plan Mode** | 扩展实现 | 内置功能 |
| **哲学** | 极简、可控 | 集成、便捷 |
| **可观察性** | 文件优先 | 黑盒编排 |
| **灵活性** | 最大 | 受限 |
| **学习曲线** | 陡峭 | 平缓 |

**适用场景：**
- **Pi-mono**：需要定制、控制、可观察性
- **Claude Code**：需要快速上手、开箱即用

### Pi-mono vs. Oh-my-pi

| 方面 | Pi-mono | Oh-my-pi |
|------|---------|----------|
| **Plan Mode** | 扩展实现 | 内置 `/plan` |
| **哲学** | 极简 | 功能丰富 |
| **核心复杂度** | 低 | 中 |
| **开箱即用** | 否 | 是 |

**关系：**
- Oh-my-pi 是 pi-mono 的 fork
- 添加了内置 `/plan` 命令
- 证明了 pi-mono 的扩展性

---

## 关键洞察

### 洞察 1：Plan Mode 不是功能，是模式

**功能思维：**
> "我需要一个 Plan Mode 功能。"

**模式思维：**
> "我需要一种规划工作流模式，可以通过文件、扩展或 Session 实现。"

### 洞察 2：黑盒编排 vs. 透明编排

**黑盒编排：**
- 代理内部有复杂逻辑
- 用户看不到、控制不了
- 调试困难

**透明编排：**
- 逻辑存储在文件中
- 用户完全可见、可控
- 调试简单

### 洞察 3：原语 > 功能

**原语的价值：**
- 可组合：创造无限可能
- 灵活：适应不同需求
- 简单：核心保持简洁

**功能的问题：**
- 固定：难以定制
- 受限：无法组合
- 复杂：核心变臃肿

### 洞察 4：用户控制 > 代理自动化

**用户控制的价值：**
- 信任：用户知道发生了什么
- 可预测：用户控制工作流
- 灵活：用户可以随时调整

**代理自动化的问题：**
- 不透明：用户不知道发生了什么
- 不可预测：代理可能做意外的事
- 不灵活：用户无法干预

---

## 实践建议

### 建议 1：从文件式规划开始

如果你是 pi-mono 新手，从最简单的文件式规划开始：

```typescript
// 最简单的规划
await api.tools.write('.pi/plan.md', `
# Plan

## Goal
${goal}

## Tasks
- Task 1
- Task 2
- Task 3
`);
```

### 建议 2：需要频繁使用时，创建扩展

如果你经常需要规划，创建一个扩展：

```typescript
// 创建扩展
api.registerCommand({
  name: 'plan',
  handler: async () => {
    await api.setState({ mode: 'plan' });
    api.disableTools(['write', 'edit']);
  }
});
```

### 建议 3：复杂项目使用 Session 集成

如果你的项目很复杂，使用 Session 管理状态：

```typescript
// Session 集成
const session = await api.createSession({
  label: 'planning',
  readOnly: true
});
await api.switchSession(session.id);
```

### 建议 4：理解哲学，而非死记功能

不要死记"pi-mono 没有 Plan Mode"，而是理解：

- **为什么**没有？（极简哲学）
- **如何**实现？（三种方式）
- **何时**使用？（根据需求选择）

---

## 参考资源

### 官方资源

- [What I learned building pi coding agent](https://mariozechner.at/posts/2025-11-30-pi-coding-agent) - Mario Zechner, 2025-11-30
- [Pi-mono GitHub Repository](https://github.com/badlogic/pi-mono)
- [Extension API Documentation](https://github.com/badlogic/pi-mono/blob/main/packages/coding-agent/docs/extensions.md)

### 研究资料

- `temp/01_grok_llm_planning_architecture.md` - LLM 规划系统架构
- `temp/02_grok_ai_agent_patterns.md` - AI 代理任务规划模式
- `temp/03_grok_pi_mono_extensions.md` - Pi-mono 扩展 API

---

## 下一步

- **03_核心概念_01_Plan表示与文件存储.md**：学习如何用文件存储计划
- **03_核心概念_02_Extension_API集成.md**：学习如何创建扩展
- **03_核心概念_03_Session状态管理.md**：学习如何管理状态
