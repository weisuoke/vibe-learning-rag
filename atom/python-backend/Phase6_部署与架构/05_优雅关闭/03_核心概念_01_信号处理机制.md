# 核心概念：信号处理机制

> 深入理解 SIGTERM、SIGINT、SIGKILL 信号及其在优雅关闭中的作用

---

## 什么是信号？

**信号（Signal）** 是操作系统用来通知进程发生某个事件的机制。

**类比：**
- **前端视角**：类似于浏览器的事件（click、keydown、beforeunload）
- **日常视角**：类似于手机的通知（来电、短信、闹钟）

**核心特点：**
- 异步：信号可以在任何时刻到达
- 中断：信号会中断进程的正常执行
- 可捕获：大部分信号可以被捕获和处理
- 不可捕获：SIGKILL 和 SIGSTOP 无法捕获

---

## 常见信号类型

### 1. SIGTERM（15）- 优雅终止信号

**定义：** 请求进程优雅地终止

**特点：**
- 可以被捕获和处理
- 给进程时间清理资源
- 默认行为：终止进程
- 用途：正常关闭、重启、部署

**发送方式：**
```bash
# 发送 SIGTERM 信号
kill -SIGTERM <pid>
kill -15 <pid>
kill <pid>  # 默认就是 SIGTERM

# Docker 停止容器
docker stop <container>  # 先发送 SIGTERM，10秒后发送 SIGKILL

# Kubernetes 删除 Pod
kubectl delete pod <pod>  # 先发送 SIGTERM，等待 terminationGracePeriodSeconds
```

**在 Python 中捕获：**
```python
import signal
import sys

def sigterm_handler(signum, frame):
    print(f"收到 SIGTERM 信号（{signum}）")
    # 执行清理逻辑
    cleanup()
    sys.exit(0)

# 注册信号处理器
signal.signal(signal.SIGTERM, sigterm_handler)
```

**使用场景：**
- 服务重启
- 滚动更新
- 容器停止
- 进程管理器（systemd、supervisor）

---

### 2. SIGINT（2）- 中断信号

**定义：** 用户请求中断进程（通常是 Ctrl+C）

**特点：**
- 可以被捕获和处理
- 通常由用户主动触发
- 默认行为：终止进程
- 用途：开发调试、手动停止

**发送方式：**
```bash
# 在终端按 Ctrl+C
^C

# 发送 SIGINT 信号
kill -SIGINT <pid>
kill -2 <pid>
```

**在 Python 中捕获：**
```python
import signal

def sigint_handler(signum, frame):
    print("\n收到 Ctrl+C，正在优雅关闭...")
    cleanup()
    sys.exit(0)

signal.signal(signal.SIGINT, sigint_handler)
```

**使用场景：**
- 开发环境手动停止
- 脚本执行中断
- 交互式程序退出

---

### 3. SIGKILL（9）- 强制终止信号

**定义：** 立即强制终止进程

**特点：**
- **无法被捕获**：进程无法处理这个信号
- 立即终止：不给任何清理时间
- 默认行为：立即终止进程
- 用途：紧急情况、进程卡死

**发送方式：**
```bash
# 发送 SIGKILL 信号
kill -SIGKILL <pid>
kill -9 <pid>

# Docker 强制停止
docker kill <container>

# Kubernetes 强制删除
kubectl delete pod <pod> --force --grace-period=0
```

**无法捕获：**
```python
import signal

# 这个处理器永远不会被调用！
def sigkill_handler(signum, frame):
    print("这行代码永远不会执行")

# 这行代码会抛出异常：ValueError: signal only works in main thread
signal.signal(signal.SIGKILL, sigkill_handler)
```

**使用场景：**
- 进程卡死无响应
- 紧急情况需要立即停止
- 优雅关闭超时后的强制措施

---

### 4. 其他常见信号

| 信号 | 编号 | 说明 | 可捕获 | 默认行为 |
|------|------|------|--------|---------|
| SIGHUP | 1 | 挂起信号（终端断开） | ✅ | 终止 |
| SIGQUIT | 3 | 退出信号（Ctrl+\\） | ✅ | 终止+核心转储 |
| SIGABRT | 6 | 异常终止 | ✅ | 终止+核心转储 |
| SIGALRM | 14 | 定时器信号 | ✅ | 终止 |
| SIGCHLD | 17 | 子进程状态改变 | ✅ | 忽略 |
| SIGSTOP | 19 | 停止进程 | ❌ | 停止 |
| SIGCONT | 18 | 继续执行 | ✅ | 继续 |

---

## 信号处理器的工作原理

### 1. 信号处理流程

```
1. 操作系统发送信号
   ↓
2. 进程收到信号
   ↓
3. 中断当前执行
   ↓
4. 调用信号处理器
   ↓
5. 执行清理逻辑
   ↓
6. 返回或退出
```

### 2. Python 信号处理器

```python
import signal
import time

# 全局标志
shutdown_requested = False

def signal_handler(signum, frame):
    """
    信号处理器函数

    参数：
    - signum: 信号编号（如 15 表示 SIGTERM）
    - frame: 当前栈帧对象（可用于调试）
    """
    global shutdown_requested

    print(f"收到信号 {signum}")
    print(f"信号名称: {signal.Signals(signum).name}")
    print(f"当前文件: {frame.f_code.co_filename}")
    print(f"当前行号: {frame.f_lineno}")

    shutdown_requested = True

# 注册信号处理器
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

# 主循环
print("进程运行中，按 Ctrl+C 或发送 SIGTERM 停止")
while not shutdown_requested:
    print("工作中...")
    time.sleep(1)

print("优雅关闭完成")
```

**运行示例：**
```bash
# 启动程序
python app.py
# 输出：进程运行中，按 Ctrl+C 或发送 SIGTERM 停止
# 输出：工作中...
# 输出：工作中...

# 按 Ctrl+C
^C
# 输出：收到信号 2
# 输出：信号名称: SIGINT
# 输出：当前文件: app.py
# 输出：当前行号: 25
# 输出：优雅关闭完成
```

---

## 在 FastAPI 中使用信号处理

### 1. 基础信号处理

```python
"""
FastAPI 应用的信号处理
"""

import signal
import asyncio
from fastapi import FastAPI

app = FastAPI()

# 创建关闭事件
shutdown_event = asyncio.Event()

def signal_handler(signum, frame):
    """信号处理器"""
    print(f"收到信号 {signum}，开始优雅关闭...")
    shutdown_event.set()

# 注册信号处理器
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.on_event("startup")
async def startup_event():
    """应用启动时"""
    print("应用启动")
    # 启动后台任务监听关闭信号
    asyncio.create_task(shutdown_monitor())

async def shutdown_monitor():
    """监听关闭信号"""
    await shutdown_event.wait()  # 等待信号
    print("开始执行优雅关闭...")

    # 执行清理逻辑
    await cleanup_resources()

    # 退出进程
    import sys
    sys.exit(0)

async def cleanup_resources():
    """清理资源"""
    print("清理资源...")
    # 关闭数据库连接
    # 关闭 Redis 连接
    # 等等
```

### 2. 使用 asyncio.Event 通知其他协程

```python
"""
使用 asyncio.Event 在信号处理器和协程之间通信
"""

import signal
import asyncio
from fastapi import FastAPI

app = FastAPI()
shutdown_event = asyncio.Event()

def signal_handler(signum, frame):
    """信号处理器（同步函数）"""
    print(f"收到信号 {signum}")
    # 设置事件，通知所有等待的协程
    shutdown_event.set()

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

async def background_worker():
    """后台工作线程"""
    while not shutdown_event.is_set():
        print("后台任务运行中...")
        await asyncio.sleep(1)

    print("后台任务收到关闭信号，正在退出...")

async def long_running_task():
    """长时间运行的任务"""
    for i in range(100):
        if shutdown_event.is_set():
            print(f"任务在第 {i} 步被中断")
            break

        print(f"执行步骤 {i}")
        await asyncio.sleep(0.5)

@app.on_event("startup")
async def startup_event():
    # 启动后台任务
    asyncio.create_task(background_worker())
```

---

## 信号处理的注意事项

### 1. 信号处理器必须是同步函数

```python
# ❌ 错误：信号处理器不能是异步函数
async def signal_handler(signum, frame):
    await cleanup()  # 这不会工作！

signal.signal(signal.SIGTERM, signal_handler)  # TypeError

# ✅ 正确：使用同步函数 + asyncio.Event
def signal_handler(signum, frame):
    shutdown_event.set()  # 设置事件

signal.signal(signal.SIGTERM, signal_handler)

# 在异步函数中等待事件
async def shutdown_monitor():
    await shutdown_event.wait()
    await cleanup()  # 现在可以使用 await
```

### 2. 信号处理器应该尽快返回

```python
# ❌ 错误：在信号处理器中执行耗时操作
def signal_handler(signum, frame):
    print("开始清理...")
    time.sleep(10)  # 阻塞10秒！
    cleanup()
    sys.exit(0)

# ✅ 正确：只设置标志，在主循环中处理
def signal_handler(signum, frame):
    shutdown_event.set()  # 立即返回

# 在主循环中处理
async def main():
    await shutdown_event.wait()
    await cleanup()  # 在这里执行耗时操作
```

### 3. 避免在信号处理器中使用不安全的函数

```python
# ⚠️ 警告：某些函数在信号处理器中不安全
def signal_handler(signum, frame):
    # 不安全：malloc、free 等内存操作
    data = [1, 2, 3]  # 可能导致死锁

    # 不安全：文件 I/O
    with open("log.txt", "a") as f:  # 可能导致死锁
        f.write("shutdown\n")

    # 安全：简单的变量赋值
    global shutdown_requested
    shutdown_requested = True  # ✅ 安全

# ✅ 推荐：只设置标志，在主循环中处理
def signal_handler(signum, frame):
    shutdown_event.set()  # 最安全的做法
```

### 4. 信号处理器只在主线程中工作

```python
import signal
import threading

def worker():
    """工作线程"""
    # ❌ 错误：在子线程中注册信号处理器
    signal.signal(signal.SIGTERM, signal_handler)  # ValueError!

# ✅ 正确：在主线程中注册
signal.signal(signal.SIGTERM, signal_handler)

# 启动工作线程
thread = threading.Thread(target=worker)
thread.start()
```

---

## 在容器环境中的信号处理

### 1. Docker 的信号传递

**Docker stop 的行为：**
```bash
docker stop <container>

# 1. Docker 向容器的 PID 1 进程发送 SIGTERM
# 2. 等待 10 秒（默认）
# 3. 如果进程还在运行，发送 SIGKILL

# 自定义等待时间
docker stop --time 30 <container>  # 等待30秒
```

**Dockerfile 中的信号处理：**
```dockerfile
FROM python:3.13-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

# 使用 exec 形式，确保 Python 进程是 PID 1
CMD ["python", "app.py"]

# ❌ 错误：使用 shell 形式
# CMD python app.py
# 这会启动一个 shell（PID 1），Python 进程是子进程
# SIGTERM 会发送给 shell，而不是 Python
```

**确保 Python 进程收到信号：**
```dockerfile
# 方法1：使用 exec 形式（推荐）
CMD ["python", "app.py"]

# 方法2：使用 exec 替换 shell
CMD exec python app.py

# 方法3：使用 tini 作为 init 进程
RUN apt-get update && apt-get install -y tini
ENTRYPOINT ["/usr/bin/tini", "--"]
CMD ["python", "app.py"]
```

### 2. Kubernetes 的信号传递

**Pod 删除流程：**
```
1. kubectl delete pod <pod>
   ↓
2. Pod 状态变为 Terminating
   ↓
3. 执行 preStop 钩子（如果有）
   ↓
4. 向容器的 PID 1 发送 SIGTERM
   ↓
5. 等待 terminationGracePeriodSeconds（默认30秒）
   ↓
6. 如果容器还在运行，发送 SIGKILL
```

**配置优雅关闭时间：**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  terminationGracePeriodSeconds: 60  # 等待60秒
  containers:
  - name: app
    image: myapp:latest
    lifecycle:
      preStop:
        exec:
          command: ["/bin/sh", "-c", "sleep 5"]  # 给5秒时间停止接收新请求
```

---

## 完整示例：生产级信号处理

```python
"""
生产级 FastAPI 应用的信号处理
演示：完整的信号处理流程
"""

import signal
import asyncio
import sys
from typing import Set
from fastapi import FastAPI, Request, HTTPException
from sqlalchemy.ext.asyncio import create_async_engine

# ===== 1. 全局状态 =====
app = FastAPI()
shutdown_event = asyncio.Event()
accepting_requests = True
active_requests = 0
background_tasks: Set[asyncio.Task] = set()

# 数据库引擎
engine = create_async_engine("postgresql+asyncpg://user:pass@localhost/db")

# ===== 2. 信号处理器 =====
def signal_handler(signum, frame):
    """
    信号处理器

    处理 SIGTERM 和 SIGINT 信号
    """
    signal_name = signal.Signals(signum).name
    print(f"\n收到信号: {signal_name} ({signum})")
    print(f"当前位置: {frame.f_code.co_filename}:{frame.f_lineno}")

    # 设置关闭事件
    shutdown_event.set()

# 注册信号处理器
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

# ===== 3. 请求排空中间件 =====
@app.middleware("http")
async def shutdown_middleware(request: Request, call_next):
    """请求排空中间件"""
    global active_requests

    if not accepting_requests:
        raise HTTPException(
            status_code=503,
            detail="Server is shutting down, please retry later"
        )

    active_requests += 1
    try:
        response = await call_next(request)
        return response
    finally:
        active_requests -= 1

# ===== 4. 示例路由 =====
@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/slow")
async def slow_endpoint():
    """模拟慢请求"""
    await asyncio.sleep(5)
    return {"message": "Done"}

# ===== 5. 后台任务 =====
async def background_worker():
    """后台工作线程"""
    try:
        while not shutdown_event.is_set():
            print("后台任务运行中...")
            await asyncio.sleep(1)
    except asyncio.CancelledError:
        print("后台任务被取消")
        raise

# ===== 6. 优雅关闭逻辑 =====
async def wait_for_requests(timeout: int = 30):
    """等待所有请求完成"""
    global accepting_requests
    accepting_requests = False

    print(f"停止接收新请求，等待 {active_requests} 个请求完成...")

    start_time = asyncio.get_event_loop().time()
    while active_requests > 0:
        elapsed = asyncio.get_event_loop().time() - start_time
        if elapsed > timeout:
            print(f"等待请求超时（{timeout}秒），强制退出")
            break

        await asyncio.sleep(0.1)

    print("所有请求已完成")

async def cleanup_background_tasks(timeout: int = 10):
    """清理后台任务"""
    print(f"取消 {len(background_tasks)} 个后台任务...")

    for task in background_tasks:
        if not task.done():
            task.cancel()

    # 等待所有任务完成
    try:
        await asyncio.wait_for(
            asyncio.gather(*background_tasks, return_exceptions=True),
            timeout=timeout
        )
    except asyncio.TimeoutError:
        print("后台任务清理超时")

    print("后台任务已清理")

async def cleanup_resources():
    """清理资源"""
    print("关闭数据库连接池...")
    await engine.dispose()
    print("资源清理完成")

async def graceful_shutdown():
    """优雅关闭主流程"""
    print("\n========== 开始优雅关闭 ==========")

    try:
        # 阶段1：等待请求完成（30秒）
        await asyncio.wait_for(
            wait_for_requests(),
            timeout=30
        )

        # 阶段2：清理后台任务（10秒）
        await asyncio.wait_for(
            cleanup_background_tasks(),
            timeout=10
        )

        # 阶段3：清理资源（10秒）
        await asyncio.wait_for(
            cleanup_resources(),
            timeout=10
        )

        print("========== 优雅关闭完成 ==========\n")
        sys.exit(0)

    except asyncio.TimeoutError:
        print("========== 优雅关闭超时，强制退出 ==========\n")
        sys.exit(1)

# ===== 7. 生命周期事件 =====
@app.on_event("startup")
async def startup_event():
    """应用启动时"""
    print("应用启动")

    # 启动后台任务
    task = asyncio.create_task(background_worker())
    background_tasks.add(task)

    # 启动关闭监听器
    asyncio.create_task(shutdown_monitor())

async def shutdown_monitor():
    """监听关闭信号"""
    await shutdown_event.wait()
    await graceful_shutdown()

# ===== 8. 运行应用 =====
if __name__ == "__main__":
    import uvicorn

    print("启动 FastAPI 应用...")
    print("按 Ctrl+C 或发送 SIGTERM 停止")

    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**测试信号处理：**
```bash
# 1. 启动应用
python app.py

# 2. 在另一个终端发送请求
curl http://localhost:8000/slow &

# 3. 立即发送 SIGTERM
kill -SIGTERM $(pgrep -f "python app.py")

# 观察日志：
# 收到信号: SIGTERM (15)
# 停止接收新请求，等待 1 个请求完成...
# 所有请求已完成
# 取消 1 个后台任务...
# 后台任务被取消
# 后台任务已清理
# 关闭数据库连接池...
# 资源清理完成
# 优雅关闭完成
```

---

## 总结

### 核心要点

1. **信号类型**：
   - SIGTERM（15）：可捕获，用于优雅关闭
   - SIGINT（2）：可捕获，用于手动中断
   - SIGKILL（9）：不可捕获，用于强制终止

2. **信号处理器**：
   - 必须是同步函数
   - 应该尽快返回
   - 避免使用不安全的函数
   - 只在主线程中工作

3. **在 FastAPI 中**：
   - 使用 `signal.signal()` 注册处理器
   - 使用 `asyncio.Event` 通知协程
   - 在 `@app.on_event("startup")` 中启动监听器

4. **在容器环境中**：
   - Docker：确保 Python 进程是 PID 1
   - Kubernetes：配置 terminationGracePeriodSeconds

### 检查清单

- [ ] 注册了 SIGTERM 和 SIGINT 处理器
- [ ] 使用 asyncio.Event 通知协程
- [ ] 信号处理器是同步函数
- [ ] 信号处理器尽快返回
- [ ] 在 Dockerfile 中使用 exec 形式
- [ ] 配置了合理的超时时间
- [ ] 测试了信号处理流程

---

**下一步**：学习 **03_核心概念_02_请求排空策略.md**，了解如何停止接收新请求并等待现有请求完成。
