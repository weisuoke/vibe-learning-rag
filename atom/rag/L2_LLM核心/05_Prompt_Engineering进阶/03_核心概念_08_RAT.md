# 核心概念 8: RAT (Retrieval Augmented Thoughts)

## 一句话定义

**RAG与CoT的深度融合,通过在推理过程中动态迭代检索,让模型根据思考需求实时补充信息,是2025年RAG系统的前沿优化技术。**

**RAG应用:** RAT是RAG系统的革命性升级,从"检索→生成"的静态流程进化为"检索→推理→再检索→再推理"的动态迭代,显著提升复杂问题的回答质量。

---

## 为什么重要?

### 问题场景

```python
# 场景:需要多步推理和信息补充的复杂查询
from openai import OpenAI
import chromadb

client = OpenAI()
chroma_client = chromadb.Client()
collection = chroma_client.create_collection("docs")

# 添加文档
docs = [
    "Python由Guido van Rossum于1991年创建",
    "Guido van Rossum在Google工作过",
    "Google成立于1998年",
    "Python 2.0发布于2000年"
]
collection.add(documents=docs, ids=[f"doc{i}" for i in range(len(docs))])

# ❌ 静态RAG:一次性检索
query = "Guido创建Python时在哪里工作?"

results = collection.query(query_texts=[query], n_results=3)
docs = results['documents'][0]

prompt = f"文档:{' | '.join(docs)}\n问题:{query}\n答案:"
answer = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": prompt}]
)

print(answer.choices[0].message.content)
# 可能输出:"Guido在Google工作"
# 问题:时间线错误!Python创建于1991年,Google成立于1998年
# 原因:初始检索没有获取到时间信息,无法补充检索
```

### 解决方案

```python
# ✅ RAT:迭代检索+推理
def rat_pipeline(query: str, max_iterations: int = 3) -> str:
    """RAT流程"""
    context = []
    
    for iteration in range(max_iterations):
        # 检索
        if iteration == 0:
            search_query = query
        else:
            # 根据推理结果生成新的检索查询
            thought_prompt = f"""
当前信息:{' | '.join(context)}
问题:{query}

分析:当前信息是否足够?如果不够,还需要什么信息?
"""
            thought = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": thought_prompt}]
            ).choices[0].message.content
            
            if "足够" in thought or "完成" in thought:
                break
            
            # 提取新的检索需求
            search_query = extract_search_need(thought)
        
        # 执行检索
        results = collection.query(query_texts=[search_query], n_results=2)
        new_docs = results['documents'][0]
        context.extend(new_docs)
        
        print(f"迭代{iteration + 1}:")
        print(f"  检索查询:{search_query}")
        print(f"  新文档:{new_docs}")
    
    # 最终答案
    final_prompt = f"""
完整信息:{' | '.join(context)}
问题:{query}

基于以上信息,给出准确答案:
"""
    
    answer = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": final_prompt}]
    ).choices[0].message.content
    
    return answer

def extract_search_need(thought: str) -> str:
    """从推理中提取检索需求"""
    prompt = f"从以下思考中提取需要检索的关键词:\n{thought}\n关键词:"
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}]
    )
    return response.choices[0].message.content.strip()

# 测试
answer = rat_pipeline("Guido创建Python时在哪里工作?")
print(f"\n最终答案:{answer}")

# 输出示例:
# 迭代1:
#   检索查询:Guido创建Python时在哪里工作?
#   新文档:['Python由Guido van Rossum于1991年创建', 'Guido van Rossum在Google工作过']
# 迭代2:
#   检索查询:Python创建时间 Guido工作经历
#   新文档:['Google成立于1998年', 'Python 2.0发布于2000年']
# 
# 最终答案:Guido创建Python(1991年)时不在Google工作,因为Google成立于1998年。
```

**性能提升:**

| 指标 | 静态RAG | RAT | 提升 |
|------|---------|-----|------|
| 多跳问答准确率 | 52% | 73% | +40% |
| 信息完整性 | 68% | 89% | +31% |
| 时间推理准确率 | 45% | 78% | +73% |

**来源:** [Retrieval Augmented Thoughts (2024)](https://arxiv.org/abs/2403.05313)

---

## 核心原理

### 原理1:思维驱动检索

**定义:** 检索不是一次性的,而是由推理过程驱动的迭代行为。

**流程对比:**

```
静态RAG:
查询 → 检索 → 生成 → 答案
      (一次性,无法调整)

RAT:
查询 → 检索1 → 推理1 → 发现信息不足
              ↓
         检索2 → 推理2 → 发现还需要X
                      ↓
                 检索3 → 推理3 → 信息充足 → 答案
```

**关键特征:**
1. **推理先行**: 先分析当前信息,再决定是否检索
2. **按需检索**: 只在需要时检索,避免过度检索
3. **迭代优化**: 每次检索都基于前一次的推理结果

**来源:** [RAT Paper (2024)](https://arxiv.org/abs/2403.05313)

---

### 原理2:信息充分性判断

**定义:** 模型能够判断当前信息是否足够回答问题。

**判断机制:**

```python
def is_information_sufficient(context: str, query: str) -> bool:
    """判断信息是否充分"""
    prompt = f"""
当前信息:{context}
问题:{query}

请判断:
1. 当前信息是否足够回答问题?
2. 如果不够,缺少什么关键信息?

判断(回答"充分"或"不充分"):
"""
    
    response = llm.generate(prompt)
    return "充分" in response or "足够" in response
```

**判断标准:**

```python
# 标准1:直接性
# 信息是否直接回答了问题?

# 标准2:完整性
# 是否覆盖了问题的所有方面?

# 标准3:一致性
# 信息之间是否有矛盾?

# 标准4:时间性
# 时间线是否合理?
```

---

### 原理3:查询改写

**定义:** 根据推理结果,动态生成新的检索查询。

**改写策略:**

```python
# 策略1:补充缺失信息
初始查询: "Python的创建者"
推理: "知道是Guido,但不知道他当时在哪工作"
新查询: "Guido van Rossum 1991年 工作单位"

# 策略2:澄清歧义
初始查询: "Python性能"
推理: "不确定是指运行速度还是开发效率"
新查询: "Python运行速度 性能基准测试"

# 策略3:深入细节
初始查询: "Python异步编程"
推理: "知道有async/await,但不知道底层原理"
新查询: "Python asyncio 事件循环 实现原理"
```

**实现:**

```python
def rewrite_query(
    original_query: str,
    current_context: str,
    reasoning: str
) -> str:
    """改写查询"""
    prompt = f"""
原始问题:{original_query}
当前信息:{current_context}
推理分析:{reasoning}

基于推理分析,生成一个新的检索查询,以获取缺失的信息。
新查询应该:
1. 具体明确
2. 包含关键词
3. 针对缺失信息

新查询:
"""
    
    response = llm.generate(prompt)
    return response.strip()
```

---

## 手写实现

### 从零实现 RAT

```python
"""
RAT (Retrieval Augmented Thoughts) Implementation
功能:迭代检索+推理
"""

from typing import List, Dict, Optional
from dataclasses import dataclass
from openai import OpenAI

@dataclass
class RATIteration:
    """RAT迭代"""
    iteration: int
    thought: str
    search_query: Optional[str]
    retrieved_docs: List[str]
    is_sufficient: bool

class RATEngine:
    """RAT引擎"""
    
    def __init__(self, client: OpenAI, retriever):
        self.client = client
        self.retriever = retriever
    
    def think(
        self,
        query: str,
        context: List[str],
        model: str = "gpt-4o-mini"
    ) -> Dict[str, any]:
        """推理当前状态"""
        prompt = f"""
问题:{query}

当前已知信息:
{chr(10).join(f"{i+1}. {doc}" for i, doc in enumerate(context))}

请分析:
1. 当前信息是否足够回答问题?
2. 如果不够,还需要什么信息?
3. 应该如何检索这些信息?

分析:
"""
        
        response = self.client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}]
        )
        
        thought = response.choices[0].message.content
        
        # 判断是否充分
        is_sufficient = any(
            keyword in thought.lower() 
            for keyword in ["充分", "足够", "完成", "sufficient", "enough"]
        )
        
        # 提取检索需求
        search_need = None
        if not is_sufficient:
            search_need = self._extract_search_need(thought, model)
        
        return {
            "thought": thought,
            "is_sufficient": is_sufficient,
            "search_need": search_need
        }
    
    def _extract_search_need(
        self,
        thought: str,
        model: str
    ) -> str:
        """提取检索需求"""
        prompt = f"""
从以下分析中提取需要检索的关键信息:

{thought}

生成一个简洁的检索查询(只包含关键词):
"""
        
        response = self.client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return response.choices[0].message.content.strip()
    
    def retrieve(
        self,
        query: str,
        top_k: int = 3
    ) -> List[str]:
        """执行检索"""
        return self.retriever.search(query, top_k=top_k)
    
    def generate_answer(
        self,
        query: str,
        context: List[str],
        model: str = "gpt-4o-mini"
    ) -> str:
        """生成最终答案"""
        prompt = f"""
问题:{query}

完整信息:
{chr(10).join(f"{i+1}. {doc}" for i, doc in enumerate(context))}

基于以上信息,给出准确、完整的答案:
"""
        
        response = self.client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return response.choices[0].message.content
    
    def run(
        self,
        query: str,
        max_iterations: int = 5,
        top_k: int = 3,
        model: str = "gpt-4o-mini"
    ) -> Dict:
        """运行RAT流程"""
        context = []
        iterations = []
        
        for i in range(max_iterations):
            # 推理
            thinking = self.think(query, context, model)
            
            # 检索(如果需要)
            retrieved_docs = []
            search_query = None
            
            if not thinking["is_sufficient"] and thinking["search_need"]:
                search_query = thinking["search_need"]
                retrieved_docs = self.retrieve(search_query, top_k)
                context.extend(retrieved_docs)
            
            # 记录迭代
            iteration = RATIteration(
                iteration=i + 1,
                thought=thinking["thought"],
                search_query=search_query,
                retrieved_docs=retrieved_docs,
                is_sufficient=thinking["is_sufficient"]
            )
            iterations.append(iteration)
            
            # 如果信息充分,停止迭代
            if thinking["is_sufficient"]:
                break
        
        # 生成最终答案
        final_answer = self.generate_answer(query, context, model)
        
        return {
            "query": query,
            "iterations": [
                {
                    "iteration": it.iteration,
                    "thought": it.thought,
                    "search_query": it.search_query,
                    "retrieved_docs": it.retrieved_docs,
                    "is_sufficient": it.is_sufficient
                }
                for it in iterations
            ],
            "final_context": context,
            "final_answer": final_answer
        }


# 使用示例
if __name__ == "__main__":
    from dotenv import load_dotenv
    import chromadb
    
    load_dotenv()
    
    client = OpenAI()
    chroma_client = chromadb.Client()
    collection = chroma_client.create_collection("docs")
    
    # 添加文档
    docs = [
        "Python由Guido van Rossum于1991年创建",
        "Guido van Rossum在Google工作过",
        "Google成立于1998年",
        "Python 2.0发布于2000年",
        "Guido在CWI(荷兰数学和计算机科学研究学会)工作时创建了Python"
    ]
    collection.add(documents=docs, ids=[f"doc{i}" for i in range(len(docs))])
    
    # 创建检索器
    class SimpleRetriever:
        def search(self, query, top_k=3):
            results = collection.query(query_texts=[query], n_results=top_k)
            return results['documents'][0]
    
    retriever = SimpleRetriever()
    rat = RATEngine(client, retriever)
    
    # 测试
    query = "Guido创建Python时在哪里工作?"
    
    result = rat.run(query, max_iterations=5, top_k=2)
    
    print(f"问题:{result['query']}\n")
    print("迭代过程:")
    for it in result['iterations']:
        print(f"\n迭代{it['iteration']}:")
        print(f"  推理:{it['thought'][:150]}...")
        if it['search_query']:
            print(f"  检索查询:{it['search_query']}")
            print(f"  检索结果:{it['retrieved_docs']}")
        print(f"  信息充分:{it['is_sufficient']}")
    
    print(f"\n最终答案:\n{result['final_answer']}")
```

---

## RAG 应用场景

### 场景1:多跳问答

```python
# 问题需要多步推理和信息链接
query = "Python的创建者在创建Python时的雇主是什么时候成立的?"

# RAT流程:
# 迭代1:检索"Python创建者" → 得到"Guido van Rossum"
# 迭代2:检索"Guido 1991年 雇主" → 得到"CWI"
# 迭代3:检索"CWI 成立时间" → 得到"1946年"
# 答案:"CWI成立于1946年"
```

### 场景2:时间推理

```python
# 问题涉及时间线验证
query = "Guido在Google工作时创建了Python吗?"

# RAT流程:
# 迭代1:检索"Python创建时间" → "1991年"
# 迭代2:检索"Google成立时间" → "1998年"
# 推理:1991年 < 1998年,时间线不符
# 答案:"不是,Python创建于1991年,而Google成立于1998年"
```

### 场景3:信息验证

```python
# 问题需要交叉验证
query = "Python是在Google创建的吗?"

# RAT流程:
# 迭代1:检索"Python创建" → "Guido创建于1991年"
# 迭代2:检索"Guido 1991年工作" → "在CWI工作"
# 迭代3:检索"Google成立" → "1998年"
# 推理:时间和地点都不匹配
# 答案:"不是,Python在CWI创建,不是Google"
```

---

## 最佳实践

### 1. 迭代次数控制

```python
# 根据问题复杂度设置
simple_query = 2-3次  # 简单问答
medium_query = 3-5次  # 中等复杂
complex_query = 5-7次  # 复杂推理

# 成本控制
# 每次迭代 = 1次推理 + 1次检索 + 1次LLM调用
# 总成本 = 迭代次数 * 单次成本
```

### 2. 信息去重

```python
def deduplicate_context(context: List[str]) -> List[str]:
    """去除重复信息"""
    seen = set()
    unique = []
    for doc in context:
        if doc not in seen:
            seen.add(doc)
            unique.append(doc)
    return unique
```

### 3. 早停策略

```python
# 策略1:信息充分时停止
if is_sufficient(context, query):
    break

# 策略2:连续N次检索无新信息时停止
if len(new_docs) == 0:
    no_new_info_count += 1
    if no_new_info_count >= 2:
        break

# 策略3:达到最大迭代次数
if iteration >= max_iterations:
    break
```

### 4. 查询质量控制

```python
def validate_search_query(query: str) -> bool:
    """验证检索查询质量"""
    # 检查1:不能为空
    if not query.strip():
        return False
    
    # 检查2:不能太短
    if len(query.split()) < 2:
        return False
    
    # 检查3:不能与之前的查询完全相同
    if query in previous_queries:
        return False
    
    return True
```

---

## 参考资源

- [Retrieval Augmented Thoughts (2024)](https://arxiv.org/abs/2403.05313)
- [Medium RAG + CoT](https://medium.com/@bijit211987/rag-chain-of-thought-retrieval-augmented-thoughts-rat-3d3489517bf0)
- [Weights & Biases RAT](https://wandb.ai/byyoung3/Generative-AI/reports/What-is-Retrieval-Augmented-Thinking-RAT-and-how-does-it-work---VmlldzoxMTc3OTg1Nw)
