# 最小可用

掌握以下内容，就能开始使用 BFS/DFS：

---

## 4.1 BFS 核心实现（队列）

**一句话：** 用队列实现层序遍历，先进先出

```python
from collections import deque

def bfs(graph, start):
    visited = set([start])
    queue = deque([start])
    result = []

    while queue:
        node = queue.popleft()  # 队首出队
        result.append(node)

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)  # 队尾入队

    return result
```

**关键点：**
- `deque` 而非 `list`（O(1) vs O(n)）
- 入队时立即标记 `visited`
- 保证最短路径

---

## 4.2 DFS 核心实现（递归）

**一句话：** 用递归实现深度探索，自动回溯

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()

    visited.add(start)
    result = [start]

    for neighbor in graph[start]:
        if neighbor not in visited:
            result.extend(dfs(graph, neighbor, visited))

    return result
```

**关键点：**
- 递归自动处理回溯
- `visited` 在递归间共享
- 适合路径探索

---

## 4.3 选择标准

**何时用 BFS：**
- 需要最短路径
- 图宽而浅
- RAG 中的广度检索

**何时用 DFS：**
- 需要完整路径
- 图窄而深
- RAG 中的推理链构建

---

## 4.4 路径重建

**一句话：** 记录父节点，反向追溯

```python
def bfs_find_path(graph, start, target):
    visited = {start}
    queue = deque([start])
    parent = {start: None}

    while queue:
        node = queue.popleft()

        if node == target:
            # 重建路径
            path = []
            while node is not None:
                path.append(node)
                node = parent[node]
            return path[::-1]

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = node
                queue.append(neighbor)

    return []
```

---

## 4.5 RAG 应用（KG2RAG）

**一句话：** BFS 扩展邻域 + DFS 组织段落

```python
# BFS 扩展
def expand_neighborhood(kg, seeds, m_hops=2):
    expanded = set(seeds)
    queue = deque([(e, 0) for e in seeds])

    while queue:
        entity, depth = queue.popleft()
        if depth >= m_hops:
            continue

        for neighbor in kg.get_neighbors(entity):
            if neighbor not in expanded:
                expanded.add(neighbor)
                queue.append((neighbor, depth + 1))

    return expanded

# DFS 组织
def organize_chunks(kg, entities, max_depth=3):
    organized = []
    visited = set()

    def dfs_path(entity, path, depth):
        if depth >= max_depth or entity in visited:
            return

        visited.add(entity)
        path.append(entity)

        neighbors = kg.get_neighbors(entity)
        if not neighbors or depth == max_depth - 1:
            organized.append(path[:])
        else:
            for neighbor in neighbors:
                if neighbor not in visited:
                    dfs_path(neighbor, path[:], depth + 1)
                    break

    for entity in entities:
        if entity not in visited:
            dfs_path(entity, [], 0)

    return organized
```

---

## 这些知识足以：

- ✅ 手写 BFS/DFS 算法
- ✅ 理解时间空间复杂度（O(V+E)）
- ✅ 实现路径查找
- ✅ 在 RAG 中应用（知识图谱检索）
- ✅ 为后续学习打基础（优化、AI 应用）

---

## 快速检查清单

- [ ] 能默写 BFS 的队列实现
- [ ] 能默写 DFS 的递归实现
- [ ] 理解 visited 集合的作用（避免重复）
- [ ] 知道何时用 BFS（最短路径）
- [ ] 知道何时用 DFS（路径探索）
- [ ] 能实现路径重建（父节点记录）
- [ ] 理解 KG2RAG 的混合策略

---

## 下一步学习

掌握最小可用知识后，建议：

1. **深入理解：** `02_第一性原理.md` - 理解为什么需要 BFS/DFS
2. **对比学习：** `03_核心概念_03_遍历策略对比.md` - 深入对比
3. **实战练习：** `07_实战代码_场景1_基础BFS_DFS实现.md` - 动手实践
4. **AI 应用：** `03_核心概念_06_知识图谱遍历.md` - 进入 RAG 应用

---

**版本：** v1.0
**最后更新：** 2026-02-14
