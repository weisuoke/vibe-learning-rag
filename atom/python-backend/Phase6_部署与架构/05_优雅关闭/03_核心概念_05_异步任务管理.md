# 核心概念：异步任务管理

> 深入理解如何管理 BackgroundTasks 和 asyncio.Task 的优雅终止

---

## 什么是异步任务？

**异步任务（Async Task）** 是在后台执行的非阻塞操作，不会阻塞主请求的返回。

**两种主要类型：**
1. **BackgroundTasks**：FastAPI 提供的后台任务机制
2. **asyncio.Task**：Python 原生的异步任务

**类比：**
- **前端视角**：类似于 `setTimeout`、`setInterval` 或后台任务队列
- **日常视角**：类似于快递员送完货后继续配送下一单

---

## BackgroundTasks vs asyncio.Task

| 特性 | BackgroundTasks | asyncio.Task |
|------|----------------|--------------|
| **来源** | FastAPI 提供 | Python 原生 |
| **生命周期** | 绑定到请求 | 独立运行 |
| **取消** | 自动取消 | 需要手动取消 |
| **错误处理** | 自动捕获 | 需要手动处理 |
| **适用场景** | 短任务（<30秒） | 长任务、后台服务 |

---

## BackgroundTasks 管理

### 1. 基础用法

```python
from fastapi import FastAPI, BackgroundTasks

app = FastAPI()

def send_email(email: str, message: str):
    """发送邮件（同步函数）"""
    print(f"发送邮件到 {email}: {message}")
    time.sleep(2)  # 模拟发送邮件
    print("邮件发送完成")

@app.post("/send-notification")
async def send_notification(
    email: str,
    background_tasks: BackgroundTasks
):
    """发送通知"""
    # 立即返回响应
    background_tasks.add_task(send_email, email, "Hello!")
    return {"message": "Notification queued"}
```

### 2. 优雅关闭时的处理

```python
"""
BackgroundTasks 优雅关闭
演示：等待后台任务完成
"""

from fastapi import FastAPI, BackgroundTasks, Request
from typing import Set
import asyncio

app = FastAPI()

# 跟踪所有后台任务
background_tasks_set: Set[asyncio.Task] = set()

async def tracked_background_task(func, *args, **kwargs):
    """包装后台任务，添加跟踪"""
    task = asyncio.current_task()
    background_tasks_set.add(task)
    try:
        if asyncio.iscoroutinefunction(func):
            await func(*args, **kwargs)
        else:
            await asyncio.to_thread(func, *args, **kwargs)
    finally:
        background_tasks_set.discard(task)

@app.post("/process")
async def process_data(
    data: str,
    background_tasks: BackgroundTasks
):
    """处理数据"""
    # 添加后台任务
    background_tasks.add_task(
        tracked_background_task,
        process_in_background,
        data
    )
    return {"message": "Processing started"}

async def cleanup_background_tasks(timeout: int = 30):
    """清理后台任务"""
    if not background_tasks_set:
        return

    print(f"等待 {len(background_tasks_set)} 个后台任务完成...")

    try:
        await asyncio.wait_for(
            asyncio.gather(*background_tasks_set, return_exceptions=True),
            timeout=timeout
        )
        print("所有后台任务已完成")
    except asyncio.TimeoutError:
        print(f"后台任务超时，取消剩余任务")
        for task in background_tasks_set:
            if not task.done():
                task.cancel()
```

### 3. BackgroundTasks 的限制

```python
# ❌ 问题：BackgroundTasks 不适合长时间任务
@app.post("/long-task")
async def long_task(background_tasks: BackgroundTasks):
    # 这个任务需要5分钟
    background_tasks.add_task(process_large_file)  # 不推荐！
    return {"message": "Task started"}

# 问题：
# 1. 如果服务重启，任务会丢失
# 2. 无法跟踪任务状态
# 3. 无法取消任务
# 4. 优雅关闭时可能超时

# ✅ 解决方案：使用任务队列（Celery、RQ）
from celery import Celery

celery_app = Celery("tasks", broker="redis://localhost:6379/0")

@celery_app.task
def process_large_file(file_path: str):
    """处理大文件（Celery 任务）"""
    # 长时间运行的任务
    pass

@app.post("/long-task")
async def long_task(file_path: str):
    # 提交到 Celery
    task = process_large_file.delay(file_path)
    return {"task_id": task.id}
```

---

## asyncio.Task 管理

### 1. 创建和跟踪任务

```python
"""
asyncio.Task 管理
演示：创建、跟踪和取消任务
"""

import asyncio
from typing import Set

# 全局任务集合
active_tasks: Set[asyncio.Task] = set()

def create_task(coro):
    """创建任务并跟踪"""
    task = asyncio.create_task(coro)
    active_tasks.add(task)

    # 任务完成时自动移除
    task.add_done_callback(active_tasks.discard)

    return task

# 使用示例
async def background_worker():
    """后台工作线程"""
    while True:
        await process_queue()
        await asyncio.sleep(1)

# 创建任务
task = create_task(background_worker())
```

### 2. 优雅取消任务

```python
"""
优雅取消 asyncio.Task
演示：正确的任务取消方式
"""

async def cancellable_task():
    """可取消的任务"""
    try:
        while True:
            # 执行工作
            await do_work()
            await asyncio.sleep(1)

    except asyncio.CancelledError:
        # 任务被取消，执行清理
        print("任务被取消，正在清理...")
        await cleanup()
        raise  # 重新抛出异常

async def cancel_task(task: asyncio.Task):
    """优雅取消任务"""
    if task.done():
        return

    # 1. 请求取消
    task.cancel()

    # 2. 等待任务完成取消
    try:
        await task
    except asyncio.CancelledError:
        print("任务已取消")
```

### 3. 任务组管理

```python
"""
任务组管理
演示：管理多个相关任务
"""

class TaskGroup:
    """任务组"""

    def __init__(self, name: str):
        self.name = name
        self.tasks: Set[asyncio.Task] = set()
        self.shutdown_event = asyncio.Event()

    def create_task(self, coro):
        """创建任务"""
        task = asyncio.create_task(coro)
        self.tasks.add(task)
        task.add_done_callback(self.tasks.discard)
        return task

    async def shutdown(self, timeout: int = 30):
        """关闭任务组"""
        print(f"关闭任务组 {self.name}...")

        # 1. 设置关闭标志
        self.shutdown_event.set()

        # 2. 等待任务自然结束
        if self.tasks:
            done, pending = await asyncio.wait(
                self.tasks,
                timeout=timeout,
                return_when=asyncio.ALL_COMPLETED
            )

            print(f"✓ {len(done)} 个任务已完成")

            # 3. 取消未完成的任务
            if pending:
                print(f"⚠ {len(pending)} 个任务超时，正在取消...")
                for task in pending:
                    task.cancel()

                await asyncio.gather(*pending, return_exceptions=True)

        print(f"任务组 {self.name} 已关闭")

# 使用示例
worker_group = TaskGroup("workers")

async def worker(worker_id: int):
    """工作线程"""
    try:
        while not worker_group.shutdown_event.is_set():
            await do_work(worker_id)
            await asyncio.sleep(1)
    except asyncio.CancelledError:
        print(f"Worker {worker_id} 被取消")
        raise

# 创建多个工作线程
for i in range(5):
    worker_group.create_task(worker(i))

# 优雅关闭
await worker_group.shutdown()
```

---

## 检测关闭信号

### 1. 使用 asyncio.Event

```python
"""
使用 asyncio.Event 检测关闭信号
演示：在任务中检测关闭信号
"""

shutdown_event = asyncio.Event()

async def long_running_task():
    """长时间运行的任务"""
    for i in range(100):
        # 检查关闭信号
        if shutdown_event.is_set():
            print(f"任务在第 {i} 步被中断")
            break

        # 执行工作
        await do_work(i)
        await asyncio.sleep(1)

    print("任务完成")

# 优雅关闭时
shutdown_event.set()  # 通知所有任务
```

### 2. 使用 try-except 捕获取消

```python
"""
使用 try-except 捕获取消
演示：处理任务取消
"""

async def task_with_cleanup():
    """带清理的任务"""
    resource = await acquire_resource()

    try:
        while True:
            await process(resource)
            await asyncio.sleep(1)

    except asyncio.CancelledError:
        # 任务被取消，清理资源
        print("任务被取消，正在清理资源...")
        await release_resource(resource)
        raise  # 重新抛出异常

    finally:
        # 无论如何都会执行
        print("任务结束")
```

---

## AI Agent 后台任务管理

### 1. Agent 任务队列

```python
"""
AI Agent 任务队列
演示：管理 Agent 任务的优雅关闭
"""

from typing import Dict, Optional
import asyncio

class AgentTaskQueue:
    """Agent 任务队列"""

    def __init__(self):
        self.tasks: Dict[str, asyncio.Task] = {}
        self.shutdown_event = asyncio.Event()
        self.accepting_tasks = True

    async def submit_task(self, task_id: str, prompt: str):
        """提交任务"""
        if not self.accepting_tasks:
            raise ValueError("Queue is shutting down")

        # 创建任务
        task = asyncio.create_task(self._run_agent(task_id, prompt))
        self.tasks[task_id] = task

        return task_id

    async def _run_agent(self, task_id: str, prompt: str):
        """运行 Agent"""
        try:
            # 检查关闭信号
            if self.shutdown_event.is_set():
                return {"status": "cancelled", "reason": "shutdown"}

            # 运行 Agent
            result = await agent.run(prompt)

            return {"status": "completed", "result": result}

        except asyncio.CancelledError:
            return {"status": "cancelled", "reason": "timeout"}

        finally:
            # 移除任务
            self.tasks.pop(task_id, None)

    async def shutdown(self, timeout: int = 60):
        """优雅关闭"""
        print(f"关闭 Agent 任务队列（{len(self.tasks)} 个任务）...")

        # 1. 停止接收新任务
        self.accepting_tasks = False

        # 2. 设置关闭标志
        self.shutdown_event.set()

        # 3. 等待任务完成
        if self.tasks:
            try:
                await asyncio.wait_for(
                    asyncio.gather(*self.tasks.values(), return_exceptions=True),
                    timeout=timeout
                )
                print("所有 Agent 任务已完成")
            except asyncio.TimeoutError:
                print(f"Agent 任务超时，取消剩余任务")
                for task in self.tasks.values():
                    if not task.done():
                        task.cancel()

        print("Agent 任务队列已关闭")

# 使用示例
agent_queue = AgentTaskQueue()

# 提交任务
task_id = await agent_queue.submit_task("task-1", "分析文档...")

# 优雅关闭
await agent_queue.shutdown()
```

### 2. LLM 流式响应任务

```python
"""
LLM 流式响应任务管理
演示：管理流式响应的优雅中断
"""

class StreamingTaskManager:
    """流式响应任务管理器"""

    def __init__(self):
        self.active_streams: Set[asyncio.Task] = set()
        self.shutdown_event = asyncio.Event()

    async def stream_llm_response(self, prompt: str):
        """流式响应"""
        task = asyncio.current_task()
        self.active_streams.add(task)

        try:
            async for chunk in llm.astream(prompt):
                # 检查关闭信号
                if self.shutdown_event.is_set():
                    yield {"type": "end", "reason": "shutdown"}
                    break

                yield {"type": "chunk", "content": chunk}

        except asyncio.CancelledError:
            yield {"type": "end", "reason": "cancelled"}
            raise

        finally:
            self.active_streams.discard(task)

    async def shutdown(self, timeout: int = 30):
        """优雅关闭"""
        print(f"关闭 {len(self.active_streams)} 个流式响应...")

        # 1. 设置关闭标志
        self.shutdown_event.set()

        # 2. 等待流式响应结束
        if self.active_streams:
            try:
                await asyncio.wait_for(
                    asyncio.gather(*self.active_streams, return_exceptions=True),
                    timeout=timeout
                )
            except asyncio.TimeoutError:
                print("流式响应超时，强制取消")
                for task in self.active_streams:
                    if not task.done():
                        task.cancel()

        print("所有流式响应已关闭")
```

---

## 完整示例：生产级异步任务管理

```python
"""
生产级异步任务管理
演示：完整的任务管理系统
"""

import asyncio
from typing import Set, Dict, Optional
from enum import Enum

class TaskStatus(Enum):
    """任务状态"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
    FAILED = "failed"

class TaskInfo:
    """任务信息"""
    def __init__(self, task_id: str, task: asyncio.Task):
        self.task_id = task_id
        self.task = task
        self.status = TaskStatus.RUNNING
        self.start_time = asyncio.get_event_loop().time()
        self.result: Optional[any] = None
        self.error: Optional[Exception] = None

class TaskManager:
    """任务管理器"""

    def __init__(self):
        self.tasks: Dict[str, TaskInfo] = {}
        self.shutdown_event = asyncio.Event()
        self.accepting_tasks = True

    def create_task(self, task_id: str, coro):
        """创建任务"""
        if not self.accepting_tasks:
            raise ValueError("TaskManager is shutting down")

        # 创建任务
        task = asyncio.create_task(self._run_task(task_id, coro))

        # 记录任务信息
        task_info = TaskInfo(task_id, task)
        self.tasks[task_id] = task_info

        return task_id

    async def _run_task(self, task_id: str, coro):
        """运行任务"""
        task_info = self.tasks[task_id]

        try:
            # 执行任务
            result = await coro

            # 记录结果
            task_info.status = TaskStatus.COMPLETED
            task_info.result = result

            return result

        except asyncio.CancelledError:
            # 任务被取消
            task_info.status = TaskStatus.CANCELLED
            raise

        except Exception as e:
            # 任务失败
            task_info.status = TaskStatus.FAILED
            task_info.error = e
            raise

    def get_task_status(self, task_id: str) -> Optional[TaskStatus]:
        """获取任务状态"""
        task_info = self.tasks.get(task_id)
        return task_info.status if task_info else None

    async def cancel_task(self, task_id: str):
        """取消任务"""
        task_info = self.tasks.get(task_id)
        if not task_info:
            return

        if not task_info.task.done():
            task_info.task.cancel()
            try:
                await task_info.task
            except asyncio.CancelledError:
                pass

    async def shutdown(self, timeout: int = 30):
        """优雅关闭"""
        print(f"\n========== 关闭任务管理器 ==========")
        print(f"当前任务数: {len(self.tasks)}")

        # 1. 停止接收新任务
        self.accepting_tasks = False

        # 2. 设置关闭标志
        self.shutdown_event.set()

        # 3. 统计任务状态
        running_tasks = [
            info for info in self.tasks.values()
            if info.status == TaskStatus.RUNNING
        ]

        if not running_tasks:
            print("没有运行中的任务")
            return

        print(f"等待 {len(running_tasks)} 个任务完成...")

        # 4. 等待任务完成
        try:
            await asyncio.wait_for(
                asyncio.gather(
                    *[info.task for info in running_tasks],
                    return_exceptions=True
                ),
                timeout=timeout
            )
            print("✓ 所有任务已完成")

        except asyncio.TimeoutError:
            print(f"⚠ 任务超时，取消剩余任务")

            # 5. 取消未完成的任务
            for info in running_tasks:
                if not info.task.done():
                    info.task.cancel()

            # 6. 等待取消完成
            await asyncio.gather(
                *[info.task for info in running_tasks],
                return_exceptions=True
            )

        # 7. 显示统计
        self._print_statistics()

        print("========== 任务管理器已关闭 ==========\n")

    def _print_statistics(self):
        """打印统计信息"""
        stats = {
            TaskStatus.COMPLETED: 0,
            TaskStatus.CANCELLED: 0,
            TaskStatus.FAILED: 0,
        }

        for info in self.tasks.values():
            if info.status in stats:
                stats[info.status] += 1

        print("\n任务统计:")
        print(f"  完成: {stats[TaskStatus.COMPLETED]}")
        print(f"  取消: {stats[TaskStatus.CANCELLED]}")
        print(f"  失败: {stats[TaskStatus.FAILED]}")

# ===== 使用示例 =====
task_manager = TaskManager()

async def example_task(task_id: int):
    """示例任务"""
    try:
        for i in range(10):
            if task_manager.shutdown_event.is_set():
                print(f"Task {task_id} 检测到关闭信号")
                break

            print(f"Task {task_id} 执行步骤 {i}")
            await asyncio.sleep(1)

        return f"Task {task_id} 完成"

    except asyncio.CancelledError:
        print(f"Task {task_id} 被取消")
        raise

# 创建任务
for i in range(5):
    task_manager.create_task(f"task-{i}", example_task(i))

# 优雅关闭
await task_manager.shutdown()
```

---

## 常见错误和解决方案

### 错误1：忘记取消任务

```python
# ❌ 错误：不取消任务
async def shutdown():
    print("关闭中...")
    # 忘记取消任务，任务继续运行

# ✅ 正确：显式取消任务
async def shutdown():
    for task in active_tasks:
        if not task.done():
            task.cancel()
    await asyncio.gather(*active_tasks, return_exceptions=True)
```

### 错误2：不处理 CancelledError

```python
# ❌ 错误：捕获所有异常
async def task():
    try:
        await do_work()
    except Exception:  # 会捕获 CancelledError！
        pass

# ✅ 正确：重新抛出 CancelledError
async def task():
    try:
        await do_work()
    except asyncio.CancelledError:
        await cleanup()
        raise  # 重新抛出
    except Exception:
        pass
```

### 错误3：不等待任务完成

```python
# ❌ 错误：取消后不等待
for task in tasks:
    task.cancel()
# 任务可能还在运行！

# ✅ 正确：等待取消完成
for task in tasks:
    task.cancel()
await asyncio.gather(*tasks, return_exceptions=True)
```

---

## 总结

### 核心要点

1. **BackgroundTasks**：
   - 适合短任务（<30秒）
   - 自动管理生命周期
   - 优雅关闭时需要等待

2. **asyncio.Task**：
   - 适合长任务和后台服务
   - 需要手动管理生命周期
   - 需要显式取消

3. **优雅关闭流程**：
   - 停止接收新任务
   - 设置关闭标志
   - 等待任务完成
   - 超时后取消任务

4. **错误处理**：
   - 捕获 CancelledError
   - 执行清理逻辑
   - 重新抛出异常

### 检查清单

- [ ] 跟踪所有后台任务
- [ ] 实现任务取消机制
- [ ] 处理 CancelledError
- [ ] 设置合理的超时时间
- [ ] 在任务中检测关闭信号
- [ ] 等待任务完成后再退出
- [ ] 记录任务统计信息

---

**下一步**：学习 **03_核心概念_06_超时控制机制.md**，了解如何设计分阶段超时策略。
