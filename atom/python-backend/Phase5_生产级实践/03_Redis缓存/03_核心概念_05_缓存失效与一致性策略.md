# 核心概念5：缓存失效与一致性策略

## 概述

缓存失效和一致性是生产环境中的关键问题。本文介绍主动失效、被动失效、缓存穿透/击穿/雪崩的防护策略。

---

## 1. 缓存失效策略

### TTL自动过期

```python
# 基础TTL设置
redis_client.setex("key", 3600, "value")  # 1小时后自动过期

# 动态TTL
def get_dynamic_ttl(data_type: str, access_count: int) -> int:
    base_ttl = {"llm": 3600, "embedding": 86400, "user": 1800}[data_type]

    # 高频访问：延长TTL
    if access_count > 100:
        return base_ttl * 2
    return base_ttl
```

### 主动失效

```python
class CacheInvalidator:
    """缓存失效管理器"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    def invalidate_by_key(self, key: str):
        """按key失效"""
        self.redis.delete(key)

    def invalidate_by_pattern(self, pattern: str):
        """按模式失效"""
        keys = self.redis.keys(pattern)
        if keys:
            self.redis.delete(*keys)

    def invalidate_by_tag(self, tag: str):
        """按标签失效"""
        cache_keys = self.redis.smembers(f"tag:{tag}")
        if cache_keys:
            self.redis.delete(*cache_keys)
            self.redis.delete(f"tag:{tag}")
```

---

## 2. 缓存一致性策略

### Cache-Aside模式（推荐）

```python
async def get_user(user_id: int):
    """Cache-Aside模式"""
    # 1. 先查缓存
    cache_key = f"user:{user_id}"
    cached = redis_client.get(cache_key)
    if cached:
        return json.loads(cached)

    # 2. 缓存未命中，查数据库
    user = await db.query(User).filter_by(id=user_id).first()

    # 3. 写入缓存
    if user:
        redis_client.setex(cache_key, 3600, json.dumps(user))

    return user

async def update_user(user_id: int, data: dict):
    """更新用户"""
    # 1. 更新数据库
    await db.query(User).filter_by(id=user_id).update(data)
    await db.commit()

    # 2. 删除缓存（让下次读取时重新加载）
    redis_client.delete(f"user:{user_id}")
```

### Write-Through模式

```python
async def update_user_write_through(user_id: int, data: dict):
    """Write-Through模式"""
    # 1. 同时更新数据库和缓存
    await db.query(User).filter_by(id=user_id).update(data)
    await db.commit()

    # 2. 更新缓存
    user = await db.query(User).filter_by(id=user_id).first()
    redis_client.setex(f"user:{user_id}", 3600, json.dumps(user))
```

---

## 3. 缓存穿透防护

### 布隆过滤器

```python
class BloomFilter:
    """简单布隆过滤器"""

    def __init__(self, size: int = 10000, hash_count: int = 3):
        self.size = size
        self.hash_count = hash_count
        self.bits = set()

    def add(self, item: str):
        """添加元素"""
        for i in range(self.hash_count):
            hash_val = hash(item + str(i)) % self.size
            self.bits.add(hash_val)

    def might_exist(self, item: str) -> bool:
        """判断元素可能存在"""
        for i in range(self.hash_count):
            hash_val = hash(item + str(i)) % self.size
            if hash_val not in self.bits:
                return False
        return True

# 使用
bloom = BloomFilter()

# 初始化：添加所有存在的用户ID
for user_id in existing_user_ids:
    bloom.add(f"user:{user_id}")

# 查询时先检查
def get_user_protected(user_id: int):
    if not bloom.might_exist(f"user:{user_id}"):
        return None  # 不存在，直接返回

    # 可能存在，继续查询
    return get_user(user_id)
```

### 空值缓存

```python
async def get_user_with_null_cache(user_id: int):
    """空值缓存"""
    cache_key = f"user:{user_id}"
    cached = redis_client.get(cache_key)

    if cached == "NULL":
        return None  # 空值缓存
    if cached:
        return json.loads(cached)

    user = await db.query(User).filter_by(id=user_id).first()

    if user:
        redis_client.setex(cache_key, 3600, json.dumps(user))
    else:
        # 缓存空值，TTL较短
        redis_client.setex(cache_key, 60, "NULL")

    return user
```

---

## 4. 缓存击穿防护

### 互斥锁

```python
import asyncio

locks = {}

async def get_with_mutex(key: str, fetch_func):
    """互斥锁防护"""
    cached = redis_client.get(key)
    if cached:
        return cached

    if key not in locks:
        locks[key] = asyncio.Lock()

    async with locks[key]:
        # 双重检查
        cached = redis_client.get(key)
        if cached:
            return cached

        # 只有一个请求执行
        data = await fetch_func()
        redis_client.setex(key, 3600, data)
        return data
```

### 提前刷新

```python
async def get_with_refresh(key: str, fetch_func, ttl: int = 3600):
    """提前刷新热点数据"""
    cached = redis_client.get(key)
    remaining_ttl = redis_client.ttl(key)

    # 剩余TTL < 10%时，异步刷新
    if remaining_ttl > 0 and remaining_ttl < ttl * 0.1:
        asyncio.create_task(refresh_cache(key, fetch_func, ttl))

    if cached:
        return cached

    data = await fetch_func()
    redis_client.setex(key, ttl, data)
    return data

async def refresh_cache(key: str, fetch_func, ttl: int):
    """异步刷新缓存"""
    data = await fetch_func()
    redis_client.setex(key, ttl, data)
```

---

## 5. 缓存雪崩防护

### 随机TTL

```python
import random

def set_with_random_ttl(key: str, value: str, base_ttl: int):
    """随机TTL防雪崩"""
    random_ttl = base_ttl + random.randint(-base_ttl//10, base_ttl//10)
    redis_client.setex(key, random_ttl, value)
```

### 缓存预热

```python
async def warmup_cache(hot_keys: List[str]):
    """缓存预热"""
    for key in hot_keys:
        data = await fetch_data(key)
        set_with_random_ttl(key, data, 3600)
```

---

## 6. 多层防护

```python
class CacheProtection:
    """多层缓存防护"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.bloom = BloomFilter()
        self.locks = {}

    async def get_protected(
        self,
        key: str,
        fetch_func,
        ttl: int = 3600
    ):
        """多层防护获取"""
        # 1. 布隆过滤器
        if not self.bloom.might_exist(key):
            return None

        # 2. 查询缓存
        cached = self.redis.get(key)
        if cached == "NULL":
            return None
        if cached:
            return cached

        # 3. 互斥锁
        if key not in self.locks:
            self.locks[key] = asyncio.Lock()

        async with self.locks[key]:
            cached = self.redis.get(key)
            if cached:
                return cached if cached != "NULL" else None

            # 4. 查询数据
            data = await fetch_func()

            # 5. 随机TTL + 空值缓存
            if data:
                random_ttl = ttl + random.randint(-ttl//10, ttl//10)
                self.redis.setex(key, random_ttl, data)
            else:
                self.redis.setex(key, 60, "NULL")

            return data
```

---

## 总结

1. **失效策略**：TTL自动过期、主动失效、按标签失效
2. **一致性**：Cache-Aside模式（推荐）、Write-Through模式
3. **缓存穿透**：布隆过滤器 + 空值缓存
4. **缓存击穿**：互斥锁 + 提前刷新
5. **缓存雪崩**：随机TTL + 缓存预热
6. **多层防护**：组合使用多种策略

**记住：** 生产环境必须考虑缓存失效和一致性问题，多层防护确保系统稳定性。
