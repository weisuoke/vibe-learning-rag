# 第一性原理

### 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

---

## 中间件系统的第一性原理

### 1. 最基础的定义

**中间件 = 在请求到达路由处理函数之前/响应返回客户端之前执行的函数**

仅此而已！没有更基础的了。

就像一个流水线上的检查站，每个请求都要经过这些检查站，每个响应也要经过这些检查站。

---

### 2. 为什么需要中间件？

**核心问题：如何在不修改每个路由函数的情况下，为所有请求添加通用逻辑？**

想象一个场景：
- 你有 100 个 API 端点
- 每个端点都需要：记录日志、验证 JWT、检查限流、处理 CORS
- 如果在每个路由函数里写这些逻辑，代码会重复 100 次

**这就是中间件要解决的问题：横切关注点（Cross-Cutting Concerns）**

---

### 3. 中间件的三层价值

#### 价值1：代码复用（DRY 原则）

**问题：** 相同的逻辑在多个地方重复

**中间件解决方案：** 写一次，应用到所有路由

```python
# ❌ 没有中间件：每个路由都要写日志
@app.get("/users")
async def get_users():
    print(f"[{datetime.now()}] GET /users")  # 重复代码
    return {"users": []}

@app.get("/posts")
async def get_posts():
    print(f"[{datetime.now()}] GET /posts")  # 重复代码
    return {"posts": []}

# ✅ 有中间件：写一次，应用到所有路由
@app.middleware("http")
async def log_requests(request: Request, call_next):
    print(f"[{datetime.now()}] {request.method} {request.url.path}")
    response = await call_next(request)
    return response

@app.get("/users")
async def get_users():
    return {"users": []}  # 干净简洁

@app.get("/posts")
async def get_posts():
    return {"posts": []}  # 干净简洁
```

#### 价值2：关注点分离（Separation of Concerns）

**问题：** 业务逻辑和基础设施逻辑混在一起

**中间件解决方案：** 业务逻辑专注业务，基础设施逻辑放中间件

```python
# ❌ 没有中间件：业务逻辑和认证逻辑混在一起
@app.get("/users/me")
async def get_current_user(authorization: str = Header(None)):
    # 认证逻辑（基础设施关注点）
    if not authorization:
        raise HTTPException(401, "Missing token")
    token = authorization.replace("Bearer ", "")
    try:
        payload = jwt.decode(token, SECRET_KEY)
    except:
        raise HTTPException(401, "Invalid token")

    # 业务逻辑
    user_id = payload["user_id"]
    return {"user_id": user_id, "name": "Alice"}

# ✅ 有中间件：关注点分离
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # 认证逻辑集中在中间件
    if request.url.path.startswith("/api/"):
        token = request.headers.get("authorization", "").replace("Bearer ", "")
        if not token:
            return JSONResponse({"error": "Missing token"}, status_code=401)
        try:
            payload = jwt.decode(token, SECRET_KEY)
            request.state.user_id = payload["user_id"]
        except:
            return JSONResponse({"error": "Invalid token"}, status_code=401)

    return await call_next(request)

@app.get("/users/me")
async def get_current_user(request: Request):
    # 只关注业务逻辑
    user_id = request.state.user_id
    return {"user_id": user_id, "name": "Alice"}
```

#### 价值3：可组合性（Composability）

**问题：** 不同的路由需要不同的处理逻辑组合

**中间件解决方案：** 像乐高积木一样组合中间件

```python
# 多个中间件按顺序执行，形成处理链
app.add_middleware(CORSMiddleware)      # 1. 处理跨域
app.add_middleware(LoggingMiddleware)   # 2. 记录日志
app.add_middleware(AuthMiddleware)      # 3. 验证认证
app.add_middleware(RateLimitMiddleware) # 4. 限流保护

# 请求流程：
# 客户端 → CORS → 日志 → 认证 → 限流 → 路由处理 → 限流 → 认证 → 日志 → CORS → 客户端
```

---

### 4. 从第一性原理推导 AI Agent 后端的中间件需求

**推理链：**

```
1. AI Agent 后端需要调用 LLM API（如 OpenAI）
   ↓
2. LLM API 调用很贵（每次调用几分钱到几块钱）
   ↓
3. 必须防止 API 被滥用（恶意用户、爬虫、DDoS）
   ↓
4. 需要认证（只有授权用户才能调用）
   ↓
5. 需要限流（每个用户每分钟最多 10 次请求）
   ↓
6. 需要日志（记录谁在什么时候调用了什么）
   ↓
7. 需要错误处理（LLM API 失败时返回友好错误）
   ↓
8. 这些都是横切关注点，适合用中间件实现
   ↓
9. 因此，AI Agent 后端必须有完善的中间件系统
```

**实际应用：**

```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
import time

app = FastAPI()

# 1. CORS 中间件：允许前端跨域调用
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# 2. 日志中间件：记录每个请求
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    start_time = time.time()
    print(f"[{request.method}] {request.url.path}")

    response = await call_next(request)

    duration = time.time() - start_time
    print(f"  ↳ {response.status_code} ({duration:.2f}s)")
    return response

# 3. 认证中间件：验证 JWT
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    if request.url.path.startswith("/api/agent/"):
        token = request.headers.get("authorization")
        if not token:
            return JSONResponse({"error": "Unauthorized"}, status_code=401)
        # 验证 token...

    return await call_next(request)

# 4. 限流中间件：防止滥用
rate_limit_store = {}

@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    client_ip = request.client.host
    now = time.time()

    # 简单的滑动窗口限流
    if client_ip not in rate_limit_store:
        rate_limit_store[client_ip] = []

    # 清理 1 分钟前的记录
    rate_limit_store[client_ip] = [
        t for t in rate_limit_store[client_ip]
        if now - t < 60
    ]

    # 检查是否超过限制
    if len(rate_limit_store[client_ip]) >= 10:
        return JSONResponse(
            {"error": "Rate limit exceeded"},
            status_code=429
        )

    rate_limit_store[client_ip].append(now)
    return await call_next(request)

# 业务路由：只关注业务逻辑
@app.post("/api/agent/chat")
async def chat(request: Request):
    # 中间件已经处理了 CORS、日志、认证、限流
    # 这里只需要关注业务逻辑
    message = await request.json()
    response = await call_llm(message["text"])
    return {"response": response}
```

---

### 5. 一句话总结第一性原理

**中间件是请求/响应的拦截器，通过在路由处理前后执行通用逻辑，实现代码复用、关注点分离和可组合性，是构建生产级 API 的基础设施。**

---

## 中间件 vs 依赖注入

很多人会混淆中间件和依赖注入，它们的区别是：

| 维度 | 中间件 | 依赖注入 |
|------|--------|----------|
| **作用范围** | 全局（所有路由） | 局部（指定路由） |
| **执行时机** | 请求前/响应后 | 路由处理时 |
| **典型用途** | 日志、认证、CORS | 数据库连接、配置 |
| **Express 类比** | `app.use()` | 函数参数 |

```python
# 中间件：全局应用
@app.middleware("http")
async def log_middleware(request: Request, call_next):
    print(f"Request: {request.url.path}")
    return await call_next(request)

# 依赖注入：局部应用
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users")
async def get_users(db: Session = Depends(get_db)):  # 只有这个路由用到 db
    return db.query(User).all()
```

**选择原则：**
- 需要应用到所有路由 → 中间件
- 只有部分路由需要 → 依赖注入

---

## 中间件的执行顺序

中间件的执行顺序是**洋葱模型**（Onion Model）：

```
请求进入：
客户端 → 中间件1 → 中间件2 → 中间件3 → 路由处理 → 中间件3 → 中间件2 → 中间件1 → 客户端
         ↓        ↓        ↓        ↓        ↑        ↑        ↑
       before   before   before   handle   after    after    after
```

**代码示例：**

```python
@app.middleware("http")
async def middleware_1(request: Request, call_next):
    print("1: before")
    response = await call_next(request)
    print("1: after")
    return response

@app.middleware("http")
async def middleware_2(request: Request, call_next):
    print("2: before")
    response = await call_next(request)
    print("2: after")
    return response

@app.get("/test")
async def test():
    print("Route handler")
    return {"message": "ok"}

# 访问 /test 的输出：
# 1: before
# 2: before
# Route handler
# 2: after
# 1: after
```

**为什么是洋葱模型？**

因为每个中间件都要：
1. 在请求到达下一层之前做一些事（before）
2. 调用 `call_next()` 让请求继续传递
3. 在响应返回上一层之前做一些事（after）

这就像剥洋葱，一层一层进去，再一层一层出来。

---

## 总结

**中间件的第一性原理：**

1. **本质**：请求/响应的拦截器
2. **目的**：解决横切关注点的代码复用问题
3. **价值**：代码复用、关注点分离、可组合性
4. **执行模型**：洋葱模型（先进后出）
5. **应用场景**：日志、认证、限流、CORS、错误处理

**在 AI Agent 后端中：**
- 中间件是保护 LLM API 的第一道防线
- 通过认证、限流、日志等中间件，防止 API 被滥用
- 让业务代码专注于 AI 逻辑，不用关心基础设施

---

**记住：** 中间件不是魔法，它只是一个在请求前后执行的函数。理解了这个本质，就能灵活运用中间件解决各种问题。
