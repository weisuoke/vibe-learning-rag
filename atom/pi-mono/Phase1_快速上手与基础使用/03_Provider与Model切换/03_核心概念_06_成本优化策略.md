# 核心概念 06：成本优化策略

> **通过智能模型选择，降低 80% API 成本**

---

## 成本现状

### 2025-2026 主流模型定价

| 模型 | Input ($/MTok) | Output ($/MTok) | 成本比 |
|------|----------------|-----------------|--------|
| **Claude 3.5 Haiku** | 0.8 | 4.0 | 1x |
| **GPT-4o Mini** | 0.15 | 0.6 | 0.2x |
| **Claude 3.5 Sonnet** | 3.0 | 15.0 | 4x |
| **GPT-4o** | 2.5 | 10.0 | 3x |
| **Claude Opus 4** | 15.0 | 75.0 | 19x |
| **GPT-4 Turbo** | 10.0 | 30.0 | 13x |

**关键发现**：
- Haiku 和 Opus 成本相差 **19 倍**
- 不合理使用 Opus 会导致成本暴增
- 80% 的任务可以用 Haiku 完成

---

## 成本优化原则

### 原则 1：任务分级

**核心思想**：根据任务复杂度选择合适的模型

```typescript
interface TaskComplexity {
  simple: string[];    // 简单任务：格式化、简单查询
  medium: string[];    // 中等任务：代码重构、功能开发
  complex: string[];   // 复杂任务：架构设计、算法优化
}

const modelSelection: TaskComplexity = {
  simple: ['claude-3-5-haiku-20241022', 'gpt-4o-mini'],
  medium: ['claude-3-5-sonnet-20241022', 'gpt-4o'],
  complex: ['claude-opus-4-20250514', 'gpt-4-turbo']
};
```

**任务分类示例**：

| 任务类型 | 推荐模型 | 成本 |
|----------|----------|------|
| 代码格式化 | Haiku | $0.8/MTok |
| 简单 Bug 修复 | Haiku | $0.8/MTok |
| 代码重构 | Sonnet | $3/MTok |
| 功能开发 | Sonnet | $3/MTok |
| 架构设计 | Opus | $15/MTok |
| 算法优化 | Opus | $15/MTok |

### 原则 2：默认便宜，按需升级

**策略**：
1. 默认使用最便宜的模型（Haiku）
2. 遇到复杂问题时升级到 Sonnet
3. 极端情况才使用 Opus

**Scoped Models 配置**：

```json
{
  "scopedModels": [
    "claude-3-5-haiku-20241022",    // 默认
    "claude-3-5-sonnet-20241022",   // 按需
    "claude-opus-4-20250514"        // 极端情况
  ]
}
```

### 原则 3：监控与调整

**使用 /session 命令监控成本**：

```bash
> /session

Session Information:
  Model: claude-3-5-sonnet-20241022
  Tokens Used: 10000 input, 2000 output
  Cost: $0.06
  Duration: 15m
```

**成本警报阈值**：
- 单次对话 > $0.10：检查是否需要降级
- 每日成本 > $5：审查使用模式
- 每月成本 > $100：优化策略

---

## 成本优化策略

### 策略 1：基于任务复杂度

**自动分类器**：

```typescript
function classifyTask(prompt: string): 'simple' | 'medium' | 'complex' {
  // 简单任务特征
  const simpleKeywords = ['format', 'fix typo', 'add comment', 'rename'];
  if (simpleKeywords.some(k => prompt.toLowerCase().includes(k))) {
    return 'simple';
  }

  // 复杂任务特征
  const complexKeywords = ['architecture', 'design system', 'optimize algorithm'];
  if (complexKeywords.some(k => prompt.toLowerCase().includes(k))) {
    return 'complex';
  }

  // 默认中等
  return 'medium';
}

function selectModel(complexity: string): string {
  const models = {
    simple: 'claude-3-5-haiku-20241022',
    medium: 'claude-3-5-sonnet-20241022',
    complex: 'claude-opus-4-20250514'
  };
  return models[complexity];
}
```

### 策略 2：Fallback 链

**目标**：主模型失败时自动降级，避免浪费

```typescript
interface FallbackChain {
  primary: string;
  fallbacks: string[];
}

const costAwareFallback: FallbackChain = {
  primary: 'claude-3-5-sonnet-20241022',
  fallbacks: [
    'claude-3-5-haiku-20241022',  // 降级到便宜模型
    'gpt-4o-mini',                // 进一步降级
    'llama3.1:8b'                 // 本地模型（免费）
  ]
};

async function executeWithFallback(prompt: string): Promise<string> {
  const models = [costAwareFallback.primary, ...costAwareFallback.fallbacks];

  for (const model of models) {
    try {
      return await callModel(model, prompt);
    } catch (error) {
      console.log(`${model} failed, trying cheaper alternative...`);
    }
  }

  throw new Error('All models failed');
}
```

### 策略 3：批量处理

**场景**：处理多个相似任务

```typescript
// ❌ 低效：每个任务单独调用
for (const file of files) {
  await formatCode(file, 'claude-3-5-sonnet-20241022');
}
// 成本：100 文件 × $0.06 = $6

// ✅ 高效：批量处理
await formatCodeBatch(files, 'claude-3-5-haiku-20241022');
// 成本：100 文件 × $0.01 = $1
```

### 策略 4：本地模型混合

**策略**：开发阶段用本地模型，生产阶段用云端模型

```typescript
const environment = process.env.NODE_ENV;

const modelConfig = {
  development: {
    provider: 'ollama',
    model: 'llama3.1:8b',
    cost: 0  // 免费
  },
  production: {
    provider: 'anthropic',
    model: 'claude-3-5-sonnet-20241022',
    cost: 3  // $/MTok
  }
};

const selectedModel = modelConfig[environment];
```

---

## 成本计算

### 成本公式

```typescript
function calculateCost(
  inputTokens: number,
  outputTokens: number,
  model: Model
): number {
  const inputCost = (inputTokens / 1_000_000) * model.cost.input;
  const outputCost = (outputTokens / 1_000_000) * model.cost.output;
  return inputCost + outputCost;
}
```

### 实际案例

**案例 1：代码审查**

```typescript
// 输入：10K tokens（代码）
// 输出：2K tokens（审查意见）

// 使用 Haiku
const haikuCost = calculateCost(10000, 2000, {
  cost: { input: 0.8, output: 4.0 }
});
// = (10000/1000000)*0.8 + (2000/1000000)*4.0
// = 0.008 + 0.008 = $0.016

// 使用 Sonnet
const sonnetCost = calculateCost(10000, 2000, {
  cost: { input: 3.0, output: 15.0 }
});
// = (10000/1000000)*3.0 + (2000/1000000)*15.0
// = 0.03 + 0.03 = $0.06

// 节省：$0.06 - $0.016 = $0.044 (73%)
```

**案例 2：每日开发**

```typescript
// 假设每天 100 次交互
// 平均每次：5K input + 1K output

// 全部使用 Sonnet
const dailySonnet = 100 * calculateCost(5000, 1000, {
  cost: { input: 3.0, output: 15.0 }
});
// = 100 * (0.015 + 0.015) = $3.00/天

// 80% 使用 Haiku，20% 使用 Sonnet
const dailyMixed =
  80 * calculateCost(5000, 1000, { cost: { input: 0.8, output: 4.0 } }) +
  20 * calculateCost(5000, 1000, { cost: { input: 3.0, output: 15.0 } });
// = 80 * 0.008 + 20 * 0.03
// = 0.64 + 0.60 = $1.24/天

// 节省：$3.00 - $1.24 = $1.76/天 (59%)
// 月度节省：$1.76 × 30 = $52.80
```

---

## 成本监控

### 实时监控

**使用 /session 命令**：

```bash
> /session

Session Information:
  Model: claude-3-5-sonnet-20241022
  Tokens Used: 10000 input, 2000 output
  Cost: $0.06
  Duration: 15m 32s
```

### 成本跟踪脚本

```typescript
// cost-tracker.ts
interface UsageLog {
  timestamp: Date;
  model: string;
  inputTokens: number;
  outputTokens: number;
  cost: number;
}

class CostTracker {
  private logs: UsageLog[] = [];

  log(model: string, inputTokens: number, outputTokens: number) {
    const cost = calculateCost(inputTokens, outputTokens, models[model]);
    this.logs.push({
      timestamp: new Date(),
      model,
      inputTokens,
      outputTokens,
      cost
    });
  }

  getDailyCost(): number {
    const today = new Date().toDateString();
    return this.logs
      .filter(log => log.timestamp.toDateString() === today)
      .reduce((sum, log) => sum + log.cost, 0);
  }

  getMonthlyCost(): number {
    const thisMonth = new Date().getMonth();
    return this.logs
      .filter(log => log.timestamp.getMonth() === thisMonth)
      .reduce((sum, log) => sum + log.cost, 0);
  }

  getModelBreakdown(): Record<string, number> {
    const breakdown: Record<string, number> = {};
    for (const log of this.logs) {
      breakdown[log.model] = (breakdown[log.model] || 0) + log.cost;
    }
    return breakdown;
  }
}
```

---

## 最佳实践

### 1. Scoped Models 按成本排序

```json
{
  "scopedModels": [
    "claude-3-5-haiku-20241022",    // $0.8/MTok - 默认
    "claude-3-5-sonnet-20241022",   // $3/MTok - 按需
    "claude-opus-4-20250514"        // $15/MTok - 极端情况
  ]
}
```

### 2. 设置成本预算

```typescript
const monthlyBudget = 100; // $100/月

function checkBudget(currentCost: number): boolean {
  if (currentCost > monthlyBudget * 0.8) {
    console.warn('⚠️ 已使用 80% 预算，建议降级模型');
    return false;
  }
  return true;
}
```

### 3. 定期审查

```bash
# 每周审查成本
> /session

# 检查模型使用分布
# 目标：80% Haiku, 15% Sonnet, 5% Opus
```

---

## 常见误区

### 误区 1："总是用最好的模型"

**错误**：所有任务都用 Opus

```typescript
// ❌ 浪费成本
const result = await callModel('claude-opus-4-20250514', 'Format this JSON');
// 成本：$0.15
```

**正确**：根据任务选择

```typescript
// ✅ 成本优化
const result = await callModel('claude-3-5-haiku-20241022', 'Format this JSON');
// 成本：$0.008
```

### 误区 2："成本优化会降低质量"

**事实**：80% 的任务用 Haiku 质量足够

```typescript
// 简单任务：Haiku 和 Opus 质量相同
const task = 'Add type annotations to this function';
// Haiku: ✅ 正确
// Opus: ✅ 正确（但贵 19 倍）
```

### 误区 3："不监控成本"

**后果**：月底账单惊人

```typescript
// 每天 200 次 Opus 调用
// 成本：200 × $0.15 = $30/天
// 月度：$30 × 30 = $900

// 优化后：80% Haiku + 20% Sonnet
// 成本：160 × $0.008 + 40 × $0.06 = $3.68/天
// 月度：$3.68 × 30 = $110.40
// 节省：$789.60 (88%)
```

---

## 下一步

- **第一性原理**：阅读 [02_第一性原理.md](./02_第一性原理.md)
- **实战优化**：阅读 [07_实战代码_04_成本优化实战.md](./07_实战代码_04_成本优化实战.md)

---

**记住**：成本优化不是降低质量，而是为每个任务选择合适的工具。
