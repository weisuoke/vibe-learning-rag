# Session 管理与分支 - 核心概念 02：分支导航与 tree 命令

> 掌握 /tree 命令的使用，实现会话树的可视化导航和时间旅行

---

## 概述

`/tree` 命令是 Pi Session 管理的核心功能，提供：
- 树形结构可视化
- 历史节点导航
- 分支关系查看
- 快速搜索定位

---

## 1. /tree 命令基础

### 1.1 启动 tree 视图

```bash
# 在 pi 交互界面中
/tree
```

**显示效果：**
```
Session: feature-development (15 entries)

├─ 1: User: 帮我实现用户登录功能
│  └─ 2: Assistant: 好的，我来实现...
│     ├─ 3: User: 使用 JWT 认证
│     │  └─ 4: Assistant: 实现 JWT 认证...
│     │     └─ 5: User: 测试通过 ✓
│     └─ 6: User: 改用 Session 认证 (分支)
│        └─ 7: Assistant: 实现 Session 认证...
│           └─ 8: User: 这个方案更好 ✓
```

### 1.2 导航操作

| 操作 | 快捷键 | 说明 |
|------|--------|------|
| 上下移动 | ↑/↓ | 在树中移动光标 |
| 展开分支 | → | 展开当前节点的子节点 |
| 折叠分支 | ← | 折叠当前节点 |
| 跳转节点 | Enter | 跳转到选中的节点 |
| 搜索 | Ctrl+O | 搜索节点内容 |
| 退出 | Esc | 退出树形视图 |

---

## 2. 树形结构可视化

### 2.1 节点表示

**节点格式：**
```
├─ {id}: {type}: {content_preview}
```

**示例：**
```
├─ 1: User: 帮我实现用户登录功能
├─ 2: Assistant: 好的，我来实现...
├─ 3: [tool_call] write: auth.ts
└─ 4: [tool_result] File created
```

### 2.2 分支标记

**分支节点：**
```
├─ 1: User: 实现功能 A
│  ├─ 2: Assistant: 方案 A (主分支)
│  └─ 3: Assistant: 方案 B (分支) ⚡
```

**标记说明：**
- `⚡` - 分支节点
- `✓` - 已完成
- `⚠` - 有警告
- `✗` - 有错误

### 2.3 TypeScript 实现

```typescript
interface TreeNode {
  id: string;
  parentId?: string;
  type: string;
  content: string;
  children: TreeNode[];
  metadata?: {
    isBranch?: boolean;
    isCompleted?: boolean;
    hasWarning?: boolean;
    hasError?: boolean;
  };
}

class TreeRenderer {
  render(nodes: TreeNode[], indent = '', isLast = true): string {
    let output = '';

    nodes.forEach((node, index) => {
      const isLastChild = index === nodes.length - 1;
      const connector = isLastChild ? '└─' : '├─';
      const childIndent = indent + (isLastChild ? '   ' : '│  ');

      // 渲染节点
      output += `${indent}${connector} ${node.id}: ${this.formatNode(node)}\n`;

      // 递归渲染子节点
      if (node.children.length > 0) {
        output += this.render(node.children, childIndent, isLastChild);
      }
    });

    return output;
  }

  private formatNode(node: TreeNode): string {
    let text = `${node.type}: ${node.content.substring(0, 50)}`;

    // 添加标记
    if (node.metadata?.isBranch) text += ' ⚡';
    if (node.metadata?.isCompleted) text += ' ✓';
    if (node.metadata?.hasWarning) text += ' ⚠';
    if (node.metadata?.hasError) text += ' ✗';

    return text;
  }
}
```

---

## 3. 搜索与过滤

### 3.1 内容搜索

**使用 Ctrl+O 搜索：**
```
Search: JWT
```

**搜索结果：**
```
Found 3 matches:

├─ 3: User: 使用 JWT 认证
├─ 4: Assistant: 实现 JWT 认证...
└─ 12: User: JWT token 过期时间设置
```

### 3.2 TypeScript 实现

```typescript
class TreeSearch {
  search(nodes: TreeNode[], keyword: string): TreeNode[] {
    const results: TreeNode[] = [];

    const searchRecursive = (node: TreeNode) => {
      // 搜索内容
      if (node.content.toLowerCase().includes(keyword.toLowerCase())) {
        results.push(node);
      }

      // 递归搜索子节点
      node.children.forEach(searchRecursive);
    };

    nodes.forEach(searchRecursive);
    return results;
  }

  // 高亮搜索结果
  highlight(text: string, keyword: string): string {
    const regex = new RegExp(`(${keyword})`, 'gi');
    return text.replace(regex, '\x1b[33m$1\x1b[0m'); // 黄色高亮
  }
}
```

---

## 4. 时间旅行

### 4.1 跳转到历史节点

**操作流程：**
```bash
# 1. 打开 tree 视图
/tree

# 2. 导航到目标节点
# 使用 ↑/↓ 移动到节点 4

# 3. 按 Enter 跳转
# 现在会话状态回到节点 4
```

### 4.2 上下文重建

**跳转后的上下文：**
```typescript
class SessionNavigator {
  async navigateTo(sessionId: string, targetNodeId: string) {
    // 1. 读取完整历史
    const entries = await this.storage.readAll();

    // 2. 获取到目标节点的路径
    const path = this.getPathToNode(entries, targetNodeId);

    // 3. 重建上下文
    const context = path.map(entry => ({
      role: entry.role,
      content: entry.content
    }));

    // 4. 更新当前节点
    this.currentNodeId = targetNodeId;

    return context;
  }

  private getPathToNode(entries: SessionEntry[], targetId: string): SessionEntry[] {
    const nodeMap = new Map(entries.map(e => [e.id, e]));
    const path: SessionEntry[] = [];

    let currentId: string | undefined = targetId;
    while (currentId) {
      const node = nodeMap.get(currentId);
      if (!node) break;

      path.unshift(node);
      currentId = node.parentId;
    }

    return path;
  }
}
```

---

## 5. Label 书签功能

### 5.1 添加 Label

```bash
# 在 tree 视图中，选中节点后
# 按 'l' 键添加 label
Label: checkpoint-v1
```

**效果：**
```
├─ 5: User: 测试通过 ✓ [checkpoint-v1]
```

### 5.2 TypeScript 实现

```typescript
class LabelManager {
  private labels = new Map<string, string>(); // nodeId -> label

  addLabel(nodeId: string, label: string) {
    this.labels.set(nodeId, label);

    // 保存到 session
    this.storage.append({
      type: 'label',
      nodeId,
      label,
      timestamp: Date.now()
    });
  }

  getLabel(nodeId: string): string | undefined {
    return this.labels.get(nodeId);
  }

  // 通过 label 查找节点
  findByLabel(label: string): string | undefined {
    for (const [nodeId, nodeLabel] of this.labels) {
      if (nodeLabel === label) return nodeId;
    }
    return undefined;
  }
}
```

---

## 6. 实际应用场景

### 场景 1：对比不同方案

```bash
# 1. 实现了两个方案
User: 实现功能 A
Assistant: 方案 A 完成
/fork
User: 改用方案 B
Assistant: 方案 B 完成

# 2. 使用 tree 对比
/tree
# 导航到方案 A 节点，查看实现
# 导航到方案 B 节点，查看实现
# 对比两个方案的差异
```

### 场景 2：回溯决策过程

```bash
# 1. 一周后，想回顾为什么选择了方案 B
/tree

# 2. 搜索相关讨论
Ctrl+O
Search: 为什么选择

# 3. 查看完整的决策过程
# 导航到相关节点，查看讨论
```

### 场景 3：保存检查点

```bash
# 1. 功能完成后，添加 label
/tree
# 选中完成节点
l
Label: feature-a-complete

# 2. 继续开发功能 B
User: 开发功能 B

# 3. 如果出问题，回到检查点
/tree
# 搜索 label: feature-a-complete
# 跳转回检查点
```

---

## 7. 高级技巧

### 7.1 快速导航

```typescript
class QuickNavigation {
  // 跳转到父节点
  async goToParent() {
    const currentNode = await this.getCurrentNode();
    if (currentNode.parentId) {
      await this.navigateTo(currentNode.parentId);
    }
  }

  // 跳转到根节点
  async goToRoot() {
    const entries = await this.storage.readAll();
    const roots = entries.filter(e => !e.parentId);
    if (roots.length > 0) {
      await this.navigateTo(roots[0].id);
    }
  }

  // 跳转到最新节点
  async goToLatest() {
    const entries = await this.storage.readAll();
    if (entries.length > 0) {
      await this.navigateTo(entries[entries.length - 1].id);
    }
  }
}
```

### 7.2 批量操作

```typescript
class BatchOperations {
  // 导出分支
  async exportBranch(nodeId: string, outputFile: string) {
    const entries = await this.storage.readAll();
    const branchEntries = this.getBranchEntries(entries, nodeId);

    await fs.writeFile(
      outputFile,
      JSON.stringify(branchEntries, null, 2)
    );
  }

  // 删除分支
  async deleteBranch(nodeId: string) {
    // 注意：JSONL 是追加日志，不能真正删除
    // 只能标记为删除
    await this.storage.append({
      type: 'branch_deleted',
      nodeId,
      timestamp: Date.now()
    });
  }

  private getBranchEntries(entries: SessionEntry[], startNodeId: string): SessionEntry[] {
    const result: SessionEntry[] = [];
    const nodeMap = new Map(entries.map(e => [e.id, e]));

    const collectRecursive = (nodeId: string) => {
      const node = nodeMap.get(nodeId);
      if (!node) return;

      result.push(node);

      // 收集所有子节点
      entries.forEach(e => {
        if (e.parentId === nodeId) {
          collectRecursive(e.id);
        }
      });
    };

    collectRecursive(startNodeId);
    return result;
  }
}
```

---

## 8. 性能优化

### 8.1 懒加载

```typescript
class LazyTreeRenderer {
  private expandedNodes = new Set<string>();

  render(nodes: TreeNode[]): string {
    return this.renderNodes(nodes, '', true);
  }

  private renderNodes(nodes: TreeNode[], indent: string, isLast: boolean): string {
    let output = '';

    nodes.forEach((node, index) => {
      const isLastChild = index === nodes.length - 1;
      const connector = isLastChild ? '└─' : '├─';
      const childIndent = indent + (isLastChild ? '   ' : '│  ');

      // 渲染节点
      output += `${indent}${connector} ${node.id}: ${node.content}\n`;

      // 只渲染展开的节点
      if (this.expandedNodes.has(node.id) && node.children.length > 0) {
        output += this.renderNodes(node.children, childIndent, isLastChild);
      } else if (node.children.length > 0) {
        output += `${childIndent}[${node.children.length} children collapsed]\n`;
      }
    });

    return output;
  }

  expand(nodeId: string) {
    this.expandedNodes.add(nodeId);
  }

  collapse(nodeId: string) {
    this.expandedNodes.delete(nodeId);
  }
}
```

### 8.2 虚拟滚动

```typescript
class VirtualScrollTree {
  private viewportHeight = 20; // 显示20行
  private scrollOffset = 0;

  render(nodes: TreeNode[]): string {
    const flatNodes = this.flattenTree(nodes);

    // 只渲染可见区域
    const visibleNodes = flatNodes.slice(
      this.scrollOffset,
      this.scrollOffset + this.viewportHeight
    );

    return visibleNodes.map(n => this.renderNode(n)).join('\n');
  }

  scrollDown() {
    this.scrollOffset++;
  }

  scrollUp() {
    this.scrollOffset = Math.max(0, this.scrollOffset - 1);
  }

  private flattenTree(nodes: TreeNode[]): TreeNode[] {
    const result: TreeNode[] = [];

    const flatten = (node: TreeNode) => {
      result.push(node);
      node.children.forEach(flatten);
    };

    nodes.forEach(flatten);
    return result;
  }

  private renderNode(node: TreeNode): string {
    return `${node.id}: ${node.content}`;
  }
}
```

---

## 学习检查清单

完成本节学习后，你应该能够：

- [ ] 使用 /tree 命令打开树形视图
- [ ] 使用快捷键导航树形结构
- [ ] 使用搜索功能快速定位节点
- [ ] 跳转到历史节点实现时间旅行
- [ ] 使用 Label 功能添加书签
- [ ] 理解树形结构的可视化原理
- [ ] 实现自定义的树形渲染器

---

**版本：** v1.0
**最后更新：** 2026-02-18
**维护者：** Claude Code
