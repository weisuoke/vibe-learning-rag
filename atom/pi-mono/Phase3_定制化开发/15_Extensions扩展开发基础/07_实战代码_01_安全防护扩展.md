# Extensions 扩展开发基础 - 实战代码 01：安全防护扩展

> 通过 permission-gate 模式实现危险命令拦截和用户确认机制

---

## 1. 场景介绍

### 1.1 为什么需要安全防护扩展？

在 AI Agent 开发中，Agent 可能会执行各种 bash 命令来完成任务。但某些命令具有破坏性，如：

```bash
rm -rf /                    # 删除整个文件系统
sudo rm -rf /var/log/*      # 删除系统日志
chmod 777 /etc/passwd       # 修改敏感文件权限
dd if=/dev/zero of=/dev/sda # 清空硬盘
```

**问题：**
- Agent 可能误判需求，执行危险命令
- 用户可能没有意识到命令的危险性
- 一旦执行，可能造成不可逆的损失

**解决方案：**
- 在命令执行前拦截（`tool_call` 事件）
- 检测危险模式（正则匹配）
- 弹出确认对话框（UI 交互）
- 用户拒绝则阻止执行（返回 `{ block: true }`）

### 1.2 实际应用场景

**场景 1：代码清理任务**
```
用户："清理项目中的临时文件"
Agent：执行 `rm -rf node_modules .next .cache`
风险：可能误删重要文件
```

**场景 2：权限修复任务**
```
用户："修复文件权限问题"
Agent：执行 `sudo chmod -R 777 /var/www`
风险：严重的安全漏洞
```

**场景 3：系统维护任务**
```
用户："清理日志文件"
Agent：执行 `sudo rm -rf /var/log/*`
风险：丢失重要日志
```

### 1.3 技术要点

- **事件监听**：`tool_call` 事件在工具执行前触发
- **模式匹配**：使用正则表达式检测危险命令
- **阻止机制**：返回 `{ block: true, reason: string }` 阻止执行
- **UI 交互**：`ctx.ui.select()` 弹出选择对话框
- **非交互模式**：`ctx.hasUI` 检测是否有 UI 可用

---

## 2. 完整实现

### 2.1 基础版本：permission-gate.ts

```typescript
/**
 * Permission Gate Extension
 *
 * 在执行危险 bash 命令前弹出确认对话框
 * 支持交互模式和非交互模式
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  // 定义危险命令模式
  const dangerousPatterns = [
    /\brm\s+(-rf?|--recursive)/i,      // rm -rf, rm -r
    /\bsudo\b/i,                        // sudo 命令
    /\b(chmod|chown)\b.*777/i,          // chmod/chown 777
  ];

  // 监听 tool_call 事件
  pi.on("tool_call", async (event, ctx) => {
    // 只处理 bash 工具
    if (event.toolName !== "bash") return undefined;

    // 获取命令内容
    const command = event.input.command as string;

    // 检测是否匹配危险模式
    const isDangerous = dangerousPatterns.some((pattern) =>
      pattern.test(command)
    );

    if (isDangerous) {
      // 非交互模式：直接阻止
      if (!ctx.hasUI) {
        return {
          block: true,
          reason: "Dangerous command blocked (no UI for confirmation)"
        };
      }

      // 交互模式：弹出确认对话框
      const choice = await ctx.ui.select(
        `⚠️ Dangerous command:\n\n  ${command}\n\nAllow?`,
        ["Yes", "No"]
      );

      // 用户拒绝：阻止执行
      if (choice !== "Yes") {
        return {
          block: true,
          reason: "Blocked by user"
        };
      }
    }

    // 允许执行
    return undefined;
  });
}
```

### 2.2 增强版本：带详细信息的确认对话框

```typescript
/**
 * Enhanced Permission Gate Extension
 *
 * 提供更详细的危险命令信息和风险等级
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

// 危险命令配置
interface DangerousCommand {
  pattern: RegExp;
  level: "high" | "medium" | "low";
  description: string;
  suggestion?: string;
}

export default function (pi: ExtensionAPI) {
  const dangerousCommands: DangerousCommand[] = [
    {
      pattern: /\brm\s+(-rf?|--recursive)/i,
      level: "high",
      description: "递归删除文件/目录",
      suggestion: "建议先用 ls 确认要删除的内容"
    },
    {
      pattern: /\bsudo\b/i,
      level: "high",
      description: "以超级用户权限执行命令",
      suggestion: "确认命令的必要性和安全性"
    },
    {
      pattern: /\b(chmod|chown)\b.*777/i,
      level: "high",
      description: "设置文件权限为 777（所有人可读写执行）",
      suggestion: "使用更安全的权限设置（如 755 或 644）"
    },
    {
      pattern: /\bdd\b.*of=/i,
      level: "high",
      description: "直接写入设备或文件",
      suggestion: "确认目标路径，避免覆盖重要数据"
    },
    {
      pattern: /\bmkfs\b/i,
      level: "high",
      description: "格式化文件系统",
      suggestion: "确认设备路径，避免误格式化"
    },
    {
      pattern: />\s*\/dev\/(sda|sdb|nvme)/i,
      level: "high",
      description: "重定向输出到磁盘设备",
      suggestion: "确认设备路径，避免破坏数据"
    }
  ];

  pi.on("tool_call", async (event, ctx) => {
    if (event.toolName !== "bash") return undefined;

    const command = event.input.command as string;

    // 查找匹配的危险命令
    const matched = dangerousCommands.find((cmd) =>
      cmd.pattern.test(command)
    );

    if (matched) {
      // 非交互模式：直接阻止
      if (!ctx.hasUI) {
        return {
          block: true,
          reason: `Dangerous command blocked: ${matched.description}`
        };
      }

      // 构建详细的确认消息
      const levelEmoji = {
        high: "🔴",
        medium: "🟡",
        low: "🟢"
      };

      const message = [
        `${levelEmoji[matched.level]} 危险命令检测`,
        ``,
        `命令: ${command}`,
        ``,
        `风险: ${matched.description}`,
        matched.suggestion ? `建议: ${matched.suggestion}` : "",
        ``,
        `是否允许执行？`
      ].filter(Boolean).join("\n");

      // 弹出确认对话框
      const choice = await ctx.ui.select(message, [
        "Yes, execute",
        "No, block",
        "Show details"
      ]);

      if (choice === "Show details") {
        // 显示命令详情
        await ctx.ui.notify(
          `命令详情:\n\n${command}\n\n` +
          `风险等级: ${matched.level}\n` +
          `描述: ${matched.description}\n` +
          (matched.suggestion ? `建议: ${matched.suggestion}` : "")
        );

        // 再次确认
        const finalChoice = await ctx.ui.select(
          "是否允许执行？",
          ["Yes", "No"]
        );

        if (finalChoice !== "Yes") {
          return { block: true, reason: "Blocked by user after review" };
        }
      } else if (choice !== "Yes, execute") {
        return { block: true, reason: "Blocked by user" };
      }
    }

    return undefined;
  });
}
```

---

## 3. 代码解析

### 3.1 事件监听机制

```typescript
pi.on("tool_call", async (event, ctx) => {
  // event: 工具调用事件
  // ctx: 扩展上下文
});
```

**`tool_call` 事件的触发时机：**
```
Agent 决定调用工具
  ↓
触发 tool_call 事件
  ↓
Extension 处理（可以阻止）
  ↓
执行工具（如果未被阻止）
  ↓
触发 tool_result 事件
```

**事件对象结构：**
```typescript
interface ToolCallEvent {
  toolName: string;           // 工具名称（如 "bash"）
  input: Record<string, any>; // 工具输入参数
  // 对于 bash 工具：
  // input.command: string    // 要执行的命令
  // input.timeout?: number   // 超时时间
}
```

### 3.2 阻止机制

```typescript
// 返回 undefined：允许执行
return undefined;

// 返回 { block: true }：阻止执行
return {
  block: true,
  reason: "原因说明"
};
```

**阻止后的效果：**
- 工具不会被执行
- Agent 会收到阻止消息
- Agent 可能会尝试其他方法或询问用户

### 3.3 UI 交互

```typescript
// 检查是否有 UI 可用
if (!ctx.hasUI) {
  // 非交互模式（如 API 调用、后台任务）
  return { block: true, reason: "No UI available" };
}

// 弹出选择对话框
const choice = await ctx.ui.select(
  "提示消息",
  ["选项1", "选项2", "选项3"]
);

// 弹出通知
await ctx.ui.notify("通知消息");

// 弹出输入框
const input = await ctx.ui.input("请输入：", "默认值");

// 弹出确认对话框
const confirmed = await ctx.ui.confirm("确认操作？");
```

### 3.4 正则表达式匹配

```typescript
// 定义危险模式
const dangerousPatterns = [
  /\brm\s+(-rf?|--recursive)/i,  // \b: 单词边界
                                  // \s+: 一个或多个空格
                                  // (-rf?|--recursive): 匹配 -r, -rf, --recursive
                                  // i: 不区分大小写

  /\bsudo\b/i,                    // 匹配独立的 sudo 单词

  /\b(chmod|chown)\b.*777/i,      // .*: 任意字符
                                  // 匹配 chmod ... 777 或 chown ... 777
];

// 检测命令
const isDangerous = dangerousPatterns.some((pattern) =>
  pattern.test(command)
);
```

**匹配示例：**
```typescript
// 匹配
"rm -rf /tmp"           // ✓ 匹配 rm -rf
"sudo apt install"      // ✓ 匹配 sudo
"chmod 777 file.txt"    // ✓ 匹配 chmod ... 777

// 不匹配
"rm file.txt"           // ✗ 没有 -rf
"pseudo code"           // ✗ sudo 不是独立单词
"chmod 755 file.txt"    // ✗ 不是 777
```

---

## 4. 变体与扩展

### 4.1 路径保护模式

保护特定路径不被删除或修改：

```typescript
export default function (pi: ExtensionAPI) {
  const protectedPaths = [
    "/",
    "/etc",
    "/var",
    "/usr",
    "/home",
    process.env.HOME,  // 用户主目录
  ];

  pi.on("tool_call", async (event, ctx) => {
    if (event.toolName !== "bash") return undefined;

    const command = event.input.command as string;

    // 检测是否操作受保护路径
    const affectsProtectedPath = protectedPaths.some((path) => {
      const regex = new RegExp(`\\b(rm|chmod|chown|mv)\\b.*${path}`, "i");
      return regex.test(command);
    });

    if (affectsProtectedPath) {
      if (!ctx.hasUI) {
        return { block: true, reason: "Protected path access blocked" };
      }

      const choice = await ctx.ui.select(
        `⚠️ 命令将操作受保护路径:\n\n  ${command}\n\n允许？`,
        ["Yes", "No"]
      );

      if (choice !== "Yes") {
        return { block: true, reason: "Protected path access denied" };
      }
    }

    return undefined;
  });
}
```

### 4.2 白名单模式

只允许执行白名单中的命令：

```typescript
export default function (pi: ExtensionAPI) {
  const allowedCommands = [
    "ls", "cat", "grep", "find", "echo",
    "git", "npm", "node", "python", "pip"
  ];

  pi.on("tool_call", async (event, ctx) => {
    if (event.toolName !== "bash") return undefined;

    const command = event.input.command as string;
    const firstWord = command.trim().split(/\s+/)[0];

    // 检查是否在白名单中
    const isAllowed = allowedCommands.some((cmd) =>
      firstWord === cmd || firstWord.endsWith(`/${cmd}`)
    );

    if (!isAllowed) {
      if (!ctx.hasUI) {
        return {
          block: true,
          reason: `Command not in whitelist: ${firstWord}`
        };
      }

      const choice = await ctx.ui.select(
        `⚠️ 命令不在白名单中:\n\n  ${command}\n\n允许？`,
        ["Yes", "No", "Add to whitelist"]
      );

      if (choice === "Add to whitelist") {
        allowedCommands.push(firstWord);
        await ctx.ui.notify(`已添加 ${firstWord} 到白名单`);
      } else if (choice !== "Yes") {
        return { block: true, reason: "Command not whitelisted" };
      }
    }

    return undefined;
  });
}
```

### 4.3 审计日志模式

记录所有危险命令的执行：

```typescript
import * as fs from "fs";
import * as path from "path";

export default function (pi: ExtensionAPI) {
  const logFile = path.join(process.env.HOME!, ".pi-audit.log");

  const dangerousPatterns = [
    /\brm\s+(-rf?|--recursive)/i,
    /\bsudo\b/i,
    /\b(chmod|chown)\b.*777/i,
  ];

  pi.on("tool_call", async (event, ctx) => {
    if (event.toolName !== "bash") return undefined;

    const command = event.input.command as string;
    const isDangerous = dangerousPatterns.some((p) => p.test(command));

    if (isDangerous) {
      // 记录到审计日志
      const logEntry = {
        timestamp: new Date().toISOString(),
        command,
        session: ctx.session.id,
        allowed: false,
      };

      if (!ctx.hasUI) {
        fs.appendFileSync(logFile, JSON.stringify(logEntry) + "\n");
        return { block: true, reason: "Dangerous command blocked" };
      }

      const choice = await ctx.ui.select(
        `⚠️ Dangerous command:\n\n  ${command}\n\nAllow?`,
        ["Yes", "No"]
      );

      logEntry.allowed = choice === "Yes";
      fs.appendFileSync(logFile, JSON.stringify(logEntry) + "\n");

      if (choice !== "Yes") {
        return { block: true, reason: "Blocked by user" };
      }
    }

    return undefined;
  });
}
```

---

## 5. 错误处理

### 5.1 UI 交互失败

```typescript
pi.on("tool_call", async (event, ctx) => {
  if (event.toolName !== "bash") return undefined;

  const command = event.input.command as string;
  const isDangerous = dangerousPatterns.some((p) => p.test(command));

  if (isDangerous) {
    try {
      if (!ctx.hasUI) {
        return { block: true, reason: "No UI available" };
      }

      const choice = await ctx.ui.select(
        `⚠️ Dangerous command:\n\n  ${command}\n\nAllow?`,
        ["Yes", "No"]
      );

      if (choice !== "Yes") {
        return { block: true, reason: "Blocked by user" };
      }
    } catch (error) {
      // UI 交互失败（如用户取消、超时）
      console.error("UI interaction failed:", error);
      return {
        block: true,
        reason: "UI interaction failed, blocking for safety"
      };
    }
  }

  return undefined;
});
```

### 5.2 正则表达式错误

```typescript
function createSafePattern(pattern: string): RegExp | null {
  try {
    return new RegExp(pattern, "i");
  } catch (error) {
    console.error(`Invalid regex pattern: ${pattern}`, error);
    return null;
  }
}

const dangerousPatterns = [
  createSafePattern("\\brm\\s+(-rf?|--recursive)"),
  createSafePattern("\\bsudo\\b"),
  createSafePattern("\\b(chmod|chown)\\b.*777"),
].filter((p): p is RegExp => p !== null);
```

### 5.3 日志写入失败

```typescript
function safeAppendLog(logFile: string, entry: any): void {
  try {
    fs.appendFileSync(logFile, JSON.stringify(entry) + "\n");
  } catch (error) {
    console.error("Failed to write audit log:", error);
    // 不阻止命令执行，只记录错误
  }
}
```

---

## 6. 最佳实践

### 6.1 性能优化

```typescript
// ✓ 好：提前编译正则表达式
const dangerousPatterns = [
  /\brm\s+(-rf?|--recursive)/i,
  /\bsudo\b/i,
];

pi.on("tool_call", async (event, ctx) => {
  const isDangerous = dangerousPatterns.some((p) => p.test(command));
});

// ✗ 差：每次都创建正则表达式
pi.on("tool_call", async (event, ctx) => {
  const isDangerous = [
    /\brm\s+(-rf?|--recursive)/i,
    /\bsudo\b/i,
  ].some((p) => p.test(command));
});
```

### 6.2 用户体验

```typescript
// ✓ 好：提供清晰的信息和建议
const message = [
  `🔴 危险命令检测`,
  ``,
  `命令: ${command}`,
  `风险: ${description}`,
  `建议: ${suggestion}`,
  ``,
  `是否允许执行？`
].join("\n");

// ✗ 差：信息不足
const message = `Dangerous command. Allow?`;
```

### 6.3 安全性

```typescript
// ✓ 好：非交互模式默认阻止
if (!ctx.hasUI) {
  return { block: true, reason: "No UI for confirmation" };
}

// ✗ 差：非交互模式默认允许
if (!ctx.hasUI) {
  return undefined; // 危险！
}
```

### 6.4 可配置性

```typescript
// ✓ 好：从配置文件读取规则
const config = JSON.parse(
  fs.readFileSync(path.join(process.env.HOME!, ".pi-security.json"), "utf-8")
);

const dangerousPatterns = config.patterns.map((p: string) =>
  new RegExp(p, "i")
);

// ✗ 差：硬编码规则
const dangerousPatterns = [
  /\brm\s+(-rf?|--recursive)/i,
  /\bsudo\b/i,
];
```

---

## 7. 总结

### 7.1 核心要点

1. **事件监听**：使用 `tool_call` 事件在工具执行前拦截
2. **模式匹配**：使用正则表达式检测危险命令
3. **阻止机制**：返回 `{ block: true }` 阻止执行
4. **UI 交互**：使用 `ctx.ui.select()` 弹出确认对话框
5. **非交互模式**：检查 `ctx.hasUI`，默认阻止危险命令

### 7.2 扩展方向

- **路径保护**：保护特定路径不被操作
- **白名单模式**：只允许执行白名单中的命令
- **审计日志**：记录所有危险命令的执行
- **风险评分**：根据命令危险程度分级处理
- **智能建议**：提供更安全的替代命令

### 7.3 实际应用

安全防护扩展适用于：
- **生产环境**：防止误操作导致系统故障
- **团队协作**：统一安全策略，降低风险
- **学习环境**：帮助新手理解命令的危险性
- **审计合规**：记录所有危险操作，满足合规要求

---

**下一步：** 学习 [07_实战代码_02_工具增强扩展.md](./07_实战代码_02_工具增强扩展.md)，了解如何注册自定义工具。
