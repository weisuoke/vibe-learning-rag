# 核心概念 01 - LCEL 基础语法

> 掌握 LCEL 的核心语法：管道操作符、Runnable 接口、链式调用

---

## 核心概念1：管道操作符 `|` - 数据流的连接器

### 一句话定义

**管道操作符 `|` 是 LCEL 的核心语法，用于连接多个 Runnable 组件，让数据从左到右依次流动。**

---

### 基础用法

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

# 定义三个组件
prompt = ChatPromptTemplate.from_template("讲一个关于{topic}的笑话")
llm = ChatOpenAI()
parser = StrOutputParser()

# 用 | 连接成链
chain = prompt | llm | parser

# 调用链
result = chain.invoke({"topic": "程序员"})
print(result)
```

**输出示例**：
```
为什么程序员总是分不清万圣节和圣诞节？
因为 Oct 31 == Dec 25
（八进制的31等于十进制的25）
```

---

### 工作原理

**管道操作符的本质是创建 RunnableSequence**：

```python
# 表面语法
chain = prompt | llm | parser

# 等价于
from langchain_core.runnables import RunnableSequence
chain = RunnableSequence([prompt, llm, parser])

# 执行时
result = chain.invoke(input)
# 等价于
step1 = prompt.invoke(input)
step2 = llm.invoke(step1)
step3 = parser.invoke(step2)
```

---

### 手写实现：简化版管道操作符

```python
class SimpleRunnable:
    """简化版 Runnable 接口"""

    def invoke(self, input):
        """子类必须实现"""
        raise NotImplementedError

    def __or__(self, other):
        """实现 | 操作符"""
        return SimpleSequence([self, other])


class SimpleSequence(SimpleRunnable):
    """简化版 RunnableSequence"""

    def __init__(self, steps):
        self.steps = steps

    def invoke(self, input):
        """依次执行每个步骤"""
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result

    def __or__(self, other):
        """支持继续链式调用"""
        return SimpleSequence(self.steps + [other])


# 测试
class AddOne(SimpleRunnable):
    def invoke(self, input):
        return input + 1


class MultiplyTwo(SimpleRunnable):
    def invoke(self, input):
        return input * 2


class ToString(SimpleRunnable):
    def invoke(self, input):
        return f"结果是: {input}"


# 使用管道操作符
chain = AddOne() | MultiplyTwo() | ToString()
result = chain.invoke(5)
print(result)  # "结果是: 12"
```

**解释**：
1. `AddOne() | MultiplyTwo()` → 创建 `SimpleSequence([AddOne(), MultiplyTwo()])`
2. `SimpleSequence(...) | ToString()` → 创建 `SimpleSequence([AddOne(), MultiplyTwo(), ToString()])`
3. `chain.invoke(5)` → 依次执行：5 → 6 → 12 → "结果是: 12"

---

### 在实际应用中

**场景1：简单问答链**

```python
# Prompt → LLM → Parser
chain = (
    ChatPromptTemplate.from_template("回答：{question}")
    | ChatOpenAI()
    | StrOutputParser()
)

answer = chain.invoke({"question": "什么是 LCEL？"})
```

**场景2：多步骤处理链**

```python
# 文本清洗 → Embedding → 向量检索 → 格式化
chain = (
    text_cleaner
    | embedder
    | retriever
    | formatter
)

results = chain.invoke(raw_text)
```

**场景3：FastAPI 集成**

```python
from fastapi import FastAPI

app = FastAPI()

# 定义链
qa_chain = prompt | llm | parser

@app.post("/ask")
async def ask(question: str):
    answer = await qa_chain.ainvoke({"question": question})
    return {"answer": answer}
```

---

## 核心概念2：Runnable 接口 - 统一的组件抽象

### 一句话定义

**Runnable 是 LCEL 的核心接口，所有组件都实现这个接口，提供统一的调用方式（invoke、ainvoke、stream、batch）。**

---

### Runnable 接口的核心方法

```python
from langchain_core.runnables import Runnable

class MyRunnable(Runnable):
    """自定义 Runnable 组件"""

    def invoke(self, input, config=None):
        """同步调用"""
        return self._process(input)

    async def ainvoke(self, input, config=None):
        """异步调用"""
        return self._process(input)

    def stream(self, input, config=None):
        """流式调用（生成器）"""
        result = self._process(input)
        for chunk in result:
            yield chunk

    async def astream(self, input, config=None):
        """异步流式调用"""
        result = self._process(input)
        for chunk in result:
            yield chunk

    def batch(self, inputs, config=None):
        """批量调用"""
        return [self.invoke(input) for input in inputs]

    def _process(self, input):
        """实际处理逻辑"""
        raise NotImplementedError
```

---

### 为什么需要统一接口？

**问题**：如果没有统一接口，每个组件的调用方式都不同：

```python
# ❌ 没有统一接口（混乱）
formatted = prompt.format(input)
response = llm.call(formatted)
result = parser.parse(response)

# ✅ 有统一接口（清晰）
formatted = prompt.invoke(input)
response = llm.invoke(formatted)
result = parser.invoke(response)

# ✅ 更好：用管道连接
chain = prompt | llm | parser
result = chain.invoke(input)
```

---

### 手写实现：完整的 Runnable 接口

```python
import asyncio
from typing import Any, List, Iterator, AsyncIterator


class Runnable:
    """完整的 Runnable 接口实现"""

    def invoke(self, input: Any) -> Any:
        """同步调用"""
        raise NotImplementedError

    async def ainvoke(self, input: Any) -> Any:
        """异步调用（默认实现：在线程池中运行同步方法）"""
        return await asyncio.to_thread(self.invoke, input)

    def stream(self, input: Any) -> Iterator[Any]:
        """流式调用（默认实现：一次性返回）"""
        yield self.invoke(input)

    async def astream(self, input: Any) -> AsyncIterator[Any]:
        """异步流式调用"""
        result = await self.ainvoke(input)
        yield result

    def batch(self, inputs: List[Any]) -> List[Any]:
        """批量调用"""
        return [self.invoke(input) for input in inputs]

    async def abatch(self, inputs: List[Any]) -> List[Any]:
        """异步批量调用"""
        tasks = [self.ainvoke(input) for input in inputs]
        return await asyncio.gather(*tasks)

    def __or__(self, other: "Runnable") -> "Runnable":
        """支持管道操作符"""
        return RunnableSequence([self, other])


class RunnableSequence(Runnable):
    """Runnable 序列"""

    def __init__(self, steps: List[Runnable]):
        self.steps = steps

    def invoke(self, input: Any) -> Any:
        result = input
        for step in self.steps:
            result = step.invoke(result)
        return result

    async def ainvoke(self, input: Any) -> Any:
        result = input
        for step in self.steps:
            result = await step.ainvoke(result)
        return result

    async def astream(self, input: Any) -> AsyncIterator[Any]:
        """流式执行：前面的步骤正常执行，最后一步流式输出"""
        result = input
        for step in self.steps[:-1]:
            result = await step.ainvoke(result)

        # 最后一步流式输出
        async for chunk in self.steps[-1].astream(result):
            yield chunk

    def __or__(self, other: Runnable) -> "Runnable":
        """支持继续链式调用"""
        return RunnableSequence(self.steps + [other])


# 测试
class UpperCase(Runnable):
    def invoke(self, input: str) -> str:
        return input.upper()


class AddPrefix(Runnable):
    def invoke(self, input: str) -> str:
        return f"[处理后] {input}"


# 使用
chain = UpperCase() | AddPrefix()
result = chain.invoke("hello world")
print(result)  # "[处理后] HELLO WORLD"

# 异步调用
async def test_async():
    result = await chain.ainvoke("hello world")
    print(result)

asyncio.run(test_async())
```

---

### 在实际应用中

**场景1：自定义数据处理组件**

```python
from langchain_core.runnables import RunnableLambda

# 方式1：用 RunnableLambda 包装函数
def clean_text(text: str) -> str:
    return text.strip().lower()

cleaner = RunnableLambda(clean_text)

# 方式2：继承 Runnable
class TextCleaner(Runnable):
    def invoke(self, input: str) -> str:
        return input.strip().lower()

cleaner = TextCleaner()

# 使用
chain = cleaner | embedder | retriever
```

**场景2：批量处理**

```python
# 批量调用
questions = [
    "什么是 LCEL？",
    "什么是 Runnable？",
    "什么是管道操作符？"
]

answers = chain.batch([{"question": q} for q in questions])
for q, a in zip(questions, answers):
    print(f"Q: {q}\nA: {a}\n")
```

**场景3：异步批量处理（更快）**

```python
# 异步批量调用（并行执行）
async def batch_qa():
    questions = ["问题1", "问题2", "问题3"]
    answers = await chain.abatch([{"question": q} for q in questions])
    return answers

# 比同步批量快3倍（如果有3个问题）
```

---

## 核心概念3：链式调用 - 组合的艺术

### 一句话定义

**链式调用是通过管道操作符 `|` 将多个 Runnable 组件组合成复杂流程的方式，支持顺序执行、并行执行、条件分支等模式。**

---

### 模式1：顺序执行（Sequential）

**最基础的链式调用，数据依次流过每个组件。**

```python
# 顺序执行
chain = step1 | step2 | step3 | step4

# 等价于
result = step4.invoke(
    step3.invoke(
        step2.invoke(
            step1.invoke(input)
        )
    )
)
```

**实际例子**：

```python
# RAG 流程：问题 → Embedding → 检索 → 格式化 → Prompt → LLM → 解析
chain = (
    embedder           # 问题向量化
    | retriever        # 检索相关文档
    | formatter        # 格式化文档
    | prompt           # 构建 Prompt
    | llm              # LLM 生成
    | parser           # 解析输出
)
```

---

### 模式2：并行执行（Parallel）

**多个任务同时执行，用字典语法 `{}` 自动触发。**

```python
# 并行执行
chain = {
    "task1": runnable1,
    "task2": runnable2,
    "task3": runnable3
}

# 等价于
from langchain_core.runnables import RunnableParallel
chain = RunnableParallel({
    "task1": runnable1,
    "task2": runnable2,
    "task3": runnable3
})
```

**实际例子**：

```python
# 同时执行多个任务
chain = {
    "summary": summarizer,      # 总结文本
    "keywords": extractor,      # 提取关键词
    "sentiment": analyzer       # 情感分析
} | combine_results             # 合并结果

result = chain.invoke(text)
# result = {
#     "summary": "...",
#     "keywords": ["...", "..."],
#     "sentiment": "positive"
# }
```

---

### 模式3：数据传递（Passthrough）

**保留原始输入，同时进行处理。**

```python
from langchain_core.runnables import RunnablePassthrough

# 保留原始输入
chain = {
    "original": RunnablePassthrough(),  # 原样传递
    "processed": processor              # 处理后的数据
} | next_step
```

**实际例子（RAG）**：

```python
# RAG 场景：需要同时使用原始问题和检索结果
chain = {
    "context": vectorstore.as_retriever(),  # 检索文档
    "question": RunnablePassthrough()       # 保留原始问题
} | ChatPromptTemplate.from_template(
    "基于以下上下文回答问题：\n\n{context}\n\n问题：{question}"
) | llm | parser

answer = chain.invoke("什么是向量检索？")
```

---

### 手写实现：RunnableParallel 和 RunnablePassthrough

```python
import asyncio
from typing import Dict, Any


class RunnableParallel(Runnable):
    """并行执行多个 Runnable"""

    def __init__(self, steps: Dict[str, Runnable]):
        self.steps = steps

    def invoke(self, input: Any) -> Dict[str, Any]:
        """同步并行执行（实际上是串行）"""
        return {
            key: runnable.invoke(input)
            for key, runnable in self.steps.items()
        }

    async def ainvoke(self, input: Any) -> Dict[str, Any]:
        """异步并行执行（真正的并行）"""
        tasks = {
            key: runnable.ainvoke(input)
            for key, runnable in self.steps.items()
        }

        # 并行执行所有任务
        results = await asyncio.gather(*tasks.values())

        # 返回字典结果
        return dict(zip(tasks.keys(), results))


class RunnablePassthrough(Runnable):
    """原样传递输入"""

    def invoke(self, input: Any) -> Any:
        return input

    async def ainvoke(self, input: Any) -> Any:
        return input


# 测试
class SlowTask(Runnable):
    def __init__(self, name: str, delay: float):
        self.name = name
        self.delay = delay

    async def ainvoke(self, input: Any) -> str:
        await asyncio.sleep(self.delay)
        return f"{self.name} 完成"


async def test_parallel():
    # 并行执行
    parallel = RunnableParallel({
        "task1": SlowTask("任务1", 2.0),
        "task2": SlowTask("任务2", 2.0),
        "task3": SlowTask("任务3", 2.0)
    })

    import time
    start = time.time()
    result = await parallel.ainvoke("输入")
    print(f"耗时: {time.time() - start:.1f}秒")  # 2秒（并行）
    print(result)

asyncio.run(test_parallel())
```

---

### 在实际应用中

**场景1：复杂的 RAG 流程**

```python
# 完整的 RAG 链
rag_chain = (
    # 步骤1：并行执行检索和问题保留
    {
        "context": vectorstore.as_retriever() | format_docs,
        "question": RunnablePassthrough()
    }
    # 步骤2：构建 Prompt
    | ChatPromptTemplate.from_template(
        "基于以下上下文回答问题：\n\n{context}\n\n问题：{question}"
    )
    # 步骤3：LLM 生成
    | ChatOpenAI()
    # 步骤4：解析输出
    | StrOutputParser()
)

# 使用
answer = rag_chain.invoke("什么是 LCEL？")
```

**场景2：多模型对比**

```python
# 同时调用多个模型，对比结果
multi_model_chain = {
    "gpt35": ChatOpenAI(model="gpt-3.5-turbo"),
    "gpt4": ChatOpenAI(model="gpt-4"),
    "claude": ChatAnthropic(model="claude-3-sonnet")
} | compare_results

results = multi_model_chain.invoke(prompt)
```

**场景3：条件路由（下一个文件详细讲解）**

```python
from langchain_core.runnables import RunnableBranch

# 根据条件选择不同的链
branch = RunnableBranch(
    (lambda x: len(x) < 100, simple_chain),
    (lambda x: len(x) < 500, normal_chain),
    complex_chain
)
```

---

## 核心概念总结

| 概念 | 核心作用 | 关键语法 | 实际应用 |
|------|---------|---------|---------|
| **管道操作符 `\|`** | 连接组件 | `a \| b \| c` | 构建线性流程 |
| **Runnable 接口** | 统一抽象 | `invoke()`, `ainvoke()`, `stream()` | 组件可组合 |
| **链式调用** | 组合模式 | 顺序、并行、传递 | 构建复杂流程 |

---

## 学习检查清单

掌握 LCEL 基础语法后，你应该能够：

- [ ] 理解管道操作符 `|` 的工作原理
- [ ] 知道 `a | b | c` 等价于 `RunnableSequence([a, b, c])`
- [ ] 理解 Runnable 接口的核心方法（invoke、ainvoke、stream、batch）
- [ ] 知道为什么需要统一接口（可组合性）
- [ ] 掌握顺序执行的链式调用
- [ ] 掌握并行执行的字典语法 `{}`
- [ ] 掌握 RunnablePassthrough 的使用场景
- [ ] 能够手写简化版的 Runnable 接口
- [ ] 能够构建简单的问答链
- [ ] 能够构建 RAG 检索链

---

## 下一步

掌握了 LCEL 基础语法后，继续学习：

- **03_核心概念_02_常用组件.md** - PromptTemplate、ChatModel、OutputParser 的详细用法
- **03_核心概念_03_高级特性.md** - 条件分支、错误处理、重试机制

---

**版本**: v1.0
**最后更新**: 2026-02-12
