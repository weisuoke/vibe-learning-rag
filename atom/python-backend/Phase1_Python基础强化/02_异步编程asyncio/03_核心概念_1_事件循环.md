# 核心概念1：事件循环（Event Loop）

> 理解 asyncio 的核心调度机制

---

## 什么是事件循环？

**一句话定义：** 事件循环是 asyncio 的核心调度器，负责管理和执行所有协程任务。

---

## 直觉理解

### 类比：餐厅服务员

想象一个餐厅，只有一个服务员（单线程），但有多个客人（多个任务）：

```
传统同步方式（效率低）：
服务员：接待客人A → 等待厨师做菜 → 送菜 → 接待客人B → 等待厨师做菜 → 送菜
问题：在等待厨师做菜时，服务员什么都不做

事件循环方式（效率高）：
服务员：
1. 接待客人A，下单给厨师
2. 不等待，去接待客人B，下单给厨师
3. 不等待，去接待客人C，下单给厨师
4. 厨师叫号：A的菜好了
5. 送菜给客人A
6. 厨师叫号：B的菜好了
7. 送菜给客人B
...循环往复
```

**事件循环就是这个服务员，不断轮询"哪个任务可以继续执行"**

---

## 事件循环的工作原理

### 核心组件

```python
事件循环包含：
1. 任务队列（Task Queue）：待执行的协程
2. 就绪队列（Ready Queue）：可以立即执行的协程
3. I/O 选择器（Selector）：监听 I/O 事件（网络、文件）
4. 回调队列（Callback Queue）：I/O 完成后的回调函数
```

### 执行流程

```
┌─────────────────────────────────────┐
│         事件循环（Event Loop）        │
│                                     │
│  1. 从就绪队列取出一个协程            │
│  2. 执行协程直到遇到 await            │
│  3. 协程暂停，注册 I/O 事件           │
│  4. 检查 I/O 选择器，哪些 I/O 完成了  │
│  5. 将完成的协程放入就绪队列          │
│  6. 回到步骤1，循环往复               │
└─────────────────────────────────────┘
```

### 可视化示例

```python
import asyncio

async def task_a():
    print("A: 开始")
    await asyncio.sleep(1)  # 暂停，让出控制权
    print("A: 完成")

async def task_b():
    print("B: 开始")
    await asyncio.sleep(0.5)  # 暂停，让出控制权
    print("B: 完成")

async def main():
    await asyncio.gather(task_a(), task_b())

asyncio.run(main())
```

**执行时间线：**
```
时间 0.0s: 事件循环启动
时间 0.0s: 执行 task_a，打印"A: 开始"
时间 0.0s: task_a 遇到 await sleep(1)，暂停，注册1秒后的回调
时间 0.0s: 执行 task_b，打印"B: 开始"
时间 0.0s: task_b 遇到 await sleep(0.5)，暂停，注册0.5秒后的回调
时间 0.5s: task_b 的 sleep 完成，恢复执行，打印"B: 完成"
时间 1.0s: task_a 的 sleep 完成，恢复执行，打印"A: 完成"
```

**输出：**
```
A: 开始
B: 开始
B: 完成
A: 完成
```

---

## 事件循环的生命周期

### 1. 创建事件循环

```python
import asyncio

# 方式1：自动创建并运行（推荐）
asyncio.run(main())

# 方式2：手动创建和管理（不推荐）
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main())
finally:
    loop.close()

# 方式3：获取当前运行的事件循环
loop = asyncio.get_running_loop()  # 只能在协程内调用
```

**推荐使用 `asyncio.run()`**：
- 自动创建新的事件循环
- 自动关闭事件循环
- 自动清理资源
- 代码更简洁

### 2. 运行事件循环

```python
import asyncio

async def main():
    print("事件循环运行中...")
    await asyncio.sleep(1)
    print("事件循环完成")

# 运行事件循环直到 main() 完成
asyncio.run(main())
```

**背后发生了什么：**
```python
# asyncio.run() 的简化实现
def run(main_coro):
    # 1. 创建新的事件循环
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    try:
        # 2. 运行主协程
        return loop.run_until_complete(main_coro)
    finally:
        # 3. 清理资源
        loop.run_until_complete(loop.shutdown_asyncgens())
        loop.close()
```

### 3. 关闭事件循环

```python
# asyncio.run() 会自动关闭，无需手动关闭

# 如果手动管理事件循环，需要显式关闭
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main())
finally:
    loop.close()  # 关闭事件循环
```

---

## 事件循环的调度策略

### 协作式调度

**关键特征：** 协程必须主动让出控制权（通过 `await`）

```python
import asyncio

async def bad_task():
    # ❌ 错误：死循环，不让出控制权
    while True:
        pass  # 事件循环被阻塞，其他任务无法执行

async def good_task():
    # ✅ 正确：定期让出控制权
    while True:
        await asyncio.sleep(0)  # 让出控制权
        # 做一些工作
```

**对比多线程的抢占式调度：**
```
多线程（抢占式）：
- 操作系统强制切换线程
- 程序员无法控制切换时机
- 需要锁来保护共享数据

asyncio（协作式）：
- 协程主动让出控制权（await）
- 程序员控制切换时机
- 单线程，无需锁
```

### 公平调度

事件循环使用 FIFO（先进先出）策略调度就绪的协程：

```python
import asyncio

async def task(name, delay):
    print(f"{name}: 开始")
    await asyncio.sleep(delay)
    print(f"{name}: 完成")

async def main():
    # 创建3个任务，按顺序加入队列
    await asyncio.gather(
        task("A", 0.1),
        task("B", 0.1),
        task("C", 0.1)
    )

asyncio.run(main())
```

**输出：**
```
A: 开始
B: 开始
C: 开始
A: 完成
B: 完成
C: 完成
```

**解释：**
- 所有任务按顺序开始（FIFO）
- 所有任务同时等待 0.1 秒
- 所有任务按顺序完成（FIFO）

---

## 事件循环的底层实现

### I/O 多路复用

事件循环使用操作系统的 I/O 多路复用机制：

```
Linux: epoll
macOS: kqueue
Windows: IOCP (I/O Completion Ports)
```

**工作原理：**
```python
# 简化的事件循环实现
class SimpleEventLoop:
    def __init__(self):
        self.ready_queue = []  # 就绪队列
        self.selector = selectors.DefaultSelector()  # I/O 选择器

    def run_until_complete(self, coro):
        # 将主协程加入就绪队列
        task = Task(coro)
        self.ready_queue.append(task)

        # 主循环
        while self.ready_queue or self.selector.get_map():
            # 1. 执行所有就绪的任务
            while self.ready_queue:
                task = self.ready_queue.pop(0)
                try:
                    # 执行任务直到遇到 await
                    task.step()
                except StopIteration:
                    # 任务完成
                    pass

            # 2. 等待 I/O 事件
            events = self.selector.select(timeout=0)
            for key, mask in events:
                # I/O 完成，将任务加入就绪队列
                task = key.data
                self.ready_queue.append(task)
```

### 性能优化

**1. 避免阻塞操作**

```python
import asyncio
import time

async def bad():
    # ❌ 错误：time.sleep() 是同步阻塞，会阻塞整个事件循环
    time.sleep(1)

async def good():
    # ✅ 正确：asyncio.sleep() 是异步，不阻塞事件循环
    await asyncio.sleep(1)
```

**2. 使用异步库**

```python
# ❌ 错误：同步 HTTP 库
import requests
async def bad():
    response = requests.get(url)  # 阻塞事件循环

# ✅ 正确：异步 HTTP 库
import httpx
async def good():
    async with httpx.AsyncClient() as client:
        response = await client.get(url)  # 不阻塞事件循环
```

**3. CPU 密集型任务使用线程池**

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

def cpu_intensive_task(n):
    # CPU 密集型计算
    return sum(range(n))

async def main():
    loop = asyncio.get_running_loop()

    # 在线程池中执行 CPU 密集型任务
    with ThreadPoolExecutor() as pool:
        result = await loop.run_in_executor(
            pool,
            cpu_intensive_task,
            10_000_000
        )
    print(result)

asyncio.run(main())
```

---

## 事件循环的调试

### 1. 启用调试模式

```python
import asyncio

# 方式1：通过参数启用
asyncio.run(main(), debug=True)

# 方式2：通过环境变量启用
# PYTHONASYNCIODEBUG=1 python script.py

# 方式3：手动启用
loop = asyncio.get_event_loop()
loop.set_debug(True)
```

**调试模式会检测：**
- 协程未被 await
- 任务执行时间过长（默认 > 100ms）
- 在错误的线程中调用协程

### 2. 检测慢协程

```python
import asyncio
import warnings

async def slow_task():
    # 模拟慢操作
    await asyncio.sleep(0.2)

async def main():
    # 启用调试模式
    loop = asyncio.get_running_loop()
    loop.set_debug(True)
    loop.slow_callback_duration = 0.1  # 设置阈值为 100ms

    await slow_task()  # 会触发警告

asyncio.run(main(), debug=True)
```

**输出警告：**
```
Executing <Task> took 0.200 seconds
```

### 3. 检测未 await 的协程

```python
import asyncio

async def fetch_data():
    return "data"

async def main():
    # ❌ 错误：忘记 await
    result = fetch_data()  # 返回协程对象，不执行

asyncio.run(main(), debug=True)
```

**输出警告：**
```
RuntimeWarning: coroutine 'fetch_data' was never awaited
```

---

## 在 AI Agent 开发中的应用

### 1. FastAPI 自动管理事件循环

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/user/{user_id}")
async def get_user(user_id: int):
    # FastAPI 自动管理事件循环
    # 每个请求在同一个事件循环中执行
    user = await db.fetch_user(user_id)
    return user

# FastAPI 启动时创建事件循环
# uvicorn app:app --reload
```

**背后发生了什么：**
```python
# FastAPI/Uvicorn 的简化实现
async def handle_request(request):
    # 在事件循环中执行路由函数
    response = await route_handler(request)
    return response

# 主事件循环
async def main():
    while True:
        request = await receive_request()
        asyncio.create_task(handle_request(request))

asyncio.run(main())
```

### 2. 并发处理多个用户请求

```python
from fastapi import FastAPI
import asyncio

app = FastAPI()

@app.get("/generate")
async def generate_response(prompt: str):
    # 调用 LLM API（I/O 操作）
    response = await openai_client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )
    return response

# 事件循环可以同时处理 1000+ 个请求
# 因为大部分时间都在等待 LLM API 响应
```

**性能对比：**
```
同步方案（阻塞）：
- 1个请求 = 1秒
- 1000个请求 = 1000秒
- 需要 1000 个线程

异步方案（事件循环）：
- 1个请求 = 1秒
- 1000个请求 = 1-2秒（并发执行）
- 只需 1 个线程
```

### 3. 后台任务

```python
from fastapi import FastAPI, BackgroundTasks
import asyncio

app = FastAPI()

async def send_email(email: str):
    # 模拟发送邮件
    await asyncio.sleep(2)
    print(f"Email sent to {email}")

@app.post("/user")
async def create_user(email: str, background_tasks: BackgroundTasks):
    # 保存用户
    await db.save_user(email)

    # 后台发送邮件（不阻塞响应）
    background_tasks.add_task(send_email, email)

    return {"status": "created"}

# 事件循环会在后台执行 send_email
# 不影响响应速度
```

---

## 常见问题

### Q1: 一个程序可以有多个事件循环吗？

**A:** 可以，但通常不推荐。

```python
import asyncio
import threading

def run_in_thread(coro):
    # 在新线程中创建新的事件循环
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(coro)
    loop.close()

async def task():
    print("Running in thread")

# 主线程的事件循环
asyncio.run(main())

# 新线程的事件循环
thread = threading.Thread(target=run_in_thread, args=(task(),))
thread.start()
thread.join()
```

**使用场景：**
- 需要在多个线程中运行异步代码
- 集成同步和异步代码

### Q2: 事件循环会自动创建吗？

**A:** 取决于使用方式。

```python
# ✅ asyncio.run() 会自动创建
asyncio.run(main())

# ❌ 直接调用协程不会创建事件循环
async def main():
    pass

main()  # 错误：没有事件循环
```

### Q3: 如何在同步代码中调用异步函数？

**A:** 使用 `asyncio.run()`。

```python
async def async_function():
    return "result"

# 在同步代码中调用
def sync_function():
    result = asyncio.run(async_function())
    return result
```

**注意：** 不能在已有事件循环的情况下调用 `asyncio.run()`。

---

## 学习检查

完成本节后，你应该能够：

- [ ] 解释事件循环的工作原理
- [ ] 理解协作式调度和抢占式调度的区别
- [ ] 使用 `asyncio.run()` 运行异步代码
- [ ] 理解事件循环的生命周期
- [ ] 避免阻塞事件循环的操作
- [ ] 使用调试模式检测问题
- [ ] 在 FastAPI 中理解事件循环的作用

---

## 下一步

- **继续学习**：阅读【核心概念2：协程与await】
- **实战练习**：完成【实战代码】中的事件循环示例
- **深入理解**：阅读【化骨绵掌】了解更多细节
