# 核心概念：依赖注入

> FastAPI 的依赖注入系统：用 Depends() 管理依赖关系，实现模块化和可测试的代码

---

## 什么是依赖注入？

**依赖注入 = 将函数需要的资源从外部传入，而不是在函数内部创建**

```
函数需要资源 → 声明依赖 → 框架自动注入 → 函数执行
```

**核心组成：**
1. **依赖函数** - 定义如何创建资源
2. **Depends()** - 声明依赖关系
3. **依赖注入器** - FastAPI 自动执行依赖函数并注入结果

---

## 1. 基础依赖注入

### 1.1 简单依赖

**定义和使用依赖：**

```python
from fastapi import FastAPI, Depends

app = FastAPI()

# 定义依赖函数
def get_query_param(q: str | None = None):
    return q

# 使用依赖
@app.get("/items")
async def list_items(query: str | None = Depends(get_query_param)):
    return {"query": query}

# GET /items?q=test → {"query": "test"}
```

**为什么要用依赖注入？**

```python
# ❌ 不使用依赖注入
@app.get("/items")
async def list_items(q: str | None = None):
    # 逻辑重复
    if q and len(q) < 3:
        raise HTTPException(status_code=400, detail="Query too short")
    return {"query": q}

@app.get("/users")
async def list_users(q: str | None = None):
    # 逻辑重复
    if q and len(q) < 3:
        raise HTTPException(status_code=400, detail="Query too short")
    return {"query": q}

# ✅ 使用依赖注入
def validate_query(q: str | None = None):
    if q and len(q) < 3:
        raise HTTPException(status_code=400, detail="Query too short")
    return q

@app.get("/items")
async def list_items(query: str | None = Depends(validate_query)):
    return {"query": query}

@app.get("/users")
async def list_users(query: str | None = Depends(validate_query)):
    return {"query": query}
```

---

### 1.2 依赖函数的类型

**普通函数：**

```python
def get_current_time():
    from datetime import datetime
    return datetime.now()

@app.get("/time")
async def get_time(current_time: datetime = Depends(get_current_time)):
    return {"time": current_time}
```

**异步函数：**

```python
async def get_user_from_db(user_id: int):
    # 异步数据库查询
    user = await db.users.find_one({"id": user_id})
    return user

@app.get("/users/{user_id}")
async def get_user(user: dict = Depends(get_user_from_db)):
    return user
```

**生成器函数（资源管理）：**

```python
def get_db():
    db = SessionLocal()
    try:
        yield db  # 注入到路由函数
    finally:
        db.close()  # 请求结束后自动关闭

@app.get("/users")
async def list_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users
```

**异步生成器：**

```python
async def get_async_db():
    db = await create_async_connection()
    try:
        yield db
    finally:
        await db.close()

@app.get("/users")
async def list_users(db = Depends(get_async_db)):
    users = await db.query(User).all()
    return users
```

---

## 2. 依赖链

### 2.1 依赖的依赖

**多层依赖：**

```python
from fastapi import Depends, HTTPException, Header

# 依赖1：数据库连接
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 依赖2：获取 token（依赖于查询参数）
def get_token(token: str = Header(...)):
    return token

# 依赖3：获取当前用户（依赖于 get_db 和 get_token）
def get_current_user(
    token: str = Depends(get_token),
    db: Session = Depends(get_db)
):
    user = db.query(User).filter_by(token=token).first()
    if not user:
        raise HTTPException(status_code=401, detail="Invalid token")
    return user

# 路由：使用依赖链
@app.get("/profile")
async def get_profile(user: User = Depends(get_current_user)):
    # FastAPI 自动执行：
    # 1. get_token() - 从 Header 获取 token
    # 2. get_db() - 创建数据库连接
    # 3. get_current_user(token, db) - 查询用户
    # 4. 注入 user 到路由函数
    return {"username": user.username}
```

**执行顺序：**

```
请求到达
  ↓
get_token() 执行 → 返回 token
  ↓
get_db() 执行 → 返回 db
  ↓
get_current_user(token, db) 执行 → 返回 user
  ↓
get_profile(user) 执行 → 返回响应
  ↓
get_db() 的 finally 执行 → 关闭 db
```

---

### 2.2 依赖缓存

**同一个请求中，依赖被缓存：**

```python
from datetime import datetime

def get_timestamp():
    timestamp = datetime.now()
    print(f"生成时间戳: {timestamp}")
    return timestamp

@app.get("/test")
async def test(
    ts1: datetime = Depends(get_timestamp),
    ts2: datetime = Depends(get_timestamp),
    ts3: datetime = Depends(get_timestamp)
):
    # get_timestamp() 只执行一次
    # ts1、ts2、ts3 是同一个对象
    return {
        "ts1": ts1,
        "ts2": ts2,
        "ts3": ts3,
        "all_same": ts1 == ts2 == ts3  # True
    }

# 控制台只会打印一次 "生成时间戳"
```

**依赖链中的缓存：**

```python
def get_db():
    print("创建数据库连接")
    db = SessionLocal()
    try:
        yield db
    finally:
        print("关闭数据库连接")
        db.close()

def get_user(db: Session = Depends(get_db)):
    print("查询用户")
    return db.query(User).first()

def get_user_posts(
    user: User = Depends(get_user),
    db: Session = Depends(get_db)  # 使用缓存的 db
):
    print("查询用户文章")
    return db.query(Post).filter_by(user_id=user.id).all()

@app.get("/user-posts")
async def get_user_posts_endpoint(
    posts: list = Depends(get_user_posts),
    user: User = Depends(get_user),  # 使用缓存的 user
    db: Session = Depends(get_db)    # 使用缓存的 db
):
    # 控制台输出：
    # 创建数据库连接
    # 查询用户
    # 查询用户文章
    # 关闭数据库连接
    return {"user": user.username, "posts": posts}
```

**禁用缓存：**

```python
from fastapi import Depends

def get_random_number():
    import random
    return random.randint(1, 100)

@app.get("/random")
async def get_random(
    num1: int = Depends(get_random_number, use_cache=False),
    num2: int = Depends(get_random_number, use_cache=False)
):
    # num1 和 num2 是不同的随机数
    return {"num1": num1, "num2": num2}
```

---

## 3. 类作为依赖

### 3.1 可调用类

**使用类定义依赖：**

```python
from fastapi import Depends, Query

class Pagination:
    def __init__(
        self,
        skip: int = Query(0, ge=0),
        limit: int = Query(10, ge=1, le=100)
    ):
        self.skip = skip
        self.limit = limit

@app.get("/items")
async def list_items(pagination: Pagination = Depends()):
    # Depends() 不传参数，FastAPI 自动使用 Pagination 类
    return {
        "skip": pagination.skip,
        "limit": pagination.limit
    }

# GET /items?skip=20&limit=50
# → {"skip": 20, "limit": 50}
```

**类的优势：**
- 封装相关参数
- 可以添加方法
- 更好的代码组织

---

### 3.2 带方法的依赖类

```python
from fastapi import Depends, Query, HTTPException

class SearchParams:
    def __init__(
        self,
        q: str = Query(..., min_length=3),
        category: str | None = Query(None),
        sort: str = Query("created_at", regex="^(created_at|price|name)$")
    ):
        self.q = q
        self.category = category
        self.sort = sort

    def to_filter(self):
        """转换为数据库过滤条件"""
        filters = {"name": {"$regex": self.q}}
        if self.category:
            filters["category"] = self.category
        return filters

    def to_sort(self):
        """转换为排序条件"""
        return [(self.sort, -1)]

@app.get("/search")
async def search(
    params: SearchParams = Depends(),
    db: Session = Depends(get_db)
):
    items = db.query(Item).filter_by(**params.to_filter()).order_by(*params.to_sort()).all()
    return {"items": items}
```

---

## 4. 子依赖

### 4.1 路径操作装饰器的依赖

**在装饰器中声明依赖：**

```python
from fastapi import Depends, HTTPException

def verify_token(token: str = Header(...)):
    if token != "valid-token":
        raise HTTPException(status_code=401, detail="Invalid token")

def verify_admin(token: str = Header(...)):
    if token != "admin-token":
        raise HTTPException(status_code=403, detail="Admin only")

# 单个依赖
@app.get("/protected", dependencies=[Depends(verify_token)])
async def protected_route():
    return {"message": "Protected"}

# 多个依赖
@app.get("/admin", dependencies=[Depends(verify_token), Depends(verify_admin)])
async def admin_route():
    return {"message": "Admin only"}
```

**依赖不返回值：**

```python
def log_request(request: Request):
    print(f"Request: {request.method} {request.url}")
    # 不返回值，只执行副作用

@app.get("/items", dependencies=[Depends(log_request)])
async def list_items():
    return {"items": []}
```

---

### 4.2 全局依赖

**应用级依赖：**

```python
from fastapi import FastAPI, Depends

def verify_api_key(api_key: str = Header(...)):
    if api_key != "secret-key":
        raise HTTPException(status_code=401, detail="Invalid API key")

# 所有路由都需要验证 API key
app = FastAPI(dependencies=[Depends(verify_api_key)])

@app.get("/items")
async def list_items():
    return {"items": []}

@app.get("/users")
async def list_users():
    return {"users": []}
```

**路由器级依赖：**

```python
from fastapi import APIRouter, Depends

def verify_admin(token: str = Header(...)):
    if token != "admin-token":
        raise HTTPException(status_code=403, detail="Admin only")

# 所有 admin 路由都需要验证
admin_router = APIRouter(
    prefix="/admin",
    dependencies=[Depends(verify_admin)]
)

@admin_router.get("/users")
async def list_users():
    return {"users": []}

@admin_router.delete("/users/{user_id}")
async def delete_user(user_id: int):
    return {"message": f"Deleted {user_id}"}

app = FastAPI()
app.include_router(admin_router)
```

---

## 5. 依赖覆盖（测试）

### 5.1 覆盖依赖

**在测试中替换依赖：**

```python
from fastapi import FastAPI, Depends
from fastapi.testclient import TestClient

app = FastAPI()

# 原始依赖
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users")
async def list_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return {"users": users}

# 测试
def test_list_users():
    # 测试依赖
    def get_test_db():
        return MockDatabase()

    # 覆盖依赖
    app.dependency_overrides[get_db] = get_test_db

    client = TestClient(app)
    response = client.get("/users")
    assert response.status_code == 200

    # 清理
    app.dependency_overrides = {}
```

---

## 6. 常见依赖模式

### 6.1 数据库连接

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session

DATABASE_URL = "postgresql://user:password@localhost/dbname"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users")
async def list_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users
```

---

### 6.2 认证授权

```python
from fastapi import Depends, HTTPException, Header
from jose import jwt, JWTError

SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"

def get_token(authorization: str = Header(...)):
    scheme, token = authorization.split()
    if scheme.lower() != "bearer":
        raise HTTPException(status_code=401, detail="Invalid authentication scheme")
    return token

def get_current_user(
    token: str = Depends(get_token),
    db: Session = Depends(get_db)
):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

    user = db.query(User).get(user_id)
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return user

def get_current_active_user(user: User = Depends(get_current_user)):
    if not user.is_active:
        raise HTTPException(status_code=403, detail="Inactive user")
    return user

@app.get("/profile")
async def get_profile(user: User = Depends(get_current_active_user)):
    return {"username": user.username}
```

---

### 6.3 分页

```python
from fastapi import Depends, Query

class Pagination:
    def __init__(
        self,
        page: int = Query(1, ge=1),
        page_size: int = Query(10, ge=1, le=100)
    ):
        self.page = page
        self.page_size = page_size
        self.skip = (page - 1) * page_size
        self.limit = page_size

@app.get("/items")
async def list_items(
    pagination: Pagination = Depends(),
    db: Session = Depends(get_db)
):
    items = db.query(Item).offset(pagination.skip).limit(pagination.limit).all()
    total = db.query(Item).count()
    return {
        "items": items,
        "page": pagination.page,
        "page_size": pagination.page_size,
        "total": total,
        "total_pages": (total + pagination.page_size - 1) // pagination.page_size
    }
```

---

### 6.4 LLM 客户端

```python
from openai import OpenAI
from fastapi import Depends

def get_llm_client():
    return OpenAI(api_key=settings.OPENAI_API_KEY)

@app.post("/chat")
async def chat(
    message: str,
    llm: OpenAI = Depends(get_llm_client)
):
    response = llm.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": message}]
    )
    return {"reply": response.choices[0].message.content}
```

---

## 7. 在 AI Agent 后端中的应用

### 7.1 完整的认证流程

```python
from fastapi import FastAPI, Depends, HTTPException, Header
from sqlalchemy.orm import Session
from jose import jwt, JWTError
from datetime import datetime, timedelta

app = FastAPI()

# 依赖1：数据库连接
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 依赖2：提取 token
def get_token(authorization: str = Header(...)):
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="Invalid scheme")
        return token
    except ValueError:
        raise HTTPException(status_code=401, detail="Invalid authorization header")

# 依赖3：验证 token 并获取用户
def get_current_user(
    token: str = Depends(get_token),
    db: Session = Depends(get_db)
):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

    user = db.query(User).get(user_id)
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return user

# 依赖4：检查用户是否激活
def get_active_user(user: User = Depends(get_current_user)):
    if not user.is_active:
        raise HTTPException(status_code=403, detail="Inactive user")
    return user

# 使用依赖链
@app.get("/profile")
async def get_profile(user: User = Depends(get_active_user)):
    return {"username": user.username, "email": user.email}

@app.post("/chat")
async def chat(
    message: str,
    user: User = Depends(get_active_user),
    db: Session = Depends(get_db),
    llm: OpenAI = Depends(get_llm_client)
):
    # 保存用户消息
    save_message(db, user.id, "user", message)

    # 调用 LLM
    response = llm.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": message}]
    )
    reply = response.choices[0].message.content

    # 保存 AI 回复
    save_message(db, user.id, "assistant", reply)

    return {"reply": reply}
```

---

### 7.2 对话上下文管理

```python
from fastapi import Depends

class ConversationContext:
    def __init__(
        self,
        conversation_id: str | None = None,
        user: User = Depends(get_current_user),
        db: Session = Depends(get_db)
    ):
        self.user = user
        self.db = db

        if conversation_id:
            self.conversation = db.query(Conversation).filter_by(
                id=conversation_id,
                user_id=user.id
            ).first()
            if not self.conversation:
                raise HTTPException(status_code=404, detail="Conversation not found")
        else:
            # 创建新对话
            self.conversation = Conversation(user_id=user.id)
            db.add(self.conversation)
            db.commit()

    def get_messages(self, limit: int = 10):
        return self.db.query(Message).filter_by(
            conversation_id=self.conversation.id
        ).order_by(Message.created_at.desc()).limit(limit).all()

    def add_message(self, role: str, content: str):
        message = Message(
            conversation_id=self.conversation.id,
            role=role,
            content=content
        )
        self.db.add(message)
        self.db.commit()
        return message

@app.post("/chat")
async def chat(
    message: str,
    conversation_id: str | None = None,
    context: ConversationContext = Depends(),
    llm: OpenAI = Depends(get_llm_client)
):
    # 获取历史消息
    history = context.get_messages()

    # 构建消息列表
    messages = [
        {"role": msg.role, "content": msg.content}
        for msg in reversed(history)
    ] + [{"role": "user", "content": message}]

    # 调用 LLM
    response = llm.chat.completions.create(model="gpt-4", messages=messages)
    reply = response.choices[0].message.content

    # 保存消息
    context.add_message("user", message)
    context.add_message("assistant", reply)

    return {
        "reply": reply,
        "conversation_id": context.conversation.id
    }
```

---

## 总结

### 依赖注入的核心要点

1. **Depends()** - 声明依赖关系
2. **依赖函数** - 定义如何创建资源
3. **依赖链** - 依赖可以依赖其他依赖
4. **依赖缓存** - 同一个请求中依赖被缓存
5. **生成器** - 自动资源管理（yield）
6. **类依赖** - 封装相关参数和方法

### 与 Express 中间件的对比

| 特性 | Express 中间件 | FastAPI 依赖注入 |
|------|---------------|-----------------|
| 声明方式 | `app.use(middleware)` | `Depends(dependency)` |
| 参数传递 | 修改 `req` 对象（隐式） | 函数参数（显式） |
| 类型安全 | ❌ 否 | ✅ 是 |
| 测试 | 需要模拟整个 `req` | 可以直接替换依赖 |
| 资源管理 | 手动 try/finally | 自动（yield） |
| 依赖链 | 嵌套中间件 | 依赖的依赖 |

---

**记住：** 依赖注入是 FastAPI 最强大的特性之一，掌握它可以写出清晰、可维护的代码！
